   protected:
		static DWORD				m_dwHelpMap[];

        CImageList                  m_imageList;
		SPIRouterInfo				m_spRouterInfo;
        SPIRtrMgrProtocolInfo		m_spRmProt;
        IRtrMgrProtocolInterfaceInfo **  m_ppRmProtIf;

		// This is used to store the list of interfaces
		// that we have pointers to in our list box.  I could
		// keep AddRef'd pointers in the item data, but this
		// seems safer.
		PInterfaceInfoList			m_pIfList;

        //{{AFX_MSG(CRpAddInterface)
        virtual BOOL                OnInitDialog();
        afx_msg VOID                OnDblclkListctrl(NMHDR* , LRESULT* );
        virtual VOID                OnOK();
        //}}AFX_MSG

        DECLARE_MESSAGE_MAP()
};



#endif	// _ADD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\add.cpp ===
//============================================================================
// Copyright (C) 1996, Microsoft Corp.
//
// File:    add.cpp
//
// History:
//  Abolade-Gbadegesin  Mar-15-1996 Created
//
// Contains implementation for dialogs listing components for addition
// to the router. All of the dialogs consists of a listview and two buttons,
// labelled "OK" and "Cancel".
//============================================================================

#include "stdafx.h"
#include "rtrres.h"        // RTRLIB resource header
#include "info.h"
#include "dialog.h"        // common code dialog class
#include "add.h"
#include "rtrui.h"        // common router UI utility functions
#include "rtrstr.h"        // common router strings
#include "mprapi.h"
#include "rtrcomn.h"    // common router utilities
#include "format.h"
#include "rtrutil.h"    // for smart pointers
#include "routprot.h"    // routing protocol IDs

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//----------------------------------------------------------------------------
// Class:       CRmAddInterface
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// Function:    CRmAddInterface::DoDataExchange
//----------------------------------------------------------------------------

CRmAddInterface::~CRmAddInterface()
{
     while (!m_pIfList.IsEmpty())
    {
        m_pIfList.RemoveTail()->Release();
    }
}

VOID
CRmAddInterface::DoDataExchange(
    CDataExchange*  pDX
    ) {

    CBaseDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRmAddInterface)
    DDX_Control(pDX, IDC_ADD_LIST, m_listCtrl);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRmAddInterface, CBaseDialog)
    //{{AFX_MSG_MAP(CRmAddInterface)
    ON_NOTIFY(NM_DBLCLK, IDC_ADD_LIST, OnDblclkListctrl)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()
            
DWORD CRmAddInterface::m_dwHelpMap[] =
{
//    IDC_ADD_PROMPT, HIDC_ADD_PROMPT,
//    IDC_ADD_LISTTITLE, HIDC_ADD_LISTTITLE,
//    IDC_ADD_LISTCTRL, HIDC_ADD_LISTCTRL,
    0,0
};




//----------------------------------------------------------------------------
// Function:    CRmAddInterface::OnInitDialog
//----------------------------------------------------------------------------

BOOL
CRmAddInterface::OnInitDialog(
    ) {

    CBaseDialog::OnInitDialog();
    
    //
    // Set the window title, the list-title, prompt-text, and icon.
    //

    HICON hIcon;
    CString sItem;
    CStringList    stIpxIfList;
    DWORD    dwIfType;
    InterfaceCB ifcb;

    sItem.FormatMessage(IDS_SELECT_INTERFACE_FOR, m_spRtrMgrInfo->GetTitle());
    SetWindowText(sItem);
    sItem.LoadString(IDS_ADD_INTERFACES);
    SetDlgItemText(IDC_ADD_TEXT_TITLE, sItem);
    sItem.LoadString(IDS_CLICK_RMINTERFACE);
    SetDlgItemText(IDC_ADD_TEXT_PROMPT, sItem);

    //
    // Set the list-view's imagelist
    //

    CreateRtrLibImageList(&m_imageList);

    m_listCtrl.SetImageList(&m_imageList, LVSIL_SMALL);

    ListView_SetExtendedListViewStyle(m_listCtrl.m_hWnd, LVS_EX_FULLROWSELECT);

    //
    // Insert the single column in the listview
    //

    RECT rc;

    m_listCtrl.GetClientRect(&rc);

    rc.right -= ::GetSystemMetrics(SM_CXVSCROLL);

    m_listCtrl.InsertColumn(0, c_szEmpty, LVCFMT_LEFT, rc.right);


    //
    // Get a list of the interfaces available
    //
    
    SPIEnumInterfaceInfo    spEnumIf;
    SPIInterfaceInfo        spIf;
    DWORD                   dwTransportId;
    
    m_spRouterInfo->EnumInterface(&spEnumIf);
    dwTransportId = m_spRtrMgrInfo->GetTransportId();

    // Make an initial pass to look for the IPX interfaces
    if (dwTransportId == PID_IPX)
    {
        CString    stBaseId;
        int        iPos;

        for (; spEnumIf->Next(1, &spIf, NULL) == hrOK; spIf.Release())
        {
            
            if ((iPos = IfInterfaceIdHasIpxExtensions((LPCTSTR) spIf->GetId())))
            {
                // We've found one, add the base Id (w/o) the extension
                // to the stIpxIfList
                stBaseId = spIf->GetId();

                // Cut off the IPX extension
                stBaseId.SetAt(iPos, 0);

                // If it's NOT in the list, add it
                if (!stIpxIfList.Find(stBaseId))
                    stIpxIfList.AddTail(stBaseId);
            }            
        }

        spEnumIf->Reset();
    }


    for (; spEnumIf->Next(1, &spIf, NULL) == hrOK ; spIf.Release())
    {
        //
        // Windows NT Bugs 103770
        //
        // We will need to filter out the interfaces depending on
        // the transport.  If IP, filter out the IPX frame types.
        if (dwTransportId != PID_IPX)
        {
            // If we found one of these IPX interfaces, skip it
            if (IfInterfaceIdHasIpxExtensions((LPCTSTR) spIf->GetId()))
                continue;
        }
        else
        {
            // If we are in IPX we should make sure that if these
            // interfaces exist in the list (already) than we need
            // to get rid of the general interface.

            if (stIpxIfList.Find(spIf->GetId()))
                continue;
        }

        dwIfType = spIf->GetInterfaceType();

        // If the interface is already added or is an internal
        // interface, continue
        if ((dwIfType == ROUTER_IF_TYPE_INTERNAL) ||
            (dwIfType == ROUTER_IF_TYPE_HOME_ROUTER))
            continue;

        // IPX should not show loopback or tunnel interfaces
        if ((dwTransportId == PID_IPX) &&
            ((dwIfType == ROUTER_IF_TYPE_LOOPBACK) ||
             (dwIfType == ROUTER_IF_TYPE_TUNNEL1) ))
            continue;

        if (spIf->FindRtrMgrInterface(dwTransportId, NULL) == hrOK)
            continue;


        // Windows NT Bug : 273424
        // check the bind state of the adapter.
        // ------------------------------------------------------------
        spIf->CopyCB(&ifcb);

        
        // If we are adding to IP and IP is not bound, continue.
        // ------------------------------------------------------------
        if ((dwTransportId == PID_IP) && !(ifcb.dwBindFlags & InterfaceCB_BindToIp))
            continue;

        
        // Similarly for IPX
        // ------------------------------------------------------------
        if ((dwTransportId == PID_IPX) && !(ifcb.dwBindFlags & InterfaceCB_BindToIpx))
            continue;
        
        //
        // Insert a list-item for the interface
        //

        // We need to ensure that the interface is live.
        m_pIfList.AddTail(spIf);
        spIf->AddRef();
        
        m_listCtrl.InsertItem(
                              LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE,
                              0,
                              spIf->GetTitle(),
                              0,
                              0,
                              spIf->GetInterfaceType() == (DWORD)ROUTER_IF_TYPE_DEDICATED ?
                              ILI_RTRLIB_NETCARD
                                : ILI_RTRLIB_MODEM,
                              (LPARAM) (IInterfaceInfo *) spIf
                             );        
    }

    //
    // If there are no items, explain this and end the dialog
    //

    if (!m_listCtrl.GetItemCount())
    {
        ::AfxMessageBox(IDS_ERR_NOINTERFACES, MB_OK|MB_ICONINFORMATION);
        OnCancel(); return FALSE;
    }


    //
    // Select the first item
    //

    m_listCtrl.SetItemState(0, LVIS_SELECTED, LVIS_SELECTED);
    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    CRmAddInterface::OnDblclkListctrl
//----------------------------------------------------------------------------

VOID
CRmAddInterface::OnDblclkListctrl(
    NMHDR*      pNMHDR,
    LRESULT*    pResult
    ) {

    OnOK();
    
    *pResult = 0;
}



//----------------------------------------------------------------------------
// Function:    CRmAddInterface::OnOK
//----------------------------------------------------------------------------

VOID
CRmAddInterface::OnOK(
    ) {

    //
    // Get the currently selected item
    //

    INT iSel = m_listCtrl.GetNextItem(-1, LVNI_SELECTED);

    if (iSel == -1) { return; }


    //
    // Get the item's data, which is a IInterfaceInfo pointer
    //
    IInterfaceInfo *pIf = (IInterfaceInfo *) m_listCtrl.GetItemData(iSel);


    //
    // Construct a new CRmInterfaceInfo object
    //
    CreateRtrMgrInterfaceInfo(m_ppRtrMgrInterfaceInfo,
                              m_spRtrMgrInfo->GetId(),
                              m_spRtrMgrInfo->GetTransportId(),
                              pIf->GetId(),
                              pIf->GetInterfaceType()
                             );

    if (!*m_ppRtrMgrInterfaceInfo) { OnCancel(); return; }


    (*m_ppRtrMgrInterfaceInfo)->SetTitle(pIf->GetTitle());
    (*m_ppRtrMgrInterfaceInfo)->SetMachineName(m_spRouterInfo->GetMachineName());

    CBaseDialog::OnOK();
}



//----------------------------------------------------------------------------
// Class:       CRpAddInterface
//
//----------------------------------------------------------------------------


CRpAddInterface::CRpAddInterface(IRouterInfo *pRouterInfo,
                                 IRtrMgrProtocolInfo *pRmProt,
                                 IRtrMgrProtocolInterfaceInfo **ppRmProtIf,
                                 CWnd *pParent)
    : CBaseDialog(CRpAddInterface::IDD, pParent)
{
    m_spRouterInfo.Set(pRouterInfo);
    m_spRmProt.Set(pRmProt);
    m_ppRmProtIf = ppRmProtIf;
}

CRpAddInterface::~CRpAddInterface()
{
     while (!m_pIfList.IsEmpty())
    {
        m_pIfList.RemoveTail()->Release();
    }
}


//----------------------------------------------------------------------------
// Function:    CRpAddInterface::DoDataExchange
//----------------------------------------------------------------------------

VOID
CRpAddInterface::DoDataExchange(
    CDataExchange*      pDX
    ) {

    CBaseDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRpAddInterface)
    DDX_Control(pDX, IDC_ADD_LIST, m_listCtrl);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRpAddInterface, CBaseDialog)
    //{{AFX_MSG_MAP(CRpAddInterface)
    ON_NOTIFY(NM_DBLCLK, IDC_ADD_LIST, OnDblclkListctrl)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

DWORD CRpAddInterface::m_dwHelpMap[] =
{
//    IDC_ADD_PROMPT, HIDC_ADD_PROMPT,
//    IDC_ADD_LISTTITLE, HIDC_ADD_LISTTITLE,
//    IDC_ADD_LISTCTRL, HIDC_ADD_LISTCTRL,
    0,0
};


//----------------------------------------------------------------------------
// Function:    CRpAddInterface::OnInitDialog
//----------------------------------------------------------------------------

BOOL
CRpAddInterface::OnInitDialog(
    ) {
    SPIEnumInterfaceInfo    spEnumIf;
    SPIInterfaceInfo        spIf;
    HRESULT                    hr = hrOK;
    DWORD                    dwIfType;
    DWORD                    dwProtocolId;
    UINT                    idi;

    CBaseDialog::OnInitDialog();

    //
    // Set the window title, the list-title, prompt-text, and icon.
    //

    HICON hIcon;
    CString sItem;

    // increase the deafault buffer size (128) first to accomodate
    // longer strings
    sItem.GetBuffer(512);
    sItem.ReleaseBuffer();
    
    // display the protocol name in the window title
    sItem.FormatMessage(IDS_SELECT_INTERFACE_FOR, m_spRmProt->GetTitle());
    SetWindowText(sItem);
    sItem.LoadString(IDS_ADD_INTERFACES);
    SetDlgItemText(IDC_ADD_TEXT_TITLE, sItem);
    sItem.LoadString(IDS_CLICK_RPINTERFACE);
    SetDlgItemText(IDC_ADD_TEXT_PROMPT, sItem);

    //
    // Set the imagelist for the listview
    //

    CreateRtrLibImageList(&m_imageList);

    m_listCtrl.SetImageList(&m_imageList, LVSIL_SMALL);

    ListView_SetExtendedListViewStyle(m_listCtrl.m_hWnd, LVS_EX_FULLROWSELECT);

    //
    // Insert the single column in the listview
    //

    RECT rc;

    m_listCtrl.GetClientRect(&rc);

    rc.right -= ::GetSystemMetrics(SM_CXVSCROLL);

    m_listCtrl.InsertColumn(0, c_szEmpty, LVCFMT_LEFT, rc.right);


    //
    // Get a list of the interfaces available on our router-manager
    //
    m_spRouterInfo->EnumInterface(&spEnumIf);

    for ( ; spEnumIf->Next(1, &spIf, NULL) == hrOK; spIf.Release())
    {
        dwIfType = spIf->GetInterfaceType();
        
        //
        // Only allow if this is not a loopback interface
        //
        if ((dwIfType == ROUTER_IF_TYPE_LOOPBACK) ||
            (dwIfType == ROUTER_IF_TYPE_HOME_ROUTER))
            continue;

        // Get the protocol id
        dwProtocolId = m_spRmProt->GetProtocolId();

        //
        // The only protocols that we can add the internal interface
        // to are BOOTP and IGMP.
        //
        if (dwIfType == ROUTER_IF_TYPE_INTERNAL)
        {
            if ((dwProtocolId != MS_IP_BOOTP) &&
                (dwProtocolId != MS_IP_IGMP)  &&
                (dwProtocolId != MS_IP_NAT))
                continue;
        }
        
        //
        // Only list adapters which have IP
        //
        if (spIf->FindRtrMgrInterface(PID_IP, NULL) != hrOK)
            continue;

        // Windows NT Bug : 234696
        // Tunnels can only be added to IGMP
        if (dwIfType == ROUTER_IF_TYPE_TUNNEL1)
        {
            if (dwProtocolId != MS_IP_IGMP)
                continue;
        }
        
        //
        // Fill the list with the adapters which haven't been added already
        //
        CORg( LookupRtrMgrProtocolInterface(spIf,
                                            m_spRmProt->GetTransportId(),
                                            m_spRmProt->GetProtocolId(),
                                            NULL));
        // This interface has this protocol, so try the next interface
        if (FHrOk(hr))
            continue;

        Assert(hr == hrFalse);
                              
        //
        // Insert a list-item for the protocol
        //

        m_pIfList.AddTail(spIf);
        spIf->AddRef();

        if (!IsWanInterface(dwIfType))
            idi = ILI_RTRLIB_NETCARD;
        else
            idi = ILI_RTRLIB_MODEM;
        
        m_listCtrl.InsertItem(
            LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE, 0, spIf->GetTitle(), 0, 0,
            idi, (LPARAM)(IInterfaceInfo *) spIf);
    }


    //
    // If there are no items, explain this and end the dialog
    //

    if (!m_listCtrl.GetItemCount()) {

        ::AfxMessageBox(IDS_ERR_NOINTERFACES, MB_OK|MB_ICONINFORMATION);
        OnCancel(); return FALSE;
    }


    //
    // Select the first item
    //

    m_listCtrl.SetItemState(0, LVIS_SELECTED, LVIS_SELECTED);

Error:
    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    CRpAddInterface::OnDblclkListctrl
//----------------------------------------------------------------------------

VOID
CRpAddInterface::OnDblclkListctrl(
    NMHDR*      pNMHDR,
    LRESULT*    pResult
    ) {

    OnOK();
    
    *pResult = 0;
}



//----------------------------------------------------------------------------
// Function:    CRpAddInterface::OnOK
//----------------------------------------------------------------------------

VOID
CRpAddInterface::OnOK(
    ) {

    //
    // Get the currently selected item
    //

    INT iSel = m_listCtrl.GetNextItem(-1, LVNI_SELECTED);

    if (iSel == -1) { return; }


    //
    // Get the item's data, which is a CInterfaceInfo pointer
    //
    IInterfaceInfo *pIf = (IInterfaceInfo *)m_listCtrl.GetItemData(iSel);


    //
    // Construct a new CRmProtInterfaceInfo object
    //
    RtrMgrProtocolInterfaceCB    RmProtIfCB;
    RtrMgrProtocolCB            RmProtCB;

    m_spRmProt->CopyCB(&RmProtCB);
    
    RmProtIfCB.dwProtocolId = RmProtCB.dwProtocolId;
    StrnCpyW(RmProtIfCB.szId, RmProtCB.szId, RTR_ID_MAX);
    RmProtIfCB.dwTransportId = RmProtCB.dwTransportId;
    StrnCpyW(RmProtIfCB.szRtrMgrId, RmProtCB.szRtrMgrId, RTR_ID_MAX);

    
    StrnCpyW(RmProtIfCB.szInterfaceId, pIf->GetId(), RTR_ID_MAX);
    RmProtIfCB.dwIfType = pIf->GetInterfaceType();
    RmProtIfCB.szTitle[0] = 0;
    CreateRtrMgrProtocolInterfaceInfo(m_ppRmProtIf,
                                      &RmProtIfCB);
                                      
    if (!*m_ppRmProtIf) { OnCancel(); return; }

    (*m_ppRmProtIf)->SetTitle(pIf->GetTitle());

    CBaseDialog::OnOK();
}


//----------------------------------------------------------------------------
// Class:       CAddRoutingProtocol
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// Function:    CAddRoutingProtocol::~CAddRoutingProtocol
//----------------------------------------------------------------------------

CAddRoutingProtocol::~CAddRoutingProtocol(
    )
{
}



//----------------------------------------------------------------------------
// Function:    CAddRoutingProtocol::DoDataExchange
//----------------------------------------------------------------------------

VOID
CAddRoutingProtocol::DoDataExchange(
    CDataExchange*  pDX
    ) {

    CBaseDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CAddRoutingProtocol)
    DDX_Control(pDX, IDC_ADD_LIST, m_listCtrl);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddRoutingProtocol, CBaseDialog)
    //{{AFX_MSG_MAP(CAddRoutingProtocol)
    ON_NOTIFY(NM_DBLCLK, IDC_ADD_LIST, OnDblclkListctrl)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// This should be merged with all of the other IDD_ADD dialogs but we
// could actually add different help topics here, so I'll leave them
// separated.
DWORD CAddRoutingProtocol::m_dwHelpMap[] =
{
//    IDC_ADD_PROMPT, HIDC_ADD_PROMPT,
//    IDC_ADD_LISTTITLE, HIDC_ADD_LISTTITLE,
//    IDC_ADD_LISTCTRL, HIDC_ADD_LISTCTRL,
    0,0
};



//----------------------------------------------------------------------------
// Function:    CAddRoutingProtocol::OnInitDialog
//----------------------------------------------------------------------------

BOOL
CAddRoutingProtocol::OnInitDialog(
    ) {

    CBaseDialog::OnInitDialog();
    
    //
    // Set the window title, the list-title, prompt-text, and icon.
    //

    HICON hIcon;
    CString sItem;
    SPIEnumRtrMgrProtocolCB    spEnumRmProtCB;
    RtrMgrProtocolCB        rmprotCB;

    sItem.LoadString(IDS_SELECT_PROTOCOL);
    SetWindowText(sItem);
    sItem.LoadString(IDS_ADD_PROTOCOL);
    SetDlgItemText(IDC_ADD_TEXT_TITLE, sItem);
    sItem.LoadString(IDS_CLICK_PROTOCOL);
    SetDlgItemText(IDC_ADD_TEXT_PROMPT, sItem);


    //
    // Set the list-view's imagelist
    //
    
    CreateRtrLibImageList(&m_imageList);

    m_listCtrl.SetImageList(&m_imageList, LVSIL_SMALL);

    ListView_SetExtendedListViewStyle(m_listCtrl.m_hWnd, LVS_EX_FULLROWSELECT);

    //
    // Insert the single column in the listview
    //

    RECT rc;

    m_listCtrl.GetClientRect(&rc);

    rc.right -= ::GetSystemMetrics(SM_CXVSCROLL);

    m_listCtrl.InsertColumn(0, c_szEmpty, LVCFMT_LEFT, rc.right);


    //
    // Get a list of the routing-protocols available for this router-manager
    //
    m_spRouter->EnumRtrMgrProtocolCB(&spEnumRmProtCB);

    while (spEnumRmProtCB->Next(1, &rmprotCB, NULL) == hrOK)
    {
        //
        // Fill the list with the protocols that aren't already added
        //

        // If this is the wrong mgr, skip it
        if (m_spRm->GetTransportId() != rmprotCB.dwTransportId)
            continue;

        // If the protocol is hidden, don't show it
        if (rmprotCB.dwFlags & RtrMgrProtocolCBFlagHidden)
            continue;

        //        
        // If the protocol is already added, continue
        //
        if (m_spRm->FindRtrMgrProtocol(rmprotCB.dwProtocolId, NULL) == hrOK)
            continue;

        //
        // Insert a list-item for the protocol
        //
        if ( rmprotCB.dwProtocolId == MS_IP_NAT )
        {
            CString sNewTitle;
            sNewTitle.LoadString(IDS_PROTO_NAT_BASIC_FIREWALL);
            m_listCtrl.InsertItem(
                LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE, 0, (LPCTSTR)sNewTitle,
                0, 0, ILI_RTRLIB_PROTOCOL, (LPARAM) rmprotCB.dwProtocolId
                );

        }
        else
        {
            m_listCtrl.InsertItem(
                LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE, 0, (LPCTSTR)rmprotCB.szTitle,
                0, 0, ILI_RTRLIB_PROTOCOL, (LPARAM) rmprotCB.dwProtocolId
                );
        }
    }


    //
    // If there are no items, explain this and end the dialog
    //

    if (!m_listCtrl.GetItemCount()) {

        ::AfxMessageBox(IDS_ERR_NOROUTINGPROTOCOLS, MB_OK|MB_ICONINFORMATION);
        OnCancel(); return FALSE;
    }


    //
    // Select the first item
    //

    m_listCtrl.SetItemState(0, LVIS_SELECTED, LVIS_SELECTED);

    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    CAddRoutingProtocol::OnDblclkListctrl
//----------------------------------------------------------------------------

VOID
CAddRoutingProtocol::OnDblclkListctrl(
    NMHDR*      pNMHDR,
    LRESULT*    pResult
    ) {

    OnOK();
    
    *pResult = 0;
}



//----------------------------------------------------------------------------
// Function:    CAddRoutingProtocol::OnOK
//----------------------------------------------------------------------------

VOID
CAddRoutingProtocol::OnOK(
    ) {
    SPIEnumRtrMgrProtocolCB    spEnumRmProtCB;
    RtrMgrProtocolCB        rmprotCB;
    RtrMgrProtocolCB        oldrmprotCB;
    SPIEnumRtrMgrProtocolInfo    spEnumRmProt;
    SPIRtrMgrProtocolInfo    spRmProt;
    DWORD_PTR                    dwData;
    HRESULT                    hr = hrOK;
    CString                    stFormat;
    SPIRtrMgrProtocolInfo    spRmProtReturn;

    //
    // Get the currently selected item
    // ----------------------------------------------------------------

    INT iSel = m_listCtrl.GetNextItem(-1, LVNI_SELECTED);

    if (iSel == -1) { return; }

    
    // Retrieve its data, which is the protocol ID
    // ----------------------------------------------------------------

    
    // Look up the protocol ID in the protocol list
    // ----------------------------------------------------------------
    m_spRouter->EnumRtrMgrProtocolCB(&spEnumRmProtCB);

    dwData = (DWORD)(m_listCtrl.GetItemData(iSel));


    // Construct a routing-protocol item
    // ----------------------------------------------------------------
    while (spEnumRmProtCB->Next(1, &rmprotCB, NULL) == hrOK)
    {
        if (rmprotCB.dwProtocolId == dwData)
        {
            hr = CreateRtrMgrProtocolInfo(&spRmProtReturn,
                                          &rmprotCB);
            if (!FHrSucceeded(hr))
            {
                OnCancel();
                return;
            }
            break;
        }
    }

    // What happens if we can't find the matching item
    // ----------------------------------------------------------------
    if (spRmProtReturn == NULL)
    {
        //$ Todo: what error message do we want to put up here?
        // ------------------------------------------------------------
        return;
    }

    // Now check to see if there are any protocol conflicts
    // ----------------------------------------------------------------
    stFormat.LoadString(IDS_WARN_ADD_PROTOCOL_CONFLICT);

    m_spRm->EnumRtrMgrProtocol(&spEnumRmProt);
    for (;spEnumRmProt->Next(1, &spRmProt, NULL) == hrOK; spRmProt.Release())
    {
        if (PROTO_FROM_PROTOCOL_ID(spRmProt->GetProtocolId()) ==
            PROTO_FROM_PROTOCOL_ID(dwData))
        {
            SPIRouterProtocolConfig    spRouterConfig;

            TCHAR    szWarning[2048];
            DWORD_PTR    rgArgs[4];
            
            // There is a conflict, ask the user if they
            // wish to remove this protocol, if yes then
            // we have to remove the protocol from our internal
            // router info and from the actual router.
            // --------------------------------------------------------
            spRmProt->CopyCB(&oldrmprotCB);

            rgArgs[0] = (DWORD_PTR) oldrmprotCB.szTitle;
            rgArgs[1] = (DWORD_PTR) oldrmprotCB.szVendorName;
            rgArgs[2] = (DWORD_PTR) rmprotCB.szTitle;
            rgArgs[3] = (DWORD_PTR) rmprotCB.szVendorName;

            // This may be the same protocol, but installed again
            // due to some timing problems.
            // --------------------------------------------------------
            if ((dwData == spRmProt->GetProtocolId()) &&
                (StriCmp((LPCTSTR) oldrmprotCB.szVendorName,
                         (LPCTSTR) rmprotCB.szVendorName) == 0) &&
                (StriCmp((LPCTSTR) oldrmprotCB.szTitle,
                         (LPCTSTR) rmprotCB.szTitle) == 0))
            {
                CString stMultipleProtocol;
                
                // Ok, this may be the same protocol, warn
                // the user about this potentially confusing
                // situation.
                // ----------------------------------------------------

                stMultipleProtocol.LoadString(IDS_WARN_PROTOCOL_ALREADY_INSTALLED);
                ::FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                                FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                (LPCTSTR) stMultipleProtocol,
                                0,
                                0,
                                szWarning,
                                DimensionOf(szWarning),
                                (va_list *) rgArgs);
                
                if (AfxMessageBox(szWarning, MB_YESNO) == IDNO)
                    return;
                
            }
            else
            {
                ::FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                                FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                (LPCTSTR) stFormat,
                                0,
                                0,
                                szWarning,
                                DimensionOf(szWarning),
                                (va_list *) rgArgs);
                
                if (AfxMessageBox(szWarning, MB_YESNO) == IDNO)
                    return;
            }

            // Remove the protocol from the RtrMgr
            // --------------------------------------------------------
            hr = m_spRm->DeleteRtrMgrProtocol(spRmProt->GetProtocolId(), TRUE);
            if (!FHrSucceeded(hr))
            {
                DisplayIdErrorMessage2(GetSafeHwnd(),
                                       IDS_ERR_UNABLE_TO_REMOVE_PROTOCOL, hr);
                return;
            }

            // Instantiate the configuration object
            // and tell it to remove the protocol
            // --------------------------------------------------------
            hr = CoCreateProtocolConfig(oldrmprotCB.guidConfig,
                                        m_spRouter,
                                        spRmProt->GetTransportId(),
                                        spRmProt->GetProtocolId(),
                                        &spRouterConfig);                                                                      

            if (!FHrSucceeded(hr))
            {
                //$ Todo: what error do we want to put up here?
                // What can the user do at this point?
                // ----------------------------------------------------
                DisplayErrorMessage(GetSafeHwnd(), hr);
                continue;
            }

            // Note that we can return success for CoCreateProtocolConfig
            // and have a NULL spRouterConfig.
            // --------------------------------------------------------
            if (spRouterConfig)
                hr = spRouterConfig->RemoveProtocol(m_spRm->GetMachineName(),
                    spRmProt->GetTransportId(),
                    spRmProt->GetProtocolId(),
                    GetSafeHwnd(),
                    0,
                    m_spRouter,
                    0);
            
            //$ Todo: if the Uninstall failed, we should warn the
            // user that something failed, what would the text of
            // the error message be?
            // --------------------------------------------------------
            if (!FHrSucceeded(hr))
                DisplayErrorMessage(GetSafeHwnd(), hr);
        }
    }

    (*m_ppRmProt) = spRmProtReturn.Transfer();
    CBaseDialog::OnOK();
}


/*!--------------------------------------------------------------------------
    AddRoutingProtocol
        This will take RtrMgr (that is being added to) and a
        RtrMgrProtocol (the protocol that is being added) and will add it.
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT AddRoutingProtocol(IRtrMgrInfo *pRm, IRtrMgrProtocolInfo *pRmProt, HWND hWnd)
{
    RtrMgrProtocolCB    rmprotCB;
    HRESULT                hr = hrOK;
    SPIRouterProtocolConfig    spRouterConfig;
    SPIRouterInfo        spRouter;

    // Create the configuration object
    // ----------------------------------------------------------------
    CORg( pRmProt->CopyCB(&rmprotCB) );

    // We can ignore any error code.
    // ----------------------------------------------------------------
    pRm->GetParentRouterInfo(&spRouter);


    // Create the actual configuration object.
    // ----------------------------------------------------------------
    hr = CoCreateProtocolConfig(rmprotCB.guidConfig,
                                spRouter,
                                pRmProt->GetTransportId(),
                                pRmProt->GetProtocolId(),
                                &spRouterConfig);
    CORg( hr );

    // Go ahead and add the protocol.
    // ----------------------------------------------------------------
    if (spRouterConfig)
        hr = spRouterConfig->AddProtocol(pRm->GetMachineName(),
                                         pRmProt->GetTransportId(),
                                         pRmProt->GetProtocolId(),
                                         hWnd,
                                         0,
                                         spRouter,
                                         0);
    CORg( hr );

Error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\basecon.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:    basecon.h
//
// History:
//	07/22/97	Kenn M. Takara			Created.
//
//	Basic interface container functionality.  One of the functions of
//	this basic container class is to provide column support.
//
//============================================================================


#ifndef _BASECON_H
#define _BASECON_H

#ifndef _BASEHAND_H
#include "basehand.h"
#endif

#ifndef _HANDLERS_H
#include "handlers.h"
#endif

#ifndef _XSTREAM_H
#include "xstream.h"		// need for ColumnData
#endif

#ifndef _RTRLIB_H
#include "rtrlib.h"			// ContainerColumnInfo
#endif

#ifndef _BASERTR_H
#include "basertr.h"		// BaseRouterHandler
#endif

#include "resource.h"

// forward declarations
struct ContainerColumnInfo;


/*---------------------------------------------------------------------------
	Class:	BaseContainerHandler

	The purpose for this class is to provide support common to all
	containers in the router snapins.

	- One feature is the ability to provide column remapping.  This
	also supports the saving/loading of column data.
 ---------------------------------------------------------------------------*/

// Valid UserResultNotify params
// This is called when it is time to save.
#define RRAS_ON_SAVE		500

HRESULT HrDisplayHelp(ITFSComponent *, LPCTSTR, UINT);
HRESULT HrDisplayHelp(ITFSComponent *, LPCTSTR, LPCTSTR);

class BaseContainerHandler :
		public BaseRouterHandler
{
public:
	BaseContainerHandler(ITFSComponentData *pCompData, ULONG ulColumnId,
						const ContainerColumnInfo *prgColumnInfo)
			: BaseRouterHandler(pCompData),
			m_ulColumnId(ulColumnId),
			m_prgColumnInfo(prgColumnInfo),
			m_nHelpTopicId(IDS_DEFAULT_HELP_TOPIC),
			m_nTaskPadDisplayNameId(IDS_DEFAULT_TASKPAD_DISPLAY_TITLE)
			{};

	// Override the column click so that we can get notifications
	// about changes to the sort order
	OVERRIDE_BaseResultHandlerNotify_OnResultColumnClick();
	OVERRIDE_BaseResultHandlerNotify_OnResultContextHelp();

	OVERRIDE_ResultHandler_UserResultNotify();
	OVERRIDE_ResultHandler_TaskPadNotify();
	OVERRIDE_ResultHandler_TaskPadGetTitle();
	//OVERRIDE_ResultHandler_EnumTasks();

	// Override LoadColumns/SaveColumns so that we can persist our data
	HRESULT LoadColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);
	HRESULT SaveColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

	HRESULT SortColumns(ITFSComponent *);


protected:
	HRESULT PrivateLoadColumns(ITFSComponent * pComponent,
							   IHeaderCtrl   * pHeaderCtrl,
							   MMC_COOKIE	   cookie);

	ULONG						m_ulColumnId;
	const ContainerColumnInfo *	m_prgColumnInfo;
	UINT						m_nHelpTopicId;
	UINT						m_nTaskPadDisplayNameId;
};



#endif _BASECON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\basertr.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:    basertr.h
//
// History:
//	07/22/97	Kenn M. Takara			Created.
//
//	Basic interface node functionality.  This is the base router
//	handler.  
//
//============================================================================


#ifndef _BASERTR_H
#define _BASERTR_H

#ifndef _BASEHAND_H
#include "basehand.h"
#endif

#ifndef _HANDLERS_H
#include "handlers.h"
#endif

#ifndef _DYNEXT_H
#include "dynext.h"
#endif

/*---------------------------------------------------------------------------
	Class:	BaseRouterHandler

	This is the base class for the router handlers.  Functionality common
	to all router handlers (both result and scope handlers) should be
	implemented here.

	- This class will handle the basic verb enabling/disabling.  Derived
	classes should set the appropriate values.
 ---------------------------------------------------------------------------*/

enum
{
	MMC_VERB_OPEN_INDEX = 0,
	MMC_VERB_COPY_INDEX,
	MMC_VERB_PASTE_INDEX,
	MMC_VERB_DELETE_INDEX,
	MMC_VERB_PROPERTIES_INDEX,
	MMC_VERB_RENAME_INDEX,
	MMC_VERB_REFRESH_INDEX,
	MMC_VERB_PRINT_INDEX,
	MMC_VERB_COUNT,
};

#define INDEX_TO_VERB(i)	(_MMC_CONSOLE_VERB)((0x8000 + (i)))
#define VERB_TO_INDEX(i)	(0x000F & (i))



struct SRouterNodeMenu
{
	ULONG	m_sidMenu;			// string/command id for this menu item
	ULONG	(*m_pfnGetMenuFlags)(const SRouterNodeMenu *pMenuData,
                                 INT_PTR pUserData);
	ULONG	m_ulPosition;
	LPCTSTR	m_pszLangIndStr;	// language independent string
};



class BaseRouterHandler :
   public CHandler
{
public:
	BaseRouterHandler(ITFSComponentData *pCompData);

	// Node Id 2 support
    OVERRIDE_BaseHandlerNotify_OnCreateNodeId2();

	// Help support
	OVERRIDE_BaseResultHandlerNotify_OnResultContextHelp();

	// To provide the verb functionality, override the select
	OVERRIDE_BaseResultHandlerNotify_OnResultSelect();

	// Property page support
	OVERRIDE_BaseHandlerNotify_OnPropertyChange();
	OVERRIDE_BaseResultHandlerNotify_OnResultPropertyChange();

	// Refresh support
	OVERRIDE_BaseHandlerNotify_OnVerbRefresh();
	OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();


	// Helpful utility function - this will forward the
	// message to the parent node.
	HRESULT ForwardCommandToParent(ITFSNode *pNode,
								   long nCommandId,
								   DATA_OBJECT_TYPES type,
								   LPDATAOBJECT pDataObject,
								   DWORD dwType);
	
    HRESULT EnumDynamicExtensions(ITFSNode * pNode);
    HRESULT AddDynamicNamespaceExtensions(ITFSNode * pNode);

protected:
	// Adds an array of menu items
	HRESULT AddArrayOfMenuItems(ITFSNode *pNode,
                                const SRouterNodeMenu *prgMenu,
                                UINT crgMenu,
                                LPCONTEXTMENUCALLBACK pCallback,
                                long iInsertionAllowed,
                                INT_PTR pUserData);
	

    
	void	EnableVerbs(IConsoleVerb *pConsoleVerb);
	
	// This holds the actual state of a button (HIDDEN/ENABLED)
	MMC_BUTTON_STATE	m_rgButtonState[MMC_VERB_COUNT];

	
	// Given that a button is enabled, what is its value (TRUE/FALSE)
	BOOL				m_bState[MMC_VERB_COUNT];

	// This is the default verb, by default it is set to MMC_VERB_NONE
	MMC_CONSOLE_VERB	m_verbDefault;

	SPIRouterInfo		m_spRouterInfo;
    
    CDynamicExtensions  m_dynExtensions;

	UINT				m_nHelpTopicId;
};

#endif _BASERTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\dumbprop.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	dumbprop.h
		Dummy property sheet to put up to avoid MMC's handlig of 
		the property verb.

    FILE HISTORY:
        
*/

#ifndef _DUMBPROP_H
#define _DUMBPROP_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CDummyPropGeneral dialog

class CDummyPropGeneral : public CPropertyPageBase
{
//	DECLARE_DYNCREATE(CDummyPropGeneral)

// Construction
public:
	CDummyPropGeneral();
	~CDummyPropGeneral();

// Dialog Data
	//{{AFX_DATA(CDummyPropGeneral)
	enum { IDD = IDD_DUMMY_PROP_PAGE };
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDummyPropGeneral)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CDummyPropGeneral)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

class CDummyProperties : public CPropertyPageHolderBase
{
public:
	CDummyProperties(ITFSNode *		  pNode,
					 IComponentData *	  pComponentData,
					 LPCTSTR			  pszSheetName);
	virtual ~CDummyProperties();

public:
	CDummyPropGeneral		m_pageGeneral;
};

#endif _DUMBPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\basecon.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	summary.cpp
		IP summary node implementation.
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "util.h"
#include "basecon.h"
#include "tfschar.h"
#include "strmap.h"		// XXXtoCString functions
#include "service.h"	// TFS service APIs
#include "rtrstr.h"	// const strings used
#include "coldlg.h"		// columndlg
#include "column.h"		// column stuff




/*---------------------------------------------------------------------------
	BaseContainerHandler implementation
 ---------------------------------------------------------------------------*/

HRESULT BaseContainerHandler::OnResultColumnClick(ITFSComponent *pComponent,
	 LPARAM iColumn, BOOL fAsc)
{
	HRESULT	hr = hrOK;
	ConfigStream *	pConfig;

	//
	// Get the configuration data
	//
	pComponent->GetUserData((LONG_PTR *) &pConfig);
	Assert(pConfig);

	pConfig->SetSortColumn(m_ulColumnId, (long)iColumn);
	pConfig->SetSortDirection(m_ulColumnId, fAsc);

	return hr;
}

/*!--------------------------------------------------------------------------
	BaseContainerHandler::SortColumns
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT BaseContainerHandler::SortColumns(ITFSComponent *pComponent)
{
	HRESULT			hr = hrOK;
	SPIResultData	spResultData;
	ULONG			ulSortColumn, ulSortDirection;
	ConfigStream *	pConfig;
	
	//
	// Get the configuration data
	//
	pComponent->GetUserData((LONG_PTR *) &pConfig);
	Assert(pConfig);

	// Setup the sort order and direction
	ulSortColumn = pConfig->GetSortColumn(m_ulColumnId);
	ulSortDirection = pConfig->GetSortDirection(m_ulColumnId);

	CORg( pComponent->GetResultData(&spResultData) );
	CORg( spResultData->Sort(ulSortColumn, ulSortDirection, 0) );

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	BaseContainerHandler::LoadColumns
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT BaseContainerHandler::LoadColumns(ITFSComponent *pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SPIHeaderCtrl spHeaderCtrl;
	pComponent->GetHeaderCtrl(&spHeaderCtrl);

	return PrivateLoadColumns(pComponent, spHeaderCtrl, cookie);
}


/*!--------------------------------------------------------------------------
	BaseContainerHandler::SaveColumns
		Override of CBaseResultHandler::SaveColumns.
		This just writes back out the width information.  Changes made
		to the column order or what is visible is written directly back
		to the ConfigStream by the "Select Columns" dialog.

        Even though MMC saves this data for us, we still need to save
        the data ourselves.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT BaseContainerHandler::SaveColumns(ITFSComponent *pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	// Get information from the column map in the nodedata
	// and save it back out
	ColumnData *prgColData;
	HRESULT		hr = hrOK;
	UINT		i;
	ULONG		ulPos;
	SPIHeaderCtrl	spHeaderCtrl;
	int			iWidth;
	ConfigStream *	pConfig;
	ULONG		cColumns;
	
	CORg( pComponent->GetHeaderCtrl(&spHeaderCtrl) );

	//
	// Get the configuration data
	//
	pComponent->GetUserData((LONG_PTR *) &pConfig);
	Assert(pConfig);

	//
	// Get the information about the columns
	//
	cColumns = pConfig->GetColumnCount(m_ulColumnId);

	//
	// Allocate temporary space for the column data
	//
	prgColData = (ColumnData *) alloca(sizeof(ColumnData)*cColumns);
	
	CORg( pConfig->GetColumnData(m_ulColumnId, cColumns, prgColData) );

	//
	// Now write over the old data with the new data (this way we preserve
	// defaults).
	//
	for (i=0; i<cColumns; i++)
	{
//		if (i < pConfig->GetVisibleColumns(m_ulColumnId))
		{
//			ulPos = pConfig->MapColumnToSubitem(m_ulColumnId, i);
            ulPos = i;
			if (FHrSucceeded(spHeaderCtrl->GetColumnWidth(i, &iWidth)))
				prgColData[ulPos].m_dwWidth = iWidth;
		}
	}

	//
	// Write the data back
	//
	CORg( pConfig->SetColumnData(m_ulColumnId, cColumns, prgColData) );

Error:
	return hr;
}



/*!--------------------------------------------------------------------------
	BaseContainerHandler::PrivateLoadColumns
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT BaseContainerHandler::PrivateLoadColumns(ITFSComponent *pComponent,
	IHeaderCtrl *pHeaderCtrl, MMC_COOKIE cookie)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT		hr = hrOK;
	CString		st;
	ULONG		i = 0;
	ColumnData *prgColData;
	int			iPos;
	ConfigStream *	pConfig;
	ULONG		cColumns;
	static UINT	s_uCharWidth = 0;
	DWORD		dwWidth;

	if (s_uCharWidth == 0)
	{
		const TCHAR s_szTestData[] = _T("abcdABCD");
		s_uCharWidth = CalculateStringWidth(NULL, s_szTestData);
		s_uCharWidth /= 8;
	}

	pComponent->GetUserData((LONG_PTR *) &pConfig);
	Assert(pConfig);

	cColumns = pConfig->GetColumnCount(m_ulColumnId);

	prgColData = (ColumnData *) alloca(sizeof(ColumnData)*cColumns);

	//
	// Build up the column data from the current list in the
	// node data
	//
	pConfig->GetColumnData(m_ulColumnId, cColumns, prgColData);
	
//	for (i=0; i<pConfig->GetVisibleColumns(m_ulColumnId); i++)
	for (i=0; i<cColumns; i++)
	{
		// Add this column to the list view
//		iPos = pConfig->MapColumnToSubitem(m_ulColumnId, i);
        iPos = i;
		
		st.LoadString(m_prgColumnInfo[iPos].m_ulStringId);

        if (prgColData[iPos].m_nPosition < 0)
            dwWidth = HIDE_COLUMN;
        else
            dwWidth = prgColData[iPos].m_dwWidth;
        
		pHeaderCtrl->InsertColumn(i,
								  const_cast<LPTSTR>((LPCWSTR)st),
								  LVCFMT_LEFT,
								  dwWidth);
		if (dwWidth == AUTO_WIDTH)
		{
			ULONG uLength = max((ULONG)st.GetLength() + 4, m_prgColumnInfo[iPos].m_ulDefaultColumnWidth);
			dwWidth = uLength * s_uCharWidth;

            pHeaderCtrl->SetColumnWidth(i, dwWidth);
		}

	}
	

//Error:
	return hr;
}

HRESULT BaseContainerHandler::UserResultNotify(ITFSNode *pNode,
											   LPARAM lParam1,
											   LPARAM lParam2)
{
	HRESULT		hr = hrOK;

	COM_PROTECT_TRY
	{
		if (lParam1 == RRAS_ON_SAVE)
		{
			hr = SaveColumns((ITFSComponent *) lParam2,
							 (MMC_COOKIE) pNode->GetData(TFS_DATA_COOKIE),
							 0, 0);
		}
		else
			hr = BaseRouterHandler::UserResultNotify(pNode, lParam1, lParam2);
	}
	COM_PROTECT_CATCH;
	
	return hr;	
}

/*!--------------------------------------------------------------------------
	BaseContainerHandler::TaskPadGetTitle
        -
    Author: MikeG (a-migall)
 ---------------------------------------------------------------------------*/
STDMETHODIMP BaseContainerHandler::TaskPadGetTitle(ITFSComponent * pComponent,
												   MMC_COOKIE      cookie,
												   LPOLESTR        pszGroup,
												   LPOLESTR		 * ppszTitle)
{
	// Check parameters;
	Assert(ppszTitle);

	// Not using...
	UNREFERENCED_PARAMETER(pComponent);
	UNREFERENCED_PARAMETER(cookie);
	UNREFERENCED_PARAMETER(pszGroup);

	// Need to call this so we can safely call the LoadString() 
	// member on CString.
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	// Load the TaskPad's display name from a string table in
	// the resources.
	*ppszTitle = NULL;
	CString sTaskpadTitle;
	Assert(m_nTaskPadDisplayNameId > 0);
	if (!sTaskpadTitle.LoadString(m_nTaskPadDisplayNameId))
		return E_OUTOFMEMORY;
	
	// Allocate a buffer for the string.
	*ppszTitle = 
		reinterpret_cast<LPOLESTR>(::CoTaskMemAlloc(sizeof(OLECHAR)*(sTaskpadTitle.GetLength()+1)));
    if (!*ppszTitle)
	{
		*ppszTitle = NULL;		// cleanup to a steady state...
		return E_OUTOFMEMORY;
	}

	// Package the display name for return to the MMC console.
	HRESULT hr = S_OK;
	if (::lstrcpy(*ppszTitle, (LPCTSTR)sTaskpadTitle) == NULL)
	{
		hr = HRESULT_FROM_WIN32(::GetLastError());
		::CoTaskMemFree(*ppszTitle);
		*ppszTitle = NULL;
		// Future: Wonder if it is safe for us to cleanup this unused
		//		   memory here in the snapin versus letting the MMC 
		//		   handle it? Well, the MMC should be smart enough to
		//		   realize that there is no string buffer.
	}

    return hr;
}

/*!--------------------------------------------------------------------------
	BaseContainerHandler::OnResultContextHelp
		-
	Author: MikeG (a-migall)
 ---------------------------------------------------------------------------*/
HRESULT BaseContainerHandler::OnResultContextHelp(ITFSComponent * pComponent, 
												  LPDATAOBJECT    pDataObject, 
												  MMC_COOKIE      cookie, 
												  LPARAM          arg, 
												  LPARAM          lParam)
{
	// Not used...
	UNREFERENCED_PARAMETER(pDataObject);
	UNREFERENCED_PARAMETER(cookie);
	UNREFERENCED_PARAMETER(arg);
	UNREFERENCED_PARAMETER(lParam);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
	return HrDisplayHelp(pComponent, m_spTFSCompData->GetHTMLHelpFileName(), m_nHelpTopicId);
}

/*!--------------------------------------------------------------------------
	BaseContainerHandler::TaskPadNotify
        -
    Author: MikeG (a-migall)
 ---------------------------------------------------------------------------*/
STDMETHODIMP BaseContainerHandler::TaskPadNotify(ITFSComponent	 * pComponent,
												 IN MMC_COOKIE     cookie,
												 IN LPDATAOBJECT   pDataObject,
												 IN VARIANT		 * arg,
												 IN VARIANT		 * param)
{
	// Not used...
	UNREFERENCED_PARAMETER(cookie);
	UNREFERENCED_PARAMETER(pDataObject);
	UNREFERENCED_PARAMETER(param);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = hrOK;
    if (arg->vt == VT_I4)
    {
        switch (arg->lVal)
        {
            case 0:			// for a lack of anything better!!!
				hr = HrDisplayHelp(pComponent, m_spTFSCompData->GetHTMLHelpFileName(), m_nHelpTopicId);
                break;

            default:
                Panic1("BaseContainerHandler::TaskPadNotify - Unrecognized command! %d", arg->lVal);
                break;
        }
    }

    return hrOK;
}

/*!--------------------------------------------------------------------------
	HrDisplayHelp
        -
    Author: MikeG (a-migall)
 ---------------------------------------------------------------------------*/
HRESULT HrDisplayHelp(ITFSComponent	  * pComponent,
					  LPCTSTR			pcszHelpFile,
					  UINT				nHelpTopicId)
{
	Assert(nHelpTopicId > 0);
	CString sHelpTopic;
	if (!sHelpTopic.LoadString(nHelpTopicId))
		return E_FAIL;

	return HrDisplayHelp(pComponent, pcszHelpFile, (LPCTSTR)sHelpTopic);
}

HRESULT HrDisplayHelp(ITFSComponent	  * pComponent,
					  LPCTSTR			pcszHelpFile,
					  LPCTSTR			pcszHelpTopic)
{
	Assert(!::IsBadStringPtr(pcszHelpFile, ::lstrlen(pcszHelpFile)));
	if (pcszHelpFile == NULL)
		//return E_FAIL;
		return S_OK;	// ???
	Trace1("HTML Help Filename = %s\n", pcszHelpFile);
	//
	// Future: Why do we hand this in when we don't even use it? There
	//		   was a reason, but I'll be damned if I can remember why.
	//

	// Get an interface to the MMC console.
    SPIConsole spConsole;
	Assert(pComponent);
    pComponent->GetConsole(&spConsole);

	// Get the MMC console's help interface.
	SPIDisplayHelp spDisplayHelp;
    HRESULT hr = spConsole->QueryInterface(IID_IDisplayHelp,
										   reinterpret_cast<LPVOID*>(&spDisplayHelp));
	//ASSERT(SUCCEEDED(hr));
	if (FAILED(hr))
		return hr;

    CString sHelpFilePath;
	UINT nLen = ::GetWindowsDirectory(sHelpFilePath.GetBufferSetLength(2*MAX_PATH), 2*MAX_PATH);
	sHelpFilePath.ReleaseBuffer();
	if (nLen == 0)
		return E_FAIL;
    	
	Assert(!::IsBadStringPtr(pcszHelpTopic, ::lstrlen(pcszHelpTopic)));
	sHelpFilePath += pcszHelpTopic;
	LPTSTR psz = const_cast<LPTSTR>((LPCTSTR)sHelpFilePath);
	Assert(!::IsBadStringPtr(psz, ::lstrlen(psz)));
	Trace1("Help Filename (with path) = %s\n", psz);

	hr = spDisplayHelp->ShowTopic(T2OLE(psz));
	//ASSERT(SUCCEEDED(hr));
 
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\basertr.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	basertr.cpp
		Base Router handler implementation.
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "util.h"
#include "basertr.h"
#include "basecon.h"
#include "tfschar.h"
#include "strmap.h"		// XXXtoCString functions
#include "service.h"	// TFS service APIs
#include "rtrstr.h"	// const strings used
#include "rtrsheet.h"	// RtrPropertySheet
#include "rtrutil.h"


/*---------------------------------------------------------------------------
	BaseRouterHandler implementation
 ---------------------------------------------------------------------------*/

BaseRouterHandler::BaseRouterHandler(ITFSComponentData *pCompData)
	: CHandler(pCompData),
	  m_nHelpTopicId(IDS_DEFAULT_HELP_TOPIC)
{
	// Initialize all of the buttons to be hidden by default

	for (int i=0; i<MMC_VERB_COUNT; i++)
	{
		m_rgButtonState[i] = HIDDEN;
		m_bState[i] = FALSE;
	}

	// Make sure that these constants don't change on us
	Assert((0x8000+MMC_VERB_OPEN_INDEX) == MMC_VERB_OPEN);
	Assert((0x8000+MMC_VERB_COPY_INDEX) == MMC_VERB_COPY);
	Assert((0x8000+MMC_VERB_PASTE_INDEX) == MMC_VERB_PASTE);
	Assert((0x8000+MMC_VERB_DELETE_INDEX) == MMC_VERB_DELETE);
	Assert((0x8000+MMC_VERB_PROPERTIES_INDEX) == MMC_VERB_PROPERTIES);
	Assert((0x8000+MMC_VERB_RENAME_INDEX) == MMC_VERB_RENAME);
	Assert((0x8000+MMC_VERB_REFRESH_INDEX) == MMC_VERB_REFRESH);
	Assert((0x8000+MMC_VERB_PRINT_INDEX) == MMC_VERB_PRINT);

	m_verbDefault = MMC_VERB_OPEN;
}


/*---------------------------------------------------------------------------
	BaseRouterHandler::OnCreateNodeId2
		Returns a unique string for this node
	Author: WeiJiang
 ---------------------------------------------------------------------------*/
HRESULT BaseRouterHandler::OnCreateNodeId2(ITFSNode * pNode, CString & strId, 
DWORD * dwFlags)
{
    const GUID * pGuid = pNode->GetNodeType();

    CString strProviderId, strGuid;

    StringFromGUID2(*pGuid, strGuid.GetBuffer(256), 256);
    strGuid.ReleaseBuffer();

	// RouterInfo should be available now

//	Assert(m_spRouterInfo);

	if(m_spRouterInfo) {
		DWORD	RouterInfoFlags = m_spRouterInfo->GetFlags();

		// if the machine is added not as local, then we use the machine name
		if (0 == (RouterInfoFlags & RouterInfo_AddedAsLocal))	// not added as local
		   strId = m_spRouterInfo->GetMachineName() + strGuid;
		else
		   strId = strGuid;
		}
	else {
		strId = strGuid;
	}

    return hrOK;
}

/*!--------------------------------------------------------------------------
	BaseRouterHandler::OnResultSelect
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT BaseRouterHandler::OnResultSelect(ITFSComponent *pComponent,
										  LPDATAOBJECT pDataObject,
										  MMC_COOKIE cookie,
										  LPARAM arg,
										  LPARAM lParam)
{
	SPIConsoleVerb	spConsoleVerb;
	SPITFSNode		spNode;
	HRESULT			hr = hrOK;

	CORg( pComponent->GetConsoleVerb(&spConsoleVerb) );
	CORg( m_spNodeMgr->FindNode(cookie, &spNode) );

	// If you need to update the verb state, do it here

	EnableVerbs(spConsoleVerb);

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	BaseRouterHandler::EnableVerbs
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void BaseRouterHandler::EnableVerbs(IConsoleVerb *pConsoleVerb)
{
	Assert(pConsoleVerb);
	Assert(DimensionOf(m_rgButtonState) == DimensionOf(m_bState));
	Assert(DimensionOf(m_rgButtonState) == MMC_VERB_COUNT);

	for (int i=0; i<DimensionOf(m_rgButtonState); i++)
	{
		if (m_rgButtonState[i] & HIDDEN)
		{
			pConsoleVerb->SetVerbState(INDEX_TO_VERB(i), HIDDEN, TRUE);
		}
		else
		{
			// unhide this button before enabling
			pConsoleVerb->SetVerbState(INDEX_TO_VERB(i), HIDDEN, FALSE);
			pConsoleVerb->SetVerbState(INDEX_TO_VERB(i), ENABLED, m_bState[i]);
		}
	}

	pConsoleVerb->SetDefaultVerb(m_verbDefault);
}

/*!--------------------------------------------------------------------------
	BaseRouterHandler::OnResultPropertyChange
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT BaseRouterHandler::OnResultPropertyChange
(
	ITFSComponent * pComponent,
	LPDATAOBJECT	pDataObject,
	MMC_COOKIE			cookie,
	LPARAM			arg,
	LPARAM			param
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	SPITFSNode spNode;
	m_spNodeMgr->FindNode(cookie, &spNode);

	RtrPropertySheet * pPropSheet = reinterpret_cast<RtrPropertySheet *>(param);

	LONG_PTR changeMask = 0;

	// tell the property page to do whatever now that we are back on the
	// main thread
	pPropSheet->OnPropertyChange(TRUE, &changeMask);

	pPropSheet->AcknowledgeNotify();

	if (changeMask)
		spNode->ChangeNode(changeMask);

	return hrOK;
}

/*!--------------------------------------------------------------------------
	BaseRouterHandler::OnPropertyChange
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT BaseRouterHandler::OnPropertyChange
(
	ITFSNode *pNode,
	LPDATAOBJECT	pDataObject,
    DWORD			dwType,
	LPARAM			arg,
	LPARAM			param
)
{
    // This is running on the MAIN THREAD!
    // ----------------------------------------------------------------
    
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	RtrPropertySheet * pPropSheet = reinterpret_cast<RtrPropertySheet *>(param);

	LONG_PTR changeMask = 0;

	// tell the property page to do whatever now that we are back on the
	// main thread
	pPropSheet->OnPropertyChange(TRUE, &changeMask);

	pPropSheet->AcknowledgeNotify();

	if (changeMask)
		pNode->ChangeNode(changeMask);

	return hrOK;
}

/*!--------------------------------------------------------------------------
	BaseRouterHandler::OnVerbRefresh
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT BaseRouterHandler::OnVerbRefresh(ITFSNode *pNode, LPARAM arg, LPARAM lParam)
{
	return ForceGlobalRefresh(m_spRouterInfo);
}

/*!--------------------------------------------------------------------------
	BaseRouterHandler::OnResultRefresh
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT BaseRouterHandler::OnResultRefresh(ITFSComponent *pTFSComponent, LPDATAOBJECT lpDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	return ForceGlobalRefresh(m_spRouterInfo);
}

HRESULT BaseRouterHandler::ForwardCommandToParent(ITFSNode *pNode,
	long nCommandId,
	DATA_OBJECT_TYPES type,
	LPDATAOBJECT pDataObject,
	DWORD dwType)
{
	SPITFSNode	spParent;
	SPITFSNodeHandler	spHandler;
	HRESULT		hr = hrOK;

	CORg( pNode->GetParent(&spParent) );
	if (!spParent)
		CORg( E_INVALIDARG );

	CORg( spParent->GetHandler(&spHandler) );
	if (!spHandler)
		CORg( E_INVALIDARG );

	hr = spHandler->OnCommand(spParent, nCommandId, type, pDataObject, dwType);
	
Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	BaseRouterHandler::EnumDynamicExtensions
		
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT BaseRouterHandler::EnumDynamicExtensions(ITFSNode * pNode)
{
    HRESULT             hr = hrOK;

    CORg (m_dynExtensions.SetNode(pNode->GetNodeType()));
    
    CORg (m_dynExtensions.Reset());
    CORg (m_dynExtensions.Load());

Error:
    return hr;
}


/*!--------------------------------------------------------------------------
	BaseRouterHandler::EnumDynamicExtensions
		
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT BaseRouterHandler::AddDynamicNamespaceExtensions(ITFSNode * pNode)
{
    HRESULT             hr = hrOK;
    CGUIDArray          aNamespace;
    SPIConsoleNameSpace spNS;
    int                 i;

    COM_PROTECT_TRY
    {
        // enumerate dynamic namespace extensions
        CORg (m_spNodeMgr->GetConsoleNameSpace(&spNS));

        m_dynExtensions.GetNamespaceExtensions(aNamespace);
        for (i = 0; i < aNamespace.GetSize(); i++)
        {
            HRESULT hrAdd = spNS->AddExtension(pNode->GetData(TFS_DATA_SCOPEID), &aNamespace[i]);  
            if (FAILED(hrAdd))
                Trace1("BaseRouterHandler::AddDynamicNamespaceExtensions - AddExtension failed %x", hrAdd);
        }

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
	BaseRouterHandler::OnResultContextHelp
		-
	Author: MikeG (a-migall)
 ---------------------------------------------------------------------------*/
HRESULT BaseRouterHandler::OnResultContextHelp(ITFSComponent * pComponent, 
											   LPDATAOBJECT    pDataObject, 
											   MMC_COOKIE      cookie, 
											   LPARAM          arg, 
											   LPARAM          lParam)
{
	// Not used...
	UNREFERENCED_PARAMETER(pDataObject);
	UNREFERENCED_PARAMETER(cookie);
	UNREFERENCED_PARAMETER(arg);
	UNREFERENCED_PARAMETER(lParam);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
	return HrDisplayHelp(pComponent, m_spTFSCompData->GetHTMLHelpFileName(), m_nHelpTopicId);
}


/*!--------------------------------------------------------------------------
	BaseRouterHandler::AddArrayOfMenuItems
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT BaseRouterHandler::AddArrayOfMenuItems(ITFSNode *pNode,
                                               const SRouterNodeMenu *prgMenu,
                                               UINT crgMenu,
                                               LPCONTEXTMENUCALLBACK pCallback,
                                               long iInsertionAllowed,
                                               INT_PTR pUserData)
{
	HRESULT	hr = hrOK;
	ULONG	ulFlags;
	UINT			i;
	CString		stMenu;
	
	// Now go through and add our menu items
		
	for (i=0; i<crgMenu; i++)
	{
		// If this type of insertion is not allowed, skip it
		if ( (iInsertionAllowed & (1L << (prgMenu[i].m_ulPosition & CCM_INSERTIONPOINTID_MASK_FLAGINDEX))) == 0 )
			 continue;

        if (prgMenu[i].m_sidMenu == IDS_MENU_SEPARATOR)
        {
            ulFlags = MF_SEPARATOR;
            stMenu.Empty();
        }
        else
        {        
            if (prgMenu[i].m_pfnGetMenuFlags)
            {
                ulFlags = (*prgMenu[i].m_pfnGetMenuFlags)(prgMenu+i,
                                                        pUserData);
            }
            else
                ulFlags = 0;
            
            // Special case - if the menu flags returns 0xFFFFFFFF
            // then we interpret this to mean don't add the menu item
            if (ulFlags == 0xFFFFFFFF)
                continue;
          
            stMenu.Empty();
            if (prgMenu[i].m_sidMenu)
                stMenu.LoadString(prgMenu[i].m_sidMenu);
        }
		
		LoadAndAddMenuItem(pCallback,
						   stMenu,
						   prgMenu[i].m_sidMenu,
						   prgMenu[i].m_ulPosition,
						   ulFlags, 
						   prgMenu[i].m_pszLangIndStr);
	}
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\dumbprop.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	dumbprop.cpp
		Dummy property sheet to put up to avoid MMC's handlig of 
		the property verb.

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "dumbprop.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
//
// CDummyProperties holder
//
/////////////////////////////////////////////////////////////////////////////
CDummyProperties::CDummyProperties
(
	ITFSNode *			pNode,
	IComponentData *	pComponentData,
	LPCTSTR				pszSheetName
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName)
{
	m_fSetDefaultSheetPos = FALSE;

	//if this is not done, deadlock can happen
	EnablePeekMessageDuringNotifyConsole(TRUE);	

	AddPageToList((CPropertyPageBase*) &m_pageGeneral);
}

CDummyProperties::~CDummyProperties()
{
	RemovePageFromList((CPropertyPageBase*) &m_pageGeneral, FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// CDummyPropGeneral property page

//IMPLEMENT_DYNCREATE(CDummyPropGeneral, CPropertyPageBase)

CDummyPropGeneral::CDummyPropGeneral() : CPropertyPageBase(CDummyPropGeneral::IDD)
{
	//{{AFX_DATA_INIT(CDummyPropGeneral)
	//}}AFX_DATA_INIT
}

CDummyPropGeneral::~CDummyPropGeneral()
{
}

void CDummyPropGeneral::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDummyPropGeneral)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDummyPropGeneral, CPropertyPageBase)
	//{{AFX_MSG_MAP(CDummyPropGeneral)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDummyPropGeneral message handlers

int CDummyPropGeneral::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CPropertyPageBase::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	RECT rect;
	::GetWindowRect(lpCreateStruct->hwndParent, &rect);

	::SetWindowPos(lpCreateStruct->hwndParent, HWND_BOTTOM, 0, 0, 0, 0, SWP_HIDEWINDOW);
	::PropSheet_PressButton(lpCreateStruct->hwndParent, PSBTN_CANCEL);
	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\format.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       format.h
//
//--------------------------------------------------------------------------


#ifndef _FORMAT_H_
#define _FORMAT_H_


#define FSEFLAG_SYSMESSAGE      0x00000001
#define FSEFLAG_MPRMESSAGE      0x00000002
#define FSEFLAG_ANYMESSAGE      0x00000003

#define FDFLAG_MSECONDS         0x00000001
#define FDFLAG_SECONDS          0x00000002
#define FDFLAG_MINUTES          0x00000004
#define FDFLAG_HOURS            0x00000008
#define FDFLAG_DAYS             0x00000010
#define FDFLAG_ALL              0x0000001F

/*!--------------------------------------------------------------------------
	DisplayErrorMessage
		This function will call FormatSystemError() on the hr value and
		display that error text.
	Author: KennT
 ---------------------------------------------------------------------------*/
void DisplayErrorMessage(HWND hWndParent, HRESULT hr);


/*!--------------------------------------------------------------------------
	DisplayStringErrorMessage2
	DisplayIdErrorMessage2
		This function will call FormatSystemError() on the hr.  But will
		prepend the pszTopLevelText onto that error.  This allows us
		to show more descriptive error messages.
	Author: KennT
 ---------------------------------------------------------------------------*/
void DisplayStringErrorMessage2(HWND hWndParent, LPCTSTR pszTopLevelText, HRESULT hr);
void DisplayIdErrorMessage2(HWND hWndParent, UINT idsError, HRESULT hr);

//----------------------------------------------------------------------------
// Function:    FormatSystemError
//
// Formats an error code using '::FormatMessage' or '::MprAdminGetErrorString',
// or both (the default).
// If 'psFormat' is specified, it is used to format the error-string
// into 'sError'.
//----------------------------------------------------------------------------

DWORD
FormatSystemError(
				  HRESULT	hr,
				  LPTSTR	pszError,
				  UINT		cchMax,
				  UINT		idsFormat,
				  DWORD		dwFormatFlags);

//    IN  UINT        idsFormat       = 0,
//    IN  DWORD       dwFormatFlags   = FSEFLAG_SYSMESSAGE|
//                                      FSEFLAG_MPRMESSAGE);


//----------------------------------------------------------------------------
// Function:    FormatNumber
//
// Formats a number as a string, using the thousands-separator
// for the current-user's locale.
//----------------------------------------------------------------------------

VOID
FormatNumber(
    DWORD       dwNumber,
	LPTSTR		pszNumber,
	UINT		cchMax,
	BOOL		bSigned);



VOID
FormatListString(
    IN  CStringList&    strList,
    IN  CString&        sListString,
    IN  LPCTSTR         pszSeparator
    );


//----------------------------------------------------------------------------
// Function:    FormatHexBytes
//
// Formats an array of bytes as a string.
//----------------------------------------------------------------------------

VOID
FormatHexBytes(
    IN  BYTE*       pBytes,
    IN  DWORD       dwCount,
    IN  CString&    sBytes,
    IN  TCHAR       chDelimiter);

//----------------------------------------------------------------------------
// Function:    FormatDuration
//
// Formats a number as a duration, using the time-separator
// for the current-user's locale. The input expected is in milliseconds.
//----------------------------------------------------------------------------

#define FDFLAG_MSECONDS         0x00000001
#define FDFLAG_SECONDS          0x00000002
#define FDFLAG_MINUTES          0x00000004
#define FDFLAG_HOURS            0x00000008
#define FDFLAG_DAYS             0x00000010
#define FDFLAG_ALL              0x0000001F

#define UNIT_SECONDS		(1)
#define UNIT_MILLISECONDS	(1000)

VOID
FormatDuration(
    IN  DWORD       dwDuration,
    IN  CString&    sDuration,
	IN	DWORD		dwTimeBase,
    IN  DWORD       dwFormatFlags   = FDFLAG_SECONDS|
                                      FDFLAG_MINUTES|
                                      FDFLAG_HOURS );



#define WIN32_FROM_HRESULT(hr)		(0x0000FFFF & (hr))




/*---------------------------------------------------------------------------
	Class:  IfIndexToNameMapping

    Use this class to implement an interface-index to friendly-name mapping.
    This is used mostly by those that use the MIB calls and want to
    display some data.

    Note that the interface index may change, so this map should not be
    kept around very long.
 ---------------------------------------------------------------------------*/

class IfIndexToNameMapping
{
public:
    IfIndexToNameMapping();
    ~IfIndexToNameMapping();

    HRESULT Add(ULONG ulIndex, LPCTSTR pszName);
    LPCTSTR Find(ULONG ulIndex);

protected:
    // This maps a key (the DWORD index) to the associated name
    CMapPtrToPtr    m_map;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\ipctrl.cpp ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    ipctrl.cpp
//
// History:
//              Tony Romano             Created.
//  06/17/96    Abolade Gbadegesin      Revised.
//
// Implements the C++ class encapsulating the IP-address custom control.
//============================================================================

#include "stdafx.h"
extern "C" {
#include "ipaddr.h"
};

#include "ipctrl.h"




IPControl::IPControl( ) { m_hIPaddr = 0; }

IPControl::~IPControl( ) { }



BOOL
IPControl::Create(
    HWND        hParent,
    UINT        nID
    ) {

    ASSERT(IsWindow(hParent));

    if (hParent)    
        m_hIPaddr   = GetDlgItem(hParent, nID);

    return m_hIPaddr != NULL;   
}



LRESULT
IPControl::SendMessage(
    UINT        uMsg,
    WPARAM      wParam,
    LPARAM      lParam
    ) {

    ASSERT(IsWindow(m_hIPaddr));

    return ::SendMessage(m_hIPaddr, uMsg, wParam, lParam);
}



BOOL
IPControl::IsBlank(
    ) {

    return (BOOL)SendMessage(IP_ISBLANK, 0, 0);
}



VOID
IPControl::SetAddress(
    DWORD       ardwAddress[4]
    ) {

    SendMessage(
        IP_SETADDRESS, 0,
        MAKEIPADDRESS(
            ardwAddress[0], ardwAddress[1], ardwAddress[2], ardwAddress[3]
            )
        );
}



VOID
IPControl::SetAddress(
    DWORD       a1,
    DWORD       a2,
    DWORD       a3,
    DWORD       a4
    ) {

    SendMessage(IP_SETADDRESS, 0, MAKEIPADDRESS(a1,a2,a3,a4));
}



VOID
IPControl::SetAddress(
    LPCTSTR     lpszString
    ) {

    if (!lpszString) { ClearAddress(); }

    SendMessage(WM_SETTEXT, 0, (LPARAM)lpszString);
}


INT
IPControl::GetAddress(
    DWORD       *a1,
    DWORD       *a2,
    DWORD       *a3,
    DWORD       *a4
    ) {

    INT_PTR nSet;
    DWORD dwAddress;

    ASSERT(a1 && a2 && a3 && a4);

    if ((nSet = SendMessage(IP_GETADDRESS,0,(LPARAM)&dwAddress)) == 0) {

        *a1 = 0;
        *a2 = 0;
        *a3 = 0;
        *a4 = 0;
    }
    else {

        *a1 = FIRST_IPADDRESS( dwAddress );
        *a2 = SECOND_IPADDRESS( dwAddress );
        *a3 = THIRD_IPADDRESS( dwAddress );
        *a4 = FOURTH_IPADDRESS( dwAddress );
    }

    return (INT)nSet;
}


INT
IPControl::GetAddress(
    DWORD       ardwAddress[4]
    ) {

    INT_PTR nSet;
    DWORD dwAddress;

    if ((nSet = SendMessage(IP_GETADDRESS, 0, (LPARAM)&dwAddress )) == 0) {

        ardwAddress[0] = 0;
        ardwAddress[1] = 0;
        ardwAddress[2] = 0;
        ardwAddress[3] = 0;
    }
    else {

        ardwAddress[0] = FIRST_IPADDRESS( dwAddress );
        ardwAddress[1] = SECOND_IPADDRESS( dwAddress );
        ardwAddress[2] = THIRD_IPADDRESS( dwAddress );
        ardwAddress[3] = FOURTH_IPADDRESS( dwAddress );
    }

    return (INT)nSet;
}


INT
IPControl::GetAddress(
    CString&    address
    ) {

    INT_PTR c, nSet;
    DWORD dwAddress;

    nSet = SendMessage(IP_GETADDRESS, 0, (LPARAM)&dwAddress);

    address.ReleaseBuffer((int)(c = SendMessage(WM_GETTEXT, 256, (LPARAM)address.GetBuffer(256))));

    return (INT)nSet;
}


VOID
IPControl::SetFocusField(
    DWORD       dwField
    ) {

    SendMessage(IP_SETFOCUS, dwField, 0);
}


VOID
IPControl::ClearAddress(
    ) {

    SendMessage(IP_CLEARADDRESS, 0, 0);
}


VOID
IPControl::SetFieldRange(
    DWORD       dwField,
    DWORD       dwMin,
    DWORD       dwMax
    ) {

    SendMessage(IP_SETRANGE, dwField, MAKERANGE(dwMin,dwMax));
}

#if 0
WCHAR *
inet_ntoaw(
    struct in_addr  dwAddress
    ) {

    static WCHAR szAddress[16];

    mbstowcs(szAddress, inet_ntoa(*(struct in_addr *)&dwAddress), 16);

    return szAddress;
}


DWORD
inet_addrw(
    LPCWSTR     szAddressW
    ) {

    CHAR szAddressA[16];

    wcstombs(szAddressA, szAddressW, 16);

    return inet_addr(szAddressA);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\ipctrl.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    ipcontrol.h
//
// History:
//  ??/??/??    Tony Romano         Created.
//  05/16/96    Abolade Gbadegesin  Revised.
//============================================================================

#ifndef __IPCTRL_H
#define __IPCTRL_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

//----------------------------------------------------------------------------
// Class:       IPControl
//
// Controls an IP-address edit-control.
//----------------------------------------------------------------------------

class IPControl {
    
    public:

        IPControl( );
        ~IPControl( );
    
        BOOL
        Create(
            HWND        hParent,
            UINT        nID );

        operator
        HWND( ) { ASSERT(m_hIPaddr); return m_hIPaddr; }
    
        BOOL
        IsBlank( );

        VOID
        SetFocusField(
            DWORD       dwField );

        VOID
        SetFieldRange(
            DWORD       dwField,
            DWORD       dwMin,
            DWORD       dwMax );

        VOID
        ClearAddress( );
    
        VOID
        SetAddress(
            DWORD       ardwAddress[4] );

        VOID
        SetAddress(
            DWORD       a1,
            DWORD       a2,
            DWORD       a3,
            DWORD       a4 );

        VOID
        SetAddress(
            LPCTSTR     lpszString );
    
        INT 
        GetAddress(
            DWORD       ardwAddress[4] );

        INT 
        GetAddress(
            DWORD*      a1,
            DWORD*      a2,
            DWORD*      a3,
            DWORD*      a4 );

        INT
        GetAddress(
            CString&    address );
    
        LRESULT
        SendMessage(
            UINT        uMsg,
            WPARAM      wParam,
            LPARAM      lParam );
    
    protected:

        HWND            m_hIPaddr;
};



//----------------------------------------------------------------------------
// Macro:   MAKEADDR
//
// Given an a, b, c, and d, constructs a network-order DWORD corresponding
// to the IP-address a.b.c.d
//----------------------------------------------------------------------------

#define MAKEADDR(a, b, c, d) \
    (((a) & 0xff) | (((b) & 0xff) << 8) | (((c) & 0xff) << 16) | (((d) & 0xff) << 24))


//----------------------------------------------------------------------------
// Macros:      INET_NTOA
//              INET_ADDR
//
// Generic-text macros for IP-address conversion.
//----------------------------------------------------------------------------

/*
#ifndef UNICODE
#define INET_NTOA(a)    inet_ntoa(*(struct in_addr *)&(a))
#define INET_ADDR       inet_addr
#else
#define INET_NTOA(a)    inet_ntoaw(*(struct in_addr *)&(a))
#define INET_ADDR       inet_addrw
#endif
*/

//----------------------------------------------------------------------------
// Macro:       INET_CMP
//
// Comparison macro for IP addresses.
//
// This macro compares two IP addresses in network order by
// masking off each pair of octets and doing a subtraction;
// the result of the final subtraction is stored in the third argument
//----------------------------------------------------------------------------

inline int INET_CMP(DWORD a, DWORD b)
{
	DWORD	t;
	
	return ((t = ((a & 0x000000ff) - (b & 0x000000ff))) ? t :  
	((t = ((a & 0x0000ff00) - (b & 0x0000ff00))) ? t :   
	((t = ((a & 0x00ff0000) - (b & 0x00ff0000))) ? t :  
	((t = (((a>>8) & 0x00ff0000) - ((b>>8) & 0x00ff0000)))))));
}




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\lsa.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       lsa.h
//
//--------------------------------------------------------------------------

#ifndef LSA_H
#define LSA_H

#ifdef __cplusplus
extern "C"
{
#endif

	
DWORD StorePrivateData(LPCWSTR pszServerNam,
					   LPCWSTR pszRadiusServerName,
					   LPCWSTR pszSecret);
DWORD RetrievePrivateData(LPCWSTR pszServerName,
						  LPCWSTR pszRadiusServerName,
						  LPWSTR pszSecret,
						  INT cchSecret);
DWORD DeletePrivateData(LPCWSTR pszServerName,
                        LPCWSTR pszRadiusServerName);


DWORD RtlEncodeW(PUCHAR pucSeed, LPWSTR pswzString);
DWORD RtlDecodeW(UCHAR ucSeed, LPWSTR pswzString);

#ifdef __cplusplus
};
#endif

#endif // LSA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\format.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	format.cpp
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "tfschar.h"
#include "mprapi.h"
#include "rtrstr.h"
#include "format.h"

#include "raserror.h"
#include "mprerror.h"

//----------------------------------------------------------------------------
// Function:    FormatSystemError
//
// Formats an error code using '::FormatMessage', '::MprAdminGetErrorString',
// or '::RasAdminGetErrorString', or all the above (the default).
// If 'psFormat' is specified, it is used to format the error-string
// into 'sError'.
//----------------------------------------------------------------------------

DWORD
FormatSystemError(
    IN  HRESULT     hrErr,
		LPTSTR		pszBuffer,
		UINT		cchBuffer,
    IN  UINT        idsFormat,
    IN  DWORD       dwFormatFlags
    ) {
	DWORD	dwErr = WIN32_FROM_HRESULT(hrErr);
    DWORD dwRet = NO_ERROR;
    TCHAR* pszErr = NULL;
    WCHAR* pwsErr = NULL;
	CString	sError;

    dwFormatFlags &= FSEFLAG_ANYMESSAGE;

    do {

        //
        // See if 'FSEFLAG_MPRMESSAGE' is specified
        //
        if (dwFormatFlags & FSEFLAG_MPRMESSAGE)
		{
            dwFormatFlags &= ~FSEFLAG_MPRMESSAGE;

			if (((dwErr >= ROUTEBASE) && (dwErr <= ROUTEBASEEND)) ||
				((dwErr >= RASBASE) && (dwErr <= RASBASEEND)))
			{
				//
				// Try retrieving a string from rasmsg.dll or mprmsg.dll
				//
                dwRet = ::MprAdminGetErrorString(dwErr, &pwsErr);

                if (dwRet == NO_ERROR)
				{
                    pszErr = StrDupTFromW(pwsErr);
					::MprAdminBufferFree(pwsErr);
                    break;
                }
                else if (!dwFormatFlags)
					break;

                dwRet = NO_ERROR;
			}
			else if (!dwFormatFlags)
				return ERROR_INVALID_PARAMETER;
        }


        //
        // See if 'FSEFLAG_SYSMESSAGE' is specified
        //
        if (dwFormatFlags & FSEFLAG_SYSMESSAGE)
		{
            dwFormatFlags &= ~FSEFLAG_SYSMESSAGE;

            //
            // Try retrieving a string from the system
            //
            dwRet = ::FormatMessageW(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER|
                        FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL,
                        hrErr,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (LPTSTR)&pwsErr,
                        1,
                        NULL
                        );

            if (dwRet)
			{
                pszErr = StrDupTFromW(pwsErr);
				LocalFree(pwsErr);
                break;
            }
            else if (!dwFormatFlags)
				break;

            dwRet = NO_ERROR;
        }


    } while (FALSE);

    //
    // If no string was found, format the error as a number.
    //

    if (!pszErr)
	{
        TCHAR szErr[12];

        wsprintf(szErr, TEXT("%d"), dwErr);

        pszErr = StrDup(szErr);
    }


    //
    // Format the string into the caller's argument
    //

    if (idsFormat)
        AfxFormatString1(sError, idsFormat, pszErr);
    else
        sError = pszErr;

	// Finally, copy the output
	StrnCpy(pszBuffer, (LPCTSTR) sError, cchBuffer);

    delete pszErr;

    return dwRet;
}


//
// Forward declaration of utility function used by 'FormatNumber'
//
TCHAR*
padultoa(
    UINT    val,
    TCHAR*  pszBuf,
    INT     width
    );


//----------------------------------------------------------------------------
// Function:    FormatNumber
//
// This function takes an integer and formats a string with the value
// represented by the number, grouping digits by powers of one-thousand
//----------------------------------------------------------------------------

VOID
FormatNumber(DWORD      dwNumber,
			 LPTSTR		pszBuffer,
			 UINT		cchBuffer,
			 BOOL		fSigned)
{
	Assert(cchBuffer > 14);
    static TCHAR szNegativeSign[4] = TEXT("");
    static TCHAR szThousandsSeparator[4] = TEXT("");

    DWORD i, dwLength;
    TCHAR szDigits[12] = {0}, pszTemp[20] = {0};


    //
    // Retrieve the thousands-separator for the user's locale
    //

    if (szThousandsSeparator[0] == TEXT('\0'))
	{
        ::GetLocaleInfo(
            LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szThousandsSeparator, 4
            );
    }


    //
    // If we are formatting a signed value, see if the value is negative
    //

    if (fSigned)
	{
        if ((INT)dwNumber >= 0)
            fSigned = FALSE;
        else
		{
            //
            // The value is negative; retrieve the locale's negative-sign
            //

            if (szNegativeSign[0] == TEXT('\0')) {

                ::GetLocaleInfo(
                    LOCALE_USER_DEFAULT, LOCALE_SNEGATIVESIGN, szNegativeSign, 4
                    );
            }

            dwNumber = abs((INT)dwNumber);
        }
    }


    //
    // Convert the number to a string without thousands-separators
    //

    padultoa(dwNumber, szDigits, 0);

    dwLength = lstrlen(szDigits);


    //
    // If the length of the string without separators is n,
    // then the length of the string with separators is n + (n - 1) / 3
    //

    i = dwLength;
    dwLength += (dwLength - 1) / 3;


    //
    // Write the number to the buffer in reverse
    //

    TCHAR* pszsrc, *pszdst;

    pszsrc = szDigits + i - 1; pszdst = pszTemp + dwLength;

    *pszdst-- = TEXT('\0');

    while (TRUE) {
        if (i--) { *pszdst-- = *pszsrc--; } else { break; }
        if (i--) { *pszdst-- = *pszsrc--; } else { break; }
        if (i--) { *pszdst-- = *pszsrc--; } else { break; }
        if (i) { *pszdst-- = *szThousandsSeparator; } else { break; }
    }

	pszBuffer[0] = 0;
	
    if (fSigned)
		lstrcat(pszBuffer, szNegativeSign);

	lstrcat(pszBuffer, pszTemp);
}


//----------------------------------------------------------------------------
// Function:    padultoa
//
// This functions formats the specified unsigned integer
// into the specified string buffer, padding the buffer
// so that it is at least the specified width.
//
// It is assumed that the buffer is at least wide enough
// to contain the output, so this function does not truncate
// the conversion result to the length of the 'width' parameter.
//----------------------------------------------------------------------------

TCHAR*
padultoa(
    UINT    val,
    TCHAR*  pszBuf,
    INT     width
    ) {

    TCHAR temp;
    PTSTR psz, zsp;

    psz = pszBuf;

    //
    // write the digits in reverse order
    //

    do {

        *psz++ = TEXT('0') + (val % 10);
        val /= 10;

    } while(val > 0);

    //
    // pad the string to the required width
    //

    zsp = pszBuf + width;
    while (psz < zsp) { *psz++ = TEXT('0'); }


    *psz-- = TEXT('\0');


    //
    // reverse the digits
    //

    for (zsp = pszBuf; zsp < psz; zsp++, psz--) {

        temp = *psz; *psz = *zsp; *zsp = temp;
    }

    //
    // return the result
    //

    return pszBuf;
}


//----------------------------------------------------------------------------
// Function:    FormatListString
//
// Formats a list of strings as a single string, using the list-separator
// for the current-user's locale.
//----------------------------------------------------------------------------

VOID
FormatListString(
    IN  CStringList&    strList,
    IN  CString&        sListString,
    IN  LPCTSTR         pszSeparator
    ) {

    static TCHAR szListSeparator[4] = TEXT("");
    POSITION pos;

    sListString.Empty();

    pos = strList.GetHeadPosition();

    while (pos) {

        //
        // Add the next string
        //

        sListString += strList.GetNext(pos);


        //
        // If any strings are left, append the list-separator
        //

        if (pos) {

            //
            // Load the list-separator if necessary
            //

            if (!pszSeparator && szListSeparator[0] == TEXT('\0')) {

                GetLocaleInfo(
                    LOCALE_USER_DEFAULT, LOCALE_SLIST, szListSeparator, 4
                    );

                lstrcat(szListSeparator, TEXT(" "));
            }


            //
            // Append the list-separator
            //

            sListString += (pszSeparator ? pszSeparator : szListSeparator);
        }
    }
}


//----------------------------------------------------------------------------
// Function:    FormatHexBytes
//
// Formats an array of bytes as a string.
//----------------------------------------------------------------------------

VOID
FormatHexBytes(
    IN  BYTE*       pBytes,
    IN  DWORD       dwCount,
    IN  CString&    sBytes,
    IN  TCHAR       chDelimiter
    ) {

    TCHAR* psz;

    sBytes.Empty();

    if (!dwCount) { return; }

    psz = sBytes.GetBufferSetLength(dwCount * 3 + 1);

    for ( ; dwCount > 1; pBytes++, dwCount--) {

        *psz++ = c_szHexCharacters[*pBytes / 16];
        *psz++ = c_szHexCharacters[*pBytes % 16];
        *psz++ = chDelimiter;
    }

    *psz++ = c_szHexCharacters[*pBytes / 16];
    *psz++ = c_szHexCharacters[*pBytes % 16];
    *psz++ = TEXT('\0');

    sBytes.ReleaseBuffer();
}


/*!--------------------------------------------------------------------------
	DisplayErrorMessage
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void DisplayErrorMessage(HWND hWndParent, HRESULT hr)
{
	if (FHrSucceeded(hr))
		return;

	TCHAR	szErr[2048];

	FormatSystemError(hr,
					  szErr,
					  DimensionOf(szErr),
					  0,
					  FSEFLAG_SYSMESSAGE | FSEFLAG_MPRMESSAGE
					 );
	AfxMessageBox(szErr);
//	::MessageBox(hWndParent, szErr, NULL, MB_OK);
}


/*!--------------------------------------------------------------------------
	DisplayStringErrorMessage2
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void DisplayStringErrorMessage2(HWND hWndParent, LPCTSTR pszTopLevelText, HRESULT hr)
{
	if (FHrSucceeded(hr))
		return;

	TCHAR	szText[4096];
	TCHAR	szErr[2048];

	FormatSystemError(hr,
					  szErr,
					  DimensionOf(szErr),
					  0,
					  FSEFLAG_SYSMESSAGE | FSEFLAG_MPRMESSAGE
					 );
	StrnCpy(szText, pszTopLevelText, DimensionOf(szText));
	StrCat(szText, szErr);
	AfxMessageBox(szText);
//	::MessageBox(hWndParent, szErr, NULL, MB_OK);
}


/*!--------------------------------------------------------------------------
	DisplayIdErrorMessage2
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void DisplayIdErrorMessage2(HWND hWndParent, UINT idsError, HRESULT hr)
{
	if (FHrSucceeded(hr))
		return;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CString	stError;
	TCHAR	szErr[2048];

	stError.LoadString(idsError);
	
	FormatSystemError(hr,
					  szErr,
					  DimensionOf(szErr),
					  0,
					  FSEFLAG_SYSMESSAGE | FSEFLAG_MPRMESSAGE
					 );

	stError += szErr;
	AfxMessageBox(stError);
//	::MessageBox(hWndParent, szErr, NULL, MB_OK);
}


//----------------------------------------------------------------------------
// Function:    FormatDuration
//
// Formats a number as a duration, using the time-separator
// for the current-user's locale. dwBase is the number of units that make
// up a second (if dwBase==1 then the input is seconds, if dwBase==1000 then
// the input expected is in milliseconds.
//----------------------------------------------------------------------------


VOID
FormatDuration(
    IN  DWORD       dwDuration,
    IN  CString&    sDuration,
	IN	DWORD		dwTimeBase,
    IN  DWORD       dwFormatFlags
    ) {

    static TCHAR szTimeSeparator[4] = TEXT("");
    TCHAR *psz, szOutput[64];

    sDuration.Empty();

    if ((dwFormatFlags & FDFLAG_ALL) == 0) { return; }


    //
    // Retrieve the time-separator if necessary
    //

    if (szTimeSeparator[0] == TEXT('\0')) {

        GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STIME, szTimeSeparator, 4);
    }


    //
    // Concatenate the strings for the duration-components together
    //

    psz = szOutput;
    szOutput[0] = TEXT('\0');
    dwFormatFlags &= FDFLAG_ALL;


    if (dwFormatFlags & FDFLAG_DAYS) {

        //
        // Format the number of days if requested
        //

        padultoa(dwDuration / (24 * 60 * 60 * dwTimeBase), psz, 0);
        dwDuration %= (24 * 60 * 60 * dwTimeBase);

        //
        // Append the time-separator
        //

        if (dwFormatFlags &= ~FDFLAG_DAYS) { lstrcat(psz, szTimeSeparator); }

        psz += lstrlen(psz);
    }

    if (dwFormatFlags & FDFLAG_HOURS) {

        //
        // Format the number of hours if requested
        //

        padultoa(dwDuration / (60 * 60 * dwTimeBase), psz, 2);
        dwDuration %= (60 * 60 * dwTimeBase);

        //
        // Append the time-separator
        //

        if (dwFormatFlags &= ~FDFLAG_HOURS) { lstrcat(psz, szTimeSeparator); }

        psz += lstrlen(psz);
    }

    if (dwFormatFlags & FDFLAG_MINUTES) {

        //
        // Format the number of minutes
        //

        padultoa(dwDuration / (60 * dwTimeBase), psz, 2);
        dwDuration %= (60 * dwTimeBase);

        //
        // Append the time separator
        //

        if (dwFormatFlags &= ~FDFLAG_MINUTES) { lstrcat(psz, szTimeSeparator); }

        psz += lstrlen(psz);
    }

    if (dwFormatFlags & FDFLAG_SECONDS) {

        //
        // Format the number of seconds
        //

        padultoa(dwDuration / dwTimeBase, psz, 2);
        dwDuration %= dwTimeBase;

        //
        // Append the time-separator
        //

        if (dwFormatFlags &= ~FDFLAG_SECONDS) { lstrcat(psz, szTimeSeparator); }

        psz += lstrlen(psz);
    }

    if (dwFormatFlags & FDFLAG_MSECONDS) {

        //
        // Format the number of milliseconds
        //

        padultoa(dwDuration % dwTimeBase, psz, 0); psz += lstrlen(psz);
    }

    sDuration = szOutput;
}


/*---------------------------------------------------------------------------
	IfIndexToNameMapping implementation
 ---------------------------------------------------------------------------*/

IfIndexToNameMapping::IfIndexToNameMapping()
{
}

IfIndexToNameMapping::~IfIndexToNameMapping()
{
    // Iterate through the map and delete all the pointers
    POSITION    pos;
    LPVOID      pvKey, pvValue;

    for (pos = m_map.GetStartPosition(); pos; )
    {
        m_map.GetNextAssoc(pos, pvKey, pvValue);
        
        delete (CString *) pvValue;
        pvValue = NULL;
        m_map.SetAt(pvKey, pvValue);
    }
    m_map.RemoveAll();
}

/*!--------------------------------------------------------------------------
	IfIndexToNameMapping::Add
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IfIndexToNameMapping::Add(ULONG ulIndex, LPCTSTR pszName)
{
    HRESULT     hr = hrOK;
    LPVOID      pvKey, pvValue;

    COM_PROTECT_TRY
    {
        pvKey = (LPVOID) ULongToPtr( ulIndex );
        pvValue = NULL;
        
        // If we can find the value, don't add it
        if (m_map.Lookup(pvKey, pvValue) == 0)
        {
            pvValue = (LPVOID) new CString(pszName);
            m_map.SetAt(pvKey, pvValue);
        }
        
        Assert(((CString *) pvValue)->CompareNoCase(pszName) == 0);
        
    }
    COM_PROTECT_CATCH;
    
    return hr;
}

/*!--------------------------------------------------------------------------
	IfIndexToNameMapping::Find
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
LPCTSTR IfIndexToNameMapping::Find(ULONG ulIndex)
{
    LPVOID  pvValue = NULL;
    
    if (m_map.Lookup((LPVOID) ULongToPtr(ulIndex), pvValue))
        return (LPCTSTR) *((CString *)pvValue);
    else
        return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\lsa.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       lsa.c
//
//--------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntmsv1_0.h>
#include <ntlsa.h>
#include <windows.h>

#include "snaputil.h"	// for IsLocalMachine

#define _USTRINGP_NO_UNICODE_STRING
#define _USTRINGP_NO_UNICODE_STRING32
#include "ustringp.h"
#include "lsa.h"

// Useful defines
#define	PSZRADIUSSERVER		L"RADIUSServer."
#define CCHRADIUSSERVER		13


DWORD 
StorePrivateData(
	IN OPTIONAL LPCWSTR pszServerName,
    IN LPCWSTR pszRadiusServerName, 
    IN LPCWSTR pszSecret
)
{
	LSA_HANDLE            hLSA = NULL;
    NTSTATUS              ntStatus;
    LSA_OBJECT_ATTRIBUTES objectAttributes;
	LSA_UNICODE_STRING	  LSAPrivData, LSAPrivDataDesc;
    TCHAR				  tszPrivData[MAX_PATH+1],
						  tszPrivDataDesc[MAX_PATH+CCHRADIUSSERVER+1];
	TCHAR *				  ptszTemp;
	PUNICODE_STRING		  pSystem;
	UNICODE_STRING		  uszSystemName;

	if (IsLocalMachine(pszServerName))
		pSystem = NULL;
	else
	{
		SetUnicodeString(&uszSystemName,
						 pszServerName);
		pSystem = &uszSystemName;
	}
		
    InitializeObjectAttributes(&objectAttributes, NULL, 0, NULL, NULL);

    ntStatus = LsaOpenPolicy(pSystem, &objectAttributes, POLICY_ALL_ACCESS, &hLSA);

    if ( !NT_SUCCESS( ntStatus) ) 
    {
        return( RtlNtStatusToDosError( ntStatus ) );
    }

	ZeroMemory(tszPrivDataDesc, sizeof(tszPrivDataDesc));
    lstrcpy(tszPrivDataDesc, PSZRADIUSSERVER);
	lstrcpyn(tszPrivDataDesc + CCHRADIUSSERVER, pszRadiusServerName, MAX_PATH);
		
    LSAPrivDataDesc.Length = (USHORT)((lstrlen(tszPrivDataDesc) + 1) * sizeof(TCHAR));
    LSAPrivDataDesc.MaximumLength = sizeof(tszPrivDataDesc);
    LSAPrivDataDesc.Buffer = tszPrivDataDesc;

	ZeroMemory(tszPrivData, sizeof(tszPrivData));
	lstrcpyn(tszPrivData, pszSecret, MAX_PATH);
    LSAPrivData.Length = (USHORT)(lstrlen(tszPrivData) * sizeof(TCHAR));
    LSAPrivData.MaximumLength = sizeof(tszPrivData);
    LSAPrivData.Buffer = tszPrivData;
		
    ntStatus = LsaStorePrivateData(hLSA, &LSAPrivDataDesc, &LSAPrivData);

    ZeroMemory( tszPrivData, sizeof( tszPrivData ) );

    LsaClose(hLSA);

	return( RtlNtStatusToDosError( ntStatus ) );
} 


DWORD 
RetrievePrivateData(
	IN OPTIONAL LPCWSTR pszServerName,
    IN  LPCWSTR pszRadiusServerName, 
    OUT LPWSTR pszSecret,
	IN	INT	cchSecret
)
{
	LSA_HANDLE			    hLSA = NULL;
    NTSTATUS                ntStatus;
    LSA_OBJECT_ATTRIBUTES	objectAttributes;
	LSA_UNICODE_STRING		*pLSAPrivData, LSAPrivDataDesc;
	TCHAR					tszPrivData[MAX_PATH+1],
							tszPrivDataDesc[MAX_PATH+CCHRADIUSSERVER+1];
	PUNICODE_STRING		  pSystem;
	UNICODE_STRING		  uszSystemName;

	if (IsLocalMachine(pszServerName))
		pSystem = NULL;
	else
	{
		SetUnicodeString(&uszSystemName,
						 pszServerName);
		pSystem = &uszSystemName;
	}
		
		
    InitializeObjectAttributes(&objectAttributes, NULL, 0, NULL, NULL);

    ntStatus = LsaOpenPolicy(pSystem, &objectAttributes, POLICY_ALL_ACCESS, &hLSA);

    if ( !NT_SUCCESS( ntStatus) )
    {
        return( RtlNtStatusToDosError( ntStatus ) );
    }

	ZeroMemory(tszPrivDataDesc, sizeof(tszPrivDataDesc));
    lstrcpy(tszPrivDataDesc, PSZRADIUSSERVER);
	lstrcpyn(tszPrivDataDesc + CCHRADIUSSERVER, pszRadiusServerName, MAX_PATH);
		
    LSAPrivDataDesc.Length = (USHORT)((lstrlen(tszPrivDataDesc) + 1) * sizeof(TCHAR));
    LSAPrivDataDesc.MaximumLength = sizeof(tszPrivDataDesc);
    LSAPrivDataDesc.Buffer = tszPrivDataDesc;

    ntStatus = LsaRetrievePrivateData(hLSA, &LSAPrivDataDesc, &pLSAPrivData);

    if ( !NT_SUCCESS( ntStatus ) )
    {
		LsaClose(hLSA);
	    return( RtlNtStatusToDosError( ntStatus ) );
    }
    else
    {
		if ((pLSAPrivData->Length + 1) >= cchSecret)
			return ERROR_INSUFFICIENT_BUFFER;
					
        ZeroMemory(pszSecret, (pLSAPrivData->Length + 1) * sizeof(TCHAR));
		CopyMemory(pszSecret, pLSAPrivData->Buffer, pLSAPrivData->Length);
		
		LsaFreeMemory(pLSAPrivData);
    } 

	return( NO_ERROR );
} 


DWORD 
DeletePrivateData(
	IN OPTIONAL LPCWSTR pszServerName,
    IN LPCWSTR pszRadiusServerName
)
{
	LSA_HANDLE            hLSA = NULL;
    NTSTATUS              ntStatus;
    LSA_OBJECT_ATTRIBUTES objectAttributes;
	LSA_UNICODE_STRING	  LSAPrivDataDesc;
    TCHAR				  tszPrivDataDesc[MAX_PATH+CCHRADIUSSERVER+1];
	PUNICODE_STRING		  pSystem;
	UNICODE_STRING		  uszSystemName;

	if (IsLocalMachine(pszServerName))
		pSystem = NULL;
	else
	{
		SetUnicodeString(&uszSystemName,
						 pszServerName);
		pSystem = &uszSystemName;
	}
		
    InitializeObjectAttributes(&objectAttributes, NULL, 0, NULL, NULL);

    ntStatus = LsaOpenPolicy(pSystem, &objectAttributes, POLICY_ALL_ACCESS, &hLSA);

    if ( !NT_SUCCESS( ntStatus) ) 
    {
        return( RtlNtStatusToDosError( ntStatus ) );
    }

	ZeroMemory(tszPrivDataDesc, sizeof(tszPrivDataDesc));
    lstrcpy(tszPrivDataDesc, PSZRADIUSSERVER);
	lstrcpyn(tszPrivDataDesc + CCHRADIUSSERVER, pszRadiusServerName, MAX_PATH);
		
    LSAPrivDataDesc.Length = (USHORT)((lstrlen(tszPrivDataDesc) + 1) * sizeof(TCHAR));
    LSAPrivDataDesc.MaximumLength = sizeof(tszPrivDataDesc);
    LSAPrivDataDesc.Buffer = tszPrivDataDesc;

    ntStatus = LsaStorePrivateData(hLSA, &LSAPrivDataDesc, NULL);

    LsaClose(hLSA);

	return( RtlNtStatusToDosError( ntStatus ) );
} 



// Some helper functions

DWORD RtlEncodeW(PUCHAR pucSeed, LPWSTR pswzString)
{
	UNICODE_STRING	ustring;

	ustring.Length = (USHORT)(lstrlenW(pswzString) * sizeof(WCHAR));
	ustring.MaximumLength = ustring.Length;
	ustring.Buffer = pswzString;

	RtlRunEncodeUnicodeString(pucSeed, &ustring);
	return 0;
}

DWORD RtlDecodeW(UCHAR ucSeed, LPWSTR pswzString)
{
	UNICODE_STRING	ustring;

	ustring.Length = (USHORT)(lstrlenW(pswzString) * sizeof(WCHAR));
	ustring.MaximumLength = ustring.Length;
	ustring.Buffer = pswzString;

	RtlRunDecodeUnicodeString(ucSeed, &ustring);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rtrlib.rc
//
#define IDS_DEFAULT_HELP_TOPIC          30000
#define IDS_DEFAULT_TASKPAD_DISPLAY_TITLE 30001
#define IDS_PROTO_NAT_BASIC_FIREWALL    30002

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        210
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         233
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\rtrcomn.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	rtrcomn.cpp
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "tfschar.h"
#include "info.h"
#include "rtrstr.h"
#include "rtrcomn.h"
#include "rtrguid.h"
#include "mprapi.h"
#include "rtrutil.h"
#include "lsa.h"
#include "tregkey.h"
#include "reg.h"


/*---------------------------------------------------------------------------
	Function: IfInterfaceIdHasIpxExtensions

	Checks the string to see if it has the following extensions
		EthernetSNAP
		EthernetII
		Ethernet802.2
		Ethernet802.3
 ---------------------------------------------------------------------------*/
int IfInterfaceIdHasIpxExtensions(LPCTSTR pszIfId)
{
	CString	stIfEnd;
	CString	stIf = pszIfId;
	BOOL	bFound = TRUE;
	int		iPos = 0;

	do
	{
		stIfEnd = stIf.Right(lstrlen(c_szEthernetII));
		if (stIfEnd == c_szEthernetII)
			break;
	
		stIfEnd = stIf.Right(lstrlen(c_szEthernetSNAP));
		if (stIfEnd == c_szEthernetSNAP)
			break;
	
		stIfEnd = stIf.Right(lstrlen(c_szEthernet8022));
		if (stIfEnd == c_szEthernet8022)
			break;
	
		stIfEnd = stIf.Right(lstrlen(c_szEthernet8023));
		if (stIfEnd == c_szEthernet8023)
			break;

		bFound = FALSE;
	}
	while (FALSE);

	if (bFound)
		iPos = stIf.GetLength() - stIfEnd.GetLength();
	
	return iPos;
}

extern const GUID CLSID_RemoteRouterConfig;

HRESULT CoCreateRouterConfig(LPCTSTR pszMachine,
                             IRouterInfo *pRouter,
                             COSERVERINFO *pcsi,
							 const GUID& riid,
							 IUnknown **ppUnk)
{
	HRESULT		hr = hrOK;
	MULTI_QI	qi;

	Assert(ppUnk);

	*ppUnk = NULL;
	
	if (IsLocalMachine(pszMachine))
	{
		hr = CoCreateInstance(CLSID_RemoteRouterConfig,
							  NULL,
							  CLSCTX_SERVER | CLSCTX_ENABLE_CODE_DOWNLOAD,
							  riid,
							  (LPVOID *) &(qi.pItf));
	}
	else
	{
        SPIRouterAdminAccess    spAdmin;
        BOOL                    fAdminInfoSet = FALSE;
        COSERVERINFO            csi;

        Assert(pcsi);
		
		qi.pIID = &riid;
		qi.pItf = NULL;
		qi.hr = 0;

		pcsi->dwReserved1 = 0;
		pcsi->dwReserved2 = 0;
		pcsi->pwszName = (LPWSTR) (LPCTSTR) pszMachine;

        if (pRouter)
        {
            spAdmin.HrQuery(pRouter);
            if (spAdmin && spAdmin->IsAdminInfoSet())
            {
                int     cPassword;
                int     cchPassword;
                WCHAR * pszPassword = NULL;
                UCHAR   ucSeed = 0x83;
                
                pcsi->pAuthInfo->dwAuthnSvc = RPC_C_AUTHN_WINNT;
                pcsi->pAuthInfo->dwAuthzSvc = RPC_C_AUTHZ_NONE;
                pcsi->pAuthInfo->pwszServerPrincName = NULL;
                pcsi->pAuthInfo->dwAuthnLevel = RPC_C_AUTHN_LEVEL_DEFAULT;
                pcsi->pAuthInfo->dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
//                pcsi->pAuthInfo->pAuthIdentityData = &caid;
                pcsi->pAuthInfo->dwCapabilities = EOAC_NONE;

                if (spAdmin->GetUserName())
                {
                    pcsi->pAuthInfo->pAuthIdentityData->User = (LPTSTR) spAdmin->GetUserName();
                    pcsi->pAuthInfo->pAuthIdentityData->UserLength = StrLenW(spAdmin->GetUserName());
                }
                if (spAdmin->GetDomainName())
                {
                    pcsi->pAuthInfo->pAuthIdentityData->Domain = (LPTSTR) spAdmin->GetDomainName();
                    pcsi->pAuthInfo->pAuthIdentityData->DomainLength = StrLenW(spAdmin->GetDomainName());
                }
                spAdmin->GetUserPassword(NULL, &cPassword);

                // Assume that the password is Unicode
                cchPassword = cPassword / sizeof(WCHAR);
                pszPassword = (WCHAR *) new BYTE[cPassword + sizeof(WCHAR)];

                spAdmin->GetUserPassword((PBYTE) pszPassword, &cPassword);
                pszPassword[cchPassword] = 0;
                RtlDecodeW(ucSeed, pszPassword);

                delete pcsi->pAuthInfo->pAuthIdentityData->Password;
                pcsi->pAuthInfo->pAuthIdentityData->Password = pszPassword;
                pcsi->pAuthInfo->pAuthIdentityData->PasswordLength = cchPassword;

                pcsi->pAuthInfo->pAuthIdentityData->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

                fAdminInfoSet = TRUE;
            }
            else
            {
                pcsi->pAuthInfo = NULL;
            }
        }

        
		hr = CoCreateInstanceEx(CLSID_RemoteRouterConfig,
								NULL,
								CLSCTX_SERVER | CLSCTX_ENABLE_CODE_DOWNLOAD,
								pcsi,
								1,
								&qi);

        if (FHrOK(hr) && fAdminInfoSet)
        {
            DWORD   dwAuthnSvc, dwAuthzSvc, dwAuthnLevel, dwImpLevel;
            DWORD   dwCaps;
            OLECHAR * pszServerPrincipal = NULL;
            CComPtr<IUnknown>	spIUnk;

            qi.pItf->QueryInterface(IID_IUnknown, (void**)&spIUnk);
            
            CoQueryProxyBlanket(spIUnk,
                                &dwAuthnSvc,
                                &dwAuthzSvc,
                                &pszServerPrincipal,
                                &dwAuthnLevel,
                                &dwImpLevel,
                                NULL,
                                &dwCaps);
            
            hr = CoSetProxyBlanket(spIUnk,
                                   dwAuthnSvc,
                                   dwAuthzSvc,
                                   pszServerPrincipal,
                                   dwAuthnLevel,
                                   dwImpLevel,
                                   (RPC_AUTH_IDENTITY_HANDLE) pcsi->pAuthInfo->pAuthIdentityData,
                                   dwCaps);

            CoTaskMemFree(pszServerPrincipal);

            pszServerPrincipal = NULL;
            
            CoQueryProxyBlanket(qi.pItf,
                                &dwAuthnSvc,
                                &dwAuthzSvc,
                                &pszServerPrincipal,
                                &dwAuthnLevel,
                                &dwImpLevel,
                                NULL,
                                &dwCaps);
            
            hr = CoSetProxyBlanket(qi.pItf,
                                   dwAuthnSvc,
                                   dwAuthzSvc,
                                   pszServerPrincipal,
                                   dwAuthnLevel,
                                   dwImpLevel,
                                   (RPC_AUTH_IDENTITY_HANDLE) pcsi->pAuthInfo->pAuthIdentityData,
                                   dwCaps);

            CoTaskMemFree(pszServerPrincipal);

        }
	}

	if (FHrSucceeded(hr))
	{
		*ppUnk = qi.pItf;
		qi.pItf = NULL;
	}
	return hr;
}



/*!--------------------------------------------------------------------------
	CoCreateProtocolConfig
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CoCreateProtocolConfig(const GUID& iid,
							  IRouterInfo *pRouter,
							  DWORD dwTransportId,
							  DWORD dwProtocolId,
							  IRouterProtocolConfig **ppConfig)
{
	HRESULT				hr = hrOK;
	GUID				guidConfig;

	guidConfig = iid;

	if (((iid == GUID_RouterNull) ||
		 (iid == GUID_RouterError)) &&
		pRouter)
	{
		RouterVersionInfo	routerVersion;
		
		pRouter->GetRouterVersionInfo(&routerVersion);

		// If we don't have a configuration GUID and this is an NT4
		// router, then we create the default configuration object
		// and use that to add/remove a protocol
		// ------------------------------------------------------------
		if ((routerVersion.dwRouterVersion <= 4) &&
			(dwTransportId == PID_IP))
		{
			// For NT4, we have to create our own object
			// --------------------------------------------------------
			guidConfig = CLSID_IPRouterConfiguration;
		}
	}

	if (guidConfig == GUID_RouterNull)
	{
		// Skip the rest of the creation, we didn't supply a GUID
		// ------------------------------------------------------------
		goto Error;
	}

	if (guidConfig == GUID_RouterError)
	{
		// We don't have a valid GUID
		// ------------------------------------------------------------
		CWRg( ERROR_BADKEY );
	}

	hr = CoCreateInstance(guidConfig,
						  NULL,
						  CLSCTX_INPROC_SERVER | CLSCTX_ENABLE_CODE_DOWNLOAD,
						  IID_IRouterProtocolConfig,
						  (LPVOID *) ppConfig);
	CORg( hr );

Error:
	return hr;
}



//----------------------------------------------------------------------------
// Function:	QueryIpAddressList(
//
// Loads a list of strings with the IP addresses configured
// for a given LAN interface, if any.
//----------------------------------------------------------------------------

HRESULT
QueryIpAddressList(
	IN		LPCTSTR 		pszMachine,
	IN		HKEY			hkeyMachine,
	IN		LPCTSTR 		pszInterface,
	OUT 	CStringList*	pAddressList,
	OUT 	CStringList*	pNetmaskList,
    OUT     BOOL *          pfDhcpObtained,
    OUT     BOOL *          pfDns,
    OUT     CString *       pDhcpServer
	) {

	DWORD dwErr = NO_ERROR;
	BOOL bDisconnect = FALSE;
	RegKey	regkeyMachine;
	RegKey	regkeyInterface;	
	DWORD dwType, dwSize, dwEnableDHCP;
	SPBYTE	spValue;
	HRESULT hr = hrOK;
	HKEY	hkeyInterface;
	INT i;
	TCHAR* psz;
	LPCTSTR aszSources[2];
	CStringList* alistDestinations[2] = { pAddressList, pNetmaskList };
	CString stNameServer;
	LPCTSTR pszNameServer = NULL;
	

	if (!pszInterface || !lstrlen(pszInterface) ||
		!pAddressList || !pNetmaskList)
		CORg(E_INVALIDARG);


	//
	// If no HKEY_LOCAL_MACHINE key was given, get one
	//
	if (hkeyMachine == NULL)
	{
		CWRg( ConnectRegistry(pszMachine, &hkeyMachine) );
		regkeyMachine.Attach(hkeyMachine);
	}

	//
	// Connect to the LAN card's registry key
	//	
	CWRg( OpenTcpipInterfaceParametersKey(pszMachine, pszInterface,
										  hkeyMachine, &hkeyInterface) );
	regkeyInterface.Attach(hkeyInterface);
	
	
	//
	// Read the 'EnableDHCP' flag to see whether to read
	// the 'DhcpIPAddress' or the 'IPAddress'.
	//

	dwErr = regkeyInterface.QueryValue( c_szEnableDHCP, dwEnableDHCP );
	if (dwErr == ERROR_SUCCESS)
	{
		if (pfDhcpObtained)
			*pfDhcpObtained = dwEnableDHCP;
	}
	else
		dwEnableDHCP = FALSE;
        
	
	//
	// If the flag isn't found, we look for the IP address;
	// otherwise, we look for the setting indicated by the flag
	//	
	if (dwErr == ERROR_SUCCESS && dwEnableDHCP)
	{	
		//
		// Read the 'DhcpIpAddress' and 'DhcpSubnetMask'
		//		
		aszSources[0] = c_szDhcpIpAddress;
		aszSources[1] = c_szDhcpSubnetMask;

		pszNameServer = c_szRegValDhcpNameServer;

	}
	else
	{	
		//
		// Read the 'IPAddress' and 'SubnetMask'
		//
		
		aszSources[0] = c_szIPAddress;
		aszSources[1] = c_szSubnetMask;

		pszNameServer= c_szRegValNameServer;
	}

	if (pDhcpServer)
	{
		pDhcpServer->Empty();
		regkeyInterface.QueryValue(c_szRegValDhcpServer, *pDhcpServer);
	}

	
	// Check the DhcpNameServer/NameServer to find the existence
	// of DNS servers
	if (pfDns)
	{
		regkeyInterface.QueryValue(pszNameServer, stNameServer);
		stNameServer.TrimLeft();
		stNameServer.TrimRight();

		*pfDns = !stNameServer.IsEmpty();
	}

    
	//
	// Read the address list and the netmask list
	//
	for (i = 0; i < 2 && dwErr == NO_ERROR; i++)
	{	
		//
		// Get the size of the multi-string-list
		//
		dwErr = regkeyInterface.QueryTypeAndSize(aszSources[i],
			&dwType, &dwSize);
//		CheckRegQueryValueError(dwErr, (LPCTSTR) c_szTcpip, aszSources[i], _T("QueryIpAddressList"));
		CWRg( dwErr );

		//
		// Allocate space for the list
		//		
		spValue = new BYTE[dwSize + sizeof(TCHAR)];
		Assert(spValue);
		
		::ZeroMemory(spValue, dwSize + sizeof(TCHAR));
				
		//
		// Read the list
		//
		dwErr = regkeyInterface.QueryValue(aszSources[i], (LPTSTR) (BYTE *)spValue, dwSize,
										   FALSE /* fExpandSz */);
//		CheckRegQueryValueError(dwErr, (LPCTSTR) c_szTcpip, aszSources[i], _T("QueryIpAddressList"));
		CWRg( dwErr );
		
		//
		// Fill the CString list with items
		//
		
		for (psz = (TCHAR*)(BYTE *)spValue; *psz; psz += lstrlen(psz) + 1)
		{	
			alistDestinations[i]->AddTail(psz);
		}
		
		spValue.Free();
		
		dwErr = NO_ERROR;
	}
	
Error:
	return hr;
}



/*!--------------------------------------------------------------------------
	OpenTcpipInterfaceParametersKey
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD OpenTcpipInterfaceParametersKey(LPCTSTR pszMachine,
									  LPCTSTR pszInterface,
									  HKEY hkeyMachine,
									  HKEY *phkeyParams)
{
	DWORD	dwErr;
	BOOL	fNt4;
	CString skey;


	dwErr = IsNT4Machine(hkeyMachine, &fNt4);
	if (dwErr != ERROR_SUCCESS)
		return dwErr;
	
	//$NT5 : kennt, the tcpip key is stored separately.  What they
	// have done is to reverse the hierarchy, instead of a tcpip key
	// under interfaces, there are now interfaces under tcpip
	// the key location is
	// HKLM\System\CCS\Services\Tcpip\Parameters\Interfaces\{interface}
	// In NT4, this was
	// HKLM\System\CCS\Services\{interface}\Parameters\Tcpip
		
	// Need to determine if the target machine is running NT5 or not
	if (fNt4)
	{
		skey = c_szSystemCCSServices;
		skey += TEXT('\\');
		skey += pszInterface;
		skey += TEXT('\\');
		skey += c_szParameters;
		skey += TEXT('\\');
		skey += c_szTcpip;
	}
	else
	{
		skey = c_szSystemCCSServices;
		skey += TEXT('\\');
		skey += c_szTcpip;
		skey += TEXT('\\');
		skey += c_szParameters;
		skey += TEXT('\\');
		skey += c_szInterfaces;
		skey += TEXT('\\');
		skey += pszInterface;
		
	}

	if (dwErr == ERROR_SUCCESS)
	{		
		dwErr = ::RegOpenKeyEx(
					hkeyMachine, skey, 0, KEY_ALL_ACCESS, phkeyParams); 
//		CheckRegOpenError(dwErr, (LPCTSTR) skey, _T("OpenTcpInterfaceParametersKey"));
	}
	return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\rtrerr.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	rtrerr.h
		Miscellaneous common router UI.
		
    FILE HISTORY:
        
*/


#ifndef _RTRERR_H
#define _RTRERR_H



/*!--------------------------------------------------------------------------
	HandleIRemoteRouterConfigErrors
		This function will setup the error code to deal with errors
		with creating the IRemoteRouterConfig object.

		Returns TRUE if the error code was handled.  Returns FALSE
		if the error code passed in was an unknown error code.

		Deals with:
			REGDB_E_CLASSNOTREG
			REGDB_E_IIDNOTREG
			E_NOINTERFACE

			S_OK
			
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL HandleIRemoteRouterConfigErrors(HRESULT hr, LPCTSTR pszMachineName);



/*!--------------------------------------------------------------------------
	FormatRasError
		Use this to get back an error string from a RAS error code.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT FormatRasError(HRESULT hr, TCHAR *pszBuffer, UINT cchBuffer);
void AddRasErrorMessage(HRESULT hr);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\rtrcomn.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
	rtrcomn.h
		Miscellaneous common router UI.
		
    FILE HISTORY:
        
*/


#ifndef _RTRCOMN_H
#define _RTRCOMN_H



//----------------------------------------------------------------------------
//	Function:	IfInterfaceIdHasIpxExtensions
//
//	Checks the id to see if it has the following extensions
//		EthernetSNAP
//		EthernetII
//		Ethernet802.2
//		Ethernet802.3
// These are frame types used by IPX.
//
//	Returns the position of the extension in the string (or 0) if not found.
//  If an ID has this extension at position 0, then it's not one of our
//	special IPX extensions.
//----------------------------------------------------------------------------
int IfInterfaceIdHasIpxExtensions(LPCTSTR pszIfId);

HRESULT CoCreateRouterConfig(LPCTSTR pszMachine,
                             IRouterInfo *pRouter,
                             COSERVERINFO *pcsi,
                             const GUID& riid,
                             IUnknown **ppUnk);

/*!--------------------------------------------------------------------------
	CoCreateProtocolConfig
		This will CoCreate the routing config object (given the GUID).
		If the machine is an NT4 machine, then we use the default
		configuration object.
	Author: KennT
 ---------------------------------------------------------------------------*/
interface IRouterProtocolConfig;
HRESULT CoCreateProtocolConfig(const IID& iid,
							   IRouterInfo *pRouter,
							   DWORD dwTransportId,
							   DWORD dwProtocolId,
							   IRouterProtocolConfig **ppConfig);


//----------------------------------------------------------------------------
// Function:    QueryIpAddressList(
//
// Loads a list of strings with the IP addresses configured
// for a given LAN interface, if any.
//----------------------------------------------------------------------------

HRESULT
QueryIpAddressList(
				   LPCTSTR      pszMachine,
				   HKEY         hkeyMachine,
				   LPCTSTR      pszInterface,
				   CStringList *pAddressList,
				   CStringList* pNetmaskList,
                   BOOL *       pfDhcpObtained = NULL,
                   BOOL *       pfDns = NULL,
                   CString *    pDhcpServer = NULL
				  );


DWORD OpenTcpipInterfaceParametersKey(LPCTSTR pszMachine,
									  LPCTSTR pszInterface,
									  HKEY hkeyMachine,
									  HKEY *phkeyParams);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\rtrres.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       rtrres.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rtrlib.rc
//
#define IDS_UNKNOWN						4000
#define IDS_IFTYPE_CLIENT				4001
#define IDS_IFTYPE_HOMEROUTER			4002
#define IDS_IFTYPE_FULLROUTER			4003
#define IDS_IFTYPE_DEDICATED			4004
#define IDS_IFTYPE_INTERNAL				4005
#define IDS_IFTYPE_LOOPBACK				4006
#define IDS_IFTYPE_UNKNOWN				4007
#define IDS_CONNSTATE_CONNECTED			4008
#define IDS_CONNSTATE_CONNECTING		4009
#define IDS_CONNSTATE_DISCONNECTED		4010
#define IDS_CONNSTATE_UNREACHABLE		4011
#define IDS_CONNSTATE_UNKNOWN			4012
#define IDS_STATUS_ENABLED				4013
#define IDS_STATUS_DISABLED				4014
#define IDS_STATUS_UNKNOWN				4015
#define IDS_ADMIN_STATUS_UP				4016
#define IDS_ADMIN_STATUS_DOWN			4017
#define IDS_ADMIN_STATUS_TESTING		4018
#define IDS_ADMIN_STATUS_UNKNOWN		4019
#define IDS_OPER_STATUS_NON_OPERATIONAL	4020
#define IDS_OPER_STATUS_UNREACHABLE		4021
#define IDS_OPER_STATUS_DISCONNECTED	4022
#define IDS_OPER_STATUS_CONNECTING		4023
#define IDS_OPER_STATUS_CONNECTED		4024
#define IDS_OPER_STATUS_OPERATIONAL		4025
#define IDS_OPER_STATUS_UNKNOWN			4026
#define IDS_ENABLED						4027
#define IDS_DISABLED					4028
#define IDS_SELECT_INTERFACE			4029
#define IDS_ADD_INTERFACES				4030
#define IDS_CLICK_RMINTERFACE			4031
#define IDS_SELECT_INTERFACE_FOR		4032
#define IDS_CLICK_RPINTERFACE			4033
#define IDS_SELECT_PROTOCOL				4034
#define IDS_ADD_PROTOCOL				4035
#define IDS_CLICK_PROTOCOL				4036
#define IDS_IFTYPE_TUNNEL1				4037
#define IDS_NO_INDEX_NAME_MATCH         4038
#define IDS_MENU_SEPARATOR              4039    // special identifier

#define IDS_ERR_UNREACH_NOT_LOADED		4300
#define IDS_ERR_UNREACH_NO_PORTS		4301
#define IDS_ERR_UNREACH_ADMIN_DISABLED	4302
#define IDS_ERR_UNREACH_CONNECT_FAILURE 4303
#define IDS_ERR_UNREACH_SERVICE_PAUSED	4304
#define IDS_ERR_UNREACH_NOT_RUNNING		4305
#define IDS_ERR_UNREACH_UNKNOWN			4306
#define IDS_ERR_NOINTERFACES			4307
#define IDS_ERR_NOROUTINGPROTOCOLS		4308
#define IDS_WARN_ADD_PROTOCOL_CONFLICT	4309
#define IDS_ERR_UNABLE_TO_REMOVE_PROTOCOL	4310
#define IDS_ERR_BAD_CLASSREG			4311
#define IDS_ERR_BAD_CLASSREG_GEEK		4312
#define IDS_ERR_BAD_INTERFACE			4313
#define IDS_ERR_BAD_INTERFACE_GEEK		4314
#define IDS_ERR_UNREACH_NO_MEDIA_SENSE  4315
#define IDS_ERR_UNREACH_DIALOUT_HOURS_RESTRICTION 4316
#define IDS_WARN_PROTOCOL_ALREADY_INSTALLED 4317

// Miscellaneous icons and such start at 4600-4649
#define IDI_RTRLIB_CHECK				4600
#define IDI_RTRLIB_UNCHECK				4601
#define IDI_RTRLIB_PROTOCOL				4602
#define IDB_RTRLIB_IMAGELIST			4603
#define IDI_RTRLIB_LAN                  4604
#define IDI_RTRLIB_WAN                  4605

// Dialogs start at 4650-4699
#define IDD_ADD							4650
#define IDD_DUMMY_PROP_PAGE					4651

// Controls start at 4700-4999
#define IDC_ADD_LIST					4700
#define IDC_ADD_TEXT_PROMPT				4701
#define IDC_ADD_TEXT_TITLE				4702
//efine IDC_ADD_ICON					4703

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        210
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         233
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\rtrsheet.cpp ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    rtrsheet.cpp
//
// History:
//  06/19/96    Abolade Gbadegesin      Created.
//
// Implementation of IP configuration dialogs.
//============================================================================

#include "stdafx.h"

#include "mprapi.h"
#include "rtrsheet.h"
#include "rtrui.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif




//----------------------------------------------------------------------------
// Class:   RtrPropertySheet
//
//----------------------------------------------------------------------------

RtrPropertySheet::RtrPropertySheet(
					  ITFSNode *	pNode,
					  IComponentData *pComponentData,
					  ITFSComponentData *pTFSCompData,
					  LPCTSTR		pszSheetName,
					  CWnd*         pParent,
					  UINT          iPage,
					  BOOL			fScopePane)
	: CPropertyPageHolderBase(pNode, pComponentData, pszSheetName, fScopePane),
	m_fCancel(FALSE)
{
	//if this is not done, deadlock can happen
	EnablePeekMessageDuringNotifyConsole(TRUE);

	Assert(pTFSCompData);
	m_spTFSCompData.Set(pTFSCompData);
}

/*!--------------------------------------------------------------------------
	RtrPropertySheet::OnPropertyChange
		This operation occurs on the main thread.  This function is called
		in response to an Apply operation on a property sheet.

	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL RtrPropertySheet::OnPropertyChange(BOOL bScopePane, LONG_PTR* pChangeMask)
{
	BOOL	bReturn = FALSE;
	// This means that all of the dirty pages have finished saving
	// their data, now we can go ahead and save the sheet data
	//
	// Because we have gotten here means that at least one page must
	// have been dirty, so go ahead and save the data (otherwise we would
	// never have gotten here).
	//
	if (m_cDirty == 1)
	{
		if (m_fCancel)
		{
			CancelSheetData();
			bReturn = TRUE;
		}
		else
			bReturn = SaveSheetData();			
	}

	BOOL	fPageReturn = CPropertyPageHolderBase::OnPropertyChange(
		bScopePane, pChangeMask);

	return bReturn && fPageReturn;
}




//----------------------------------------------------------------------------
// Class:   RtrPropertyPage
//
//----------------------------------------------------------------------------

IMPLEMENT_DYNAMIC(RtrPropertyPage, CPropertyPageBase)


RtrPropertyPage::~RtrPropertyPage()
{
    if (m_hIcon)
    {
        DestroyIcon(m_hIcon);
    }
}


/*!--------------------------------------------------------------------------
	RtrPropertyPage::SetDirty
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void RtrPropertyPage::SetDirty(BOOL bDirty)
{
	// Set the property sheet to be dirty
	// But change the dirty count only if we are toggling the flag
	if (GetHolder() && (bDirty != IsDirty()))
	{		
		GetHolder()->IncrementDirty(bDirty ? 1 : -1);
	}
	CPropertyPageBase::SetDirty(bDirty);
}


void RtrPropertyPage::OnCancel()
{
	// We need to notify the property sheet of this
	((RtrPropertySheet *)GetHolder())->SetCancelFlag(TRUE);

	// Give the property sheet a chance to do something
	OnApply();
	
	CPropertyPageBase::OnCancel();

	((RtrPropertySheet *)GetHolder())->SetCancelFlag(FALSE);
}

void RtrPropertyPage::ValidateSpinRange(CSpinButtonCtrl *pSpin)
{
	int		iPos, iLow, iHigh;

	Assert(pSpin);

	iPos = pSpin->GetPos();
	if (HIWORD(iPos))
	{
		pSpin->GetRange(iLow, iHigh);
		iPos = iLow;
		pSpin->SetPos(iPos);
	}
}

BOOL RtrPropertyPage::OnApply()
{
    BOOL fReturn = CPropertyPageBase::OnApply();
    SetDirty(FALSE);
    return fReturn;
}


void RtrPropertyPage::CancelApply()
{
    CPropertyPageBase::CancelApply();
    SetDirty(FALSE);
}


void RtrPropertyPage::InitializeInterfaceIcon(UINT idcIcon, DWORD dwType)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    UINT    uIcon = IsWanInterface(dwType) ? IDI_RTRLIB_WAN : IDI_RTRLIB_LAN;

    if (m_hIcon)
    {
        DestroyIcon(m_hIcon);
        m_hIcon = NULL;
    }
    m_hIcon = AfxGetApp()->LoadIcon(MAKEINTRESOURCE(uIcon));

    if (m_hIcon && GetDlgItem(idcIcon))
        ((CStatic *) GetDlgItem(idcIcon))->SetIcon(m_hIcon);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\rtrerr.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	rtrerr.cpp
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "tfschar.h"
#include "tfsres.h"
#include "info.h"
#include "errutil.h"
#include "rtrerr.h"
#include "mprapi.h"
#include "mprerror.h"
#include "raserror.h"

#define IS_WIN32_HRESULT(x)	(((x) & 0xFFFF0000) == 0x80070000)
#define WIN32_FROM_HRESULT(hr)		(0x0000FFFF & (hr))



/*!--------------------------------------------------------------------------
	HandleIRemoteRouterConfigErrors
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL HandleIRemoteRouterConfigErrors(HRESULT hr, LPCTSTR pszMachineName)
{
	BOOL	fReturn = FALSE;

	if (FHrSucceeded(hr))
		return TRUE;
	
	if ((hr == REGDB_E_CLASSNOTREG) ||
		(hr == REGDB_E_IIDNOTREG))
	{
		CString	st, stGeek;
		// This error indicates that we could not find the server
		// on the remote machine.  This means that it could be a
		// down-level machine or the setup is messed up.
		AfxFormatString1(st, IDS_ERR_BAD_INTERFACE,
						 pszMachineName);
		AfxFormatString1(stGeek, IDS_ERR_BAD_INTERFACE_GEEK,
						 pszMachineName);
		
		AddStringErrorMessage2(hr, st, stGeek);
		
		fReturn = TRUE;
	}
	else if (hr == E_NOINTERFACE)
	{
		// These errors indicate that there was an installation
		// problem (this IID, probably rrasprxy.dll, should have
		// been registered).
		CString	st, stGeek;

		AfxFormatString1(st, IDS_ERR_BAD_CLASSREG,
						 pszMachineName);
		AfxFormatString1(stGeek, IDS_ERR_BAD_CLASSREG_GEEK,
						 pszMachineName);
		AddStringErrorMessage2(hr, st, stGeek);
		
		fReturn = TRUE;
	}

	return fReturn;
}

HRESULT FormatRasError(HRESULT hr, TCHAR *pszBuffer, UINT cchBuffer)
{
	HRESULT	hrReturn = hrFalse;
	
	// Copy over default message into szBuffer
	_tcscpy(pszBuffer, _T("Error"));

	// Ok, we can't get the error info, so try to format it
	// using the FormatMessage
		
	// Ignore the return message, if this call fails then I don't
	// know what to do.

	if (IS_WIN32_HRESULT(hr))
	{
		DWORD	dwErr;

		dwErr = WIN32_FROM_HRESULT(hr);

		if (((dwErr >= ROUTEBASE) && (dwErr <= ROUTEBASEEND)) ||
			((dwErr >= RASBASE) && (dwErr <= RASBASEEND)))
		{
			WCHAR *	pswzErr;
			
			if ( ::MprAdminGetErrorString(dwErr, &pswzErr) == NO_ERROR ) {
				StrnCpyTFromW(pszBuffer, pswzErr, cchBuffer);
				::MprAdminBufferFree(pswzErr);
				hrReturn = hrOK;
			}
		}
	}

	if (!FHrOK(hrReturn))
	{
		// If we didn't get any error info, try again
		FormatError(hr, pszBuffer, cchBuffer);
	}

	return hrReturn;
}

void AddRasErrorMessage(HRESULT hr)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	if (!FHrSucceeded(hr))
	{
		TCHAR	szBuffer[4096];
		CString	st, stHr;

		FormatRasError(hr, szBuffer, DimensionOf(szBuffer));
		stHr.Format(_T("%08lx"), hr);

		AfxFormatString2(st, IDS_ERROR_SYSTEM_ERROR_FORMAT,
						 szBuffer, (LPCTSTR) stHr);

		FillTFSError(0, hr, FILLTFSERR_LOW, NULL, (LPCTSTR) st, NULL);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\rtrlib.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       rtrlib.h
//
//--------------------------------------------------------------------------


#ifndef _RTRLIB_H
#define _RTRLIB_H



//----------------------------------------------------------------------------
// Macro:       DWORD_CMP
//
// Performs a 'safe' comparison of two 32-bit DWORDs, using subtraction.
// The values are first shifted right to clear the sign-bit, and then
// if the resulting values are equal, the difference between the lowest bits
// is returned.
//----------------------------------------------------------------------------

//#define DWORD_CMP(a,b,c) \
//    (((c) = (((a)>>1) - ((b)>>1))) ? (c) : ((c) = (((a)&1) - ((b)&1))))


inline int DWORD_CMP(DWORD a, DWORD b)
{
	DWORD t = ((a >> 1) - (b >> 1));
	return t ? t : ((a & 1) - (b & 1));
}


HRESULT	AddRoutingProtocol(IRtrMgrInfo *pRm, IRtrMgrProtocolInfo *pRmProt, HWND hWnd);


#endif	// _RTRLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\rtrstr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       rtrstr.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"

#include "rtrstr.h"
#define _RTRLIB_STRINGS_DEFINE_STRINGS
#include "rtrstr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\rtrsheet.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:    rtrsheet.h
//
// History:
//  08/04/97		Kenn M. Takara		Created.
//
//	Router property sheet common code.
//============================================================================

#ifndef _RTRSHEET_H_
#define _RTRSHEET_H_



//----------------------------------------------------------------------------
// Class:   RtrPropertySheet
//
// This class is used by property sheets in the router administration tool.
// It is intended to host pages derived from RtrPropertyPage (below).
//
// This is derived from CPropertyPageHolderBase.  Sheets derived
// from this class allow their creators to specify a callback
// to be invoked when certain events occur, such as closing the sheet or
// applying changes.
// 
// It also allows its contained pages to accumulate their changes in memory
// when the user selects "Apply"; the changes are then saved together,
// rather than having each page save its own changes.
// Note that this increases the performance of the router UI, which uses RPC
// to save its information; using this class results in a single RPC call
// to save changes, rather than separate calls from each of the pages.
//----------------------------------------------------------------------------

class RtrPropertySheet : public CPropertyPageHolderBase
{

public:

	//-------------------------------------------------------------------
	// Constructors
	//
	//-------------------------------------------------------------------

	RtrPropertySheet( ITFSNode *	pNode,
					  IComponentData *pComponentData,
					  ITFSComponentData *pTFSCompData,
					  LPCTSTR		pszSheetName,
					  CWnd*         pParent = NULL,
					  UINT          iPage = 0,
					  BOOL			fScopePane = FALSE);

	// --------------------------------------------------------
	// Function: PressButton
	//
	// This function is identical to the CPropertySheet::PressButton
	//
	// --------------------------------------------------------
	BOOL PressButton(int nButton)
	{
		Assert(::IsWindow(GetSheetWindow()));
		return (BOOL) ::PostMessage(GetSheetWindow(), PSM_PRESSBUTTON, nButton, 0);
	}


	// --------------------------------------------------------
	// Function:	OnPropertyChange
	//
	// This is the code that gets executed on the main thread
	// by the property sheet in order to make changes to the data.
	//
	// We will call the ApplyAll() function (which is implemented
	// by the derived classes) and then call the base class to
	// then save the page itself.
	// --------------------------------------------------------
	virtual BOOL OnPropertyChange(BOOL bScopePane, LONG_PTR* pChangeMask);

	
	// --------------------------------------------------------
	// Function:	SaveSheetData
	//
	// This function should be overridden by the user.  This is
	// the function that gets called AFTER ApplySheetData() has
	// been called on all of the pages.
	// --------------------------------------------------------
	virtual BOOL SaveSheetData()
	{
		return TRUE;
	}


	virtual void CancelSheetData()
	{
	};


	void SetCancelFlag(BOOL fCancel)
	{
		m_fCancel = fCancel;
	}

	BOOL IsCancel()
	{
		return m_fCancel;
	}

protected:
	SPITFSComponentData	m_spTFSCompData;
	BOOL				m_fCancel;
};



//----------------------------------------------------------------------------
// Class:   RtrPropertyPage
//
// This class is used for property-pages in the router administration tool.
// It is intended to be contained by a RtrPropertySheet-derived object.
//
// This class supports the ability for the RtrPropertySheet to do
// the actual apply (to save on RPCs we batch the Apply into one function
// at the sheet level rather than the page level).  The page does
// this by setting the sheet to be dirty when the page itself is marked
// dirty.  The actual code to save the global data in the PropertySheet
// is done by the RtrPropertySheet.
//
// When an apply is performed, the RtrPropertySheet calls "ApplySheetData"
// on each of the pages.  The pages will then save their data and the
// property sheet will then save this global data.
//----------------------------------------------------------------------------

class RtrPropertyPage : public CPropertyPageBase
{
	DECLARE_DYNAMIC(RtrPropertyPage);
public:

	//-------------------------------------------------------------------
	// Constructors
	//
	//-------------------------------------------------------------------

	RtrPropertyPage(
					UINT                nIDTemplate,
					UINT                nIDCaption = 0
		) : CPropertyPageBase(nIDTemplate, nIDCaption),
        m_hIcon(NULL)
	{ 
	}
    virtual ~RtrPropertyPage();

	virtual void OnCancel();


	//-------------------------------------------------------------------
	// Function:    Cancel
	//
	// Called to cancel the sheet.
	//-------------------------------------------------------------------
	
	virtual VOID Cancel()
	{
		((RtrPropertySheet*)GetHolder())->PressButton(PSBTN_CANCEL);
	}


	// --------------------------------------------------------
	// Function:	SetDirty
	//
	// Override the default implementation to forward the SetDirty()
	// call to the property sheet so that the property sheet can
	// save global data.
	// --------------------------------------------------------
	
	virtual void SetDirty(BOOL bDirty);


	// ----------------------------------------------------------------
	// Function:	ValidateSpinRange
	//
	// Checks and corrects a spin control that goes out of range.
	// This function will reset the spin control to its lower
	// value if it finds it to be out-of-range.
	// ----------------------------------------------------------------
	void	ValidateSpinRange(CSpinButtonCtrl *pSpin);

    // ----------------------------------------------------------------
    // Function :   OnApply
    //
    // We override this so that we can clear the dirty flag.
    // ----------------------------------------------------------------
    virtual BOOL OnApply();
    virtual void CancelApply();


    // ----------------------------------------------------------------
    // Function :   InitializeInterfaceIcon
    //
    // Use this function to specialize the icon.
    // ----------------------------------------------------------------
    void    InitializeInterfaceIcon(UINT idcIcon, DWORD dwType);

protected:

    HICON   m_hIcon;
};




#endif // _RTRSHEET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\rtrstr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       rtrstr.h
//
//--------------------------------------------------------------------------


#undef RTRLIB_STRING
#undef RTRLIB_STRINGA
#undef RTRLIB_STRINGW

#ifdef _RTRLIB_STRINGS_DEFINE_STRINGS

	#define RTRLIB_STRING(rg,s)	const TCHAR rg[] = TEXT(s);
	#define RTRLIB_STRINGA(rg,s) const char rg[] = s;
	#define RTRLIB_STRINGW(rg,s)	const WCHAR rg[] = s;

#else

	#define RTRLIB_STRING(rg,s)	extern const TCHAR rg[];
	#define RTRLIB_STRINGA(rg,s) extern const char rg[];
	#define RTRLIB_STRINGW(rg,s)	extern const WCHAR rg[];

#endif

RTRLIB_STRING(c_szDhcpIpAddress,	"DhcpIpAddress")
RTRLIB_STRING(c_szDhcpSubnetMask,	"DhcpSubnetMask")
RTRLIB_STRING(c_szEmpty,			"")
RTRLIB_STRING(c_szEnableDHCP,		"EnableDHCP")
RTRLIB_STRING(c_szEthernetII,		"/EthII")
RTRLIB_STRING(c_szEthernetSNAP,		"/SNAP")
RTRLIB_STRING(c_szEthernet8022,		"/802.2")
RTRLIB_STRING(c_szEthernet8023,		"/802.3")
RTRLIB_STRING(c_szHexCharacters,	"0123456789ABCDEF")
RTRLIB_STRING(c_szInterfaceName,		"InterfaceName")
RTRLIB_STRING(c_szInterfaces,		"Interfaces")
RTRLIB_STRING(c_szIPAddress,		"IPAddress")
RTRLIB_STRING(c_szParameters,		"Parameters")
RTRLIB_STRING(c_szRegValDhcpNameServer, "DhcpNameServer")
RTRLIB_STRING(c_szRegValDhcpServer, "DhcpServer")
RTRLIB_STRING(c_szRegValNameServer, "NameServer")
RTRLIB_STRING(c_szRouterInterfacesKey, "SYSTEM\\CurrentControlSet\\Services\\Router\\Interfaces")
RTRLIB_STRING(c_szSharedAccessService,  "SharedAccess")
RTRLIB_STRING(c_szSubnetMask,		"SubnetMask")
RTRLIB_STRING(c_szSystemCCSServices, "SYSTEM\\CurrentControlSet\\Services")
RTRLIB_STRING(c_szTcpip,			"Tcpip")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\rtrui.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	rtrui.h
		Miscellaneous common router UI.
		
    FILE HISTORY:
        
*/


#ifndef _RTRUI_H
#define _RTRUI_H



//----------------------------------------------------------------------------
// Function:    AddRmInterfacePrompt
//
// Prompts the user to select from a list of the interfaces on which
// a specified router-manager can be enabled.
//
// Returns TRUE if the user selects an interface, FALSE otherwise.
//
// If the user selects an interface, then on output 'ppRmInterfaceInfo'
// will contain a pointer to a 'CRmInterfaceInfo' describing the interface
// selected by the user.
//
// Requires common.rc.
//----------------------------------------------------------------------------

BOOL
AddRmInterfacePrompt(
					 IRouterInfo *	pRouterInfo,
					 IRtrMgrInfo *	pRtrMgrInfo,
					 IRtrMgrInterfaceInfo **ppRtrMgrInterfaceInfo,
					 CWnd *			pParent);

//----------------------------------------------------------------------------
// Function:    AddRmProtInterfacePrompt
//
// Prompts the user to select from a list of the interfaces on which
// a specified routing-protocol can be enabled.
//
// Returns TRUE if the user selects an interface, FALSE otherwise.
//
// If the user selects an interface, then on output 'ppRmInterfaceInfo'
// will contain a pointer to a 'CRmInterfaceInfo' describing the interface
// selected by the user.
//
// Requires common.rc.
//----------------------------------------------------------------------------

BOOL
AddRmProtInterfacePrompt(
    IN  IRouterInfo*            pRouterInfo,
    IN  IRtrMgrProtocolInfo*            pRmProtInfo,
    OUT IRtrMgrProtocolInterfaceInfo**  ppRmProtInterfaceInfo,
    IN  CWnd*                   pParent             = NULL );


//----------------------------------------------------------------------------
// Function:    AddProtocolPrompt
//
// Prompts the user to select from a list of the routing-protocols
// which can be installed for the specified transport.
//
// Returns TRUE if the user selects a routing-protocol, FALSE otherwise.
//
// If the user selects a protocol, then on output 'ppRmProtInfo' will contain
// a pointer to an 'CRmProtInfo' describing the protocol selected by the user.
//
// Requires common.rc.
//----------------------------------------------------------------------------

BOOL
AddProtocolPrompt(
	IN	IRouterInfo *			pRouter,
    IN  IRtrMgrInfo*            pRmInfo,
    OUT IRtrMgrProtocolInfo**   ppRmProtInfo,
    IN  CWnd*                   pParent             = NULL );




//----------------------------------------------------------------------------
// Function:    CreateRtrLibImageList
//
// Creates an imagelist containing images from the resource
//		'IDB_RTRLIB_IMAGELIST'.
//----------------------------------------------------------------------------

BOOL
CreateRtrLibImageList(
    IN  CImageList* imageList
    );

//
// Indices of images in shared bitmap 'images.bmp'
//

enum RTRLIB_IMAGELISTINDEX {
	ILI_RTRLIB_NETCARD         = 0,
	ILI_RTRLIB_PROTOCOL        = 1,
    ILI_RTRLIB_SERVER          = 2,
    ILI_RTRLIB_CLIENT          = 3,
    ILI_RTRLIB_UNKNOWN         = 4,
    ILI_RTRLIB_WINFLAG         = 5,
    ILI_RTRLIB_BOB             = 6,
    ILI_RTRLIB_DISABLED        = 7,
    ILI_RTRLIB_PRINTER         = 8,
    ILI_RTRLIB_PRINTSERVICE    = 9,
    ILI_RTRLIB_PARTLYDISABLED  = 10,
    ILI_RTRLIB_NETCARD_0       = 11,
    ILI_RTRLIB_SERVER_0        = 12,
    ILI_RTRLIB_CLIENT_0        = 13,
    ILI_RTRLIB_FOLDER          = 14,
    ILI_RTRLIB_FOLDER_0        = 15,
    ILI_RTRLIB_MODEM           = 16
};

#define PROTO_FROM_PROTOCOL_ID(pid)	((pid) & 0xF000FFFF )


/*---------------------------------------------------------------------------
	Function : IsWanInterface

	Returns TRUE if the interface type passed in is for a WAN interface.

	WAN interfaces are interfaces that are NOT
		ROUTER_IF_TYPE_INTERNAL
		ROUTER_IF_TYPE_DEDICATED
		ROUTER_IF_TYPE_LOOPBACK
        ROUTER_IF_TYPE_TUNNEL1
 ---------------------------------------------------------------------------*/
#define IsWanInterface(type)	((type != ROUTER_IF_TYPE_INTERNAL) && \
								(type != ROUTER_IF_TYPE_DEDICATED) && \
								(type != ROUTER_IF_TYPE_LOOPBACK) && \
								(type != ROUTER_IF_TYPE_TUNNEL1))


/*---------------------------------------------------------------------------
	Function : IsDedicatedInterface

	Returns TRUE if the interface type passed in is a dedicated interface.

	Dedicated interfaces are of type
		ROUTER_IF_TYPE_INTERNAL
		ROUTER_IF_TYPE_DEDICATED
		ROUTER_IF_TYPE_LOOPBACK
		ROUTER_IF_TYPE_TUNNEL1
 ---------------------------------------------------------------------------*/
#define IsDedicatedInterface(type)	((type == ROUTER_IF_TYPE_INTERNAL) || \
									(type == ROUTER_IF_TYPE_LOOPBACK) || \
									(type == ROUTER_IF_TYPE_TUNNEL1) || \
									(type == ROUTER_IF_TYPE_DEDICATED) )


BOOL ExtractComputerAddedAsLocal(LPDATAOBJECT lpDataObject);


/*---------------------------------------------------------------------------
	Function:   NatConflictExists

    Returns TRUE if SharedAccess is already running on the specified
    machine.
 ---------------------------------------------------------------------------*/
BOOL NatConflictExists(LPCTSTR lpszMachine);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\stdafx.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	stdafx.h
		include file for standard system include files,
		or project specific include files that are used frequently,
		but are changed infrequently

    FILE HISTORY:
        
*/

#include <afxwin.h>
#include <afxdisp.h>
#include <afxcmn.h>
#include <afxtempl.h>

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#include <mmc.h>

extern LPCWSTR g_lpszNullString;

extern enum FOLDER_TYPES;

// New Clipboard format that has the Type and Cookie
extern const wchar_t*   SNAPIN_INTERNAL;

#include "tfschar.h"
#include "snapbase.h"
#include "resource.h"
#include "rtrres.h"

#include "router.h"
#include "info.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\rtrui.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	rtrui.cpp
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "tfschar.h"
#include "info.h"
#include "rtrui.h"
#include "add.h"		// dialogs
#include "rtrstr.h"
#include "tregkey.h"
#include "reg.h"        // Connect/DisconnectRegistry

//----------------------------------------------------------------------------
// Function:    AddRmInterfacePrompt
//
// Prompts the user to select from a list of the interfaces on which
// a specified router-manager can be enabled.
//
// Returns TRUE if the user selects an interface, FALSE otherwise.
//
// If the user selects an interface, then on output 'ppRmInterfaceInfo'
// will contain a pointer to a 'CRmInterfaceInfo' describing the interface
// selected by the user.
//----------------------------------------------------------------------------

BOOL
AddRmInterfacePrompt(
    IN      IRouterInfo*            pRouterInfo,
    IN      IRtrMgrInfo*                pRmInfo,
    OUT     IRtrMgrInterfaceInfo**      ppRmInterfaceInfo,
    IN      CWnd*                   pParent
    ) {

    //
    // Construct and display the interfaces dialog.
    //

    CRmAddInterface dlg(pRouterInfo, pRmInfo, ppRmInterfaceInfo, pParent);

    if (dlg.DoModal() != IDOK) { return FALSE; }

    return TRUE;
}


//----------------------------------------------------------------------------
// Function:    CreateRtrLibImageList
//
// Creates an imagelist containing images from the resource 'IDB_IMAGELIST'.
//----------------------------------------------------------------------------

BOOL
CreateRtrLibImageList(
    IN  CImageList* imageList
    ) {

    return imageList->Create(
                MAKEINTRESOURCE(IDB_RTRLIB_IMAGELIST), 16, 0, PALETTEINDEX(6)
                );
}


//----------------------------------------------------------------------------
// Function:    AddRmProtInterfacePrompt
//
// Prompts the user to select from a list of the interfaces on which
// a specified routing-protocol can be enabled.
//
// Returns TRUE if the user selects an interface, FALSE otherwise.
//
// If the user selects an interface, then on output 'ppRmInterfaceInfo'
// will contain a pointer to a 'CRmInterfaceInfo' describing the interface
// selected by the user.
//
// Requires common.rc.
//----------------------------------------------------------------------------

BOOL
AddRmProtInterfacePrompt(
    IN  IRouterInfo*            pRouterInfo,
    IN  IRtrMgrProtocolInfo*            pRmProtInfo,
    OUT IRtrMgrProtocolInterfaceInfo**  ppRmProtInterfaceInfo,
    IN  CWnd*                   pParent)
{

    //
    // Construct and display the interfaces dialog.
    //

    CRpAddInterface dlg(pRouterInfo, pRmProtInfo, ppRmProtInterfaceInfo, pParent);

    if (dlg.DoModal() != IDOK) { return FALSE; }

    return TRUE;
}


BOOL
AddProtocolPrompt(IN IRouterInfo *pRouter,
				  IN IRtrMgrInfo *pRm,
				  IN IRtrMgrProtocolInfo **ppRmProt,
				  IN CWnd *pParent)
{

    //
    // Construct and display the routing-protocol dialog.
    //

    CAddRoutingProtocol dlg(pRouter, pRm, ppRmProt, pParent);

    if (dlg.DoModal() != IDOK) { return FALSE; }

    return TRUE;
}



static unsigned int	s_cfComputerAddedAsLocal = RegisterClipboardFormat(L"MMC_MPRSNAP_COMPUTERADDEDASLOCAL");

BOOL ExtractComputerAddedAsLocal(LPDATAOBJECT lpDataObject)
{
    BOOL    fReturn = FALSE;
    BOOL *  pReturn;
    pReturn = Extract<BOOL>(lpDataObject, (CLIPFORMAT) s_cfComputerAddedAsLocal, -1);
    if (pReturn)
    {
        fReturn = *pReturn;
        GlobalFree(pReturn);
    }

    return fReturn;
}


/*!--------------------------------------------------------------------------
	NatConflictExists
		Returns TRUE if SharedAccess is already running on the specified
        machine.
	Author: AboladeG
 ---------------------------------------------------------------------------*/
BOOL NatConflictExists(LPCTSTR lpszMachine)
{
    SC_HANDLE hScm;
    SC_HANDLE hSharedAccess;
    BOOL fReturn  = FALSE;
    SERVICE_STATUS serviceStatus;

    hScm = OpenSCManager(lpszMachine, SERVICES_ACTIVE_DATABASE, GENERIC_READ);
    
    if (hScm)
    {
        hSharedAccess = OpenService(hScm, c_szSharedAccessService, GENERIC_READ);
        
        if (hSharedAccess)
        {
            if (QueryServiceStatus(hSharedAccess, &serviceStatus))
            {
                if (SERVICE_RUNNING == serviceStatus.dwCurrentState
                    || SERVICE_START_PENDING == serviceStatus.dwCurrentState)
                {
                    fReturn = TRUE;
                }
            }
            
            CloseServiceHandle(hSharedAccess);
        }

        CloseServiceHandle(hScm);
    }

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\strmap.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       strmap.h
//
//--------------------------------------------------------------------------



#ifndef _STRMAP_H
#define _STRMAP_H


CString&	InterfaceTypeToCString(DWORD dwType);
CString&	ConnectionStateToCString(DWORD dwConnState);
CString&	StatusToCString(DWORD dwStatus);

CString&	AdminStatusToCString(DWORD dwStatus);
CString&	OperStatusToCString(DWORD dwStatus);

CString&	EnabledDisabledToCString(BOOL fEnabled);

CString&	GetUnreachReasonCString(UINT ids);


/*---------------------------------------------------------------------------
	Function:	MapDWORDToCString

	This is a generic DWORD-to-CString mapping function.
 ---------------------------------------------------------------------------*/

struct CStringMapEntry
{
	DWORD		dwType;		// -1 is a sentinel value
	CString *	pst;
	ULONG		ulStringId;
};
CString&	MapDWORDToCString(DWORD dwType, const CStringMapEntry *pMap);

#endif	// _STRMAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\sheet.cpp ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    sheet.cpp
//
// History:
//  Abolade-Gbadegesin  April-17-1996   Created.
//
// Contains implementation of modeless-capable property sheet class.
//============================================================================

#include "stdafx.h"
#include "sheet.h"
#include "dialog.h"   // for FixupIpAddressHelp

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CPropertySheetEx_Mine, CPropertySheet)

BEGIN_MESSAGE_MAP(CPropertySheetEx_Mine, CPropertySheet)
    //{{AFX_MSG_MAP(CPropertySheetEx_Mine)
    //}}AFX_MSG_MAP
    ON_WM_HELPINFO()
END_MESSAGE_MAP()


static int g_piButtons[] = { IDOK, IDCANCEL, ID_APPLY_NOW, IDHELP };


//----------------------------------------------------------------------------
// Function:    CPropertySheetEx_Mine::DestroyWindow
//
// Called to destroy a modeless property-sheet.
// If 'm_bDllInvoked' is TRUE, the function destroys the sheet in the context
// of the DLL's 'CAdminThread', since the sheet will have been created
// in that thread's context, and 'DestroyWindow' only works in the context
// of the thread which created the window being destroyed.
//----------------------------------------------------------------------------

BOOL
CPropertySheetEx_Mine::DestroyWindow(
    ) {

    BOOL bRet = FALSE;


    if (!m_bDllInvoked) {

        bRet = CPropertySheet::DestroyWindow();
    }
    else {
		Panic0("huh?");
    }

    return bRet;
}




//----------------------------------------------------------------------------
// Function:    CPropertySheetEx_Mine::DoModeless
//
// Called to display a modeless property-sheet.
// If 'bDllInvoked' is TRUE, the function creates the sheet in the context
// of the DLL's  'CAdminThread', to ensure that 'PreTranslateMessage'
// is called for the property-sheet.
//----------------------------------------------------------------------------

BOOL
CPropertySheetEx_Mine::DoModeless(
    IN  CWnd*       pParent,
    IN  BOOL        bDllInvoked
    ) {

    BOOL bRet = FALSE;

    if (!bDllInvoked) {

        //
        // We aren't in a DLL, so create the sheet
        // in the context of the caller's thread.
        //

        m_bDllInvoked = FALSE;

        bRet = Create(
                    pParent, DS_MODALFRAME|DS_3DLOOK|DS_CONTEXTHELP|WS_POPUP|
                    WS_VISIBLE|WS_CAPTION
                    );
    }
    else {
		Panic0("huh?");
    }

    return bRet;
}



//----------------------------------------------------------------------------
// Function:    CPropertySheetEx_Mine::OnInitDialog
//
// Handles initialization for an extended property sheet.
// This re-enables and re-displays the OK, Cancel, Apply and Help buttons
// which are hidden by default for modeless sheets.
//----------------------------------------------------------------------------

BOOL
CPropertySheetEx_Mine::OnInitDialog(
    ) {

    //
    // Save the absolute position of the sheet and the "OK" button
    // for the repair work we will do when the base version returns.
    // Also save the enabled/disabled state of the buttons
    //

    CRect rectWndOld;
    GetWindowRect(rectWndOld);

    CRect rectButton;
    HWND hwnd = ::GetDlgItem(m_hWnd, IDOK);
    ::GetWindowRect(hwnd, rectButton);


    //
    // Enable the Context sensitive help style for the 
    // property sheet
    //

    LONG style = ::GetWindowLong(m_hWnd, GWL_EXSTYLE);
    style |= WS_EX_CONTEXTHELP;
    ::SetWindowLong(m_hWnd, GWL_EXSTYLE, style);

    //
    // save the enabled/disabled state of the buttons
    //

    BOOL pfEnabled[sizeof(g_piButtons)/sizeof(int)];

    for (INT i = 0; i < sizeof(pfEnabled)/sizeof(BOOL); i++) {

        hwnd = ::GetDlgItem(m_hWnd, g_piButtons[i]);

        if (::IsWindow(hwnd)) { pfEnabled[i] = ::IsWindowEnabled(hwnd); }
    }


    //
    // invoke the base class property-sheet initialization
    //

    BOOL bResult = CPropertySheet::OnInitDialog();


    //
    // now if the sheet is modeless, undo the damage done
    // by the base class OnInitDialog. In particular, enable and unhide
    // the buttons OK, Cancel, Apply, and Help.
    // See dlgprop.cpp for the offending MFC code.
    //

    if (!m_bSheetModal && !(m_psh.dwFlags & PSH_WIZARD)) {

        //
        // resize the property-sheet window so that there is space
        // at the bottom for the buttons; we do this by adding back
        // the height of the area between the top of the OK button
        // and the original bottom of the property sheet
        //

        CRect rectWndNew;
        GetWindowRect(rectWndNew);

        SetWindowPos(
            NULL, 0, 0, rectWndNew.Width(), rectWndNew.Height() +
            rectWndOld.bottom - rectButton.top, SWP_NOMOVE | SWP_NOZORDER |
            SWP_NOACTIVATE
            );


        //
        // now restore the enable/disabled state of the buttons and show them
        //

        for (INT i = 0; i < sizeof(g_piButtons)/sizeof(int); i++) {

            if (g_piButtons[i] == IDHELP)
                { if (!(m_psh.dwFlags & PSH_HASHELP)) { continue; } }

            hwnd = ::GetDlgItem(m_hWnd, g_piButtons[i]);

            if (::IsWindow(hwnd)) {
                ::EnableWindow(hwnd, pfEnabled[i]);
                ::ShowWindow(hwnd, SW_SHOW);
            }
        }
    }

    return bResult;
}




//----------------------------------------------------------------------------
// Function:    CPropertySheetEx_Mine::PreTranslateMessage
//
// Augments the window procedure for modeless property-sheets
// with a check to see whether the sheet should be destroyed.
//----------------------------------------------------------------------------

BOOL
CPropertySheetEx_Mine::PreTranslateMessage(
    MSG*    pmsg
    ) {

    //
    // Call the base version of PreTranslateMessage
    //

//    TRACE(TEXT("CPropertySheetEx_Mine::PreTranslateMessage\n"));

    BOOL bresult = CPropertySheet::PreTranslateMessage(pmsg);


    //
    // If the window is modeless, see if its time to destroy the window;
    // when it is, PropSheet_GetCurrentPageHwnd returns NULL
    //

    if (!m_bSheetModal && !PropSheet_GetCurrentPageHwnd(m_hWnd)) {
        DestroyWindow(); bresult = TRUE;
    }

    return bresult;
}

//----------------------------------------------------------------------------
// Function:    CPropertySheetEx_Mine::OnHelpInfo
//
// 
// This is called by MFC in response to WM_HELP message. 
// This function calls the AfxGetApp->WinHelp with the help ID corresponding
// to the control or menu.
//
// MFC calls the window which received the WM_HELP message with the LPARAM
// pointing to a HELPINFO structure. This HELPINFO structure has enought context
// info to give us the control ID that needs the context help. 
//----------------------------------------------------------------------------

BOOL CPropertySheetEx_Mine::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if (pHelpInfo->iContextType == HELPINFO_WINDOW)
	{
		HWND	hItem = (HWND) pHelpInfo->hItemHandle;

		// Check for the case that we're looking for help in an IP
		// address control
//		hItem = FixupIpAddressHelp((HWND) pHelpInfo->hItemHandle);

		// If the help we're looking for is a different control, update
		// the control id also.
//		if (hItem != pHelpInfo->hItemHandle)
//			pHelpInfo->iCtrlId = ::GetDlgCtrlID(hItem);
		
        // for all dialog controls
//        AfxGetApp()->WinHelp(HID_BASE_CONTROL + pHelpInfo->iCtrlId, HELP_CONTEXTPOPUP);
    }
    else {
        // this is for menus
//        AfxGetApp()->WinHelp(HID_BASE_COMMAND + pHelpInfo->iCtrlId);
    }
    return TRUE;
}

//----------------------------------------------------------------------------
// Class:   CRtrSheet
//
//----------------------------------------------------------------------------

IMPLEMENT_DYNAMIC(CRtrSheet, CPropertySheetEx_Mine)


//----------------------------------------------------------------------------
// Class:   CRtrPage
//
//----------------------------------------------------------------------------

IMPLEMENT_DYNAMIC(CRtrPage, CPropertyPage)

BEGIN_MESSAGE_MAP(CRtrPage, CPropertyPage)
    ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
END_MESSAGE_MAP()


/*!--------------------------------------------------------------------------
	CRtrPage::OnHelpInfo
		Brings up the context-sensitive help for the controls.
	Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL CRtrPage::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	int		i;
	DWORD	dwCtrlId;

    if (pHelpInfo->iContextType == HELPINFO_WINDOW)
	{
		DWORD * pdwHelp = GetHelpMapInternal();

        if (pdwHelp)
        {
		    // Ok to fix the f**king help for the f**king IP address
		    // controls, we will need to add special case code.  If we
		    // can't find the id of our control in our list, then we look
		    // to see if this is the child of the "RtrIpAddress" control, if
		    // so then we change the pHelpInfo->hItemHandle to point to the
		    // handle of the ip address control rather than the control in
		    // the ip addrss control.  *SIGH*
		    dwCtrlId = ::GetDlgCtrlID((HWND) pHelpInfo->hItemHandle);
		    for (i=0; pdwHelp[i]; i+=2)
		    {
			    if (pdwHelp[i] == dwCtrlId)
				    break;
		    }

		    if (pdwHelp[i] == 0)
		    {
			    // Ok, we didn't find the control in our list, so let's
			    // check to see if it's part of the IP address control.
			    pHelpInfo->hItemHandle = FixupIpAddressHelp((HWND) pHelpInfo->hItemHandle);
		    }

            ::WinHelp ((HWND)pHelpInfo->hItemHandle,
			           AfxGetApp()->m_pszHelpFilePath,
			           HELP_WM_HELP,
			           (ULONG_PTR)pdwHelp);
        }
	}
	
	return TRUE;
}


/*!--------------------------------------------------------------------------
	CRtrPage::OnContextMenu
		Brings up the help context menu for those controls that don't
		usually have context menus (i.e. buttons).  Note that this won't
		work for static controls since they just eat up all messages.
	Author: KennT
 ---------------------------------------------------------------------------*/
void CRtrPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	DWORD * pdwHelp = GetHelpMapInternal();

    if (pdwHelp)
    {
        ::WinHelp (pWnd->m_hWnd,
		           AfxGetApp()->m_pszHelpFilePath,
		           HELP_CONTEXTMENU,
		           (ULONG_PTR)pdwHelp);
    }
}


// This can be found in dialog.cpp
extern PFN_FINDHELPMAP	g_pfnHelpMap;


DWORD * CRtrPage::GetHelpMapInternal()
{
	DWORD	*	pdwHelpMap = NULL;
	DWORD		dwIDD = 0;

	if ((ULONG_PTR) m_lpszTemplateName < 0xFFFF)
		dwIDD = (WORD) m_lpszTemplateName;
	
	// If there is no dialog IDD, give up
	// If there is no global help map function, give up
	if ((dwIDD == 0) ||
		(g_pfnHelpMap == NULL) ||
		((pdwHelpMap = g_pfnHelpMap(dwIDD)) == NULL))
		return GetHelpMap();

	return pdwHelpMap;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\sheet.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    sheet.h
//
// History:
//  Abolade Gbadegesin  April-17-1996   Created.
//
// This file contains declarations for the CPropertySheetEx_Mine class,
// which is based on CPropertySheet and supports modal or modeless display.
//============================================================================


#ifndef _SHEET_H_
#define _SHEET_H_


//----------------------------------------------------------------------------
// Class:   CPropertySheetEx_Mine
//----------------------------------------------------------------------------

class CPropertySheetEx_Mine : public CPropertySheet {

        DECLARE_DYNAMIC(CPropertySheetEx_Mine)

    public:

        //-------------------------------------------------------------------
        // Constructors
        //
        //-------------------------------------------------------------------

        CPropertySheetEx_Mine(
            UINT                nIDCaption,
            CWnd*               pParent         = NULL,
            UINT                iPage           = 0
            ) : CPropertySheet(nIDCaption, pParent, iPage),
				m_bSheetModal(FALSE),
                m_bDllInvoked(FALSE) 
        { 
           m_psh.dwFlags &= ~(PSH_HASHELP);
        }

        CPropertySheetEx_Mine(
            LPCTSTR             pszCaption,
            CWnd*               pParent         = NULL,
            UINT                iPage           = 0
            ) : CPropertySheet(pszCaption, pParent, iPage),
				m_bSheetModal(FALSE),
                m_bDllInvoked(FALSE)
        { 
           m_psh.dwFlags &= ~(PSH_HASHELP);
        }

        CPropertySheetEx_Mine(
            ) : m_bDllInvoked(FALSE),
				m_bSheetModal(FALSE)
        { 
           m_psh.dwFlags &= ~(PSH_HASHELP);
        }

        //-------------------------------------------------------------------
        // Function:    DestroyWindow
        //
        // Checks whether the sheet was invoked modeless from a DLL, 
        // and if so tells the admin-thread to destroy the sheet.
        // This is necessary since DestroyWindow can only be invoked
        // from the context of the thread which created the window.
        //-------------------------------------------------------------------

        virtual BOOL
        DestroyWindow( );

        
        //-------------------------------------------------------------------
        // Function:   OnHelpInfo
        //
        // This is called by MFC in response to WM_HELP message
        //  
        //
        //-------------------------------------------------------------------

        afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);

        //-------------------------------------------------------------------
        // Function:    DoModeless
        //
        // Invoked to show the modeless property sheet
        //-------------------------------------------------------------------

        BOOL
        DoModeless(
            CWnd*               pParent         = NULL,
            BOOL                bDllInvoked     = FALSE );



        //-------------------------------------------------------------------
        // Function:    OnInitDialog
        //
        // Invokes the base OnInitDialog and then if DoModeless was called,
        // shows the buttons OK, Cancel, Apply, and Help which are hidden
        // in the default CPropertySheet::OnInitDialog
        //-------------------------------------------------------------------

        virtual BOOL
        OnInitDialog( );



        //-------------------------------------------------------------------
        // Function:    PostNcDestroy
        //
        // Destroys the sheet's object if modeless
        //-------------------------------------------------------------------

        virtual void
        PostNcDestroy( ) {

            CPropertySheet::PostNcDestroy();

            if (!m_bSheetModal) { delete this; }
        }


        //-------------------------------------------------------------------
        // Function:    PreTranslateMessage
        //
        // Replacement for CPropertySheet::PreTranslateMessage;
        // handles destruction of the sheet when it is modeless.
        //-------------------------------------------------------------------

        virtual BOOL
        PreTranslateMessage(
            MSG*                pmsg );


    protected:


		// This is set to TRUE if we are calling this through DoModal().
		// We can't use the m_bModeless variable due to the Wiz97 changes.
		BOOL				m_bSheetModal;

        BOOL                    m_bDllInvoked;

        DECLARE_MESSAGE_MAP()
};




//----------------------------------------------------------------------------
// Type:    PFNROUTERUICALLBACK
//
// Defines the callback function used by the CRtrPropertySheet class.
//----------------------------------------------------------------------------

typedef VOID
(CALLBACK* PFNROUTERUICALLBACK)(
    IN  HWND    hwndSheet,
    IN  VOID*   pCallbackData,
    IN  UINT    uiCode
    );



//----------------------------------------------------------------------------
// Definitions of the callback codes passed by the CRtrPropertySheet class.
//----------------------------------------------------------------------------

#define RTRUI_Close         1
#define RTRUI_Apply         2
#define RTRUI_Changed       3
#define RTRUI_Unchanged     4





//----------------------------------------------------------------------------
// Class:   CRtrSheet
//
// This class is used by property sheets in the router administration tool.
// It is intended to host pages derived from CRtrPropertyPage (below).
//
// It is an enhanced version of CPropertySheetEx_Mine; sheets derived
// from this class allow their creators to specify a callback
// to be invoked when certain events occur, such as closing the sheet or
// applying changes.
// 
// It also allows its contained pages to accumulate their changes in memory
// when the user selects "Apply"; the changes are then saved together,
// rather than having each page save its own changes.
// Note that this increases the performance of the router UI, which uses RPC
// to save its information; using this class results in a single RPC call
// to save changes, rather than separate calls from each of the pages.
//----------------------------------------------------------------------------

class CRtrSheet : public CPropertySheetEx_Mine {

        DECLARE_DYNAMIC(CRtrSheet)

    public:

        //-------------------------------------------------------------------
        // Constructors
        //
        //-------------------------------------------------------------------

        CRtrSheet(
            PFNROUTERUICALLBACK pfnCallback,
            VOID*               pCallbackData,
            UINT                nIDCaption,
            CWnd*               pParent = NULL,
            UINT                iPage = 0
            ) : CPropertySheetEx_Mine(nIDCaption, pParent, iPage),
                m_pfnCallback(pfnCallback),
                m_pCallbackData(pCallbackData) { }

        CRtrSheet(
            PFNROUTERUICALLBACK pfnCallback,
            VOID*               pCallbackData,
            LPCTSTR             pszCaption,
            CWnd*               pParent = NULL,
            UINT                iPage = 0
            ) : CPropertySheetEx_Mine(pszCaption, pParent, iPage),
                m_pfnCallback(pfnCallback),
                m_pCallbackData(pCallbackData) { }

        CRtrSheet( 
            ) : m_pfnCallback(NULL),
                m_pCallbackData(NULL) { }

        //-------------------------------------------------------------------
        // Function:    Cancel
        //
        // Called to cancel the sheet.
        //-------------------------------------------------------------------

        virtual VOID
        Cancel(
            ) {

            if (!m_bSheetModal) { PressButton(PSBTN_CANCEL); }
            else { EndDialog(IDCANCEL); }
        }


        //-------------------------------------------------------------------
        // Function:    Callback
        //
        // Called by contained pages to notify the sheet-owner of events
        //-------------------------------------------------------------------

        virtual VOID
        Callback(
            UINT                uiMsg
            ) {

            if (m_pfnCallback) {
                m_pfnCallback(m_hWnd, m_pCallbackData, uiMsg);
            }
        }



        //-------------------------------------------------------------------
        // Function:    DoModal
        //
        // Invoked to show a modal property sheet.
        //
        // We remove the 'Apply' button so that the page only gets applied
        // when the user hits OK.
        //
        // In addition, in order to avoid an MFC bug, lock the handle-map
        // for the caller's module. The bug surfaces when idle-processing
        // in MFC deletes the dialog's top-level parent from the temporary
        // handle-map, causing an assertion to fail as soon as the dialog
        // is dismissed.
        //-------------------------------------------------------------------

        virtual INT_PTR
        DoModal(
            ) {

			m_bSheetModal = TRUE;
            m_psh.dwFlags |= PSH_NOAPPLYNOW;
            m_psh.dwFlags &= ~(PSH_HASHELP);

            AfxLockTempMaps();

            INT_PTR ret = CPropertySheet::DoModal();

            AfxUnlockTempMaps();

			m_bSheetModal = FALSE;

            return ret;
        }


        //-------------------------------------------------------------------
        // Function:    ApplyAll
        //
        // This should be overridden to call the "Apply" method of each of
        // the sheet's pages, collecting information, and then saving all
        // changes at once.
        //-------------------------------------------------------------------

        virtual BOOL
        ApplyAll( ) { return TRUE; }


        //-------------------------------------------------------------------
        // Function:    PostNcDestroy
        //
        // notifies the UI framework that the sheet is being destroyed
        //-------------------------------------------------------------------

        virtual void
        PostNcDestroy( ) {

            Callback(RTRUI_Close);

            CPropertySheetEx_Mine::PostNcDestroy();
        }

    protected:

        PFNROUTERUICALLBACK m_pfnCallback;
        VOID*               m_pCallbackData;
};



//----------------------------------------------------------------------------
// Class:   CRtrPage
//
// This class is used for property-pages in the router administration tool.
// It is intended to be contained by a CRtrSheet-derived object.
//
// In addition to the behavior defined by CPropertyPage, this class
// adds the ability to have a page accumulate its changes with those of
// other pages in a sheet, and have the sheet save the collected changes.
//
// This is accomplished below by overriding "CPropertyPage::OnApply"
// to call the parent-sheet's "CRtrSheet::ApplyAll" if the page
// is the first page (i.e. the page with index 0).
//
// The parent's "ApplyAll" should then call the "CRtrSheet::Apply"
// methods for each of the pages in the sheet, passing them a sheet-specific
// pointer into which changes are to be collected. The parent then saves
// the information for all of the pages.
//
// CRtrPage-derived objects can also notify the creator of the sheet
// of events, by calling the "CRtrSheet::Callback" method.
//----------------------------------------------------------------------------

class CRtrPage : public CPropertyPage
{
    DECLARE_DYNAMIC(CRtrPage)

public:

    //-------------------------------------------------------------------
    // Constructors
    //
    //-------------------------------------------------------------------
        
    CRtrPage(
             LPCTSTR             lpszTemplate,
             UINT                nIDCaption = 0
            ) : CPropertyPage(lpszTemplate, nIDCaption) 
    { 
        m_psp.dwFlags &= ~(PSP_HASHELP);
    }
    CRtrPage(
             UINT                nIDTemplate,
             UINT                nIDCaption = 0
            ) : CPropertyPage(nIDTemplate, nIDCaption)
    { 
        m_psp.dwFlags &= ~(PSP_HASHELP);
    }


    //-------------------------------------------------------------------
    // Function:    Cancel
    //
    // Called to cancel the sheet.
    //-------------------------------------------------------------------
    
    virtual VOID
            Cancel(
                  ) {
        
        ((CRtrSheet*)GetParent())->Cancel();
    }
    
    //-------------------------------------------------------------------
    // Function:    OnApply
    //
    // Called by the MFC propsheet-proc when user clicks Apply;
    // the active page calls the pages' parent (CPropertySheet)
    // and the parent invokes the Apply method for each of its pages.
    //-------------------------------------------------------------------
    
    virtual BOOL
            OnApply( )
    {
        
        if (((CRtrSheet *)GetParent())->GetActiveIndex() !=
            ((CRtrSheet *)GetParent())->GetPageIndex(this))
        {
            
            return TRUE;
        }
        else
        {    
            return ((CRtrSheet *)GetParent())->ApplyAll();
        }
    }

    
    //-------------------------------------------------------------------
    // Function:    Apply
    //
    // called by the page's parent (CRtrSheet) to apply changes
    //-------------------------------------------------------------------
    
    virtual BOOL
            Apply(
                  VOID*               pArg
                 ) {
        
        return TRUE;
    }
    
    
    //-------------------------------------------------------------------
    // Function:    Callback
    //
    // notifies the UI framework of an event
    //-------------------------------------------------------------------
    
    virtual void
            Callback(
                     UINT                uiMsg ) {
        
        ((CRtrSheet *)GetParent())->Callback(uiMsg);
    }
    
    // help messages
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    

protected:
    // Use this call to get the actual help map
	// this version will check the global help map first.
	DWORD *		GetHelpMapInternal();
	
    // override this to return the pointer to the help map
    virtual LPDWORD GetHelpMap() { return NULL; }

    DECLARE_MESSAGE_MAP()

};



#endif // _SHEET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\ustringp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ndisutil.cpp
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "ustringp.h"



//-------------------------------------------------------------------
// Function:    SetUnicodeString
//
// Purpose:     given a UNICODE_STRING initialize it to the given WSTR
//
// Parameters:
//      pustr - the UNICODE_STRING to initialize
//      psz - the WSTR to use to initialize the UNICODE_STRING
//
// Notes:  This differs from the RtlInitUnicodeString in that the
//      MaximumLength value contains the terminating null
//
//-------------------------------------------------------------------
void
SetUnicodeString (
        IN OUT UNICODE_STRING*  pustr,
        IN     LPCWSTR          psz )
{
    AssertSz( pustr != NULL, "Invalid Argument" );
    AssertSz( psz != NULL, "Invalid Argument" );

    pustr->Buffer = const_cast<PWSTR>(psz);
    pustr->Length = (USHORT)(lstrlenW(pustr->Buffer) * sizeof(WCHAR));
    pustr->MaximumLength = pustr->Length + sizeof(WCHAR);
}

//-------------------------------------------------------------------
// Function:    SetUnicodeMultiString
//
// Purpose:     given a UNICODE_STRING initialize it to the given WSTR
//              multi string buffer
//
// Parameters:
//      pustr - the UNICODE_STRING to initialize
//      pmsz - the multi sz WSTR to use to initialize the UNICODE_STRING
//
//-------------------------------------------------------------------
void
SetUnicodeMultiString (
        IN OUT UNICODE_STRING*  pustr,
        IN     LPCWSTR          pmsz )
{
    AssertSz( pustr != NULL, "Invalid Argument" );
    AssertSz( pmsz != NULL, "Invalid Argument" );

    pustr->Buffer = const_cast<PWSTR>(pmsz);
	// Note: Length does NOT include terminating NULL
    pustr->Length = (USHORT)(StrLenW(pustr->Buffer) * sizeof(WCHAR));         
    pustr->MaximumLength = pustr->Length;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\strmap.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       strmap.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "mprapi.h"
#include "ipifcons.h"	// MIB constants

#include "strmap.h"

static	CString	s_stUnknown;

static	CString	s_stIfTypeClient;
static	CString s_stIfTypeHomeRouter;
static	CString	s_stIfTypeFullRouter;
static	CString s_stIfTypeDedicated;
static	CString	s_stIfTypeInternal;
static	CString s_stIfTypeUnknown;
static	CString s_stIfTypeLoopback;
static	CString s_stIfTypeTunnel1;

static	CString	s_stConnStateConnected;
static	CString	s_stConnStateConnecting;
static	CString s_stConnStateDisconnected;
static	CString	s_stConnStateUnreachable;
static	CString s_stConnStateUnknown;

static	CString	s_stStatusEnabled;
static	CString	s_stStatusDisabled;
static	CString	s_stStatusUnknown;

static	CString	s_stUnreachNotLoaded;
static	CString	s_stUnreachNoPorts;
static	CString	s_stUnreachAdminDisabled;
static	CString	s_stUnreachConnectFailure;
static	CString	s_stUnreachServicePaused;
static	CString	s_stUnreachNotRunning;
static  CString s_stUnreachNoMediaSense;
static  CString s_stUnreachDialoutHoursRestriction;
static	CString	s_stUnreachUnknown;

static	CString	s_stAdminStatusUp;
static	CString	s_stAdminStatusDown;
static	CString	s_stAdminStatusTesting;
static	CString	s_stAdminStatusUnknown;

static	CString	s_stOperStatusNonOperational;
static	CString	s_stOperStatusUnreachable;
static	CString	s_stOperStatusDisconnected;
static	CString	s_stOperStatusConnecting;
static	CString	s_stOperStatusConnected;
static	CString	s_stOperStatusOperational;
static	CString	s_stOperStatusUnknown;

static	CString	s_stEnabled;
static	CString	s_stDisabled;



const CStringMapEntry IfTypeMap[] =
	{
	{ ROUTER_IF_TYPE_CLIENT,	&s_stIfTypeClient, IDS_IFTYPE_CLIENT },
	{ ROUTER_IF_TYPE_HOME_ROUTER, &s_stIfTypeHomeRouter, IDS_IFTYPE_HOMEROUTER },
	{ ROUTER_IF_TYPE_FULL_ROUTER, &s_stIfTypeFullRouter, IDS_IFTYPE_FULLROUTER },
	{ ROUTER_IF_TYPE_DEDICATED, &s_stIfTypeDedicated, IDS_IFTYPE_DEDICATED },
	{ ROUTER_IF_TYPE_INTERNAL, &s_stIfTypeInternal, IDS_IFTYPE_INTERNAL },
	{ ROUTER_IF_TYPE_LOOPBACK, &s_stIfTypeLoopback, IDS_IFTYPE_LOOPBACK },
	{ ROUTER_IF_TYPE_TUNNEL1, &s_stIfTypeTunnel1, IDS_IFTYPE_TUNNEL1 },
	{ -1, &s_stIfTypeUnknown, IDS_IFTYPE_UNKNOWN },
	};

const CStringMapEntry ConnStateMap[] =
	{
	{ ROUTER_IF_STATE_CONNECTED, &s_stConnStateConnected, IDS_CONNSTATE_CONNECTED },
	{ ROUTER_IF_STATE_CONNECTING, &s_stConnStateConnecting, IDS_CONNSTATE_CONNECTING },
	{ ROUTER_IF_STATE_DISCONNECTED, &s_stConnStateDisconnected, IDS_CONNSTATE_DISCONNECTED },
	{ ROUTER_IF_STATE_UNREACHABLE, &s_stConnStateUnreachable, IDS_CONNSTATE_UNREACHABLE },
	{ -1, &s_stConnStateUnknown, IDS_CONNSTATE_UNKNOWN },
	};

const CStringMapEntry StatusMap[] =
	{
	{ TRUE, &s_stStatusEnabled, IDS_STATUS_ENABLED },
	{ FALSE, &s_stStatusDisabled, IDS_STATUS_DISABLED },
	{ -1, &s_stStatusUnknown, IDS_STATUS_UNKNOWN },
	};

const CStringMapEntry UnreachMap[] =
	{
	{ IDS_ERR_UNREACH_NOT_LOADED, &s_stUnreachNotLoaded, IDS_ERR_UNREACH_NOT_LOADED },
	{ IDS_ERR_UNREACH_NO_PORTS, &s_stUnreachNoPorts, IDS_ERR_UNREACH_NO_PORTS } ,
	{ IDS_ERR_UNREACH_ADMIN_DISABLED, &s_stUnreachAdminDisabled, IDS_ERR_UNREACH_ADMIN_DISABLED },
	{ IDS_ERR_UNREACH_CONNECT_FAILURE, &s_stUnreachConnectFailure, IDS_ERR_UNREACH_CONNECT_FAILURE },
	{ IDS_ERR_UNREACH_SERVICE_PAUSED, &s_stUnreachServicePaused, IDS_ERR_UNREACH_SERVICE_PAUSED },
	{ IDS_ERR_UNREACH_NOT_RUNNING, &s_stUnreachNotRunning, IDS_ERR_UNREACH_NOT_RUNNING },
    { IDS_ERR_UNREACH_NO_MEDIA_SENSE, &s_stUnreachNoMediaSense, IDS_ERR_UNREACH_NO_MEDIA_SENSE },
    { IDS_ERR_UNREACH_DIALOUT_HOURS_RESTRICTION, &s_stUnreachDialoutHoursRestriction, IDS_ERR_UNREACH_DIALOUT_HOURS_RESTRICTION },
	{ -1, &s_stUnreachUnknown, IDS_ERR_UNREACH_UNKNOWN },
	};


const CStringMapEntry AdminStatusMap[] =
	{
	{ MIB_IF_ADMIN_STATUS_UP, &s_stAdminStatusUp, IDS_ADMIN_STATUS_UP },
	{ MIB_IF_ADMIN_STATUS_DOWN, &s_stAdminStatusDown, IDS_ADMIN_STATUS_DOWN },
	{ MIB_IF_ADMIN_STATUS_TESTING, &s_stAdminStatusTesting, IDS_ADMIN_STATUS_TESTING },
	{ -1, &s_stAdminStatusUnknown, IDS_ADMIN_STATUS_UNKNOWN },
	};

const CStringMapEntry OperStatusMap[] =
	{
	{ MIB_IF_OPER_STATUS_NON_OPERATIONAL, &s_stOperStatusNonOperational, IDS_OPER_STATUS_NON_OPERATIONAL },
	{ MIB_IF_OPER_STATUS_UNREACHABLE, &s_stOperStatusUnreachable, IDS_OPER_STATUS_UNREACHABLE },
	{ MIB_IF_OPER_STATUS_DISCONNECTED, &s_stOperStatusDisconnected, IDS_OPER_STATUS_DISCONNECTED },
	{ MIB_IF_OPER_STATUS_CONNECTING, &s_stOperStatusConnecting, IDS_OPER_STATUS_CONNECTING },
	{ MIB_IF_OPER_STATUS_CONNECTED, &s_stOperStatusConnected, IDS_OPER_STATUS_CONNECTED },
	{ MIB_IF_OPER_STATUS_OPERATIONAL, &s_stOperStatusOperational, IDS_OPER_STATUS_OPERATIONAL },
	{ -1, &s_stOperStatusUnknown, IDS_OPER_STATUS_UNKNOWN },
	};

const CStringMapEntry EnabledDisabledMap[] =
	{
	{ TRUE, &s_stEnabled, IDS_ENABLED },
	{ FALSE, &s_stDisabled, IDS_DISABLED },
	{ -1, &s_stUnknown, IDS_UNKNOWN },
	};

/*!--------------------------------------------------------------------------
	MapDWORDToCString
		Generic mapping of a DWORD to a CString.
	Author: KennT
 ---------------------------------------------------------------------------*/
CString& MapDWORDToCString(DWORD dwType, const CStringMapEntry *pMap)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	const CStringMapEntry	*pEntry = pMap;

	for (; pEntry->dwType != -1; pEntry++)
	{
		if (pEntry->dwType == dwType)
			break;
	}
	if (pEntry->pst->IsEmpty())
		Verify(pEntry->pst->LoadString(pEntry->ulStringId));
	return (*(pEntry->pst));
}

CString& InterfaceTypeToCString(DWORD dwType)
{
	return MapDWORDToCString(dwType, IfTypeMap);
}

CString& ConnectionStateToCString(DWORD dwConnState)
{
	return MapDWORDToCString(dwConnState, ConnStateMap);
}

CString& StatusToCString(DWORD dwStatus)
{
	return MapDWORDToCString(dwStatus, StatusMap);
}

CString& GetUnreachReasonCString(UINT ids)
{
	return MapDWORDToCString(ids, UnreachMap);
}

CString& AdminStatusToCString(DWORD dwStatus)
{
	return MapDWORDToCString(dwStatus, AdminStatusMap);
}

CString& OperStatusToCString(DWORD dwStatus)
{
	return MapDWORDToCString(dwStatus, OperStatusMap);
}

CString& EnabledDisabledToCString(BOOL fEnabled)
{
	return MapDWORDToCString(fEnabled, EnabledDisabledMap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\rtrlib\ustringp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ustringp.h
//
//--------------------------------------------------------------------------

#ifndef _USTRINGP_H_
#define _USTRINGP_H_


//nclude <ntdef.h>
//
// Unicode strings are counted 16-bit character strings. If they are
// NULL terminated, Length does not include trailing NULL.
//
#ifndef _USTRINGP_NO_UNICODE_STRING
	
typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;
#define UNICODE_NULL ((WCHAR)0) // winnt

#endif

#ifndef _USTRINGP_NO_UNICODE_STRING32

typedef struct _STRING32 {
    USHORT   Length;
    USHORT   MaximumLength;
    ULONG  Buffer;
} STRING32;
typedef STRING32 *PSTRING32;

typedef STRING32 UNICODE_STRING32;
typedef UNICODE_STRING32 *PUNICODE_STRING32;

#endif



#ifdef __cplusplus
extern "C"
{
#endif

void
SetUnicodeString (
        IN OUT UNICODE_STRING*  pustr,
        IN     LPCWSTR          psz );
void
SetUnicodeMultiString (
        IN OUT UNICODE_STRING*  pustr,
        IN     LPCWSTR          pmsz );

#ifdef __cplusplus
};
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\snmp\handler.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997-1999                 **/
/**********************************************************************/

/*
	croot.h
		Root node information (the root node is not displayed
		in the MMC framework but contains information such as 
		all of the subnodes in this snapin).
		
    FILE HISTORY:
	
*/

#ifndef _HANDLER_H
#define _HANDLER_H

#ifndef _HANDLERS_H
#include "handlers.h"
#endif



/*---------------------------------------------------------------------------
	Class:  CSnmpRootHandler
 ---------------------------------------------------------------------------*/
class CSnmpRootHandler :
		public CHandler
{
public:
	//DeclareIUnknownMembers(IMPL)
	//DeclareITFSResultHandlerMembers(IMPL)
	//DeclareITFSNodeHandlerMembers(IMPL)

    CSnmpRootHandler(ITFSComponentData *pCompData)
			: CHandler(pCompData)
			{};


	// base handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages();
    OVERRIDE_NodeHandler_CreatePropertyPages();
	
    HRESULT         DoPropSheet(ITFSNode *              pNode,
                                LPPROPERTYSHEETCALLBACK lpProvider = NULL,
                                LONG_PTR                handle = 0);

};


class CSnmpNodeHandler :
   public CBaseHandler
{
public:
	CSnmpNodeHandler(ITFSComponentData *pCompData)
			: CBaseHandler(pCompData)
			{};
protected:
};

#endif _HANDLER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\snmp\handler.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997-1999                 **/
/**********************************************************************/

/*
	node.cpp
		Root node information (the root node is not displayed
		in the MMC framework but contains information such as
		all of the subnodes in this snapin).
		
    FILE HISTORY:

*/

#include "stdafx.h"
#include "snmpclst.h"
#include "handler.h"
#include "util.h"
#include "statsdlg.h"
#include "modeless.h"
#include "snmppp.h"


extern CString g_strMachineName;

/*---------------------------------------------------------------------------
	CSnmpRootHandler implementation
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	CSnmpRootHandler::HasPropertyPages
		Implementation of ITFSNodeHandler::HasPropertyPages
	NOTE: the root node handler has to over-ride this function to
	handle the snapin manager property page (wizard) case!!!
	
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CSnmpRootHandler::HasPropertyPages
(
	ITFSNode *			pNode,
	LPDATAOBJECT		pDataObject,
	DATA_OBJECT_TYPES   type,
	DWORD               dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = hrOK;
	
	if (dwType & TFS_COMPDATA_CREATE)
	{
		// This is the case where we are asked to bring up property
		// pages when the user is adding a new snapin.  These calls
		// are forwarded to the root node to handle.
		hr = S_FALSE;
	}
	else
	{
		// we have property pages in the normal case
		hr = S_OK;
	}
	return hr;
}

/*---------------------------------------------------------------------------
	CSnmpRootHandler::CreatePropertyPages
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
#ifndef PROPSHEETPAGE_LATEST
#ifdef UNICODE
#define PROPSHEETPAGE_LATEST PROPSHEETPAGEW_LATEST
#else
#define PROPSHEETPAGE_LATEST PROPSHEETPAGEA_LATEST
#endif
#endif

HPROPSHEETPAGE MyCreatePropertySheetPage(AFX_OLDPROPSHEETPAGE* ppsp)
{
    PROPSHEETPAGE_LATEST pspLatest = {0};
    CopyMemory (&pspLatest, ppsp, ppsp->dwSize);
    pspLatest.dwSize = sizeof(pspLatest);
    
    return (::CreatePropertySheetPage (&pspLatest));
}

STDMETHODIMP
CSnmpRootHandler::CreatePropertyPages
(
    ITFSNode                *pNode,
	LPPROPERTYSHEETCALLBACK lpProvider,
	LPDATAOBJECT			pDataObject,
	LONG_PTR    			handle,
    DWORD                   dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT        hr;
    DWORD		   dwError;
    CString        strServiceName;

    static UINT s_cfServiceName = RegisterClipboardFormat(L"FILEMGMT_SNAPIN_SERVICE_NAME");
    static UINT s_cfMachineName = RegisterClipboardFormat(L"MMC_SNAPIN_MACHINE_NAME");

    g_strMachineName.Empty();

    hr = ::ExtractString( pDataObject,
                          (CLIPFORMAT) s_cfMachineName,
                          &g_strMachineName,
                          255 );

    if (FAILED(hr))
        return FALSE;
   
    hr = ::ExtractString( pDataObject,
                          (CLIPFORMAT) s_cfServiceName,
                          &strServiceName,
                          255 );

    if (FAILED(hr))
       return FALSE; 
    
    if( !lstrcmpi(strServiceName, L"Snmp") ) {

		SPIComponentData spComponentData;
		m_spNodeMgr->GetComponentData(&spComponentData);

        CAgentPage *pAgentPage  = new CAgentPage();
       
        // tell MMC to hook the proc because we are running on a separate, 
        // non MFC thread.

        MMCPropPageCallback(&pAgentPage->m_psp);

        HPROPSHEETPAGE hAgentPage = MyCreatePropertySheetPage(&pAgentPage->m_psp);
        if(hAgentPage == NULL)
           return E_UNEXPECTED;

        lpProvider->AddPage(hAgentPage);

        CTrapsPage *pTrapsPage  = new CTrapsPage();
       
        MMCPropPageCallback(&pTrapsPage->m_psp);

        HPROPSHEETPAGE hTrapsPage = MyCreatePropertySheetPage(&pTrapsPage->m_psp);
        if(hTrapsPage == NULL)
           return E_UNEXPECTED;

        lpProvider->AddPage(hTrapsPage);

        CSecurityPage *pSecurityPage  = new CSecurityPage();
       
        MMCPropPageCallback(&pSecurityPage->m_psp);

        HPROPSHEETPAGE hSecurityPage = MyCreatePropertySheetPage(&pSecurityPage->m_psp);
        if(hSecurityPage == NULL)
           return E_UNEXPECTED;

        lpProvider->AddPage(hSecurityPage);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\snmp\snmpclst.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997-1999                 **/
/**********************************************************************/

/*
	snmpclst.cpp
	 snmp community list control	
		
    FILE HISTORY:

*/

#include "stdafx.h"
#include "snmpsnap.h"
#include "snmpclst.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

int CCommList::InsertString( int nIndex, LPCTSTR lpszItem )
{
	if (nIndex != -1)
		return CListCtrl::InsertItem(nIndex, lpszItem);
	else
		return CListCtrl::InsertItem(CListCtrl::GetItemCount(), lpszItem);
}

int CCommList::SetCurSel( int nSelect )
{
	return CListCtrl::SetItemState(nSelect, LVIS_SELECTED, LVIS_SELECTED);
}

int CCommList::GetCurSel( ) const
{
	for (int i=0, count=CListCtrl::GetItemCount(); i < count; i++)
	{
		if (CListCtrl::GetItemState(i, LVIS_SELECTED) & LVIS_SELECTED)
			return i;
	}
	return LB_ERR;
}

void CCommList::GetText( int nIndex, CString& rString ) const
{
	rString = CListCtrl::GetItemText(nIndex, 0);
}

int CCommList::DeleteString( UINT nIndex )
{
	return CListCtrl::DeleteItem(nIndex);
}

int CCommList::GetCount( ) const
{
	return CListCtrl::GetItemCount();
}

void CCommList::OnInitList()
{
	LV_COLUMN columnSettings;
	RECT winRect;
	CString caption;

	GetClientRect(&winRect);

	if (!caption.LoadString(IDS_SEC_COMMUNITY))
		caption = "????";
	columnSettings.mask = LVCF_TEXT | LVCF_WIDTH;
	columnSettings.cx = 4 * winRect.right / 7;
	columnSettings.pszText = caption.GetBuffer(caption.GetLength()+1);
	CListCtrl::InsertColumn(0, &columnSettings);

	if (!caption.LoadString(IDS_SEC_PERMISSIONS))
		caption = "????";
	columnSettings.cx = 2 * winRect.right / 7;
	columnSettings.pszText = caption.GetBuffer(caption.GetLength()+1);
	CListCtrl::InsertColumn(1, &columnSettings);

    ListView_SetExtendedListViewStyle(m_hWnd, LVS_EX_FULLROWSELECT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\snmp\snmpclst.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997-1999                 **/
/**********************************************************************/

/*
	snmclist.h
	 snmp community list control
		
    FILE HISTORY:

*/

#ifndef _SNMPCLISTH_
#define _SNMPCLISTH_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CCommList : public CListCtrl
{
public:
	int InsertString( int nIndex, LPCTSTR lpszItem );
	int SetCurSel( int nSelect );
	int GetCurSel( ) const;
	void GetText( int nIndex, CString& rString ) const;
	int DeleteString( UINT nIndex );
	int GetCount( ) const;
	void OnInitList();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\snmp\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by snmpsnap.rc
//
#define IDS_SNAPIN_DESC                 1
#define IDS_ROOT_NODE_NAME              2
#define IDS_CREATE_NEW_SNMP             3
#define IDS_TOP_SNMP                    4
#define IDS_EXTENSION_CREATE_NEW_SNMP   5
#define IDS_EXTENSION_TASK_SNMP         6
#define IDS_STATS_SNMP                  7
#define IDS_STATS_SNMP2                 8
#define IDS_STATS_ROUTER_IPADDRESS      9
#define IDS_STATS_ROUTER_TEXT           10
#define IDS_STATS_ROUTER_STUFF          11
#define IDS_PERM_NAME0                  50
#define IDS_PERM_NAME1                  51
#define IDS_PERM_NAME2                  52
#define IDS_PERM_NAME3                  53
#define IDS_PERM_NAME4                  54
#define IDS_SEC_COMMUNITY               55
#define IDS_SEC_PERMISSIONS             56
#define IDS_ABOUT_DESCRIPTION           100
#define IDS_ABOUT_PROVIDER              101
#define IDS_ABOUT_VERSION               102
#define IDB_16x16                       202
#define IDB_32x32                       203
#define IDD_DIALOG_ADD                  210
#define IDC_EDIT_CONTACT                222
#define IDC_EDIT_LOCATION               223
#define IDC_STATIC_CONTACT              224
#define IDC_STATIC_LOCATION             225
#define IDC_STATIC_SERVICE              226
#define IDC_CHECK_PHYSICAL              227
#define IDC_CHECK_APPLICATIONS          228
#define IDC_CHECK_DATALINK              229
#define IDC_BUTTON_ADD_NAME             229
#define IDC_CHECK_INTERNET              230
#define IDC_BUTTON_REMOVE_NAME          230
#define IDC_CHECK_ENDTOEND              231
#define IDC_BUTTON_ADD_TRAP             232
#define IDC_BUTTON_EDIT_TRAP            233
#define IDC_CHECK_SEND_AUTH_TRAP        233
#define IDC_BUTTON_REMOVE_TRAP          234
#define IDC_BUTTON_EDIT_COMMUNITY       234
#define IDC_COMBO_COMMUNITY             235
#define IDC_BUTTON_REMOVE_COMMUNITY     235
#define IDC_LIST_TRAP                   236
#define IDC_BUTTON_EDIT_HOSTS           236
#define IDC_LIST_COMMUNITY              237
#define IDC_BUTTON_ADD_COMMUNITY        238
#define IDC_LIST_HOSTS                  239
#define IDC_BUTTON_ADD_HOSTS            240
#define IDC_BUTTON_REMOVE_HOSTS         241
#define IDC_RADIO_ACCEPT_ANY            242
#define IDC_RADIO_ACCEPT_SPECIFIC_HOSTS 243
#define IDC_EDIT_NAME                   244
#define IDC_STATIC_EDIT_TEXT            245
#define IDC_STATIC_ADD_TEXT             246
#define IDC_ADD                         247
#define IDC_CB_PERMISSIONS              250
#define IDC_ST_PERMISSIONS              251
#define IDD_AGENT_PROP_PAGE             11701
#define IDD_SNMP_DIALOG                 11702
#define IDD_TRAPS_PROP_PAGE             11703
#define IDD_SECURITY_PROP_PAGE          11704
#define IDD_DIALOG_EDIT                 11705
#define IDS_REGISTRY_LOAD_FAILED        57345
#define IDS_REGISTRY_SAVE_FAILED        57346
#define IDS_ACCEPTHOST_MISSING          57347
#define IDS_SNMPCOMM_TEXT               57348
#define IDS_SNMP_INVALID_IP_IPX_ADD     57349

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        213
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         252
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\snmp\helparr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       helparr.h
//
//--------------------------------------------------------------------------

#define	IDH_ADD_BTN_ADDR	10001151
#define	IDH_ADD_BTN_COMM	10001030
#define	IDH_ADD_NAME_ADDR	10001150
#define	IDH_ADD_NAME_COMM	10001029
#define	IDH_BUTTON_ADD_COMMUNITY	10001106
#define	IDH_BUTTON_ADD_HOSTS	10001112
#define	IDH_BUTTON_ADD_NAME	10001132
#define	IDH_BUTTON_ADD_TRAP	10001135
#define	IDH_BUTTON_EDIT_COMMUNITY	10001107
#define	IDH_BUTTON_EDIT_HOSTS	10001113
#define	IDH_BUTTON_EDIT_TRAP	10001136
#define	IDH_BUTTON_REMOVE_COMMUNITY	10001108
#define	IDH_BUTTON_REMOVE_HOSTS	10001114
#define	IDH_BUTTON_REMOVE_NAME	10001133
#define	IDH_BUTTON_REMOVE_TRAP	10001137
#define	IDH_CB_PERMISSIONS	10001027
#define	IDH_CHECK_APPLICATIONS	10001007
#define	IDH_CHECK_DATALINK	10001008
#define	IDH_CHECK_ENDTOEND	10001010
#define	IDH_CHECK_INTERNET	10001009
#define	IDH_CHECK_PHYSICAL	10001006
#define	IDH_CHECK_SEND_AUTH_TRAP	10001103
#define	IDH_COMBO_COMMUNITY	10001131
#define	IDH_EDIT_CONTACT	10001002
#define	IDH_EDIT_LOCATION	10001004
#define	IDH_EDIT_NAME_ADDR	10001200
#define	IDH_EDIT_NAME_COMM	10001055
#define	IDH_LIST_COMMUNITY	10001105
#define	IDH_LIST_HOSTS	10001111
#define	IDH_LIST_TRAP	10001134
#define	IDH_RADIO_ACCEPT_ANY	10001109
#define	IDH_RADIO_ACCEPT_SPECIFIC_HOSTS	10001110


const DWORD g_aHelpIDs_IDD_AGENT_PROP_PAGE[]=
{

	IDC_EDIT_CONTACT,	IDH_EDIT_CONTACT,
	IDC_EDIT_LOCATION,	IDH_EDIT_LOCATION,
	IDC_CHECK_PHYSICAL,	IDH_CHECK_PHYSICAL,
	IDC_CHECK_APPLICATIONS,	IDH_CHECK_APPLICATIONS,
	IDC_CHECK_DATALINK, IDH_CHECK_DATALINK,
	IDC_CHECK_INTERNET, IDH_CHECK_INTERNET,
	IDC_CHECK_ENDTOEND, IDH_CHECK_ENDTOEND,
	IDC_STATIC, (DWORD(-1)),
	IDC_STATIC_CONTACT,	(DWORD(-1)),
	IDC_STATIC_LOCATION,	(DWORD(-1)),
	IDC_STATIC_SERVICE,	(DWORD(-1)),
	0, 0
};

const DWORD g_aHelpIDs_IDD_DIALOG_ADD_COMM[]=
{
	IDC_CB_PERMISSIONS,	IDH_CB_PERMISSIONS,
	IDC_EDIT_NAME,	IDH_ADD_NAME_COMM,
	IDC_ADD,	IDH_ADD_BTN_COMM,
	IDC_ST_PERMISSIONS,	(DWORD(-1)),
	IDC_STATIC_ADD_TEXT,	(DWORD(-1)),
	0, 0
};

const DWORD g_aHelpIDs_IDD_DIALOG_EDIT_COMM[]=
{
	IDC_CB_PERMISSIONS,	IDH_CB_PERMISSIONS,
	IDC_EDIT_NAME,	IDH_EDIT_NAME_COMM,
	IDC_ST_PERMISSIONS,	(DWORD(-1)),
	IDC_STATIC_EDIT_TEXT,	(DWORD(-1)),
	0, 0
};

const DWORD g_aHelpIDs_IDD_DIALOG_ADD_ADDR[]=
{
	IDC_CB_PERMISSIONS,	(DWORD(-1)),
	IDC_EDIT_NAME,	IDH_ADD_NAME_ADDR,
	IDC_ADD,	IDH_ADD_BTN_ADDR,
	IDC_ST_PERMISSIONS,	(DWORD(-1)),
	IDC_STATIC_ADD_TEXT,	(DWORD(-1)),
	0, 0
};

const DWORD g_aHelpIDs_IDD_DIALOG_EDIT_ADDR[]=
{
	IDC_CB_PERMISSIONS,	(DWORD(-1)),
	IDC_EDIT_NAME,	IDH_EDIT_NAME_ADDR,
	IDC_ST_PERMISSIONS,	(DWORD(-1)),
	IDC_STATIC_EDIT_TEXT,	(DWORD(-1)),
	0, 0
};

const DWORD g_aHelpIDs_IDD_SECURITY_PROP_PAGE[]=
{
	IDC_CHECK_SEND_AUTH_TRAP,	IDH_CHECK_SEND_AUTH_TRAP,
	IDC_LIST_COMMUNITY,	IDH_LIST_COMMUNITY,
	IDC_BUTTON_ADD_COMMUNITY,	IDH_BUTTON_ADD_COMMUNITY,
	IDC_BUTTON_EDIT_COMMUNITY,	IDH_BUTTON_EDIT_COMMUNITY,
	IDC_BUTTON_REMOVE_COMMUNITY,	IDH_BUTTON_REMOVE_COMMUNITY,
	IDC_RADIO_ACCEPT_ANY,	IDH_RADIO_ACCEPT_ANY,
	IDC_RADIO_ACCEPT_SPECIFIC_HOSTS,	IDH_RADIO_ACCEPT_SPECIFIC_HOSTS,
	IDC_LIST_HOSTS,	IDH_LIST_HOSTS,
	IDC_BUTTON_ADD_HOSTS,	IDH_BUTTON_ADD_HOSTS,
	IDC_BUTTON_EDIT_HOSTS,	IDH_BUTTON_EDIT_HOSTS,
	IDC_BUTTON_REMOVE_HOSTS,	IDH_BUTTON_REMOVE_HOSTS,
	IDC_STATIC, (DWORD(-1)),	
	0, 0
};

const DWORD g_aHelpIDs_IDD_TRAPS_PROP_PAGE[]=
{
	IDC_COMBO_COMMUNITY, IDH_COMBO_COMMUNITY,
	IDC_BUTTON_ADD_NAME,	IDH_BUTTON_ADD_NAME,
	IDC_BUTTON_REMOVE_NAME,	IDH_BUTTON_REMOVE_NAME,
	IDC_LIST_TRAP, IDH_LIST_TRAP,
	IDC_BUTTON_ADD_TRAP,	IDH_BUTTON_ADD_TRAP,
	IDC_BUTTON_EDIT_TRAP, IDH_BUTTON_EDIT_TRAP,
	IDC_BUTTON_REMOVE_TRAP, IDH_BUTTON_REMOVE_TRAP,	
	IDC_STATIC, (DWORD(-1)),
	0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\snmp\snmppp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997-1999                 **/
/**********************************************************************/

/*
	snmppp.h
	 snmp extension property pages	
		
    FILE HISTORY:

*/

#ifndef _SNMPPPH_
#define _SNMPPPH_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define N_PERMISSION_BITS	5
#define PERM_BIT_NONE       0
#define PERM_BIT_NOTIFY     1
#define PERM_BIT_READONLY	2
#define PERM_BIT_READWRITE	3
#define PERM_BIT_READCREATE 4

const int COMBO_EDIT_LEN    = 256;
const int HOSTNAME_LENGTH   = 64;
const int DOMAINNAME_LENGTH = 255;

/////////////////////////////////////////////////////////////////////////////
// CAddDialog dialog

class CAddDialog : public CBaseDialog
{
// Construction
public:
    CAddDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CAddDialog)
    enum { IDD = IDD_DIALOG_ADD };
    CEdit   m_editName;
    CButton m_buttonAdd;
    CButton m_buttonCancel;
    CStatic m_staticText;
	CStatic m_staticPermissions;
	CComboBox m_comboPermissions;
    //}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAddDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CAddDialog)
    virtual BOOL OnInitDialog();
    virtual void OnClickedButtonAdd();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    virtual DWORD * GetHelpMap();

public:
    BOOL    m_bCommunity;
    // this contains the specified string to add
    CString m_strName;
	// this contains the specified choice name
	CString m_strChoice;
	// this contains the specified choice index
	int		m_nChoice;
};

/////////////////////////////////////////////////////////////////////////////
// CEditDialog dialog

class CEditDialog : public CBaseDialog
{
// Construction
public:
    CEditDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CEditDialog)
    enum { IDD = IDD_DIALOG_EDIT };
    CEdit   m_editName;
    CButton m_buttonOk;
    CButton m_buttonCancel;
    CStatic m_staticText;
	CComboBox m_comboPermissions;
	CStatic m_staticPermissions;
    //}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEditDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CEditDialog)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    virtual DWORD * GetHelpMap();

public:
    BOOL    m_bCommunity;
    // this contains the modified string
    CString m_strName;
	// this contains the specified choice name
	CString m_strChoice;
	// this contains the specified choice index
	int		m_nChoice;
};

/////////////////////////////////////////////////////////////////////////////
// CAgentPage dialog

class CAgentPage : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CAgentPage)

// Construction
public:
	CAgentPage();
	~CAgentPage();

// Dialog Data
	//{{AFX_DATA(CAgentPage)
	enum { IDD = IDD_AGENT_PROP_PAGE };
	CButton	m_checkPhysical;
	CButton	m_checkApplications;
	CButton	m_checkDatalink;
	CButton	m_checkInternet;
	CButton	m_checkEndToEnd;
   CEdit    m_editContact;
   CEdit    m_editLocation;
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CAgentPage)
   public:
   virtual BOOL OnApply();
   protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
    // Context Help Support
    virtual DWORD * GetHelpMap() { return (DWORD *) &g_aHelpIDs_IDD_AGENT_PROP_PAGE[0]; }
    BOOL LoadRegistry();
    BOOL SaveRegistry();

protected:
	// Generated message map functions
	//{{AFX_MSG(CAgentPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnClickedCheckPhysical();
    afx_msg void OnClickedCheckApplications();
    afx_msg void OnClickedCheckDatalink();
    afx_msg void OnClickedCheckInternet();
    afx_msg void OnClickedCheckEndToEnd();
    afx_msg void OnChangeEditContact();
    afx_msg void OnChangeEditLocation();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    BOOL     m_bLocationChanged;
    BOOL     m_bContactChanged;
};

/////////////////////////////////////////////////////////////////////////////
// CTrapsPage dialog

class CTrapsPage : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CTrapsPage)

// Construction
public:
	CTrapsPage();
	~CTrapsPage();

// Dialog Data
	//{{AFX_DATA(CTrapsPage)
	enum { IDD = IDD_TRAPS_PROP_PAGE };
    CComboBox  m_comboCommunityName;
    CButton    m_buttonAddName;
    CButton    m_buttonRemoveName;
    CListBox   m_listboxTrapDestinations;
    CButton    m_buttonAddTrap;
    CButton    m_buttonEditTrap;
    CButton    m_buttonRemoveTrap;
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTrapsPage)

   public:
   virtual BOOL OnApply();

   protected:
   virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
    // Context Help Support
    virtual DWORD * GetHelpMap() { return (DWORD *) &g_aHelpIDs_IDD_TRAPS_PROP_PAGE[0]; }

    BOOL LoadRegistry();
    BOOL SaveRegistry();
    BOOL LoadTrapDestination(int nIndex);
    void UpdateCommunityAddButton();
    void UpdateCommunityRemoveButton();
    void UpdateTrapDestinationButtons();

protected:
	// Generated message map functions
	//{{AFX_MSG(CTrapsPage)
	virtual BOOL OnInitDialog();
   afx_msg void OnEditChangeCommunityName();
   afx_msg void OnEditUpdateCommunityName();
   afx_msg void OnSelectionChangeCommunityName();

   afx_msg void OnClickedButtonAddName();
   afx_msg void OnClickedButtonRemoveName();
   afx_msg void OnClickedButtonAddTrap();
   afx_msg void OnClickedButtonEditTrap();
   afx_msg void OnClickedButtonRemoveTrap();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

   CObList * m_pCommunityList;
   CAddDialog m_dlgAdd;
   CEditDialog m_dlgEdit;
   BOOL m_fPolicyTrapConfig;
};

/////////////////////////////////////////////////////////////////////////////
// CSecurityPage dialog

class CSecurityPage : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CSecurityPage)

// Construction
public:
	CSecurityPage();
	~CSecurityPage();

// Dialog Data
	//{{AFX_DATA(CSecurityPage)
	enum { IDD = IDD_SECURITY_PROP_PAGE };
	CCommList m_listboxCommunity;
    CButton	  m_buttonAddCommunity;
    CButton   m_buttonEditCommunity;
    CButton   m_buttonRemoveCommunity;
    CButton	  m_buttonAddHost;
    CButton   m_buttonEditHost;
    CButton   m_buttonRemoveHost;
    CListBox  m_listboxHost;
    CButton   m_checkSendAuthTrap;
    CButton   m_radioAcceptAnyHost;
    CButton   m_radioAcceptSpecificHost;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSecurityPage)
   public:
   virtual BOOL OnApply();

	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
    // Context Help Support
    virtual DWORD * GetHelpMap() { return (DWORD *) &g_aHelpIDs_IDD_SECURITY_PROP_PAGE[0]; }
    BOOL LoadRegistry();
    BOOL SaveRegistry();
    BOOL LoadTrapDestination(int nIndex);
    void UpdateNameButtons();
    void UpdateHostButtons();
    BOOL LoadSecurityInfo(CString &strRegName);
    BOOL SaveSecurityInfo(CString &strRegName);


protected:
	// Generated message map functions
	//{{AFX_MSG(CSecurityPage)
	virtual BOOL OnInitDialog();
   afx_msg void OnClickedButtonAddCommunity();
   afx_msg void OnClickedButtonEditCommunity();
   afx_msg void OnClickedButtonRemoveCommunity();
   afx_msg void OnClickedButtonAddHost();
   afx_msg void OnClickedButtonEditHost();
   afx_msg void OnClickedButtonRemoveHost();
   afx_msg void OnClickedCheckSendAuthTrap();
   afx_msg void OnClickedRadioAcceptAnyHost();
   afx_msg void OnClickedRadioAcceptSpecificHost();
	afx_msg void OnDblclkCtrlistCommunity(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnCommunityListChanged(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

   // private methods to add admin acl to registry subkey
   PACL AllocACL();
   void FreeACL( PACL pAcl);
   BOOL SnmpAddAdminAclToKey(LPTSTR pszKey);

   CAddDialog m_dlgAddName;
   CEditDialog m_dlgEditName;

   CAddDialog m_dlgAddHost;
   CEditDialog m_dlgEditHost;

   BOOL m_fPolicyValidCommunities;
   BOOL m_fPolicyPermittedManagers;
};

BOOL IsValidString(CString & strName);
BOOL ValidateDomain(CString & strdomain);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\snmp\snmpcomp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997-1999                 **/
/**********************************************************************/

/*
	handler.h
		This file contains the prototypes for the derived classes
		for CComponent and CComponentData.  Most of these functions
		are pure virtual functions that need to be overridden
		for snapin functionality.
		
    FILE HISTORY:

*/

#include "resource.h"       // main symbols

#ifndef __mmc_h__
#include <mmc.h>
#endif

#ifndef _COMPONT_H_
#include "compont.h"
#endif

#ifndef _SNMPCOMPH_
#define _SNMPCOMPH_

/*---------------------------------------------------------------------------
	CSnmpComponentData

	This is the base implementation of ComponentData.  This will be
	incorporated into the two derived classes.
 ---------------------------------------------------------------------------*/

class CSnmpComponentData :
	public CComponentData,
	public CComObjectRoot
{
public:
BEGIN_COM_MAP(CSnmpComponentData)
	COM_INTERFACE_ENTRY(IComponentData)
	COM_INTERFACE_ENTRY(IExtendPropertySheet)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
END_COM_MAP()
			
	// These are the interfaces that we MUST implement

	// We will implement our common behavior here, with the derived
	// classes implementing the specific behavior.
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	DeclareIPersistStreamInitMembers(IMPL)
	DeclareITFSCompDataCallbackMembers(IMPL)

	CSnmpComponentData();

	HRESULT FinalConstruct();
	void FinalRelease();
	
protected:
	SPITFSNodeMgr	m_spNodeMgr;
};



/*---------------------------------------------------------------------------
	This is how the sample snapin implements its extension functionality.
	It actually exposes two interfaces that are CoCreate-able.  One is the
	primary interface, the other the extension interface.
	
	Author: EricDav
 ---------------------------------------------------------------------------*/
class CSnmpComponentDataPrimary :
	public CSnmpComponentData,
	public CComCoClass<CSnmpComponentDataPrimary, &CLSID_SnmpSnapin>
{
public:
	DECLARE_REGISTRY(CSnmpComponentDataPrimary,
					 _T("SnmpSnapin.SnmpSnapin.1"),
					 _T("SnmpSnapin.SnmpSnapin"),
					 IDS_SNAPIN_DESC, THREADFLAGS_BOTH)
    STDMETHOD_(const CLSID *,GetCoClassID()){ return &CLSID_SnmpSnapin; }
};


class CSnmpComponentDataExtension :
	public CSnmpComponentData,
    public CComCoClass<CSnmpComponentDataExtension, &CLSID_SnmpSnapinExtension>
{
public:
	DECLARE_REGISTRY(CSnmpComponentDataExtension,
					 _T("SnmpSnapinExtension.SnmpSnapinExtension.1"),
					 _T("SnmpSnapinExtension.SnmpSnapinExtension"),
					 IDS_SNAPIN_DESC, THREADFLAGS_BOTH)
    STDMETHOD_(const CLSID *, GetCoClassID)(){ return &CLSID_SnmpSnapinExtension; }
};



/////////////////////////////////////////////////////////////////////////////
//
// CSnmpComponent
//
/////////////////////////////////////////////////////////////////////////////

class CSnmpComponent :
	public TFSComponent
{
public:
	CSnmpComponent();
	~CSnmpComponent();

	DeclareITFSCompCallbackMembers(IMPL)
	
//Attributes
private:
};



/*---------------------------------------------------------------------------
	This is the derived class for handling the IAbout interface from MMC
	Author: EricDav
 ---------------------------------------------------------------------------*/
class CSnmpAbout :
	public CAbout,
    public CComCoClass<CSnmpAbout, &CLSID_SnmpSnapinAbout>
{
public:
DECLARE_REGISTRY(CSnmpAbout,
				 _T("SnmpSnapin.About.1"),
				 _T("SnmpSnapin.About"),
				 IDS_SNAPIN_DESC,
				 THREADFLAGS_BOTH)

BEGIN_COM_MAP(CSnmpAbout)
    COM_INTERFACE_ENTRY(ISnapinAbout) // Must have one static entry
	COM_INTERFACE_ENTRY_CHAIN(CAbout) // chain to the base class
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CSnmpAbout)

// these must be overridden to provide values to the base class
protected:
	virtual UINT GetAboutDescriptionId() { return IDS_ABOUT_DESCRIPTION; }
	virtual UINT GetAboutProviderId()	 { return IDS_ABOUT_PROVIDER; }
	virtual UINT GetAboutVersionId()	 { return IDS_ABOUT_VERSION; }

	virtual UINT GetAboutIconId()		 { return 0; }
	virtual UINT GetSmallRootId()		 { return 0; }
	virtual UINT GetSmallOpenRootId()	 { return 0; }
	virtual UINT GetLargeRootId()		 { return 0; }
	virtual COLORREF GetLargeColorMask() { return (COLORREF) 0; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\snmp\snmpcomp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997-1999                 **/
/**********************************************************************/

/*
	csmplsnp.cpp
		This file contains the derived classes for CComponent and
		CComponentData.  Most of these functions are pure virtual
		functions that need to be overridden for snapin functionality.
		
    FILE HISTORY:

*/

#include "stdafx.h"
#include "handler.h"
#include <atlimpl.cpp>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/*---------------------------------------------------------------------------
	CSnmpComponent
 ---------------------------------------------------------------------------*/



/////////////////////////////////////////////////////////////////////////////
// CSnmpComponent implementation

CSnmpComponent::CSnmpComponent()
{
}

CSnmpComponent::~CSnmpComponent()
{
}

STDMETHODIMP CSnmpComponent::OnUpdateView(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param)
{
	return hrOK;
}

STDMETHODIMP CSnmpComponent::InitializeBitmaps(MMC_COOKIE cookie)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT(m_spImageList != NULL);

	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		CBitmap bmp16x16;
		CBitmap bmp32x32;
	
		// Load the bitmaps from the dll
		bmp16x16.LoadBitmap(IDB_16x16);
		bmp32x32.LoadBitmap(IDB_32x32);

		// Set the images
		m_spImageList->ImageListSetStrip(
					reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
					reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp32x32)),
					0, RGB(255,0,255));
	}
	COM_PROTECT_CATCH;

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CSnmpComponentData implementation

STDMETHODIMP_(ULONG) CSnmpComponentData::AddRef() {return InternalAddRef();}
STDMETHODIMP_(ULONG) CSnmpComponentData::Release()
{
	ULONG l = InternalRelease();
	if (l == 0)
		delete this;
	return l;
}

CSnmpComponentData::CSnmpComponentData()
{
}

/*!--------------------------------------------------------------------------
	CSnmpComponentData::OnInitialize
		-
	Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CSnmpComponentData::OnInitialize(LPIMAGELIST pScopeImage)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	ASSERT(pScopeImage);

	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		// add the images for the scope tree
		CBitmap bmp16x16;

		// Load the bitmaps from the dll
		bmp16x16.LoadBitmap(IDB_16x16);

		// Set the images
		pScopeImage->ImageListSetStrip(
					reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
					reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
					0,
					RGB(255,0,255));
	}
	COM_PROTECT_CATCH;

	return hr;
}

/*!--------------------------------------------------------------------------
	CSnmpComponentData::OnInitializeNodeMgr
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CSnmpComponentData::OnInitializeNodeMgr(ITFSComponentData *pTFSCompData, ITFSNodeMgr *pNodeMgr)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	// For now create a new node handler for each new node,
	// this is rather bogus as it can get expensive.  We can
	// consider creating only a single node handler for each
	// node type.
	CSnmpRootHandler *pHandler = NULL;
	SPITFSNodeHandler	spHandler;
	SPITFSNode			spNode;
	HRESULT				hr = hrOK;

	COM_PROTECT_TRY
	{
		pHandler = new CSnmpRootHandler(pTFSCompData);

		// Do this so that it will get released correctly
		spHandler = pHandler;
	
		// Create the root node for this sick puppy
		CORg( CreateContainerTFSNode(&spNode,
									 &GUID_SnmpRootNodeType,
									 pHandler,
									 pHandler /* result handler */,
									 pNodeMgr) );
		
		// Need to initialize the data for the root node
		spNode->SetData(TFS_DATA_IMAGEINDEX, IMAGE_IDX_FOLDER_CLOSED);
		spNode->SetData(TFS_DATA_OPENIMAGEINDEX, IMAGE_IDX_FOLDER_OPEN);
		spNode->SetData(TFS_DATA_SCOPEID, 0);
		
		CORg( pNodeMgr->SetRootNode(spNode) );
	
		// in general do
		//		spNode->SetData(TFS_DATA_COOKIE, (DWORD)(ITFSNode *)spNode);
		spNode->SetData(TFS_DATA_COOKIE, 0);

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;

	return hr;
}

/*!--------------------------------------------------------------------------
	CSnmpComponentData::OnCreateComponent
		-
	Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CSnmpComponentData::OnCreateComponent(LPCOMPONENT *ppComponent)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT(ppComponent != NULL);
	
	HRESULT		hr = hrOK;
	CSnmpComponent *	pComp = NULL;

	COM_PROTECT_TRY
	{
		pComp = new CSnmpComponent;
		
		if (FHrSucceeded(hr))
		{
			pComp->Construct(m_spNodeMgr,
							 static_cast<IComponentData *>(this),
							 m_spTFSComponentData);
			*ppComponent = static_cast<IComponent *>(pComp);
		}
		
	}
	COM_PROTECT_CATCH;
	
	return hr;
}


STDMETHODIMP CSnmpComponentData::OnDestroy()
{
	m_spNodeMgr.Release();
	return hrOK;
}

/*!--------------------------------------------------------------------------
	CSnmpComponentData::GetCoClassID
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(const CLSID *) CSnmpComponentData::GetCoClassID()
{
	return &CLSID_SnmpSnapin;
}

/*!--------------------------------------------------------------------------
	CSnmpComponentData::OnCreateDataObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CSnmpComponentData::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(ppDataObject != NULL);

	CDataObject *	pObject = NULL;
	SPIDataObject	spDataObject;
	
	pObject = new CDataObject;
	spDataObject = pObject;	// do this so that it gets released correctly
						
    ASSERT(pObject != NULL);

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    // Store the coclass with the data object
    pObject->SetClsid(*GetCoClassID());

	pObject->SetTFSComponentData(m_spTFSComponentData);

    return  pObject->QueryInterface(IID_IDataObject,
									reinterpret_cast<void**>(ppDataObject));
}


///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members

STDMETHODIMP CSnmpComponentData::GetClassID
(
	CLSID *pClassID
)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_SnmpSnapin;

    return hrOK;
}

STDMETHODIMP CSnmpComponentData::IsDirty()
{
	SPITFSNode	spNode;
	m_spNodeMgr->GetRootNode(&spNode);
	return spNode->GetData(TFS_DATA_DIRTY) ? hrOK : hrFalse;
}

STDMETHODIMP CSnmpComponentData::Load
(
	IStream *pStm
)
{
    HRESULT hr = S_OK;

	ASSERT(pStm);

    return SUCCEEDED(hr) ? S_OK : E_FAIL;
}


STDMETHODIMP CSnmpComponentData::Save
(
	IStream *pStm,
	BOOL	 fClearDirty
)
{
	HRESULT hr = S_OK;
	SPITFSNode	spNode;

	ASSERT(pStm);

	if (fClearDirty)
	{
		m_spNodeMgr->GetRootNode(&spNode);
		spNode->SetData(TFS_DATA_DIRTY, FALSE);
	}

    return SUCCEEDED(hr) ? S_OK : STG_E_CANTSAVE;
}


STDMETHODIMP CSnmpComponentData::GetSizeMax
(
	ULARGE_INTEGER *pcbSize
)
{
    ASSERT(pcbSize);

    // Set the size of the string to be saved
    ULISet32(*pcbSize, 500);

    return S_OK;
}

STDMETHODIMP CSnmpComponentData::InitNew()
{
	return hrOK;
}



HRESULT CSnmpComponentData::FinalConstruct()
{
	HRESULT				hr = hrOK;
	
	hr = CComponentData::FinalConstruct();
	
	if (FHrSucceeded(hr))
	{
		m_spTFSComponentData->GetNodeMgr(&m_spNodeMgr);
	}
	return hr;
}

void CSnmpComponentData::FinalRelease()
{
	CComponentData::FinalRelease();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\snmp\snmppp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997-1999     **/
/**********************************************************************/

/*
    snmppp.cpp
     snmp extension property pages  
        
    FILE HISTORY:

*/

#include "stdafx.h"
#include "snmpclst.h"
#include "snmpsnap.h"
#include "snmppp.h"
#include "tregkey.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CString g_strMachineName;

/////////////////////////////////////////////////////////////////////////////
// CAgentPage property page

IMPLEMENT_DYNCREATE(CAgentPage, CPropertyPageBase)

CAgentPage::CAgentPage()
    : CPropertyPageBase(CAgentPage::IDD)
{
    //{{AFX_DATA_INIT(CAgentPage)
#if 0
    m_strClientComment = _T("");
#endif
    //}}AFX_DATA_INIT
    
}

CAgentPage::~CAgentPage()
{
}

void CAgentPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPageBase::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAgentPage)
    DDX_Control(pDX, IDC_CHECK_PHYSICAL, m_checkPhysical);
    DDX_Control(pDX, IDC_CHECK_APPLICATIONS, m_checkApplications);
    DDX_Control(pDX, IDC_CHECK_DATALINK, m_checkDatalink);
    DDX_Control(pDX, IDC_CHECK_INTERNET, m_checkInternet);
    DDX_Control(pDX, IDC_CHECK_ENDTOEND, m_checkEndToEnd);
    DDX_Control(pDX, IDC_EDIT_CONTACT, m_editContact);
    DDX_Control(pDX, IDC_EDIT_LOCATION, m_editLocation);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAgentPage, CPropertyPageBase)
    //{{AFX_MSG_MAP(CAgentPage)
    ON_BN_CLICKED(IDC_CHECK_PHYSICAL, OnClickedCheckPhysical)
    ON_BN_CLICKED(IDC_CHECK_APPLICATIONS, OnClickedCheckApplications)
    ON_BN_CLICKED(IDC_CHECK_DATALINK, OnClickedCheckDatalink)
    ON_BN_CLICKED(IDC_CHECK_INTERNET, OnClickedCheckInternet)
    ON_BN_CLICKED(IDC_CHECK_ENDTOEND, OnClickedCheckEndToEnd)
    ON_EN_CHANGE(IDC_EDIT_CONTACT, OnChangeEditContact)
    ON_EN_CHANGE(IDC_EDIT_LOCATION, OnChangeEditLocation)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAgentPage message handlers

BOOL CAgentPage::OnInitDialog()
{
    CPropertyPageBase::OnInitDialog();

    m_bLocationChanged = FALSE;
    m_bContactChanged = FALSE;

    // Limit edit controls
    m_editContact.SetLimitText(COMBO_EDIT_LEN);
    m_editLocation.SetLimitText(COMBO_EDIT_LEN);

    if (LoadRegistry() == FALSE)
    {
       AfxMessageBox(IDS_REGISTRY_LOAD_FAILED, MB_ICONSTOP|MB_OK);
//        PostMessage(GetParent(*this), WM_COMMAND, IDCANCEL, 0);
    }

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CAgentPage::OnApply()
{
    UpdateData();

    if( SaveRegistry() == FALSE )
    {
        AfxMessageBox(IDS_REGISTRY_SAVE_FAILED, MB_ICONSTOP|MB_OK);
        return FALSE;
    }

    BOOL bRet = CPropertyPageBase::OnApply();

    if (bRet == FALSE)
    {
        // Something bad happened... grab the error code
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
//        ::DhcpMessageBox(GetHolder()->GetError());
    }

    return bRet;
}

BOOL CAgentPage::LoadRegistry()
{
    RegKey  rk;
    LONG    err;
    CString strContact;
    CString strLocation;
    DWORD   dwServices = 0;
    LPCTSTR lpcszMachineName = g_strMachineName.IsEmpty() ? NULL : (LPCTSTR)g_strMachineName;

    // Open or create the registry key
    err = rk.Open(HKEY_LOCAL_MACHINE,
                  AGENT_REG_KEY_NAME,
                  KEY_ALL_ACCESS,
                  lpcszMachineName);

    if (err != ERROR_SUCCESS)
    {
        err = rk.Create(HKEY_LOCAL_MACHINE,
                        AGENT_REG_KEY_NAME,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        lpcszMachineName);

        if (err != ERROR_SUCCESS)
            return FALSE;
    }

    err = rk.QueryValue(SNMP_CONTACT, strContact);
    if (err != ERROR_SUCCESS)
       return FALSE;

    err = rk.QueryValue(SNMP_LOCATION, strLocation);
    if (err != ERROR_SUCCESS)
       return FALSE;

    err = rk.QueryValue(SNMP_SERVICES, dwServices);
    if (err != ERROR_SUCCESS)
    {
        // if no registry value, set it to default:
        // applications, end-to-end, internet
        dwServices = 0x40 | 0x8 | 0x4;
    }

    m_editContact.SetWindowText(strContact);
    m_editLocation.SetWindowText(strLocation);

    m_checkPhysical.SetCheck((dwServices & 0x1));
    m_checkDatalink.SetCheck((dwServices & 0x2));
    m_checkInternet.SetCheck((dwServices & 0x4));
    m_checkEndToEnd.SetCheck((dwServices & 0x8));
    m_checkApplications.SetCheck((dwServices & 0x40));

    return TRUE;
}

BOOL CAgentPage::SaveRegistry()
{
    RegKey  rk;
    LONG    err;
    CString strContact;
    CString strLocation;
    DWORD   dwServices = 0;
    LPCTSTR lpcszMachineName = g_strMachineName.IsEmpty() ? NULL : (LPCTSTR)g_strMachineName;

    // Open or create the registry key
    err = rk.Open(HKEY_LOCAL_MACHINE,
                  AGENT_REG_KEY_NAME,
                  KEY_ALL_ACCESS,
                  lpcszMachineName);

    if (err != ERROR_SUCCESS)
    {
        err = rk.Create(HKEY_LOCAL_MACHINE,
                        AGENT_REG_KEY_NAME,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        lpcszMachineName);

        if (err != ERROR_SUCCESS)
            return FALSE;
    }

    dwServices |= (m_checkPhysical.GetCheck() ? 0x1 : 0 ) ;
    dwServices |= (m_checkDatalink.GetCheck() ? 0x2 : 0 ) ;
    dwServices |= (m_checkInternet.GetCheck() ? 0x4 : 0 ) ;
    dwServices |= (m_checkEndToEnd.GetCheck() ? 0x8 : 0 ) ;
    dwServices |= (m_checkApplications.GetCheck() ? 0x40 : 0 ) ;

    err = rk.SetValue(SNMP_SERVICES, dwServices);
    if (err != ERROR_SUCCESS)
       return FALSE;

    m_editContact.GetWindowText(strContact);
    err = rk.SetValue(SNMP_CONTACT, strContact);
    if (err != ERROR_SUCCESS)
       return FALSE;

    m_editLocation.GetWindowText(strLocation);
    err = rk.SetValue(SNMP_LOCATION, strLocation);
    if (err != ERROR_SUCCESS)
       return FALSE;

    return TRUE;
}

void CAgentPage::OnClickedCheckPhysical()
{
    SetDirty(TRUE);
}

void CAgentPage::OnClickedCheckApplications()
{
    SetDirty(TRUE);
}

void CAgentPage::OnClickedCheckDatalink()
{
    SetDirty(TRUE);
}
void CAgentPage::OnClickedCheckInternet()
{
    SetDirty(TRUE);
}

void CAgentPage::OnClickedCheckEndToEnd()
{
    SetDirty(TRUE);
}

void CAgentPage::OnChangeEditContact()
{
    SetDirty(TRUE);
}

void CAgentPage::OnChangeEditLocation()
{
    SetDirty(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// CTrapsPage property page
//

IMPLEMENT_DYNCREATE(CTrapsPage, CPropertyPageBase)

CTrapsPage::CTrapsPage()
    : CPropertyPageBase(CTrapsPage::IDD)
{
    m_pCommunityList = new CObList();
    m_fPolicyTrapConfig = FALSE; // default to use service registry
    //{{AFX_DATA_INIT(CTrapsPage)
#if 0
    m_strServerNetbiosName = _T("");
#endif
    //}}AFX_DATA_INIT
    
}

CTrapsPage::~CTrapsPage()
{
   m_pCommunityList->RemoveAll();
   delete m_pCommunityList;
}

void CTrapsPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPageBase::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CTrapsPage)
    DDX_Control(pDX, IDC_COMBO_COMMUNITY, m_comboCommunityName);
    DDX_Control(pDX, IDC_BUTTON_ADD_NAME, m_buttonAddName);
    DDX_Control(pDX, IDC_BUTTON_REMOVE_NAME, m_buttonRemoveName);
    DDX_Control(pDX, IDC_LIST_TRAP, m_listboxTrapDestinations);
    DDX_Control(pDX, IDC_BUTTON_ADD_TRAP, m_buttonAddTrap);
    DDX_Control(pDX, IDC_BUTTON_EDIT_TRAP, m_buttonEditTrap);
    DDX_Control(pDX, IDC_BUTTON_REMOVE_TRAP, m_buttonRemoveTrap);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CTrapsPage, CPropertyPageBase)
    //{{AFX_MSG_MAP(CTrapsPage)
    ON_BN_CLICKED(IDC_BUTTON_ADD_NAME, OnClickedButtonAddName)
    ON_BN_CLICKED(IDC_BUTTON_REMOVE_NAME, OnClickedButtonRemoveName)
    ON_BN_CLICKED(IDC_BUTTON_ADD_TRAP, OnClickedButtonAddTrap)
    ON_BN_CLICKED(IDC_BUTTON_EDIT_TRAP, OnClickedButtonEditTrap)
    ON_BN_CLICKED(IDC_BUTTON_REMOVE_TRAP, OnClickedButtonRemoveTrap)

    ON_CBN_EDITCHANGE(IDC_COMBO_COMMUNITY, OnEditChangeCommunityName)
    ON_CBN_EDITUPDATE(IDC_COMBO_COMMUNITY, OnEditUpdateCommunityName)
    ON_CBN_SELCHANGE(IDC_COMBO_COMMUNITY, OnSelectionChangeCommunityName)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTrapsPage message handlers

BOOL CTrapsPage::OnInitDialog()
{
   CPropertyPageBase::OnInitDialog();

   m_comboCommunityName.LimitText(COMBO_EDIT_LEN-1);
   if( LoadRegistry() ) {
      if( m_comboCommunityName.GetCount() ) {
         m_comboCommunityName.SetCurSel(0);
         LoadTrapDestination(0);
      }
   }
   else {
      AfxMessageBox(IDS_REGISTRY_LOAD_FAILED, MB_ICONSTOP|MB_OK);
   }
    
   UpdateCommunityAddButton();     // set state of Add button
   UpdateCommunityRemoveButton();  // set state of Remove button
   UpdateTrapDestinationButtons(); // set state of TRAP destination buttons
    
   return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CTrapsPage::OnApply()
{
    UpdateData();

    if( SaveRegistry() == FALSE )
    {
        AfxMessageBox(IDS_REGISTRY_SAVE_FAILED, MB_ICONSTOP|MB_OK);
        return FALSE;
    }

    BOOL bRet = CPropertyPageBase::OnApply();

    if (bRet == FALSE)
    {
        // Something bad happened... grab the error code
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
//        ::DhcpMessageBox(GetHolder()->GetError());
    }

    return bRet;
}

BOOL CTrapsPage::LoadRegistry()
{
   RegKey           rk;
   RegKey           rkTrap;
   RegKeyIterator   rkIter;
   RegValueIterator rvIter;
   HRESULT          hr, hrIter;
   LONG             err;
   CString          stKey, stValue;
   LPCTSTR          lpcszMachineName = g_strMachineName.IsEmpty() ? NULL : (LPCTSTR)g_strMachineName;
   BOOL             fPolicy;

   // we need to provide precedence to the parameters set through the policy
   fPolicy = TRUE;
   if (fPolicy)
   {
       err = rk.Open(HKEY_LOCAL_MACHINE,
                     POLICY_TRAP_CONFIG_KEY_NAME,
                     KEY_ALL_ACCESS,
                     lpcszMachineName);
       
       if (err != ERROR_SUCCESS)
          fPolicy = FALSE;
       else
       {
           // remember that we are loading from policy registry
           m_fPolicyTrapConfig = TRUE;
       }

   }

   if (fPolicy == FALSE)
   {
      // Open or create the registry key
      err = rk.Open(HKEY_LOCAL_MACHINE,
                    TRAP_CONFIG_KEY_NAME,
                    KEY_ALL_ACCESS,
                    lpcszMachineName);
      if (err != ERROR_SUCCESS)
      {
         err = rk.Create(HKEY_LOCAL_MACHINE,
                         TRAP_CONFIG_KEY_NAME,
                         REG_OPTION_NON_VOLATILE,
                         KEY_ALL_ACCESS,
                         NULL,
                         lpcszMachineName);

         if (err != ERROR_SUCCESS)
            return FALSE;
      }
   }

   

   err = rkIter.Init(&rk);
   if (err != ERROR_SUCCESS) {
      return FALSE;
   }

   for (hrIter = rkIter.Next(&stKey); hrIter == hrOK; hrIter = rkIter.Next(&stKey)) {
        //
        // open the key
        //
        err = rkTrap.Open(rk, stKey, KEY_READ);

        int nIndex = m_comboCommunityName.InsertString(-1, stKey);
        if (nIndex >= 0 ) {
           CStringList * pstrList = new CStringList();
           if (!pstrList) {
              return FALSE;
           }

           m_comboCommunityName.SetItemData(nIndex, (ULONG_PTR) pstrList);
           m_pCommunityList->AddHead(pstrList);

           err = rvIter.Init(&rkTrap);
           if (err != ERROR_SUCCESS) {
              return FALSE;
           }

           for (hr = rvIter.Next(&stValue, NULL); hr == hrOK; hr = rvIter.Next(&stValue, NULL)) {
              CString strTrap;
              err = rkTrap.QueryValue(stValue, strTrap);
              if (err != ERROR_SUCCESS) {
                 return FALSE;
              }
              CString * pstr = new CString(strTrap);
              if (!pstr) {
                 return FALSE;
              }
              pstrList->AddHead(*pstr);
           }
        }
   }
   return TRUE;
}

BOOL CTrapsPage::SaveRegistry()
{
   RegKey   rk;
   RegKey   rkTrap;
   LONG     err;
   LPCTSTR  lpcszMachineName = g_strMachineName.IsEmpty() ? NULL : (LPCTSTR)g_strMachineName;


   if (m_fPolicyTrapConfig)
   {
      // Group Policy enforced
      return TRUE;
   }

   // Open the SNMP Parameters key
   err = rk.Open(HKEY_LOCAL_MACHINE,
                 SNMP_PARAMS_KEY_NAME,
                 KEY_ALL_ACCESS,
                 lpcszMachineName);
   if (err != ERROR_SUCCESS)
   {
      return FALSE;
   }

   // delete the Trap Configuration key first
   err = rk.RecurseDeleteKey(TRAP_CONFIGURATION);
   if (err != ERROR_SUCCESS) {
      return FALSE;
   }

   // now create the key to add the new values
   err = rk.Create(HKEY_LOCAL_MACHINE,
                   TRAP_CONFIG_KEY_NAME,
                   REG_OPTION_NON_VOLATILE,
                   KEY_ALL_ACCESS,
                   NULL,
                   lpcszMachineName);
   if (err != ERROR_SUCCESS)
       return FALSE;

   CString       strCommunityName;

   int nMax = m_comboCommunityName.GetCount();
   for (int nCount = 0; nCount < nMax; nCount++ ) {

      m_comboCommunityName.GetLBText(nCount, strCommunityName);

      ASSERT(strCommunityName.GetLength());

      CStringList * pstrList = (CStringList *)m_comboCommunityName.GetItemData(nCount);

      // For each community name create a key
      err = rkTrap.Create(rk, strCommunityName);
      if (err != ERROR_SUCCESS) {
         return FALSE;
      }

      // for each community name get the TRAP destination values from the saved
      // away list and write them as values to the registry

      POSITION posTrap;
      CString * pstr;
      TCHAR     buf[32];
      int j;

      for (j = 1, posTrap = pstrList->GetHeadPosition();
           posTrap != NULL && (pstr = & (pstrList->GetNext( posTrap )));
           j++ ) {

          wsprintf(buf, TEXT("%d"), j);
          err = rkTrap.SetValue(buf, *pstr);
      }
   }

   return TRUE;
}

BOOL CTrapsPage::LoadTrapDestination(int nIndex)
{
   ASSERT (m_pCommunityList);

   POSITION pos;

   // empty list box and add trap destinations for this community name
   m_listboxTrapDestinations.ResetContent();

   CStringList * pstrList = (CStringList *)m_comboCommunityName.GetItemData(nIndex);

   CString * pstr;

   for (pos = pstrList->GetHeadPosition();
        pos != NULL && (pstr = & pstrList->GetNext( pos )); /**/) {

       m_listboxTrapDestinations.AddString(*pstr);
   }

   if (m_listboxTrapDestinations.GetCount()) {
      m_listboxTrapDestinations.SetCurSel(0);
   }

   return TRUE;
}

void CTrapsPage::UpdateCommunityAddButton()
{
   CString strCommunityName;

   m_comboCommunityName.GetWindowText(strCommunityName);
   if (strCommunityName.GetLength() && strCommunityName != L" ") {
      // enable the button if the text doesn't match
      BOOL bEnable = (m_comboCommunityName.FindStringExact(-1, strCommunityName) == CB_ERR);
      if (!bEnable) {
         // move focus to the combo box before disabling the Add button
         m_comboCommunityName.SetFocus();
      }
      m_buttonAddName.EnableWindow(bEnable);
   }
   else
   {
      m_buttonAddName.EnableWindow(FALSE);
      m_comboCommunityName.SetFocus();
   }

   if (m_fPolicyTrapConfig)
   {
       // Group Policy enforced
       m_buttonAddName.EnableWindow(FALSE);
   }
}

void CTrapsPage::UpdateCommunityRemoveButton()
{
   int nCount = m_comboCommunityName.GetCount();

   if(nCount == 0)
      m_comboCommunityName.SetFocus();

   m_buttonRemoveName.EnableWindow(nCount? TRUE : FALSE);

   if (m_fPolicyTrapConfig)
   {
       // Group Policy enforced
       m_buttonRemoveName.EnableWindow(FALSE);
       m_buttonAddName.EnableWindow(FALSE);
   }
}

void CTrapsPage::UpdateTrapDestinationButtons()
{
   m_buttonAddTrap.EnableWindow(m_comboCommunityName.GetCount()? TRUE : FALSE);

   int nCount = m_listboxTrapDestinations.GetCount();

   m_buttonEditTrap.EnableWindow(nCount? TRUE: FALSE);
   m_buttonRemoveTrap.EnableWindow(nCount? TRUE: FALSE);

   if (m_fPolicyTrapConfig)
   {
       // Group Policy enforced
       m_buttonAddTrap.EnableWindow(FALSE);
       m_buttonEditTrap.EnableWindow(FALSE);
       m_buttonRemoveTrap.EnableWindow(FALSE);
   }
}

/*
  Handle the ON_CBN_EDITCHANGE message.
  The user has taken an action that may have altered the text in the 
  edit-control portion of a combo box. 
  Unlike the CBN_EDITUPDATE message, this message is sent after Windows 
  updates the screen.
*/

void CTrapsPage::OnEditChangeCommunityName()
{
    UpdateCommunityAddButton();
    // community name entered in the edit-control portion of the combo box,
    // we need to disable the Trap destinations "Edit..." and "Remove" 
    // buttons
    m_buttonEditTrap.EnableWindow(FALSE);
    m_buttonRemoveTrap.EnableWindow(FALSE);
//    UpdateTrapDestinationButtons();
}

/*
  Handle the ON_CBN_EDITUPDATE message.
  The user has taken an action that may have altered the text in the
  edit-control portion of a combo box.
*/

void CTrapsPage::OnEditUpdateCommunityName()
{
    UpdateCommunityAddButton();
    m_buttonRemoveName.EnableWindow(FALSE);
    m_buttonAddTrap.EnableWindow(FALSE);
}

void CTrapsPage::OnSelectionChangeCommunityName()
// User has changed the community name selection
// load the corresponding trap destination entries in the listbox
{
   int nIndex = m_comboCommunityName.GetCurSel();

   if (nIndex != CB_ERR) {
      LoadTrapDestination(nIndex);
      // Windows Bug# 401218
      // the user has selected a previous entered community name.
      // we should make sure the "Add to list" button is disabled.
      m_buttonAddName.EnableWindow(FALSE);
   }
   else  // there are no items in the combobox
   {
      m_listboxTrapDestinations.ResetContent();
   }
   UpdateCommunityRemoveButton();
   UpdateTrapDestinationButtons();
}

void CTrapsPage::OnClickedButtonAddName()
{
   CString strCommunityName;

   m_comboCommunityName.GetWindowText(strCommunityName);

   int nIndex = m_comboCommunityName.InsertString(-1, strCommunityName);

   if (nIndex >= 0 ) {
      // Create a Trap list item and add to global list
      // the items added to the trap destination will be inserted in
      // this list - see OnClickedAddbuttonAddTrap

      CStringList * pstrList = new CStringList;

      m_pCommunityList->AddHead(pstrList);

      // save list pointer with data
      m_comboCommunityName.SetItemData(nIndex, (ULONG_PTR) pstrList);
      m_comboCommunityName.SetCurSel(nIndex);
      LoadTrapDestination(nIndex);
      UpdateCommunityAddButton();
      UpdateCommunityRemoveButton();
      UpdateTrapDestinationButtons();
      SetDirty(TRUE);
   }
}

void CTrapsPage::OnClickedButtonRemoveName()
{
   int nIndex = m_comboCommunityName.GetCurSel();

   ASSERT(nIndex >= 0 );

   POSITION pos;

   if (nIndex != CB_ERR) {
      ASSERT (m_pCommunityList);

      CStringList * pstrList, * pstrList2;

      pstrList = (CStringList *) m_comboCommunityName.GetItemData(nIndex);

      pos = m_pCommunityList->Find( pstrList);

      if( pos ) {
          pstrList2 = (CStringList *) & m_pCommunityList->GetAt(pos);
            // delete the item from the global list
          m_pCommunityList->RemoveAt(pos);
          delete pstrList;
      }

      // remove the item from the Combo Box
      m_comboCommunityName.DeleteString(nIndex);

      // select item 0 if there are any left
      if (m_comboCommunityName.GetCount()) {
         m_comboCommunityName.SetCurSel(0);
      }
      else
         m_comboCommunityName.SetWindowText(_T(""));

      OnSelectionChangeCommunityName();
      UpdateCommunityRemoveButton();
      UpdateTrapDestinationButtons();
      SetDirty(TRUE);
   }
}

void CTrapsPage::OnClickedButtonAddTrap()
{
   if (m_dlgAdd.DoModal() == IDOK)
   {
      if (m_dlgAdd.m_strName.GetLength()) {
         int nIndex = m_comboCommunityName.GetCurSel();

         if (nIndex >= 0) {

            ULONG_PTR dwData = m_comboCommunityName.GetItemData(nIndex);

            if (dwData != CB_ERR) {

               CStringList * pstrList = (CStringList *) dwData;

               nIndex = m_listboxTrapDestinations.InsertString(-1, m_dlgAdd.m_strName);
               if (nIndex >=0) {
                  SetDirty(TRUE);

                  m_listboxTrapDestinations.SetCurSel(nIndex);

                  CString * pstr = new CString(m_dlgAdd.m_strName);
                  pstrList->AddHead(*pstr);
               }
            }
         }
      }
   }
   UpdateTrapDestinationButtons();
}

void CTrapsPage::OnClickedButtonEditTrap()
{
   int nLBIndex = m_listboxTrapDestinations.GetCurSel();
   int nCBIndex = m_comboCommunityName.GetCurSel();

   if (nCBIndex >=0 && nLBIndex >=0) {
      CString strTrap;

      m_listboxTrapDestinations.GetText(nLBIndex, strTrap);
      ASSERT( strTrap.GetLength() != 0 );
      m_dlgEdit.m_strName = strTrap;

      // present dialog

      if (m_dlgEdit.DoModal() == IDOK)
      {
         if (m_dlgEdit.m_strName.GetLength()) {
            // remove item and then add it
            OnClickedButtonRemoveTrap();

            ULONG_PTR dwData = m_comboCommunityName.GetItemData(nCBIndex);

            if (dwData != CB_ERR) {

               CStringList * pstrList = (CStringList *) dwData;

               nLBIndex = m_listboxTrapDestinations.InsertString(-1, m_dlgEdit.m_strName);
               if (nLBIndex >=0) {
                  SetDirty(TRUE);

                  m_listboxTrapDestinations.SetCurSel(nLBIndex);

                  CString * pstr = new CString(m_dlgEdit.m_strName);
                  pstrList->AddHead(*pstr);
               }
            }
         }
      }
   }
   UpdateTrapDestinationButtons();
}

void CTrapsPage::OnClickedButtonRemoveTrap()
{
   int nCount = -1;
   int nLBIndex = m_listboxTrapDestinations.GetCurSel();
   int nCBIndex = m_comboCommunityName.GetCurSel();

   if (nCBIndex >=0 && nLBIndex >=0) {
      ULONG_PTR dwData = m_comboCommunityName.GetItemData(nCBIndex);
      ASSERT (dwData != CB_ERR);

      CString strTrap;

      m_listboxTrapDestinations.GetText(nLBIndex, strTrap);
      ASSERT( strTrap.GetLength() != 0 );

      if (strTrap.GetLength() != NULL && dwData != CB_ERR) {

         m_listboxTrapDestinations.DeleteString(nLBIndex);
         SetDirty(TRUE);

         CStringList * pStrList = (CStringList*) dwData;

         // find the matching string and remove
         POSITION pos = pStrList->Find(strTrap);
         pStrList->RemoveAt(pos);
         m_dlgAdd.m_strName = strTrap; // save off item removed

         nCount = m_listboxTrapDestinations.GetCount();

         if (nCount) {
            if (nCount != nLBIndex) {
               m_listboxTrapDestinations.SetCurSel(nLBIndex);
            }
            else
            {
               m_listboxTrapDestinations.SetCurSel(nCount-1);
            }
         }
      }
   }
   UpdateTrapDestinationButtons();
   if (nCount == 0)
   {
       // Windows Bug# 401181, 
       // when all the hosts in the Trap destinations list box are removed, 
       // we need to set focus
       m_comboCommunityName.SetFocus();
   }
}

IMPLEMENT_DYNCREATE(CSecurityPage, CPropertyPageBase)

CSecurityPage::CSecurityPage()
    : CPropertyPageBase(CSecurityPage::IDD)
{
    //{{AFX_DATA_INIT(CSecurityPage)
    //}}AFX_DATA_INIT
    m_fPolicyValidCommunities = m_fPolicyPermittedManagers = FALSE;
    
}

CSecurityPage::~CSecurityPage()
{
}

void CSecurityPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPageBase::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSecurityPage)
    DDX_Control(pDX, IDC_LIST_COMMUNITY, m_listboxCommunity);
    DDX_Control(pDX, IDC_BUTTON_ADD_COMMUNITY, m_buttonAddCommunity);
    DDX_Control(pDX, IDC_BUTTON_EDIT_COMMUNITY, m_buttonEditCommunity);
    DDX_Control(pDX, IDC_BUTTON_REMOVE_COMMUNITY, m_buttonRemoveCommunity);
    DDX_Control(pDX, IDC_BUTTON_ADD_HOSTS, m_buttonAddHost);
    DDX_Control(pDX, IDC_BUTTON_EDIT_HOSTS, m_buttonEditHost);
    DDX_Control(pDX, IDC_BUTTON_REMOVE_HOSTS, m_buttonRemoveHost);
    DDX_Control(pDX, IDC_LIST_HOSTS, m_listboxHost);
    DDX_Control(pDX, IDC_CHECK_SEND_AUTH_TRAP, m_checkSendAuthTrap);
    DDX_Control(pDX, IDC_RADIO_ACCEPT_ANY, m_radioAcceptAnyHost);
    DDX_Control(pDX, IDC_RADIO_ACCEPT_SPECIFIC_HOSTS, m_radioAcceptSpecificHost);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSecurityPage, CPropertyPageBase)
    //{{AFX_MSG_MAP(CSecurityPage)
    ON_BN_CLICKED(IDC_BUTTON_ADD_COMMUNITY, OnClickedButtonAddCommunity)
    ON_BN_CLICKED(IDC_BUTTON_EDIT_COMMUNITY, OnClickedButtonEditCommunity)
    ON_BN_CLICKED(IDC_BUTTON_REMOVE_COMMUNITY, OnClickedButtonRemoveCommunity)
    ON_BN_CLICKED(IDC_BUTTON_ADD_HOSTS, OnClickedButtonAddHost)
    ON_BN_CLICKED(IDC_BUTTON_EDIT_HOSTS, OnClickedButtonEditHost)
    ON_BN_CLICKED(IDC_BUTTON_REMOVE_HOSTS, OnClickedButtonRemoveHost)
    ON_BN_CLICKED(IDC_CHECK_SEND_AUTH_TRAP, OnClickedCheckSendAuthTrap)
    ON_BN_CLICKED(IDC_RADIO_ACCEPT_ANY, OnClickedRadioAcceptAnyHost)
    ON_BN_CLICKED(IDC_RADIO_ACCEPT_SPECIFIC_HOSTS, OnClickedRadioAcceptSpecificHost)
    ON_NOTIFY(NM_DBLCLK, IDC_LIST_COMMUNITY, OnDblclkCtrlistCommunity)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST_COMMUNITY, OnCommunityListChanged)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSecurityPage message handlers

BOOL CSecurityPage::OnInitDialog()
{
    CPropertyPageBase::OnInitDialog();
    m_listboxCommunity.OnInitList();

   if (LoadRegistry() == FALSE) {
      AfxMessageBox(IDS_REGISTRY_LOAD_FAILED, MB_ICONSTOP|MB_OK);
   }

   UpdateNameButtons();
   UpdateHostButtons();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CSecurityPage::OnApply()
{
    UpdateData();

    if (m_radioAcceptSpecificHost.GetCheck()) {
       if (m_listboxHost.GetCount() == 0) {
          AfxMessageBox(IDS_ACCEPTHOST_MISSING, MB_ICONSTOP|MB_OK);
          return FALSE;
       }
    }

    if( SaveRegistry() == FALSE )
    {
        AfxMessageBox(IDS_REGISTRY_SAVE_FAILED, MB_ICONSTOP|MB_OK);
        return FALSE;
    }

    BOOL bRet = CPropertyPageBase::OnApply();

    if (bRet == FALSE)
    {
        // Something bad happened... grab the error code
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
//        ::DhcpMessageBox(GetHolder()->GetError());
    }

    return bRet;
}

void CSecurityPage::OnClickedButtonAddCommunity()
{
   CString strText;

   strText.LoadString( IDS_SNMPCOMM_TEXT );

   // change static text of dialog to "Community Name"
   m_dlgAddName.m_bCommunity = TRUE;
   m_dlgAddName.m_nChoice = PERM_BIT_READONLY;

   if (m_dlgAddName.DoModal() == IDOK)
   {
      int nIndex;

      if (m_dlgAddName.m_strName.GetLength()) {
         if ((nIndex = m_listboxCommunity.InsertString(-1, m_dlgAddName.m_strName)) >=0 &&
             m_listboxCommunity.SetItemText(nIndex, 1, m_dlgAddName.m_strChoice) &&
             m_listboxCommunity.SetItemData(nIndex, m_dlgAddName.m_nChoice))
         {
            m_listboxCommunity.SetCurSel(nIndex);
            UpdateNameButtons();
            SetDirty(TRUE);
         }
      }
   }
   // Windows Bug# 401181
   m_buttonAddCommunity.SetFocus();
}


void CSecurityPage::OnClickedButtonEditCommunity()
{
   int nIndex;
   int nPermissions;

   nIndex = m_listboxCommunity.GetCurSel();
   ASSERT(nIndex >= 0);

   if (nIndex < 0) {
      return;
   }

   nPermissions = (int) m_listboxCommunity.GetItemData(nIndex);
   CString strName;

   m_listboxCommunity.GetText(nIndex, strName);

   // save off old string
   m_dlgAddName.m_strName = strName;
   m_dlgAddName.m_nChoice = nPermissions;

   m_dlgEditName.m_bCommunity = TRUE;
   m_dlgEditName.m_strName = strName;
   m_dlgEditName.m_nChoice = nPermissions;

   if (m_dlgEditName.DoModal() == IDOK) {
      // first delete the string from list box
      m_listboxCommunity.DeleteString(nIndex);

      SetDirty(TRUE);

      if ((nIndex = m_listboxCommunity.InsertString(nIndex, m_dlgEditName.m_strName)) >= 0 &&
           m_listboxCommunity.SetItemText(nIndex, 1, m_dlgEditName.m_strChoice) &&
           m_listboxCommunity.SetItemData(nIndex, m_dlgEditName.m_nChoice))
      {
         m_listboxCommunity.SetCurSel(nIndex);
      }
   }
   // Windows Bug# 401181
   m_buttonEditCommunity.SetFocus();
}

void CSecurityPage::OnClickedButtonRemoveCommunity()
{
   int nIndex = m_listboxCommunity.GetCurSel();
   if (nIndex < 0)
       return;

   CString strName;

   m_listboxCommunity.GetText(nIndex, strName);
   // save off removed name for quick add
   m_dlgAddName.m_strName = strName;

   m_listboxCommunity.DeleteString(nIndex);

   int nCount = m_listboxCommunity.GetCount();

   if (nCount != nIndex) {
      m_listboxCommunity.SetCurSel(nIndex);
   }
   else
   {
      m_listboxCommunity.SetCurSel(nCount -1);
   }

   UpdateNameButtons();
   if (0 != nCount)
   {
      // Windows Bug# 401181
      m_buttonRemoveCommunity.SetFocus();
   }
   else
   {
      // all community names are removed, move focus to Community Add button
      m_buttonAddCommunity.SetFocus(); 
   }
   SetDirty(TRUE);
}

void CSecurityPage::UpdateNameButtons()
{
   int nCount = m_listboxCommunity.GetCount();

   m_buttonEditCommunity.EnableWindow(nCount? TRUE: FALSE);
   m_buttonRemoveCommunity.EnableWindow(nCount? TRUE: FALSE);

   if (m_fPolicyValidCommunities)
   {
      m_buttonEditCommunity.EnableWindow(FALSE);
      m_buttonRemoveCommunity.EnableWindow(FALSE);
      m_buttonAddCommunity.EnableWindow(FALSE);
   }
}

void CSecurityPage::OnClickedButtonAddHost()
{
   CString strHostName;

   if (m_dlgAddHost.DoModal() == IDOK) {
      int nIndex;

      if ((nIndex = m_listboxHost.InsertString(-1, m_dlgAddHost.m_strName)) >=0) {
         m_listboxHost.SetCurSel(nIndex);
         m_radioAcceptSpecificHost.SetCheck(1);
         m_radioAcceptAnyHost.SetCheck(0);
         UpdateHostButtons();
         SetDirty(TRUE);
      }
   }
}

void CSecurityPage::OnClickedButtonEditHost()
{
   int nIndex;

   nIndex = m_listboxHost.GetCurSel();
   ASSERT( nIndex >= 0 );

   if (nIndex < 0) {
      return;
   }

   CString strHost;

   m_listboxHost.GetText(nIndex, strHost);
   // save off old host name for quick add
   m_dlgAddHost.m_strName = strHost;
   m_dlgEditHost.m_strName = strHost;

   if (m_dlgEditHost.DoModal() == IDOK) {

      m_listboxHost.DeleteString(nIndex);
      SetDirty(TRUE);

      if ((nIndex = m_listboxHost.InsertString(-1, m_dlgEditHost.m_strName)) >= 0) {
         m_listboxHost.SetCurSel(nIndex);
      }
   }
}

void CSecurityPage::OnClickedButtonRemoveHost()
{
   int nIndex = m_listboxHost.GetCurSel();
   ASSERT(nIndex >= 0);

   CString strHost;

   m_listboxHost.GetText(nIndex, strHost);
   // save off removed host name for quick add
   m_dlgAddHost.m_strName = strHost;

   m_listboxHost.DeleteString(nIndex);

   int nCount = m_listboxHost.GetCount();

   if (nCount != nIndex) {
      m_listboxHost.SetCurSel(nIndex);
   }
   else
   {
      m_listboxHost.SetCurSel(nCount - 1);
   }

   m_radioAcceptSpecificHost.SetCheck(nCount);
   m_radioAcceptAnyHost.SetCheck(!nCount);

   UpdateHostButtons();
   if (nCount == 0)
   {
       // Windows Bug# 401181, 
       // when all the hosts are removed, we need to set the focus
       m_radioAcceptAnyHost.SetFocus();
   }
   SetDirty(TRUE);
}

void CSecurityPage::UpdateHostButtons()
{
   int nCount = m_listboxHost.GetCount();

   m_buttonEditHost.EnableWindow(nCount? TRUE: FALSE);
   m_buttonRemoveHost.EnableWindow(nCount? TRUE: FALSE);

   if (m_fPolicyPermittedManagers)
   {
      m_buttonEditHost.EnableWindow(FALSE);
      m_buttonRemoveHost.EnableWindow(FALSE);
      m_buttonAddHost.EnableWindow(FALSE);
      m_radioAcceptAnyHost.EnableWindow(FALSE);
      m_radioAcceptSpecificHost.EnableWindow(FALSE);
   }
}

void CSecurityPage::OnClickedCheckSendAuthTrap()
{
   SetDirty(TRUE);
}

void CSecurityPage::OnClickedRadioAcceptAnyHost()
{
   m_listboxHost.ResetContent();
   UpdateHostButtons();
   SetDirty(TRUE);
}

void CSecurityPage::OnClickedRadioAcceptSpecificHost()
{
   SetDirty(TRUE);
}

PACL CSecurityPage::AllocACL()
{
   PACL                        pAcl = NULL;
   PSID                        pSidAdmins = NULL;
   SID_IDENTIFIER_AUTHORITY    Authority = SECURITY_NT_AUTHORITY;

   EXPLICIT_ACCESS ea[1];

   // Create a SID for the BUILTIN\Administrators group.
   if ( !AllocateAndInitializeSid( &Authority,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_ADMINS,
                                    0, 0, 0, 0, 0, 0,
                                    &pSidAdmins ))
   {
       return NULL;
   }


   // Initialize an EXPLICIT_ACCESS structure for an ACE.
   ZeroMemory(&ea, 1 * sizeof(EXPLICIT_ACCESS));
    
   // The ACE will allow the Administrators group full access to the key.
   ea[0].grfAccessPermissions = KEY_ALL_ACCESS;
   ea[0].grfAccessMode        = SET_ACCESS;
   ea[0].grfInheritance       = NO_INHERITANCE;
   ea[0].Trustee.TrusteeForm  = TRUSTEE_IS_SID;
   ea[0].Trustee.TrusteeType  = TRUSTEE_IS_GROUP;
   ea[0].Trustee.ptstrName    = (LPTSTR) pSidAdmins;

   // Create a new ACL that contains the new ACEs.
   if (SetEntriesInAcl(1, ea, NULL, &pAcl) != ERROR_SUCCESS) 
   {
       FreeSid(pSidAdmins);
       return NULL;
   }
   FreeSid(pSidAdmins);

   return pAcl;
}

void CSecurityPage::FreeACL( PACL pAcl)
{
   if (pAcl != NULL)
      LocalFree(pAcl);
}
BOOL CSecurityPage::SnmpAddAdminAclToKey(LPTSTR pszKey)
{
    HKEY    hKey = NULL;
    LONG    rc;
    PACL    pAcl = NULL;
    SECURITY_DESCRIPTOR S_Desc;

    if (pszKey == NULL)
        return FALSE;
    
    // open registy key
    rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                        pszKey,          // subkey name
                        0,               // reserved
                        KEY_ALL_ACCESS,  // want WRITE_DAC,
                        &hKey            // handle to open key
                          );
    if (rc != ERROR_SUCCESS)
    {
        return FALSE;
    }
    
    // Initialize a security descriptor.  
    if (InitializeSecurityDescriptor (&S_Desc, SECURITY_DESCRIPTOR_REVISION) == 0)
    {
        RegCloseKey(hKey);
        return FALSE;
    }

    // get the ACL and put it into the security descriptor
    if ( (pAcl = AllocACL()) != NULL )
    {
        if (!SetSecurityDescriptorDacl (&S_Desc, TRUE, pAcl, FALSE))
        {
            FreeACL(pAcl);
            RegCloseKey(hKey);
            return FALSE;
        }
    }
    else
    {
        RegCloseKey(hKey);
        return FALSE;
    }

    if (RegSetKeySecurity (hKey, DACL_SECURITY_INFORMATION, &S_Desc)  != ERROR_SUCCESS)
    {
        FreeACL(pAcl);
        RegCloseKey(hKey);
        return FALSE;
    }

    FreeACL(pAcl);
    RegCloseKey(hKey);
    return TRUE;
}

BOOL CSecurityPage::LoadRegistry()
{
   RegKey           rk;
   LONG             err;
   HRESULT          hr, hrIter;
   RegValueIterator rvIter;
   LPCTSTR lpcszMachineName = g_strMachineName.IsEmpty() ? NULL : (LPCTSTR)g_strMachineName;
   BOOL fPolicy; 

   // we need to provide precedence to the parameters set through the policy
   fPolicy = TRUE;
   if (fPolicy)
   {
       err = rk.Open(HKEY_LOCAL_MACHINE,
                     POLICY_VALID_COMMUNITIES_KEY_NAME,
                     KEY_ALL_ACCESS,
                     lpcszMachineName);
       
       if (err != ERROR_SUCCESS)
          fPolicy = FALSE;
       else
       {
           // remember that we are loading from policy registry
           m_fPolicyValidCommunities = TRUE;
       }

   }

   if (fPolicy == FALSE)
   {
      // Open or create the registry key
      err = rk.Open(HKEY_LOCAL_MACHINE,
                    VALID_COMMUNITIES_KEY_NAME,
                    KEY_ALL_ACCESS,
                    lpcszMachineName);
      if (err != ERROR_SUCCESS)
      {
         err = rk.Create(HKEY_LOCAL_MACHINE,
                         VALID_COMMUNITIES_KEY_NAME,
                         REG_OPTION_NON_VOLATILE,
                         KEY_ALL_ACCESS,
                         NULL,
                         lpcszMachineName);

         if (err != ERROR_SUCCESS)
            return FALSE;
         SnmpAddAdminAclToKey(VALID_COMMUNITIES_KEY_NAME);
      }
   }

   err = rvIter.Init(&rk);
   if (err != ERROR_SUCCESS) {
      return FALSE;
   }

   CString stValue;
   DWORD   dwType;

   for (hr = rvIter.Next(&stValue, &dwType); hr == hrOK; hr = rvIter.Next(&stValue, &dwType)) {
      CString strCommunity;
      DWORD   dwRights;
      int     nIndex;
      char log[128];
      CString Log;

      if (dwType == REG_SZ)
      {
         err = rk.QueryValue(stValue, strCommunity);
         if (err != ERROR_SUCCESS) {
            return FALSE;
         }
         // BUG# 638837
         // For registry value of type REG_SZ, SNMP service interprets it as
         // READ ONLY community name.
         dwRights = 1 << PERM_BIT_READONLY;
      }
      else if (dwType == REG_DWORD)
      {
         strCommunity = stValue;
         err = rk.QueryValue(stValue, dwRights);
         if (err != ERROR_SUCCESS) {
            return FALSE;
         }
      }
      else
          return FALSE;

      if ((nIndex = m_listboxCommunity.InsertString(-1, strCommunity)) >=0)
      {
          int nPermIndex = 0;
          CString strPermName("?????");

          for (nPermIndex = 0; (dwRights & ((DWORD)(-1)^1)) != 0; dwRights >>=1, nPermIndex++);

          if (!strPermName.LoadString(IDS_PERM_NAME0 + nPermIndex))
              return FALSE;
          
          if (!m_listboxCommunity.SetItemText(nIndex, 1, strPermName) ||
              !m_listboxCommunity.SetItemData(nIndex, nPermIndex))
          {
              return FALSE;
          }
      }
      else
      {
         return FALSE;
      }
   }

   if (m_listboxCommunity.GetCount()) {
      m_listboxCommunity.SetCurSel(0);
   }

   rk.Close();
   


   // we need to provide precedence to the parameters set through the policy
   fPolicy = TRUE;
   if (fPolicy)
   {
       err = rk.Open(HKEY_LOCAL_MACHINE,
                     POLICY_PERMITTED_MANAGERS_KEY_NAME,
                     KEY_ALL_ACCESS,
                     lpcszMachineName);
       
       if (err != ERROR_SUCCESS)
          fPolicy = FALSE;
       else
       {
           // remember that we are loading from policy registry
           m_fPolicyPermittedManagers = TRUE;
       }

   }

   if (fPolicy == FALSE)
   {
      // Open or create the registry key
      err = rk.Open(HKEY_LOCAL_MACHINE,
                    PERMITTED_MANAGERS_KEY_NAME,
                    KEY_ALL_ACCESS,
                    lpcszMachineName);
      if (err != ERROR_SUCCESS)
      {
         err = rk.Create(HKEY_LOCAL_MACHINE,
                         PERMITTED_MANAGERS_KEY_NAME,
                         REG_OPTION_NON_VOLATILE,
                         KEY_ALL_ACCESS,
                         NULL,
                         lpcszMachineName);

         if (err != ERROR_SUCCESS)
            return FALSE;
         SnmpAddAdminAclToKey(PERMITTED_MANAGERS_KEY_NAME);
      }
   }

   err = rvIter.Init(&rk);
   if (err != ERROR_SUCCESS) {
      return FALSE;
   }

   for (hr = rvIter.Next(&stValue, NULL); hr == hrOK; hr = rvIter.Next(&stValue, NULL)) {
      CString strHost;

      err = rk.QueryValue(stValue, strHost);
      if (err != ERROR_SUCCESS) {
         return FALSE;
      }
      m_listboxHost.InsertString(-1, strHost);
   }

   if (m_listboxHost.GetCount()) {
      m_radioAcceptSpecificHost.SetCheck(1);
      m_listboxHost.SetCurSel(0);
   }
   else
   {
      m_radioAcceptAnyHost.SetCheck(1);
   }

   rk.Close();

   // Open or create the registry key
   err = rk.Open(HKEY_LOCAL_MACHINE,
                 SNMP_PARAMS_KEY_NAME,
                 KEY_ALL_ACCESS,
                 lpcszMachineName);
   if (err != ERROR_SUCCESS)
   {
       // This can't fail as far as all the other keys could be opened before
       // however ... just to make sure
       return FALSE;
   }

   DWORD dwSwitch;

   // get the value for the authentication trap flag
   err = rk.QueryValue(ENABLE_AUTH_TRAPS, dwSwitch);

   if (err != ERROR_SUCCESS)
      return FALSE;

   m_checkSendAuthTrap.SetCheck(dwSwitch);

   return TRUE;
}

BOOL CSecurityPage::SaveRegistry()
{
   RegKey  rk;
   LONG    err;
   CString strContact;
   CString strLocation;
   DWORD   dwServices = 0;
   LPCTSTR lpcszMachineName = g_strMachineName.IsEmpty() ? NULL : (LPCTSTR)g_strMachineName;

   if (m_fPolicyValidCommunities == FALSE)
   {
      // Open or create the registry key
      err = rk.Open(HKEY_LOCAL_MACHINE,
                    SNMP_PARAMS_KEY_NAME,
                    KEY_ALL_ACCESS,
                    lpcszMachineName);
      if (err != ERROR_SUCCESS)
      {
         return FALSE;
      }

      // If it already exists, delete the key first
      err = rk.RecurseDeleteKey(VALID_COMMUNITIES);
      if (err != ERROR_SUCCESS) {
         return FALSE;
      }

      // recreate the key now
      err = rk.Create(HKEY_LOCAL_MACHINE,
                      VALID_COMMUNITIES_KEY_NAME,
                      REG_OPTION_NON_VOLATILE,
                      KEY_ALL_ACCESS,
                      NULL,
                      lpcszMachineName);
      if (err != ERROR_SUCCESS)
         return FALSE;
      SnmpAddAdminAclToKey(VALID_COMMUNITIES_KEY_NAME);

      int nCount = m_listboxCommunity.GetCount();

      for (int i = 0; i < nCount; i++) {
         DWORD dwPermissions;
         CString strCommunity;

         m_listboxCommunity.GetText(i, strCommunity);
         dwPermissions = 1 << (DWORD) m_listboxCommunity.GetItemData(i);

         err = rk.SetValue(strCommunity, dwPermissions);
         if (err != ERROR_SUCCESS) {
            return FALSE;
         }
      }
      rk.Close();

   }
   
   if (m_fPolicyPermittedManagers == FALSE)
   {
      // Open or create the registry key
      err = rk.Open(HKEY_LOCAL_MACHINE,
                    SNMP_PARAMS_KEY_NAME,
                    KEY_ALL_ACCESS,
                    lpcszMachineName);
      if (err != ERROR_SUCCESS)
      {
      }

      // delete the key first
      err = rk.RecurseDeleteKey(PERMITTED_MANAGERS);
      if (err != ERROR_SUCCESS) {
         return FALSE;
      }

      // recreate the key now
      err = rk.Create(HKEY_LOCAL_MACHINE,
                      PERMITTED_MANAGERS_KEY_NAME,
                      REG_OPTION_NON_VOLATILE,
                      KEY_ALL_ACCESS,
                      NULL,
                      lpcszMachineName);
      if (err != ERROR_SUCCESS)
         return FALSE;
      SnmpAddAdminAclToKey(PERMITTED_MANAGERS_KEY_NAME);

      int nCount = m_listboxHost.GetCount();

      for (int i = 0; i < nCount; i++) {
         TCHAR buffer[32];
         CString strHost;

         wsprintf(buffer, TEXT("%d"), i+1);
         m_listboxHost.GetText(i, strHost);
         err = rk.SetValue(buffer, strHost);
         if (err != ERROR_SUCCESS) {
            return FALSE;
         }
      }

      rk.Close();
   }

   // Open or create the registry key
   err = rk.Open(HKEY_LOCAL_MACHINE,
                 SNMP_PARAMS_KEY_NAME,
                 KEY_ALL_ACCESS,
                 lpcszMachineName);
   if (err != ERROR_SUCCESS)
   {
       return FALSE;
   }

   DWORD dwSwitch = (m_checkSendAuthTrap.GetCheck() ? 0x1 : 0 ) ;

   err = rk.SetValue(ENABLE_AUTH_TRAPS, dwSwitch);
   if (err != ERROR_SUCCESS)
      return FALSE;
   
   
   return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAddDialog dialog


CAddDialog::CAddDialog(CWnd* pParent /*=NULL*/)
    : CBaseDialog(CAddDialog::IDD, pParent)
{
   m_bCommunity = FALSE;
   m_nChoice = 0;
    //{{AFX_DATA_INIT(CAddDialog)
    //}}AFX_DATA_INIT
}


void CAddDialog::DoDataExchange(CDataExchange* pDX)
{
    CBaseDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAddDialog)
    DDX_Control(pDX, IDC_EDIT_NAME, m_editName);
    DDX_Control(pDX, IDC_ADD, m_buttonAdd);
    DDX_Control(pDX, IDCANCEL, m_buttonCancel);
    DDX_Control(pDX, IDC_STATIC_ADD_TEXT, m_staticText);
    DDX_Control(pDX, IDC_ST_PERMISSIONS, m_staticPermissions);
    DDX_Control(pDX, IDC_CB_PERMISSIONS, m_comboPermissions);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddDialog, CBaseDialog)
    //{{AFX_MSG_MAP(CAddDialog)
    ON_BN_CLICKED(IDC_ADD, OnClickedButtonAdd)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddDialog message handlers

BOOL CAddDialog::OnInitDialog()
{
    CBaseDialog::OnInitDialog();

    m_editName.SetLimitText(COMBO_EDIT_LEN-1);
    m_editName.SetWindowText(m_strName);
    m_editName.SetFocus();
    m_editName.SetSel(0, -1);

    if (m_bCommunity) {
       CString strText;

       strText.LoadString( IDS_SNMPCOMM_TEXT );
       m_staticPermissions.ShowWindow(SW_SHOW);
       m_comboPermissions.ShowWindow(SW_SHOW);
       m_comboPermissions.ResetContent();
       for (int i = 0; i<N_PERMISSION_BITS; i++)
       {
           CString strPermName;
           int idx;
           
           if (!strPermName.LoadString(IDS_PERM_NAME0 + i) ||
               (idx=m_comboPermissions.AddString(strPermName))<0 ||
               !m_comboPermissions.SetItemData(idx, i))
               return FALSE;

       }
       m_comboPermissions.SetCurSel(m_nChoice);

       // change static text of dialog to "Community Name"
       m_staticText.SetWindowText(strText);
    }
    return FALSE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CAddDialog::OnClickedButtonAdd()
{
    m_editName.GetWindowText(m_strName);

    if (!m_bCommunity && IsValidString(m_strName) == FALSE)
    {
       m_editName.SetFocus();
       m_editName.SetSel(0,-1);

       return ;
    }
    if (m_bCommunity)
    {
        m_nChoice = m_comboPermissions.GetCurSel();
        m_comboPermissions.GetWindowText(m_strChoice);
    }

    CBaseDialog::OnOK();
}

DWORD * CAddDialog::GetHelpMap()
{
    return m_bCommunity ?
        (DWORD *) &g_aHelpIDs_IDD_DIALOG_ADD_COMM[0]:
        (DWORD *) &g_aHelpIDs_IDD_DIALOG_ADD_ADDR[0];
}

/////////////////////////////////////////////////////////////////////////////
// CEditDialog dialog


CEditDialog::CEditDialog(CWnd* pParent /*=NULL*/)
    : CBaseDialog(CEditDialog::IDD, pParent)
{
    m_bCommunity = FALSE;
    m_nChoice = 0;
    //{{AFX_DATA_INIT(CEditDialog)
    //}}AFX_DATA_INIT
}

void CEditDialog::DoDataExchange(CDataExchange* pDX)
{
    CBaseDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CEditDialog)
    DDX_Control(pDX, IDC_EDIT_NAME, m_editName);
    DDX_Control(pDX, IDOK, m_buttonOk);
    DDX_Control(pDX, IDCANCEL, m_buttonCancel);
    DDX_Control(pDX, IDC_STATIC_EDIT_TEXT, m_staticText);
    DDX_Control(pDX, IDC_ST_PERMISSIONS, m_staticPermissions);
    DDX_Control(pDX, IDC_CB_PERMISSIONS, m_comboPermissions);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CEditDialog, CBaseDialog)
    //{{AFX_MSG_MAP(CEditDialog)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEditDialog message handlers

BOOL CEditDialog::OnInitDialog()
{
    CBaseDialog::OnInitDialog();

    m_editName.SetLimitText(COMBO_EDIT_LEN-1);
    m_editName.SetWindowText(m_strName);
    m_editName.SetFocus();
    // select the entire string in the edit control
    m_editName.SetSel(0, -1);

    if (m_bCommunity) {
       CString strText;

       strText.LoadString( IDS_SNMPCOMM_TEXT );
       m_staticPermissions.ShowWindow(SW_SHOW);
       m_comboPermissions.ShowWindow(SW_SHOW);
       m_comboPermissions.ResetContent();
       for (int i = 0; i<N_PERMISSION_BITS; i++)
       {
           CString strPermName;
           int idx;
           
           if (!strPermName.LoadString(IDS_PERM_NAME0 + i) ||
               (idx=m_comboPermissions.AddString(strPermName))<0 ||
               !m_comboPermissions.SetItemData(idx, i))
           {
               AfxMessageBox(strPermName);
               return FALSE;
           }

       }
       m_comboPermissions.SetCurSel(m_nChoice);

       // change static text of dialog to "Community Name"
       m_staticText.SetWindowText(strText);
    }

    return FALSE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CEditDialog::OnOK()
{
    m_editName.GetWindowText(m_strName);

    if (!m_bCommunity) {
       if (IsValidString(m_strName) == FALSE)
       {
          m_editName.SetFocus();
          return ;
       }
    }
    else
    {
        m_comboPermissions.GetWindowText(m_strChoice);
        m_nChoice = m_comboPermissions.GetCurSel();
    }
    CBaseDialog::OnOK();
}

DWORD * CEditDialog::GetHelpMap()
{
    return m_bCommunity ?
        (DWORD *) &g_aHelpIDs_IDD_DIALOG_EDIT_COMM[0] :
        (DWORD *) &g_aHelpIDs_IDD_DIALOG_EDIT_ADDR[0];
}

BOOL IsValidString(CString & strName)
{
    BOOL bResult = FALSE;

    // check if this is a valid IP host name or address
    if (ValidateDomain(strName) == TRUE)
        return(TRUE);

    int nLen = strName.GetLength();

    if (nLen == 0 || nLen > 12) {
       CString strMsg;

       strMsg.FormatMessage(IDS_SNMP_INVALID_IP_IPX_ADD, strName);
       AfxMessageBox(strMsg, MB_ICONEXCLAMATION|MB_OK);
       return FALSE;
    }

    LPTSTR buffer = strName.GetBuffer(64);

    for (int i = 0; i < nLen; i++) {
       if (!iswxdigit((int) buffer[i])) {
          CString strMsg;

          strName.ReleaseBuffer();
          strMsg.FormatMessage(IDS_SNMP_INVALID_IP_IPX_ADD, strName);
          AfxMessageBox(strMsg, MB_ICONEXCLAMATION|MB_OK);
          return FALSE;
       }
    }

    return TRUE;
}

BOOL ValidateDomain(CString & strDomain)
{
    int nLen;

    if ((nLen = strDomain.GetLength()) != 0)
    {
        if (nLen < DOMAINNAME_LENGTH)
        {
            int i;
            TCHAR ch;
            BOOL fLet_Dig = FALSE;
            BOOL fDot = FALSE;
            int cHostname = 0;
            LPTSTR buffer = strDomain.GetBuffer(64);

            for (i = 0; i < nLen; i++)
            {
                // check each character
                ch = buffer[i];

                BOOL fAlNum = iswalpha(ch) || iswdigit(ch);

                if (((i == 0) && !fAlNum) ||
                        // first letter must be a digit or a letter
                    (fDot && !fAlNum) ||
                        // first letter after dot must be a digit or a letter
                    ((i == (nLen - 1)) && !fAlNum) ||
                        // last letter must be a letter or a digit
                    (!fAlNum && ( ch != _T('-') && ( ch != _T('.') && ( ch != _T('_'))))) ||
                        // must be letter, digit, - or "."
                    (( ch == _T('.')) && ( !fLet_Dig )))
                        // must be letter or digit before '.'
                {
                    return FALSE;
                }
                fLet_Dig = fAlNum;
                fDot = (ch == _T('.'));
                cHostname++;
                if ( cHostname > HOSTNAME_LENGTH )
                {
                    return FALSE;
                }
                if ( fDot )
                {
                    cHostname = 0;
                }
            }
        }
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}

void CSecurityPage::OnDblclkCtrlistCommunity(NMHDR* pNMHDR, LRESULT* pResult) 
{
   if (m_fPolicyValidCommunities == FALSE)
      OnClickedButtonEditCommunity();

    *pResult = 0;
}

void CSecurityPage::OnCommunityListChanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
    INT nIndex;
    NMLVODSTATECHANGE* pStateChanged = (NMLVODSTATECHANGE*)pNMHDR;
    // TODO: Add your control notification handler code here

    nIndex = m_listboxCommunity.GetCurSel();

    m_buttonEditCommunity.EnableWindow(nIndex >= 0);
    m_buttonRemoveCommunity.EnableWindow(nIndex >= 0);

   if (m_fPolicyValidCommunities)
   {
      m_buttonEditCommunity.EnableWindow(FALSE);
      m_buttonRemoveCommunity.EnableWindow(FALSE);
   }
    
   *pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\snmp\stdafx.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997-1999                 **/
/**********************************************************************/

/*
    stdafx.cpp
		include file for standard system include files,
		or project specific include files that are used frequently,
		but are changed infrequently

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\snmp\snmpsnap.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997-1999                 **/
/**********************************************************************/

/*
	snmpsnap.h
		This file contains the constant definitions for the snap-in
		
    FILE HISTORY:

*/

#define AGENT_REG_KEY_NAME   _T("System\\CurrentControlSet\\Services\\SNMP\\Parameters\\RFC1156Agent")
#define SNMP_PARAMS_KEY_NAME _T("System\\CurrentControlSet\\Services\\SNMP\\Parameters")
#define TRAP_CONFIG_KEY_NAME _T("System\\CurrentControlSet\\Services\\SNMP\\Parameters\\TrapConfiguration")
#define VALID_COMMUNITIES_KEY_NAME _T("System\\CurrentControlSet\\Services\\SNMP\\Parameters\\ValidCommunities")
#define PERMITTED_MANAGERS_KEY_NAME _T("System\\CurrentControlSet\\Services\\SNMP\\Parameters\\PermittedManagers")

// Group Policy related registry keys
#define POLICY_TRAP_CONFIG_KEY_NAME _T("SOFTWARE\\Policies\\SNMP\\Parameters\\TrapConfiguration")
#define POLICY_VALID_COMMUNITIES_KEY_NAME _T("SOFTWARE\\Policies\\SNMP\\Parameters\\ValidCommunities")
#define POLICY_PERMITTED_MANAGERS_KEY_NAME _T("SOFTWARE\\Policies\\SNMP\\Parameters\\PermittedManagers")


#define SNMP_CONTACT        _T("sysContact")
#define SNMP_LOCATION       _T("sysLocation")
#define SNMP_SERVICES       _T("sysServices")
#define TRAP_CONFIGURATION  _T("TrapConfiguration")
#define ENABLE_AUTH_TRAPS   _T("EnableAuthenticationTraps")
#define NAME_RESOLV_RETRIES _T("NameResolutionRetries")
#define VALID_COMMUNITIES   _T("ValidCommunities")
#define PERMITTED_MANAGERS  _T("PermittedManagers")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\snmp\snmp_cn.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       snmp_cn.h
//
//--------------------------------------------------------------------------

#define IDH_11704_237	15543736	// Security: "List1" (SysListView32)
#define IDH_11704_238	15609272	// Security: "A&dd..." (Button)
#define IDH_11704_239	15674808	// Security: "" (ListBox)
#define IDH_11704_240	15740344	// Security: "Add&..." (Button)
#define IDH_11704_241	15805880	// Security: "Re&move" (Button)
#define IDH_11704_242	15871416	// Security: "A&ccept SNMP Packets from Any Host" (Button)
#define IDH_30721_100	6584321	// New: "" (ListBox)
#define IDH_11704_243	15936952	// Security: "Accept SNMP Packets from &These Hosts" (Button)
#define IDH_5001_5111	334959497	// Customize Columns: "List1" (SysListView32)
#define IDH_11705_244	16002489	// SNMP Service Configuration: "" (Edit)
#define IDH_5001_5112	335025033	// Customize Columns: "Move &up" (Button)
#define IDH_11705_245	16068025	// SNMP Service Configuration: "&Host name, IP or IPX Address:" (Static)
#define IDH_11701_222	14560693	// Agent: "" (Edit)
#define IDH_5001_5113	335090569	// Customize Columns: "Move &down" (Button)
#define IDH_11701_223	14626229	// Agent: "" (Edit)
#define IDH_5001_5114	335156105	// Customize Columns: "Use Defaults" (Button)
#define IDH_11701_224	14691765	// Agent: "&Contact:" (Static)
#define IDH_5003_5115	335221643	// Untitled: "" (Static)
#define IDH_11701_225	14757301	// Agent: "&Location:" (Static)
#define IDH_5003_5116	335287179	// Untitled: "Animate2" (SysAnimate32)
#define IDH_11701_226	14822837	// Agent: "Service" (Button)
#define IDH_11705_250	16395705	// SNMP Service Configuration: "" (ComboBox)
#define IDH_11701_227	14888373	// Agent: "&Physical" (Button)
#define IDH_210_244	15990994	// SNMP Service Configuration: "" (Edit)
#define IDH_11705_251	16461241	// SNMP Service Configuration: "Community &Rights" (Static)
#define IDH_11701_228	14953909	// Agent: "Applica&tions" (Button)
#define IDH_11703_229	15019447	// Traps: "Add to &list" (Button)
#define IDH_11701_229	15019445	// Agent: "&Datalink / Subnetwork" (Button)
#define IDH_210_246	16122066	// SNMP Service Configuration: "&Host name, IP or IPX Address:" (Static)
#define IDH_11703_230	15084983	// Traps: "&Remove from list" (Button)
#define IDH_11701_230	15084981	// Agent: "&Internet" (Button)
#define IDH_210_247	16187602	// SNMP Service Configuration: "&Add" (Button)
#define IDH_11701_231	15150517	// Agent: "&End-to-End" (Button)
#define IDH_11703_232	15216055	// Traps: "A&dd..." (Button)
#define IDH_30721_57670	3779491841	// New: "&Help" (Button)
#define IDH_5002_5100	334238602	// Untitled: "List1" (SysListView32)
#define IDH_5000_5100	334238600	// Untitled: "List1" (SysListView32)
#define IDH_11704_233	15281592	// Security: "Send A&uthentication Trap" (Button)
#define IDH_11703_233	15281591	// Traps: "&Edit..." (Button)
#define IDH_5002_5101	334304138	// Untitled: "&Refresh" (Button)
#define IDH_5000_5101	334304136	// Untitled: "&Refresh" (Button)
#define IDH_210_250	16384210	// SNMP Service Configuration: "" (ComboBox)
#define IDH_11704_234	15347128	// Security: "&Edit..." (Button)
#define IDH_11703_234	15347127	// Traps: "Re&move" (Button)
#define IDH_5002_5102	334369674	// Untitled: "&Columns" (Button)
#define IDH_5000_5102	334369672	// Untitled: "&Select Columns" (Button)
#define IDH_210_251	16449746	// SNMP Service Configuration: "Community &Rights" (Static)
#define IDH_11704_235	15412664	// Security: "&Remove" (Button)
#define IDH_11703_235	15412663	// Traps: "" (ComboBox)
#define IDH_5002_5103	334435210	// Untitled: "C&lear" (Button)
#define IDH_5000_5103	334435208	// Untitled: "C&lear" (Button)
#define IDH_11704_236	15478200	// Security: "Ed&it..." (Button)
#define IDH_11703_236	15478199	// Traps: "" (ListBox)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\snmp\snmpsnap.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997-1999                 **/
/**********************************************************************/

/*
    smplsnap.cpp
        Snapin entry points/registration functions
        
        Note: Proxy/Stub Information
            To build a separate proxy/stub DLL,
            run nmake -f Snapinps.mak in the project directory.

    FILE HISTORY:

*/

#include "stdafx.h"
#include "initguid.h"
#include "register.h"
#include "tfsguid.h"

//
// NOTE: The next three items should be changed for each different snapin.
//

// {7AF60DD2-4979-11d1-8A6C-00C04FC33566}
const CLSID CLSID_SnmpSnapin = 
{ 0x7af60dd2, 0x4979, 0x11d1, { 0x8a, 0x6c, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x66 } };

// {7AF60DD3-4979-11d1-8A6C-00C04FC33566}
const GUID CLSID_SnmpSnapinExtension = 
{ 0x7af60dd3, 0x4979, 0x11d1, { 0x8a, 0x6c, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x66 } };

// {7AF60DD4-4979-11d1-8A6C-00C04FC33566}
const GUID CLSID_SnmpSnapinAbout =
{ 0x7af60dd4, 0x4979, 0x11d1, { 0x8a, 0x6c, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x66 } };

// {7AF60DD5-4979-11d1-8A6C-00C04FC33566}
const GUID GUID_SnmpRootNodeType =
{ 0x7af60dd5, 0x4979, 0x11d1, { 0x8a, 0x6c, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x66 } };

// Copied and defined from ..\..\filemgmt for structuuidNodetypeService due to compiler error

// {4e410f16-abc1-11d0-b944-00c04fd8d5b0} 
const CLSID CLSID_NodetypeService =
{ 0x4e410f16, 0xabc1, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };

// {58221C66-EA27-11CF-ADCF-00AA00A80033} 
const CLSID CLSID_NodetypeServices =
{ 0x58221C66, 0xEA27, 0x11CF, { 0xAD, 0xCF, 0x0, 0xAA, 0x0, 0xA8, 0x0, 0x33 } };

//
// Internal private format
//
//const wchar_t* SNAPIN_INTERNAL = _T("SNAPIN_INTERNAL");

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_SnmpSnapin, CSnmpComponentDataPrimary)
    OBJECT_ENTRY(CLSID_SnmpSnapinExtension, CSnmpComponentDataExtension)
    OBJECT_ENTRY(CLSID_SnmpSnapinAbout, CSnmpAbout)
END_OBJECT_MAP()

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

class CSnmpSnapinApp : public CWinApp
{
public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
};

CSnmpSnapinApp theApp;
CString        g_strMachineName;

BOOL CSnmpSnapinApp::InitInstance()
{
    _Module.Init(ObjectMap, m_hInstance);
    return CWinApp::InitInstance();
}

int CSnmpSnapinApp::ExitInstance()
{
    _Module.Term();

    return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    CString strSnapinExtension;
    CString strSnapinExtensionNameIndirect;
    TCHAR   szModuleFileName[MAX_PATH * 2 + 1] = {0};
    BOOL    fGotModuleName = TRUE;
    DWORD   dwRet;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    
    dwRet = ::GetModuleFileName(_Module.GetModuleInstance(),
                                szModuleFileName,
                                DimensionOf(szModuleFileName)-1);

    // According to BUG# 559631,
    // when truncation happens, GetModuleFileName will null terminate the 
    // string and the size of the buffer is returned. The size returned is 
    // the same as the size of the passed in parameter.

    // 0 return or string truncation are considered as failure
    fGotModuleName = ( (0 != dwRet) && ((DimensionOf(szModuleFileName)-1) != dwRet) );

    //
    // registers object, typelib and all interfaces in typelib
    //
    HRESULT hr = _Module.RegisterServer(/* bRegTypeLib */ FALSE);
    ASSERT(SUCCEEDED(hr));
    
    if (FAILED(hr))
        return hr;

    strSnapinExtension.LoadString(IDS_SNAPIN_DESC);
    strSnapinExtensionNameIndirect.Format(L"@%s,-%-d", szModuleFileName, IDS_SNAPIN_DESC);

    //
    // register the snapin as an extension snapin in the console snapin list
    //
    hr = RegisterSnapinGUID(&CLSID_SnmpSnapinExtension,
                        NULL,
                        &CLSID_SnmpSnapinAbout,
                        strSnapinExtension,
                        _T("1.0"),
                        FALSE,
                        fGotModuleName ? (LPCTSTR)strSnapinExtensionNameIndirect : NULL);
    ASSERT(SUCCEEDED(hr));
    
    if (FAILED(hr))
        return hr;
    //
    // register as an extension of the system service snapin 
    //

    // EricDav 2/18/98 - this now means register as a dynamic extension
    // so until the parent of this snapin supports dynamic extensions, 
    // leave the last parameter NULL.
    hr = RegisterAsRequiredExtensionGUID(&CLSID_NodetypeService,
                                         &CLSID_SnmpSnapinExtension,
                                         strSnapinExtension,
                                         EXTENSION_TYPE_PROPERTYSHEET,
                                         NULL //&CLSID_NodetypeServices
                                        );
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr  = _Module.UnregisterServer();
    ASSERT(SUCCEEDED(hr));
    
    if (FAILED(hr))
        return hr;
    
    // un register the snapin
    //
    hr = UnregisterSnapinGUID(&CLSID_SnmpSnapinExtension);
    ASSERT(SUCCEEDED(hr));
    
    if (FAILED(hr))
        return hr;

    // unregister the snapin nodes
    //
    hr = UnregisterAsRequiredExtensionGUID(&CLSID_NodetypeService,
                                           &CLSID_SnmpSnapinExtension,
                                           EXTENSION_TYPE_PROPERTYSHEET,
                                           NULL //&CLSID_NodetypeServices
                                          );
    
    ASSERT(SUCCEEDED(hr));
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\dlgaddm.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       dlgaddm.cpp
//
//--------------------------------------------------------------------------

// dlgaddm.cpp : implementation file
//

#include "stdafx.h"
#include "dlgaddm.h"
#include "shlobj.h"  // shell 32 version

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddMachineDlg dialog


CAddMachineDlg::CAddMachineDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CAddMachineDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAddMachineDlg)
	m_strMachineName = _T("");
	//}}AFX_DATA_INIT
}


void CAddMachineDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddMachineDlg)
	DDX_Text(pDX, IDC_REMOTENAME, m_strMachineName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddMachineDlg, CDialog)
	//{{AFX_MSG_MAP(CAddMachineDlg)
	ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddMachineDlg message handlers

void CAddMachineDlg::OnBrowse() 
{
    BROWSEINFO BrowseInfo;
    LPITEMIDLIST pidlComputer;
    TCHAR szRemoteName[4096];
    IMalloc * pMalloc;

    BrowseInfo.hwndOwner = GetSafeHwnd();
    BrowseInfo.pidlRoot = (LPITEMIDLIST) MAKEINTRESOURCE(CSIDL_NETWORK);
    BrowseInfo.pszDisplayName = szRemoteName;
    BrowseInfo.lpszTitle = _T("Click on the computer you want to connect to.");//LoadDynamicString(IDS_COMPUTERBROWSETITLE);
    BrowseInfo.ulFlags = BIF_BROWSEFORCOMPUTER;
    BrowseInfo.lpfn = NULL;

    if ((pidlComputer = SHBrowseForFolder(&BrowseInfo)) != NULL) 
    {
        SHGetMalloc(&pMalloc);
        pMalloc->Free(pidlComputer);
        pMalloc->Release();

        Trace1("User selected %s\n", szRemoteName);

        GetDlgItem(IDC_REMOTENAME)->SetWindowText(szRemoteName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\dlgaddm.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       dlgaddm.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_DLGADDM_H__C2A9C6F6_5628_11D1_9AA9_00C04FC3357A__INCLUDED_)
#define AFX_DLGADDM_H__C2A9C6F6_5628_11D1_9AA9_00C04FC3357A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// dlgaddm.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAddMachineDlg dialog

class CAddMachineDlg : public CDialog
{
// Construction
public:
	CAddMachineDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAddMachineDlg)
	enum { IDD = IDD_ADD_MACHINE };
	CString	m_strMachineName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddMachineDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddMachineDlg)
	afx_msg void OnBrowse();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGADDM_H__C2A9C6F6_5628_11D1_9AA9_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\snmp\stdafx.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997-1999                 **/
/**********************************************************************/

/*
    stdafx.h
        include file for standard system include files,
        or project specific include files that are used frequently,
        but are changed infrequently

    FILE HISTORY:

*/

#include <afxwin.h>
#include <afxdisp.h>
#include <afxcmn.h>
#include <afxdlgs.h>
#include <afxtempl.h>

#include <atlbase.h>

#include <commctrl.h>

//
// You may derive a class from CComModule and use it if you want to override
// something, but do not change the name of _Module
//
extern CComModule _Module;
#include <atlcom.h>

#include <mmc.h>

#include <aclapi.h> // for adding admin acl to registry subkey

// from stub_extract_string.cpp
HRESULT ExtractString( IDataObject* piDataObject,
                       CLIPFORMAT   cfClipFormat,
                       CString*     pstr,
                       DWORD        cchMaxLength );

//
// Constants used in samples
//
const int NUM_FOLDERS = 2;
const int MAX_COLUMNS = 1;

//
// Types of folders
//
enum FOLDER_TYPES
{
    SAMPLE_ROOT,
    SAMPLE_DUMMY,
    NONE
};

extern LPCWSTR g_lpszNullString;

extern const CLSID      CLSID_SnmpSnapin;               // In-Proc server GUID
extern const CLSID      CLSID_SnmpSnapinExtension;  // In-Proc server GUID
extern const CLSID      CLSID_SnmpSnapinAbout;      // In-Proc server GUID
extern const GUID       GUID_SnmpRootNodeType;      // Main NodeType GUID on numeric format

//
// New Clipboard format that has the Type and Cookie
//
extern const wchar_t*   SNAPIN_INTERNAL;

//
// NOTE: Right now all header files are included from here.  It might be a good
// idea to move the snapin specific header files out of the precompiled header.
//
#include "resource.h"
#include <snapbase.h>
#include <dialog.h>
#include "ccdata.h"
#include "snmpcomp.h"
#include "snmp_cn.h"
#include "helparr.h"

// Note - These are offsets into my image list
typedef enum _IMAGE_INDICIES
{
    IMAGE_IDX_FOLDER_CLOSED,
    IMAGE_IDX_NA1,
    IMAGE_IDX_NA2,
    IMAGE_IDX_NA3,
    IMAGE_IDS_NA4,
    IMAGE_IDX_FOLDER_OPEN
} IMAGE_INDICIES, *LPIMAGE_INDICIES;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\snmp\stub_extract_string.cpp ===
#include <stdafx.h>
#include <afx.h>
#include <ole2.h>
#include <basetyps.h>
#include <atlbase.h>
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       cstr.h
//
//--------------------------------------------------------------------------

#ifndef __STR_H__
#define __STR_H__

#include <tchar.h>

#define STRAPI __stdcall
struct _STR_DOUBLE  { BYTE doubleBits[sizeof(double)]; };

BOOL STRAPI IsValidString(LPCSTR lpsz, int nLength);
BOOL STRAPI IsValidString(LPCWSTR lpsz, int nLength);

BOOL STRAPI IsValidAddressz(const void* lp, UINT nBytes, BOOL bReadWrite=TRUE);

int  STRAPI StrLoadString(HINSTANCE hInst, UINT nID, LPTSTR lpszBuf); 

class CStr
{
public:

// Constructors
    CStr();
    CStr(const CStr& stringSrc);
    CStr(TCHAR ch, int nRepeat = 1);
    CStr(LPCSTR lpsz);
    CStr(LPCWSTR lpsz);
    CStr(LPCTSTR lpch, int nLength);
    CStr(const unsigned char* psz);

// Attributes & Operations
    // as an array of characters
    int GetLength() const;
    BOOL IsEmpty() const;
    void Empty();                       // free up the data

    TCHAR GetAt(int nIndex) const;      // 0 based
    TCHAR operator[](int nIndex) const; // same as GetAt
    void SetAt(int nIndex, TCHAR ch);
    operator LPCTSTR() const;           // as a C string

    // overloaded assignment
    const CStr& operator=(const CStr& stringSrc);
    const CStr& operator=(TCHAR ch);
#ifdef UNICODE
    const CStr& operator=(char ch);
#endif
    const CStr& operator=(LPCSTR lpsz);
    const CStr& operator=(LPCWSTR lpsz);
    const CStr& operator=(const unsigned char* psz);

    // string concatenation
    const CStr& operator+=(const CStr& string);
    const CStr& operator+=(TCHAR ch);
#ifdef UNICODE
    const CStr& operator+=(char ch);
#endif
    const CStr& operator+=(LPCTSTR lpsz);

    friend CStr STRAPI operator+(const CStr& string1,
            const CStr& string2);
    friend CStr STRAPI operator+(const CStr& string, TCHAR ch);
    friend CStr STRAPI operator+(TCHAR ch, const CStr& string);
#ifdef UNICODE
    friend CStr STRAPI operator+(const CStr& string, char ch);
    friend CStr STRAPI operator+(char ch, const CStr& string);
#endif
    friend CStr STRAPI operator+(const CStr& string, LPCTSTR lpsz);
    friend CStr STRAPI operator+(LPCTSTR lpsz, const CStr& string);

    // string comparison
    int Compare(LPCTSTR lpsz) const;         // straight character
    int CompareNoCase(LPCTSTR lpsz) const;   // ignore case
    int Collate(LPCTSTR lpsz) const;         // NLS aware

    // simple sub-string extraction
    CStr Mid(int nFirst, int nCount) const;
    CStr Mid(int nFirst) const;
    CStr Left(int nCount) const;
    CStr Right(int nCount) const;

    CStr SpanIncluding(LPCTSTR lpszCharSet) const;
    CStr SpanExcluding(LPCTSTR lpszCharSet) const;

    // upper/lower/reverse conversion
    void MakeUpper();
    void MakeLower();
    void MakeReverse();

    // trimming whitespace (either side)
    void TrimRight();
    void TrimLeft();

    // searching (return starting index, or -1 if not found)
    // look for a single character match
    int Find(TCHAR ch) const;               // like "C" strchr
    int ReverseFind(TCHAR ch) const;
    int FindOneOf(LPCTSTR lpszCharSet) const;

    // look for a specific sub-string
    int Find(LPCTSTR lpszSub) const;        // like "C" strstr

    // simple formatting
    void Format(LPCTSTR lpszFormat, ...);

#ifndef _MAC
    // formatting for localization (uses FormatMessage API)
    void __cdecl FormatMessage(LPCTSTR lpszFormat, ...);
    void __cdecl FormatMessage(UINT nFormatID, ...);
#endif

    // Windows support
    BOOL LoadString(HINSTANCE hInst, UINT nID);          // load from string resource
                                        // 255 chars max
#ifndef UNICODE
    // ANSI <-> OEM support (convert string in place)
    void AnsiToOem();
    void OemToAnsi();
#endif
    BSTR AllocSysString();
    BSTR SetSysString(BSTR* pbstr);

    // Access to string implementation buffer as "C" character array
    LPTSTR GetBuffer(int nMinBufLength);
    void ReleaseBuffer(int nNewLength = -1);
    LPTSTR GetBufferSetLength(int nNewLength);
    void FreeExtra();

// Implementation
public:
    ~CStr();
    int GetAllocLength() const;

protected:
    // lengths/sizes in characters
    //  (note: an extra character is always allocated)
    LPTSTR m_pchData;           // actual string (zero terminated)
    int m_nDataLength;          // does not include terminating 0
    int m_nAllocLength;         // does not include terminating 0

    // implementation helpers
    void Init();
    void AllocCopy(CStr& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
    void AllocBuffer(int nLen);
    void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
    void ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
    void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
    static void SafeDelete(LPTSTR lpch);
    static int SafeStrlen(LPCTSTR lpsz);
};

// Compare helpers
BOOL STRAPI operator==(const CStr& s1, const CStr& s2);
BOOL STRAPI operator==(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator==(LPCTSTR s1, const CStr& s2);
BOOL STRAPI operator!=(const CStr& s1, const CStr& s2);
BOOL STRAPI operator!=(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator!=(LPCTSTR s1, const CStr& s2);
BOOL STRAPI operator<(const CStr& s1, const CStr& s2);
BOOL STRAPI operator<(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator<(LPCTSTR s1, const CStr& s2);
BOOL STRAPI operator>(const CStr& s1, const CStr& s2);
BOOL STRAPI operator>(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator>(LPCTSTR s1, const CStr& s2);
BOOL STRAPI operator<=(const CStr& s1, const CStr& s2);
BOOL STRAPI operator<=(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator<=(LPCTSTR s1, const CStr& s2);
BOOL STRAPI operator>=(const CStr& s1, const CStr& s2);
BOOL STRAPI operator>=(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator>=(LPCTSTR s1, const CStr& s2);

// conversion helpers
int mmc_wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
int mmc_mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// Globals
extern const CStr strEmptyString;
extern TCHAR strChNil;

// Compiler doesn't inline for DBG
/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

inline int CStr::SafeStrlen(LPCTSTR lpsz)
    { return (lpsz == NULL) ? NULL : _tcslen(lpsz); }
inline CStr::CStr(const unsigned char* lpsz)
    { Init(); *this = (LPCSTR)lpsz; }
inline const CStr& CStr::operator=(const unsigned char* lpsz)
    { *this = (LPCSTR)lpsz; return *this; }

#ifdef _UNICODE
inline const CStr& CStr::operator+=(char ch)
    { *this += (TCHAR)ch; return *this; }
inline const CStr& CStr::operator=(char ch)
    { *this = (TCHAR)ch; return *this; }
inline CStr STRAPI operator+(const CStr& string, char ch)
    { return string + (TCHAR)ch; }
inline CStr STRAPI operator+(char ch, const CStr& string)
    { return (TCHAR)ch + string; }
#endif

inline int CStr::GetLength() const
    { return m_nDataLength; }
inline int CStr::GetAllocLength() const
    { return m_nAllocLength; }
inline BOOL CStr::IsEmpty() const
    { return m_nDataLength == 0; }
inline CStr::operator LPCTSTR() const
    { return (LPCTSTR)m_pchData; }

// String support (windows specific)
inline int CStr::Compare(LPCTSTR lpsz) const
    { return _tcscmp(m_pchData, lpsz); }    // MBCS/Unicode aware
inline int CStr::CompareNoCase(LPCTSTR lpsz) const
    { return _tcsicmp(m_pchData, lpsz); }   // MBCS/Unicode aware
// CStr::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
inline int CStr::Collate(LPCTSTR lpsz) const
    { return _tcscoll(m_pchData, lpsz); }   // locale sensitive
inline void CStr::MakeUpper()
    { ::CharUpper(m_pchData); }
inline void CStr::MakeLower()
    { ::CharLower(m_pchData); }

inline void CStr::MakeReverse()
    { _tcsrev(m_pchData); }
inline TCHAR CStr::GetAt(int nIndex) const
    {
        ASSERT(nIndex >= 0);
        ASSERT(nIndex < m_nDataLength);

        return m_pchData[nIndex];
    }
inline TCHAR CStr::operator[](int nIndex) const
    {
        // same as GetAt

        ASSERT(nIndex >= 0);
        ASSERT(nIndex < m_nDataLength);

        return m_pchData[nIndex];
    }
inline void CStr::SetAt(int nIndex, TCHAR ch)
    {
        ASSERT(nIndex >= 0);
        ASSERT(nIndex < m_nDataLength);
        ASSERT(ch != 0);

        m_pchData[nIndex] = ch;
    }
inline BOOL STRAPI operator==(const CStr& s1, const CStr& s2)
    { return s1.Compare(s2) == 0; }
inline BOOL STRAPI operator==(const CStr& s1, LPCTSTR s2)
    { return s1.Compare(s2) == 0; }
inline BOOL STRAPI operator==(LPCTSTR s1, const CStr& s2)
    { return s2.Compare(s1) == 0; }
inline BOOL STRAPI operator!=(const CStr& s1, const CStr& s2)
    { return s1.Compare(s2) != 0; }
inline BOOL STRAPI operator!=(const CStr& s1, LPCTSTR s2)
    { return s1.Compare(s2) != 0; }
inline BOOL STRAPI operator!=(LPCTSTR s1, const CStr& s2)
    { return s2.Compare(s1) != 0; }
inline BOOL STRAPI operator<(const CStr& s1, const CStr& s2)
    { return s1.Compare(s2) < 0; }
inline BOOL STRAPI operator<(const CStr& s1, LPCTSTR s2)
    { return s1.Compare(s2) < 0; }
inline BOOL STRAPI operator<(LPCTSTR s1, const CStr& s2)
    { return s2.Compare(s1) > 0; }
inline BOOL STRAPI operator>(const CStr& s1, const CStr& s2)
    { return s1.Compare(s2) > 0; }
inline BOOL STRAPI operator>(const CStr& s1, LPCTSTR s2)
    { return s1.Compare(s2) > 0; }
inline BOOL STRAPI operator>(LPCTSTR s1, const CStr& s2)
    { return s2.Compare(s1) < 0; }
inline BOOL STRAPI operator<=(const CStr& s1, const CStr& s2)
    { return s1.Compare(s2) <= 0; }
inline BOOL STRAPI operator<=(const CStr& s1, LPCTSTR s2)
    { return s1.Compare(s2) <= 0; }
inline BOOL STRAPI operator<=(LPCTSTR s1, const CStr& s2)
    { return s2.Compare(s1) >= 0; }
inline BOOL STRAPI operator>=(const CStr& s1, const CStr& s2)
    { return s1.Compare(s2) >= 0; }
inline BOOL STRAPI operator>=(const CStr& s1, LPCTSTR s2)
    { return s1.Compare(s2) >= 0; }
inline BOOL STRAPI operator>=(LPCTSTR s1, const CStr& s2)
    { return s2.Compare(s1) <= 0; }

#ifndef UNICODE
inline void CStr::AnsiToOem()
    { ::AnsiToOem(m_pchData, m_pchData); }
inline void CStr::OemToAnsi()
    { ::OemToAnsi(m_pchData, m_pchData); }

#endif // UNICODE

// General Exception for memory
class MemoryException
{
public:
    MemoryException(){}
    void DisplayMessage()
    {
    ::MessageBox(NULL, _T("Memory Exception"), _T("System Out of Memory"), MB_OK|MB_ICONSTOP);
    }
};

// General Exception for memory
class ResourceException
{
public:
    ResourceException()
    {
    ::MessageBox(NULL, _T("Resource Exception"), _T("Unable to Load Resource"), MB_OK|MB_ICONSTOP);
    }
};

#endif // __STR_H__

/////////////////////////////////////////////////////////////////////////////
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       macros.h
//
//  Contents:   Useful macros
//
//  Macros:     ARRAYLEN
//
//              BREAK_ON_FAIL(hresult)
//              BREAK_ON_FAIL(hresult)
//
//              DECLARE_IUNKNOWN_METHODS
//              DECLARE_STANDARD_IUNKNOWN
//              IMPLEMENT_STANDARD_IUNKNOWN
//
//              SAFE_RELEASE
//
//              DECLARE_SAFE_INTERFACE_PTR_MEMBERS
//
//  History:    6/3/1996   RaviR   Created
//              7/23/1996  JonN    Added exception handling macros
//
//____________________________________________________________________________

#ifndef _MACROS_H_
#define _MACROS_H_


//____________________________________________________________________________
//
//  Macro:      ARRAYLEN
//
//  Purpose:    To determine the length of an array.
//____________________________________________________________________________
//

#define ARRAYLEN(a) (sizeof(a) / sizeof((a)[0]))


//____________________________________________________________________________
//
//  Macros:     BREAK_ON_FAIL(hresult), BREAK_ON_ERROR(lastError)
//
//  Purpose:    To break out of a loop on error.
//____________________________________________________________________________
//

#define BREAK_ON_FAIL(hr)   if (FAILED(hr)) { break; } else 1;

#define BREAK_ON_ERROR(lr)  if (lr != ERROR_SUCCESS) { break; } else 1;

#define RETURN_ON_FAIL(hr)  if (FAILED(hr)) { return(hr); } else 1;

#define THROW_ON_FAIL(hr)   if (FAILED(hr)) { _com_issue_error(hr); } else 1;


//____________________________________________________________________________
//
//  Macros:     DwordAlign(n)
//____________________________________________________________________________
//

#define DwordAlign(n)  (((n) + 3) & ~3)


//____________________________________________________________________________
//
//  Macros:     SAFE_RELEASE
//____________________________________________________________________________
//

#ifndef SAFE_RELEASE
#define SAFE_RELEASE(punk) \
                if (punk != NULL) \
                { \
                    punk##->Release(); \
                    punk = NULL; \
                } \
                else \
                { \
                    TRACE(_T("Release called on NULL interface ptr")); \
                }
#endif // SAFE_RELEASE


//____________________________________________________________________________
//
//  Macros:     IF_NULL_RETURN_INVALIDARG
//____________________________________________________________________________
//

#define IF_NULL_RETURN_INVALIDARG(x) \
    { \
        ASSERT((x) != NULL); \
        if ((x) == NULL) \
            return E_INVALIDARG; \
    }

#define IF_NULL_RETURN_INVALIDARG2(x, y) \
    IF_NULL_RETURN_INVALIDARG(x) \
    IF_NULL_RETURN_INVALIDARG(y)

#define IF_NULL_RETURN_INVALIDARG3(x, y, z) \
    IF_NULL_RETURN_INVALIDARG(x) \
    IF_NULL_RETURN_INVALIDARG(y) \
    IF_NULL_RETURN_INVALIDARG(z)

#endif // _MACROS_H_



HRESULT ExtractString( IDataObject* piDataObject,
                       CLIPFORMAT cfClipFormat,
                       CStr*     pstr,           // OUT: Pointer to CStr to store data
                       DWORD        cchMaxLength)
{
    IF_NULL_RETURN_INVALIDARG2( piDataObject, pstr );
    ASSERT( cchMaxLength > 0 );

    HRESULT hr = S_OK;
    FORMATETC formatetc = {cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL};
    stgmedium.hGlobal = ::GlobalAlloc(GPTR, sizeof(WCHAR)*cchMaxLength);
    do // false loop
    {
        if (NULL == stgmedium.hGlobal)
        {
            ASSERT(FALSE);
            ////AfxThrowMemoryException();
            hr = E_OUTOFMEMORY;
            break;
        }
        hr = piDataObject->GetDataHere( &formatetc, &stgmedium );
        if ( FAILED(hr) )
        {
            // This failure happens when 'searching' for
            // clipboard format supported by the IDataObject.
            // t-danmo (24-Oct-96)
            // Skipping ASSERT( FALSE );
            break;
        }

        LPWSTR pszNewData = reinterpret_cast<LPWSTR>(stgmedium.hGlobal);
        if (NULL == pszNewData)
        {
            ASSERT(FALSE);
            hr = E_UNEXPECTED;
            break;
        }
        pszNewData[cchMaxLength-1] = L'\0'; // just to be safe
        USES_CONVERSION;
        *pstr = OLE2T(pszNewData);
    } while (FALSE); // false loop

    if (NULL != stgmedium.hGlobal)
    {
#if (_MSC_VER >= 1200)
#pragma warning (push)
#endif
#pragma warning(disable: 4553)      // "==" operator has no effect
        VERIFY( NULL == ::GlobalFree(stgmedium.hGlobal) );
#if (_MSC_VER >= 1200)
#pragma warning (pop)
#endif
    }
    return hr;
} // ExtractString()

TCHAR strChNil = '\0';      
void CStr::Init()
{
    m_nDataLength = m_nAllocLength = 0;
    m_pchData = (LPTSTR)&strChNil;
}

// declared static
void CStr::SafeDelete(LPTSTR lpch)
{
    if (lpch != (LPTSTR)&strChNil)
        delete[] lpch;
}

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

// begin_extractstring
CStr::CStr()
{
    Init();
}

CStr::CStr(const CStr& stringSrc)
{
    // if constructing a String from another String, we make a copy of the
    // original string data to enforce value semantics (i.e. each string
    // gets a copy of its own

    stringSrc.AllocCopy(*this, stringSrc.m_nDataLength, 0, 0);
}

void CStr::AllocBuffer(int nLen)
 // always allocate one extra character for '\0' termination
 // assumes [optimistically] that data length will equal allocation length
{
    ASSERT(nLen >= 0);

    if (nLen == 0)
    {
        Init();
    }
    else
    {
        m_pchData = new TCHAR[nLen+1];       //REVIEW may throw an exception
        m_pchData[nLen] = '\0';
        m_nDataLength = nLen;
        m_nAllocLength = nLen;
    }
}

void CStr::Empty()
{
    SafeDelete(m_pchData);
    Init();
    ASSERT(m_nDataLength == 0);
    ASSERT(m_nAllocLength == 0);
}

CStr::~CStr()
 //  free any attached data
{
    SafeDelete(m_pchData);
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

static inline int SafeStrlen(LPCTSTR lpsz)
{
    ASSERT(lpsz == NULL || IsValidString(lpsz, FALSE));
    return (lpsz == NULL) ? 0 : lstrlen(lpsz);
}

void CStr::AllocCopy(CStr& dest, int nCopyLen, int nCopyIndex,
     int nExtraLen) const
{
    // will clone the data attached to this string
    // allocating 'nExtraLen' characters
    // Places results in uninitialized string 'dest'
    // Will copy the part or all of original data to start of new string

    int nNewLen = nCopyLen + nExtraLen;

    if (nNewLen == 0)
    {
        dest.Init();
    }
    else
    {
        dest.AllocBuffer(nNewLen);
        memcpy(dest.m_pchData, &m_pchData[nCopyIndex], nCopyLen*sizeof(TCHAR));
    }
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CStr::CStr(LPCTSTR lpsz)
{
    if (lpsz != NULL && (DWORD_PTR)lpsz <= 0xffff)
    {
        Init();
        UINT nID = LOWORD((DWORD_PTR)lpsz);
        // REVIEW hInstance for LoadString(hInst, nID);
    }
    else
    {
        int nLen;
        if ((nLen = SafeStrlen(lpsz)) == 0)
            Init();
        else
        {
            AllocBuffer(nLen);
            memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
        }
    }
}


//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CStr&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CStr::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
    // check if it will fit
    if (nSrcLen > m_nAllocLength)
    {
        // it won't fit, allocate another one
        Empty();
        AllocBuffer(nSrcLen);
    }
    if (nSrcLen != 0)
        memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
    m_nDataLength = nSrcLen;
    m_pchData[nSrcLen] = '\0';
}

const CStr& CStr::operator=(const CStr& stringSrc)
{
    AssignCopy(stringSrc.m_nDataLength, stringSrc.m_pchData);
    return *this;
}

const CStr& CStr::operator=(LPCTSTR lpsz)
{
    ASSERT(lpsz == NULL || IsValidString(lpsz, FALSE));
    AssignCopy(SafeStrlen(lpsz), lpsz);
    return *this;
}
HRESULT ExtractString( IDataObject* piDataObject,
                       CLIPFORMAT   cfClipFormat,
                       CString*     pstr,           // OUT: Pointer to CStr to store data
                       DWORD        cchMaxLength)
{
    if (pstr == NULL)
        return E_POINTER;

    CStr cstr(*pstr);

    HRESULT hr = ExtractString(piDataObject, cfClipFormat, &cstr, cchMaxLength);

    *pstr = cstr;

    return hr;
}



BOOL STRAPI IsValidString(LPCSTR lpsz, int nLength)
{
    if (lpsz == NULL)
        return FALSE;
    return ::IsBadStringPtrA(lpsz, nLength) == 0;
}

BOOL STRAPI IsValidString(LPCWSTR lpsz, int nLength)
{
    if (lpsz == NULL)
        return FALSE;

    return ::IsBadStringPtrW(lpsz, nLength) == 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\drivers.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	drivers.cpp
        Tapi drivers config dialog

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "drivers.h"
#include "tapidb.h"
#include "server.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDriverSetup dialog


CDriverSetup::CDriverSetup(ITFSNode * pServerNode, ITapiInfo * pTapiInfo, CWnd* pParent /*=NULL*/)
	: CBaseDialog(CDriverSetup::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDriverSetup)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_spServerNode.Set(pServerNode);
    m_spTapiInfo.Set(pTapiInfo);

	m_fDriverAdded = FALSE;
}


void CDriverSetup::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDriverSetup)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDriverSetup, CBaseDialog)
	//{{AFX_MSG_MAP(CDriverSetup)
	ON_BN_CLICKED(IDC_BUTTON_ADD_DRIVER, OnButtonAdd)
	ON_BN_CLICKED(IDC_BUTTON_EDIT_DRIVER, OnButtonEdit)
	ON_BN_CLICKED(IDC_BUTTON_REMOVE_DRIVER, OnButtonRemove)
	ON_LBN_DBLCLK(IDC_LIST_DRIVERS, OnDblclkListDrivers)
	ON_LBN_SELCHANGE(IDC_LIST_DRIVERS, OnSelchangeListDrivers)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDriverSetup message handlers

BOOL CDriverSetup::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    CBaseDialog::OnInitDialog();

    CTapiProvider   tapiProvider;
	int             i, nIndex;

    // fill in the listbox with the providers that are installed.
    for (i = 0; i < m_spTapiInfo->GetProviderCount(); i++)
    {
	    // add this provider to the listbox.
        m_spTapiInfo->GetProviderInfo(&tapiProvider, i);

        nIndex = ((CListBox *) GetDlgItem(IDC_LIST_DRIVERS))->AddString(tapiProvider.m_strName);
        ((CListBox *) GetDlgItem(IDC_LIST_DRIVERS))->SetItemData(nIndex, tapiProvider.m_dwProviderID);
    }
	
    ((CListBox *) GetDlgItem(IDC_LIST_DRIVERS))->SetCurSel(0);

    EnableButtons();

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDriverSetup::OnButtonAdd() 
{
    CAddDriver  dlgAddDriver(m_spTapiInfo);
    if (dlgAddDriver.DoModal() == IDOK)
    {
        CTapiServer * pServer = GETHANDLER(CTapiServer, m_spServerNode);

        // add to listbox
        int nIndex = ((CListBox *) GetDlgItem(IDC_LIST_DRIVERS))->AddString(dlgAddDriver.m_tapiProvider.m_strName);
        ((CListBox *) GetDlgItem(IDC_LIST_DRIVERS))->SetItemData(nIndex, dlgAddDriver.m_tapiProvider.m_dwProviderID);

        // add to MMC UI
        pServer->AddProvider(m_spServerNode, &dlgAddDriver.m_tapiProvider);

		m_fDriverAdded = TRUE;
    }

    EnableButtons();
}

void CDriverSetup::OnButtonEdit() 
{
    HRESULT     hr = hrOK;
    int         nCurSel;
    DWORD       dwProviderID;

	nCurSel = ((CListBox *) GetDlgItem(IDC_LIST_DRIVERS))->GetCurSel();
    dwProviderID = (DWORD) ((CListBox *) GetDlgItem(IDC_LIST_DRIVERS))->GetItemData(nCurSel);

    hr = m_spTapiInfo->ConfigureProvider(dwProviderID, GetSafeHwnd());
    if (FAILED(hr))
    {
        ::TapiMessageBox(WIN32_FROM_HRESULT(hr));
    }
}

void CDriverSetup::OnButtonRemove() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT         hr = hrOK;
    int             nCurSel, nCount;
    DWORD           dwProviderID;
    CString         strMessage;
    CTapiProvider   tapiProvider;
    CTapiServer * pServer = GETHANDLER(CTapiServer, m_spServerNode);

	nCurSel = ((CListBox *) GetDlgItem(IDC_LIST_DRIVERS))->GetCurSel();
    dwProviderID = (DWORD) ((CListBox *) GetDlgItem(IDC_LIST_DRIVERS))->GetItemData(nCurSel);

    m_spTapiInfo->GetProviderInfo(&tapiProvider, dwProviderID);

    AfxFormatString2(strMessage, IDS_WARN_PROVIDER_DELETE, tapiProvider.m_strName, pServer->GetName());
    
	if (AfxMessageBox(strMessage, MB_YESNO) == IDYES)
	{
        Assert(m_spTapiInfo);

        BEGIN_WAIT_CURSOR;

        hr = m_spTapiInfo->RemoveProvider(dwProviderID, GetSafeHwnd());
        if (FAILED(hr))
        {
            ::TapiMessageBox(WIN32_FROM_HRESULT(hr));
        }
        else
        {
            // remove from the list box
            ((CListBox *) GetDlgItem(IDC_LIST_DRIVERS))->DeleteString(nCurSel);
                
            // now remove from the MMC UI
            pServer->RemoveProvider(m_spServerNode, dwProviderID);

            // update the list of installed providers
            m_spTapiInfo->EnumProviders();
        }

        END_WAIT_CURSOR;
    }

    // select another item in the listbox
    nCount = ((CListBox *) GetDlgItem(IDC_LIST_DRIVERS))->GetCount();
    ((CListBox *) GetDlgItem(IDC_LIST_DRIVERS))->SetCurSel((nCurSel == nCount) ? nCount - 1 : nCurSel);

    EnableButtons();
}

void CDriverSetup::OnDblclkListDrivers() 
{
    OnButtonEdit();	
}

void CDriverSetup::OnCancel() 
{
	// TODO: Add extra cleanup here
	
	CBaseDialog::OnCancel();
}

void CDriverSetup::OnSelchangeListDrivers() 
{
    EnableButtons();
}

void CDriverSetup::EnableButtons()
{
    int nIndex = ((CListBox *) GetDlgItem(IDC_LIST_DRIVERS))->GetCurSel();

    if (nIndex != LB_ERR)
    {
        DWORD dwProviderID = (DWORD) ((CListBox *) GetDlgItem(IDC_LIST_DRIVERS))->GetItemData(nIndex);

        CTapiProvider tapiProvider;

        m_spTapiInfo->GetProviderInfo(&tapiProvider, dwProviderID);

        // enable the appropriate buttons
        GetDlgItem(IDC_BUTTON_REMOVE_DRIVER)->EnableWindow(tapiProvider.m_dwFlags & AVAILABLEPROVIDER_REMOVABLE);
        GetDlgItem(IDC_BUTTON_EDIT_DRIVER)->EnableWindow(tapiProvider.m_dwFlags & AVAILABLEPROVIDER_CONFIGURABLE);
    }
    else
    {
        GetDlgItem(IDC_BUTTON_REMOVE_DRIVER)->EnableWindow(FALSE);
        GetDlgItem(IDC_BUTTON_EDIT_DRIVER)->EnableWindow(FALSE);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CAddDriver dialog


CAddDriver::CAddDriver(ITapiInfo * pTapiInfo, CWnd* pParent /*=NULL*/)
	: CBaseDialog(CAddDriver::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAddDriver)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_spTapiInfo.Set(pTapiInfo);
}


void CAddDriver::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddDriver)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddDriver, CBaseDialog)
	//{{AFX_MSG_MAP(CAddDriver)
	ON_BN_CLICKED(IDC_BUTTON_ADD_NEW_DRIVER, OnButtonAdd)
	ON_LBN_DBLCLK(IDC_LIST_NEW_DRIVERS, OnDblclkListNewDrivers)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddDriver message handlers

BOOL CAddDriver::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();

    CTapiProvider   tapiProvider;
    int             i, j, nIndex;

    m_spTapiInfo->EnumAvailableProviders();

    for (i = 0; i < m_spTapiInfo->GetAvailableProviderCount(); i++)
    {
	    // add this provider to the listbox.
        m_spTapiInfo->GetAvailableProviderInfo(&tapiProvider, i);

        if (tapiProvider.m_dwFlags & AVAILABLEPROVIDER_INSTALLABLE)
        {
            BOOL bInstalled = FALSE;

            /* some TAPI providers can be installed mutliple times, so just add to the list
               and let the server return an error if it fails.

            for (j = 0; j < m_spTapiInfo->GetProviderCount(); j++)
            {
                CTapiProvider tapiProviderInstalled;

                m_spTapiInfo->GetProviderInfo(&tapiProviderInstalled, j);
                if (tapiProviderInstalled.m_strFilename.CompareNoCase(tapiProvider.m_strFilename) == 0)
                {
                    // this provider is already installed... don't add
                    bInstalled = TRUE;
                    break;
                }
            }
            */

            if (!bInstalled)
            {
                // this provider isn't installed yet... make it available to the user
                nIndex = ((CListBox *) GetDlgItem(IDC_LIST_NEW_DRIVERS))->AddString(tapiProvider.m_strName);
                ((CListBox *) GetDlgItem(IDC_LIST_NEW_DRIVERS))->SetItemData(nIndex, i);
            }
        }
    }
	
    ((CListBox *) GetDlgItem(IDC_LIST_NEW_DRIVERS))->SetCurSel(0);

    EnableButtons();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CAddDriver::OnButtonAdd() 
{
    int     nCurSel, nIndex;
    HRESULT hr = hrOK;

    // get the info on the currently selected provider
    nCurSel = ((CListBox *) GetDlgItem(IDC_LIST_NEW_DRIVERS))->GetCurSel();
    nIndex = (int) ((CListBox *) GetDlgItem(IDC_LIST_NEW_DRIVERS))->GetItemData(nCurSel);

    m_spTapiInfo->GetAvailableProviderInfo(&m_tapiProvider, nIndex);

    BEGIN_WAIT_CURSOR;

    // try to add the provider to the server
    hr = m_spTapiInfo->AddProvider(m_tapiProvider.m_strFilename, &m_tapiProvider.m_dwProviderID, GetSafeHwnd());	
    if (FAILED(hr))
    {
        ::TapiMessageBox(WIN32_FROM_HRESULT(hr));
    }
    else
    {
        // success... we're done here
        // update our installed provider list
        hr = m_spTapiInfo->EnumProviders();	

        EndDialog(IDOK);
    }

    END_WAIT_CURSOR;
}

void CAddDriver::OnDblclkListNewDrivers() 
{
    OnButtonAdd();
}

void CAddDriver::EnableButtons()
{
    int nCount = ((CListBox *) GetDlgItem(IDC_LIST_NEW_DRIVERS))->GetCount();
    
    GetDlgItem(IDC_BUTTON_ADD_NEW_DRIVER)->EnableWindow(nCount > 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\dynamlnk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       dynamlnk.h
//
//--------------------------------------------------------------------------

// DynamLnk.h : Base class for DLLs which are loaded only when needed

#ifndef __DYNAMLNK_H_INCLUDED__
#define __DYNAMLNK_H_INCLUDED__

class DynamicDLL
{
public:
	// These strings must remain unchanged until the FileServiceProvider is released
	DynamicDLL(LPCTSTR ptchLibraryName, LPCSTR* apchFunctionNames);
	virtual ~DynamicDLL();

	BOOL LoadFunctionPointers();
	void Unload();

	FARPROC QueryFunctionPtr(INT i) const;
	inline FARPROC operator[] (INT i) const
		{ return QueryFunctionPtr(i); }

private:
	HMODULE m_hLibrary;
	FARPROC* m_apfFunctions;
	LPCTSTR m_ptchLibraryName;
	LPCSTR* m_apchFunctionNames;
	INT m_nNumFunctions;
};

#endif // ~__DYNAMLNK_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\drivers.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	drivers.h
        Tapi drivers config dialog

    FILE HISTORY:
        
*/

#ifndef _DRIVERS_H
#define _DRIVERS_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef _TAPIDB_H
#include "tapidb.h"
#endif 

/////////////////////////////////////////////////////////////////////////////
// CDriverSetup dialog

class CDriverSetup : public CBaseDialog
{
// Construction
public:
	CDriverSetup(ITFSNode * pServerNode, ITapiInfo * pTapiInfo, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDriverSetup)
	enum { IDD = IDD_DRIVER_SETUP };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

    // Context Help Support
    virtual DWORD * GetHelpMap() { return (DWORD *) &g_aHelpIDs_DRIVER_SETUP[0]; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDriverSetup)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

    void    EnableButtons();

public:
    BOOL    m_fDriverAdded;

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDriverSetup)
	afx_msg void OnButtonAdd();
	afx_msg void OnButtonEdit();
	afx_msg void OnButtonRemove();
	afx_msg void OnDblclkListDrivers();
	virtual BOOL OnInitDialog();
	virtual void OnCancel();
	afx_msg void OnSelchangeListDrivers();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    SPITFSNode          m_spServerNode;
    SPITapiInfo         m_spTapiInfo;
};

/////////////////////////////////////////////////////////////////////////////
// CAddDriver dialog

class CAddDriver : public CBaseDialog
{
// Construction
public:
	CAddDriver(ITapiInfo * pTapiInfo, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAddDriver)
	enum { IDD = IDD_ADD_DRIVER };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

    // Context Help Support
    virtual DWORD * GetHelpMap() { return (DWORD *) &g_aHelpIDs_ADD_DRIVER[0]; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddDriver)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

    void EnableButtons();

// Implementation
public:
    CTapiProvider   m_tapiProvider;

protected:

	// Generated message map functions
	//{{AFX_MSG(CAddDriver)
	afx_msg void OnButtonAdd();
	afx_msg void OnDblclkListNewDrivers();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    SPITapiInfo         m_spTapiInfo;
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif _DRIVERS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\dynamlnk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       dynamlnk.cpp
//
//--------------------------------------------------------------------------

// DynamLnk.cpp : base class for DLLs which are loaded only when needed

#include "stdafx.h"
//#include "safetemp.h"
#include "DynamLnk.h"

//#include "macros.h"
//USE_HANDLE_MACROS("TAPISNAP(DynamLnk.cpp)")

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

DynamicDLL::DynamicDLL(LPCTSTR ptchLibraryName, LPCSTR* apchFunctionNames)
: m_hLibrary( (HMODULE)-1 ),
  m_apfFunctions( NULL ),
  m_ptchLibraryName( ptchLibraryName ),
  m_apchFunctionNames( apchFunctionNames ),
  m_nNumFunctions( 0 )
{
	ASSERT( !IsBadStringPtr(m_ptchLibraryName,MAX_PATH) );
	ASSERT( NULL != apchFunctionNames );
	for (LPCSTR pchFunctionName = *apchFunctionNames;
	     NULL != pchFunctionName;
		 pchFunctionName = *(++apchFunctionNames) )
	{
		m_nNumFunctions++;
		ASSERT( !IsBadStringPtrA(pchFunctionName,MAX_PATH) );
	}
}

DynamicDLL::~DynamicDLL()
{
	Unload();
}

BOOL DynamicDLL::LoadFunctionPointers()
{
	if ((HMODULE)-1 != m_hLibrary)
		return (NULL != m_hLibrary);

	m_hLibrary = ::LoadLibrary( m_ptchLibraryName );
	if (NULL == m_hLibrary)
	{
		// The library is not present
		return FALSE;
	}

	// let this throw an exception
	m_apfFunctions = new FARPROC[m_nNumFunctions];

	for (INT i = 0; i < m_nNumFunctions; i++)
	{
		m_apfFunctions[i] = ::GetProcAddress( m_hLibrary, m_apchFunctionNames[i] );
		if ( NULL == m_apfFunctions[i] )
		{
			// The library is present but does not have all of the entrypoints
			VERIFY( ::FreeLibrary( m_hLibrary ) );
			m_hLibrary = NULL;
			return FALSE;
		}
	}

	return TRUE;
}


FARPROC DynamicDLL::QueryFunctionPtr(INT i) const
{
	if ( 0 > i || m_nNumFunctions <= i || NULL == m_apfFunctions || NULL == m_apfFunctions[i] )
	{
		ASSERT( FALSE );
		return NULL;
	}
	return m_apfFunctions[i];
}

void DynamicDLL::Unload()
{
	if (NULL != m_apfFunctions)
	{
		delete m_apfFunctions;
		m_apfFunctions = NULL;
	}
	if ((HMODULE)-1 != m_hLibrary && NULL != m_hLibrary)
	{
		VERIFY( ::FreeLibrary( m_hLibrary ) );
		m_hLibrary = (HMODULE) -1;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\edituser.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    EditUser.h   
        Edit Users dialog header file

	FILE HISTORY:
        
*/

#if !defined(AFX_EDITUSER_H__77C7FD5C_6CE5_11D1_93B6_00C04FC3357A__INCLUDED_)
#define AFX_EDITUSER_H__77C7FD5C_6CE5_11D1_93B6_00C04FC3357A__INCLUDED_

#ifndef _TAPIDB_H
#include "tapidb.h"
#endif

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CEditUsers dialog

class CEditUsers : public CBaseDialog
{
// Construction
public:
	CEditUsers(CTapiDevice * pTapiDevice, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CEditUsers)
	enum { IDD = IDD_EDIT_USERS };
	CListBox	m_listUsers;
	//}}AFX_DATA

    void UpdateButtons();

    void SetDirty(BOOL bDirty) { m_bDirty = bDirty; }
    BOOL IsDirty() { return m_bDirty; }

    // Context Help Support
    virtual DWORD * GetHelpMap() { return (DWORD *) &g_aHelpIDs_EDIT_USERS[0]; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditUsers)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CEditUsers)
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonAdd();
	afx_msg void OnButtonRemove();
	virtual void OnOK();
	afx_msg void OnSelchangeListUsers();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    BOOL    m_bDirty;

private:
	void CEditUsers::RefreshList();

public:
	CTapiDevice *		m_pTapiDevice;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EDITUSER_H__77C7FD5C_6CE5_11D1_93B6_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\edituser.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    edituser.h
        Edit user dialog implementation file

	FILE HISTORY:

*/

#include "stdafx.h"
#include "EditUser.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEditUsers dialog


CEditUsers::CEditUsers(CTapiDevice * pTapiDevice, CWnd* pParent /*=NULL*/)
	: CBaseDialog(CEditUsers::IDD, pParent),
	  m_pTapiDevice(pTapiDevice),
      m_bDirty(FALSE)
{
	//{{AFX_DATA_INIT(CEditUsers)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CEditUsers::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEditUsers)
	DDX_Control(pDX, IDC_LIST_USERS, m_listUsers);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CEditUsers, CBaseDialog)
	//{{AFX_MSG_MAP(CEditUsers)
	ON_BN_CLICKED(IDC_BUTTON_ADD_USER, OnButtonAdd)
	ON_BN_CLICKED(IDC_BUTTON_REMOVE_USER, OnButtonRemove)
	ON_LBN_SELCHANGE(IDC_LIST_USERS, OnSelchangeListUsers)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEditUsers message handlers

BOOL CEditUsers::OnInitDialog()
{
	CBaseDialog::OnInitDialog();
	
    for (int i = 0; i < m_pTapiDevice->m_arrayUsers.GetSize(); i++)
    {
        CString strDisplay;

        FormatName(m_pTapiDevice->m_arrayUsers[i].m_strFullName,
                   m_pTapiDevice->m_arrayUsers[i].m_strName,
                   strDisplay);

        int nIndex = m_listUsers.AddString(strDisplay);
		m_listUsers.SetItemData(nIndex, i);
    }

    UpdateButtons();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

//
// Refresh the list box and rebuild the index 
//
void CEditUsers::RefreshList()
{
	m_listUsers.ResetContent();

	for (int i = 0; i < m_pTapiDevice->m_arrayUsers.GetSize(); i++)
	{
		CString strDisplay;

        FormatName(m_pTapiDevice->m_arrayUsers[i].m_strFullName,
                   m_pTapiDevice->m_arrayUsers[i].m_strName,
                   strDisplay);

        int nIndex = m_listUsers.AddString(strDisplay);
		m_listUsers.SetItemData(nIndex, i);
	}
}

void CEditUsers::OnButtonAdd()
{
    CGetUsers getUsers(TRUE);

    if (!getUsers.GetUsers(GetSafeHwnd()))
        return;

    for (int nCount = 0; nCount < getUsers.GetSize(); nCount++)
    {
	    CUserInfo userTemp;

        userTemp = getUsers[nCount];

        // check for duplicates
        BOOL fDuplicate = FALSE;
        for (int i = 0; i < m_pTapiDevice->m_arrayUsers.GetSize(); i++)
        {
            if (m_pTapiDevice->m_arrayUsers[i].m_strName.CompareNoCase(userTemp.m_strName) == 0)
            {
                fDuplicate = TRUE;
                break;
            }
        }

        if (!fDuplicate)
        {
            // add to the array
		    int nIndex = (int)m_pTapiDevice->m_arrayUsers.Add(userTemp);

		    // now add to the listbox
            CString strDisplay;

            FormatName(m_pTapiDevice->m_arrayUsers[nIndex].m_strFullName,
                       m_pTapiDevice->m_arrayUsers[nIndex].m_strName,
                       strDisplay);

		    int nListboxIndex = m_listUsers.AddString(strDisplay);
			m_listUsers.SetItemData(nListboxIndex, nIndex);
        }
        else
        {
            // tell the user we're not adding this to the list
            CString strMessage;
            AfxFormatString1(strMessage, IDS_USER_ALREADY_AUTHORIZED, userTemp.m_strName);
            AfxMessageBox(strMessage);
        }

        SetDirty(TRUE);
    }

    UpdateButtons();
}

void CEditUsers::OnButtonRemove()
{
	CString strSelectedName, strFullName, strDomainName;

    int nCurSel = m_listUsers.GetCurSel();
	int nIndex = (int)m_listUsers.GetItemData(nCurSel);

	// remove from the list
	m_pTapiDevice->m_arrayUsers.RemoveAt(nIndex);
	
	//Fix bug 386474, we need to rebuild the index <-> string mapping in the list box.
	//So reload the users to the list box
	RefreshList();

	SetDirty(TRUE);

    UpdateButtons();
}

void CEditUsers::OnOK()
{
    if (IsDirty())
    {
    }

	CBaseDialog::OnOK();
}

void CEditUsers::UpdateButtons()
{
	// enable the remove button if something is selected
	BOOL fEnable = (m_listUsers.GetCurSel() != LB_ERR);

	CWnd * pwndRemove = GetDlgItem(IDC_BUTTON_REMOVE_USER);
	
	//if we will disable the remove button and the remove button has the focus, 
	//we should change focus to the OK button
	if (!fEnable && GetFocus() == pwndRemove)
	{
		SetDefID(IDOK);
		GetDlgItem(IDOK)->SetFocus();
		((CButton*)pwndRemove)->SetButtonStyle(BS_PUSHBUTTON);
	}

	pwndRemove->EnableWindow(fEnable);
}


void CEditUsers::OnSelchangeListUsers()
{
    UpdateButtons();	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\gtusrdlg.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corporation, 1992 - 1997 -1997           **/
/**********************************************************************/

/*
    GetUser.h

    This file contains the definitions for the User Browser "C" API

    FILE HISTORY:
        AndyHe  11-Oct-1992     Created

*/

#ifndef _GETUSER_H_
#define _GETUSER_H_

//#include <ntseapi.h>

typedef HANDLE    HUSERBROW;        // handle type returned by OpenUserBrowser

//
//   Parameter structure passed to OpenUserBrowser
//
typedef struct tagUSLT {    // uslt
    ULONG             ulStructSize;
    BOOL              fUserCancelled;   // Set if user cancelled
    BOOL              fExpandNames;     // TRUE if full names should be returned
    HWND              hwndOwner;        // Window handle to use for dialog
    WCHAR           * pszTitle;         // Dialog title (or NULL)
    WCHAR           * pszInitialDomain; // NULL for local machine or prefix
                                        // with "\\" for server
    DWORD             Flags;            // Defined below
    ULONG             ulHelpContext;    // Help context for the main dialog
    WCHAR           * pszHelpFileName;  // Help file name
}  USERBROWSER, *LPUSERBROWSER, * PUSERBROWSER;

//
// Bit values for Flags field
//

//
//  Indicates the user accounts should be shown as if the user pressed
//  the "Show Users" button.  The button will be hidden if this flag is
//  set.  The USRBROWS_SHOW_USERS flag must also be set.

#define USRBROWS_EXPAND_USERS       (0x00000008)

//
//  Passing this will prevent the computer name from showing up in the
//  combo box.
//

#define USRBROWS_DONT_SHOW_COMPUTER (0x00000100)

//
//  Allow the user to only select a single item from the listbox (not all
//  SHOW_* combinations are supported with this option).
//

#define USRBROWS_SINGLE_SELECT	    (0x00001000)

//
//  These manifests determine which well known Sids are included in the list.
//
#define USRBROWS_INCL_REMOTE_USERS  (0x00000010)
#define USRBROWS_INCL_INTERACTIVE   (0x00000020)
#define USRBROWS_INCL_EVERYONE      (0x00000040)
#define USRBROWS_INCL_CREATOR       (0x00000080)
#define USRBROWS_INCL_SYSTEM        (0x00010000)
#define USRBROWS_INCL_ALL           (USRBROWS_INCL_REMOTE_USERS |\
                                     USRBROWS_INCL_INTERACTIVE  |\
                                     USRBROWS_INCL_EVERYONE     |\
                                     USRBROWS_INCL_CREATOR      |\
                                     USRBROWS_INCL_SYSTEM)

//
//  These manifests determine which type of accounts to display
//
//  Note: currently, if you display groups, you must display users
//		     if you display aliases (local groups), you must display
//			   groups and users
//
#define USRBROWS_SHOW_ALIASES	    (0x00000001)
#define USRBROWS_SHOW_GROUPS	    (0x00000002)
#define USRBROWS_SHOW_USERS	    (0x00000004)
#define USRBROWS_SHOW_ALL	    (USRBROWS_SHOW_ALIASES |\
				     USRBROWS_SHOW_GROUPS  |\
				     USRBROWS_SHOW_USERS)


//
// The caller should provide the name of a help file containing four
// help contexts.  The first help context is for the main User Browser
// dialog, the next three are for the Local Group Membership, Global Group
// Membership, and Find Account subdialogs, respectively.
//
#define USRBROWS_HELP_OFFSET_LOCALGROUP  1
#define USRBROWS_HELP_OFFSET_GLOBALGROUP 2
#define USRBROWS_HELP_OFFSET_FINDUSER    3

//
//  User Details structure returned by user browser enumeration
//
typedef struct tagUSDT {    // usdt
    enum _SID_NAME_USE    UserType;
    PSID                  psidUser;
    PSID                  psidDomain;
    WCHAR               * pszFullName;
    WCHAR               * pszAccountName;
    WCHAR               * pszDisplayName;
    WCHAR               * pszDomainName;
    WCHAR               * pszComment;
    ULONG                 ulFlags;          // User account flags
} USERDETAILS, * LPUSERDETAILS, * PUSERDETAILS;


// Function definitions for the GetUser API...

HUSERBROW WINAPI OpenUserBrowser( LPUSERBROWSER lpUserParms );

BOOL WINAPI EnumUserBrowserSelection( HUSERBROW hHandle,
                                      LPUSERDETAILS lpUser,
                                      DWORD *plBufferSize );

BOOL WINAPI CloseUserBrowser( HUSERBROW hHandle );

#endif //_GETUSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\guids.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	guids.cpp
		Tapi snapin GUID definitions

	FILE HISTORY:
        
*/
#include "stdafx.h"


// MMC required node types

// {E26D02A0-4C1F-11d1-9AA1-00C04FC3357A}
static const CLSID CLSID_TapiSnapin = 
{ 0xe26d02a0, 0x4c1f, 0x11d1, { 0x9a, 0xa1, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

static const CLSID CLSID_TapiSnapinExtension = 
{ 0xe26d02a1, 0x4c1f, 0x11d1, { 0x9a, 0xa1, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

static const GUID CLSID_TapiSnapinAbout = 
{ 0xe26d02a2, 0x4c1f, 0x11d1, { 0x9a, 0xa1, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

//
// Scope pane node types
//

static const GUID GUID_TapiRootNodeType = 
{ 0xe26d02a3, 0x4c1f, 0x11d1, { 0x9a, 0xa1, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

static const GUID GUID_TapiServerNodeType = 
{ 0xe26d02a4, 0x4c1f, 0x11d1, { 0x9a, 0xa1, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

static const GUID GUID_TapiProviderNodeType = 
{ 0xe26d02a5, 0x4c1f, 0x11d1, { 0x9a, 0xa1, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

//
// result pane item GUIDs
//

static const GUID GUID_TapiLineNodeType = 
{ 0xe26d02a6, 0x4c1f, 0x11d1, { 0x9a, 0xa1, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

static const GUID GUID_TapiUserNodeType = 
{ 0xe26d02a7, 0x4c1f, 0x11d1, { 0x9a, 0xa1, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

static const GUID GUID_TapiPhoneNumNodeType = 
{ 0xe26d02a8, 0x4c1f, 0x11d1, { 0x9a, 0xa1, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

//
//  GUID for our fake ITapiInfo object
//
static const GUID IID_ITapiInfo = 
{ 0xe26d02a9, 0x4c1f, 0x11d1, { 0x9a, 0xa1, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\harray.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	harray.h
		Index mgr for TAPI devices db

	FILE HISTORY:
    Dec 16  1997    EricDav     Created        

*/

#ifndef _HARRAY_H__
#define _HARRAY_H__

#ifndef TAPI_H
#include "tapi.h"
#endif

#ifndef _TAPIMMC_H
#define _TAPIMMC_H
#include "tapimmc.h"
#endif

#include "afxmt.h"

typedef LPDEVICEINFO    HDEVICE;
typedef HDEVICE FAR *   LPHDEVICE;

typedef enum _INDEX_TYPE
{
    INDEX_TYPE_NAME,
    INDEX_TYPE_USERS,
    INDEX_TYPE_STATUS
} INDEX_TYPE;

typedef enum _SORT_OPTIONS
{
	SORT_DESCENDING	= 0x00,
	SORT_ASCENDING	= 0x01

} SORT_OPTIONS;


class CHDeviceIndex;

typedef CArray<HDEVICE, HDEVICE>		                    HDeviceArray;
typedef CList<CHDeviceIndex *, CHDeviceIndex *>             HDeviceArrayList;

class CProviderIndexInfo
{
public:
    DWORD               m_dwProviderID;
    HDeviceArrayList	m_listIndicies;
    POSITION            m_posCurrentIndex;
};

typedef CList<CProviderIndexInfo *, CProviderIndexInfo *>    ProviderIndexList;

// base class for a sorted index
class CHDeviceIndex 
{
public:
    CHDeviceIndex(INDEX_TYPE IndexType);
	virtual ~CHDeviceIndex();

public:
    // used for insertion into the list
    virtual int     BCompare(const void *, const void *) = 0;
    virtual HRESULT Sort(LPBYTE pStart) = 0;
    
    virtual HRESULT Add(HDEVICE hDevice, BOOL bEnd);
    virtual HRESULT Remove(HDEVICE hDevice);
    virtual HRESULT GetType(INDEX_TYPE * pIndexType);
    virtual HDEVICE GetHDevice(int nIndex);
    virtual int     GetIndex(HDEVICE hDevice);
    
    BOOL    IsAscending() { return m_bAscending; }
    void    SetAscending(BOOL bAscending) { m_bAscending = bAscending; }

    HRESULT SetArray(HDeviceArray & hdeviceArray);
    HDeviceArray & GetArray() { return m_hdeviceArray; }
	
	void SetType(INDEX_TYPE indexType)
	{
		m_dbType = indexType;
	}

    void * BSearch(const void * key, const void * base, size_t num, size_t width);

protected:
    INDEX_TYPE          m_dbType;
    HDeviceArray        m_hdeviceArray;
    BOOL                m_bAscending;
};


// the Index manager
class CIndexMgr : public HDeviceArrayList
{
public:
	CIndexMgr();
	virtual ~CIndexMgr();

public:
    HRESULT Initialize();
    HRESULT Reset();

    UINT    GetTotalCount();
    UINT    GetCurrentCount();

    HRESULT AddHDevice(DWORD dwProviderID, HDEVICE hDevice, BOOL bLoading = FALSE);
    HRESULT RemoveHDevice(DWORD dwProviderID, HDEVICE hDevice);
    HRESULT Sort(DWORD dwProviderID, INDEX_TYPE SortType, DWORD dwSortOptions, LPBYTE pStart);
	
    HRESULT GetHDevice(DWORD dwProviderID, int nIndex, LPHDEVICE phdevice);
    HRESULT GetIndex(DWORD dwProviderID, HDEVICE hrow, int * pIndex);

    void CleanupIndicies();

    HRESULT SetCurrentProvider(DWORD dwProviderID);

protected:
    ProviderIndexList           m_listProviderIndex;
	POSITION					m_posCurrentProvider;
    CCriticalSection			m_cs;
};

// Index for name sorted
class CIndexName : public CHDeviceIndex
{
public:
    CIndexName() : CHDeviceIndex(INDEX_TYPE_NAME) { };

public:
    // used for insertion into the list
    int     BCompare(const void *, const void *);
    
    // used for sorting the list
    virtual HRESULT Sort(LPBYTE pStart);
    static int __cdecl QCompareA(const void *, const void *);
    static int __cdecl QCompareD(const void *, const void *);
};

// Index for Users sorted
class CIndexUsers : public CHDeviceIndex
{
public:
    CIndexUsers() : CHDeviceIndex(INDEX_TYPE_USERS) { };

public:
    // used for insertion into the list
    int     BCompare(const void *, const void *);
    
    // used for sorting the list
    virtual HRESULT Sort(LPBYTE pStart);
    static int __cdecl QCompareA(const void *, const void *);
    static int __cdecl QCompareD(const void *, const void *);
};

// Index for status sorted
class CIndexStatus : public CHDeviceIndex
{
public:
    CIndexStatus() : CHDeviceIndex(INDEX_TYPE_STATUS) { };

public:
    // used for insertion into the list
    int     BCompare(const void *, const void *);
    
    // used for sorting the list
    virtual HRESULT Sort(LPBYTE pStart);
    static int __cdecl QCompareA(const void *, const void *);
    static int __cdecl QCompareD(const void *, const void *);
};


#endif //_HARRAY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\lsastuff.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       lsastuff.cpp
//
//--------------------------------------------------------------------------

//	LsaStuff.cpp
//
//	LSA-dependent code
//
//	HISTORY
//	09-Jul-97	jonn		Creation.
//

#include "stdafx.h"
#include "DynamLnk.h"		// DynamicDLL
#include "servpp.h"

extern "C"
{
	#include <lmcons.h>
	#include <lmshare.h>
	#include <lmerr.h>
	#include <lmapibuf.h>

	#define NTSTATUS LONG
	#define PNTSTATUS NTSTATUS*
	#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
	#define SE_SHUTDOWN_PRIVILEGE             (19L)

// stuff taken from ntdef.h
typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
    PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;
#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }
#define _NTDEF

// from ntstatus.h
#define STATUS_OBJECT_NAME_NOT_FOUND     ((NTSTATUS)0xC0000034L)

// from lmaccess.h
NET_API_STATUS NET_API_FUNCTION
NetUserModalsGet (
    IN  LPCWSTR    servername OPTIONAL,
    IN  DWORD     level,
    OUT LPBYTE    *bufptr
    );
typedef struct _USER_MODALS_INFO_1 {
    DWORD    usrmod1_role;
    LPWSTR   usrmod1_primary;
}USER_MODALS_INFO_1, *PUSER_MODALS_INFO_1, *LPUSER_MODALS_INFO_1;
//
//  UAS role manifests under NETLOGON
//
#define UAS_ROLE_STANDALONE     0
#define UAS_ROLE_MEMBER         1
#define UAS_ROLE_BACKUP         2
#define UAS_ROLE_PRIMARY        3

#include <ntlsa.h>
}


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


typedef enum _Netapi32ApiIndex
{
	BUFFERFREE_ENUM = 0,
	USERMODALSGET_ENUM
};

// not subject to localization
static LPCSTR g_apchNetapi32FunctionNames[] = {
	"NetApiBufferFree",
	"NetUserModalsGet",
	NULL
};

typedef NET_API_STATUS (*BUFFERFREEPROC)(LPVOID);
typedef NET_API_STATUS (*USERMODALSGETPROC)(LPCWSTR, DWORD, LPBYTE*);

// not subject to localization
DynamicDLL g_LSASTUFF_Netapi32DLL( _T("NETAPI32.DLL"), g_apchNetapi32FunctionNames );



/*******************************************************************

    NAME: ::FillUnicodeString

    SYNOPSIS: Standalone method for filling in a UNICODE_STRING

    ENTRY:	punistr - Unicode string to be filled in.
			nls - Source for filling the unistr

    EXIT:

    NOTES:	punistr->Buffer is allocated here and must be deallocated
			by the caller using FreeUnicodeString.

    HISTORY:
	jonn		07/09/97	copied from net\ui\common\src\lmobj\lmobj\uintmem.cxx

********************************************************************/
VOID FillUnicodeString( LSA_UNICODE_STRING * punistr, LPCWSTR psz )
{
	ASSERT( NULL != punistr && NULL != psz );
	int cTchar = ::wcslen(psz);
	// Length and MaximumLength are counts of bytes.
	punistr->Length = (USHORT) (cTchar * sizeof(WCHAR));
	punistr->MaximumLength = punistr->Length + sizeof(WCHAR);
	punistr->Buffer = new WCHAR[cTchar + 1];
	ASSERT( NULL != punistr->Buffer );
	::wcscpy( punistr->Buffer, psz );
}

/*******************************************************************

    NAME: ::FreeUnicodeString

    SYNOPSIS: Standalone method for freeing in a UNICODE_STRING

    ENTRY:	unistr - Unicode string whose Buffer is to be freed.

    EXIT:

    HISTORY:
	jonn		07/09/97	copied from net\ui\common\src\lmobj\lmobj\uintmem.cxx

********************************************************************/
VOID FreeUnicodeString( LSA_UNICODE_STRING * punistr )
{
	ASSERT( punistr != NULL );
	delete punistr->Buffer;
}



/*******************************************************************

    NAME: InitObjectAttributes

    SYNOPSIS:

    This function initializes the given Object Attributes structure, including
    Security Quality Of Service.  Memory must be allcated for both
    ObjectAttributes and Security QOS by the caller.

    ENTRY:

    poa - Pointer to Object Attributes to be initialized.

    psqos - Pointer to Security QOS to be initialized.

    EXIT:

    NOTES:

    HISTORY:
	jonn		07/09/97	copied from net\ui\common\src\lmobj\lmobj\uintlsa.cxx

********************************************************************/
VOID InitObjectAttributes( PLSA_OBJECT_ATTRIBUTES poa,
                           PSECURITY_QUALITY_OF_SERVICE psqos )

{
    ASSERT( poa != NULL );
    ASSERT( psqos != NULL );

    psqos->Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    psqos->ImpersonationLevel = SecurityImpersonation;
    psqos->ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    psqos->EffectiveOnly = FALSE;

    //
    // Set up the object attributes prior to opening the LSA.
    //

    InitializeObjectAttributes(
				poa,
				NULL,
				0L,
				NULL,
				NULL );

    //
    // The InitializeObjectAttributes macro presently stores NULL for
    // the psqos field, so we must manually copy that
    // structure for now.
    //

    poa->SecurityQualityOfService = psqos;
}


BOOL
I_CheckLSAAccount( LSA_UNICODE_STRING* punistrServerName,
				   LPCTSTR pszLogOnAccountName,
				   DWORD* pdwMsgID ) // *pdsMsgID is always set if this fails
{
	ASSERT( NULL != pdwMsgID );

	BOOL fSuccess = FALSE;
    LSA_HANDLE hlsa = NULL;
    LSA_HANDLE hlsaAccount = NULL;
	PSID psidAccount = NULL;

	do { // false loop

		//
		// Determine whether the target machine is a BDC, and if so, get the PDC
		//

		// if an error occurs now, it is a read error
		*pdwMsgID = IDS_LSAERR_READ_FAILED;

		//
		// Get LSA_POLICY handle
		//
		LSA_OBJECT_ATTRIBUTES oa;
		SECURITY_QUALITY_OF_SERVICE sqos;
		InitObjectAttributes( &oa, &sqos );

		NTSTATUS ntstatus = ::LsaOpenPolicy(
			             punistrServerName,
						 &oa,
						 POLICY_ALL_ACCESS, // CODEWORK ??
						 &hlsa );
		if ( !NT_SUCCESS(ntstatus) )
			break;

		//
		// Remove ".\" from the head of the account name if it is present
		//
		CString strAccountName = pszLogOnAccountName;
		if (   strAccountName.GetLength() >= 2
			&& strAccountName[0] == _T('.')
			&& strAccountName[1] == _T('\\')
		   )
		{
			strAccountName = strAccountName.Mid(2);
		}

		//
		// determine the SID of the account
		//
		PLSA_REFERENCED_DOMAIN_LIST plsardl = NULL;
		PLSA_TRANSLATED_SID plsasid = NULL;
		LSA_UNICODE_STRING unistrAccountName;
		::FillUnicodeString( &unistrAccountName, strAccountName );
		ntstatus = ::LsaLookupNames(
						 hlsa,
						 1,
						 &unistrAccountName,
						 &plsardl,
						 &plsasid );
		::FreeUnicodeString( &unistrAccountName );
		if ( !NT_SUCCESS(ntstatus) )
			break;

		//
		// Build the SID of the account by taking the SID of the domain
		// and adding at the end the RID of the account
		//
		PSID psidDomain = plsardl->Domains[0].Sid;
		DWORD ridAccount = plsasid[0].RelativeId;
		DWORD cbNewSid = ::GetLengthSid(psidDomain)+sizeof(ridAccount);
		psidAccount = (PSID) new BYTE[cbNewSid];
		ASSERT( NULL != psidAccount );
		(void) ::CopySid( cbNewSid, psidAccount, psidDomain );
		UCHAR* pcSubAuthorities = ::GetSidSubAuthorityCount( psidAccount ) ;
        (*pcSubAuthorities)++;
		DWORD* pdwSubAuthority = ::GetSidSubAuthority(
			psidAccount, (*pcSubAuthorities)-1 );
		*pdwSubAuthority = ridAccount;

		(void) ::LsaFreeMemory( plsardl );
		(void) ::LsaFreeMemory( plsasid );

		//
		// Determine whether this LSA account exists, create it if not
		//
		ntstatus = ::LsaOpenAccount( hlsa,
		                             psidAccount,
                                     ACCOUNT_ALL_ACCESS | DELETE, // CODEWORK
		                             &hlsaAccount );
		ULONG ulSystemAccessCurrent = 0;
		if (STATUS_OBJECT_NAME_NOT_FOUND == ntstatus)
		{
			// handle account-not-found case

			// if an error occurs now, it is a write error
			*pdwMsgID = IDS_LSAERR_WRITE_FAILED;
			ntstatus = ::LsaCreateAccount( hlsa,
			                               psidAccount,
										   ACCOUNT_ALL_ACCESS | DELETE,
										   &hlsaAccount );
			// presumably the account is created without POLICY_MODE_SERVICE privilege
		}
		else
		{
			ntstatus = ::LsaGetSystemAccessAccount( hlsaAccount, &ulSystemAccessCurrent );
		}
		if ( !NT_SUCCESS(ntstatus) )
			break;

		//
		// Determine whether this LSA account has POLICY_MODE_SERVICE privilege,
		// grant it if not
		//
		if ( POLICY_MODE_SERVICE != (ulSystemAccessCurrent & POLICY_MODE_SERVICE ) )
		{
			// if an error occurs now, it is a write error
			*pdwMsgID = IDS_LSAERR_WRITE_FAILED;

			ntstatus = ::LsaSetSystemAccessAccount(
				hlsaAccount,
				ulSystemAccessCurrent | POLICY_MODE_SERVICE );
			if ( !NT_SUCCESS(ntstatus) )
				break; // CODEWORK could check for STATUS_BACKUP_CONTROLLER

			*pdwMsgID = 0;
		}
		else
		{
			*pdwMsgID = 0;
		}

		fSuccess = TRUE;

	} while (FALSE); // false loop

	// CODEWORK should check for special error code for NT5 non-DC
	// using local policy object

	if (NULL != hlsa)
	{
		::LsaClose( hlsa );
	}
	if (NULL != hlsaAccount)
	{
		::LsaClose( hlsaAccount );
	}
	if (NULL != psidAccount)
	{
		delete psidAccount;
	}

	return fSuccess;

} // I_CheckLSAAccount()

/////////////////////////////////////////////////////////////////////
//	FCheckLSAAccount()
//
VOID
CServerProperties::FCheckLSAAccount()
{
	LSA_UNICODE_STRING unistrServerName;
	PLSA_UNICODE_STRING punistrServerName = NULL ;
	USER_MODALS_INFO_1* pum1 = NULL;
	DWORD dwMsgID = 0;

	TRACE1("INFO: Checking LSA permissions for account %s...\n",
		(LPCTSTR)m_strLogOnAccountName);

	if ( !m_strMachineName.IsEmpty() )
	{
		::FillUnicodeString( &unistrServerName, m_strMachineName );
		punistrServerName = &unistrServerName;
	}

	do // false loop
	{
		// check on the local machine
		// this will always set dwMsgID if it fails
		if (I_CheckLSAAccount(punistrServerName, m_strLogOnAccountName, &dwMsgID))
			break; // this succeeded, we can stop now

		// check whether this is a Backup Domain Controller
		if ( !g_LSASTUFF_Netapi32DLL.LoadFunctionPointers() )
		{
			ASSERT(FALSE);
			return;
		}
		DWORD err = ((USERMODALSGETPROC)g_LSASTUFF_Netapi32DLL[USERMODALSGET_ENUM])(
			(m_strMachineName.IsEmpty()) ? NULL : const_cast<LPTSTR>((LPCTSTR)m_strMachineName),
			1,
			reinterpret_cast<LPBYTE*>(&pum1) );
		if (NERR_Success != err)
			break;
		ASSERT( NULL != pum1 );
		if (UAS_ROLE_BACKUP != pum1->usrmod1_role)
			break; // not a backup controller
		if (NULL == pum1->usrmod1_primary )
		{
			ASSERT(FALSE);
			break;
		}

		// Try it on the PDC
		(void) I_CheckLSAAccount(punistrServerName, pum1->usrmod1_primary, &dwMsgID);

	} while (FALSE); // false loop

    if ( NULL != punistrServerName )
    {
		::FreeUnicodeString( punistrServerName );
    }

	if ( NULL != pum1 )
	{
		if ( !g_LSASTUFF_Netapi32DLL.LoadFunctionPointers() )
		{
			ASSERT(FALSE);
			return;
		}

		((BUFFERFREEPROC)g_LSASTUFF_Netapi32DLL[BUFFERFREE_ENUM])( pum1 );
	}

	if (0 != dwMsgID)
	{
		CString strMessage;

		strMessage.FormatMessage(dwMsgID, m_strLogOnAccountName);

		AfxMessageBox(strMessage);
	}

} // FCheckLSAAccount()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\harray.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	hArray.cpp	
		Index manager for TAPI devices db

	FILE HISTORY:
    Dec 16  1997    EricDav     Created

*/

#include "stdafx.h"
#include "harray.h"
#include "mbstring.h"

LPBYTE		g_pStart;

/*!--------------------------------------------------------------------------
    Class CHDeviceIndex
 ---------------------------------------------------------------------------*/
CHDeviceIndex::CHDeviceIndex(INDEX_TYPE IndexType)
    : m_dbType(IndexType), m_bAscending(TRUE)
{
}

CHDeviceIndex::~CHDeviceIndex()
{
}

/*!--------------------------------------------------------------------------
	CHDeviceIndex::GetType
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CHDeviceIndex::GetType(INDEX_TYPE * pIndexType)
{
    if (pIndexType)
        *pIndexType = m_dbType;

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CHDeviceIndex::SetArray
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CHDeviceIndex::SetArray(HDeviceArray & hdeviceArray)
{
    m_hdeviceArray.Copy(hdeviceArray);

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CHDeviceIndex::GetHDevice
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HDEVICE
CHDeviceIndex::GetHDevice(int nIndex)
{
    Assert(nIndex >= 0);
    Assert(nIndex <= m_hdeviceArray.GetSize());

    if (nIndex < 0 || 
        nIndex >= m_hdeviceArray.GetSize())
    {
        return NULL;
    }

    return m_hdeviceArray.GetAt(nIndex);
}

/*!--------------------------------------------------------------------------
	CHDeviceIndex::GetIndex
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
int
CHDeviceIndex::GetIndex(HDEVICE hdevice)
{
    Assert(hdevice != 0);

    LPHDEVICE phdevice = (LPHDEVICE) BSearch((const void *)&hdevice, 
                                    (const void *)m_hdeviceArray.GetData(), 
                                    (size_t)m_hdeviceArray.GetSize(), 
                                    sizeof(HDEVICE));

    int nIndex = (int) (phdevice - (LPHDEVICE) m_hdeviceArray.GetData());
    Assert(nIndex >= 0);
    Assert(nIndex <= m_hdeviceArray.GetSize());

    int nComp, nIndexTemp;
    
    nComp = BCompare(&hdevice, phdevice);
    if (nComp == 0)
    {
        // found the right one, check the previous one to return the first 
        // record in a list of duplicates
        nIndexTemp = nIndex;

        while (nIndexTemp && nComp == 0)
        {
            *phdevice = m_hdeviceArray.GetAt(--nIndexTemp);
            nComp = BCompare(&hdevice, phdevice);
        }

        if (nIndexTemp == nIndex)
			return nIndex; // nIndex should be zero here as well
		else
			if (nComp == 0)
				return nIndexTemp; // nIndexTemp should be 0 in this case
			else
				return nIndexTemp++;
    }

    return -1;
}

/*!--------------------------------------------------------------------------
	CHDeviceIndex::Add
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CHDeviceIndex::Add(HDEVICE hdevice, BOOL bEnd)
{
    // if we are loading the array then just stick this on the end
    if (bEnd)
    {
        m_hdeviceArray.Add(hdevice);
    }
    else
    {
        if (m_hdeviceArray.GetSize() == 0)
        {
            m_hdeviceArray.Add(hdevice);
        }
        else
        {
            LPHDEVICE phdevice = (LPHDEVICE) BSearch((const void *)&hdevice, 
                                            (const void *)m_hdeviceArray.GetData(), 
                                            (size_t)m_hdeviceArray.GetSize(), 
                                            sizeof(HDEVICE));
    
            int nIndex = (int) (phdevice - (LPHDEVICE) m_hdeviceArray.GetData());
            Assert(nIndex >= 0);
            Assert(nIndex <= m_hdeviceArray.GetSize());
    
            int nComp = BCompare(&hdevice, phdevice);
            if (nComp < 0)
            {
				if(nIndex == 0)
					m_hdeviceArray.InsertAt(nIndex , hdevice);

				else             // Insert before phdevice
					m_hdeviceArray.InsertAt(nIndex - 1, hdevice);
            }
            else
            {
                // insert after phdevice
                m_hdeviceArray.InsertAt(nIndex + 1, hdevice);
            }
        }
    }

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CHDeviceIndex::Remove
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CHDeviceIndex::Remove(HDEVICE hdevice)
{
    // do a bsearch for the record and then remove
    LPHDEVICE phdevice = (LPHDEVICE) BSearch(&hdevice, 
                                    m_hdeviceArray.GetData(), 
                                    (size_t)m_hdeviceArray.GetSize(), 
                                    sizeof(HDEVICE));

    int nComp = BCompare(&hdevice, phdevice);
    Assert(nComp == 0);
    if (nComp != 0)
        return E_FAIL;

    // calculate the index
    int nIndex = (int) (phdevice - (LPHDEVICE) m_hdeviceArray.GetData());
    Assert(nIndex >= 0);
    Assert(nIndex <= m_hdeviceArray.GetSize());

    m_hdeviceArray.RemoveAt(nIndex);

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CHDeviceIndex::BSearch
		Modified bsearch which returns the closest or equal element in
        an array
	Author: EricDav
 ---------------------------------------------------------------------------*/
void * 
CHDeviceIndex::BSearch (const void *key,
                     const void *base,
                     size_t num,
                     size_t width)
{
        char *lo = (char *)base;
        char *hi = (char *)base + (num - 1) * width;
        char *mid;
        unsigned int half;
        int result;

        while (lo <= hi)
                if (half = num / 2)
                {
                        mid = lo + (num & 1 ? half : (half - 1)) * width;
                        if (!(result = BCompare(key,mid)))
                                return(mid);
                        else if (result < 0)
                        {
                                hi = mid - width;
                                num = num & 1 ? half : half-1;
                        }
                        else    {
                                lo = mid + width;
                                num = half;
                        }
                }
                else if (num)
                        return(lo);
                else
                        break;

        return(mid);
}






/*!--------------------------------------------------------------------------
    Class CIndexMgr
 ---------------------------------------------------------------------------*/

CIndexMgr::CIndexMgr()
{
    m_posCurrentProvider= NULL;
}

CIndexMgr::~CIndexMgr()
{
    Reset();
}
	
/*!--------------------------------------------------------------------------
	CIndexMgr::Initialize
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CIndexMgr::Initialize()
{
    HRESULT hr = hrOK;

    CSingleLock cl(&m_cs);
    cl.Lock();

    COM_PROTECT_TRY
    {
        // cleanup
        Reset();
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
	CIndexMgr::Reset
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CIndexMgr::Reset()
{
    CSingleLock cl(&m_cs);
    cl.Lock();

    while (m_listProviderIndex.GetCount() > 0)
    {
        CProviderIndexInfo * pProviderIndexInfo = m_listProviderIndex.RemoveHead();
        while (pProviderIndexInfo->m_listIndicies.GetCount() > 0)
            delete pProviderIndexInfo->m_listIndicies.RemoveHead();

        delete pProviderIndexInfo;
	}

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CIndexMgr::GetTotalCount
        The index sorted by name contains the total database and should
        always be available. Use this for the total count.
	Author: EricDav
 ---------------------------------------------------------------------------*/
UINT
CIndexMgr::GetTotalCount()
{
    CSingleLock cl(&m_cs);
    cl.Lock();

    UINT uTotalCount = 0;
    POSITION pos;

    pos = m_listProviderIndex.GetHeadPosition();
    while (pos)
    {
        CProviderIndexInfo * pProviderIndexInfo = m_listProviderIndex.GetNext(pos);
        if (pProviderIndexInfo->m_listIndicies.GetCount() > 0)
            uTotalCount += (UINT)(pProviderIndexInfo->m_listIndicies.GetHead())->GetArray().GetSize();
    }

    return uTotalCount;
}

/*!--------------------------------------------------------------------------
	CIndexMgr::GetCurrentCount
        The current count may differ depending upon if the current Index
        is a filtered index.
	Author: EricDav
 ---------------------------------------------------------------------------*/
UINT
CIndexMgr::GetCurrentCount()
{
    CSingleLock cl(&m_cs);
    cl.Lock();

    CProviderIndexInfo * pProviderIndexInfo = NULL;
    CHDeviceIndex * pIndex = NULL;

    pProviderIndexInfo = m_listProviderIndex.GetAt(m_posCurrentProvider);
	pIndex = pProviderIndexInfo->m_listIndicies.GetAt(pProviderIndexInfo->m_posCurrentIndex);

    if (pIndex == NULL)
        return 0;

    return (UINT)pIndex->GetArray().GetSize();
}

/*!--------------------------------------------------------------------------
	CIndexMgr::AddHDevice
        -
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CIndexMgr::AddHDevice(DWORD dwProviderID, HDEVICE hdevice, BOOL bEnd)
{
    CSingleLock cl(&m_cs);
    cl.Lock();

    HRESULT hr = hrOK;
    CProviderIndexInfo * pProviderIndexInfo = NULL;
    CHDeviceIndex * pIndex = NULL;

    COM_PROTECT_TRY
    {
        // set current provider set the current provider position and if 
        // the provider doesn't exist, it will create one
        hr = SetCurrentProvider(dwProviderID);
        if (FAILED(hr))
            return hr;

        pProviderIndexInfo = m_listProviderIndex.GetAt(m_posCurrentProvider);

        pIndex = pProviderIndexInfo->m_listIndicies.GetAt(pProviderIndexInfo->m_posCurrentIndex);
        if (pIndex)
            pIndex->Add(hdevice, bEnd);

    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
	CIndexMgr::RemoveHDevice
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CIndexMgr::RemoveHDevice(DWORD dwProviderID, HDEVICE hdevice)
{
    CSingleLock cl(&m_cs);
    cl.Lock();

    HRESULT hr = hrOK;
    CProviderIndexInfo * pProviderIndexInfo = NULL;
    CHDeviceIndex * pIndex = NULL;

    COM_PROTECT_TRY
    {
        hr = SetCurrentProvider(dwProviderID);
        if (FAILED(hr))
            return hr;

        pProviderIndexInfo = m_listProviderIndex.GetAt(m_posCurrentProvider);

        pIndex = pProviderIndexInfo->m_listIndicies.GetAt(pProviderIndexInfo->m_posCurrentIndex);
        if (pIndex)
            pIndex->Remove(hdevice);
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
	CIndexMgr::Sort
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CIndexMgr::Sort(DWORD dwProviderID, INDEX_TYPE SortType, DWORD dwSortOptions, LPBYTE pStart)
{
    CSingleLock cl(&m_cs);
    cl.Lock();

    HRESULT hr = hrOK;
    CHDeviceIndex * pNameIndex;
    CHDeviceIndex * pNewIndex;
    POSITION pos, posLast;

    INDEX_TYPE indexType;
    BOOL bAscending = (dwSortOptions & SORT_ASCENDING) ? TRUE : FALSE;

    hr = SetCurrentProvider(dwProviderID);
    if (FAILED(hr))
        return hr;

	// check to see if we have an index for this.
    CProviderIndexInfo * pProviderIndexInfo = m_listProviderIndex.GetAt(m_posCurrentProvider);

    pos = pProviderIndexInfo->m_listIndicies.GetHeadPosition();
	while (pos)
	{
		posLast = pos;
		CHDeviceIndex * pIndex = pProviderIndexInfo->m_listIndicies.GetNext(pos);

		pIndex->GetType(&indexType);

        // the index for this type already exists, just sort accordingly
        if (indexType == SortType)
		{
			if (pIndex->IsAscending() != bAscending)
			{
				pIndex->SetAscending(bAscending);
				pIndex->Sort(pStart);
			}

			pProviderIndexInfo->m_posCurrentIndex = posLast;
		
			return hrOK;
		}
    }
    
    // to save memory, remove all old indicies, except the name index
    //CleanupIndicies();

    // if not, create one
    switch (SortType)
    {
        case INDEX_TYPE_NAME:
            pNewIndex = new CIndexName();
            break;

        case INDEX_TYPE_USERS:
            pNewIndex = new CIndexUsers();
            break;

        case INDEX_TYPE_STATUS:
            pNewIndex = new CIndexStatus();
            break;

        default:
            Panic1("Invalid sort type passed to IndexMgr::Sort %d\n", SortType);
            break;
    }

    Assert(pNewIndex);

    // name index is always the first in the list
    pNameIndex = pProviderIndexInfo->m_listIndicies.GetHead();

    Assert(pNameIndex);

    // copy the array from the named index
    pNewIndex->SetArray(pNameIndex->GetArray());

    pNewIndex->SetAscending(bAscending);
    pNewIndex->Sort(pStart);

	pProviderIndexInfo->m_posCurrentIndex = pProviderIndexInfo->m_listIndicies.AddTail(pNewIndex);

    return hr;
}

/*!--------------------------------------------------------------------------
	CIndexMgr::CleanupIndicies
		Removes all indicies except the name index, and a filtered view
	Author: EricDav
 ---------------------------------------------------------------------------*/
void
CIndexMgr::CleanupIndicies()
{
    CSingleLock cl(&m_cs);
    cl.Lock();

    INDEX_TYPE  indexType;

    CProviderIndexInfo * pProviderIndexInfo = m_listProviderIndex.GetAt(m_posCurrentProvider);

    POSITION pos = pProviderIndexInfo->m_listIndicies.GetHeadPosition();
    while (pos)
    {
        POSITION posLast = pos;
        CHDeviceIndex * pIndex = pProviderIndexInfo->m_listIndicies.GetNext(pos);
    
        pIndex->GetType(&indexType);

        if (indexType == INDEX_TYPE_NAME)
            continue;

        pProviderIndexInfo->m_listIndicies.RemoveAt(posLast);
        delete pIndex;
    }
}

/*!--------------------------------------------------------------------------
	CIndexMgr::GetHDevice
		Returns an hdevice based on an index into the current sorted list
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CIndexMgr::GetHDevice(DWORD dwProviderID, int nIndex, LPHDEVICE phdevice)
{
    CSingleLock cl(&m_cs);
    cl.Lock();

    SetCurrentProvider(dwProviderID);

    CProviderIndexInfo * pProviderIndexInfo = m_listProviderIndex.GetAt(m_posCurrentProvider);
    CHDeviceIndex * pIndex = pProviderIndexInfo->m_listIndicies.GetAt(pProviderIndexInfo->m_posCurrentIndex);

    Assert(pIndex);

    if (phdevice)
        *phdevice = pIndex->GetHDevice(nIndex);

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CIndexMgr::GetIndex
		Returns the index of an hlien from the current sorted list
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CIndexMgr::GetIndex(DWORD dwProviderID, HDEVICE hdevice, int * pnIndex)
{
    CSingleLock cl(&m_cs);
    cl.Lock();

    SetCurrentProvider(dwProviderID);

    CProviderIndexInfo * pProviderIndexInfo = m_listProviderIndex.GetAt(m_posCurrentProvider);
    CHDeviceIndex * pIndex = pProviderIndexInfo->m_listIndicies.GetAt(pProviderIndexInfo->m_posCurrentIndex);

    Assert(pIndex);

    if (pIndex)
        *pnIndex = pIndex->GetIndex(hdevice);

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CIndexMgr::SetCurrentProvider
		Sets the current provider for the index mgr, if it doesn't exist,
        it is created
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CIndexMgr::SetCurrentProvider(DWORD dwProviderID)
{
    HRESULT hr = hrOK;
    BOOL    bExists = FALSE;
    POSITION posLast;

    COM_PROTECT_TRY
    {
        POSITION pos = m_listProviderIndex.GetHeadPosition();
        while (pos)
        {
            posLast = pos;
            CProviderIndexInfo * pProviderIndexInfo = m_listProviderIndex.GetNext(pos);

            // is the the correct provider to add this to?
            if (pProviderIndexInfo->m_dwProviderID != dwProviderID)
                continue;
            
            m_posCurrentProvider = posLast;
            bExists = TRUE;
    	}

        if (!bExists)
        {   
            // no provider index exists for this.  Create one now.
            CProviderIndexInfo * pProviderIndexInfo = new CProviderIndexInfo;
            pProviderIndexInfo->m_dwProviderID = dwProviderID;
            
            CHDeviceIndex * pIndex = new CIndexName;
            pProviderIndexInfo->m_posCurrentIndex = pProviderIndexInfo->m_listIndicies.AddHead(pIndex);

            m_posCurrentProvider = m_listProviderIndex.AddTail(pProviderIndexInfo);
        }
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
    Class CIndexName
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	CIndexName::BCompare
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
int
CIndexName::BCompare(const void * elem1, const void * elem2)
{
    int     nRet;
    LPHDEVICE phdevice1 = (LPHDEVICE) elem1;
    LPHDEVICE phdevice2 = (LPHDEVICE) elem2;

    LPDEVICEINFO pRec1 = (LPDEVICEINFO) *phdevice1;
    LPDEVICEINFO pRec2 = (LPDEVICEINFO) *phdevice2;

    nRet = lstrcmp((LPCTSTR) (g_pStart + pRec1->dwDeviceNameOffset), (LPCTSTR) (g_pStart + pRec2->dwDeviceNameOffset));
    if (nRet == 0)
    {
        // permanent device IDs should be unique
        if (pRec1->dwPermanentDeviceID > pRec2->dwPermanentDeviceID)
            nRet = 1;
        else
            nRet = -1;
    }

    return nRet;
}

/*!--------------------------------------------------------------------------
	CIndexName::Sort
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CIndexName::Sort(LPBYTE pStart)
{
	// save the base pointer for later
	g_pStart = pStart;

    if (m_bAscending)
        qsort(m_hdeviceArray.GetData(), (size_t)m_hdeviceArray.GetSize(), sizeof(HDEVICE), QCompareA);
    else
        qsort(m_hdeviceArray.GetData(), (size_t)m_hdeviceArray.GetSize(), sizeof(HDEVICE), QCompareD);

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CIndexName::QCompare
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
int __cdecl
CIndexName::QCompareA(const void * elem1, const void * elem2)
{
    int     nRet;
    LPHDEVICE phdevice1 = (LPHDEVICE) elem1;
    LPHDEVICE phdevice2 = (LPHDEVICE) elem2;
    
    LPDEVICEINFO pRec1 = (LPDEVICEINFO) *phdevice1;
    LPDEVICEINFO pRec2 = (LPDEVICEINFO) *phdevice2;
    
    nRet = lstrcmp((LPCTSTR) (g_pStart + pRec1->dwDeviceNameOffset), (LPCTSTR) (g_pStart + pRec2->dwDeviceNameOffset));
    if (nRet == 0)
    {
        // permanent device IDs should be unique
        if (pRec1->dwPermanentDeviceID > pRec2->dwPermanentDeviceID)
            nRet = 1;
        else
            nRet = -1;
    }

    return nRet;
}

int __cdecl
CIndexName::QCompareD(const void * elem1, const void * elem2)
{
    return -QCompareA(elem1, elem2);
}

/*!--------------------------------------------------------------------------
    Class CIndexUsers
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	CIndexUsers::BCompare
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
int
CIndexUsers::BCompare(const void * elem1, const void * elem2)
{
    int     nRet;
    LPHDEVICE phdevice1 = (LPHDEVICE) elem1;
    LPHDEVICE phdevice2 = (LPHDEVICE) elem2;
    
    LPDEVICEINFO pRec1 = (LPDEVICEINFO) *phdevice1;
    LPDEVICEINFO pRec2 = (LPDEVICEINFO) *phdevice2;
    
    nRet = lstrcmp((LPCTSTR) (g_pStart + pRec1->dwDomainUserNamesOffset), (LPCTSTR) (g_pStart + pRec2->dwDomainUserNamesOffset));
    if (nRet == 0)
        nRet = lstrcmp((LPCTSTR) (g_pStart + pRec1->dwDeviceNameOffset), (LPCTSTR) (g_pStart + pRec2->dwDeviceNameOffset));
    
    return nRet;
}

/*!--------------------------------------------------------------------------
	CIndexUsers::Sort
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CIndexUsers::Sort(LPBYTE pStart)
{
	// save the base pointer for later
	g_pStart = pStart;

    if (m_bAscending)
        qsort(m_hdeviceArray.GetData(), (size_t)m_hdeviceArray.GetSize(), sizeof(HDEVICE), QCompareA);
    else
        qsort(m_hdeviceArray.GetData(), (size_t)m_hdeviceArray.GetSize(), sizeof(HDEVICE), QCompareD);

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CIndexUsers::QCompare
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
int __cdecl
CIndexUsers::QCompareA(const void * elem1, const void * elem2)
{
    int nRet;

    LPHDEVICE phdevice1 = (LPHDEVICE) elem1;
    LPHDEVICE phdevice2 = (LPHDEVICE) elem2;
    
    LPDEVICEINFO pRec1 = (LPDEVICEINFO) *phdevice1;
    LPDEVICEINFO pRec2 = (LPDEVICEINFO) *phdevice2;
    
    nRet = lstrcmp((LPCTSTR) (g_pStart + pRec1->dwDomainUserNamesOffset), (LPCTSTR) (g_pStart + pRec2->dwDomainUserNamesOffset));
    if (nRet == 0)
        nRet = lstrcmp((LPCTSTR) (g_pStart + pRec1->dwDeviceNameOffset), (LPCTSTR) (g_pStart + pRec2->dwDeviceNameOffset));
    
    return nRet;
}

int __cdecl
CIndexUsers::QCompareD(const void * elem1, const void * elem2)
{
    return -QCompareA(elem1, elem2);
}

/*!--------------------------------------------------------------------------
    Class CIndexStatus
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	CIndexStatus::BCompare
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
int
CIndexStatus::BCompare(const void * elem1, const void * elem2)
{
    LPHDEVICE phdevice1 = (LPHDEVICE) elem1;
    LPHDEVICE phdevice2 = (LPHDEVICE) elem2;
    
    LPDEVICEINFO pRec1 = (LPDEVICEINFO) *phdevice1;
    LPDEVICEINFO pRec2 = (LPDEVICEINFO) *phdevice2;
    
    //return _mbscmp((const PUCHAR) &pRec1->szRecordName[0], (const PUCHAR) &pRec2->szRecordName[0]);
    return 0;
}

/*!--------------------------------------------------------------------------
	CIndexStatus::Sort
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CIndexStatus::Sort(LPBYTE pStart)
{
	// save the base pointer for later
	g_pStart = pStart;

    if (m_bAscending)
        qsort(m_hdeviceArray.GetData(), (size_t)m_hdeviceArray.GetSize(), sizeof(HDEVICE), QCompareA);
    else
        qsort(m_hdeviceArray.GetData(), (size_t)m_hdeviceArray.GetSize(), sizeof(HDEVICE), QCompareD);

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CIndexIpAddr::QCompare
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
int __cdecl
CIndexStatus::QCompareA(const void * elem1, const void * elem2)
{
    LPHDEVICE phdevice1 = (LPHDEVICE) elem1;
    LPHDEVICE phdevice2 = (LPHDEVICE) elem2;
    
    LPHDEVICE pRec1 = (LPHDEVICE) *phdevice1;
    LPHDEVICE pRec2 = (LPHDEVICE) *phdevice2;
    
    //return lstrcmp((LPCTSTR) (g_pStart + pRec1->dwDeviceNameOffset), (LPCTSTR) (g_pStart + pRec2->dwDeviceNameOffset));
    return 0;
}

int __cdecl
CIndexStatus::QCompareD(const void * elem1, const void * elem2)
{
    return -QCompareA(elem1, elem2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\provider.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	lines.h

    FILE HISTORY:
        
*/

#ifndef _LINES_H
#define _LINES_H

#ifndef _TAPIHAND_H
#include "tapihand.h"
#endif

#ifndef _TAPIDB_H
#include "tapidb.h"
#endif

#define TAPISNAP_UPDATE_STATUS ( 0x10000000 )

typedef struct TapiStrRecord_t
{
    CString     strName;
    CString     strUsers;
} TapiStrRecord;

// hash table for Tapi string records
typedef CMap<int, int, TapiStrRecord, TapiStrRecord&> CTapiRecordMap;
typedef CMap<int, int, CString, CString&> CTapiStatusRecordMap;

/*---------------------------------------------------------------------------
	Class:	CProviderHandler
 ---------------------------------------------------------------------------*/
class CProviderHandler : public CTapiHandler
{
public:
    CProviderHandler(ITFSComponentData* pTFSComponentData);
	~CProviderHandler();

// Interface
public:
	// base handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages();
    OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();
	OVERRIDE_NodeHandler_GetString()
			{ return (nCol == 0) ? GetDisplayName() : NULL; }

    // Base handler notifications we handle
    OVERRIDE_BaseHandlerNotify_OnCreateNodeId2();
	OVERRIDE_BaseHandlerNotify_OnExpand();
    OVERRIDE_BaseHandlerNotify_OnDelete();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();    

	// Result handler functionality we override
    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultUpdateView();
    OVERRIDE_BaseResultHandlerNotify_OnResultItemClkOrDblClk();

    OVERRIDE_ResultHandler_OnGetResultViewType();
	OVERRIDE_ResultHandler_GetVirtualString(); 
	OVERRIDE_ResultHandler_GetVirtualImage();
    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();

	STDMETHODIMP CacheHint(int nStartIndex, int nEndIndex);
	STDMETHODIMP SortItems(int     nColumn, 
						   DWORD   dwSortOptions,    
						   LPARAM  lUserParam);

    // base handler overrides
	virtual HRESULT LoadColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

    // multi select support
    virtual const GUID * GetVirtualGuid(int nIndex) 
	{ 
		return &GUID_TapiLineNodeType; 
	}

public:
	// CMTTapiHandler functionality
	virtual HRESULT  InitializeNode(ITFSNode * pNode);
	virtual int      GetImageIndex(BOOL bOpenImage);
	ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);

public:
	// implementation specific	
    HRESULT BuildDisplayName(CString * pstrDisplayName);
    HRESULT InitData(CTapiProvider & tapiProvider, ITapiInfo * pTapiInfo);
    HRESULT UpdateListboxCount(ITFSNode * pNode, BOOL bClear = FALSE);
    HRESULT UpdateStatus(ITFSNode * pNode);
    HRESULT UpdateColumnText(ITFSComponent * pComponent);

    void    SetColumnInfo();

    BOOL    BuildTapiStrRecord(int nIndex, TapiStrRecord & tsr);
    BOOL    BuildStatus(int nIndex, CString & strStatus);
    DWORD   GetID() { return m_dwProviderID; }

// Implementation
private:
	// Command handlers
    HRESULT OnConfigureProvider(ITFSNode * pNode);
    HRESULT OnDelete(ITFSNode * pNode);

    HRESULT OnEditUsers(ITFSComponent * pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie);

private:
    DWORD               m_dwProviderID;
    DWORD               m_dwFlags;
    CString             m_strProviderName;
    SPITapiInfo         m_spTapiInfo;

    CTapiRecordMap          m_mapRecords;
    CTapiStatusRecordMap    m_mapStatus;

    DEVICE_TYPE             m_deviceType;
};



/*---------------------------------------------------------------------------
	Class:	CProviderHandlerQueryObj
 ---------------------------------------------------------------------------*/
class CProviderHandlerQueryObj : public CTapiQueryObj
{
public:
	CProviderHandlerQueryObj(ITFSComponentData * pTFSComponentData,
						ITFSNodeMgr *	    pNodeMgr) 
			: CTapiQueryObj(pTFSComponentData, pNodeMgr) {};
	
	STDMETHODIMP Execute();
	
public:
};


#endif _LINES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\provider.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    provider.cpp
        Tapi provider node handler

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "provider.h"       // Provider node definition
#include "EditUser.h"       // user editor
#include "server.h"
#include "tapi.h"

/*---------------------------------------------------------------------------
    Class CProviderHandler implementation
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    Constructor and destructor
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
CProviderHandler::CProviderHandler
(
    ITFSComponentData * pComponentData
) : CTapiHandler(pComponentData)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    m_deviceType = DEVICE_LINE;
}


CProviderHandler::~CProviderHandler()
{
}

/*!--------------------------------------------------------------------------
    CProviderHandler::InitializeNode
        Initializes node specific data
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CProviderHandler::InitializeNode
(
    ITFSNode * pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
    CString strTemp;

    BuildDisplayName(&strTemp);
    
    SetDisplayName(strTemp);

    // Make the node immediately visible
    pNode->SetVisibilityState(TFS_VIS_SHOW);
    pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
    pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_FOLDER_CLOSED);
    pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_FOLDER_OPEN);
    pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, TAPISNAP_PROVIDER);
    pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

    SetColumnStringIDs(&aColumns[TAPISNAP_PROVIDER][0]);
    SetColumnWidths(&aColumnWidths[TAPISNAP_PROVIDER][0]);

    return hrOK;
}

/*---------------------------------------------------------------------------
	CProviderHandler::OnCreateNodeId2
		Returns a unique string for this node
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CProviderHandler::OnCreateNodeId2(ITFSNode * pNode, CString & strId, DWORD * dwFlags)
{
    const GUID * pGuid = pNode->GetNodeType();

    CString strProviderId, strGuid;

    StringFromGUID2(*pGuid, strGuid.GetBuffer(256), 256);
    strGuid.ReleaseBuffer();

    strProviderId.Format(_T("%d"), m_dwProviderID);

    strId = m_spTapiInfo->GetComputerName() + strProviderId + strGuid;

    return hrOK;
}

/*---------------------------------------------------------------------------
    CProviderHandler::GetImageIndex
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
int 
CProviderHandler::GetImageIndex(BOOL bOpenImage) 
{
    int nIndex = -1;

    return nIndex;
}


/*---------------------------------------------------------------------------
    Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CProviderHandler::OnAddMenuItems
        Adds context menu items for the provider scope pane node
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CProviderHandler::OnAddMenuItems
(
    ITFSNode *              pNode,
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    LPDATAOBJECT            lpDataObject, 
    DATA_OBJECT_TYPES       type, 
    DWORD                   dwType,
    long *                  pInsertionAllowed
)
{ 
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    LONG        fFlags = 0, fLoadingFlags = 0;
    HRESULT     hr = S_OK;
    CString     strMenuItem;
/*
    if ( m_nState != loaded )
    {
        fFlags |= MF_GRAYED;
    }

    if ( m_nState == loading)
    {
        fLoadingFlags = MF_GRAYED;
    }
*/
    //Bug 305657 We cannot configure TSP remotely
    if (!m_spTapiInfo->IsLocalMachine() || !m_spTapiInfo->IsAdmin())
    {
        fFlags |= MF_GRAYED;
    }

    if (type == CCT_SCOPE)
    {
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
            if (m_dwFlags & AVAILABLEPROVIDER_CONFIGURABLE)
            {
                strMenuItem.LoadString(IDS_CONFIGURE_PROVIDER);
                hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                         strMenuItem, 
                                         IDS_CONFIGURE_PROVIDER,
                                         CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                         fFlags );
                ASSERT( SUCCEEDED(hr) );
            }
        }
    }

    return hr; 
}

/*!--------------------------------------------------------------------------
    CProviderHandler::AddMenuItems
        Adds context menu items for virtual list box (result pane) items
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CProviderHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
    MMC_COOKIE              cookie,
    LPDATAOBJECT            pDataObject, 
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    long *                  pInsertionAllowed
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT     hr = hrOK;
    CString     strMenuItem;
    SPINTERNAL  spInternal;
    LONG        fFlags = 0;
    int         nIndex;
    DWORD       dwFlags;
    CTapiDevice tapiDevice;

    spInternal = ExtractInternalFormat(pDataObject);

    // virtual listbox notifications come to the handler of the node that is selected.
    // check to see if this notification is for a virtual listbox item or this provider
    // node itself.
    if (spInternal->HasVirtualIndex())
    {
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
            CTapiConfigInfo     tapiConfigInfo;

            m_spTapiInfo->GetConfigInfo(&tapiConfigInfo);

            if (m_spTapiInfo->IsAdmin() && 
                tapiConfigInfo.m_dwFlags & TAPISERVERCONFIGFLAGS_ISSERVER)
            {
                fFlags = 0;
            }
            else
            {
                fFlags = MF_GRAYED;
            }

            //  Check to see if this device can ONLY be used locally, if
            //  so, gray the edit user menu item
            nIndex = spInternal->GetVirtualIndex();
            m_spTapiInfo->GetDeviceInfo(m_deviceType, &tapiDevice, m_dwProviderID, nIndex);
            if (m_deviceType == DEVICE_PHONE ||
                m_spTapiInfo->GetDeviceFlags (
                    tapiDevice.m_dwProviderID,
                    tapiDevice.m_dwPermanentID,
                    &dwFlags
                    ) ||
                (dwFlags & LINEDEVCAPFLAGS_LOCAL)
                )
            {
                fFlags = MF_GRAYED;
            }

            strMenuItem.LoadString(IDS_EDIT_USERS);
            hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                     strMenuItem, 
                                     IDS_EDIT_USERS,
                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                     fFlags );
            ASSERT( SUCCEEDED(hr) );
        }
    }

    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    {
        strMenuItem.LoadString(IDS_VIEW_LINES);
        hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                 strMenuItem, 
                                 IDS_VIEW_LINES,
                                 CCM_INSERTIONPOINTID_PRIMARY_VIEW, 
                                 (m_deviceType == DEVICE_LINE) ? MF_CHECKED : 0 );
        ASSERT( SUCCEEDED(hr) );
        
        strMenuItem.LoadString(IDS_VIEW_PHONES);
        hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                 strMenuItem, 
                                 IDS_VIEW_PHONES,
                                 CCM_INSERTIONPOINTID_PRIMARY_VIEW, 
                                 (m_deviceType == DEVICE_PHONE) ? MF_CHECKED : 0 );
        ASSERT( SUCCEEDED(hr) );
    }

    return hr;
}

/*---------------------------------------------------------------------------
    CProviderHandler::OnCommand
        Handles context menu commands for provider scope pane node
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CProviderHandler::OnCommand
(
    ITFSNode *          pNode, 
    long                nCommandId, 
    DATA_OBJECT_TYPES   type, 
    LPDATAOBJECT        pDataObject, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;

    switch (nCommandId)
    {
        case IDS_CONFIGURE_PROVIDER:
            OnConfigureProvider(pNode);
            break;

        default:
            break;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    CProviderHandler::Command
        Handles context menu commands for virtual listbox items
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CProviderHandler::Command
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    int             nCommandID,
    LPDATAOBJECT    pDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;
    SPITFSNode spNode;

    m_spResultNodeMgr->FindNode(cookie, &spNode);

    switch (nCommandID)
    {
        case IDS_EDIT_USERS:
            OnEditUsers(pComponent,  pDataObject, cookie);
            break;
        
        case IDS_VIEW_LINES:
            m_deviceType = DEVICE_LINE;

            // clear the listbox then set the size
            SetColumnInfo();
            UpdateColumnText(pComponent);
            UpdateListboxCount(spNode, TRUE);
            UpdateListboxCount(spNode);
            break;

        case IDS_VIEW_PHONES:
            m_deviceType = DEVICE_PHONE;

            // clear the listbox then set the size
            SetColumnInfo();
            UpdateColumnText(pComponent);
            UpdateListboxCount(spNode, TRUE);
            UpdateListboxCount(spNode);
            break;

        default:
            break;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    CProviderHandler::HasPropertyPages
        Implementation of ITFSNodeHandler::HasPropertyPages
    NOTE: the root node handler has to over-ride this function to 
    handle the snapin manager property page (wizard) case!!!
    
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CProviderHandler::HasPropertyPages
(
    ITFSNode *          pNode,
    LPDATAOBJECT        pDataObject, 
    DATA_OBJECT_TYPES   type, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    return hrFalse;
}

/*---------------------------------------------------------------------------
    CProviderHandler::CreatePropertyPages
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CProviderHandler::CreatePropertyPages
(
    ITFSNode *              pNode,
    LPPROPERTYSHEETCALLBACK lpProvider,
    LPDATAOBJECT            pDataObject, 
    LONG_PTR                handle, 
    DWORD                   dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    DWORD       dwError;
    DWORD       dwDynDnsFlags;

    //
    // Create the property page
    //
    SPIComponentData spComponentData;
    m_spNodeMgr->GetComponentData(&spComponentData);

    //CServerProperties * pServerProp = new CServerProperties(pNode, spComponentData, m_spTFSCompData, NULL);

    //
    // Object gets deleted when the page is destroyed
    //
    Assert(lpProvider != NULL);

    //return pServerProp->CreateModelessSheet(lpProvider, handle);
    return hrFalse;
}

/*---------------------------------------------------------------------------
    CProviderHandler::OnPropertyChange
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CProviderHandler::OnPropertyChange
(   
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataobject, 
    DWORD           dwType, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    //CServerProperties * pServerProp = reinterpret_cast<CServerProperties *>(lParam);

    LONG_PTR changeMask = 0;

    // tell the property page to do whatever now that we are back on the
    // main thread
    //pServerProp->OnPropertyChange(TRUE, &changeMask);

    //pServerProp->AcknowledgeNotify();

    if (changeMask)
        pNode->ChangeNode(changeMask);

    return hrOK;
}

/*---------------------------------------------------------------------------
    CProviderHandler::OnExpand
        Handles enumeration of a scope item
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CProviderHandler::OnExpand
(
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg, 
    LPARAM          param
)
{
    HRESULT hr = hrOK;

    if (m_bExpanded) 
        return hr;
    
    // do the default handling
    CORg (CTapiHandler::OnExpand(pNode, pDataObject, dwType, arg, param));

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    CProviderHandler::OnResultSelect
        Handles the MMCN_SELECT notifcation 
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CProviderHandler::OnResultSelect
(
    ITFSComponent * pComponent, 
    LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie,
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT         hr = hrOK;
    SPINTERNAL      spInternal;
    SPIConsole      spConsole;
    SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;
    BOOL            bStates[ARRAYLEN(g_ConsoleVerbs)];
    int             i;
    LONG_PTR        dwNodeType;
    BOOL            fSelect = HIWORD(arg);

    if (!fSelect)
        return hr;

    if (m_spTapiInfo)
    {
        // Get the current count
        i = m_spTapiInfo->GetDeviceCount(m_deviceType, m_dwProviderID);

        // now notify the virtual listbox
        CORg ( m_spNodeMgr->GetConsole(&spConsole) );
        CORg ( spConsole->UpdateAllViews(pDataObject, i, RESULT_PANE_SET_VIRTUAL_LB_SIZE) ); 
    }

    // now update the verbs...
    spInternal = ExtractInternalFormat(pDataObject);
    Assert(spInternal);

    // virtual listbox notifications come to the handler of the node that is selected.
    // check to see if this notification is for a virtual listbox item or the active
    // registrations node itself.
    CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

    if (spInternal->HasVirtualIndex())
    {
        // we gotta do special stuff for the virtual index items
        dwNodeType = TAPISNAP_DEVICE;
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
    }
    else
    {
        // enable/disable delete depending if the provider supports it
        CORg (m_spNodeMgr->FindNode(cookie, &spNode));
        dwNodeType = spNode->GetData(TFS_DATA_TYPE);

        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);

        //Per XZhang, hide "delete" context menu of provider nodes on remote machines
        if (!m_spTapiInfo->IsLocalMachine() || !m_spTapiInfo->IsAdmin() || (m_dwFlags & AVAILABLEPROVIDER_REMOVABLE) == 0)
        {
            bStates[MMC_VERB_DELETE & 0x000F] = FALSE;
        }
    }

    EnableVerbs(spConsoleVerb, g_ConsoleVerbStates[dwNodeType], bStates);

COM_PROTECT_ERROR_LABEL;
    return hr;
}

/*!--------------------------------------------------------------------------
    CProviderHandler::OnDelete
        The base handler calls this when MMC sends a MMCN_DELETE for a 
        scope pane item.  We just call our delete command handler.
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CProviderHandler::OnDelete
(
    ITFSNode *  pNode, 
    LPARAM      arg, 
    LPARAM      lParam
)
{
    return OnDelete(pNode);
}

/*---------------------------------------------------------------------------
    CProviderHandler::OnGetResultViewType
        Return the result view that this node is going to support
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CProviderHandler::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE            cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    if (cookie != NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_OWNERDATALIST | MMC_VIEW_OPTIONS_MULTISELECT;
    }

    return S_FALSE;
}

/*---------------------------------------------------------------------------
    CProviderHandler::GetVirtualImage
        Returns the image index for virtual listbox items
    Author: EricDav
 ---------------------------------------------------------------------------*/
int 
CProviderHandler::GetVirtualImage
(
    int     nIndex
)
{
    return ICON_IDX_MACHINE;
}

/*---------------------------------------------------------------------------
    CProviderHandler::GetVirtualString
        returns a pointer to the string for virtual listbox items
    Author: EricDav
 ---------------------------------------------------------------------------*/
LPCWSTR 
CProviderHandler::GetVirtualString
(
    int     nIndex,
    int     nCol
)
{
    // check our cache to see if we have this one.
    //TapiStrRecord * ptsr = m_RecList.FindItem(nIndex);
    CString         strStatus;
    TapiStrRecord   tsr;

    if (!m_mapRecords.Lookup(nIndex, tsr))
    {
        Trace1("CProviderHandler::GetVirtualString - Index %d not in TAPI string cache\n", nIndex);
        
        // doesn't exist in our cache, need to add this one.
        if (!BuildTapiStrRecord(nIndex, tsr))
        {
            Trace0("CProviderHandler::BuildTapiStrRecord failed!\n");
        }

        //m_RecList.AddTail(ptsr);
        m_mapRecords.SetAt(nIndex, tsr);
    }
    
    if (!m_mapStatus.Lookup(nIndex, strStatus))
    {
        Trace1("CProviderHandler::GetVirtualString - Index %d not in status cache\n", nIndex);

        if (!BuildStatus(nIndex, strStatus))
        {
            Trace0("CProviderHandler::BuildStatus failed!\n");
        }
    }

    switch (nCol)
    {
        case 0:
            return tsr.strName;
            break;

        case 1:
            return tsr.strUsers;
            break;

        case 2:
            return strStatus;
            break;

        default:
            Panic0("CProviderHandler::GetVirtualString - Unknown column!\n");
            break;
    }

    return NULL;
}

/*---------------------------------------------------------------------------
    CProviderHandler::CacheHint
        MMC tells us which items it will need before it requests things
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CProviderHandler::CacheHint
(
    int nStartIndex, 
    int nEndIndex
)
{
    HRESULT hr = hrOK;;

    Trace2("CacheHint - Start %d, End %d\n", nStartIndex, nEndIndex);
    
    // the virtual listbox stores no strings and gives us cache hints for
    // everything, including individual querries.  To avoid thrashing, only
    // clear our the cache if the request is large.
    if ((nEndIndex - nStartIndex) > 2)
    {
        m_mapRecords.RemoveAll();
    }

    TapiStrRecord   tsr;
    CString         strStatus;

    for (int i = nStartIndex; i <= nEndIndex; i++)
    {
        if (!BuildTapiStrRecord(i, tsr))
            continue; 

        m_mapRecords.SetAt(i, tsr);

        // only refresh status records if they don't exist.  Only the auto refresh
        // background thread cleans out the map...
        if (!m_mapStatus.Lookup(i, strStatus))
        {
            BuildStatus(i, strStatus);
            m_mapStatus.SetAt(i, strStatus);
        }
    }

    return hr;
}

/*---------------------------------------------------------------------------
    CProviderHandler::SortItems
        We are responsible for sorting of virtual listbox items
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CProviderHandler::SortItems
(
    int     nColumn, 
    DWORD   dwSortOptions, 
    LPARAM    lUserParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    BEGIN_WAIT_CURSOR

    switch (nColumn)
    {
        case 0:
            m_spTapiInfo->SortDeviceInfo(m_deviceType, m_dwProviderID, INDEX_TYPE_NAME, dwSortOptions);
            break;
        case 1:
            m_spTapiInfo->SortDeviceInfo(m_deviceType, m_dwProviderID, INDEX_TYPE_USERS, dwSortOptions);
            break;
//      case 2:
//          m_spTapiInfo->SortDeviceInfo(m_deviceType, m_dwProviderID, INDEX_TYPE_STATUS, dwSortOptions);
//          break;
    }
    END_WAIT_CURSOR

    return hrOK;
}

/*!--------------------------------------------------------------------------
    CProviderHandler::OnResultUpdateView
        Implementation of ITFSResultHandler::OnResultUpdateView
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CProviderHandler::OnResultUpdateView
(
    ITFSComponent *pComponent, 
    LPDATAOBJECT  pDataObject, 
    LPARAM        data, 
    LONG_PTR      hint
)
{
    HRESULT    hr = hrOK;
    SPITFSNode spSelectedNode;

    pComponent->GetSelectedNode(&spSelectedNode);
    if (spSelectedNode == NULL)
        return S_OK; // no selection for our IComponentData

    if ( hint == TAPISNAP_UPDATE_STATUS )
    {
        SPINTERNAL spInternal = ExtractInternalFormat(pDataObject);
        ITFSNode * pNode = reinterpret_cast<ITFSNode *>(spInternal->m_cookie);
        SPITFSNode spSelectedNode;

        pComponent->GetSelectedNode(&spSelectedNode);

        if (pNode == spSelectedNode)
        {       
            Trace1("CProviderHandler::OnResultUpdateView - Provider %x is selected, invalidating listbox.\n", m_dwProviderID);
            
            // if we are the selected node, then we need to update
            SPIResultData spResultData;

            CORg (pComponent->GetResultData(&spResultData));
            CORg (spResultData->SetItemCount((int) data, MMCLV_UPDATE_NOSCROLL));
        }
    }
    else
    {
        // we don't handle this message, let the base class do it.
        return CTapiHandler::OnResultUpdateView(pComponent, pDataObject, data, hint);
    }

COM_PROTECT_ERROR_LABEL;

    return hr;
}

/*!--------------------------------------------------------------------------
    CProviderHandler::OnResultItemClkOrDblClk
        The user had double clicked on a line/phone.  Invoke the edit users.
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CProviderHandler::OnResultItemClkOrDblClk
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam, 
    BOOL            bDoubleClick
)
{
    HRESULT hr = hrOK;

    if (bDoubleClick)
    {
        // first check to see if we are selected
        SPITFSNode spSelectedNode;
        pComponent->GetSelectedNode(&spSelectedNode);

        SPITFSNode spNode;
        m_spResultNodeMgr->FindNode(cookie, &spNode);

        if (spSelectedNode == spNode)
        {
            CTapiConfigInfo     tapiConfigInfo;

            m_spTapiInfo->GetConfigInfo(&tapiConfigInfo);

            // check to see if they have access rights
            if (m_spTapiInfo->IsAdmin() && 
                tapiConfigInfo.m_dwFlags & TAPISERVERCONFIGFLAGS_ISSERVER)
            {
                // double click on a line/phone entry.  
                SPIDataObject spDataObject;

                CORg (pComponent->GetCurrentDataObject(&spDataObject));

                OnEditUsers(pComponent, spDataObject, cookie);
            }
        }
        else
        {
            // we are being double clicked to open 
            // let the base class handle this
            return CTapiHandler::OnResultItemClkOrDblClk(pComponent, cookie, arg, lParam, bDoubleClick);
        }
    }

Error:
    return S_OK;
}

/*!--------------------------------------------------------------------------
    CProviderHandler::LoadColumns
        Set the correct column header and then call the base class
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CProviderHandler::LoadColumns
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    SetColumnInfo();

    return CTapiHandler::LoadColumns(pComponent, cookie, arg, lParam);
}

/*---------------------------------------------------------------------------
    Command handlers
 ---------------------------------------------------------------------------*/

 /*---------------------------------------------------------------------------
    CProviderHandler::OnConfigureProvider
        Configures a service provider
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CProviderHandler::OnConfigureProvider
(
    ITFSNode * pNode
)
{
    HRESULT hr = hrOK;

    Assert(m_spTapiInfo);

    hr = m_spTapiInfo->ConfigureProvider(m_dwProviderID, NULL);
    if (FAILED(hr))
    {
        ::TapiMessageBox(WIN32_FROM_HRESULT(hr));
    }

    return hr;
}

 /*---------------------------------------------------------------------------
    CProviderHandler::OnDelete
        Removes a service provider
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CProviderHandler::OnDelete
(
    ITFSNode * pNode
)
{
    HRESULT         hr = hrOK;
    SPITFSNode      spNode;
    CString         strMessage;

    pNode->GetParent(&spNode);

    CTapiServer * pServer = GETHANDLER(CTapiServer, spNode);

    // Ask the user to make sure
    AfxFormatString2(strMessage, IDS_WARN_PROVIDER_DELETE, m_strProviderName, pServer->GetName());
    
    if (AfxMessageBox(strMessage, MB_YESNO) == IDYES)
    {
        Assert(m_spTapiInfo);

        hr = m_spTapiInfo->RemoveProvider(m_dwProviderID, NULL);
        if (FAILED(hr))
        {
            ::TapiMessageBox(WIN32_FROM_HRESULT(hr));
        }
        else
        {
            // remove from the UI
            SPITFSNode spParent;
            CORg (pNode->GetParent(&spParent));
        
            CORg (spParent->RemoveChild(pNode));

            // update the list of installed providers
            CORg (m_spTapiInfo->EnumProviders());
        }
    }

Error:
    return hr;
}

 /*---------------------------------------------------------------------------
    CProviderHandler::OnEditUsers
        Allows different users to be assigned to a device
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CProviderHandler::OnEditUsers
(
    ITFSComponent * pComponent, 
    LPDATAOBJECT    pDataObject,
    MMC_COOKIE      cookie
)
{
    SPITFSNode  spNode;
    SPINTERNAL  spInternal;
    int         nIndex;
    DWORD       dwFlags;
    CTapiDevice tapiDevice;
    HRESULT     hr = hrOK;

    spInternal = ExtractInternalFormat(pDataObject);

    // virtual listbox notifications come to the handler of the node that is selected.
    // assert that this notification is for a virtual listbox item 
    Assert(spInternal);
    if (!spInternal->HasVirtualIndex() || m_deviceType == DEVICE_PHONE)
        return hr;

    nIndex = spInternal->GetVirtualIndex();
    Trace1("OnEditUsers - edit users for index %d\n", nIndex);
    
    m_spTapiInfo->GetDeviceInfo(m_deviceType, &tapiDevice, m_dwProviderID, nIndex);

    //  Check to see if this device can be remoted
    hr = m_spTapiInfo->GetDeviceFlags (
        tapiDevice.m_dwProviderID,
        tapiDevice.m_dwPermanentID,
        &dwFlags
        );
    if (hr || (dwFlags & LINEDEVCAPFLAGS_LOCAL))
    {
        return hr;
    }
    
    CEditUsers  dlgEditUsers(&tapiDevice);
    
    if (dlgEditUsers.DoModal() == IDOK)
    {
        if (dlgEditUsers.IsDirty())
        {
            hr = m_spTapiInfo->SetDeviceInfo(m_deviceType, &tapiDevice);
            if (FAILED(hr))
            {
                TapiMessageBox(WIN32_FROM_HRESULT(hr));
            }
            else
            {
                pComponent->GetSelectedNode(&spNode);
            
                // clear the listbox then set the size
                UpdateListboxCount(spNode, TRUE);
                UpdateListboxCount(spNode);
            }
        }
    }

    return hr;
}

/*---------------------------------------------------------------------------
    CProviderHandler::UpdateStatus
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CProviderHandler::UpdateStatus
(
    ITFSNode * pNode
)
{
    HRESULT             hr = hrOK;
    SPIComponentData    spComponentData;
    SPIConsole          spConsole;
    IDataObject *       pDataObject;
    SPIDataObject       spDataObject;
    int                 i = 0;
    
    Trace1("CProviderHandler::UpdateStatus - Updating status for provider %x\n", m_dwProviderID);
    
    // clear our status strings
    m_mapStatus.RemoveAll();

    // force the listbox to update.  We do this by setting the count and 
    // telling it to invalidate the data
    CORg(m_spNodeMgr->GetComponentData(&spComponentData));
    CORg(m_spNodeMgr->GetConsole(&spConsole));
    
    // grab a data object to use
    CORg(spComponentData->QueryDataObject((MMC_COOKIE) pNode, CCT_RESULT, &pDataObject) );
    spDataObject = pDataObject;

    i = m_spTapiInfo->GetDeviceCount(m_deviceType, m_dwProviderID);
    CORg(spConsole->UpdateAllViews(pDataObject, i, TAPISNAP_UPDATE_STATUS));

COM_PROTECT_ERROR_LABEL;

    return hr;
}

/*---------------------------------------------------------------------------
    Misc functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CProviderHandler::BuildDisplayName
        Builds the string that goes in the UI for this server
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CProviderHandler::BuildDisplayName
(
    CString * pstrDisplayName
)
{
    if (pstrDisplayName)
    {
        CString strName;

        *pstrDisplayName = GetDisplayName();
    }

    return hrOK;
}

/*---------------------------------------------------------------------------
    CProviderHandler::InitData
        Initializes data for this node
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CProviderHandler::InitData
(
    CTapiProvider & tapiProvider,
    ITapiInfo *     pTapiInfo
)
{
    m_strProviderName = tapiProvider.m_strName;
    m_dwProviderID = tapiProvider.m_dwProviderID;
    m_dwFlags = tapiProvider.m_dwFlags;

    m_spTapiInfo.Set(pTapiInfo);

    SetDisplayName(m_strProviderName);

    return hrOK;
}

/*---------------------------------------------------------------------------
    CProviderHandler::BuildTapiStrRecord
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
CProviderHandler::BuildTapiStrRecord(int nIndex, TapiStrRecord & tsr)
{
    HRESULT             hr = hrOK;
    CTapiDevice         tapiDevice;
    CString             strTemp;
    int                 i;

    if (!m_spTapiInfo)
        return FALSE;

    COM_PROTECT_TRY
    {
        CORg (m_spTapiInfo->GetDeviceInfo(m_deviceType, &tapiDevice, m_dwProviderID, nIndex));

        // set the index for this record
        //tsr.nIndex = nIndex;

        // name
        tsr.strName = tapiDevice.m_strName;

        // users
        tsr.strUsers.Empty();
        for (i = 0; i < tapiDevice.m_arrayUsers.GetSize(); i++)
        {
            if (!tapiDevice.m_arrayUsers[i].m_strFullName.IsEmpty())
            {
                tsr.strUsers += tapiDevice.m_arrayUsers[i].m_strFullName;
            }
            else
            {
                tsr.strUsers += tapiDevice.m_arrayUsers[i].m_strName;
            }

            if ((i + 1) != tapiDevice.m_arrayUsers.GetSize())
                tsr.strUsers += _T(", ");
        }
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return SUCCEEDED(hr);
}

/*---------------------------------------------------------------------------
    CProviderHandler::BuildStatus
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
CProviderHandler::BuildStatus(int nIndex, CString & strStatus)
{
    HRESULT hr = hrOK;

    // status
    hr = m_spTapiInfo->GetDeviceStatus(m_deviceType, &strStatus, m_dwProviderID, nIndex, NULL);
    
    if (strStatus.IsEmpty())
        strStatus.LoadString(IDS_NO_STATUS);

    return SUCCEEDED(hr);
}

/*---------------------------------------------------------------------------
    CProviderHandler::UpdateListboxCount
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CProviderHandler::UpdateListboxCount(ITFSNode * pNode, BOOL bClear)
{
    HRESULT             hr = hrOK;
    SPIComponentData    spCompData;
    SPIConsole          spConsole;
    IDataObject*        pDataObject;
    SPIDataObject       spDataObject;
    LONG_PTR            command;               
    int i;

    COM_PROTECT_TRY
    {
        if (!m_spTapiInfo || bClear)
        {
            command = RESULT_PANE_CLEAR_VIRTUAL_LB;
            i = 0;
        }
        else
        {
            command = RESULT_PANE_SET_VIRTUAL_LB_SIZE;
            i = m_spTapiInfo->GetDeviceCount(m_deviceType, m_dwProviderID);
        }

        m_spNodeMgr->GetComponentData(&spCompData);

        CORg ( spCompData->QueryDataObject((MMC_COOKIE) pNode, CCT_RESULT, &pDataObject) );
        spDataObject = pDataObject;

        CORg ( m_spNodeMgr->GetConsole(&spConsole) );
    
        CORg ( spConsole->UpdateAllViews(spDataObject, i, command) ); 

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}

/*---------------------------------------------------------------------------
    CProviderHandler::SetColumnInfo
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
void
CProviderHandler::SetColumnInfo()
{
    // set the correct column header
    if (m_deviceType == DEVICE_LINE)
    {
        aColumns[TAPISNAP_PROVIDER][0] = IDS_LINE_NAME;
    }
    else
    {
        aColumns[TAPISNAP_PROVIDER][0] = IDS_PHONE_NAME;
    }
}

/*---------------------------------------------------------------------------
    CProviderHandler::UpdateColumnText
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CProviderHandler::UpdateColumnText(ITFSComponent * pComponent)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    SPIHeaderCtrl spHeaderCtrl;
    pComponent->GetHeaderCtrl(&spHeaderCtrl);

    CString str;
    int i = 0;

    while (TRUE)
    {
        if ( 0 == aColumns[TAPISNAP_PROVIDER][i] )
            break;
        
        str.LoadString(aColumns[TAPISNAP_PROVIDER][i]);
        
        spHeaderCtrl->SetColumnText(i, const_cast<LPTSTR>((LPCWSTR)str));

        i++;
    }

    return hrOK;

}

/*---------------------------------------------------------------------------
    Background thread functionality
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CProviderHandler::OnCreateQuery
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
ITFSQueryObject* 
CProviderHandler::OnCreateQuery(ITFSNode * pNode)
{
    CProviderHandlerQueryObj* pQuery = 
        new CProviderHandlerQueryObj(m_spTFSCompData, m_spNodeMgr);
    
    //pQuery->m_strServer = NULL;
    
    return pQuery;
}

/*---------------------------------------------------------------------------
    CProviderHandlerQueryObj::Execute()
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CProviderHandlerQueryObj::Execute()
{
    return hrFalse;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tapisnap.rc
//
#define IDS_SNAPIN_DESC                 1
#define IDS_NAME                        2
#define IDI_TAPI_SNAPIN                 2
#define IDS_SIZE                        3
#define IDS_TYPE                        4
#define IDS_ROOT_NODENAME               5
#define IDS_ROOT_NAME                   6
#define IDS_SERVER_NAME                 7
#define IDS_STATUS                      8
#define IDS_USERS                       11
#define IDS_LINE_NAME                   12
#define IDS_PROVIDER_NODENAME           13
#define IDS_TELEPHONY                   14
#define IDS_PHONE_NAME                  15
#define IDS_SNAPIN_NAME                 30
#define IDS_SNAPIN_EXTENSION            31
#define IDS_ABOUT_DESCRIPTION           100
#define IDS_ABOUT_PROVIDER              101
#define IDS_ABOUT_VERSION               102
#define IDP_SERVER_REFRESH              140
#define IDB_16x16                       202
#define IDB_32x32                       203
#define IDB_ROOT_SMALL                  216
#define IDB_ROOT_LARGE                  217
#define IDD_EDIT_USERS                  231
#define IDP_SERVER_SETUP                232
#define IDD_DRIVER_SETUP                233
#define IDD_ADD_DRIVER                  234
#define IDI_ICON06                      283
#define IDI_ICON07                      284
#define IDI_ICON05                      296
#define IDI_ICON01                      305
#define IDI_ICON02                      306
#define IDI_ICON03                      307
#define IDI_ICON04                      308
#define IDC_BUTTON_ADD_ADMIN            354
#define IDC_BUTTON_REMOVE_ADMIN         355
#define IDC_LIST_USERS                  356
#define IDC_EDIT_NAME                   357
#define IDC_EDIT_PASSWORD               358
#define IDC_CHECK_ENABLE_STATS          360
#define IDC_EDIT_HOURS                  361
#define IDC_EDIT_MINUTES                362
#define IDC_SPIN_HOURS                  364
#define IDC_STATIC_MINUTES              365
#define IDC_SPIN_MINUTES                366
#define IDC_CHECK_ENABLE_SERVER         367
#define IDC_LIST_ADMINS                 368
#define IDC_BUTTON_CHOOSE_USER          371
#define IDC_STATIC_ADMINS               372
#define IDC_STATIC_ACCOUNT              373
#define IDC_STATIC_USERNAME             374
#define IDC_STATIC_PASSWORD             375
#define IDC_STATIC_NOTE                 376
#define IDC_STATIC_LISTBOX              377
#define IDI_TELEPHONY                   378
#define IDC_LIST_DRIVERS                380
#define IDC_BUTTON_EDIT_DRIVER          381
#define IDC_LIST_NEW_DRIVERS            382
#define IDC_BUTTON_ADD_DRIVER           384
#define IDC_BUTTON_REMOVE_DRIVER        386
#define IDC_BUTTON_ADD_USER             387
#define IDC_BUTTON_REMOVE_USER          388
#define IDC_BUTTON_ADD_NEW_DRIVER       389
#define IDC_STATIC_ACCOUNT_INFO         390
#define IDS_ADD_MACHINE                 1000
#define IDS_EDIT_USERS                  1001
#define IDS_CONFIGURE_PROVIDER          1002
#define IDS_ENABLE_SERVER               1003
#define IDS_ADD_PROVIDER                1004
#define IDS_VIEW_TASKPAD                1005
#define IDS_VIEW_LINES                  1006
#define IDS_VIEW_PHONES                 1007
#define IDS_WARN_SERVER_DELETE          2000
#define IDS_WARN_PROVIDER_DELETE        2001
#define IDS_ROOT_TASK_TITLE             3000
#define IDS_ROOT_TASK_GETTING_STARTED   3002
#define IDS_ROOT_TASK_GETTING_STARTED_HELP 3003
#define IDS_ROOT_TASK_MANAGE_TAPI       3004
#define IDS_ROOT_TASK_MANAGE_TAPI_HELP  3005
#define IDS_ROOT_TASK_ADD_SERVER        3006
#define IDS_ROOT_TASK_ADD_SERVER_HELP   3007
#define IDS_ROOT_TASK_LAUNCH_TAPI       3008
#define IDS_ROOT_TASK_LAUNCH_TAPI_HELP  3009
#define IDS_ERR_MESSAGE_GENERIC         5001
#define IDS_ERR_INVALID_INTEGER         5002
#define IDS_ERR_AUTO_REFRESH_ZERO       5003
#define IDS_ERR_SERVER_IN_LIST          5004
#define IDS_ERR_OLD_CONSOLE_FILE        5005
#define IDS_NO_STATUS                   5006
#define IDS_ERR_SERVER_NODE             5007
#define IDS_ACCOUNT_CHANGE_RESTART      5008
#define IDS_SERVICE_DESCRIPTION         5009
#define IDS_ERR_SERVICE_NOT_STOPPED     5010
#define IDS_LOCAL_SYSTEM_ACCOUNT        5011
#define IDS_ERR_USER_NOT_ADMIN          5012
#define IDS_ADMIN_ALREADY_IN_LIST       5013
#define IDS_USER_ALREADY_AUTHORIZED     5014
#define IDS_ACCOUNT_CHANGE_START        5015
#define IDS_ERR_SERVICE_NOT_STARTED     5016
#define IDS_LSAERR_READ_FAILED          5017
#define IDS_LSAERR_WRITE_FAILED         5018
#define IDS_NETWORK_SERVICE_ACCOUNT     5019
#define IDS_ERR_BASE                    63000
#define IDS_ERR_TAPI_DOWN               63001
#define IDS_ERR_RPC_NO_ENTRY            63022
#define IDS_MESG_MAX                    65000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        236
#define _APS_NEXT_COMMAND_VALUE         32807
#define _APS_NEXT_CONTROL_VALUE         391
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\nodes.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	nodes.h
		This file contains all of the prototypes for the TAPI
		objects that appear in the result pane of the MMC framework.
		The objects are:

    FILE HISTORY:
        
*/

#ifndef _TAPINODE_H
#define _TAPINODE_H

#ifndef _TAPIHAND_H
#include "tapihand.h"
#endif


/*---------------------------------------------------------------------------
	Class:	CTapiLineHandler
 ---------------------------------------------------------------------------*/
class CTapiLineHandler : public CTapiHandler
{
// Constructor/destructor
public:
	CTapiLineHandler(ITFSComponentData * pTFSCompData);

// Interface
public:
	// Result handler functionality
    OVERRIDE_ResultHandler_GetString();
    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();

// Implementation
public:
	// CTapiHandler overrides
	virtual HRESULT InitializeNode(ITFSNode * pNode);

private:
    HRESULT OnEditUsers(ITFSComponent * pComponent, MMC_COOKIE cookie);

// Attributes
private:
	CString			m_strName;
	CString			m_strUsers;
	CString			m_strStatus;
};


#endif _TAPINODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\nodes.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	nodes.h

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "nodes.h"

// user editor
#include "EditUser.h"

/*---------------------------------------------------------------------------
	Class CTapiLine implementation
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	Function
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
CTapiLineHandler::CTapiLineHandler
(
	ITFSComponentData * pTFSCompData
) : CTapiHandler(pTFSCompData)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
}

/*!--------------------------------------------------------------------------
	CDhcpAllocationRange::InitializeNode
		Initializes node specific data
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CTapiLineHandler::InitializeNode
(
	ITFSNode * pNode
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	CString strTemp;
	SetDisplayName(strTemp);

	// Make the node immediately visible
	pNode->SetVisibilityState(TFS_VIS_SHOW);
	pNode->SetData(TFS_DATA_COOKIE, pNode);
	pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_MACHINE);
	pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_MACHINE);
	pNode->SetData(TFS_DATA_USER, this);
    pNode->SetData(TFS_DATA_TYPE, TAPISNAP_LINE);

	return hrOK;
}

/*!--------------------------------------------------------------------------
	Function
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) 
CTapiLineHandler::GetString
(
	ITFSComponent * pComponent,	
	MMC_COOKIE		cookie,
	int				nCol
)
{
	switch (nCol)
	{
		case 0:
			return GetDisplayName();

		case 1:
			return (LPCWSTR)m_strUsers;

		case 2:
			return (LPCWSTR)m_strStatus;
	}
	
	return NULL;
}

/*!--------------------------------------------------------------------------
	CTapiLineHandler::AddMenuItems
		Implementation of ITFSResultHandler::AddMenuItems
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CTapiLineHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
	MMC_COOKIE				cookie,
	LPDATAOBJECT			pDataObject, 
	LPCONTEXTMENUCALLBACK	pContextMenuCallback, 
	long *					pInsertionAllowed
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr;

    CString strMenuItem;

    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
    {
        strMenuItem.LoadString(IDS_EDIT_USERS);
        hr = LoadAndAddMenuItem( pContextMenuCallback, 
							     strMenuItem, 
							     IDS_EDIT_USERS,
							     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
							     0 );
	    ASSERT( SUCCEEDED(hr) );
    }

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CTapiLineHandler::Command
		Implementation of ITFSResultHandler::Command
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CTapiLineHandler::Command
(
    ITFSComponent * pComponent, 
	MMC_COOKIE		cookie, 
	int				nCommandID,
	LPDATAOBJECT	pDataObject
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    switch (nCommandID)
	{
        case IDS_EDIT_USERS:
            OnEditUsers(pComponent, cookie);
            break;

		default:
			break;
	}
    
	return hrOK;
}

HRESULT
CTapiLineHandler::OnEditUsers(ITFSComponent * pComponent, MMC_COOKIE cookie)
{
/*
    CEditUsers dlgEditUsers;

    if (dlgEditUsers.DoModal() == IDOK)
    {
    }
*/
    return hrOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\stdafx.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	stdafx.cpp	
		precompiled header file

	FILE HISTORY:
        
*/

#include "stdafx.h"
#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\root.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    root.cpp
        
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "root.h"
#include "server.h"
#include "tregkey.h"
#include "service.h"
#include "ncglobal.h"  // network console global defines

unsigned int g_cfMachineName = RegisterClipboardFormat(L"MMC_SNAPIN_MACHINE_NAME");

LPOLESTR g_RootTaskOverBitmaps[ROOT_TASK_MAX] = 
{
    L"/wlcmroll.bmp",
    L"/srvrroll.bmp",
    L"/toolroll.bmp",
    L"/toolroll.bmp",
};

LPOLESTR g_RootTaskOffBitmaps[ROOT_TASK_MAX] = 
{
    L"/wlcm.bmp",
    L"/srvr.bmp",
    L"/tool.bmp",
    L"/tool.bmp",
};

UINT g_RootTaskText[ROOT_TASK_MAX] = 
{
    IDS_ROOT_TASK_GETTING_STARTED,
    IDS_ROOT_TASK_ADD_SERVER,
    IDS_ROOT_TASK_MANAGE_TAPI,  // for the extension case
    IDS_ROOT_TASK_LAUNCH_TAPI,  // for the extension case
};

UINT g_RootTaskHelp[ROOT_TASK_MAX] = 
{
    IDS_ROOT_TASK_GETTING_STARTED_HELP,
    IDS_ROOT_TASK_ADD_SERVER_HELP,
    IDS_ROOT_TASK_MANAGE_TAPI_HELP, // for the extension case
    IDS_ROOT_TASK_LAUNCH_TAPI_HELP, // for the extension case
};

HRESULT
CRootTasks::Init(BOOL bExtension, BOOL bThisMachine, BOOL bNetServices)
{
    HRESULT     hr = hrOK;
    MMC_TASK    mmcTask;
    int         nPos = 0;
    int         nFinish = ROOT_TASK_MAX - 2;

    m_arrayMouseOverBitmaps.SetSize(ROOT_TASK_MAX);
    m_arrayMouseOffBitmaps.SetSize(ROOT_TASK_MAX);
    m_arrayTaskText.SetSize(ROOT_TASK_MAX);
    m_arrayTaskHelp.SetSize(ROOT_TASK_MAX);

    // setup path for reuse
    OLECHAR szBuffer[MAX_PATH*2];    // that should be enough
    lstrcpy (szBuffer, L"res://");
    ::GetModuleFileName(_Module.GetModuleInstance(), szBuffer + lstrlen(szBuffer), MAX_PATH);
    OLECHAR * temp = szBuffer + lstrlen(szBuffer);

    if (bExtension && bThisMachine)
    {
        nPos = ROOT_TASK_MAX - 2;
        nFinish = ROOT_TASK_MAX - 1;
    }
    else
    if (bExtension && bNetServices)
    {
        nPos = ROOT_TASK_MAX - 1;
        nFinish = ROOT_TASK_MAX;
    }

    for (nPos; nPos < nFinish; nPos++)
    {
        m_arrayMouseOverBitmaps[nPos] = szBuffer;
        m_arrayMouseOffBitmaps[nPos] = szBuffer;
        m_arrayMouseOverBitmaps[nPos] += g_RootTaskOverBitmaps[nPos];
        m_arrayMouseOffBitmaps[nPos] += g_RootTaskOffBitmaps[nPos];

        m_arrayTaskText[nPos].LoadString(g_RootTaskText[nPos]);
        m_arrayTaskHelp[nPos].LoadString(g_RootTaskHelp[nPos]);

        AddTask((LPTSTR) (LPCTSTR) m_arrayMouseOverBitmaps[nPos], 
                (LPTSTR) (LPCTSTR) m_arrayMouseOffBitmaps[nPos], 
                (LPTSTR) (LPCTSTR) m_arrayTaskText[nPos], 
                (LPTSTR) (LPCTSTR) m_arrayTaskHelp[nPos], 
                MMC_ACTION_ID, 
                nPos);
    }
    
    return hr;
}



/*---------------------------------------------------------------------------
    CTapiRootHandler::CTapiRootHandler
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
CTapiRootHandler::CTapiRootHandler(ITFSComponentData *pCompData) : CTapiHandler(pCompData)
{
    //m_bTaskPadView = FUseTaskpadsByDefault(NULL);
    m_bTaskPadView = FALSE;
}

/*!--------------------------------------------------------------------------
    CTapiRootHandler::InitializeNode
        Initializes node specific data
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CTapiRootHandler::InitializeNode
(
    ITFSNode * pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
    CString strTemp;
    strTemp.LoadString(IDS_ROOT_NODENAME);

    SetDisplayName(strTemp);

    // Make the node immediately visible
    //pNode->SetVisibilityState(TFS_VIS_SHOW);
    pNode->SetData(TFS_DATA_COOKIE, 0);
    pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_PRODUCT);
    pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_PRODUCT);
    pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, TAPISNAP_ROOT);

    SetColumnStringIDs(&aColumns[TAPISNAP_ROOT][0]);
    SetColumnWidths(&aColumnWidths[TAPISNAP_ROOT][0]);

    m_strTaskpadTitle.LoadString(IDS_ROOT_TASK_TITLE);

    return hrOK;
}

/*---------------------------------------------------------------------------
    Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
    CTapiRootHandler::GetString
        Implementation of ITFSNodeHandler::GetString
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) 
CTapiRootHandler::GetString
(
    ITFSNode *  pNode, 
    int         nCol
)
{
    if (nCol == 0 || nCol == -1)
        return GetDisplayName();
    else
        return NULL;
}

HRESULT
CTapiRootHandler::SetGroupName(LPCTSTR pszGroupName)
{
    CString strSnapinBaseName;
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        strSnapinBaseName.LoadString(IDS_ROOT_NODENAME);
    }
    
    CString szBuf;
    szBuf.Format(_T("%s [%s]"), (LPCWSTR)strSnapinBaseName, (LPCWSTR)pszGroupName);
    
    SetDisplayName(szBuf);

    return hrOK;
}

HRESULT
CTapiRootHandler::GetGroupName(CString * pstrGroupName) 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    CString strSnapinBaseName, strDisplayName;
    strSnapinBaseName.LoadString(IDS_ROOT_NODENAME);

    int nBaseLength = strSnapinBaseName.GetLength() + 1; // For the space
    strDisplayName = GetDisplayName();

    if (strDisplayName.GetLength() == nBaseLength)
        pstrGroupName->Empty();
    else
        *pstrGroupName = strDisplayName.Right(strDisplayName.GetLength() - nBaseLength);

    return hrOK;
}

/*---------------------------------------------------------------------------
    CTapiRootHandler::OnExpand
        Handles enumeration of a scope item
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CTapiRootHandler::OnExpand
(
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg, 
    LPARAM          param
)
{
    HRESULT hr = hrOK;

    if (m_bExpanded) 
        return hr;

    // do the default handling
    hr = CTapiHandler::OnExpand(pNode, pDataObject, dwType, arg, param);

    if (dwType & TFS_COMPDATA_EXTENSION)
    {
        // we are extending somebody.  Get the computer name and check that machine
        hr = CheckMachine(pNode, pDataObject);
    }
    else
    {
        int iVisibleCount = 0;
        int iTotalCount = 0;

        pNode->GetChildCount(&iVisibleCount, &iTotalCount);

        if (0 == iTotalCount)
        {
            // check to see if we need to add the local machine to the list
            hr = CheckMachine(pNode, NULL);
        }
    }

    return hr;
}

/*---------------------------------------------------------------------------
    CTapiRootHandler::OnRemoveChildren
        Handles removal of the children nodes
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CTapiRootHandler::OnRemoveChildren
(
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataObject,
    LPARAM          arg, 
    LPARAM          param
)
{
    HRESULT hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
    SPITFSNode      spCurrentNode;
    ULONG           nNumReturned = 0;

   
    if (!m_bExpanded)
        return hr;

    m_bExpanded = FALSE;

    // do the default handling
    hr = CTapiHandler::OnRemoveChildren(pNode, pDataObject, arg, param);


    // get the enumerator for this node
    CORg(pNode->GetEnum(&spNodeEnum));

    CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));

    // walk the list of child nodes and remove each node
    while (nNumReturned)
    {
        CORg (pNode->RemoveChild(spCurrentNode));

        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    }

Error:
    return hr;
}


/*---------------------------------------------------------------------------
    CTapiRootHandler::OnAddMenuItems
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CTapiRootHandler::OnAddMenuItems
(
    ITFSNode *              pNode,
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    LPDATAOBJECT            lpDataObject, 
    DATA_OBJECT_TYPES       type, 
    DWORD                   dwType,
    long *                  pInsertionAllowed
)
{ 
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;
    CString strMenuItem;

    if (type == CCT_SCOPE)
    {
        // these menu items go in the new menu, 
        // only visible from scope pane
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
            strMenuItem.LoadString(IDS_ADD_MACHINE);
            hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                     strMenuItem, 
                                     IDS_ADD_MACHINE,
                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                     0 );
            ASSERT( SUCCEEDED(hr) );
        }
    }

    return hr; 
}

/*---------------------------------------------------------------------------
    CTapiRootHandler::OnCommand
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CTapiRootHandler::OnCommand
(
    ITFSNode *          pNode, 
    long                nCommandId, 
    DATA_OBJECT_TYPES   type, 
    LPDATAOBJECT        pDataObject, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;

    switch (nCommandId)
    {
        case IDS_ADD_MACHINE:
            OnAddMachine(pNode);
            break;

        default:
            break;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    CTapiRootHandler::AddMenuItems
        Over-ride this to add our view menu item
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CTapiRootHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
    MMC_COOKIE              cookie,
    LPDATAOBJECT            pDataObject, 
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    long *                  pInsertionAllowed
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;
    CString strMenuItem;
/*
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    {
        strMenuItem.LoadString(IDS_VIEW_TASKPAD);
        hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                 strMenuItem, 
                                 IDS_VIEW_TASKPAD,
                                 CCM_INSERTIONPOINTID_PRIMARY_VIEW, 
                                 (m_bTaskPadView) ? MF_CHECKED : 0 );
    }
*/
    return hr;
}

/*!--------------------------------------------------------------------------
    CTapiRootHandler::Command
        Handles commands for the current view
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CTapiRootHandler::Command
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    int             nCommandID,
    LPDATAOBJECT    pDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;

    switch (nCommandID)
    {
        case MMCC_STANDARD_VIEW_SELECT:
            m_bTaskPadView = FALSE;
            break;

        case IDS_VIEW_TASKPAD:
            {
                // if we are not viewing the taskpad presently, re-select the node
                // so that the taskpad is visible
                SPIConsole   spConsole;
                SPITFSNode   spNode;

                m_bTaskPadView = !m_bTaskPadView;

                m_spResultNodeMgr->FindNode(cookie, &spNode);
                m_spTFSCompData->GetConsole(&spConsole);
                spConsole->SelectScopeItem(spNode->GetData(TFS_DATA_SCOPEID));
            }
            break;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    CTapiRootHandler::HasPropertyPages
        Implementation of ITFSNodeHandler::HasPropertyPages
    NOTE: the root node handler has to over-ride this function to 
    handle the snapin manager property page (wizard) case!!!
    
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CTapiRootHandler::HasPropertyPages
(
    ITFSNode *          pNode,
    LPDATAOBJECT        pDataObject, 
    DATA_OBJECT_TYPES   type, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    HRESULT hr = hrOK;
    
    if (dwType & TFS_COMPDATA_CREATE)
    {
        // This is the case where we are asked to bring up property
        // pages when the user is adding a new snapin.  These calls
        // are forwarded to the root node to handle.
        hr = hrFalse;
    }
    else
    {
        // we have property pages in the normal case
        hr = hrFalse;
    }
    return hr;
}

/*---------------------------------------------------------------------------
    CTapiRootHandler::CreatePropertyPages
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CTapiRootHandler::CreatePropertyPages
(
    ITFSNode *              pNode,
    LPPROPERTYSHEETCALLBACK lpProvider,
    LPDATAOBJECT            pDataObject, 
    LONG_PTR                handle, 
    DWORD                   dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = hrOK;
    HPROPSHEETPAGE hPage;

    Assert(pNode->GetData(TFS_DATA_COOKIE) == 0);
    
    if (dwType & TFS_COMPDATA_CREATE)
    {
        //
        // We are loading this snapin for the first time, put up a property
        // page to allow them to name this thing.
        // 
    }
    else
    {
        //
        // Object gets deleted when the page is destroyed
        //
    }

    return hr;
}

/*---------------------------------------------------------------------------
    CTapiRootHandler::OnPropertyChange
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CTapiRootHandler::OnPropertyChange
(   
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataobject, 
    DWORD           dwType, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    return hrOK;
}

/*!--------------------------------------------------------------------------
    CTapiRootHandler::TaskPadNotify
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CTapiRootHandler::TaskPadNotify
(
    ITFSComponent * pComponent,
    MMC_COOKIE      cookie,
    LPDATAOBJECT    pDataObject,
    VARIANT *       arg,
    VARIANT *       param
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    if (arg->vt == VT_I4)
    {
        switch (arg->lVal)
        {
            case ROOT_TASK_GETTING_STARTED:
                {
                    SPIDisplayHelp spDisplayHelp;
                    SPIConsole spConsole;

                    pComponent->GetConsole(&spConsole);

                    HRESULT hr = spConsole->QueryInterface (IID_IDisplayHelp, (LPVOID*) &spDisplayHelp);
                    ASSERT (SUCCEEDED (hr));
                    if ( SUCCEEDED (hr) )
                    {
                        LPCTSTR pszHelpFile = m_spTFSCompData->GetHTMLHelpFileName();
                        if (pszHelpFile == NULL)
                            break;

                        CString szHelpFilePath;
                        UINT nLen = ::GetWindowsDirectory (szHelpFilePath.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
                        if (nLen == 0)
                            return E_FAIL;

                        szHelpFilePath.ReleaseBuffer();
                        szHelpFilePath += g_szDefaultHelpTopic;

                        hr = spDisplayHelp->ShowTopic (T2OLE ((LPTSTR)(LPCTSTR) szHelpFilePath));
                        ASSERT (SUCCEEDED (hr));
                    }
                }
                break;
            
            case ROOT_TASK_ADD_SERVER:
                {
                    SPITFSNode spNode;

                    m_spResultNodeMgr->FindNode(cookie, &spNode);
                    OnAddMachine(spNode);
                }
                break;

            case ROOT_TASK_MANAGE_TAPI:
                // manage TAPI - only shown when an extension
                {
                    SPITFSNodeEnum spNodeEnum;
                    SPITFSNode spCurrentNode;
                    ULONG nNumReturned = 0;
                    SPITFSNode spNode;

                    m_spResultNodeMgr->FindNode(cookie, &spNode);
                    
                    // get the enumerator for this node
                    spNode->GetEnum(&spNodeEnum);

                    spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
                    while (nNumReturned)
                    {
                        // in this case there should only be one child,
                        // so select it.
                        SPIConsole  spConsole;
                        m_spTFSCompData->GetConsole(&spConsole);
                        spConsole->SelectScopeItem(spCurrentNode->GetData(TFS_DATA_SCOPEID));
                        break;
                    }
                }
                break;
            
            case ROOT_TASK_LAUNCH_TAPI:
            {
                TCHAR       SystemPath[MAX_PATH];
                CString     CommandLine;

                GetSystemDirectory(SystemPath, MAX_PATH);

                // to construct "mmc.exe /s %windir%\system32\acssnap.msc")
                CommandLine = _T("mmc.exe /s ");
                CommandLine += SystemPath;
                CommandLine += _T("\\tapimgmt.msc");
                USES_CONVERSION;
                WinExec(T2A((LPTSTR)(LPCTSTR)CommandLine), SW_SHOW);
            }
                break;

            default:
                Panic1("CTapiRootHandler::TaskPadNotify - Unrecognized command! %d", arg->lVal);
                break;
        }
    }

    return hrOK;
}

/*!--------------------------------------------------------------------------
    CBaseResultHandler::EnumTasks
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CTapiRootHandler::EnumTasks
(
    ITFSComponent * pComponent,
    MMC_COOKIE      cookie,
    LPDATAOBJECT    pDataObject,
    LPOLESTR        pszTaskGroup,
    IEnumTASK **    ppEnumTask
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT         hr = hrOK;
    CRootTasks *    pTasks = NULL;
    SPIEnumTask     spEnumTasks;
    SPINTERNAL      spInternal = ExtractInternalFormat(pDataObject);
    BOOL            bExtension = FALSE;
    BOOL            bAddThisMachineTasks = FALSE;
    BOOL            bAddNetServicesTasks = FALSE;
    const CLSID *   pNodeClsid = &CLSID_TapiSnapin;
    CString         strMachineGroup = NETCONS_ROOT_THIS_MACHINE;
    CString         strNetServicesGroup = NETCONS_ROOT_NET_SERVICES;
        
    if ((spInternal == NULL) || (*pNodeClsid != spInternal->m_clsid))
        bExtension = TRUE;

    if (bExtension && 
        strMachineGroup.CompareNoCase(pszTaskGroup) == 0)
    {
        // There are multiple taskpad groups in the network console
        // we need to make sure we are extending the correct one.
        bAddThisMachineTasks = TRUE;
    }

    if (bExtension && 
        strNetServicesGroup.CompareNoCase(pszTaskGroup) == 0)
    {
        // There are multiple taskpad groups in the network console
        // we need to make sure we are extending the correct one.
        bAddNetServicesTasks = TRUE;
    }

    COM_PROTECT_TRY
    {
        pTasks = new CRootTasks();
        spEnumTasks = pTasks;

        if (!(bExtension && !bAddThisMachineTasks && !bAddNetServicesTasks))
            CORg (pTasks->Init(bExtension, bAddThisMachineTasks, bAddNetServicesTasks));

        CORg (pTasks->QueryInterface (IID_IEnumTASK, (void **)ppEnumTask));
    
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
    CTapiRootHandler::TaskPadGetTitle
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CTapiRootHandler::TaskPadGetTitle
(
    ITFSComponent * pComponent,
    MMC_COOKIE      cookie,
    LPOLESTR        pszGroup,
    LPOLESTR *      ppszTitle
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    *ppszTitle = (LPOLESTR) CoTaskMemAlloc (sizeof(OLECHAR)*(lstrlen(m_strTaskpadTitle)+1));
    if (!*ppszTitle)
        return E_OUTOFMEMORY;

    lstrcpy (*ppszTitle, m_strTaskpadTitle);
   
    return S_OK;
}

/*---------------------------------------------------------------------------
    CTapiRootHandler::OnGetResultViewType
        Return the result view that this node is going to support
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CTapiRootHandler::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    // if we aren't displaying the taskpad, use the default stuff...
    if (!m_bTaskPadView)
        return CTapiHandler::OnGetResultViewType(pComponent, cookie, ppViewType, pViewOptions);

    //
    // In this code we are defaulting to a taskpad view for this node all the time.
    // It is the snapins responsibility to put up a view menu selection that has a
    // selection for the taskpad. Do that in AddMenuItems.
    //
    //
    // We will use the default DHTML provided by MMC. It actually resides as a
    // resource inside MMC.EXE. We just get the path to it and use that.
    // The one piece of magic here is the text following the '#'. That is the special
    // way we have of identifying they taskpad we are talking about. Here we say we are
    // wanting to show a taskpad that we refer to as "CMTP1". We will actually see this
    // string pass back to us later. If someone is extending our taskpad, they also need
    // to know what this secret string is.
    //
    *pViewOptions = MMC_VIEW_OPTIONS_NONE;
    OLECHAR szBuffer[MAX_PATH*2]; // a little extra

    lstrcpy (szBuffer, L"res://");
    OLECHAR * temp = szBuffer + lstrlen(szBuffer);

    // get "res://"-type string for custom taskpad
    // the string after the # gets handed back to us in future calls...
    // should be unique for each node
    ::GetModuleFileName (NULL, temp, MAX_PATH);
    lstrcat (szBuffer, L"/default.htm#TAPIROOT");

    // alloc and copy bitmap resource string
    *ppViewType = (LPOLESTR)CoTaskMemAlloc (sizeof(OLECHAR)*(lstrlen(szBuffer)+1));

    if (!*ppViewType)
        return E_OUTOFMEMORY;   // or S_FALSE ???

    lstrcpy (*ppViewType, szBuffer);

    return S_OK;
}

/*!--------------------------------------------------------------------------
    CTapiRootHandler::OnResultSelect
        For nodes with task pads, we override the select message to set 
        the selected node.  Nodes with taskpads do not get the MMCN_SHOW
        message which is where we normall set the selected node
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CTapiRootHandler::OnResultSelect(ITFSComponent *pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    HRESULT hr = hrOK;

    CORg(DoTaskpadResultSelect(pComponent, pDataObject, cookie, arg, lParam, m_bTaskPadView));

    CORg(CTapiHandler::OnResultSelect(pComponent, pDataObject, cookie, arg, lParam));

Error:
    return hr;
}


/*---------------------------------------------------------------------------
    Command handlers
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CTapiRootHandler::OnAddMachine
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CTapiRootHandler::OnAddMachine
(
    ITFSNode *  pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
    HRESULT hr = hrOK;
    
    /*
    GETCOMPUTERSELECTIONINFO    info;
    PDSSELECTIONLIST    pSelList = NULL;

    LPCTSTR attrs[] = {_T("dNSHostName")};

    ZeroMemory(&info, sizeof(GETCOMPUTERSELECTIONINFO));
    info.cbSize = sizeof(GETCOMPUTERSELECTIONINFO);
    info.hwndParent = FindMMCMainWindow();
    info.flObjectPicker = 0; // not allow multiple selection
    info.flDsObjectPicker = DSOP_SCOPE_DIRECTORY | 
                            DSOP_SCOPE_DOMAIN_TREE | 
                            DSOP_SCOPE_EXTERNAL_TRUSTED_DOMAINS;
    info.flStartingScope = DSOP_SCOPE_DIRECTORY;
    info.ppDsSelList = &pSelList;
    info.cRequestedAttributes = 1;
    info.aptzRequestedAttributes = attrs;

    hr = GetComputerSelection(&info);
    if(hr != S_OK)  // assume the API will display error message, if there is
        return hr;

    CString strTemp = pSelList->aDsSelection[0].pwzName;
    if (strTemp.Left(2) == _T("\\\\"))
        strTemp = pSelList->aDsSelection[0].pwzName[2];
    */
    CGetComputer getComputer;
    
    if (!getComputer.GetComputer(FindMMCMainWindow()))
        return hr;

    CString strTemp = getComputer.m_strComputerName;

    // if the machine is already in the list, don't bother.
    if (IsServerInList(pNode, strTemp))
    {
        AfxMessageBox(IDS_ERR_SERVER_IN_LIST);
    }
    else
    {
        AddServer(_T(""), strTemp, TRUE, 0, TAPISNAP_REFRESH_INTERVAL_DEFAULT);
    }

    return hr;
}

/*---------------------------------------------------------------------------
    CTapiRootHandler::AddServer
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CTapiRootHandler::AddServer
(
    LPCWSTR          pServerIp,
    LPCTSTR          pServerName,
    BOOL             bNewServer,
    DWORD            dwServerOptions,
    DWORD            dwRefreshInterval,
    BOOL             bExtension,
    DWORD            dwLineBuffSize,
    DWORD            dwPhoneBuffSize
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    CTapiServer *       pTapiServer = NULL;
    SPITFSNodeHandler   spHandler;
    SPITFSNode          spNode, spRootNode;

    // Create a handler for the node
    try
    {
        pTapiServer = new CTapiServer(m_spTFSCompData);
        //pTapiServer->SetName(pServerName);
        
        // Do this so that it will get released correctly
        spHandler = pTapiServer;
    }
    catch(...)
    {
        hr = E_OUTOFMEMORY;
    }
    CORg( hr );
    
    //
    // Create the server container information
    // 
    CreateContainerTFSNode(&spNode,
                           &GUID_TapiServerNodeType,
                           pTapiServer,
                           pTapiServer,
                           m_spNodeMgr);

    // Tell the handler to initialize any specific data
    pTapiServer->SetName(pServerName);
    
    pTapiServer->InitializeNode((ITFSNode *) spNode);

    pTapiServer->SetCachedLineBuffSize(dwLineBuffSize);
    pTapiServer->SetCachedPhoneBuffSize(dwPhoneBuffSize);
    
    if (dwServerOptions & TAPISNAP_OPTIONS_EXTENSION)
    {
        pTapiServer->SetExtensionName();
    }

    // Mask out the auto refresh option because we set it next
    pTapiServer->SetOptions(dwServerOptions & ~TAPISNAP_OPTIONS_REFRESH);

    // if we got a valid refresh interval, then set it.
    pTapiServer->SetAutoRefresh(spNode, dwServerOptions & TAPISNAP_OPTIONS_REFRESH, dwRefreshInterval);

    AddServerSortedName(spNode, bNewServer);

    if (bNewServer)
    {
        // need to get our node descriptor
        CORg(m_spNodeMgr->GetRootNode(&spRootNode));
        spRootNode->SetData(TFS_DATA_DIRTY, TRUE);
    }

Error:
    return hr;
}

/*---------------------------------------------------------------------------
    CTapiRootHandler::IsServerInList
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
CTapiRootHandler::IsServerInList
(
    ITFSNode *      pRootNode,
    LPCTSTR         pszMachineName
)
{
    HRESULT         hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
    SPITFSNode      spCurrentNode;
    ULONG           nNumReturned = 0;
    DWORD           dwIpAddressCurrent;
    BOOL            bFound = FALSE;
    CString         strNewName = pszMachineName;

    // get the enumerator for this node
    pRootNode->GetEnum(&spNodeEnum);

    spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    while (nNumReturned)
    {
        // walk the list of servers and see if it already exists
        CTapiServer * pServer = GETHANDLER(CTapiServer, spCurrentNode);
        if (strNewName.CompareNoCase(pServer->GetName()) == 0)
        {
            bFound = TRUE;
            break;
        }

        // get the next Server in the list
        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    }

    return bFound;
}

/*---------------------------------------------------------------------------
    CTapiRootHandler::AddServerSortedIp
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CTapiRootHandler::AddServerSortedIp
(
    ITFSNode *      pNewNode,
    BOOL            bNewServer
)
{
    HRESULT         hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
    SPITFSNode      spCurrentNode;
    SPITFSNode      spPrevNode;
    SPITFSNode      spRootNode;
    ULONG           nNumReturned = 0;
    DWORD           dwIpAddressCurrent = 0;
    DWORD           dwIpAddressTarget;

    CTapiServer *   pServer;

    // get our target address
    pServer = GETHANDLER(CTapiServer, pNewNode);
    //pServer->GetIpAddress(&dwIpAddressTarget);

    // need to get our node descriptor
    CORg(m_spNodeMgr->GetRootNode(&spRootNode));

    // get the enumerator for this node
    CORg(spRootNode->GetEnum(&spNodeEnum));

    CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
    while (nNumReturned)
    {
        // walk the list of servers and see if it already exists
        pServer = GETHANDLER(CTapiServer, spCurrentNode);
        //pServer->GetIpAddress(&dwIpAddressCurrent);

        //if (dwIpAddressCurrent > dwIpAddressTarget)
        //{
            // Found where we need to put it, break out
            break;
        //}

        // get the next Server in the list
        spPrevNode.Set(spCurrentNode);

        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    }

    // Add the node in based on the PrevNode pointer
    if (spPrevNode)
    {
        if (bNewServer)
        {
            if (spPrevNode->GetData(TFS_DATA_SCOPEID) != NULL)
            {
                pNewNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_PREVIOUS);
                pNewNode->SetData(TFS_DATA_RELATIVE_SCOPEID, spPrevNode->GetData(TFS_DATA_SCOPEID));
            }
        }
        
        CORg(spRootNode->InsertChild(spPrevNode, pNewNode));
    }
    else
    {   
        // add to the head
        if (m_bExpanded)
        {
            pNewNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_FIRST);
        }
        CORg(spRootNode->AddChild(pNewNode));
    }

Error:
    return hr;
}

/*---------------------------------------------------------------------------
    CTapiRootHandler::AddServerSortedName
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CTapiRootHandler::AddServerSortedName
(
    ITFSNode *      pNewNode,
    BOOL            bNewServer
)
{
    HRESULT         hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
    SPITFSNode      spCurrentNode;
    SPITFSNode      spPrevNode;
    SPITFSNode      spRootNode;
    ULONG           nNumReturned = 0;
    CString         strTarget, strCurrent;

    CTapiServer *   pServer;

    // get our target address
    pServer = GETHANDLER(CTapiServer, pNewNode);
    strTarget = pServer->GetName();

    // need to get our node descriptor
    CORg(m_spNodeMgr->GetRootNode(&spRootNode));

    // get the enumerator for this node
    CORg(spRootNode->GetEnum(&spNodeEnum));

    CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
    while (nNumReturned)
    {
        // walk the list of servers and see if it already exists
        pServer = GETHANDLER(CTapiServer, spCurrentNode);
        strCurrent = pServer->GetName();

        if (strTarget.Compare(strCurrent) < 0)
        {
            // Found where we need to put it, break out
            break;
        }

        // get the next Server in the list
        spPrevNode.Set(spCurrentNode);

        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    }

    // Add the node in based on the PrevNode pointer
    if (spPrevNode)
    {
        if (bNewServer)
        {
            if (spPrevNode->GetData(TFS_DATA_SCOPEID) != NULL)
            {
                pNewNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_PREVIOUS);
                pNewNode->SetData(TFS_DATA_RELATIVE_SCOPEID, spPrevNode->GetData(TFS_DATA_SCOPEID));
            }
        }
        
        CORg(spRootNode->InsertChild(spPrevNode, pNewNode));
    }
    else
    {   
        // add to the head
        if (m_bExpanded)
        {
            pNewNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_FIRST);
        }
        CORg(spRootNode->AddChild(pNewNode));
    }

Error:
    return hr;
}

/*---------------------------------------------------------------------------
    CTapiRootHandler::CheckMachine
        Checks to see if the TAPI server service is running on the local
        machine.  If it is, it adds it to the list of servers.
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CTapiRootHandler::CheckMachine
(
    ITFSNode *      pRootNode,
    LPDATAOBJECT    pDataObject
)
{
    HRESULT hr = hrOK;

    // Get the local machine name and check to see if the service
    // is installed.
    CString strMachineName;
    LPTSTR  pBuf;
    DWORD   dwLength = MAX_COMPUTERNAME_LENGTH + 1;
    BOOL    bExtension = (pDataObject != NULL);
    
    if (!bExtension)
    {
        pBuf = strMachineName.GetBuffer(dwLength);
        GetComputerName(pBuf, &dwLength);
        strMachineName.ReleaseBuffer();
    }
    else
    {
        strMachineName = Extract<TCHAR>(pDataObject, (CLIPFORMAT) g_cfMachineName, COMPUTERNAME_LEN_MAX);
    }

    if (strMachineName.IsEmpty())
    {
        DWORD   dwSize = MAX_COMPUTERNAME_LENGTH + 1;
        LPTSTR  pBuf = strMachineName.GetBuffer(dwSize);
    
        ::GetComputerName(pBuf, &dwSize);
    
        strMachineName.ReleaseBuffer();
    }

    // if the machine is already in the list, don't bother.
    if (IsServerInList(pRootNode, strMachineName))
        return hr;

    if (bExtension)
        RemoveOldEntries(pRootNode, strMachineName);

    // we always add the local machine or whatever machine we are pointed at even if 
    // we are an extension
/*
    BOOL bServiceRunning;
    DWORD dwError = ::TFSIsServiceRunning(strMachineName, TAPI_SERVICE_NAME, &bServiceRunning);
    if (dwError != ERROR_SUCCESS ||
        !bServiceRunning)
    {
        // The following condition could happen to get here:
        //  o The service is not installed.
        //  o Couldn't access for some reason.
        //  o The service isn't running.
        
        // Don't add to the list.
        
        return hrOK;
    }
*/

    // OK.  The service is installed, so add it to the list.
    DWORD dwFlags = 0;

    if (bExtension)
        dwFlags |= TAPISNAP_OPTIONS_EXTENSION;

    AddServer(_T(""), strMachineName, TRUE, dwFlags, TAPISNAP_REFRESH_INTERVAL_DEFAULT, bExtension);

    return hr;
}

// when running as an extension, it is possible that we were saved as "local machine"
// which means that if the saved console file was moved to another machine we need to remove 
// the old entry that was saved
HRESULT 
CTapiRootHandler::RemoveOldEntries(ITFSNode * pNode, LPCTSTR pszAddr)
{
    HRESULT         hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
    SPITFSNode      spCurrentNode;
    ULONG           nNumReturned = 0;
    CTapiServer *   pServer;
    CString         strCurAddr;

    // get the enumerator for this node
    CORg(pNode->GetEnum(&spNodeEnum));

    CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
    while (nNumReturned)
    {
        // walk the list of servers and see if it already exists
        pServer = GETHANDLER(CTapiServer, spCurrentNode);

        strCurAddr = pServer->GetName();

        if (strCurAddr.CompareNoCase(pszAddr) != 0)
        {
            CORg (pNode->RemoveChild(spCurrentNode));
        }

        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    }

Error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\root.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    root.h
        TAPI root node information (the root node is not displayed
        in the MMC framework but contains information such as 
        all of the servers in this snapin).
        
    FILE HISTORY:
        
*/

#ifndef _ROOT_H
#define _ROOT_H

#ifndef _TAPIHAND_H
#include "tapihand.h"
#endif

#ifndef _TASK_H
#include <task.h>
#endif

#define COMPUTERNAME_LEN_MAX            255

typedef enum _ROOT_TASKS
{
    ROOT_TASK_GETTING_STARTED,
    ROOT_TASK_ADD_SERVER,
    ROOT_TASK_MANAGE_TAPI,
    ROOT_TASK_LAUNCH_TAPI,
    ROOT_TASK_MAX
} ROOT_TASKS;

class CRootTasks : public CTaskList
{
public:
    HRESULT Init(BOOL bExtension, BOOL bThisMachine, BOOL bNetServices);

private:
    CStringArray    m_arrayMouseOverBitmaps;
    CStringArray    m_arrayMouseOffBitmaps;
    CStringArray    m_arrayTaskText;
    CStringArray    m_arrayTaskHelp; 
};

/*---------------------------------------------------------------------------
    Class:  CTapiRootHandler
 ---------------------------------------------------------------------------*/
class CTapiRootHandler : public CTapiHandler
{
// Interface
public:
    CTapiRootHandler(ITFSComponentData *pCompData);

    // Node handler functionality we override
    OVERRIDE_NodeHandler_HasPropertyPages();
    OVERRIDE_NodeHandler_CreatePropertyPages();
    OVERRIDE_NodeHandler_OnAddMenuItems();
    OVERRIDE_NodeHandler_OnCommand();
    OVERRIDE_NodeHandler_GetString();

    // base handler functionality we override
    OVERRIDE_BaseHandlerNotify_OnExpand();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();
    OVERRIDE_BaseHandlerNotify_OnRemoveChildren();

    // Result handler functionality
    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();

    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();
    OVERRIDE_ResultHandler_OnGetResultViewType();
    OVERRIDE_ResultHandler_TaskPadNotify();
    OVERRIDE_ResultHandler_EnumTasks();
    OVERRIDE_ResultHandler_TaskPadGetTitle();

public:
    // helper routines
    void    CreateLocalTapiServer();
    HRESULT AddServer(LPCWSTR pServerIp, 
                      LPCTSTR pServerName, 
                      BOOL bNewServer, 
                      DWORD dwServerOptions = 0x00000000, 
                      DWORD dwRefreshInterval = 0xffffffff, 
                      BOOL bExtension = FALSE,  
                      DWORD dwLineBuffSize = 0,
                      DWORD dwPhoneBuffSize = 0
                      );
    HRESULT GetGroupName(CString * pstrGroupName);
    HRESULT SetGroupName(LPCTSTR pszGroupName);

    BOOL    IsServerInList(ITFSNode * pRootNode, LPCTSTR pszNewName);
    HRESULT AddServerSortedIp(ITFSNode * pNewNode, BOOL bNewServer);
    HRESULT AddServerSortedName(ITFSNode * pNewNode, BOOL bNewServer);

public:
    // CTapiHandler overrides
    virtual HRESULT InitializeNode(ITFSNode * pNode);

// Implementation
private:
    // Command handlers
    HRESULT OnAddMachine(ITFSNode * pNode);
    HRESULT OnImportOldList(ITFSNode * pNode);
    BOOL    OldServerListExists();

    // helpers
    HRESULT CheckMachine(ITFSNode * pRootNode, LPDATAOBJECT pDataObject);
    HRESULT RemoveOldEntries(ITFSNode * pRootNode, LPCTSTR pszAddr);

protected:
    CString m_strTaskpadTitle;
    BOOL    m_bTaskPadView;
};

#endif _ROOT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\server.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    server.cpp
        Tapi server node handler

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "server.h"     // Server definition
#include "provider.h"
#include "servpp.h"     // server property sheet
#include "tapidb.h"
#include "drivers.h"

CTimerMgr g_TimerMgr;

/////////////////////////////////////////////////////////////////////
// 
// CTimerArray implementation
//
/////////////////////////////////////////////////////////////////////
CTimerMgr::CTimerMgr()
{

}

CTimerMgr::~CTimerMgr()
{
    CTimerDesc * pTimerDesc;

    for (int i = (int)GetUpperBound(); i >= 0; --i)
    {
        pTimerDesc = GetAt(i);
        if (pTimerDesc->uTimer != 0)
            FreeTimer(i);

        delete pTimerDesc;
    }

}

int
CTimerMgr::AllocateTimer
(
    ITFSNode *      pNode,
    CTapiServer *   pServer,
    UINT            uTimerValue,
    TIMERPROC       TimerProc
)
{
    CSingleLock slTimerMgr(&m_csTimerMgr);

    // get a lock on the timer mgr for the scope of this
    // function.
    slTimerMgr.Lock();

    CTimerDesc * pTimerDesc = NULL;

    // look for an empty slot
    for (int i = (int)GetUpperBound(); i >= 0; --i)
    {
        pTimerDesc = GetAt(i);
        if (pTimerDesc->uTimer == 0)
            break;
    }

    // did we find one?  if not allocate one
    if (i < 0)
    {
        pTimerDesc = new CTimerDesc;
        Add(pTimerDesc);
        i = (int)GetUpperBound();
    }
    
    pTimerDesc->uTimer = SetTimer(NULL, (UINT) i, uTimerValue, TimerProc);
    if (pTimerDesc->uTimer == 0)
        return -1;
    
    pTimerDesc->spNode.Set(pNode);
    pTimerDesc->pServer = pServer;
     pTimerDesc->timerProc = TimerProc;    
 
    return i;
}

void 
CTimerMgr::FreeTimer
(
    UINT_PTR uEventId
)
{
    CSingleLock slTimerMgr(&m_csTimerMgr);

    // get a lock on the timer mgr for the scope of this
    // function.
    slTimerMgr.Lock();

    CTimerDesc * pTimerDesc;

    Assert(uEventId <= (UINT) GetUpperBound());
    if (uEventId > (UINT) GetUpperBound())
        return;

    pTimerDesc = GetAt((int) uEventId);
    ::KillTimer(NULL, pTimerDesc->uTimer);

    pTimerDesc->spNode.Release();
    pTimerDesc->pServer = NULL;
    pTimerDesc->uTimer = 0;
}

CTimerDesc *
CTimerMgr::GetTimerDesc
(
    UINT_PTR uEventId
)
{
    CSingleLock slTimerMgr(&m_csTimerMgr);

    // the caller of this function should lock the timer mgr
    // while accessing this pointer
    CTimerDesc * pTimerDesc;

    for (int i = (int)GetUpperBound(); i >= 0; --i)
    {
        pTimerDesc = GetAt(i);
        if (pTimerDesc->uTimer == (UINT) uEventId)
            return pTimerDesc;
    }

    return NULL;
}

void
CTimerMgr::ChangeInterval
(
    UINT_PTR    uEventId,
    UINT        uNewInterval
)
{
    CSingleLock slTimerMgr(&m_csTimerMgr);

    // get a lock on the timer mgr for the scope of this
    // function.
    slTimerMgr.Lock();

    Assert(uEventId <= (UINT) GetUpperBound());
    if (uEventId > (UINT) GetUpperBound())
        return;

    CTimerDesc   tempTimerDesc;
    CTimerDesc * pTimerDesc;

    pTimerDesc = GetAt((int) uEventId);

    // kill the old timer
    ::KillTimer(NULL, pTimerDesc->uTimer);

    // set a new one with the new interval
    pTimerDesc->uTimer = ::SetTimer(NULL, (UINT) uEventId, uNewInterval, pTimerDesc->timerProc);
}

VOID CALLBACK 
StatisticsTimerProc
( 
    HWND        hwnd, 
    UINT        uMsg, 
    UINT_PTR    idEvent, 
    DWORD       dwTime 
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CSingleLock slTimerMgr(&g_TimerMgr.m_csTimerMgr);

    // get a lock on the timer mgr for the scope of this
    // function.
    slTimerMgr.Lock();

    // on the timer, get the timer descriptor for this event
    // Call into the appropriate handler to update the stats.
    CTimerDesc * pTimerDesc;

    pTimerDesc = g_TimerMgr.GetTimerDesc(idEvent);

    pTimerDesc->pServer->m_bStatsOnly = TRUE;
    pTimerDesc->pServer->OnRefreshStats(pTimerDesc->spNode,
                                        NULL,
                                        NULL,
                                        0,
                                        0);
    pTimerDesc->pServer->m_bStatsOnly = FALSE;
}

/*---------------------------------------------------------------------------
    Class CTapiServer implementation
 ---------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------
    Constructor and destructor
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
CTapiServer::CTapiServer
(
    ITFSComponentData * pComponentData
) : CMTTapiHandler(pComponentData),
    m_bStatsOnly(FALSE),
    m_StatsTimerId(-1),
    m_dwOptions(0)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
}

CTapiServer::~CTapiServer()
{
}

/*!--------------------------------------------------------------------------
    CTapiServer::InitializeNode
        Initializes node specific data
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CTapiServer::InitializeNode
(
    ITFSNode * pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
    HRESULT hr = hrOK;
    CString strTemp;

    COM_PROTECT_TRY
    {
        CORg (CreateTapiInfo(&m_spTapiInfo));

        BuildDisplayName(&strTemp);

        SetDisplayName(strTemp);

        // Make the node immediately visible
        pNode->SetVisibilityState(TFS_VIS_SHOW);
        pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
        pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_SERVER);
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_SERVER);
        pNode->SetData(TFS_DATA_USER, (LPARAM) this);
        pNode->SetData(TFS_DATA_TYPE, TAPISNAP_SERVER);

        SetColumnStringIDs(&aColumns[TAPISNAP_SERVER][0]);
        SetColumnWidths(&aColumnWidths[TAPISNAP_SERVER][0]);

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}

/*---------------------------------------------------------------------------
	CTapiServer::OnCreateNodeId2
		Returns a unique string for this node
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CTapiServer::OnCreateNodeId2(ITFSNode * pNode, CString & strId, DWORD * dwFlags)
{
    const GUID * pGuid = pNode->GetNodeType();
    
    CString strGuid;

    StringFromGUID2(*pGuid, strGuid.GetBuffer(256), 256);
    strGuid.ReleaseBuffer();

    strId = GetName() + strGuid;

    return hrOK;
}

/*---------------------------------------------------------------------------
    CTapiServer::GetImageIndex
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
int 
CTapiServer::GetImageIndex(BOOL bOpenImage) 
{
    int nIndex = -1;
    switch (m_nState)
    {
        case notLoaded:
            nIndex = ICON_IDX_SERVER;
            break;

        case loading:
            nIndex = ICON_IDX_SERVER_BUSY;
            break;

        case loaded:
            nIndex = ICON_IDX_SERVER_CONNECTED;
            break;

        case unableToLoad:
            nIndex = ICON_IDX_SERVER_LOST_CONNECTION;
            break;
        default:
            ASSERT(FALSE);
    }

    return nIndex;
}

/*---------------------------------------------------------------------------
    CTapiServer::OnHaveData
        When the background thread enumerates nodes to be added to the UI,
        we get called back here.  We override this to force expansion of the 
        node so that things show up correctly.
    Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CTapiServer::OnHaveData
(
    ITFSNode * pParentNode, 
    ITFSNode * pNewNode
)
{
    CMTTapiHandler::OnHaveData(pParentNode, pNewNode);
    ExpandNode(pParentNode, TRUE);
}

/*---------------------------------------------------------------------------
    CTapiServer::OnHaveData
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CTapiServer::OnHaveData
(
    ITFSNode * pParentNode, 
    DWORD      dwData,
    DWORD      dwType
)
{
    HRESULT hr = hrOK;

    // This is how we get non-node data back from the background thread.
    switch (dwType)
    {
        case TAPI_QDATA_REFRESH_STATS:
        {
            // tell all of the provider nodes to clear their status caches
            // if any of the nodes is the selected node, then they should
            // repaint the window
            SPITFSNodeEnum      spNodeEnum;
            SPITFSNode          spCurrentNode;
            ULONG               nNumReturned;
            
            CORg(pParentNode->GetEnum(&spNodeEnum));

            CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
            while (nNumReturned)
            {
                if (spCurrentNode->GetData(TFS_DATA_TYPE) == TAPISNAP_PROVIDER)
                {
                    CProviderHandler * pProvider = GETHANDLER(CProviderHandler, spCurrentNode);

                    pProvider->UpdateStatus(spCurrentNode);
                }

                spCurrentNode.Release();
                spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
            }

            break;
        }
    }

COM_PROTECT_ERROR_LABEL;
}

/*---------------------------------------------------------------------------
    Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CTapiServer::OnAddMenuItems
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CTapiServer::OnAddMenuItems
(
    ITFSNode *              pNode,
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    LPDATAOBJECT            lpDataObject, 
    DATA_OBJECT_TYPES       type, 
    DWORD                   dwType,
    long *                  pInsertionAllowed
)
{ 
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    LONG    fFlags = 0;
    HRESULT hr = S_OK;
    CString strMenuItem;

    if (m_nState != loaded || !m_spTapiInfo->IsLocalMachine() || !m_spTapiInfo->IsAdmin())
    {
        fFlags |= MF_GRAYED;
    }

    if (type == CCT_SCOPE)
    {
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
            strMenuItem.LoadString(IDS_ADD_PROVIDER);
            hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                     strMenuItem, 
                                     IDS_ADD_PROVIDER,
                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                     fFlags );
            ASSERT( SUCCEEDED(hr) );
        }

    }

    return hr; 
}

/*---------------------------------------------------------------------------
    CTapiServer::OnCommand
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CTapiServer::OnCommand
(
    ITFSNode *          pNode, 
    long                nCommandId, 
    DATA_OBJECT_TYPES   type, 
    LPDATAOBJECT        pDataObject, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;

    switch (nCommandId)
    {
        case IDS_ADD_PROVIDER:
            OnAddProvider(pNode);
            break;

        default:
            break;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    CTapiServer::HasPropertyPages
        Implementation of ITFSNodeHandler::HasPropertyPages
    NOTE: the root node handler has to over-ride this function to 
    handle the snapin manager property page (wizard) case!!!
    
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CTapiServer::HasPropertyPages
(
    ITFSNode *          pNode,
    LPDATAOBJECT        pDataObject, 
    DATA_OBJECT_TYPES   type, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    HRESULT hr = hrOK;
    
    if (dwType & TFS_COMPDATA_CREATE)
    {
        // This is the case where we are asked to bring up property
        // pages when the user is adding a new snapin.  These calls
        // are forwarded to the root node to handle.  Only for the root node
        hr = hrOK;
        Assert(FALSE); // should never get here
    }
    else
    {
        // we have property pages in the normal case, but don't put the
        // menu up if we are not loaded yet
        if ( (m_nState == loaded) ||
             (m_nState == unableToLoad) )
        {
            hr = hrOK;
        }
        else
        {
            hr = hrFalse;
        }
    }
    
    return hr;
}

/*---------------------------------------------------------------------------
    CTapiServer::CreatePropertyPages
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CTapiServer::CreatePropertyPages
(
    ITFSNode *              pNode,
    LPPROPERTYSHEETCALLBACK lpProvider,
    LPDATAOBJECT            pDataObject, 
    LONG_PTR                handle, 
    DWORD                   dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // Create the property page
    //
    SPIComponentData spComponentData;
    m_spNodeMgr->GetComponentData(&spComponentData);

    CServerProperties * pServerProp = new CServerProperties(pNode, spComponentData, m_spTFSCompData, m_spTapiInfo, NULL, loaded == m_nState);

    pServerProp->m_strMachineName = m_strServerAddress;

    // fill in the auto refresh info
    pServerProp->m_pageRefresh.m_dwRefreshInterval = GetAutoRefreshInterval();
    pServerProp->m_pageRefresh.m_bAutoRefresh = GetOptions() & TAPISNAP_OPTIONS_REFRESH ? TRUE : FALSE;

    // initialze the service information
    if (!pServerProp->FInit())
    {
        delete pServerProp;
        return E_FAIL;
    }

    //
    // Object gets deleted when the page is destroyed
    //
    Assert(lpProvider != NULL);

    return pServerProp->CreateModelessSheet(lpProvider, handle);
}

/*---------------------------------------------------------------------------
    CTapiServer::OnPropertyChange
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CTapiServer::OnPropertyChange
(   
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataobject, 
    DWORD           dwType, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    CServerProperties * pServerProp = reinterpret_cast<CServerProperties *>(lParam);

    LONG_PTR changeMask = 0;

    // tell the property page to do whatever now that we are back on the
    // main thread
    pServerProp->OnPropertyChange(TRUE, &changeMask);

    pServerProp->AcknowledgeNotify();

    if (changeMask)
        pNode->ChangeNode(changeMask);

    return hrOK;
}

/*!--------------------------------------------------------------------------
    CTapiServer::OnDelete
        The base handler calls this when MMC sends a MMCN_DELETE for a 
        scope pane item.  We just call our delete command handler.
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CTapiServer::OnDelete
(
    ITFSNode *  pNode, 
    LPARAM      arg, 
    LPARAM      lParam
)
{
    return OnDelete(pNode);
}

/*!--------------------------------------------------------------------------
    CTapiServer::OnNotifyExiting
        We override this for the server node because we don't want the 
        icon to change when the thread goes away.  Normal behavior is that
        the node's icon changes to a wait cursor when the background thread
        is running.  If we are only doing stats collection, then we 
        don't want the icon to change.
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CTapiServer::OnNotifyExiting
(
    LPARAM          lParam
)
{
    CTapiServerQueryObj * pQuery = (CTapiServerQueryObj *) lParam;
    
    if (!pQuery->m_bStatsOnly)
        OnChangeState(m_spNode);

    ReleaseThreadHandler();

    Unlock();

    return hrOK;
}

/*---------------------------------------------------------------------------
    Command handlers
 ---------------------------------------------------------------------------*/

 /*!--------------------------------------------------------------------------
    CTapiServer::OnRefresh
        Default implementation for the refresh functionality
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CTapiServer::OnRefresh
(
    ITFSNode *      pNode,
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg,
    LPARAM          param
)
{
    m_spTapiInfo->Destroy();

    return CMTHandler::OnRefresh(pNode, pDataObject, dwType, arg, param);
}

/*!--------------------------------------------------------------------------
    CTapiServer::OnRefreshStats
        Default implementation for the Stats refresh functionality
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CTapiServer::OnRefreshStats
(
    ITFSNode *      pNode,
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg,
    LPARAM          param
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    SPITFSNode          spNode;
    SPITFSNodeHandler   spHandler;
    ITFSQueryObject *   pQuery = NULL;
    
    if (m_bExpanded == FALSE)
    {
        // we cannot get statistics if the node hasn't been expanded yet
        return hr;
    }

    // only do stats refresh if the server was loaded correctly.
    if (m_nState != loaded)
        return hr;

    BOOL bLocked = IsLocked();
    if (bLocked)
    {
        // cannot refresh stats if this node is locked
        return hr; 
    }

    Lock();

    //OnChangeState(pNode);

    pQuery = OnCreateQuery(pNode);
    Assert(pQuery);

    // notify the UI to change icon, if needed
    //Verify(SUCCEEDED(pComponentData->ChangeNode(this, SCOPE_PANE_CHANGE_ITEM_ICON)));

    Verify(StartBackgroundThread(pNode, m_spTFSCompData->GetHiddenWnd(), pQuery));
    
    pQuery->Release();

    return hrOK;
}

 /*---------------------------------------------------------------------------
    CTapiServer::OnAddProvider()
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CTapiServer::OnAddProvider(ITFSNode * pNode)
{
    CDriverSetup dlgDrivers(pNode, m_spTapiInfo);

    dlgDrivers.DoModal();
    if (dlgDrivers.m_fDriverAdded)
    {
        OnRefresh(pNode, NULL, 0, NULL, NULL);
    }

    return hrOK;
}

 /*---------------------------------------------------------------------------
    CTapiServer::OnDelete()
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CTapiServer::OnDelete(ITFSNode * pNode)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;

    CString strMessage;
    AfxFormatString1(strMessage, IDS_WARN_SERVER_DELETE, m_strServerAddress);

    if (AfxMessageBox(strMessage, MB_YESNO) == IDYES)
    {
        // remove this node from the list, there's nothing we need to tell
        // the server, it's just our local list of servers
        SPITFSNode spParent;

        pNode->GetParent(&spParent);
        spParent->RemoveChild(pNode);
    }

    return hr;
}

 /*---------------------------------------------------------------------------
    CTapiServer::RemoveProvider()
        Removes a provider from the scope pane - UI only
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CTapiServer::RemoveProvider(ITFSNode * pNode, DWORD dwProviderID)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;

    SPITFSNodeEnum      spNodeEnum;
    SPITFSNode          spCurrentNode;
    ULONG               nNumReturned;
    
    CORg(pNode->GetEnum(&spNodeEnum));

    CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
    while (nNumReturned)
    {
        if (spCurrentNode->GetData(TFS_DATA_TYPE) == TAPISNAP_PROVIDER)
        {
            CProviderHandler * pProvider = GETHANDLER(CProviderHandler, spCurrentNode);

            if (dwProviderID == pProvider->GetID())
            {
                pNode->RemoveChild(spCurrentNode);
                break;
            }
        }

        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    }

Error:
    return hr;
}

 /*---------------------------------------------------------------------------
    CTapiServer::AddProvider()
        Adds a provider from the scope pane - UI only
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CTapiServer::AddProvider(ITFSNode * pNode, CTapiProvider * pProvider)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT     hr = hrOK;
    SPITFSNode  spProviderNode;
    CProviderHandler *pProviderHandler = new CProviderHandler(m_spTFSCompData);

    CreateContainerTFSNode(&spProviderNode,
                           &GUID_TapiProviderNodeType,
                           pProviderHandler,
                           pProviderHandler,
                           m_spNodeMgr);

    // Tell the handler to initialize any specific data
    pProviderHandler->InitData(*pProvider, m_spTapiInfo);
    pProviderHandler->InitializeNode(spProviderNode);
    
    pNode->AddChild(spProviderNode);
    pProviderHandler->Release();

    return hr;
}

DWORD CTapiServer::GetCachedLineBuffSize()
{
	return m_spTapiInfo->GetCachedLineBuffSize();
}

VOID CTapiServer::SetCachedLineBuffSize(DWORD dwLineSize)
{
	m_spTapiInfo->SetCachedLineBuffSize(dwLineSize);
}

DWORD CTapiServer::GetCachedPhoneBuffSize()
{
	return m_spTapiInfo->GetCachedPhoneBuffSize();
}

VOID CTapiServer::SetCachedPhoneBuffSize(DWORD dwPhoneSize)
{
	m_spTapiInfo->SetCachedPhoneBuffSize(dwPhoneSize);
}

BOOL CTapiServer::IsCacheDirty()
{
	return m_spTapiInfo->IsCacheDirty();
}

/*---------------------------------------------------------------------------
    Server manipulation functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CTapiServer::BuildDisplayName
        Builds the string that goes in the UI for this server
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CTapiServer::BuildDisplayName
(
    CString * pstrDisplayName
)
{
    if (pstrDisplayName)
    {
        *pstrDisplayName = GetName();
    }

    return hrOK;
}

/*---------------------------------------------------------------------------
    CTapiServer::SetAutoRefresh
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CTapiServer::SetAutoRefresh
(
    ITFSNode *  pNode,
    BOOL        bOn,
    DWORD       dwRefreshInterval
)
{
    BOOL bCurrentAutoRefresh = IsAutoRefreshEnabled();

    if (bCurrentAutoRefresh &&
        !bOn)
    {
        // turning off the timer
        g_TimerMgr.FreeTimer(m_StatsTimerId);
    }
    else
    if (!bCurrentAutoRefresh &&
        bOn)
    {
        // gotta turn on the timer
        m_StatsTimerId = g_TimerMgr.AllocateTimer(pNode, this, dwRefreshInterval, StatisticsTimerProc);
    }
    else
    if (bOn && 
        m_dwRefreshInterval != dwRefreshInterval)
    {
        // time to change the timer
        g_TimerMgr.ChangeInterval(m_StatsTimerId, dwRefreshInterval);
    }

    if (bOn)
        m_dwOptions |= TAPISNAP_OPTIONS_REFRESH;
    else
        m_dwOptions &= ~TAPISNAP_OPTIONS_REFRESH;

    m_dwRefreshInterval = dwRefreshInterval;

    return hrOK;
}

/*---------------------------------------------------------------------------
    CTapiServer::SetAutoRefresh
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
void
CTapiServer::SetExtensionName()
{
    CString strName;
    strName.LoadString(IDS_TELEPHONY);
    SetDisplayName(strName);
}

 /*!--------------------------------------------------------------------------
    CTapiServer::UpdateStandardVerbs
        Updates the standard verbs depending upon the state of the node
    Author: EricDav
 ---------------------------------------------------------------------------*/
void
CTapiServer::UpdateConsoleVerbs
(
    IConsoleVerb * pConsoleVerb,
    LONG_PTR       dwNodeType,
    BOOL           bMultiSelect
)
{
    BOOL                bStates[ARRAYLEN(g_ConsoleVerbs)];  
    MMC_BUTTON_STATE *  ButtonState;
    int                 i;
    
    if (bMultiSelect)
    {
        ButtonState = g_ConsoleVerbStatesMultiSel[dwNodeType];
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
    }
    else
    {
        ButtonState = g_ConsoleVerbStates[dwNodeType];
        switch (m_nState)
        {
            case loaded:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
                break;
    
            case notLoaded:
            case loading:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
                break;

            case unableToLoad:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
                bStates[MMC_VERB_REFRESH & 0x000F] = TRUE;
                bStates[MMC_VERB_DELETE & 0x000F] = TRUE;
                bStates[MMC_VERB_PROPERTIES & 0x000F] = TRUE;
                break;
        }
    }

    EnableVerbs(pConsoleVerb, ButtonState, bStates);
}

/*---------------------------------------------------------------------------
    Background thread functionality
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CTapiServer::OnCreateQuery
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
ITFSQueryObject* 
CTapiServer::OnCreateQuery(ITFSNode * pNode)
{
    CTapiServerQueryObj* pQuery = 
        new CTapiServerQueryObj(m_spTFSCompData, m_spNodeMgr);
    
    pQuery->m_strServer = GetName();
    pQuery->m_spTapiInfo.Set(m_spTapiInfo);
    pQuery->m_bStatsOnly = m_bStatsOnly;
    
    return pQuery;
}

/*---------------------------------------------------------------------------
    CTapiServerQueryObj::Execute()
        Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CTapiServerQueryObj::Execute()
{
    HRESULT   hr;

    if (m_bStatsOnly)
    {
        // we post this message esentially to get back on the main thread 
        // so that we can update the UI
        AddToQueue(NULL, TAPI_QDATA_REFRESH_STATS);
        return hrFalse;
    }

    m_spTapiInfo->SetComputerName(m_strServer);

    // close the connection with the server if there is one
    m_spTapiInfo->Destroy();

    // reset state
    m_spTapiInfo->Reset();

    hr = m_spTapiInfo->Initialize();
    if (FAILED(hr))
    {
        Trace1("CTapiServerQueryObj::Execute() - Initialize failed! %lx\n", hr);
        PostError(WIN32_FROM_HRESULT(hr));
        return hrFalse;
    }

    hr = m_spTapiInfo->EnumProviders();
    if (FAILED(hr))
    {
        Trace1("CTapiServerQueryObj::Execute() - EnumProviders failed! %lx\n", hr);
        PostError(WIN32_FROM_HRESULT(hr));
        return hrFalse;
    }
    else
    {
        hr = m_spTapiInfo->EnumAvailableProviders();
        if (FAILED(hr))
        {
            Trace1("CTapiServerQueryObj::Execute() - EnumAvailableProviders failed! %lx\n", hr);
            PostError(WIN32_FROM_HRESULT(hr));
            return hrFalse;
        }
        else
        {
        }
    }

    CTapiConfigInfo tapiConfigInfo;

    hr = m_spTapiInfo->EnumConfigInfo();
    if (FAILED(hr))
    {
        Trace1("CTapiServerQueryObj::Execute() - EnumConfigInfo failed! %lx\n", hr);
        PostError(WIN32_FROM_HRESULT(hr));
        return hrFalse;
    }
    else
    {
    }

    hr = m_spTapiInfo->EnumDevices(DEVICE_LINE);
    if (FAILED(hr))
    {
        Trace1("CTapiServerQueryObj::Execute() - EnumDevices(DEVICE_LINE) failed! %lx\n", hr);
        PostError(WIN32_FROM_HRESULT(hr));
        return hrFalse;
    }
    else
    {
    }

    hr = m_spTapiInfo->EnumDevices(DEVICE_PHONE);
    if (FAILED(hr))
    {
        Trace1("CTapiServerQueryObj::Execute() - EnumDevices(DEVICE_PHONE) failed! %lx\n", hr);
        PostError(WIN32_FROM_HRESULT(hr));
        return hrFalse;
    }
    else
    {
    }

    //
    for (int i = 0; i < m_spTapiInfo->GetProviderCount(); i++)
    {
        CTapiProvider tapiProvider;
        SPITFSNode spProviderNode;
        CProviderHandler *pProviderHandler = new CProviderHandler(m_spTFSCompData);

        CreateContainerTFSNode(&spProviderNode,
                               &GUID_TapiProviderNodeType,
                               pProviderHandler,
                               pProviderHandler,
                               m_spNodeMgr);

        // Tell the handler to initialize any specific data
        m_spTapiInfo->GetProviderInfo(&tapiProvider, i);

        pProviderHandler->InitData(tapiProvider, m_spTapiInfo);
        pProviderHandler->InitializeNode(spProviderNode);
        
        AddToQueue(spProviderNode);
        pProviderHandler->Release();
    }


    return hrFalse;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\tapicomp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    tapicomp.h
        This file contains the derived prototypes from CComponent
        and CComponentData for the TAPI admin snapin.

    FILE HISTORY:
        
*/

#ifndef _TAPICOMP_H
#define _TAPICOMP_H

#include "resource.h"       // main symbols

#ifndef __mmc_h__
#include <mmc.h>
#endif

#ifndef _COMPONT_H_
#include "compont.h"
#endif

#ifndef _XSTREAM_H
#include "xstream.h"
#endif

#define COLORREF_PINK   0x00FF00FF

//  Use FormatMessage() to get a system error message
LONG GetSystemMessage ( UINT nId, TCHAR * chBuffer, int cbBuffSize ) ;

BOOL LoadMessage (UINT nIdPrompt, TCHAR * chMsg, int nMsgSize);

//  Surrogate AfxMessageBox replacement for error message filtering.
int TapiMessageBox(UINT nIdPrompt, 
                   UINT nType = MB_OK, 
                   const TCHAR * pszSuffixString = NULL,
                   UINT nHelpContext = -1);

int TapiMessageBoxEx(UINT    nIdPrompt, 
                     LPCTSTR pszPrefixMessage,
                     UINT    nType = MB_OK, 
                     UINT    nHelpContext = -1);

enum TAPISTRM_TAG
{
    TAPISTRM_TAG_VERSION =                  XFER_TAG(1, XFER_DWORD),
    TAPISTRM_TAG_VERSIONADMIN =             XFER_TAG(2, XFER_DWORD),
    TAPISTRM_TAG_SERVER_NAME =              XFER_TAG(3, XFER_STRING_ARRAY),
    TAPISTRM_TAG_SERVER_REFRESH_INTERVAL =  XFER_TAG(4, XFER_DWORD_ARRAY),
    TAPISTRM_TAG_COLUMN_INFO =              XFER_TAG(5, XFER_DWORD_ARRAY),
    TAPISTRM_TAG_SERVER_OPTIONS =           XFER_TAG(6, XFER_DWORD_ARRAY),
    TAPISTRM_TAG_SERVER_LINE_SIZE =         XFER_TAG(7, XFER_DWORD_ARRAY),
    TAPISTRM_TAG_SERVER_PHONE_SIZE =        XFER_TAG(8, XFER_DWORD_ARRAY)
};

/////////////////////////////////////////////////////////////////////////////
// CTapiComponentData

class CTapiComponentData :
    public CComponentData,
    public CComObjectRoot
{
public:
    
BEGIN_COM_MAP(CTapiComponentData)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()
            
    // These are the interfaces that we MUST implement

    // We will implement our common behavior here, with the derived
    // classes implementing the specific behavior.
    DeclareIPersistStreamInitMembers(IMPL)
    DeclareITFSCompDataCallbackMembers(IMPL)

    CTapiComponentData();

    HRESULT FinalConstruct();
    void FinalRelease();
    
protected:
    SPITFSNodeMgr   m_spNodeMgr;
    SPITFSNode      m_spRootNode;

// Notify handler declarations
private:
};

/////////////////////////////////////////////////////////////////////////////
// CTapiComponent
class CTapiComponent : 
    public TFSComponent
{
public:
    CTapiComponent();
    ~CTapiComponent();

    STDMETHOD(InitializeBitmaps)(MMC_COOKIE cookie);
    STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar);
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param); 
    STDMETHOD(QueryDataObject)(MMC_COOKIE           cookie, 
                               DATA_OBJECT_TYPES    type,
                               LPDATAOBJECT*        ppDataObject);
    STDMETHOD(OnSnapinHelp)(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param);

//Attributes
private:
    SPIToolbar          m_spToolbar;    // Toolbar
    CBitmap*            m_pbmpToolbar;  // Imagelist for toolbar
};

/*---------------------------------------------------------------------------
    This is how the DHCP snapin implements its extension functionality.
    It actually exposes two interfaces that are CoCreate-able.  One is the 
    primary interface, the other the extension interface.
    
    Author: EricDav
 ---------------------------------------------------------------------------*/
class CTapiComponentDataPrimary : public CTapiComponentData,
    public CComCoClass<CTapiComponentDataPrimary, &CLSID_TapiSnapin>
{
public:
    DECLARE_REGISTRY(CTapiComponentDataPrimary, 
                     _T("TelephonySnapin.TelephonySnapin.1"), 
                     _T("TelephonySnapin.TelephonySnapin"), 
                     IDS_SNAPIN_DESC, THREADFLAGS_BOTH)

    STDMETHODIMP_(const CLSID *)GetCoClassID() { return &CLSID_TapiSnapin; }
};


class CTapiComponentDataExtension : public CTapiComponentData,
    public CComCoClass<CTapiComponentDataExtension, &CLSID_TapiSnapinExtension>
{
public:
    DECLARE_REGISTRY(CTapiComponentDataExtension, 
                     _T("TelephonySnapinExtension.TelephonySnapinExtension.1"), 
                     _T("TelephonySnapinExtension.TelephonySnapinExtension"), 
                     IDS_SNAPIN_DESC, THREADFLAGS_BOTH)
    STDMETHODIMP_(const CLSID *)GetCoClassID() { return &CLSID_TapiSnapinExtension; }
};


/*---------------------------------------------------------------------------
    This is the derived class for handling the IAbout interface from MMC
    Author: EricDav
 ---------------------------------------------------------------------------*/
class CTapiAbout : 
    public CAbout,
    public CComCoClass<CTapiAbout, &CLSID_TapiSnapinAbout>
{
public:
DECLARE_REGISTRY(CTapiAbout, _T("TelephonySnapin.About.1"), 
                             _T("TelephonySnapin.About"), 
                             IDS_SNAPIN_DESC, THREADFLAGS_BOTH)

BEGIN_COM_MAP(CTapiAbout)
    COM_INTERFACE_ENTRY(ISnapinAbout) // Must have one static entry
    COM_INTERFACE_ENTRY_CHAIN(CAbout) // chain to the base class
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CTapiAbout)

// these must be overridden to provide values to the base class
protected:
    virtual UINT GetAboutDescriptionId() { return IDS_ABOUT_DESCRIPTION; }
    virtual UINT GetAboutProviderId()    { return IDS_ABOUT_PROVIDER; }
    virtual UINT GetAboutVersionId()     { return IDS_ABOUT_VERSION; }
    virtual UINT GetAboutIconId()        { return IDI_TAPI_SNAPIN; }

    virtual UINT GetSmallRootId()        { return IDB_ROOT_SMALL; }
    virtual UINT GetSmallOpenRootId()    { return IDB_ROOT_SMALL; }
    virtual UINT GetLargeRootId()        { return IDB_ROOT_LARGE; }
    virtual COLORREF GetLargeColorMask() { return (COLORREF) COLORREF_PINK; } 

};
    

#endif _TAPICOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\server.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    server.h

    FILE HISTORY:
        
*/

#ifndef _SERVER_H
#define _SERVER_H

#ifndef _TAPIHAND_H
#include "tapihand.h"
#endif

#ifndef _TAPIDB_H
#include "tapidb.h"
#endif

// options for the server outside of the API
#define TAPISNAP_OPTIONS_REFRESH            0x00000001
#define TAPISNAP_OPTIONS_EXTENSION          0x00000002
#define TAPISNAP_OPTIONS_LOCAL              0x00000004

// custom data types for query object
#define TAPI_QDATA_REFRESH_STATS            0x00000001

class CTapiServer;

class CTimerDesc
{
public:
    SPITFSNode      spNode;
    CTapiServer *   pServer;
    UINT_PTR        uTimer;
    TIMERPROC       timerProc;
};

typedef CArray<CTimerDesc *, CTimerDesc *> CTimerArrayBase;

class CTimerMgr : CTimerArrayBase
{
public:
    CTimerMgr();
    ~CTimerMgr();

public:
    int                 AllocateTimer(ITFSNode * pNode, CTapiServer * pServer, UINT uTimerValue, TIMERPROC TimerProc);
    void                FreeTimer(UINT_PTR uEventId);
    void                ChangeInterval(UINT_PTR uEventId, UINT uNewInterval);
    CTimerDesc *        GetTimerDesc(UINT_PTR uEventId);
    CCriticalSection    m_csTimerMgr;
};

/*---------------------------------------------------------------------------
    Class:  CTapiServer
 ---------------------------------------------------------------------------*/
class CTapiServer : public CMTTapiHandler
{
public:
    CTapiServer(ITFSComponentData* pTFSComponentData);
    ~CTapiServer();

// Interface
public:
    // base handler functionality we override
    OVERRIDE_NodeHandler_HasPropertyPages();
    OVERRIDE_NodeHandler_CreatePropertyPages();
    OVERRIDE_NodeHandler_OnAddMenuItems();
    OVERRIDE_NodeHandler_OnCommand();
    OVERRIDE_NodeHandler_GetString()
            { return (nCol == 0) ? GetDisplayName() : NULL; }
    
    // Choose which messages we want to handle
    OVERRIDE_BaseHandlerNotify_OnCreateNodeId2();
    OVERRIDE_BaseHandlerNotify_OnDelete();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();    

    // Result handler functionality we override

    // CMTHandler overridden
    virtual HRESULT OnRefresh(ITFSNode *, LPDATAOBJECT, DWORD, LPARAM, LPARAM);

public:
    // CMTTapiHandler functionality
    virtual HRESULT  InitializeNode(ITFSNode * pNode);
    virtual int      GetImageIndex(BOOL bOpenImage);
    ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);
    virtual void     OnHaveData(ITFSNode * pParentNode, ITFSNode * pNode);
    virtual void     OnHaveData(ITFSNode * pParentNode, DWORD dwData, DWORD dwType);

    STDMETHOD(OnNotifyExiting)(LPARAM);

    virtual void     GetErrorPrefix(ITFSNode * pNode, CString * pstrMessage)
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        AfxFormatString1(*pstrMessage, IDS_ERR_SERVER_NODE, GetDisplayName());
    }
    
    virtual void    UpdateConsoleVerbs(IConsoleVerb * pConsoleVerb, LONG_PTR dwNodeType, BOOL bMultiSelect = FALSE);

public:
    // implementation specific  
    HRESULT BuildDisplayName(CString * pstrDisplayName);

    void    SetName(LPCTSTR pName) { m_strServerAddress = pName; }
    LPCTSTR GetName() { return m_strServerAddress; }

    HRESULT OnRefreshStats(ITFSNode *   pNode,
                           LPDATAOBJECT pDataObject,
                           DWORD        dwType,
                           LPARAM       arg,
                           LPARAM       param);

    void    SetOptions(DWORD dwOptions) { m_dwOptions = dwOptions; }
    DWORD   GetOptions() { return m_dwOptions; }

    HRESULT SetAutoRefresh(ITFSNode *  pNode, BOOL bOn, DWORD dwRefreshInterval);
    BOOL    IsAutoRefreshEnabled() { return m_dwOptions & TAPISNAP_OPTIONS_REFRESH; }
    DWORD   GetAutoRefreshInterval() { return m_dwRefreshInterval; }
    
    DWORD   GetCachedLineBuffSize();
    DWORD   GetCachedPhoneBuffSize();

    VOID    SetCachedLineBuffSize(DWORD dwLineSize);
    VOID    SetCachedPhoneBuffSize(DWORD dwPhoneSize);

    BOOL    IsCacheDirty();

    HRESULT AddProvider(ITFSNode * pNode, CTapiProvider * pProvider);
    HRESULT RemoveProvider(ITFSNode * pNode, DWORD dwProviderID);

    void    SetExtensionName();

// Implementation
private:
    // Command handlers
    HRESULT OnAddProvider(ITFSNode * pNode);
    HRESULT OnEnableServer(ITFSNode * pNode);
    HRESULT OnDelete(ITFSNode * pNode);

public:
    BOOL                m_bStatsOnly;

private:
    CString             m_strServerAddress;
    SPITapiInfo         m_spTapiInfo;
    
    DWORD               m_dwOptions;
    DWORD               m_dwRefreshInterval;
    
    int                 m_StatsTimerId;
};



/*---------------------------------------------------------------------------
    Class:  CTapiServerQueryObj
 ---------------------------------------------------------------------------*/
class CTapiServerQueryObj : public CTapiQueryObj
{
public:
    CTapiServerQueryObj(ITFSComponentData * pTFSComponentData,
                        ITFSNodeMgr *       pNodeMgr) 
            : CTapiQueryObj(pTFSComponentData, pNodeMgr) {};
    
    STDMETHODIMP Execute();
    
public:
    SPITapiInfo         m_spTapiInfo;
    BOOL                m_bStatsOnly;
};


#endif _SERVER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\servpp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    Servpp.h   
        Server properties implementation file

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "Servpp.h"
#include "server.h"
#include "service.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const DWORD c_dwChangableFlagMask = 
    TAPISERVERCONFIGFLAGS_ENABLESERVER |
    TAPISERVERCONFIGFLAGS_SETACCOUNT |          
    TAPISERVERCONFIGFLAGS_SETTAPIADMINISTRATORS;

const TCHAR szPasswordNull[] = _T("               ");   // Empty password

BOOL
IsLocalSystemAccount(LPCTSTR pszAccount)
{
 BOOL						 bRet = FALSE;
 DWORD                       dwSidSize = 128;
 DWORD                       dwDomainNameSize = 128;
 SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;
 PSID                        pLocalSid = NULL;
 PSID                        pLocalServiceSid = NULL;
 PSID                        pNetworkServiceSid = NULL;
 PSID                        accountSid = NULL;
 SID_NAME_USE                SidType;
 LPWSTR                      pwszDomainName;


    do
    {
        // Attempt to allocate a buffer for the SID. Note that apparently in the
        // absence of any error theData->m_Sid is freed only when theData goes
        // out of scope.

        accountSid = LocalAlloc( LMEM_FIXED, dwSidSize );
        pwszDomainName = (LPWSTR) LocalAlloc( LMEM_FIXED, dwDomainNameSize * sizeof(WCHAR) );

        // Was space allocated for the SID and domain name successfully?

        if ( accountSid == NULL || pwszDomainName == NULL )
        {
            if ( accountSid != NULL )
            {
                LocalFree( accountSid );
                accountSid = NULL;
            }

            if ( pwszDomainName != NULL )
            {
                LocalFree( pwszDomainName );
                pwszDomainName = NULL;
            }

            goto ExitHere;
        }

        // Attempt to Retrieve the SID and domain name. If LookupAccountName failes
        // because of insufficient buffer size(s) dwSidSize and dwDomainNameSize
        // will be set correctly for the next attempt.

        if (LookupAccountName (NULL,
                               pszAccount,
                               accountSid,
                               &dwSidSize,
                               pwszDomainName,
                               &dwDomainNameSize,
                               &SidType ))
        {
            break;
        }

        if (ERROR_INSUFFICIENT_BUFFER != GetLastError ())
        {
            goto ExitHere;
        }

        // domain name isn't needed at any time
        LocalFree (pwszDomainName);
        LocalFree (accountSid);

    } while ( TRUE );

    if (!AllocateAndInitializeSid (
        &NtAuthority, 
        1, 
        SECURITY_LOCAL_SYSTEM_RID, 
        0, 0, 0, 0, 0, 0, 0, 
        &pLocalSid) ||
        !AllocateAndInitializeSid (
        &NtAuthority, 
        1, 
        SECURITY_LOCAL_SERVICE_RID, 
        0, 0, 0, 0, 0, 0, 0, 
        &pLocalServiceSid) ||
        !AllocateAndInitializeSid (
        &NtAuthority, 
        1, 
        SECURITY_NETWORK_SERVICE_RID, 
        0, 0, 0, 0, 0, 0, 0, 
        &pNetworkServiceSid)
        )
    {
        goto ExitHere;
    }

    if (EqualSid(pLocalSid, accountSid) ||
        EqualSid(pLocalServiceSid, accountSid) ||
        EqualSid(pNetworkServiceSid, accountSid)) 
    {
        bRet = TRUE;
    } 

ExitHere:

    if (NULL != pwszDomainName)
    {
        LocalFree (pwszDomainName);
    }

    if (NULL != accountSid) 
    {
        LocalFree (accountSid);
    }

    if (NULL != pLocalSid) 
    {
        FreeSid(pLocalSid);
    }
    if (NULL != pLocalServiceSid)
    {
        FreeSid (pLocalServiceSid);
    }
    if (NULL != pNetworkServiceSid)
    {
        FreeSid (pNetworkServiceSid);
    }

    return bRet;
}

/////////////////////////////////////////////////////////////////////////////
//
// CServerProperties holder
//
/////////////////////////////////////////////////////////////////////////////
CServerProperties::CServerProperties
(
    ITFSNode *          pNode,
    IComponentData *    pComponentData,
    ITFSComponentData * pTFSCompData,
    ITapiInfo *         pTapiInfo,
    LPCTSTR             pszSheetName,
    BOOL                fTapiInfoLoaded
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName),
    m_fTapiInfoLoaded(fTapiInfoLoaded)
{
    //ASSERT(pFolderNode == GetContainerNode());

    m_bAutoDeletePages = FALSE; // we have the pages as embedded members

    AddPageToList((CPropertyPageBase*) &m_pageSetup);
    AddPageToList((CPropertyPageBase*) &m_pageRefresh);

    Assert(pTFSCompData != NULL);
    m_spTFSCompData.Set(pTFSCompData);
    
    m_spTapiInfo.Set(pTapiInfo);

    m_hScManager = NULL;
    m_paQSC = NULL;

    m_pszServiceName = TAPI_SERVICE_NAME;

}

CServerProperties::~CServerProperties()
{
    // Close the service control manager database
    if (m_hScManager != NULL)
    {
        (void)::CloseServiceHandle(m_hScManager);
    }

    // Free the allocated pointers
    if (m_paQSC)
        delete m_paQSC;
    
    RemovePageFromList((CPropertyPageBase*) &m_pageSetup, FALSE);
    RemovePageFromList((CPropertyPageBase*) &m_pageRefresh, FALSE);
}

BOOL
CServerProperties::FInit()
{
    // get the service account information here
    SC_HANDLE hService = NULL;
    DWORD cbBytesNeeded = 0;
    BOOL fSuccess = TRUE;
    BOOL f;
    DWORD dwErr;

    m_uFlags = 0;

    if (!FOpenScManager())
    {
        // Unable to open service control database
        return FALSE;
    }

    /*
    **  Open service with querying access-control
    */
    hService = ::OpenService(m_hScManager,
                             m_pszServiceName,
                             SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG);
    if (hService == NULL)
    {
        TapiMessageBox(::GetLastError());
        return FALSE;
    }

    /*
    **  Query the service status
    */
    Trace1("# QueryServiceStatus(%s)...\n", m_pszServiceName);
    f = ::QueryServiceStatus(hService, OUT &m_SS);
    if (f)
    {
        //m_uFlags |= mskfValidSS;
    }
    else
    {
        ::TapiMessageBox(::GetLastError());
        fSuccess = FALSE;
    }

    /*
    **  Query the service config
    */
    Trace1("# QueryServiceConfig(%s)...\n", m_pszServiceName);
    f = ::QueryServiceConfig(hService,
                             NULL,
                             0,
                             OUT &cbBytesNeeded);   // Compute how many bytes we need to allocate

    cbBytesNeeded += 100;       // Add extra bytes (just in case)
    delete m_paQSC;             // Free previously allocated memory (if any)
    
    m_paQSC = (QUERY_SERVICE_CONFIG *) new BYTE[cbBytesNeeded];
    f = ::QueryServiceConfig(hService,
                             OUT m_paQSC,
                             cbBytesNeeded,
                             OUT &cbBytesNeeded);
    if (f)
    {
        m_strServiceDisplayName = m_paQSC->lpDisplayName;
        m_strLogOnAccountName = m_paQSC->lpServiceStartName;
    }
    else
    {
        ::TapiMessageBox(::GetLastError());
        fSuccess = FALSE;
    }

    VERIFY(::CloseServiceHandle(hService));
    return fSuccess;
}

/////////////////////////////////////////////////////////////////////
//  FOpenScManager()
//
//  Open the service control manager database (if not already opened).
//  The idea for such a function is to recover from a broken connection.
//
//  Return TRUE if the service control database was opened successfully,
//  othersise false.
//
BOOL
CServerProperties::FOpenScManager()
{
    if (m_hScManager == NULL)
    {
        m_hScManager = ::OpenSCManager(m_strMachineName,
                                       NULL,
                                       SC_MANAGER_CONNECT);
    }
    
    if (m_hScManager == NULL)
    {
        TapiMessageBox(::GetLastError());
        return FALSE;
    }
    
    return TRUE;
} // CServicePropertyData::FOpenScManager()

BOOL
CServerProperties::FUpdateServiceInfo(LPCTSTR pszName, LPCTSTR pszPassword, DWORD dwStartType)
{
    SC_HANDLE hService = NULL;
    BOOL fSuccess = TRUE;
    BOOL f;
    DWORD dwServiceType = 0;

    Trace1("INFO: Updating data for service %s...\n", (LPCTSTR)m_pszServiceName);
    // Re-open service control manager (in case it was closed)
    if (!FOpenScManager())
    {
        return FALSE;
    }

    /*
    **  Open service with write access
    **
    **  CODEWORK Could provide a more specific error message
    **    if SERVICE_CHANGE_CONFIG is available but not SERVICE_START
    */
    hService = ::OpenService(m_hScManager,
                             m_pszServiceName,
                             SERVICE_CHANGE_CONFIG);
    if (hService == NULL)
    {
        TapiMessageBox(::GetLastError());
        return FALSE;
    }

    Trace1("# ChangeServiceConfig(%s)...\n", m_pszServiceName);
    
    if (pszName)
    {
        if (IsLocalSystemAccount(pszName))
        {
            pszPassword = szPasswordNull;
        }
        dwServiceType = m_paQSC->dwServiceType & ~SERVICE_INTERACTIVE_PROCESS;
    }
    else
    {
        dwServiceType = SERVICE_NO_CHANGE;
    }

    f = ::ChangeServiceConfig(hService,           // Handle to service 
                              dwServiceType,      // Type of service 
                              dwStartType,        // When/How to start service
                              SERVICE_NO_CHANGE,  // dwErrorControl - severity if service fails to start 
                              NULL,               // Pointer to service binary file name 
                              NULL,               // lpLoadOrderGroup - pointer to load ordering group name 
                              NULL,               // lpdwTagId - pointer to variable to get tag identifier 
                              NULL,               // lpDependencies - pointer to array of dependency names 
                              pszName,            // Pointer to account name of service 
                              pszPassword,        // Pointer to password for service account
                              m_strServiceDisplayName);
            
    if (!f)
    {
        DWORD dwErr = ::GetLastError();
        Assert(dwErr != ERROR_SUCCESS);
        Trace2("ERR: ChangeServiceConfig(%s) failed. err= %u.\n", m_pszServiceName, dwErr);
        TapiMessageBox(dwErr);
        fSuccess = FALSE;
    }
    else
    {
        m_strLogOnAccountName = pszName;

        // if pszName is null, we aren't changing the account info, so don't check 
        // the logon as service info
        if (pszName && !IsLocalSystemAccount(pszName))
        {
            /*
            **  Make sure there is an LSA account with POLICY_MODE_SERVICE privilege
            **  This function reports its own errors, failure is only advisory
            */
            FCheckLSAAccount();
        } 
    }

    VERIFY(::CloseServiceHandle(hService));

    return fSuccess;
}

//Check if the user has the write access on service config info
BOOL 
CServerProperties::FHasServiceControl()
{
    BOOL fRet = FALSE;

    if (FIsTapiInfoLoaded())
    {
        fRet = m_spTapiInfo->FHasServiceControl();
    }
    else 
    {
        if (!FOpenScManager())
        {
            fRet = FALSE;
        }
        else
        {
            SC_HANDLE hService = NULL;

            hService = ::OpenService(m_hScManager,
                             m_pszServiceName,
                             SERVICE_CHANGE_CONFIG);

            fRet = (hService != NULL);
            
            if (hService)
            {
                VERIFY(::CloseServiceHandle(hService));
            }
        }
    }

    return fRet;
}

/////////////////////////////////////////////////////////////////////////////
// CServerPropRefresh property page

IMPLEMENT_DYNCREATE(CServerPropRefresh, CPropertyPageBase)

CServerPropRefresh::CServerPropRefresh() : CPropertyPageBase(CServerPropRefresh::IDD)
{
    //{{AFX_DATA_INIT(CServerPropRefresh)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

CServerPropRefresh::~CServerPropRefresh()
{
}

void CServerPropRefresh::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPageBase::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CServerPropRefresh)
    DDX_Control(pDX, IDC_EDIT_MINUTES, m_editMinutes);
    DDX_Control(pDX, IDC_EDIT_HOURS, m_editHours);
    DDX_Control(pDX, IDC_SPIN_MINUTES, m_spinMinutes);
    DDX_Control(pDX, IDC_SPIN_HOURS, m_spinHours);
    DDX_Control(pDX, IDC_CHECK_ENABLE_STATS, m_checkEnableStats);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CServerPropRefresh, CPropertyPageBase)
    //{{AFX_MSG_MAP(CServerPropRefresh)
    ON_BN_CLICKED(IDC_CHECK_ENABLE_STATS, OnCheckEnableStats)
    ON_EN_KILLFOCUS(IDC_EDIT_HOURS, OnKillfocusEditHours)
    ON_EN_KILLFOCUS(IDC_EDIT_MINUTES, OnKillfocusEditMinutes)
    ON_EN_CHANGE(IDC_EDIT_HOURS, OnChangeEditHours)
    ON_EN_CHANGE(IDC_EDIT_MINUTES, OnChangeEditMinutes)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServerPropRefresh message handlers

BOOL CServerPropRefresh::OnInitDialog() 
{
    CPropertyPageBase::OnInitDialog();
    
    m_spinHours.SetRange(0, AUTO_REFRESH_HOURS_MAX);
    m_spinMinutes.SetRange(0, AUTO_REFRESH_MINUTES_MAX);

    m_checkEnableStats.SetCheck(m_bAutoRefresh);

    // update the refresh interval
    int nHours, nMinutes;
    DWORD dwRefreshInterval = m_dwRefreshInterval;

    nHours = dwRefreshInterval / MILLISEC_PER_HOUR;
    dwRefreshInterval -= nHours * MILLISEC_PER_HOUR;

    nMinutes = dwRefreshInterval / MILLISEC_PER_MINUTE;
    dwRefreshInterval -= nMinutes * MILLISEC_PER_MINUTE;

    m_spinHours.SetPos(nHours);
    m_spinMinutes.SetPos(nMinutes);

    m_editHours.LimitText(2);
    m_editMinutes.LimitText(2);

    // set the button states
    UpdateButtons();

    SetDirty(FALSE);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CServerPropRefresh::UpdateButtons()
{
    int nCheck = m_checkEnableStats.GetCheck();

    GetDlgItem(IDC_EDIT_HOURS)->EnableWindow(nCheck != 0);
    GetDlgItem(IDC_EDIT_MINUTES)->EnableWindow(nCheck != 0);

    GetDlgItem(IDC_SPIN_HOURS)->EnableWindow(nCheck != 0);
    GetDlgItem(IDC_SPIN_MINUTES)->EnableWindow(nCheck != 0);
}

void CServerPropRefresh::OnCheckEnableStats() 
{
    SetDirty(TRUE);
    
    UpdateButtons();    
}

void CServerPropRefresh::OnKillfocusEditHours() 
{
}

void CServerPropRefresh::OnKillfocusEditMinutes() 
{
}

void CServerPropRefresh::OnChangeEditHours() 
{
    ValidateHours();
    SetDirty(TRUE);
}

void CServerPropRefresh::OnChangeEditMinutes() 
{
    ValidateMinutes();
    SetDirty(TRUE);
}

void CServerPropRefresh::ValidateHours() 
{
    CString strValue;
    int nValue;

    if (m_editHours.GetSafeHwnd() != NULL)
    {
        m_editHours.GetWindowText(strValue);
        if (!strValue.IsEmpty())
        {
            nValue = _ttoi(strValue);

            if ((nValue >= 0) &&
                (nValue <= AUTO_REFRESH_HOURS_MAX))
            {
                // everything is good
                return;
            }

            if (nValue > AUTO_REFRESH_HOURS_MAX)
                nValue = AUTO_REFRESH_HOURS_MAX;
            else
            if (nValue < 0)
                nValue = 0;

            // set the new value and beep
            CString strText;
            LPTSTR pBuf = strText.GetBuffer(5);
            
            _itot(nValue, pBuf, 10);
            strText.ReleaseBuffer();

            MessageBeep(MB_ICONEXCLAMATION);

            m_editHours.SetWindowText(strText);
            
            m_editHours.SetSel(0, -1);
            m_editHours.SetFocus();
        }
    }
}

void CServerPropRefresh::ValidateMinutes() 
{
    CString strValue;
    int nValue;

    if (m_editMinutes.GetSafeHwnd() != NULL)
    {
        m_editMinutes.GetWindowText(strValue);
        if (!strValue.IsEmpty())
        {
            nValue = _ttoi(strValue);

            if ((nValue >= 0) &&
                (nValue <= AUTO_REFRESH_MINUTES_MAX))
            {
                // everything is good
                return;
            }
            
            if (nValue > AUTO_REFRESH_MINUTES_MAX)
                nValue = AUTO_REFRESH_MINUTES_MAX;
            else
            if (nValue < 0)
                nValue = 0;

            CString strText;
            LPTSTR pBuf = strText.GetBuffer(5);
            
            _itot(nValue, pBuf, 10);
            strText.ReleaseBuffer();

            MessageBeep(MB_ICONEXCLAMATION);

            m_editMinutes.SetWindowText(strText);
            
            m_editMinutes.SetSel(0, -1);
            m_editMinutes.SetFocus();
        }
    }
}

BOOL CServerPropRefresh::OnApply() 
{
    if (!IsDirty())
        return TRUE;

    UpdateData();

    m_bAutoRefresh = (m_checkEnableStats.GetCheck() == 1) ? TRUE : FALSE;

    int nHours = m_spinHours.GetPos();
    int nMinutes = m_spinMinutes.GetPos();
    
    m_dwRefreshInterval = nHours * MILLISEC_PER_HOUR;
    m_dwRefreshInterval += nMinutes * MILLISEC_PER_MINUTE;

    if (m_bAutoRefresh && m_dwRefreshInterval == 0)
    {
        CString strMessage;
        
        AfxMessageBox(IDS_ERR_AUTO_REFRESH_ZERO);
        m_editHours.SetSel(0, -1);
        m_editHours.SetFocus();

        return FALSE;
    }
    
    BOOL bRet = CPropertyPageBase::OnApply();

    if (bRet == FALSE)
    {
        // Something bad happened... grab the error code
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        ::TapiMessageBox(GetHolder()->GetError());
    }

    return bRet;
}

BOOL CServerPropRefresh::OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask)
{
    SPITFSNode      spNode;
    CTapiServer *   pServer;
    DWORD           dwError;

    // do stuff here.
    BEGIN_WAIT_CURSOR;

    spNode = GetHolder()->GetNode();
    pServer = GETHANDLER(CTapiServer, spNode);

    pServer->SetAutoRefresh(spNode, m_bAutoRefresh, m_dwRefreshInterval);

    SPITFSNodeMgr   spNodeMgr;
    SPITFSNode spRootNode;

    spNode->GetNodeMgr(&spNodeMgr);
    spNodeMgr->GetRootNode(&spRootNode);
    spRootNode->SetData(TFS_DATA_DIRTY, TRUE);

    END_WAIT_CURSOR;
    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CServerPropSetup property page

IMPLEMENT_DYNCREATE(CServerPropSetup, CPropertyPageBase)

CServerPropSetup::CServerPropSetup() : CPropertyPageBase(CServerPropSetup::IDD)
{
    //{{AFX_DATA_INIT(CServerPropSetup)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    
    m_dwNewFlags = 0;
}

CServerPropSetup::~CServerPropSetup()
{
}

void CServerPropSetup::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CServerPropSetup)
    DDX_Control(pDX, IDC_LIST_ADMINS, m_listAdmins);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CServerPropSetup, CPropertyPageBase)
    //{{AFX_MSG_MAP(CServerPropSetup)
    ON_BN_CLICKED(IDC_BUTTON_ADD_ADMIN, OnButtonAdd)
    ON_BN_CLICKED(IDC_BUTTON_CHOOSE_USER, OnButtonChooseUser)
    ON_BN_CLICKED(IDC_BUTTON_REMOVE_ADMIN, OnButtonRemove)
    ON_BN_CLICKED(IDC_CHECK_ENABLE_SERVER, OnCheckEnableServer)
    ON_EN_CHANGE(IDC_EDIT_NAME, OnChangeEditName)
    ON_EN_CHANGE(IDC_EDIT_PASSWORD, OnChangeEditPassword)
    ON_LBN_SELCHANGE(IDC_LIST_ADMINS, OnSelchangeListAdmins)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServerPropSetup message handlers

BOOL CServerPropSetup::OnInitDialog() 
{
    SPITapiInfo     spTapiInfo;
    CString         strName;
    HRESULT         hr = hrOK;

    CPropertyPageBase::OnInitDialog();

    CServerProperties * pServerProp = (CServerProperties * ) GetHolder();
    pServerProp->GetTapiInfo(&spTapiInfo);
    Assert(spTapiInfo);

    BOOL fIsNTS = TRUE;

    if (pServerProp->FIsServiceRunning())
    {
        fIsNTS = spTapiInfo->IsServer();

        hr = spTapiInfo->GetConfigInfo(&m_tapiConfigInfo);
        if (FAILED(hr))
        {
            Panic1("ServerPropSetup - GetConfigInfo failed! %x", hr);
        }

        // update the checkbox
        ((CButton *) GetDlgItem(IDC_CHECK_ENABLE_SERVER))->SetCheck(spTapiInfo->IsTapiServer());

        // now update any TAPI administrators
        for (int i = 0; i < m_tapiConfigInfo.m_arrayAdministrators.GetSize(); i++)
        {
            ((CListBox *) GetDlgItem(IDC_LIST_ADMINS))->AddString(m_tapiConfigInfo.m_arrayAdministrators[i].m_strName);
        }
        
    }
    else
    {
        // check to see if the machine is NTS  
        TFSIsNTServer(pServerProp->m_strMachineName, &fIsNTS);
    }

    if (fIsNTS)
    {
        // fill in the username and password
        strName = pServerProp->GetServiceAccountName();
        GetDlgItem(IDC_EDIT_NAME)->SetWindowText(strName);
        GetDlgItem(IDC_EDIT_PASSWORD)->SetWindowText(szPasswordNull);

        m_dwNewFlags = TAPISERVERCONFIGFLAGS_ISSERVER;
    }
    else
    {
        m_dwNewFlags = 0;
    }
    EnableButtons(fIsNTS);

    m_fRestartService = FALSE;
    m_dwInitFlags = m_tapiConfigInfo.m_dwFlags;

    SetDirty(FALSE);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CServerPropSetup::OnButtonAdd() 
{
    CGetUsers getUsers(TRUE);

    if (!getUsers.GetUsers(GetSafeHwnd()))
        return;

    for (int nCount = 0; nCount < getUsers.GetSize(); nCount++)
    {
        CUserInfo userTemp;

        userTemp = getUsers[nCount];

        BOOL fDuplicate = FALSE;
        for (int i = 0; i < m_tapiConfigInfo.m_arrayAdministrators.GetSize(); i++)
        {
            if (m_tapiConfigInfo.m_arrayAdministrators[i].m_strName.CompareNoCase(userTemp.m_strName) == 0)
            {
                fDuplicate = TRUE;
                break;
            }
        }

        if (!fDuplicate)
        {
            // add to the array
            int nIndex = (int)m_tapiConfigInfo.m_arrayAdministrators.Add(userTemp);

            // now add to the listbox
            m_listAdmins.AddString(m_tapiConfigInfo.m_arrayAdministrators[nIndex].m_strName);
        }
        else
        {
            // tell the user we're not adding this to the list
            CString strMessage;
            AfxFormatString1(strMessage, IDS_ADMIN_ALREADY_IN_LIST, userTemp.m_strName);
            AfxMessageBox(strMessage);
        }

        SetDirty(TRUE);
    }

    m_dwNewFlags |= TAPISERVERCONFIGFLAGS_SETTAPIADMINISTRATORS;

    EnableButtons();
}

void CServerPropSetup::OnButtonRemove() 
{
    CString strSelectedName;
    int nCurSel = m_listAdmins.GetCurSel();

    m_listAdmins.GetText(nCurSel, strSelectedName);

    // remove from the list
    for (int i = 0; i < m_tapiConfigInfo.m_arrayAdministrators.GetSize(); i++)
    {
        if (strSelectedName.Compare(m_tapiConfigInfo.m_arrayAdministrators[i].m_strName) == 0)
        {
            // found it.  remove from the list
            m_tapiConfigInfo.m_arrayAdministrators.RemoveAt(i);
            break;
        }
    }

    // now remove from the list box
    m_listAdmins.DeleteString(nCurSel);

    m_dwNewFlags |= TAPISERVERCONFIGFLAGS_SETTAPIADMINISTRATORS;

    SetDirty(TRUE);

    EnableButtons();
}

void CServerPropSetup::OnButtonChooseUser() 
{
    CGetUsers getUsers;

    if (!getUsers.GetUsers(GetSafeHwnd()))
        return;

    if (0 == getUsers.GetSize())
        return;

    CUserInfo userTemp;

    userTemp = getUsers[0];

    GetDlgItem(IDC_EDIT_NAME)->SetWindowText(userTemp.m_strName);
            
    m_dwNewFlags |= TAPISERVERCONFIGFLAGS_SETACCOUNT;

    SetDirty(TRUE);
    EnableButtons();
}

void CServerPropSetup::OnCheckEnableServer() 
{
    if (((CButton *) GetDlgItem(IDC_CHECK_ENABLE_SERVER))->GetCheck())
    {
        m_dwNewFlags |= TAPISERVERCONFIGFLAGS_ENABLESERVER;
    }
    else
    {
        m_dwNewFlags &= ~TAPISERVERCONFIGFLAGS_ENABLESERVER;
    }

    EnableButtons ();

    SetDirty(TRUE); 
}

void CServerPropSetup::OnChangeEditName() 
{
    m_dwNewFlags |= TAPISERVERCONFIGFLAGS_SETACCOUNT;

    SetDirty(TRUE); 
}

void CServerPropSetup::OnChangeEditPassword() 
{
    m_dwNewFlags |= TAPISERVERCONFIGFLAGS_SETACCOUNT;
    
    m_fRestartService = TRUE;

    SetDirty(TRUE); 
}

void CServerPropSetup::OnSelchangeListAdmins() 
{
    EnableButtons();    
}

void CServerPropSetup::EnableButtons(BOOL fIsNtServer)
{
    BOOL fServiceRunning = ((CServerProperties *) GetHolder())->FIsServiceRunning();
    
    //if we are unable to get the write access to tapisrv service, we need to disable
    // some controls
    BOOL fHasServiceControl = ((CServerProperties *) GetHolder())->FHasServiceControl();

    //We enable the admin controls only if we sucessfully loaded the tapi info
    BOOL fTapiInfoLoaded = ((CServerProperties *) GetHolder())->FIsTapiInfoLoaded();

    BOOL fIsAdmin = ((CServerProperties *) GetHolder())->FIsAdmin();

    // if this isn't an NT server, disable all controls 
    if (!fIsNtServer)
        fServiceRunning = FALSE;
    
    //Enable the Admin controls only if 
    //(1) the service is running
    //(2) successfully loaded the tapi config info
    //(3) the user is a machine admin or tapi admin
    BOOL fEnableAdminControls = fServiceRunning && fTapiInfoLoaded && fIsAdmin;

    // enable the admin controls on
    GetDlgItem(IDC_STATIC_ADMINS)->EnableWindow(fEnableAdminControls);
    GetDlgItem(IDC_STATIC_NOTE)->EnableWindow(fEnableAdminControls);
    GetDlgItem(IDC_STATIC_LISTBOX)->EnableWindow(fEnableAdminControls);
    GetDlgItem(IDC_BUTTON_ADD_ADMIN)->EnableWindow(fEnableAdminControls);
    GetDlgItem(IDC_BUTTON_REMOVE_ADMIN)->EnableWindow(fEnableAdminControls);
    GetDlgItem(IDC_LIST_ADMINS)->EnableWindow(fEnableAdminControls);

    //If the user is not admin, then they don't have ServiceControl write access
    //So fHasServiceControl covers fIsAdmin
    
    GetDlgItem(IDC_CHECK_ENABLE_SERVER)->EnableWindow(fServiceRunning 
                                                    && fHasServiceControl
                                                    && fTapiInfoLoaded);
                                                    
    // these should always be available if we have service control access 
    // and we are running on server
    GetDlgItem(IDC_STATIC_USERNAME)->EnableWindow(fIsNtServer && fHasServiceControl);
    GetDlgItem(IDC_STATIC_PASSWORD)->EnableWindow(fIsNtServer && fHasServiceControl);
    GetDlgItem(IDC_STATIC_ACCOUNT)->EnableWindow(fIsNtServer && fHasServiceControl);
    GetDlgItem(IDC_BUTTON_CHOOSE_USER)->EnableWindow(fIsNtServer && fHasServiceControl);
    GetDlgItem(IDC_EDIT_NAME)->EnableWindow(fIsNtServer && fHasServiceControl);
    GetDlgItem(IDC_EDIT_PASSWORD)->EnableWindow(fIsNtServer && fHasServiceControl);
    GetDlgItem(IDC_STATIC_ACCOUNT_INFO)->EnableWindow(fIsNtServer && fHasServiceControl);

    if (fServiceRunning)
    {

        // enable the remove button if something is selected
        BOOL fEnableRemove = m_listAdmins.GetCurSel() != LB_ERR;

        //if we will disable the remove button and the remove button has the focus, 
        //we should change focus to the next control
        CWnd * pwndRemove = GetDlgItem(IDC_BUTTON_REMOVE_ADMIN);

        if (!fEnableRemove && GetFocus() == pwndRemove)
        {
            NextDlgCtrl();
        }

        pwndRemove->EnableWindow(fEnableRemove);
    }
}

BOOL CServerPropSetup::OnApply() 
{
    CString     strAccount, strPassword;
    BOOL        fUpdateAccount = FALSE;
    BOOL        fUpdateTapiServer = FALSE;
    BOOL        bRet = TRUE;
    BOOL        bWasServer, bToBeServer;
    DWORD       dwStartType = SERVICE_NO_CHANGE;

    if (!IsDirty())
        return bRet;

    CServerProperties * pServerProp = (CServerProperties * ) GetHolder();

    UpdateData();

    //  Check to see if there is any change on enabling server
    //  or user account name, that requires service restarting
    if (!m_fRestartService)
    {
        bWasServer = m_dwInitFlags & TAPISERVERCONFIGFLAGS_ENABLESERVER;
        bToBeServer = ((CButton *) GetDlgItem(IDC_CHECK_ENABLE_SERVER))->GetCheck();
        if (bWasServer && !bToBeServer || !bWasServer && bToBeServer)
        {
            m_fRestartService = TRUE;
        }
        if (m_dwNewFlags & TAPISERVERCONFIGFLAGS_SETACCOUNT)
        {
            GetDlgItem(IDC_EDIT_NAME)->GetWindowText(strAccount);
            if (strAccount.CompareNoCase(pServerProp->GetServiceAccountName()) != 0)
            {
                m_fRestartService = TRUE;
            }
            else
            {
                m_dwNewFlags &= ~TAPISERVERCONFIGFLAGS_SETACCOUNT;
            }
        }
    }

    // if the account information has changed, the update the info struct now
    if (m_dwNewFlags & TAPISERVERCONFIGFLAGS_SETACCOUNT)
    {
        GetDlgItem(IDC_EDIT_NAME)->GetWindowText(strAccount);
        GetDlgItem(IDC_EDIT_PASSWORD)->GetWindowText(strPassword);

        // verify that the user is an admin on the machine
        if (!IsLocalSystemAccount(strAccount))
        {
            DWORD   dwErr;
            BOOL    fIsAdmin;
            CString strMessage;
            
            dwErr = ::IsAdmin(pServerProp->m_strMachineName, strAccount, strPassword, &fIsAdmin);

            if (!fIsAdmin)
            {
                AfxFormatString1(strMessage, IDS_ERR_USER_NOT_ADMIN, pServerProp->m_strMachineName);
                AfxMessageBox(strMessage);
            
                GetDlgItem(IDC_EDIT_NAME)->SetFocus();
                ((CEdit *) GetDlgItem(IDC_EDIT_NAME))->SetSel(0, -1);

                return FALSE;
            }
        }

        // clear the flag so we don't use the TAPI MMC APIs to set this
        m_dwNewFlags &= ~TAPISERVERCONFIGFLAGS_SETACCOUNT;
        fUpdateAccount = TRUE;
    }

    // if we are changing the server state or admin stuff then
    if (((CButton *) GetDlgItem(IDC_CHECK_ENABLE_SERVER))->GetCheck())
    {
        m_dwNewFlags |= TAPISERVERCONFIGFLAGS_ENABLESERVER;
    }

    // only update config information if it has changed
    if ((pServerProp->FIsServiceRunning()) &&
        (m_tapiConfigInfo.m_dwFlags != m_dwNewFlags))
    {
        // if we modify the tapi server status then we need to change the 
        // service statrt type as well.
        if ((m_dwNewFlags & TAPISERVERCONFIGFLAGS_ENABLESERVER) &&
            !(m_tapiConfigInfo.m_dwFlags & TAPISERVERCONFIGFLAGS_ENABLESERVER))
        {
            fUpdateTapiServer = TRUE;
        }

        dwStartType = (m_dwNewFlags & TAPISERVERCONFIGFLAGS_ENABLESERVER) ? SERVICE_AUTO_START : SERVICE_DEMAND_START;
        
        bRet = CPropertyPageBase::OnApply();
    }

    if (bRet == FALSE)
    {
        // Something bad happened... grab the error code
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        ::TapiMessageBox(WIN32_FROM_HRESULT(GetHolder()->GetError()));

        // restore the flag
        if (fUpdateAccount) 
            m_dwNewFlags |= TAPISERVERCONFIGFLAGS_SETACCOUNT;
    }
    else
    {
        m_dwNewFlags = TAPISERVERCONFIGFLAGS_ISSERVER;

        if (fUpdateAccount || fUpdateTapiServer)
        {
            // do the account change
            BEGIN_WAIT_CURSOR

            LPCTSTR pszAccount = (fUpdateAccount) ? (LPCTSTR) strAccount : NULL;
            LPCTSTR pszPassword = (fUpdateAccount) ? (LPCTSTR) strPassword : NULL;

            bRet = pServerProp->FUpdateServiceInfo(pszAccount, pszPassword, dwStartType);
            
            if (bRet)
            {
                /*$REVIEW
                Tapisrv occupies a seperate house in NT server. It lives with the other 
                services on NT Professional Edition(workstation). We do not need to 
                sperate/merge services anymore. Users should not be allowed to change 
                account information from TAPI MMC on NT workstation(Disabled). 

                HRESULT hr;

                // if the change was successful, update the svc host information
                hr = UpdateSvcHostInfo(pServerProp->m_strMachineName, IsLocalSystemAccount(strAccount));
                if (FAILED(hr))
                {
                    // restore the flag
                    if (fUpdateAccount)
                    {
                        m_dwNewFlags |= TAPISERVERCONFIGFLAGS_SETACCOUNT;
                    }

                    ::TapiMessageBox(WIN32_FROM_HRESULT(hr));
                    return FALSE;
                }
                */
            }
            else if (fUpdateAccount)
            {
                // set account failed, so set the flag again.
                m_dwNewFlags |= TAPISERVERCONFIGFLAGS_SETACCOUNT;
            }

            END_WAIT_CURSOR
        }

        // if everything went OK and we changed something that requires a service restart then
        // do ask the user if they want to do it now
        if (bRet && m_fRestartService)
        {
            CString strText;
            BOOL    fServiceRunning = pServerProp->FIsServiceRunning();
            
            ::TFSIsServiceRunning(pServerProp->m_strMachineName, 
                                  TAPI_SERVICE_NAME, 
                                  &fServiceRunning);

            if (fServiceRunning)
                strText.LoadString(IDS_ACCOUNT_CHANGE_RESTART);
            else
                strText.LoadString(IDS_ACCOUNT_CHANGE_START);

            // Tell the user the service needs to be restarted in order to make the changes
            if (AfxMessageBox(strText, MB_YESNO) == IDYES)
            {
                if (RestartService() == ERROR_SUCCESS)
                {
                    m_fRestartService = FALSE;
                    m_dwInitFlags = m_tapiConfigInfo.m_dwFlags;
                }
            }
        }
    }

    if (!bRet)
        SetDirty(TRUE);

    return bRet;
}

BOOL CServerPropSetup::OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask)
{
    SPITapiInfo     spTapiInfo;
    HRESULT         hr = hrOK;
    BOOL            fServiceRunning = TRUE;
    DWORD           dwOldFlags;
    DWORD           dwErr = ERROR_SUCCESS;

    CServerProperties * pServerProp = (CServerProperties * ) GetHolder();

    pServerProp->GetTapiInfo(&spTapiInfo);
    Assert(spTapiInfo);

    // if the service isn't running, try to start it
    //if (!pServerProp->FIsServiceRunning())
    dwErr = ::TFSIsServiceRunning(pServerProp->m_strMachineName, 
                                  TAPI_SERVICE_NAME, 
                                  &fServiceRunning);
    if (!fServiceRunning)
    {
        // service has stopped from under us.  Return an error.
        GetHolder()->SetError(HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE));
        return FALSE;
    }

    // if everything is cool then make the changes
    if (dwErr == ERROR_SUCCESS)
    {
        dwOldFlags = m_tapiConfigInfo.m_dwFlags;

        //clear the changable bits in old flags
        m_tapiConfigInfo.m_dwFlags &= ~c_dwChangableFlagMask;

        //set the changable bits
        m_tapiConfigInfo.m_dwFlags |= (m_dwNewFlags & c_dwChangableFlagMask);
                
        hr = spTapiInfo->SetConfigInfo(&m_tapiConfigInfo);

        //Bug 276787 We should clear the two write bits
        m_tapiConfigInfo.m_dwFlags &= ~(TAPISERVERCONFIGFLAGS_SETACCOUNT | 
                                        TAPISERVERCONFIGFLAGS_SETTAPIADMINISTRATORS);

        if (FAILED(hr))
        {
            GetHolder()->SetError(hr);
            m_tapiConfigInfo.m_dwFlags = dwOldFlags;
        }
    }

    return FALSE;
}

HRESULT CServerPropSetup::UpdateSvcHostInfo(LPCTSTR pszMachine, BOOL fLocalSystemAccount)
{
    HRESULT     hr = hrOK;
    MULTI_QI    qi;
    SPIRemoteNetworkConfig  spRemote;
    
    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        return hr;
    }

    if (IsLocalMachine(pszMachine))
    {
        hr = CoCreateInstance(CLSID_RemoteRouterConfig,
                              NULL,
                              CLSCTX_SERVER,
                              IID_IRemoteNetworkConfig,
                              (LPVOID *) &(qi.pItf));
    }
    else
    {
        COSERVERINFO    csi;
        
        qi.pIID = &IID_IRemoteNetworkConfig;
        qi.pItf = NULL;
        qi.hr = 0;
        
        csi.dwReserved1 = 0;
        csi.dwReserved2 = 0;
        csi.pwszName = (LPWSTR) (LPCTSTR) pszMachine;
        csi.pAuthInfo = NULL;
        hr = CoCreateInstanceEx(CLSID_RemoteRouterConfig,
                                NULL,
                                CLSCTX_SERVER,
                                &csi,
                                1,
                                &qi);
    }
    
    Trace1("CServerPropSetup::UpdateSvcHostInfo - CoCreateInstance returned %lx\n", hr);

    if (hr == S_OK)
    {
        CString strGroup;

        strGroup = _T("Tapisrv");

        spRemote = (IRemoteNetworkConfig *)qi.pItf;
        hr = spRemote->SetUserConfig(TAPI_SERVICE_NAME, strGroup);
    
        Trace1("CServerPropSetup::UpdateSvcHostInfo - SetUserConfig returned %lx\n", hr);
    }

    CoUninitialize();

    return hr;
}

DWORD CServerPropSetup::RestartService()
{
    // restart the service if requested
    CServerProperties * pServerProp = (CServerProperties * ) GetHolder();
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fRestart = FALSE;
    
    SPITapiInfo     spTapiInfo;
    pServerProp->GetTapiInfo(&spTapiInfo);

    // gotta clean up before the service stops
    spTapiInfo->Destroy();

    // any time we stop/start the service we need to call this
    ::UnloadTapiDll();

    // stop the service if it is running
    BOOL    fServiceRunning = pServerProp->FIsServiceRunning();
    
    ::TFSIsServiceRunning(pServerProp->m_strMachineName, 
                          TAPI_SERVICE_NAME, 
                          &fServiceRunning);

    if (fServiceRunning)
    {
        dwErr = ::TFSStopService(pServerProp->m_strMachineName, TAPI_SERVICE_NAME, pServerProp->GetServiceDisplayName());
    }

    if (dwErr != ERROR_SUCCESS)
    {
        CString strText;
        strText.LoadString(IDS_ERR_SERVICE_NOT_STOPPED);
        TapiMessageBox(dwErr, MB_OK, strText);
    }

    // start the service
    if (dwErr == ERROR_SUCCESS)
    {
        dwErr = ::TFSStartService(pServerProp->m_strMachineName, TAPI_SERVICE_NAME, pServerProp->GetServiceDisplayName());

        if (dwErr != ERROR_SUCCESS)
        {
            CString strText;
            strText.LoadString(IDS_ERR_SERVICE_NOT_STARTED);
            TapiMessageBox(dwErr, MB_OK, strText);
        }
    }

    StartRefresh();

    return dwErr;
}

void CServerPropSetup::StartRefresh()
{
    // refresh the snapin to reflect the changes
    SPITFSNode      spNode;
    CTapiServer *   pServer;

    spNode = GetHolder()->GetNode();
    pServer = GETHANDLER(CTapiServer, spNode);

    pServer->OnRefresh(spNode, NULL, 0, 0, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\servpp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    Servpp.h   
        Server properties header file

    FILE HISTORY:
        
*/

#if !defined(AFX_SERVPP_H__037BF46A_6E87_11D1_93B6_00C04FC3357A__INCLUDED_)
#define AFX_SERVPP_H__037BF46A_6E87_11D1_93B6_00C04FC3357A__INCLUDED_

#ifndef _TAPIDB_H
#include "tapidb.h"
#endif

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define AUTO_REFRESH_HOURS_MAX         23
#define AUTO_REFRESH_MINUTES_MAX       59

#include "rrasutil.h"

BOOL    IsLocalSystemAccount(LPCTSTR pszAccount);

/////////////////////////////////////////////////////////////////////////////
// CServerPropRefresh dialog

class CServerPropRefresh : public CPropertyPageBase
{
    DECLARE_DYNCREATE(CServerPropRefresh)

// Construction
public:
    CServerPropRefresh();
    ~CServerPropRefresh();

// Dialog Data
    //{{AFX_DATA(CServerPropRefresh)
    enum { IDD = IDP_SERVER_REFRESH };
    CEdit   m_editMinutes;
    CEdit   m_editHours;
    CSpinButtonCtrl m_spinMinutes;
    CSpinButtonCtrl m_spinHours;
    CButton m_checkEnableStats;
    //}}AFX_DATA

    void UpdateButtons();
    void ValidateHours();
    void ValidateMinutes();

    virtual BOOL OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask);

    // Context Help Support
    virtual DWORD * GetHelpMap() { return (DWORD *) &g_aHelpIDs_SERVER_REFRESH[0]; }

    BOOL        m_bAutoRefresh;
    DWORD       m_dwRefreshInterval;

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CServerPropRefresh)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CServerPropRefresh)
    virtual BOOL OnInitDialog();
    afx_msg void OnCheckEnableStats();
    afx_msg void OnKillfocusEditHours();
    afx_msg void OnKillfocusEditMinutes();
    afx_msg void OnChangeEditHours();
    afx_msg void OnChangeEditMinutes();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CServerPropSetup dialog

class CServerPropSetup : public CPropertyPageBase
{
    DECLARE_DYNCREATE(CServerPropSetup)

// Construction
public:
    CServerPropSetup();
    ~CServerPropSetup();

// Dialog Data
    //{{AFX_DATA(CServerPropSetup)
    enum { IDD = IDP_SERVER_SETUP };
    CListBox    m_listAdmins;
    //}}AFX_DATA

    void EnableButtons(BOOL fIsNtServer = TRUE);

    virtual BOOL OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask);

    // Context Help Support
    virtual DWORD * GetHelpMap() { return (DWORD *) &g_aHelpIDs_SERVER_SETUP[0]; }

    HRESULT UpdateSvcHostInfo(LPCTSTR pszMachine, BOOL fLocalSystemAccount);
    DWORD   RestartService();
    void    StartRefresh();

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CServerPropSetup)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CServerPropSetup)
    afx_msg void OnButtonAdd();
    afx_msg void OnButtonChooseUser();
    afx_msg void OnButtonRemove();
    afx_msg void OnCheckEnableServer();
    afx_msg void OnChangeEditName();
    afx_msg void OnChangeEditPassword();
    virtual BOOL OnInitDialog();
    afx_msg void OnSelchangeListAdmins();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    CTapiConfigInfo         m_tapiConfigInfo;
    DWORD                   m_dwNewFlags;
    DWORD                   m_dwInitFlags;
    BOOL                    m_fRestartService;
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

class CServerProperties : public CPropertyPageHolderBase
{
    friend class CServerPropRefresh;

public:
    CServerProperties(ITFSNode *          pNode,
                      IComponentData *    pComponentData,
                      ITFSComponentData * pTFSCompData,
                      ITapiInfo *         pTapiInfo,
                      LPCTSTR             pszSheetName,
                      BOOL                fTapiInfoLoaded);
    virtual ~CServerProperties();

    ITFSComponentData * GetTFSCompData()
    {
        if (m_spTFSCompData)
            m_spTFSCompData->AddRef();
        return m_spTFSCompData;
    }

    HRESULT GetTapiInfo(ITapiInfo ** ppTapiInfo) 
    {   
        Assert(ppTapiInfo);
        *ppTapiInfo = NULL;
        SetI((LPUNKNOWN *) ppTapiInfo, m_spTapiInfo);
        return hrOK;
    }

    BOOL    FInit();
    BOOL    FOpenScManager();
    VOID    FCheckLSAAccount();
    BOOL    FUpdateServiceInfo(LPCTSTR pszName, LPCTSTR pszPassword, DWORD dwStartType);
    BOOL    FIsServiceRunning() { return (m_SS.dwCurrentState == SERVICE_RUNNING); }
    BOOL    FHasServiceControl(); 
    BOOL    FIsTapiInfoLoaded() { return m_fTapiInfoLoaded; }
    BOOL    FIsAdmin() { return m_spTapiInfo->IsAdmin(); }

    LPCTSTR GetServiceAccountName() { return m_strLogOnAccountName; }
    LPCTSTR GetServiceDisplayName() { return m_strServiceDisplayName; }

public:
    CServerPropSetup        m_pageSetup;
    CServerPropRefresh      m_pageRefresh;

    CString                 m_strMachineName;
    CONST TCHAR *           m_pszServiceName;

protected:
    SPITFSComponentData     m_spTFSCompData;
    SPITapiInfo             m_spTapiInfo;
    
    SC_HANDLE               m_hScManager;

    UINT                    m_uFlags;           // Flags about which fields are dirty
    SERVICE_STATUS          m_SS;               // Service Status structure
    QUERY_SERVICE_CONFIG *  m_paQSC;            // Pointer to allocated QSC structure
    CString                 m_strServiceDisplayName;
    CString                 m_strLogOnAccountName;
    BOOL                    m_fTapiInfoLoaded;
};


#endif // !defined(AFX_SERVPP_H__037BF46A_6E87_11D1_93B6_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\tapidb.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    tapidb.h

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "DynamLnk.h"
#include "tapidb.h"

#include "security.h"
#include "lm.h"
#include "service.h"
#include <shlwapi.h>
#include <shlwapip.h>   

#define DEFAULT_SECURITY_PKG    _T("negotiate")
#define NT_SUCCESS(Status)      ((NTSTATUS)(Status) >= 0)
#define STATUS_SUCCESS          ((NTSTATUS)0x00000000L)

// internal functions
BOOL    IsUserAdmin(LPCTSTR pszMachine, PSID    AccountSid);
BOOL    LookupAliasFromRid(LPWSTR TargetComputer, DWORD Rid, LPWSTR Name, PDWORD cchName);
DWORD   ValidateDomainAccount(IN CString Machine, IN CString UserName, IN CString Domain, OUT PSID * AccountSid);
NTSTATUS ValidatePassword(IN LPCWSTR UserName, IN LPCWSTR Domain, IN LPCWSTR Password);
DWORD   GetCurrentUser(CString & strAccount);


DEBUG_DECLARE_INSTANCE_COUNTER(CTapiInfo);

DynamicDLL g_TapiDLL( _T("TAPI32.DLL"), g_apchFunctionNames );

CTapiInfo::CTapiInfo()
    : m_hServer(NULL),
      m_pTapiConfig(NULL),
      m_pProviderList(NULL),
      m_pAvailProviderList(NULL),
      m_hReinit(NULL),
      m_dwApiVersion(TAPI_CURRENT_VERSION),
      m_hResetEvent(NULL),
      m_cRef(1),
      m_fIsLocalMachine(FALSE),
      m_dwCachedLineSize(0),
      m_dwCachedPhoneSize(0),
      m_fCacheDirty(0)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CTapiInfo);
    
    for (int i = 0; i < DEVICE_TYPE_MAX; i++)
        m_paDeviceInfo[i] = NULL;
}

CTapiInfo::~CTapiInfo()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CTapiInfo);

    CSingleLock cl(&m_csData);

    if (m_hServer)
    {
        Destroy();
    }

    cl.Lock();
    if (m_pTapiConfig)
    {
        free(m_pTapiConfig);
        m_pTapiConfig = NULL;
    }

    for (int i = 0; i < DEVICE_TYPE_MAX; i++)
    {
        if (m_paDeviceInfo[i])
        {
            free(m_paDeviceInfo[i]);
            m_paDeviceInfo[i] = NULL;
        }
    }

    if (m_pProviderList)
    {
        free(m_pProviderList);
        m_pProviderList = NULL;
    }

    if (m_pAvailProviderList)
    {
        free(m_pAvailProviderList);
        m_pAvailProviderList = NULL;
    }

    if (m_hResetEvent)
    {
        CloseHandle(m_hResetEvent);
        m_hResetEvent = NULL;
    }

    cl.Unlock();
}

// Although this object is not a COM Interface, we want to be able to
// take advantage of recounting, so we have basic addref/release/QI support
IMPLEMENT_ADDREF_RELEASE(CTapiInfo)

IMPLEMENT_SIMPLE_QUERYINTERFACE(CTapiInfo, ITapiInfo)

/*!--------------------------------------------------------------------------
    CTapiInfo::Initialize()
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CTapiInfo::Initialize()
{
    HRESULT hr = hrOK;
    LONG    lReturn = 0;

    if ( !g_TapiDLL.LoadFunctionPointers() )
        return S_OK;

    if (m_hServer)
    {
        // already initialized
        return S_OK;
    }

    CString strLocalMachineName;
    DWORD   dwSize = MAX_COMPUTERNAME_LENGTH + 1;
    LPTSTR pBuf = strLocalMachineName.GetBuffer(dwSize);
    ::GetComputerName(pBuf, &dwSize);
    strLocalMachineName.ReleaseBuffer();

    if (m_strComputerName.IsEmpty())
    {
        m_strComputerName = strLocalMachineName;
        m_fIsLocalMachine = TRUE;
        Trace1("CTapiInfo::Initialize - Using local computer %s\n", m_strComputerName);
    }
    else
    {
        m_fIsLocalMachine = (0 == m_strComputerName.CompareNoCase(strLocalMachineName)) ?
                            TRUE : FALSE;
            
        Trace1("CTapiInfo::Initialize - Using computer %s\n", m_strComputerName);
    }

    if (m_hResetEvent == NULL)
    {
        m_hResetEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (m_hResetEvent == NULL)
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }

    lReturn = ((INITIALIZE) g_TapiDLL[TAPI_INITIALIZE])(m_strComputerName, &m_hServer, &m_dwApiVersion, &m_hResetEvent);
    if (lReturn != ERROR_SUCCESS)
    {
        Trace1("CTapiInfo::Initialize - Initialize failed! %lx\n", lReturn);
        return HRESULT_FROM_WIN32(TAPIERROR_FORMATMESSAGE(lReturn));
    }

    // check to see if the local user is an admin on the machine
    ::IsAdmin(m_strComputerName, NULL, NULL, &m_fIsAdmin);

    // get the local user name for later to compare against list of tapi admins
    GetCurrentUser();

    return hr;
}

/*!--------------------------------------------------------------------------
    CTapiInfo::Reset()
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CTapiInfo::Reset()
{
    LONG    lReturn = 0;
    
    for (int i = 0; i < DEVICE_TYPE_MAX; i++)
    {
        m_IndexMgr[i].Reset();
    }

    return S_OK;
}

/*!--------------------------------------------------------------------------
    CTapiInfo::Destroy()
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CTapiInfo::Destroy()
{
    LONG    lReturn = 0;
    HRESULT hr = S_OK;

    if ( !g_TapiDLL.LoadFunctionPointers() )
        return hr;

    if (m_hServer == NULL)
    {
        return hr;
    }

    lReturn = ((SHUTDOWN) g_TapiDLL[TAPI_SHUTDOWN])(m_hServer);
    if (lReturn != ERROR_SUCCESS)
    {
        Trace1("CTapiInfo::Destroy - Shutdown failed! %lx\n", lReturn);
        hr = HRESULT_FROM_WIN32(TAPIERROR_FORMATMESSAGE(lReturn));
    }

    m_hServer = NULL;

    return hr;
}

/*!--------------------------------------------------------------------------
    CTapiInfo::EnumConfigInfo
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CTapiInfo::EnumConfigInfo()
{
    CSingleLock         cl(&m_csData);
    LONG                lReturn = 0;
    TAPISERVERCONFIG    tapiServerConfig = {0};
    LPTAPISERVERCONFIG  pTapiServerConfig = NULL;
    HRESULT             hr = hrOK;

    if ( !g_TapiDLL.LoadFunctionPointers() )
        return S_OK;

    if (m_hServer == NULL)
    {
        Trace0("CTapiInfo::GetConfigInfo - Server not initialized!\n");
        return E_FAIL;
    }

    COM_PROTECT_TRY
    {
        // the first call will tell us how big of a buffer we need to allocate
        // to hold the config info struct
        tapiServerConfig.dwTotalSize = sizeof(TAPISERVERCONFIG);
        lReturn = ((GETSERVERCONFIG) g_TapiDLL[TAPI_GET_SERVER_CONFIG])(m_hServer, &tapiServerConfig);
        if (lReturn != ERROR_SUCCESS)
        {
            Trace1("CTapiInfo::GetConfigInfo - 1st MMCGetServerConfig returned %x!\n", lReturn);
            return HRESULT_FROM_WIN32(TAPIERROR_FORMATMESSAGE(lReturn));
        }

        pTapiServerConfig = (LPTAPISERVERCONFIG) malloc(tapiServerConfig.dwNeededSize);
		if (NULL == pTapiServerConfig)
		{
			return E_OUTOFMEMORY;
		}

        memset(pTapiServerConfig, 0, tapiServerConfig.dwNeededSize);
        pTapiServerConfig->dwTotalSize = tapiServerConfig.dwNeededSize;

        lReturn = ((GETSERVERCONFIG) g_TapiDLL[TAPI_GET_SERVER_CONFIG])(m_hServer, pTapiServerConfig);
        if (lReturn != ERROR_SUCCESS)
        {
            Trace1("CTapiInfo::GetConfigInfo - 2nd MMCGetServerConfig returned %x!\n", lReturn);
            free(pTapiServerConfig);
            return HRESULT_FROM_WIN32(TAPIERROR_FORMATMESSAGE(lReturn));
        }

        cl.Lock();
        if (m_pTapiConfig)
        {
            free(m_pTapiConfig);
        }

        m_pTapiConfig = pTapiServerConfig;
        cl.Unlock();
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
    CTapiInfo::GetConfigInfo
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CTapiInfo::GetConfigInfo(CTapiConfigInfo * ptapiConfigInfo)
{
    CSingleLock cl(&m_csData);

    cl.Lock();
    if (m_pTapiConfig)
    {
        TapiConfigToInternal(m_pTapiConfig, *ptapiConfigInfo);
    }
    else
    {
        return E_FAIL;
    }

    return S_OK;
}

/*!--------------------------------------------------------------------------
    CTapiInfo::SetConfigInfo
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CTapiInfo::SetConfigInfo(CTapiConfigInfo * ptapiConfigInfo)
{
    CSingleLock cl(&m_csData);

    LPTAPISERVERCONFIG  pServerConfig = NULL;
    HRESULT             hr = hrOK;
    LONG                lReturn = 0;

    if ( !g_TapiDLL.LoadFunctionPointers() )
        return S_OK;

    if (m_hServer == NULL)
    {
        Trace0("CTapiInfo::SetConfigInfo - Server not initialized!\n");
        return E_FAIL;
    }

    InternalToTapiConfig(*ptapiConfigInfo, &pServerConfig);
    Assert(pServerConfig);

    if (pServerConfig)
    {
        // make the call
        lReturn = ((SETSERVERCONFIG) g_TapiDLL[TAPI_SET_SERVER_CONFIG])(m_hServer, pServerConfig);
        if (lReturn != ERROR_SUCCESS)
        {
            Trace1("CTapiInfo::SetConfigInfo - MMCSetServerConfig returned %x!\n", lReturn);
            free(pServerConfig);
            return HRESULT_FROM_WIN32(TAPIERROR_FORMATMESSAGE(lReturn));
        }

        // free up the old config struct if there was one
        cl.Lock();
        if (m_pTapiConfig)
            free(m_pTapiConfig);

        m_pTapiConfig = pServerConfig;

        //Bug 276787 We should clear the two write bits
        m_pTapiConfig->dwFlags &= ~(TAPISERVERCONFIGFLAGS_SETACCOUNT | 
                                     TAPISERVERCONFIGFLAGS_SETTAPIADMINISTRATORS);

        cl.Unlock();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    CTapiInfo::IsServer
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(BOOL) 
CTapiInfo::IsServer()
{
    CSingleLock cl(&m_csData);
    cl.Lock();

    if (m_pTapiConfig)
        return m_pTapiConfig->dwFlags & TAPISERVERCONFIGFLAGS_ISSERVER;
    else if (!m_strComputerName.IsEmpty())
    {
        BOOL fIsNTS = FALSE;
        TFSIsNTServer(m_strComputerName, &fIsNTS);
        return fIsNTS;
    }
    else
        return FALSE;  // assume workstation
}

/*!--------------------------------------------------------------------------
    CTapiInfo::IsTapiServer
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(BOOL) 
CTapiInfo::IsTapiServer()
{
    CSingleLock cl(&m_csData);
    cl.Lock();

    if (m_pTapiConfig)
        return m_pTapiConfig->dwFlags & TAPISERVERCONFIGFLAGS_ENABLESERVER;
    else
        return FALSE;  // assume not a tapi server
}

STDMETHODIMP
CTapiInfo::SetComputerName(LPCTSTR pComputer)
{
    m_strComputerName = pComputer;
    return hrOK;
}

STDMETHODIMP_(LPCTSTR) 
CTapiInfo::GetComputerName()
{
    return m_strComputerName;
}

/*!--------------------------------------------------------------------------
    CTapiInfo::IsLocalMachine
        Says whether this machine is local or remote
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(BOOL) 
CTapiInfo::IsLocalMachine()
{
    return m_fIsLocalMachine;
}

/*!--------------------------------------------------------------------------
    CTapiInfo::FHasServiceControl
        Says whether we the access of service control for tapisrv
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(BOOL)
CTapiInfo::FHasServiceControl()
{
    CSingleLock cl(&m_csData);
    cl.Lock();

    if (m_pTapiConfig)
        return !(m_pTapiConfig->dwFlags & TAPISERVERCONFIGFLAGS_NOSERVICECONTROL);
    else
        return FALSE;  // assume workstation
}

STDMETHODIMP
CTapiInfo::SetCachedLineBuffSize(DWORD dwLineSize)
{
    m_dwCachedLineSize = dwLineSize;
    return S_OK;
}

STDMETHODIMP
CTapiInfo::SetCachedPhoneBuffSize(DWORD dwPhoneSize)
{
    m_dwCachedPhoneSize = dwPhoneSize;
    return S_OK;
}

STDMETHODIMP_(DWORD)
CTapiInfo::GetCachedLineBuffSize()
{
    return m_dwCachedLineSize;
}

STDMETHODIMP_(DWORD)
CTapiInfo::GetCachedPhoneBuffSize()
{
    return m_dwCachedPhoneSize;
}

STDMETHODIMP_(BOOL)
CTapiInfo::IsCacheDirty()
{
    return m_fCacheDirty;
}

/*!--------------------------------------------------------------------------
    CTapiInfo::GetProviderCount
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int)
CTapiInfo::GetProviderCount()
{
    CSingleLock cl(&m_csData);
    cl.Lock();

    if (m_pProviderList)
    {
        return m_pProviderList->dwNumProviders;
    }
    else
    {   
        return 0;
    }
}

/*!--------------------------------------------------------------------------
    CTapiInfo::EnumProviders
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CTapiInfo::EnumProviders()
{
    CSingleLock cl(&m_csData);

    LINEPROVIDERLIST    tapiProviderList = {0};
    LPLINEPROVIDERLIST  pProviderList = NULL;
    HRESULT             hr = hrOK;
    LONG                lReturn = 0;

    if ( !g_TapiDLL.LoadFunctionPointers() )
        return S_OK;

    if (m_hServer == NULL)
    {
        Trace0("CTapiInfo::GetConfigInfo - Server not initialized!\n");
        return E_FAIL;
    }

    COM_PROTECT_TRY
    {
        // the first call will tell us how big of a buffer we need to allocate
        // to hold the provider list struct
        tapiProviderList.dwTotalSize = sizeof(LINEPROVIDERLIST);
        lReturn = ((GETPROVIDERLIST) g_TapiDLL[TAPI_GET_PROVIDER_LIST])(m_hServer, &tapiProviderList);
        if (lReturn != ERROR_SUCCESS)
        {
            Trace1("CTapiInfo::EnumProviders - 1st MMCGetProviderList returned %x!\n", lReturn);
            return HRESULT_FROM_WIN32(TAPIERROR_FORMATMESSAGE(lReturn));
        }

        pProviderList = (LPLINEPROVIDERLIST) malloc(tapiProviderList.dwNeededSize);
		if (NULL == pProviderList)
		{
			return E_OUTOFMEMORY;
		}

        memset(pProviderList, 0, tapiProviderList.dwNeededSize);
        pProviderList->dwTotalSize = tapiProviderList.dwNeededSize;
    
        lReturn = ((GETPROVIDERLIST) g_TapiDLL[TAPI_GET_PROVIDER_LIST])(m_hServer, pProviderList);
        if (lReturn != ERROR_SUCCESS)
        {
            Trace1("CTapiInfo::EnumProviders - 2nd MMCGetProviderList returned %x!\n", lReturn);
            free(pProviderList);
            return HRESULT_FROM_WIN32(TAPIERROR_FORMATMESSAGE(lReturn));
        }

        cl.Lock();
        if (m_pProviderList)
        {
            free(m_pProviderList);
        }

        m_pProviderList = pProviderList;
        cl.Unlock();
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
    CTapiInfo::GetProviderInfo
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CTapiInfo::GetProviderInfo(CTapiProvider * pproviderInfo, int nIndex)
{
    CSingleLock cl(&m_csData);
    cl.Lock();

    HRESULT             hr = hrOK;
    LPLINEPROVIDERENTRY pProvider = NULL;

    if (m_pProviderList == NULL)
        return E_FAIL;

    if ((UINT) nIndex > m_pProviderList->dwNumProviders)
        return E_FAIL;

    pProvider = (LPLINEPROVIDERENTRY) ((LPBYTE) m_pProviderList + m_pProviderList->dwProviderListOffset);
    for (int i = 0; i < nIndex; i++)
    {
        pProvider++;
    }

    pproviderInfo->m_dwProviderID = pProvider->dwPermanentProviderID;
    pproviderInfo->m_strFilename = (LPCWSTR) ((LPBYTE) m_pProviderList + pProvider->dwProviderFilenameOffset);
    pproviderInfo->m_strName = GetProviderName(pproviderInfo->m_dwProviderID, pproviderInfo->m_strFilename, &pproviderInfo->m_dwFlags);

    return hr;
}

/*!--------------------------------------------------------------------------
    CTapiInfo::GetProviderInfo
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CTapiInfo::GetProviderInfo(CTapiProvider * pproviderInfo, DWORD dwProviderID)
{
    CSingleLock cl(&m_csData);
    cl.Lock();

    HRESULT             hr = hrOK;
    LPLINEPROVIDERENTRY pProvider = NULL;

    if (m_pProviderList == NULL)
        return E_FAIL;

    pProvider = (LPLINEPROVIDERENTRY) ((LPBYTE) m_pProviderList + m_pProviderList->dwProviderListOffset);
    for (UINT i = 0; i < m_pProviderList->dwNumProviders; i++)
    {
        if (pProvider->dwPermanentProviderID == dwProviderID)
            break;

        pProvider++;
    }

    pproviderInfo->m_dwProviderID = pProvider->dwPermanentProviderID;
    pproviderInfo->m_strFilename = (LPCWSTR) ((LPBYTE) m_pProviderList + pProvider->dwProviderFilenameOffset);
    pproviderInfo->m_strName = GetProviderName(pproviderInfo->m_dwProviderID, pproviderInfo->m_strFilename, &pproviderInfo->m_dwFlags);

    return hr;
}

/*!--------------------------------------------------------------------------
    CTapiInfo::AddProvider
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CTapiInfo::AddProvider(LPCTSTR pProviderFilename, LPDWORD pdwProviderID, HWND hWnd)
{
    CSingleLock cl(&m_csData);
    cl.Lock();

    LONG        lReturn = 0;
    HRESULT     hr = hrOK;
    HWND        hWndParent;

    if (hWnd == NULL)
    {
        hWndParent = ::FindMMCMainWindow();
    }
    else
    {
        hWndParent = hWnd;
    }
    
    if ( !g_TapiDLL.LoadFunctionPointers() )
        return S_OK;

    if (m_hServer == NULL)
    {
        Trace0("CTapiInfo::AddProvider - Server not initialized!\n");
        return E_FAIL;
    }

    lReturn = ((ADDPROVIDER) g_TapiDLL[TAPI_ADD_PROVIDER])(m_hServer, hWndParent, pProviderFilename, pdwProviderID);
    if (lReturn != ERROR_SUCCESS)
    {
        Trace1("CTapiInfo::AddProvider - MMCAddProvider returned %x!\n", lReturn);
        return HRESULT_FROM_WIN32(TAPIERROR_FORMATMESSAGE(lReturn));
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    CTapiInfo::ConfigureProvider
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CTapiInfo::ConfigureProvider(DWORD dwProviderID, HWND hWnd)
{
    LONG        lReturn = 0;
    HRESULT     hr = hrOK;
   
    HWND        hWndParent;

    if (hWnd == NULL)
    {
        hWndParent = ::FindMMCMainWindow();
    }
    else
    {
        hWndParent = hWnd;
    }

    if ( !g_TapiDLL.LoadFunctionPointers() )
        return S_OK;

    if (m_hServer == NULL)
    {
        Trace0("CTapiInfo::ConfigureProvider - Server not initialized!\n");
        return E_FAIL;
    }

    lReturn = ((CONFIGPROVIDER) g_TapiDLL[TAPI_CONFIG_PROVIDER])(m_hServer, hWndParent, dwProviderID);
    if (lReturn != ERROR_SUCCESS)
    {
        Trace1("CTapiInfo::ConfigureProvider - MMCConfigureProvider returned %x!\n", lReturn);
        return HRESULT_FROM_WIN32(TAPIERROR_FORMATMESSAGE(lReturn));
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    CTapiInfo::RemoveProvider
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CTapiInfo::RemoveProvider(DWORD dwProviderID, HWND hWnd)
{
    LONG        lReturn = 0;
    HRESULT     hr = hrOK;
    HWND        hWndParent;

    if (hWnd == NULL)
    {
        hWndParent = ::FindMMCMainWindow();
    }
    else
    {
        hWndParent = hWnd;
    }
   
    if ( !g_TapiDLL.LoadFunctionPointers() )
        return S_OK;

    if (m_hServer == NULL)
    {
        Trace0("CTapiInfo::RemoveProvider - Server not initialized!\n");
        return E_FAIL;
    }

    lReturn = ((REMOVEPROVIDER) g_TapiDLL[TAPI_REMOVE_PROVIDER])(m_hServer, hWndParent, dwProviderID);
    if (lReturn != ERROR_SUCCESS)
    {
        Trace1("CTapiInfo::RemoveProvider - MMCRemoveProvider returned %x!\n", lReturn);
        return HRESULT_FROM_WIN32(TAPIERROR_FORMATMESSAGE(lReturn));
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    CTapiInfo::GetAvailableProviderCount
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int)
CTapiInfo::GetAvailableProviderCount()
{
    CSingleLock cl(&m_csData);
    cl.Lock();

    if (m_pAvailProviderList)
    {
        return m_pAvailProviderList->dwNumProviderListEntries;
    }
    else
    {   
        return 0;
    }
}

/*!--------------------------------------------------------------------------
    CTapiInfo::EnumAvailableProviders
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CTapiInfo::EnumAvailableProviders()
{
    CSingleLock cl(&m_csData);

    AVAILABLEPROVIDERLIST       tapiProviderList = {0};
    LPAVAILABLEPROVIDERLIST     pProviderList = NULL;
    HRESULT                     hr = hrOK;
    LONG                        lReturn = 0;

    if ( !g_TapiDLL.LoadFunctionPointers() )
        return S_OK;

    if (m_hServer == NULL)
    {
        Trace0("CTapiInfo::GetConfigInfo - Server not initialized!\n");
        return E_FAIL;
    }

    COM_PROTECT_TRY
    {
        // the first call will tell us how big of a buffer we need to allocate
        // to hold the provider list struct
        tapiProviderList.dwTotalSize = sizeof(LINEPROVIDERLIST);
        lReturn = ((GETAVAILABLEPROVIDERS) g_TapiDLL[TAPI_GET_AVAILABLE_PROVIDERS])(m_hServer, &tapiProviderList);
        if (lReturn != ERROR_SUCCESS)
        {
            Trace1("CTapiInfo::EnumProviders - 1st MMCGetAvailableProviders returned %x!\n", lReturn);
            return HRESULT_FROM_WIN32(TAPIERROR_FORMATMESSAGE(lReturn));
        }

        pProviderList = (LPAVAILABLEPROVIDERLIST) malloc(tapiProviderList.dwNeededSize);
        memset(pProviderList, 0, tapiProviderList.dwNeededSize);
        pProviderList->dwTotalSize = tapiProviderList.dwNeededSize;
    
        lReturn = ((GETAVAILABLEPROVIDERS) g_TapiDLL[TAPI_GET_AVAILABLE_PROVIDERS])(m_hServer, pProviderList);
        if (lReturn != ERROR_SUCCESS)
        {
            Trace1("CTapiInfo::EnumProviders - 2nd MMCGetAvailableProviders returned %x!\n", lReturn);
            free(pProviderList);
            return HRESULT_FROM_WIN32(TAPIERROR_FORMATMESSAGE(lReturn));
        }

        cl.Lock();
        if (m_pAvailProviderList)
        {
            free(m_pAvailProviderList);
        }

        m_pAvailProviderList = pProviderList;
        cl.Unlock();
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
    CTapiInfo::GetAvailableProviderInfo
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CTapiInfo::GetAvailableProviderInfo(CTapiProvider * pproviderInfo, int nIndex)
{
    CSingleLock cl(&m_csData);
    cl.Lock();

    HRESULT                  hr = hrOK;
    LPAVAILABLEPROVIDERENTRY pProvider = NULL;

    if (m_pAvailProviderList == NULL)
        return E_FAIL;

    if ((UINT) nIndex > m_pAvailProviderList->dwNumProviderListEntries)
        return E_FAIL;

    pProvider = (LPAVAILABLEPROVIDERENTRY) ((LPBYTE) m_pAvailProviderList + m_pAvailProviderList->dwProviderListOffset);
    for (int i = 0; i < nIndex; i++)
    {
        pProvider++;
    }

    // available providers do not have ProviderIDs until they are installed
    pproviderInfo->m_dwProviderID = 0;
    pproviderInfo->m_dwFlags = pProvider->dwOptions;
    pproviderInfo->m_strName = (LPCWSTR) ((LPBYTE) m_pAvailProviderList + pProvider->dwFriendlyNameOffset);
    pproviderInfo->m_strFilename = (LPCWSTR) ((LPBYTE) m_pAvailProviderList + pProvider->dwFileNameOffset);

    return hr;
}

/*!--------------------------------------------------------------------------
    CTapiInfo::EnumDevices
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CTapiInfo::EnumDevices(DEVICE_TYPE deviceType)
{
    CSingleLock cl(&m_csData);

    LONG                lReturn = 0;
    HRESULT             hr = hrOK;
    LPDEVICEINFOLIST    pDeviceInfoList = NULL;

    if ( !g_TapiDLL.LoadFunctionPointers() )
        return S_OK;

    if (m_hServer == NULL)
    {
        Trace0("CTapiInfo::EnumDevices - Server not initialized!\n");
        return E_FAIL;
    }

    // the first call will tell us how big of a buffer we need to allocate
    // to hold the provider list struct
    COM_PROTECT_TRY
    {
        // Fix bug 381469
        // First allocate the cached size of memory to get line info

        DWORD dwCachedSize = (DEVICE_LINE == deviceType) ? m_dwCachedLineSize : m_dwCachedPhoneSize;

        if (dwCachedSize < sizeof(DEVICEINFOLIST))
        {
            //if we didn't have the cached size, then use the default size
            dwCachedSize = TAPI_DEFAULT_DEVICE_BUFF_SIZE;
            m_fCacheDirty = TRUE;
        }
        
        DWORD dwTotalSize = dwCachedSize + DEVICEINFO_GROW_SIZE;
        pDeviceInfoList = (LPDEVICEINFOLIST) malloc(dwTotalSize);
		if (NULL == pDeviceInfoList)
		{
			return E_OUTOFMEMORY;
		}

        memset(pDeviceInfoList, 0, dwTotalSize);
        pDeviceInfoList->dwTotalSize = dwTotalSize;

        switch (deviceType)
        {
            case DEVICE_LINE:
                lReturn = ((GETLINEINFO) g_TapiDLL[TAPI_GET_LINE_INFO])(m_hServer, pDeviceInfoList);
                break;

            case DEVICE_PHONE:
                lReturn = ((GETPHONEINFO) g_TapiDLL[TAPI_GET_PHONE_INFO])(m_hServer, pDeviceInfoList);
                break;  
        }

        if (lReturn != ERROR_SUCCESS)
        {
            Trace1("CTapiInfo::EnumDevices - 1st MMCGetDeviceInfo returned %x!\n", lReturn);
            free (pDeviceInfoList);
            return HRESULT_FROM_WIN32(TAPIERROR_FORMATMESSAGE(lReturn));
        }

        if (pDeviceInfoList->dwNeededSize > pDeviceInfoList->dwTotalSize)
        {
            // the cached size is too small, now allocate the buffer and call again to the the info
            DWORD dwNeededSize = pDeviceInfoList->dwNeededSize;
            free (pDeviceInfoList);
            
            dwNeededSize += DEVICEINFO_GROW_SIZE;
            pDeviceInfoList = (LPDEVICEINFOLIST) malloc(dwNeededSize);
		    if (NULL == pDeviceInfoList)
		    {
			    return E_OUTOFMEMORY;
		    }
            memset(pDeviceInfoList, 0, dwNeededSize);
            pDeviceInfoList->dwTotalSize = dwNeededSize;
    
            switch (deviceType)
            {
                case DEVICE_LINE:
                    lReturn = ((GETLINEINFO) g_TapiDLL[TAPI_GET_LINE_INFO])(m_hServer, pDeviceInfoList);
                    break;

                case DEVICE_PHONE:
                    lReturn = ((GETPHONEINFO) g_TapiDLL[TAPI_GET_PHONE_INFO])(m_hServer, pDeviceInfoList);
                    break;  
            }
        
            if (lReturn != ERROR_SUCCESS)
            {
                Trace1("CTapiInfo::EnumDevices - 2nd MMCGetDeviceInfo returned %x!\n", lReturn);
                free(pDeviceInfoList);
                return HRESULT_FROM_WIN32(TAPIERROR_FORMATMESSAGE(lReturn));
            }
        }


        //update the cache
        if (DEVICE_LINE == deviceType && m_dwCachedLineSize != pDeviceInfoList->dwNeededSize)
        {
            m_dwCachedLineSize = pDeviceInfoList->dwNeededSize;
            m_fCacheDirty = TRUE;
        }
        else if (DEVICE_PHONE == deviceType && m_dwCachedPhoneSize != pDeviceInfoList->dwNeededSize)
        {
            m_dwCachedPhoneSize = pDeviceInfoList->dwNeededSize;
            m_fCacheDirty = TRUE;
        }

        cl.Lock();
        if (m_paDeviceInfo[deviceType])
        {
            free (m_paDeviceInfo[deviceType]);
        }

        m_paDeviceInfo[deviceType] = pDeviceInfoList;

        // build our index list for sorting
        if (pDeviceInfoList->dwNumDeviceInfoEntries)
        {
            LPDEVICEINFO  pDevice = NULL;
            pDevice = (LPDEVICEINFO) ((LPBYTE) pDeviceInfoList + pDeviceInfoList->dwDeviceInfoOffset);

            // now add all of the devices to our index
            for (int i = 0; i < GetTotalDeviceCount(deviceType); i++)
            {
                // walk the list of device info structs and add to the index mgr
                m_IndexMgr[deviceType].AddHDevice(pDevice->dwProviderID, (HDEVICE) pDevice, TRUE);

                pDevice++;
            }
        }
        cl.Unlock();

    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
    CTapiInfo::GetTotalDeviceCount
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int)
CTapiInfo::GetTotalDeviceCount(DEVICE_TYPE deviceType)
{
    CSingleLock cl(&m_csData);
    cl.Lock();

    if (m_paDeviceInfo[deviceType])
    {
        return m_paDeviceInfo[deviceType]->dwNumDeviceInfoEntries;
    }
    else
    {
        return 0;
    }
}

/*!--------------------------------------------------------------------------
    CTapiInfo::GetDeviceCount
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int)
CTapiInfo::GetDeviceCount(DEVICE_TYPE deviceType, DWORD dwProviderID)
{
    m_IndexMgr[deviceType].SetCurrentProvider(dwProviderID);
    return m_IndexMgr[deviceType].GetCurrentCount();
}

/*!--------------------------------------------------------------------------
    CTapiInfo::GetDeviceInfo
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CTapiInfo::GetDeviceInfo(DEVICE_TYPE deviceType, CTapiDevice * ptapiDevice, DWORD dwProviderID, int nIndex)
{
    CSingleLock cl(&m_csData);
    cl.Lock();

    LPDEVICEINFO        pDevice = NULL;
    HDEVICE             hdevice = NULL;
    HRESULT             hr = hrOK;

    if (m_paDeviceInfo[deviceType] == NULL)
        return E_FAIL;

    if ((UINT) nIndex > m_paDeviceInfo[deviceType]->dwNumDeviceInfoEntries)
        return E_INVALIDARG;

    hr = m_IndexMgr[deviceType].GetHDevice(dwProviderID, nIndex, &hdevice);
    if (FAILED(hr))
        return hr;

    pDevice = (LPDEVICEINFO) hdevice;
    if (pDevice == NULL)
        return E_FAIL;

    TapiDeviceToInternal(deviceType, pDevice, *ptapiDevice);

    return hr;
}

/*!--------------------------------------------------------------------------
    CTapiInfo::SetDeviceInfo
        Sets the device info on a TAPI server.  First builds a deviceinfolist 
        struct to user for the SetDeviceInfo call then updates the internal
        device info list.
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CTapiInfo::SetDeviceInfo(DEVICE_TYPE deviceType, CTapiDevice * ptapiDevice)
{
    CSingleLock cl(&m_csData);
    cl.Lock();

    HRESULT             hr = hrOK;
    LONG                lReturn = 0;
    LPDEVICEINFOLIST    pDeviceInfoList = NULL, pNewDeviceInfoList;
    LPDEVICEINFO        pDeviceInfo = NULL;
    int                 i;

    if ( !g_TapiDLL.LoadFunctionPointers() )
        return S_OK;

    if (m_hServer == NULL)
    {
        Trace0("CTapiInfo::EnumDevices - Server not initialized!\n");
        return E_FAIL;
    }

    InternalToTapiDevice(*ptapiDevice, &pDeviceInfoList);
    Assert(pDeviceInfoList);

    if (!pDeviceInfoList)
        return E_OUTOFMEMORY;

    // make the call...
    switch (deviceType)
    {
        case DEVICE_LINE:
            lReturn = ((SETLINEINFO) g_TapiDLL[TAPI_SET_LINE_INFO])(m_hServer, pDeviceInfoList);
            break;

        case DEVICE_PHONE:
            lReturn = ((SETPHONEINFO) g_TapiDLL[TAPI_SET_PHONE_INFO])(m_hServer, pDeviceInfoList);
            break;
    }

    if (lReturn != ERROR_SUCCESS)
    {
        return HRESULT_FROM_WIN32(TAPIERROR_FORMATMESSAGE(lReturn));
    }
    
    // finally, update our internal struct to reflect the changes
    Assert(m_paDeviceInfo[deviceType]);

    pDeviceInfo = (LPDEVICEINFO) ((LPBYTE) pDeviceInfoList + pDeviceInfoList->dwDeviceInfoOffset);

    // find the device in the list
    LPDEVICEINFO  pDevice = NULL;
    pDevice = (LPDEVICEINFO) ((LPBYTE) m_paDeviceInfo[deviceType] + m_paDeviceInfo[deviceType]->dwDeviceInfoOffset);
    for (i = 0; i < GetTotalDeviceCount(deviceType); i++)
    {
        // walk the list of device info structs and add to the index mgr
        if (pDevice->dwPermanentDeviceID == ptapiDevice->m_dwPermanentID)
        {
            // update the device info here.  First check to make sure we have enough room to grow
            if (m_paDeviceInfo[deviceType]->dwTotalSize < (m_paDeviceInfo[deviceType]->dwUsedSize + pDeviceInfo->dwDomainUserNamesSize + pDeviceInfo->dwFriendlyUserNamesSize))
            {
                // we've run out of room.  Realloc a bigger piece
                pNewDeviceInfoList = (LPDEVICEINFOLIST) realloc(m_paDeviceInfo[deviceType], m_paDeviceInfo[deviceType]->dwTotalSize + DEVICEINFO_GROW_SIZE);
    
                if (pNewDeviceInfoList == NULL)
                {
                    free(pDeviceInfoList);
                    return E_OUTOFMEMORY;
                }
                else
                {
                    m_paDeviceInfo[deviceType] = pNewDeviceInfoList;
                }

                //  Update the dwTotalSize
                m_paDeviceInfo[deviceType]->dwTotalSize = m_paDeviceInfo[deviceType]->dwTotalSize + DEVICEINFO_GROW_SIZE;
            }

            // update the sizes
            pDevice->dwDomainUserNamesSize = pDeviceInfo->dwDomainUserNamesSize;
            pDevice->dwFriendlyUserNamesSize = pDeviceInfo->dwFriendlyUserNamesSize;

            // update the new domain name info
            pDevice->dwDomainUserNamesOffset = m_paDeviceInfo[deviceType]->dwUsedSize;
            memcpy(((LPBYTE) m_paDeviceInfo[deviceType] + pDevice->dwDomainUserNamesOffset),
                   ((LPBYTE) pDeviceInfoList + pDeviceInfo->dwDomainUserNamesOffset),
                   pDeviceInfo->dwDomainUserNamesSize);

            // update the new friendly name info
            pDevice->dwFriendlyUserNamesOffset = m_paDeviceInfo[deviceType]->dwUsedSize + pDevice->dwDomainUserNamesSize;
            memcpy(((LPBYTE) m_paDeviceInfo[deviceType] + pDevice->dwFriendlyUserNamesOffset),
                   ((LPBYTE) pDeviceInfoList + pDeviceInfo->dwFriendlyUserNamesOffset),
                   pDeviceInfo->dwFriendlyUserNamesOffset);

            m_paDeviceInfo[deviceType]->dwUsedSize += (pDevice->dwDomainUserNamesSize + pDevice->dwFriendlyUserNamesSize);
        }

        pDevice++;
    }

    free(pDeviceInfoList);

    return hr;
}

/*!--------------------------------------------------------------------------
    CTapiInfo::SortDeviceInfo
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CTapiInfo::SortDeviceInfo(DEVICE_TYPE deviceType, DWORD dwProviderID, INDEX_TYPE indexType, DWORD dwSortOptions)

{
    CSingleLock cl(&m_csData);
    cl.Lock();

    HRESULT     hr = hrOK;

    if (m_paDeviceInfo[deviceType])
        m_IndexMgr[deviceType].Sort(dwProviderID, indexType, dwSortOptions, (LPBYTE) m_paDeviceInfo[deviceType]);
    
    return hr;
}

/*!--------------------------------------------------------------------------
    CTapiInfo::GetDeviceStatus
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CTapiInfo::GetDeviceStatus(DEVICE_TYPE deviceType, CString * pstrStatus, DWORD dwProviderID, int nIndex, HWND hWnd)
{
    CSingleLock cl(&m_csData);

    HRESULT         hr = hrOK;
    LPDEVICEINFO    pDevice = NULL;
    HDEVICE         hdevice;
    LONG            lReturn = 0;
    BYTE            data[256] = {0};
    LPVARSTRING     pVarStatus = (LPVARSTRING) &data[0];
    int             nHash;
    CString         strStatus;
    CString         strData;
    HWND            hWndParent;

    if (hWnd == NULL)
    {
        hWndParent = ::FindMMCMainWindow();
    }
    else
    {
        hWndParent = hWnd;
    }

    if ( !g_TapiDLL.LoadFunctionPointers() )
        return S_OK;

    if (m_hServer == NULL)
    {
        Trace0("CTapiInfo::EnumDevices - Server not initialized!\n");
        return E_FAIL;
    }

    cl.Lock();

    hr = m_IndexMgr[deviceType].GetHDevice(dwProviderID, nIndex, &hdevice);
    if (FAILED(hr))
        return hr;

    pDevice = (LPDEVICEINFO) hdevice;
    if (pDevice == NULL)
        return E_FAIL;

    // try to get the string
    pVarStatus->dwTotalSize = sizeof(data);
    switch (deviceType)
    {
        case DEVICE_LINE:
            lReturn = ((GETLINESTATUS) g_TapiDLL[TAPI_GET_LINE_STATUS])(m_hServer, 
                                                                        hWndParent,
                                                                        0,
                                                                        pDevice->dwProviderID,
                                                                        pDevice->dwPermanentDeviceID,
                                                                        pVarStatus);
            break;

        case DEVICE_PHONE:
            lReturn = ((GETLINESTATUS) g_TapiDLL[TAPI_GET_PHONE_STATUS])(m_hServer, 
                                                                        hWndParent,
                                                                        0,
                                                                        pDevice->dwProviderID,
                                                                        pDevice->dwPermanentDeviceID,
                                                                        pVarStatus);
            break;
    }

    if (lReturn != ERROR_SUCCESS)
    {
        Trace1("CTapiInfo::GetDeviceStatus - 1st call to GetDeviceStatus returned %x!\n", lReturn);
        return HRESULT_FROM_WIN32(TAPIERROR_FORMATMESSAGE(lReturn));
    }
   
    if (pVarStatus->dwNeededSize > pVarStatus->dwTotalSize)
    {
        // buffer not big enough, try again.
        pVarStatus = (LPVARSTRING) alloca(pVarStatus->dwNeededSize);
        memset(pVarStatus, 0, pVarStatus->dwNeededSize);
        pVarStatus->dwTotalSize = pVarStatus->dwNeededSize;

        switch (deviceType)
        {
            case DEVICE_LINE:
                lReturn = ((GETLINESTATUS) g_TapiDLL[TAPI_GET_LINE_STATUS])(m_hServer, 
                                                                            hWndParent,
                                                                            0,
                                                                            pDevice->dwProviderID,
                                                                            pDevice->dwPermanentDeviceID,
                                                                            pVarStatus);
                break;

            case DEVICE_PHONE:
                lReturn = ((GETLINESTATUS) g_TapiDLL[TAPI_GET_PHONE_STATUS])(m_hServer, 
                                                                            hWndParent,
                                                                            0,
                                                                            pDevice->dwProviderID,
                                                                            pDevice->dwPermanentDeviceID,
                                                                            pVarStatus);
                break;
        }
        if (lReturn != ERROR_SUCCESS)
        {
            Trace1("CTapiInfo::GetDeviceStatus - 2nd call to GetDeviceStatus returned %x!\n", lReturn);
            return HRESULT_FROM_WIN32(TAPIERROR_FORMATMESSAGE(lReturn));
        }
    }

    cl.Unlock();

    // now see if the string exists in our table.  If so, return a pointer to that,
    // otherwise add and return a pointer to our table.
    strStatus = (LPCTSTR) ((LPBYTE) pVarStatus + pVarStatus->dwStringOffset);
    if (!m_mapStatusStrings.Lookup(strStatus, strData))
    {
        Trace1("CTapiInfo::GetDeviceStatus - Entry for %s added.\n", strStatus);
        strData = strStatus;
        m_mapStatusStrings.SetAt(strStatus, strData);
    }
    else
    {
        // entry is already in our map
    }

    *pstrStatus = strData;

    return hr;
}


/*!--------------------------------------------------------------------------

    Internal functions

---------------------------------------------------------------------------*/

 /*!--------------------------------------------------------------------------
    CTapiInfo::TapiConfigToInternal
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
void        
CTapiInfo::TapiConfigToInternal(LPTAPISERVERCONFIG pTapiConfig, CTapiConfigInfo & tapiConfigInfo)
{
    HRESULT     hr = hrOK;
    UINT        uAdminLength = (pTapiConfig->dwAdministratorsSize != 0) ? pTapiConfig->dwAdministratorsSize - sizeof(WCHAR) : 0;
    UINT        uAdminOffset = 0;
    CUserInfo   userTemp;

    COM_PROTECT_TRY
    {
        if (pTapiConfig->dwDomainNameSize)
            tapiConfigInfo.m_strDomainName = (LPCTSTR) ((LPBYTE) pTapiConfig + pTapiConfig->dwDomainNameOffset);
    
        if (pTapiConfig->dwUserNameSize) 
            tapiConfigInfo.m_strUserName = (LPCTSTR) ((LPBYTE) pTapiConfig + pTapiConfig->dwUserNameOffset);

        if (pTapiConfig->dwPasswordSize) 
            tapiConfigInfo.m_strPassword = (LPCTSTR) ((LPBYTE) pTapiConfig + pTapiConfig->dwPasswordOffset);

        // add all of the administrators from the list
        while (uAdminOffset < uAdminLength)
        {
            userTemp.m_strName = (LPCTSTR) ((LPBYTE) pTapiConfig + pTapiConfig->dwAdministratorsOffset + uAdminOffset);

            if (!userTemp.m_strName.IsEmpty())
            {
                int nIndex = (int)tapiConfigInfo.m_arrayAdministrators.Add(userTemp);
            }

            uAdminOffset += (userTemp.m_strName.GetLength() + 1) * sizeof(TCHAR);
        }
    
        tapiConfigInfo.m_dwFlags = pTapiConfig->dwFlags;
    }
    COM_PROTECT_CATCH
}

/*!--------------------------------------------------------------------------
    CTapiInfo::InternalToTapiConfig
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
void        
CTapiInfo::InternalToTapiConfig(CTapiConfigInfo & tapiConfigInfo, LPTAPISERVERCONFIG * ppTapiConfig)
{
    LPTAPISERVERCONFIG  pTapiConfig = NULL;
    HRESULT             hr = hrOK;
    UINT                uSize = sizeof(TAPISERVERCONFIG);
    UINT                uDomainNameSize = 0;
    UINT                uUserNameSize = 0;
    UINT                uPasswordSize = 0;
    UINT                uAdministratorsSize = 0;
    UINT                uAdminOffset = 0;
    int                 i;

    COM_PROTECT_TRY
    {
        *ppTapiConfig = NULL;

        // calculate the size of the struct we will need
        uDomainNameSize = (tapiConfigInfo.m_strDomainName.GetLength() + 1) * sizeof(WCHAR);
        uUserNameSize = (tapiConfigInfo.m_strUserName.GetLength() + 1) * sizeof(WCHAR);
        uPasswordSize = (tapiConfigInfo.m_strPassword.GetLength() + 1) * sizeof(WCHAR);

        for (i = 0; i < tapiConfigInfo.m_arrayAdministrators.GetSize(); i++)
        {
            uAdministratorsSize += (tapiConfigInfo.m_arrayAdministrators[i].m_strName.GetLength() + 1) * sizeof(WCHAR);
        }

        // for the extra null terminator 
        if (uAdministratorsSize > 0)
            uAdministratorsSize += sizeof(WCHAR);
        else
            // if there are no names then we need two null terminators
            uAdministratorsSize += 2 * sizeof(WCHAR);


        uSize += uDomainNameSize + uUserNameSize + uPasswordSize + uAdministratorsSize;

        pTapiConfig = (LPTAPISERVERCONFIG) malloc(uSize);

		if (NULL == pTapiConfig)
		{
			return;
		}

        ZeroMemory(pTapiConfig, uSize);

        // fill in the structure
        pTapiConfig->dwTotalSize = uSize;
        pTapiConfig->dwNeededSize = uSize;
        pTapiConfig->dwUsedSize = uSize;
        pTapiConfig->dwFlags = tapiConfigInfo.m_dwFlags;

        pTapiConfig->dwDomainNameSize = uDomainNameSize;
        pTapiConfig->dwDomainNameOffset = sizeof(TAPISERVERCONFIG);
        memcpy( ((LPBYTE) pTapiConfig + pTapiConfig->dwDomainNameOffset), 
                (LPCTSTR) tapiConfigInfo.m_strDomainName, 
                uDomainNameSize );

        pTapiConfig->dwUserNameSize = uUserNameSize;
        pTapiConfig->dwUserNameOffset = sizeof(TAPISERVERCONFIG) + uDomainNameSize;
        memcpy( ((LPBYTE) pTapiConfig + pTapiConfig->dwUserNameOffset), 
                (LPCTSTR) tapiConfigInfo.m_strUserName, 
                uUserNameSize );

        pTapiConfig->dwPasswordSize = uPasswordSize;
        pTapiConfig->dwPasswordOffset = sizeof(TAPISERVERCONFIG) + uDomainNameSize + uUserNameSize;
        memcpy( ((LPBYTE) pTapiConfig + pTapiConfig->dwPasswordOffset), 
                (LPCTSTR) tapiConfigInfo.m_strPassword, 
                uPasswordSize );

        pTapiConfig->dwAdministratorsSize = uAdministratorsSize;
        pTapiConfig->dwAdministratorsOffset = sizeof(TAPISERVERCONFIG) + uDomainNameSize + uUserNameSize + uPasswordSize;

        if (uAdministratorsSize > 0)
        {
            for (i = 0; i < tapiConfigInfo.m_arrayAdministrators.GetSize(); i++)
            {
                memcpy( ((LPBYTE) pTapiConfig + pTapiConfig->dwAdministratorsOffset + uAdminOffset), 
                        (LPCTSTR) tapiConfigInfo.m_arrayAdministrators[i].m_strName,
                        (tapiConfigInfo.m_arrayAdministrators[i].m_strName.GetLength() + 1) * sizeof(WCHAR) );

                uAdminOffset += (tapiConfigInfo.m_arrayAdministrators[i].m_strName.GetLength() + 1) * sizeof(WCHAR);
            }
        }

        *ppTapiConfig = pTapiConfig;

    }
    COM_PROTECT_CATCH
}

/*!--------------------------------------------------------------------------
    CTapiInfo::TapiDeviceToInternal
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
void        
CTapiInfo::TapiDeviceToInternal(DEVICE_TYPE deviceType, LPDEVICEINFO pTapiDeviceInfo, CTapiDevice & tapiDevice)
{
    HRESULT     hr = hrOK;
    UINT        uCurSize = 0; 
    UINT        uCurOffset = 0;
    CUserInfo   userTemp;
    int         nCount = 0;

    COM_PROTECT_TRY
    {
        tapiDevice.m_dwPermanentID = pTapiDeviceInfo->dwPermanentDeviceID;
        tapiDevice.m_dwProviderID = pTapiDeviceInfo->dwProviderID;
        
        if (pTapiDeviceInfo->dwDeviceNameSize > 0)
        {
            DWORD       cch = pTapiDeviceInfo->dwDeviceNameSize / sizeof(TCHAR) + 1;
            LPTSTR      sz = tapiDevice.m_strName.GetBufferSetLength (cch);
            LPTSTR      pLastChar = sz + cch - 1;

            memcpy (
                sz, 
                (LPBYTE) m_paDeviceInfo[deviceType] + pTapiDeviceInfo->dwDeviceNameOffset,
                pTapiDeviceInfo->dwDeviceNameSize
                );

            // append NULL;
            *pLastChar = _T('\0');
        }
        else
            tapiDevice.m_strName.Empty();

        // build a list of all of the devicess

        // in the case that the string is empty then it will have 2 NULL terminators, one for the
        // name and one for the overall string
        if (pTapiDeviceInfo->dwAddressesSize > (2 * sizeof(WCHAR)))
        {
            uCurSize = pTapiDeviceInfo->dwAddressesSize - sizeof(WCHAR);
            while (uCurOffset < uCurSize)
            {
                int nIndex = (int)tapiDevice.m_arrayAddresses.Add((LPCTSTR) ((LPBYTE) m_paDeviceInfo[deviceType] + pTapiDeviceInfo->dwAddressesOffset + uCurOffset));
                uCurOffset += (tapiDevice.m_arrayAddresses[nIndex].GetLength() + 1) * sizeof(TCHAR);
            }
        }
    
        // add all of the usernames from the list

        // in the case that the string is empty then it will have 2 NULL terminators, one for the
        // name and one for the overall string
        if (pTapiDeviceInfo->dwDomainUserNamesSize > (2 * sizeof(WCHAR)))
        {
            uCurOffset = 0;
            uCurSize = pTapiDeviceInfo->dwDomainUserNamesSize - sizeof(WCHAR);
            while (uCurOffset < uCurSize)
            {
                userTemp.m_strName = (LPCTSTR) ((LPBYTE) m_paDeviceInfo[deviceType] + pTapiDeviceInfo->dwDomainUserNamesOffset + uCurOffset);
            
                int nIndex = (int)tapiDevice.m_arrayUsers.Add(userTemp);
                uCurOffset += (userTemp.m_strName.GetLength() + 1) * sizeof(TCHAR);
            }
        }
    
        // in the case that the string is empty then it will have 2 NULL terminators, one for the
        // name and one for the overall string
        if (pTapiDeviceInfo->dwFriendlyUserNamesSize > (2 * sizeof(WCHAR)))
        {
            uCurOffset = 0;
            uCurSize = pTapiDeviceInfo->dwFriendlyUserNamesSize - sizeof(WCHAR);
            while (uCurOffset < uCurSize)
            {
                tapiDevice.m_arrayUsers[nCount].m_strFullName = (LPCTSTR) ((LPBYTE) m_paDeviceInfo[deviceType] + pTapiDeviceInfo->dwFriendlyUserNamesOffset + uCurOffset);
                uCurOffset += (tapiDevice.m_arrayUsers[nCount].m_strFullName.GetLength() + 1) * sizeof(TCHAR);

                nCount++;
            }
        }
    }
    COM_PROTECT_CATCH
}

/*!--------------------------------------------------------------------------
    CTapiInfo::InternalToTapiDevice
        Takes one tapi device internal struct and builds a TAPIDEVICEINFO 
        struct for it.
    Author: EricDav
 ---------------------------------------------------------------------------*/
void        
CTapiInfo::InternalToTapiDevice(CTapiDevice & tapiDevice, LPDEVICEINFOLIST * ppTapiDeviceInfoList)
{
    LPDEVICEINFO        pDeviceInfo;
    LPDEVICEINFOLIST    pDeviceInfoList;
    HRESULT             hr = hrOK;
    UINT                uSize = 0;
    int                 i;

    COM_PROTECT_TRY
    {
        *ppTapiDeviceInfoList = NULL;

        // first calculate the size of the buffer we need
        uSize += (tapiDevice.m_strName.GetLength() + 1) * sizeof(WCHAR);
        
        for (i = 0; i < tapiDevice.m_arrayAddresses.GetSize(); i++)
        {
            uSize += (tapiDevice.m_arrayAddresses[i].GetLength() + 1) * sizeof(WCHAR);
        }

        for (i = 0; i < tapiDevice.m_arrayUsers.GetSize(); i++)
        {
            uSize += (tapiDevice.m_arrayUsers[i].m_strName.GetLength() + 1) * sizeof(WCHAR);
            uSize += (tapiDevice.m_arrayUsers[i].m_strFullName.GetLength() + 1) * sizeof(WCHAR);
        }

        // for the terminating NULLs for both addresses, domain and friendly names
        uSize += 3 * sizeof(WCHAR);

        uSize += sizeof(DEVICEINFO);
        uSize += sizeof(DEVICEINFOLIST);

        // now allocate a buffer
        pDeviceInfoList = (LPDEVICEINFOLIST) malloc(uSize);
        if (!pDeviceInfoList)
            return;

        ZeroMemory(pDeviceInfoList, uSize);

        // now fill in the info
        pDeviceInfoList->dwTotalSize = uSize;
        pDeviceInfoList->dwNeededSize = uSize;
        pDeviceInfoList->dwUsedSize = uSize;
        pDeviceInfoList->dwNumDeviceInfoEntries = 1;
        pDeviceInfoList->dwDeviceInfoSize = sizeof(DEVICEINFO);
        pDeviceInfoList->dwDeviceInfoOffset = sizeof(DEVICEINFOLIST);

        pDeviceInfo = (LPDEVICEINFO) (((LPBYTE) pDeviceInfoList) + pDeviceInfoList->dwDeviceInfoOffset);
    
        pDeviceInfo->dwPermanentDeviceID = tapiDevice.m_dwPermanentID;
        pDeviceInfo->dwProviderID = tapiDevice.m_dwProviderID;
    
        // Device name
        pDeviceInfo->dwDeviceNameSize = (tapiDevice.m_strName.GetLength() + 1) * sizeof(WCHAR);
        pDeviceInfo->dwDeviceNameOffset = pDeviceInfoList->dwDeviceInfoOffset + sizeof(DEVICEINFO);
        memcpy((LPBYTE) pDeviceInfoList + pDeviceInfo->dwDeviceNameOffset, (LPCTSTR) tapiDevice.m_strName, pDeviceInfo->dwDeviceNameSize);

        // Device addresses
        pDeviceInfo->dwAddressesOffset = pDeviceInfo->dwDeviceNameOffset + pDeviceInfo->dwDeviceNameSize;

        for (i = 0; i < tapiDevice.m_arrayAddresses.GetSize(); i++)
        {
            memcpy(((LPBYTE) pDeviceInfoList + pDeviceInfo->dwAddressesOffset + pDeviceInfo->dwAddressesSize), 
                   (LPCTSTR) tapiDevice.m_arrayAddresses[i], 
                   (tapiDevice.m_arrayAddresses[i].GetLength() + 1) * sizeof(WCHAR));
            pDeviceInfo->dwAddressesSize += (tapiDevice.m_arrayAddresses[i].GetLength() + 1) * sizeof(WCHAR);
        }

        // increment size by 1 for the extra null terminator
        pDeviceInfo->dwAddressesSize += sizeof(WCHAR);

        // now the user info
        pDeviceInfo->dwDomainUserNamesOffset = pDeviceInfo->dwAddressesOffset + pDeviceInfo->dwAddressesSize;

        for (i = 0; i < tapiDevice.m_arrayUsers.GetSize(); i++)
        {
            memcpy(((LPBYTE) pDeviceInfoList + pDeviceInfo->dwDomainUserNamesOffset + pDeviceInfo->dwDomainUserNamesSize),
                   (LPCTSTR) tapiDevice.m_arrayUsers[i].m_strName,
                   (tapiDevice.m_arrayUsers[i].m_strName.GetLength() + 1) * sizeof(WCHAR));
            pDeviceInfo->dwDomainUserNamesSize += (tapiDevice.m_arrayUsers[i].m_strName.GetLength() + 1) * sizeof(WCHAR);
        }

        // increment size by 1 for the extra null terminator
        pDeviceInfo->dwDomainUserNamesSize += sizeof(WCHAR);

        // now the friendly names
        pDeviceInfo->dwFriendlyUserNamesOffset = pDeviceInfo->dwDomainUserNamesOffset + pDeviceInfo->dwDomainUserNamesSize;

        for (i = 0; i < tapiDevice.m_arrayUsers.GetSize(); i++)
        {
            memcpy(((LPBYTE) pDeviceInfoList + pDeviceInfo->dwFriendlyUserNamesOffset + pDeviceInfo->dwFriendlyUserNamesSize),
                   (LPCTSTR) tapiDevice.m_arrayUsers[i].m_strFullName,
                   (tapiDevice.m_arrayUsers[i].m_strFullName.GetLength() + 1) * sizeof(WCHAR));
            pDeviceInfo->dwFriendlyUserNamesSize += (tapiDevice.m_arrayUsers[i].m_strFullName.GetLength() + 1) * sizeof(WCHAR);
        }

        // increment size by 1 for the extra null terminator
        pDeviceInfo->dwFriendlyUserNamesSize += sizeof(WCHAR);

        *ppTapiDeviceInfoList = pDeviceInfoList;
    }
    COM_PROTECT_CATCH
}

/*!--------------------------------------------------------------------------
    CTapiInfo::GetProviderName
        Takes a provider filename and tries to locate the friendly name.
    Author: EricDav
 ---------------------------------------------------------------------------*/
LPCTSTR
CTapiInfo::GetProviderName(DWORD dwProviderID, LPCTSTR pszFilename, LPDWORD pdwFlags)
{
    UINT i;

    if (m_pAvailProviderList)
    {
        LPAVAILABLEPROVIDERENTRY pProvider = NULL;
        pProvider = (LPAVAILABLEPROVIDERENTRY) ((LPBYTE) m_pAvailProviderList + m_pAvailProviderList->dwProviderListOffset);

        for (i = 0; i < m_pAvailProviderList->dwNumProviderListEntries; i++)
        {
            // walk the available provider info and see if we can find
            // a friendly name
            LPCTSTR pszCurFilename = (LPCWSTR) ((LPBYTE) m_pAvailProviderList + pProvider->dwFileNameOffset);
            if (lstrcmpi(pszFilename, pszCurFilename) == 0)
            {
                // found it, return 
                if (pdwFlags)
                    *pdwFlags = pProvider->dwOptions;
                
                return (LPCTSTR) ((LPBYTE) m_pAvailProviderList + pProvider->dwFriendlyNameOffset);
            }

            pProvider++;
        }
    }

    // if we can't find a friendly name for the provider, 
    // then just return the filename that was passed in.
    return pszFilename;
}

/*!--------------------------------------------------------------------------
    CTapiInfo::IsAdmin
        Says whether on not the current user is an admin on the machine
    Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
CTapiInfo::IsAdmin()
{
    HRESULT         hr = hrOK;
    BOOL            fIsAdmin = m_fIsAdmin;
    BOOL            fIsTapiAdmin = FALSE;
    CTapiConfigInfo tapiConfigInfo;
    DWORD           dwErr = 0;
    int             i = 0;

    CORg(GetConfigInfo(&tapiConfigInfo));

    if (m_strCurrentUser.IsEmpty())
    {
        dwErr = GetCurrentUser();
    }

    if (dwErr == ERROR_SUCCESS)
    {
        for (i = 0; i < tapiConfigInfo.m_arrayAdministrators.GetSize(); i++)
        {
            if (tapiConfigInfo.m_arrayAdministrators[i].m_strName.CompareNoCase(m_strCurrentUser) == 0)
            {
                fIsTapiAdmin = TRUE;
                break;
            }
        }
    }

    if (fIsTapiAdmin)
    {
        fIsAdmin = TRUE;
    }

COM_PROTECT_ERROR_LABEL;
    return fIsAdmin;
}

/*!--------------------------------------------------------------------------
    CTapiInfo::GetCurrentUser
        Get the current user
    Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CTapiInfo::GetCurrentUser()
{
    DWORD dwErr;

    dwErr = ::GetCurrentUser(m_strCurrentUser);

    return dwErr;
}

STDMETHODIMP 
CTapiInfo::GetDeviceFlags (DWORD dwProviderID, DWORD dwPermanentID, DWORD * pdwFlags)
{
    HRESULT             hr;
    DWORD               dwDeviceID;

    hr = ((GETDEVICEFLAGS) g_TapiDLL[TAPI_GET_DEVICE_FLAGS])(
        m_hServer,
        TRUE,
        dwProviderID,
        dwPermanentID,
        pdwFlags,
        &dwDeviceID
        );

    return hr;
}


/*!--------------------------------------------------------------------------
    CreateTapiInfo
        Helper to create the TapiInfo object.
    Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CreateTapiInfo(ITapiInfo ** ppTapiInfo)
{
    AFX_MANAGE_STATE(AfxGetModuleState());
    
    SPITapiInfo     spTapiInfo;
    ITapiInfo *     pTapiInfo = NULL;
    HRESULT         hr = hrOK;

    COM_PROTECT_TRY
    {
        pTapiInfo = new CTapiInfo;

        // Do this so that it will get freed on error
        spTapiInfo = pTapiInfo;

        *ppTapiInfo = spTapiInfo.Transfer();

    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
    UnloadTapiDll
        Unloads the TAPI32.DLL file.  This is necessary whenever we stop the
        TAPI service because the DLL keeps and internal handle to the service
        and if the service goes away and comes back then it is confused.
        The only way to reset that state is to unload the DLL.
    Author: EricDav
 ---------------------------------------------------------------------------*/
void UnloadTapiDll()
{
    g_TapiDLL.Unload();

    //if ( !g_TapiDLL.LoadFunctionPointers() )
    //  Assert("Could not reload the TAPI32 DLL!!!");
}


DWORD GetCurrentUser(CString & strAccount)
{
    LPBYTE pBuf;

    NET_API_STATUS status = NetWkstaUserGetInfo(NULL, 1, &pBuf);
    if (status == NERR_Success)
    {
        strAccount.Empty();

        WKSTA_USER_INFO_1 * pwkstaUserInfo = (WKSTA_USER_INFO_1 *) pBuf;
 
        strAccount = pwkstaUserInfo->wkui1_logon_domain;
        strAccount += _T("\\");
        strAccount += pwkstaUserInfo->wkui1_username;

        NetApiBufferFree(pBuf);
    }

    return (DWORD) status;
}

/*!--------------------------------------------------------------------------
    IsAdmin
        Connect to the remote machine as administrator with user-supplied
        credentials to see if the user has admin priviledges

        Returns
            TRUE - the user has admin rights
            FALSE - if user doesn't
    Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
DWORD IsAdmin(LPCTSTR szMachineName, LPCTSTR szAccount, LPCTSTR szPassword, BOOL * pIsAdmin)
{
    CString         stAccount;
    CString         stDomain;
    CString         stUser;
    CString         stMachineName;
    DWORD           dwStatus;
    BOOL            fIsAdmin = FALSE;

    // get the current user info
    if (szAccount == NULL)
    {
        GetCurrentUser(stAccount);
    }
    else
    {
        stAccount = szAccount;
    }
    
    // separate the user and domain
    int nPos = stAccount.Find(_T("\\"));
    stDomain = stAccount.Left(nPos);
    stUser = stAccount.Right(stAccount.GetLength() - nPos - 1);

    // build the machine string
    stMachineName = szMachineName;
    if ( stMachineName.Left(2) != TEXT( "\\\\" ) )
    {
        stMachineName = TEXT( "\\\\" ) + stMachineName;
    }

    // validate the domain account and get the sid 
    PSID connectSid;

    dwStatus = ValidateDomainAccount( stMachineName, stUser, stDomain, &connectSid );
    if ( dwStatus != ERROR_SUCCESS  ) 
    {
        goto Error;
    }

    // if a password was supplied, is it correct?
    if (szPassword)
    {
        dwStatus = ValidatePassword( stUser, stDomain, szPassword );

        if ( dwStatus != SEC_E_OK ) 
        {
            switch ( dwStatus ) 
            {
                case SEC_E_LOGON_DENIED:
                    dwStatus = ERROR_INVALID_PASSWORD;
                    break;

                case SEC_E_INVALID_HANDLE:
                    dwStatus = ERROR_INTERNAL_ERROR;
                    break;

                default:
                    dwStatus = ERROR_INTERNAL_ERROR;
                    break;
            } // end of switch

            goto Error;

        } // Did ValidatePassword succeed?
    }

    // now check the machine to see if this account has admin access
    fIsAdmin = IsUserAdmin( stMachineName, connectSid );

Error:
    if (pIsAdmin)
        *pIsAdmin = fIsAdmin;

    return dwStatus;
}


BOOL
IsUserAdmin(LPCTSTR pszMachine,
            PSID    AccountSid)

/*++

Routine Description:

    Determine if the specified account is a member of the local admin's group

Arguments:

    AccountSid - pointer to service account Sid

Return Value:

    True if member

--*/

{
    NET_API_STATUS status;
    DWORD count;
    WCHAR adminGroupName[UNLEN+1];
    WCHAR pwszMachine[MAX_COMPUTERNAME_LENGTH+3]; // pszMachine comes as \\<computer-name>
    DWORD cchName = UNLEN;
    PLOCALGROUP_MEMBERS_INFO_0 grpMemberInfo;
    PLOCALGROUP_MEMBERS_INFO_0 pInfo;
    DWORD entriesRead;
    DWORD totalEntries;
    DWORD_PTR resumeHandle = NULL;
    DWORD bufferSize = 128;
    BOOL foundEntry = FALSE;

    // get the name of the admin's group
    SHTCharToUnicode(pszMachine, pwszMachine, MAX_COMPUTERNAME_LENGTH+3);

    if (!LookupAliasFromRid(pwszMachine,
                            DOMAIN_ALIAS_RID_ADMINS,
                            adminGroupName,
                            &cchName)) {
        return(FALSE);
    }

    // get the Sids of the members of the admin's group

    do 
    {
        status = NetLocalGroupGetMembers(pwszMachine,
                                         adminGroupName,
                                         0,             // level 0 - just the Sid
                                         (LPBYTE *)&grpMemberInfo,
                                         bufferSize,
                                         &entriesRead,
                                         &totalEntries,
                                         &resumeHandle);

        bufferSize *= 2;
        if ( status == ERROR_MORE_DATA ) 
        {
            // we got some of the data but I want it all; free this buffer and
            // reset the context handle for the API

            NetApiBufferFree( grpMemberInfo );
            resumeHandle = NULL;
        }
    } while ( status == NERR_BufTooSmall || status == ERROR_MORE_DATA );

    if ( status == NERR_Success ) 
    {
        // loop through the members of the admin group, comparing the supplied
        // Sid to that of the group members' Sids

        for ( count = 0, pInfo = grpMemberInfo; count < totalEntries; ++count, ++pInfo ) 
        {
            if ( EqualSid( AccountSid, pInfo->lgrmi0_sid )) 
            {
                foundEntry = TRUE;
                break;
            }
        }

        NetApiBufferFree( grpMemberInfo );
    }

    return foundEntry;
}

//
//
//

BOOL
LookupAliasFromRid(
    LPWSTR TargetComputer,
    DWORD Rid,
    LPWSTR Name,
    PDWORD cchName
    )
{
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    SID_NAME_USE snu;
    PSID pSid;
    WCHAR DomainName[DNLEN+1];
    DWORD cchDomainName = DNLEN;
    BOOL bSuccess = FALSE;

    //
    // Sid is the same regardless of machine, since the well-known
    // BUILTIN domain is referenced.
    //

    if(AllocateAndInitializeSid(&sia,
                                2,
                                SECURITY_BUILTIN_DOMAIN_RID,
                                Rid,
                                0, 0, 0, 0, 0, 0,
                                &pSid)) {

        bSuccess = LookupAccountSidW(TargetComputer,
                                     pSid,
                                     Name,
                                     cchName,
                                     DomainName,
                                     &cchDomainName,
                                     &snu);

        FreeSid(pSid);
    }

    return bSuccess;
} // LookupAliasFromRid

DWORD
ValidateDomainAccount(
    IN CString Machine,
    IN CString UserName,
    IN CString Domain,
    OUT PSID * AccountSid
    )

/*++

Routine Description:

    For the given credentials, look up the account SID for the specified
    domain. As a side effect, the Sid is stored in theData->m_Sid.

Arguments:

    pointers to strings that describe the user name, domain name, and password

    AccountSid - address of pointer that receives the SID for this user

Return Value:

    TRUE if everything validated ok.

--*/

{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwSidSize = 128;
    DWORD dwDomainNameSize = 128;
    LPWSTR pwszDomainName;
    SID_NAME_USE SidType;
    CString domainAccount;
    PSID accountSid;

    domainAccount = Domain + _T("\\") + UserName;

    do {
        // Attempt to allocate a buffer for the SID. Note that apparently in the
        // absence of any error theData->m_Sid is freed only when theData goes
        // out of scope.

        accountSid = LocalAlloc( LMEM_FIXED, dwSidSize );
        pwszDomainName = (LPWSTR) LocalAlloc( LMEM_FIXED, dwDomainNameSize * sizeof(WCHAR) );

        // Was space allocated for the SID and domain name successfully?

        if ( accountSid == NULL || pwszDomainName == NULL ) {
            if ( accountSid != NULL ) {
                LocalFree( accountSid );
            }

            if ( pwszDomainName != NULL ) {
                LocalFree( pwszDomainName );
            }

            //FATALERR( IDS_ERR_NOT_ENOUGH_MEMORY, GetLastError() );    // no return
            break;
        }

        // Attempt to Retrieve the SID and domain name. If LookupAccountName failes
        // because of insufficient buffer size(s) dwSidSize and dwDomainNameSize
        // will be set correctly for the next attempt.

        if ( !LookupAccountName( Machine,
                                 domainAccount,
                                 accountSid,
                                 &dwSidSize,
                                 pwszDomainName,
                                 &dwDomainNameSize,
                                 &SidType ))
        {
            // free the Sid buffer and find out why we failed
            LocalFree( accountSid );

            dwStatus = GetLastError();
        }

        // domain name isn't needed at any time
        LocalFree( pwszDomainName );
        pwszDomainName = NULL;

    } while ( dwStatus == ERROR_INSUFFICIENT_BUFFER );

    if ( dwStatus == ERROR_SUCCESS ) {
        *AccountSid = accountSid;
    }

    return dwStatus;
} // ValidateDomainAccount

NTSTATUS
ValidatePassword(
    IN LPCWSTR UserName,
    IN LPCWSTR Domain,
    IN LPCWSTR Password
    )
/*++

Routine Description:

    Uses SSPI to validate the specified password

Arguments:

    UserName - Supplies the user name

    Domain - Supplies the user's domain

    Password - Supplies the password

Return Value:

    TRUE if the password is valid.

    FALSE otherwise.

--*/

{
    SECURITY_STATUS SecStatus;
    SECURITY_STATUS AcceptStatus;
    SECURITY_STATUS InitStatus;
    CredHandle ClientCredHandle;
    CredHandle ServerCredHandle;
    BOOL ClientCredAllocated = FALSE;
    BOOL ServerCredAllocated = FALSE;
    CtxtHandle ClientContextHandle;
    CtxtHandle ServerContextHandle;
    TimeStamp Lifetime;
    ULONG ContextAttributes;
    PSecPkgInfo PackageInfo = NULL;
    ULONG ClientFlags;
    ULONG ServerFlags;
    SEC_WINNT_AUTH_IDENTITY_W AuthIdentity;

    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;

    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;

    SecBufferDesc AuthenticateDesc;
    SecBuffer AuthenticateBuffer;

    SecBufferDesc *pChallengeDesc      = NULL;
    CtxtHandle *  pClientContextHandle = NULL;
    CtxtHandle *  pServerContextHandle = NULL;

    AuthIdentity.User = (LPWSTR)UserName;
    AuthIdentity.UserLength = lstrlenW(UserName);
    AuthIdentity.Domain = (LPWSTR)Domain;
    AuthIdentity.DomainLength = lstrlenW(Domain);
    AuthIdentity.Password = (LPWSTR)Password;
    AuthIdentity.PasswordLength = lstrlenW(Password);
    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    NegotiateBuffer.pvBuffer = NULL;
    ChallengeBuffer.pvBuffer = NULL;
    AuthenticateBuffer.pvBuffer = NULL;

    //
    // Get info about the security packages.
    //

    SecStatus = QuerySecurityPackageInfo( DEFAULT_SECURITY_PKG, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        goto error_exit;
    }

    //
    // Acquire a credential handle for the server side
    //
    SecStatus = AcquireCredentialsHandle(
                    NULL,
                    DEFAULT_SECURITY_PKG,
                    SECPKG_CRED_INBOUND,
                    NULL,
                    &AuthIdentity,
                    NULL,
                    NULL,
                    &ServerCredHandle,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        goto error_exit;
    }
    ServerCredAllocated = TRUE;

    //
    // Acquire a credential handle for the client side
    //

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    DEFAULT_SECURITY_PKG,
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    &AuthIdentity,
                    NULL,
                    NULL,
                    &ClientCredHandle,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        goto error_exit;
    }
    ClientCredAllocated = TRUE;

    NegotiateBuffer.pvBuffer = LocalAlloc( 0, PackageInfo->cbMaxToken ); // [CHKCHK] check or allocate this earlier //
    if ( NegotiateBuffer.pvBuffer == NULL ) {
        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
        goto error_exit;
    }

    ChallengeBuffer.pvBuffer = LocalAlloc( 0, PackageInfo->cbMaxToken ); // [CHKCHK]
    if ( ChallengeBuffer.pvBuffer == NULL ) {
        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
        goto error_exit;
    }

    do {

        //
        // Get the NegotiateMessage (ClientSide)
        //

        NegotiateDesc.ulVersion = 0;
        NegotiateDesc.cBuffers = 1;
        NegotiateDesc.pBuffers = &NegotiateBuffer;

        NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
        NegotiateBuffer.cbBuffer = PackageInfo->cbMaxToken;

        ClientFlags = 0; // ISC_REQ_MUTUAL_AUTH | ISC_REQ_REPLAY_DETECT; // [CHKCHK] 0

        InitStatus = InitializeSecurityContext(
                         &ClientCredHandle,
                         pClientContextHandle, // (NULL on the first pass, partially formed ctx on the next)
                         NULL,                 // [CHKCHK] szTargetName
                         ClientFlags,
                         0,                    // Reserved 1
                         SECURITY_NATIVE_DREP,
                         pChallengeDesc,       // (NULL on the first pass)
                         0,                    // Reserved 2
                         &ClientContextHandle,
                         &NegotiateDesc,
                         &ContextAttributes,
                         &Lifetime );

        if ( !NT_SUCCESS(InitStatus) ) {
            SecStatus = InitStatus;
            goto error_exit;
        }

        // ValidateBuffer( &NegotiateDesc ) // [CHKCHK]

        pClientContextHandle = &ClientContextHandle;

        //
        // Get the ChallengeMessage (ServerSide)
        //

        NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
        ChallengeDesc.ulVersion = 0;
        ChallengeDesc.cBuffers = 1;
        ChallengeDesc.pBuffers = &ChallengeBuffer;

        ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;
        ChallengeBuffer.BufferType = SECBUFFER_TOKEN;

        ServerFlags = ASC_REQ_ALLOW_NON_USER_LOGONS; // ASC_REQ_EXTENDED_ERROR; [CHKCHK]

        AcceptStatus = AcceptSecurityContext(
                        &ServerCredHandle,
                        pServerContextHandle,   // (NULL on the first pass)
                        &NegotiateDesc,
                        ServerFlags,
                        SECURITY_NATIVE_DREP,
                        &ServerContextHandle,
                        &ChallengeDesc,
                        &ContextAttributes,
                        &Lifetime );


        if ( !NT_SUCCESS(AcceptStatus) ) {
            SecStatus = AcceptStatus;
            goto error_exit;
        }

        // ValidateBuffer( &NegotiateDesc ) // [CHKCHK]

        pChallengeDesc = &ChallengeDesc;
        pServerContextHandle = &ServerContextHandle;


    } while ( AcceptStatus == SEC_I_CONTINUE_NEEDED ); // || InitStatus == SEC_I_CONTINUE_NEEDED );

error_exit:
    if (ServerCredAllocated) {
        FreeCredentialsHandle( &ServerCredHandle );
    }
    if (ClientCredAllocated) {
        FreeCredentialsHandle( &ClientCredHandle );
    }

    //
    // Final Cleanup
    //

    if ( NegotiateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( NegotiateBuffer.pvBuffer );
    }

    if ( ChallengeBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( ChallengeBuffer.pvBuffer );
    }

    if ( AuthenticateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( AuthenticateBuffer.pvBuffer );
    }
    return(SecStatus);
} // ValidatePassword
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\tapidb.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	tapidb.h

    FILE HISTORY:
        
*/

#ifndef _TAPIDB_H
#define _TAPIDB_H

#ifndef TAPI_H
#include "tapi.h"
#endif

#ifndef _TAPIMMC_H
#define _TAPIMMC_H
#include "tapimmc.h"
#endif

#ifndef __DYNAMLNK_H_INCLUDED__
#include "dynamlnk.h"
#endif

#ifndef _HARRAY_H
#include "harray.h"
#endif

interface ITapiInfo;

// we allocate a bigger line info size so that users can be added
#define DEVICEINFO_GROW_SIZE	10240

#define TAPI_DEFAULT_DEVICE_BUFF_SIZE	204800

// hash table for status strings
typedef CMap<CString, LPCTSTR, CString, CString&> CTapiStatusMap;

typedef enum _TapiApiIndex
{
	TAPI_ADD_PROVIDER = 0,
	TAPI_CONFIG_PROVIDER,
	TAPI_GET_AVAILABLE_PROVIDERS,
	TAPI_GET_LINE_INFO,
	TAPI_GET_LINE_STATUS,
	TAPI_GET_PHONE_INFO,
	TAPI_GET_PHONE_STATUS,
	TAPI_GET_PROVIDER_LIST,
	TAPI_GET_SERVER_CONFIG,
	TAPI_INITIALIZE,
	TAPI_REMOVE_PROVIDER,
	TAPI_SET_LINE_INFO,
	TAPI_SET_PHONE_INFO,
	TAPI_SET_SERVER_CONFIG,
	TAPI_GET_DEVICE_FLAGS,
	TAPI_SHUTDOWN
};

// not subject to localization
static LPCSTR g_apchFunctionNames[] = {
	"MMCAddProvider",
	"MMCConfigProvider",
	"MMCGetAvailableProviders",
	"MMCGetLineInfo",
	"MMCGetLineStatus",
	"MMCGetPhoneInfo",
	"MMCGetPhoneStatus",
	"MMCGetProviderList",
	"MMCGetServerConfig",
	"MMCInitialize",
	"MMCRemoveProvider",
	"MMCSetLineInfo",
	"MMCSetPhoneInfo",
	"MMCSetServerConfig",
	"MMCGetDeviceFlags",
	"MMCShutdown",
	NULL
};

// not subject to localization
extern DynamicDLL g_TapiDLL;

typedef LONG (*ADDPROVIDER)             (HMMCAPP, HWND, LPCWSTR, LPDWORD);
typedef LONG (*CONFIGPROVIDER)          (HMMCAPP, HWND, DWORD);
typedef LONG (*GETAVAILABLEPROVIDERS)   (HMMCAPP, LPAVAILABLEPROVIDERLIST);
typedef LONG (*GETLINEINFO)             (HMMCAPP, LPVOID);
typedef LONG (*GETLINESTATUS)           (HMMCAPP, HWND, DWORD, DWORD, DWORD, LPVARSTRING);
typedef LONG (*GETPHONEINFO)            (HMMCAPP, LPVOID);
typedef LONG (*GETPHONESTATUS)          (HMMCAPP, HWND, DWORD, DWORD, DWORD, LPVARSTRING);
typedef LONG (*GETPROVIDERLIST)         (HMMCAPP, LPLINEPROVIDERLIST);
typedef LONG (*GETSERVERCONFIG)         (HMMCAPP, LPTAPISERVERCONFIG);
typedef LONG (*INITIALIZE)              (LPCWSTR, LPHMMCAPP, LPDWORD, HANDLE);
typedef LONG (*REMOVEPROVIDER)          (HMMCAPP, HWND, DWORD);
typedef LONG (*SETLINEINFO)             (HMMCAPP, LPVOID);
typedef LONG (*SETPHONEINFO)            (HMMCAPP, LPVOID);
typedef LONG (*SETSERVERCONFIG)         (HMMCAPP, LPTAPISERVERCONFIG);
typedef LONG (*GETDEVICEFLAGS)          (HMMCAPP, BOOL, DWORD, DWORD, LPDWORD, LPDWORD);
typedef LONG (*SHUTDOWN)                (HMMCAPP);

class CTapiConfigInfo
{
public:
    CString         m_strDomainName;
    CString         m_strUserName;
    CString         m_strPassword;
    CUserInfoArray  m_arrayAdministrators;
    DWORD           m_dwFlags;
};

class CTapiProvider
{
public:
    DWORD       m_dwProviderID;
    DWORD       m_dwFlags;
    CString     m_strName;
    CString     m_strFilename;
};

class CTapiDevice
{
public:
    DWORD           m_dwPermanentID;
    DWORD           m_dwProviderID;
    CString         m_strName;
    CStringArray    m_arrayAddresses;
    CUserInfoArray  m_arrayUsers;
};

typedef enum _DEVICE_TYPE
{
	DEVICE_LINE = 0,
    DEVICE_PHONE,
    DEVICE_TYPE_MAX
} DEVICE_TYPE, * LPDEVICE_TYPE;

// for our interface
#define DeclareITapiInfoMembers(IPURE) \
	STDMETHOD(Initialize) (THIS) IPURE; \
	STDMETHOD(Reset) (THIS) IPURE; \
	STDMETHOD(Destroy) (THIS) IPURE; \
    STDMETHOD(EnumConfigInfo) (THIS) IPURE; \
	STDMETHOD(GetConfigInfo) (THIS_ CTapiConfigInfo * ptapiConfigInfo) IPURE; \
	STDMETHOD(SetConfigInfo) (THIS_ CTapiConfigInfo * ptapiConfigInfo) IPURE; \
	STDMETHOD_(BOOL, IsServer) (THIS) IPURE; \
	STDMETHOD_(BOOL, IsTapiServer) (THIS) IPURE; \
	STDMETHOD(SetComputerName) (THIS_ LPCTSTR pComputer) IPURE; \
	STDMETHOD_(LPCTSTR, GetComputerName) (THIS) IPURE; \
    STDMETHOD_(int, GetProviderCount) (THIS) IPURE; \
	STDMETHOD(EnumProviders) (THIS) IPURE; \
	STDMETHOD(GetProviderInfo) (THIS_ CTapiProvider * pproviderInfo, int nIndex) IPURE; \
	STDMETHOD(GetProviderInfo) (THIS_ CTapiProvider * pproviderInfo, DWORD dwProviderID) IPURE; \
    STDMETHOD(AddProvider) (THIS_ LPCTSTR pProviderFilename, LPDWORD pdwProviderID, HWND hWnd) IPURE; \
	STDMETHOD(ConfigureProvider) (THIS_ DWORD dwProviderID, HWND hWnd) IPURE; \
	STDMETHOD(RemoveProvider) (THIS_ DWORD dwProviderID, HWND hWnd) IPURE; \
    STDMETHOD(EnumDevices) (THIS_ DEVICE_TYPE deviceType) IPURE; \
    STDMETHOD_(int, GetTotalDeviceCount) (THIS_ DEVICE_TYPE deviceType) IPURE; \
    STDMETHOD_(int, GetDeviceCount) (THIS_ DEVICE_TYPE deviceType, DWORD dwProviderID) IPURE; \
	STDMETHOD(GetDeviceInfo) (THIS_ DEVICE_TYPE deviceType, CTapiDevice * ptapiDevice, DWORD dwProviderID, int nIndex) IPURE; \
	STDMETHOD(SetDeviceInfo) (THIS_ DEVICE_TYPE deviceType, CTapiDevice * ptapiDevice) IPURE; \
	STDMETHOD(SortDeviceInfo) (THIS_ DEVICE_TYPE deviceType, DWORD dwProviderID, INDEX_TYPE indexType, DWORD dwSortOptions) IPURE; \
	STDMETHOD(GetDeviceStatus) (THIS_ DEVICE_TYPE deviceType, CString * pstrStatus, DWORD dwProviderID, int nIndex, HWND hWnd) IPURE; \
    STDMETHOD_(int, GetAvailableProviderCount) (THIS) IPURE; \
	STDMETHOD(EnumAvailableProviders) (THIS) IPURE; \
	STDMETHOD(GetAvailableProviderInfo) (THIS_ CTapiProvider * pproviderInfo, int nIndex) IPURE; \
	STDMETHOD_(BOOL,IsAdmin) (THIS) IPURE; \
	STDMETHOD_(BOOL,IsLocalMachine) (THIS) IPURE; \
	STDMETHOD_(BOOL,FHasServiceControl) (THIS) IPURE; \
	STDMETHOD(SetCachedLineBuffSize) (THIS_ DWORD dwLineSize) IPURE; \
	STDMETHOD(SetCachedPhoneBuffSize) (THIS_ DWORD dwPhoneSize) IPURE; \
	STDMETHOD_(DWORD,GetCachedLineBuffSize) (THIS) IPURE; \
	STDMETHOD_(DWORD,GetCachedPhoneBuffSize) (THIS) IPURE; \
	STDMETHOD_(BOOL,IsCacheDirty) (THIS) IPURE; \
	STDMETHOD(GetDeviceFlags) (THIS_ DWORD dwProviderID, DWORD dwPermanentID, LPDWORD pdwFlags) IPURE; \

#undef INTERFACE
#define INTERFACE ITapiInfo
DECLARE_INTERFACE_(ITapiInfo, IUnknown)
{
	DeclareIUnknownMembers(PURE)
	DeclareITapiInfoMembers(PURE)
};
typedef ComSmartPointer<ITapiInfo, &IID_ITapiInfo> SPITapiInfo;

// now the object that implements ITapiInfo
class CTapiInfo : public ITapiInfo
{
public:
    CTapiInfo();
    ~CTapiInfo();

    DeclareIUnknownMembers(IMPL);
    DeclareITapiInfoMembers(IMPL);

private:
    void        TapiConfigToInternal(LPTAPISERVERCONFIG pTapiConfig, CTapiConfigInfo & tapiConfigInfo);
    void        InternalToTapiConfig(CTapiConfigInfo & tapiConfigInfo, LPTAPISERVERCONFIG * pTapiConfig);

    void        TapiDeviceToInternal(DEVICE_TYPE deviceType, LPDEVICEINFO pTapiDeviceInfo, CTapiDevice & tapiDevice);
    void        InternalToTapiDevice(CTapiDevice & tapiDevice, LPDEVICEINFOLIST * pTapiDeviceInfoList);
    int         CalcHashValue(LPCTSTR pString);

    LPCTSTR     GetProviderName(DWORD dwProviderID, LPCTSTR pszFilename, LPDWORD pdwFlags);

    DWORD       GetCurrentUser();

private:
    HMMCAPP                 m_hServer;        // handle to server
    LPTAPISERVERCONFIG      m_pTapiConfig;
    LPLINEPROVIDERLIST      m_pProviderList;
    LPAVAILABLEPROVIDERLIST m_pAvailProviderList;

    LPDEVICEINFOLIST        m_paDeviceInfo[DEVICE_TYPE_MAX];

    CString                 m_strComputerName;

    DWORD                   m_dwApiVersion;
    HANDLE                  m_hReinit;

    CIndexMgr               m_IndexMgr[DEVICE_TYPE_MAX];

    CCriticalSection        m_csData;

    CTapiStatusMap          m_mapStatusStrings;

    HANDLE                  m_hResetEvent;

    LONG                    m_cRef;

    BOOL                    m_fIsAdmin;
    CString                 m_strCurrentUser;

	BOOL					m_fIsLocalMachine;

	DWORD					m_dwCachedLineSize;
	DWORD					m_dwCachedPhoneSize;
	BOOL					m_fCacheDirty;
};

HRESULT CreateTapiInfo(ITapiInfo ** ppTapiInfo);
void	UnloadTapiDll();
DWORD   IsAdmin(LPCTSTR szMachineName, LPCTSTR szAccount, LPCTSTR szPassword, BOOL * pfIsAdmin);

#endif _TAPIDB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\stdafx.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	stdafx.h
		include file for standard system include files,
		or project specific include files that are used frequently,
		but are changed infrequently

	FILE HISTORY:
        
*/


#include <afxwin.h>
#include <afxdisp.h>
#include <afxcmn.h>
#include <afxtempl.h>
#include <afxcview.h>
#include <afxext.h>
#include <afxmt.h>

#include <atlbase.h>
#include <htmlhelp.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//#pragma comment(lib, "mmc")
#include <mmc.h>

extern "C"
{
	#include "winsock.h"     //  WinSock definitions
	#include "lmerr.h"

    // for get user stuff
    #include <wtypes.h>
}


#include "resource.h"

// Global defines for TAPI snapin
#include "tapisnap.h"

// Files from ..\tfscore
#include <dbgutil.h>
#include <std.h>
#include <errutil.h>
#include <register.h>

// Files from ..\common
#include <ccdata.h>
#include <about.h>
#include <dataobj.h>
#include <proppage.h>
#include <ipaddr.hpp>
#include <dialog.h>
#include <objpick.h>

// from ..\remras\inc
#include "remras.h"		 // remote network config 

// from ..\mprinc
#include "rtrguid.h"

// project specific
#include "tapicomp.h"
#include "tapihelp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\tapicomp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    tapicomp.cpp
        This file contains the derived implementations from CComponent
        and CComponentData for the TAPI admin snapin.

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "tapicomp.h"
#include "root.h"
#include "server.h"

#include <atlimpl.cpp>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

DWORD gdwTapiSnapVersion;

UINT aColumns[TAPISNAP_NODETYPE_MAX][MAX_COLUMNS] =
{
    {IDS_ROOT_NAME,       0,                0,          0,          0},
    {IDS_SERVER_NAME,     0         ,       0,          0,          0},
    {IDS_LINE_NAME,       IDS_USERS,        IDS_STATUS, 0,          0},
    {0,0,0,0,0}
};

//
// CODEWORK this should be in a resource, for example code on loading data resources see
//   D:\nt\private\net\ui\common\src\applib\applib\lbcolw.cxx ReloadColumnWidths()
//   JonN 10/11/96
//
int aColumnWidths[TAPISNAP_NODETYPE_MAX][MAX_COLUMNS] =
{   
    {200       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // TAPISNAP_ROOT
    {200       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // TAPISNAP_SERVER
    {150       ,200       ,200       ,AUTO_WIDTH,AUTO_WIDTH}, // TAPISNAP_PROVIDER
    {AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, 
};

#define HI HIDDEN
#define EN ENABLED

MMC_CONSOLE_VERB g_ConsoleVerbs[] =
{
    MMC_VERB_OPEN,
    MMC_VERB_COPY,
    MMC_VERB_PASTE,
    MMC_VERB_DELETE,
    MMC_VERB_PROPERTIES,
    MMC_VERB_RENAME,
    MMC_VERB_REFRESH,
    MMC_VERB_PRINT
};

// default states for the console verbs
MMC_BUTTON_STATE g_ConsoleVerbStates[TAPISNAP_NODETYPE_MAX][ARRAYLEN(g_ConsoleVerbs)] =
{
    {HI, HI, HI, HI, HI, HI, HI, HI}, // TAPISNAP_ROOT
    {HI, HI, HI, EN, EN, HI, EN, HI}, // TAPISNAP_SERVER
    {HI, HI, HI, EN, HI, HI, HI, HI}, // TAPISNAP_PROVIDER
    {HI, HI, HI, HI, HI, HI, HI, HI}, // TAPISNAP_LINE
};

// default states for the console verbs
MMC_BUTTON_STATE g_ConsoleVerbStatesMultiSel[TAPISNAP_NODETYPE_MAX][ARRAYLEN(g_ConsoleVerbs)] =
{
    {HI, HI, HI, HI, HI, HI, HI, HI}, // TAPISNAP_ROOT
    {HI, HI, HI, EN, EN, HI, EN, HI}, // TAPISNAP_SERVER
    {HI, HI, HI, EN, HI, HI, EN, HI}, // TAPISNAP_PROVIDER
    {HI, HI, HI, EN, HI, HI, HI, HI}, // TAPISNAP_LINE
};

// Help ID array for help on scope items
DWORD g_dwMMCHelp[TAPISNAP_NODETYPE_MAX] =
{
    TAPISNAP_HELP_ROOT,                // TAPISNAP_ROOT
    TAPISNAP_HELP_SERVER,              // TAPISNAP_SERVER
    TAPISNAP_HELP_PROVIDER,            // TAPISNAP_PROVIDER
    TAPISNAP_HELP_DEVICE,              // TAPISNAP_DEVICE
};

// icon defines
UINT g_uIconMap[ICON_IDX_MAX + 1][2] = 
{
    {IDI_ICON01,        ICON_IDX_SERVER},
    {IDI_ICON02,        ICON_IDX_SERVER_BUSY},
    {IDI_ICON03,        ICON_IDX_SERVER_CONNECTED},
    {IDI_ICON04,        ICON_IDX_SERVER_LOST_CONNECTION},
    {IDI_ICON05,        ICON_IDX_MACHINE},
    {IDI_ICON06,        ICON_IDX_FOLDER_CLOSED},
    {IDI_ICON07,        ICON_IDX_FOLDER_OPEN},
    {IDI_TAPI_SNAPIN,   ICON_IDX_PRODUCT},
    {0, 0}
};

/*!--------------------------------------------------------------------------
    GetSystemMessage
        Use FormatMessage() to get a system error message
    Author: EricDav
 ---------------------------------------------------------------------------*/
LONG 
GetSystemMessage 
(
    UINT    nId,
    TCHAR * chBuffer,
    int     cbBuffSize 
)
{
    TCHAR * pszText = NULL ;
    HINSTANCE hdll = NULL ;

    DWORD flags = FORMAT_MESSAGE_IGNORE_INSERTS
        | FORMAT_MESSAGE_MAX_WIDTH_MASK;

    //
    //  Interpret the error.  Need to special case
    //  the lmerr & ntstatus ranges, as well as
    //  dhcp server error messages.
    //

    if (nId > 0x0000E000 && nId <= 0x0000FFFF)
    {
        hdll = LoadLibrary( _T("tapiui.dll") );
    }   
    else if( nId >= NERR_BASE && nId <= MAX_NERR )
    {
        hdll = LoadLibrary( _T("netmsg.dll") );
    }
    else if( nId >= 0x40000000L )
    {
        hdll = LoadLibrary( _T("ntdll.dll") );
    }

    if( hdll == NULL )
    {
        flags |= FORMAT_MESSAGE_FROM_SYSTEM;
    }
    else
    {
        flags |= FORMAT_MESSAGE_FROM_HMODULE;
    }

    //
    //  Let FormatMessage do the dirty work.
    //
    DWORD dwResult = ::FormatMessage( flags,
                      (LPVOID) hdll,
                      nId,
                      0,
                      chBuffer,
                      cbBuffSize,
                      NULL ) ;

    if( hdll != NULL )
    {
        LONG err = GetLastError();
        FreeLibrary( hdll );
        if ( dwResult == 0 )
        {
            ::SetLastError( err );
        }
    }

    return dwResult ? 0 : ::GetLastError() ;
}

/*!--------------------------------------------------------------------------
    LoadMessage
        Loads the error message from the correct DLL.
    Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
LoadMessage 
(
    UINT    nIdPrompt,
    TCHAR * chMsg,
    int     nMsgSize
)
{
    BOOL bOk;

    //
    // Substitute a friendly message for "RPC server not
    // available" and "No more endpoints available from
    // the endpoint mapper".
    //
    if (nIdPrompt == EPT_S_NOT_REGISTERED ||
        nIdPrompt == RPC_S_SERVER_UNAVAILABLE)
    {
        nIdPrompt = IDS_ERR_TAPI_DOWN;
    }
    else if (nIdPrompt == RPC_S_PROCNUM_OUT_OF_RANGE)
    {
        nIdPrompt = IDS_ERR_RPC_NO_ENTRY;      
    }

    //
    //  If it's a socket error or our error, the text is in our resource fork.
    //  Otherwise, use FormatMessage() and the appropriate DLL.
    //
    if (nIdPrompt >= IDS_ERR_BASE && nIdPrompt < IDS_MESG_MAX)
    {
        //
        //  It's in our resource fork
        //
        bOk = ::LoadString( AfxGetInstanceHandle(), nIdPrompt, chMsg, nMsgSize ) != 0 ;
    }
    else
    {
        //
        //  It's in the system somewhere.
        //
        bOk = GetSystemMessage( nIdPrompt, chMsg, nMsgSize ) == 0 ;
    }

    //
    //  If the error message did not compute, replace it.
    //
    if ( ! bOk ) 
    {
        TCHAR chBuff [STRING_LENGTH_MAX] ;
        static const TCHAR * pszReplacement = _T("System Error: %ld");
        const TCHAR * pszMsg = pszReplacement ;

        //
        //  Try to load the generic (translatable) error message text
        //
        if ( ::LoadString( AfxGetInstanceHandle(), IDS_ERR_MESSAGE_GENERIC, 
            chBuff, sizeof(chBuff)/sizeof(TCHAR) ) != 0 ) 
        {
            pszMsg = chBuff ;
        }
        ::wsprintf( chMsg, pszMsg, nIdPrompt ) ;
    }

    return bOk;
}

/*!--------------------------------------------------------------------------
    TapiMessageBox
        Puts up a message box with the corresponding error text.
    Author: EricDav
 ---------------------------------------------------------------------------*/
int 
TapiMessageBox 
(
    UINT            nIdPrompt,
    UINT            nType,
    const TCHAR *   pszSuffixString,
    UINT            nHelpContext 
)
{
    TCHAR chMesg [4000] ;
    BOOL bOk ;

    chMesg[0] = 0;
    bOk = LoadMessage(nIdPrompt, chMesg, sizeof(chMesg)/sizeof(TCHAR));
    if ( pszSuffixString ) 
    {
        ::lstrcat( chMesg, _T("  ") ) ;
        ::lstrcat( chMesg, pszSuffixString ) ; 
    }

    return ::AfxMessageBox( chMesg, nType, nHelpContext ) ;
}

/*!--------------------------------------------------------------------------
    TapiMessageBoxEx
        Puts up a message box with the corresponding error text.
    Author: EricDav
 ---------------------------------------------------------------------------*/
int 
TapiMessageBoxEx
(
    UINT        nIdPrompt,
    LPCTSTR     pszPrefixMessage,
    UINT        nType,
    UINT        nHelpContext
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    TCHAR       chMesg[4000];
    CString     strMessage;
    BOOL        bOk;

    bOk = LoadMessage(nIdPrompt, chMesg, sizeof(chMesg)/sizeof(TCHAR));
    if ( pszPrefixMessage ) 
    {
        strMessage = pszPrefixMessage;
        strMessage += _T("\n");
        strMessage += _T("\n");
        strMessage += chMesg;
    }
    else
    {
        strMessage = chMesg;
    }

    return AfxMessageBox(strMessage, nType, nHelpContext);
}

/*---------------------------------------------------------------------------
    Class CTapiComponent implementation
 ---------------------------------------------------------------------------*/
CTapiComponent::CTapiComponent()
{
    m_pbmpToolbar = NULL;
}

CTapiComponent::~CTapiComponent()
{
    if (m_pbmpToolbar)
    {
        delete m_pbmpToolbar;
        m_pbmpToolbar = NULL;
    }
}

STDMETHODIMP CTapiComponent::InitializeBitmaps(MMC_COOKIE cookie)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(m_spImageList != NULL);
    HICON   hIcon;

    for (int i = 0; i < ICON_IDX_MAX; i++)
    {
        hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
        if (hIcon)
        {
            // call mmc
            VERIFY(SUCCEEDED(m_spImageList->ImageListSetIcon(reinterpret_cast<LONG_PTR*>(hIcon), g_uIconMap[i][1])));
        }
    }

    return S_OK;
}

/*!--------------------------------------------------------------------------
    CTapiComponent::QueryDataObject
        Implementation of IComponent::QueryDataObject.  We need this for
        virtual listbox support.  MMC calls us back normally with the cookie
        we handed it...  In the case of the VLB, it hands us the index of 
        the item.  So, we need to do some extra checking...
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CTapiComponent::QueryDataObject
(
    MMC_COOKIE              cookie, 
    DATA_OBJECT_TYPES       type,
    LPDATAOBJECT*           ppDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    SPITFSNode          spSelectedNode;
    SPITFSResultHandler spResultHandler;
    long                lViewOptions;
    LPOLESTR            pViewType;
    CDataObject *       pDataObject;

    COM_PROTECT_TRY
    {
        // check to see what kind of result view type the selected node has
        CORg (GetSelectedNode(&spSelectedNode));
        CORg (spSelectedNode->GetResultHandler(&spResultHandler));
   
        CORg (spResultHandler->OnGetResultViewType(this, spSelectedNode->GetData(TFS_DATA_COOKIE), &pViewType, &lViewOptions));

        if ( (lViewOptions & MMC_VIEW_OPTIONS_OWNERDATALIST) ||
             (cookie == MMC_MULTI_SELECT_COOKIE) )
        {
            if (cookie == MMC_MULTI_SELECT_COOKIE)
            {
                // this is a special case for multiple select.  We need to build a list
                // of GUIDs and the code to do this is in the handler...
                spResultHandler->OnCreateDataObject(this, cookie, type, ppDataObject);
            }
            else
            {
                // this node has a virtual listbox for the result pane.  Gerenate
                // a special data object using the selected node as the cookie
                Assert(m_spComponentData != NULL);
                CORg (m_spComponentData->QueryDataObject(reinterpret_cast<MMC_COOKIE>((ITFSNode *) spSelectedNode), type, ppDataObject));
            }

            pDataObject = reinterpret_cast<CDataObject *>(*ppDataObject);
            pDataObject->SetVirtualIndex((int) cookie);
        }
        else
        {
            // just forward this to the component data
            Assert(m_spComponentData != NULL);
            CORg (m_spComponentData->QueryDataObject(cookie, type, ppDataObject));
        }

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
    CTapiComponentData::SetControlbar
        -
    Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
HRESULT
CTapiComponent::SetControlbar
(
    LPCONTROLBAR    pControlbar
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;

    if (pControlbar)
    {
    }

    // store the control bar away for future use
    m_spControlbar.Set(pControlbar);

    return hr;
}

/*!--------------------------------------------------------------------------
    CTapiComponentData::ControlbarNotify
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CTapiComponent::ControlbarNotify
(
    MMC_NOTIFY_TYPE event, 
    LPARAM          arg, 
    LPARAM          param
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;

    return hr;
}

/*!--------------------------------------------------------------------------
    CTapiComponentData::OnSnapinHelp
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CTapiComponent::OnSnapinHelp
(
    LPDATAOBJECT    pDataObject,
    LPARAM          arg, 
    LPARAM          param
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;

    HtmlHelpA(NULL, "tapisnap.chm", HH_DISPLAY_TOPIC, 0);

    return hr;
}

/*---------------------------------------------------------------------------
    Class CTapiComponentData implementation
 ---------------------------------------------------------------------------*/
CTapiComponentData::CTapiComponentData()
{
    gdwTapiSnapVersion = TAPISNAP_VERSION;
}

/*!--------------------------------------------------------------------------
    CTapiComponentData::OnInitialize
        -
    Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CTapiComponentData::OnInitialize(LPIMAGELIST pScopeImage)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HICON   hIcon;

    for (int i = 0; i < ICON_IDX_MAX; i++)
    {
        hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
        if (hIcon)
        {
            // call mmc
            VERIFY(SUCCEEDED(pScopeImage->ImageListSetIcon(reinterpret_cast<LONG_PTR*>(hIcon), g_uIconMap[i][1])));
        }
    }

    return hrOK;
}

/*!--------------------------------------------------------------------------
    CTapiComponentData::OnDestroy
        -
    Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CTapiComponentData::OnDestroy()
{
    m_spNodeMgr.Release();
    return hrOK;
}

/*!--------------------------------------------------------------------------
    CTapiComponentData::OnInitializeNodeMgr
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CTapiComponentData::OnInitializeNodeMgr
(
    ITFSComponentData * pTFSCompData, 
    ITFSNodeMgr *       pNodeMgr
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // For now create a new node handler for each new node,
    // this is rather bogus as it can get expensive.  We can
    // consider creating only a single node handler for each
    // node type.
    CTapiRootHandler *  pHandler = NULL;
    SPITFSNodeHandler   spHandler;
    SPITFSNode          spNode;
    HRESULT             hr = hrOK;

    try
    {
        pHandler = new CTapiRootHandler(pTFSCompData);

        // Do this so that it will get released correctly
        spHandler = pHandler;
    }
    catch(...)
    {
        hr = E_OUTOFMEMORY;
    }
    CORg( hr );
    
    // Create the root node for this sick puppy
    CORg( CreateContainerTFSNode(&spNode,
                                 &GUID_TapiRootNodeType,
                                 pHandler,
                                 pHandler,       /* result handler */
                                 pNodeMgr) );

    // Need to initialize the data for the root node
    pHandler->InitializeNode(spNode);   

    CORg( pNodeMgr->SetRootNode(spNode) );
    m_spRootNode.Set(spNode);

    pTFSCompData->SetHTMLHelpFileName(_T("tapisnap.chm"));

Error:  
    return hr;
}

/*!--------------------------------------------------------------------------
    CTapiComponentData::OnCreateComponent
        -
    Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CTapiComponentData::OnCreateComponent
(
    LPCOMPONENT *ppComponent
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(ppComponent != NULL);
    
    HRESULT           hr = hrOK;
    CTapiComponent *  pComp = NULL;

    try
    {
        pComp = new CTapiComponent;
    }
    catch(...)
    {
        hr = E_OUTOFMEMORY;
    }

    if (FHrSucceeded(hr))
    {
        pComp->Construct(m_spNodeMgr,
                        static_cast<IComponentData *>(this),
                        m_spTFSComponentData);
        *ppComponent = static_cast<IComponent *>(pComp);
    }
    return hr;
}

/*!--------------------------------------------------------------------------
    CTapiComponentData::GetCoClassID
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(const CLSID *) 
CTapiComponentData::GetCoClassID()
{
    return &CLSID_TapiSnapin;
}

/*!--------------------------------------------------------------------------
    CTapiComponentData::OnCreateDataObject
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CTapiComponentData::OnCreateDataObject
(
    MMC_COOKIE          cookie, 
    DATA_OBJECT_TYPES   type, 
    IDataObject **      ppDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Assert(ppDataObject != NULL);

    CDataObject *   pObject = NULL;
    SPIDataObject   spDataObject;
    
    pObject = new CDataObject;
    spDataObject = pObject; // do this so that it gets released correctly
                        
    Assert(pObject != NULL);

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    // Store the coclass with the data object
    pObject->SetClsid(*GetCoClassID());

    pObject->SetTFSComponentData(m_spTFSComponentData);

    return  pObject->QueryInterface(IID_IDataObject, 
                                    reinterpret_cast<void**>(ppDataObject));
}

///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members
STDMETHODIMP 
CTapiComponentData::GetClassID
(
    CLSID *pClassID
)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_TapiSnapin;

    return hrOK;
}

STDMETHODIMP 
CTapiComponentData::IsDirty()
{
    HRESULT hr = hrFalse;

    if (m_spRootNode->GetData(TFS_DATA_DIRTY))
    {
        hr = hrOK;
    }
    else 
    {
        //check whether the cache is dirtry

        SPITFSNodeEnum spNodeEnum;
        SPITFSNode spCurrentNode;
        ULONG nNumReturned = 0;

        m_spRootNode->GetEnum(&spNodeEnum);

        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        while (nNumReturned)
        {
            CTapiServer * pServer = GETHANDLER(CTapiServer, spCurrentNode);

            if (pServer->IsCacheDirty())
            {
                hr = hrOK;
                spCurrentNode.Release();
                break;
            }

            // go to the next node
            spCurrentNode.Release();
            spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        }
    }
    
    return hr;
}

STDMETHODIMP 
CTapiComponentData::Load
(
    IStream *pStm
)
{
    HRESULT     hr = hrOK;
    DWORD       dwSavedVersion;
    CString     str;
    int         i, j;
    
    ASSERT(pStm);

    CStringArray strArrayName;
    CDWordArray dwArrayRefreshInterval;
    CDWordArray dwArrayOptions;
    CDWordArray dwArrayColumnInfo;

    CDWordArray dwArrayLines;
    CDWordArray dwArrayPhones;

    ASSERT(pStm);
    
    CTapiRootHandler * pRootHandler = GETHANDLER(CTapiRootHandler, m_spRootNode);

    // set the mode for this stream
    XferStream xferStream(pStm, XferStream::MODE_READ);    
    
    // read the version of the file format
    DWORD dwFileVersion;
    CORg(xferStream.XferDWORD(TAPISTRM_TAG_VERSION, &dwFileVersion));
    if (dwFileVersion < TAPISNAP_FILE_VERSION_1)
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        AfxMessageBox(IDS_ERR_OLD_CONSOLE_FILE);
        return hr;
    }

    // Read the version # of the admin tool
    CORg(xferStream.XferDWORD(TAPISTRM_TAG_VERSIONADMIN, &dwSavedVersion));
    if (dwSavedVersion < gdwTapiSnapVersion)
    {
        // File is an older version.  Warn the user and then don't
        // load anything else
        Assert(FALSE);
    }

    // now read all of the server information
    CORg(xferStream.XferCStringArray(TAPISTRM_TAG_SERVER_NAME, &strArrayName));
    CORg(xferStream.XferDWORDArray(TAPISTRM_TAG_SERVER_REFRESH_INTERVAL, &dwArrayRefreshInterval));
    CORg(xferStream.XferDWORDArray(TAPISTRM_TAG_SERVER_OPTIONS, &dwArrayOptions));

    // now load the column information
    for (i = 0; i < NUM_SCOPE_ITEMS; i++)
    {
        CORg(xferStream.XferDWORDArray(TAPISTRM_TAG_COLUMN_INFO, &dwArrayColumnInfo));

        for (j = 0; j < MAX_COLUMNS; j++)
        {
            aColumnWidths[i][j] = dwArrayColumnInfo[j];
        }
    }

    if (dwFileVersion >= TAPISNAP_FILE_VERSION)
    {
        CORg(xferStream.XferDWORDArray(TAPISTRM_TAG_SERVER_LINE_SIZE, &dwArrayLines));
        CORg(xferStream.XferDWORDArray(TAPISTRM_TAG_SERVER_PHONE_SIZE, &dwArrayPhones));
    }

    // now create the servers based on the information
    for (i = 0; i < strArrayName.GetSize(); i++)
    {
        //
        // check if this is the local server 
        //
        if (dwArrayOptions[i] & TAPISNAP_OPTIONS_LOCAL)
        {
            //
            // the computer name might have changed; if it did, load the new name
            //
            TCHAR   szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
            DWORD   dwSize = MAX_COMPUTERNAME_LENGTH + 1;

            if (GetComputerName (szComputerName, &dwSize))
            {
                if (_tcsicmp(szComputerName, strArrayName[i]))
                {
                    strArrayName[i] = szComputerName;
                }
            }
        }

        //
        // now create the server object
        //
        pRootHandler->AddServer(NULL, 
                                strArrayName[i],
                                FALSE, 
                                dwArrayOptions[i], 
                                dwArrayRefreshInterval[i],
                                FALSE,
                                (dwFileVersion >= TAPISNAP_FILE_VERSION) ? dwArrayLines[i] : 0,
                                (dwFileVersion >= TAPISNAP_FILE_VERSION) ? dwArrayPhones[i] : 0);
    }

Error:
    return SUCCEEDED(hr) ? S_OK : E_FAIL;
}


STDMETHODIMP 
CTapiComponentData::Save
(
    IStream *pStm, 
    BOOL     fClearDirty
)
{
    HRESULT hr = hrOK;
    CStringArray strArrayName;
    CDWordArray dwArrayRefreshInterval;
    CDWordArray dwArrayOptions;
    CDWordArray dwArrayColumnInfo;
    CDWordArray dwArrayLines;
    CDWordArray dwArrayPhones;

    ASSERT(pStm);
    
    // set the mode for this stream
    XferStream xferStream(pStm, XferStream::MODE_WRITE);    
    CString str;

    // Write the version # of the file format
    DWORD dwFileVersion = TAPISNAP_FILE_VERSION;
    xferStream.XferDWORD(TAPISTRM_TAG_VERSION, &dwFileVersion);
    
    // Write the version # of the admin tool
    xferStream.XferDWORD(TAPISTRM_TAG_VERSIONADMIN, &gdwTapiSnapVersion);

    //
    // Build our array of servers
    //
    int nNumServers = 0, nVisibleCount = 0;
    hr = m_spRootNode->GetChildCount(&nVisibleCount, &nNumServers);

    strArrayName.SetSize(nNumServers);
    dwArrayRefreshInterval.SetSize(nNumServers);
    dwArrayOptions.SetSize(nNumServers);
    dwArrayColumnInfo.SetSize(MAX_COLUMNS);
    
    dwArrayLines.SetSize(nNumServers);
    dwArrayPhones.SetSize(nNumServers);

    //
    // loop and save off all the server's attributes
    //
    SPITFSNodeEnum spNodeEnum;
    SPITFSNode spCurrentNode;
    ULONG nNumReturned = 0;
    int nCount = 0;

    m_spRootNode->GetEnum(&spNodeEnum);

    spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    while (nNumReturned)
    {
        CTapiServer   * pServer = GETHANDLER(CTapiServer, spCurrentNode);
        TCHAR           szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
        DWORD           dwSize = MAX_COMPUTERNAME_LENGTH + 1;

        // query the server for it's options:
        // auto refresh
        dwArrayRefreshInterval[nCount] = pServer->GetAutoRefreshInterval();
        dwArrayOptions[nCount] = pServer->GetOptions();
        
        //
        // check if this is the name of the local server; 
        // if it is, add the "local" flag
        //
        if (GetComputerName (szComputerName, &dwSize))
        {
            if(!_tcsicmp(pServer->GetName(), szComputerName))
            {
                dwArrayOptions[nCount] |= TAPISNAP_OPTIONS_LOCAL;
            }
        }

        // put the information in our array
        strArrayName[nCount] = pServer->GetName();

        // put the cached line and phone size in the array
        dwArrayLines[nCount] = pServer->GetCachedLineBuffSize();
        dwArrayPhones[nCount] = pServer->GetCachedPhoneBuffSize();

        // go to the next node
        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);

        nCount++;
    }

    // now write out all of the server information
    xferStream.XferCStringArray(TAPISTRM_TAG_SERVER_NAME, &strArrayName);
    xferStream.XferDWORDArray(TAPISTRM_TAG_SERVER_REFRESH_INTERVAL, &dwArrayRefreshInterval);
    xferStream.XferDWORDArray(TAPISTRM_TAG_SERVER_OPTIONS, &dwArrayOptions);

    // now save the column information
    for (int i = 0; i < NUM_SCOPE_ITEMS; i++)
    {
        for (int j = 0; j < MAX_COLUMNS; j++)
        {
            dwArrayColumnInfo[j] = aColumnWidths[i][j];
        }

        xferStream.XferDWORDArray(TAPISTRM_TAG_COLUMN_INFO, &dwArrayColumnInfo);
    }

    xferStream.XferDWORDArray(TAPISTRM_TAG_SERVER_LINE_SIZE, &dwArrayLines);
    xferStream.XferDWORDArray(TAPISTRM_TAG_SERVER_PHONE_SIZE, &dwArrayPhones);


    if (fClearDirty)
    {
        m_spRootNode->SetData(TFS_DATA_DIRTY, FALSE);
    }

    return SUCCEEDED(hr) ? S_OK : STG_E_CANTSAVE;
}


STDMETHODIMP 
CTapiComponentData::GetSizeMax
(
    ULARGE_INTEGER *pcbSize
)
{
    ASSERT(pcbSize);

    // Set the size of the string to be saved
    ULISet32(*pcbSize, 10000);

    return S_OK;
}

STDMETHODIMP 
CTapiComponentData::InitNew()
{
    return hrOK;
}

HRESULT 
CTapiComponentData::FinalConstruct()
{
    HRESULT             hr = hrOK;
    
    hr = CComponentData::FinalConstruct();
    
    if (FHrSucceeded(hr))
    {
        m_spTFSComponentData->GetNodeMgr(&m_spNodeMgr);
    }
    return hr;
}

void 
CTapiComponentData::FinalRelease()
{
    CComponentData::FinalRelease();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\tapihelp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    tapihelp.h  
        help IDs for context sensitive help

    FILE HISTORY:
    
*/

// TAPISNAP Identifiers 
// Dialogs (IDD_*) 
#define HIDD_EDIT_USERS                         0x200E7
#define HIDD_DRIVER_SETUP                       0x200E9
#define HIDD_ADD_DRIVER                         0x200EA
 
// Property Pages (IDP_*) 
#define HIDP_SERVER_REFRESH                     0x3008C
#define HIDP_SERVER_SETUP                       0x300E8
 
// Wizard Pages (IDW_*) 
 
// Controls (IDC_*) 
#define HIDC_BUTTON_ADD_ADMIN                   0x50162
#define HIDC_BUTTON_REMOVE_ADMIN                0x50163
#define HIDC_LIST_USERS                         0x50164
#define HIDC_EDIT_NAME                          0x50165
#define HIDC_EDIT_PASSWORD                      0x50166
#define HIDC_CHECK_ENABLE_STATS                 0x50168
#define HIDC_EDIT_HOURS                         0x50169
#define HIDC_EDIT_MINUTES                       0x5016A
#define HIDC_SPIN_HOURS                         0x5016C
#define HIDC_SPIN_MINUTES                       0x5016E
#define HIDC_CHECK_ENABLE_SERVER                0x5016F
#define HIDC_LIST_ADMINS                        0x50170
#define HIDC_BUTTON_CHOOSE_USER                 0x50173
#define HIDC_STATIC_ADMINS                      0x50174
#define HIDC_STATIC_ACCOUNT                     0x50175
#define HIDC_STATIC_USERNAME                    0x50176
#define HIDC_STATIC_PASSWORD                    0x50177
#define HIDC_STATIC_NOTE                        0x50178
#define HIDC_STATIC_LISTBOX                     0x50179
#define HIDC_LIST_DRIVERS                       0x5017C
#define HIDC_BUTTON_EDIT_DRIVER                 0x5017D
#define HIDC_LIST_NEW_DRIVERS                   0x5017E
#define HIDC_BUTTON_ADD_DRIVER                  0x50180
#define HIDC_BUTTON_ADD_NEW_DRIVER              0x50181
#define HIDC_BUTTON_REMOVE_DRIVER               0x50182
#define HIDC_BUTTON_ADD_USER                    0x50183
#define HIDC_BUTTON_REMOVE_USER                 0x50184

const DWORD g_aHelpIDs_EDIT_USERS[]=
{
    IDC_LIST_USERS,             HIDC_LIST_USERS,
    IDC_BUTTON_ADD_USER,        HIDC_BUTTON_ADD_USER,
    IDC_BUTTON_REMOVE_USER,     HIDC_BUTTON_REMOVE_USER,
    0,0
};

const DWORD g_aHelpIDs_DRIVER_SETUP[]=
{
    IDC_LIST_DRIVERS,           HIDC_LIST_DRIVERS,
    IDC_BUTTON_ADD_DRIVER,      HIDC_BUTTON_ADD_DRIVER,
    IDC_BUTTON_REMOVE_DRIVER,   HIDC_BUTTON_REMOVE_DRIVER,
    IDC_BUTTON_EDIT_DRIVER,     HIDC_BUTTON_EDIT_DRIVER,
    0,0
};

const DWORD g_aHelpIDs_ADD_DRIVER[]=
{
    IDC_LIST_NEW_DRIVERS,       HIDC_LIST_NEW_DRIVERS,
    IDC_BUTTON_ADD_NEW_DRIVER,  HIDC_BUTTON_ADD_NEW_DRIVER,
    0,0
};

const DWORD g_aHelpIDs_SERVER_REFRESH[]=
{
    IDC_CHECK_ENABLE_STATS,     HIDC_CHECK_ENABLE_STATS,
    IDC_EDIT_HOURS,             HIDC_EDIT_HOURS,
    IDC_SPIN_HOURS,             HIDC_SPIN_HOURS,
    IDC_EDIT_MINUTES,           HIDC_EDIT_MINUTES,
    IDC_SPIN_MINUTES,           HIDC_SPIN_MINUTES,
    IDC_STATIC_MINUTES,         HIDC_SPIN_MINUTES,
    0,0
};

const DWORD g_aHelpIDs_SERVER_SETUP[]=
{
    IDC_CHECK_ENABLE_SERVER,    HIDC_CHECK_ENABLE_SERVER,
    IDC_STATIC_ACCOUNT_INFO,    HIDC_STATIC_ACCOUNT,
    IDC_STATIC_ACCOUNT,         HIDC_STATIC_ACCOUNT,
    IDC_STATIC_USERNAME,        HIDC_STATIC_USERNAME,
    IDC_EDIT_NAME,              HIDC_EDIT_NAME,
    IDC_BUTTON_CHOOSE_USER,     HIDC_BUTTON_CHOOSE_USER,
    IDC_STATIC_PASSWORD,        HIDC_STATIC_PASSWORD,
    IDC_EDIT_PASSWORD,          HIDC_EDIT_PASSWORD,
    IDC_STATIC_ADMINS,          HIDC_STATIC_ADMINS,
    IDC_STATIC_NOTE,            HIDC_STATIC_NOTE,
    IDC_BUTTON_ADD_ADMIN,       HIDC_BUTTON_ADD_ADMIN,
    IDC_BUTTON_REMOVE_ADMIN,    HIDC_BUTTON_REMOVE_ADMIN,
    IDC_STATIC_LISTBOX,         HIDC_STATIC_LISTBOX,
    IDC_LIST_ADMINS,            HIDC_LIST_ADMINS,
    0,0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\tapisnap.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    tapisnap.cpp
        TAPI snapin entry points/registration functions
        
        Note: Proxy/Stub Information
            To build a separate proxy/stub DLL, 
            run nmake -f Snapinps.mak in the project directory.

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "initguid.h"
#include "tapicomp.h"
#include "ncglobal.h"  // network console global defines
#include "cmptrmgr.h"   // computer menagement snapin stuff

#ifdef _DEBUG
void DbgVerifyInstanceCounts();
#define DEBUG_VERIFY_INSTANCE_COUNTS DbgVerifyInstanceCounts()
#else
#define DEBUG_VERIFY_INSTANCE_COUNTS
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_TapiSnapin, CTapiComponentDataPrimary)
    OBJECT_ENTRY(CLSID_TapiSnapinExtension, CTapiComponentDataExtension)
    OBJECT_ENTRY(CLSID_TapiSnapinAbout, CTapiAbout)
END_OBJECT_MAP()

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// CTapiSnapinApp
//
BEGIN_MESSAGE_MAP(CTapiSnapinApp, CWinApp)
    //{{AFX_MSG_MAP(CTapiSnapinApp)
    //ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
    //}}AFX_MSG_MAP
    // Standard file based document commands
    //ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    //ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
    // Standard print setup command
    //ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
    // Global help commands
    ON_COMMAND(ID_HELP_INDEX, CWinApp::OnHelpFinder)
    ON_COMMAND(ID_HELP_USING, CWinApp::OnHelpUsing)
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
    ON_COMMAND(ID_CONTEXT_HELP, CWinApp::OnContextHelp)
    ON_COMMAND(ID_DEFAULT_HELP, CWinApp::OnHelpIndex)
END_MESSAGE_MAP()

CTapiSnapinApp theApp;

BOOL CTapiSnapinApp::InitInstance()
{
    _Module.Init(ObjectMap, m_hInstance);

    //
    //  Initialize the CWndIpAddress control window class IPADDRESS
    //
    CWndIpAddress::CreateWindowClass( m_hInstance ) ;
    
    //
    //  Initialize use of the WinSock routines
    //
    WSADATA wsaData ;
    
    if ( ::WSAStartup( MAKEWORD( 1, 1 ), & wsaData ) != 0 )
    {
        m_bWinsockInited = TRUE;
        Trace0("InitInstance: Winsock initialized!\n");
    }
    else
    {
        m_bWinsockInited = FALSE;
    }

    return CWinApp::InitInstance();
}

int CTapiSnapinApp::ExitInstance()
{
    _Module.Term();

    DEBUG_VERIFY_INSTANCE_COUNTS;

    //
    // Terminate use of the WinSock routines.
    //
    if ( m_bWinsockInited )
    {
        WSACleanup() ;
    }

    return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // registers object, typelib and all interfaces in typelib
    //
    HRESULT hr = _Module.RegisterServer(/* bRegTypeLib */ FALSE);
    ASSERT(SUCCEEDED(hr));
    
    if (FAILED(hr))
        return hr;

    CString stName, stNameIndirect;

    stName.LoadString(IDS_SNAPIN_NAME);
    stNameIndirect.Format (_T("@%s,-%d"), _T("tapisnap.dll"), IDS_SNAPIN_NAME);

    //
    // register the snapin into the console snapin list
    //
    hr = RegisterSnapinGUID(&CLSID_TapiSnapin, 
                        &GUID_TapiRootNodeType, 
                        &CLSID_TapiSnapinAbout,
                        (LPCTSTR) stName, 
                        _T("1.0"), 
                        TRUE,
                        stNameIndirect);
    ASSERT(SUCCEEDED(hr));
    
    if (FAILED(hr))
        return hr;

    CString stExtensionName;
    stExtensionName.LoadString(IDS_SNAPIN_EXTENSION);

    hr = RegisterSnapinGUID(&CLSID_TapiSnapinExtension, 
                            NULL, 
                            &CLSID_TapiSnapinAbout,
                            (LPCTSTR) stExtensionName, 
                            _T("1.0"), 
                            FALSE);
    ASSERT(SUCCEEDED(hr));
    
    if (FAILED(hr))
        return hr;

    //
    // register the snapin nodes into the console node list
    //
    hr = RegisterNodeTypeGUID(&CLSID_TapiSnapin, 
                              &GUID_TapiRootNodeType, 
                              _T("Root of Manager"));
    ASSERT(SUCCEEDED(hr));

#ifdef  __NETWORK_CONSOLE__
    hr = RegisterAsRequiredExtensionGUID(&GUID_NetConsRootNodeType, 
                                         &CLSID_TapiSnapinExtension,
                                         (LPCTSTR) stExtensionName,
                                         EXTENSION_TYPE_TASK | EXTENSION_TYPE_NAMESPACE,
                                         &GUID_NetConsRootNodeType);   // doesn't matter what this is, just 
                                                                       // needs to be non-null guid

    ASSERT(SUCCEEDED(hr));
#endif

    hr = RegisterAsRequiredExtensionGUID(&NODETYPE_COMPUTERMANAGEMENT_SERVERAPPS, 
                                         &CLSID_TapiSnapinExtension,
                                         (LPCTSTR) stExtensionName,
                                         EXTENSION_TYPE_TASK | EXTENSION_TYPE_NAMESPACE,
                                         &NODETYPE_COMPUTERMANAGEMENT_SERVERAPPS);  // NULL makes it not dynamic
    ASSERT(SUCCEEDED(hr));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hr  = _Module.UnregisterServer();
    ASSERT(SUCCEEDED(hr));
    
    if (FAILED(hr))
        return hr;
    
    // un register the snapin 
    //
    hr = UnregisterSnapinGUID(&CLSID_TapiSnapin);
    ASSERT(SUCCEEDED(hr));
    
    if (FAILED(hr))
        return hr;

    hr = UnregisterSnapinGUID(&CLSID_TapiSnapinExtension);
    ASSERT(SUCCEEDED(hr));
    
    if (FAILED(hr))
        return hr;

    // unregister the snapin nodes 
    //
    hr = UnregisterNodeTypeGUID(&GUID_TapiRootNodeType);
    ASSERT(SUCCEEDED(hr));

#ifdef  __NETWORK_CONSOLE__
    
    hr = UnregisterAsExtensionGUID(&GUID_NetConsRootNodeType, 
                                   &CLSID_TapiSnapinExtension,
                                   EXTENSION_TYPE_TASK | EXTENSION_TYPE_NAMESPACE);
    ASSERT(SUCCEEDED(hr));
#endif

    hr = UnregisterAsExtensionGUID(&NODETYPE_COMPUTERMANAGEMENT_SERVERAPPS, 
                                   &CLSID_TapiSnapinExtension,
                                   EXTENSION_TYPE_TASK | EXTENSION_TYPE_NAMESPACE);
    ASSERT(SUCCEEDED(hr));

    return hr;
}

#ifdef _DEBUG
void DbgVerifyInstanceCounts()
{
    DEBUG_VERIFY_INSTANCE_COUNT(CHandler);
    DEBUG_VERIFY_INSTANCE_COUNT(CMTHandler);
    DEBUG_VERIFY_INSTANCE_COUNT(CTapiInfo);
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\tapisnap.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	global.h
		Global defines for the Tapi snapin


	FILE HISTORY:
        
*/

#define TAPI_SERVICE_NAME                   _T("tapisrv")

// Defines for help from the help menu and F1 help for scope pane items
#define TAPISNAP_HELP_BASE				    0xA0000000
#define TAPISNAP_HELP_SNAPIN			    TAPISNAP_HELP_BASE + 1
#define TAPISNAP_HELP_ROOT				    TAPISNAP_HELP_BASE + 2
#define TAPISNAP_HELP_SERVER 			    TAPISNAP_HELP_BASE + 3
#define TAPISNAP_HELP_PROVIDER 		        TAPISNAP_HELP_BASE + 4
#define TAPISNAP_HELP_DEVICE  			    TAPISNAP_HELP_BASE + 5

// wait cursor stuff around functions.  If you need a wait cursor for 
// and entire fucntion, just use CWaitCursor.  To wrap a wait cursor
// around an rpc call, use these macros.
#define BEGIN_WAIT_CURSOR   {  CWaitCursor waitCursor;
#define RESTORE_WAIT_CURSOR    waitCursor.Restore();
#define END_WAIT_CURSOR     }

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

// macro to get the handler for a node. This is a Tapi snapin specific 
// implementation
#define GETHANDLER(classname, node) (reinterpret_cast<classname *>(node->GetData(TFS_DATA_USER)))

// HRESULT Mapping
#define WIN32_FROM_HRESULT(hr)         (0x0000FFFF & (hr))

// Version Suff
#define TAPISNAP_VERSION         0x00010000
#define TAPISNAP_MAJOR_VERSION   HIWORD(TAPISNAP_VERSION)
#define TAPISNAP_MINOR_VERSION	 LOWORD(TAPISNAP_VERSION)

extern DWORD gdwTapiSnapVersion;

#define TAPISNAP_FILE_VERSION_1	 0x00000001
#define TAPISNAP_FILE_VERSION    0x00000002

// constants for time conversion
#define MILLISEC_PER_SECOND			1000
#define MILLISEC_PER_MINUTE			(60 * MILLISEC_PER_SECOND)
#define MILLISEC_PER_HOUR			(60 * MILLISEC_PER_MINUTE)

#define TAPISNAP_REFRESH_INTERVAL_DEFAULT	(10 * MILLISEC_PER_MINUTE) // 10 minutes in milliseconds

// macros for memory exception handling
#define CATCH_MEM_EXCEPTION             \
	TRY

#define END_MEM_EXCEPTION(err)          \
	CATCH_ALL(e) {                      \
       err = ERROR_NOT_ENOUGH_MEMORY ;  \
    } END_CATCH_ALL

// some global defines we need
#define STRING_LENGTH_MAX		 256

// Note - These are offsets into my image list
typedef enum _ICON_INDICIES
{
	ICON_IDX_SERVER,
	ICON_IDX_SERVER_BUSY,
	ICON_IDX_SERVER_CONNECTED,
	ICON_IDX_SERVER_LOST_CONNECTION,
	ICON_IDX_MACHINE,
	ICON_IDX_FOLDER_OPEN,
	ICON_IDX_FOLDER_CLOSED,
	ICON_IDX_PRODUCT,
	ICON_IDX_MAX
} ICON_INDICIES, * LPICON_INDICIES;

// Sample folder types
enum NODETYPES
{
// scope pane items
    TAPISNAP_ROOT,
    TAPISNAP_SERVER,
    TAPISNAP_PROVIDER,
// result pane items
    TAPISNAP_DEVICE,
    TAPISNAP_NODETYPE_MAX,
};

//  GUIDs are defined in guids.cpp
extern const CLSID      CLSID_TapiSnapin;				// In-Proc server GUID
extern const CLSID      CLSID_TapiSnapinExtension;		// In-Proc server GUID
extern const CLSID      CLSID_TapiSnapinAbout;			// In-Proc server GUID
extern const GUID       GUID_TapiRootNodeType;			// Root NodeType GUID 
extern const GUID       GUID_TapiServerNodeType;		// Server NodeType GUID
extern const GUID       GUID_TapiProviderNodeType;		// Lines NodeType GUID
extern const GUID       GUID_TapiLineNodeType;			// Line (result pane) NodeType GUID 
extern const GUID       GUID_TapiUserNodeType;			// User (result pane) NodeType GUID 
extern const GUID       GUID_TapiPhoneNumNodeType;		// User (result pane) NodeType GUID 
extern const GUID       IID_ITapiInfo;

const int MAX_COLUMNS = 5;
const int NUM_SCOPE_ITEMS = 3;
const int NUM_CONSOLE_VERBS = 8;

// arrays used to hold all of the result pane column information
extern UINT aColumns[TAPISNAP_NODETYPE_MAX][MAX_COLUMNS];
extern int aColumnWidths[TAPISNAP_NODETYPE_MAX][MAX_COLUMNS];


// arrays for console verbs
extern MMC_CONSOLE_VERB g_ConsoleVerbs[NUM_CONSOLE_VERBS];
extern MMC_BUTTON_STATE g_ConsoleVerbStates[TAPISNAP_NODETYPE_MAX][NUM_CONSOLE_VERBS];
extern MMC_BUTTON_STATE g_ConsoleVerbStatesMultiSel[TAPISNAP_NODETYPE_MAX][NUM_CONSOLE_VERBS];

// array for help
extern DWORD g_dwMMCHelp[TAPISNAP_NODETYPE_MAX];

// Clipboard format that has the Type and Cookie
extern const wchar_t*   SNAPIN_INTERNAL;

// CTapiSnapinApp definition
class CTapiSnapinApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();

    DECLARE_MESSAGE_MAP()

public:
	BOOL m_bWinsockInited;
};

extern CTapiSnapinApp theApp;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\alloc.h ===
/*----------------------------------------------------------------------------
	alloc.h

	Copyright (C) Microsoft Corporation, 1993 - 1998
	All rights reserved.

	Authors:
		kennt	Kenn Takara
 ----------------------------------------------------------------------------*/

#ifndef _ALLOC_H
#define _ALLOC_H

#if _MSC_VER >= 1000	// VC 5.0 or later
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif


void *	TFSAlloc(size_t size);
void	TFSFree(void *pv);

inline void * __cdecl	operator new (size_t size)
{
	return TFSAlloc(size);
}

inline void * __cdecl	operator new[] (size_t size)
{
	return TFSAlloc(size);
}

inline void * __cdecl	operator delete (void * pv)
{
	if (pv)
		TFSFree(pv);
}

inline void * __cdecl	operator delete[] (void *pv)
{
	if (pv)
		TFSFree(pv);
}



#ifdef __cplusplus
} // extern "C"
#endif

#endif // _ALLOC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\tapihand.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	tapihand.cpp
		TAPI specifc handler base classes

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "tapihand.h"
#include "snaputil.h"  // For CGUIDArray
#include "extract.h"   // For ExtractInternalFormat

const TCHAR g_szDefaultHelpTopic[] = _T("\\help\\tapiconcepts.chm::/sag_TAPItopnode.htm");

/*---------------------------------------------------------------------------
	CMTTapiHandler::OnChangeState
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
void CMTTapiHandler::OnChangeState
(
	ITFSNode * pNode
)
{
	// Increment the state to the next position
	switch (m_nState)
	{
		case notLoaded:
		case loaded:
		case unableToLoad:
			{
				m_nState = loading;
				m_dwErr = 0;
			}
			break;

		case loading:
			{
				m_nState = (m_dwErr != 0) ? unableToLoad : loaded;
                if (m_dwErr)
                {
                    CString strPrefix;
                    GetErrorPrefix(pNode, &strPrefix);
                    if (!strPrefix.IsEmpty())
                        ::TapiMessageBoxEx(m_dwErr, strPrefix);
                }
			}
			break;
	
		default:
			ASSERT(FALSE);
	}

    // check to make sure we are still the visible node in the UI
    if (m_bSelected)
    {
        UpdateStandardVerbs(pNode, pNode->GetData(TFS_DATA_TYPE));
    }

    // Now check and see if there is a new image for this state for this handler
	int nImage, nOpenImage;

	nImage = GetImageIndex(FALSE);
	nOpenImage = GetImageIndex(TRUE);

	if (nImage >= 0)
		pNode->SetData(TFS_DATA_IMAGEINDEX, nImage);

	if (nOpenImage >= 0)
		pNode->SetData(TFS_DATA_OPENIMAGEINDEX, nOpenImage);
	
	VERIFY(SUCCEEDED(pNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM_ICON)));
}

 /*!--------------------------------------------------------------------------
	CMTTapiHandler::UpdateStandardVerbs
		Tells the IComponent to update the verbs for this node
	Author: EricDav
 ---------------------------------------------------------------------------*/
void
CMTTapiHandler::UpdateStandardVerbs
(
    ITFSNode *  pNode,
    LONG_PTR    dwNodeType
)
{
    HRESULT				hr = hrOK;
    SPIComponentData	spCompData;
	SPIConsole			spConsole;
    IDataObject*		pDataObject;

    m_spNodeMgr->GetComponentData(&spCompData);

    CORg ( spCompData->QueryDataObject(NULL, CCT_RESULT, &pDataObject) );

    CORg ( m_spNodeMgr->GetConsole(&spConsole) );

    CORg ( spConsole->UpdateAllViews(pDataObject, 
                                     reinterpret_cast<MMC_COOKIE>(pNode), 
                                     RESULT_PANE_UPDATE_VERBS) ); 

    pDataObject->Release();
	
Error:
    return;
}

/*!--------------------------------------------------------------------------
	CMTTapiHandler::OnCreateDataObject
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMTTapiHandler::OnCreateDataObject
(
    ITFSComponent *     pComponent,
	MMC_COOKIE			cookie, 
	DATA_OBJECT_TYPES	type, 
	IDataObject **		ppDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Assert(ppDataObject != NULL);

	CDataObject *	    pObject = NULL;
	SPIDataObject	    spDataObject;

    pObject = new CDataObject;
	spDataObject = pObject;	// do this so that it gets released correctly
						
    Assert(pObject != NULL);

    if (cookie == MMC_MULTI_SELECT_COOKIE)
    {
        CreateMultiSelectData(pComponent, pObject);
    }

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    // Store the coclass with the data object
    pObject->SetClsid(*(m_spTFSComponentData->GetCoClassID()));

	pObject->SetTFSComponentData(m_spTFSComponentData);

    return  pObject->QueryInterface(IID_IDataObject, 
									reinterpret_cast<void**>(ppDataObject));
}

HRESULT
CMTTapiHandler::CreateMultiSelectData(ITFSComponent * pComponent, CDataObject * pObject)
{
    HRESULT hr = hrOK;

    // build the list of selected nodes
	CTFSNodeList listSelectedNodes;
    CGUIDArray   rgGuids;
    UINT         cb;
    GUID*        pGuid;

    COM_PROTECT_TRY
    {
        CORg (BuildSelectedItemList(pComponent, &listSelectedNodes));

        // collect all of the unique guids
        while (listSelectedNodes.GetCount() > 0)
	    {
		    SPITFSNode   spCurNode;
            const GUID * pGuid;

		    spCurNode = listSelectedNodes.RemoveHead();
            pGuid = spCurNode->GetNodeType();
        
            rgGuids.AddUnique(*pGuid);
        }

        // now put the information in the data object
        pObject->SetMultiSelDobj();
        cb = (UINT)rgGuids.GetSize() * sizeof(GUID);
        
        pGuid = new GUID[(size_t)rgGuids.GetSize()];
        CopyMemory(pGuid, rgGuids.GetData(), cb);
        
        pObject->SetMultiSelData((BYTE*)pGuid, cb);

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
	CMTTapiHandler::SaveColumns
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CMTTapiHandler::SaveColumns
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    LONG_PTR            dwNodeType;
    int                 nCol = 0;
    int                 nColWidth;
    SPITFSNode          spNode, spRootNode;
    SPIHeaderCtrl       spHeaderCtrl;
    BOOL                bDirty = FALSE;

    CORg (m_spNodeMgr->FindNode(cookie, &spNode));
    CORg (pComponent->GetHeaderCtrl(&spHeaderCtrl));
    
    dwNodeType = spNode->GetData(TFS_DATA_TYPE);

    while (aColumns[dwNodeType][nCol] != 0)
    {
        if ( (SUCCEEDED(spHeaderCtrl->GetColumnWidth(nCol, &nColWidth))) && 
             (aColumnWidths[dwNodeType][nCol] != nColWidth) )
        {
            aColumnWidths[dwNodeType][nCol] = nColWidth;
            bDirty = TRUE;
        }

        nCol++;
    }

    if (bDirty)
    {
        CORg (m_spNodeMgr->GetRootNode(&spRootNode));
		spRootNode->SetData(TFS_DATA_DIRTY, TRUE);
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CMTTapiHandler::OnResultSelect
		Handles the MMCN_SELECT notifcation 
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CMTTapiHandler::OnResultSelect
(
	ITFSComponent * pComponent, 
	LPDATAOBJECT	pDataObject, 
    MMC_COOKIE      cookie,
	LPARAM			arg, 
	LPARAM			lParam
)
{
    SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;
    HRESULT         hr = hrOK;
    SPINTERNAL		spInternal;
    BOOL            bMultiSelect = FALSE;

    BOOL bScope = (BOOL) LOWORD(arg);
    BOOL bSelect = (BOOL) HIWORD(arg);

    m_bSelected = bSelect;

   	Trace1("CMTTapiHandler::OnResultSelect select = %d\n", bSelect);
 
    CORg (pComponent->GetConsoleVerb(&spConsoleVerb));
    
    spInternal = ::ExtractInternalFormat(pDataObject);
    
    if (spInternal && 
        spInternal->m_cookie == MMC_MULTI_SELECT_COOKIE)
    {
        CORg (pComponent->GetSelectedNode(&spNode));
        bMultiSelect = TRUE;
    }
    else
    {
        CORg (m_spNodeMgr->FindNode(cookie, &spNode));
    }

    UpdateConsoleVerbs(spConsoleVerb, spNode->GetData(TFS_DATA_TYPE), bMultiSelect);

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CMTTapiHandler::OnResultUpdateView
		Implementation of ITFSResultHandler::OnResultUpdateView
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CMTTapiHandler::OnResultUpdateView
(
    ITFSComponent *pComponent, 
    LPDATAOBJECT   pDataObject, 
    LPARAM         data, 
    LPARAM         hint
)
{
	HRESULT hr = hrOK;

    if (hint == RESULT_PANE_UPDATE_VERBS)
    {
	    SPIConsoleVerb  spConsoleVerb;
        SPITFSNode      spNode;

        CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

        spNode.Set(reinterpret_cast<ITFSNode *>(data));

        UpdateConsoleVerbs(spConsoleVerb, spNode->GetData(TFS_DATA_TYPE));
    }
    else
    {
        return CBaseResultHandler::OnResultUpdateView(pComponent, pDataObject, data, hint);
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CMTTapiHandler::OnResultContextHelp
		Implementation of ITFSResultHandler::OnResultContextHelp
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CMTTapiHandler::OnResultContextHelp
(
    ITFSComponent * pComponent, 
    LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT         hr = hrOK;
    SPIDisplayHelp  spDisplayHelp;
    SPIConsole      spConsole;

    pComponent->GetConsole(&spConsole);

    hr = spConsole->QueryInterface (IID_IDisplayHelp, (LPVOID*) &spDisplayHelp);
	ASSERT (SUCCEEDED (hr));
	if ( SUCCEEDED (hr) )
	{
        LPCTSTR pszHelpFile = m_spTFSCompData->GetHTMLHelpFileName();
        if (pszHelpFile == NULL)
            goto Error;

        CString szHelpFilePath;
	    UINT nLen = ::GetWindowsDirectory (szHelpFilePath.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
	    if (nLen == 0)
        {
		    hr = E_FAIL;
            goto Error;
        }

	    szHelpFilePath.ReleaseBuffer();
        szHelpFilePath += g_szDefaultHelpTopic;

		hr = spDisplayHelp->ShowTopic (T2OLE ((LPTSTR)(LPCTSTR) szHelpFilePath));
		ASSERT (SUCCEEDED (hr));
    }

Error:
    return hr;
}

 /*!--------------------------------------------------------------------------
	CMTTapiHandler::UpdateStandardVerbs
		Updates the standard verbs depending upon the state of the node
	Author: EricDav
 ---------------------------------------------------------------------------*/
void
CMTTapiHandler::UpdateConsoleVerbs
(
    IConsoleVerb * pConsoleVerb,
    LONG_PTR       dwNodeType,
    BOOL           bMultiSelect
)
{
    BOOL                bStates[ARRAYLEN(g_ConsoleVerbs)];	
    MMC_BUTTON_STATE *  ButtonState;
    int                 i;
    
    if (bMultiSelect)
    {
        ButtonState = g_ConsoleVerbStatesMultiSel[dwNodeType];
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
    }
    else
    {
        ButtonState = g_ConsoleVerbStates[dwNodeType];
        switch (m_nState)
        {
            case loaded:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
                break;
    
            case notLoaded:
            case loading:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
                break;

            case unableToLoad:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
                bStates[MMC_VERB_REFRESH & 0x000F] = TRUE;
                bStates[MMC_VERB_DELETE & 0x000F] = TRUE;
                break;
        }
    }

    EnableVerbs(pConsoleVerb, ButtonState, bStates);
}

/*!--------------------------------------------------------------------------
	CMTTapiHandler::EnableVerbs
		Enables the verb buttons
	Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CMTTapiHandler::EnableVerbs
(
    IConsoleVerb *      pConsoleVerb,
    MMC_BUTTON_STATE    ButtonState[],
    BOOL                bState[]
)
{
    if (pConsoleVerb == NULL)
    {
        Assert(FALSE);
        return;
    }

    for (int i=0; i < ARRAYLEN(g_ConsoleVerbs); ++i)
    {
        if (ButtonState[i] == ENABLED)
        {
            // unhide this button before enabling
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       HIDDEN, 
                                       FALSE);
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       ButtonState[i], 
                                       bState[i]);
        }
        else
        {
            // hide this button
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       HIDDEN, 
                                       TRUE);
        }
    }
}

/*!--------------------------------------------------------------------------
	CMTTapiHandler::OnResultRefresh
		Call into the MTHandler to do a refresh
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CMTTapiHandler::OnResultRefresh
(
    ITFSComponent *     pComponent,
    LPDATAOBJECT        pDataObject,
    MMC_COOKIE          cookie,
    LPARAM              arg,
    LPARAM              lParam
)
{
	HRESULT     hr = hrOK;
    SPITFSNode  spNode;

	CORg (m_spNodeMgr->FindNode(cookie, &spNode));

    OnRefresh(spNode, pDataObject, 0, arg, lParam);

Error:
    return hr;
}

 /*!--------------------------------------------------------------------------
	CMTTapiHandler::ExpandNode
		Expands/compresses this node
	Author: EricDav
 ---------------------------------------------------------------------------*/
void
CMTTapiHandler::ExpandNode
(
    ITFSNode *  pNode,
    BOOL        fExpand
)
{
    SPIComponentData	spCompData;
    SPIDataObject       spDataObject;
    LPDATAOBJECT        pDataObject;
    SPIConsole          spConsole;
    HRESULT             hr = hrOK;

    // don't expand the node if we are handling the EXPAND_SYNC message,
    // this screws up the insertion of item, getting duplicates.
    if (!m_fExpandSync)
    {
        m_spNodeMgr->GetComponentData(&spCompData);

	    CORg ( spCompData->QueryDataObject((MMC_COOKIE) pNode, CCT_SCOPE, &pDataObject) );
        spDataObject = pDataObject;

        CORg ( m_spNodeMgr->GetConsole(&spConsole) );
	    CORg ( spConsole->UpdateAllViews(pDataObject, TRUE, RESULT_PANE_EXPAND) ); 
    }

Error:
    return;
}

/*!--------------------------------------------------------------------------
	CMTTapiHandler::OnExpandSync
		Handles the MMCN_EXPANDSYNC notifcation 
        We need to do syncronous enumeration.  We'll fire off the background 
        thread like before, but we'll wait for it to exit before we return.
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CMTTapiHandler::OnExpandSync
(
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataObject, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    HRESULT hr = hrOK;
    MSG msg;

    m_fExpandSync = TRUE;

    hr = OnExpand(pNode, pDataObject, CCT_SCOPE, arg, lParam);

    // wait for the background thread to exit
    WaitForSingleObject(m_hThread, INFINITE);
    
    // The background thread posts messages to a hidden window to 
    // pass data back to the main thread. The messages won't go through since we are
    // blocking the main thread.  The data goes on a queue in the query object
    // which the handler has a pointer to so we can just fake the notification.
    if (m_spQuery.p)
        OnNotifyHaveData((LPARAM) m_spQuery.p);

    // Tell MMC we handled this message
    MMC_EXPANDSYNC_STRUCT * pES = reinterpret_cast<MMC_EXPANDSYNC_STRUCT *>(lParam);
    if (pES)
        pES->bHandled = TRUE;

    m_fExpandSync = FALSE;

    return hr;
}

/*---------------------------------------------------------------------------
	Class:	CTapiHandler
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	CTapiHandler::SaveColumns
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CTapiHandler::SaveColumns
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    LONG_PTR            dwNodeType;
    int                 nCol = 0;
    int                 nColWidth = 0;
    SPITFSNode          spNode, spRootNode;
    SPIHeaderCtrl       spHeaderCtrl;
    BOOL                bDirty = FALSE;

    CORg (m_spNodeMgr->FindNode(cookie, &spNode));
    CORg (pComponent->GetHeaderCtrl(&spHeaderCtrl));
    
    dwNodeType = spNode->GetData(TFS_DATA_TYPE);

    while (aColumns[dwNodeType][nCol] != 0)
    {
        if ( (SUCCEEDED(spHeaderCtrl->GetColumnWidth(nCol, &nColWidth))) && 
             (aColumnWidths[dwNodeType][nCol] != nColWidth) )
        {
            aColumnWidths[dwNodeType][nCol] = nColWidth;
            bDirty = TRUE;
        }
         
        nCol++;
    }

    if (bDirty)
    {
        CORg (m_spNodeMgr->GetRootNode(&spRootNode));
		spRootNode->SetData(TFS_DATA_DIRTY, TRUE);
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CTapiHandler::OnCreateDataObject
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CTapiHandler::OnCreateDataObject
(
    ITFSComponent *     pComponent,
	MMC_COOKIE      	cookie, 
	DATA_OBJECT_TYPES	type, 
	IDataObject **		ppDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Assert(ppDataObject != NULL);

	CDataObject *	pObject = NULL;
	SPIDataObject	spDataObject;
	
	pObject = new CDataObject;
	spDataObject = pObject;	// do this so that it gets released correctly
						
    Assert(pObject != NULL);

    if (cookie == MMC_MULTI_SELECT_COOKIE)
    {
        CreateMultiSelectData(pComponent, pObject);
    }

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    // Store the coclass with the data object
    pObject->SetClsid(*(m_spTFSComponentData->GetCoClassID()));

	pObject->SetTFSComponentData(m_spTFSComponentData);

    return  pObject->QueryInterface(IID_IDataObject, 
									reinterpret_cast<void**>(ppDataObject));
}

HRESULT
CTapiHandler::CreateMultiSelectData(ITFSComponent * pComponent, CDataObject * pObject)
{
    HRESULT hr = hrOK;

    // build the list of selected nodes
	CTFSNodeList listSelectedNodes;
    CGUIDArray   rgGuids;
    UINT         cb;
    GUID*        pGuid;

    COM_PROTECT_TRY
    {
        CORg (BuildSelectedItemList(pComponent, &listSelectedNodes));

        // collect all of the unique guids
        while (listSelectedNodes.GetCount() > 0)
	    {
		    SPITFSNode   spCurNode;
            const GUID * pGuid;

		    spCurNode = listSelectedNodes.RemoveHead();
            pGuid = spCurNode->GetNodeType();
        
            rgGuids.AddUnique(*pGuid);
        }

        // now put the information in the data object
        pObject->SetMultiSelDobj();
        cb = (UINT)rgGuids.GetSize() * sizeof(GUID);
        
        pGuid = new GUID[(size_t)rgGuids.GetSize()];
        CopyMemory(pGuid, rgGuids.GetData(), cb);
        
        pObject->SetMultiSelData((BYTE*)pGuid, cb);

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}

 /*---------------------------------------------------------------------------
	CTapiHandler::OnResultDelete
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CTapiHandler::OnResultDelete
(
	ITFSComponent * pComponent, 
	LPDATAOBJECT	pDataObject,
	MMC_COOKIE  	cookie, 
	LPARAM			arg, 
	LPARAM			lParam
)
{
	HRESULT hr = hrOK;

	Trace0("CTapiHandler::OnResultDelete received\n");

	// translate this call to the parent and let it handle deletion 
	// of result pane items
	SPITFSNode spNode, spParent;
	SPITFSResultHandler spParentRH;

	CORg (m_spNodeMgr->FindNode(cookie, &spNode));
	CORg (spNode->GetParent(&spParent));

	if (spParent == NULL)
		return hr;

	CORg (spParent->GetResultHandler(&spParentRH));

	CORg (spParentRH->Notify(pComponent, spParent->GetData(TFS_DATA_COOKIE), pDataObject, MMCN_DELETE, arg, lParam));

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	CTapiHandler::OnResultContextHelp
		Implementation of ITFSResultHandler::OnResultContextHelp
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CTapiHandler::OnResultContextHelp
(
    ITFSComponent * pComponent, 
    LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT         hr = hrOK;
    SPIDisplayHelp  spDisplayHelp;
    SPIConsole      spConsole;

    pComponent->GetConsole(&spConsole);

    hr = spConsole->QueryInterface (IID_IDisplayHelp, (LPVOID*) &spDisplayHelp);
	ASSERT (SUCCEEDED (hr));
	if ( SUCCEEDED (hr) )
	{
        LPCTSTR pszHelpFile = m_spTFSCompData->GetHTMLHelpFileName();
        if (pszHelpFile == NULL)
            goto Error;

        CString szHelpFilePath;
	    UINT nLen = ::GetWindowsDirectory (szHelpFilePath.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
	    if (nLen == 0)
        {
		    hr = E_FAIL;
            goto Error;
        }

	    szHelpFilePath.ReleaseBuffer();
        szHelpFilePath += g_szDefaultHelpTopic;

		hr = spDisplayHelp->ShowTopic (T2OLE ((LPTSTR)(LPCTSTR) szHelpFilePath));
		ASSERT (SUCCEEDED (hr));
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CTapiHandler::OnResultSelect
		Handles the MMCN_SELECT notifcation 
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CTapiHandler::OnResultSelect
(
	ITFSComponent * pComponent, 
	LPDATAOBJECT	pDataObject, 
    MMC_COOKIE      cookie,
	LPARAM	    	arg, 
	LPARAM		    lParam
)
{
    SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;
    HRESULT         hr = hrOK;
    BOOL            bStates[ARRAYLEN(g_ConsoleVerbs)];
    int             i;

    BOOL bScope = (BOOL) LOWORD(arg);
    BOOL bSelect = (BOOL) HIWORD(arg);

   	Trace1("CTapiHandler::OnResultSelect select = %d\n", bSelect);
    //m_bSelected = bSelect;

    CORg (pComponent->GetConsoleVerb(&spConsoleVerb));
    CORg (m_spNodeMgr->FindNode(cookie, &spNode));

    for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);

    EnableVerbs(spConsoleVerb, g_ConsoleVerbStates[spNode->GetData(TFS_DATA_TYPE)], bStates);

Error:
    return hr;
}


/*!--------------------------------------------------------------------------
	CMTTapiHandler::EnableVerbs
		Enables the verb buttons
	Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CTapiHandler::EnableVerbs
(
    IConsoleVerb *      pConsoleVerb,
    MMC_BUTTON_STATE    ButtonState[],
    BOOL                bState[]
)
{
    if (pConsoleVerb == NULL)
    {
        Assert(FALSE);
        return;
    }

    for (int i=0; i < ARRAYLEN(g_ConsoleVerbs); ++i)
    {
        if (ButtonState[i] == ENABLED)
        {
            // unhide this button before enabling
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       HIDDEN, 
                                       FALSE);
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       ButtonState[i], 
                                       bState[i]);
        }
        else
        {
            // hide this button
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       HIDDEN, 
                                       TRUE);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tapi\tapihand.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	TAPIhand.h
		Header file for tapi specific base handler classes and query obj

    FILE HISTORY:
        
*/

#ifndef _TAPIHAND_H
#define _TAPIHAND_H

#ifndef _HANDLERS_H
#include <handlers.h>
#endif

#ifndef _QUERYOBJ_H
#include <queryobj.h>
#endif

extern const TCHAR g_szDefaultHelpTopic[];

/*---------------------------------------------------------------------------
	Class:	CHandlerEx
 ---------------------------------------------------------------------------*/
class CHandlerEx
{
// Interface
public:
    virtual HRESULT InitializeNode(ITFSNode * pNode) = 0;
	LPCTSTR GetDisplayName() { return m_strDisplayName; }
	void    SetDisplayName(LPCTSTR pName) { m_strDisplayName = pName; }

private:
	CString m_strDisplayName;
};

/*---------------------------------------------------------------------------
	Class:	CTapiHandler
 ---------------------------------------------------------------------------*/
class CTapiHandler : 
        public CHandler,
		public CHandlerEx
{
public:
	CTapiHandler(ITFSComponentData *pCompData) : CHandler(pCompData) {};
	~CTapiHandler() {};

    // base handler virtual function over-rides
	virtual HRESULT SaveColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

    // by default we don't allow nodes to be renamed
    OVERRIDE_BaseHandlerNotify_OnRename() { return hrFalse; }

    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultDelete();
    OVERRIDE_BaseResultHandlerNotify_OnResultContextHelp();

    // Multi-select functionalty
    OVERRIDE_ResultHandler_OnCreateDataObject();

    void EnableVerbs(IConsoleVerb *     pConsoleVerb,
                     MMC_BUTTON_STATE   ButtonState[],
                     BOOL               bEnable[]);

protected:
    HRESULT CreateMultiSelectData(ITFSComponent * pComponent, CDataObject * pObject);

public:
};

/*---------------------------------------------------------------------------
	Class:	CMTTapiHandler
 ---------------------------------------------------------------------------*/
class CMTTapiHandler : 
		public CMTHandler,
		public CHandlerEx
{
public:
	// enumeration for node states, to handle icon changes
	typedef enum
	{
		notLoaded = 0, // initial state, valid only if server never contacted
		loading,
		loaded,
		unableToLoad
	} nodeStateType;

	CMTTapiHandler(ITFSComponentData *pCompData) : CMTHandler(pCompData) 
		{ m_nState = notLoaded; m_bSelected = FALSE; m_fExpandSync = FALSE; }
	~CMTTapiHandler() {};

    // base handler virtual function over-rides
	virtual HRESULT SaveColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

    // by default we don't allow nodes to be renamed
	OVERRIDE_BaseHandlerNotify_OnRename() { return hrFalse; }
    OVERRIDE_BaseHandlerNotify_OnExpandSync();

    // base result handler overrides
    OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();
	OVERRIDE_BaseResultHandlerNotify_OnResultUpdateView();
	OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultContextHelp();

    // Multi-select functionalty
    OVERRIDE_ResultHandler_OnCreateDataObject();

    void EnableVerbs(IConsoleVerb *     pConsoleVerb,
                     MMC_BUTTON_STATE   ButtonState[],
                     BOOL               bEnable[]);

protected:
	virtual void OnChangeState(ITFSNode* pNode);
    virtual void GetErrorPrefix(ITFSNode * pNode, CString * pstrPrefix) { };
	virtual void OnHaveData(ITFSNode * pParentNode, ITFSNode * pNewNode)
	{
		if (pNewNode->IsContainer())
		{
			// assume all the child containers are derived from this class
			//((CTapiMTContainer*)pNode)->SetServer(GetServer());
		}
		pParentNode->AddChild(pNewNode);
	}

    virtual void    UpdateConsoleVerbs(IConsoleVerb * pConsoleVerb, LONG_PTR dwNodeType, BOOL bMultiSelect = FALSE);

    void    UpdateStandardVerbs(ITFSNode * pToolbar, LONG_PTR dwNodeType);
    HRESULT CreateMultiSelectData(ITFSComponent * pComponent, CDataObject * pObject);
    void    ExpandNode(ITFSNode * pNode, BOOL fExpand);

protected:
    BOOL        m_bSelected;
    BOOL        m_fExpandSync;
};

/*---------------------------------------------------------------------------
	Class:	CTapiQueryObj : general purpose base class
 ---------------------------------------------------------------------------*/
class CTapiQueryObj : public CNodeQueryObject
{
public:
	CTapiQueryObj
	(
		ITFSComponentData *	pTFSCompData, 
		ITFSNodeMgr *		pNodeMgr
	) : m_dwErr(0)
	{
		m_spTFSCompData.Set(pTFSCompData); 
	    m_spNodeMgr.Set(pNodeMgr);
	}

	CQueueDataListBase & GetQueue() { return m_dataQueue; }

public:
	CString				 m_strServer;
	SPITFSComponentData  m_spTFSCompData;
	SPITFSNodeMgr		 m_spNodeMgr;
	DWORD				 m_dwErr;
};

#endif _TAPIHAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\alloc.cpp ===
/*----------------------------------------------------------------------------
	dbgtrace.c
		Debug trace functions.

	Copyright (C) Microsoft Corporation, 1993 - 1998
	All rights reserved.

	Authors:
		suryanr		Suryanarayanan Raman
		GaryBu		Gary S. Burd

	History:
		05/11/93 suryanr	Created
		06/18/93 GaryBu		Convert to C.
		07/21/93 KennT		Code Reorg
		07/26/94 SilvanaR	Trace Buffer
		27 oct 95	garykac	DBCS_FILE_CHECK	debug file: BEGIN_STRING_OK
 ----------------------------------------------------------------------------*/
#include "stdafx.h"

#include <string.h>
#include <stdio.h>
#include <stdarg.h>
#include <time.h>

#include <stdarg.h>
#include <tchar.h>

#include "new"

#include "dbgutil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static const	std::bad_alloc	nomem;

void *	TFSAlloc(size_t size)
{
	void* ptr = 0;
	
	// NOTE: if someone calls _set_new_mode(1), then were hosed, as that
	// will cause malloc to call the new handler were trying to avoid!
	ptr = malloc(size);

	if (ptr == NULL)
	{
	
		::OutputDebugString(
							TEXT("myOperatorNew: user opted to throw bad_alloc\n"));
	
		throw nomem;
	}
	
#ifdef DEBUG_BUILD
	memset(ptr, 0xCD, size);
#endif
	
	return ptr;
}


void	TFSFree(void* ptr)
{
	   free(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\cluster.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1999 - 1999 **/
/**********************************************************************/

/*
    cluster.cpp
	handles starting/stopping cluster resources

    FILE HISTORY:
	
*/

//define USE_CCLUSPROPLIST  // tells Clushead.h to compile for the CClusPropList class
//include "clushead.h"      // the Sample Include Header

#include "stdafx.h"
#include "cluster.h"
#include "objplus.h"
#include "ipaddres.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

DynamicDLL g_ClusDLL( _T("CLUSAPI.DLL"), g_apchClusFunctionNames );
DynamicDLL g_ResUtilsDLL( _T("RESUTILS.DLL"), g_apchResUtilsFunctionNames );

//////////////////////////////////////////////////////////////////////
//
//  ControlClusterService()
//
//  Finds the cluster name using the following procedure:
//  1. Opens a handle to the local cluster (using NULL cluster name).
//  1. Enumerates the resources in the cluster.
//  2. Checks each resource to see if it is the core 
//     Network Name resource.
//  5. Finds the cluster name by retrieving the private properties 
//     of the core Network Name resource.
//  6. Online/Offline the service
//
//  Arguments:            ServiceName, start/stop flag
//
//  Return value:         Error code
//
//////////////////////////////////////////////////////////////////////
DWORD
ControlClusterService(LPCTSTR pszComputer, LPCTSTR pszResourceType, LPCTSTR pszServiceDesc, BOOL fStart)
{
    HCLUSTER  hCluster  = NULL;  // cluster handle
    HCLUSENUM hClusEnum = NULL;  // enumeration handle
    HRESOURCE hRes      = NULL;  // resource handle

    DWORD dwError       = ERROR_SUCCESS;         // captures return values
    DWORD dwIndex       = 0;                     // enumeration index; incremented to loop through all resources
    DWORD dwResFlags    = 0;                     // describes the flags set for a resource
    DWORD dwEnumType    = CLUSTER_ENUM_RESOURCE; // bitmask describing the cluster object(s) to enumerate
    
    DWORD cchResNameSize  = 0;               // actual size (count of characters) of lpszResName
    DWORD cchResNameAlloc = MAX_NAME_SIZE;   // allocated size of lpszResName; MAX_NAME_SIZE = 256 (defined in clushead.h)

    LPWSTR lpszResName      = (LPWSTR)LocalAlloc(LPTR, MAX_NAME_SIZE);  // enumerated resource name
    LPWSTR lpszResType      = (LPWSTR)LocalAlloc(LPTR, MAX_NAME_SIZE);  // the resource type of the current resource name
	
    BOOL bDoLoop        = TRUE;  // loop exit condition
    int  iResult        = 0;     // for return values

	if ( !g_ClusDLL.LoadFunctionPointers() )
		return dwError;

    //
    // Open a cluster handle.
    // The NULL cluster name opens a handle to the local cluster.
    //
    hCluster = ((OPENCLUSTER) g_ClusDLL[CLUS_OPEN_CLUSTER])( pszComputer );
    if (hCluster == NULL)
    {
        dwError = GetLastError();
        Trace1("OpenCluster failed %d!", dwError );
        goto ExitFunc;
    }

    //
    // Open an enumeration handle
    //
    hClusEnum = ((CLUSTEROPENENUM) g_ClusDLL[CLUS_CLUSTER_OPEN_ENUM])( hCluster, dwEnumType );
    if (hClusEnum == NULL)
    {
        dwError = GetLastError();
        Trace1( "ClusterOpenEnum failed %d", dwError );
        goto ExitFunc;
    }

    //
    // Enumeration loop
    //
    while( bDoLoop == TRUE )
    {
        //
        // Reset the name size for each iteration
        //
        cchResNameSize = cchResNameAlloc;

        //
        // Enumerate resource #<dwIndex>
        //
        dwError = ((CLUSTERENUM) g_ClusDLL[CLUS_CLUSTER_ENUM])( hClusEnum, 
                                                                dwIndex, 
                                                                &dwEnumType, 
                                                                lpszResName, 
                                                                &cchResNameSize );
        //
        // If the lpszResName buffer was too small, reallocate
        // according to the size returned by cchResNameSize
        // 
        if ( dwError == ERROR_MORE_DATA )
        {
            LocalFree( lpszResName );

            cchResNameAlloc = cchResNameSize;

            lpszResName = (LPWSTR) LocalAlloc( LPTR, cchResNameAlloc );

            dwError = ((CLUSTERENUM) g_ClusDLL[CLUS_CLUSTER_ENUM])( hClusEnum, 
                                                                    dwIndex, 
                                                                    &dwEnumType, 
                                                                    lpszResName, 
                                                                    &cchResNameSize );
        }

        // 
        // Exit loop on any non-success.
        // Includes ERROR_NO_MORE_ITEMS (no more objects to enumerate)
        // 
        if ( dwError != ERROR_SUCCESS ) 
			break;

        //
        // Open resource handle
        //
        hRes = ((OPENCLUSTERRESOURCE) g_ClusDLL[CLUS_OPEN_CLUSTER_RESOURCE])( hCluster, lpszResName );
    
        if (hRes == NULL)
        {
			dwError = GetLastError();
			Trace1 ( "OpenClusterResource failed %d", dwError);
            goto ExitFunc;
        }

		//
        // Get the resource type.
        //
        dwError = ((CLUSTERRESOURCECONTROL) g_ClusDLL[CLUS_CLUSTER_RESOURCE_CONTROL])( hRes, 
                                                                                       NULL, 
                                                                                       CLUSCTL_RESOURCE_GET_RESOURCE_TYPE, 
                                                                                       NULL, 
                                                                                       0,
                                                                                       lpszResType,
                                                                                       cchResNameAlloc,
                                                                                       &cchResNameSize);

        //
        // Reallocation routine if lpszResType is too small
        //
        if ( dwError == ERROR_MORE_DATA )
        {
            LocalFree( lpszResType );

            cchResNameAlloc = cchResNameSize;

            lpszResType = (LPWSTR) LocalAlloc( LPTR, cchResNameAlloc );

            dwError = ((CLUSTERRESOURCECONTROL) g_ClusDLL[CLUS_CLUSTER_RESOURCE_CONTROL])( hRes, 
                                                                                           NULL, 
                                                                                           CLUSCTL_RESOURCE_GET_RESOURCE_TYPE, 
                                                                                           NULL, 
                                                                                           0,
                                                                                           lpszResType,
                                                                                           cchResNameAlloc,
                                                                                           &cchResNameSize);
        }

        if ( dwError != ERROR_SUCCESS ) 
            break;

        if ( lstrcmpi( lpszResType, pszResourceType ) == 0 )
        {
			//
			// do the online/offline stuff here
			//
            if (fStart)
            {
                dwError = StartResource(pszComputer, hRes, pszServiceDesc);
            }
            else
            {
                dwError = StopResource(pszComputer, hRes, pszServiceDesc);
            }

			bDoLoop = FALSE;
        } 

        ((CLOSECLUSTERRESOURCE) g_ClusDLL[CLUS_CLOSE_CLUSTER_RESOURCE])( hRes );

        dwIndex++;                    // increment the enumeration index


    }  // end Enumeration Loop


ExitFunc:

    if ( hClusEnum != NULL )
        ((CLUSTERCLOSEENUM) g_ClusDLL[CLUS_CLUSTER_CLOSE_ENUM])( hClusEnum );

    if ( hCluster != NULL )
        ((CLOSECLUSTER) g_ClusDLL[CLUS_CLOSE_CLUSTER])( hCluster );

    LocalFree( lpszResName );
    LocalFree( lpszResType );

    return dwError;
} 


//////////////////////////////////////////////////////////////////////
//
//  FIsComputerInRunningCluster()
//
//	Determines if the given machine is in a running cluster
//
//  Arguments:            Computer Name
//
//  Return value:         Error code
//
//////////////////////////////////////////////////////////////////////
BOOL
FIsComputerInRunningCluster(LPCTSTR pszComputer)
{
	DWORD dwClusterState = 0;
	DWORD dwError = ERROR_SUCCESS;

	BOOL fInRunningCluster = FALSE;
	
	if ( !g_ClusDLL.LoadFunctionPointers() )
		return dwError;

    dwError = ((GETNODECLUSTERSTATE) g_ClusDLL[CLUS_GET_NODE_CLUSTER_STATE])( pszComputer, &dwClusterState );

	if (dwError == ERROR_SUCCESS)
	{
		if (dwClusterState == ClusterStateRunning)
			fInRunningCluster = TRUE;
	}

	return fInRunningCluster;
}


DWORD
StartResource(LPCTSTR pszComputer, HRESOURCE hResource, LPCTSTR pszServiceDesc)
{
	DWORD dwError = ERROR_SUCCESS;

	if ( !g_ClusDLL.LoadFunctionPointers() )
		return dwError;

    dwError = ((ONLINECLUSTERRESOURCE) g_ClusDLL[CLUS_ONLINE_CLUSTER_RESOURCE])( hResource );

	if ( dwError == ERROR_IO_PENDING )
	{
		// 
		// Put up the dialog with the funky spinning thing to 
		// let the user know that something is happening
		//
		CServiceCtrlDlg	dlgServiceCtrl(hResource, pszComputer, pszServiceDesc, TRUE);

		dlgServiceCtrl.DoModal();
        dwError = dlgServiceCtrl.m_dwErr;
	}

	return dwError;
}

DWORD
StopResource(LPCTSTR pszComputer, HRESOURCE hResource, LPCTSTR pszServiceDesc)
{
	DWORD dwError = ERROR_SUCCESS;

	if ( !g_ClusDLL.LoadFunctionPointers() )
		return dwError;

    dwError = ((OFFLINECLUSTERRESOURCE) g_ClusDLL[CLUS_OFFLINE_CLUSTER_RESOURCE])( hResource );

	if ( dwError == ERROR_IO_PENDING )
	{
		// 
		// Put up the dialog with the funky spinning thing to 
		// let the user know that something is happening
		//
		CServiceCtrlDlg	dlgServiceCtrl(hResource, pszComputer, pszServiceDesc, FALSE);

		dlgServiceCtrl.DoModal();
        dwError = dlgServiceCtrl.m_dwErr;
	}

	return dwError;
}



//////////////////////////////////////////////////////////////////////
//
//  GetClusterResourceIp()
//
//  Finds the cluster name using the following procedure:
//  1. Opens a handle to the local cluster (using NULL cluster name).
//  1. Enumerates the resources in the cluster.
//  2. Checks each resource to see if it is the core 
//     Network Name resource.
//  5. Finds the cluster name by retrieving the private properties 
//     of the core Network Name resource.
//
//  Arguments:            ServiceName
//
//  Return value:         Error code
//
//////////////////////////////////////////////////////////////////////
DWORD
GetClusterResourceIp(LPCTSTR pszComputer, LPCTSTR pszResourceType, CString & strAddress)
{
    HCLUSTER  hCluster  = NULL;  // cluster handle
    HCLUSENUM hClusEnum = NULL;  // enumeration handle
    HRESOURCE hRes      = NULL;  // resource handle
    HRESOURCE hResIp    = NULL;  // resource handle

    DWORD dwError       = ERROR_SUCCESS;         // captures return values
    DWORD dwIndex       = 0;                     // enumeration index; incremented to loop through all resources
    DWORD dwResFlags    = 0;                     // describes the flags set for a resource
    DWORD dwEnumType    = CLUSTER_ENUM_RESOURCE; // bitmask describing the cluster object(s) to enumerate
    
    DWORD cchResNameSize  = 0;               // actual size (count of characters) of lpszResName
    DWORD cchResNameAlloc = MAX_NAME_SIZE;   // allocated size of lpszResName; MAX_NAME_SIZE = 256 (defined in clushead.h)

    LPWSTR lpszResName      = (LPWSTR)LocalAlloc(LPTR, MAX_NAME_SIZE);  // enumerated resource name
    LPWSTR lpszResType      = (LPWSTR)LocalAlloc(LPTR, MAX_NAME_SIZE);                                     // the resource type of the current resource name
	
    BOOL bDoLoop        = TRUE;  // loop exit condition
    
	HKEY			hkeyProvider = NULL;
    HRESENUM        hResEnum = NULL;
	int				ienum;
	LPWSTR			pwszName = NULL;
	DWORD			cchName;
	DWORD			cchmacName;
	DWORD			dwRetType;
    LPWSTR          lpszResIpType = NULL;

	strAddress.Empty();

	if ( !g_ClusDLL.LoadFunctionPointers() )
		return dwError;

    //
    // Open a cluster handle.
    // The NULL cluster name opens a handle to the local cluster.
    //
    hCluster = ((OPENCLUSTER) g_ClusDLL[CLUS_OPEN_CLUSTER])( pszComputer );
    if (hCluster == NULL)
    {
        dwError = GetLastError();
        Trace1("OpenCluster failed %d!", dwError );
        goto ExitFunc;
    }

    //
    // Open an enumeration handle
    //
    hClusEnum = ((CLUSTEROPENENUM) g_ClusDLL[CLUS_CLUSTER_OPEN_ENUM])( hCluster, dwEnumType );
    if (hClusEnum == NULL)
    {
        dwError = GetLastError();
        Trace1( "ClusterOpenEnum failed %d", dwError );
        goto ExitFunc;
    }

    //
    // Enumeration loop
    //
    while( bDoLoop == TRUE )
    {
        //
        // Reset the name size for each iteration
        //
        cchResNameSize = cchResNameAlloc;

        //
        // Enumerate resource #<dwIndex>
        //
        dwError = ((CLUSTERENUM) g_ClusDLL[CLUS_CLUSTER_ENUM])( hClusEnum, 
                                                                dwIndex, 
                                                                &dwEnumType, 
                                                                lpszResName, 
                                                                &cchResNameSize );
        //
        // If the lpszResName buffer was too small, reallocate
        // according to the size returned by cchResNameSize
        // 
        if ( dwError == ERROR_MORE_DATA )
        {
            LocalFree( lpszResName );

            cchResNameAlloc = cchResNameSize;

            lpszResName = (LPWSTR) LocalAlloc( LPTR, cchResNameAlloc );

            dwError = ((CLUSTERENUM) g_ClusDLL[CLUS_CLUSTER_ENUM])( hClusEnum, 
                                                                    dwIndex, 
                                                                    &dwEnumType, 
                                                                    lpszResName, 
                                                                    &cchResNameSize );
        }

        // 
        // Exit loop on any non-success.
        // Includes ERROR_NO_MORE_ITEMS (no more objects to enumerate)
        // 
        if ( dwError != ERROR_SUCCESS ) 
			break;

        //
        // Open resource handle
        //
        hRes = ((OPENCLUSTERRESOURCE) g_ClusDLL[CLUS_OPEN_CLUSTER_RESOURCE])( hCluster, lpszResName );
    
        if (hRes == NULL)
        {
			dwError = GetLastError();
			Trace1 ( "OpenClusterResource failed %d", dwError);
            goto ExitFunc;
        }

        dwError = GetResourceType(hRes, &lpszResType, cchResNameAlloc, &cchResNameSize);

        if ( dwError != ERROR_SUCCESS ) 
            break;

        if ( lstrcmpi( lpszResType, pszResourceType ) == 0 )
        {
            // found the right resource, enum dependencies and find the IP
            hResEnum = ((CLUSTERRESOURCEOPENENUM) g_ClusDLL[CLUS_CLUSTER_RESOURCE_OPEN_ENUM])( hRes, 
                                                                                               CLUSTER_RESOURCE_ENUM_DEPENDS);

            if (hResEnum)
            {
			    // Allocate a name buffer.
			    cchmacName = 128;
			    pwszName = new WCHAR[cchmacName];

			    // Loop through the enumeration and add each dependent resource to the list.
			    for (ienum = 0 ; ; ienum++)
			    {
				    // Get the next item in the enumeration.
				    cchName = cchmacName;
				    
                    dwError = ((CLUSTERRESOURCEENUM) g_ClusDLL[CLUS_CLUSTER_RESOURCE_ENUM])( hResEnum, 
                                                                                             ienum,
                                                                                             &dwRetType,
                                                                                             pwszName,
                                                                                             &cchName);
				    if (dwError == ERROR_MORE_DATA)
				    {
					    delete [] pwszName;
					    cchmacName = ++cchName;
					    pwszName = new WCHAR[cchmacName];
                        dwError = ((CLUSTERRESOURCEENUM) g_ClusDLL[CLUS_CLUSTER_RESOURCE_ENUM])( hResEnum, 
                                                                                                 ienum,
                                                                                                 &dwRetType,
                                                                                                 pwszName,
                                                                                                 &cchName);
				    }  // if:  name buffer was too small
				    
                    if (dwError == ERROR_NO_MORE_ITEMS)
                    {
					    break;
                    }
				    else 
                    if (dwError != ERROR_SUCCESS)
                    {
					    break;
                    }

				    ASSERT(dwRetType == CLUSTER_RESOURCE_ENUM_DEPENDS);

                    //
                    // Open resource handle
                    //
                    hResIp = ((OPENCLUSTERRESOURCE) g_ClusDLL[CLUS_OPEN_CLUSTER_RESOURCE])( hCluster, pwszName );
                    if (hResIp == NULL)
                    {
			            dwError = GetLastError();
			            Trace1 ( "OpenClusterResource failed %d", dwError);
                        break;
                    }

					lpszResIpType = (LPWSTR)LocalAlloc(LPTR, MAX_NAME_SIZE);

                    dwError = GetResourceType(hResIp, &lpszResIpType, MAX_NAME_SIZE, NULL);

                    if ( dwError != ERROR_SUCCESS ) 
                        break;

                    if ( lstrcmpiW( lpszResIpType, _T("IP Address") ) == 0 )
			        {
                        GetResourceIpAddress(hResIp, strAddress);
						bDoLoop = FALSE;
                    } // if: IP Address resource found

                    ((CLOSECLUSTERRESOURCE) g_ClusDLL[CLUS_CLOSE_CLUSTER_RESOURCE])( hResIp );
			        
                    LocalFree( lpszResIpType );
			        
                    hResIp = NULL;
			        lpszResIpType = NULL;

					if (!strAddress.IsEmpty())
						break;  // found it
		        
                } // for: each dependency

    		    delete [] pwszName;
                dwError = ((CLUSTERRESOURCECLOSEENUM) g_ClusDLL[CLUS_CLUSTER_RESOURCE_CLOSE_ENUM])( hResEnum ); 
            }
                
        }

        ((CLOSECLUSTERRESOURCE) g_ClusDLL[CLUS_CLOSE_CLUSTER_RESOURCE])( hRes );

        dwIndex++;                    // increment the enumeration index


    }  // end Enumeration Loop


ExitFunc:

    if ( hClusEnum != NULL )
        ((CLUSTERCLOSEENUM) g_ClusDLL[CLUS_CLUSTER_CLOSE_ENUM])( hClusEnum );

    if ( hCluster != NULL )
        ((CLOSECLUSTER) g_ClusDLL[CLUS_CLOSE_CLUSTER])( hCluster );

    LocalFree( lpszResName );
    LocalFree( lpszResType );

    return dwError;
} 


DWORD
GetResourceType(HRESOURCE hRes, LPWSTR * ppszName, DWORD dwBufSizeIn, DWORD * pdwBufSizeOut)
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD cchResNameSize = dwBufSizeIn;
    DWORD cchResNameSizeNeeded = 0;
	//
	// Figure out how big a buffer we need.
	//
    dwError = ((CLUSTERRESOURCECONTROL) g_ClusDLL[CLUS_CLUSTER_RESOURCE_CONTROL])( hRes, 
                                                                                   NULL, 
                                                                                   CLUSCTL_RESOURCE_GET_RESOURCE_TYPE, 
                                                                                   NULL, 
                                                                                   0,
                                                                                   *ppszName,
                                                                                   cchResNameSize,
                                                                                   &cchResNameSizeNeeded);

    //
    // Reallocation routine if lpszResType is too small
    //
    if ( dwError == ERROR_MORE_DATA )
    {
        cchResNameSize = cchResNameSizeNeeded;

        LocalFree(*ppszName);

        *ppszName = (LPWSTR) LocalAlloc( LPTR, cchResNameSize );

        dwError = ((CLUSTERRESOURCECONTROL) g_ClusDLL[CLUS_CLUSTER_RESOURCE_CONTROL])( hRes, 
                                                                                       NULL, 
                                                                                       CLUSCTL_RESOURCE_GET_RESOURCE_TYPE, 
                                                                                       NULL, 
                                                                                       0,
                                                                                       *ppszName,
                                                                                       cchResNameSize,
                                                                                       &cchResNameSizeNeeded);
    }

    if (pdwBufSizeOut)
        *pdwBufSizeOut = cchResNameSizeNeeded;

    return dwError;
}

DWORD
GetResourceIpAddress(HRESOURCE hRes, CString & strAddress)
{
	DWORD		dwError = ERROR_SUCCESS;
	DWORD		cbProps;
	PVOID		pvProps = NULL;
    LPWSTR  	pszIPAddress = NULL;
    
    // Loop to avoid goto's.
	do
	{
		//
		// Get the size of the private properties from the resource.
		//
        dwError = ((CLUSTERRESOURCECONTROL) g_ClusDLL[CLUS_CLUSTER_RESOURCE_CONTROL])( hRes, 
                                                                                       NULL, 
                                                                                       CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES, 
                                                                                       NULL, 
                                                                                       0,
                                                                                       NULL,
                                                                                       0,
                                                                                       &cbProps);
       
		if ( (dwError != ERROR_SUCCESS) ||
			 (cbProps == 0) )
		{
			if ( dwError == ERROR_SUCCESS )
			{
				dwError = ERROR_INVALID_DATA;
			} // if: no properties available
			
            break;
		
        } // if: error getting size of properties or no properties available

		//
		// Allocate the property buffer.
		//
		pvProps = LocalAlloc( LMEM_FIXED, cbProps );
		if ( pvProps == NULL )
		{
			dwError = GetLastError();
			break;
		} // if: error allocating memory

		//
		// Get the private properties from the resource.
		//
        dwError = ((CLUSTERRESOURCECONTROL) g_ClusDLL[CLUS_CLUSTER_RESOURCE_CONTROL])( hRes, 
                                                                                       NULL, 
                                                                                       CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES, 
                                                                                       NULL, 
                                                                                       0,
                                                                                       pvProps,
                                                                                       cbProps,
                                                                                       &cbProps);
		if ( dwError != ERROR_SUCCESS )
		{
			break;
		} // if: error getting private properties

		//
		// Find the Address property.
		//
		dwError = FindSzProp(pvProps, cbProps, L"Address", &pszIPAddress);
		
		if ( dwError != ERROR_SUCCESS )
		{
			break;
		} // if: error finding the Address property

	} while ( 0 );

	//
	// Cleanup.
	//

    strAddress = pszIPAddress;

	LocalFree( pvProps );

	return dwError;
}

DWORD FindSzProp
(
    LPVOID      pvProps,
    DWORD       cbProps,
    LPCWSTR     pszTarget,
    LPWSTR *    ppszOut
)
{

    BOOL   DoLoop      = TRUE;          // loop exit condition
    BOOL   Found       = FALSE;         // tests whether property has been found
    DWORD  dwError     = ERROR_SUCCESS; // for return values

    DWORD  cbOffset    = 0;    // offset to next entry in the value list
    DWORD  cbPosition  = 0;    // tracks the advance through the value list buffer

    CLUSPROP_BUFFER_HELPER ListEntry;  // to parse the list
    
    //
    // Set the pb member to the start of the list
    //
    ListEntry.pb = (BYTE *) pvProps;

    //
    // Main loop:
    // 1. Check syntax of current list entry
    // 2. If it is a property name, check that we have the right property.
    // 3. If it is a binary value, check that we found the right name.
    // 4. Advance the position counter and test vs. size of list.
    // 
    do
    {
        switch( *ListEntry.pdw ) // check the syntax of the entry
        {
        case CLUSPROP_SYNTAX_NAME:
            //
            // If this is the Security property, flag Found as TRUE.
            // The next pass through the loop should yield the Security value.
            //
            if ( lstrcmpi( ListEntry.pName->sz, pszTarget ) == 0 )
            {
                Trace0( "Found name.\n" );
                Found = TRUE;
            }
            else
            {
                Found = FALSE;
            }
            //
            // Calculate offset to next entry. Note the use of ALIGN_CLUSPROP
            //
            cbOffset = sizeof( *ListEntry.pName ) + ALIGN_CLUSPROP( ListEntry.pName->cbLength );
            break;
        case CLUSPROP_SYNTAX_LIST_VALUE_DWORD:
            cbOffset = sizeof( *ListEntry.pDwordValue ); // ALIGN_CLUSPROP not used; value is already DWORD-aligned
            break;
        case CLUSPROP_SYNTAX_LIST_VALUE_SZ:
            if ( Found == TRUE)
            {
                if (ppszOut)
                {
                    *ppszOut = ListEntry.pStringValue->sz;
                }

                DoLoop = FALSE;
            }
            else
            {
                Trace0( "Found something else.\n" );
                cbOffset = sizeof( *ListEntry.pStringValue ) + ALIGN_CLUSPROP( ListEntry.pStringValue->cbLength );
            }
            break;
        case CLUSPROP_SYNTAX_LIST_VALUE_BINARY:  // this is what we're looking for
            cbOffset = sizeof( *ListEntry.pBinaryValue ) + ALIGN_CLUSPROP( ListEntry.pBinaryValue->cbLength );
            break;
        case CLUSPROP_SYNTAX_ENDMARK:
        default:
            cbOffset = sizeof( DWORD );
            break;
        }
        
        //
        // Verify that the offset to the next entry is
        // within the value list buffer, then advance
        // the CLUSPROP_BUFFER_HELPER pointer.
        //
        cbPosition += cbOffset;
        if ( cbPosition > cbProps ) 
            break;
        ListEntry.pb += cbOffset;

    } while ( DoLoop );

	if (Found)
		return 0;
	else
	    return 1;
}

DWORD   GetClusterInfo(
            LPCTSTR pszClusIp,
            CString &strClusName,
            DWORD * pdwClusIp)
{
    DWORD       dwErr = ERROR_SUCCESS;
    HCLUSTER    hCluster;
    CIpAddress  ipClus(pszClusIp);

    strClusName.Empty();
    *pdwClusIp = (LONG)ipClus;

    hCluster = ((OPENCLUSTER) g_ClusDLL[CLUS_OPEN_CLUSTER])(pszClusIp);
    if (hCluster == NULL)
    {
        dwErr = GetLastError();
    }
    else
    {
        DWORD    dwClusNameLen;

        dwClusNameLen = 0;
        dwErr = ((GETCLUSTERINFORMATION) g_ClusDLL[CLUS_GET_CLUSTER_INFORMATION])(
                    hCluster,
                    NULL,
                    &dwClusNameLen,
                    NULL);
        if (dwClusNameLen > 0)
        {
            LPTSTR   pClusName;

            dwClusNameLen++;
            pClusName = strClusName.GetBuffer((dwClusNameLen)*sizeof(WCHAR));
            dwErr = ((GETCLUSTERINFORMATION) g_ClusDLL[CLUS_GET_CLUSTER_INFORMATION])(
                    hCluster,
                    pClusName,
                    &dwClusNameLen,
                    NULL);
            strClusName.ReleaseBuffer();
        }
    
        ((CLOSECLUSTER) g_ClusDLL[CLUS_CLOSE_CLUSTER])(hCluster);
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\cluster.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1999 - 1999 **/
/**********************************************************************/

/*
    cluster.h
	handles starting/stopping cluster resources

    FILE HISTORY:
	
*/

#ifndef _CLUSTER_H
#define _CLUSTER_H

#ifndef _DYNAMLNK_H
#include "dynamlnk.h"
#endif

#define MAX_NAME_SIZE	256

typedef enum _ClusApiIndex
{
	CLUS_GET_NODE_CLUSTER_STATE = 0,
	CLUS_OPEN_CLUSTER,
	CLUS_CLUSTER_OPEN_ENUM,
	CLUS_CLUSTER_ENUM,
	CLUS_OPEN_CLUSTER_RESOURCE,
	CLUS_ONLINE_CLUSTER_RESOURCE,
	CLUS_OFFLINE_CLUSTER_RESOURCE,
	CLUS_GET_CLUSTER_RESOURCE_STATE,
	CLUS_CLOSE_CLUSTER_RESOURCE,
	CLUS_CLUSTER_CLOSE_ENUM,
	CLUS_CLOSE_CLUSTER,
    CLUS_CLUSTER_RESOURCE_CONTROL,
    CLUS_CLUSTER_RESOURCE_OPEN_ENUM,
    CLUS_CLUSTER_RESOURCE_ENUM,
    CLUS_CLUSTER_RESOURCE_CLOSE_ENUM,
    CLUS_GET_CLUSTER_INFORMATION
};

// not subject to localization
static LPCSTR g_apchClusFunctionNames[] = {
	"GetNodeClusterState",
	"OpenCluster",
	"ClusterOpenEnum",
	"ClusterEnum",
	"OpenClusterResource",
	"OnlineClusterResource",
	"OfflineClusterResource",
	"GetClusterResourceState",
	"CloseClusterResource",
	"ClusterCloseEnum",
	"CloseCluster",
    "ClusterResourceControl",
    "ClusterResourceOpenEnum",
    "ClusterResourceEnum",
    "ClusterResourceCloseEnum",
    "GetClusterInformation",
	NULL
};

// not subject to localization
extern DynamicDLL g_ClusDLL;

typedef LONG                    (*GETNODECLUSTERSTATE)      (LPCWSTR, LPDWORD);
typedef HCLUSTER                (*OPENCLUSTER)              (LPCWSTR);
typedef HCLUSENUM               (*CLUSTEROPENENUM)		    (HCLUSTER, DWORD);
typedef DWORD                   (*CLUSTERENUM)              (HCLUSENUM, DWORD, LPDWORD, LPWSTR, LPDWORD);
typedef HRESOURCE               (*OPENCLUSTERRESOURCE)      (HCLUSTER, LPCWSTR);
typedef DWORD                   (*ONLINECLUSTERRESOURCE)    (HRESOURCE);
typedef DWORD                   (*OFFLINECLUSTERRESOURCE)   (HRESOURCE);
typedef CLUSTER_RESOURCE_STATE  (*GETCLUSTERRESOURCESTATE)  (HRESOURCE, LPWSTR, LPDWORD, LPWSTR, LPDWORD);
typedef BOOL                    (*CLOSECLUSTERRESOURCE)     (HRESOURCE);
typedef DWORD                   (*CLUSTERCLOSEENUM)         (HCLUSENUM);
typedef BOOL                    (*CLOSECLUSTER)			    (HCLUSTER);
typedef DWORD                   (*CLUSTERRESOURCECONTROL)   (HRESOURCE, HNODE, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPVOID);
typedef HRESENUM                (*CLUSTERRESOURCEOPENENUM)  (HRESOURCE, DWORD);
typedef DWORD                   (*CLUSTERRESOURCEENUM)      (HRESENUM, DWORD, LPDWORD, LPWSTR, LPDWORD);
typedef DWORD                   (*CLUSTERRESOURCECLOSEENUM) (HRESENUM);
typedef DWORD                   (*GETCLUSTERINFORMATION)    (HCLUSTER, LPWSTR, LPDWORD, LPCLUSTERVERSIONINFO);

// Resource utils for cluster support
typedef enum _ResUtilsIndex
{
	RESUTILS_FIND_DWORD_PROPERTY = 0,
	RESUTILS_FIND_SZ_PROPERTY,
};

// not subject to localization
static LPCSTR g_apchResUtilsFunctionNames[] = {
	"ResUtilFindDwordProperty",
    "ResUtilFindSzProperty",
	NULL,
};

typedef DWORD					(*RESUTILSFINDDWORDPROPERTY)(PVOID, DWORD, LPCWSTR, LPDWORD);
typedef DWORD					(*RESUTILSFINDSZPROPERTY)(PVOID, DWORD, LPCWSTR, LPWSTR *);
 
// not subject to localization
extern DynamicDLL g_ResUtilsDLL;

DWORD   ControlClusterService(LPCTSTR pszComputer, LPCTSTR pszResourceType, LPCTSTR pszServiceDesc, BOOL fStart);
BOOL    FIsComputerInRunningCluster(LPCTSTR pszComputer);
DWORD   GetClusterResourceIp(LPCTSTR pszComputer, LPCTSTR pszResourceType, CString & strAddress);

DWORD   StartResource(LPCTSTR pszComputer, HRESOURCE hResource, LPCTSTR pszServiceDesc);
DWORD   StopResource(LPCTSTR pszComputer, HRESOURCE hResource, LPCTSTR pszServiceDesc);

DWORD   GetResourceType(HRESOURCE hRes, LPWSTR * ppszName, DWORD dwBufSizeIn, DWORD * pdwBufSizeOut);
DWORD   GetResourceIpAddress(HRESOURCE hRes, CString & strAddress);

DWORD	FindSzProp(LPVOID pvProps, DWORD cbProps, LPCWSTR pszTarget, LPWSTR * ppszOut);

DWORD   GetClusterInfo(LPCTSTR pszClusIp, CString &strClusName, DWORD * pdwClusIp);

#endif _CLUSTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\compdata.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    ccompont.cpp
	base classes for IComponent and IComponentData

    FILE HISTORY:
	
*/

#include "stdafx.h"
#include "extract.h"
#include "compdata.h"
#include "proppage.h"
#include "tregkey.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/*!--------------------------------------------------------------------------
	FUseTaskpadsByDefault
		See comments in header file.
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL	FUseTaskpadsByDefault(LPCTSTR pszMachineName)
{
	static DWORD	s_dwStopTheInsanity = 42;
	RegKey	regkeyMMC;
	DWORD	dwErr;

	if (s_dwStopTheInsanity == 42)
	{
		// Set the default to FALSE (i.e. use taskpads by default)
		// ------------------------------------------------------------
		s_dwStopTheInsanity = 0;
		
		dwErr = regkeyMMC.Open(HKEY_LOCAL_MACHINE,
							   _T("Software\\Microsoft\\MMC"),
							   KEY_READ, pszMachineName);
		if (dwErr == ERROR_SUCCESS)
		{
			regkeyMMC.QueryValue(_T("TFSCore_StopTheInsanity"), s_dwStopTheInsanity);
		}
	}
		
	return !s_dwStopTheInsanity;
}


/*!--------------------------------------------------------------------------

	IComponentData implementation
 
---------------------------------------------------------------------------*/

DEBUG_DECLARE_INSTANCE_COUNTER(TFSComponentData);

/*!--------------------------------------------------------------------------
	TFSComponentData::TFSComponentData
		Constructor.
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSComponentData::TFSComponentData()
	: m_cRef(1),
      m_pWatermarkInfo(NULL)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(TFSComponentData);

	m_hWnd = NULL;
	m_bFirstTimeRun = FALSE;

    m_fTaskpadInitialized = FALSE;
}


/*!--------------------------------------------------------------------------
	TFSComponentData::~TFSComponentData
		Destructor
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSComponentData::~TFSComponentData()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(TFSComponentData);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	if (m_hiddenWnd.GetSafeHwnd())
		::DestroyWindow(m_hiddenWnd.GetSafeHwnd());
	Assert(m_cRef == 0);
}


/*!--------------------------------------------------------------------------
	TFSComponentData::Construct
		Call this to fully initialize this object.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT TFSComponentData::Construct(ITFSCompDataCallback *pCallback)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{	
		m_spCallback.Set(pCallback);
	
		// Create the node mgr
		CORg( CreateTFSNodeMgr(&m_spNodeMgr,
							   (IComponentData *) this,
							   m_spConsole,
							   m_spConsoleNameSpace));

		// Initialize the node manager by pasing the ptr to ourselves
		// in
		CORg( m_spCallback->OnInitializeNodeMgr(
										static_cast<ITFSComponentData *>(this),
										m_spNodeMgr) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;

	return hr;
}



IMPLEMENT_ADDREF_RELEASE(TFSComponentData)



/*!--------------------------------------------------------------------------
	TFSComponentData::QueryInterface
		Implementation of IUnknown::QueryInterface
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSComponentData::QueryInterface(REFIID riid, LPVOID *ppv)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
        *ppv = (LPVOID) this;
	else if (riid == IID_IComponentData)
		*ppv = (IComponentData *) this;
	else if (riid == IID_IExtendPropertySheet)
		*ppv = (IExtendPropertySheet *) this;
	else if (riid == IID_IExtendPropertySheet2)
		*ppv = (IExtendPropertySheet2 *) this;
	else if (riid == IID_IExtendContextMenu)
		*ppv = (IExtendContextMenu *) this;
	else if (riid == IID_IPersistStreamInit)
		*ppv = (IPersistStreamInit *) this;
	else if (riid == IID_ISnapinHelp)
		*ppv = (ISnapinHelp *) this;
	else if (riid == IID_ITFSComponentData)
		*ppv = (ITFSComponentData *) this;

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
        {
        ((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
        }
    else
		return E_NOINTERFACE;
}

 
TFSCORE_API(HRESULT) ExtractNodeFromDataObject(ITFSNodeMgr *pNodeMgr,
								  const CLSID *pClsid,
								  LPDATAOBJECT pDataObject,
								  BOOL fCheckForCreate,
								  ITFSNode **ppNode,
								  DWORD *pdwType,
								  INTERNAL **ppInternal)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	Assert(pNodeMgr);
	Assert(pClsid);
	Assert(ppNode);

	SPINTERNAL	spInternal = ExtractInternalFormat(pDataObject);
	BOOL		bExtension;
	MMC_COOKIE	cookie;
	SPITFSNode	spNode;
	SPITFSNodeHandler	spNodeHandler;
	HRESULT		hr = hrOK;

	// Set the default value
	if (pdwType)
		*pdwType |= TFS_COMPDATA_NORMAL;

	if (ppInternal)
		*ppInternal = NULL;

	//
	// No pInternal means that we are an extension and this is 
	// our root node... translate by calling find object
	//
	// Check the CLSID for a match (because we are in shared code
	// multiple snapins are using the SNAPIN_INTERNAL format).  Thus
	// we need to do an extra check to make sure that this is really us.
	//
	if ((spInternal == NULL) || (*pClsid != spInternal->m_clsid) )
	{
		CORg( pNodeMgr->GetRootNode(&spNode) );
		if (pdwType)
		{
			*pdwType |= (TFS_COMPDATA_EXTENSION | TFS_COMPDATA_UNKNOWN_DATAOBJECT);
		}
		
	}
	else
	{
		DATA_OBJECT_TYPES	type = spInternal->m_type;

		if (fCheckForCreate && type == CCT_SNAPIN_MANAGER)
		{
			CORg( pNodeMgr->GetRootNode(&spNode) );

			//$ Review (kennt): is this always true, can we always
			// depend on a create node being available?
			Assert(spNode);
			if (pdwType)
				*pdwType |= TFS_COMPDATA_CREATE;
		}
		else
		{
			if (pdwType && (spInternal->m_clsid != *pClsid))
				*pdwType |= TFS_COMPDATA_EXTENSION;
				
			cookie = spInternal->m_cookie;
			CORg( pNodeMgr->FindNode(cookie, &spNode) );
			Assert((MMC_COOKIE) spNode->GetData(TFS_DATA_COOKIE) == cookie);
		}
		
	}

	if (ppInternal)
		*ppInternal = spInternal.Transfer();
	
	*ppNode = spNode.Transfer();
Error:
	return hr;
}


/*!--------------------------------------------------------------------------
	TFSComponentData::Initialize
		Implementation of IComponentData::Initialize
		MMC calls this to initialize the IComponentData interface
	Author: 
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSComponentData::Initialize
(
	LPUNKNOWN pUnk
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Assert(pUnk != NULL);
    HRESULT hr = hrOK;

	COM_PROTECT_TRY
	{

		// MMC should only call ::Initialize once!
		Assert(m_spConsoleNameSpace == NULL);
		pUnk->QueryInterface(IID_IConsoleNameSpace2, 
							 reinterpret_cast<void**>(&m_spConsoleNameSpace));
		Assert(m_spConsoleNameSpace);

		// add the images for the scope tree
		SPIImageList	spScopeImageList;
	
		CORg( pUnk->QueryInterface(IID_IConsole2,
								   reinterpret_cast<void**>(&m_spConsole)) );
		CORg( m_spConsole->QueryScopeImageList(&spScopeImageList) );

		// call the derived class
		Assert(m_spCallback);
		CORg( m_spCallback->OnInitialize(spScopeImageList) );
		
		
		// Create the utility members
		if (!m_hiddenWnd.GetSafeHwnd())
		{
			if (!m_hiddenWnd.Create())
			{
				Trace0("Failed to create hidden window\n");
				CORg( E_FAIL );
			}
			m_hWnd = m_hiddenWnd.GetSafeHwnd();
		}
		Assert(m_hWnd);
		
		// Setup the node mgr
		// As strange as it seems, the Initialize() method is not
		// necessarily the first function called.
		Assert(m_spNodeMgr);
		m_spNodeMgr->SetConsole(m_spConsoleNameSpace, m_spConsole);
		
		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;

	if (!FHrSucceeded(hr))
	{
		m_spNodeMgr.Release();
		m_spConsoleNameSpace.Release();		
		m_spConsole.Release();
	}
	return hr;
}


/*!--------------------------------------------------------------------------
	TFSComponentData::CreateComponent
		Implementation of IComponentData::CreateComponent
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSComponentData::CreateComponent(LPCOMPONENT *ppComponent)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return m_spCallback->OnCreateComponent(ppComponent);
}

/*!--------------------------------------------------------------------------
	TFSComponentData::Notify
		Implementation of IComponentData::Notify
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSComponentData::Notify(LPDATAOBJECT lpDataObject,
									  MMC_NOTIFY_TYPE event,
									  LPARAM arg, LPARAM lParam)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Assert(m_spConsoleNameSpace != NULL);
    HRESULT hr = hrOK;
	SPITFSNode	spNode;
	SPITFSNodeHandler	spNodeHandler;
	DWORD	dwType = 0;

	COM_PROTECT_TRY
	{
		if (event == MMCN_PROPERTY_CHANGE)
		{
            hr = m_spCallback->OnNotifyPropertyChange(lpDataObject, event, arg, lParam);
            if (hr != E_NOTIMPL)
            {
                return hr;
            }
			
            CPropertyPageHolderBase * pHolder = 
                reinterpret_cast<CPropertyPageHolderBase *>(lParam);
			
			spNode = pHolder->GetNode();
		}
		else
		{
			//
			// Since it's my folder it has an internal format.
			// Design Note: for extension.  I can use the fact, that the
			// data object doesn't have my internal format and I should
			// look at the node type and see how to extend it.
			//
			CORg( ExtractNodeFromDataObject(m_spNodeMgr,
											m_spCallback->GetCoClassID(),
											lpDataObject,
											FALSE,
											&spNode,
											&dwType,
											NULL) );
		}
		
		// pass the event to the event handler
		Assert(spNode);
		CORg( spNode->GetHandler(&spNodeHandler) );
		CORg( spNodeHandler->Notify(spNode, lpDataObject, dwType, event, arg, lParam) );
		
		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;

    return hr;
}

/*!--------------------------------------------------------------------------
	TFSComponentData::Destroy
		Implementation of IComponentData::Destroy
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSComponentData::Destroy()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	SPITFSNode	spNode;
	HRESULT		hr = hrOK;

	COM_PROTECT_TRY
	{
        if (m_spCallback)
		    m_spCallback->OnDestroy();
	
		m_spConsole.Release();
		m_spConsoleNameSpace.Release();

		if (m_spNodeMgr)
		{
			m_spNodeMgr->GetRootNode(&spNode);
			if (spNode)
			{
				spNode->DeleteAllChildren(FALSE);
				spNode->Destroy();
			}
			spNode.Release();

			m_spNodeMgr->SetRootNode(NULL);
		}
		
		m_spNodeMgr.Release();

		m_spCallback.Release();

	}
	COM_PROTECT_CATCH;
			
	return hr;
}

/*!--------------------------------------------------------------------------
	TFSComponentData::QueryDataObject
		Implementation of IComponentData::QueryDataObject
		MMC calls this to get a data object from us to hand us data in
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSComponentData::QueryDataObject(MMC_COOKIE cookie,
											   DATA_OBJECT_TYPES type,
											   LPDATAOBJECT *ppDataObject)
{
	return m_spCallback->OnCreateDataObject(cookie, type, ppDataObject);
}

/*!--------------------------------------------------------------------------
	TFSComponentData::CompareObjects
		Implementation of IComponentData::CompareObject
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSComponentData::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
		return E_POINTER;

    // Make sure both data object are mine
    SPINTERNAL	spA;
    SPINTERNAL	spB;
    HRESULT hr = S_FALSE;

	COM_PROTECT_TRY
	{

		spA = ExtractInternalFormat(lpDataObjectA);
		spB = ExtractInternalFormat(lpDataObjectA);
		
		if (spA != NULL && spB != NULL)
			hr = (*spA == *spB) ? S_OK : S_FALSE;
		
	}
	COM_PROTECT_CATCH;

    return hr;
}

/*!--------------------------------------------------------------------------
	TFSComponentData::GetDisplayInfo
		Implementation of IComponentData::GetDisplayInfo		
		MMC calls this to get the display string for scope items
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSComponentData::GetDisplayInfo(LPSCOPEDATAITEM pScopeDataItem)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    wchar_t* pswzString = NULL;
    
    Assert(pScopeDataItem != NULL);

	SPITFSNode	spNode;
	MMC_COOKIE	cookie = pScopeDataItem->lParam;
	HRESULT		hr = hrOK;

	COM_PROTECT_TRY
	{

		m_spNodeMgr->FindNode(cookie, &spNode);
		
		pswzString = const_cast<LPTSTR>(spNode->GetString(0));
		
		Assert(pswzString != NULL);
		
		//$ Review (kennt) : will need to convert string to Wide from Tchar
		//$ Review (kennt) : when do we free this string up?
		if (*pswzString != NULL)
			pScopeDataItem->displayname = pswzString;
		
	}
	COM_PROTECT_CATCH;

	return hr;
}



/*---------------------------------------------------------------------------
	IExtendPropertySheet Implementation
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	TFSComponentData::CreatePropertyPages
		Implementation of IExtendPropertySheet::CreatePropertyPages
		Called for a node to put up property pages
	Author: 
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
TFSComponentData::CreatePropertyPages
(
	LPPROPERTYSHEETCALLBACK lpProvider, 
    LONG_PTR				handle, 
    LPDATAOBJECT            pDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SPITFSNode	        spNode;
	SPITFSNodeHandler	spNodeHandler;
	HRESULT		        hr = hrOK;
	DWORD		        dwType = 0;
    SPINTERNAL          spInternal;

	COM_PROTECT_TRY
	{
        spInternal = ExtractInternalFormat(pDataObject);

	    // this was an object created by the modal wizard, do nothing
	    if (spInternal && spInternal->m_type == CCT_UNINITIALIZED)
	    {
		    return hr;
	    }

		CORg( ExtractNodeFromDataObject(m_spNodeMgr,
										m_spCallback->GetCoClassID(),
										pDataObject,
										TRUE, &spNode, &dwType, NULL) );

        //
		// Create the property page for a particular node
		//
		CORg( spNode->GetHandler(&spNodeHandler) );
		
		CORg( spNodeHandler->CreatePropertyPages(spNode, lpProvider,
			pDataObject,
			handle, dwType) );
		
		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
			
	return hr;
}

/*!--------------------------------------------------------------------------
	TFSComponentData::QueryPagesFor
		Implementation of IExtendPropertySheet::QueryPagesFor
		MMC calls this to see if a node has property pages
	Author: 
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
TFSComponentData::QueryPagesFor
(
	LPDATAOBJECT pDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	DATA_OBJECT_TYPES   type;
	SPITFSNode			spNode;
	SPITFSNodeHandler	spNodeHandler;
	DWORD				dwType = 0;
	SPINTERNAL			spInternal;
	HRESULT				hr = hrOK;
    
	COM_PROTECT_TRY
	{
        spInternal = ExtractInternalFormat(pDataObject);

	    // this was an object created by the modal wizard, do nothing
	    if (spInternal && spInternal->m_type == CCT_UNINITIALIZED)
	    {
		    return hr;
	    }

        CORg( ExtractNodeFromDataObject(m_spNodeMgr,
										m_spCallback->GetCoClassID(),
										pDataObject,
										TRUE, &spNode, &dwType, NULL) );

        if (spInternal)
			type = spInternal->m_type;
		else
			type = CCT_SCOPE;
		
		CORg( spNode->GetHandler(&spNodeHandler) );
		CORg( spNodeHandler->HasPropertyPages(spNode, pDataObject,
											  type, dwType) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;

	return hr;
}

/*!--------------------------------------------------------------------------
	TFSComponentData::GetWatermarks
		Implementation of IExtendPropertySheet::Watermarks
		MMC calls this for wizard 97 info
	Author: 
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
TFSComponentData::GetWatermarks
(
    LPDATAOBJECT pDataObject,
    HBITMAP *   lphWatermark, 
    HBITMAP *   lphHeader,    
    HPALETTE *  lphPalette, 
    BOOL *      bStretch
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    HRESULT				hr = hrOK;

	COM_PROTECT_TRY
	{
        // set some defaults
        *lphWatermark = NULL;
        *lphHeader = NULL;
        *lphPalette = NULL;
        *bStretch = FALSE;

        if (m_pWatermarkInfo)
        {
            *lphWatermark = m_pWatermarkInfo->hWatermark;
            *lphHeader = m_pWatermarkInfo->hHeader;
            *lphPalette = m_pWatermarkInfo->hPalette;
            *bStretch = m_pWatermarkInfo->bStretch;
        }

	}
	COM_PROTECT_CATCH;

	return hr;
}

/*---------------------------------------------------------------------------
	IExtendContextMenu implementation
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	TFSComponentData::AddMenuItems
		Implementation of IExtendContextMenu::AddMenuItems
		MMC calls this so that a node can add menu items to a context menu
	Author: 
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
TFSComponentData::AddMenuItems
(
	LPDATAOBJECT                pDataObject, 
	LPCONTEXTMENUCALLBACK		pContextMenuCallback,
	long *						pInsertionAllowed
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT				hr = S_OK;
	SPINTERNAL			spInternal;
	DATA_OBJECT_TYPES   type;
	SPITFSNode			spNode;
	SPITFSNodeHandler	spNodeHandler;
	DWORD				dwType;

	COM_PROTECT_TRY
	{

		CORg( ExtractNodeFromDataObject(m_spNodeMgr,
										m_spCallback->GetCoClassID(),
										pDataObject,
										FALSE, &spNode, &dwType,
										&spInternal) );

		type = (spInternal ? spInternal->m_type : CCT_SCOPE);

		// Note - snap-ins need to look at the data object and determine
		// in what context, menu items need to be added. They must also
		// observe the insertion allowed flags to see what items can be 
		// added.
		
		CORg( spNode->GetHandler(&spNodeHandler) );

		hr = spNodeHandler->OnAddMenuItems(spNode, pContextMenuCallback, 
										   pDataObject,
										   type, 
										   dwType,
										   pInsertionAllowed);

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
			
	return hr;
}

/*!--------------------------------------------------------------------------
	TFSComponentData::Command
		Implemenation of IExtendContextMenu::Command
		Command handler for any items added to a context menu
	Author: 
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
TFSComponentData::Command
(
	long            nCommandID, 
	LPDATAOBJECT    pDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = S_OK;
	SPINTERNAL	spInternal;
	
	DATA_OBJECT_TYPES   type;
	SPITFSNode			spNode;
	SPITFSNodeHandler	spNodeHandler;
	DWORD				dwType;

	COM_PROTECT_TRY
	{

		CORg( ExtractNodeFromDataObject(m_spNodeMgr,
										m_spCallback->GetCoClassID(),
										pDataObject,
										FALSE, &spNode, &dwType,
										&spInternal) );

		type = (spInternal ? spInternal->m_type : CCT_SCOPE);

		CORg( spNode->GetHandler(&spNodeHandler) );

		hr = spNodeHandler->OnCommand(spNode, nCommandID, 
									  type, 
									  pDataObject,
									  dwType);
		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
		
	return hr;
}

/*---------------------------------------------------------------------------
	ISnapinHelp implementation
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	TFSComponentData::GetHelpTopic
		Implementation of ISnapinHelp::GetHelpTopic
		MMC calls this so that a snapin can add it's .chm file to the main index
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
TFSComponentData::GetHelpTopic
(
    LPOLESTR* lpCompiledHelpFile
)
{
    HRESULT hr = S_OK;

    if (lpCompiledHelpFile == NULL)
        return E_INVALIDARG;
    
    LPCWSTR lpszHelpFileName = GetHTMLHelpFileName();
    if (lpszHelpFileName == NULL)
    {
        *lpCompiledHelpFile = NULL;
        return E_NOTIMPL;
    }

	CString szHelpFilePath;
	UINT nLen = ::GetWindowsDirectory (szHelpFilePath.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
	if (nLen == 0)
		return E_FAIL;

	szHelpFilePath.ReleaseBuffer();
	szHelpFilePath += L"\\help\\";
	szHelpFilePath += lpszHelpFileName;

    UINT nBytes = (szHelpFilePath.GetLength() + 1) * sizeof(WCHAR);
    *lpCompiledHelpFile = (LPOLESTR)::CoTaskMemAlloc(nBytes);
    if (*lpCompiledHelpFile)
    {
        memcpy(*lpCompiledHelpFile, (LPCWSTR)szHelpFilePath, nBytes);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}



STDMETHODIMP TFSComponentData::GetNodeMgr(ITFSNodeMgr **ppNodeMgr)
{
	Assert(ppNodeMgr);
	SetI((LPUNKNOWN *) ppNodeMgr, m_spNodeMgr);
	return hrOK;
}

STDMETHODIMP TFSComponentData::GetConsole(IConsole2 **ppConsole)
{
	Assert(ppConsole);
	SetI((LPUNKNOWN *) ppConsole, m_spConsole);
	return hrOK;
}

STDMETHODIMP TFSComponentData::GetConsoleNameSpace(IConsoleNameSpace2 **ppConsoleNS)
{
	Assert(ppConsoleNS);
	SetI((LPUNKNOWN *) ppConsoleNS, m_spConsoleNameSpace);
	return hrOK;
}

STDMETHODIMP TFSComponentData::GetRootNode(ITFSNode **ppNode)
{
	return m_spNodeMgr->GetRootNode(ppNode);
}

STDMETHODIMP_(const CLSID *) TFSComponentData::GetCoClassID()
{
	Assert(m_spCallback);
	return m_spCallback->GetCoClassID();
}

STDMETHODIMP_(HWND) TFSComponentData::GetHiddenWnd()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	if (!m_hiddenWnd.GetSafeHwnd())
	{
		m_hiddenWnd.Create();
		m_hWnd = m_hiddenWnd.GetSafeHwnd();
	}
	Assert(m_hWnd);
	return m_hWnd;
}

STDMETHODIMP_(LPWATERMARKINFO) TFSComponentData::SetWatermarkInfo(LPWATERMARKINFO pNewWatermarkInfo)
{
    LPWATERMARKINFO pOldWatermarkInfo = m_pWatermarkInfo;

    m_pWatermarkInfo = pNewWatermarkInfo;
    
    return pOldWatermarkInfo;
}

STDMETHODIMP TFSComponentData::GetClassID(LPCLSID lpClassID)
{
	Assert(m_spCallback);
	return m_spCallback->GetClassID(lpClassID);
}
STDMETHODIMP TFSComponentData::IsDirty()
{
	Assert(m_spCallback);
	return m_spCallback->IsDirty();
}
STDMETHODIMP TFSComponentData::Load(LPSTREAM pStm)
{
	Assert(m_spCallback);
	return m_spCallback->Load(pStm);
}
STDMETHODIMP TFSComponentData::Save(LPSTREAM pStm, BOOL fClearDirty)
{
	Assert(m_spCallback);
	return m_spCallback->Save(pStm, fClearDirty);
}
STDMETHODIMP TFSComponentData::GetSizeMax(ULARGE_INTEGER FAR *pcbSize)
{
	Assert(m_spCallback);
	return m_spCallback->GetSizeMax(pcbSize);
}
STDMETHODIMP TFSComponentData::InitNew()
{
	Assert(m_spCallback);
	return m_spCallback->InitNew();
}

STDMETHODIMP
TFSComponentData::SetTaskpadState(int nIndex, BOOL fEnable)
{
    DWORD dwMask = 0x00000001 << nIndex;

    if (!m_fTaskpadInitialized)
    {
        // this will initialize the states to the deafult value
        GetTaskpadState(0);
    }

    if (fEnable)
        m_dwTaskpadStates |= dwMask;
    else
        m_dwTaskpadStates &= ~dwMask;
            
    return hrOK;
}

// taskpad states are kept track of on a pernode basis.
// we can store up to 32 (DWORD) different node states here
// if you don't want taskpads on a per node basis, always
// pass an index of 0
STDMETHODIMP_(BOOL)
TFSComponentData::GetTaskpadState(int nIndex)
{
    DWORD dwMask = 0x00000001 << nIndex;

    if (!m_fTaskpadInitialized)
    {
        // assume taskpads on
		BOOL fDefault = TRUE;

        m_fTaskpadInitialized = TRUE;

        // get the default state from MMC
		if (m_spConsole)
			fDefault = (m_spConsole->IsTaskpadViewPreferred() == S_OK) ? TRUE : FALSE;

        if (fDefault)
        {
            // now check our private override
            fDefault = FUseTaskpadsByDefault(NULL);
        }

        if (fDefault)
            m_dwTaskpadStates = 0xFFFFFFFF;
        else
            m_dwTaskpadStates = 0;

    }

    return m_dwTaskpadStates & dwMask;
}

STDMETHODIMP_(LPCTSTR)
TFSComponentData::GetHTMLHelpFileName()
{
    if (m_strHTMLHelpFileName.IsEmpty())
        return NULL;
    else
        return (LPCTSTR) m_strHTMLHelpFileName;
}

STDMETHODIMP
TFSComponentData::SetHTMLHelpFileName(LPCTSTR pszHelpFileName)
{
    m_strHTMLHelpFileName = pszHelpFileName;
    return S_OK;
}


TFSCORE_API(HRESULT) CreateTFSComponentData(IComponentData **ppCompData,
											ITFSCompDataCallback *pCallback)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	TFSComponentData *	pCompData = NULL;
	HRESULT				hr = hrOK;

	COM_PROTECT_TRY
	{
		*ppCompData = NULL;
		
		pCompData = new TFSComponentData;
	
		CORg( pCompData->Construct(pCallback) );

		*ppCompData = static_cast<IComponentData *>(pCompData);
		(*ppCompData)->AddRef();

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;

	// Note: to balance the AddRef()/Release() we Release() this pointer
	// even in the success case
	
	if (pCompData)
		pCompData->Release();
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\compont.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    compont.h
        base classes for IComponent and IComponentData

    FILE HISTORY:
        
*/

#ifndef _COMPONT_H
#define _COMPONT_H

#if _MSC_VER >= 1000	// VC 5.0 or later
#pragma once
#endif

#ifndef __mmc_h__
#include <mmc.h>
#endif

#ifndef _TFSINT_H
#include "tfsint.h"
#endif

class TFSComponentData;

#define IMPL

class TFS_EXPORT_CLASS TFSComponent :
    public ITFSComponent,
    public IComponent,
    public IExtendPropertySheet2,
    public IExtendContextMenu,
    public IExtendControlbar,
    public IResultDataCompare,
    public IResultDataCompareEx,
    public IResultOwnerData,
    public IExtendTaskPad
{
public:
	TFSComponent();
	virtual ~TFSComponent();

	void Construct(ITFSNodeMgr *pNodeMgr,
				   IComponentData *pCompData,
				   ITFSComponentData *pTFSCompData);

// INTERFACES
public:
	DeclareIUnknownMembers(IMPL)
	DeclareIComponentMembers(IMPL)
	DeclareIExtendPropertySheetMembers(IMPL)
	DeclareIExtendContextMenuMembers(IMPL)
	DeclareIExtendControlbarMembers(IMPL)
	DeclareIResultDataCompareMembers(IMPL)
        DeclareIResultDataCompareExMembers( IMPL )
	DeclareIResultOwnerDataMembers(IMPL)
	DeclareITFSComponentMembers(IMPL)
    DeclareIExtendTaskPadMembers(IMPL)

public:
	// These functions are to be implemented by the derived class
	//DeclareITFSCompCallbackMembers(PURE)
	STDMETHOD(InitializeBitmaps)(MMC_COOKIE cookie) = 0;
	STDMETHOD(OnUpdateView)(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param);
	STDMETHOD(OnDeselectAll)(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param);
	STDMETHOD(OnColumnClick)(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param);
	STDMETHOD(OnSnapinHelp)(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param);

protected:
    virtual HRESULT OnNotifyPropertyChange(LPDATAOBJECT lpDataObject,
                                           MMC_NOTIFY_TYPE event,
									       LPARAM arg, 
                                           LPARAM lParam)
    {
        return E_NOTIMPL;
    }

protected:
	SPITFSNodeMgr		m_spNodeMgr;
	SPITFSNode			m_spSelectedNode;
    SPIConsole			m_spConsole;	// Console's IConsole interface

	SPIHeaderCtrl		m_spHeaderCtrl;	// Result pane's hdr control
	SPIResultData		m_spResultData;	// if ptr to the result pane
	SPIImageList		m_spImageList;
	SPIConsoleVerb		m_spConsoleVerb;
	SPIControlBar		m_spControlbar;
	SPIToolbar		    m_spToolbar;
    SPIDataObject       m_spCurrentDataObject;

	//$ Review (kennt) : should we be doing this?  Should we have
	// our components hold onto each other?  What if this gets done
	// at a higher level?
	SPITFSComponentData m_spTFSComponentData;
	SPIComponentData	m_spComponentData;
	LONG_PTR			m_ulUserData;
	
	long	m_cRef;
};


 
#endif _COMPONT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\compdata.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    compdata.h
        base classes for IComponent and IComponentData

    FILE HISTORY:
        
*/

#ifndef _COMPDATA_H
#define _COMPDATA_H

#if _MSC_VER >= 1000	// VC 5.0 or later
#pragma once
#endif

#ifndef __mmc_h__
#include <mmc.h>
#endif

#ifndef _TFSINT_H
#include "tfsint.h"
#endif

#ifndef _UTIL_H
#include "util.h"
#endif


#define EXTENSION_TYPE_NAMESPACE		( 0x00000001 )
#define EXTENSION_TYPE_CONTEXTMENU		( 0x00000002 )
#define EXTENSION_TYPE_TOOLBAR			( 0x00000004 )
#define EXTENSION_TYPE_PROPERTYSHEET	( 0x00000008 )
#define EXTENSION_TYPE_TASK         	( 0x00000010 )


						

/////////////////////////////////////////////////////////////////////////////
// TFSComponentData

#define IMPL

class TFSComponentData :
		public ITFSComponentData,
		public IComponentData,
		public IExtendPropertySheet2,
		public IExtendContextMenu,
		public IPersistStreamInit,
        public ISnapinHelp
{
	// INTERFACES
public:
	DeclareIUnknownMembers(IMPL)
	DeclareIExtendContextMenuMembers(IMPL)
	DeclareIExtendPropertySheetMembers(IMPL)
	DeclareIComponentDataMembers(IMPL)
	DeclareITFSComponentDataMembers(IMPL)
	DeclareIPersistStreamInitMembers(IMPL)
	DeclareISnapinHelpMembers(IMPL)

public:
	TFSComponentData();
	~TFSComponentData();

	HRESULT Construct(ITFSCompDataCallback *pCallback);

public:
	// Accessors
	ITFSNodeMgr *	QueryNodeMgr();		   // no AddRef
	ITFSNodeMgr *	GetNodeMgr();		   // AddRef

protected:
	SPIConsoleNameSpace		m_spConsoleNameSpace;
	SPIConsole				m_spConsole;
	SPITFSNodeMgr			m_spNodeMgr;
	SPITFSCompDataCallback  m_spCallback;

// Hidden window
private:
	CHiddenWnd	m_hiddenWnd;	//	syncronization with background threads
	HWND		m_hWnd;			// thread safe HWND (gotten from the MFC CWnd)

	BOOL		m_bFirstTimeRun;
	long		m_cRef;

    LPWATERMARKINFO     m_pWatermarkInfo;   // for wizard 97 style wizards

    // taskpad stuff
    BOOL    m_fTaskpadInitialized;
    DWORD   m_dwTaskpadStates;

    // help stuff
    CString m_strHTMLHelpFileName;
};




inline ITFSNodeMgr * TFSComponentData::QueryNodeMgr()
{
	return m_spNodeMgr;
}

inline ITFSNodeMgr * TFSComponentData::GetNodeMgr()
{
	m_spNodeMgr->AddRef();
	return m_spNodeMgr;
}

#endif _COMPDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\compont.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    compont.cpp
	base classes for IComponent

    FILE HISTORY:
	
*/

#include "stdafx.h"
#include "compont.h"
#include "compdata.h"
#include "extract.h"
#include "proppage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_ADDREF_RELEASE(TFSComponent)

STDMETHODIMP TFSComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
        *ppv = (LPVOID) this;
	else if (riid == IID_IComponent)
		*ppv = (IComponent *) this;
	else if (riid == IID_IExtendPropertySheet)
		*ppv = (IExtendPropertySheet *) this;
	else if (riid == IID_IExtendPropertySheet2)
		*ppv = (IExtendPropertySheet2 *) this;
	else if (riid == IID_IExtendContextMenu)
		*ppv = (IExtendContextMenu *) this;
	else if (riid == IID_IExtendControlbar)
		*ppv = (IExtendControlbar *) this;
	else if (riid == IID_IResultDataCompare)
		*ppv = (IResultDataCompare *) this;
        else if ( riid == IID_IResultDataCompareEx)
                *ppv = ( IResultDataCompareEx * ) this;
	else if (riid == IID_IResultOwnerData)
		*ppv = (IResultOwnerData *) this;
	else if (riid == IID_IExtendTaskPad)
		*ppv = (IExtendTaskPad *) this;
	else if (riid == IID_ITFSComponent)
		*ppv = (ITFSComponent *) this;

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
    {
        ((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
    }
    else
		return E_NOINTERFACE;
}



/*---------------------------------------------------------------------------
	TFSComponent's IComponent implementation
 ---------------------------------------------------------------------------*/


/*!--------------------------------------------------------------------------
	TFSComponent::Initialize
		Implementation of IComponent::Initialize
		MMC calls this to initalize the IComponent interface
	Author: 
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
TFSComponent::Initialize
(
	LPCONSOLE lpConsole
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Assert(lpConsole != NULL);

	HRESULT		hr = hrOK;

	COM_PROTECT_TRY
	{
		// Save the IConsole pointer
		//m_spConsole.Set(lpConsole);
		hr = lpConsole->QueryInterface(IID_IConsole2,
								   reinterpret_cast<void**>(&m_spConsole));
        Assert(hr == S_OK);

		// QI for a IHeaderCtrl
		m_spConsole->QueryInterface(IID_IHeaderCtrl, 
			reinterpret_cast<void**>(&m_spHeaderCtrl));

		// Give the console the header control interface pointer
		if (SUCCEEDED(hr))
			m_spConsole->SetHeader(m_spHeaderCtrl);

		m_spConsole->QueryInterface(IID_IResultData, 
									reinterpret_cast<void**>(&m_spResultData));

		hr = m_spConsole->QueryResultImageList(&m_spImageList);
		Assert(hr == S_OK);

		hr = m_spConsole->QueryConsoleVerb(&m_spConsoleVerb);
		Assert(hr == S_OK);
		
	}
	COM_PROTECT_CATCH

    return S_OK;
}

/*!--------------------------------------------------------------------------
	TFSComponent::Notify
		Implementation of IComponent::Notify
		All event notification for the IComponent interface happens here
	Author: 
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
TFSComponent::Notify
(
	LPDATAOBJECT		lpDataObject, 
	MMC_NOTIFY_TYPE		event, 
	LPARAM                arg, 
	LPARAM                param
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = S_OK;
    LONG_PTR			cookie;
	SPITFSNode			spNode;
	SPITFSResultHandler	spResultHandler;
    SPIDataObject       spDataObject;

	COM_PROTECT_TRY
	{
	    // Handle MMC special dataobjects.
	    // lDataObject == NULL is what we get for property change
	    // notifications, so we have to let those pass through
	    if (lpDataObject && IS_SPECIAL_DATAOBJECT(lpDataObject))
        {
            // get a data object for the selected node.
            GetSelectedNode(&spNode);

            if (!spNode)
            {
                CORg(E_FAIL);
            }

//kmurthy: for bug 477315: following did not seem to work
//            CORg(QueryDataObject((MMC_COOKIE) spNode->GetData(TFS_DATA_COOKIE), CCT_RESULT, &spDataObject));
// so changed to this.
	     CORg(m_spComponentData->QueryDataObject((MMC_COOKIE) spNode->GetData(TFS_DATA_COOKIE), CCT_RESULT, &spDataObject));
            spNode.Release();                

            lpDataObject = spDataObject;
        }

		if (event == MMCN_PROPERTY_CHANGE)
		{
			Trace0("CComponent::Notify got MMCN_PROPERTY_CHANGE\n");

            hr = OnNotifyPropertyChange(lpDataObject, event, arg, param);
            if (hr != E_NOTIMPL)
            {
                return hr;
            }

            CPropertyPageHolderBase * pHolder = 
							reinterpret_cast<CPropertyPageHolderBase *>(param);

			spNode = pHolder->GetNode();
			cookie = spNode->GetData(TFS_DATA_COOKIE);

			CORg( spNode->GetResultHandler(&spResultHandler) );
			if (spResultHandler)
				CORg( spResultHandler->Notify(this, cookie, lpDataObject, event, arg, param) );
		}
		else if (event == MMCN_VIEW_CHANGE)
		{
			hr = OnUpdateView(lpDataObject, arg, param);
		}
        else if (event == MMCN_DESELECT_ALL)
        {
            hr = OnDeselectAll(lpDataObject, arg, param);
        }
        else if (event == MMCN_ADD_IMAGES)
		{
   			SPINTERNAL		    spInternal;

            spInternal = ::ExtractInternalFormat(lpDataObject);
            if (spInternal && 
                spInternal->m_cookie == MMC_MULTI_SELECT_COOKIE)
            {
                GetSelectedNode(&spNode);
            }
            else
            {
                spInternal.Free();

                CORg(ExtractNodeFromDataObject(m_spNodeMgr,
									           m_spTFSComponentData->GetCoClassID(),
									           lpDataObject, 
                                               FALSE,
									           &spNode, 
                                               NULL, 
                                               &spInternal));
            }

			hr = InitializeBitmaps(spNode->GetData(TFS_DATA_COOKIE));
		}
        else if (event == MMCN_COLUMN_CLICK)
        {
            hr = OnColumnClick(lpDataObject, arg, param);
        }
		else if (event == MMCN_SNAPINHELP)
		{
			hr = OnSnapinHelp(lpDataObject, arg, param);
		}
		else
		{
			DATA_OBJECT_TYPES   type = CCT_RESULT;
			SPINTERNAL		    spInternal;

            spInternal = ::ExtractInternalFormat(lpDataObject);
            
            if (spInternal && 
                spInternal->m_cookie == MMC_MULTI_SELECT_COOKIE)
            {
                GetSelectedNode(&spNode);
            }
            else
            {
                spInternal.Free();

                CORg(ExtractNodeFromDataObject(m_spNodeMgr,
									           m_spTFSComponentData->GetCoClassID(),
									           lpDataObject, 
                                               FALSE,
									           &spNode, 
                                               NULL, 
                                               &spInternal));
            }

			//$ Review (kennt) : if pInternal is NULL, what does this
			// mean for the result pane items?
			if (spInternal)
				type = spInternal->m_type;

            cookie = spNode->GetData(TFS_DATA_COOKIE);
			
			CORg( spNode->GetResultHandler(&spResultHandler) );
			if (spResultHandler)
				CORg( spResultHandler->Notify(this, cookie, lpDataObject, event, arg, param) );
		}
		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH
			
    return hr;
}


/*!--------------------------------------------------------------------------
	TFSComponent::Destroy
		Implementation of IComponent::Destroy
	Author: 
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
TFSComponent::Destroy
(
	MMC_COOKIE cookie
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		//$ Review (kennt):
		// Does this mean destroy the particular instance of that
		// cookie or the entire thing?
		
		// Release the interfaces that we QI'ed
		if (m_spConsole)
			m_spConsole->SetHeader(NULL);
		m_spHeaderCtrl.Release();
		m_spResultData.Release();
		m_spImageList.Release();
		m_spConsoleVerb.Release();
		m_spConsole.Release();
		m_spControlbar.Release();
		m_spToolbar.Release();
    }
	COM_PROTECT_CATCH

    return S_OK;
}

/*!--------------------------------------------------------------------------
	TFSComponent::GetResultViewType
		Implementation of IComponent::GetResultViewType
		This determines what kind result view we use.  Use the default.
	Author: 
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
TFSComponent::GetResultViewType
(
	MMC_COOKIE            cookie,  
	LPOLESTR *      ppViewType,
	long *			pViewOptions
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SPITFSNode		    spNode;
	SPITFSResultHandler	spResultHandler;
	HRESULT			    hr = hrOK;

	COM_PROTECT_TRY
	{
        CORg (m_spNodeMgr->FindNode(cookie, &spNode));
		
        if (spNode == NULL)
    	    goto Error;	// no selection for out IComponentData

		CORg( spNode->GetResultHandler(&spResultHandler) );

		if (spResultHandler)
		{
			CORg( spResultHandler->OnGetResultViewType(this, spNode->GetData(TFS_DATA_COOKIE), ppViewType, pViewOptions) );
		}
		else
			hr = S_FALSE;

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH
			
    return hr;
}


/*!--------------------------------------------------------------------------
	TFSComponent::QueryDataObject
		Implementation of IComponent::QueryDataObject
	Author: 
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
TFSComponent::QueryDataObject
(
	MMC_COOKIE                    cookie, 
	DATA_OBJECT_TYPES       type,
    LPDATAOBJECT*           ppDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Delegate it to the IComponentData
    Assert(m_spComponentData != NULL);
    return m_spComponentData->QueryDataObject(cookie, type, ppDataObject);
}


/*!--------------------------------------------------------------------------
	TFSComponent::CompareObjects
		Implementation of IComponent::CompareObjects
		MMC calls this to compare two objects
	Author: 
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
TFSComponent::CompareObjects
(
	LPDATAOBJECT lpDataObjectA, 
	LPDATAOBJECT lpDataObjectB
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
		return E_POINTER;

    // Make sure both data object are mine
    SPINTERNAL spA;
    SPINTERNAL spB;
    HRESULT hr = S_FALSE;

	COM_PROTECT_TRY
	{
		spA = ExtractInternalFormat(lpDataObjectA);
		spB = ExtractInternalFormat(lpDataObjectB);

		if (spA != NULL && spB != NULL)
			hr = (spA->m_cookie == spB->m_cookie) ? S_OK : S_FALSE;
	}
	COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
	TFSComponent::GetDisplayInfo
		Implementation of IComponent::GetDisplayInfo
	Author: 
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
TFSComponent::GetDisplayInfo
(
	LPRESULTDATAITEM pResult
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SPITFSNode	spNode;
	SPITFSResultHandler	spResultHandler;
	HRESULT		hr = hrOK;
    LPOLESTR    pViewType;
    long        lViewOptions = 0;

    Assert(pResult != NULL);

	COM_PROTECT_TRY
	{ 
		if (pResult)
		{
			MMC_COOKIE cookie = pResult->lParam;
			
			if (pResult->bScopeItem == TRUE)
			{
				m_spNodeMgr->FindNode(cookie, &spNode);
				
				if (pResult->mask & RDI_STR)
				{
					pResult->str = const_cast<LPWSTR>(spNode->GetString(pResult->nCol));
				}
				
				if (pResult->mask & RDI_IMAGE)
				{
					pResult->nImage = (UINT)spNode->GetData(TFS_DATA_IMAGEINDEX);
				}
			}
			else 
			{
                if (pResult->itemID == 0 &&
                    pResult->lParam == 0)
                {
                    // virtual listbox call.  The selected node should own
                    // this so call into it's result handler.
					CORg(GetSelectedNode(&spNode));
					CORg(spNode->GetResultHandler(&spResultHandler));
					
				    if (pResult->mask & RDI_STR)
				    {
    					pResult->str = const_cast<LPWSTR>(spResultHandler->GetVirtualString(pResult->nIndex, pResult->nCol));
                    }

				    if (pResult->mask & RDI_IMAGE)
				    {
                        pResult->nImage = spResultHandler->GetVirtualImage(pResult->nIndex);
                    }
                }   
                else

                // If it's not a scope item, we have to assume that the
				// lParam is the cookie, the reasoning behind making this a
				// cookie instead is that we can't assume that we have a node
				// behind every result pane item.
				
				if (pResult->mask & RDI_STR)
				{
                    // more $!#@!$#@ special code to support the virtual listbox
                    if (pResult->mask & RDI_PARAM)
                    {
					    CORg(GetSelectedNode(&spNode));
					    CORg(spNode->GetResultHandler(&spResultHandler));

                        CORg(spResultHandler->OnGetResultViewType(this, cookie, &pViewType, &lViewOptions));
    					
                        if (lViewOptions & MMC_VIEW_OPTIONS_OWNERDATALIST)
                            pResult->str = const_cast<LPWSTR>(spResultHandler->GetVirtualString((int)pResult->lParam, pResult->nCol));
                        else
                        {
    					    spResultHandler.Set(NULL);
                            spNode.Set(NULL);
                            CORg(m_spNodeMgr->FindNode(cookie, &spNode));
                            CORg(spNode->GetResultHandler(&spResultHandler));

        				    pResult->str = const_cast<LPWSTR>(spResultHandler->GetString(this, cookie, pResult->nCol));
                        }
                    }
                    else
                    {
					    CORg(m_spNodeMgr->FindNode(cookie, &spNode));
					    CORg(spNode->GetResultHandler(&spResultHandler));
					    
					    pResult->str = const_cast<LPWSTR>(spResultHandler->GetString(this, cookie, pResult->nCol));
					    
					    //ASSERT(pResult->str != NULL);
                    }
				}
			}
		}
		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH
		
	return hr;
}


/*!--------------------------------------------------------------------------
	TFSComponent::OnUpdateView
		-
	Author: 
 ---------------------------------------------------------------------------*/
HRESULT 
TFSComponent::OnUpdateView
(
	LPDATAOBJECT lpDataObject,
	LPARAM             data,	// arg
	LPARAM             hint	// param
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SPITFSNode		spNode;
	SPITFSResultHandler	spResultHandler;
	HRESULT			hr = hrOK;

	COM_PROTECT_TRY
	{
		GetSelectedNode(&spNode);
		if (spNode == NULL)
        {
            ITFSNode * pNode = NULL;

            // no selected node, check and see if there is something in the
            // data object we can use.
            if (lpDataObject)
            {
                SPINTERNAL spInternal = ExtractInternalFormat(lpDataObject);
                if (spInternal)
                {
                    pNode = reinterpret_cast<ITFSNode *>(spInternal->m_cookie);
                }
            }

            if (pNode)
            {
                spNode.Set(pNode);
            }
            else
            {
    	        goto Error;	// no selection for our IComponentData
            }
        }

		CORg( spNode->GetResultHandler(&spResultHandler) );

		CORg( spResultHandler->UpdateView(this, lpDataObject, data, hint) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH
			
    return hr;
}

/*!--------------------------------------------------------------------------
	TFSComponent::OnDeselectAll
		Handler for the MMCN_DESELECT_ALL notify message
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
TFSComponent::OnDeselectAll
(
	LPDATAOBJECT lpDataObject,
	LPARAM             data,	// arg
	LPARAM             hint	// param
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = hrOK;

    COM_PROTECT_TRY
	{
	}
	COM_PROTECT_CATCH
			
    return hr;
}

/*!--------------------------------------------------------------------------
	TFSComponent::OnColumnClick
		-
	Author: 
 ---------------------------------------------------------------------------*/
HRESULT 
TFSComponent::OnColumnClick
(
	LPDATAOBJECT     lpDataObject,
	LPARAM             arg,	        // arg
	LPARAM             param	        // param
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SPITFSNode		spNode;
	SPITFSResultHandler	spResultHandler;
	HRESULT			hr = hrOK;

	COM_PROTECT_TRY
	{
		GetSelectedNode(&spNode);
		if (spNode == NULL)
    	    goto Error;	// no selection for out IComponentData

		CORg( spNode->GetResultHandler(&spResultHandler) );

		CORg( spResultHandler->Notify(this, 
                                      spNode->GetData(TFS_DATA_COOKIE), 
                                      lpDataObject, 
                                      MMCN_COLUMN_CLICK, 
                                      arg, 
                                      param) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH
			
    return hr;
}

/*!--------------------------------------------------------------------------
	TFSComponent::OnSnapinHelp
		MMC calls us with this when the user select About <snapin>
		from MMC's main window Help menu.
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
TFSComponent::OnSnapinHelp
(
	LPDATAOBJECT     lpDataObject,
	LPARAM             arg,	        // arg
	LPARAM             param	        // param
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = hrOK;

	COM_PROTECT_TRY
	{
	}
	COM_PROTECT_CATCH
			
    return hr;
}

/*---------------------------------------------------------------------------
	IExtendControlbar implementation
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	TFSComponent::SetControlbar
		MMC hands us the interface to the control bars here
	Author: 
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
TFSComponent::SetControlbar
(
	LPCONTROLBAR pControlbar
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	SPITFSNode	spNode;
	SPITFSResultHandler	spResultHandler;
	HRESULT hr=hrOK;

	COM_PROTECT_TRY
	{		
		if (pControlbar != NULL)
		{
			// Hold on to the controlbar interface.
			m_spControlbar.Set(pControlbar);
			
			hr = S_FALSE;
			
			//
			// Tell the derived class to put up it's toolbars
			//
			
			// Get the result handler for the root node
			m_spNodeMgr->GetRootNode(&spNode);
			spNode->GetResultHandler(&spResultHandler);
			
			spResultHandler->OnCreateControlbars(this, pControlbar);
		}
		else
		{
			m_spControlbar.Release();
		}

	}
	COM_PROTECT_CATCH
			
	return hr;
}

/*!--------------------------------------------------------------------------
	TFSComponent::ControlbarNotify
		Implementation of IExtendControlbar::ControlbarNotify
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSComponent::ControlbarNotify(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SPITFSNode	spNode;
	SPITFSResultHandler	spResultHandler;
	HRESULT		hr = hrOK;

	COM_PROTECT_TRY
	{	
		CORg( m_spNodeMgr->GetRootNode(&spNode) );
		CORg( spNode->GetResultHandler(&spResultHandler) );

		CORg( spResultHandler->ControlbarNotify(this, event, arg, param) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH
	
	return hr;
}

/*---------------------------------------------------------------------------
	TFSComponent's implementation specific members
 ---------------------------------------------------------------------------*/

DEBUG_DECLARE_INSTANCE_COUNTER(TFSComponent);

/*!--------------------------------------------------------------------------
	TFSComponent::TFSComponent()
		-
	Author: 
 ---------------------------------------------------------------------------*/
TFSComponent::TFSComponent()
	: m_cRef(1)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(TFSComponent);
}

void TFSComponent::Construct(ITFSNodeMgr *pNodeMgr,
							 IComponentData *pComponentData,
							 ITFSComponentData *pTFSCompData)
{
	HRESULT	hr;

	COM_PROTECT_TRY
	{
		m_spNodeMgr.Set(pNodeMgr);
		m_spTFSComponentData.Set(pTFSCompData);
		m_spComponentData.Set(pComponentData);
	
		m_spConsole = NULL;
		m_spHeaderCtrl = NULL;
		
		m_spResultData = NULL;
		m_spImageList = NULL;
		m_spControlbar = NULL;
		
		m_spConsoleVerb = NULL;
	}
	COM_PROTECT_CATCH
}

/*!--------------------------------------------------------------------------
	TFSComponent::~TFSComponent()
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
TFSComponent::~TFSComponent()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(TFSComponent);

	m_spControlbar.Release();

    // Make sure the interfaces have been released
    Assert(m_spConsole == NULL);
    Assert(m_spHeaderCtrl == NULL);

    Construct(NULL, NULL, NULL);
}

/*---------------------------------------------------------------------------
	IResultDataCompare Implementation
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	TFSComponent::Compare
		MMC calls this to compare to nodes in the result pane
	Author: 
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
TFSComponent::Compare
(
	LPARAM lUserParam, 
	MMC_COOKIE cookieA, 
	MMC_COOKIE cookieB, 
	int* pnResult
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	int nCol = *pnResult;
	HRESULT	hr = hrOK;

	SPITFSNode	spNode1, spNode2;

	COM_PROTECT_TRY
	{

		m_spNodeMgr->FindNode(cookieA, &spNode1);
		m_spNodeMgr->FindNode(cookieB, &spNode2);

		SPITFSResultHandler	spResultHandler;

		// If the nodes are different then each result item
		// has it's own node/handler.  Call the parent node's
		// result handler to compare these two items
		if (spNode1 != spNode2)
		{
			SPITFSNode	spParentNode1, spParentNode2;
			
			spNode1->GetParent(&spParentNode1);
			spNode2->GetParent(&spParentNode2);
			
			Assert(spParentNode1 == spParentNode2);
			spParentNode1->GetResultHandler(&spResultHandler);
		}
		else
		{
			// If the nodes are the same, then we are in the case
			// of a node holding multiple result items, have the
			// node compare the two
			spNode1->GetResultHandler(&spResultHandler);
		}
		
		*pnResult = spResultHandler->CompareItems(this, cookieA, cookieB, nCol);
	}
	COM_PROTECT_CATCH

	return hr;
}

STDMETHODIMP 
TFSComponent::Compare
(
     RDCOMPARE *prdc,
     int* pnResult
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT	hr = hrOK;
    MMC_COOKIE  cookieA, cookieB;

    SPITFSNode	spNode1, spNode2;

    COM_PROTECT_TRY
    {

        cookieA = prdc->prdch1->cookie;
        cookieB = prdc->prdch2->cookie;

        m_spNodeMgr->FindNode(cookieA, &spNode1);
        m_spNodeMgr->FindNode(cookieB, &spNode2);

        SPITFSResultHandler	spResultHandler;

        // If the nodes are different then each result item
        // has it's own node/handler.  Call the parent node's
        // result handler to compare these two items
        if (spNode1 != spNode2)
        {
            SPITFSNode	spParentNode1, spParentNode2;

            spNode1->GetParent(&spParentNode1);
            spNode2->GetParent(&spParentNode2);

            Assert(spParentNode1 == spParentNode2);
            spParentNode1->GetResultHandler(&spResultHandler);
        }
        else {
            // If the nodes are the same, then we are in the case
            // of a node holding multiple result items, have the
            // node compare the two
            spNode1->GetResultHandler(&spResultHandler);
        }

        *pnResult = spResultHandler->CompareItems( this,  prdc );
    }
    COM_PROTECT_CATCH

    return hrOK;
} // TFSComponent::Compare()

/*---------------------------------------------------------------------------
	IResultOwnerData Implementation
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	TFSComponent::FindItem
		The Virutal listbox calls this when it needs to find an item.  
        Forward the call to the selected node's result handler.
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
TFSComponent::FindItem
(
    LPRESULTFINDINFO    pFindInfo, 
    int *               pnFoundIndex
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT	hr = hrOK;

	SPITFSNode	spNode;

	COM_PROTECT_TRY
	{
    	SPITFSResultHandler	spResultHandler;

		CORg(GetSelectedNode(&spNode));
		CORg(spNode->GetResultHandler(&spResultHandler));

        hr = spResultHandler->FindItem(pFindInfo, pnFoundIndex);

		COM_PROTECT_ERROR_LABEL;
    }
	COM_PROTECT_CATCH

	return hr;
}

/*!--------------------------------------------------------------------------
	TFSComponent::CacheHint
		The virtual listbox calls this with hint information that we can
        pre-load.  The hint is not a guaruntee that the items will be used
        or that items outside this range will be used.
        Forward the call to the selected node's result handler.
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
TFSComponent::CacheHint
(
    int nStartIndex, 
    int nEndIndex
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT	hr = hrOK;

	SPITFSNode	spNode;

	COM_PROTECT_TRY
	{
    	SPITFSResultHandler	spResultHandler;

		CORg(GetSelectedNode(&spNode));

        if (spNode)
        {
            CORg(spNode->GetResultHandler(&spResultHandler));

            hr = spResultHandler->CacheHint(nStartIndex, nEndIndex);
        }

		COM_PROTECT_ERROR_LABEL;
    }
	COM_PROTECT_CATCH

	return hr;
}

/*!--------------------------------------------------------------------------
	TFSComponent::SortItems
		The Virutal listbox calls this when the data needs to be sorted
        Forward the call to the selected node's result handler.
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
TFSComponent::SortItems
(
    int     nColumn, 
    DWORD   dwSortOptions, 
    LPARAM    lUserParam
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT	hr = hrOK;

	SPITFSNode	spNode;

	COM_PROTECT_TRY
	{
    	SPITFSResultHandler	spResultHandler;

		CORg(GetSelectedNode(&spNode));
		CORg(spNode->GetResultHandler(&spResultHandler));

        hr = spResultHandler->SortItems(nColumn, dwSortOptions, lUserParam);

        COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH

	return hr;
}


/*---------------------------------------------------------------------------
	IExtendPropertySheet Implementation
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	TFSComponent::CreatePropertyPages
		Implementation of IExtendPropertySheet::CreatePropertyPages
		Called for a node to put up property pages
	Author: 
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
TFSComponent::CreatePropertyPages
(
	LPPROPERTYSHEETCALLBACK lpProvider, 
    LONG_PTR				handle, 
    LPDATAOBJECT            pDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SPITFSNode				spNode;
	SPITFSResultHandler		spResultHandler;
	HRESULT					hr = hrOK;
    SPINTERNAL              spInternal;

	COM_PROTECT_TRY
	{
        spInternal = ExtractInternalFormat(pDataObject);

	    // this was an object created by the modal wizard, do nothing
	    if (spInternal && spInternal->m_type == CCT_UNINITIALIZED)
	    {
		    return hr;
	    }

		CORg( ExtractNodeFromDataObject(m_spNodeMgr,
										m_spTFSComponentData->GetCoClassID(),
										pDataObject, FALSE,
										&spNode, NULL, NULL) );

        //
		// Create the property page for a particular node
		//
		CORg( spNode->GetResultHandler(&spResultHandler) );
		
		CORg( spResultHandler->CreatePropertyPages(this, 
												   spNode->GetData(TFS_DATA_COOKIE),
												   lpProvider,
												   pDataObject,
												   handle));
		
		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
			
	return hr;
}

/*!--------------------------------------------------------------------------
	TFSComponent::QueryPagesFor
		Implementation of IExtendPropertySheet::QueryPagesFor
		MMC calls this to see if a node has property pages
	Author: 
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
TFSComponent::QueryPagesFor
(
	LPDATAOBJECT pDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SPITFSNode			spNode;
	SPITFSResultHandler	spResultHandler;
	HRESULT				hr = hrOK;
    SPINTERNAL          spInternal;

	COM_PROTECT_TRY
	{
        spInternal = ExtractInternalFormat(pDataObject);

	    // this was an object created by the modal wizard, do nothing
	    if (spInternal && spInternal->m_type == CCT_UNINITIALIZED)
	    {
		    return hr;
	    }

		CORg( ExtractNodeFromDataObject(m_spNodeMgr,
										m_spTFSComponentData->GetCoClassID(),
										pDataObject, FALSE,
										&spNode, NULL, NULL) );
        
        CORg( spNode->GetResultHandler(&spResultHandler) );

		if (spResultHandler)
			CORg( spResultHandler->HasPropertyPages(this,
												    spNode->GetData(TFS_DATA_COOKIE),
												    pDataObject) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;

	return hr;
}

/*!--------------------------------------------------------------------------
	TFSComponent::GetWatermarks
		Implementation of IExtendPropertySheet::Watermarks
		MMC calls this for wizard 97 info
	Author: 
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
TFSComponent::GetWatermarks
(
    LPDATAOBJECT pDataObject,
    HBITMAP *   lphWatermark, 
    HBITMAP *   lphHeader,    
    HPALETTE *  lphPalette, 
    BOOL *      bStretch
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT				hr = hrOK;

	COM_PROTECT_TRY
	{
        // set some defaults
        lphWatermark = NULL;
        lphHeader = NULL;
        lphPalette = NULL;
        *bStretch = FALSE;

	}
	COM_PROTECT_CATCH;

	return hr;
}

/*---------------------------------------------------------------------------
	IExtendTaskPad Implementation
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	TFSComponent::TaskNotify
		IExtendTaskPad::TaskNotify implementation
	Author: 
 ---------------------------------------------------------------------------*/
STDMETHODIMP
TFSComponent::TaskNotify
(
    LPDATAOBJECT    pDataObject,
    VARIANT *       arg, 
    VARIANT *       param
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SPITFSNode				spNode;
	SPITFSResultHandler		spResultHandler;
	HRESULT					hr = hrOK;
    SPINTERNAL              spInternal;

	COM_PROTECT_TRY
	{
        spInternal = ExtractInternalFormat(pDataObject);

		CORg( ExtractNodeFromDataObject(m_spNodeMgr,
										m_spTFSComponentData->GetCoClassID(),
										pDataObject, FALSE,
										&spNode, NULL, NULL) );

        //
		// Forward the call so that the handler can do something 
		//
		CORg( spNode->GetResultHandler(&spResultHandler) );
		
		CORg( spResultHandler->TaskPadNotify(this, 
										     spNode->GetData(TFS_DATA_COOKIE),
										     pDataObject,
                                             arg,
										     param));
		
		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
			
	return hr;
}

/*!--------------------------------------------------------------------------
	TFSComponent::EnumTasks
		IExtendTaskPad::EnumTasks implementation
	Author: 
 ---------------------------------------------------------------------------*/
STDMETHODIMP
TFSComponent::EnumTasks
(
    LPDATAOBJECT    pDataObject, 
    LPOLESTR        pszTaskGroup, 
    IEnumTASK **    ppEnumTask
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SPITFSNode				spNode;
	SPITFSResultHandler		spResultHandler;
	HRESULT					hr = hrOK;
    SPINTERNAL              spInternal;

	COM_PROTECT_TRY
	{
        spInternal = ExtractInternalFormat(pDataObject);

		CORg( ExtractNodeFromDataObject(m_spNodeMgr,
										m_spTFSComponentData->GetCoClassID(),
										pDataObject, FALSE,
										&spNode, NULL, NULL) );

        //
		// Forward the call so that the handler can do something 
		//
		CORg( spNode->GetResultHandler(&spResultHandler) );
		
		CORg( spResultHandler->EnumTasks(this, 
										 spNode->GetData(TFS_DATA_COOKIE),
										 pDataObject,
                                         pszTaskGroup,
										 ppEnumTask));
		
		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
			
	return hr;
}

/*!--------------------------------------------------------------------------
	TFSComponent::GetTitle
		IExtendTaskPad::GetTitle implementation
	Author: 
 ---------------------------------------------------------------------------*/
STDMETHODIMP
TFSComponent::GetTitle
(
    LPOLESTR    szGroup, 
    LPOLESTR *  ppszBitmapResource
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SPITFSNode				spNode;
	SPITFSResultHandler		spResultHandler;
	HRESULT					hr = hrOK;

	COM_PROTECT_TRY
	{
		GetSelectedNode(&spNode);
		if (spNode == NULL)
    	    goto Error;	// no selection for out IComponentData

        //
		// Forward the call so that the handler can do something 
		//
		CORg( spNode->GetResultHandler(&spResultHandler) );
		
		CORg( spResultHandler->TaskPadGetTitle(this, 
										       spNode->GetData(TFS_DATA_COOKIE),
                                               szGroup,
                                               ppszBitmapResource));
		
		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
			
	return hr;
}

/*!--------------------------------------------------------------------------
	TFSComponent::GetBackground
		IExtendTaskPad::GetBackground implementation
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
TFSComponent::GetBackground
(
    LPOLESTR					szGroup, 
	MMC_TASK_DISPLAY_OBJECT *   pTDO
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SPITFSNode				spNode;
	SPITFSResultHandler		spResultHandler;
	HRESULT					hr = hrOK;

	COM_PROTECT_TRY
	{
		GetSelectedNode(&spNode);
		if (spNode == NULL)
    	    goto Error;	// no selection for out IComponentData

        //
		// Forward the call so that the handler can do something 
		//
		CORg( spNode->GetResultHandler(&spResultHandler) );
		
		CORg( spResultHandler->TaskPadGetBackground(this, 
										            spNode->GetData(TFS_DATA_COOKIE),
                                                    szGroup,
                                                    pTDO));
		
		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
			
	return hr;
}

/*!--------------------------------------------------------------------------
	TFSComponent::GetDescriptiveText
		IExtendTaskPad::GetDescriptiveText implementation
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
TFSComponent::GetDescriptiveText
(
    LPOLESTR	szGroup, 
	LPOLESTR *  pszDescriptiveText
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SPITFSNode				spNode;
	SPITFSResultHandler		spResultHandler;
	HRESULT					hr = hrOK;

	COM_PROTECT_TRY
	{
		GetSelectedNode(&spNode);
		if (spNode == NULL)
    	    goto Error;	// no selection for out IComponentData

        //
		// Forward the call so that the handler can do something 
		//
		CORg( spNode->GetResultHandler(&spResultHandler) );
		
		CORg( spResultHandler->TaskPadGetDescriptiveText(this, 
										                 spNode->GetData(TFS_DATA_COOKIE),
														 szGroup,
														 pszDescriptiveText));
		
		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
			
	return hr;
}

/*---------------------------------------------------------------------------
	TFSComponent::GetListPadInfo
		IExtendTaskPad::GetListPadInfo implementation
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP
TFSComponent::GetListPadInfo
(
	LPOLESTR pszGroup,
	MMC_LISTPAD_INFO *pListPadInfo
)
{
	return E_NOTIMPL;
}

/*---------------------------------------------------------------------------
	IExtendContextMenu Implementation
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	TFSComponent::AddMenuItems
		MMC calls this to add menu items when a context menu is being put up
	Author: 
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
TFSComponent::AddMenuItems
(
	LPDATAOBJECT            pDataObject, 
	LPCONTEXTMENUCALLBACK   pContextMenuCallback,
	long *					pInsertionAllowed
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SPITFSNode	spNode;
	SPITFSResultHandler	spResultHandler;
	HRESULT		hr = hrOK;

	Assert(m_spTFSComponentData);

	COM_PROTECT_TRY
	{
        ASSERT(pDataObject != NULL);
        if ( (IS_SPECIAL_DATAOBJECT(pDataObject)) ||
             (pDataObject && IsMMCMultiSelectDataObject(pDataObject)) )
        {
            // get the selected node
		    CORg(GetSelectedNode(&spNode));
        }
        else
        {
            // normal case, extract the node from the DO
            CORg( ExtractNodeFromDataObject(m_spNodeMgr,
										    m_spTFSComponentData->GetCoClassID(),
										    pDataObject, FALSE,
										    &spNode, NULL, NULL) );
        }

		CORg( spNode->GetResultHandler(&spResultHandler) );

		if (spResultHandler)
			CORg( spResultHandler->AddMenuItems(this,
											spNode->GetData(TFS_DATA_COOKIE),
											pDataObject,
											pContextMenuCallback,
											pInsertionAllowed) );
		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH

	return hr;
}

/*!--------------------------------------------------------------------------
	TFSComponent::Command
		Command handler for context menus
	Author: 
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
TFSComponent::Command
(
	long            nCommandID, 
	LPDATAOBJECT    pDataObject
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	SPITFSNode	spNode;
	SPITFSResultHandler	spResultHandler;
	HRESULT		hr = hrOK;

	COM_PROTECT_TRY
	{
        if ( (IS_SPECIAL_DATAOBJECT(pDataObject)) ||
             (pDataObject && IsMMCMultiSelectDataObject(pDataObject)) )
        {
            // get the selected node
		    CORg(GetSelectedNode(&spNode));
        }
        else
        {
            // otherwise use the DO
		    CORg( ExtractNodeFromDataObject(m_spNodeMgr,
										    m_spTFSComponentData->GetCoClassID(),
										    pDataObject, FALSE,
										    &spNode, NULL, NULL) );
        }

		CORg( spNode->GetResultHandler(&spResultHandler) );
		if (spResultHandler)
			CORg( spResultHandler->Command(this,
										   spNode->GetData(TFS_DATA_COOKIE),
										   nCommandID,
										   pDataObject) );
		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH

	return hr;
}

/*!--------------------------------------------------------------------------
	ITFSComponent implementation specific members
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
TFSComponent::GetSelectedNode(ITFSNode **ppNode)
{
	Assert(ppNode);
	SetI((LPUNKNOWN *) ppNode, m_spSelectedNode);
	return hrOK;
}

STDMETHODIMP 
TFSComponent::SetSelectedNode(ITFSNode *pNode)
{
	m_spSelectedNode.Set(pNode);
	return hrOK;
}

STDMETHODIMP 
TFSComponent::GetConsole(IConsole2 **ppConsole)
{
	Assert(ppConsole);
	SetI((LPUNKNOWN *) ppConsole, m_spConsole);
	return hrOK;
}

STDMETHODIMP 
TFSComponent::GetHeaderCtrl(IHeaderCtrl **ppHeaderCtrl)
{
	Assert(ppHeaderCtrl);
	SetI((LPUNKNOWN *) ppHeaderCtrl, m_spHeaderCtrl);
	return hrOK;
}

STDMETHODIMP 
TFSComponent::GetResultData(IResultData **ppResultData)
{
	Assert(ppResultData);
	SetI((LPUNKNOWN *) ppResultData, m_spResultData);
	return hrOK;
}

STDMETHODIMP 
TFSComponent::GetImageList(IImageList **ppImageList)
{
	Assert(ppImageList);
	SetI((LPUNKNOWN *) ppImageList, m_spImageList);
	return hrOK;
}

STDMETHODIMP 
TFSComponent::GetConsoleVerb(IConsoleVerb **ppConsoleVerb)
{
	Assert(ppConsoleVerb);
	SetI((LPUNKNOWN *) ppConsoleVerb, m_spConsoleVerb);
	return hrOK;
}

STDMETHODIMP 
TFSComponent::GetControlbar(IControlbar **ppControlbar)
{
	Assert(ppControlbar);
	SetI((LPUNKNOWN *) ppControlbar, m_spControlbar);
	return hrOK;
}

STDMETHODIMP 
TFSComponent::GetComponentData(IComponentData **ppComponentData)
{
	Assert(ppComponentData);
	SetI((LPUNKNOWN *) ppComponentData, m_spComponentData);
	return hrOK;
}


STDMETHODIMP
TFSComponent::SetUserData(LONG_PTR ulData)
{
	m_ulUserData = ulData;
	return hrOK;
}

STDMETHODIMP
TFSComponent::GetUserData(LONG_PTR *pulData)
{
	Assert(pulData);
	*pulData = m_ulUserData;
	return hrOK;
}

STDMETHODIMP
TFSComponent::SetCurrentDataObject(LPDATAOBJECT pDataObject)
{
	m_spCurrentDataObject.Set(pDataObject);
	return hrOK;
}

STDMETHODIMP
TFSComponent::GetCurrentDataObject(LPDATAOBJECT * ppDataObject)
{
	Assert(ppDataObject);
	SetI((LPUNKNOWN *) ppDataObject, m_spCurrentDataObject);
	return hrOK;
}

STDMETHODIMP
TFSComponent::SetToolbar(IToolbar * pToolbar)
{
	m_spToolbar.Set(pToolbar);
	return hrOK;
}

STDMETHODIMP
TFSComponent::GetToolbar(IToolbar ** ppToolbar)
{
	Assert(ppToolbar);
	SetI((LPUNKNOWN *) ppToolbar, m_spToolbar);
	return hrOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\dbgutil.cpp ===
/*----------------------------------------------------------------------------
	dbgtrace.c
		Debug trace functions.

	Copyright (C) Microsoft Corporation, 1993 - 1999
	All rights reserved.

	Authors:
		suryanr		Suryanarayanan Raman
		GaryBu		Gary S. Burd

	History:
		05/11/93 suryanr	Created
		06/18/93 GaryBu		Convert to C.
		07/21/93 KennT		Code Reorg
		07/26/94 SilvanaR	Trace Buffer
		27 oct 95	garykac	DBCS_FILE_CHECK	debug file: BEGIN_STRING_OK
 ----------------------------------------------------------------------------*/
#include "stdafx.h"

#include <string.h>
#include <stdio.h>
#include <stdarg.h>
#include <time.h>

#include <stdarg.h>
#include <tchar.h>

#include "dbgutil.h"
#include "tfschar.h"
#include "atlconv.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#if 0
DBG_API(BOOL) FDbgFalse(void)
{
	return FALSE;
}
#endif

#ifdef DEBUG

/*!--------------------------------------------------------------------------
	DbgFmtPgm
		builds a string with the filename and line number 
	Author: EricDav
 ---------------------------------------------------------------------------*/
DBG_APIV(LPCTSTR) DbgFmtFileLine ( const char * szFn, int line )
{
    USES_CONVERSION;
    const TCHAR * ptszFn = A2CT(szFn);
    const TCHAR * pszTail = ptszFn + ::_tcslen( ptszFn );
    static TCHAR szBuff [100];

    for ( ; pszTail > ptszFn ; pszTail-- )
    {
        if ( *pszTail == '\\' || *pszTail == ':' )
        {
            pszTail++;
            break;
        }
    }

    ::wsprintf( szBuff, _T("[%s:%d]  "), pszTail, line );

    return szBuff;
}

/*!--------------------------------------------------------------------------
	DbgTrace
		Trace string with args.
	Author: suryanr
 ---------------------------------------------------------------------------*/
DBG_APIV(void) DbgTrace(LPCTSTR szFileLine, LPTSTR szFormat, ...)
{
	TCHAR szBuffer[1024];
	
	va_list args;
	va_start(args, szFormat);
	
	wvsprintf(szBuffer, szFormat, args);

    OutputDebugString(szFileLine);
    OutputDebugString(szBuffer);
	
	va_end(args);
}


#define MAX_ASSERT_INFO 32
#define MAX_ASSERT_FILE_LEN 64
struct ASSERT_INFO {
	char szFile[MAX_ASSERT_FILE_LEN];
	int iLine;
	};
static ASSERT_INFO s_rgAssertInfo[MAX_ASSERT_INFO] = {0};
static int s_iAssertInfo = 0;

/*!--------------------------------------------------------------------------
	DbgAssert
		Display assert dialog.
	Author: GaryBu, kennt
 ---------------------------------------------------------------------------*/
DBG_APIV(void) DbgAssert(LPCSTR szFile, int iLine, LPCTSTR szFmt, ...)
{
	va_list	arg;
	TCHAR sz[1024];
	int	iloc;
	int	ival;
	TCHAR *pch = sz;
	TCHAR *pchHead;
	static BOOL s_fInDbgAssert = FALSE;
	BOOL fQuit;
	MSG	msgT;

	// -- begin Ctrl-Ignore support ---------------------------------------
	// check if this assert is disabled (user has hit Ctrl-Ignore on this
	// assert this session).
	for (int i = s_iAssertInfo; i--;)
		if (lstrcmpA(szFile, s_rgAssertInfo[i].szFile) == 0 &&
				iLine == s_rgAssertInfo[i].iLine)
			// this assert is disabled
			return;
	// -- end Ctrl-Ignore support -----------------------------------------

	DBG_STRING(szTitle, "NT Networking Snapin Assert")
	DBG_STRING(szFileLineFmt, "%S @ line %d\n\n")

	pch += wsprintf(pch, (LPCTSTR)szFileLineFmt, szFile, iLine);
	pchHead = pch;

	// Add location to the output.

	if (szFmt)
		{
		*pch++ = '"';

		va_start(arg, szFmt);
		pch += wvsprintf(pch, szFmt, arg);
		va_end(arg);
		// Remove trailing newlines...
		while (*(pch-1) == '\n')
			--pch;

		*pch++ = '"';
		*pch++ = '\n';
		}
	else
		*pch++ = ' ';

	if (s_fInDbgAssert)
		{
		*pch = 0;
		Trace1("Arrgg! Recursive assert: %s", (LPTSTR) sz);

		MessageBeep(0);MessageBeep(0);
		return;
		}

	s_fInDbgAssert = TRUE;

	*pch++ = '\n';
	*pch = 0;

	Trace2("%s: %s", (LPTSTR) szTitle, (LPTSTR) sz);

repost_assert:
	// Is there a WM_QUIT message in the queue, if so remove it.
#define WM_QUIT                         0x0012
	fQuit = ::PeekMessage(&msgT, NULL, WM_QUIT, WM_QUIT, PM_REMOVE);
	ival = MessageBox(NULL, sz, szTitle,
					  MB_TASKMODAL|MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_DEFBUTTON3);
	// If there was a quit message, add it back into the queue
	if (fQuit)
		::PostQuitMessage((int)msgT.wParam);
		
	switch (ival)
		{
		case 0:
			Trace0("Failed to create message box on assert.\n");
			//	Fallthrough
		case IDRETRY:
			//	Hard break to cause just-in-time to fire (DbgStop doesn't)
			s_fInDbgAssert = FALSE;
			DebugBreak();
			return;
		case IDIGNORE:
			// -- begin Shift-Ignore support ------------------------------
			// use Shift-Ignore to copy assert text to clipboard.
			if ((GetKeyState(VK_SHIFT) & 0x8000) != 0)
				{
				if (OpenClipboard(0))
					{
					HGLOBAL hData;
					LPTSTR lpstr;

					hData = GlobalAlloc(GMEM_MOVEABLE|GMEM_DDESHARE,
							(lstrlen(sz)+1)*sizeof(TCHAR));
					if (hData)
						{
						lpstr = (LPTSTR)GlobalLock(hData);
						if (lpstr)
							{
							lstrcpy(lpstr, sz);
							GlobalUnlock(hData);
							EmptyClipboard();
							// Windows takes ownership of hData
							SetClipboardData(CF_TEXT, hData);
							}
						else
							{
							GlobalFree(hData);
							MessageBox(NULL, _T("Error locking memory handle."), szTitle, MB_OK);
							}
						}
					else
						MessageBox(NULL, _T("Not enough memory."), szTitle, MB_OK);
					CloseClipboard();
					}
				else
					MessageBox(NULL, _T("Cannot access clipboard."), szTitle, MB_OK);
				goto repost_assert;
				}
			// -- end Shift-Ignore support --------------------------------
			// -- begin Ctrl-Ignore support -------------------------------
			// check if user hit Ctrl-Ignore to disable this assert for the
			// rest of this session.
			if ((GetKeyState(VK_CONTROL) & 0x8000) != 0)
				if (s_iAssertInfo < MAX_ASSERT_INFO)
					{
					// add this assert to list of asserts to disable
					s_rgAssertInfo[s_iAssertInfo].iLine = iLine;
					lstrcpynA(s_rgAssertInfo[s_iAssertInfo].szFile, szFile, MAX_ASSERT_FILE_LEN);
					s_rgAssertInfo[s_iAssertInfo].szFile[MAX_ASSERT_FILE_LEN-1] = 0;
					s_iAssertInfo++;
					}
				else
					{
					// max asserts disabled already, warn user
					MessageBox(NULL, _T("Cannot disable that assert; ")
							_T("already disabled max number of asserts (32)."),
							szTitle, MB_OK);
					}
			// -- end Ctrl-Ignore support ---------------------------------
			s_fInDbgAssert = FALSE;
			return;
		case IDABORT:
			ExitProcess(1);
			break;
		}

	Trace1("Panic!  Dropping out of DbgAssert: %s", (LPSTR) sz);
	s_fInDbgAssert = FALSE;
	// A generic way of bringing up the debugger
	DebugBreak();
}



DBG_API(HRESULT) HrReportExit(HRESULT hr, LPCTSTR szName)
{
	if (!FHrOK(hr))
	{
		Trace2("%s returned 0x%08lx\n", szName, hr);
	}
	return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\dbgutil.h ===
/*----------------------------------------------------------------------------
	Dbgutil.H
		Exported header file for Dbgutil module.

	Copyright (C) Microsoft Corporation, 1993 - 1998
	All rights reserved.

	Authors:
		kennt	Kenn Takara
 ----------------------------------------------------------------------------*/

#ifndef _DBGUTIL_H
#define _DBGUTIL_H

#if _MSC_VER >= 1000	// VC 5.0 or later
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _OBJBASE_H_
#include <objbase.h>
#endif

#if defined(_DEBUG) && !defined(DEBUG)
#define DEBUG
#endif

#define DBG_API(type)	__declspec( dllexport ) type FAR PASCAL
#define DBG_APIV(type)	__declspec( dllexport ) type FAR CDECL

#define DBG_STRING(var, val) \
	static TCHAR var[] = _T(val);

/*---------------------------------------------------------------------------
	Debug instance counter
 ---------------------------------------------------------------------------*/
#ifdef _DEBUG 

inline void DbgInstanceRemaining(char * pszClassName, int cInstRem)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    char buf[100];
	char title[100];
	char szModule[100];
	
	GetModuleFileNameA(AfxGetInstanceHandle(), szModule, 100);

    wsprintfA(buf, "%s has %d instances left over.", pszClassName, cInstRem);
	wsprintfA(title, "%s Memory Leak!!!", szModule);

    ::MessageBoxA(NULL, buf, title, MB_OK);
}

    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)      extern int s_cInst_##cls = 0;
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    extern int s_cInst_##cls; ++(s_cInst_##cls);
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    extern int s_cInst_##cls; --(s_cInst_##cls);
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    \
        extern int s_cInst_##cls; \
        if (s_cInst_##cls) DbgInstanceRemaining(#cls, s_cInst_##cls);

#else

    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)   
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    

#endif _DEBUG



#ifdef _DEBUG
	DBG_API(HRESULT) HrReportExit(HRESULT hr, LPCTSTR szString);
#else
	#define HrReportExit(hr,sz)	hr
#endif _DEBUG


/*---------------------------------------------------------------------------
	Assert
 ---------------------------------------------------------------------------*/

#define Panic()						Assert0(FDbgFalse(), "Panic")
#define Panic0(szFmt)				Assert0(FDbgFalse(), szFmt)
#define Panic1(szFmt, p1)			Assert1(FDbgFalse(), szFmt, p1)
#define Panic2(szFmt, p1, p2)		Assert2(FDbgFalse(), szFmt, p1, p2)
#define Panic3(szFmt, p1, p2, p3)	Assert3(FDbgFalse(), szFmt, p1, p2, p3)
#define Panic4(szFmt, p1, p2, p3, p4)	Assert4(FDbgFalse(), szFmt, p1, p2, p3, p4)
#define Panic5(szFmt, p1, p2, p3, p4, p5)	Assert5(FDbgFalse(), szFmt, p1, p2, p3, p4, p5)
#define SideAssert(f)				Verify(f)
#define AssertSz(f, sz)				Assert0(f, sz)

#if !defined(DEBUG)

#define IfDebug(x)
#define Verify(f)							((void)(f))

#define Assert(f)							((void)0)
#define Assert0(f, szFmt)					((void)0)
#define Assert1(f, szFmt, p1)				((void)0)
#define Assert2(f, szFmt, p1, p2)			((void)0)
#define Assert3(f, szFmt, p1, p2, p3)		((void)0)
#define Assert4(f, szFmt, p1, p2, p3, p4)	((void)0)
#define Assert5(f, szFmt, p1, p2, p3, p4, p5) ((void)0)

#else

#ifndef THIS_FILE
#define THIS_FILE __FILE__
#endif

#define IfDebug(x)	x
#define Verify(f) Assert(f)

DBG_APIV(void)	DbgAssert(LPCSTR szFileName, int iLine, LPCTSTR szFmt, ...);
#define FDbgFalse()	(0)
	
#define Assert(f) \
	do { DBG_STRING(_sz, #f) \
		 DBG_STRING(_szFmt, "%s") \
	if (!(f)) DbgAssert(THIS_FILE, __LINE__,_szFmt,(LPSTR)_sz); } while (FDbgFalse())
#define Assert0(f, szFmt) \
	do { DBG_STRING(_sz, szFmt)\
	if (!(f)) DbgAssert(THIS_FILE, __LINE__, _sz); } while (FDbgFalse())
#define Assert1(f, szFmt, p1) \
	do { DBG_STRING(_sz, szFmt)\
	if (!(f)) DbgAssert(THIS_FILE, __LINE__, _sz, p1); } while (FDbgFalse())
#define Assert2(f, szFmt, p1, p2) \
	do { DBG_STRING(_sz, szFmt)\
	if (!(f)) DbgAssert(THIS_FILE, __LINE__, _sz, p1, p2); } while (FDbgFalse())
#define Assert3(f, szFmt, p1, p2, p3) \
	do { DBG_STRING(_sz, szFmt)\
	if (!(f)) DbgAssert(THIS_FILE, __LINE__, _sz, p1, p2, p3); } while (FDbgFalse())
#define Assert4(f, szFmt, p1, p2, p3, p4) \
	do { DBG_STRING(_sz, szFmt)\
	if (!(f)) DbgAssert(THIS_FILE, __LINE__, _sz, p1, p2, p3, p4); } while (FDbgFalse())
#define Assert5(f, szFmt, p1, p2, p3, p4, p5) \
	do { DBG_STRING(_sz, szFmt)\
	if (!(f)) DbgAssert(THIS_FILE, __LINE__, _sz, p1, p2, p3, p4, p5); } while (FDbgFalse())

#endif

/*---------------------------------------------------------------------------
	Trace
 ---------------------------------------------------------------------------*/

#if !defined(DEBUG)

#define Trace0(szFmt)						((void)0)
#define Trace1(szFmt, p1)					((void)0)
#define Trace2(szFmt, p1, p2)				((void)0)
#define Trace3(szFmt, p1, p2, p3)			((void)0)
#define Trace4(szFmt, p1, p2, p3, p4)		((void)0)
#define Trace5(szFmt, p1, p2, p3, p4, p5)	((void)0)

#else

DBG_APIV(LPCTSTR) DbgFmtFileLine ( const char * szFn, int line );
DBG_APIV(void)	DbgTrace(LPCTSTR szFileLine, LPTSTR szFormat, ...);

#define szPreDbg DbgFmtFileLine(THIS_FILE, __LINE__)

#define Trace0(szFmt) \
	 do { DBG_STRING(_sz, szFmt) DbgTrace(szPreDbg, _sz); } while (FDbgFalse())
#define Trace1(szFmt, p1) \
	 do { DBG_STRING(_sz, szFmt) DbgTrace(szPreDbg, _sz, p1); } while (FDbgFalse())
#define Trace2(szFmt, p1, p2) \
	 do { DBG_STRING(_sz, szFmt) DbgTrace(szPreDbg, _sz, p1, p2); } while (FDbgFalse())
#define Trace2(szFmt, p1, p2) \
	 do { DBG_STRING(_sz, szFmt) DbgTrace(szPreDbg, _sz, p1, p2); } while (FDbgFalse()) 
#define Trace3(szFmt, p1, p2, p3) \
	 do { DBG_STRING(_sz, szFmt) DbgTrace(szPreDbg, _sz, p1, p2, p3); } while (FDbgFalse())
#define Trace4(szFmt, p1, p2, p3, p4) \
	 do { DBG_STRING(_sz, szFmt) DbgTrace(szPreDbg, _sz, p1, p2, p3, p4); } while (FDbgFalse()) 
#define Trace5(szFmt, p1, p2, p3, p4, p5) \
	 do { DBG_STRING(_sz, szFmt) DbgTrace(szPreDbg, _sz, p1, p2, p3, p4, p5); } while (FDbgFalse())

#endif




#if !defined(DEBUG)

#define FImplies(a,b)       (!(a) || (b))
#define FIff(a,b)           (!(a) == !(b))

#else

#define FImplies(a,b)
#define FIff(a,b)

#endif


void	DbgStop(void);

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _DBGUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\ipadd.h ===
/* Copyright (C) Microsoft Corporation, 1991 - 1999 , all rights reserved

    ipadd.h - TCP/IP Address custom control

    November 9, 1992    - Greg Strange
*/


#if _MSC_VER >= 1000	// VC 5.0 or later
#pragma once
#endif

/* String table defines */
#define IDS_IPMBCAPTION         6612
#define IDS_IPNOMEM             6613
#define IDS_IPBAD_FIELD_VALUE   6614

#define MAX_IPNOMEMSTRING       256
#define MAX_IPCAPTION           256
#define MAX_IPRES               256

#ifdef IP_CUST_CTRL
/* IPAddress style dialog definitions */
#define ID_VISIBLE              201
#define ID_DISABLED             202
#define ID_GROUP                203
#define ID_TABSTOP              204

HANDLE FAR WINAPI IPAddressInfo();
BOOL FAR WINAPI IPAddressStyle( HWND, HANDLE, LPFNSTRTOID, LPFNIDTOSTR );
WORD FAR WINAPI IPAddressFlags( WORD, LPSTR, WORD );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\extract.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    extract.cpp

    FILE HISTORY:
	
*/

#include "stdafx.h"
#include "extract.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Internal private format
extern const wchar_t* SNAPIN_INTERNAL; //  = L"SNAPIN_INTERNAL";

// Generic MMC computer name format (also used by Computer Management snapin)
const wchar_t* MMC_SNAPIN_MACHINE_NAME = L"MMC_SNAPIN_MACHINE_NAME";

static unsigned int	s_cfNodeType = RegisterClipboardFormat(CCF_NODETYPE);
static unsigned int s_cfCoClass = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
static unsigned int s_cfInternal = RegisterClipboardFormat(SNAPIN_INTERNAL);
static unsigned int s_cfComputerName = RegisterClipboardFormat(MMC_SNAPIN_MACHINE_NAME);

/*!--------------------------------------------------------------------------
	IsMMCMultiSelectDataObject
        returns whether or not this dataobject is multiselect
        This only works for MMC supplied dataobjects.  Here is a list
        of notifications and what we can expect for DataObjects:
        MMC-MS-DO is an MMC supplied DO
        SI_MS_DO is a snapin supplied DO

        MMCN_BTN_CLICK	    MMC-MS-DO
        MMCN_CONTEXTMENU	MMC-MS-DO
        MMCN_CUTORMOVE	    CUTORMOVE_DO
        MMCN_DELETE	        SI_MS_DO
        MMCN_QUERY_PASTE	MMC-MS-DO
        MMCN_PASTE	        SI_MS_DO
        MMCN_SELECT	        SI_MS_DO

	Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL 
IsMMCMultiSelectDataObject
(
    IDataObject* pDataObject
)
{
    HRESULT     hr;
    BOOL        bMultiSelect = FALSE;

	COM_PROTECT_TRY
	{	
        if (pDataObject == NULL)
            return FALSE;
    
        static UINT s_cf = 0;  
        if (s_cf == 0)
        {
            USES_CONVERSION;
            s_cf = RegisterClipboardFormat(CCF_MMC_MULTISELECT_DATAOBJECT);
        }

        FORMATETC fmt = {(CLIPFORMAT) s_cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

        bMultiSelect = (pDataObject->QueryGetData(&fmt) == S_OK);   
    }
    COM_PROTECT_CATCH;

    return bMultiSelect;
}

// Data object extraction helpers
CLSID* ExtractClassID(LPDATAOBJECT lpDataObject)
{
    return Extract<CLSID>(lpDataObject, (CLIPFORMAT) s_cfCoClass, -1);    
}

GUID* ExtractNodeType(LPDATAOBJECT lpDataObject)
{
    return Extract<GUID>(lpDataObject, (CLIPFORMAT) s_cfNodeType, -1);    
}

INTERNAL* ExtractInternalFormat(LPDATAOBJECT lpDataObject)
{
    return Extract<INTERNAL>(lpDataObject, (CLIPFORMAT) s_cfInternal, -1);    
}

TFSCORE_API(WCHAR*) ExtractComputerName(LPDATAOBJECT lpDataObject)
{
    return Extract<WCHAR>(lpDataObject, (CLIPFORMAT) s_cfComputerName, (MAX_PATH+1) * sizeof(WCHAR));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\extract.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    extract.h

    FILE HISTORY:
        
*/

#ifndef _EXTRACT_H
#define _EXTRACT_H

#if _MSC_VER >= 1000	// VC 5.0 or later
#pragma once
#endif

#ifndef __mmc_h__
#include <mmc.h>
#endif


struct INTERNAL 
{
    INTERNAL() 
	{ 
		m_type = CCT_UNINITIALIZED; 
		m_cookie = -1;
        m_index = -1;
        ZeroMemory(&m_clsid, sizeof(CLSID));
	};

    ~INTERNAL() {}

    DATA_OBJECT_TYPES   m_type;     // What context is the data object.
    MMC_COOKIE          m_cookie;   // What object the cookie represents
    CString             m_string;   //
    CLSID               m_clsid;    // Class ID of who created this data object
    int                 m_index;    // index of the item in the virtual listbox

    BOOL HasVirtualIndex() { return m_index != -1; }
    int  GetVirtualIndex() { return m_index; }

    INTERNAL & operator=(const INTERNAL& rhs) 
    { 
		if (&rhs == this)
			return *this;

		m_type = rhs.m_type; 
		m_cookie = rhs.m_cookie; 
		m_string = rhs.m_string;
        memcpy(&m_clsid, &rhs.m_clsid, sizeof(CLSID));

		return *this;
    } 

    BOOL operator==(const INTERNAL& rhs) 
    {
		return rhs.m_string == m_string;
    }
};


// SPINTERNAL
DeclareSmartPointer(SPINTERNAL, INTERNAL, if (m_p) GlobalFree((void *) m_p) )




//
// Extracts a data type from a data object
//
template <class TYPE>
TYPE* Extract(LPDATAOBJECT lpDataObject, CLIPFORMAT cf, int nSize)
{
    ASSERT(lpDataObject != NULL);

    TYPE* p = NULL;

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc = { cf, NULL, 
                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL 
                          };

    int len;

	// Allocate memory for the stream
    if (nSize == -1)
	{
		len = sizeof(TYPE);
	}
	else
	{
		//int len = (cf == CDataObject::m_cfWorkstation) ? 
		//    ((MAX_COMPUTERNAME_LENGTH+1) * sizeof(TYPE)) : sizeof(TYPE);	
		len = nSize;
	}

    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, len);
    
    // Get the workstation name from the data object
    do 
    {
        if (stgmedium.hGlobal == NULL)
            break;

        if (FAILED(lpDataObject->GetDataHere(&formatetc, &stgmedium)))
            break;
        
        p = reinterpret_cast<TYPE*>(stgmedium.hGlobal);

        if (p == NULL)
            break;

    } while (FALSE); 

    return p;
}

struct INTERNAL;

TFSCORE_API(INTERNAL*)	ExtractInternalFormat(LPDATAOBJECT lpDataObject);
TFSCORE_API(GUID *)     ExtractNodeType(LPDATAOBJECT lpDataObject);
TFSCORE_API(CLSID *)    ExtractClassID(LPDATAOBJECT lpDataObject);
TFSCORE_API(WCHAR *)	ExtractComputerName(LPDATAOBJECT lpDataObject);
TFSCORE_API(BOOL)       IsMMCMultiSelectDataObject(LPDATAOBJECT lpDataObject);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\errutil.h ===
/*----------------------------------------------------------------------------
	ErrUtil.H
		Exported header file for Error module.

	Copyright (C) Microsoft Corporation, 1993 - 1999
	All rights reserved.

	Authors:
		kennt	Kenn Takara
 ----------------------------------------------------------------------------*/

#ifndef _ERRUTIL_H
#define _ERRUTIL_H

#if _MSC_VER >= 1000	// VC 5.0 or later
#pragma once
#endif

#ifndef _TFSINT_H
#include "tfsint.h"
#endif

BOOL FHrFailed(HRESULT hr);
BOOL FHrSucceeded(HRESULT hr);
BOOL FHrOK(HRESULT hr);
#define FHrOk(hr) FHrOK(hr)	// archaic case

inline BOOL FHrFailed(HRESULT hr)
{
	return FAILED(hr);
}

inline BOOL FHrSucceeded(HRESULT hr)
{
	return SUCCEEDED(hr);
}

inline BOOL FHrOK(HRESULT hr)
{
	return hr == 0;
}


/*---------------------------------------------------------------------------
	Function: InitializeErrorObject

	Initializes the error structure for the current thread (this is all
	done on a thread-by-thread basis).
 ---------------------------------------------------------------------------*/

extern "C"
{
TFSCORE_API(HRESULT)	InitializeTFSError();
TFSCORE_API(HRESULT)	CleanupTFSError();

TFSCORE_API(ITFSError *) GetTFSErrorObject();
TFSCORE_API(HANDLE)	GetTFSErrorHeap();

TFSCORE_API(HRESULT)	CreateTFSErrorInfo(LONG_PTR uReserved);
TFSCORE_API(HRESULT)	CreateTFSErrorInfoForThread(DWORD dwThreadId, LONG_PTR uReserved);

TFSCORE_API(HRESULT)	DestroyTFSErrorInfo(LONG_PTR uReserved);
TFSCORE_API(HRESULT)	DestroyTFSErrorInfoForThread(DWORD dwThreadId, LONG_PTR uReserved);

TFSCORE_API(HRESULT)	ClearTFSErrorInfo(LONG_PTR uReserved);
TFSCORE_API(HRESULT)	ClearTFSErrorInfoForThread(DWORD dwThreadId, LONG_PTR uReserved);

TFSCORE_API(HRESULT)	GetTFSErrorInfo(TFSErrorInfo **ppErrInfo);
TFSCORE_API(HRESULT)	GetTFSErrorInfoForThread(DWORD dwThreadId, TFSErrorInfo **ppErrInfo);

TFSCORE_API(HRESULT)	SetTFSErrorInfo(const TFSErrorInfo *pErrInfo);
TFSCORE_API(HRESULT)	SetTFSErrorInfoForThread(DWORD dwThreadId, const TFSErrorInfo *pErrInfo);

TFSCORE_API(HRESULT)	TFSErrorInfoFree(TFSErrorInfo *pErrInfo);

TFSCORE_API(HRESULT)	DisplayTFSErrorMessage(HWND hWnd);

#define FILLTFSERR_HIGH	0x01
#define FILLTFSERR_LOW	0x02
#define FILLTFSERR_GEEK	0x04
#define FILLTFSERR_NOCLOBBER 0x08


TFSCORE_API(HRESULT)	FillTFSError(LONG_PTR uReserved,
									 HRESULT hrLow,
									 DWORD   dwFlags,
									 LPCTSTR pszHigh,
									 LPCTSTR pszLow,
									 LPCTSTR pszGeek);

TFSCORE_API(HRESULT)	FillTFSErrorId(LONG_PTR uReserved,
									   HRESULT hrLow,
									   DWORD   dwFlags,
									   UINT nHigh,
									   UINT nLow,
									   UINT nGeek);

};

									 


// Use this function for most error handling
TFSCORE_API(HRESULT) FormatError(HRESULT hr, TCHAR *pszBuffer, UINT cchBuffer);

/*---------------------------------------------------------------------------
	Helper APIs for the COR macros.
 ---------------------------------------------------------------------------*/
TFSCORE_API(void)	AddSystemErrorMessage(HRESULT hr);
TFSCORE_API(void)	AddWin32ErrorMessage(DWORD dwErr);

#define AddStringIdErrorMessage(hr,ids)	FillTFSErrorId(0, hr, FILLTFSERR_HIGH, ids, 0, 0)
#define AddStringIdErrorMessage2(hr, ids, idsgeek) FillTFSErrorId(0, hr, FILLTFSERR_HIGH | FILLTFSERR_GEEK, ids, 0, idsgeek)
#define AddStringErrorMessage(hr, psz)	FillTFSError(0, hr, FILLTFSERR_HIGH, psz, 0, 0)
#define AddStringErrorMessage2(hr, psz, pszGeek) FillTFSError(0, hr, FILLTFSERR_HIGH | FILLTFSERR_GEEK, psz, 0, pszGeek)


/*---------------------------------------------------------------------------
	These next three functions set the high-level error string, but
	do NOT set the underlying HRESULT.
 ---------------------------------------------------------------------------*/
#define AddHighLevelErrorString(psz)	AddStringErrorMessage(0, psz)
#define AddHighLevelErrorStringId(ids)	AddStringIdErrorMessage(0, ids)
#define AddHighLevelErrorStringId2(ids, idsGeek)	AddStringIdErrorMessage2(0, ids, idsGeek)
#define SetDefaultHighLevelErrorStringId(ids) \
     FillTFSErrorId(0, hr, FILLTFSERR_HIGH | FILLTFSERR_NOCLOBBER, ids, 0, 0)

#define AddLowLevelErrorString(psz)		FillTFSError(0, 0, FILLTFSERR_LOW, NULL, psz, NULL)
#define AddLowLevelErrorStringId(ids)	FillTFSErrorId(0, 0, FILLTFSERR_LOW, NULL, ids, NULL)

#define AddGeekLevelErrorString(psz)	FillTFSError(0, 0, FILLTFSERR_GEEK, NULL, NULL, psz)
#define AddGeekLevelErrorStringId(ids)	FillTFSErrorId(0, 0, FILLTFSERR_GEEK, NULL, NULL, ids)


#define CORg(hResult) \
	do\
		{\
		hr = (hResult);\
		if (FHrFailed(hr))\
		  {\
			AddSystemErrorMessage(hr);\
			goto Error;\
		  }\
		}\
	while (FALSE)

#define CWRg(hResult) \
	do\
		{\
		hr = (DWORD) hResult;\
		hr = HRESULT_FROM_WIN32(hr);\
		if (FHrFailed(hr))\
		  {\
			AddSystemErrorMessage(hr);\
			goto Error;\
		  }\
		}\
	while (FALSE)


#define	CORg_s(hResult, ids)\
	do\
		{\
		hr = (hResult);\
		if (FHrFailed(hr))\
			{\
			AddStringIdErrorMessage(hr);\
			goto Error;\
			}\
		}\
	while (FALSE)

#define	CORg_sz(hResult, sz)\
	do\
		{\
		hr = (hResult);\
		if (FHrFailed(hr))\
			{\
			AddStringErrorMessage(hr);\
			goto Error;\
			}\
		}\
	while (FALSE)


// Provide for an inline expansion
inline HRESULT	HResultFromWin32(DWORD dwError)
{
	return HRESULT_FROM_WIN32(dwError);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\errutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       errutil.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"

#include "errutil.h"
#include "mprapi.h"
#include "mprerror.h"
#include "raserror.h"

#define IS_WIN32_HRESULT(x)	(((x) & 0xFFFF0000) == 0x80070000)
#define WIN32_FROM_HRESULT(hr)		(0x0000FFFF & (hr))

/*!--------------------------------------------------------------------------
	FormatError
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) FormatError(HRESULT hr, TCHAR *pszBuffer, UINT cchBuffer)
{
	DWORD	dwErr;
	
	// Copy over default message into szBuffer
	_tcscpy(pszBuffer, _T("Error"));

	// Ok, we can't get the error info, so try to format it
	// using the FormatMessage
		
	// Ignore the return message, if this call fails then I don't
	// know what to do.

	dwErr = FormatMessage(
						  FORMAT_MESSAGE_FROM_SYSTEM,
						  NULL,
						  hr,
						  0,
						  pszBuffer,
						  cchBuffer,
						  NULL);
	pszBuffer[cchBuffer-1] = 0;
	
	return HResultFromWin32(dwErr);
}



/*---------------------------------------------------------------------------
	TFS Error handling code.
 ---------------------------------------------------------------------------*/

struct TFSInternalErrorInfo
{
	DWORD	m_dwSize;		// size of the structure, used for versioning 
	DWORD	m_dwThreadId;	// thread id of this error structure
	LONG_PTR	m_uReserved1;	// = 0, reserved for object id
	LONG_PTR	m_uReserved2;	// = 0 for now, reserved for HRESULT component type
	DWORD	m_hrLow;		// HRESULT of the low level error
	CString	m_stLow;		// allocate using HeapAlloc() and GetErrorHeap()
	CString	m_stHigh;		// allocate using HeapAlloc() and GetErrorHeap()
	CString	m_stGeek;		// allocate using HeapAlloc() and GetErrorHeap()
	LONG_PTR	m_uReserved3;	// =0, reserved for error dialog information(?)
	LONG_PTR	m_uReserved4;	// =0, reserved for error dialog information(?)
	LONG_PTR	m_uReserved5;	// =0, reserved for future use


    DWORD   m_dwFlags;      // used to pass info between our objects

	// Allocates and serializes a TFSErrorInfo.  Used by GetErrorInfo();
	TFSErrorInfo *	SaveToBlock();
	void			LoadFromBlock(const TFSErrorInfo *pErr);
};



/*!--------------------------------------------------------------------------
	TFSInternalErrorInfo::SaveToBlock
		This function converts the internal structure into a TFSErrorInfo
		structure (that is allocated on the error heap).  It will allocate
		all of the data at once.
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSErrorInfo *	TFSInternalErrorInfo::SaveToBlock()
{
	DWORD		dwSize = 0;
	TFSErrorInfo *pError = NULL;
	WCHAR *		pswz = NULL;
	
	// Determine how large of an allocation we will need
	// Need the size of the structure itself
	dwSize += sizeof(TFSErrorInfo);

	// Need the size of the low-level error string
	dwSize += (m_stLow.GetLength() + 1) * sizeof(WCHAR);
	dwSize += (m_stHigh.GetLength() + 1) * sizeof(WCHAR);
	dwSize += (m_stGeek.GetLength() + 1) * sizeof(WCHAR);

	// Allocate a chunk of memory for this
    HANDLE hHeap = GetTFSErrorHeap();
    if (hHeap)
    {
        pError = (TFSErrorInfo *) ::HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwSize);
	    if (pError)
	    {
		    pError->m_dwSize = sizeof(TFSErrorInfo);
    //		pError->m_dwThreadId = m_dwThreadId;
		    pError->m_hrLow = m_hrLow;
    //		pError->m_uReserved1 = m_uReserved1;
		    pError->m_uReserved2 = m_uReserved2;
		    pError->m_uReserved3 = m_uReserved3;
		    pError->m_uReserved4 = m_uReserved4;
		    pError->m_uReserved5 = m_uReserved5;

		    // Add the strings to the end of this structure
		    pswz = (LPWSTR) (pError+1);
		    StrCpy(pswz, (LPCWSTR) T2CW(m_stLow));
		    pError->m_pszLow = pswz;
		    
		    pswz += (StrLenW(pswz) + 1);
		    StrCpy(pswz, (LPCWSTR) T2CW(m_stHigh));
		    pError->m_pszHigh = pswz;
		    
		    pswz += (StrLenW(pswz) + 1);
		    StrCpy(pswz, (LPCWSTR) T2CW(m_stGeek));
		    pError->m_pszGeek = pswz;

		    // Check to see that the size is what we think it is
		    Assert( (sizeof(TFSErrorInfo) +
				     (pswz - (LPWSTR)(pError+1)) +
				     StrLenW(pswz) + 1) <= dwSize );

	    }
    }

	return pError;
}


/*!--------------------------------------------------------------------------
	TFSInternalErrorInfo::LoadFromBlock
		Fills a TFSInternalErrorInfo struct with the information from
		a TFSErrorInfo.  If pErr is NULL, then we clear this struct (i.e.
		fill it in with NULL data).
	Author: KennT
 ---------------------------------------------------------------------------*/
void TFSInternalErrorInfo::LoadFromBlock(const TFSErrorInfo *pErr)
{
	USES_CONVERSION;

	if (pErr)
	{
		m_dwSize = pErr->m_dwSize;
//		m_dwThreadId = pErr->m_dwThreadId;
//		m_uReserved1 = pErr->m_uReserved1;
		m_uReserved2 = pErr->m_uReserved2;
		m_uReserved3 = pErr->m_uReserved3;
		m_uReserved4 = pErr->m_uReserved4;
		m_uReserved5 = pErr->m_uReserved5;

		if (pErr->m_hrLow)
			m_hrLow = pErr->m_hrLow;

		// Overwrite the low-level string if one is provided
		if (pErr->m_pszLow)
			m_stLow = OLE2CT(pErr->m_pszLow);

		// Overwrite the high-level error
		if (pErr->m_pszHigh && ((pErr->m_dwFlags & FILLTFSERR_NOCLOBBER) == 0))
			m_stHigh = OLE2CT(pErr->m_pszHigh);

		// Overwrite the geek-level string if one is provided
		if (pErr->m_pszGeek)
			m_stGeek = OLE2CT(pErr->m_pszGeek);
	}
	else
	{
		// if pErr==NULL, clear out the structure		
		m_dwSize = 0;
//		m_dwThreadId = 0;
//		m_uReserved1 = 0;
		m_uReserved2 = 0;
		m_uReserved3 = 0;
		m_uReserved4 = 0;
		m_uReserved5 = 0;
		
		m_hrLow = 0;

		m_stLow.Empty();
		m_stHigh.Empty();
		m_stGeek.Empty();
	}
}


/*---------------------------------------------------------------------------
	Type:	TFSInternalErrorList
 ---------------------------------------------------------------------------*/
typedef CList<TFSInternalErrorInfo *, TFSInternalErrorInfo *> TFSInternalErrorInfoList;


/*---------------------------------------------------------------------------
	Class:	TFSErrorObject

	This is the central class that manages the error information structures
	for the various threads and objects.

	This class is thread-safe.
 ---------------------------------------------------------------------------*/

class TFSErrorObject : public ITFSError
{
public:
	DeclareIUnknownMembers(IMPL);
	DeclareITFSErrorMembers(IMPL);

	TFSErrorObject();
	~TFSErrorObject();

	void Lock();
	void Unlock();

	HRESULT	Init();
	HRESULT	Cleanup();

	HANDLE	GetHeap();

	HRESULT	CreateErrorInfo(DWORD dwThreadId, LONG_PTR uReserved);
	HRESULT DestroyErrorInfo(DWORD dwThreadId, LONG_PTR uReserved);

	// Looks for the error info that matches up with the dwThreadId
	// and uReserved.
	TFSInternalErrorInfo * FindErrorInfo(DWORD dwThreadId, LONG_PTR uReserved);

protected:
	long	m_cRef;

	BOOL	m_fInitialized;	// TRUE if initialized, FALSE otherwise

	CRITICAL_SECTION	m_critsec;

	TFSInternalErrorInfoList	m_tfserrList;
	
	HANDLE	m_hHeap;		// Handle of the heap for this error object
};


TFSErrorObject::TFSErrorObject()
	: m_cRef(1),
	m_fInitialized(FALSE),
	m_hHeap(NULL)
{
	InitializeCriticalSection(&m_critsec);
}

TFSErrorObject::~TFSErrorObject()
{
	Cleanup();
	DeleteCriticalSection(&m_critsec);
}

IMPLEMENT_SIMPLE_QUERYINTERFACE(TFSErrorObject, ITFSError)

STDMETHODIMP_(ULONG) TFSErrorObject::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) TFSErrorObject::Release()
{
	Assert(m_cRef > 0);
	
	if (0 == InterlockedDecrement(&m_cRef))
	{
		// No need to free this object up since it's static
		return 0;
	}
	return m_cRef;
}

/*!--------------------------------------------------------------------------
	TFSErrorObject::Lock
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void TFSErrorObject::Lock()
{
	EnterCriticalSection(&m_critsec);
}

/*!--------------------------------------------------------------------------
	TFSErrorObject::Unlock
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void TFSErrorObject::Unlock()
{
	LeaveCriticalSection(&m_critsec);
}

/*!--------------------------------------------------------------------------
	TFSErrorObject::Init
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT TFSErrorObject::Init()
{
	HRESULT	hr = hrOK;

	Lock();

	if (!m_fInitialized)
	{
		Assert(m_tfserrList.GetCount() == 0);
		
		// Create the heap
		m_hHeap = HeapCreate(0, 4096, 0);
		if (m_hHeap == NULL)
			hr = HRESULT_FROM_WIN32(GetLastError());

		if (FHrSucceeded(hr))
			m_fInitialized = TRUE;
	}
	
	Unlock();

	return hr;
}

/*!--------------------------------------------------------------------------
	TFSErrorObject::Cleanup
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT TFSErrorObject::Cleanup()
{
	HRESULT	hr = hrOK;
	POSITION	pos;
	TFSInternalErrorInfo *	pErr;

	Lock();

	if (m_fInitialized)
	{
		while (!m_tfserrList.IsEmpty())
		{
			delete m_tfserrList.RemoveHead();
		}

		if (m_hHeap)
		{
			HeapDestroy(m_hHeap);
			m_hHeap = NULL;
		}
	}
	
	Unlock();

	return hr;
}

/*!--------------------------------------------------------------------------
	TFSErrorObject::GetHeap
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HANDLE TFSErrorObject::GetHeap()
{
	HANDLE	hHeap = NULL;

	Lock();

	if (m_fInitialized)
		hHeap = m_hHeap;
	
	Unlock();

	return hHeap;
}

HRESULT	TFSErrorObject::CreateErrorInfo(DWORD dwThreadId, LONG_PTR uReserved)
{
	HRESULT	hr = hrOK;
	TFSInternalErrorInfo *	pErr = NULL;

	COM_PROTECT_TRY
	{
		if (FindErrorInfo(dwThreadId, uReserved) == NULL)
		{
			pErr = new TFSInternalErrorInfo;

			pErr->LoadFromBlock(NULL);

			// Fill in the data with the appropriate fields
			pErr->m_dwThreadId = dwThreadId;
			pErr->m_uReserved1 = uReserved;

			m_tfserrList.AddTail(pErr);
		}
	}
	COM_PROTECT_CATCH;

	if (!FHrSucceeded(hr))
		delete pErr;
	
	return hr;
}

HRESULT TFSErrorObject::DestroyErrorInfo(DWORD dwThreadId, LONG_PTR uReserved)
{
	HRESULT	hr = hrOK;
	POSITION	pos, posTemp;
	TFSInternalErrorInfo *	pErr;
	BOOL		bFound = FALSE;

	COM_PROTECT_TRY
	{
		pos = m_tfserrList.GetHeadPosition();
		while (pos)
		{
			posTemp = pos;
			pErr = m_tfserrList.GetNext(pos);
			if ((pErr->m_dwThreadId == dwThreadId) &&
				(pErr->m_uReserved1 == uReserved))
			{
				m_tfserrList.RemoveAt(posTemp);
				delete pErr;
				bFound = TRUE;
				break;
			}
		}

		if (!bFound)
			hr = E_INVALIDARG;
	}
	COM_PROTECT_CATCH;
	
	return hr;
}

TFSInternalErrorInfo * TFSErrorObject::FindErrorInfo(DWORD dwThreadId, LONG_PTR uReserved)
{
	POSITION	pos;
	POSITION	posTemp;
	TFSInternalErrorInfo *	pErr = NULL;
	BOOL		bFound = FALSE;
	HRESULT		hr = hrOK;

	COM_PROTECT_TRY
	{
		pos = m_tfserrList.GetHeadPosition();
		while (pos)
		{
			posTemp = pos;
			pErr = m_tfserrList.GetNext(pos);
			if ((pErr->m_dwThreadId == dwThreadId) &&
				(pErr->m_uReserved1 == uReserved))
			{				
				bFound = TRUE;
				break;
			}
		}
	}
	COM_PROTECT_CATCH;
	
	return bFound ? pErr : NULL;
}
   
/*!--------------------------------------------------------------------------
	TFSErrorObject::GetErrorInfo
		Implementation of ITFSError::GetErrorInfo
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSErrorObject::GetErrorInfo(LONG_PTR uReserved, TFSErrorInfo **ppErr)
{
	HRESULT	hr = hrOK;

	Lock();
	
	COM_PROTECT_TRY
	{
		hr = GetErrorInfoForThread(GetCurrentThreadId(), uReserved, ppErr);
	}
	COM_PROTECT_CATCH;

	Unlock();

	return hr;
}

/*!--------------------------------------------------------------------------
	TFSErrorObject::GetErrorInfoForThread
		Implementation of ITFSError::GetErrorInfoForThread
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSErrorObject::GetErrorInfoForThread(DWORD dwThreadId, LONG_PTR uReserved, TFSErrorInfo **ppErr)
{
	HRESULT	hr = hrOK;
	TFSInternalErrorInfo *	pInternalError;
	TFSErrorInfo *	pErr = NULL;

	if (ppErr == NULL)
		return E_INVALIDARG;
	*ppErr = NULL;

	Lock();
	
	COM_PROTECT_TRY
	{
		if (!m_fInitialized)
			hr = E_FAIL;
		else
		{
			// Can we find the right error object?
			pInternalError = FindErrorInfo(dwThreadId, uReserved);
			if (pInternalError)
				pErr = pInternalError->SaveToBlock();
			else
				hr = E_INVALIDARG;

			*ppErr = pErr;
		}
	}
	COM_PROTECT_CATCH;

	Unlock();

	return hr;
}

/*!--------------------------------------------------------------------------
	TFSErrorObject::SetErrorInfo
		Implementation of ITFSError::SetErrorInfo
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSErrorObject::SetErrorInfo(LONG_PTR uReserved, const TFSErrorInfo *pErr)
{
	HRESULT	hr = hrOK;

	Lock();
	
	COM_PROTECT_TRY
	{
		hr = SetErrorInfoForThread(GetCurrentThreadId(), uReserved, pErr);
	}
	COM_PROTECT_CATCH;

	Unlock();

	return hr;
}

/*!--------------------------------------------------------------------------
	TFSErrorObject::SetErrorInfoForThread
		Implementation of ITFSError::SetErrorInfoForThread
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSErrorObject::SetErrorInfoForThread(DWORD dwThreadId, LONG_PTR uReserved, const TFSErrorInfo *pErr)
{
	HRESULT	hr = hrOK;
	TFSInternalErrorInfo *	pInternalError;

	Lock();
	
	COM_PROTECT_TRY
	{
		if (!m_fInitialized)
			hr = E_FAIL;
		else
		{
			// Can we find the right error object?
			pInternalError = FindErrorInfo(dwThreadId, uReserved);
			if (pInternalError)
			{
				pInternalError->LoadFromBlock(pErr);
			}
			else
				hr = E_INVALIDARG;
		}
	}
	COM_PROTECT_CATCH;

	Unlock();

	return hr;
}

/*!--------------------------------------------------------------------------
	TFSErrorObject::ClearErrorInfo
		Implementation of ITFSError::ClearErrorInfo
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSErrorObject::ClearErrorInfo(LONG_PTR uReserved)
{
	HRESULT	hr = hrOK;

	Lock();
	
	COM_PROTECT_TRY
	{
		hr = ClearErrorInfoForThread(GetCurrentThreadId(), uReserved);
	}
	COM_PROTECT_CATCH;

	Unlock();

	return hr;
}

/*!--------------------------------------------------------------------------
	TFSErrorObject::ClearErrorInfoForThread
		Implementation of ITFSError::ClearErrorInfoForThread
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSErrorObject::ClearErrorInfoForThread(DWORD dwThreadId, LONG_PTR uReserved)
{
	HRESULT	hr = hrOK;
	TFSInternalErrorInfo *	pInternalError;

	Lock();
	
	COM_PROTECT_TRY
	{
		if (!m_fInitialized)
			hr = E_FAIL;
		else
		{
			// Can we find the right error object?
			pInternalError = FindErrorInfo(dwThreadId, uReserved);
			if (pInternalError)
			{
				// Clear the information out of the internal block
				pInternalError->LoadFromBlock(NULL);
			}
			else
				hr = E_INVALIDARG;
		}
	}
	COM_PROTECT_CATCH;

	Unlock();

	return hr;
}




/*---------------------------------------------------------------------------
	This is a static object that lives in the process space.  It does not
	get dynamically created or destroyed.
 ---------------------------------------------------------------------------*/
static TFSErrorObject	s_tfsErrorObject;


/*---------------------------------------------------------------------------
	Global API functions
 ---------------------------------------------------------------------------*/


/*!--------------------------------------------------------------------------
	InitializeTFSError
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) InitializeTFSError()
{
	return s_tfsErrorObject.Init();
}

/*!--------------------------------------------------------------------------
	CleanupTFSError
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) CleanupTFSError()
{
	return s_tfsErrorObject.Cleanup();
}

/*!--------------------------------------------------------------------------
	GetTFSErrorObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(ITFSError *) GetTFSErrorObject()
{
	return &s_tfsErrorObject;
}

/*!--------------------------------------------------------------------------
	GetTFSErrorHeap
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HANDLE) GetTFSErrorHeap()
{
	return s_tfsErrorObject.GetHeap();
}


/*!--------------------------------------------------------------------------
	CreateTFSErrorInfo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) CreateTFSErrorInfo(LONG_PTR uReserved)
{
	return CreateTFSErrorInfoForThread(GetCurrentThreadId(), uReserved);
}

/*!--------------------------------------------------------------------------
	CreateTFSErrorInfoForThread
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) CreateTFSErrorInfoForThread(DWORD dwThreadId, LONG_PTR uReserved)
{
	return s_tfsErrorObject.CreateErrorInfo(dwThreadId, uReserved);
}

/*!--------------------------------------------------------------------------
	DestroyTFSErrorInfo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) DestroyTFSErrorInfo(LONG_PTR uReserved)
{
	return DestroyTFSErrorInfoForThread(GetCurrentThreadId(), uReserved);
}

/*!--------------------------------------------------------------------------
	DestroyTFSErrorInfoForThread
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) DestroyTFSErrorInfoForThread(DWORD dwThreadId, LONG_PTR uReserved)
{
	return s_tfsErrorObject.DestroyErrorInfo(dwThreadId, uReserved);
}

TFSCORE_API(HRESULT) ClearTFSErrorInfo(LONG_PTR uReserved)
{
	return ClearTFSErrorInfoForThread(GetCurrentThreadId(), uReserved);
}

TFSCORE_API(HRESULT) ClearTFSErrorInfoForThread(DWORD dwThreadId, LONG_PTR uReserved)
{
	return s_tfsErrorObject.ClearErrorInfoForThread(dwThreadId, uReserved);
}


/*!--------------------------------------------------------------------------
	DisplayTFSErrorMessage
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) DisplayTFSErrorMessage(HWND hWndParent)
{
	CString	stTitle;
	stTitle.LoadString(AFX_IDS_APP_TITLE);

	HRESULT	hr = hrOK;
	CString	st;
	TFSErrorInfo *	pErr = NULL;
	BOOL fQuit;
	MSG	msgT;

	// Format the string with the text for the current error message
	GetTFSErrorObject()->GetErrorInfo(0, &pErr);
	if (pErr && !FHrSucceeded(pErr->m_hrLow))
	{
		if (pErr->m_pszHigh && pErr->m_pszLow)
		{
			AFX_MANAGE_STATE(AfxGetStaticModuleState());
			AfxFormatString2(st, IDS_ERROR_FORMAT2,
							 pErr->m_pszHigh, pErr->m_pszLow);
		}
		else if (pErr->m_pszHigh || pErr->m_pszLow)
		{
			AFX_MANAGE_STATE(AfxGetStaticModuleState());
			AfxFormatString1(st, IDS_ERROR_FORMAT1,
							pErr->m_pszHigh ? pErr->m_pszHigh : pErr->m_pszLow);
		}
		
		// Is there a WM_QUIT message in the queue, if so remove it.
		fQuit = ::PeekMessage(&msgT, NULL, WM_QUIT, WM_QUIT, PM_REMOVE);
		::MessageBox(hWndParent, (LPCTSTR) st, (LPCTSTR) stTitle,
					 MB_OK | MB_ICONERROR | /*MB_DEFAULT_DESKTOP_ONLY | --ft:removed as per bug #233282*/
					 MB_SETFOREGROUND);
		// If there was a quit message, add it back into the queue
		if (fQuit)
			::PostQuitMessage((int)msgT.wParam);

		if ((GetAsyncKeyState(VK_CONTROL) & 0x8000) != 0)
		{
			CString	stHresult;
			
			// Bring up another message box with the geek message
			// if there is one
			if (pErr->m_pszGeek)
			{
				{
					AFX_MANAGE_STATE(AfxGetStaticModuleState());
					stHresult.Format(_T("%08lx"), pErr->m_hrLow);
					AfxFormatString2(st, IDS_ERROR_MORE_INFORMATION, stHresult, pErr->m_pszGeek);
				}
				
				// Is there a WM_QUIT message in the queue, if so remove it.
				fQuit = ::PeekMessage(&msgT, NULL, WM_QUIT, WM_QUIT, PM_REMOVE);
				::MessageBox(hWndParent, (LPCTSTR) st, (LPCTSTR) stTitle,
							 MB_OK | MB_ICONERROR | /*MB_DEFAULT_DESKTOP_ONLY | --ft:removed as per bug #233282*/
							 MB_SETFOREGROUND);
				// If there was a quit message, add it back into the queue
				if (fQuit)
					::PostQuitMessage((int)msgT.wParam);
			}
		}

		TFSErrorInfoFree(pErr);
		pErr = NULL;
		
	}
	else
		hr = E_FAIL;
	return hr;
}


TFSCORE_API(HRESULT)	FillTFSError(LONG_PTR uReserved,
									 HRESULT hrLow,
									 DWORD dwFlags,
									 LPCTSTR pszHigh,
									 LPCTSTR pszLow,
									 LPCTSTR pszGeek)
{
	TFSErrorInfo	es;
	HRESULT			hr = hrOK;
	USES_CONVERSION;

	::ZeroMemory(&es, sizeof(es));
	
	es.m_dwSize = sizeof(TFSErrorInfo);
	es.m_uReserved2 = 0;
	es.m_hrLow = hrLow;
	if (dwFlags & FILLTFSERR_LOW)
		es.m_pszLow = T2COLE(pszLow);
	if (dwFlags & FILLTFSERR_HIGH)
		es.m_pszHigh = T2COLE(pszHigh);
	if (dwFlags & FILLTFSERR_GEEK)
		es.m_pszGeek = T2COLE(pszGeek);
	es.m_uReserved3 = 0;
	es.m_uReserved4 = 0;
	es.m_uReserved5 = 0;
    es.m_dwFlags = dwFlags;
	
	GetTFSErrorObject()->SetErrorInfo(uReserved, &es);
	return hr;
}

TFSCORE_API(HRESULT)	FillTFSErrorId(LONG_PTR uReserved,
									   HRESULT hrLow,
									   DWORD dwFlags,
									   UINT nHigh,
									   UINT nLow,
									   UINT nGeek)
{
	CString	stHigh, stLow, stGeek;

	if ((dwFlags & FILLTFSERR_HIGH) && nHigh)
		stHigh.LoadString(nHigh);
	if ((dwFlags & FILLTFSERR_LOW) && nLow)
		stLow.LoadString(nLow);
	if ((dwFlags & FILLTFSERR_GEEK) && nGeek)
		stGeek.LoadString(nGeek);

	return FillTFSError(uReserved, hrLow, dwFlags, (LPCTSTR) stHigh,
						(LPCTSTR) stLow, (LPCTSTR) stGeek);
}


TFSCORE_API(void) AddSystemErrorMessage(HRESULT hr)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	if (!FHrSucceeded(hr))
	{
		TCHAR	szBuffer[4096];
		CString	st, stHr;

		FormatError(hr, szBuffer, DimensionOf(szBuffer));
		stHr.Format(_T("%08lx"), hr);

		AfxFormatString2(st, IDS_ERROR_SYSTEM_ERROR_FORMAT,
						 szBuffer, (LPCTSTR) stHr);

		FillTFSError(0, hr, FILLTFSERR_LOW, NULL, (LPCTSTR) st, NULL);
	}
}

TFSCORE_API(void) AddWin32ErrorMessage(DWORD dwErr)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (dwErr != ERROR_SUCCESS)
	{
		TCHAR	szBuffer[4096];
		CString	st, stHr;

		FormatError(dwErr, szBuffer, DimensionOf(szBuffer));
		stHr.Format(_T("%08lx"), dwErr);

		AfxFormatString2(st, IDS_ERROR_SYSTEM_ERROR_FORMAT,
						 szBuffer, (LPCTSTR) stHr);

		FillTFSError(0, HResultFromWin32(dwErr), FILLTFSERR_LOW, NULL, (LPCTSTR) st, NULL);
	}
}




TFSCORE_API(HRESULT)	GetTFSErrorInfo(TFSErrorInfo **ppErrInfo)
{
	return GetTFSErrorInfoForThread(GetCurrentThreadId(), ppErrInfo);
}


TFSCORE_API(HRESULT)	SetTFSErrorInfo(const TFSErrorInfo *pErrInfo)
{
	return SetTFSErrorInfoForThread(GetCurrentThreadId(), pErrInfo);
}

TFSCORE_API(HRESULT)	GetTFSErrorInfoForThread(DWORD dwThreadId, TFSErrorInfo **ppErrInfo)
{
	return GetTFSErrorObject()->GetErrorInfoForThread(dwThreadId, 0, ppErrInfo);
}

TFSCORE_API(HRESULT)	SetTFSErrorInfoForThread(DWORD dwThreadId, const TFSErrorInfo *pErrInfo)
{
	return GetTFSErrorObject()->SetErrorInfoForThread(dwThreadId, 0, pErrInfo);
}

TFSCORE_API(HRESULT)	TFSErrorInfoFree(TFSErrorInfo *pErrInfo)
{
    HANDLE hHeap = GetTFSErrorHeap();
    if (hHeap)
    {
        ::HeapFree(hHeap, 0, pErrInfo);
    }

	return hrOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\dynamlnk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dynamlnk.cpp
//
//--------------------------------------------------------------------------

// DynamLnk.cpp : base class for DLLs which are loaded only when needed

#include "stdafx.h"
//#include "safetemp.h"
#include "DynamLnk.h"

//#include "macros.h"
//USE_HANDLE_MACROS("TAPISNAP(DynamLnk.cpp)")

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

DynamicDLL::DynamicDLL(LPCTSTR ptchLibraryName, LPCSTR* apchFunctionNames)
: m_hLibrary( (HMODULE)-1 ),
  m_apfFunctions( NULL ),
  m_ptchLibraryName( ptchLibraryName ),
  m_apchFunctionNames( apchFunctionNames ),
  m_nNumFunctions( 0 )
{
	ASSERT( !IsBadStringPtr(m_ptchLibraryName,MAX_PATH) );
	ASSERT( NULL != apchFunctionNames );
	for (LPCSTR pchFunctionName = *apchFunctionNames;
	     NULL != pchFunctionName;
		 pchFunctionName = *(++apchFunctionNames) )
	{
		m_nNumFunctions++;
		ASSERT( !IsBadStringPtrA(pchFunctionName,MAX_PATH) );
	}
}

DynamicDLL::~DynamicDLL()
{
	if (NULL != m_apfFunctions)
	{
		delete m_apfFunctions;
		m_apfFunctions = NULL;
	}
	if ((HMODULE)-1 != m_hLibrary && NULL != m_hLibrary)
	{
		VERIFY( ::FreeLibrary( m_hLibrary ) );
		m_hLibrary = NULL;
	}
}

BOOL DynamicDLL::LoadFunctionPointers()
{
	if ((HMODULE)-1 != m_hLibrary)
		return (NULL != m_hLibrary);

	m_hLibrary = ::LoadLibrary( m_ptchLibraryName );
	if (NULL == m_hLibrary)
	{
		// The library is not present
		return FALSE;
	}

	// let this throw an exception
	m_apfFunctions = new FARPROC[m_nNumFunctions];

	for (INT i = 0; i < m_nNumFunctions; i++)
	{
		m_apfFunctions[i] = ::GetProcAddress( m_hLibrary, m_apchFunctionNames[i] );
		if ( NULL == m_apfFunctions[i] )
		{
			// The library is present but does not have all of the entrypoints
			VERIFY( ::FreeLibrary( m_hLibrary ) );
			m_hLibrary = NULL;
			return FALSE;
		}
	}

	return TRUE;
}


FARPROC DynamicDLL::QueryFunctionPtr(INT i) const
{
	if ( 0 > i || m_nNumFunctions <= i || NULL == m_apfFunctions || NULL == m_apfFunctions[i] )
	{
		ASSERT( FALSE );
		return NULL;
	}
	return m_apfFunctions[i];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\dynamlnk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dynamlnk.h
//
//--------------------------------------------------------------------------

// DynamLnk.h : Base class for DLLs which are loaded only when needed

#ifndef __DYNAMLNK_H_INCLUDED__
#define __DYNAMLNK_H_INCLUDED__

#if _MSC_VER >= 1000	// VC 5.0 or later
#pragma once
#endif

class DynamicDLL
{
public:
	// These strings must remain unchanged until the FileServiceProvider is released
	DynamicDLL(LPCTSTR ptchLibraryName, LPCSTR* apchFunctionNames);
	virtual ~DynamicDLL();

	BOOL LoadFunctionPointers();

	FARPROC QueryFunctionPtr(INT i) const;
	inline FARPROC operator[] (INT i) const
		{ return QueryFunctionPtr(i); }

private:
	HMODULE m_hLibrary;
	FARPROC* m_apfFunctions;
	LPCTSTR m_ptchLibraryName;
	LPCSTR* m_apchFunctionNames;
	INT m_nNumFunctions;
};

#endif // ~__DYNAMLNK_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tfscore.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        210
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         225
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\main.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1995 - 1998 **/
/**********************************************************************/

/*
    FILE HISTORY:

	main.cpp - holds our CWinApp implementation for this DLL
*/

#include "stdafx.h"

#ifdef _DEBUG
void DbgVerifyInstanceCounts();
#define DEBUG_VERIFY_INSTANCE_COUNTS DbgVerifyInstanceCounts()
#else
#define DEBUG_VERIFY_INSTANCE_COUNTS
#endif


#ifdef _DEBUG
void TFSCore_DbgVerifyInstanceCounts()
{
    DEBUG_VERIFY_INSTANCE_COUNT(TFSComponent);
    DEBUG_VERIFY_INSTANCE_COUNT(TFSComponentData);

//    DEBUG_VERIFY_INSTANCE_COUNT(CBaseHandler);
//    DEBUG_VERIFY_INSTANCE_COUNT(CBaseResultHandler);

    DEBUG_VERIFY_INSTANCE_COUNT(TFSNode);
    DEBUG_VERIFY_INSTANCE_COUNT(TFSNodeEnum);
    DEBUG_VERIFY_INSTANCE_COUNT(TFSNodeMgr);

    DEBUG_VERIFY_INSTANCE_COUNT(CHiddenWnd);
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\service.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
        service.cpp
                Calls to start and stop services.
                        
    FILE HISTORY:
        
*/
#include "stdafx.h"
#include "DynamLnk.h"
#include "cluster.h"

DynamicDLL g_NetApiDLL( _T("NETAPI32.DLL"), g_apchNetApiFunctionNames );

/*---------------------------------------------------------------------------
        IsComputerNT
                Checks to see if the given computer is running NT
        Author: EricDav
 ---------------------------------------------------------------------------*/
TFSCORE_API(DWORD) 
TFSIsComputerNT
(
        LPCTSTR         pszComputer, 
        BOOL *          bIsNT
)
{
        DWORD   err = 0;
        BYTE *  pbBuffer;
        
        *bIsNT = FALSE;

        if ( !g_NetApiDLL.LoadFunctionPointers() )
                return err;

    err = ((NETSERVERGETINFO) g_NetApiDLL[NET_API_NET_SERVER_GET_INFO])
                ( (LPTSTR) pszComputer,
                                  101,
                                  &pbBuffer );

    if (err == NERR_Success)
    {
                //
                // Possible Errors:
                //   ERROR_ACCESS_DENIED 
                //   ERROR_INVALID_LEVEL 
                //   ERROR_INVALID_PARAMETER 
                //   ERROR_NOT_ENOUGH_MEMORY 
                //
                SERVER_INFO_101 *       pServerInfo = (SERVER_INFO_101 *) pbBuffer;

                if ( (pServerInfo->sv101_type & SV_TYPE_NT) )
                {
                        *bIsNT = TRUE;
                }

                err = ERROR_SUCCESS; //Translate the NERR code to a winerror code
    }

    return err;
}


/*---------------------------------------------------------------------------
        IsNTServer
                Checks to see if the given computer is running NTS
        Author: EricDav
 ---------------------------------------------------------------------------*/
TFSCORE_API(DWORD) 
TFSIsNTServer
(
        LPCTSTR         pszComputer, 
        BOOL *          bIsNTS
)
{
        DWORD   err = 0;
        BYTE *  pbBuffer;
        
        *bIsNTS = FALSE;

        if ( !g_NetApiDLL.LoadFunctionPointers() )
                return err;

    err = ((NETSERVERGETINFO) g_NetApiDLL[NET_API_NET_SERVER_GET_INFO])
                ( (LPTSTR) pszComputer,
                                  101,
                                  &pbBuffer );

    if (err == NERR_Success)
    {
                //
                // Possible Errors:
                //   ERROR_ACCESS_DENIED 
                //   ERROR_INVALID_LEVEL 
                //   ERROR_INVALID_PARAMETER 
                //   ERROR_NOT_ENOUGH_MEMORY 
                //
                SERVER_INFO_101 *       pServerInfo = (SERVER_INFO_101 *) pbBuffer;

                if ( (pServerInfo->sv101_type & SV_TYPE_SERVER_NT) ||
                         (pServerInfo->sv101_type & SV_TYPE_DOMAIN_CTRL) ||
                         (pServerInfo->sv101_type & SV_TYPE_DOMAIN_BAKCTRL) )
                {
                        *bIsNTS = TRUE;
                }

                err = ERROR_SUCCESS; //Translate the NERR code to a winerror code
    }

    return err;
}


/*---------------------------------------------------------------------------
        TFSIsServiceRunning
                Checks to see if the given service is running on a machine
        Author: EricDav
 ---------------------------------------------------------------------------*/
TFSCORE_API(DWORD) 
TFSIsServiceRunning
(
        LPCTSTR         pszComputer, 
        LPCTSTR         pszServiceName,
        BOOL *          fIsRunning 
)
{
    DWORD               err = 0;
        DWORD           dwStatus;

        *fIsRunning = FALSE;

        err = TFSGetServiceStatus(pszComputer, pszServiceName, &dwStatus, NULL);

        if (err == 0)
                *fIsRunning = (BOOL)(dwStatus & SERVICE_RUNNING);

        return err;     
}


/*!--------------------------------------------------------------------------
        TFSGetServiceStatus
       Returns ERROR_SUCCESS on API success.
       Returns an error code otherwise.

       pszComputer - name of the computer to attach to.
       pszServiceName -  name of the service to check.
       pdwServiceStatus - returns the status of the service.
       pdwErrorCode - returns the error code returned from the service
                      (this is NOT the error code from the API itself).
                      This may be NULL.
                
        Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(DWORD) 
TFSGetServiceStatus
(
        LPCWSTR         pszComputer, 
        LPCWSTR         pszServiceName,
        DWORD *         pdwServiceStatus,
    OPTIONAL DWORD *     pdwErrorCode
)
{
    DWORD               err = 0;
        SC_HANDLE       hScManager;

    Assert(pdwServiceStatus);

    *pdwServiceStatus = 0;

    if (pdwErrorCode)
        *pdwErrorCode = 0;

    //
    // Find out if the service is running on the given machine 
    //
        hScManager = ::OpenSCManager(pszComputer, NULL, GENERIC_READ);  
        if (hScManager == NULL)
        {
                //
                // Possible Errors:
                //      ERROR_ACCESS_DENIED 
                //      ERROR_DATABASE_DOES_NOT_EXIST 
                //      ERROR_INVALID_PARAMETER                 
                //
                return GetLastError();
        }
        
        SC_HANDLE hService = ::OpenService(hScManager, pszServiceName, SERVICE_QUERY_STATUS);
        if (hService == NULL)
        {
                //
                // Possible Errors:
                //      ERROR_ACCESS_DENIED 
                //      ERROR_INVALID_HANDLE 
                //      ERROR_INVALID_NAME 
                //      ERROR_SERVICE_DOES_NOT_EXIST    
                //
                err = GetLastError();

                ::CloseServiceHandle(hScManager);
                
                return err;
        }

    SERVICE_STATUS      serviceStatus;
        if (!::QueryServiceStatus(hService, &serviceStatus))
        {
                //
                // Possible Errors:
                //      ERROR_ACCESS_DENIED 
                //      ERROR_INVALID_HANDLE            
                //
                err = GetLastError();

                ::CloseServiceHandle(hService);
                ::CloseServiceHandle(hScManager);
                
                return err;
        }

        *pdwServiceStatus = serviceStatus.dwCurrentState;

    // Also return the error code
    if (pdwErrorCode)
    {
        if (serviceStatus.dwWin32ExitCode == ERROR_SERVICE_SPECIFIC_ERROR)
            *pdwErrorCode = serviceStatus.dwServiceSpecificExitCode;
        else
            *pdwErrorCode = serviceStatus.dwWin32ExitCode;
    }

        ::CloseServiceHandle(hService);
        ::CloseServiceHandle(hScManager);

    return err;
}


/*---------------------------------------------------------------------------
        StartService
                Starts the given service on a machine
        Author: EricDav
 ---------------------------------------------------------------------------*/
TFSCORE_API(DWORD) 
TFSStartService
(
        LPCTSTR pszComputer,
        LPCTSTR pszServiceName,
        LPCTSTR pszServiceDesc
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

        DWORD           err = 0;
    
    err = StartSCMService(pszComputer, pszServiceName, pszServiceDesc);
    
        return err;
}

/*---------------------------------------------------------------------------
        StartServiceEx
                Starts the given service on a machine, cluster aware
        Author: EricDav
 ---------------------------------------------------------------------------*/
TFSCORE_API(DWORD) 
TFSStartServiceEx
(
        LPCTSTR pszComputer,
        LPCTSTR pszServiceName,
        LPCTSTR pszClusterResourceType,
        LPCTSTR pszServiceDesc
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

        DWORD           err = 0;
    
    if (FIsComputerInRunningCluster(pszComputer))
    {
        err = ControlClusterService(pszComputer, pszClusterResourceType, pszServiceDesc, TRUE);
    }
    else
    {
        err = StartSCMService(pszComputer, pszServiceName, pszServiceDesc);
    }
    
        return err;
}


/*---------------------------------------------------------------------------
        StopService
                Stops the given service on a machine
        Author: EricDav
 ---------------------------------------------------------------------------*/
TFSCORE_API(DWORD) 
TFSStopService
(
        LPCTSTR pszComputer,
        LPCTSTR pszServiceName,
    LPCTSTR pszServiceDesc
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    DWORD               err = 0;

    err = StopSCMService(pszComputer, pszServiceName, pszServiceDesc);

        return err;
}

/*---------------------------------------------------------------------------
        StopServiceEx
                Stops the given service on a machine, cluster aware
        Author: EricDav
 ---------------------------------------------------------------------------*/
TFSCORE_API(DWORD) 
TFSStopServiceEx
(
        LPCTSTR pszComputer,
        LPCTSTR pszServiceName,
        LPCTSTR pszClusterResourceType,
    LPCTSTR pszServiceDesc
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    DWORD               err = 0;

    if (FIsComputerInRunningCluster(pszComputer))
    {
        err = ControlClusterService(pszComputer, pszClusterResourceType, pszServiceDesc, FALSE);
    }
    else
    {
        err = StopSCMService(pszComputer, pszServiceName, pszServiceDesc);
    }

        return err;
}


TFSCORE_API(DWORD) TFSGetServiceStartType(LPCWSTR pszComputer, LPCWSTR pszServiceName, DWORD *pdwStartType)
{
    DWORD               err = 0;
        SC_HANDLE       hScManager = 0;
        SC_HANDLE       hService = 0;
        HRESULT         hr = hrOK;
        BOOL    fReturn = FALSE;
        LPQUERY_SERVICE_CONFIG pqsConfig = NULL;
        DWORD   cbNeeded = sizeof( QUERY_SERVICE_CONFIG );
        DWORD   cbSize;

    //
    // Find out if the service is running on the given machine 
    //
        hScManager = ::OpenSCManager(pszComputer, NULL, GENERIC_READ);  
        if (hScManager == NULL)
        {
                //
                // Possible Errors:
                //      ERROR_ACCESS_DENIED 
                //      ERROR_DATABASE_DOES_NOT_EXIST 
                //      ERROR_INVALID_PARAMETER                 
                //
                err = GetLastError();
                goto Exit;
        }
        
        hService = ::OpenService(hScManager, pszServiceName, SERVICE_QUERY_CONFIG);
        if (hService == NULL)
        {
                //
                // Possible Errors:
                //      ERROR_ACCESS_DENIED 
                //      ERROR_INVALID_HANDLE 
                //      ERROR_INVALID_NAME 
                //      ERROR_SERVICE_DOES_NOT_EXIST    
                //
                err = GetLastError();
                goto Exit;
        }


        COM_PROTECT_TRY
        {
                
                *pdwStartType = 0;
                
                // loop, allocating the needed size
                do
                {
                        delete [] (PBYTE)pqsConfig;
                        
                        pqsConfig = (LPQUERY_SERVICE_CONFIG) new BYTE[cbNeeded];
                        cbSize = cbNeeded;
                        
                        fReturn = ::QueryServiceConfig( hService,
                                                                                        pqsConfig,
                                                                                        cbSize,
                                                                                        &cbNeeded );
                        *pdwStartType = pqsConfig->dwStartType;
                        delete [] (PBYTE)pqsConfig;
                        pqsConfig = NULL;
                        
                        if (!fReturn && (cbNeeded == cbSize))
                        {
                                // error
                                *pdwStartType = 0;
                                err = GetLastError();
                                goto Error;
                        }
                        
                } while (!fReturn && (cbNeeded != cbSize));

                
                COM_PROTECT_ERROR_LABEL;
        }
        COM_PROTECT_CATCH;

        if (!FHrSucceeded(hr))
        {
                // The only time we should get here (with an hr is for outofmemory)
                err = ERROR_OUTOFMEMORY;
        }
        
Exit:
        if (err != 0)
        {
                *pdwStartType = 0;              
        }
        ::CloseServiceHandle(hService);
        ::CloseServiceHandle(hScManager);

    return err;
}

TFSCORE_API(DWORD) TFSSetServiceStartType(LPCWSTR pszComputer, LPCWSTR pszServiceName, DWORD dwStartType)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    DWORD               err = 0;
        SC_HANDLE       hScManager;

    //
    // Open the SCManager so that we can try to stop the service
    //
        hScManager = ::OpenSCManager(pszComputer, NULL, SC_MANAGER_ALL_ACCESS);
        if (hScManager == NULL)
        {
                //
                // Possible Errors:
                //      ERROR_ACCESS_DENIED 
                //      ERROR_DATABASE_DOES_NOT_EXIST 
                //      ERROR_INVALID_PARAMETER                 
                //
                return GetLastError();
        }
        
        SC_HANDLE hService = ::OpenService(hScManager, pszServiceName, SERVICE_STOP | SERVICE_ALL_ACCESS);
        if (hService == NULL)
        {
                //
                // Possible Errors:
                //      ERROR_ACCESS_DENIED 
                //      ERROR_INVALID_HANDLE 
                //      ERROR_INVALID_NAME 
                //      ERROR_SERVICE_DOES_NOT_EXIST    
                //
                err = GetLastError();
                ::CloseServiceHandle(hScManager);
                
                return err;
        }

        if (!::ChangeServiceConfig( hService,
                                                           SERVICE_NO_CHANGE,
                                                           dwStartType,
                                                           SERVICE_NO_CHANGE,
                                                           NULL,
                                                           NULL,
                                                           NULL,
                                                           NULL,
                                                           NULL,
                                                           NULL,
                                                           NULL))
        {
                //
                // Possible Errors:
                //      ERROR_ACCESS_DENIED
                //      ERROR_CIRCULAR_DEPENDENCY
                //      ERROR_DUP_NAME
                //      ERROR_INVALID_HANDLE
                //      ERROR_INVALID_PARAMETER
                //      ERROR_INVALID_SERVICE_ACCOUNT
                //      ERROR_SERVICE_MARKED_FOR_DELETE
                //
                err = ::GetLastError();
                ::CloseServiceHandle(hService);
                ::CloseServiceHandle(hScManager);
                return err;
        }
        
        ::CloseServiceHandle(hService);
        ::CloseServiceHandle(hScManager);
        
        return err;
}

DWORD
StartSCMService
(
        LPCTSTR pszComputer,
        LPCTSTR pszServiceName,
        LPCTSTR pszServiceDesc
)
{
    DWORD       err = 0;
    SC_HANDLE   hScManager;

    //
    // Open the SCManager so that we can try to start the service
    //
    hScManager = ::OpenSCManager(pszComputer, NULL, SC_MANAGER_CONNECT );
        if (hScManager == NULL)
        {
                //
                // Possible Errors:
                //      ERROR_ACCESS_DENIED 
                //      ERROR_DATABASE_DOES_NOT_EXIST 
                //      ERROR_INVALID_PARAMETER                 
                //
                return GetLastError();
        }
        
        SC_HANDLE hService = ::OpenService(hScManager, pszServiceName, SERVICE_START | SERVICE_QUERY_STATUS);
        if (hService == NULL)
        {
                //
                // Possible Errors:
                //      ERROR_ACCESS_DENIED 
                //      ERROR_INVALID_HANDLE 
                //      ERROR_INVALID_NAME 
                //      ERROR_SERVICE_DOES_NOT_EXIST    
                //
                err = GetLastError();
                ::CloseServiceHandle(hScManager);
                
                return err;
        }

    SERVICE_STATUS      serviceStatus;
        if (!::QueryServiceStatus(hService, &serviceStatus))
        {
                //
                // Possible Errors:
                //      ERROR_ACCESS_DENIED 
                //      ERROR_INVALID_HANDLE            
                //
                err = GetLastError();
                ::CloseServiceHandle(hService);
                ::CloseServiceHandle(hScManager);
                
                return err;
        }

        // If the service is in a start pending, do not do anything
        if (serviceStatus.dwCurrentState == SERVICE_START_PENDING)
        {
                ::CloseServiceHandle(hService);
                ::CloseServiceHandle(hScManager);

                err = ERROR_SERVICE_ALREADY_RUNNING;

                return err;
        }
        
        if (!::StartService(hService, NULL, NULL))
        {
                //
                // Possible Errors:
                //      ERROR_ACCESS_DENIED 
                //      ERROR_INVALID_HANDLE 
                //      ERROR_PATH_NOT_FOUND 
                //      ERROR_SERVICE_ALREADY_RUNNING 
                //      ERROR_SERVICE_DATABASE_LOCKED 
                //      ERROR_SERVICE_DEPENDENCY_DELETED 
                //      ERROR_SERVICE_DEPENDENCY_FAIL 
                //      ERROR_SERVICE_DISABLED 
                //      ERROR_SERVICE_LOGON_FAILED 
                //      ERROR_SERVICE_MARKED_FOR_DELETE 
                //      ERROR_SERVICE_NO_THREAD 
                //      ERROR_SERVICE_REQUEST_TIMEOUT 
                //
                err = GetLastError();
                ::CloseServiceHandle(hService);
                ::CloseServiceHandle(hScManager);

                return err;
        }
        
        // 
        // Put up the dialog with the funky spinning thing to 
        // let the user know that something is happening
        //
        CServiceCtrlDlg dlgServiceCtrl(hService, pszComputer, pszServiceDesc, TRUE);

        dlgServiceCtrl.DoModal();
    err = dlgServiceCtrl.m_dwErr;

        //
        // Everything started ok, close up and get going
        //
        ::CloseServiceHandle(hService);
        ::CloseServiceHandle(hScManager);

    return err;
}   


DWORD
StopSCMService
(
        LPCTSTR pszComputer,
        LPCTSTR pszServiceName,
        LPCTSTR pszServiceDesc
)
{
    DWORD                   err = 0;
    SC_HANDLE               hScManager;
    LPENUM_SERVICE_STATUS   lpScStatus = NULL;
    DWORD                   dwNumService = 0, dwSize = 0, dwSizeReqd = 0, i = 0;
    BOOL                    bRet;
    

    //
    // Open the SCManager so that we can try to stop the service
    //
        hScManager = ::OpenSCManager(pszComputer, NULL, SC_MANAGER_CONNECT );
        if (hScManager == NULL)
        {
                //
                // Possible Errors:
                //      ERROR_ACCESS_DENIED 
                //      ERROR_DATABASE_DOES_NOT_EXIST 
                //      ERROR_INVALID_PARAMETER                 
                //
                return GetLastError();
        }
        
        SC_HANDLE hService = ::OpenService(
                                    hScManager, pszServiceName, 
                                    SERVICE_STOP | SERVICE_QUERY_STATUS | 
                                        SERVICE_ENUMERATE_DEPENDENTS
                                    );
        if (hService == NULL)
        {
                //
                // Possible Errors:
                //      ERROR_ACCESS_DENIED 
                //      ERROR_INVALID_HANDLE 
                //      ERROR_INVALID_NAME 
                //      ERROR_SERVICE_DOES_NOT_EXIST    
                //
                err = GetLastError();
                ::CloseServiceHandle(hScManager);
                
                return err;
        }

        //
        // Stop all dependent services that are currently active.
        //  Since the number of services is unknown (up front), 
        //  EnumDependentServices is called atleast twice (first
        //  to get the size of buffer, and second to get the
        //  list of services).  If the number of services changes
        //  between the calls, then EnumDependentServices is called
        //  one more time (as per the logic, i < 3).
        //
        
        do
        {
            //
            // Enumerate all dependent services
            //
            
            bRet = ::EnumDependentServices(
                        hService, SERVICE_ACTIVE, lpScStatus, dwSize, 
                        &dwSizeReqd, &dwNumService
                        );
                        
            if (!bRet && (GetLastError() == ERROR_MORE_DATA))
            {
                //
                // Not enough buffer to hold the dependent service list,
                //  delete previous allocation (if any) and allocate new
                //  buffer of requiste size.
                //
                
                if (lpScStatus) { delete lpScStatus; lpScStatus = NULL; }

                lpScStatus = reinterpret_cast<LPENUM_SERVICE_STATUS> 
                                (new BYTE[2 * dwSizeReqd]);
                if (lpScStatus == NULL)
                {
                    //
                    // allocation failed, forget about stopping dependent 
                    // services
                    //
                    
                    break;
                }

                //
                // Increment attempt count.  At most 3 attempts will be made
                //  to get the list of dependent services
                //

                dwSize = 2 * dwSizeReqd;
                dwSizeReqd = 0;
                i++;
            }

            else
            {
                //
                // Success or failure for other than insufficent buffer reason
                //
                
                break;
            }
            
        } while( i < 3 );

        //
        // if dependent service were successfully enumerated
        //  stop them all
        //
        
        if (bRet)
        {
            for (i = 0; i < dwNumService; i++)
            {
                StopSCMService(
                    pszComputer, 
                    lpScStatus[i].lpServiceName,
                    lpScStatus[i].lpDisplayName
                    );
            }
        }

        if (lpScStatus) { delete lpScStatus; lpScStatus = NULL; }

        //
        // Stop the service, now that all dependents have been stopped
        //
        
        SERVICE_STATUS serviceStatus;
        if (!::ControlService(hService, SERVICE_CONTROL_STOP, &serviceStatus)) 
        {
                //
                // Possible Errors:
                //  ERROR_ACCESS_DENIED 
                //  ERROR_DEPENDENT_SERVICES_RUNNING 
                //  ERROR_INVALID_SERVICE_CONTROL 
                //  ERROR_SERVICE_CANNOT_ACCEPT_CTRL 
                //  ERROR_SERVICE_NOT_ACTIVE 
                //  ERROR_SERVICE_REQUEST_TIMEOUT 
                //
                err = GetLastError();
                ::CloseServiceHandle(hService);
                ::CloseServiceHandle(hScManager);
                
                return err;
        }

        if ( serviceStatus.dwCurrentState != SERVICE_STOPPED )
        {
                // 
                // Put up the dialog with the funky spinning thing to 
                // let the user know that something is happening
                //
                CServiceCtrlDlg dlgServiceCtrl(hService, pszComputer, pszServiceDesc, FALSE);

                dlgServiceCtrl.DoModal();
        err = dlgServiceCtrl.m_dwErr;
        }

        //
        // Everything stopped ok, close up and get going
        //
        ::CloseServiceHandle(hService);
        ::CloseServiceHandle(hScManager);

    return err;
}



TFSCORE_API(DWORD) TFSPauseService(LPCTSTR pszComputer, LPCTSTR pszServiceName, LPCTSTR pszServiceDesc)
{
    return PauseSCMService(pszComputer, pszServiceName, pszServiceDesc);
}



TFSCORE_API(DWORD) TFSResumeService(LPCTSTR pszComputer, LPCTSTR pszServiceName, LPCTSTR pszServiceDesc)
{
    return ResumeSCMService(pszComputer, pszServiceName, pszServiceDesc);
}


DWORD
PauseSCMService
(
        LPCTSTR pszComputer,
        LPCTSTR pszServiceName,
        LPCTSTR pszServiceDesc
)
{
    DWORD       err = 0;
        SC_HANDLE       hScManager;

    //
    // Open the SCManager so that we can try to stop the service
    //
        hScManager = ::OpenSCManager(pszComputer, NULL, SC_MANAGER_CONNECT );
        if (hScManager == NULL)
        {
                //
                // Possible Errors:
                //      ERROR_ACCESS_DENIED 
                //      ERROR_DATABASE_DOES_NOT_EXIST 
                //      ERROR_INVALID_PARAMETER                 
                //
                return GetLastError();
        }
        
        SC_HANDLE hService = ::OpenService(hScManager, pszServiceName, SERVICE_PAUSE_CONTINUE | SERVICE_QUERY_STATUS);
        if (hService == NULL)
        {
                //
                // Possible Errors:
                //      ERROR_ACCESS_DENIED 
                //      ERROR_INVALID_HANDLE 
                //      ERROR_INVALID_NAME 
                //      ERROR_SERVICE_DOES_NOT_EXIST    
                //
                err = GetLastError();
                ::CloseServiceHandle(hScManager);
                
                return err;
        }

        SERVICE_STATUS serviceStatus;
        if (!::ControlService(hService, SERVICE_CONTROL_PAUSE, &serviceStatus)) 
        {
                //
                // Possible Errors:
                //  ERROR_ACCESS_DENIED 
                //  ERROR_DEPENDENT_SERVICES_RUNNING 
                //  ERROR_INVALID_SERVICE_CONTROL 
                //  ERROR_SERVICE_CANNOT_ACCEPT_CTRL 
                //  ERROR_SERVICE_NOT_ACTIVE 
                //  ERROR_SERVICE_REQUEST_TIMEOUT 
                //
                err = GetLastError();
                ::CloseServiceHandle(hService);
                ::CloseServiceHandle(hScManager);
                
                return err;
        }

#if 0
        if ( serviceStatus.dwCurrentState != SERVICE_STOPPED )
        {
                // 
                // Put up the dialog with the funky spinning thing to 
                // let the user know that something is happening
                //
                CServiceCtrlDlg dlgServiceCtrl(hService, pszComputer, pszServiceDesc, FALSE);

                dlgServiceCtrl.DoModal();
        err = dlgServiceCtrl.m_dwErr;
        }
#endif

        //
        // Everything stopped ok, close up and get going
        //
        ::CloseServiceHandle(hService);
        ::CloseServiceHandle(hScManager);

    return err;
}

DWORD
ResumeSCMService
(
        LPCTSTR pszComputer,
        LPCTSTR pszServiceName,
        LPCTSTR pszServiceDesc
)
{
    DWORD       err = 0;
        SC_HANDLE       hScManager;

    //
    // Open the SCManager so that we can try to stop the service
    //
        hScManager = ::OpenSCManager(pszComputer, NULL, SC_MANAGER_CONNECT );
        if (hScManager == NULL)
        {
                //
                // Possible Errors:
                //      ERROR_ACCESS_DENIED 
                //      ERROR_DATABASE_DOES_NOT_EXIST 
                //      ERROR_INVALID_PARAMETER                 
                //
                return GetLastError();
        }
        
        SC_HANDLE hService = ::OpenService(hScManager, pszServiceName, SERVICE_PAUSE_CONTINUE | SERVICE_QUERY_STATUS);
        if (hService == NULL)
        {
                //
                // Possible Errors:
                //      ERROR_ACCESS_DENIED 
                //      ERROR_INVALID_HANDLE 
                //      ERROR_INVALID_NAME 
                //      ERROR_SERVICE_DOES_NOT_EXIST    
                //
                err = GetLastError();
                ::CloseServiceHandle(hScManager);
                
                return err;
        }

        SERVICE_STATUS serviceStatus;
        if (!::ControlService(hService, SERVICE_CONTROL_CONTINUE, &serviceStatus)) 
        {
                //
                // Possible Errors:
                //  ERROR_ACCESS_DENIED 
                //  ERROR_DEPENDENT_SERVICES_RUNNING 
                //  ERROR_INVALID_SERVICE_CONTROL 
                //  ERROR_SERVICE_CANNOT_ACCEPT_CTRL 
                //  ERROR_SERVICE_NOT_ACTIVE 
                //  ERROR_SERVICE_REQUEST_TIMEOUT 
                //
                err = GetLastError();
                ::CloseServiceHandle(hService);
                ::CloseServiceHandle(hScManager);
                
                return err;
        }
#if 0
        if ( serviceStatus.dwCurrentState != SERVICE_STOPPED )
        {
                // 
                // Put up the dialog with the funky spinning thing to 
                // let the user know that something is happening
                //
                CServiceCtrlDlg dlgServiceCtrl(hService, pszComputer, pszServiceDesc, FALSE);

                dlgServiceCtrl.DoModal();
        err = dlgServiceCtrl.m_dwErr;
        }
#endif

        //
        // Everything stopped ok, close up and get going
        //
        ::CloseServiceHandle(hService);
        ::CloseServiceHandle(hScManager);

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\oleint.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       oleint.h
//
//--------------------------------------------------------------------------

/*---------------------------------------------------------------------

	OLEINT.H

		Helpful Macros to declare ole interfaces

 	Authors:
		MFH		Matthew F. Hillman

	Contents:
		Definitions for various Ren interfaces

	History:
		02/21/93 mfh	Created.
		10/24/95	v-ronaar DBCS_FILE_CHECK
  ---------------------------------------------------------------------*/
#ifdef _OLEINT_H
#error oleint.h included twice!
#else
#define _OLEINT_H

#if _MSC_VER >= 1000	// VC 5.0 or later
#pragma once
#endif

#ifndef WIN16
#define INITGUID
#endif

#ifndef _OLE2_H_
#include <ole2.h>
#endif

#undef IMPL
#define IMPL

#undef DeclareIUnknownMembers
#define DeclareIUnknownMembers(IPURE) \
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) IPURE; \
    STDMETHOD_(ULONG,AddRef) (THIS)  IPURE; \
    STDMETHOD_(ULONG,Release) (THIS) IPURE;	\

// Server Interfaces...

#define DeclareIOleObjectMembers(IPURE) \
    STDMETHOD(SetClientSite) (THIS_ LPOLECLIENTSITE pClientSite) IPURE;\
    STDMETHOD(GetClientSite) (THIS_ LPOLECLIENTSITE FAR* ppClientSite) IPURE;\
    STDMETHOD(SetHostNames) (THIS_ LPCOLESTR szContainerApp, LPCOLESTR szContainerObj) IPURE;\
    STDMETHOD(Close) (THIS_ DWORD dwSaveOption) IPURE;\
    STDMETHOD(SetMoniker) (THIS_ DWORD dwWhichMoniker, LPMONIKER pmk) IPURE;\
    STDMETHOD(GetMoniker) (THIS_ DWORD dwAssign, DWORD dwWhichMoniker, \
                LPMONIKER FAR* ppmk) IPURE;\
    STDMETHOD(InitFromData) (THIS_ LPDATAOBJECT pDataObject,\
                BOOL fCreation,\
                DWORD dwReserved) IPURE;\
    STDMETHOD(GetClipboardData) (THIS_ DWORD dwReserved, \
                LPDATAOBJECT FAR* ppDataObject) IPURE;\
    STDMETHOD(DoVerb) (THIS_ LONG iVerb,\
                LPMSG lpmsg, \
                LPOLECLIENTSITE pActiveSite, \
                LONG lindex,\
                HWND hwndParent,\
                LPCRECT lprcPosRect) IPURE;\
    STDMETHOD(EnumVerbs) (THIS_ LPENUMOLEVERB FAR* ppenumOleVerb) IPURE;\
    STDMETHOD(Update) (THIS) IPURE;\
    STDMETHOD(IsUpToDate) (THIS) IPURE;\
    STDMETHOD(GetUserClassID) (THIS_ CLSID FAR* pClsid) IPURE;\
    STDMETHOD(GetUserType) (THIS_ DWORD dwFormOfType, LPOLESTR FAR* pszUserType) IPURE;\
    STDMETHOD(SetExtent) (THIS_ DWORD dwDrawAspect, LPSIZEL lpsizel) IPURE;\
    STDMETHOD(GetExtent) (THIS_ DWORD dwDrawAspect, LPSIZEL lpsizel) IPURE;\
    STDMETHOD(Advise)(THIS_ LPADVISESINK pAdvSink, DWORD FAR* pdwConnection) IPURE;\
    STDMETHOD(Unadvise)(THIS_ DWORD dwConnection) IPURE;\
    STDMETHOD(EnumAdvise) (THIS_ LPENUMSTATDATA FAR* ppenumAdvise) IPURE;\
    STDMETHOD(GetMiscStatus) (THIS_ DWORD dwAspect, DWORD FAR* pdwStatus) IPURE;\
    STDMETHOD(SetColorScheme) (THIS_ LPLOGPALETTE lpLogpal) IPURE;\

#define DeclareIViewObjectMembers(IPURE)\
    STDMETHOD(Draw) (THIS_ DWORD dwDrawAspect, LONG lindex,\
                    void FAR* pvAspect, DVTARGETDEVICE FAR * ptd,\
                    HDC hicTargetDev,\
                    HDC hdcDraw, \
                    LPCRECTL lprcBounds, \
                    LPCRECTL lprcWBounds,\
                    BOOL (CALLBACK * pfnContinue) (DWORD), \
                    DWORD dwContinue) IPURE;\
    STDMETHOD(GetColorSet) (THIS_ DWORD dwDrawAspect, LONG lindex,\
                    void FAR* pvAspect, DVTARGETDEVICE FAR * ptd,\
                    HDC hicTargetDev,\
                    LPLOGPALETTE FAR* ppColorSet) IPURE;\
    STDMETHOD(Freeze)(THIS_ DWORD dwDrawAspect, LONG lindex, \
                    void FAR* pvAspect,\
                    DWORD FAR* pdwFreeze) IPURE;\
    STDMETHOD(Unfreeze) (THIS_ DWORD dwFreeze) IPURE;\
    STDMETHOD(SetAdvise) (THIS_ DWORD aspects, DWORD advf, \
                    LPADVISESINK pAdvSink) IPURE;\
    STDMETHOD(GetAdvise) (THIS_ DWORD FAR* pAspects, DWORD FAR* pAdvf, \
                    LPADVISESINK FAR* ppAdvSink) IPURE;\

#define DeclareIViewObject2Members(IPURE)\
    STDMETHOD(Draw) (THIS_ DWORD dwDrawAspect, LONG lindex,\
                    void FAR* pvAspect, DVTARGETDEVICE FAR * ptd,\
                    HDC hicTargetDev,\
                    HDC hdcDraw, \
                    LPCRECTL lprcBounds, \
                    LPCRECTL lprcWBounds,\
                    BOOL (CALLBACK * pfnContinue) (DWORD), \
                    DWORD dwContinue) IPURE;\
    STDMETHOD(GetColorSet) (THIS_ DWORD dwDrawAspect, LONG lindex,\
                    void FAR* pvAspect, DVTARGETDEVICE FAR * ptd,\
                    HDC hicTargetDev,\
                    LPLOGPALETTE FAR* ppColorSet) IPURE;\
    STDMETHOD(Freeze)(THIS_ DWORD dwDrawAspect, LONG lindex, \
                    void FAR* pvAspect,\
                    DWORD FAR* pdwFreeze) IPURE;\
    STDMETHOD(Unfreeze) (THIS_ DWORD dwFreeze) IPURE;\
    STDMETHOD(SetAdvise) (THIS_ DWORD aspects, DWORD advf, \
                    LPADVISESINK pAdvSink) IPURE;\
    STDMETHOD(GetAdvise) (THIS_ DWORD FAR* pAspects, DWORD FAR* pAdvf, \
                    LPADVISESINK FAR* ppAdvSink) IPURE;\
    STDMETHOD(GetExtent) (THIS_ DWORD dwAspect, LONG lindex, \
    				DVTARGETDEVICE *ptd, LPSIZEL lpsizel) IPURE;\

#define DeclareIDataObjectMembers(IPURE) \
    STDMETHOD(GetData) (THIS_ LPFORMATETC pformatetcIn,\
                            LPSTGMEDIUM pmedium ) IPURE;\
    STDMETHOD(GetDataHere) (THIS_ LPFORMATETC pformatetc,\
                            LPSTGMEDIUM pmedium ) IPURE;\
    STDMETHOD(QueryGetData) (THIS_ LPFORMATETC pformatetc ) IPURE;\
    STDMETHOD(GetCanonicalFormatEtc) (THIS_ LPFORMATETC pformatetc,\
                            LPFORMATETC pformatetcOut) IPURE;\
    STDMETHOD(SetData) (THIS_ LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,\
                            BOOL fRelease) IPURE;\
    STDMETHOD(EnumFormatEtc) (THIS_ DWORD dwDirection,\
                            LPENUMFORMATETC FAR* ppenumFormatEtc) IPURE;\
    STDMETHOD(DAdvise) (THIS_ FORMATETC FAR* pFormatetc, DWORD advf, \
                    LPADVISESINK pAdvSink, DWORD FAR* pdwConnection) IPURE;\
    STDMETHOD(DUnadvise) (THIS_ DWORD dwConnection) IPURE;\
    STDMETHOD(EnumDAdvise) (THIS_ LPENUMSTATDATA FAR* ppenumAdvise) IPURE;\

#define DeclareIEnumFORMATETCMembers(IPURE) \
    STDMETHOD(Next) (THIS_ ULONG celt, FORMATETC FAR * rgelt, ULONG FAR* pceltFetched) IPURE; \
    STDMETHOD(Skip) (THIS_ ULONG celt) IPURE; \
    STDMETHOD(Reset) (THIS) IPURE; \
    STDMETHOD(Clone) (THIS_ IEnumFORMATETC FAR* FAR* ppenum) IPURE; \

#define DeclareIDropSourceMembers(IPURE) \
    STDMETHOD(QueryContinueDrag) (THIS_ BOOL fEscapePressed, DWORD grfKeyState) IPURE;\
    STDMETHOD(GiveFeedback) (THIS_ DWORD dwEffect) IPURE;\

#define DeclareIDropTargetMembers(IPURE) \
    STDMETHOD(DragEnter) (THIS_ LPDATAOBJECT pDataObj, DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect) IPURE;\
    STDMETHOD(DragOver) (THIS_ DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect) IPURE;\
    STDMETHOD(DragLeave) (THIS) IPURE;\
    STDMETHOD(Drop) (THIS_ LPDATAOBJECT pDataObj, DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect) IPURE;\

#define DeclareIPersistStorageMembers(IPURE) \
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) IPURE;\
    STDMETHOD(IsDirty) (THIS) IPURE;\
    STDMETHOD(InitNew) (THIS_ LPSTORAGE pStg) IPURE;\
    STDMETHOD(Load) (THIS_ LPSTORAGE pStg) IPURE;\
    STDMETHOD(Save) (THIS_ LPSTORAGE pStgSave, BOOL fSameAsLoad) IPURE;\
    STDMETHOD(SaveCompleted) (THIS_ LPSTORAGE pStgNew) IPURE;\
    STDMETHOD(HandsOffStorage) (THIS) IPURE;\

#define DeclareIPersistFileMembers(IPURE) \
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) IPURE;\
    STDMETHOD(IsDirty) (THIS) IPURE;\
    STDMETHOD(Load) (THIS_ LPCOLESTR lpszFileName, DWORD grfMode) IPURE;\
    STDMETHOD(Save) (THIS_ LPCOLESTR lpszFileName, BOOL fRemember) IPURE;\
    STDMETHOD(SaveCompleted) (THIS_ LPCOLESTR lpszFileName) IPURE;\
    STDMETHOD(GetCurFile) (THIS_ LPOLESTR FAR * lplpszFileName) IPURE;\

#define DeclareIPersistStreamMembers(IPURE) \
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) IPURE;\
    STDMETHOD(IsDirty) (THIS) IPURE;\
    STDMETHOD(Load) (THIS_ LPSTREAM pStm) IPURE;\
    STDMETHOD(Save) (THIS_ LPSTREAM pStm,\
                    BOOL fClearDirty) IPURE;\
    STDMETHOD(GetSizeMax) (THIS_ ULARGE_INTEGER FAR * pcbSize) IPURE;\
											
#define DeclareIPersistStreamInitMembers(IPURE) \
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) IPURE;\
    STDMETHOD(IsDirty) (THIS) IPURE;\
    STDMETHOD(Load) (THIS_ LPSTREAM pStm) IPURE;\
    STDMETHOD(Save) (THIS_ LPSTREAM pStm,\
                    BOOL fClearDirty) IPURE;\
    STDMETHOD(GetSizeMax) (THIS_ ULARGE_INTEGER FAR * pcbSize) IPURE;\
	STDMETHOD(InitNew) (THIS) IPURE; \

#define DeclareIOleInPlaceObjectMembers(IPURE)\
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) IPURE;\
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) IPURE;\
	\
    STDMETHOD(InPlaceDeactivate) (THIS) IPURE;\
    STDMETHOD(UIDeactivate) (THIS) IPURE;\
    STDMETHOD(SetObjectRects) (THIS_ LPCRECT lprcPosRect, \
                    LPCRECT lprcClipRect) IPURE;\
    STDMETHOD(ReactivateAndUndo) (THIS) IPURE;\

#define DeclareIOleInPlaceActiveObjectMembers(IPURE)\
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) IPURE;\
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) IPURE;\
	\
    STDMETHOD(TranslateAccelerator) (THIS_ LPMSG lpmsg) IPURE;\
    STDMETHOD(OnFrameWindowActivate) (THIS_ BOOL fActivate) IPURE;\
    STDMETHOD(OnDocWindowActivate) (THIS_ BOOL fActivate) IPURE;\
    STDMETHOD(ResizeBorder) (THIS_ LPCRECT lprectBorder, LPOLEINPLACEUIWINDOW lpUIWindow, BOOL fFrameWindow) IPURE;\
    STDMETHOD(EnableModeless) (THIS_ BOOL fEnable) IPURE;\

// Client Stuff....

#define DeclareIOleContainerMembers(IPURE)\
    STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPOLESTR lpszDisplayName,\
        ULONG FAR* pchEaten, LPMONIKER FAR* ppmkOut) IPURE;\
	\
    STDMETHOD(EnumObjects) ( DWORD grfFlags, LPENUMUNKNOWN FAR* ppenumUnknown) IPURE;\
    STDMETHOD(LockContainer) (THIS_ BOOL fLock) IPURE;\

#define DeclareIOleClientSiteMembers(IPURE)\
    STDMETHOD(SaveObject) (THIS) IPURE;\
    STDMETHOD(GetMoniker) (THIS_ DWORD dwAssign, DWORD dwWhichMoniker,\
                LPMONIKER FAR* ppmk) IPURE;\
    STDMETHOD(GetContainer) (THIS_ LPOLECONTAINER FAR* ppContainer) IPURE;\
    STDMETHOD(ShowObject) (THIS) IPURE;\
    STDMETHOD(OnShowWindow) (THIS_ BOOL fShow) IPURE;\
    STDMETHOD(RequestNewObjectLayout) (THIS) IPURE;\

#define DeclareIOleInPlaceSiteMembers(IPURE)\
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) IPURE;\
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) IPURE;\
	\
    STDMETHOD(CanInPlaceActivate) (THIS) IPURE;\
    STDMETHOD(OnInPlaceActivate) (THIS) IPURE;\
    STDMETHOD(OnUIActivate) (THIS) IPURE;\
    STDMETHOD(GetWindowContext) (THIS_ LPOLEINPLACEFRAME FAR *lplpFrame,\
						LPOLEINPLACEUIWINDOW  FAR* lplpDoc,\
                        LPRECT lprcPosRect,\
                        LPRECT lprcClipRect,\
                        LPOLEINPLACEFRAMEINFO lpFrameInfo) IPURE;\
    STDMETHOD(Scroll) (THIS_ SIZE scrollExtent) IPURE;\
    STDMETHOD(OnUIDeactivate) (THIS_ BOOL fUndoable) IPURE;\
    STDMETHOD(OnInPlaceDeactivate) (THIS) IPURE;\
    STDMETHOD(DiscardUndoState) (THIS) IPURE;\
    STDMETHOD(DeactivateAndUndo) (THIS) IPURE;\
    STDMETHOD(OnPosRectChange) (THIS_ LPCRECT lprcPosRect) IPURE;\

#define DeclareIOleInPlaceUIWindowMembers(IPURE)\
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) IPURE;\
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) IPURE;\
    STDMETHOD(GetBorder) (THIS_ LPRECT lprectBorder) IPURE;\
    STDMETHOD(RequestBorderSpace) (THIS_ LPCBORDERWIDTHS lpborderwidths) IPURE;\
    STDMETHOD(SetBorderSpace) (THIS_ LPCBORDERWIDTHS lpborderwidths) IPURE;\
    STDMETHOD(SetActiveObject) (THIS_ LPOLEINPLACEACTIVEOBJECT lpActiveObject,\
                        LPCOLESTR lpszObjName) IPURE;\

#define DeclareIOleInPlaceFrameMembers(IPURE)\
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) IPURE;\
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) IPURE;\
    STDMETHOD(GetBorder) (THIS_ LPRECT lprectBorder) IPURE;\
    STDMETHOD(RequestBorderSpace) (THIS_ LPCBORDERWIDTHS lpborderwidths) IPURE;\
    STDMETHOD(SetBorderSpace) (THIS_ LPCBORDERWIDTHS lpborderwidths) IPURE;\
    STDMETHOD(SetActiveObject) (THIS_ LPOLEINPLACEACTIVEOBJECT lpActiveObject,\
                    LPCOLESTR lpszObjName) IPURE;\
    STDMETHOD(InsertMenus) (THIS_ HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths) IPURE;\
    STDMETHOD(SetMenu) (THIS_ HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject) IPURE;\
    STDMETHOD(RemoveMenus) (THIS_ HMENU hmenuShared) IPURE;\
    STDMETHOD(SetStatusText) (THIS_ LPCOLESTR lpszStatusText) IPURE;\
    STDMETHOD(EnableModeless) (THIS_ BOOL fEnable) IPURE;\
    STDMETHOD(TranslateAccelerator) (THIS_ LPMSG lpmsg, WORD wID) IPURE;\

#define DeclareIStreamMembers(IPURE)\
    STDMETHOD(Read) (THIS_ VOID HUGEP *pv, ULONG cb, ULONG FAR *pcbRead) IPURE;\
    STDMETHOD(Write) (THIS_ VOID const HUGEP *pv,ULONG cb,ULONG FAR *pcbWritten) IPURE;\
    STDMETHOD(Seek) (THIS_ LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER FAR *plibNewPosition) IPURE;\
    STDMETHOD(SetSize) (THIS_ ULARGE_INTEGER libNewSize) IPURE;\
    STDMETHOD(CopyTo) (THIS_ IStream FAR *pstm,ULARGE_INTEGER cb,ULARGE_INTEGER FAR *pcbRead,ULARGE_INTEGER FAR *pcbWritten) IPURE;\
    STDMETHOD(Commit) (THIS_ DWORD grfCommitFlags) IPURE;\
    STDMETHOD(Revert) (THIS) IPURE;\
    STDMETHOD(LockRegion) (THIS_ ULARGE_INTEGER libOffset,ULARGE_INTEGER cb,DWORD dwLockType) IPURE;\
    STDMETHOD(UnlockRegion) (THIS_ ULARGE_INTEGER libOffset,ULARGE_INTEGER cb,DWORD dwLockType) IPURE;\
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag) IPURE;\
    STDMETHOD(Clone)(THIS_ IStream FAR * FAR *ppstm) IPURE;\

#define DeclareIStorageMembers(IPURE)\
	STDMETHOD(CreateStream) (THIS_ const OLECHAR FAR *pwcsName, DWORD grfMode, DWORD reserved1, DWORD reserved2, IStream FAR * FAR *ppstm) IPURE; \
	STDMETHOD(OpenStream) 	(THIS_ const OLECHAR FAR *pwcsName, void FAR *reserved1, DWORD grfMode, DWORD reserved2, IStream FAR * FAR *ppstm) IPURE; \
	STDMETHOD(CreateStorage)(THIS_ const OLECHAR FAR *pwcsName, DWORD grfMode, DWORD dwStgFmt, DWORD reserved2, IStorage FAR * FAR *ppstg) IPURE; \
	STDMETHOD(OpenStorage)	(THIS_ const OLECHAR FAR *pwcsName, IStorage FAR *pstgPriority, DWORD grfMode, SNB snbExclude, DWORD reserved, IStorage FAR * FAR *ppstg) IPURE;\
	STDMETHOD(CopyTo)		(THIS_ DWORD ciidExclude, const IID FAR *rgiidExclude, SNB snbExclude, IStorage FAR *pstgDest) IPURE;\
	STDMETHOD(MoveElementTo)(THIS_ const OLECHAR FAR *pwcsName, IStorage FAR *pstgDest, const OLECHAR FAR *pwcsNewName, DWORD grfFlags) IPURE;\
	STDMETHOD(Commit)		(THIS_ DWORD grfCommitFlags) IPURE;\
	STDMETHOD(Revert)		(THIS_) IPURE;\
	STDMETHOD(EnumElements)	(THIS_ DWORD reserved1, void FAR *reserved2, DWORD reserved3, IEnumSTATSTG FAR * FAR *ppenum) IPURE;\
	STDMETHOD(DestroyElement)(THIS_ const OLECHAR FAR *pwcsName) IPURE;\
	STDMETHOD(RenameElement)(THIS_ const OLECHAR FAR *pwcsOldName, const OLECHAR FAR *pwcsNewName) IPURE;\
    STDMETHOD(SetElementTimes)(THIS_ const OLECHAR FAR *pwcsName, const FILETIME FAR *pctime, const FILETIME FAR *patime, const FILETIME FAR *pmtime) IPURE;\
	STDMETHOD(SetClass)		(THIS_ REFCLSID clsid) IPURE;\
	STDMETHOD(SetStateBits)	(THIS_ DWORD grfStateBits, DWORD grfMask) IPURE;\
	STDMETHOD(Stat)			(THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag) IPURE;\

#define DeclareIClassFactoryMembers(IPURE) \
		STDMETHOD(CreateInstance)(THIS_ IUnknown *punkOuter, REFIID riid,\
				void **ppvObj) IPURE;\
		STDMETHOD(LockServer)(THIS_ BOOL fLock) IPURE;\

// Moniker stuff....

#define DeclareIMonikerMembers(IPURE)\
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) IPURE;\
    STDMETHOD(IsDirty) (THIS) IPURE;\
    STDMETHOD(Load) (THIS_ LPSTREAM pStm) IPURE;\
    STDMETHOD(Save) (THIS_ LPSTREAM pStm,\
                    BOOL fClearDirty) IPURE;\
    STDMETHOD(GetSizeMax) (THIS_ ULARGE_INTEGER FAR * pcbSize) IPURE;\
    STDMETHOD(BindToObject) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,\
        REFIID riidResult, LPVOID FAR* ppvResult) IPURE;\
    STDMETHOD(BindToStorage) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,\
        REFIID riid, LPVOID FAR* ppvObj) IPURE;\
    STDMETHOD(Reduce) (THIS_ LPBC pbc, DWORD dwReduceHowFar, LPMONIKER FAR*\
        ppmkToLeft, LPMONIKER FAR * ppmkReduced) IPURE;\
    STDMETHOD(ComposeWith) (THIS_ LPMONIKER pmkRight, BOOL fOnlyIfNotGeneric,\
        LPMONIKER FAR* ppmkComposite) IPURE;\
    STDMETHOD(Enum) (THIS_ BOOL fForward, LPENUMMONIKER FAR* ppenumMoniker)\
        IPURE;\
    STDMETHOD(IsEqual) (THIS_ LPMONIKER pmkOtherMoniker) IPURE;\
    STDMETHOD(Hash) (THIS_ LPDWORD pdwHash) IPURE;\
    STDMETHOD(IsRunning) (THIS_ LPBC pbc, LPMONIKER pmkToLeft, LPMONIKER\
        pmkNewlyRunning) IPURE;\
    STDMETHOD(GetTimeOfLastChange) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,\
        FILETIME FAR* pfiletime) IPURE;\
    STDMETHOD(Inverse) (THIS_ LPMONIKER FAR* ppmk) IPURE;\
    STDMETHOD(CommonPrefixWith) (THIS_ LPMONIKER pmkOther, LPMONIKER FAR*\
        ppmkPrefix) IPURE;\
    STDMETHOD(RelativePathTo) (THIS_ LPMONIKER pmkOther, LPMONIKER FAR*\
        ppmkRelPath) IPURE;\
    STDMETHOD(GetDisplayName) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,\
        LPOLESTR FAR* lplpszDisplayName) IPURE;\
    STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,\
        LPOLESTR lpszDisplayName, ULONG FAR* pchEaten,\
        LPMONIKER FAR* ppmkOut) IPURE;\
    STDMETHOD(IsSystemMoniker) (THIS_ LPDWORD pdwMksys) IPURE;\


#define DeclareILockBytesMembers(IPURE)\
    STDMETHOD(ReadAt) (THIS_ ULARGE_INTEGER ulOffset, VOID HUGEP *pv,\
			ULONG cb, ULONG *pcbRead) IPURE;\
    STDMETHOD(WriteAt) (THIS_ ULARGE_INTEGER ulOffset, VOID const HUGEP *pv,\
			ULONG cb, ULONG *pcbWritten) IPURE;\
    STDMETHOD(Flush) (THIS) IPURE;\
    STDMETHOD(SetSize) (THIS_ ULARGE_INTEGER cb) IPURE;\
    STDMETHOD(LockRegion) (THIS_ ULARGE_INTEGER libOffset,\
			ULARGE_INTEGER cb, DWORD dwLockType) IPURE;\
    STDMETHOD(UnlockRegion) (THIS_ ULARGE_INTEGER libOffset,\
			ULARGE_INTEGER cb, DWORD dwLockType) IPURE;\
    STDMETHOD(Stat) (THIS_ STATSTG *pstatstg, DWORD grfStatFlag) IPURE;\

#define DeclareIAdviseSinkMembers(IPURE) \
	STDMETHOD_(void,OnDataChange) (THIS_ FORMATETC FAR* pFormatetc, \
			STGMEDIUM FAR* pmedium) IPURE; \
	STDMETHOD_(void,OnViewChange) (THIS_ DWORD dwAspect, \
			LONG lindex) IPURE; \
	STDMETHOD_(void,OnRename) (THIS_ LPMONIKER pmk) IPURE; \
	STDMETHOD_(void,OnSave) (THIS) IPURE; \
	STDMETHOD_(void,OnClose) (THIS) IPURE; \

#define DeclareIOleControlMembers(IPURE) \
	STDMETHOD(GetControlInfo)(THIS_ LPCONTROLINFO pCL) IPURE; \
	STDMETHOD(OnMnemonic)(THIS_ LPMSG pMsg) IPURE; \
	STDMETHOD(OnAmbientPropertyChange)(THIS_ DISPID dispid) IPURE; \
	STDMETHOD(FreezeEvents)(THIS_ BOOL fFreeze) IPURE; \

#define DeclareIOleCacheMembers(IPURE) \
	STDMETHOD(Cache)(THIS_ FORMATETC *, DWORD, DWORD *) IPURE; \
	STDMETHOD(Uncache)(THIS_ DWORD) IPURE; \
	STDMETHOD(EnumCache)(THIS_ IEnumSTATDATA **) IPURE; \
	STDMETHOD(InitCache)(THIS_ IDataObject *) IPURE; \
	STDMETHOD(SetData)(THIS_ FORMATETC *, STGMEDIUM *, BOOL) IPURE; \

#define DeclareIExternalConnectionMembers(IPURE) \
    STDMETHOD_(DWORD,AddConnection) (THIS_ DWORD, DWORD)  IPURE; \
    STDMETHOD_(DWORD,ReleaseConnection) (THIS_ DWORD, DWORD, BOOL) IPURE;	\

#define DeclareIMAPIViewAdviseSinkMembers(IPURE) \
	STDMETHOD(OnShutdown)(THIS) IPURE; \
	STDMETHOD(OnNewMessage)(THIS) IPURE; \
	STDMETHOD(OnPrint)(THIS_ ULONG dwPageNumber, HRESULT hrStatus) IPURE; \
	STDMETHOD(OnSubmitted)(THIS) IPURE; \
	STDMETHOD(OnSaved)(THIS) IPURE; \

#endif /* _OLEINT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\ipaddr.h ===
/* Copyright (C) Microsoft Corporation, 1991 - 1999 , all rights reserved

    ipaddr.h - TCP/IP Address custom control, global definitions

    November 10, 1992   - Greg Strange
    December 13, 1993   - Ronald Meijer - Added wildcard & readonly styles
    April    28, 1994   - Ronald Meijer - Added IP_SETFIELD
*/
#if !defined(_IPADDR_H_)
#define _IPADDR_H_

#if _MSC_VER >= 1000	// VC 5.0 or later
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif
   
#ifndef _WINSOCKAPI_
#include "winsock.h"
#endif


// Messages sent to IPAddress controls

#define IP_CLEARADDRESS WM_USER+100 // No parameters
#define IP_SETADDRESS   WM_USER+101 // lparam = TCP/IP address
#define IP_GETADDRESS   WM_USER+102 // lresult = TCP/IP address
#define IP_SETRANGE     WM_USER+103 // wparam = field, lparam = range
#define IP_SETFOCUS     WM_USER+104 // wparam = field
#define IP_SETMODIFY    WM_USER+105 // wparam = TRUE/FALSE
#define IP_GETMODIFY    WM_USER+106 // return TRUE/FALSE
#define IP_GETMASK      WM_USER+107 // Return bitfield indicating which fields are masks
#define IP_SETMASK      WM_USER+108 // Set the mask bitfield and address
#define IP_SETFIELD     WM_USER+109 // wparam = field, lparam = value or -1
#define IP_SETREADONLY  WM_USER+110 // if wparam = 1, set read-only flag, re-set it otherwise
#define IP_ISBLANK		WM_USER+111 // no parameters

//
// IP Styles:
//

#define IPS_ALLOWWILDCARDS 0x00000001L  // Allow the use of wildcard characters.
#define IPS_READONLY       0x00000800L  // Do not allow editing.  Same as ES_READONLY

// Extended style bit causes the ip address control to 
// correct the ip address so that it is contiguous (for submasks)
#define IPADDR_EX_STYLE_CONTIGUOUS 0x1


// The following is a useful macro for passing the range values in the
// IP_SETRANGE message.

#define MAKERANGE(low, high)    ((LPARAM)(WORD)(((BYTE)(high) << 8) + (BYTE)(low)))

// And this is a useful macro for making the IP Address to be passed
// as a LPARAM.

// #define MAKEIPADDRESS(b1,b2,b3,b4)  ((DWORD)(((DWORD)(b1)<<24)+((DWORD)(b2)<<16)+((DWORD)(b3)<<8)+((DWORD)(b4))))

// Get individual number
#define FIRST_IPADDRESS(x)  ((x>>24) & 0xff)
#define SECOND_IPADDRESS(x) ((x>>16) & 0xff)
#define THIRD_IPADDRESS(x)  ((x>>8) & 0xff)
#define FOURTH_IPADDRESS(x) (x & 0xff)

// If you statically link ipaddr.obj, then call this function during
// initialization.  If you use the DLL, then it is called automatically
// when you load the DLL.

#define DLL_BASED

DLL_BASED int FAR WINAPI IPAddrInit(HINSTANCE hInstance);



// Some utility functions (used for unicode mainly)
#ifndef UNICODE
#define INET_NTOA(a)    inet_ntoa(*(struct in_addr *)&(a))
#define INET_ADDR       inet_addr
#else
#define INET_NTOA(a)    inet_ntoaw(*(struct in_addr *)&(a))
#define INET_ADDR       inet_addrw
#endif

//----------------------------------------------------------------------------
// Functions:   inet_ntoaw
//              inet_addrw
//
// Unicode versions of IP-address conversion functions.
//----------------------------------------------------------------------------

__declspec(dllexport) WCHAR* WINAPI
inet_ntoaw(
    struct in_addr      dwAddress );

__declspec(dllexport) DWORD WINAPI
inet_addrw(
    LPCWSTR             szAddress );


// Use this function to force the ip address entered to 
// be contiguous (series of 1's followed by a series of 0's).
// This is useful for entering valid submasks
//
// Returns NO_ERROR if successful, error code otherwise
//
__declspec(dllexport) DWORD APIENTRY
IpAddr_ForceContiguous(
    HWND hwndIpAddr );

#ifdef __cplusplus
};
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\ipaddr.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1995 - 1999 **/
/**********************************************************************/

/*
    FILE HISTORY:
        
    ipaddr.c - TCP/IP Address custom control

    November 9, 1992    Greg Strange
    December 13, 1993   Ronald Meijer - Wildcard and readonly style bits
    April    18, 1994   Ronald Meijer - Added IP_SETREADONLY, IP_SETFIELD
*/
#include <stdafx.h>
//nclude <windows.h>
//nclude <stdlib.h>
#ifdef IP_CUST_CTRL
#include <custcntl.h>
#endif
#include "ipaddr.h"             // Global IPAddress definitions
#include "ipadd.h"              // Internal IPAddress definitions

/* global static variables */
static HINSTANCE           s_hLibInstance = NULL;
#ifdef IP_CUST_CTRL
HANDLE           hLibData;
LPFNSTRTOID      lpfnVerId;
LPFNIDTOSTR      lpfnIdStr;
#endif

/*
    Strings loaded at initialization.
*/
TCHAR szNoMem[MAX_IPNOMEMSTRING];       // Out of memory string
TCHAR szCaption[MAX_IPCAPTION];         // Alert message box caption

#define IPADDRESS_CLASS            TEXT("IPAddress")

// The character that is displayed between address fields.
#define FILLER          TEXT('.')
#define SZFILLER        TEXT(".")
#define SPACE           TEXT(' ')
#define WILDCARD        TEXT('*')
#define SZWILDCARD      TEXT("  *")
#define BACK_SPACE      8

// Min, max values
#define NUM_FIELDS      4
#define CHARS_PER_FIELD 3
#define HEAD_ROOM       1       // space at top of control
#define LEAD_ROOM       1       // space at front of control
#define MIN_FIELD_VALUE 0       // default minimum allowable field value
#define MAX_FIELD_VALUE 255     // default maximum allowable field value


// All the information unique to one control is stuffed in one of these
// structures in global memory and the handle to the memory is stored in the
// Windows extra space.

typedef struct tagFIELD {
    HWND		hWnd;
    WNDPROC     lpfnWndProc;
    BYTE        byLow;  // lowest allowed value for this field.
    BYTE        byHigh; // Highest allowed value for this field.
    HFONT		hFont; // Handle to the logical Font
} FIELD;

typedef struct tagCONTROL {
    HWND        hwndParent;
    UINT        uiFieldWidth;
    UINT        uiFillerWidth;
    BOOL        fEnabled;
    BOOL        fPainted;
    BOOL        fAllowWildcards;
    BOOL        fReadOnly;
    BOOL        fInMessageBox;  // Set when a message box is displayed so that
                                // we don't send a EN_KILLFOCUS message when
                                // we receive the EN_KILLFOCUS message for the
                                // current field.
    BOOL        fModified ; // Indicates whether field has changed
    FIELD       Children[NUM_FIELDS];
} CONTROL;


// The following macros extract and store the CONTROL structure for a control.
#define    IPADDRESS_EXTRA            (2 * sizeof(LONG_PTR))

#define GET_CONTROL_HANDLE(hWnd)        ((HGLOBAL)(GetWindowLongPtr((hWnd), GWLP_USERDATA)))
#define SAVE_CONTROL_HANDLE(hWnd,x)     (SetWindowLongPtr((hWnd), GWLP_USERDATA, (LONG_PTR)x))
#define IPADDR_GET_SUBSTYLE(hwnd) (GetWindowLongPtr((hwnd), sizeof(LONG_PTR) * 1))
#define IPADDR_SET_SUBSTYLE(hwnd, style) (SetWindowLongPtr((hwnd), sizeof(LONG_PTR) * 1, (style)))


/* internal IPAddress function prototypes */
#ifdef IP_CUST_CTRL
BOOL FAR WINAPI IPAddressDlgFn( HWND, WORD, WORD, LONG );
void GetStyleBit(HWND, LPCTLSTYLE, int, DWORD);
#endif
LRESULT FAR WINAPI IPAddressWndFn( HWND, UINT, WPARAM, LPARAM );
LRESULT FAR WINAPI IPAddressFieldProc(HWND, UINT, WPARAM, LPARAM);
BOOL SwitchFields(CONTROL FAR *, int, int, WORD, WORD);
void EnterField(FIELD FAR *, WORD, WORD);
BOOL ExitField(CONTROL FAR *, int iField);
int GetFieldValue(FIELD FAR *);
int FAR CDECL IPAlertPrintf(HWND hwndParent, UINT ids, int iCurrent, int iLow, int iHigh);
BOOL IPLoadOem(HINSTANCE hInst, UINT idResource, TCHAR* lpszBuffer, int cbBuffer);



/*
    LibMain() - Called once before anything else.

    call
        hInstance = library instance handle
        wDataSegment = library data segment
        wHeapSize = default heap size
        lpszCmdLine = command line arguements

    When this file is compiled as a DLL, this function is called by Libentry()
    when the library is first loaded.  See the SDK docs for details.
*/
#ifdef IPDLL
/*
//DLL_BASED BOOL WINAPI IpAddrDllEntry (
DLL_BASED BOOL WINAPI DllMain (
   HINSTANCE hDll,
   DWORD dwReason,
   LPVOID lpReserved
   )
{
    BOOL bResult = TRUE ;

    switch ( dwReason )
    {
        case DLL_PROCESS_ATTACH:
            bResult = IPAddrInit( hDll ) ;
            break ;
        case DLL_THREAD_ATTACH:
            break ;
        case DLL_PROCESS_DETACH:
            break ;
        case DLL_THREAD_DETACH:
            break ;
    }

    return bResult ;
}
*/
#endif

#ifdef FE_SB
BYTE
CodePageToCharSet(
    UINT CodePage
    )
{
    CHARSETINFO csi;

    if (!TranslateCharsetInfo((DWORD *)ULongToPtr(CodePage), &csi, TCI_SRCCODEPAGE))
        csi.ciCharset = OEM_CHARSET;

    return (BYTE)csi.ciCharset;
}
#endif // FE_SB

LOGFONT logfont;

void SetDefaultFont( )
{
    LANGID langid = PRIMARYLANGID(GetThreadLocale());
    BOOL fIsDbcs = (langid == LANG_CHINESE ||
                    langid == LANG_JAPANESE ||
                    langid == LANG_KOREAN);

    logfont.lfWidth            = 0;
    logfont.lfEscapement       = 0;
    logfont.lfOrientation      = 0;
    logfont.lfOutPrecision     = OUT_DEFAULT_PRECIS;
    logfont.lfClipPrecision    = CLIP_DEFAULT_PRECIS;
    logfont.lfQuality          = DEFAULT_QUALITY;
    logfont.lfPitchAndFamily   = VARIABLE_PITCH | FF_SWISS;
    logfont.lfUnderline        = 0;
    logfont.lfStrikeOut        = 0;
    logfont.lfItalic           = 0;
    logfont.lfWeight           = FW_NORMAL;
	HDC	hDC = GetDC(NULL);
    if (hDC)
    {
        if (fIsDbcs)
        {
            logfont.lfHeight       = -(9*GetDeviceCaps(hDC,LOGPIXELSY)/72);
            logfont.lfCharSet      = DEFAULT_CHARSET;
        }
        else 
        {
            logfont.lfHeight       = -(8*GetDeviceCaps(hDC,LOGPIXELSY)/72);
            logfont.lfCharSet      = ANSI_CHARSET;
        }
    //  logfont.lfHeight           = -(8*GetDeviceCaps(GetDC(NULL),LOGPIXELSY)/72);
    //fdef FE_SB
    //  logfont.lfCharSet          = CodePageToCharSet( GetACP() );
    //lse
    //  logfont.lfCharSet          = ANSI_CHARSET;
    //ndif
	    lstrcpy(logfont.lfFaceName, TEXT("MS Shell Dlg"));
	    ReleaseDC(NULL, hDC);
    }
}


/*
    IPAddrInit() - IPAddress custom control initialization
    call
        hInstance = library or application instance
    return
        TRUE on success, FALSE on failure.

    This function does all the one time initialization of IPAddress custom
    controls.  Specifically it creates the IPAddress window class.
*/

DLL_BASED int FAR WINAPI IPAddrInit(HINSTANCE hInstance)
{
    HGLOBAL            hClassStruct;
    LPWNDCLASS        lpClassStruct;

    /* register IPAddress window if necessary */
    if ( s_hLibInstance == NULL ) {

        /* allocate memory for class structure */
        hClassStruct = GlobalAlloc( GHND, (DWORD)sizeof(WNDCLASS) );
        if ( hClassStruct ) {

            /* lock it down */
            lpClassStruct = (LPWNDCLASS)GlobalLock( hClassStruct );
            if ( lpClassStruct ) {

                /* define class attributes */
                lpClassStruct->lpszClassName = IPADDRESS_CLASS;
                lpClassStruct->hCursor =       LoadCursor(NULL,IDC_IBEAM);
                lpClassStruct->lpszMenuName =  (LPCTSTR)NULL;
                lpClassStruct->style =         CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS|CS_GLOBALCLASS;
                lpClassStruct->lpfnWndProc =   IPAddressWndFn;
                lpClassStruct->hInstance =     hInstance;
                lpClassStruct->hIcon =         NULL;
                lpClassStruct->cbWndExtra =    IPADDRESS_EXTRA;
                lpClassStruct->hbrBackground = (HBRUSH)(COLOR_WINDOW + 1 );

                /* register IPAddress window class */
                s_hLibInstance = ( RegisterClass(lpClassStruct) ) ? hInstance : NULL;

                if (hInstance)
                {
                    /* Load caption and out of memory string before we're
                       out of memory. */
                    if (!IPLoadOem(hInstance, IDS_IPNOMEM, szNoMem,
                                sizeof(szNoMem) / sizeof(*szNoMem))
                        || !IPLoadOem(hInstance, IDS_IPMBCAPTION, szCaption,
                                sizeof(szCaption) / sizeof(*szCaption)))
                        return FALSE;
                }
                GlobalUnlock( hClassStruct );
            }
            GlobalFree( hClassStruct );
        }
    }
    SetDefaultFont();

    return s_hLibInstance != NULL ;
}


// Use this function to force the ip address entered to 
// be contiguous (series of 1's followed by a series of 0's).
// This is useful for entering valid submasks
//
// Returns NO_ERROR if successful, error code otherwise
//
DWORD APIENTRY IpAddr_ForceContiguous(HWND hwndIpAddr) {
    DWORD_PTR dwOldStyle;
    
    // Set the last error information so that we can
    // return an error correctly
    SetLastError(NO_ERROR);

    // Set the extended style of the given window so 
    // that it descriminates the address entered.
    dwOldStyle = IPADDR_GET_SUBSTYLE(hwndIpAddr);
    IPADDR_SET_SUBSTYLE(hwndIpAddr, dwOldStyle | IPADDR_EX_STYLE_CONTIGUOUS);

    return GetLastError();
}


/*
    IPAddressInfo() - Returns various bits of information about the control.

    returns
        A handle for a CtlInfo structure.

    This function is only included in the DLL and is used by the dialog
    editor.
*/
#ifdef IP_CUST_CTRL
HANDLE FAR WINAPI IPAddressInfo()
{
    HGLOBAL        hCtlInfo;
    LPCTLINFO    lpCtlInfo;

    /* allocate space for information structure */
    hCtlInfo = GlobalAlloc( GHND, (DWORD)sizeof(CTLINFO) );
    if ( hCtlInfo ) {

        /* attempt to lock it down */
        lpCtlInfo = (LPCTLINFO)GlobalLock( hCtlInfo );
        if ( lpCtlInfo ) {

            /* define the fixed portion of the structure */
            lpCtlInfo->wVersion = 100;
            lpCtlInfo->wCtlTypes = 1;
            lstrcpy( lpCtlInfo->szClass, IPADDRESS_CLASS );
            lstrcpy( lpCtlInfo->szTitle, TEXT("TCP/IP IP Address") );

            /* define the variable portion of the structure */
            lpCtlInfo->Type[0].wWidth = NUM_FIELDS*(CHARS_PER_FIELD+1) * 4 + 4;
            lpCtlInfo->Type[0].wHeight = 13;
            lpCtlInfo->Type[0].dwStyle = WS_CHILD | WS_TABSTOP;
            lstrcpy( lpCtlInfo->Type[0].szDescr, TEXT("IPAddress") );

            /* unlock it */
            GlobalUnlock( hCtlInfo );

        } else {
            GlobalFree( hCtlInfo );
            hCtlInfo = NULL;
        }

    }

    /* return result */
    return( hCtlInfo );
}
#endif


/*
    IPAddressStyle()
    call
        hWnd            handle of parent window
        hCtlStyle       handle to control style info
        lpfnVerifyId    pointer to the VerifyId function from dialog editor
        lpfnGetIDStr    pointer to the GetIdStr function from dialog editor

    This function is called by the dialog editor when the user double clicks
    on the custom control.  Or when the user chooses to edit the control's
    styles.
*/
#ifdef IP_CUST_CTRL
BOOL FAR WINAPI IPAddressStyle(
    HWND        hWnd,
    HANDLE      hCtlStyle,
    LPFNSTRTOID    lpfnVerifyId,
    LPFNIDTOSTR    lpfnGetIdStr )
{
    FARPROC       lpDlgFn;
    HANDLE        hNewCtlStyle;

    // initialization
    hLibData = hCtlStyle;
    lpfnVerId = lpfnVerifyId;
    lpfnIdStr = lpfnGetIdStr;

    // display dialog box
    lpDlgFn = MakeProcInstance( (FARPROC)IPAddressDlgFn, s_hLibInstance );
    hNewCtlStyle = ( DialogBox(s_hLibInstance,TEXT("IPAddressStyle"),hWnd,lpDlgFn) ) ? hLibData : NULL;
    FreeProcInstance( lpDlgFn );

    // return updated data block
    return( hNewCtlStyle );
}
#endif




/*
    IPAddressDlgFn() - Dialog editor style dialog

    hDlg        styles dialog box handle
    wMessage    window message
    wParam      word parameter
    lParam      long parameter

    This is the dialog function for the styles dialog that is displayed when
    the user wants to edit an IPAddress control's style from the dialog editor.
*/
#ifdef IP_CUST_CTRL
BOOL FAR WINAPI IPAddressDlgFn(
    HWND        hDlg,
    WORD        wMessage,
    WORD        wParam,
    LONG        lParam )
{
    BOOL            bResult;

    /* initialization */
    bResult = TRUE;

    /* process message */
    switch( wMessage )
    {
        case WM_INITDIALOG :
        {
            HANDLE        hCtlStyle;
            LPCTLSTYLE    lpCtlStyle;

            /* disable Ok button & save dialog data handle */
            hCtlStyle = hLibData;

            /* retrieve & display style parameters */
            if ( hCtlStyle ) {

                /* add handle to property list */
                SetProp( hDlg, MAKEINTRESOURCE(1), hCtlStyle );

                /* update dialog box fields */
                lpCtlStyle = (LPCTLSTYLE)GlobalLock( hCtlStyle );

                lstrcpy( lpCtlStyle->szClass, IPADDRESS_CLASS );
                SendDlgItemMessage(hDlg, ID_VISIBLE, BM_SETCHECK,
                        (WPARAM)((lpCtlStyle->dwStyle & WS_VISIBLE) != 0), 0L);
                SendDlgItemMessage(hDlg, ID_GROUP, BM_SETCHECK,
                        (WPARAM)((lpCtlStyle->dwStyle & WS_GROUP) != 0), 0L);
                SendDlgItemMessage(hDlg, ID_DISABLED, BM_SETCHECK,
                        (WPARAM)((lpCtlStyle->dwStyle & WS_DISABLED) != 0), 0L);
                SendDlgItemMessage(hDlg, ID_TABSTOP, BM_SETCHECK,
                        (WPARAM)((lpCtlStyle->dwStyle & WS_TABSTOP) != 0), 0L);
                GlobalUnlock( hCtlStyle );

            } else
                EndDialog( hDlg, FALSE );
        }
        break;

        case WM_COMMAND :

            switch( wParam )
            {
                case IDCANCEL:
                    RemoveProp( hDlg, MAKEINTRESOURCE(1) );
                    EndDialog( hDlg, FALSE );
                    break;

                case IDOK:
                {
                    HANDLE        hCtlStyle;
                    LPCTLSTYLE    lpCtlStyle;

                    hCtlStyle = GetProp( hDlg, MAKEINTRESOURCE(1) );
                    lpCtlStyle = (LPCTLSTYLE)GlobalLock( hCtlStyle );

                    GetStyleBit(hDlg, lpCtlStyle, ID_VISIBLE,  WS_VISIBLE);
                    GetStyleBit(hDlg, lpCtlStyle, ID_DISABLED, WS_DISABLED);
                    GetStyleBit(hDlg, lpCtlStyle, ID_GROUP,    WS_GROUP);
                    GetStyleBit(hDlg, lpCtlStyle, ID_TABSTOP,  WS_TABSTOP);

                    GlobalUnlock( hCtlStyle );

                    RemoveProp( hDlg, MAKEINTRESOURCE(1) );

                    hLibData = hCtlStyle;
                    EndDialog( hDlg, TRUE );
                }
                break;

                default :
                    bResult = FALSE;
                    break;
            }
            break;

        default :
            bResult = FALSE;
            break;
    }
    return( bResult );
}
#endif




/*
    Get the value of a check box and set the appropriate style bit.
*/
#ifdef IP_CUST_CTRL
void GetStyleBit(HWND hDlg, LPCTLSTYLE lpCtlStyle, int iControl, DWORD dwStyle)
{
    if (SendDlgItemMessage(hDlg, iControl, BM_GETSTATE, 0, 0L))
        lpCtlStyle->dwStyle |= dwStyle;
    else
        lpCtlStyle->dwStyle &= ~dwStyle;
}
#endif


/*
    IPAddressFlags()

    call
        wFlags          class style flags
        lpszString      class style string
        wMaxString      maximum size of class style string

  This function translates the class style flags provided into a
  corresponding text string for output to an RC file.  The general
  windows flags (contained in the low byte) are not interpreted,
  only those in the high byte.

  The value returned by this function is the library instance
  handle when sucessful, and NULL otherwise.
*/
#ifdef IP_CUST_CTRL
WORD FAR WINAPI IPAddressFlags(
    WORD        wFlags,
    LPSTR       lpszString,
    WORD        wMaxString )
{
    lpszString[0] = NULL;
    return( 0 );
}
#endif

// This function causes the ip address entered into hwndIpAddr to be
// corrected so that it is contiguous.
DWORD IpAddrMakeContiguous(HWND hwndIpAddr) {
    DWORD i, dwNewMask, dwMask;

    // Read in the current address
    SendMessage(hwndIpAddr, IP_GETADDRESS, 0, (LPARAM)&dwMask);

    // Find out where the first '1' is in binary going right to left
    dwNewMask = 0;
    for (i = 0; i < sizeof(dwMask)*8; i++) {
        dwNewMask |= 1 << i;
        if (dwNewMask & dwMask) {
            break;
        }
    }

    // At this point, dwNewMask is 000...0111...  If we inverse it, 
    // we get a mask that can be or'd with dwMask to fill in all of
    // the holes.
    dwNewMask = dwMask | ~dwNewMask;

    // If the new mask is different, correct it here
    if (dwMask != dwNewMask) {
//        WCHAR pszAddr[32];
//        wsprintfW(pszAddr, L"%d.%d.%d.%d", FIRST_IPADDRESS (dwNewMask),
//                                           SECOND_IPADDRESS(dwNewMask),
//                                           THIRD_IPADDRESS (dwNewMask),
//                                           FOURTH_IPADDRESS(dwNewMask));
		SendMessage(hwndIpAddr, IP_SETADDRESS, 0, (LPARAM) dwNewMask);
//        SendMessage(hwndIpAddr, IP_SETADDRESS, 0, (LPARAM)pszAddr);                                           
    }
    
    return NO_ERROR;
}


/*
    IPAddressWndFn() - Main window function for an IPAddress control.

    call
        hWnd    handle to IPAddress window
        wMsg    message number
        wParam  word parameter
        lParam  long parameter
*/
LRESULT FAR WINAPI IPAddressWndFn( HWND hWnd,
								   UINT wMsg,
								   WPARAM wParam,
								   LPARAM lParam )
{
    LONG_PTR lResult;
    HGLOBAL hControl;
    CONTROL *pControl;
    int i;

    lResult = TRUE;

    switch( wMsg )
    {

        case WM_SETTEXT:
            {
                static TCHAR szBuf[CHARS_PER_FIELD+1];
                DWORD dwValue[4];
                int nField, nPos;
                BOOL fFinish = FALSE;
                TCHAR *pszString = (TCHAR*)lParam;
                dwValue[0]=0;
                dwValue[1]=0;
                dwValue[2]=0;
                dwValue[3]=0;

                for( nField = 0, nPos = 0; !fFinish; nPos++)
                {
                    if (( pszString[nPos]<TEXT('0')) || (pszString[nPos]>TEXT('9')))
                    {
                        // not a number
                        nField++;
                        fFinish = (nField == 4);
                    }
                    else
                    {
                        dwValue[nField] *= 10;
                        dwValue[nField] += (pszString[nPos]-TEXT('0'));
                    }
                }

                hControl = GET_CONTROL_HANDLE(hWnd);
                pControl = (CONTROL *)GlobalLock(hControl);
                for (i = 0; i < NUM_FIELDS; ++i)
                {
                    if ( lstrcmp(pszString, TEXT("")) == 0 )
                    {
                        wsprintf(szBuf,TEXT(""));
                    }
                    else
                    {
                        wsprintf(szBuf, TEXT("%d"), dwValue[i]);
                    }
                    SendMessage(pControl->Children[i].hWnd, WM_SETTEXT,
                                0, (LPARAM) (LPSTR) szBuf);
                }
                GlobalUnlock(hControl);
            }
            break;
        case WM_GETTEXTLENGTH:
        case WM_GETTEXT:
            {
                int iFieldValue;
                int srcPos, desPos;
                DWORD dwValue[4];
                TCHAR pszResult[30];
                TCHAR *pszDest = (TCHAR *)lParam;

                hControl = GET_CONTROL_HANDLE(hWnd);
                pControl = (CONTROL *)GlobalLock(hControl);

                lResult = 0;
                dwValue[0] = 0;
                dwValue[1] = 0;
                dwValue[2] = 0;
                dwValue[3] = 0;
                for (i = 0; i < NUM_FIELDS; ++i)
                {
                    iFieldValue = GetFieldValue(&(pControl->Children[i]));
                    if (iFieldValue == -1)
                        iFieldValue = 0;
                    else
                        ++lResult;
                    dwValue[i] = iFieldValue;
                }
                wsprintf( pszResult, TEXT("%d.%d.%d.%d"), dwValue[0], dwValue[1], dwValue[2], dwValue[3] );
                if ( wMsg == WM_GETTEXTLENGTH )
                {
                    lResult = lstrlen( pszResult );
                }
                else
                {
                    for ( srcPos=0, desPos=0; (srcPos+1<(INT)wParam) && (pszResult[srcPos]!=TEXT('\0')); )
                    {
                        pszDest[desPos++] = pszResult[srcPos++];
                    }
                    pszDest[desPos]=TEXT('\0');
                    lResult = desPos;
                }
                GlobalUnlock(hControl);
            }
            break;

        case WM_GETDLGCODE :
            lResult = DLGC_WANTCHARS;
            break;

        case WM_CREATE : /* create pallette window */
            {
                HDC hdc;
                UINT uiFieldStart;
                FARPROC lpfnFieldProc;

                hControl = GlobalAlloc(GMEM_MOVEABLE, sizeof(CONTROL));
                if (hControl)
                {
                    HFONT OldFont;
                    RECT  rectClient;

                    #define LPCS    ((CREATESTRUCT *)lParam)

                    pControl = (CONTROL *)GlobalLock(hControl);
                    pControl->fEnabled = TRUE;
                    pControl->fPainted = FALSE;
                    pControl->fModified = FALSE ;
                    pControl->fInMessageBox = FALSE;
                    pControl->hwndParent = LPCS->hwndParent;
                    pControl->fAllowWildcards = (LPCS->style & IPS_ALLOWWILDCARDS);
                    pControl->fReadOnly = (LPCS->style & IPS_READONLY);

                    hdc = GetDC(hWnd);
                    if (hdc)
                    {
                        OldFont = (HFONT) SelectObject( hdc, CreateFontIndirect(&logfont) );
                        GetCharWidth(hdc, FILLER, FILLER,
                                                (int *)(&pControl->uiFillerWidth));
                        
                        HGDIOBJ hObj = SelectObject(hdc, OldFont );
                        if (hObj)
                            DeleteObject( hObj );
                        
                        ReleaseDC(hWnd, hdc);

	                    // we need to calculate this with the client rect
	                    // because we may have a 3d look and feel which makes 
	                    // the client area smaller than the window
	                    GetClientRect(hWnd, &rectClient);

	                    pControl->uiFieldWidth = (rectClient.right - rectClient.left
	                                          - LEAD_ROOM
	                                          - pControl->uiFillerWidth
	                                              *(NUM_FIELDS-1))
	                                                  / NUM_FIELDS;

	                    uiFieldStart = LEAD_ROOM;

	                    lpfnFieldProc = MakeProcInstance((FARPROC)IPAddressFieldProc,
	                                                 LPCS->hInstance);

	                    for (i = 0; i < NUM_FIELDS; ++i)
	                    {
	                        pControl->Children[i].byLow = MIN_FIELD_VALUE;
	                        pControl->Children[i].byHigh = MAX_FIELD_VALUE;

	                        pControl->Children[i].hWnd = CreateWindow(
	                                        TEXT("Edit"),
	                                        NULL,
	                                        WS_CHILD | WS_VISIBLE |
	                                        /*ES_MULTILINE |*/ ES_CENTER,
	                                        uiFieldStart,
	                                        HEAD_ROOM,
	                                        pControl->uiFieldWidth,
	                                        rectClient.bottom - rectClient.top - (HEAD_ROOM*2),
	                                        hWnd,
	                                        (HMENU)ULongToPtr(i),
	                                        LPCS->hInstance,
	                                        (LPVOID)ULongToPtr(NULL));

	                        SendMessage(pControl->Children[i].hWnd, EM_LIMITTEXT,
	                                CHARS_PER_FIELD, 0L);

				pControl->Children[i].hFont = CreateFontIndirect(&logfont);
				
	                        SendMessage(pControl->Children[i].hWnd, WM_SETFONT,
	                                (WPARAM)pControl->Children[i].hFont, TRUE);

	                        pControl->Children[i].lpfnWndProc =
	                            (WNDPROC)GetWindowLongPtr(pControl->Children[i].hWnd,
	                                                GWLP_WNDPROC);

	                        SetWindowLongPtr(pControl->Children[i].hWnd,
	                                  GWLP_WNDPROC, (LPARAM)lpfnFieldProc);

	                        uiFieldStart += pControl->uiFieldWidth
	                                    + pControl->uiFillerWidth;
	                    }

	                    #undef LPCS
	            	}

                    GlobalUnlock(hControl);
                    SAVE_CONTROL_HANDLE(hWnd, hControl);

                }
                else
                    DestroyWindow(hWnd);
            }
            lResult = 0;
            break;

        case WM_PAINT: /* paint control window */
            {
                PAINTSTRUCT Ps;
                RECT rect;
                UINT uiFieldStart;
                COLORREF TextColor;
                HFONT OldFont;
                HBRUSH hBrush;
                HBRUSH hOldBrush;
            
                BeginPaint(hWnd, (LPPAINTSTRUCT)&Ps);
                OldFont = (HFONT) SelectObject( Ps.hdc, CreateFontIndirect(&logfont));
                GetClientRect(hWnd, &rect);
                hControl = GET_CONTROL_HANDLE(hWnd);
                pControl = (CONTROL *)GlobalLock(hControl);

                // paint the background depending upon if the control is enabled
                if (pControl->fEnabled)
                    hBrush = CreateSolidBrush( GetSysColor( COLOR_WINDOW ));
                else
                    hBrush = CreateSolidBrush( GetSysColor( COLOR_BTNFACE ));

                hOldBrush = (HBRUSH) SelectObject( Ps.hdc, hBrush );

                if (!(GetWindowLong(hWnd, GWL_EXSTYLE) & WS_EX_CLIENTEDGE))
					Rectangle(Ps.hdc, 0, 0, rect.right, rect.bottom);
                else
                    FillRect(Ps.hdc, &rect, hBrush);

                HGDIOBJ hObj = SelectObject( Ps.hdc, hOldBrush );
                if (hObj)
                    DeleteObject( hObj );

                // now set the text color
                if (pControl->fEnabled)
                    TextColor = GetSysColor(COLOR_WINDOWTEXT);
                else
                    TextColor = GetSysColor(COLOR_GRAYTEXT);

                if (TextColor)
                    SetTextColor(Ps.hdc, TextColor);

                // and the background color
                if (pControl->fEnabled)
                    SetBkColor(Ps.hdc, GetSysColor(COLOR_WINDOW));
                else
                    SetBkColor(Ps.hdc, GetSysColor(COLOR_BTNFACE));

                uiFieldStart = pControl->uiFieldWidth + LEAD_ROOM;
                for (i = 0; i < NUM_FIELDS-1; ++i)
                {
                    TextOut(Ps.hdc, uiFieldStart, HEAD_ROOM, SZFILLER, 1);
                    uiFieldStart +=pControl->uiFieldWidth + pControl->uiFillerWidth;
                }

                pControl->fPainted = TRUE;

                GlobalUnlock(hControl);
                DeleteObject(SelectObject(Ps.hdc, OldFont));
                EndPaint(hWnd, &Ps);
            }
            break;

        case WM_SETFOCUS : /* get focus - display caret */
            hControl = GET_CONTROL_HANDLE(hWnd);
            pControl = (CONTROL *)GlobalLock(hControl);
            EnterField(&(pControl->Children[0]), 0, CHARS_PER_FIELD);
            GlobalUnlock(hControl);
            break;

        case WM_LBUTTONDOWN : /* left button depressed - fall through */
            SetFocus(hWnd);
            break;

        case WM_ENABLE:
            {
                hControl = GET_CONTROL_HANDLE(hWnd);
                pControl = (CONTROL *)GlobalLock(hControl);
                pControl->fEnabled = (BOOL)wParam;
                for (i = 0; i < NUM_FIELDS; ++i)
                {
                    EnableWindow(pControl->Children[i].hWnd, (BOOL)wParam);
                }
                EnableWindow(hWnd, (BOOL) wParam);

                if (pControl->fPainted)    InvalidateRect(hWnd, NULL, FALSE);
                GlobalUnlock(hControl);
            }
            break;

        case WM_DESTROY :
            hControl = GET_CONTROL_HANDLE(hWnd);
            if (!hControl)
				break;

			pControl = (CONTROL *)GlobalLock(hControl);

            // Restore all the child window procedures before we delete our memory block.
            for (i = 0; i < NUM_FIELDS; ++i)
            {
                SetWindowLongPtr(pControl->Children[i].hWnd, GWLP_WNDPROC,
                          (LPARAM)pControl->Children[i].lpfnWndProc);
                DeleteObject(pControl->Children[i].hFont);
            }

            GlobalUnlock(hControl);
            GlobalFree(hControl);
			SAVE_CONTROL_HANDLE(hWnd, NULL);
            break;

        case WM_COMMAND:
            switch (HIWORD(wParam))
            {
// One of the fields lost the focus, see if it lost the focus to another field
// of if we've lost the focus altogether.  If its lost altogether, we must send
// an EN_KILLFOCUS notification on up the ladder.
                case EN_KILLFOCUS:
                    {
                        HWND hFocus;

                        hControl = GET_CONTROL_HANDLE(hWnd);
                        pControl = (CONTROL *)GlobalLock(hControl);

                        if (!pControl->fInMessageBox)
                        {
                            hFocus = GetFocus();
                            for (i = 0; i < NUM_FIELDS; ++i)
                                if (pControl->Children[i].hWnd == hFocus)
                                    break;

                            if (i >= NUM_FIELDS)
							{
								// Before sending the address up the
								// ladder, make sure that the ip
								// address is contiguous, if needed
								if (IPADDR_GET_SUBSTYLE(hWnd) &
									IPADDR_EX_STYLE_CONTIGUOUS)
									IpAddrMakeContiguous(hWnd);
								
                                SendMessage(pControl->hwndParent, WM_COMMAND,
                                    MAKEWPARAM(GetWindowLongPtr(hWnd, GWLP_ID),
                                    EN_KILLFOCUS), (LPARAM)hWnd);
							}
						}
						GlobalUnlock(hControl);
					}
                    break;
                case EN_CHANGE:
                    hControl = GET_CONTROL_HANDLE(hWnd);
                    pControl = (CONTROL *)GlobalLock(hControl);

                    SendMessage(pControl->hwndParent, WM_COMMAND,
                        MAKEWPARAM(GetWindowLongPtr(hWnd, GWLP_ID), EN_CHANGE), (LPARAM)hWnd);

                    GlobalUnlock(hControl);
                    break;
            }
            break;

// Get the value of the IP Address.  The address is placed in the DWORD pointed
// to by lParam and the number of non-blank fields is returned.
        case IP_GETADDRESS:
            {
                int iFieldValue;
                DWORD dwValue;

                hControl = GET_CONTROL_HANDLE(hWnd);
                pControl = (CONTROL *)GlobalLock(hControl);

                lResult = 0;
                dwValue = 0;
                for (i = 0; i < NUM_FIELDS; ++i)
                {
                    iFieldValue = GetFieldValue(&(pControl->Children[i]));
                    if (iFieldValue == -1)
                        iFieldValue = 0;
                    else
                        ++lResult;
                    dwValue = (dwValue << 8) + iFieldValue;
                }
                *((DWORD *)lParam) = dwValue;

                GlobalUnlock(hControl);
            }
            break;

        case IP_GETMASK:
            {
                TCHAR szBuf[CHARS_PER_FIELD+1];
                WORD wLength;

                lResult = 0;
                hControl = GET_CONTROL_HANDLE(hWnd);
                pControl = (CONTROL *)GlobalLock(hControl);
                for (i = 0; i < NUM_FIELDS; ++i)
                {
                    *(WORD *)szBuf = (sizeof(szBuf) / sizeof(*szBuf)) - 1;
                    wLength = (WORD)SendMessage(pControl->Children[i].hWnd,
                            EM_GETLINE,0, (LPARAM) szBuf);
                    szBuf[wLength] = TEXT('\0');
                    if (!lstrcmp(szBuf, SZWILDCARD))
                    {
                        lResult |= 1L<<i;
                    }
                }
                GlobalUnlock(hControl);
            }
            break;

        case IP_GETMODIFY:
            {
                hControl = GET_CONTROL_HANDLE(hWnd);
                if ( ! hControl )
                    break ;
                pControl = (CONTROL *)GlobalLock(hControl);

                lResult = pControl->fModified > 0 ;
                for (i = 0 ; i < NUM_FIELDS ; )
                {
                    lResult |= SendMessage( pControl->Children[i++].hWnd, EM_GETMODIFY, 0, 0 ) > 0 ;
                }
                GlobalUnlock(hControl);
            }
            break ;

        case IP_SETMODIFY:
            {
                hControl = GET_CONTROL_HANDLE(hWnd);
                if ( ! hControl )
                    break ;
                pControl = (CONTROL *)GlobalLock(hControl);
                pControl->fModified =  wParam > 0 ;
                for (i = 0 ; i < NUM_FIELDS ; )
                {
                    SendMessage( pControl->Children[i++].hWnd, EM_GETMODIFY, wParam, 0 ) ;
                }
                GlobalUnlock(hControl);
            }
            break ;

        // Clear all fields to blanks.
        case IP_CLEARADDRESS:
            {
                hControl = GET_CONTROL_HANDLE(hWnd);
                pControl = (CONTROL *)GlobalLock(hControl);
                for (i = 0; i < NUM_FIELDS; ++i)
                {
                    SendMessage(pControl->Children[i].hWnd, WM_SETTEXT,
                            0, (LPARAM) (LPSTR) TEXT(""));
                }
                GlobalUnlock(hControl);
            }
            break;

// Set the value of the IP Address.  The address is in the lParam with the
// first address byte being the high byte, the second being the second byte,
// and so on.  A lParam value of -1 removes the address.
        case IP_SETADDRESS:
            {
                static TCHAR szBuf[CHARS_PER_FIELD+1];

                hControl = GET_CONTROL_HANDLE(hWnd);
                pControl = (CONTROL *)GlobalLock(hControl);
                for (i = 0; i < NUM_FIELDS; ++i)
                {
                    wsprintf(szBuf, TEXT("%d"), HIBYTE(HIWORD(lParam)));
                    SendMessage(pControl->Children[i].hWnd, WM_SETTEXT,
                                0, (LPARAM) (LPSTR) szBuf);
                    lParam <<= 8;
                }
                GlobalUnlock(hControl);
            }
            break;

        case IP_SETREADONLY:
            {
                hControl = GET_CONTROL_HANDLE(hWnd);
                pControl = (CONTROL *)GlobalLock(hControl);
                pControl->fReadOnly = (wParam != 0);
                GlobalUnlock(hControl);
            }
            break;

// Set a single field value.  The wparam (0-3) indicates the field,
// the lparam (0-255) indicates the value
        case IP_SETFIELD:
            {
                static TCHAR szBuf[CHARS_PER_FIELD+1] = TEXT("");

                hControl = GET_CONTROL_HANDLE(hWnd);
                pControl = (CONTROL *)GlobalLock(hControl);
                if (wParam < NUM_FIELDS)
                {
                    if (lParam != -1)
                    {
                        wsprintf(szBuf, TEXT("%d"), HIBYTE(HIWORD(lParam)));
                    }
                    SendMessage(pControl->Children[wParam].hWnd, WM_SETTEXT,
                                0, (LPARAM) (LPSTR) szBuf);
                }
                GlobalUnlock(hControl);
            }
            break;

        case IP_SETMASK:
            {
                BYTE bMask = (BYTE)wParam;
                static TCHAR szBuf[CHARS_PER_FIELD+1];

                hControl = GET_CONTROL_HANDLE(hWnd);
                pControl = (CONTROL *)GlobalLock(hControl);
                for (i = 0; i < NUM_FIELDS; ++i)
                {
                    if (bMask & 1<<i)
                    {
                        SendMessage(pControl->Children[i].hWnd, WM_SETTEXT,
                                    0, (LPARAM)SZWILDCARD);
                    }
                    else
                    {
                        wsprintf(szBuf, TEXT("%d"), HIBYTE(HIWORD(lParam)));
                        SendMessage(pControl->Children[i].hWnd, WM_SETTEXT,
                                    0, (LPARAM) (LPSTR) szBuf);
                    }
                    lParam <<= 8;
                }
                GlobalUnlock(hControl);
            }
            break;

        case IP_SETRANGE:
            if (wParam < NUM_FIELDS)
            {
                hControl = GET_CONTROL_HANDLE(hWnd);
                pControl = (CONTROL *)GlobalLock(hControl);

                pControl->Children[wParam].byLow = LOBYTE(LOWORD(lParam));
                pControl->Children[wParam].byHigh = HIBYTE(LOWORD(lParam));

                GlobalUnlock(hControl);
            }
            break;

// Set the focus to this control.
// wParam = the field number to set focus to, or -1 to set the focus to the
// first non-blank field.
        case IP_SETFOCUS:
            hControl = GET_CONTROL_HANDLE(hWnd);
            pControl = (CONTROL *)GlobalLock(hControl);

            if (wParam >= NUM_FIELDS)
            {
                for (wParam = 0; wParam < NUM_FIELDS; ++wParam)
                    if (GetFieldValue(&(pControl->Children[wParam])) == -1)
                        break;
                if (wParam >= NUM_FIELDS)    wParam = 0;
            }
            //
            // 0, -1 select the entire control
            //
            EnterField(&(pControl->Children[wParam]), 0, (WORD)-1);

            GlobalUnlock(hControl);
            break;

			// Determine whether all four subfields are blank
		case IP_ISBLANK:
			hControl = GET_CONTROL_HANDLE(hWnd);
			pControl = (CONTROL *)GlobalLock(hControl);
			
			lResult = TRUE;
			for (i = 0; i < NUM_FIELDS; ++i)
			{
				if (GetFieldValue(&(pControl->Children[i])) != -1)
				{
					lResult = FALSE;
					break;
				}
			}
			
			GlobalUnlock(hControl);
			break;
		
        default:
            lResult = DefWindowProc( hWnd, wMsg, wParam, lParam );
            break;
    }
    return( lResult );
}




/*
    IPAddressFieldProc() - Edit field window procedure

    This function sub-classes each edit field.
*/
LRESULT FAR WINAPI IPAddressFieldProc(HWND hWnd,
                                   UINT wMsg,
                                   WPARAM wParam,
                                   LPARAM lParam)
{
    HANDLE hControl;
    CONTROL *pControl;
    FIELD *pField;
    HWND hControlWindow;
    WORD wChildID;
    LRESULT lresult;

    if (!(hControlWindow = GetParent(hWnd)))
        return 0;

    hControl = GET_CONTROL_HANDLE(hControlWindow);
    pControl = (CONTROL *)GlobalLock(hControl);
    wChildID = (WORD) GetWindowLong(hWnd, GWL_ID);
    pField = &(pControl->Children[wChildID]);
    if (pField->hWnd != hWnd)
    {
        return 0;
    }

    switch (wMsg)
    {
        case WM_DESTROY:
            DeleteObject( (HGDIOBJ) SendMessage( hWnd, WM_GETFONT, 0, 0 ));
            return 0;
        case WM_CHAR:
            if (pControl->fReadOnly)
            {
                MessageBeep((UINT)-1);
                GlobalUnlock( hControl );
                return 0;
            }

            // Typing in the last digit in a field, skips to the next field.
            if (wParam >= TEXT('0') && wParam <= TEXT('9'))
            {
                DWORD_PTR dwResult;

                pControl->fModified = TRUE ;
                dwResult = CallWindowProc(pControl->Children[wChildID].lpfnWndProc,
                                      hWnd, wMsg, wParam, lParam);
                dwResult = SendMessage(hWnd, EM_GETSEL, 0, 0L);

                if (dwResult == MAKELPARAM(CHARS_PER_FIELD, CHARS_PER_FIELD)
                    && ExitField(pControl, wChildID)
                    && wChildID < NUM_FIELDS-1)
                {
                    EnterField(&(pControl->Children[wChildID+1]),
                                0, CHARS_PER_FIELD);
                }
                GlobalUnlock( hControl );
                return dwResult;
            }

            // spaces and periods fills out the current field and then if possible,
            // goes to the next field.

            else if (wParam == FILLER || wParam == SPACE )
            {
                DWORD_PTR dwResult;
                dwResult = SendMessage(hWnd, EM_GETSEL, 0, 0L);

                if (dwResult != 0L && HIWORD(dwResult) == LOWORD(dwResult)
                    && ExitField(pControl, wChildID))
                {
                    if (wChildID >= NUM_FIELDS-1)
                        MessageBeep((UINT)-1);
                    else
                    {
                        EnterField(&(pControl->Children[wChildID+1]),
                                    0, CHARS_PER_FIELD);
                    }
                }
                GlobalUnlock( hControl );
                return 0;
            }

// Backspaces go to the previous field if at the beginning of the current field.
// Also, if the focus shifts to the previous field, the backspace must be
// processed by that field.

            else if (wParam == BACK_SPACE)
            {
                pControl->fModified = TRUE ;
                if (wChildID > 0 && SendMessage(hWnd, EM_GETSEL, 0, 0L) == 0L)
                {
                    if (SwitchFields(pControl, wChildID, wChildID-1,
                            CHARS_PER_FIELD, CHARS_PER_FIELD)
                        && SendMessage(pControl->Children[wChildID-1].hWnd,
                        EM_LINELENGTH, 0, 0L) != 0L)
                    {
                        SendMessage(pControl->Children[wChildID-1].hWnd,
                                wMsg, wParam, lParam);
                    }
                    GlobalUnlock( hControl );
                    return 0;
                }
                else
                {
                    TCHAR szBuf[CHARS_PER_FIELD+1];
                    WORD wLength;

                    *(WORD *)szBuf = (sizeof(szBuf) / sizeof(*szBuf)) - 1;
                    wLength = (WORD)SendMessage(pControl->Children[wChildID].hWnd,
                            EM_GETLINE,0, (LPARAM) szBuf);
                    szBuf[wLength] = TEXT('\0');
                    if (!lstrcmp(szBuf, SZWILDCARD))
                    {
                        SendMessage(pControl->Children[wChildID].hWnd,
                            WM_SETTEXT, 0, (LPARAM)TEXT(""));
                    }
                }
            }

            else if ((wParam == WILDCARD) && (pControl->fAllowWildcards))
            {
                // Only works at the beginning of the line.
                if (SendMessage(hWnd, EM_GETSEL, 0, 0L) == 0L)
                {
                    pControl->fModified = TRUE;
                    SendMessage(pControl->Children[wChildID].hWnd, WM_SETTEXT, 0, (LPARAM)SZWILDCARD);

                    if (ExitField(pControl, wChildID) && (wChildID < NUM_FIELDS-1))
                    {
                        EnterField(&(pControl->Children[wChildID+1]),0, CHARS_PER_FIELD);
                    }
                }
                else
                {
                    // Not at the beginning of the line, complain
                    MessageBeep((UINT)-1);
                }
                GlobalUnlock( hControl );
                return 0;
            }

            // Any other printable characters are not allowed.
            else if (wParam > SPACE)
            {
                MessageBeep((UINT)-1);
                GlobalUnlock( hControl );
                return 0;
            }
            break;

    case WM_KEYDOWN:
        switch (wParam)
        {
        case VK_DELETE:
            {
                TCHAR szBuf[CHARS_PER_FIELD+1];
                WORD wLength;

                if (pControl->fReadOnly)
                {
                    MessageBeep((UINT)-1);
                    GlobalUnlock( hControl );
                    return 0;
                }

                pControl->fModified = TRUE ;

                *(WORD *)szBuf = (sizeof(szBuf) / sizeof(*szBuf)) - 1;
                wLength = (WORD)SendMessage(pControl->Children[wChildID].hWnd,
                            EM_GETLINE,0, (LPARAM) szBuf);
                szBuf[wLength] = TEXT('\0');
                if (!lstrcmp(szBuf, SZWILDCARD))
                {
                    SendMessage(pControl->Children[wChildID].hWnd,
                            WM_SETTEXT, 0, (LPARAM)TEXT(""));
                    GlobalUnlock( hControl );
                    return 0;
                }
            }
            break;

// Arrow keys move between fields when the end of a field is reached.
        case VK_LEFT:
        case VK_RIGHT:
        case VK_UP:
        case VK_DOWN:
            if (GetKeyState(VK_CONTROL) < 0)
            {
                if ((wParam == VK_LEFT || wParam == VK_UP) && wChildID > 0)
                {
                    SwitchFields(pControl, wChildID, wChildID-1,
                                  0, CHARS_PER_FIELD);
                    GlobalUnlock( hControl );
                    return 0;
                }
                else if ((wParam == VK_RIGHT || wParam == VK_DOWN)
                         && wChildID < NUM_FIELDS-1)
                {
                    SwitchFields(pControl, wChildID, wChildID+1,
                                      0, CHARS_PER_FIELD);
                    GlobalUnlock( hControl );
                    return 0;
                }
            }
            else
            {
                DWORD_PTR dwResult;
                WORD wStart, wEnd;

                dwResult = SendMessage(hWnd, EM_GETSEL, 0, 0L);
                wStart = LOWORD(dwResult);
                wEnd = HIWORD(dwResult);
                if (wStart == wEnd)
                {
                    if ((wParam == VK_LEFT || wParam == VK_UP)
                        && wStart == 0
                        && wChildID > 0)
                    {
                        SwitchFields(pControl, wChildID, wChildID-1,
                                          CHARS_PER_FIELD, CHARS_PER_FIELD);
                        GlobalUnlock( hControl );
                        return 0;
                    }
                    else if ((wParam == VK_RIGHT || wParam == VK_DOWN)
                             && wChildID < NUM_FIELDS-1)
                    {
                        dwResult = SendMessage(hWnd, EM_LINELENGTH, 0, 0L);
                        if (wStart >= dwResult)
                        {
                            SwitchFields(pControl, wChildID, wChildID+1, 0, 0);
                            GlobalUnlock( hControl );
                            return 0;
                        }
                    }
                }
            }
            break;

// Home jumps back to the beginning of the first field.
        case VK_HOME:
            if (wChildID > 0)
            {
                SwitchFields(pControl, wChildID, 0, 0, 0);
                GlobalUnlock( hControl );
                return 0;
            }
            break;

// End scoots to the end of the last field.
        case VK_END:
            if (wChildID < NUM_FIELDS-1)
            {
                SwitchFields(pControl, wChildID, NUM_FIELDS-1,
                                CHARS_PER_FIELD, CHARS_PER_FIELD);
                GlobalUnlock( hControl );
                return 0;
            }
            break;


        } // switch (wParam)

        break;

    case WM_KILLFOCUS:
        if ( !ExitField( pControl, wChildID ))
        {
            GlobalUnlock( hControl );
            return 0;
        }

    } // switch (wMsg)

    lresult = CallWindowProc(pControl->Children[wChildID].lpfnWndProc,
        hWnd, wMsg, wParam, lParam);
    GlobalUnlock( hControl );
    return lresult;
}




/*
    Switch the focus from one field to another.
    call
        pControl = Pointer to the CONTROL structure.
        iOld = Field we're leaving.
        iNew = Field we're entering.
        hNew = Window of field to goto
        wStart = First character selected
        wEnd = Last character selected + 1
    returns
        TRUE on success, FALSE on failure.

    Only switches fields if the current field can be validated.
*/
BOOL SwitchFields(CONTROL *pControl, int iOld, int iNew, WORD wStart, WORD wEnd)
{
    if (!ExitField(pControl, iOld))
        return FALSE;
    
    EnterField(&(pControl->Children[iNew]), wStart, wEnd);

    return TRUE;
}

/*
    Set the focus to a specific field's window.
    call
        pField = pointer to field structure for the field.
        wStart = First character selected
        wEnd = Last character selected + 1
*/
void EnterField(FIELD *pField, WORD wStart, WORD wEnd)
{
    SetFocus(pField->hWnd);
    SendMessage(pField->hWnd, EM_SETSEL, wStart, wEnd);
}


/*
    Exit a field.
    call
        pControl = pointer to CONTROL structure.
        iField = field number being exited.
    returns
        TRUE if the user may exit the field.
        FALSE if he may not.
*/
BOOL ExitField(CONTROL  *pControl, int iField)
{
    HWND hControlWnd;
    HWND hDialog;
    WORD wLength;
    FIELD *pField;
    static TCHAR szBuf[CHARS_PER_FIELD+1];
    int i,j;

    pField = &(pControl->Children[iField]);
    *(WORD *)szBuf = (sizeof(szBuf) / sizeof(*szBuf)) - 1;
    wLength = (WORD)SendMessage(pField->hWnd,EM_GETLINE,0,(LPARAM)(LPSTR)szBuf);
    if (wLength != 0)
    {
        szBuf[wLength] = TEXT('\0');
        if (pControl->fAllowWildcards && !lstrcmp(szBuf, SZWILDCARD))
        {
            return TRUE;
        }
        for (j=0,i=0;j<(INT)wLength;j++)
        {
            i=i*10+szBuf[j]-TEXT('0');
        }
        if (i < (int)(UINT)pField->byLow || i > (int)(UINT)pField->byHigh)
        {
            if ( i < (int)(UINT) pField->byLow )
            {
                /* too small */
                wsprintf(szBuf, TEXT("%d"), (int)(UINT)pField->byLow );
            }
            else
            {
                /* must be bigger */
                wsprintf(szBuf, TEXT("%d"), (int)(UINT)pField->byHigh );
            }
            SendMessage(pField->hWnd, WM_SETTEXT, 0, (LPARAM) (LPSTR) szBuf);
            if ((hControlWnd = GetParent(pField->hWnd)) != NULL
                && (hDialog = GetParent(hControlWnd)) != NULL)
            {
                pControl->fInMessageBox = TRUE;
                IPAlertPrintf(hDialog, IDS_IPBAD_FIELD_VALUE, i,
                            pField->byLow, pField->byHigh);
                pControl->fInMessageBox = FALSE;
                SendMessage(pField->hWnd, EM_SETSEL, 0, CHARS_PER_FIELD);
                return FALSE;
            }
        }
    }

	if ((hControlWnd = GetParent(pField->hWnd)))
	{
		if (IPADDR_GET_SUBSTYLE(hControlWnd) & IPADDR_EX_STYLE_CONTIGUOUS)
			IpAddrMakeContiguous(hControlWnd);		
	}
    return TRUE;
}


/*
    Get the value stored in a field.
    call
        pField = pointer to the FIELD structure for the field.
    returns
        The value (0..255) or -1 if the field has not value.
*/
int GetFieldValue(FIELD *pField)
{
    WORD wLength;
    static TCHAR szBuf[CHARS_PER_FIELD+1];
    INT i,j;

    //*(WORD *)szBuf = sizeof(szBuf) - 1;
    //wLength = (WORD)SendMessage(pField->hWnd,EM_GETLINE,0,(DWORD)(LPSTR)szBuf);
    wLength = (WORD)SendMessage(pField->hWnd,WM_GETTEXT,(sizeof(szBuf) / sizeof(*szBuf)),(LPARAM)(LPSTR)szBuf);
    if (wLength != 0)
    {
        szBuf[wLength] = TEXT('\0');
        if (!lstrcmp(szBuf, SZWILDCARD))
        {
            return 255;
        }
        for (j=0,i=0;j<(INT)wLength;j++)
        {
            i=i*10+szBuf[j]-TEXT('0');
        }
        return i;
    }
    else
        return -1;
}



/*
    IPAlertPrintf() - Does a printf to a message box.
*/

int FAR CDECL IPAlertPrintf(HWND hwndParent, UINT ids, int iCurrent, int iLow, int iHigh)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
	// Is this large enough?
    static TCHAR szBuf[MAX_IPRES*2];
    static TCHAR szFormat[MAX_IPRES];
    TCHAR * psz;

    if (ids != IDS_IPNOMEM &&
        //
        // Why OEM?
        //
        //IPLoadOem(s_hLibInstance, ids, szFormat, sizeof(szFormat)))
        LoadString(AfxGetResourceHandle(), ids, szFormat, sizeof(szFormat)/sizeof(*szFormat)))
    {
        wsprintf(szBuf, szFormat, iCurrent, iLow, iHigh);
        psz = szBuf;
    }
    else
    {
        psz = szNoMem;
    }

    MessageBeep(MB_ICONEXCLAMATION);
    return MessageBox(hwndParent, psz, szCaption, MB_ICONEXCLAMATION);
}



/*
    Load an OEM string and convert it to ANSI.
    call
        hInst = This instance
        idResource = The ID of the string to load
        lpszBuffer = Pointer to buffer to load string into.
        cbBuffer = Length of the buffer.
    returns
        TRUE if the string is loaded, FALSE if it is not.
*/
BOOL IPLoadOem(HINSTANCE hInst, UINT idResource, TCHAR* lpszBuffer, int cbBuffer)
{
    if (LoadString(hInst, idResource, lpszBuffer, cbBuffer))
    {
        //OemToAnsi(lpszBuffer, lpszBuffer);
        return TRUE;
    }
    else
    {
        lpszBuffer[0] = 0;
        return FALSE;
    }
}


__declspec(dllexport) WCHAR * WINAPI
inet_ntoaw(
    struct in_addr  dwAddress
    ) {

    static WCHAR szAddress[16];
    char* pAddr = inet_ntoa(*(struct in_addr *) &dwAddress);

    if (pAddr)
    {
	    // mbstowcs(szAddress, inet_ntoa(*(struct in_addr *)&dwAddress), 16);
	    MultiByteToWideChar(CP_ACP, 0, pAddr, -1, szAddress, 16);

	    return szAddress;
	}
	else
		return NULL;
}


__declspec(dllexport) DWORD WINAPI
inet_addrw(
    LPCWSTR     szAddressW
    ) {

    CHAR szAddressA[16];

    wcstombs(szAddressA, szAddressW, 16);

    return inet_addr(szAddressA);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\register.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    register.cpp

    FILE HISTORY:
	
*/

#include "stdafx.h"
#include "register.h"
#include "compdata.h"
#include "tregkey.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// MMC Snapin specific registry stuff

// REVIEW_MARCOC: need to get MMC helpers for this
// registry keys matching ACTIVEC\CORE\STRINGS.CPP

const TCHAR NODE_TYPES_KEY[] = TEXT("Software\\Microsoft\\MMC\\NodeTypes");
const TCHAR SNAPINS_KEY[] = TEXT("Software\\Microsoft\\MMC\\SnapIns");

const TCHAR g_szHKLM[] = TEXT("HKEY_LOCAL_MACHINE");
const TCHAR g_szStandAlone[] = TEXT("StandAlone");
const TCHAR g_szAbout[] = TEXT("About");
const TCHAR g_szNameString[] = TEXT("NameString");
const TCHAR g_szNameStringIndirect[] = TEXT("NameStringIndirect");

const TCHAR g_szNodeTypes[] = TEXT("NodeTypes");
const TCHAR g_szRequiredExtensions[] = TEXT("RequiredExtensions");

const TCHAR g_szExtensions[] = TEXT("Extensions");
const TCHAR g_szNameSpace[] = TEXT("NameSpace");
const TCHAR g_szContextMenu[] = TEXT("ContextMenu");
const TCHAR g_szToolbar[] = TEXT("Toolbar");
const TCHAR g_szPropertySheet[] = TEXT("PropertySheet");
const TCHAR g_szTask[] = TEXT("Task");
const TCHAR g_szDynamicExtensions[] = TEXT("Dynamic Extensions");


/*!--------------------------------------------------------------------------
	GetModuleFileName
		-
	Author: WeiJiang
 ---------------------------------------------------------------------------*/
TFSCORE_API(DWORD) GetModuleFileNameOnly(HINSTANCE hInst, LPTSTR lpFileName, DWORD nSize )
{
	CString	name;
	TCHAR	FullName[MAX_PATH * 2];
	DWORD	dwErr = ::GetModuleFileName( hInst, FullName,
                                             sizeof( FullName ) / sizeof( FullName[ 0 ]));
        // Make sure FullName is NULL temrinated properly
        FullName[ sizeof( FullName ) / sizeof( FullName[ 0 ]) - 1 ] = _T( '\0' );

	if (dwErr != 0)
	{
		name = FullName;
		DWORD	FirstChar = name.ReverseFind(_T('\\')) + 1;

		name = name.Mid(FirstChar);
		DWORD len = name.GetLength();

		if( len < nSize )
		{
			_tcscpy(lpFileName, name);
		}
		else
			len = 0;

		return len;
	}
	else
		return dwErr;
}

/*!--------------------------------------------------------------------------
	ReportRegistryError
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(void) ReportRegistryError(DWORD dwReserved, HRESULT hr, UINT nFormat, LPCTSTR pszFirst, va_list argptr)
{
	// Need to do this BEFORE the AFX_MANAGE_STATE so that we get the
	// correct output format
	
	CString	stHigh, stGeek, stKey;
	TCHAR	szBuffer[1024];
	LPCTSTR	psz = pszFirst;

	// Get the error message for the HRESULT error
	FormatError(hr, szBuffer, DimensionOf(szBuffer));

	// Concatenate the strings to form one string
	while (psz)
	{
		stKey += '\\';
		stKey += psz;
		psz = va_arg(argptr, LPCTSTR);
	}
	// Format it appropriately
	stGeek.Format(nFormat, stKey);

	// Get the text for the high level error string
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	stHigh.LoadString(IDS_ERR_REGISTRY_CALL_FAILED);
	
	FillTFSError(dwReserved, hr, FILLTFSERR_HIGH | FILLTFSERR_LOW | FILLTFSERR_GEEK,
				 (LPCTSTR) stHigh, szBuffer, stGeek);
}


/*!--------------------------------------------------------------------------
	SetRegError
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_APIV(void) SetRegError(DWORD dwReserved, HRESULT hr, UINT nFormat, LPCTSTR pszFirst, ...)
{
	va_list	marker;

	va_start(marker, pszFirst);
	ReportRegistryError(dwReserved, hr, nFormat, pszFirst, marker);
	va_end(marker);
}


/*!--------------------------------------------------------------------------
	RegisterSnapin
		Registers a snapin based on GUIDs
	Author:
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) 
RegisterSnapinGUID
(
	const GUID* pSnapinCLSID, 
	const GUID* pStaticNodeGUID, 
	const GUID* pAboutGUID, 
	LPCWSTR     lpszNameString, 
	LPCWSTR     lpszVersion,
	BOOL		bStandalone,
	LPCWSTR lpszNameStringIndirect
)
{
//	USES_CONVERSION;
	OLECHAR szSnapinClassID[128] = {0}, 
			szStaticNodeGuid[128] = {0}, 
			szAboutGuid[128] = {0};
	
	::StringFromGUID2(*pSnapinCLSID, szSnapinClassID, 128);
	::StringFromGUID2(*pStaticNodeGUID, szStaticNodeGuid, 128);
	::StringFromGUID2(*pAboutGUID, szAboutGuid, 128);
	
	return RegisterSnapin(szSnapinClassID, szStaticNodeGuid, szAboutGuid,
						  lpszNameString, lpszVersion, bStandalone, lpszNameStringIndirect);
}

/*!--------------------------------------------------------------------------
	CHiddenWnd::WindowProc
		Resisters a snapin based on the GUID strings
	Author: 
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) 
RegisterSnapin
(
	LPCWSTR lpszSnapinClassID, 
	LPCWSTR lpszStaticNodeGuid,
	LPCWSTR lpszAboutGuid,
	LPCWSTR lpszNameString, 
	LPCWSTR lpszVersion,
	BOOL	bStandalone,
	LPCWSTR lpszNameStringIndirect
)
{
	RegKey regkeySnapins;
	LONG lRes = regkeySnapins.Open(HKEY_LOCAL_MACHINE, SNAPINS_KEY,
                                   KEY_WRITE | KEY_READ);
	Assert(lRes == ERROR_SUCCESS);
	if (lRes != ERROR_SUCCESS)
	{
		SetRegError(0, HRESULT_FROM_WIN32(lRes),
					IDS_ERR_REG_OPEN_CALL_FAILED,
					g_szHKLM, SNAPINS_KEY, NULL);
		return HRESULT_FROM_WIN32(lRes); // failed to open
	}
	
	// 
	// Create this key for our snapin
	//
	RegKey regkeyThisSnapin;
	lRes = regkeyThisSnapin.Create(regkeySnapins, lpszSnapinClassID,
                                   REG_OPTION_NON_VOLATILE, KEY_WRITE | KEY_READ);
	Assert(lRes == ERROR_SUCCESS);
	
	if (lRes != ERROR_SUCCESS)
	{
		SetRegError(0, HRESULT_FROM_WIN32(lRes),
					IDS_ERR_REG_CREATE_CALL_FAILED,
					g_szHKLM, SNAPINS_KEY, lpszSnapinClassID, NULL);
		return HRESULT_FROM_WIN32(lRes); // failed to create
	}

	// 
	// Add in the values that go in this key:
	//     NameString, About, Provider, and Version.
	//
	lRes = regkeyThisSnapin.SetValue(g_szNameString, lpszNameString);
	if (lRes != ERROR_SUCCESS)
	{
		SetRegError(0, HRESULT_FROM_WIN32(lRes),
					IDS_ERR_REG_SETVALUE_CALL_FAILED,
					g_szHKLM, SNAPINS_KEY, lpszSnapinClassID,
					lpszNameString, NULL);
		return HRESULT_FROM_WIN32(lRes);
	}

	// to enable MUI, MMC introduces NameStringIndirect value with value format "@dllname,-id"
	if(lpszNameStringIndirect)
	{
		lRes = regkeyThisSnapin.SetValue(g_szNameStringIndirect, lpszNameStringIndirect);
		if (lRes != ERROR_SUCCESS)
		{
			SetRegError(0, HRESULT_FROM_WIN32(lRes),
						IDS_ERR_REG_SETVALUE_CALL_FAILED,
						g_szHKLM, SNAPINS_KEY, lpszSnapinClassID,
						lpszNameStringIndirect, NULL);
			return HRESULT_FROM_WIN32(lRes);
		}
	}

	lRes = regkeyThisSnapin.SetValue(g_szAbout, lpszAboutGuid);
	if (lRes != ERROR_SUCCESS)
	{
		SetRegError(0, HRESULT_FROM_WIN32(lRes),
					IDS_ERR_REG_SETVALUE_CALL_FAILED,
					g_szHKLM, SNAPINS_KEY, lpszSnapinClassID,
					lpszAboutGuid, NULL);
		return HRESULT_FROM_WIN32(lRes);
	}
	
	lRes = regkeyThisSnapin.SetValue( _T("Provider"), _T("Microsoft"));
	if (lRes != ERROR_SUCCESS)
	{
		SetRegError(0, HRESULT_FROM_WIN32(lRes),
					IDS_ERR_REG_SETVALUE_CALL_FAILED,
					g_szHKLM, SNAPINS_KEY, lpszSnapinClassID,
					_T("Provider"), NULL);
		return HRESULT_FROM_WIN32(lRes);
	}
	
	lRes = regkeyThisSnapin.SetValue(_T("Version"), lpszVersion);
	Assert(lRes == ERROR_SUCCESS);
	
	// 
	// Create the NodeTypes subkey
	//
	RegKey regkeySnapinNodeTypes;
	lRes = regkeySnapinNodeTypes.Create(regkeyThisSnapin, g_szNodeTypes,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_WRITE | KEY_READ);
	Assert(lRes == ERROR_SUCCESS);

	if (lRes != ERROR_SUCCESS)
	{
		SetRegError(0, HRESULT_FROM_WIN32(lRes),
					IDS_ERR_REG_CREATE_CALL_FAILED,
					g_szHKLM, SNAPINS_KEY, lpszSnapinClassID,
					g_szNodeTypes, NULL);
		return HRESULT_FROM_WIN32(lRes); // failed to create
	}
	
	RegKey regkeySnapinThisNodeType;
	lRes = regkeySnapinThisNodeType.Create(regkeySnapinNodeTypes,
                                           lpszStaticNodeGuid,
                                           REG_OPTION_NON_VOLATILE,
                                           KEY_WRITE | KEY_READ);

	if (lRes != ERROR_SUCCESS)
	{
		SetRegError(0, HRESULT_FROM_WIN32(lRes),
					IDS_ERR_REG_CREATE_CALL_FAILED,
					g_szHKLM, SNAPINS_KEY, lpszSnapinClassID,
					g_szNodeTypes, lpszStaticNodeGuid, NULL);
		return HRESULT_FROM_WIN32(lRes);
	}

	//
	// If this snapin can run by itself then create the Standalone subkey
	//
	if (bStandalone)
	{
		RegKey regkeySnapinStandalone;	
		lRes = regkeySnapinStandalone.Create(regkeyThisSnapin,
                                             g_szStandAlone,
                                             REG_OPTION_NON_VOLATILE,
                                             KEY_WRITE | KEY_READ);

		Assert(lRes == ERROR_SUCCESS);

		if (lRes != ERROR_SUCCESS)
		{
			SetRegError(0, HRESULT_FROM_WIN32(lRes),
						IDS_ERR_REG_CREATE_CALL_FAILED,
						g_szHKLM, SNAPINS_KEY, lpszSnapinClassID,
						g_szStandAlone, NULL);
			return HRESULT_FROM_WIN32(lRes); // failed to create
		}
	}
	
	return HRESULT_FROM_WIN32(lRes); 
}

/*!--------------------------------------------------------------------------
	UnregisterSnapin
		Removes snapin specific registry entries
	Author: 
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) 
UnregisterSnapinGUID
(
	const GUID* pSnapinCLSID
)
{
//	USES_CONVERSION;
	OLECHAR szSnapinClassID[128];
	
	::StringFromGUID2(*pSnapinCLSID,szSnapinClassID,128);
	
	return UnregisterSnapin(szSnapinClassID);
}

/*!--------------------------------------------------------------------------
	UnregisterSnapin
		Removes snapin specific registry entries
	Author: 
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) 
UnregisterSnapin
(
	LPCWSTR lpszSnapinClassID
)
{
	RegKey regkeySnapins;
	LONG lRes = regkeySnapins.Open(HKEY_LOCAL_MACHINE, SNAPINS_KEY,
                                   KEY_WRITE | KEY_READ);
	Assert(lRes == ERROR_SUCCESS);
	if (lRes != ERROR_SUCCESS)
	{
		SetRegError(0, HRESULT_FROM_WIN32(lRes),
					IDS_ERR_REG_OPEN_CALL_FAILED,
					g_szHKLM, SNAPINS_KEY, NULL);
		return HRESULT_FROM_WIN32(lRes); // failed to open
	}
	
	lRes = regkeySnapins.RecurseDeleteKey(lpszSnapinClassID);
	
	return HRESULT_FROM_WIN32(lRes); 
}

/*!--------------------------------------------------------------------------
	RegisterNodeType
		Registers a particular node type
	Author: 
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) 
RegisterNodeTypeGUID
(
	const GUID* pGuidSnapin,
	const GUID* pGuidNode, 
	LPCWSTR     lpszNodeDescription
)
{
//	USES_CONVERSION;
	OLECHAR swzGuidSnapin[128];
	OLECHAR swzGuidNode[128];
	
	::StringFromGUID2(*pGuidSnapin,swzGuidSnapin,128);
	::StringFromGUID2(*pGuidNode,swzGuidNode,128);
	
	return RegisterNodeType(swzGuidSnapin, swzGuidNode, lpszNodeDescription);
}

/*!--------------------------------------------------------------------------
	RegisterNodeType
		Registers a particular node type
	Author: 
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) 
RegisterNodeType
(       
	LPCWSTR lpszGuidSnapin, 
	LPCWSTR lpszGuidNode, 
	LPCWSTR lpszNodeDescription
)
{
	// register this node type under the snapin
	RegKey	regkeySnapins;
	RegKey	regkeySnapinGuid;
	RegKey	regkeySnapinGuidNodeTypes;
	RegKey	regkeyNode;
	RegKey regkeyThisNodeType;
	RegKey regkeyNodeTypes;
	DWORD	lRes;
	HRESULT	hr = hrOK;
	
	lRes = regkeySnapins.Open(HKEY_LOCAL_MACHINE, SNAPINS_KEY,
                             KEY_WRITE | KEY_READ);
	Assert(lRes == ERROR_SUCCESS);
	if ( lRes != ERROR_SUCCESS)
	{
		SetRegError(0, HRESULT_FROM_WIN32(lRes),
					IDS_ERR_REG_OPEN_CALL_FAILED,
					g_szHKLM, SNAPINS_KEY, NULL);
		CWRg( lRes );
	}
	
	lRes = regkeySnapinGuid.Create(regkeySnapins, lpszGuidSnapin,
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_WRITE | KEY_READ);

	Assert(lRes == ERROR_SUCCESS);
	if (lRes != ERROR_SUCCESS)
		SetRegError(0, HRESULT_FROM_WIN32(lRes),
					IDS_ERR_REG_CREATE_CALL_FAILED,
					g_szHKLM, SNAPINS_KEY, lpszGuidSnapin, NULL);
	CWRg( lRes );

	lRes = regkeySnapinGuidNodeTypes.Create(regkeySnapinGuid, g_szNodeTypes,
                                            REG_OPTION_NON_VOLATILE,
                                            KEY_WRITE | KEY_READ);

	Assert(lRes == ERROR_SUCCESS);
	if (lRes != ERROR_SUCCESS)
		SetRegError(0, HRESULT_FROM_WIN32(lRes),
					IDS_ERR_REG_CREATE_CALL_FAILED,
					g_szHKLM, SNAPINS_KEY, lpszGuidSnapin,
					g_szNodeTypes, NULL);
	CWRg( lRes );

	lRes = regkeyNode.Create(regkeySnapinGuidNodeTypes, lpszGuidNode,
                             REG_OPTION_NON_VOLATILE,
                             KEY_WRITE | KEY_READ);
                             
	Assert(lRes == ERROR_SUCCESS);
	if (lRes != ERROR_SUCCESS)
		SetRegError(0, HRESULT_FROM_WIN32(lRes),
					IDS_ERR_REG_CREATE_CALL_FAILED,
					g_szHKLM, SNAPINS_KEY, lpszGuidSnapin,
					g_szNodeTypes, lpszGuidNode, NULL);
	CWRg( lRes );

	// set the description
	lRes = regkeyNode.SetValue(NULL, lpszNodeDescription);
	Assert(lRes == ERROR_SUCCESS);

	// now register the node type in the global list so that people
	// can extend it
	lRes = regkeyNodeTypes.Open(HKEY_LOCAL_MACHINE, NODE_TYPES_KEY,
                                KEY_WRITE | KEY_READ);
	Assert(lRes == ERROR_SUCCESS);
	if (lRes != ERROR_SUCCESS)
	{
		SetRegError(0, HRESULT_FROM_WIN32(lRes),
					IDS_ERR_REG_OPEN_CALL_FAILED,
					g_szHKLM, NODE_TYPES_KEY, NULL);
		CWRg( lRes );
	}

	lRes = regkeyThisNodeType.Create(regkeyNodeTypes, lpszGuidNode,
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_WRITE | KEY_READ);
                                     
	Assert(lRes == ERROR_SUCCESS);
	if (lRes != ERROR_SUCCESS)
		SetRegError(0, HRESULT_FROM_WIN32(lRes),
					IDS_ERR_REG_CREATE_CALL_FAILED,
					g_szHKLM, NODE_TYPES_KEY, lpszGuidNode, NULL);
	CWRg( lRes );

	lRes = regkeyThisNodeType.SetValue(NULL, lpszNodeDescription);
	Assert(lRes == ERROR_SUCCESS);
	CWRg( lRes );

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	UnregisterNodeType
		Removes registry entries for a node
	Author: 
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) 
UnregisterNodeTypeGUID
(
	const GUID* pGuid
)
{
//	USES_CONVERSION;
	OLECHAR szGuid[128];

	::StringFromGUID2(*pGuid,szGuid,128);
	
	return UnregisterNodeType(szGuid);
}

/*!--------------------------------------------------------------------------
	UnregisterNodeType
		Removes registry entries for a node
	Author: 
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) 
UnregisterNodeType
(
	LPCWSTR lpszNodeGuid
)
{
	RegKey regkeyNodeTypes;
	LONG lRes = regkeyNodeTypes.Open(HKEY_LOCAL_MACHINE, NODE_TYPES_KEY,
                                     KEY_WRITE | KEY_READ);
	Assert(lRes == ERROR_SUCCESS);

	if (lRes != ERROR_SUCCESS)
	{
		SetRegError(0, HRESULT_FROM_WIN32(lRes),
					IDS_ERR_REG_OPEN_CALL_FAILED,
					g_szHKLM, NODE_TYPES_KEY, NULL);
		return HRESULT_FROM_WIN32(lRes); // failed to open
	}
	
	lRes = regkeyNodeTypes.RecurseDeleteKey(lpszNodeGuid);
	Assert(lRes == ERROR_SUCCESS);

	return HRESULT_FROM_WIN32(lRes); 
}

/*!--------------------------------------------------------------------------
	RegisterAsExtensionGUID
		Registers a particular node type as an extension of another node
	Author: 
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) 
RegisterAsExtensionGUID
(
	const GUID* pGuidNodeToExtend,
	const GUID* pGuidExtensionSnapin,
	LPCWSTR     lpszSnapinDescription,
	DWORD		dwExtensionType
)
{
	return RegisterAsRequiredExtensionGUID(pGuidNodeToExtend,
									       pGuidExtensionSnapin,
										   lpszSnapinDescription,
										   dwExtensionType,
										   NULL);
}

/*!--------------------------------------------------------------------------
	RegisterAsExtension
		Registers a particular node type as an extension of another node
	Author: 
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT)
RegisterAsExtension
(       
	LPCWSTR lpszNodeToExtendGuid, 
	LPCWSTR lpszExtensionSnapin, 
	LPCWSTR lpszSnapinDescription,
	DWORD	dwExtensionType
)
{
	return RegisterAsRequiredExtension(lpszNodeToExtendGuid,
									   lpszExtensionSnapin,
									   lpszSnapinDescription,
									   dwExtensionType,
									   NULL);
}

/*!--------------------------------------------------------------------------
	RegisterAsExtensionGUID
		Registers a particular node type as an extension of another node
	Author: 
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) 
RegisterAsRequiredExtensionGUID
(
	const GUID* pGuidNodeToExtend,
	const GUID* pGuidExtensionSnapin,
	LPCWSTR     lpszSnapinDescription,
	DWORD		dwExtensionType,
	const GUID* pGuidRequiredPrimarySnapin
)
{
    return RegisterAsRequiredExtensionGUIDEx(NULL,
                                             pGuidNodeToExtend,
                                             pGuidExtensionSnapin,
                                             lpszSnapinDescription,
                                             dwExtensionType,
                                             pGuidRequiredPrimarySnapin);
}

/*!--------------------------------------------------------------------------
	RegisterAsExtensionGUIDEx
		Registers a particular node type as an extension of another node
	Author: 
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) 
RegisterAsRequiredExtensionGUIDEx
(
    LPCWSTR     lpszMachineName,
	const GUID* pGuidNodeToExtend,
	const GUID* pGuidExtensionSnapin,
	LPCWSTR     lpszSnapinDescription,
	DWORD		dwExtensionType,
	const GUID* pGuidRequiredPrimarySnapin
)
{
//	USES_CONVERSION;
	OLECHAR szGuidNodeToExtend[128];
	OLECHAR szGuidExtensionSnapin[128];
	OLECHAR szGuidRequiredPrimarySnapin[128];
    OLECHAR * pszGuidRequiredPrimarySnapin = NULL;

	::StringFromGUID2(*pGuidNodeToExtend, szGuidNodeToExtend, 128);
	::StringFromGUID2(*pGuidExtensionSnapin, szGuidExtensionSnapin, 128);
		
	if (pGuidRequiredPrimarySnapin)
	{
		Assert(pGuidExtensionSnapin);

		::StringFromGUID2(*pGuidRequiredPrimarySnapin, szGuidRequiredPrimarySnapin, 128);
		pszGuidRequiredPrimarySnapin = szGuidRequiredPrimarySnapin;

		::StringFromGUID2(*pGuidExtensionSnapin, szGuidExtensionSnapin, 128);
	}

	return RegisterAsRequiredExtensionEx(lpszMachineName,
                                         szGuidNodeToExtend, 
                                         szGuidExtensionSnapin,
                                         lpszSnapinDescription,
                                         dwExtensionType,
                                         pszGuidRequiredPrimarySnapin);
}


/*!--------------------------------------------------------------------------
	RegisterAsRequiredExtension
		Registers a particular node type as an extension of another node
		and if necessary a required snapin
	Author: 
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT)
RegisterAsRequiredExtension
(
	LPCWSTR lpszNodeToExtendGuid,
	LPCWSTR lpszExtensionSnapinGuid,
	LPCWSTR lpszSnapinDescription,
	DWORD	dwExtensionType,
	LPCWSTR lpszRequiredPrimarySnapin
)
{
    return RegisterAsRequiredExtensionEx(NULL,
                                         lpszNodeToExtendGuid,
                                         lpszExtensionSnapinGuid,
                                         lpszSnapinDescription,
                                         dwExtensionType,
                                         lpszRequiredPrimarySnapin);
}

/*!--------------------------------------------------------------------------
	RegisterAsRequiredExtensionEx
		Registers a particular node type as an extension of another node
		and if necessary a required snapin

        This will take the name of the machine to register for.  If
        lpszMachineName is NULL, then the local machine is used.
	Author: 
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT)
RegisterAsRequiredExtensionEx
(
    LPCWSTR lpszMachine,
	LPCWSTR lpszNodeToExtendGuid,
	LPCWSTR lpszExtensionSnapinGuid,
	LPCWSTR lpszSnapinDescription,
	DWORD	dwExtensionType,
	LPCWSTR lpszRequiredPrimarySnapin
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	RegKey regkeyNodeTypes;
	LONG lRes = regkeyNodeTypes.Open(HKEY_LOCAL_MACHINE, NODE_TYPES_KEY,
                                     KEY_WRITE | KEY_READ, lpszMachine);
	Assert(lRes == ERROR_SUCCESS);

	if (lRes != ERROR_SUCCESS)
	{
		SetRegError(0, HRESULT_FROM_WIN32(lRes),
					IDS_ERR_REG_OPEN_CALL_FAILED,
					g_szHKLM, NODE_TYPES_KEY, NULL);
		return HRESULT_FROM_WIN32(lRes); // failed to open
	}

	CString strRegKey;

	strRegKey = lpszNodeToExtendGuid;
	strRegKey +=  _T("\\");
	strRegKey += g_szExtensions;
	strRegKey += _T("\\");

	// check to see if we this is a required extension, if so register
	if (lpszRequiredPrimarySnapin)
	{
		RegKey regkeyNode, regkeyDynExt;
		RegKey regkeyExtension;
		CString strNodeToExtend, strDynExtKey;

        strNodeToExtend = lpszNodeToExtendGuid;
        
		// open the snapin that we are registering as a required snapin
		lRes = regkeyNode.Create(regkeyNodeTypes, strNodeToExtend,
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_WRITE | KEY_READ);
		Assert(lRes == ERROR_SUCCESS);

		if (lRes != ERROR_SUCCESS)
		{
			SetRegError(0, HRESULT_FROM_WIN32(lRes),
						IDS_ERR_REG_OPEN_CALL_FAILED,
						g_szHKLM, strNodeToExtend, NULL);
			return HRESULT_FROM_WIN32(lRes); // failed to open
		}

		// now create the required extensions key and add the subkey
		lRes = regkeyDynExt.Create(regkeyNode, g_szDynamicExtensions,
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_WRITE | KEY_READ);
        Assert(lRes == ERROR_SUCCESS);

		if (lRes != ERROR_SUCCESS)
		{
			SetRegError(0, HRESULT_FROM_WIN32(lRes),
						IDS_ERR_REG_CREATE_CALL_FAILED,
						g_szHKLM,
						strNodeToExtend,
						g_szDynamicExtensions, NULL);
			return HRESULT_FROM_WIN32(lRes); // failed to open
		}

		// now set the value
		lRes = regkeyDynExt.SetValue(lpszExtensionSnapinGuid, lpszSnapinDescription);
		Assert(lRes == ERROR_SUCCESS);

		if (lRes != ERROR_SUCCESS)
		{
			SetRegError(0, HRESULT_FROM_WIN32(lRes),
						IDS_ERR_REG_SETVALUE_CALL_FAILED,
						g_szHKLM,
						lpszExtensionSnapinGuid,
						g_szDynamicExtensions,
						lpszSnapinDescription, NULL);
			return HRESULT_FROM_WIN32(lRes); // failed to open
		}
	}
	
	if (dwExtensionType & EXTENSION_TYPE_NAMESPACE)
	{
		RegKey regkeyNameSpace;
		CString strNameSpaceRegKey = strRegKey + g_szNameSpace;

		regkeyNameSpace.Create(regkeyNodeTypes, strNameSpaceRegKey,
                               REG_OPTION_NON_VOLATILE,
                               KEY_WRITE | KEY_READ);
        
		lRes = regkeyNameSpace.SetValue(lpszExtensionSnapinGuid, lpszSnapinDescription);
		Assert(lRes == ERROR_SUCCESS);
		
		if (lRes != ERROR_SUCCESS)
		{
			Trace0("RegisterAsExtension: Unable to create NameSpace extension key\n");
			return HRESULT_FROM_WIN32(lRes); // failed to create
		}
	}

	if (dwExtensionType & EXTENSION_TYPE_CONTEXTMENU)
	{
		RegKey regkeyContextMenu;
		CString strContextMenuRegKey = strRegKey + g_szContextMenu;

		regkeyContextMenu.Create(regkeyNodeTypes, strContextMenuRegKey,
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_WRITE | KEY_READ);

		lRes = regkeyContextMenu.SetValue(lpszExtensionSnapinGuid, lpszSnapinDescription);
		Assert(lRes == ERROR_SUCCESS);
		
		if (lRes != ERROR_SUCCESS)
		{
			Trace0("RegisterAsExtension: Unable to create ContextMenu extension key\n");
			return HRESULT_FROM_WIN32(lRes); // failed to create
		}
	}

	if (dwExtensionType & EXTENSION_TYPE_TOOLBAR)
	{
		RegKey regkeyToolbar;
		CString strToolbarRegKey = strRegKey + g_szToolbar;

		regkeyToolbar.Create(regkeyNodeTypes, strToolbarRegKey,
                             REG_OPTION_NON_VOLATILE,
                             KEY_WRITE | KEY_READ);

		lRes = regkeyToolbar.SetValue(lpszExtensionSnapinGuid, lpszSnapinDescription);
		Assert(lRes == ERROR_SUCCESS);
		
		if (lRes != ERROR_SUCCESS)
		{
			Trace0("RegisterAsExtension: Unable to create Toolbar extension key\n");
			return HRESULT_FROM_WIN32(lRes); // failed to create
		}
	}

	if (dwExtensionType & EXTENSION_TYPE_PROPERTYSHEET)
	{
		RegKey regkeyPropertySheet;
		CString strPropertySheetRegKey = strRegKey + g_szPropertySheet;

		regkeyPropertySheet.Create(regkeyNodeTypes, strPropertySheetRegKey,
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_WRITE | KEY_READ);

		lRes = regkeyPropertySheet.SetValue(lpszExtensionSnapinGuid, lpszSnapinDescription);
		Assert(lRes == ERROR_SUCCESS);
		
		if (lRes != ERROR_SUCCESS)
		{
			Trace0("RegisterAsExtension: Cannot create PropertySheet extension key\n");
			return HRESULT_FROM_WIN32(lRes); // failed to create
		}
	}

	if (dwExtensionType & EXTENSION_TYPE_TASK)
	{
		RegKey regkeyTask;
		CString strTaskRegKey = strRegKey + g_szTask;

		regkeyTask.Create(regkeyNodeTypes, strTaskRegKey,
                          REG_OPTION_NON_VOLATILE,
                          KEY_WRITE | KEY_READ);
        
		lRes = regkeyTask.SetValue(lpszExtensionSnapinGuid, lpszSnapinDescription);
		Assert(lRes == ERROR_SUCCESS);
		
		if (lRes != ERROR_SUCCESS)
		{
			Trace0("RegisterAsExtension: Cannot create Task extension key\n");
			return HRESULT_FROM_WIN32(lRes); // failed to create
		}
	}

	return HRESULT_FROM_WIN32(lRes); 
}

/*!--------------------------------------------------------------------------
	UnregisterAsExtensionGUID
		Removes registry entries for a node as an extension
	Author: 
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) 
UnregisterAsExtensionGUID
(
	const GUID* pGuidNodeToExtend, 
	const GUID* pGuidExtensionSnapin, 
	DWORD		dwExtensionType
)
{
	return UnregisterAsRequiredExtensionGUID(pGuidNodeToExtend, 
											 pGuidExtensionSnapin, 
											 dwExtensionType,
											 NULL);
}

/*!--------------------------------------------------------------------------
	UnregisterAsExtension
		Removes registry entries for a node as an extension
	Author: 
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) 
UnregisterAsExtension
(
	LPCWSTR lpszNodeToExtendGuid, 
	LPCWSTR lpszExtendingNodeGuid, 
	DWORD	dwExtensionType
)
{
	return UnregisterAsRequiredExtension(lpszNodeToExtendGuid, 
										 lpszExtendingNodeGuid, 
										 dwExtensionType,
										 NULL);
}

/*!--------------------------------------------------------------------------
	UnregisterAsRequiredExtensionGUID
		Removes registry entries for a node as an extension
	Author: 
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) 
UnregisterAsRequiredExtensionGUID
(
	const GUID* pGuidNodeToExtend, 
	const GUID* pGuidExtensionSnapin, 
	DWORD		dwExtensionType,
	const GUID* pGuidRequiredPrimarySnapin
)
{
    return UnregisterAsRequiredExtensionGUIDEx(
                                               NULL,
                                               pGuidNodeToExtend,
                                               pGuidExtensionSnapin,
                                               dwExtensionType,
                                               pGuidRequiredPrimarySnapin);
}

/*!--------------------------------------------------------------------------
	UnregisterAsRequiredExtensionGUIDEx
		Removes registry entries for a node as an extension
	Author: 
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) 
UnregisterAsRequiredExtensionGUIDEx
(
    LPCWSTR     lpszMachineName,
	const GUID* pGuidNodeToExtend, 
	const GUID* pGuidExtensionSnapin, 
	DWORD		dwExtensionType,
	const GUID* pGuidRequiredPrimarySnapin
)
{
//	USES_CONVERSION;
	OLECHAR szGuidNodeToExtend[128];
	OLECHAR szGuidExtensionSnapin[128];
	OLECHAR szGuidRequiredPrimarySnapin[128];
	OLECHAR szGuidRequiredExtensionSnapin[128];
	OLECHAR * pszGuidRequiredPrimarySnapin = NULL;
	
	::StringFromGUID2(*pGuidNodeToExtend, szGuidNodeToExtend, 128);
	::StringFromGUID2(*pGuidExtensionSnapin, szGuidExtensionSnapin, 128);
	
	if (pGuidRequiredPrimarySnapin)
	{
		Assert(pGuidExtensionSnapin);

		::StringFromGUID2(*pGuidRequiredPrimarySnapin, szGuidRequiredPrimarySnapin, 128);
		pszGuidRequiredPrimarySnapin = szGuidRequiredPrimarySnapin;

		::StringFromGUID2(*pGuidExtensionSnapin, szGuidExtensionSnapin, 128);
	}

	return UnregisterAsRequiredExtensionEx(lpszMachineName,
                                           szGuidNodeToExtend, 
                                           szGuidExtensionSnapin, 
                                           dwExtensionType,
                                           pszGuidRequiredPrimarySnapin);
    
}

/*!--------------------------------------------------------------------------
	UnregisterAsRequiredExtension
		Removes registry entries for a node as an extension
	Author: 
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) 
UnregisterAsRequiredExtension
(
	LPCWSTR lpszNodeToExtendGuid, 
	LPCWSTR lpszExtensionSnapinGuid, 
	DWORD	dwExtensionType,
	LPCWSTR lpszRequiredPrimarySnapin
)
{
    return UnregisterAsRequiredExtensionEx(NULL,
                                           lpszNodeToExtendGuid,
                                           lpszExtensionSnapinGuid,
                                           dwExtensionType,
                                           lpszRequiredPrimarySnapin);
}

/*!--------------------------------------------------------------------------
	UnregisterAsRequiredExtensionEx
		Removes registry entries for a node as an extension
	Author: 
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) 
UnregisterAsRequiredExtensionEx
(
    LPCWSTR lpszMachineName,
	LPCWSTR lpszNodeToExtendGuid, 
	LPCWSTR lpszExtensionSnapinGuid, 
	DWORD	dwExtensionType,
	LPCWSTR lpszRequiredPrimarySnapin
)
{
	RegKey regkeyNodeTypes;
	CString strDynamicExtensions;

	LONG lRes = regkeyNodeTypes.Open(HKEY_LOCAL_MACHINE, NODE_TYPES_KEY,
                                     KEY_WRITE | KEY_READ, lpszMachineName);
	Assert(lRes == ERROR_SUCCESS);

	if (lRes != ERROR_SUCCESS)
	{
		SetRegError(0, HRESULT_FROM_WIN32(lRes),
					IDS_ERR_REG_OPEN_CALL_FAILED,
					g_szHKLM, NODE_TYPES_KEY, NULL);
		return HRESULT_FROM_WIN32(lRes); // failed to open
	}

	RegKey regkeyNodeToExtend;
	lRes = regkeyNodeToExtend.Open(regkeyNodeTypes, lpszNodeToExtendGuid,
                                   KEY_WRITE | KEY_READ);
	if (lRes != ERROR_SUCCESS)
	{
		SetRegError(0, HRESULT_FROM_WIN32(lRes),
					IDS_ERR_REG_OPEN_CALL_FAILED,
					g_szHKLM,
					NODE_TYPES_KEY,
					lpszNodeToExtendGuid, NULL);
		Trace1("UnregisterAsExtension: Node To extend (%s) does not exist\n", lpszNodeToExtendGuid);
		return HRESULT_FROM_WIN32(lRes); // failed to create
	}

    // check to see if we need to remove the dynamic extension stuff
	if (lpszRequiredPrimarySnapin)
	{
		RegKey regkeyDynExt;
		
		// open dynamic extensions key
		lRes = regkeyDynExt.Open(regkeyNodeToExtend, g_szDynamicExtensions,
                                 KEY_WRITE | KEY_READ);
    	if (lRes == ERROR_SUCCESS)
		{
			// now remove the value
    		regkeyDynExt.DeleteValue(lpszExtensionSnapinGuid);
		}
	}
	
	RegKey regkeyExtensionKey;
	lRes = regkeyExtensionKey.Open(regkeyNodeToExtend, g_szExtensions,
                                   KEY_WRITE | KEY_READ);
	if (lRes != ERROR_SUCCESS)
	{
		SetRegError(0, HRESULT_FROM_WIN32(lRes),
					IDS_ERR_REG_OPEN_CALL_FAILED,
					g_szHKLM,
					NODE_TYPES_KEY,
					lpszNodeToExtendGuid,
					g_szExtensions, NULL);
		Trace0("UnregisterAsExtension: Node To extend Extensions subkey does not exist\n");
		return HRESULT_FROM_WIN32(lRes); // failed to create
	}
	
	if (dwExtensionType & EXTENSION_TYPE_NAMESPACE)
	{
		RegKey regkeyNameSpace;
		lRes = regkeyNameSpace.Open(regkeyExtensionKey, g_szNameSpace,
                                    KEY_WRITE | KEY_READ);
		Assert(lRes == ERROR_SUCCESS);
		
		while (lRes != ERROR_SUCCESS)
		{
			SetRegError(0, HRESULT_FROM_WIN32(lRes),
						IDS_ERR_REG_OPEN_CALL_FAILED,
						g_szHKLM,
						NODE_TYPES_KEY,
						lpszNodeToExtendGuid,
						g_szExtensions,
						g_szNameSpace, NULL);
			Trace0("UnregisterAsExtension: Node To extend NameSpace subkey does not exist\n");
			//return HRESULT_FROM_WIN32(lRes); // failed to create
			break;
		}
		
		regkeyNameSpace.DeleteValue(lpszExtensionSnapinGuid);
	}

	if (dwExtensionType & EXTENSION_TYPE_CONTEXTMENU)
	{
		RegKey regkeyContextMenu;
		lRes = regkeyContextMenu.Open(regkeyExtensionKey, g_szContextMenu,
                                      KEY_WRITE | KEY_READ);
		Assert(lRes == ERROR_SUCCESS);
		
		while (lRes != ERROR_SUCCESS)
		{
			SetRegError(0, HRESULT_FROM_WIN32(lRes),
						IDS_ERR_REG_OPEN_CALL_FAILED,
						g_szHKLM,
						NODE_TYPES_KEY,
						lpszNodeToExtendGuid,
						g_szExtensions,
						g_szContextMenu, NULL);
			Trace0("UnregisterAsExtension: Node To extend ContextMenu subkey does not exist\n");
			//return HRESULT_FROM_WIN32(lRes); // failed to create
			break;
		}
		
		regkeyContextMenu.DeleteValue(lpszExtensionSnapinGuid);
	}

	if (dwExtensionType & EXTENSION_TYPE_TOOLBAR)
	{
		RegKey regkeyToolbar;
		lRes = regkeyToolbar.Open(regkeyExtensionKey, g_szToolbar,
                                  KEY_WRITE | KEY_READ);
		Assert(lRes == ERROR_SUCCESS);
		
		while (lRes != ERROR_SUCCESS)
		{
			SetRegError(0, HRESULT_FROM_WIN32(lRes),
						IDS_ERR_REG_OPEN_CALL_FAILED,
						g_szHKLM,
						NODE_TYPES_KEY,
						lpszNodeToExtendGuid,
						g_szExtensions,
						g_szToolbar, NULL);
			Trace0("UnregisterAsExtension: Node To extend Toolbar subkey does not exist\n");
			//return HRESULT_FROM_WIN32(lRes); // failed to create
			break;
		}
		
		regkeyToolbar.DeleteValue(lpszExtensionSnapinGuid);
	}

	if (dwExtensionType & EXTENSION_TYPE_PROPERTYSHEET)
	{
		RegKey regkeyPropertySheet;
		lRes = regkeyPropertySheet.Open(regkeyExtensionKey, g_szPropertySheet,
                                        KEY_WRITE | KEY_READ);
		Assert(lRes == ERROR_SUCCESS);
		
		while (lRes != ERROR_SUCCESS)
		{
			SetRegError(0, HRESULT_FROM_WIN32(lRes),
						IDS_ERR_REG_OPEN_CALL_FAILED,
						g_szHKLM,
						NODE_TYPES_KEY,
						lpszNodeToExtendGuid,
						g_szExtensions,
						g_szPropertySheet, NULL);
			Trace0("UnregisterAsExtension: Node To extend PropertySheet subkey does not exist\n");
			//return HRESULT_FROM_WIN32(lRes); // failed to create
			break;
		}
		
		regkeyPropertySheet.DeleteValue(lpszExtensionSnapinGuid);
	}
	
	return HRESULT_FROM_WIN32(lRes); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\register.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    register.h

    FILE HISTORY:
        
*/

#ifndef _REGISTER_H
#define _REGISTER_H

#if _MSC_VER >= 1000	// VC 5.0 or later
#pragma once
#endif

#ifndef __mmc_h__
#include <mmc.h>
#endif

TFSCORE_API(DWORD) GetModuleFileNameOnly(HINSTANCE hInst, LPTSTR lpFileName, DWORD nSize );

// functions to register/unregister a snapin
TFSCORE_API(HRESULT) RegisterSnapinGUID(const GUID* pSnapinCLSID, 
						  const GUID* pStaticNodeGUID, 
						  const GUID* pAboutGUID, 
						  LPCWSTR lpszNameStringNoValueName, 
						  LPCWSTR lpszVersion, 
						  BOOL bStandalone,
						  LPCWSTR lpszNameStringIndirect = NULL
						  );
TFSCORE_API(HRESULT) RegisterSnapin(LPCWSTR lpszSnapinClassID, 
					   LPCWSTR lpszStaticNodeGuid, 
					   LPCWSTR lpszAboutGuid, 
					   LPCWSTR lpszNameString, 
					   LPCWSTR lpszVersion,
					   BOOL bStandalone,
					   LPCWSTR lpszNameStringIndirect = NULL
					   );

TFSCORE_API(HRESULT) UnregisterSnapinGUID(const GUID* pSnapinCLSID);
TFSCORE_API(HRESULT) UnregisterSnapin(LPCWSTR lpszSnapinClassID);

// functions to register/unregister node types
TFSCORE_API(HRESULT) RegisterNodeTypeGUID(const GUID* pGuidSnapin, 
										  const GUID* pGuidNode, 
										  LPCWSTR lpszNodeDescription);
TFSCORE_API(HRESULT) RegisterNodeType(LPCWSTR lpszGuidSnapin, 
									  LPCWSTR lpszGuidNode, 
									  LPCWSTR lpszNodeDescription);

TFSCORE_API(HRESULT) UnregisterNodeTypeGUID(const GUID* pGuid);
TFSCORE_API(HRESULT) UnregisterNodeType(LPCWSTR lpszNodeGuid);

// functions to register as an extension
TFSCORE_API(HRESULT) RegisterAsExtensionGUID(const GUID* pGuidNodeToExtend, 
											 const GUID* pGuidExtendingNode, 
											 LPCWSTR	 lpszNodeDescription,
											 DWORD		 dwExtensionType);

TFSCORE_API(HRESULT) RegisterAsExtension(LPCWSTR	lpszNodeToExtendGuid, 
										 LPCWSTR	lpszExtendingNodeGuid, 
										 LPCWSTR	lpszNodeDescription,
										 DWORD		dwExtensionType);

TFSCORE_API(HRESULT) RegisterAsRequiredExtensionGUID(const GUID* pGuidNodeToExtend, 
													 const GUID* pGuidExtensionSnapin, 
													 LPCWSTR	 lpszNodeDescription,
													 DWORD		 dwExtensionType,
													 const GUID* pGuidRequiredPrimarySnapin);


TFSCORE_API(HRESULT) RegisterAsRequiredExtension(LPCWSTR	lpszNodeToExtendGuid, 
												 LPCWSTR	lpszExtensionSnapin, 
												 LPCWSTR	lpszNodeDescription,
												 DWORD		dwExtensionType,
												 LPCWSTR	lpszRequiredPrimarySnapin);


// Same as the regular functions, but this also takes the
// name of another machine.
TFSCORE_API(HRESULT) RegisterAsRequiredExtensionGUIDEx(
    LPCWSTR pswzMachine,
    const GUID* pGuidNodeToExtend, 
    const GUID* pGuidExtensionSnapin, 
    LPCWSTR	lpszNodeDescription,
    DWORD	dwExtensionType,
    const GUID* pGuidRequiredPrimarySnapin);

TFSCORE_API(HRESULT) RegisterAsRequiredExtensionEx(
    LPCWSTR pswzMachine,
    LPCWSTR	lpszNodeToExtendGuid, 
    LPCWSTR	lpszExtensionSnapin, 
    LPCWSTR	lpszNodeDescription,
    DWORD	dwExtensionType,
    LPCWSTR	lpszRequiredPrimarySnapin);



// functions to unregister as an extension
TFSCORE_API(HRESULT) UnregisterAsExtensionGUID(const GUID* pGuidNodeToExtend, 
											   const GUID* pGuidExtension, 
											   DWORD	   dwExtensionType);
TFSCORE_API(HRESULT) UnregisterAsExtension(LPCWSTR lpszNodeToExtendGuid, 
										   LPCWSTR lpszExtension, 
										   DWORD   dwExtensionType);

TFSCORE_API(HRESULT) UnregisterAsRequiredExtensionGUID(const GUID* pGuidNodeToExtend, 
													   const GUID* pGuidExtension, 
													   DWORD	   dwExtensionType,
													   const GUID* pGuidRequiredPrimarySnapin);

TFSCORE_API(HRESULT) UnregisterAsRequiredExtension(LPCWSTR lpszNodeToExtendGuid, 
												   LPCWSTR lpszExtensionGuid, 
												   DWORD   dwExtensionType,
												   LPCWSTR lpszRequiredPrimarySnapin);


TFSCORE_API(HRESULT) UnregisterAsRequiredExtensionGUIDEx(
    LPCWSTR     lpszMachineName,
    const GUID* pGuidNodeToExtend, 
    const GUID* pGuidExtension, 
    DWORD	   dwExtensionType,
    const GUID* pGuidRequiredPrimarySnapin);

TFSCORE_API(HRESULT) UnregisterAsRequiredExtensionEx(
    LPCWSTR     lpszMachineName,
    LPCWSTR lpszNodeToExtendGuid, 
    LPCWSTR lpszExtensionGuid, 
    DWORD   dwExtensionType,
    LPCWSTR lpszRequiredPrimarySnapin);



// Registry error reporting API helpers
TFSCORE_API(void) ReportRegistryError(DWORD dwReserved, HRESULT hr, UINT nFormat, LPCTSTR pszFirst, va_list argptr);

TFSCORE_APIV(void) SetRegError(DWORD dwReserved, HRESULT hr, UINT nFormat, LPCTSTR pszFirst, ...);
#endif _REGISTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\service.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	service.h
		Calls to start and stop services.
			
    FILE HISTORY:
        
*/

#ifndef _SERVICE_H
#define _SERVICE_H

#if _MSC_VER >= 1000	// VC 5.0 or later
#pragma once
#endif

class DynamicDLL;

typedef enum _NetApiIndex
{
	NET_API_NET_SERVER_GET_INFO = 0,
};

// not subject to localization
static LPCSTR g_apchNetApiFunctionNames[] = {
	"NetServerGetInfo",
	NULL
};

// not subject to localization
extern DynamicDLL g_NetApiDLL;

typedef LONG (*NETSERVERGETINFO)   (LPTSTR, DWORD, LPBYTE *);

#ifdef __cplusplus
extern "C" {
#endif

TFSCORE_API(DWORD) TFSIsComputerNT(LPCTSTR pszComputer, BOOL * bIsNT);
TFSCORE_API(DWORD) TFSIsNTServer(LPCTSTR pszComputer, BOOL * bIsNTS);
TFSCORE_API(DWORD) TFSIsServiceRunning(LPCTSTR pszComputer, LPCTSTR pszServiceName, BOOL * fIsRunning);

TFSCORE_API(DWORD) TFSStartService(LPCTSTR pszComputer,	LPCTSTR pszServiceName, LPCTSTR pszServiceDesc);
TFSCORE_API(DWORD) TFSStartServiceEx(LPCTSTR pszComputer, LPCTSTR pszServiceName, LPCTSTR pszClusterResourceType, LPCTSTR pszServiceDesc);


TFSCORE_API(DWORD) TFSStopService(LPCTSTR pszComputer, LPCTSTR pszServiceName, LPCTSTR pszServiceDesc);
TFSCORE_API(DWORD) TFSStopServiceEx(LPCTSTR pszComputer, LPCTSTR pszServiceName, LPCTSTR pszClusterResourceType, LPCTSTR pszServiceDesc);


TFSCORE_API(DWORD) TFSPauseService(LPCTSTR pszComputer, LPCTSTR pszServiceName, LPCTSTR pszServiceDesc);


TFSCORE_API(DWORD) TFSResumeService(LPCTSTR pszComputer, LPCTSTR pszServiceName, LPCTSTR pszServiceDesc);


TFSCORE_API(DWORD) TFSGetServiceStatus(LPCWSTR pswzComputer, LPCWSTR pszServiceName, DWORD *pdwServiceStatus, DWORD *pdwErrorCode);
TFSCORE_API(DWORD) TFSGetServiceStartType(LPCWSTR pswzComputer, LPCWSTR pszServiceName, DWORD *pdwStartType);
TFSCORE_API(DWORD) TFSSetServiceStartType(LPCWSTR pswzComputer, LPCWSTR pszServiceName, DWORD dwStartType);

// internal fuctions
DWORD StartSCMService(LPCTSTR pszComputer, LPCTSTR pszServiceName, LPCTSTR pszServiceDesc);
DWORD StopSCMService(LPCTSTR pszComputer, LPCTSTR pszServiceName, LPCTSTR pszServiceDesc);
DWORD PauseSCMService(LPCTSTR pszComputer, LPCTSTR pszServiceName, LPCTSTR pszServiceDesc);
DWORD ResumeSCMService(LPCTSTR pszComputer, LPCTSTR pszServiceName, LPCTSTR pszServiceDesc);

#ifdef __cplusplus
} // extern "C"
#endif

#endif //_SERVICE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\tfsguid.c ===
/*----------------------------------------------------------------------------
	dbgguid.c
		Initialize debug GUIDs.

	Copyright (C) Microsoft Corporation, 1993 - 1997
	All rights reserved.

	Authors:
		GaryBu	Gary S. Burd, Microsoft

	History:
		05/27/93	GaryBu	Created.
		27 oct 95	garykac	DBCS_FILE_CHECK	debug file: BEGIN_STRING_OK
 ----------------------------------------------------------------------------*/

#include <windows.h>
#include <objbase.h>
#include <initguid.h>
#include "tfsguid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\stdafx.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	stdafx.h
		include file for standard system include files,
		or project specific include files that are used frequently,
		but are changed infrequently

    FILE HISTORY:
        
*/

#include <afxwin.h>
#include <afxdisp.h>
#include <afxcmn.h>
#include <afxtempl.h>
#include <clusapi.h>

#include <mmc.h>

#include "resource.h"
#include "tfsres.h"
#include "lm.h"       // For NetServerGetInfo and related structs/error codes
#include "svcctrl.h"
#include "tfscore.h"
#include "tfschar.h"

#ifndef _OLEINT_H
#include "oleint.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\std.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    std.h
//
// History:
//
//	03/15/97	Kenn Takara				Created.
//
//	Declarations for some common code/macros.
//============================================================================


#ifndef _STD_H_
#define _STD_H_

#if _MSC_VER >= 1000	// VC 5.0 or later
#pragma once
#endif

#ifndef _DBGUTIL_H
#include "dbgutil.h"
#endif

#include "malloc.h"

#ifndef TFSCORE_API
#define TFSCORE_API(type)	__declspec( dllexport ) type FAR PASCAL
#define TFSCORE_APIV(type)	__declspec( dllexport ) type FAR CDECL
#endif

#define hrOK		HRESULT(0)
#define hrTrue		HRESULT(0)
#define hrFalse		ResultFromScode(S_FALSE)
#define hrFail		ResultFromScode(E_FAIL)
#define hrNotImpl	ResultFromScode(E_NOTIMPL)
#define hrNoInterface	ResultFromScode(E_NOINTERFACE)
#define hrNoMem	ResultFromScode(E_OUTOFMEMORY)


#define OffsetOf(s,m)		(size_t)( (char *)&(((s *)0)->m) - (char *)0 )
#define EmbeddorOf(C,m,p)	((C *)(((char *)p) - OffsetOf(C,m)))
#define DimensionOf(rgx)	(sizeof((rgx)) / sizeof(*(rgx)))


/*!--------------------------------------------------------------------------
	DeclareSP,	DeclareSPBasic
	DeclareSRG,	DeclareSRGBasic
	DeclareSPT,	DeclareSPTBasic
	DeclareSPM,	DeclareSPMBasic

	These macros declare 'smart' pointers.  Smart pointers behave like
	normal pointers with the exception that a smart pointer destructor
	frees the thing it is pointing at and assignment to a non-null smart
	pointer is not allowed.

	The DeclareSxx macros differ by how the generated smart pointer frees
	the memory:

	Macro					Free			Smart Pointer Type
	======================	============	==================
	DeclareSP(TAG, Type)	delete p;		SPTAG
	DeclareSRG(TAG, Type)	delete [] p;	SRGTAG
	DeclareSPT(TAG, Type)	TMemFree(p);	SPTTAG
	DeclareSPM(TAG, Type)	MMemFree(p);	SPMTAG

	NOTE: use the 'Basic' variants (DeclareSPBasic, etc) for pointer to
	non-struct types (e.g. char, int, etc).
	
	Smart pointers have two methods:

	void SPTAG::Free()
		Free and then null the internally maintained pointer.

	Type *SPTAG::Transfer()
		Transfers pointer ownership to caller.  The internally
		maintained pointer is cleared on exit.

	Author: GaryBu
 ---------------------------------------------------------------------------*/

#define DeclareSP(TAG,Type)  DeclareSmartPointer(SP##TAG,Type,delete m_p)
#define DeclareSRG(TAG,Type) DeclareSmartPointer(SRG##TAG,Type,delete [] m_p)
#define DeclareSPT(TAG,Type) DeclareSmartPointer(SPT##TAG,Type,TMemFree(m_p))
#define DeclareSPM(TAG,Type) DeclareSmartPointer(SPM##TAG,Type,MMemFree(m_p))

#define DeclareSPBasic(TAG,Type)\
	DeclareSPPrivateBasic(SP##TAG,Type, delete m_p)
#define DeclareSRGBasic(TAG,Type)\
	DeclareSPPrivateBasic(SRG##TAG,Type, delete [] m_p)
#define DeclareSPTBasic(TAG,Type)\
	DeclareSPPrivateBasic(SPT##TAG,Type,TMemFree(m_p))
#define DeclareSPMBasic(TAG,Type)\
	DeclareSPPrivateBasic(SPM##TAG,Type,MMemFree(m_p))

#define DeclareSPPrivateCore(klass, Type, free)\
class klass \
{\
public:\
	klass()					{ m_p = 0; }\
	klass(Type *p)			{ m_p = p; }\
	~klass()				{ free; }\
	operator Type*() const	{ return m_p; }\
	Type &operator*() const	{ return *m_p; }\
	Type &operator[](int i) const	{ return m_p[i]; }\
	Type &nth(int i) const	{ return m_p[i]; }\
	Type **operator &()		{ Assert(!m_p); return &m_p; }\
	Type *operator=(Type *p){ Assert(!m_p); return m_p = p; }\
	Type *Transfer()		{ Type *p = m_p; m_p = 0; return p; }\
	void Free()				{ free; m_p = 0; }\
private:\
	void *operator=(const klass &);\
	klass(const klass &);\
	Type *m_p;

#define DeclareSPPrivateBasic(klass, Type, free)\
	DeclareSPPrivateCore(klass, Type, free)\
};

/*!--------------------------------------------------------------------------
	DeclareSPBasicEx
		Variant of smart pointers that allows an extra member variable.

	The klassFree parameter lets you supply an alias for Free().
	
	An example is IPropertyAccess and StdRowEditingTable:

		DeclareSPPrivateBasicEx(SPIPropertyAccess,IPropertyAccess,
			m_pex->ReleaseContext(m_p), StdRowEditingTable, ReleaseContext)

		SPIPropertyAccess	sppac(pstdtable);
		sppac = pstdtable->GetContext(0);
		...use spfc...
		sppac.ReleaseContext();

	Author: KennT
 ---------------------------------------------------------------------------*/
#define DeclareSPBasicEx(klass, Type, free, klassEx, klassFree)\
	DeclareSPPrivateCore(klass, Type, free)\
public:\
	klass(klassEx *pex) \
		{\
			m_p = 0; m_pex=pex; } \
	void klassFree() \
		{ Free(); } \
private:\
	klassEx	*m_pex; \
};

#define DeclareSmartPointer(klass, Type, free)\
	DeclareSPPrivateCore(klass, Type, free)\
public:\
	Type * operator->() const	{ return m_p; }\
};


TFSCORE_API(HRESULT) HrQueryInterface(IUnknown *punk, REFIID iid, LPVOID *ppv);

template <class T, const IID *piid>
class ComSmartPointer
{
public:
	typedef T _PtrClass;
	ComSmartPointer() {p=NULL;}
	~ComSmartPointer() { Release(); }
	// set p to NULL before releasing, this fixes a subtle bug
	// A has a ptr to B, B has a ptr to A
	//	A gets told to release B
	//  A calls spB.Release();
	//    in spB.Release(), B gets destructed and calls spA.Release()
	//      in spA.Release(), A gets destructed and calls spB.Release()
	//      since the ptr in spB has not been set to NULL (which is bad
	//      since B has already gone away).
	void Release() {T* pTemp = p; if (p) { p=NULL; pTemp->Release(); }}
	operator T*() {return (T*)p;}
	T& operator*() {Assert(p!=NULL); return *p; }
	T** operator&() { Assert(p==NULL); return &p; }
	T* operator->() { Assert(p!=NULL); return p; }
	T* operator=(T* lp){ Release(); p = lp; return p;}
	T* operator=(const ComSmartPointer<T,piid>& lp)
	{
		if (p)
			p->Release();
		p = lp.p;
		return p;
	}
	void Set(T* lp) { Release(); p = lp; if (p) p->AddRef(); }
	T * Transfer() { T* pTemp=p; p=NULL; return pTemp; }
	BOOL operator!(){return (p == NULL) ? TRUE : FALSE;}
	void Query(IUnknown *punk)
			{ HrQuery(punk); }
	HRESULT HrQuery(IUnknown *punk)
			{ return ::HrQueryInterface(punk, *piid, (LPVOID *) &p); }
	T* p;

private:
	// These methods should NEVER get called.
	ComSmartPointer(T* lp);
	ComSmartPointer(const ComSmartPointer<T,piid>& lp);
};




// Interface utilities
TFSCORE_API(void)  SetI(IUnknown * volatile *punkL, IUnknown *punkR);
TFSCORE_API(void)  ReleaseI(IUnknown *punk);



// Utilities for dealing with embedded classes
#define DeclareEmbeddedInterface(interface, base) \
    class E##interface : public interface \
		{ \
    public: \
		Declare##base##Members(IMPL) \
		Declare##interface##Members(IMPL) \
    } m_##interface; \
    friend class E##interface;


#define ImplementEmbeddedUnknown(embeddor, interface) \
    STDMETHODIMP embeddor::E##interface::QueryInterface(REFIID iid,void **ppv)\
		{ \
		return EmbeddorOf(embeddor,m_##interface,this)->QueryInterface(iid,ppv);\
		} \
	STDMETHODIMP_(ULONG) embeddor::E##interface::AddRef() \
		{ \
		return EmbeddorOf(embeddor, m_##interface, this)->AddRef(); \
		} \
	STDMETHODIMP_(ULONG) embeddor::E##interface::Release() \
		{ \
		return EmbeddorOf(embeddor, m_##interface, this)->Release(); \
		}

#define ImplementEmbeddedUnknownNoRefCount(embeddor, interface) \
    STDMETHODIMP embeddor::E##interface::QueryInterface(REFIID iid,void **ppv)\
		{ \
		return EmbeddorOf(embeddor,m_##interface,this)->QueryInterface(iid,ppv);\
		}

#define EMPrologIsolated(embeddor, interface, method) \
	embeddor *pThis = EmbeddorOf(embeddor, m_##interface, this);

#define ImplementIsolatedUnknown(embeddor, interface) \
    STDMETHODIMP embeddor::E##interface::QueryInterface(REFIID iid,void **ppv)\
		{ \
		EMPrologIsolated(embeddor, interface, QueryInterface); \
		Assert(!FHrSucceeded(pThis->QueryInterface(IID_##interface, ppv))); \
		*ppv = 0; \
		if (iid == IID_IUnknown)		*ppv = (IUnknown *) this; \
		else if (iid == IID_##interface)	*ppv = (interface *) this; \
		else return ResultFromScode(E_NOINTERFACE); \
		((IUnknown *) *ppv)->AddRef(); \
		return HRESULT_OK; \
		} \
	STDMETHODIMP_(ULONG) embeddor::E##interface::AddRef() \
		{ \
		EMPrologIsolated(embeddor, interface, AddRef) \
		return 1; \
		} \
	STDMETHODIMP_(ULONG) embeddor::E##interface::Release() \
		{ \
		EMPrologIsolated(embeddor, interface, Release) \
		return 1; \
		}

#define InitPThis(embeddor, object)\
	embeddor *pThis = EmbeddorOf(embeddor, m_##object, this);\


/*---------------------------------------------------------------------------
	Implements the controlling IUnknown interface for the inner object
	of an aggregation.
 ---------------------------------------------------------------------------*/
#define IMPLEMENT_AGGREGATION_IUNKNOWN(klass) \
STDMETHODIMP_(ULONG) klass::AddRef() \
{ \
	Assert(m_pUnknownOuter); \
	return m_pUnknownOuter->AddRef(); \
} \
STDMETHODIMP_(ULONG) klass::Release() \
{ \
	Assert(m_pUnknownOuter); \
	return m_pUnknownOuter->Release(); \
} \
STDMETHODIMP klass::QueryInterface(REFIID riid, LPVOID *ppv) \
{ \
	Assert(m_pUnknownOuter); \
	return m_pUnknownOuter->QueryInterface(riid, ppv); \
} \

/*---------------------------------------------------------------------------
	Declares the non-delegating IUnknown implementation in a class.
 ---------------------------------------------------------------------------*/
#define DECLARE_AGGREGATION_NONDELEGATING_IUNKNOWN(klass) \
class ENonDelegatingIUnknown : public IUnknown \
{ \
	public: \
		DeclareIUnknownMembers(IMPL) \
} m_ENonDelegatingIUnknown; \
friend class ENonDelegatingIUnknown; \
IUnknown *m_pUnknownOuter; \

/*---------------------------------------------------------------------------
	Implements the non-delegating IUnknown for a class.
 ---------------------------------------------------------------------------*/
#define IMPLEMENT_AGGREGATION_NONDELEGATING_ADDREFRELEASE(klass,interface) \
STDMETHODIMP_(ULONG) klass::ENonDelegatingIUnknown::AddRef() \
{ \
	InitPThis(klass, ENonDelegatingIUnknown); \
	return InterlockedIncrement(&(pThis->m_cRef)); \
} \
STDMETHODIMP_(ULONG) klass::ENonDelegatingIUnknown::Release() \
{ \
	InitPThis(klass, ENonDelegatingIUnknown); \
	if (0 == InterlockedDecrement(&(pThis->m_cRef))) \
	{ \
		delete pThis; \
		return 0; \
	} \
	return pThis->m_cRef; \
} \


#define IMPLEMENT_AGGREGATION_NONDELEGATING_IUNKNOWN(klass,interface) \
IMPLEMENT_AGGREGATION_NONDELEGATING_ADDREFRELEASE(klass,interface) \
STDMETHODIMP klass::ENonDelegatingIUnknown::QueryInterface(REFIID riid, LPVOID *ppv) \
{ \
	InitPThis(klass, ENonDelegatingIUnknown);	 \
	if (ppv == NULL) \
		return E_INVALIDARG; \
	*ppv = NULL; \
	if (riid == IID_IUnknown) \
		*ppv = (IUnknown *) this; \
	else if (riid == IID_##interface) \
		*ppv = (interface *) pThis; \
	else \
		return E_NOINTERFACE; \
	((IUnknown *)*ppv)->AddRef(); \
	return hrOK; \
} \

													




/*---------------------------------------------------------------------------
	Standard TRY/CATCH wrappers for the COM interfaces
 ---------------------------------------------------------------------------*/

#define COM_PROTECT_TRY \
	try

#define COM_PROTECT_ERROR_LABEL	Error: ;\

#ifdef DEBUG
#define COM_PROTECT_CATCH \
	catch(CException *pe) \
	{ \
		hr = COleException::Process(pe); \
	} \
	catch(...) \
	{ \
		hr = E_FAIL; \
	} 
#else
#define COM_PROTECT_CATCH \
	catch(CException *pe) \
	{ \
		hr = COleException::Process(pe); \
	} \
	catch(...) \
	{ \
		hr = E_FAIL; \
	} 
#endif

/*---------------------------------------------------------------------------
	Some useful smart pointers
 ---------------------------------------------------------------------------*/
DeclareSPPrivateBasic(SPSZ, TCHAR, delete[] m_p);
DeclareSPPrivateBasic(SPWSZ, WCHAR, delete[] m_p);
DeclareSPPrivateBasic(SPASZ, char, delete[] m_p);
DeclareSPPrivateBasic(SPBYTE, BYTE, delete m_p);

typedef ComSmartPointer<IUnknown, &IID_IUnknown> SPIUnknown;
typedef ComSmartPointer<IStream, &IID_IStream> SPIStream;
typedef ComSmartPointer<IPersistStreamInit, &IID_IPersistStreamInit> SPIPersistStreamInit;


#endif // _STD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\svcctrl.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	svcctrl.h
		Prototypes for the dialog that pops up while waiting
		for the server to start.
		
    FILE HISTORY:
        
*/


#if !defined(AFX_STARTSVC_H__0B2EAD4B_929C_11D0_9800_00C04FC3357A__INCLUDED_)
#define AFX_STARTSVC_H__0B2EAD4B_929C_11D0_9800_00C04FC3357A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "clusapi.h"

// startsvc.h : header file
//
//
//  TIMER_FREQ is the frequency of our timer messages.
//  TIMER_MULT is a multiplier.  We'll actually poll the
//  service every (TIMER_FREQ * TIMER_MULT) seconds.
//  This allows us to advance the progress indicator more
//  fequently than we hit the net.  Should keep the user better
//  amused.
//

#define TIMER_ID   29
#define TIMER_FREQ 500
#define TIMER_MULT 6
#define POLL_TIMER_FREQ (TIMER_FREQ * TIMER_MULT)
#define POLL_DEFAULT_MAX_TRIES 1
#define PROGRESS_ICON_COUNT	12

/////////////////////////////////////////////////////////////////////////////
// CServiceCtrlDlg dialog

class CServiceCtrlDlg : public CDialog
{
// Construction
public:
	CServiceCtrlDlg(SC_HANDLE hService,
					LPCTSTR pServerName,
					LPCTSTR pszServiceDesc,
					BOOL bStart, CWnd* pParent = NULL);   // standard constructor

	CServiceCtrlDlg(HRESOURCE hResource,
				LPCTSTR pServerName,
				LPCTSTR pszServiceDesc,
				BOOL bStart, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CServiceCtrlDlg)
	enum { IDD = IDD_SERVICE_CTRL_DIALOG };
	CStatic	m_staticMessage;
	CStatic	m_iconProgress;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CServiceCtrlDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CServiceCtrlDlg)
	afx_msg void OnTimer(UINT nIDEvent);
	virtual BOOL OnInitDialog();
	afx_msg void OnClose();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
    DWORD       m_dwErr;

private:
    void UpdateIndicator();

    BOOL CheckForError(SERVICE_STATUS * pServiceStats);
    BOOL CheckForClusterError(SERVICE_STATUS * pServiceStats);

	void CheckService();
	void CheckClusterService();

	void GetClusterResourceTimeout();

private:
	SC_HANDLE	m_hService;
	HRESOURCE	m_hResource;

	UINT_PTR	m_timerId;
	
	int			m_nTickCounter;
	int			m_nTotalTickCount;
	
	CString		m_strServerName;
	CString		m_strServiceDesc;
	
	BOOL		m_bStart;
    
	DWORD       m_dwTickBegin;
    DWORD       m_dwWaitPeriod;
    DWORD       m_dwLastCheckPoint;
};



/*---------------------------------------------------------------------------
	Class:  CWaitDlg

    This is a generic wait dialog (this can be used by anyone).
 ---------------------------------------------------------------------------*/
class CWaitDlg : public CDialog
{
// Construction
public:
	CWaitDlg(LPCTSTR pServerName,
             LPCTSTR pszText,
             LPCTSTR pszTitle,
             CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CWaitDlg)
	enum { IDD = IDD_SERVICE_CTRL_DIALOG };
	CStatic	m_staticMessage;
	CStatic	m_iconProgress;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CServiceCtrlDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CServiceCtrlDlg)
	afx_msg void OnTimer(UINT nIDEvent);
	virtual BOOL OnInitDialog();
	afx_msg void OnClose();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    // Override this function to provide your own implementation
    // To exit out of the dialog, call CDialog::OnOK() here.
    virtual void    OnTimerTick()
    {
        CDialog::OnOK();
    }

    void    CloseTimer();

	CString		m_strServerName;
    CString     m_strText;
    CString     m_strTitle;
    
private:
    void UpdateIndicator();

	UINT_PTR		m_timerId;
	int			m_nTickCounter;
	int			m_nTotalTickCount;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STARTSVC_H__0B2EAD4B_929C_11D0_9800_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\tfschar.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:	tfschar.h
//
//	String functions that are used in general for TFS code.
//
// History:
//
//	05/28/97	Kenn Takara				Created.
//
//	Declarations for some common code/macros.
//============================================================================


#ifndef _TFSCHAR_H
#define _TFSCHAR_H

#if _MSC_VER >= 1000	// VC 5.0 or later
#pragma once
#endif


#ifndef _STD_H
#include "std.h"
#endif

//$ Win95: kennt, the list of Unicode-enabled functions on Win95 will
// have to be checked.  Does lstrlenW work, but lstrcpyW doesn't? (that's
// what the ATL versions of the functions imply).


/*---------------------------------------------------------------------------
	String copy functions
 ---------------------------------------------------------------------------*/

// Baisc conversion functions
TFSCORE_API(LPSTR)	StrCpyAFromW(LPSTR psz, LPCWSTR pswz);
TFSCORE_API(LPWSTR)	StrCpyWFromA(LPWSTR pswz, LPCSTR psz);

TFSCORE_API(LPSTR)	StrnCpyAFromW(LPSTR psz, LPCWSTR pswz, int iMax);
TFSCORE_API(LPWSTR)	StrnCpyWFromA(LPWSTR pswz, LPCSTR psz, int iMax);

#define	StrCpy		lstrcpy
#define StrnCpy		lstrcpyn

#define StrCpyW		lstrcpyW
#define StrCpyA		lstrcpyA
#define StrnCpyW	lstrcpynW
#define StrnCpyA	lstrcpynA

#define StrCpyOle	StrCpyW
#define StrnCpyOle	StrnCpyW

#ifdef _UNICODE

	#define StrCpyAFromT	StrCpyAFromW
	#define StrCpyTFromA	StrCpyWFromA
	#define StrCpyTFromW	lstrcpy
	#define StrCpyWFromT	lstrcpy

	#define StrnCpyAFromT	StrnCpyAFromW
	#define StrnCpyTFromA	StrnCpyWFromA
	#define StrnCpyTFromW	lstrcpyn
	#define StrnCpyWFromT	lstrcpyn

#else
	
	#define StrCpyAFromT	lstrcpy
	#define StrCpyTFromA	lstrcpy
	#define	StrCpyTFromW	StrCpyAFromW
	#define StrCpyWFromT	StrCpyWFromA

	#define StrnCpyAFromT	lstrcpyn
	#define StrnCpyTFromA	lstrcpyn
	#define	StrnCpyTFromW	StrnCpyAFromW
	#define StrnCpyWFromT	StrnCpyWFromA

#endif


#define StrCpyOleFromT		StrCpyWFromT
#define StrCpyTFromOle		StrCpyTFromW

#define StrCpyOleFromA		StrCpyWFromA
#define StrCpyAFromOle		StrCpyAFromW
#define StrCpyWFromOle		StrCpyW
#define StrCpyOleFromW		StrCpyW

#define StrnCpyOleFromT		StrnCpyWFromT
#define StrnCpyTFromOle		StrnCpyTFromW
#define StrnCpyOleFromA		StrnCpyWFromA
#define StrnCpyAFromOle		StrnCpyAFromW
#define StrnCpyOleFromW		StrnCpyW
#define StrnCpyWFromOle		StrnCpyW


/*---------------------------------------------------------------------------
	String length functions
 ---------------------------------------------------------------------------*/

#define StrLen			lstrlen
#define StrLenA			lstrlenA
#define StrLenW			lstrlenW
#define StrLenOle		StrLenW

//
//	CbStrLenA() is inaccurate for DBCS strings!  It will return the
//	incorrect number of bytes needed.
//

#define CbStrLenA(psz)	((StrLenA(psz)+1)*sizeof(char))
#define CbStrLenW(psz)	((StrLenW(psz)+1)*sizeof(WCHAR))

#ifdef _UNICODE
	#define CbStrLen(psz)	CbStrLenW(psz)
#else
	#define CbStrLen(psz)	CbStrLenA(psz)
#endif


// Given a number of characters, this it the minimal number of TCHARs
// that needs to be allocated to hold the string
#define MinTCharNeededForCch(ch)	((ch) * (2/sizeof(TCHAR)))
#define MinCbNeededForCch(ch)		(sizeof(TCHAR)*MinTCharNeededForCch(ch))

// Given a cb (count of bytes) this is the maximal number of characters
// that can be in this string
#define MaxCchFromCb(cb)		((cb) / sizeof(TCHAR))


#ifdef _UNICODE
	// Given a cb, this is the minimum number of chars found in this string
	// MinCchFromCb
	#define MinCchFromCb(cb)	((cb) / sizeof(WCHAR))
#else
	// Number of characters is only half due to DBCS
	#define MinCchFromCb(cb)	((cb) / (2*sizeof(char)))
#endif

/*---------------------------------------------------------------------------
	String dup functions

	The returned string from these functions must be freed using delete!
 ---------------------------------------------------------------------------*/
	
TFSCORE_API(LPSTR)	StrDupA( LPCSTR psz );
TFSCORE_API(LPWSTR)	StrDupW( LPCWSTR pws );

TFSCORE_API(LPSTR)	StrDupAFromW( LPCWSTR pwsz );
TFSCORE_API(LPWSTR)	StrDupWFromA( LPCSTR psz );

#ifdef _UNICODE
	#define	StrDup			StrDupW
	#define StrDupTFromW	StrDupW
	#define StrDupWFromT	StrDupW
	#define	StrDupTFromA	StrDupWFromA
	#define StrDupAFromT	StrDupAFromW

	#define StrDupOleFromA	StrDupWFromA
	#define StrDupAFromOle	StrDupAFromW
	#define StrDupOleFromW	StrDupW
	#define StrDupWFromOle	StrDupW
	#define StrDupOleFromT	StrDupOleFromW
	#define StrDupTFromOle	StrDupWFromOle
#else
	#define StrDup			StrDupA
	#define StrDupTFromA	StrDupA
	#define StrDupAFromT	StrDupA
	#define StrDupTFromW	StrDupAFromW
	#define StrDupWFromT	StrDupWFromT

	#define StrDupOleFromA	StrDupWFromA
	#define StrDupAFromOle	StrDupAFromW
	#define StrDupOleFromW	StrDupW
	#define StrDupWFromOle	StrDupW
	#define StrDupOleFromT	StrDupOleFromA
	#define StrDupTFromOle	StrDupAFromOle
#endif


//	AllocaStrDup
//	AllocaStrDupA
//	AllocaStrDupW
//
//	These functions will dup a string on the STACK.
//
#define AllocaStrDupA(lpa) (\
	((LPCSTR)lpa == NULL) ? NULL : (\
		StrCpyA((LPSTR) alloca(CbStrLenA(lpa)*2), lpa)))

#define AllocaStrDupW(lpw) (\
	((LPCWSTR)lpw == NULL) ? NULL : (\
		StrCpyW((LPWSTR) alloca(CbStrLenW(lpw)), lpw)))

#ifdef _UNICODE
	#define AllocaStrDup	AllocaStrDupW
#else
	#define AllocaStrDup	AllocaStrDupA
#endif





/*---------------------------------------------------------------------------
	String comparison functions
 ---------------------------------------------------------------------------*/
#define StrCmpA		lstrcmpA
#define StrCmpW		lstrcmpW
#define StrCmpOle	StrCmpW

TFSCORE_API(int) StrnCmpA(LPCSTR psz1, LPCSTR psz2, int nLen);
TFSCORE_API(int) StrnCmpW(LPCWSTR pswz1, LPCWSTR pswz2, int nLen);

#define StriCmpA	lstrcmpiA
#define StriCmpW	lstrcmpiW
#define StriCmpOle	StriCmpW

TFSCORE_API(int) StrniCmpA(LPCSTR psz1, LPCSTR psz2, int nLen);
TFSCORE_API(int) StrniCmpW(LPCWSTR pswz1, LPCWSTR pswz2, int nLen);


#ifdef _UNICODE
	#define StrCmp		StrCmpW
	#define StrnCmp		StrnCmpW
	#define StriCmp		StriCmpW
	#define StrniCmp	StrniCmpW
#else
	#define StrCmp		StrCmpA
	#define StrnCmp		StrnCmpA
	#define StriCmp		StriCmpA
	#define StrniCmp	StrniCmpA
#endif


/*---------------------------------------------------------------------------
	String concatenation routines
 ---------------------------------------------------------------------------*/
#define	StrCatW			lstrcatW
#define StrCatA			lstrcatA

#ifdef _UNICODE
	#define StrCat		StrCatW
#else
	#define StrCat		StrCatA
#endif



/*---------------------------------------------------------------------------
	Local conversion routines (conversions performed on stack!)
 ---------------------------------------------------------------------------*/

// Make sure MFC's afxconv.h hasn't already been loaded to do this
#include "atlconv.h"

#endif	// _TFSCHAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\tfschar.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       tfschar.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "tfschar.h"

/*!--------------------------------------------------------------------------
	StrCpyAFromW
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(LPSTR)	StrCpyAFromW(LPSTR psz, LPCWSTR pswz)
{
	USES_CONVERSION;
	return StrCpyA(psz, W2CA(pswz));
}

/*!--------------------------------------------------------------------------
	StrCpyWFromA
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(LPWSTR)	StrCpyWFromA(LPWSTR pswz, LPCSTR psz)
{
	USES_CONVERSION;
	return StrCpyW(pswz, A2CW(psz));
}

/*!--------------------------------------------------------------------------
	StrnCpyAFromW
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(LPSTR)	StrnCpyAFromW(LPSTR psz, LPCWSTR pswz, int iMax)
{
	USES_CONVERSION;
	return StrnCpyA(psz, W2CA(pswz), iMax);
}

/*!--------------------------------------------------------------------------
	StrnCpyWFromA
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(LPWSTR)	StrnCpyWFromA(LPWSTR pswz, LPCSTR psz, int iMax)
{
	USES_CONVERSION;
	return StrnCpyW(pswz, A2CW(psz), iMax);
}

/*!--------------------------------------------------------------------------
	StrDupA
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(LPSTR)	StrDupA( LPCSTR psz )
{
	// Multiply by 2 to account for DBCS strings
	LPSTR	pszcpy = new char[CbStrLenA(psz)*2];
	return StrCpyA(pszcpy, psz);
}

/*!--------------------------------------------------------------------------
	StrDupW
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(LPWSTR)	StrDupW( LPCWSTR pswz )
{
	LPWSTR	pswzcpy = new WCHAR[CbStrLenW(pswz)];
	return StrCpyW(pswzcpy, pswz);
}


/*!--------------------------------------------------------------------------
	StrDupAFromW
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(LPSTR)	StrDupAFromW( LPCWSTR pwsz )
{
	USES_CONVERSION;
	return StrDupA( W2CA(pwsz) );
}

/*!--------------------------------------------------------------------------
	StrDupWFromA
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(LPWSTR)	StrDupWFromA( LPCSTR psz )
{
	USES_CONVERSION;
	return StrDupW( A2CW(psz) );
}



/*!--------------------------------------------------------------------------
	StrnCmpA
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(int) StrnCmpA(LPCSTR psz1, LPCSTR psz2, int nLen)
{
	USES_CONVERSION;
	// It's easier to convert it to a wide string than do the
	// conversion.  (it's a pain having to deal with DBCS characters).
	return StrnCmpW(A2CW(psz1), A2CW(psz2), nLen);
}


/*!--------------------------------------------------------------------------
	StrnCmpW
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(int) StrnCmpW(LPCWSTR pswz1, LPCWSTR pswz2, int nLen)
{
	WCHAR *pswz1Temp = AllocaStrDupW(pswz1);
	WCHAR *pswz2Temp = AllocaStrDupW(pswz2);

	if (pswz1Temp && StrLenW(pswz1Temp) > nLen)
		pswz1Temp[nLen] = 0;
	if (pswz2Temp && StrLenW(pswz2Temp) > nLen)
		pswz2Temp[nLen] = 0;
	
	return StrCmpW(pswz1Temp, pswz2Temp);
}


/*!--------------------------------------------------------------------------
	StrniCmpA
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(int) StrniCmpA(LPCSTR psz1, LPCSTR psz2, int nLen)
{
	CHAR *psz1Temp = AllocaStrDupA(psz1);
	CHAR *psz2Temp = AllocaStrDupA(psz2);

	if (psz1Temp)
        CharUpperBuffA(psz1Temp, StrLenA(psz1Temp));

    if (psz2Temp)
	    CharUpperBuffA(psz2Temp, StrLenA(psz2Temp));

    return StrnCmpA(psz1Temp, psz2Temp, nLen);
}


/*!--------------------------------------------------------------------------
	StrniCmpW
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(int) StrniCmpW(LPCWSTR pswz1, LPCWSTR pswz2, int nLen)
{
	WCHAR *pswz1Temp = AllocaStrDupW(pswz1);
	WCHAR *pswz2Temp = AllocaStrDupW(pswz2);

	if (pswz1Temp)
        CharUpperBuffW(pswz1Temp, StrLenW(pswz1Temp));

    if (pswz2Temp)
	    CharUpperBuffW(pswz2Temp, StrLenW(pswz2Temp));

	return StrnCmpW(pswz1Temp, pswz2Temp, nLen);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\svcctrl.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	svcctrl.cpp
		Implementation for the dialog that pops up while waiting
		for the server to start.
		
    FILE HISTORY:
	
*/

#include "stdafx.h"
#include "cluster.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CServiceCtrlDlg dialog


CServiceCtrlDlg::CServiceCtrlDlg
(
	SC_HANDLE       hService,
	LPCTSTR         pServerName,
	LPCTSTR			pszServiceDesc,
	BOOL			bStart,
	CWnd*           pParent /*=NULL*/
)
	: CDialog(CServiceCtrlDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CServiceCtrlDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	
	m_hService = hService;
	m_hResource = NULL;
	m_nTickCounter = TIMER_MULT;
	m_nTotalTickCount = 0;
	m_strServerName = pServerName;
	m_strServerName.MakeUpper();
	m_strServiceDesc = pszServiceDesc;
	m_bStart = bStart;
	m_timerId = 0;
    m_dwErr = 0;
    m_dwLastCheckPoint = -1;
}


CServiceCtrlDlg::CServiceCtrlDlg
(
	HRESOURCE       hResource,
	LPCTSTR         pServerName,
	LPCTSTR			pszServiceDesc,
	BOOL			bStart,
	CWnd*           pParent /*=NULL*/
)
	: CDialog(CServiceCtrlDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CServiceCtrlDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	
	m_hService = NULL;
	m_hResource = hResource;
	m_nTickCounter = TIMER_MULT;
	m_nTotalTickCount = 0;
	m_strServerName = pServerName;
	m_strServerName.MakeUpper();
	m_strServiceDesc = pszServiceDesc;
	m_bStart = bStart;
	m_timerId = 0;
    m_dwErr = 0;
    m_dwLastCheckPoint = -1;
}

void CServiceCtrlDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServiceCtrlDlg)
	DDX_Control(pDX, IDC_STATIC_MESSAGE, m_staticMessage);
	DDX_Control(pDX, IDC_ICON_PROGRESS, m_iconProgress);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CServiceCtrlDlg, CDialog)
	//{{AFX_MSG_MAP(CServiceCtrlDlg)
	ON_WM_TIMER()
	ON_WM_CLOSE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServiceCtrlDlg message handlers

BOOL CServiceCtrlDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	m_timerId = SetTimer(TIMER_ID, TIMER_FREQ, NULL);

	CString strTemp;
    CString strTitle;
    UINT    idsTitle;
    
	if (m_bStart)
	{
		AfxFormatString2(strTemp, IDS_STARTING_SERVICE_NOW, m_strServerName,
						m_strServiceDesc);
        idsTitle = IDS_START_SERVICE_TITLE;
	}
	else
	{
		AfxFormatString2(strTemp, IDS_STOPPING_SERVICE_NOW, m_strServerName,
						m_strServiceDesc);
        idsTitle = IDS_STOP_SERVICE_TITLE;
	}

	m_staticMessage.SetWindowText(strTemp);

    // Setup the title of the window
    strTitle.Format(idsTitle, (LPCTSTR) m_strServiceDesc);
    SetWindowText(strTitle);

	UpdateIndicator();

    m_dwTickBegin = GetTickCount();

	if (m_hService)
	{
		// get the wait period 
		SERVICE_STATUS  serviceStatus;
		::ZeroMemory(&serviceStatus, sizeof(serviceStatus));

		if (QueryServiceStatus(m_hService, &serviceStatus))
		{
			m_dwWaitPeriod = serviceStatus.dwWaitHint;
		}
	}
    else
    {
		GetClusterResourceTimeout();
    }

    return TRUE;  // return TRUE unless you set the focus to a control
		          // EXCEPTION: OCX Property Pages should return FALSE
}

void CServiceCtrlDlg::OnClose() 
{
	if (m_timerId)
		KillTimer(m_timerId);
	
	CDialog::OnClose();
}

void CServiceCtrlDlg::OnTimer(UINT nIDEvent) 
{
    //
    //  Bag-out if it's not our timer.
    //
    if(nIDEvent != TIMER_ID)
    {
	return;
    }

    //
    //  Advance the progress indicator.
    //
    UpdateIndicator();

    //
    //  No need to continue if we're just amusing the user.
    //
    if(--m_nTickCounter > 0)
    {
	return;
    }

    m_nTickCounter = TIMER_MULT;

    //
    //  Poll the service to see if the operation is
    //  either complete or continuing as expected.
    //
	
	if (m_hService)
	{
		CheckService();
	}
	else
	{
		CheckClusterService();
	}

}

void
CServiceCtrlDlg::GetClusterResourceTimeout()
{
	DWORD dwError			= 0;
	DWORD cPropListSize		= 0;
	DWORD cPropListAlloc	= MAX_NAME_SIZE;
	DWORD dwPendingTimeout	= 0;

	// set the default
	m_dwWaitPeriod = 18000;

	if ( !g_ClusDLL.LoadFunctionPointers() )
		return;

	if ( !g_ResUtilsDLL.LoadFunctionPointers() )
		return;

	PCLUSPROP_LIST pPropList = (PCLUSPROP_LIST)LocalAlloc(LPTR, MAX_NAME_SIZE);

	//
	// get the wait timeout value 
	//
    dwError = ((CLUSTERRESOURCECONTROL) g_ClusDLL[CLUS_CLUSTER_RESOURCE_CONTROL])( m_hResource, 
                                                                                   NULL, 
                                                                                   CLUSCTL_RESOURCE_GET_COMMON_PROPERTIES, 
                                                                                   NULL, 
                                                                                   0,
                                                                                   pPropList,
                                                                                   cPropListAlloc,
                                                                                   &cPropListSize);
    //
    // Reallocation routine if pPropList is too small
    //
    if ( dwError == ERROR_MORE_DATA )
    {
        LocalFree( pPropList );

        cPropListAlloc = cPropListSize;

        pPropList = (PCLUSPROP_LIST) LocalAlloc( LPTR, cPropListAlloc );

        dwError = ((CLUSTERRESOURCECONTROL) g_ClusDLL[CLUS_CLUSTER_RESOURCE_CONTROL])( m_hResource, 
                                                                                       NULL, 
                                                                                       CLUSCTL_RESOURCE_GET_COMMON_PROPERTIES, 
                                                                                       NULL, 
                                                                                       0,
                                                                                       pPropList,
                                                                                       cPropListAlloc,
                                                                                       &cPropListSize);
    }

	//
	// find the pending timeout property
	//
	dwError = ((RESUTILSFINDDWORDPROPERTY) g_ResUtilsDLL[RESUTILS_FIND_DWORD_PROPERTY])(pPropList,
																					    cPropListSize,
																					    _T("PendingTimeout"),
																					    &dwPendingTimeout);

	if (dwError == ERROR_SUCCESS)
	{
		m_dwWaitPeriod = dwPendingTimeout;
	}

	LocalFree( pPropList );
}

BOOL
CServiceCtrlDlg::CheckForError(SERVICE_STATUS * pServiceStats)
{
    BOOL fError = FALSE;

    DWORD dwTickCurrent = GetTickCount();

	if (pServiceStats->dwCheckPoint == 0)
	{
		// the service is in some state, not pending anything.
		// before calling this function the code should check to see if
		// the service is in the correct state.  This means it is in 
		// some unexpected state.
		fError = TRUE;
	}
	else
    if ((dwTickCurrent - m_dwTickBegin) > m_dwWaitPeriod)
    {
        // ok to check the dwCheckPoint field to see if 
        // everything is going ok
        if (m_dwLastCheckPoint == -1)
        {
            m_dwLastCheckPoint = pServiceStats->dwCheckPoint;
        }
        else
        {
            if (m_dwLastCheckPoint >= pServiceStats->dwCheckPoint)
            {
                fError = TRUE;
            }
        }

        m_dwLastCheckPoint = pServiceStats->dwCheckPoint;
        m_dwTickBegin = dwTickCurrent;
        m_dwWaitPeriod = pServiceStats->dwWaitHint;
    }

    return fError;
}

BOOL
CServiceCtrlDlg::CheckForClusterError(SERVICE_STATUS * pServiceStats)
{
    BOOL fError = FALSE;

    DWORD dwTickCurrent = GetTickCount();

    if ((dwTickCurrent - m_dwTickBegin) > m_dwWaitPeriod)
    {
        // ok to check the dwCheckPoint field to see if 
        // everything is going ok
        if (m_dwLastCheckPoint == -1)
        {
            m_dwLastCheckPoint = pServiceStats->dwCheckPoint;
        }
        else
        {
            if (m_dwLastCheckPoint >= pServiceStats->dwCheckPoint)
            {
                fError = TRUE;
            }
        }

        m_dwLastCheckPoint = pServiceStats->dwCheckPoint;
        m_dwTickBegin = dwTickCurrent;
        m_dwWaitPeriod = pServiceStats->dwWaitHint;
    }

    return fError;
}

void
CServiceCtrlDlg::UpdateIndicator()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (m_nTotalTickCount % (1000 / TIMER_FREQ) == 0)
	{
		int     nTempTickCount = m_nTotalTickCount / (1000 / TIMER_FREQ);
		HICON   hIcon;

		hIcon = AfxGetApp()->LoadIcon(IDI_PROGRESS_ICON_0 + (nTempTickCount % PROGRESS_ICON_COUNT));
		m_iconProgress.SetIcon(hIcon);
	}
	
	m_nTotalTickCount++;
}

void 
CServiceCtrlDlg::CheckService()
{
	SERVICE_STATUS  serviceStatus;

	::ZeroMemory(&serviceStatus, sizeof(serviceStatus));

	if (!QueryServiceStatus(m_hService, &serviceStatus))
	{
		//
		// Either an error occurred retrieving the
		// service status OR the service is returning
		// bogus state information.
		//
		CDialog::OnOK();
	}

	// If the dwCheckpoint value is 0, then there is no start/stop/pause
	// or continue action pending (in which case we can exit no matter
	// what happened).
	
	if (m_bStart)
	{
		if (serviceStatus.dwCurrentState == SERVICE_RUNNING)
		{
            //
            // The operation is complete.
            //
            CDialog::OnOK();
		}
		else 
		{
            if (CheckForError(&serviceStatus))
            {
		        // Something failed.  Report an error.
			    CString		strTemp;

			    // Kill the timer so that we don't get any messages
			    // while the message box is up.
			    if (m_timerId)
				    KillTimer(m_timerId);
	    
			    AfxFormatString2(strTemp, IDS_ERR_STARTING_SERVICE,
							     m_strServerName,
							     m_strServiceDesc);
			    AfxMessageBox(strTemp);

                if (serviceStatus.dwWin32ExitCode)
                    m_dwErr = serviceStatus.dwWin32ExitCode;
                else
                    m_dwErr = ERROR_SERVICE_REQUEST_TIMEOUT;

			    CDialog::OnOK();
            }

		}
	}
	else
	{
		if (serviceStatus.dwCurrentState == SERVICE_STOPPED)
		{
			//
			// The operation is complete.
			//
			CDialog::OnOK();
		}
		else 
		{
            if (CheckForError(&serviceStatus))
            {
			    // Something failed.  Report an error.
			    CString		strTemp;
			    
			    // Kill the timer so that we don't get any messages
			    // while the message box is up.
			    if (m_timerId)
				    KillTimer(m_timerId);
	    
			    AfxFormatString2(strTemp, IDS_ERR_STOPPING_SERVICE,
							     m_strServerName,
							     m_strServiceDesc);
			    AfxMessageBox(strTemp);
			    
                if (serviceStatus.dwWin32ExitCode)
                    m_dwErr = serviceStatus.dwWin32ExitCode;
                else
                    m_dwErr = ERROR_SERVICE_REQUEST_TIMEOUT;

                CDialog::OnOK();
            }
		}
	}
}

void 
CServiceCtrlDlg::CheckClusterService()
{
	SERVICE_STATUS          serviceStatus = {0};
	DWORD			        dwError = ERROR_SUCCESS;
    CLUSTER_RESOURCE_STATE  crs;

	if ( !g_ClusDLL.LoadFunctionPointers() )
		return;

    // Check the state before we check the notification port.
    crs = ((GETCLUSTERRESOURCESTATE) g_ClusDLL[CLUS_GET_CLUSTER_RESOURCE_STATE])( m_hResource, NULL, NULL, NULL, NULL );

	if (crs == ClusterResourceStateUnknown)
	{
		// get cluster resource state failed
		m_dwErr = GetLastError();
		CDialog::OnOK();
	}

	
	if (m_bStart)
	{
		if (crs == ClusterResourceOnline)
		{
            //
            // The operation is complete.
            //
            CDialog::OnOK();
		}
		else
		if (crs == ClusterResourceFailed)
		{
			//
			//	resource failed to start. now error code available
			//
			m_dwErr = ERROR_SERVICE_REQUEST_TIMEOUT;
		
			CDialog::OnOK();
		}
		else
		{
			Assert(crs == ClusterResourcePending ||
				   crs == ClusterResourceOnlinePending);

			if (CheckForClusterError(&serviceStatus))
			{
				// Something failed.  Report an error.
				CString		strTemp;

				// Kill the timer so that we don't get any messages
				// while the message box is up.
				if (m_timerId)
					KillTimer(m_timerId);
		
				AfxFormatString2(strTemp, IDS_ERR_STARTING_SERVICE,
								 m_strServerName,
								 m_strServiceDesc);
				AfxMessageBox(strTemp);

				if (serviceStatus.dwWin32ExitCode)
					m_dwErr = serviceStatus.dwWin32ExitCode;
				else
					m_dwErr = ERROR_SERVICE_REQUEST_TIMEOUT;

				CDialog::OnOK();
			}
		}
	}
	else
	{
		if (crs == ClusterResourceOffline)
		{
			//
			// The operation is complete.
			//
			CDialog::OnOK();
		}
		if (crs == ClusterResourceFailed)
		{
			//
			//	resource failed to start. now error code available
			//
			m_dwErr = ERROR_SERVICE_REQUEST_TIMEOUT;
		
			CDialog::OnOK();
		}
		else 
		{
			Assert(crs == ClusterResourcePending ||
				   crs == ClusterResourceOfflinePending);

            if (CheckForClusterError(&serviceStatus))
            {
			    // Something failed.  Report an error.
			    CString		strTemp;
			    
			    // Kill the timer so that we don't get any messages
			    // while the message box is up.
			    if (m_timerId)
				    KillTimer(m_timerId);
	    
			    AfxFormatString2(strTemp, IDS_ERR_STOPPING_SERVICE,
							     m_strServerName,
							     m_strServiceDesc);
			    AfxMessageBox(strTemp);
			    
                if (serviceStatus.dwWin32ExitCode)
                    m_dwErr = serviceStatus.dwWin32ExitCode;
                else
                    m_dwErr = ERROR_SERVICE_REQUEST_TIMEOUT;

                CDialog::OnOK();
            }
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CWaitDlg dialog


CWaitDlg::CWaitDlg
(
	LPCTSTR         pServerName,
    LPCTSTR         pszText,
    LPCTSTR         pszTitle,
	CWnd*           pParent /*=NULL*/
)
	: CDialog(CWaitDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CWaitDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	
	m_nTickCounter = TIMER_MULT;
	m_nTotalTickCount = 0;
	m_strServerName = pServerName;
	m_strServerName.MakeUpper();
    m_strText = pszText;
    m_strTitle = pszTitle;
	m_timerId = 0;
}


void CWaitDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWaitDlg)
	DDX_Control(pDX, IDC_STATIC_MESSAGE, m_staticMessage);
	DDX_Control(pDX, IDC_ICON_PROGRESS, m_iconProgress);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWaitDlg, CDialog)
	//{{AFX_MSG_MAP(CWaitDlg)
	ON_WM_TIMER()
	ON_WM_CLOSE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWaitDlg message handlers

BOOL CWaitDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	m_timerId = SetTimer(TIMER_ID, TIMER_FREQ, NULL);

    m_staticMessage.SetWindowText(m_strText);

    SetWindowText(m_strTitle);

	UpdateIndicator();

	return TRUE;  // return TRUE unless you set the focus to a control
		          // EXCEPTION: OCX Property Pages should return FALSE
}

void CWaitDlg::OnClose()
{
    CloseTimer();
	CDialog::OnClose();
}


void CWaitDlg::CloseTimer()
{
	if (m_timerId)
		KillTimer(m_timerId);
    m_timerId = 0;	
}

void CWaitDlg::OnTimer(UINT nIDEvent) 
{
    //
    //  Bag-out if it's not our timer.
    //
    if(nIDEvent != TIMER_ID)
    {
	return;
    }

    //
    //  Advance the progress indicator.
    //
    UpdateIndicator();

    //
    //  No need to continue if we're just amusing the user.
    //
    if(--m_nTickCounter > 0)
    {
	return;
    }

    m_nTickCounter = TIMER_MULT;

    // check here to see if we can exit out
    OnTimerTick();
}

void
CWaitDlg::UpdateIndicator()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (m_nTotalTickCount % (1000 / TIMER_FREQ) == 0)
	{
		int             nTempTickCount = m_nTotalTickCount / (1000 / TIMER_FREQ);
		HICON   hIcon;

		hIcon = AfxGetApp()->LoadIcon(IDI_PROGRESS_ICON_0 + (nTempTickCount % PROGRESS_ICON_COUNT));
		m_iconProgress.SetIcon(hIcon);
	}
	
	m_nTotalTickCount++;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\tfscore.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
    snapbase.h
	Common header file included by all snapins derived 
		from these base classes

    FILE HISTORY:
	
*/

#include "dbgutil.h"
#include "std.h"
#include "errutil.h"

extern "C"
{
    #include "ipaddr.h"
}
#include "ipaddr.hpp"

#include "service.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\tfsnode.cpp ===
/**********************************************************************/
/**						Microsoft Windows/NT                         **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	tfsnode.cpp

    FILE HISTORY:
	
*/

#include "stdafx.h"
#include "util.h"
#include "tfsnode.h"

DEBUG_DECLARE_INSTANCE_COUNTER(TFSNodeEnum);

/*!--------------------------------------------------------------------------
	TFSNodeEnum::TFSNodeEnum
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
TFSNodeEnum::TFSNodeEnum(TFSContainer * pContainer)
    : m_cRef(1)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(TFSNodeEnum);

    Assert(pContainer->IsContainer());
    pContainer->AddRef();
    m_pNode = pContainer;

	Reset();
}

TFSNodeEnum::~TFSNodeEnum()
{
	DEBUG_DECREMENT_INSTANCE_COUNTER(TFSNodeEnum);

    m_pNode->Release();
    m_pNode = NULL;
}

IMPLEMENT_ADDREF_RELEASE(TFSNodeEnum)

/*!--------------------------------------------------------------------------
	TFSNodeEnum::QueryInterface
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSNodeEnum::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown || riid == IID_ITFSNodeEnum)
        *ppv = (LPVOID) this;

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
    {
        ((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
    }
    else
		return E_NOINTERFACE;
}

/*!--------------------------------------------------------------------------
	TFSNodeEnum::Next
		We always return one node 
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
TFSNodeEnum::Next
(
    ULONG       uNum, 
    ITFSNode ** ppNode, 
    ULONG *     pNumReturned 
)
{
    HRESULT hr = hrFalse;
    ULONG nNumReturned = 0;
	ITFSNode *	pNode;

	COM_PROTECT_TRY
	{

		if (ppNode)
			*ppNode = NULL;
		
		if ((m_pNode->IsContainer()) && (uNum >= 1) && (m_pos != NULL))
		{
			while (m_pos)
			{
				pNode = m_pNode->m_listChildren.GetNext(m_pos);
        
				if (pNode &&
					((pNode->GetVisibilityState() & TFS_VIS_DELETE) == 0))
				{
					*ppNode = pNode;					
					break;
				}
			}

			if (*ppNode)
			{
				((LPUNKNOWN)*ppNode)->AddRef();
				nNumReturned = 1;
				hr = S_OK;
			}
		}
		else
		{
			nNumReturned = 0;
			hr = S_FALSE;
		}
		
		if (pNumReturned)
			*pNumReturned = nNumReturned;
	}
	COM_PROTECT_CATCH

	if (FHrFailed(hr))
	{
		if (pNumReturned)
			*pNumReturned = 0;
		*ppNode = NULL;
	}
	
    return hr;
}

/*!--------------------------------------------------------------------------
	TFSNodeEnum::Skip
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
TFSNodeEnum::Skip
( 
    ULONG uNum
)
{
    return E_NOTIMPL;
}

/*!--------------------------------------------------------------------------
	TFSNodeEnum::Reset
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
TFSNodeEnum::Reset()
{
    m_pos = m_pNode->m_listChildren.GetHeadPosition();

    return S_OK;
}

/*!--------------------------------------------------------------------------
	TFSNodeEnum::Clone
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
TFSNodeEnum::Clone
( 
    ITFSNodeEnum **ppEnum
)
{
    return E_NOTIMPL;
}
 
DEBUG_DECLARE_INSTANCE_COUNTER(TFSNode);

/*!--------------------------------------------------------------------------
	TFSNode::TFSNode
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSNode::TFSNode()
	: m_cRef(1),
	  m_cPropSheet(0),
	  m_pNodeType(NULL),
	  m_uData(0),
	  m_cookie(0),
	  m_tfsVis(TFS_VIS_SHOW),
	  m_fContainer(0),
	  m_nImageIndex(0),
	  m_nOpenImageIndex(0),
	  m_lParam(0),
	  m_fDirty(0),
	  m_hScopeItem(0),
	  m_hRelativeId(0),
	  m_ulRelativeFlags(0),
      m_fScopeLeafNode(FALSE)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(TFSNode);

	IfDebug(m_bCookieSet=FALSE);
}

/*!--------------------------------------------------------------------------
	TFSNode::~TFSNode
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSNode::~TFSNode()
{
	DEBUG_DECREMENT_INSTANCE_COUNTER(TFSNode);

	Assert(m_cPropSheet == 0);
	Assert(m_cRef == 0);
}

IMPLEMENT_ADDREF_RELEASE(TFSNode)

/*!--------------------------------------------------------------------------
	TFSNode::QueryInterface
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSNode::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown || riid == IID_ITFSNode)
        *ppv = (LPVOID) this;

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
        {
        ((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
        }
    else
		return E_NOINTERFACE;
}

/*!--------------------------------------------------------------------------
	TFSNode::Construct
		The pNodeType parameter must stay around for the lifetime of
		the node, we do not make a copy of it!
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT TFSNode::Construct(const GUID *pNodeType,
						   ITFSNodeHandler *pHandler,
						   ITFSResultHandler *pResultHandler,
						   ITFSNodeMgr *pNodeMgr)
{
	m_pNodeType = pNodeType;
	m_spNodeHandler.Set(pHandler);
	m_spResultHandler.Set(pResultHandler);
	m_spNodeMgr.Set(pNodeMgr);
	
	return hrOK;
}


/*!--------------------------------------------------------------------------
	TFSNode::Init
		Implementation of ITSFNode::Init
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSNode::Init(int nImageIndex, int nOpenImageIndex,
						   LPARAM lParam, MMC_COOKIE cookie
						  )
{
	m_nImageIndex = nImageIndex;
	m_nOpenImageIndex = nOpenImageIndex;
	m_lParam = lParam;
	m_cookie = cookie;

	return hrOK;
}

/*!--------------------------------------------------------------------------
	TFSNode::GetParent
		Implementation of ITFSNode::GetParent
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSNode::GetParent(ITFSNode **ppNode)
{
	Assert(ppNode);
	*ppNode = NULL;

	SetI((LPUNKNOWN *) ppNode, m_spNodeParent);
	return hrOK;
}

/*!--------------------------------------------------------------------------
	TFSNode::SetParent
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSNode::SetParent(ITFSNode *pNode)
{
	m_spNodeParent.Set(pNode);
	return hrOK;
}

/*!--------------------------------------------------------------------------
	TFSNode::GetNodeMgr
		Implementation of ITFSNode::GetNodeMgr
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSNode::GetNodeMgr(ITFSNodeMgr **ppNodeMgr)
{
	Assert(ppNodeMgr);
	*ppNodeMgr = NULL;
	SetI((LPUNKNOWN *) ppNodeMgr, m_spNodeMgr);
	return hrOK;
}


/*!--------------------------------------------------------------------------
	TFSNode::IsVisible
		Implementation of ITFSNode::IsVisible
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(BOOL) TFSNode::IsVisible()
{
 	// If we are the root node, then we are ALWAYS visible
	// (actually it's kind of weird because the root node is never
	// shown to the user).  It's an imaginary construct much as
	// software is (in a way) imaginary.  Software is structure
	// imposed on a mass of random machine instructions and data.

	return (m_tfsVis & TFS_VIS_SHOW);
}


/*!--------------------------------------------------------------------------
	TFSNode::SetVisibilityState
		Implementation of ITFSNode::SetVisibilityState
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSNode::SetVisibilityState(TFSVisibility vis)
{
	m_tfsVis = vis;
	return hrOK;
}

STDMETHODIMP_(TFSVisibility) TFSNode::GetVisibilityState()
{
	return m_tfsVis;
}

/*!--------------------------------------------------------------------------
	TFSNode::IsInUI
		Implementation of ITFSNode::IsInUI
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(BOOL) TFSNode::IsInUI()
{
	// If we have been added to the UI, then return TRUE
	return (m_hScopeItem != 0);
}

/*!--------------------------------------------------------------------------
	TFSContainer::InternalRemoveFromUI
		Removes a node from the UI and sets its scope ID to zero
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT TFSNode::InternalRemoveFromUI(ITFSNode *pNodeChild,
									  BOOL fDeleteThis)
{
	HRESULT hr = hrOK;

    SPIConsoleNameSpace	spConsoleNS;

	m_spNodeMgr->GetConsoleNameSpace(&spConsoleNS);
	hr = spConsoleNS->DeleteItem(pNodeChild->GetData(TFS_DATA_SCOPEID), TRUE);
	
	// Set the scope ID to 0 after we delete it from the UI
	// and set all of the children's scope ID's to zero so that they will
	// get added again later
	if (SUCCEEDED(hr))
		InternalZeroScopeID(pNodeChild, TRUE);

	return hr;
}

/*!--------------------------------------------------------------------------
	TFSNode::InternalZeroScopeID
		Recursively zeros the scope ID for all scope pane items 
		(container nodes only)
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT TFSNode::InternalZeroScopeID(ITFSNode *pNode, BOOL fZeroChildren)
{
	HRESULT hr = hrOK;

	if (pNode->IsContainer())
	{
		if (fZeroChildren)
		{
			// recursively delete children
			SPITFSNodeEnum spNodeEnum;
			ITFSNode * pCurrentNode;
			ULONG nNumReturned = 0;

			pNode->GetEnum(&spNodeEnum);

			spNodeEnum->Next(1, &pCurrentNode, &nNumReturned);
			while (nNumReturned)
			{
				InternalZeroScopeID(pCurrentNode, fZeroChildren);

				pCurrentNode->Release();
				spNodeEnum->Next(1, &pCurrentNode, &nNumReturned);
			}
		}
	}

	// zero the scope ID for this node
	pNode->SetData(TFS_DATA_SCOPEID, 0);

    return hr;
}

/*!--------------------------------------------------------------------------
	TFSNode::Show
		This function changes the visiblity state of the node in the UI.
        Depending upon what has been set via SetVisibilityState, the function
        will add or remove the node from the UI.
	Author: KennT, EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSNode::Show()
{
	AFX_MANAGE_STATE(AfxGetModuleState());
	
	HRESULT hr = hrOK;
	SCOPEDATAITEM	scopedataitem;
	SPIConsoleNameSpace	spConsoleNS;

	COM_PROTECT_TRY
	{
        // check to see if we should remove this node from the UI
        if (IsInUI() && !IsVisible())
        {
		    if (IsContainer())
            {
			    CORg( InternalRemoveFromUI(this, TRUE) );
            }
            else
            {
                CORg( UpdateAllViewsHelper(reinterpret_cast<LPARAM>(this), RESULT_PANE_DELETE_ITEM) );
            }
        }
        else
        if (!IsInUI() && IsVisible()) 
        {
            // this node isn't in the UI and needs to be shown

		    if (IsContainer())
		    {
			    // If we're making this node visible, our parent should be also
			    Assert(!m_spNodeParent || m_spNodeParent->IsInUI());
			    
			    //$ Review: kennt, what if our parent isn't visible?
			    // Do we want to act on this?  Do we show all of our parents?
		    
			    // add this node in the UI
			    CORg( InitializeScopeDataItem(&scopedataitem,
										      m_spNodeParent ?
										      m_spNodeParent->GetData(TFS_DATA_SCOPEID) :
										      NULL,
										      GetData(TFS_DATA_COOKIE),
										      m_nImageIndex,
										      m_nOpenImageIndex,
										      IsContainer(),
										      m_ulRelativeFlags,
										      m_hRelativeId));

			    CORg( m_spNodeMgr->GetConsoleNameSpace(&spConsoleNS) );
			    CORg( spConsoleNS->InsertItem(&scopedataitem) );
			    
			    // Now that we've added the node to the scope pane, we have a HSCOPEITEM
			    SetData( TFS_DATA_SCOPEID, scopedataitem.ID );
		    }
		    else
		    {
			    //
			    // result pane item, has to go through IComponent interface
			    //
			    hr = UpdateAllViewsHelper(reinterpret_cast<LPARAM>(this), RESULT_PANE_ADD_ITEM); 
		    }
        }

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH

	return hr;
}

/*!--------------------------------------------------------------------------
	TFSNode::ChangeNode
		Implementation of ITFSnode::ChangeNode
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT 
TFSNode::ChangeNode
(
	LONG_PTR    changeMask
)
{
	// will have to broadcast to all views
	return UpdateAllViewsHelper(reinterpret_cast<LPARAM>(this), changeMask); 
}

/*!--------------------------------------------------------------------------
	TFSNode::UpdateAllViewsHelper
		Notifies the current view to do something.  Add a node, change
		a node or delete a node.
	Author: 
 ---------------------------------------------------------------------------*/
HRESULT 
TFSNode::UpdateAllViewsHelper
(       
	LPARAM  data, 
	LONG_PTR hint
)
{
    HRESULT				hr = hrOK;
    SPIComponentData	spCompData;
	SPIConsole			spConsole;
    IDataObject*		pDataObject;

	COM_PROTECT_TRY
	{
        m_spNodeMgr->GetComponentData(&spCompData);

        CORg ( spCompData->QueryDataObject(NULL, CCT_RESULT, &pDataObject) );

        CORg ( m_spNodeMgr->GetConsole(&spConsole) );

        CORg ( spConsole->UpdateAllViews(pDataObject, data, hint) ); 

        pDataObject->Release();

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH
	
	return hr;
}



/*!--------------------------------------------------------------------------
	TFSNode::GetData
		Implementation of ITFSnode::GetData
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LONG_PTR) TFSNode::GetData(int nIndex)
{
	AFX_MANAGE_STATE(AfxGetModuleState());
	
	LONG_PTR	uReturn = 0;
	
	switch (nIndex)
	{
		case TFS_DATA_COOKIE:
			Assert(m_bCookieSet);
			uReturn = m_cookie;
			break;
		case TFS_DATA_SCOPEID:
			uReturn = (LONG_PTR) m_hScopeItem;
			break;
		case TFS_DATA_IMAGEINDEX:
			uReturn = m_nImageIndex;
			break;
		case TFS_DATA_OPENIMAGEINDEX:
			uReturn = m_nOpenImageIndex;
			break;
		case TFS_DATA_PROPSHEETCOUNT:
			uReturn = m_cPropSheet;
			break;
		case TFS_DATA_RELATIVE_FLAGS:
			uReturn = m_ulRelativeFlags;
			break;
		case TFS_DATA_RELATIVE_SCOPEID:
			uReturn = m_hRelativeId;
			break;
        case TFS_DATA_SCOPE_LEAF_NODE:
            uReturn = m_fScopeLeafNode;
            break;
		case TFS_DATA_DIRTY:
			uReturn = m_fDirty;
			break;
		case TFS_DATA_USER:
			uReturn = m_uData;
			break;
		case TFS_DATA_TYPE:
			uReturn = m_uType;
			break;
		case TFS_DATA_PARENT:
			uReturn = m_uDataParent;
			break;
		default:
			Panic1("Alert the troops!: invalid arg(%d) to ITFSNode::GetData",
				   nIndex);
			break;
	}
	return uReturn;
}

/*!--------------------------------------------------------------------------
	TFSNode::SetData
		Implementaton of ITFSNode::SetData
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LONG_PTR) TFSNode::SetData(int nIndex, LONG_PTR dwData)
{
	AFX_MANAGE_STATE(AfxGetModuleState());
	
	LONG_PTR	dwOldValue = 0;
	
	switch (nIndex)
	{
		case TFS_DATA_COOKIE:
			IfDebug(m_bCookieSet=TRUE);
			dwOldValue = m_cookie;
			m_cookie = dwData;
			break;
		case TFS_DATA_SCOPEID:
			dwOldValue = m_hScopeItem;
			m_hScopeItem = (HSCOPEITEM) dwData;
			break;
		case TFS_DATA_IMAGEINDEX:
			dwOldValue = m_nImageIndex;
			m_nImageIndex = (UINT) dwData;
			break;
		case TFS_DATA_OPENIMAGEINDEX:
			dwOldValue = m_nOpenImageIndex;
			m_nOpenImageIndex = (UINT) dwData;
			break;
		case TFS_DATA_PROPSHEETCOUNT:
			dwOldValue = m_cPropSheet;
			m_cPropSheet = (UINT) dwData;
			break;
		case TFS_DATA_DIRTY:
			dwOldValue = m_fDirty;
			m_fDirty = (UINT) dwData;
			break;
		case TFS_DATA_RELATIVE_FLAGS:
			dwOldValue = m_ulRelativeFlags;
			m_ulRelativeFlags = (UINT) dwData;
			break;
		case TFS_DATA_RELATIVE_SCOPEID:
			dwOldValue = m_hRelativeId;
			m_hRelativeId = (HSCOPEITEM) dwData;
			break;
        case TFS_DATA_SCOPE_LEAF_NODE:
            dwOldValue = m_fScopeLeafNode;
            m_fScopeLeafNode = (BOOL) dwData;
            break;
		case TFS_DATA_USER:
			dwOldValue = m_uData;
			m_uData = dwData;
			break;
		case TFS_DATA_TYPE:
			dwOldValue = m_uType;
			m_uType = dwData;
			break;
		case TFS_DATA_PARENT:
			dwOldValue = m_uDataParent;
			m_uDataParent = dwData;
			break;
		default:
			Panic1("Alert the troops!: invalid arg(%d) to ITFSNode::SetData",
				   nIndex);
			break;
	}
	return dwOldValue;
}

/*!--------------------------------------------------------------------------
	TFSNode::Notify
		Implementation of ITFSNode::Notify
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LONG_PTR) TFSNode::Notify(int nIndex, LPARAM lParam)
{
	AFX_MANAGE_STATE(AfxGetModuleState());
	
	LONG_PTR	uReturn = 0;
	
	switch (nIndex)
	{
		case TFS_NOTIFY_CREATEPROPSHEET:
		{
			SPITFSNodeHandler	spHandler;
		
			uReturn = InterlockedIncrement(&m_cPropSheet);
			GetHandler(&spHandler);
			if (spHandler)
    			spHandler->UserNotify(this, TFS_MSG_CREATEPROPSHEET, lParam);
		}
			break;
			
		case TFS_NOTIFY_DELETEPROPSHEET:
		{
			SPITFSNodeHandler	spHandler;
			
			uReturn = InterlockedDecrement(&m_cPropSheet);
			GetHandler(&spHandler);
			if (spHandler)
				spHandler->UserNotify(this, TFS_MSG_DELETEPROPSHEET, lParam);
		}
			break;
			
		case TFS_NOTIFY_RESULT_CREATEPROPSHEET:
		{
			SPITFSResultHandler	spHandler;
		
			uReturn = InterlockedIncrement(&m_cPropSheet);
			GetResultHandler(&spHandler);
			if (spHandler)
    			spHandler->UserResultNotify(this, TFS_MSG_CREATEPROPSHEET, lParam);
		}
			break;
			
		case TFS_NOTIFY_RESULT_DELETEPROPSHEET:
		{
			SPITFSResultHandler	spHandler;
			
			uReturn = InterlockedDecrement(&m_cPropSheet);
			GetResultHandler(&spHandler);
			if (spHandler)
				spHandler->UserResultNotify(this, TFS_MSG_DELETEPROPSHEET, lParam);
		}
			break;

		case TFS_NOTIFY_REMOVE_DELETED_NODES:
			break;

		default:
			Panic1("Alert the troops!: invalid arg(%d) to ITFSNode::Notify",
				   nIndex);			
			break;
	}
	return uReturn;
}

/*!--------------------------------------------------------------------------
	TFSNode::GetHandler
		Implementation of ITFSNode::GetHandler
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSNode::GetHandler(ITFSNodeHandler **ppNodeHandler)
{
	Assert(ppNodeHandler);
	*ppNodeHandler = NULL;
	SetI((LPUNKNOWN *) ppNodeHandler, m_spNodeHandler);
	return hrOK;
}


/*!--------------------------------------------------------------------------
	TFSNode::SetHandler
		Implementation of ITFSNode::SetHandler
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSNode::SetHandler(ITFSNodeHandler *pNodeHandler)
{
	m_spNodeHandler.Set(pNodeHandler);
	return hrOK;
}

/*!--------------------------------------------------------------------------
	TFSNode::GetResultHandler
		Implementation of ITFSNode::GetResultHandler
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSNode::GetResultHandler(ITFSResultHandler **ppResultHandler)
{
	Assert(ppResultHandler);
	*ppResultHandler = NULL;
	SetI((LPUNKNOWN *) ppResultHandler, m_spResultHandler);
	return hrOK;
}

/*!--------------------------------------------------------------------------
	TFSNode::SetResultHandler
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSNode::SetResultHandler(ITFSResultHandler *pResultHandler)
{
	m_spResultHandler.Set(pResultHandler);
	return hrOK;
}

/*!--------------------------------------------------------------------------
	TFSNode::GetString
		Implementation of ITFSNode::GetString
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) TFSNode::GetString(int nCol)
{
	AFX_MANAGE_STATE(AfxGetModuleState());
	
	// Need to forward this onto the handler
	return m_spNodeHandler->GetString(static_cast<ITFSNode *>(this), nCol);
}


/*!--------------------------------------------------------------------------
	TFSNode::GetNodeType
		Implementation of ITFSNode::GetNodeType
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(const GUID *) TFSNode::GetNodeType()
{
	return m_pNodeType;
}


/*!--------------------------------------------------------------------------
	TFSNode::SetNodeType
		Implementation of ITFSNode::SetNodeType
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSNode::SetNodeType(const GUID *pGuid)
{
	m_pNodeType = pGuid;
	return hrOK;
}


/*!--------------------------------------------------------------------------
	TFSNode::IsContainer
		Implementation of ITFSNode:;IsContainer
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(BOOL) TFSNode::IsContainer()
{
	return FALSE;
}

STDMETHODIMP TFSNode::AddChild(ITFSNode *pNodeChild)
{
	return E_NOTIMPL;
}

STDMETHODIMP TFSNode::InsertChild(ITFSNode *pInsertAfterNode, ITFSNode *pNodeChild)
{
	return E_NOTIMPL;
}

STDMETHODIMP TFSNode::RemoveChild(ITFSNode *pNode)
{
	return E_NOTIMPL;
}

STDMETHODIMP TFSNode::ExtractChild(ITFSNode *pNode)
{
	return E_NOTIMPL;
}

STDMETHODIMP TFSNode::GetChildCount(int *pVisibleCount, int *pTotalCount)
{
	if (pVisibleCount)
		*pVisibleCount = 0;
	if (pTotalCount)
		*pTotalCount = 0;
	return hrOK;
}

STDMETHODIMP TFSNode::GetEnum(ITFSNodeEnum **ppNodeEnum)
{
	return E_NOTIMPL;
}

STDMETHODIMP TFSNode::DeleteAllChildren(BOOL fRemoveFromUI)
{
	return E_NOTIMPL;
}


/*!--------------------------------------------------------------------------
	TFSNode::InitializeScopeDataItem
		-
	Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
HRESULT TFSNode::InitializeScopeDataItem(LPSCOPEDATAITEM pScopeDataItem, 
										 HSCOPEITEM		pParentScopeItem, 
										 LPARAM			lParam,
										 int			nImage, 
										 int			nOpenImage, 
										 BOOL			bHasChildren,
										 ULONG			ulRelativeFlags,
										 HSCOPEITEM		hSibling
										)
{
	AFX_MANAGE_STATE(AfxGetModuleState());
	
	Assert(pScopeDataItem != NULL); 
	::ZeroMemory(pScopeDataItem, sizeof(SCOPEDATAITEM));

	// set parent scope item
	if (ulRelativeFlags & (SDI_NEXT | SDI_PREVIOUS))
	{
		pScopeDataItem->mask |= (ulRelativeFlags & (SDI_NEXT | SDI_PREVIOUS));
		pScopeDataItem->mask |= SDI_FIRST;
		pScopeDataItem->relativeID = hSibling;
	}
	else
	{
        if (ulRelativeFlags & SDI_FIRST)
            pScopeDataItem->mask |= SDI_FIRST;

		pScopeDataItem->mask |= SDI_PARENT;
		pScopeDataItem->relativeID = pParentScopeItem;
	}

	// Add node name, we implement callback
	pScopeDataItem->mask |= SDI_STR;
	pScopeDataItem->displayname = MMC_CALLBACK;

	// Add the lParam
	pScopeDataItem->mask |= SDI_PARAM;
	pScopeDataItem->lParam = lParam;
	
	// Add close image
	if (nImage != -1)
	{
		pScopeDataItem->mask |= SDI_IMAGE;
		pScopeDataItem->nImage = nImage;
	}

	// Add open image
	if (nOpenImage != -1)
	{
		pScopeDataItem->mask |= SDI_OPENIMAGE;
		pScopeDataItem->nOpenImage = nOpenImage;
	}
	
	// Add button to node if the folder has children
	if (bHasChildren == TRUE)
	{
		pScopeDataItem->mask |= SDI_CHILDREN;
		pScopeDataItem->cChildren = 1;
        
        if (m_fScopeLeafNode)
        {
            // Note: the bHasChildren flag is set because the node
            // is really a container node or is a result container.
            // If it is purely a result container, then the m_fScopeLeafNode
            // will be set and we can clear the '+' symbol.
            pScopeDataItem->cChildren = 0;
        }
	}
       
             
	return hrOK;
}



/*!--------------------------------------------------------------------------
	TFSContainer::~TFSContainer
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSContainer::~TFSContainer()
{
	DeleteAllChildren(FALSE);
}


/*!--------------------------------------------------------------------------
	TFSContainer::IsContainer
		Implementation of ITFSNode::IsContainer
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(BOOL) TFSContainer::IsContainer()
{
	return TRUE;
}


/*!--------------------------------------------------------------------------
	TFSContainer::AddChild
		Implementation of ITFSContainer::AddChild
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSContainer::AddChild(ITFSNode *pNodeChild)
{
	return InsertChild(NULL, pNodeChild);
}

/*!--------------------------------------------------------------------------
	TFSContainer::InsertChild
		Implementation of ITFSContainer::InsertChild
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSContainer::InsertChild(ITFSNode *pInsertAfterNode, ITFSNode *pNodeChild)
{
	AFX_MANAGE_STATE(AfxGetModuleState());
	
	SCOPEDATAITEM	scopedataitem;
	HRESULT			hr = hrOK;

	Assert(pNodeChild);
	Assert(IsContainer());

	// add the node to our internal tree
	CORg( pNodeChild->SetParent(this) );
	CORg( InternalAddToList(pInsertAfterNode, pNodeChild) );

	// if we're not visible yet, we can't add this to the UI
	if (!IsInUI())
	{
		return hrOK;
	}

	CORg( pNodeChild->Show() );
	
Error:
	if (!FHrSucceeded(hr))
	{
		InternalRemoveFromList(pNodeChild);
	}
	return hr;
}


/*!--------------------------------------------------------------------------
	TFSContainer::RemoveChild
		Implementation of ITFSNode::RemoveChild
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSContainer::RemoveChild(ITFSNode *pNodeChild)
{
	AFX_MANAGE_STATE(AfxGetModuleState());
	HRESULT hr;
	SPITFSNode	spNode;

	// This node must be kept alive during this operation
	spNode.Set(pNodeChild);
	hr = InternalRemoveChild(spNode, TRUE, TRUE, TRUE);
	spNode->Destroy();

	return hr;
}

/*!--------------------------------------------------------------------------
	TFSContainer::ExtractChild
		Implementation of ITFSNode::ExtractChild
		This function removes the node and all children from the UI, and
		removes the node from our internal tree.  It does not destroy the 
		node and it's children, call RemoveChild if that is required.
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSContainer::ExtractChild(ITFSNode *pNodeChild)
{
	AFX_MANAGE_STATE(AfxGetModuleState());
	
	return InternalRemoveChild(pNodeChild, TRUE, TRUE, FALSE);
}


/*!--------------------------------------------------------------------------
	TFSContainer::GetChildCount
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSContainer::GetChildCount(int *pVisibleCount, int *pTotalCount)
{
	AFX_MANAGE_STATE(AfxGetModuleState());
	
	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		if (pTotalCount)
			*pTotalCount = (int)m_listChildren.GetCount();
	
		// Enumerate through all of the nodes and count the visible ones
		if (pVisibleCount)
		{
			POSITION	pos;
			ITFSNode *	pNode = NULL;
			int			cVisible = 0;
			
			*pVisibleCount = 0;
			pos = m_listChildren.GetHeadPosition();
			while (pos != NULL)
			{
				pNode = m_listChildren.GetNext(pos);
				if (pNode->IsInUI())
					cVisible++;
			}
			*pVisibleCount = cVisible;
		}
	}
	COM_PROTECT_CATCH

	if (FHrFailed(hr))
	{
		if (pTotalCount)
			*pTotalCount = 0;
		if (pVisibleCount)
			*pVisibleCount = 0;

	}
	
	return hr;
}

/*!--------------------------------------------------------------------------
	TFSContainer::GetEnum
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSContainer::GetEnum(ITFSNodeEnum **ppNodeEnum)
{
    HRESULT hr = hrOK;
	TFSNodeEnum * pNodeEnum = NULL;

	COM_PROTECT_TRY
    {
        pNodeEnum = new TFSNodeEnum(this);
    }
	COM_PROTECT_CATCH

	*ppNodeEnum = pNodeEnum;

    return hr;
}

/*!--------------------------------------------------------------------------
	TFSContainer::DeleteAllChildren
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSContainer::DeleteAllChildren(BOOL fRemoveFromUI)
{
	AFX_MANAGE_STATE(AfxGetModuleState());
	
	SPITFSNode	spNode;
	HRESULT		hr =  hrOK;
	
	COM_PROTECT_TRY
	{
	    if (fRemoveFromUI)
			CORg( UpdateAllViewsHelper(reinterpret_cast<LPARAM>(this), RESULT_PANE_DELETE_ALL) );
		
		while (!m_listChildren.IsEmpty())
		{
			BOOL bRemoveFromUI = FALSE;
			spNode = m_listChildren.RemoveHead();
			
			if (spNode->IsContainer() && fRemoveFromUI)
				bRemoveFromUI = TRUE;

			InternalRemoveChild(spNode, FALSE, bRemoveFromUI, TRUE);

			spNode->Destroy();
			spNode.Release();
		}

		COM_PROTECT_ERROR_LABEL
	}
	COM_PROTECT_CATCH

	return hr;
}

/*!--------------------------------------------------------------------------
	TFSContainer::CompareChildNodes
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSContainer::CompareChildNodes(int *pnResult, ITFSNode *pNode1, ITFSNode *pNode2)
{
	*pnResult = 0;
	return hrOK;
}

/*!--------------------------------------------------------------------------
	TFSContainer::ChangeNode
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT 
TFSContainer::ChangeNode
(
	LONG_PTR    changeMask
)
{
	HRESULT             hr = hrOK;
    SCOPEDATAITEM       dataitemScope;
	SPITFSNode          spRootNode;
    SPIConsoleNameSpace spConsoleNS;

	COM_PROTECT_TRY
	{
        Assert(changeMask & (SCOPE_PANE_CHANGE_ITEM | SCOPE_PANE_STATE_NORMAL | SCOPE_PANE_STATE_BOLD | SCOPE_PANE_STATE_EXPANDEDONCE | SCOPE_PANE_STATE_CLEAR));

	    // this node may have been removed from the UI, but something like a 
	    // background thread may have been holding onto it... just exit gracefully
	    //Assert(m_hScopeItem != 0);
	    if (m_hScopeItem == 0)
		    return S_FALSE;

        if (!(changeMask & (SCOPE_PANE_CHANGE_ITEM | SCOPE_PANE_STATE_NORMAL | SCOPE_PANE_STATE_BOLD | SCOPE_PANE_STATE_EXPANDEDONCE | SCOPE_PANE_STATE_CLEAR)))
        {
            // the change mask is not valid for this node
            return S_FALSE;
        }

        ZeroMemory(&dataitemScope, sizeof(dataitemScope));

        CORg ( m_spNodeMgr->GetConsoleNameSpace(&spConsoleNS) );

	    m_spNodeMgr->GetRootNode(&spRootNode);

        dataitemScope.ID = GetData(TFS_DATA_SCOPEID);
		ASSERT(dataitemScope.ID != 0);

	    if (changeMask & SCOPE_PANE_CHANGE_ITEM_DATA)
	    {
		    dataitemScope.mask |= SDI_STR;
		    dataitemScope.displayname = MMC_CALLBACK;
	    }
	    
        if (changeMask & SCOPE_PANE_CHANGE_ITEM_ICON)
	    {
		    dataitemScope.mask |= SDI_IMAGE;
		    dataitemScope.nImage = (UINT)GetData(TFS_DATA_IMAGEINDEX);
		    dataitemScope.mask |= SDI_OPENIMAGE;
		    dataitemScope.nOpenImage = (UINT)GetData(TFS_DATA_OPENIMAGEINDEX);
	    }

        if (changeMask & SCOPE_PANE_STATE_NORMAL)
        {
		    dataitemScope.mask |= SDI_STATE;
            dataitemScope.nState = MMC_SCOPE_ITEM_STATE_NORMAL;
        }

        if (changeMask & SCOPE_PANE_STATE_BOLD)
        {
		    dataitemScope.mask |= SDI_STATE;
            dataitemScope.nState = MMC_SCOPE_ITEM_STATE_BOLD;
        }

        if (changeMask & SCOPE_PANE_STATE_EXPANDEDONCE)
        {
		    dataitemScope.mask |= SDI_STATE;
            dataitemScope.nState = MMC_SCOPE_ITEM_STATE_EXPANDEDONCE;
        }
        
        if (changeMask & SCOPE_PANE_STATE_CLEAR)
        {
		    dataitemScope.mask |= SDI_STATE;
            dataitemScope.nState = 0;
        }

        CORg ( spConsoleNS->SetItem(&dataitemScope) );

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}


/*!--------------------------------------------------------------------------
	TFSContainer::InternalAddToList
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT TFSContainer::InternalAddToList(ITFSNode * pInsertAfterNode, ITFSNode *pNode)
{
	AFX_MANAGE_STATE(AfxGetModuleState());
	
	if (pInsertAfterNode == NULL)
	{
		m_listChildren.AddHead(pNode);
	}
	else
	{
		POSITION pos = m_listChildren.Find(pInsertAfterNode);
		if (pos)
			m_listChildren.InsertAfter(pos, pNode);
		else
			m_listChildren.AddHead(pNode);
	}

	pNode->AddRef();

	return hrOK;
}

/*!--------------------------------------------------------------------------
	TFSContainer::InternalRemoveFromList
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT TFSContainer::InternalRemoveFromList(ITFSNode *pNode)
{
	AFX_MANAGE_STATE(AfxGetModuleState());

	m_listChildren.RemoveNode(pNode);
	pNode->Release();

	return hrOK;
}

/*!--------------------------------------------------------------------------
	TFSContainer::InternalRemoveChild
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT TFSContainer::InternalRemoveChild(ITFSNode *pNodeChild,
										  BOOL fRemoveFromList,
										  BOOL fRemoveFromUI,
										  BOOL fRemoveChildren)
{
	AFX_MANAGE_STATE(AfxGetModuleState());
	
 	HRESULT	hr = hrOK;
	
	Assert(pNodeChild);

	// Call this recursively on the children of pNodeChild
	if (fRemoveChildren && pNodeChild->IsContainer())
	{
		pNodeChild->DeleteAllChildren(fRemoveFromUI);
	}

	// Remove the node from the UI
	if (fRemoveFromUI)
	{
		if (pNodeChild->IsContainer())
        {
			// Check to see if we need to remove the node from the UI
			if (!pNodeChild->IsInUI())
				return hrOK;

			CORg( InternalRemoveFromUI(pNodeChild, TRUE) );
        }
        else
        {
            CORg( UpdateAllViewsHelper(reinterpret_cast<LPARAM>(pNodeChild), RESULT_PANE_DELETE_ITEM) );
        }
	}

	if (fRemoveFromList)
		InternalRemoveFromList(pNodeChild);

	pNodeChild->SetParent(NULL);
	
Error:		
	return hr;
}

STDMETHODIMP_(LONG_PTR) TFSContainer::Notify(int nIndex, LPARAM lParam)
{
	LONG_PTR	uReturn = 0;
    HRESULT hr = hrOK;

	COM_PROTECT_TRY
	{		
		if (nIndex == TFS_NOTIFY_REMOVE_DELETED_NODES)
		{
			ITFSNode *	pNode;
			POSITION	pos;
			
			pos = m_listChildren.GetHeadPosition();
			while (pos)
			{
				pNode = m_listChildren.GetNext(pos);
				if (pNode->GetVisibilityState() & TFS_VIS_DELETE)
				{
					RemoveChild(pNode);
				}
			}
		}
		else
			uReturn = TFSNode::Notify(nIndex, lParam);
	}
	COM_PROTECT_CATCH;

	return uReturn;
}
		




/*!--------------------------------------------------------------------------
	CreateLeafTFSNode
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) CreateLeafTFSNode(ITFSNode **ppNode,
						   const GUID *pNodeType,
						   ITFSNodeHandler *pNodeHandler,
						   ITFSResultHandler *pResultHandler,
						   ITFSNodeMgr *pNodeMgr)
{
	AFX_MANAGE_STATE(AfxGetModuleState());
	
	SPITFSNode	spNode;
	TFSNode *	pNode = NULL;
	HRESULT		hr = hrOK;

	COM_PROTECT_TRY
	{
		pNode = new TFSNode;
		Assert(pNode);

		spNode = pNode;
		CORg(pNode->Construct(pNodeType, pNodeHandler, pResultHandler, pNodeMgr));
		*ppNode = spNode.Transfer();

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH
	
	return hr;
}


/*!--------------------------------------------------------------------------
	CreateContainerTFSNode
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) CreateContainerTFSNode(ITFSNode **ppNode,
								const GUID *pNodeType,
								ITFSNodeHandler *pNodeHandler,
								ITFSResultHandler *pResultHandler,
								ITFSNodeMgr *pNodeMgr)
{
	AFX_MANAGE_STATE(AfxGetModuleState());
	
	SPITFSNode	spNode;
	TFSContainer *	pContainer = NULL;
	HRESULT		hr = hrOK;

	COM_PROTECT_TRY
	{
		pContainer = new TFSContainer;
		Assert(pContainer);
		
		spNode = pContainer;
		CORg(pContainer->Construct(pNodeType, pNodeHandler, pResultHandler, pNodeMgr));
		*ppNode = spNode.Transfer();

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH
	
	return hr;
}


DEBUG_DECLARE_INSTANCE_COUNTER(TFSNodeMgr);

/*---------------------------------------------------------------------------
	TFSNodeMgr implementation
 ---------------------------------------------------------------------------*/
TFSNodeMgr::TFSNodeMgr()
	: m_cRef(1)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(TFSNodeMgr);
}

TFSNodeMgr::~TFSNodeMgr()
{
	DEBUG_DECREMENT_INSTANCE_COUNTER(TFSNodeMgr);
}

IMPLEMENT_ADDREF_RELEASE(TFSNodeMgr)

/*!--------------------------------------------------------------------------
	TFSNode::QueryInterface
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSNodeMgr::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown || riid == IID_ITFSNodeMgr)
        *ppv = (LPVOID) this;

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
        {
        ((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
        }
    else
		return E_NOINTERFACE;
}


/*!--------------------------------------------------------------------------
	TFSNodeMgr::Construct
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT TFSNodeMgr::Construct(IComponentData *pCompData,
							  IConsoleNameSpace2 *pConsoleNS)
{
	m_spComponentData.Set(pCompData);
	m_spConsoleNS.Set(pConsoleNS);
	return hrOK;
}
 

/*!--------------------------------------------------------------------------
	TFSNodeMgr::GetRootNode
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSNodeMgr::GetRootNode(ITFSNode **ppTFSNode)
{
	Assert(ppTFSNode);
	SetI((LPUNKNOWN *) ppTFSNode, m_spRootNode);
	return hrOK;
}

/*!--------------------------------------------------------------------------
	TFSNodeMgr::SetRootNode
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSNodeMgr::SetRootNode(ITFSNode *pRootNode)
{
	m_spRootNode.Set(pRootNode);
	return hrOK;
}

/*!--------------------------------------------------------------------------
	TFSNodeMgr::GetComponentData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSNodeMgr::GetComponentData(IComponentData **ppComponentData)
{
	Assert(ppComponentData);
	SetI((LPUNKNOWN *) ppComponentData, m_spComponentData);
	return hrOK;
}

/*!--------------------------------------------------------------------------
	TFSNodeMgr::FindNode
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSNodeMgr::FindNode(MMC_COOKIE cookie, ITFSNode **ppTFSNode)
{
	if (cookie == 0)
	{
		*ppTFSNode = m_spRootNode;
	}
	else
	{
		// Call the cookie lookup routines
		*ppTFSNode = (ITFSNode *) cookie;
	}
	Assert(*ppTFSNode);
	(*ppTFSNode)->AddRef();
	return hrOK;
}

/*!--------------------------------------------------------------------------
	TFSNodeMgr::RegisterCookieLookup
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSNodeMgr::RegisterCookieLookup() 
{
	return hrOK;
}

/*!--------------------------------------------------------------------------
	TFSNodeMgr::UnregisterCookieLookup
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSNodeMgr::UnregisterCookieLookup() 
{
	return hrOK;
}

/*!--------------------------------------------------------------------------
	TFSNodeMgr::IsCookieValid
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSNodeMgr::IsCookieValid(MMC_COOKIE cookie) 
{
	return hrOK;
}

/*!--------------------------------------------------------------------------
	TFSNodeMgr::SelectNode
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSNodeMgr::SelectNode(ITFSNode *pNode) 
{
	return hrOK;
}

/*!--------------------------------------------------------------------------
	TFSNodeMgr::SetResultPaneNode
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSNodeMgr::SetResultPaneNode(ITFSNode *pNode) 
{
	m_spResultPaneNode.Set(pNode);
	return hrOK;
}

/*!--------------------------------------------------------------------------
	TFSNodeMgr::GetResultPaneNode
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSNodeMgr::GetResultPaneNode(ITFSNode **ppNode) 
{
	Assert(ppNode);
	SetI((LPUNKNOWN *) ppNode, m_spResultPaneNode);
	return hrOK;
}

/*!--------------------------------------------------------------------------
	TFSNodeMgr::GetConsoleNameSpace
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSNodeMgr::GetConsoleNameSpace(IConsoleNameSpace2 **ppConsoleNS)
{
	Assert(ppConsoleNS);
	SetI((LPUNKNOWN *) ppConsoleNS, m_spConsoleNS);
	return hrOK;
}

/*!--------------------------------------------------------------------------
	TFSNodeMgr::GetConsole
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSNodeMgr::GetConsole(IConsole2 **ppConsole)
{
	Assert(ppConsole);
	SetI((LPUNKNOWN *) ppConsole, m_spConsole);
	return hrOK;
}

/*!--------------------------------------------------------------------------
	TFSNodeMgr::SetConsole
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP TFSNodeMgr::SetConsole(IConsoleNameSpace2 *pConsoleNS, IConsole2 *pConsole)
{
	m_spConsoleNS.Set(pConsoleNS);
	m_spConsole.Set(pConsole);
	return hrOK;
}


STDMETHODIMP TFSNode::Destroy()
{
	if (m_spNodeHandler)
	{
		m_spNodeHandler->DestroyHandler((ITFSNode *) this);
	}

	if (m_spResultHandler)
	{
		m_spResultHandler->DestroyResultHandler(m_cookie);
		m_spResultHandler.Release();
	}
	
	//Bug 254167  We need to DestroyResultHander first before release NodeHandler
	m_spNodeHandler.Release();

	m_spNodeParent.Release();
	m_spNodeMgr.Release();
	return hrOK;
}


/*!--------------------------------------------------------------------------
	CreateTFSNodeMgr
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) CreateTFSNodeMgr(ITFSNodeMgr **ppNodeMgr,
						IComponentData *pComponentData,
						IConsole2 *pConsole,
						IConsoleNameSpace2 *pConsoleNameSpace)
{
	AFX_MANAGE_STATE(AfxGetModuleState());
	
	SPITFSNodeMgr	spNodeMgr;
	TFSNodeMgr *	pTFSNodeMgr = NULL;
	HRESULT			hr = hrOK;

	COM_PROTECT_TRY
	{
		pTFSNodeMgr = new TFSNodeMgr;

		// Do this so that it will get freed on error
		spNodeMgr = pTFSNodeMgr;

		CORg( pTFSNodeMgr->Construct(pComponentData, pConsoleNameSpace) );

		*ppNodeMgr = spNodeMgr.Transfer();

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\tfsres.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       tfsres.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tfscore.rc
//

#ifndef _TFSCORE_TFSRES_H
#define _TFSCORE_TFSRES_H

// Dialog ids are in 6000-6099
#define IDD_SERVICE_CTRL_DIALOG         6000

// Controls are in 6100-6499
#define IDC_ICON_PROGRESS               6101
#define IDC_STATIC_MESSAGE              6102

// Misc are from 6500-6599
//efine IDB_TFSCORE_16x16               6500
//efine IDB_TFSCORE_32x32               6501
//efine IDI_SAMPLE_SNAPIN_ICON          6502
#define IDI_PROGRESS_ICON_0             6503
#define IDI_PROGRESS_ICON_1             6504
#define IDI_PROGRESS_ICON_2             6505
#define IDI_PROGRESS_ICON_3             6506
#define IDI_PROGRESS_ICON_4             6507
#define IDI_PROGRESS_ICON_5             6508
#define IDI_PROGRESS_ICON_6             6509
#define IDI_PROGRESS_ICON_7             6510
#define IDI_PROGRESS_ICON_8             6511
#define IDI_PROGRESS_ICON_9             6512
#define IDI_PROGRESS_ICON_10            6513
#define IDI_PROGRESS_ICON_11            6514

// Strings are from 6600-6999
#define IDS_ERR_REGISTRY_CALL_FAILED	6600
#define IDS_ERR_REG_OPEN_CALL_FAILED	6601
#define IDS_ERR_REG_CREATE_CALL_FAILED	6602
#define IDS_ERR_REG_SETVALUE_CALL_FAILED 6603
#define IDS_ERROR_FORMAT1				6604
#define IDS_ERROR_FORMAT2				6605
#define IDS_ERROR_MORE_INFORMATION		6606
#define IDS_ERROR_SYSTEM_ERROR_FORMAT	6607

#define IDS_STOPPING_SERVICE_NOW        6608
#define IDS_STARTING_SERVICE_NOW        6609
#define IDS_ERR_STARTING_SERVICE		6610
#define IDS_ERR_STOPPING_SERVICE		6611
#define IDS_IPMBCAPTION                 6612
#define IDS_IPNOMEM                     6613
#define IDS_IPBAD_FIELD_VALUE           6614
#define IDS_STOP_SERVICE_TITLE          6615
#define IDS_START_SERVICE_TITLE         6616

#endif	// _TFSCORE_TFSRES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\tfsguid.h ===
/*----------------------------------------------------------------------------
	tfsguid.c


	Copyright (C) Microsoft Corporation, 1997 - 1997
	All rights reserved.

 ----------------------------------------------------------------------------*/

#ifndef _TFSGUID_H
#define _TFSGUID_H

//	ITFSNode
// {1FD09AB9-B508-11d0-A376-00C04FC9DA04}
DEFINE_GUID(IID_ITFSNode,
	0x1fd09ab9, 0xb508, 0x11d0, 0xa3, 0x76, 0x0, 0xc0, 0x4f, 0xc9, 0xda, 0x4);


//	ITFSNodeMgr
// {1FD09ABA-B508-11d0-A376-00C04FC9DA04}
DEFINE_GUID(IID_ITFSNodeMgr,
	0x1fd09aba, 0xb508, 0x11d0, 0xa3, 0x76, 0x0, 0xc0, 0x4f, 0xc9, 0xda, 0x4);


//	ITFSNodeHandler
// {1FD09ABB-B508-11d0-A376-00C04FC9DA04}
DEFINE_GUID(IID_ITFSNodeHandler,
	0x1fd09abb, 0xb508, 0x11d0, 0xa3, 0x76, 0x0, 0xc0, 0x4f, 0xc9, 0xda, 0x4);


//	ITFSResultHandler
// {1FD09ABC-B508-11d0-A376-00C04FC9DA04}
DEFINE_GUID(IID_ITFSResultHandler,
	0x1fd09abc, 0xb508, 0x11d0, 0xa3, 0x76, 0x0, 0xc0, 0x4f, 0xc9, 0xda, 0x4);


//	ITFSQueryObject
// {1FD09ABD-B508-11d0-A376-00C04FC9DA04}
DEFINE_GUID(IID_ITFSQueryObject,
	0x1fd09abd, 0xb508, 0x11d0, 0xa3, 0x76, 0x0, 0xc0, 0x4f, 0xc9, 0xda, 0x4);


// ITFSComponentData
// {1FD09ABE-B508-11d0-A376-00C04FC9DA04}
DEFINE_GUID(IID_ITFSComponentData,
	0x1fd09abe, 0xb508, 0x11d0, 0xa3, 0x76, 0x0, 0xc0, 0x4f, 0xc9, 0xda, 0x4);

//	ITFSCompDataCallback
// {1FD09ABF-B508-11d0-A376-00C04FC9DA04}
DEFINE_GUID(IID_ITFSCompDataCallback,
	0x1fd09abf, 0xb508, 0x11d0, 0xa3, 0x76, 0x0, 0xc0, 0x4f, 0xc9, 0xda, 0x4);

//	ITFSThreadHandler
// {1FD09AC0-B508-11d0-A376-00C04FC9DA04}
DEFINE_GUID(IID_ITFSThreadHandler,
	0x1fd09ac0, 0xb508, 0x11d0, 0xa3, 0x76, 0x0, 0xc0, 0x4f, 0xc9, 0xda, 0x4);

//	ITFSComponent
// {1FD09AC1-B508-11d0-A376-00C04FC9DA04}
DEFINE_GUID(IID_ITFSComponent,
	0x1fd09ac1, 0xb508, 0x11d0, 0xa3, 0x76, 0x0, 0xc0, 0x4f, 0xc9, 0xda, 0x4);

//	ITFSNodeEnum
// {1FD09AC2-B508-11d0-A376-00C04FC9DA04}
DEFINE_GUID(IID_ITFSNodeEnum,
	0x1fd09ac2, 0xb508, 0x11d0, 0xa3, 0x76, 0x0, 0xc0, 0x4f, 0xc9, 0xda, 0x4);

//	ITFSError
// {1FD09AC3-B508-11d0-A376-00C04FC9DA04}
DEFINE_GUID(IID_ITFSError,
	0x1fd09ac3, 0xb508, 0x11d0, 0xa3, 0x76, 0x0, 0xc0, 0x4f, 0xc9, 0xda, 0x4);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\tfsint.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:    tfsint.h
//
// History:
//
//    04/10/97    Kenn Takara                Created.
//
//============================================================================


#ifndef _TFSINT_H
#define _TFSINT_H

#if _MSC_VER >= 1000    // VC 5.0 or later
#pragma once
#endif

#ifndef _OLEINT_H
#include "oleint.h"
#endif

#ifndef _TFSGUID_H
#include "tfsguid.h"
#endif

// for WATERMARKINFO
#ifndef _UTIL_H
#include "util.h"
#endif

#ifndef TFSCORE_API
#define TFSCORE_API(type)    __declspec( dllexport ) type FAR PASCAL
#define TFSCORE_APIV(type)    __declspec( dllexport ) type FAR CDECL
#endif

// enums
enum TFSVisibility
{
    TFS_VIS_SHOW = 0x1,     // Add this node to the tree and the UI
    TFS_VIS_HIDE = 0x2,        // Add this node to the tree, but not the UI
    TFS_VIS_DELETE = 0x4,    // this node will be deleted by the parent
};


// some useful macros
#ifndef TFS_EXPORT_CLASS
#define TFS_EXPORT_CLASS
#endif





#define IMPLEMENT_ADDREF_RELEASE(class) \
STDMETHODIMP_(ULONG) class::AddRef() \
{ \
    Assert2(m_cRef > 0, "m_cRef(%d:0x%08lx) > 0", m_cRef, m_cRef); \
    return InterlockedIncrement(&m_cRef); \
} \
STDMETHODIMP_(ULONG) class::Release() \
{ \
    ULONG cRef; \
    Assert2(m_cRef>0,"m_cRef(%d:0x%08lx) > 0", m_cRef, m_cRef); \
    cRef = InterlockedDecrement(&m_cRef); \
    if (cRef == 0) \
    { \
        delete this; \
    } \
    return cRef; \
} \

#define IMPLEMENT_TRACE_ADDREF_RELEASE(class) \
STDMETHODIMP_(ULONG) class::AddRef() \
{ \
    DBG_STRING(_szAddRef, #class) \
    Assert2(m_cRef > 0, "m_cRef(%d:0x%08lx) > 0", m_cRef, m_cRef); \
    Trace2("%s::Addref - current count %d\n",_szAddRef,m_cRef); \
    return InterlockedIncrement(&m_cRef); \
} \
STDMETHODIMP_(ULONG) class::Release() \
{ \
    DBG_STRING(_szRelease, #class) \
    Assert2(m_cRef>0,"m_cRef(%d:0x%08lx) > 0", m_cRef, m_cRef); \
    Trace2("%s::Release - current count %d\n", _szRelease, m_cRef); \
    if (InterlockedDecrement(&m_cRef) == 0) \
    { \
        delete this; \
        return 0; \
    } \
    return m_cRef; \
} \

#define IMPLEMENT_SIMPLE_QUERYINTERFACE(klass, iid) \
STDMETHODIMP klass::QueryInterface(REFIID riid, LPVOID *ppv) \
{ \
    if (ppv == NULL) \
        return E_INVALIDARG; \
    *ppv = NULL; \
    if (riid == IID_IUnknown) \
        *ppv = (LPVOID) this; \
    else if (riid == IID_##iid) \
        *ppv = (iid *) this; \
    if (*ppv) \
    { \
    ((LPUNKNOWN) *ppv)->AddRef(); \
        return hrOK; \
    } \
    else \
        return E_NOINTERFACE; \
} \



#ifndef PURE
#define PURE =0
#endif

// forward declarations
interface ITFSNode;
interface ITFSNodeMgr;
interface ITFSNodeHandler;
interface ITFSResultHandler;
interface ITFSNodeEnum;
struct      INTERNAL;


/*---------------------------------------------------------------------------
    IComponentData Inteface
 ---------------------------------------------------------------------------*/

#define DeclareIComponentDataMembers(IPURE) \
    STDMETHOD(Initialize) (LPUNKNOWN pUnknown) IPURE; \
    STDMETHOD(CreateComponent) (LPCOMPONENT *ppComponent) IPURE; \
    STDMETHOD(Notify) (LPDATAOBJECT lpDataObject, \
                        MMC_NOTIFY_TYPE event, \
                        LPARAM arg, \
                        LPARAM param) IPURE; \
    STDMETHOD(Destroy) ( void) IPURE; \
    STDMETHOD(QueryDataObject) (MMC_COOKIE cookie, \
                              DATA_OBJECT_TYPES type, \
                              LPDATAOBJECT *ppDataObject) IPURE; \
    STDMETHOD(CompareObjects) (LPDATAOBJECT lpDataObjectA, \
                             LPDATAOBJECT lpDataObjectB) IPURE; \
    STDMETHOD(GetDisplayInfo) (SCOPEDATAITEM *pScopeDataItem) IPURE; \

typedef ComSmartPointer<IComponentData, &IID_IComponentData> SPIComponentData;

typedef ComSmartPointer<IConsole2, &IID_IConsole2> SPIConsole;
typedef ComSmartPointer<IConsoleNameSpace2, &IID_IConsoleNameSpace2> SPIConsoleNameSpace;

/*---------------------------------------------------------------------------
    ITFSComponentData interface
        Extensions to the IComponentData interface for specific information.
 ---------------------------------------------------------------------------*/

#define DeclareITFSComponentDataMembers(IPURE) \
    STDMETHOD(GetNodeMgr) (THIS_ ITFSNodeMgr **ppNodeMgr) IPURE; \
    STDMETHOD(GetConsole) (THIS_ IConsole2 **ppConsole) IPURE; \
    STDMETHOD(GetConsoleNameSpace) (THIS_ IConsoleNameSpace2 **ppConsoleNS) IPURE; \
    STDMETHOD(GetRootNode) (THIS_ ITFSNode **ppNode) IPURE; \
    STDMETHOD_(const CLSID *, GetCoClassID) (THIS) IPURE; \
    STDMETHOD_(HWND, GetHiddenWnd) (THIS) IPURE; \
    STDMETHOD_(LPWATERMARKINFO, SetWatermarkInfo) (THIS_ LPWATERMARKINFO pNewWatermarkInfo) IPURE; \
    STDMETHOD_(BOOL, GetTaskpadState) (THIS_ int nIndex) IPURE; \
    STDMETHOD(SetTaskpadState) (THIS_ int nIndex, BOOL fEnable) IPURE; \
    STDMETHOD_(LPCTSTR, GetHTMLHelpFileName) (THIS) IPURE; \
    STDMETHOD(SetHTMLHelpFileName) (THIS_ LPCTSTR pszHelpFileName) IPURE; \

#undef INTERFACE
#define INTERFACE ITFSComponentData
DECLARE_INTERFACE_(ITFSComponentData, IUnknown)
{
    DeclareIUnknownMembers(PURE)
    DeclareITFSComponentDataMembers(PURE)
};
typedef ComSmartPointer<ITFSComponentData, &IID_ITFSComponentData> SPITFSComponentData;


/*---------------------------------------------------------------------------
    ITFSCompDataCallback interface
 ---------------------------------------------------------------------------*/

enum
{
    TFS_COMPDATA_NORMAL = 0,
    TFS_COMPDATA_EXTENSION = 1,
    TFS_COMPDATA_CREATE = 2,
    TFS_COMPDATA_UNKNOWN_DATAOBJECT = 4,
    // A parent node will get this when its child wants the parent
    // to add context menus to its context menu.
    TFS_COMPDATA_CHILD_CONTEXTMENU = 8,
};


#define DeclareITFSCompDataCallbackMembers(IPURE) \
    STDMETHOD(OnInitialize) (THIS_ LPIMAGELIST lpScopeImage) IPURE; \
    STDMETHOD(OnInitializeNodeMgr) (THIS_ ITFSComponentData *pTFSCompData, ITFSNodeMgr *pNodeMgr) IPURE; \
    STDMETHOD(OnCreateComponent) (THIS_ LPCOMPONENT *ppComponent) IPURE; \
    STDMETHOD_(const CLSID *, GetCoClassID) (THIS) IPURE; \
    STDMETHOD(OnCreateDataObject)(THIS_ MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject) IPURE; \
    STDMETHOD(OnDestroy)(void) IPURE; \

#undef INTERFACE
#define INTERFACE ITFSCompDataCallback
DECLARE_INTERFACE_(ITFSCompDataCallback, IUnknown)
{
    DeclareIUnknownMembers(PURE)
    DeclareIPersistStreamInitMembers(PURE)
    DeclareITFSCompDataCallbackMembers(PURE)

    // not required part of callback interface
    STDMETHOD(OnNotifyPropertyChange)(THIS_ LPDATAOBJECT pDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM lParam) PURE; 
};
typedef ComSmartPointer<ITFSCompDataCallback, &IID_ITFSCompDataCallback> SPITFSCompDataCallback;


/*---------------------------------------------------------------------------
    IComponent interface
 ---------------------------------------------------------------------------*/

#define DeclareIComponentMembers(IPURE) \
    STDMETHOD(Initialize)(LPCONSOLE lpConsole) IPURE; \
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, \
                    LPARAM arg, LPARAM param) IPURE; \
    STDMETHOD(Destroy)(MMC_COOKIE cookie) IPURE; \
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie,  LPOLESTR* ppViewType, \
                                 long* pViewOptions) IPURE; \
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, \
                        LPDATAOBJECT* ppDataObject) IPURE; \
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, \
                              LPDATAOBJECT lpDataObjectB) IPURE; \
    STDMETHOD(GetDisplayInfo)(LPRESULTDATAITEM pResult) IPURE; \

typedef ComSmartPointer<IComponent, &IID_IComponent> SPIComponent;
typedef ComSmartPointer<IMessageView, &IID_IMessageView> SPIMessageView;


/*---------------------------------------------------------------------------
    ITFSCompCallback interface
 ---------------------------------------------------------------------------*/
#define DeclareITFSCompCallbackMembers(IPURE) \
    STDMETHOD(OnUpdateView)(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param) IPURE; \
    STDMETHOD(InitializeBitmaps)(MMC_COOKIE cookie) IPURE; \

/*---------------------------------------------------------------------------
    ITFSComponent interface
 ---------------------------------------------------------------------------*/
#define DeclareITFSComponentMembers(IPURE) \
    STDMETHOD(GetSelectedNode) (THIS_ ITFSNode **ppNode) IPURE; \
    STDMETHOD(SetSelectedNode) (THIS_ ITFSNode *pNode) IPURE; \
    STDMETHOD(GetConsole) (THIS_ IConsole2 **ppConsole) IPURE; \
    STDMETHOD(GetHeaderCtrl) (THIS_ IHeaderCtrl **ppHeaderCtrl) IPURE; \
    STDMETHOD(GetResultData) (THIS_ IResultData **ppResultData) IPURE; \
    STDMETHOD(GetImageList) (THIS_ IImageList **ppImageList) IPURE; \
    STDMETHOD(GetConsoleVerb) (THIS_ IConsoleVerb **ppConsoleVerb) IPURE; \
    STDMETHOD(GetControlbar) (THIS_ IControlbar **ppControlbar) IPURE; \
    STDMETHOD(GetComponentData) (THIS_ IComponentData **ppComponentData) IPURE; \
    STDMETHOD(GetUserData)(THIS_ LONG_PTR *pulUserData) IPURE; \
    STDMETHOD(SetUserData)(THIS_ LONG_PTR ulUserData) IPURE; \
    STDMETHOD(SetCurrentDataObject)(THIS_ LPDATAOBJECT pDataObject) IPURE; \
    STDMETHOD(GetCurrentDataObject)(THIS_ LPDATAOBJECT *pDataObject) IPURE; \
    STDMETHOD(SetToolbar)(THIS_ IToolbar * pToolbar) IPURE; \
    STDMETHOD(GetToolbar)(THIS_ IToolbar ** ppToolbar) IPURE; \

#undef INTERFACE
#define INTERFACE ITFSComponent
DECLARE_INTERFACE_(ITFSComponent, IUnknown)
{
    DeclareIUnknownMembers(PURE)
    DeclareITFSComponentMembers(PURE)
};
typedef ComSmartPointer<ITFSComponent, &IID_ITFSComponent> SPITFSComponent;

/*---------------------------------------------------------------------------
    IExtendControlbar interface
 ---------------------------------------------------------------------------*/

#define DeclareIExtendControlbarMembers(IPURE) \
    STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar) IPURE; \
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param) IPURE; \

typedef ComSmartPointer<IExtendControlbar, &IID_IExtendControlbar> SPIExtendControlbar;


/*---------------------------------------------------------------------------
    IExtendContextMenu interface
 ---------------------------------------------------------------------------*/
#define DeclareIExtendContextMenuMembers(IPURE) \
    STDMETHOD(AddMenuItems)(LPDATAOBJECT            pDataObject, \
                            LPCONTEXTMENUCALLBACK    pCallbackUnknown, \
                            long *                    pInsertionAllowed) IPURE; \
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject) IPURE; \

typedef ComSmartPointer<IExtendContextMenu, &IID_IExtendContextMenu> SPIExtendContextMenu;


/*---------------------------------------------------------------------------
    IExtendPropertySheet interface
 ---------------------------------------------------------------------------*/

#define DeclareIExtendPropertySheetMembers(IPURE) \
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider, \
                                   LONG_PTR handle, \
                                   LPDATAOBJECT lpIDataObject) IPURE;\
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject) IPURE;\
    STDMETHOD(GetWatermarks)(LPDATAOBJECT pDataObject, \
                             HBITMAP *  lphWatermark, \
                             HBITMAP *  lphHeader, \
                             HPALETTE * lphPalette, \
                             BOOL *     bStretch) IPURE; \
                                                   
typedef ComSmartPointer<IExtendPropertySheet2, &IID_IExtendPropertySheet2> SPIExtendPropertySheet;

/*---------------------------------------------------------------------------
    IExtendTaskPad interface
 ---------------------------------------------------------------------------*/

#define DeclareIExtendTaskPadMembers(IPURE) \
    STDMETHOD(TaskNotify)(LPDATAOBJECT lpDataObject, \
                          VARIANT * arg, \
                          VARIANT * param) IPURE;\
    STDMETHOD(EnumTasks)(LPDATAOBJECT lpDataObject, \
                         LPOLESTR pszTaskGroup, \
                         IEnumTASK ** ppEnumTask) IPURE; \
    STDMETHOD(GetTitle)(LPOLESTR pszGroup, \
                        LPOLESTR * pszTitle) IPURE; \
    STDMETHOD(GetBackground)(LPOLESTR pszGroup, \
                             MMC_TASK_DISPLAY_OBJECT * pTDO) IPURE; \
    STDMETHOD(GetDescriptiveText)(LPOLESTR    pszGroup, \
                                  LPOLESTR *  pszDescriptiveText) IPURE; \
    STDMETHOD(GetListPadInfo)(LPOLESTR pszGroup, \
                              MMC_LISTPAD_INFO *pListPadInfo) IPURE; \
                                                   
typedef ComSmartPointer<IExtendTaskPad, &IID_IExtendTaskPad> SPIExtendTaskPad;
typedef ComSmartPointer<IEnumTASK, &IID_IEnumTASK> SPIEnumTask;

/*---------------------------------------------------------------------------
    IResultDataCompare interface
 ---------------------------------------------------------------------------*/
#define DeclareIResultDataCompareMembers(IPURE) \
     STDMETHOD(Compare)(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult) IPURE; \

typedef ComSmartPointer<IResultDataCompare, &IID_IResultDataCompare> SPIResultDataCompare;

/*---------------------------------------------------------------------------
    IResultDataCompareEx interface
 ---------------------------------------------------------------------------*/
#define DeclareIResultDataCompareExMembers(IPURE) \
     STDMETHOD(Compare)( RDCOMPARE *prdc, int* pnResult) IPURE; \

typedef ComSmartPointer<IResultDataCompareEx, &IID_IResultDataCompareEx> SPIResultDataCompareEx;

/*---------------------------------------------------------------------------
    IResultOwnerData interface
        Virtual Listbox support
 ---------------------------------------------------------------------------*/
#define DeclareIResultOwnerDataMembers(IPURE) \
    STDMETHOD(FindItem)(LPRESULTFINDINFO pFindInfo, int * pnFoundIndex) IPURE; \
    STDMETHOD(CacheHint)(int nStartIndex, int nEndIndex) IPURE; \
    STDMETHOD(SortItems)(int nColumn, DWORD dwSortOptions, LPARAM lUserParam) IPURE; \

typedef ComSmartPointer<IResultOwnerData, &IID_IResultOwnerData> SPIResultOwnerData;


/*---------------------------------------------------------------------------
    ISnapinAbout interface
 ---------------------------------------------------------------------------*/
#define DeclareISnapinAboutMembers(IPURE) \
        STDMETHOD(GetSnapinDescription)( \
            LPOLESTR *lpDescription) IPURE; \
        STDMETHOD(GetProvider)( \
            LPOLESTR *lpName) IPURE; \
        STDMETHOD(GetSnapinVersion)( \
            LPOLESTR *lpVersion) IPURE; \
        STDMETHOD(GetSnapinImage)( \
            HICON *hAppIcon) IPURE;        \
        STDMETHOD(GetStaticFolderImage)( \
            HBITMAP *hSmallImage,\
            HBITMAP *cSmallMask,\
            HBITMAP *hLargeImage,\
            COLORREF *cLargeMask) IPURE;\
        
typedef ComSmartPointer<ISnapinAbout, &IID_ISnapinAbout> SPISnapinAbout;

/*---------------------------------------------------------------------------
    ISnapinHelp interface
 ---------------------------------------------------------------------------*/

#define DeclareISnapinHelpMembers(IPURE) \
    STDMETHOD(GetHelpTopic)(LPOLESTR* lpCompiledHelpFile) IPURE; \
                                                   
typedef ComSmartPointer<ISnapinHelp, &IID_ISnapinHelp> SPISnapinHelp;
typedef ComSmartPointer<IDisplayHelp, &IID_IDisplayHelp> SPIDisplayHelp;

/*---------------------------------------------------------------------------
    Class:    ITFSNode
    This interface is NOT designed to be remotable.

    General initialization:
        Init

    Node management:
        GetParent
        SetParent
        GetNodeMgr

    Visibility
        IsInUI
        IsVisible
        SetVisibilityState
        Show

    Data
        SetData
        GetData

    Handler
        GetHandler
        SetHandler
        GetResultHandler
        SetResultHandler

    Display
        GetString

    MMC stuff
        GetNodeType

    Container
        IsContainer
        AddChild
        InsertChild
        RemoveChild
        ExtractChild
        GetChildCount
        GetEnum
        RemoveAllChildren
        CompareChildNodes
        
 ---------------------------------------------------------------------------*/

enum
{
    // Reserve 0 for an invalid value
    TFS_DATA_COOKIE = 1,            // cookie for this node
    TFS_DATA_SCOPEID = 2,            // HSCOPEITEM
    TFS_DATA_IMAGEINDEX = 3,        // index into image list
    TFS_DATA_OPENIMAGEINDEX = 4,    // index into image list for open item
    TFS_DATA_PROPSHEETCOUNT = 5,    // number of active property pages
    TFS_DATA_DIRTY = 6,                // dirty flag

    // These two are used by the Show() call to determine where
    // to add this node.  This must be set BEFORE the node is
    // displayed.
    TFS_DATA_RELATIVE_FLAGS = 7,    // see relative MMC flags
    TFS_DATA_RELATIVE_SCOPEID = 8,    // scopeid of relative node

    // Set this flag, if this is a leaf node in the scope pane.
    TFS_DATA_SCOPE_LEAF_NODE = 9,   // this will let us remove the '+'
    
    TFS_DATA_USER = 16,                // user-settable data
    TFS_DATA_TYPE = 17,                // user-settable index (used for searching)
    TFS_DATA_PARENT = 18,            // user-settable (by the parent node)
};

enum
{
    // Reserve 0 for an invalid value
    TFS_NOTIFY_CREATEPROPSHEET = 1,
    TFS_NOTIFY_DELETEPROPSHEET = 2,
    TFS_NOTIFY_RESULT_CREATEPROPSHEET = 3,
    TFS_NOTIFY_RESULT_DELETEPROPSHEET = 4,
    
    // Removes nodes marked as deleted
    TFS_NOTIFY_REMOVE_DELETED_NODES = 5,
};


// This is the list of messages for the UserNotify call
enum
{
    // Reserve 0 for an invalid value

    // Notify the handler that a property sheet has gone away
    // The second DWORD contains a pointer to CPropPageHolderBase.
    TFS_MSG_CREATEPROPSHEET = 1,
    TFS_MSG_DELETEPROPSHEET = 2,

};

#define DeclareITFSNodeMembers(IPURE) \
    STDMETHOD(Init)(int    nImageIndex, \
                    int    nOpenImageIndex, \
                    LPARAM lParam, \
                    MMC_COOKIE cookie) IPURE; \
    STDMETHOD(GetParent) (ITFSNode **ppNode) IPURE; \
    STDMETHOD(SetParent) (ITFSNode *pNode) IPURE; \
    STDMETHOD(GetNodeMgr) (ITFSNodeMgr **ppNodeMgr) IPURE; \
    STDMETHOD_(BOOL, IsVisible) () IPURE; \
    STDMETHOD(SetVisibilityState) (TFSVisibility vis) IPURE; \
    STDMETHOD_(TFSVisibility, GetVisibilityState)() IPURE; \
    STDMETHOD_(BOOL, IsInUI) () IPURE; \
    STDMETHOD(Show) () IPURE; \
    STDMETHOD_(LONG_PTR, GetData) (int nIndex) IPURE; \
    STDMETHOD_(LONG_PTR, SetData) (int nIndex, LONG_PTR dwData) IPURE; \
    STDMETHOD_(LONG_PTR, Notify) (int nIndex, LPARAM lParam) IPURE; \
    STDMETHOD(GetHandler) (ITFSNodeHandler **ppNodeHandler) IPURE; \
    STDMETHOD(SetHandler)(ITFSNodeHandler *pNodeHandler) IPURE; \
    STDMETHOD(GetResultHandler) (ITFSResultHandler **ppResultHandler) IPURE; \
    STDMETHOD(SetResultHandler) (ITFSResultHandler *pResultHandler) IPURE; \
    STDMETHOD_(LPCTSTR, GetString) (int nCol) IPURE; \
    STDMETHOD_(const GUID *, GetNodeType) (THIS) IPURE; \
    STDMETHOD(SetNodeType)(THIS_ const GUID *) IPURE; \
    STDMETHOD_(BOOL, IsContainer) () IPURE; \
    STDMETHOD(AddChild) (ITFSNode *pNodeChild) IPURE; \
    STDMETHOD(InsertChild) (ITFSNode *pInsertAfterNode, ITFSNode *pNodeChild) IPURE; \
    STDMETHOD(RemoveChild) (ITFSNode *pNodeChild) IPURE; \
    STDMETHOD(ExtractChild) (ITFSNode *pNodeChild) IPURE; \
    STDMETHOD(GetChildCount) (int *pVisibleCount, int *pTotalCount) IPURE; \
    STDMETHOD(GetEnum) (ITFSNodeEnum **ppNodeEnum) IPURE; \
    STDMETHOD(DeleteAllChildren) (BOOL fRemoveFromUI) IPURE; \
    STDMETHOD(Destroy)() IPURE; \
    STDMETHOD(ChangeNode)(THIS_ LONG_PTR changemask) IPURE; \


//    STDMETHOD(SearchForChild)(ITFSNode *pParent, DWORD dwSearchType, ITFSNode **ppNode) IPURE; \

#undef INTERFACE
#define INTERFACE ITFSNode
DECLARE_INTERFACE_(ITFSNode, IUnknown)
{
    DeclareIUnknownMembers(PURE)
    DeclareITFSNodeMembers(PURE)
};
typedef ComSmartPointer<ITFSNode, &IID_ITFSNode> SPITFSNode;


/*---------------------------------------------------------------------------
    ITFSNodeEnum    interface
 ---------------------------------------------------------------------------*/
#define DeclareITFSNodeEnumMembers(IPURE) \
    STDMETHOD(Next) (THIS_ ULONG uNum, ITFSNode **ppNode, ULONG *pNumReturned) IPURE; \
    STDMETHOD(Skip) (THIS_ ULONG uNum) IPURE; \
    STDMETHOD(Reset) (THIS) IPURE; \
    STDMETHOD(Clone) (THIS_ ITFSNodeEnum **ppNodeEnum) IPURE; \

#undef INTERFACE
#define INTERFACE ITFSNodeEnum
DECLARE_INTERFACE_(ITFSNodeEnum, IUnknown)
{
    DeclareIUnknownMembers(PURE)
    DeclareITFSNodeEnumMembers(PURE)
};

typedef ComSmartPointer<ITFSNodeEnum, &IID_ITFSNodeEnum> SPITFSNodeEnum;


/*---------------------------------------------------------------------------
    ITFSNodeMgr    interface
 ---------------------------------------------------------------------------*/
#define DeclareITFSNodeMgrMembers(IPURE) \
    STDMETHOD(GetRootNode) (THIS_ ITFSNode **ppTFSNode) IPURE; \
    STDMETHOD(SetRootNode) (THIS_ ITFSNode *pRootNode) IPURE; \
    STDMETHOD(GetComponentData) (THIS_ IComponentData **ppComponentData) IPURE; \
    STDMETHOD(FindNode) (THIS_ MMC_COOKIE cookie, ITFSNode **ppTFSNode) IPURE; \
    STDMETHOD(RegisterCookieLookup) (THIS) IPURE; \
    STDMETHOD(UnregisterCookieLookup) (THIS) IPURE; \
    STDMETHOD(IsCookieValid) (THIS_ MMC_COOKIE cookie) IPURE; \
    STDMETHOD(SelectNode) (THIS_ ITFSNode *pNode) IPURE; \
    STDMETHOD(SetResultPaneNode) (THIS_ ITFSNode *pNode) IPURE; \
    STDMETHOD(GetResultPaneNode) (THIS_ ITFSNode **ppNode) IPURE; \
    STDMETHOD(GetConsole) (THIS_ IConsole2 **ppConsole) IPURE; \
    STDMETHOD(GetConsoleNameSpace) (THIS_ IConsoleNameSpace2 **ppConsoleNS) IPURE; \
    STDMETHOD(SetConsole)(THIS_ IConsoleNameSpace2 *pConsoleNS, IConsole2 *pConsole) IPURE; \


#undef INTERFACE
#define INTERFACE ITFSNodeMgr
DECLARE_INTERFACE_(ITFSNodeMgr, IUnknown)
{
    DeclareIUnknownMembers(PURE)
    DeclareITFSNodeMgrMembers(PURE)
};

typedef ComSmartPointer<ITFSNodeMgr, &IID_ITFSNodeMgr> SPITFSNodeMgr;




/*---------------------------------------------------------------------------
    Interface:    ITFSNodeHandler

    Notification
        Notify

    Methods to deal with property sheets
        CreatePropertyPages
        HasPropertyPages

    Methods to deal with context menus
        OnAddMenuItems
        OnCommand

    Display columns of info
        GetString
    
 ---------------------------------------------------------------------------*/


#define OVERRIDE_NodeHandler_Notify() \
            STDMETHOD(Notify) (ITFSNode *pNode, IDataObject *pDataObject, \
                    DWORD dwType, MMC_NOTIFY_TYPE event, \
                    LPARAM arg, LPARAM lParam) 

#define OVERRIDE_NodeHandler_CreatePropertyPages() \
    STDMETHOD(CreatePropertyPages) (ITFSNode *pNode, \
                                LPPROPERTYSHEETCALLBACK lpProvider, \
                                LPDATAOBJECT            pDataObject, \
                                LONG_PTR                handle, \
                                DWORD                   dwType)

#define OVERRIDE_NodeHandler_HasPropertyPages() \
    STDMETHOD(HasPropertyPages) (ITFSNode *pNode, LPDATAOBJECT pDataObject, \
                               DATA_OBJECT_TYPES    type, \
                               DWORD                dwType) 

#define OVERRIDE_NodeHandler_OnAddMenuItems() \
    STDMETHOD(OnAddMenuItems)(ITFSNode *pNode, \
                            LPCONTEXTMENUCALLBACK pContextMenuCallback, \
                            LPDATAOBJECT lpDataObject, \
                            DATA_OBJECT_TYPES type, \
                            DWORD dwType, \
                            long *pInsertionAllowed) 

#define OVERRIDE_NodeHandler_OnCommand() \
    STDMETHOD(OnCommand) (ITFSNode *pNode, long nCommandId, \
                        DATA_OBJECT_TYPES    type, \
                        LPDATAOBJECT pDataObject, \
                        DWORD    dwType) 

#define OVERRIDE_NodeHandler_GetString() \
    STDMETHOD_(LPCTSTR, GetString) (ITFSNode *pNode, int nCol) 

#define OVERRIDE_NodeHandler_UserNotify() \
    STDMETHOD(UserNotify)(ITFSNode *pNode, LPARAM dwParam, LPARAM dwParam2) 

#define OVERRIDE_NodeHandler_OnCreateDataObject() \
    STDMETHOD(OnCreateDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject) 

#define OVERRIDE_NodeHandler_DestroyHandler() \
    STDMETHOD(DestroyHandler)(ITFSNode *pNode) 

#define OVERRIDE_NodeHandler_CreateNodeId2() \
    STDMETHOD(CreateNodeId2)(ITFSNode * pNode, BSTR * bstrId, DWORD * dwFlags) 
                                    
#define DeclareITFSNodeHandlerMembers(IPURE) \
    OVERRIDE_NodeHandler_Notify() IPURE; \
    OVERRIDE_NodeHandler_CreatePropertyPages() IPURE; \
    OVERRIDE_NodeHandler_HasPropertyPages() IPURE; \
    OVERRIDE_NodeHandler_OnAddMenuItems() IPURE; \
    OVERRIDE_NodeHandler_OnCommand() IPURE; \
    OVERRIDE_NodeHandler_GetString() IPURE; \
    OVERRIDE_NodeHandler_UserNotify() IPURE; \
    OVERRIDE_NodeHandler_OnCreateDataObject() IPURE; \
    OVERRIDE_NodeHandler_DestroyHandler() IPURE; \
    OVERRIDE_NodeHandler_CreateNodeId2() IPURE;

#undef INTERFACE
#define INTERFACE ITFSNodeHandler
DECLARE_INTERFACE_(ITFSNodeHandler, IUnknown)
{
    DeclareIUnknownMembers(PURE)
    DeclareITFSNodeHandlerMembers(PURE)
};

typedef ComSmartPointer<ITFSNodeHandler, &IID_ITFSNodeHandler> SPITFSNodeHandler;



/*---------------------------------------------------------------------------
    Interface:    ITFSResultHandler

    Notification
        Notify

    Result pane callbacks
        UpdateView
        GetString

    Context menu members
        AddMenuItems
        Command

    (root node only)
        OnCreateControlbars
        Controlbarnotify
 ---------------------------------------------------------------------------*/


#define OVERRIDE_ResultHandler_Notify() \
            STDMETHOD(Notify) (ITFSComponent * pComponent, \
                               MMC_COOKIE            cookie, \
                               LPDATAOBJECT    pDataObject, \
                               MMC_NOTIFY_TYPE event, \
                               LPARAM            arg, \
                               LPARAM            lParam) 

#define OVERRIDE_ResultHandler_UpdateView() \
            STDMETHOD(UpdateView) (ITFSComponent * pComponent, \
                                   LPDATAOBJECT    pDataObject, \
                                   LPARAM            data, \
                                   LPARAM            hint) 

#define OVERRIDE_ResultHandler_GetString()    \
            STDMETHOD_(LPCTSTR, GetString) (ITFSComponent * pComponent, \
                                            MMC_COOKIE            cookie, \
                                            int             nCol) 
                           
#define OVERRIDE_ResultHandler_CompareItems()    \
            STDMETHOD_(int, CompareItems)(ITFSComponent * pComponent, \
                                          MMC_COOKIE            cookieA, \
                                          MMC_COOKIE            cookieB, \
                                          int             nCol)

#define OVERRIDE_ResultHandler_CompareItemsEx()    \
            STDMETHOD_(int, CompareItems)( ITFSComponent * pComponent, \
                                           RDCOMPARE *prdc )

#define OVERRIDE_ResultHandler_CreatePropertyPages() \
            STDMETHOD(CreatePropertyPages) (ITFSComponent * pComponent, \
                                            MMC_COOKIE            cookie, \
                                            LPPROPERTYSHEETCALLBACK lpProvider, \
                                            LPDATAOBJECT    pDataObject, \
                                            LONG_PTR            handle) 
                                
#define OVERRIDE_ResultHandler_HasPropertyPages() \
            STDMETHOD(HasPropertyPages) (ITFSComponent * pComponent, \
                                         MMC_COOKIE            cookie, \
                                         LPDATAOBJECT    pDataObject) 
                                
#define OVERRIDE_ResultHandler_AddMenuItems()  \
            STDMETHOD(AddMenuItems) (ITFSComponent * pComponent,\
                                     MMC_COOKIE            cookie, \
                                     LPDATAOBJECT    pDataObject, \
                                     LPCONTEXTMENUCALLBACK pContextMenuCallback, \
                                     long *          pInsertionAllowed) 
                                
#define OVERRIDE_ResultHandler_Command() \
            STDMETHOD(Command) (ITFSComponent * pComponent, \
                                MMC_COOKIE            cookie, \
                                int             nCommandID, \
                                LPDATAOBJECT    pDataObject) 
                                
#define OVERRIDE_ResultHandler_OnCreateControlbars() \
            STDMETHOD(OnCreateControlbars) (ITFSComponent * pComponent, \
                                            LPCONTROLBAR    pControlBar) 
                                
#define OVERRIDE_ResultHandler_ControlbarNotify() \
            STDMETHOD(ControlbarNotify) (ITFSComponent * pComponent, \
                                         MMC_NOTIFY_TYPE event, \
                                         LPARAM            arg, \
                                         LPARAM            param) 
                                
#define OVERRIDE_ResultHandler_UserResultNotify()    \
            STDMETHOD(UserResultNotify)(ITFSNode *  pNode, \
                                        LPARAM      dwParam, \
                                        LPARAM      dwParam2) 
                                        
#define OVERRIDE_ResultHandler_OnCreateDataObject()    \
            STDMETHOD(OnCreateDataObject)(ITFSComponent *    pComponent, \
                                          LONG_PTR               cookie, \
                                          DATA_OBJECT_TYPES  type, \
                                          IDataObject **     ppDataObject) 
                                
#define OVERRIDE_ResultHandler_DestroyResultHandler()    \
            STDMETHOD(DestroyResultHandler)(LONG_PTR cookie) 

#define OVERRIDE_ResultHandler_OnGetResultViewType()    \
            STDMETHOD(OnGetResultViewType)(ITFSComponent * pComponent, \
                                           MMC_COOKIE            cookie, \
                                           LPOLESTR *      ppViewType, \
                                           long*          pViewOptions)

// virtual listbox support
#define OVERRIDE_ResultHandler_GetVirtualString()    \
            STDMETHOD_(LPCWSTR, GetVirtualString)(int nIndex, int nCol) 

#define OVERRIDE_ResultHandler_GetVirtualImage()    \
            STDMETHOD_(int, GetVirtualImage)(int nIndex) 

#define OVERRIDE_ResultHandler_FindItem()    \
            STDMETHOD(FindItem)(LPRESULTFINDINFO pFindInfo, int * pnFoundIndex) 

#define OVERRIDE_ResultHandler_CacheHint()    \
            STDMETHOD(CacheHint)(int nStartIndex, int nEndIndex) 

#define OVERRIDE_ResultHandler_SortItems()    \
            STDMETHOD(SortItems)(int nColumn, DWORD dwSortOptions, LPARAM lUserParam) 

// task pad functions
#define OVERRIDE_ResultHandler_TaskPadNotify() \
    STDMETHOD(TaskPadNotify)(ITFSComponent *,MMC_COOKIE,LPDATAOBJECT,VARIANT *,VARIANT *)

#define OVERRIDE_ResultHandler_EnumTasks() \
    STDMETHOD(EnumTasks)(ITFSComponent *,MMC_COOKIE,LPDATAOBJECT,LPOLESTR,IEnumTASK **)

#define OVERRIDE_ResultHandler_TaskPadGetTitle() \
    STDMETHOD(TaskPadGetTitle)(ITFSComponent *,MMC_COOKIE,LPOLESTR,LPOLESTR *)

#define OVERRIDE_ResultHandler_TaskPadGetBackground() \
    STDMETHOD(TaskPadGetBackground)(ITFSComponent *,MMC_COOKIE,LPOLESTR,MMC_TASK_DISPLAY_OBJECT *)

/* 
#define OVERRIDE_ResultHandler_TaskPadGetBanner() \
    STDMETHOD(TaskPadGetBanner)(ITFSComponent *,MMC_COOKIE,LPOLESTR,LPOLESTR *)
*/

#define OVERRIDE_ResultHandler_TaskPadGetDescriptiveText() \
    STDMETHOD(TaskPadGetDescriptiveText)(ITFSComponent *,MMC_COOKIE,LPOLESTR,LPOLESTR *)

#define DeclareITFSResultHandlerMembers(IPURE) \
    OVERRIDE_ResultHandler_Notify() IPURE; \
    OVERRIDE_ResultHandler_UpdateView() IPURE; \
    OVERRIDE_ResultHandler_GetString() IPURE; \
    OVERRIDE_ResultHandler_CompareItems() IPURE; \
    OVERRIDE_ResultHandler_CompareItemsEx() IPURE; \
    OVERRIDE_ResultHandler_CreatePropertyPages() IPURE; \
    OVERRIDE_ResultHandler_HasPropertyPages() IPURE; \
    OVERRIDE_ResultHandler_AddMenuItems() IPURE; \
    OVERRIDE_ResultHandler_Command() IPURE; \
    OVERRIDE_ResultHandler_OnCreateControlbars() IPURE; \
    OVERRIDE_ResultHandler_ControlbarNotify() IPURE; \
    OVERRIDE_ResultHandler_UserResultNotify() IPURE; \
    OVERRIDE_ResultHandler_OnCreateDataObject() IPURE; \
    OVERRIDE_ResultHandler_DestroyResultHandler() IPURE; \
    OVERRIDE_ResultHandler_OnGetResultViewType() IPURE; \
    OVERRIDE_ResultHandler_GetVirtualString() IPURE; \
    OVERRIDE_ResultHandler_GetVirtualImage() IPURE; \
    OVERRIDE_ResultHandler_FindItem() IPURE; \
    OVERRIDE_ResultHandler_CacheHint() IPURE; \
    OVERRIDE_ResultHandler_SortItems() IPURE; \
    OVERRIDE_ResultHandler_TaskPadNotify() IPURE; \
    OVERRIDE_ResultHandler_EnumTasks() IPURE; \
    OVERRIDE_ResultHandler_TaskPadGetTitle() IPURE; \
    OVERRIDE_ResultHandler_TaskPadGetBackground() IPURE; \
    OVERRIDE_ResultHandler_TaskPadGetDescriptiveText() IPURE; 

#undef INTERFACE
#define INTERFACE ITFSResultHandler
DECLARE_INTERFACE_(ITFSResultHandler, IUnknown)
{
    DeclareIUnknownMembers(PURE)
    DeclareITFSResultHandlerMembers(PURE)
};

typedef ComSmartPointer<ITFSResultHandler, &IID_ITFSResultHandler> SPITFSResultHandler;


/*---------------------------------------------------------------------------
    ITFSThreadHandler interface
 ---------------------------------------------------------------------------*/

#define DeclareITFSThreadHandlerMembers(IPURE) \
    STDMETHOD(OnNotifyHaveData)(LPARAM) IPURE; \
    STDMETHOD(OnNotifyError)(LPARAM) IPURE; \
    STDMETHOD(OnNotifyExiting)(LPARAM) IPURE; \

#undef INTERFACE
#define INTERFACE ITFSThreadHandler
DECLARE_INTERFACE_(ITFSThreadHandler, IUnknown)
{
    DeclareIUnknownMembers(PURE)
    DeclareITFSThreadHandlerMembers(PURE)
};

typedef ComSmartPointer<ITFSThreadHandler, &IID_ITFSThreadHandler> SPITFSThreadHandler;


/*---------------------------------------------------------------------------
    ITFSQueryObject interface
 ---------------------------------------------------------------------------*/

#define DeclareITFSQueryObjectMembers(IPURE) \
    STDMETHOD(Init) (ITFSThreadHandler *pHandler, HWND hwndHidden, UINT uMsgBase) IPURE; \
    STDMETHOD(Execute) (THIS) IPURE; \
    STDMETHOD(OnThreadExit) (THIS) IPURE; \
    STDMETHOD(FCheckForAbort) (THIS) IPURE; \
    STDMETHOD(SetAbortEvent) (THIS) IPURE; \
    STDMETHOD_(HANDLE, GetAbortEventHandle) (THIS) IPURE; \
    STDMETHOD(OnEventAbort) (THIS) IPURE; \
    STDMETHOD(DoCleanup) (THIS) IPURE; 

#undef INTERFACE
#define INTERFACE ITFSQueryObject
DECLARE_INTERFACE_(ITFSQueryObject, IUnknown)
{
    DeclareIUnknownMembers(PURE)
    DeclareITFSQueryObjectMembers(PURE)
};

typedef ComSmartPointer<ITFSQueryObject, &IID_ITFSQueryObject> SPITFSQueryObject;




/*---------------------------------------------------------------------------
    ITFSError interface
 ---------------------------------------------------------------------------*/

struct TFSErrorInfo
{
    DWORD    m_dwSize;        // size of the structure, used for versioning 
    DWORD    m_dwThreadId;    // thread id of this error structure
    LONG_PTR    m_uReserved1;    // = 0, reserved for object id
    LONG_PTR    m_uReserved2;    // = 0 for now, reserved for HRESULT component type
    DWORD    m_hrLow;        // HRESULT of the low level error
    LPCOLESTR    m_pszLow;    // allocate using HeapAlloc() and GetErrorHeap()
    LPCOLESTR    m_pszHigh;    // allocate using HeapAlloc() and GetErrorHeap()
    LPCOLESTR    m_pszGeek;    // allocate using HeapAlloc() and GetErrorHeap()
    LONG_PTR    m_uReserved3;    // =0, reserved for future help info
    LONG_PTR    m_uReserved4;    // =0, reserved for future help info
    LONG_PTR    m_uReserved5;    // =0, reserved for future use

    DWORD       m_dwFlags;      // used to pass internal info
};


#define DeclareITFSErrorMembers(IPURE) \
    STDMETHOD(GetErrorInfo)(THIS_ LONG_PTR uReserved, TFSErrorInfo **ppErrStruct) IPURE; \
    STDMETHOD(GetErrorInfoForThread)(THIS_ DWORD dwThreadId, LONG_PTR uReserved, TFSErrorInfo **ppErrStruct) IPURE; \
    STDMETHOD(SetErrorInfo)(THIS_ LONG_PTR uReserved, const TFSErrorInfo *pErrStruct) IPURE; \
    STDMETHOD(SetErrorInfoForThread)(THIS_ DWORD dwThreadId, LONG_PTR uReserved, const TFSErrorInfo *pErrStruct) IPURE; \
    STDMETHOD(ClearErrorInfo)(THIS_ LONG_PTR uReserved) IPURE; \
    STDMETHOD(ClearErrorInfoForThread)(THIS_ DWORD dwThreadId, LONG_PTR uReserved) IPURE; \
            

#undef INTERFACE
#define INTERFACE ITFSError
DECLARE_INTERFACE_(ITFSError, IUnknown)
{
    DeclareIUnknownMembers(PURE)
    DeclareITFSErrorMembers(PURE)
};

typedef ComSmartPointer<ITFSError, &IID_ITFSError> SPITFSError;






// Misc smart pointers
typedef ComSmartPointer<IConsoleVerb, &IID_IConsoleVerb> SPIConsoleVerb;
typedef ComSmartPointer<IControlbar, &IID_IControlbar> SPIControlBar;
typedef ComSmartPointer<IDataObject, &IID_IDataObject> SPIDataObject;
typedef ComSmartPointer<IHeaderCtrl, &IID_IHeaderCtrl> SPIHeaderCtrl;
typedef ComSmartPointer<IImageList, &IID_IImageList> SPIImageList;
typedef ComSmartPointer<IPropertySheetCallback, &IID_IPropertySheetCallback> SPIPropertySheetCallback;
typedef ComSmartPointer<IPropertySheetProvider, &IID_IPropertySheetProvider> SPIPropertySheetProvider;
typedef ComSmartPointer<IResultData, &IID_IResultData> SPIResultData;
typedef ComSmartPointer<IToolbar, &IID_IToolbar> SPIToolbar;

typedef ComSmartPointer<IPersistStream, &IID_IPersistStream> SPIPersistStream;
typedef ComSmartPointer<IPersistStreamInit, &IID_IPersistStreamInit> SPIPersistStreamInit;



/*---------------------------------------------------------------------------
    Misc. APIs
 ---------------------------------------------------------------------------*/

TFSCORE_API(HRESULT) ExtractNodeFromDataObject(ITFSNodeMgr *pNodeMgr,
                                 const CLSID *pClsid,
                                 LPDATAOBJECT pDataObject,
                                 BOOL fCheckForCreate,
                                 ITFSNode **ppNode,
                                 DWORD *pdwType,
                                 INTERNAL **ppInternal);
        
// These are non-AGGREGATABLE!
TFSCORE_API(HRESULT) CreateLeafTFSNode (ITFSNode **pNode,
                           const GUID *pNodeType,
                           ITFSNodeHandler *pNodeHandler,
                           ITFSResultHandler *pResultHandler,
                           ITFSNodeMgr *pNodeMgr);

TFSCORE_API(HRESULT) CreateContainerTFSNode (ITFSNode **ppNode,
                                const GUID *pNodeType,
                                ITFSNodeHandler *pNodeHandler,
                                ITFSResultHandler *pResultHandler,
                                ITFSNodeMgr *pNodeMgr);

TFSCORE_API(HRESULT) CreateTFSNodeMgr(ITFSNodeMgr **ppTFSNodeMgr,
                        IComponentData *pComponentData,
                        IConsole2 *pConsole,
                        IConsoleNameSpace2 *pConsoleNamespace);

TFSCORE_API(HRESULT) CreateTFSComponentData(IComponentData **ppCompData,
                            ITFSCompDataCallback *pCallback);

                                                   
#endif // _TFSINT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\tfsnode.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:	tfsnode.h
//
// History:
//
//	04/13/97	Kenn Takara				Created.
//
//	Declarations for some common code/macros.
//============================================================================

#ifndef _TFSNODE_H_
#define _TFSNODE_H_

#if _MSC_VER >= 1000	// VC 5.0 or later
#pragma once
#endif

// UpdateAllViews hints
#define RESULT_PANE_ADD_ITEM			( 0x00000001 )
#define RESULT_PANE_DELETE_ITEM			( 0x00000002 )
#define RESULT_PANE_CHANGE_ITEM_DATA	( 0x00000004 )
#define RESULT_PANE_CHANGE_ITEM_ICON	( 0x00000008 )
#define RESULT_PANE_CHANGE_ITEM			( RESULT_PANE_CHANGE_ITEM_DATA | RESULT_PANE_CHANGE_ITEM_ICON )
#define RESULT_PANE_REPAINT				( 0x00000010 )
#define RESULT_PANE_DELETE_ALL			( 0x00000020 )
#define RESULT_PANE_ADD_ALL				( 0x00000040 )
#define RESULT_PANE_COLUMN_CHANGE		( 0x00000080 )
#define RESULT_PANE_SAVE_COLUMNS		( 0x00000100 )
#define RESULT_PANE_UPDATE_VERBS        ( 0x00000200 )
#define RESULT_PANE_SET_VIRTUAL_LB_SIZE ( 0x00000400 )
#define RESULT_PANE_CLEAR_VIRTUAL_LB    ( 0x00000800 )
#define RESULT_PANE_EXPAND              ( 0x00001000 )
#define RESULT_PANE_SHOW_MESSAGE        ( 0x00002000 )
#define RESULT_PANE_CLEAR_MESSAGE       ( 0x00004000 )

// Used for ChangeNode
#define SCOPE_PANE_CHANGE_ITEM_DATA		( 0x00000080 )
#define SCOPE_PANE_CHANGE_ITEM_ICON		( 0x00000100 )
#define SCOPE_PANE_STATE_NORMAL         ( 0x00000200 )
#define SCOPE_PANE_STATE_BOLD           ( 0x00000400 )
#define SCOPE_PANE_STATE_EXPANDEDONCE   ( 0x00000800 )
#define SCOPE_PANE_STATE_CLEAR          ( 0x00001000 )
#define SCOPE_PANE_CHANGE_ITEM			( SCOPE_PANE_CHANGE_ITEM_DATA | \
                                          SCOPE_PANE_CHANGE_ITEM_ICON )

typedef struct _TFSEXPANDDATA
{
    SPITFSNode spNode;
    BOOL       fExpand;
} TFSEXPANDDATA, * LPTFSEXPANDDATA;

typedef CList<ITFSNode *, ITFSNode *> CTFSNodeListBase;

class CTFSNodeList : public CTFSNodeListBase
{
public:
	~CTFSNodeList()
	{
		ReleaseAllNodes();
	}

	BOOL RemoveNode(ITFSNode* p)
	{
		POSITION pos = Find(p);
		if (pos == NULL)
			return FALSE;
		RemoveAt(pos);
		return TRUE;
	}
	void ReleaseAllNodes() 
	{	
		while (!IsEmpty()) 
			RemoveTail()->Release();	
	}
	BOOL HasNode(ITFSNode* p)
	{
		return NULL != Find(p);
	}
};


#define IMPL

/*---------------------------------------------------------------------------
	Class:	TFSNode
 ---------------------------------------------------------------------------*/

class TFSNode : public ITFSNode
{
public:
	TFSNode();
	virtual ~TFSNode();

	DeclareIUnknownMembers(IMPL);
	DeclareITFSNodeMembers(IMPL);

	HRESULT Construct(const GUID *pNodeType,
					  ITFSNodeHandler *pHandler,
					  ITFSResultHandler *pResultHandler,
					  ITFSNodeMgr *pNodeMgr);

protected:
    HRESULT UpdateAllViewsHelper(LPARAM data, LONG_PTR hint);

	HRESULT InternalRemoveFromUI(ITFSNode *pNode, BOOL fDeleteThis);
	HRESULT InternalZeroScopeID(ITFSNode *pNode, BOOL fZeroChildren);

protected:
	TFSVisibility	m_tfsVis;
	LONG_PTR			m_uData;		// user-settable data
	LONG_PTR			m_uDataParent;	// user-settable (set by the parent) data
	LONG_PTR			m_uType;		// user-settable data
	LONG_PTR			m_cookie;
	IfDebug(BOOL m_bCookieSet);

	SPITFSNodeHandler	m_spNodeHandler;
	SPITFSResultHandler	m_spResultHandler;
	BOOL			    m_fContainer;

	int				m_nImageIndex;
	int				m_nOpenImageIndex;
	LPARAM			m_lParam;
	long			m_cPropSheet;		// # of active property pages
	
	BOOL			m_fDirty;

	SPITFSNode		m_spNodeParent;
	SPITFSNodeMgr	m_spNodeMgr;

	HSCOPEITEM		m_hScopeItem;

	const GUID *	m_pNodeType;

	// Positional data
	HSCOPEITEM		m_hRelativeId;
	ULONG			m_ulRelativeFlags;

    BOOL            m_fScopeLeafNode;

	LONG			m_cRef;

private:
	HRESULT InitializeScopeDataItem(LPSCOPEDATAITEM pScopeDataItem, 
									HSCOPEITEM		pParentScopeItem, 
									LPARAM			lParam,
									int				nImage, 
									int				nOpenImage, 
									BOOL			bHasChildren,
									ULONG			ulRelativeFlags,
									HSCOPEITEM		hSibling);
};

/*---------------------------------------------------------------------------
	Class:	TFSContainer
 ---------------------------------------------------------------------------*/

class TFSContainer : public TFSNode
{
public:
	virtual ~TFSContainer();

	// specific container-related functions that we need to override
	STDMETHOD_(BOOL, IsContainer) ();
	STDMETHOD(AddChild) (ITFSNode *pNodeChild);
	STDMETHOD(InsertChild) (ITFSNode *pInsertAfterNode, ITFSNode *pNodeChild);
	STDMETHOD(RemoveChild) (ITFSNode *pNodeChild);
	STDMETHOD(ExtractChild) (ITFSNode *pNodeChild);
	STDMETHOD(GetChildCount) (int *pVis, int *pTotal);
	STDMETHOD(GetEnum) (ITFSNodeEnum **ppNodeEnum);
	STDMETHOD(DeleteAllChildren) (BOOL fRemoveFromUI);
	STDMETHOD(CompareChildNodes) (int *pnResult, ITFSNode *pChild1, ITFSNode *pChild2);
	STDMETHOD_(LONG_PTR, Notify)(int nIndex, LPARAM lParam);
	

    // we override this node interface member for containers
    STDMETHOD(ChangeNode)(LONG_PTR    changeMask);

protected:
	HRESULT		InternalAddToList(ITFSNode *pInsertAfterNode, ITFSNode *pNode);
	HRESULT		InternalRemoveFromList(ITFSNode *pNode);
	HRESULT		InternalRemoveChild(ITFSNode *	pChild, 
		                            BOOL		fRemoveFromList, 
									BOOL		fRemoveFromUI, 
									BOOL		fRemoveChildren);

    CTFSNodeList	m_listChildren;

private:
    friend class TFSNodeEnum;
};

/*---------------------------------------------------------------------------
	Class:	TFSNodeEnum
 ---------------------------------------------------------------------------*/

class TFSNodeEnum : public ITFSNodeEnum
{
public:
	TFSNodeEnum(TFSContainer * pNode);
	virtual ~TFSNodeEnum();

	DeclareIUnknownMembers(IMPL);
	DeclareITFSNodeEnumMembers(IMPL);

protected:
	TFSContainer *  m_pNode;
	LONG			m_cRef;

    POSITION        m_pos;
private:
};

/*---------------------------------------------------------------------------
	Class:	TFSNodeMgr
 ---------------------------------------------------------------------------*/
class TFSNodeMgr :
	public ITFSNodeMgr
{
public:
	TFSNodeMgr();
	~TFSNodeMgr();

	DeclareIUnknownMembers(IMPL)
	DeclareITFSNodeMgrMembers(IMPL)

	HRESULT Construct(IComponentData *pCompData,
					  IConsoleNameSpace2 *pConsoleNS);

protected:
	SPIComponentData	m_spComponentData;
	SPITFSNode	        m_spRootNode;
	SPITFSNode	        m_spResultPaneNode;
	SPIConsole      	m_spConsole;
	SPIConsoleNameSpace	m_spConsoleNS;

	long				m_cRef;
};

#endif	// _TFSNODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\tregkey.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1995 - 1999 **/
/**********************************************************************/

/*
    FILE HISTORY:
        
*/

#include "stdafx.h"

#include <stdlib.h>
#include <memory.h>
#include <ctype.h>

#include "tfschar.h"
#include "tregkey.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//  Convert a CStringList to the REG_MULTI_SZ format
DWORD StrList2MULTI_SZ(CStringList & strList, DWORD * pcbSize, BYTE ** ppbData)
{
    DWORD dwErr = 0 ;

    POSITION pos ;
    CString * pstr ;
    int cbTotal = 0 ;

    //  Walk the list accumulating sizes
    for ( pos = strList.GetHeadPosition() ;
          pos != NULL && (pstr = & strList.GetNext( pos )) ; ) 
    {
        cbTotal += pstr->GetLength() + 1 ;
    }

	// Add on space for two NULL characters
	cbTotal += 2;

    //  Allocate and fill a temporary buffer
    if (*pcbSize = (cbTotal * sizeof(TCHAR) ) )
    {
        TRY
        {
            *ppbData = new BYTE[ *pcbSize] ;

			// NULL out the data buffer
			::ZeroMemory(*ppbData, *pcbSize);

            BYTE * pbData = *ppbData ;

            //  Populate the buffer with the strings.
            for ( pos = strList.GetHeadPosition() ;
                pos != NULL && (pstr = & strList.GetNext( pos )) ; ) 
            {
                int cb = (pstr->GetLength() + 1) * sizeof(TCHAR) ;
                ::memcpy( pbData, (LPCTSTR) *pstr, cb ) ;
                pbData += cb ;
            }

			// Assert that we have not passed the end of the buffer
			Assert((pbData - *ppbData) < (int) *pcbSize);

			// Assert that we have an extra NULL character
			Assert(*((TCHAR *)pbData) == 0);
        }
        CATCH_ALL(e)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
    else
    {
        *ppbData = NULL;
    }

    return dwErr ;
}

//  Convert a REG_MULTI_SZ format to the CStringList 
DWORD MULTI_SZ2StrList(LPCTSTR pstrMulti_Sz, CStringList& strList)
{
	DWORD	dwErr = NOERROR;

	strList.RemoveAll();
	
        //  Catch exceptions trying to build the list
    TRY
    {
        if (pstrMulti_Sz)
        {
            while ( StrLen(pstrMulti_Sz) )
            {
                strList.AddTail( pstrMulti_Sz ) ;
                pstrMulti_Sz += StrLen( pstrMulti_Sz ) + 1 ;
            }
        }
    }
    CATCH_ALL(e)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY ;
    }
    END_CATCH_ALL

	return dwErr;
}


/*!--------------------------------------------------------------------------
	RegKey::RegKey
		Constructor
	Author: KennT
 ---------------------------------------------------------------------------*/
RegKey::RegKey()
	: m_hKey(0)
{
}


/*!--------------------------------------------------------------------------
	RegKey::~RegKey
		Destructor
	Author: KennT
 ---------------------------------------------------------------------------*/
RegKey::~RegKey ()
{
	Close();
}

/*!--------------------------------------------------------------------------
	RegKey::Open
		
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD RegKey::Open( HKEY hKeyParent,
					LPCTSTR pszSubKey,
					REGSAM regSam,
					LPCTSTR pszServerName)
{
    HKEY	hkBase = NULL ;
	DWORD	dwErr = 0;

	Close();

	// If we have a server name, try to open a remote connection
    if ( pszServerName ) 
		dwErr = ::RegConnectRegistry((LPTSTR) pszServerName, hKeyParent, &hkBase);
    else
        hkBase = hKeyParent ;

    if ( dwErr == 0 ) 
    {
        if ( pszSubKey )
		{
            dwErr = ::RegOpenKeyEx( hkBase, pszSubKey, 0, regSam, & m_hKey ) ;
		}
        else
        {
            m_hKey = hkBase ;
            hkBase = NULL ;	// set to NULL so that the key doesn't get closed
        }

        if ( hkBase && (hkBase != hKeyParent) )
            ::RegCloseKey( hkBase ) ;
    }
    
    if ( dwErr ) 
        m_hKey = NULL ;

	return dwErr;
}


/*!--------------------------------------------------------------------------
	RegKey::Create
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD RegKey::Create(
					 HKEY hKeyBase, 
					 LPCTSTR pszSubKey,
					 DWORD dwOptions,
					 REGSAM regSam,
					 LPSECURITY_ATTRIBUTES pSecAttr,
					 LPCTSTR pszServerName )
{
    HKEY	hkBase = NULL ;
    LONG	dwErr = 0;
	DWORD	dwDisposition;

	Close();
    
    if ( pszServerName ) 
    {
        // This is a remote connection.
        dwErr = ::RegConnectRegistry( (LPTSTR) pszServerName, hKeyBase, &hkBase );
    }
    else
        hkBase = hKeyBase ;

    if (dwErr == 0)
    {
        LPTSTR szEmpty = _T("");

        dwErr = ::RegCreateKeyEx( hkBase, pszSubKey, 
								  0, szEmpty, 
								  dwOptions, regSam,  pSecAttr,
								  & m_hKey, 
								  & dwDisposition ) ;

        if ( hkBase && (hkBase != hKeyBase) )
            ::RegCloseKey( hkBase ) ;
    }
	
    if ( dwErr )
        m_hKey = NULL ;

	return dwErr;
}

/*!--------------------------------------------------------------------------
	RegKey::Close
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD RegKey::Close()
{
	DWORD	dwErr = 0;
	if (m_hKey)
		dwErr = ::RegCloseKey(m_hKey);
	m_hKey = 0;
	return dwErr;
}


/*!--------------------------------------------------------------------------
	RegKey::Detach
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HKEY RegKey::Detach()
{
	HKEY hKey = m_hKey;
	m_hKey = NULL;
	return hKey;
}

/*!--------------------------------------------------------------------------
	RegKey::Attach
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void RegKey::Attach(HKEY hKey)
{
	Assert(m_hKey == NULL);
	m_hKey = hKey;
}


/*!--------------------------------------------------------------------------
	RegKey::DeleteSubKey
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD RegKey::DeleteSubKey(LPCTSTR lpszSubKey)
{
	Assert(m_hKey != NULL);
	return RegDeleteKey(m_hKey, lpszSubKey);
}

/*!--------------------------------------------------------------------------
	RegKey::DeleteValue
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD RegKey::DeleteValue(LPCTSTR lpszValue)
{
	Assert(m_hKey != NULL);
	return RegDeleteValue(m_hKey, (LPTSTR)lpszValue);
}


/*!--------------------------------------------------------------------------
	RegKey::RecurseDeleteKey
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD RegKey::RecurseDeleteKey(LPCTSTR lpszKey)
{
 	RegKey	key;
	DWORD	dwRes = key.Open(m_hKey, lpszKey, KEY_READ | KEY_WRITE);
	if (dwRes != ERROR_SUCCESS)
		return dwRes;
	
	FILETIME time;
	TCHAR szBuffer[256];
	DWORD dwSize = 256;
	
	while (RegEnumKeyEx(key, 0, szBuffer, &dwSize, NULL, NULL, NULL,
						&time)==ERROR_SUCCESS)
	{
		dwRes = key.RecurseDeleteKey(szBuffer);
		if (dwRes != ERROR_SUCCESS)
			return dwRes;
		dwSize = 256;
	}
	key.Close();
	return DeleteSubKey(lpszKey);
}


/*!--------------------------------------------------------------------------
	RegKey::RecurseDeleteSubKeys
		Deletes the subkeys of the current key.
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD RegKey::RecurseDeleteSubKeys()
{
	FILETIME time;
	TCHAR szBuffer[256];
	DWORD dwSize = 256;
    DWORD   dwRes;

	while (RegEnumKeyEx(m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
						&time)==ERROR_SUCCESS)
	{
        dwRes = RecurseDeleteKey(szBuffer);
		if (dwRes != ERROR_SUCCESS)
			return dwRes;
		dwSize = 256;
	}
    return ERROR_SUCCESS;
}


/*!--------------------------------------------------------------------------
	RegKey::PrepareValue
		Prepare to read a value by finding the value's size.  This will
		allocate space for the data.  The data needs to be freed separately
		by 'delete'.
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD RegKey::PrepareValue( LPCTSTR pszValueName, 
							DWORD * pdwType,
							DWORD * pcbSize,
							BYTE ** ppbData )
{
	DWORD	dwErr = 0;
    
    BYTE chDummy[2] ;
    DWORD cbData = 0 ;

    do
    {
        //  Set the resulting buffer size to 0.
        *pcbSize = 0 ;
        *ppbData = NULL ;

        dwErr = ::RegQueryValueEx( m_hKey, 
								 pszValueName, 
								 0, pdwType, 
								 chDummy, & cbData ) ;

        //  The only error we should get here is ERROR_MORE_DATA, but
        //  we may get no error if the value has no data.
        if ( dwErr == 0 ) 
        {
            cbData = sizeof (LONG) ;  //  Just a fudgy number
        }
        else
            if ( dwErr != ERROR_MORE_DATA ) 
                break ;

        //  Allocate a buffer large enough for the data.

        *ppbData = new BYTE [ (*pcbSize = cbData) + sizeof (LONG) ] ;
		Assert(*ppbData);

        //  Now that have a buffer, re-fetch the value.

        dwErr = ::RegQueryValueEx( m_hKey, 
								   pszValueName, 
								   0, pdwType, 
								   *ppbData, &cbData ) ;

    } while ( FALSE ) ;

    if ( dwErr ) 
    {
        delete [] *ppbData ;
		*ppbData = NULL;
		*pcbSize = 0;
    }

    return dwErr ;
}


DWORD RegKey::QueryTypeAndSize(LPCTSTR pszValueName, DWORD *pdwType, DWORD *pdwSize)
{
	return ::RegQueryValueEx(m_hKey, pszValueName, NULL, pdwType,
							  NULL, pdwSize);
}

DWORD RegKey::QueryValueExplicit(LPCTSTR pszValueName,
								 DWORD *pdwType,
								 DWORD *pdwSize,
								 LPBYTE *ppbData)
{
	DWORD	dwErr = 0;
	DWORD	dwType;
	DWORD	cbData;
	BYTE *	pbData = NULL;
	
	Assert(pdwType);
	Assert(pdwSize);
	Assert(ppbData);

	dwErr = PrepareValue( pszValueName, &dwType, &cbData, &pbData );
	if (dwErr == ERROR_SUCCESS)
	{
		if (dwType != REG_MULTI_SZ)
		{
			dwErr = ERROR_INVALID_PARAMETER;
		}
		else
		{
			*pdwType = dwType;
			*pdwSize = cbData;
			*ppbData = pbData;
			pbData = NULL;
		}
	}
	delete pbData;
	
	return dwErr;
}

//  Overloaded value query members; each returns ERROR_INVALID_PARAMETER
//  if data exists but not in correct form to deliver into result object.

DWORD RegKey::QueryValue( LPCTSTR pszValueName, CString& strResult )
{
	DWORD	dwErr = 0;
    
    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        if ( dwErr = PrepareValue( pszValueName, &dwType, &cbData, &pabData ) )
            break ;
   
        if (( dwType != REG_SZ ) && (dwType != REG_EXPAND_SZ))
        {
            dwErr = ERROR_INVALID_PARAMETER ;
            break ;
        }

        //  Guarantee that the data looks like a string
        pabData[cbData] = 0 ;

        //  Catch exceptions trying to assign to the caller's string
        TRY
        {
            strResult = (LPCTSTR) pabData ;
        }
        CATCH_ALL(e)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    } 
    while ( FALSE ) ;

	delete [] pabData ;

    return dwErr ; 
}


DWORD RegKey::QueryValue ( LPCTSTR pchValueName, CStringList & strList ) 
{
    DWORD dwErr = 0 ;
    
    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;
    LPTSTR pbTemp, pbTempLimit;

    do
    {
        if ( dwErr = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
            break ;
   
        if ( dwType != REG_MULTI_SZ ) 
        {
            dwErr = ERROR_INVALID_PARAMETER ;
            break ;
        }

        //  Guarantee that the trailing data looks like a string
        pabData[cbData] = 0 ;
        pbTemp = (LPTSTR) pabData ;
        pbTempLimit = & pbTemp[MaxCchFromCb(cbData)-1] ;

        dwErr = MULTI_SZ2StrList(pbTemp, strList);

    } 
    while ( FALSE ) ;

    delete [] pabData ;

    return dwErr ; 
}

/*!--------------------------------------------------------------------------
	RegKey::QueryValue
		Gets the DWORD value for this key. Returns ERROR_INVALID_PARAMETER
		if the value is not a REG_DWORD.
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD RegKey::QueryValue( LPCTSTR pszValueName, DWORD& dwResult ) 
{
	DWORD	dwErr;
    DWORD	cbData = sizeof(DWORD);
	DWORD	dwType = REG_DWORD;

	dwErr = ::RegQueryValueEx( m_hKey, 
							   pszValueName, 
							   0, &dwType, 
							   (LPBYTE) &dwResult, &cbData ) ;

	if ((dwErr == ERROR_SUCCESS) && (dwType != REG_DWORD))
		dwErr = ERROR_INVALID_PARAMETER;
		
    if ( dwErr )
		dwResult = 0;

    return dwErr;
}

DWORD RegKey::QueryValue ( LPCTSTR pchValueName, LPTSTR pszDestBuffer, DWORD cchSize, BOOL fExpandSz)
{
	DWORD	dwErr;
    DWORD	cbData = MinCbNeededForCch(cchSize);
	DWORD	dwType = REG_SZ;
	TCHAR *	pszBuffer = (TCHAR *) _alloca(MinCbNeededForCch(cchSize));

	dwErr = ::RegQueryValueEx( m_hKey, 
							   pchValueName, 
							   0, &dwType,
							   (LPBYTE) pszBuffer, &cbData ) ;

	if ((dwErr == ERROR_SUCCESS) &&
		(dwType != REG_SZ) &&
		(dwType != REG_EXPAND_SZ) &&
	    (dwType != REG_MULTI_SZ))
		dwErr = ERROR_INVALID_PARAMETER;

	
	if (dwErr == ERROR_SUCCESS)
	{
		if ((dwType == REG_EXPAND_SZ) && fExpandSz)
			ExpandEnvironmentStrings(pszBuffer, pszDestBuffer, cchSize);
		else
			::CopyMemory(pszDestBuffer, pszBuffer, cbData);
	}

    return dwErr;
}


DWORD RegKey::QueryValue ( LPCTSTR pszValueName, CByteArray & abResult )
{
    DWORD dwErr = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        if ( dwErr = PrepareValue( pszValueName, & dwType, & cbData, & pabData ) )
            break ;
   
        if ( dwType != REG_BINARY ) 
        {
            dwErr = ERROR_INVALID_PARAMETER ;
            break ;
        }

        //  Catch exceptions trying to grow the result array
        TRY
        {
            abResult.SetSize( cbData ) ;
        }
        CATCH_ALL(e)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL

        if ( dwErr ) 
            break ;

        //  Move the data to the result array.
        for ( DWORD i = 0 ; i < cbData ; i++ ) 
        {
            abResult[i] = pabData[i] ;
        }
    } 
    while ( FALSE ) ;

    // Memory leak....
    //if ( dwErr )
    //{
        delete [] pabData ;
    //}
    
    return dwErr ; 
}

DWORD RegKey::QueryValue ( LPCTSTR pszValueName, void * pvResult, DWORD cbSize )
{
	DWORD	dwErr;
	DWORD	dwType = REG_BINARY;

	dwErr = ::RegQueryValueEx( m_hKey, 
							   pszValueName, 
							   0, &dwType, 
							   (LPBYTE) pvResult, &cbSize ) ;

	if ((dwErr == ERROR_SUCCESS) && (dwType != REG_BINARY))
		dwErr = ERROR_INVALID_PARAMETER;
		
    return dwErr;
}

DWORD RegKey::SetValueExplicit(LPCTSTR pszValueName,
							   DWORD dwType,
							   DWORD dwSize,
							   LPBYTE pbData)
{
    return ::RegSetValueEx( *this, 
                    pszValueName,
                    0,
                    dwType,
					pbData,
					dwSize);
}

//  Overloaded value setting members.
DWORD RegKey::SetValue ( LPCTSTR pszValueName, LPCTSTR pszValue,
						 BOOL fRegExpand)
{
    DWORD dwErr = 0;
    DWORD dwType = fRegExpand ? REG_EXPAND_SZ : REG_SZ;

    dwErr = ::RegSetValueEx( *this, 
                    pszValueName,
                    0,
                    dwType,
                    (const BYTE *) pszValue,
					// This is not the correct string length
					// for DBCS strings
					pszValue ? CbStrLen(pszValue) : 0);

    return dwErr ;
}

DWORD RegKey::SetValue ( LPCTSTR pszValueName, CStringList & strList ) 
{

    DWORD dwErr = 0;
    
    DWORD cbSize ;
    BYTE * pbData = NULL ;

    dwErr = FlattenValue( strList, & cbSize, & pbData ) ;

    if ( dwErr == 0 ) 
    {
        dwErr = ::RegSetValueEx( *this, 
                       pszValueName,
                       0,
                       REG_MULTI_SZ,
                       pbData, 
                       cbSize ) ;
    }

    delete pbData ;

    return dwErr ;
}

DWORD RegKey::SetValue ( LPCTSTR pszValueName, DWORD & dwResult )
{
    DWORD dwErr = 0;

    dwErr = ::RegSetValueEx( *this, 
                    pszValueName,
                    0,
                    REG_DWORD,
                    (const BYTE *) & dwResult,
                    sizeof dwResult ) ;

    return dwErr ;
}

DWORD RegKey::SetValue ( LPCTSTR pszValueName, CByteArray & abResult )
{

    DWORD dwErr = 0;

    DWORD cbSize ;
    BYTE * pbData = NULL ;

    dwErr = FlattenValue( abResult, & cbSize, & pbData ) ;

    if ( dwErr == 0 ) 
    {
        dwErr = ::RegSetValueEx( *this, 
                       pszValueName,
                       0,
                       REG_BINARY,
                       pbData, 
                       cbSize ) ;
    }

    delete pbData ;

    return dwErr ;
}

DWORD RegKey::SetValue ( LPCTSTR pszValueName, void * pvResult, DWORD cbSize )
{

    DWORD dwErr = 0;

    dwErr = ::RegSetValueEx( *this, 
                       pszValueName,
                       0,
                       REG_BINARY,
                       (const BYTE *)pvResult, 
                       cbSize ) ;

    return dwErr ;
}

DWORD RegKey::FlattenValue ( 
							 CStringList & strList, 
							 DWORD * pcbSize, 
							 BYTE ** ppbData )
{
	return StrList2MULTI_SZ(strList, pcbSize, ppbData);
}

DWORD RegKey::FlattenValue ( 
							 CByteArray & abData,
							 DWORD * pcbSize,
							 BYTE ** ppbData )
{
    DWORD dwErr = 0 ;
    
    DWORD i ;

    //  Allocate and fill a temporary buffer
    if (*pcbSize = (DWORD)abData.GetSize())
    {
        TRY
        {
            *ppbData = new BYTE[*pcbSize] ;

            for ( i = 0 ; i < *pcbSize ; i++ ) 
            {
                (*ppbData)[i] = abData[i] ;
            }

        }
        CATCH_ALL(e)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
    else
    {
        *ppbData = NULL;
    }

    return dwErr ;
}


DWORD RegKey::QueryKeyInfo ( CREGKEY_KEY_INFO * pRegKeyInfo ) 
{
    DWORD dwErr = 0 ;

    pRegKeyInfo->dwClassNameSize = sizeof pRegKeyInfo->chBuff - 1 ;

    dwErr = ::RegQueryInfoKey( *this,
                     pRegKeyInfo->chBuff,
                     & pRegKeyInfo->dwClassNameSize,
                     NULL,
                     & pRegKeyInfo->dwNumSubKeys,
                     & pRegKeyInfo->dwMaxSubKey,
                     & pRegKeyInfo->dwMaxClass,
                     & pRegKeyInfo->dwMaxValues,
                     & pRegKeyInfo->dwMaxValueName,
                     & pRegKeyInfo->dwMaxValueData,
                     & pRegKeyInfo->dwSecDesc,
                     & pRegKeyInfo->ftKey ) ;

    return dwErr ;
}


RegValueIterator::RegValueIterator()
    : m_pRegKey( NULL ),
    m_pszBuffer( NULL ),
    m_cbBuffer( 0 ) 
{
}

HRESULT RegValueIterator::Init(RegKey *pRegKey)
{
    DWORD dwErr = 0 ;
    RegKey::CREGKEY_KEY_INFO regKeyInfo ;

    Reset() ;

    m_pRegKey= pRegKey;

    dwErr = pRegKey->QueryKeyInfo( & regKeyInfo ) ;

    if ( dwErr == 0 ) 
    {
		m_cbBuffer = regKeyInfo.dwMaxValueName + sizeof (DWORD) ;
		delete [] m_pszBuffer;
		m_pszBuffer = new TCHAR [ m_cbBuffer ] ;
		Assert(m_pszBuffer);
    }
	return HRESULT_FROM_WIN32(dwErr);
}

RegValueIterator::~RegValueIterator() 
{
    delete [] m_pszBuffer ;
}

HRESULT RegValueIterator::Next( CString * pstrName, DWORD * pdwType )
{
    DWORD dwErr = 0 ;
    
    DWORD dwNameLength = m_cbBuffer ;

    dwErr = ::RegEnumValue( *m_pRegKey,
                  m_dwIndex,
                  m_pszBuffer,
                  & dwNameLength,
                  NULL,
                  pdwType,
                  NULL,
                  NULL ) ;
    
    if ( dwErr == 0 ) 
    {
        m_dwIndex++ ;

		*pstrName = m_pszBuffer ;
    }
    
    return HRESULT_FROM_WIN32(dwErr) ;
}


RegKeyIterator::RegKeyIterator()
    : m_pregkey(NULL),
    m_pszBuffer(NULL),
    m_cbBuffer( 0 ) 
{
}

HRESULT RegKeyIterator::Init(RegKey *pregkey)
{
    DWORD dwErr = 0 ;
    RegKey::CREGKEY_KEY_INFO regKeyInfo ;

    Reset() ;

	m_pregkey= pregkey;

    dwErr = pregkey->QueryKeyInfo( & regKeyInfo ) ;

    if ( dwErr == 0 ) 
    {
		m_cbBuffer = regKeyInfo.dwMaxSubKey + sizeof(DWORD);
		delete [] m_pszBuffer;
		m_pszBuffer = new TCHAR[m_cbBuffer];
    }

	return HRESULT_FROM_WIN32(dwErr);
}

RegKeyIterator::~RegKeyIterator () 
{
    delete [] m_pszBuffer ;
}

HRESULT RegKeyIterator::Reset()
{
	m_dwIndex = 0;
	return hrOK;
}


/*!--------------------------------------------------------------------------
	RegKeyIterator::Next
		Returns the name (and optional last write time) of the next key.
		Return S_FALSE if there are no other items to be returned.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RegKeyIterator::Next ( CString * pstrName, CTime * pTime ) 
{
    DWORD dwErr = 0;

    FILETIME ftDummy ;
    DWORD dwNameSize = m_cbBuffer;

    dwErr = ::RegEnumKeyEx( *m_pregkey, 
							m_dwIndex, 
							m_pszBuffer,
							& dwNameSize, 
							NULL,
							NULL,
							NULL,
							& ftDummy ) ;    
    if ( dwErr == 0 ) 
    {
        m_dwIndex++ ;

        if ( pTime ) 
        {
			*pTime = ftDummy ;
        }

		if (pstrName)
		{
            *pstrName = m_pszBuffer ;
        }
    }
    
    return (dwErr == ERROR_NO_MORE_ITEMS) ? S_FALSE : HRESULT_FROM_WIN32(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\tregkey.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    regkey.h

    FILE HISTORY:
        
*/

#ifndef _TREGKEY_H
#define _TREGKEY_H

#if _MSC_VER >= 1000	// VC 5.0 or later
#pragma once
#endif

//
//  Maximum size of a Registry class name
//
#define CREGKEY_MAX_CLASS_NAME MAX_PATH


#ifndef TFS_EXPORT_CLASS
#define TFS_EXPORT_CLASS
#endif

//  Convert a CStringList to the REG_MULTI_SZ format
DWORD StrList2MULTI_SZ(CStringList & strList, DWORD * pcbSize, BYTE ** ppbData);

//  Convert a REG_MULTI_SZ format to the CStringList 
DWORD MULTI_SZ2StrList(LPCTSTR pbMulti_Sz, CStringList & strList);

//
//  Wrapper for a Registry key handle.
//
class TFS_EXPORT_CLASS RegKey
{

public:
    //
    //  Key information return structure
    //
    typedef struct
    {
        TCHAR chBuff [CREGKEY_MAX_CLASS_NAME] ;
        DWORD dwClassNameSize,	// size of the class string
              dwNumSubKeys,		// number of subkeys
              dwMaxSubKey,		// longest subkey name length
              dwMaxClass,		// longest class string length
              dwMaxValues,		// number of value entries
              dwMaxValueName,	// longest value name length
              dwMaxValueData,	// longest value data length
              dwSecDesc ;		// security descriptor length
        FILETIME ftKey ;
    } CREGKEY_KEY_INFO ;

	//	Standard constructor
	//		To get at keys, you will have to open/create the key
	RegKey();
    ~RegKey ();

	DWORD Create(HKEY hKeyParent,
				 LPCTSTR lpszKeyName,
				 DWORD dwOptions = REG_OPTION_NON_VOLATILE,
				 REGSAM samDesired = KEY_ALL_ACCESS,
				 LPSECURITY_ATTRIBUTES lpSecAttr = NULL,
				 LPCTSTR pszServerName = NULL);
	
	DWORD Open(HKEY hKeyParent,
			   LPCTSTR pszSubKey,
			   REGSAM samDesired = KEY_ALL_ACCESS,
			   LPCTSTR pszServerName = NULL);
	DWORD Close();
	HKEY Detach();
	void Attach(HKEY hKey);
	DWORD DeleteSubKey(LPCTSTR lpszSubKey);
	DWORD RecurseDeleteKey(LPCTSTR lpszKey);
	DWORD DeleteValue(LPCTSTR lpszValue);

    // Deletes the subkeys of the current key (does NOT delete the
    // current key).
    DWORD RecurseDeleteSubKeys();
    //
    //  Allow a RegKey to be used anywhere an HKEY is required.
    //
    operator HKEY () const
    {
        return m_hKey ;
    }

    //
    //  Fill a key information structure
    //
    DWORD QueryKeyInfo ( CREGKEY_KEY_INFO * pRegKeyInfo ) ;

	DWORD QueryTypeAndSize(LPCTSTR pszValueName, DWORD *pdwType, DWORD *pdwSize);

    //
    //  Overloaded value query members; each returns ERROR_INVALID_PARAMETER
    //  if data exists but not in correct form to deliver into result object.
    //
    DWORD QueryValue ( LPCTSTR pchValueName, CString & strResult ) ;
    DWORD QueryValue ( LPCTSTR pchValueName, CStringList & strList ) ;
    DWORD QueryValue ( LPCTSTR pchValueName, DWORD & dwResult ) ;
    DWORD QueryValue ( LPCTSTR pchValueName, CByteArray & abResult ) ;
    DWORD QueryValue ( LPCTSTR pchValueName, void * pvResult, DWORD cbSize );
	DWORD QueryValue ( LPCTSTR pchValueName, LPTSTR pszDestBuffer, DWORD cbSize, BOOL fExpandSz);

	DWORD QueryValueExplicit(LPCTSTR pchValueName,
							 DWORD *pdwType,
							 DWORD *pdwSize,
							 LPBYTE *ppbData);

    //  Overloaded value setting members.
    DWORD SetValue ( LPCTSTR pchValueName, LPCTSTR pszValue,
					 BOOL fRegExpand = FALSE) ;
    DWORD SetValue ( LPCTSTR pchValueName, CStringList & strList ) ;
    DWORD SetValue ( LPCTSTR pchValueName, DWORD & dwResult ) ;
    DWORD SetValue ( LPCTSTR pchValueName, CByteArray & abResult ) ;
    DWORD SetValue ( LPCTSTR pchValueName, void * pvResult, DWORD cbSize );

	DWORD SetValueExplicit(LPCTSTR pchValueName,
						   DWORD dwType,
						   DWORD dwSize,
						   LPBYTE pbData);
	
protected:
    HKEY m_hKey;

    //  Prepare to read a value by finding the value's size.
	DWORD PrepareValue (
        LPCTSTR pchValueName,
        DWORD * pdwType,
        DWORD * pcbSize,
        BYTE ** ppbData
        );

    //  Convert a CStringList to the REG_MULTI_SZ format
    static DWORD FlattenValue (
        CStringList & strList,
        DWORD * pcbSize,
        BYTE ** ppbData
        );

    //  Convert a CByteArray to a REG_BINARY block
    static DWORD FlattenValue (
        CByteArray & abData,
        DWORD * pcbSize,
        BYTE ** ppbData
        );
};

//
//  Iterate the values of a key, return the name and type
//  of each.
//
class TFS_EXPORT_CLASS RegValueIterator
{
protected:
	RegKey *	m_pRegKey;
    DWORD m_dwIndex ;
    TCHAR * m_pszBuffer ;
    DWORD m_cbBuffer ;

public:
    RegValueIterator();
    ~ RegValueIterator () ;

	HRESULT	Init(RegKey *pRegKey);

    //
    // Get the name (and optional last write time) of the next key.
    //
    HRESULT Next ( CString * pstName, DWORD * pdwType ) ;

    //
    // Reset the iterator
    //
    void Reset ()
    {
        m_dwIndex = 0 ;
    }
};

//
//  Iterate the sub-key names of a key.
//

class TFS_EXPORT_CLASS RegKeyIterator
{
public:
	RegKeyIterator();
	~RegKeyIterator();
	
	HRESULT	Init(RegKey *pRegKey);

	HRESULT	Next(CString *pstName, CTime *pTime = NULL);
	HRESULT	Reset();

protected:
	RegKey *	m_pregkey;
	DWORD		m_dwIndex;
	TCHAR *		m_pszBuffer;
	DWORD		m_cbBuffer;
};


#endif _TREGKEY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\util.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    ccompont.cpp
	base classes for IComponent and IComponentData

    FILE HISTORY:
	
*/

#include "stdafx.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

TFSCORE_API(HRESULT)
InitWatermarkInfo
(
    HINSTANCE       hInstance,
    LPWATERMARKINFO pWatermarkInfo, 
    UINT uIDHeader, 
    UINT uIDWatermark, 
    HPALETTE hPalette, 
    BOOL bStretch
)
{
    pWatermarkInfo->hHeader = ::LoadBitmap(hInstance, MAKEINTRESOURCE(uIDHeader));
	if (pWatermarkInfo->hHeader == NULL)
		return E_FAIL;

    pWatermarkInfo->hWatermark = ::LoadBitmap(hInstance, MAKEINTRESOURCE(uIDWatermark));
	if (pWatermarkInfo->hWatermark == NULL)
		return E_FAIL;

    pWatermarkInfo->hPalette = hPalette;
    pWatermarkInfo->bStretch = bStretch;

    return S_OK;
}

TFSCORE_API(HRESULT)
ResetWatermarkInfo(LPWATERMARKINFO   pWatermarkInfo)
{
	if(pWatermarkInfo->hHeader)
	{
		DeleteObject(pWatermarkInfo->hHeader);
		pWatermarkInfo->hHeader = NULL;
	}
	if(pWatermarkInfo->hWatermark)
	{
		DeleteObject(pWatermarkInfo->hWatermark);
		pWatermarkInfo->hWatermark = NULL;
	}

	return S_OK;
}

/*!--------------------------------------------------------------------------
	InterfaceUtilities::SetI
		Encapsulates the common Release/Assign/AddRef sequence.
	Handles null ptrs.
	Author: GaryBu
 ---------------------------------------------------------------------------*/
TFSCORE_API(void) SetI(IUnknown * volatile *ppunkL, IUnknown *punkR)
{
	if (*ppunkL)
	{
		IUnknown *punkRel = *ppunkL;
		*ppunkL = 0;
		punkRel->Release();
	}
	*ppunkL = punkR;
	if (punkR)
		punkR->AddRef();
}

/*!--------------------------------------------------------------------------
	InterfaceUtilities::ReleaseI
		Release interface, handles null interface pointer.
	Use Set(&pFoo, 0) if you want to set interface pointer to zero.
	Author: GaryBu
 ---------------------------------------------------------------------------*/
TFSCORE_API(void) ReleaseI(IUnknown *punk)
{
#if 0
	__try
#endif
		{
		if (punk)
			{
			if (IsBadReadPtr(punk,sizeof(void *)))
				{
				AssertSz(FALSE,"Bad Punk");
				return;
				}
			if (IsBadReadPtr(*((LPVOID FAR *) punk),sizeof(void *) * 3))
				{
				AssertSz(FALSE, "Bad Vtable");
				return;
				}
//			if (IsBadCodePtr((FARPROC) punk->Release))
//				{
//				AssertSz(fFalse, "Bad Release Address");
//				return;
//				}
			punk->Release();
			}
		}
#if 0
	__except(1)
		{
		Trace0("Exception ignored in ReleaseI()\n");
		}
#endif
}


TFSCORE_API(HRESULT) HrQueryInterface(IUnknown *punk, REFIID iid, LPVOID *ppv)
{
	HRESULT	hr;
	
#ifdef DEBUG
	if (IsBadReadPtr(punk,sizeof(void *)))
 		{
		AssertSz(FALSE,"CRASHING BUG!  Bad Punk in QueryInterface");
		return ResultFromScode(E_NOINTERFACE);
		}
		
	if (IsBadReadPtr(*((LPVOID FAR *) punk),sizeof(void *) * 3))
		{
		AssertSz(FALSE, "CRASHING BUG!  Bad Vtable in QueryInterface");
		return ResultFromScode(E_NOINTERFACE);
		}
#endif

	IfDebug(*ppv = (void*)0xCCCCCCCC;)
	hr = punk->QueryInterface(iid, ppv);
	if (FHrFailed(hr))
		{
		*ppv = 0;
		}
	return hr;
}


TFSCORE_API(HRESULT) LoadAndAddMenuItem
(
	IContextMenuCallback*	pIContextMenuCallback,
	LPCTSTR					pszMenuString, // has text & status text separated by '\n'
	LONG					lCommandID,
	LONG					lInsertionPointID,
	LONG					fFlags,
	LPCTSTR					pszLangIndStr
)
{
	Assert( pIContextMenuCallback != NULL );

	// load the resource
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CString	strText(pszMenuString);
	CString strStatusText;

	if (!(fFlags & MF_SEPARATOR))
	{
		Assert( !strText.IsEmpty() );
		
		// split the resource into the menu text and status text
		int iSeparator = strText.Find(_T('\n'));
		if (0 > iSeparator)
		{
			Panic0("Could not find separator between menu text and status text");
			strStatusText = strText;
		}
		else
		{
			strStatusText = strText.Right( strText.GetLength()-(iSeparator+1) );
			strText = strText.Left( iSeparator );
		}
	}
		
	// add the menu item
	USES_CONVERSION;
	HRESULT		hr = S_OK;
	BOOL		bAdded = FALSE;

	// if language independent string is specified, then try to use IContextMenuCallback2
	if(pszLangIndStr)
	{
		CONTEXTMENUITEM2 contextmenuitem;
		IContextMenuCallback2*	pIContextMenuCallback2 = NULL;

		hr = pIContextMenuCallback->QueryInterface(IID_IContextMenuCallback2, (void**)&pIContextMenuCallback2);

		if(hr == S_OK && pIContextMenuCallback2 != NULL)
		{
			::ZeroMemory( &contextmenuitem, sizeof(contextmenuitem) );
			contextmenuitem.strName = T2OLE(const_cast<LPTSTR>((LPCWSTR)strText));
			contextmenuitem.strStatusBarText = T2OLE(const_cast<LPTSTR>((LPCWSTR)strStatusText));
			contextmenuitem.lCommandID = lCommandID;
			contextmenuitem.lInsertionPointID = lInsertionPointID;
			contextmenuitem.fFlags = fFlags;
			contextmenuitem.fSpecialFlags = ((fFlags & MF_POPUP) ? CCM_SPECIAL_SUBMENU : 0L);
			contextmenuitem.fSpecialFlags |= ((fFlags & MF_SEPARATOR) ? CCM_SPECIAL_SEPARATOR : 0L);
			contextmenuitem.strLanguageIndependentName = T2OLE(const_cast<LPTSTR>((LPCWSTR)pszLangIndStr));
			hr = pIContextMenuCallback2->AddItem( &contextmenuitem );
			if( hr == S_OK)
				bAdded = TRUE;

			pIContextMenuCallback2->Release();
			pIContextMenuCallback2 = NULL;
		}
	}

	// if not added above for any reason, we try to use the IContextMenuCallback
	if (!bAdded)
	{
		CONTEXTMENUITEM contextmenuitem;
		::ZeroMemory( &contextmenuitem, sizeof(contextmenuitem) );
		contextmenuitem.strName = T2OLE(const_cast<LPTSTR>((LPCWSTR)strText));
		contextmenuitem.strStatusBarText = T2OLE(const_cast<LPTSTR>((LPCWSTR)strStatusText));
		contextmenuitem.lCommandID = lCommandID;
		contextmenuitem.lInsertionPointID = lInsertionPointID;
		contextmenuitem.fFlags = fFlags;
		contextmenuitem.fSpecialFlags = ((fFlags & MF_POPUP) ? CCM_SPECIAL_SUBMENU : 0L);
		contextmenuitem.fSpecialFlags |= ((fFlags & MF_SEPARATOR) ? CCM_SPECIAL_SEPARATOR : 0L);
		hr = pIContextMenuCallback->AddItem( &contextmenuitem );
	}
	
    Assert(hr == S_OK);

	return hr;
}



/*---------------------------------------------------------------------------
	CHiddenWnd implementation
 ---------------------------------------------------------------------------*/
DEBUG_DECLARE_INSTANCE_COUNTER(CHiddenWnd);

BEGIN_MESSAGE_MAP( CHiddenWnd, CWnd )
	ON_MESSAGE(WM_HIDDENWND_REGISTER, OnNotifyRegister)
END_MESSAGE_MAP( )

/*!--------------------------------------------------------------------------
	CHiddenWnd::Create
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL CHiddenWnd::Create()
{
	CString s_szHiddenWndClass = AfxRegisterWndClass(
			0x0,  //UINT nClassStyle, 
			NULL, //HCURSOR hCursor,        
			NULL, //HBRUSH hbrBackground, 
			NULL  //HICON hIcon
	);

	// Initialize our bit mask to 0
	::ZeroMemory(&m_bitMask, sizeof(m_bitMask));

	// Reserve position 0.  This means that
	// we can use from WM_USER to WM_USER+15 for our own purposes.
	SetBitMask(m_bitMask, 0);

	m_iLastObjectIdSet = 1;
	
	return CreateEx(
					0x0,    //DWORD dwExStyle, 
					s_szHiddenWndClass,     //LPCTSTR lpszClassName, 
					NULL,   //LPCTSTR lpszWindowName, 
					0x0,    //DWORD dwStyle, 
					0,              //int x, 
					0,              //int y, 
					0,              //int nWidth, 
					0,              //int nHeight, 
					NULL,   //HWND hwndParent, 
					NULL,   //HMENU nIDorHMenu, 
					NULL    //LPVOID lpParam = NULL
					);
}

/*!--------------------------------------------------------------------------
	CHiddenWnd::WindowProc
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
LRESULT CHiddenWnd::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	LRESULT	lReturn = 0;
	
	if ((message >= (WM_USER+16)) && (message < (WM_USER+(HIDDENWND_MAXTHREADS*16))))
	{
		// Ok, this is one of our special messages
		UINT	uObjectId = WM_TO_OBJECTID(message);
		UINT	uMsgId = WM_TO_MSGID(message);

		// look up the object id in our list of registered users
		if (FIsIdRegistered(uObjectId))
		{
			// forward the message down to the right window

			if (uMsgId == WM_HIDDENWND_INDEX_HAVEDATA)
				lReturn = OnNotifyHaveData(wParam, lParam);
			
			else if (uMsgId == WM_HIDDENWND_INDEX_ERROR)
				lReturn = OnNotifyError(wParam, lParam);
			
			else if (uMsgId == WM_HIDDENWND_INDEX_EXITING)
				lReturn = OnNotifyExiting(wParam, lParam);
			
#ifdef DEBUG
			else
			{
				Panic1("Unknown message %d", uMsgId);
			}
#endif
		}
		else if (uObjectId != 0)
		{
			// If we get a message that is not registered, go into
			// our message queue and remove any other messages that
			// have the same id.  This will reduce accidents that
			// occur because different threads were assigned the
			// same id.
			MSG	msg;
			
			Assert(GetSafeHwnd());
			while(::PeekMessage(&msg,
						  GetSafeHwnd(),
						  OBJECTID_TO_WM(uObjectId),
						  OBJECTID_TO_WM(uObjectId)+WM_HIDDENWND_INDEX_MAX,
						  PM_REMOVE))
				;
			
//  		Trace1("Ignoring message: 0x%08x, removing other msgs\n", message);
		}
	
		// If the object is not registered, eat up the message
		return lReturn;
	}
	return CWnd::WindowProc(message, wParam, lParam);
}

/*!--------------------------------------------------------------------------
	CHiddenWnd::FIsIdRegistered
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL CHiddenWnd::FIsIdRegistered(UINT uObjectId)
{
	Assert(uObjectId > 0);
	Assert(uObjectId < HIDDENWND_MAXTHREADS);

	// 0 is not allowed as an object id
	return (uObjectId != 0) && !!(IsBitMaskSet(m_bitMask, uObjectId));
}

/*!--------------------------------------------------------------------------
	CHiddenWnd::OnNotifyRegister
		If we fail to find an empty slot, return 0.
	Author: KennT
 ---------------------------------------------------------------------------*/
LONG CHiddenWnd::OnNotifyRegister(WPARAM wParam, LPARAM lParam)
{
	LONG	lReturn = 0;
	
	// Look for a valid hole in our mask

	// The point of using the m_iLastObjectIdSet is to avoid the
	// problem of reusing ids.  This doesn't totally eliminate the
	// problem but it should reduce the likelihood to practically 0.
	// That is, unless someone actually runs a snapin that utilizes
	// 512 threads!
	
	if (wParam)
	{
		if (((m_iLastObjectIdSet+1) < HIDDENWND_MAXTHREADS) &&
		   !IsBitMaskSet(m_bitMask, m_iLastObjectIdSet))
		{
			SetBitMask(m_bitMask, m_iLastObjectIdSet);
			lReturn = OBJECTID_TO_WM(m_iLastObjectIdSet);
			m_iLastObjectIdSet++;
		}
		else
		{
			// do this the painful way
			Assert(IsBitMaskSet(m_bitMask, 0));
			for (int iLoop=0; iLoop<2; iLoop++)
			{
				for (int i=m_iLastObjectIdSet; i<HIDDENWND_MAXTHREADS; i++)
				{
					if (!IsBitMaskSet(m_bitMask, i))
					{
						m_iLastObjectIdSet = i;
						SetBitMask(m_bitMask, m_iLastObjectIdSet);
						lReturn = OBJECTID_TO_WM(i);
						break;
					}
				}

				if (lReturn || (m_iLastObjectIdSet == 1))
					break;
				
				// restart the loop from the beginning
				m_iLastObjectIdSet = 1;
			}
		}
		
	}
	else
	{
		LONG_PTR	uObjectId = WM_TO_OBJECTID(lParam);

		Assert(uObjectId > 0);
		Assert(IsBitMaskSet(m_bitMask, uObjectId));
		
		ClearBitMask(m_bitMask, uObjectId);
	}
	return lReturn;
}

/*!--------------------------------------------------------------------------
	CHiddenWnd::OnNotifyHaveData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
afx_msg LONG CHiddenWnd::OnNotifyHaveData(WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {
        //Trace0("CHiddenWnd::OnNotifyHaveData()\n");

	    ITFSThreadHandler *phandler = reinterpret_cast<ITFSThreadHandler*>(wParam);	
	    Assert(phandler);

	    // If there is an error, we can't do anything
	    phandler->OnNotifyHaveData(lParam);
    }
    COM_PROTECT_CATCH

	return 0;
}

/*!--------------------------------------------------------------------------
	CHiddenWnd::OnNotifyError
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
afx_msg LONG CHiddenWnd::OnNotifyError(WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {
//      Trace0("CHiddenWnd::OnNotifyError()\n");

	    ITFSThreadHandler *phandler = reinterpret_cast<ITFSThreadHandler*>(wParam);	
	    Assert(phandler);
	    
	    // If there is an error, we can't do anything
	    phandler->OnNotifyError(lParam);
    }
    COM_PROTECT_CATCH

	return 0;
}

/*!--------------------------------------------------------------------------
	CHiddenWnd::OnNotifyExiting
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
afx_msg LONG CHiddenWnd::OnNotifyExiting(WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {
//      Trace0("CHiddenWnd::OnNotifyExiting()\n");

	    ITFSThreadHandler *phandler = reinterpret_cast<ITFSThreadHandler*>(wParam);	
	    Assert(phandler);
	    
	    // If there is an error, we can't do anything
	    phandler->OnNotifyExiting(lParam);	
    }
    COM_PROTECT_CATCH

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\tfscore\util.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:	util.h
//
// History:
//
//	04/13/97	Kenn Takara				Created.
//
//	Declarations for some common code/macros.
//============================================================================


#ifndef _UTIL_H
#define _UTIL_H

#if _MSC_VER >= 1000	// VC 5.0 or later
#pragma once
#endif

#ifndef _TFSINT_H
#include "tfsint.h"
#endif


///////////////////////////////////////////////////////////////////////////////
// CWatermarkInfo

typedef struct _WATERMARKINFO
{
    HBITMAP		hHeader;
	HBITMAP		hWatermark;
	HPALETTE	hPalette;
	BOOL		bStretch;
} WATERMARKINFO, * LPWATERMARKINFO;

TFSCORE_API(HRESULT)
InitWatermarkInfo(HINSTANCE         hInstance,
                  LPWATERMARKINFO   pWatermarkInfo, 
                  UINT              uIDHeader, 
                  UINT              uIDWatermark, 
                  HPALETTE          hPalette, 
                  BOOL              bStretch);

TFSCORE_API(HRESULT)
ResetWatermarkInfo(LPWATERMARKINFO   pWatermarkInfo); 

////////////////////////////////////////////////////////////////////
// CHiddenWnd : Hidden window to syncronize threads and CComponentData object
//	When the handler receives the notification messages, it is running
//	on the main thread (and can thus call MMC interfaces).
//
//	If you need a background thread and don't need to access any of
//	the MMC interfaces, you should create a pure worker thread instead
//	of using this mechanism.  The whole point of this is to synchronize
//	our data calls with MMC (because they're a single-threaded app). *sigh*


// maximum number of threads we will be able to handle
// actually the max number is one less
// This value must be a multiple of 32
#define HIDDENWND_MAXTHREADS			(512)


// These are the predefined messages for this window
//

/*---------------------------------------------------------------------------
	WM_HIDDENWND_REGISTER
	wParam - TRUE if to register, FALSE to unregister
	lParam - if registering this is ignored
			if unregistering, this is the base value (the value that was
			returned by the call).
	RETURNS: the base value to use when posting the notifications
			returns 0 on error
 ---------------------------------------------------------------------------*/
#define WM_HIDDENWND_REGISTER			WM_USER


/*---------------------------------------------------------------------------
	WM_HIDDENWND_INDEX_HAVEDATA
	wParam - this is an ITFSThreadHandler *
	lParam - private data communication between the QueryObject and
			 the parent node.
	RETURNS: N/A, use PostMessage() for this
 ---------------------------------------------------------------------------*/
#define WM_HIDDENWND_INDEX_HAVEDATA		(0)

/*---------------------------------------------------------------------------
	WM_HIDDENWND_INDEX_ERROR
	wParam - this is an ITFSThreadHandler *
	lParam - contains HRESULT			 
	RETURNS: N/A, use PostMessage() for this
 ---------------------------------------------------------------------------*/
#define WM_HIDDENWND_INDEX_ERROR		(1)

/*---------------------------------------------------------------------------
	WM_HIDDENWND_INDEX_EXITING
	wParam - this is an ITFSThreadHandler *
	lParam - not used
	RETURNS: N/A, use PostMessage() for this
 ---------------------------------------------------------------------------*/
#define WM_HIDDENWND_INDEX_EXITING		(2)

#define WM_HIDDENWND_INDEX_LAST			(2)
#define WM_HIDDENWND_INDEX_MAX			(15)

class CHiddenWnd : public CWnd
{
public:
	CHiddenWnd() 
	{
	    DEBUG_INCREMENT_INSTANCE_COUNTER(CHiddenWnd);
	}

	~CHiddenWnd()
	{
		DEBUG_DECREMENT_INSTANCE_COUNTER(CHiddenWnd);
	}
	BOOL Create();


private:
	BOOL FIsIdRegistered(UINT uObjectId);

	DWORD			m_bitMask[(HIDDENWND_MAXTHREADS >> 5)+1];
	int				m_iLastObjectIdSet;
	DWORD			m_dwContext;
	
public:

	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	afx_msg LONG OnNotifyHaveData(WPARAM wParam, LPARAM lParam);
	afx_msg LONG OnNotifyError(WPARAM wParam, LPARAM lParam);
	afx_msg LONG OnNotifyExiting(WPARAM wParam, LPARAM lParam);
	
	//{{AFX_MSG(CHiddenWnd)
	afx_msg LONG OnNotifyRegister(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#define WM_TO_OBJECTID(wm)	((((wm)-WM_USER) >> 4))
#define WM_TO_MSGID(wm)		(((wm)-WM_USER) & 0x0000000F)
#define OBJECTID_TO_WM(ob)	((((ob)) << 4) + WM_USER)

#define SetBitMask(x,n)			(x[n>>5] |= (1 << (n%32)))
#define ClearBitMask(x,n)		(x[n>>5] &= ~(1 << (n%32)))
#define IsBitMaskSet(x,n)		(x[n>>5] & (1 << (n%32)))




#ifdef __cplusplus
extern "C" {
#endif

TFSCORE_API(HRESULT) LoadAndAddMenuItem(
				IContextMenuCallback* pIContextMenuCallback,
				LPCTSTR	pszMenuString,
				LONG	lCommandID,
				LONG	lInsertionPointID,
				LONG	fFlags,
				LPCTSTR pszLangIndStr = NULL);
#ifdef __cplusplus
} // extern "C"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\actreg.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	actreg.h
		WINS active registrations node information. 
		
    FILE HISTORY:
        
*/

#include "loadrecs.h"

#ifndef _ACTREG_H
#define _ACTREG_H

#ifndef _WINSHAND_H
#include "winshand.h"
#endif

#ifndef _WINSDB_H
#include "winsdb.h"
#endif

#ifndef _MULTIP_H
#include "multip.h"
#endif

#ifndef _BUSYDLG_H
#include "..\common\busydlg.h"
#endif

#ifndef _VERIFY_H
#include "verify.h"
#endif

#ifndef _CONFIG_H
#include "config.h"
#endif

typedef struct WinsStrRecord_t
{
	int         nIndex;
    CString		strName;
	CString		strExpiration;
	CString		strActive;
	CString		strStatic;
	CString		strIPAdd;
	CString		strOwner;
	CString		strType;
	CString		strVersion;
} WinsStrRecord;

typedef enum _ACTREG_COL
{
    ACTREG_COL_NAME,
    ACTREG_COL_TYPE,
    ACTREG_COL_IPADDRESS,
    ACTREG_COL_STATE,
    ACTREG_COL_STATIC,
    ACTREG_COL_OWNER,
    ACTREG_COL_VERSION,
    ACTREG_COL_EXPIRATION,
    ACTREG_COL_MAX
};

class CDlgWorkerThread;


typedef CList<WinsStrRecord*,WinsStrRecord*>  RecordListBase;
typedef CArray<WINSERVERS, WINSERVERS> WinsServersArray;


class RecordList : public RecordListBase
{
public:
    ~RecordList()
    {
        RemoveAllEntries();
    }

    WinsStrRecord * FindItem(int nIndex)
    {
        WinsStrRecord * pRec = NULL;
		POSITION pos = GetHeadPosition();
		while (pos)
		{
			WinsStrRecord * pCurRec = GetNext(pos);
			if (pCurRec->nIndex == nIndex)
			{
				pRec = pCurRec;
				break;
			}
		}
    	return pRec;
    }

    void RemoveAllEntries()
    {
        // cleanup the list 
        while (!IsEmpty())
            delete RemoveHead();
    }

    POSITION AddTail(WinsStrRecord * pwsr)
    {
        // Sets a maximum size.  If we hit this we remove the oldest element.
        // this works because we always add to the tail of the list.
        if ( GetCount() > 500 )
        {
            delete RemoveHead();
        }

        return RecordListBase::AddTail(pwsr);
    }

};


class CSortWorker : public CDlgWorkerThread
{
public:
    CSortWorker(IWinsDatabase * pCurrentDatabase, int nColumn, DWORD dwSortOptions);
    ~CSortWorker();
    
    void OnDoAction();

private:
	IWinsDatabase * m_pCurrentDatabase;
	int				m_nColumn;
	DWORD			m_dwSortOptions;
};

/*---------------------------------------------------------------------------
	Class:	CActiveRegistrationsHandler
 ---------------------------------------------------------------------------*/
class CActiveRegistrationsHandler : public CMTWinsHandler

{
// Interface
public:
	CActiveRegistrationsHandler(ITFSComponentData *pCompData);
	~CActiveRegistrationsHandler();

	// base handler functionality we override				
	OVERRIDE_NodeHandler_HasPropertyPages();
	OVERRIDE_NodeHandler_CreatePropertyPages();
    OVERRIDE_NodeHandler_DestroyHandler();
	
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();

	OVERRIDE_NodeHandler_GetString();
    OVERRIDE_BaseHandlerNotify_OnCreateNodeId2();
	OVERRIDE_BaseHandlerNotify_OnExpand();

    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultDelete();
	OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();

    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();
    OVERRIDE_ResultHandler_OnGetResultViewType();
	OVERRIDE_ResultHandler_GetVirtualString(); 
	OVERRIDE_ResultHandler_GetVirtualImage();
	OVERRIDE_ResultHandler_CreatePropertyPages();
	OVERRIDE_ResultHandler_HasPropertyPages();
	
	// base result handler overridees

	STDMETHODIMP CacheHint(int nStartIndex, int nEndIndex);
	STDMETHODIMP SortItems(int     nColumn, 
						   DWORD   dwSortOptions,    
						   LPARAM  lUserParam);

    HRESULT SetVirtualLbSize(ITFSComponent * pComponent, LONG_PTR data);
							
	// needed for background threading with a QueryObject
	virtual void     OnHaveData(ITFSNode * pParentNode, LPARAM Data, LPARAM Type);
	ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);

    // multi select support
    virtual const GUID * GetVirtualGuid(int nIndex) 
	{ 
		return &GUID_WinsActiveRegistrationLeafNodeType; 
	}
	
public:
	// CWinsHandler overrides
	virtual HRESULT InitializeNode(ITFSNode * pNode);
		
	// base result handler overrides
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();
    OVERRIDE_BaseResultHandlerNotify_OnResultPropertyChange();

	virtual int GetImageIndex(BOOL bOpenImage);
	void GetServerName(ITFSNode * pNode, CString &strServerName);

	HRESULT OnImportLMHOSTS(ITFSNode* pNode);
	HRESULT	OnExportEntries();
	BOOL    IsLocalConnection(ITFSNode *pNode);
	HRESULT ImportStaticMappingsFile(ITFSNode *pNode, CString strTmpFile,BOOL fDelete);
	DWORD   RemoteTmp(CString & strDir, CString & strPrefix, CString & strRemoteFile);
	HRESULT EditMapping(ITFSNode *pNode, ITFSComponent *pComponent,  int nIndex);
	HRESULT OnCheckRegNames(ITFSNode* pNode);
	HRESULT OnDeleteOwner(ITFSNode* pNode);
	void    CheckNameConsistency(ITFSNode* pNode, BOOL fVerifyWithPartners);
	HRESULT RefreshResults(ITFSNode *pNode);
	
// helpers
public:
    HRESULT OnCreateMapping(ITFSNode *pNode);
	HRESULT OnDatabaseLoadStart(ITFSNode *pNode);
	HRESULT OnDatabaseLoadStop(ITFSNode *pNode);
	HRESULT AddMapping(ITFSNode* pNode);
    void    GetStateString(DWORD dwState, CString& strType);
	void    FilterCleanup(ITFSNode *pNode);

	void    GetVersionInfo(LONG lLowWord, LONG lHighWord, CString& strVers);
	void    CleanNetBIOSName(LPCSTR       lpszSrc,
                          CString &    strDest,
						  BOOL        fExpandChars,
						  BOOL        fTruncate,
						  BOOL        fLanmanCompatible,
						  BOOL        fOemName,
						  BOOL        fWackwack,
						  int         nLength);
	PWINSINTF_RECORD_ACTION_T  QueryForName(ITFSNode *pNode, PWINSINTF_RECORD_ACTION_T pRecAction, BOOL fStatic = TRUE);
	void	GetStaticTypeString(DWORD dwState, CString& strStaticType);
	DWORD	TombstoneRecords(ITFSComponent *pComponent, WinsRecord* pws);
	DWORD	TombstoneAllRecords(DWORD dwServerIpAddress, ITFSNode * pNode);
	HRESULT UpdateRecord(ITFSComponent *pComponenet, WinsRecord *pws, int nDelIndex);
	BOOL	GetRecordOwner(ITFSNode * pNode, WinsRecord * pWinsRecord);
	void    GetOwnerInfo(CServerInfoArray & serverInfoArray);
	HRESULT BuildOwnerArray(handle_t hBinding);
    void    SetServer(ITFSNode * pServer) { m_spServerNode.Set(pServer); }
    BOOL    IsLanManCompatible();

public:
    CLoadRecords            m_dlgLoadRecords;

    SPIWinsDatabase     m_spWinsDatabase;
    SPITFSNode          m_spServerNode;
    IWinsDatabase *     m_pCurrentDatabase;
	CString				m_strFindName;
    BOOL                m_fMatchCase;
	BOOL				m_fFindNameOrIP; // TRUE for Name

	// for the static mapping dialog
	CString				m_strStaticMappingName;
	CString				m_strStaticMappingScope;
	CStringArray		m_strArrayStaticMappingIPAddress;
	CString				m_strStaticMappingType;
	int					m_nStaticMappingType;
	CDWordArray			m_lArrayIPAddress;

	CMultipleIpNamePair m_Multiples;
	ULONG				m_nSelectedIndex;

	// for the combobox of Find record
	CStringArray		m_strFindNamesArray;

    NameTypeMapping		m_NameTypeMap;

    CServerInfoArray *  m_pServerInfoArray;
	BOOL				m_fLoadedOnce;
    BOOL                m_fFindLoaded;
    BOOL                m_fDbLoaded;
    BOOL                m_fForceReload;

// Implementation
private:
	void GetServerIP(ITFSNode * pNode, DWORD &dwIP,CString &strIP);

    WinsStrRecord * BuildWinsStrRecord(int nIndex);

    void    DatabaseLoadingCleanup();
    HRESULT UpdateListboxCount(ITFSNode * pNode, BOOL bClear = FALSE);
    HRESULT UpdateCurrentView(ITFSNode *  pNode);
	HRESULT UpdateVerbs(ITFSNode * pNode);

	BOOL	CompareRecName(LPSTR szNewName);
	
	DWORD   AddMappingToServer(ITFSNode* pNode,
							   int nType,
							   int nCount,
							   CMultipleIpNamePair& mipnp,
							   BOOL fEdit = FALSE);      // Editing existing mapping?
	void AppendScopeName(char* lpName, char* lpAppend);

	HRESULT AddToLocalStorage(PWINSINTF_RECORD_ACTION_T pRecAction,ITFSNode* pNode);


    HRESULT DeleteRegistration(ITFSComponent * pComponent, int nIndex);
	DWORD   DeleteMappingFromServer(ITFSComponent * pComponent,WinsRecord *pws,int nIndex);
	HRESULT EditMappingToServer(ITFSNode* pNode,
								int nType,
								int nCount,
								CMultipleIpNamePair& mipnp,
								BOOL fEdit,      
								WinsRecord *pRecord);  // Editing existing mapping?
	void    ToString(DWORD dwParam, CString& strParam);
	void	SetLoadedOnce(ITFSNode * pNode);

private:
	CString         m_strActiveReg;
	CString         m_strDesp;
    RecordList      m_RecList;
    WINSDB_STATE    m_winsdbState;

	WSAData			m_WsaData;
	SOCKET			m_sd;
	u_long			m_NonBlocking;
	
	struct sockaddr_in  myad;
	u_short				m_uTranID;
	char				m_pScope[20];

	WinsRecord			m_CurrentRecord;

	CConfiguration		m_Config;
};

#endif _ACTREG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\chkrgdlg.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	chkrgdlg.h
		WINS Check registered names dialog
		
    FILE HISTORY:
        
*/

#if !defined _CHKRGDLG_H
#define _CHKRGDLG_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "dialog.h"
#include <ipaddr.hpp>

/////////////////////////////////////////////////////////////////////////////
// CCheckRegNames dialog

class CCheckRegNames : public CBaseDialog
{
// Construction
public:
	CCheckRegNames(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CCheckRegNames)
	enum { IDD = IDD_CHECK_REG_NAMES };
	CEdit	m_editRecordNameForList;
	CButton	m_buttonAddServer;
	CButton	m_buttonRemoveServer;
	CButton	m_buttonBrowseServer;
	CButton	m_buttonNameremove;
	CButton	m_buttonBrowseName;
	CButton	m_buttonAddName;
	CListBox	m_listServer;
	CListBox	m_listName;
	CEdit	m_editServer;
	CEdit	m_editName;
	int		m_nFileName;
	CString	m_strName;
	CString	m_strServer;
	int		m_nFileServer;
	CString	m_strRecNameForList;
	BOOL	m_fVerifyWithPartners;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCheckRegNames)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CCheckRegNames)
	virtual BOOL OnInitDialog();
	afx_msg void OnNameBrowse();
	afx_msg void OnServerBrowse();
	afx_msg void OnChangeEditName();
	afx_msg void OnChangeEditServer();
	afx_msg void OnSelchangeListName();
	afx_msg void OnSelchangeListServer();
	virtual void OnOK();
	afx_msg void OnNameAdd();
	afx_msg void OnNameRemove();
	afx_msg void OnServerAdd();
	afx_msg void OnServerRemove();
	afx_msg void OnRadioNameFile();
	afx_msg void OnRadioNameList();
	afx_msg void OnRadioServerFile();
	afx_msg void OnRadioServerList();
	afx_msg void OnChangeEditNameList();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	afx_msg void OnChangeIpAddress();

	CWndIpAddress	m_ipaServerIPAddress;

public:
	CWinsNameArray		m_strNameArray;
	CStringArray		m_strServerArray;

private:
	void EnableControls(int nNameOrServer, BOOL bEnable);
	void ParseFile(CString strFile, int nServerOrName);
	void SetControlState(int NameOrServer);
	void Add(int nServerOrName);
	void AddFileContent(CString & strContent, int nNameOrServer);
	BOOL CheckIfPresent(CString & strText, int nNameOrServer) ;
	BOOL CheckIfPresent(CWinsName & winsName, int nNameOrServer);
	BOOL CheckIfAdded(CString & strText, int nNameOrServer);
	BOOL CheckIfAdded(CWinsName winsName, int nNameOrServer);
	BOOL ParseName(CString & strNameIn, CWinsName & winsName, CString & strFormattedName);

public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CCheckRegNames::IDD);};//return NULL;}

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined _CHKRGDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\chkrgdlg.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1999 - 1999 **/
/**********************************************************************/

/*
	chkrgdlg.cpp.cpp
		The check registered names dialog
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include <mbstring.h>
#include "winssnap.h"
#include "actreg.h"
#include "ChkRgdlg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCheckRegNames dialog

#define NAME	0
#define SERVER	1

CCheckRegNames::CCheckRegNames(CWnd* pParent /*=NULL*/)
	: CBaseDialog(CCheckRegNames::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCheckRegNames)
	m_nFileName = 0;
	m_strName = _T("");
	m_strServer = _T("");
	m_nFileServer = 0;
	m_strRecNameForList = _T("");
	m_fVerifyWithPartners = FALSE;
	//}}AFX_DATA_INIT
}


void CCheckRegNames::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCheckRegNames)
	DDX_Control(pDX, IDC_EDIT_NAME_LIST, m_editRecordNameForList);
	DDX_Control(pDX, IDC_SERVER_ADD, m_buttonAddServer);
	DDX_Control(pDX, IDC_SERVER_REMOVE, m_buttonRemoveServer);
	DDX_Control(pDX, IDC_SERVER_BROWSE, m_buttonBrowseServer);
	DDX_Control(pDX, IDC_NAME_REMOVE, m_buttonNameremove);
	DDX_Control(pDX, IDC_NAME_BROWSE, m_buttonBrowseName);
	DDX_Control(pDX, IDC_NAME_ADD, m_buttonAddName);
	DDX_Control(pDX, IDC_LIST_SERVER, m_listServer);
	DDX_Control(pDX, IDC_LIST_NAME, m_listName);
	DDX_Control(pDX, IDC_EDIT_SERVER, m_editServer);
	DDX_Control(pDX, IDC_EDIT_NAME, m_editName);
	DDX_Radio(pDX, IDC_RADIO_NAME_FILE, m_nFileName);
	DDX_Text(pDX, IDC_EDIT_NAME, m_strName);
	DDX_Text(pDX, IDC_EDIT_SERVER, m_strServer);
	DDX_Radio(pDX, IDC_RADIO_SERVER_FILE, m_nFileServer);
	DDX_Text(pDX, IDC_EDIT_NAME_LIST, m_strRecNameForList);
	DDX_Check(pDX, IDC_CHECK_PARTNERS, m_fVerifyWithPartners);
	//}}AFX_DATA_MAP

	DDX_Control(pDX, IDC_IPADDRESS, m_ipaServerIPAddress);
}


BEGIN_MESSAGE_MAP(CCheckRegNames, CBaseDialog)
	//{{AFX_MSG_MAP(CCheckRegNames)
	ON_BN_CLICKED(IDC_NAME_BROWSE, OnNameBrowse)
	ON_BN_CLICKED(IDC_SERVER_BROWSE, OnServerBrowse)
	ON_EN_CHANGE(IDC_EDIT_NAME, OnChangeEditName)
	ON_EN_CHANGE(IDC_EDIT_SERVER, OnChangeEditServer)
	ON_LBN_SELCHANGE(IDC_LIST_NAME, OnSelchangeListName)
	ON_LBN_SELCHANGE(IDC_LIST_SERVER, OnSelchangeListServer)
	ON_BN_CLICKED(IDC_NAME_ADD, OnNameAdd)
	ON_BN_CLICKED(IDC_NAME_REMOVE, OnNameRemove)
	ON_BN_CLICKED(IDC_SERVER_ADD, OnServerAdd)
	ON_BN_CLICKED(IDC_SERVER_REMOVE, OnServerRemove)
	ON_BN_CLICKED(IDC_RADIO_NAME_FILE, OnRadioNameFile)
	ON_BN_CLICKED(IDC_RADIO_NAME_LIST, OnRadioNameList)
	ON_BN_CLICKED(IDC_RADIO_SERVER_FILE, OnRadioServerFile)
	ON_BN_CLICKED(IDC_RADIO_SERVER_LIST, OnRadioServerList)
	ON_EN_CHANGE(IDC_EDIT_NAME_LIST, OnChangeEditNameList)
	//}}AFX_MSG_MAP
	ON_EN_CHANGE(IDC_IPADDRESS,OnChangeIpAddress)
END_MESSAGE_MAP()



/////////////////////////////////////////////////////////////////////////////
// CCheckRegNames message handlers

BOOL CCheckRegNames::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();
	
	EnableControls(NAME, FALSE);
	EnableControls(SERVER, FALSE);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CCheckRegNames::OnNameBrowse() 
{
    CString strFilter;
    strFilter.LoadString(IDS_TEXT_FILES);

    CFileDialog	cFileDlg(TRUE, NULL, NULL, OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, strFilter);
    CThemeContextActivator themeActivator;
	
	if (IDOK != cFileDlg.DoModal())
		return;

	CString strFile = cFileDlg.GetPathName();

	m_editName.EnableWindow(TRUE);
	m_editName.SetWindowText(strFile);
	m_editName.SetReadOnly(TRUE);

	ParseFile(strFile, NAME);

}

void CCheckRegNames::OnServerBrowse() 
{
    CString strFilter;
    strFilter.LoadString(IDS_TEXT_FILES);

    CFileDialog	cFileDlg(TRUE, NULL, NULL, OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, strFilter);
    CThemeContextActivator themeActivator;
	
	if (IDOK != cFileDlg.DoModal())
		return ;

	CString strFile = cFileDlg.GetPathName();

	m_editServer.EnableWindow(TRUE);
	m_editServer.SetWindowText(strFile);
	m_editServer.SetReadOnly(TRUE);


	ParseFile(strFile, SERVER);
}

void 
CCheckRegNames::EnableControls(int nNameOrServer, BOOL bEnable)
{
	switch (nNameOrServer)
	{
	case SERVER:
		m_buttonAddServer.EnableWindow(bEnable);
		m_buttonRemoveServer.EnableWindow(bEnable);
		//m_listServer.EnableWindow(bEnable);
		//m_editServerNameForList.EnableWindow(bEnable);
		m_ipaServerIPAddress.EnableWindow(bEnable);
		m_buttonBrowseServer.EnableWindow(!bEnable);
		m_editServer.EnableWindow(!bEnable);
		m_editServer.SetReadOnly(TRUE);
		break;

	case NAME:
		m_buttonAddName.EnableWindow(bEnable);
		m_buttonNameremove.EnableWindow(bEnable);
		//m_listName.EnableWindow(bEnable);
		m_editRecordNameForList.EnableWindow(bEnable);
		m_buttonBrowseName.EnableWindow(!bEnable);
		m_editName.EnableWindow(!bEnable);
		m_editName.SetReadOnly(TRUE);
		
		break;
	}
	
}

void 
CCheckRegNames::ParseFile(CString strFile, int nServerOrName)
{
	TRY
	{
#define MAX_SIZE 64000

		CFile cFile(strFile, CFile::modeRead );

		CString strContent;

		char szContent[MAX_SIZE];

		int nSize = cFile.GetLength();
				
		cFile.Read(szContent, nSize);

		szContent[nSize] = '\0';

		CString strTemp(szContent);

		strContent = strTemp;
			
		cFile.Close();

		if (strContent.IsEmpty())
		{
            CThemeContextActivator themeActivator;
			::AfxMessageBox(IDS_ERR_FILE_EMPTY, MB_OK|MB_ICONINFORMATION);

			if (nServerOrName == SERVER)
				m_buttonBrowseServer.SetFocus();
			else 
            if(nServerOrName == NAME)
				m_buttonBrowseName.SetFocus();

			return;
		}

		AddFileContent(strContent, nServerOrName);
	}
	CATCH( CFileException, e )
	{
#ifdef _DEBUG
		afxDump << "File could not be opened " << e->m_cause << "\n";
		
#endif
		return;
	}
	END_CATCH

	
}

void 
CCheckRegNames::SetControlState(int nNameOrServer)
{
    UpdateData();
	
    DWORD   dwIPAdd;

    switch (nNameOrServer)
	{
	    case NAME:
		    if ( (m_editRecordNameForList.GetWindowTextLength() > 0) && 
                 (m_nFileName != 0) )
            {
			    m_buttonAddName.EnableWindow(TRUE);
            }
		    else
            {
			    m_buttonAddName.EnableWindow(FALSE);
            }

		    if ( (m_listName.GetCurSel() == LB_ERR ) ||
                 (m_nFileName == 0) )
            {
			    m_buttonNameremove.EnableWindow(FALSE);
            }
		    else
            {
			    m_buttonNameremove.EnableWindow(TRUE);
            }

		    break;

	    case SERVER:
           	m_ipaServerIPAddress.GetAddress(&dwIPAdd);

            if ( (dwIPAdd != 0) &&
                 (m_nFileServer != 0) )
            {
			    m_buttonAddServer.EnableWindow(TRUE);
            }
		    else
            {
			    m_buttonAddServer.EnableWindow(FALSE);
            }

		    if ( (m_listServer.GetCurSel() == LB_ERR) ||
                 (m_nFileServer == 0) )
            {
			    m_buttonRemoveServer.EnableWindow(FALSE);
            }
		    else
            {
			    m_buttonRemoveServer.EnableWindow(TRUE);
            }
		    
            break;
	}
}


void CCheckRegNames::OnChangeEditName() 
{
	UpdateData();

	if(m_nFileName != 0)
		SetControlState(NAME);	
}


void CCheckRegNames::OnChangeEditServer() 
{
	UpdateData();

	if(m_nFileServer != 0)
		SetControlState(SERVER);
}


void CCheckRegNames::OnSelchangeListName() 
{
	SetControlState(NAME);
}


void CCheckRegNames::OnSelchangeListServer() 
{
	SetControlState(SERVER);
}

void CCheckRegNames::OnOK() 
{
    CThemeContextActivator themeActivator;
	UpdateData();

    // if the list radio button is selected
	if (m_nFileServer)
    {
		Add(SERVER);
    }

    if (m_strServerArray.GetSize() == 0)
    {
        AfxMessageBox(IDS_ERR_NAME_CHECK_NO_SERVERS);
        return;
    }

	//if the list radio button is selected
	if (m_nFileName)
    {
		Add(NAME);
    }

    if (m_strNameArray.GetSize() == 0)
    {
        AfxMessageBox(IDS_ERR_NAME_CHECK_NO_NAMES);
        return;
    }

	// clean up the name array because of deletions
	for (int i = 0; i < m_strNameArray.GetSize(); i++)
	{
		CWinsName winsName = m_strNameArray.GetAt(i);
		if (winsName.strName.IsEmpty())
		{
			m_strNameArray.RemoveAt(i);
			i--;
		}
	}

	CBaseDialog::OnOK();
}

void CCheckRegNames::OnNameAdd() 
{
	UpdateData();

	CString		strFormattedName;
	CWinsName	winsName;
    CThemeContextActivator themeActivator;

	if (!ParseName(m_strRecNameForList, winsName, strFormattedName))
	{
		// invalid name
		CString strMessage;
		AfxFormatString1(strMessage, IDS_ERR_INVALID_NAME, m_strRecNameForList);
		AfxMessageBox(strMessage);
		return;
	}

	if (!CheckIfPresent(winsName, NAME))
	{
		int nItem = m_listName.AddString(strFormattedName);
		int nIndex = (int)m_strNameArray.Add(winsName);
		m_listName.SetItemData(nItem, nIndex);

		m_editRecordNameForList.SetWindowText(NULL);
	}
	else
	{
		::AfxMessageBox(IDS_STRING_PRESENT);
		
        m_editRecordNameForList.SetFocus();
		m_editRecordNameForList.SetSel(0,-1);
		
        return;
	}
}

void CCheckRegNames::OnNameRemove() 
{
	int nSel = m_listName.GetCurSel();

	if (nSel == LB_ERR)
		return;

	DWORD_PTR dwIndex = m_listName.GetItemData(nSel);
	m_listName.DeleteString(nSel);
	m_strNameArray[(int) dwIndex].strName.Empty();

	SetControlState(NAME);
}

void CCheckRegNames::OnServerAdd() 
{
	UpdateData();

	DWORD dwIPAdd;
	m_ipaServerIPAddress.GetAddress(&dwIPAdd);

	if (dwIPAdd == 0)
	{
		m_ipaServerIPAddress.SetFocusField(0);
		return;
	}

	CString strIP;
	m_ipaServerIPAddress.GetWindowText(strIP);

	if (!CheckIfPresent(strIP, SERVER))
	{
		m_listServer.AddString(strIP);
		m_ipaServerIPAddress.ClearAddress();
	}
	else
	{
        CThemeContextActivator themeActivator;

		::AfxMessageBox(IDS_STRING_PRESENT);
		
        m_ipaServerIPAddress.SetFocusField(0);
		
        return;
	}
}

void CCheckRegNames::OnServerRemove() 
{
	int nSel = m_listServer.GetCurSel();

	if (nSel == LB_ERR)
		return;

	m_listServer.DeleteString(nSel);

	SetControlState(SERVER);
}

void 
CCheckRegNames::AddFileContent(CString &strContent, int nNameOrServer)
{
	int nCount;
	int i = 0;
	int nPos = 0;

	CString strPart;
    CThemeContextActivator themeActivator;

	while (i < strContent.GetLength())
	{
		strPart.Empty();

		while(strContent[i] != 10 && strContent[i] != 13)
		{
			strPart += strContent[i++];
			if (i > strContent.GetLength())
				break;
		}

		if (!strPart.IsEmpty())
		{
			if (nNameOrServer == NAME)
			{
				CString strFormattedName;
				CWinsName winsName;

				if (!ParseName(strPart, winsName, strFormattedName))
				{
					// invalid name
					CString strMessage;

					AfxFormatString1(strMessage, IDS_INVALID_NAME_IN_FILE, strPart);

					if (AfxMessageBox(strMessage, MB_YESNO) == IDNO)
						break;
				}
				else
				if (!CheckIfAdded(winsName, NAME))
				{
					// add to internal lists and UI
					int nItem = m_listName.AddString(strFormattedName);
					int nIndex = (int)m_strNameArray.Add(winsName);
					m_listName.SetItemData(nItem, nIndex);
				}
			}
			else 
			if (nNameOrServer == SERVER)
			{
				if (!CheckIfAdded(strPart, SERVER)  && !strPart.IsEmpty())
				{
					m_listServer.AddString(strPart);
					m_strServerArray.Add(strPart);
				}
			}
		}

		i++;
	}
}

void 
CCheckRegNames::Add(int nServerOrName)
{
	int nCount;
	int i = 0;

	switch (nServerOrName)
	{
		case SERVER:
			m_strServerArray.RemoveAll();
			nCount = m_listServer.GetCount();

			for(i = 0; i < nCount; i++)
			{
				CString strText;
				m_listServer.GetText(i, strText);
				m_strServerArray.Add(strText);
			}
			break;

		case NAME:
			/*
			m_strNameArray.RemoveAll();

			nCount = m_listName.GetCount();

			for(i = 0; i < nCount; i++)
			{
				CString strText;
				m_listName.GetText(i, strText);
				strText.MakeUpper();
				m_strNameArray.Add(strText);
			}
			*/
			break;
	}
}

void CCheckRegNames::OnRadioNameFile() 
{
	EnableControls(NAME, FALSE);
}

void CCheckRegNames::OnRadioNameList() 
{
	// set focus to the edit control
	m_editRecordNameForList.SetFocus();
	EnableControls(NAME, TRUE);

    SetControlState(NAME);
}

void CCheckRegNames::OnRadioServerFile() 
{
	EnableControls(SERVER, FALSE);
}

void CCheckRegNames::OnRadioServerList() 
{
	// set focus to the IP control meant for the list
	m_ipaServerIPAddress.SetFocus();
	EnableControls(SERVER, TRUE);

    SetControlState(SERVER);
}

BOOL 
CCheckRegNames::CheckIfPresent(CWinsName & winsName, int nNameOrServer) 
{
	BOOL bPresent = FALSE;

	if (nNameOrServer == NAME)
	{
		int nCount = (int)m_strNameArray.GetSize();

		for (int i = 0; i < nCount; i++)
		{
			CWinsName winsNameCur = m_strNameArray[i];

			if (winsName == winsNameCur)
			{
				bPresent = TRUE;
				break;
			}
		}
	}

	return bPresent;
}

BOOL 
CCheckRegNames::CheckIfPresent(CString & strText, int nNameOrServer) 
{
	BOOL bPresent = FALSE;

    if (nNameOrServer == SERVER)
	{
		int nCount = m_listServer.GetCount();

		for (int i = 0; i < nCount; i++)
		{
			CString strListItem;
			m_listServer.GetText(i, strListItem);

			if (strListItem.CompareNoCase(strText) == 0)
            {
				bPresent = TRUE;
				break;
            }
		}
	}

	return bPresent;
}

BOOL 
CCheckRegNames::CheckIfAdded(CWinsName winsName, int nNameOrServer)
{
	BOOL bAdded = FALSE;

	int nCount;
	
	if (nNameOrServer == NAME)
	{
		nCount = (int)m_strNameArray.GetSize();

		for (int i = 0; i < nCount; i++)
		{
			CWinsName winsNameCur = m_strNameArray[i];

			if (winsName == winsNameCur)
			{
				bAdded = TRUE;
				break;
			}
		}
    }

	return bAdded;
}

BOOL 
CCheckRegNames::CheckIfAdded(CString & strText, int nNameOrServer)
{
	BOOL bAdded = FALSE;

	int nCount;
	
	if (nNameOrServer == SERVER)
	{
		nCount = (int)m_strServerArray.GetSize();

		for (int i = 0; i < nCount; i++)
		{
			if (m_strServerArray[i].Compare(strText) == 0)
			{
				bAdded =  TRUE;
				break;
			}
		}
	}

	return bAdded;
}

void CCheckRegNames::OnChangeEditNameList() 
{
	UpdateData();
	
    if (m_nFileName != 0)
		SetControlState(NAME);	
}

void
CCheckRegNames::OnChangeIpAddress()
{
    SetControlState(SERVER);
}

BOOL 
CCheckRegNames::ParseName(CString & strNameIn, CWinsName & winsName, CString & strFormattedName)
{
	int nSeparator = strNameIn.Find(_T("*"));

	if (nSeparator == -1)
	{
		// no * separator between name and type -- in valid name
		return FALSE;
	}

	CString strName, strType;

	strName = strNameIn.Left(nSeparator);
	strType = strNameIn.Right(strNameIn.GetLength() - nSeparator - 1);

	if (strName.GetLength() > 15 ||
		strName.IsEmpty())
	{
		// name is too long or too short
		return FALSE;
	}

    DWORD dwType = _tcstol(strType, NULL, 16);
    if (dwType > 255)
	{
		// invalid type specified
		return FALSE;
	}

	winsName.strName = strName;
	winsName.dwType = dwType;

	strFormattedName.Format(_T("%s[%02Xh]"), strName, dwType);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\actreg.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	actreg.cpp
		WINS active registrations node information. 
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "nodes.h"
#include "actreg.h"
#include "server.h"
#include "Queryobj.h"
#include "statmapp.h"
#include "fndrcdlg.h"
#include <string.h>
#include "pushtrig.h"
#include "tregkey.h"
#include "chkrgdlg.h"
#include "dynrecpp.h"
#include "vrfysrv.h"
#include "delrcdlg.h"
#include "delowner.h"
#include "cprogdlg.h"
#include "loadrecs.h"

#include "verify.h"

WORD gwUnicodeHeader = 0xFEFF;

#define INFINITE_EXPIRATION     0x7FFFFFFF
#define BADNAME_CHAR _T('-')        // This char is substituted for bad characters
	                                // NetBIOS names.
UINT guActregMessageStrings[] =
{
    IDS_ACTREG_MESSAGE_BODY1,
    IDS_ACTREG_MESSAGE_BODY2,
    IDS_ACTREG_MESSAGE_BODY3,
    IDS_ACTREG_MESSAGE_BODY4,
    -1
};

BOOL
WinsIsPrint(char * pChar)
{
    WORD    charType;

    // isprint isn't working for thai characters, so use the GetStringType
    // API and figure it out ourselves.
    BOOL fRet = GetStringTypeA(LOCALE_SYSTEM_DEFAULT, CT_CTYPE1, pChar, 1, &charType);
    if (!fRet)
        return 0;

    return !(charType & C1_CNTRL) ? 1 : 0;  
}

/*---------------------------------------------------------------------------
    class CSortWorker
 ---------------------------------------------------------------------------*/
CSortWorker::CSortWorker(IWinsDatabase * pCurrentDatabase, 
						 int nColumn, 
						 DWORD dwSortOptions)
{
    m_pCurrentDatabase = pCurrentDatabase;
	m_nColumn = nColumn;
	m_dwSortOptions = dwSortOptions;
}


CSortWorker::~CSortWorker()
{
}


void
CSortWorker::OnDoAction()
{
#ifdef DEBUG
	CString strType;
    CTime timeStart, timeFinish;
    timeStart = CTime::GetCurrentTime();
#endif

	WINSDB_SORT_TYPE uSortType = WINSDB_SORT_BY_NAME;

	switch (m_nColumn)
	{
	    case ACTREG_COL_NAME:
			uSortType = WINSDB_SORT_BY_NAME;
		    break;
	    
		case ACTREG_COL_TYPE:
			uSortType = WINSDB_SORT_BY_TYPE;
		    break;

		case ACTREG_COL_IPADDRESS:
			uSortType = WINSDB_SORT_BY_IP;
		    break;
	    
		case ACTREG_COL_STATE:
			uSortType = WINSDB_SORT_BY_STATE;
		    break;
	    
		case ACTREG_COL_STATIC:
			uSortType = WINSDB_SORT_BY_STATIC;
		    break;
	    
		case ACTREG_COL_VERSION:
			uSortType = WINSDB_SORT_BY_VERSION;
		    break;
	    
		case ACTREG_COL_EXPIRATION:
			uSortType = WINSDB_SORT_BY_EXPIRATION;
		    break;

		case ACTREG_COL_OWNER:
			uSortType = WINSDB_SORT_BY_OWNER;
		    break;
	}

	BEGIN_WAIT_CURSOR

	m_pCurrentDatabase->Sort(uSortType, m_dwSortOptions);
	
	END_WAIT_CURSOR

#ifdef DEBUG
    timeFinish = CTime::GetCurrentTime();
    CTimeSpan timeDelta = timeFinish - timeStart;
	CString str = timeDelta.Format(_T("%H:%M:%S"));

    Trace2("Record Sorting for the column: %d, total time %s\n", 
			uSortType, str);
#endif

}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::CActiveRegistrationsHandler
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
CActiveRegistrationsHandler::CActiveRegistrationsHandler(ITFSComponentData *pCompData) 
														: CMTWinsHandler(pCompData), m_dlgLoadRecords(IDS_VIEW_RECORDS)
{
    m_winsdbState = WINSDB_NORMAL;
	m_bExpanded = FALSE;
    m_pCurrentDatabase = NULL;
	m_fFindNameOrIP = TRUE;
	m_NonBlocking = 1;

    m_pServerInfoArray = NULL;

	m_fLoadedOnce = FALSE;
    m_fFindLoaded = FALSE;
    m_fDbLoaded = FALSE;
    m_fForceReload = TRUE;
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::~CActiveRegistrationsHandler
		Description
 ---------------------------------------------------------------------------*/
CActiveRegistrationsHandler::~CActiveRegistrationsHandler()
{
}

/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::DestroyHandler
	    Release and pointers we have here
    Author: EricDav
----------------------------------------------------------------------------*/
HRESULT
CActiveRegistrationsHandler::DestroyHandler
(
	ITFSNode * pNode
)
{
    m_spServerNode.Set(NULL);
    return hrOK;
}

/*!--------------------------------------------------------------------------
	CActiveRegistrationsHandler::InitializeNode
		Initializes node specific data
 ---------------------------------------------------------------------------*/
HRESULT
CActiveRegistrationsHandler::InitializeNode
(
	ITFSNode * pNode
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT				hr = hrOK;
	CString				strTemp;

	m_strActiveReg.LoadString(IDS_ACTIVEREG);
	SetDisplayName(m_strActiveReg);

	m_strDesp.LoadString(IDS_ACTIVEREG_DISC);

	// Make the node immediately visible
	pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
	pNode->SetData(TFS_DATA_IMAGEINDEX, GetImageIndex(FALSE));
	pNode->SetData(TFS_DATA_OPENIMAGEINDEX, GetImageIndex(TRUE));
	pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, WINSSNAP_ACTIVE_REGISTRATIONS);
    pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

	SetColumnStringIDs(&aColumns[WINSSNAP_ACTIVE_REGISTRATIONS][0]);
	SetColumnWidths(&aColumnWidths[WINSSNAP_ACTIVE_REGISTRATIONS][0]);

    if (g_strStaticTypeUnique.IsEmpty())
    {
        g_strStaticTypeUnique.LoadString(IDS_STATIC_RECORD_TYPE_UNIQUE);
        g_strStaticTypeDomainName.LoadString(IDS_STATIC_RECORD_TYPE_DOMAIN_NAME);
        g_strStaticTypeMultihomed.LoadString(IDS_STATIC_RECORD_TYPE_MULTIHOMED);
        g_strStaticTypeGroup.LoadString(IDS_STATIC_RECORD_TYPE_GROUP);
        g_strStaticTypeInternetGroup.LoadString(IDS_STATIC_RECORD_TYPE_INTERNET_GROUP);
        g_strStaticTypeUnknown.LoadString(IDS_STATIC_RECORD_TYPE_UNKNOWN);
    }

	return hr;
}

/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::OnCreateNodeId2
		Returns a unique string for this node
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CActiveRegistrationsHandler::OnCreateNodeId2(ITFSNode * pNode, CString & strId, DWORD * dwFlags)
{
    const GUID * pGuid = pNode->GetNodeType();

    CString strGuid;

    StringFromGUID2(*pGuid, strGuid.GetBuffer(256), 256);
    strGuid.ReleaseBuffer();

	SPITFSNode spServerNode;
    pNode->GetParent(&spServerNode);

    CWinsServerHandler * pServer = GETHANDLER(CWinsServerHandler, spServerNode);

    strId = pServer->m_strServerAddress + strGuid;

    return hrOK;
}

/*---------------------------------------------------------------------------
	Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	CActiveRegistrationsHandler::GetString
		Implementation of ITFSNodeHandler::GetString
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) 
CActiveRegistrationsHandler::GetString
(
	ITFSNode *	pNode, 
	int			nCol
)
{
	if (nCol == 0 || nCol == -1)
    {
		return GetDisplayName();
    }
	else 
    if (nCol ==1)
    {
		return m_strDesp;
    }
	else
    {
		return NULL;
    }
}

/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::OnExpand
		Description
 ---------------------------------------------------------------------------*/
HRESULT 
CActiveRegistrationsHandler::OnExpand
(
	ITFSNode *		pNode, 
	LPDATAOBJECT	pDataObject,
	DWORD			dwType,
	LPARAM  		arg, 
	LPARAM			param
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT				hr = hrOK;
	SPITFSNode			spNode;
	SPITFSNodeHandler	spHandler;
	ITFSQueryObject *	pQuery = NULL;
	CString				strIP;
	DWORD				dwIP;
	CString				strMachineName;
    
    SPITFSNode spServerNode;
    pNode->GetParent(&spServerNode);

    CWinsServerHandler * pServer = GETHANDLER(CWinsServerHandler, spServerNode);

	// get the config info for later
	m_Config = pServer->GetConfig();

	m_RecList.RemoveAll();

	if (m_bExpanded)
	{
		return hr;
	}

	strMachineName = _T("\\\\") + pServer->GetServerAddress();

	// load the name type mapping from the registry
	m_NameTypeMap.SetMachineName(strMachineName);
    m_NameTypeMap.Load();

	// start the database download for the surrent owner
    if (!m_spWinsDatabase)
    {
        dwIP = pServer->GetServerIP();
	    MakeIPAddress(dwIP, strIP);

        m_dlgLoadRecords.ResetFiltering();
        
        CORg(CreateWinsDatabase(strIP, strIP, &m_spWinsDatabase));

        // set the owner to the current owner
        m_spWinsDatabase->SetApiInfo(
                            dwIP, 
                            NULL,
                            FALSE);
    }

    m_bExpanded = TRUE;

COM_PROTECT_ERROR_LABEL;
    return hr;
}


/*---------------------------------------------------------------------------
	CWinsServerHandler::OnResultRefresh
		Refreshes the data realting to the server
	Author: v-shubk
---------------------------------------------------------------------------*/
HRESULT 
CActiveRegistrationsHandler::OnResultRefresh
(
    ITFSComponent *     pComponent,
    LPDATAOBJECT        pDataObject,
    MMC_COOKIE          cookie,
    LPARAM              arg,
    LPARAM              lParam
)
{
	HRESULT     hr = hrOK;
    SPITFSNode  spNode;

	CORg (m_spNodeMgr->FindNode(cookie, &spNode));

	// get the stae of the databse if not normal, ie in the loading or filtering state
	// don't let refresh
	if (m_winsdbState != WINSDB_NORMAL)
    {
		return hrOK;
    }
	
    RefreshResults(spNode);

Error:
    return hr;
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::OnCreateQuery
		Description
	Author: v-shubk
 ---------------------------------------------------------------------------*/
ITFSQueryObject *
CActiveRegistrationsHandler::OnCreateQuery(ITFSNode * pNode)
{
	CNodeTimerQueryObject * pQObj = new CNodeTimerQueryObject();

	pQObj->SetTimerInterval(2000);
	
	return pQObj;
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::OnHaveData
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CActiveRegistrationsHandler::OnHaveData
(
	ITFSNode * pParentNode, 
	LPARAM	   Data,
	LPARAM	   Type
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    // This is how we get non-node data back from the background thread.
	HRESULT hr = hrOK;
    WINSDB_STATE uState;

    COM_PROTECT_TRY
    {
        if (Type == QDATA_TIMER)
	    {
            BOOL bDone;

            m_spWinsDatabase->GetCurrentState(&uState);

            bDone = (m_winsdbState == WINSDB_LOADING && uState != WINSDB_LOADING) ||
                    (m_winsdbState == WINSDB_FILTERING && uState != WINSDB_LOADING);

			// if records per owner are downloaded, clear and redraw the
			// items as the records are inserted, rather than being added.
			//if (TRUE /*m_dwOwnerFilter != -1*/)
			//{
			//	UpdateCurrentView(pParentNode);
			//}

            // call into the WinsDatbase object and check the count.
		    // if we need to update call..UpdateAllViews
            UpdateListboxCount(pParentNode);

			UpdateCurrentView(pParentNode);

		    if (m_nState != loading)
            {
                m_nState = loading;
                OnChangeState(pParentNode);
            }


			// take care of the tomer in case of the filetr records case
            if (bDone)
            {
                Trace0("ActiveRegHandler::OnHaveData - Done loading DB\n");

                DatabaseLoadingCleanup();

                if ( (m_nState != loaded) &&
                     (m_nState != unableToLoad) )
                {
                    m_nState = loaded;
			        m_dwErr = 0;
			        OnChangeState(pParentNode);
                }
            }
	    }
    }
    COM_PROTECT_CATCH

	return;
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::CActiveRegistrationsHandler
		Description
	Author: v-shubk
 ---------------------------------------------------------------------------*/
int CActiveRegistrationsHandler::GetImageIndex(BOOL bOpenImage)
{
	int nIndex = 0;
	switch (m_nState)
	{
		case notLoaded:
		case loaded:
		case unableToLoad:
			if (bOpenImage)
				nIndex = ICON_IDX_ACTREG_FOLDER_OPEN;
			else
				nIndex = ICON_IDX_ACTREG_FOLDER_CLOSED;
			break;

		case loading:
			if (bOpenImage)
				nIndex = ICON_IDX_ACTREG_FOLDER_OPEN_BUSY;
			else
				nIndex = ICON_IDX_ACTREG_FOLDER_CLOSED_BUSY;
			break;

		default:
			ASSERT(FALSE);
	}
	return nIndex;
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::OnAddMenuItems
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CActiveRegistrationsHandler::OnAddMenuItems
(
	ITFSNode *				pNode,
	LPCONTEXTMENUCALLBACK	pContextMenuCallback, 
	LPDATAOBJECT			lpDataObject, 
	DATA_OBJECT_TYPES		type, 
	DWORD					dwType,
	long *					pInsertionAllowed
)
{ 
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT     hr = S_OK;
    LONG        lFlags = 0; 
    CString strMenuItem;

    if (!m_Config.IsAdmin())
    {
        lFlags = MF_GRAYED;
    }

	if (type == CCT_SCOPE)
	{
		// these menu items go in the new menu, 
		// only visible from scope pane
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
		 
			// find record
			//strMenuItem.LoadString(IDS_ACTIVEREG_FIND_RECORD);
			//hr = LoadAndAddMenuItem( pContextMenuCallback, 
			//						 strMenuItem, 
			//						 IDS_ACTIVEREG_FIND_RECORD,
			//						 CCM_INSERTIONPOINTID_PRIMARY_TOP, 
			//						 0 );
			//ASSERT( SUCCEEDED(hr) );
			
    		// start database load if th state is normal
			if (m_winsdbState == WINSDB_NORMAL)
			{
				strMenuItem.LoadString(IDS_DATABASE_LOAD_START);
				hr = LoadAndAddMenuItem( pContextMenuCallback, 
										 strMenuItem, 
										 IDS_DATABASE_LOAD_START,
										 CCM_INSERTIONPOINTID_PRIMARY_TOP, 
										 0 );
				ASSERT( SUCCEEDED(hr) );
			}
			else
			{
				strMenuItem.LoadString(IDS_DATABASE_LOAD_STOP);
				hr = LoadAndAddMenuItem( pContextMenuCallback, 
										 strMenuItem, 
										 IDS_DATABASE_LOAD_STOP,
										 CCM_INSERTIONPOINTID_PRIMARY_TOP, 
										 0 );
				ASSERT( SUCCEEDED(hr) );
			}

            // separator
		    hr = LoadAndAddMenuItem( pContextMenuCallback, 
								     strMenuItem, 
								     0,
								     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
								     MF_SEPARATOR);
		    ASSERT( SUCCEEDED(hr) );

            // create static mapping
            strMenuItem.LoadString(IDS_ACTIVEREG_CREATE_STATIC_MAPPING);
		    hr = LoadAndAddMenuItem( pContextMenuCallback, 
								     strMenuItem, 
								     IDS_ACTIVEREG_CREATE_STATIC_MAPPING,
								     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
								     0 );
		    ASSERT( SUCCEEDED(hr) );

            // separator
		    hr = LoadAndAddMenuItem( pContextMenuCallback, 
								     strMenuItem, 
								     0,
								     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
								     MF_SEPARATOR);
		    ASSERT( SUCCEEDED(hr) );

            // import LMHOSTS file
            strMenuItem.LoadString(IDS_ACTIVEREG_IMPORT_LMHOSTS);
			hr = LoadAndAddMenuItem( pContextMenuCallback, 
									 strMenuItem, 
									 IDS_ACTIVEREG_IMPORT_LMHOSTS,
									 CCM_INSERTIONPOINTID_PRIMARY_TOP, 
									 0 );
			ASSERT( SUCCEEDED(hr) );

            // only available to admins
            strMenuItem.LoadString(IDS_ACTREG_CHECK_REG_NAMES);
			hr = LoadAndAddMenuItem( pContextMenuCallback, 
									 strMenuItem, 
									 IDS_ACTREG_CHECK_REG_NAMES,
									 CCM_INSERTIONPOINTID_PRIMARY_TOP, 
								    lFlags );
    		ASSERT( SUCCEEDED(hr) );

			strMenuItem.LoadString(IDS_ACTREG_DELETE_OWNER);
			hr = LoadAndAddMenuItem( pContextMenuCallback, 
									 strMenuItem, 
									 IDS_ACTREG_DELETE_OWNER,
									 CCM_INSERTIONPOINTID_PRIMARY_TOP, 
								    0 );
    		ASSERT( SUCCEEDED(hr) );
        }

		 
	}

	return hr; 
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::OnCommand
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CActiveRegistrationsHandler::OnCommand
(
	ITFSNode *			pNode, 
	long				nCommandId, 
	DATA_OBJECT_TYPES	type, 
	LPDATAOBJECT		pDataObject, 
	DWORD				dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = S_OK;

	switch (nCommandId)
	{
		case IDS_ACTIVEREG_CREATE_STATIC_MAPPING:
			OnCreateMapping(pNode);
			break;
    	
        case IDS_DATABASE_LOAD_START:
			OnDatabaseLoadStart(pNode);
			break;

        case IDS_DATABASE_LOAD_STOP:
			OnDatabaseLoadStop(pNode);
			break;

		case IDS_ACTIVEREG_IMPORT_LMHOSTS:
			OnImportLMHOSTS(pNode);
			break;

		case IDS_ACTIVEREG_EXPORT_WINSENTRIES:
			OnExportEntries();
			break;

		case IDS_ACTREG_CHECK_REG_NAMES:
			OnCheckRegNames(pNode);
			break;

		case IDS_ACTREG_DELETE_OWNER:
			OnDeleteOwner(pNode);
			break;

        default:
			break;
	}


	return hr;
}


/*!--------------------------------------------------------------------------
	CActiveRegistrationsHandler::AddMenuItems
		Over-ride this to add our view menu item
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CActiveRegistrationsHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
	MMC_COOKIE  			cookie,
	LPDATAOBJECT			pDataObject, 
	LPCONTEXTMENUCALLBACK	pContextMenuCallback, 
	long *					pInsertionAllowed
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;
	CString strMenuItem;
    LONG    lFlags = 0;

    // figure out if we need to pass this to the scope pane menu handler
    hr = HandleScopeMenus(cookie, pDataObject, pContextMenuCallback, pInsertionAllowed);

    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW) 
    {
        if (m_fLoadedOnce)
        {
            lFlags = MF_CHECKED|MFT_RADIOCHECK;
        }
        else
        {
            lFlags = 0;
        }

        strMenuItem.LoadString(IDS_ACTREG_SHOW_ENTIRE);
        hr = LoadAndAddMenuItem( pContextMenuCallback, 
								 strMenuItem, 
								 IDM_FILTER_DATABASE,
								 CCM_INSERTIONPOINTID_PRIMARY_VIEW, 
                                 lFlags);
		ASSERT( SUCCEEDED(hr) );
    }

    return hr;
}

/*!--------------------------------------------------------------------------
	CActiveRegistrationsHandler::Command
		Handles commands for the current view
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CActiveRegistrationsHandler::Command
(
    ITFSComponent * pComponent, 
	MMC_COOKIE		cookie, 
	int				nCommandID,
	LPDATAOBJECT	pDataObject
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = S_OK;
    SPITFSNode spNode;

    CORg (m_spNodeMgr->FindNode(cookie, &spNode));

    switch (nCommandID)
	{
        case IDM_FILTER_DATABASE:
            if (m_fDbLoaded)
            {
                UpdateCurrentView(spNode);
            }
            else
            {
                OnDatabaseLoadStart(spNode);
            }
            break;

        // this may have come from the scope pane handler, so pass it up
        default:
            hr = HandleScopeCommand(cookie, nCommandID, pDataObject);
            break;
    }

Error:
    return hr;
}


/*!--------------------------------------------------------------------------
	CActiveRegistrationsHandler::HasPropertyPages
		Implementation of ITFSNodeHandler::HasPropertyPages
	NOTE: the root node handler has to over-ride this function to 
	handle the snapin manager property page (wizard) case!!!
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CActiveRegistrationsHandler::HasPropertyPages
(
	ITFSNode *			pNode,
	LPDATAOBJECT		pDataObject, 
	DATA_OBJECT_TYPES   type, 
	DWORD               dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = hrOK;
	
	if (dwType & TFS_COMPDATA_CREATE)
	{
		// This is the case where we are asked to bring up property
		// pages when the user is adding a new snapin.  These calls
		// are forwarded to the root node to handle.
		hr = hrFalse;
	}
	else
	{
		// we have property pages in the normal case
		hr = hrOK;
	}

	return hr;
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::CreatePropertyPages
		The active registrations node (scope pane) doesn't have 
        any property pages.  We should never get here.
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CActiveRegistrationsHandler::CreatePropertyPages
(
	ITFSNode *				pNode,
	LPPROPERTYSHEETCALLBACK lpProvider,
	LPDATAOBJECT			pDataObject, 
	LONG_PTR    			handle, 
	DWORD					dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// we use this to create static mappings, but we don't show it
	// through the properties verb.  We invoke this mechanism when the
	// user selects create static mapping

	HRESULT	            hr = hrOK;

	// Object gets deleted when the page is destroyed
	SPIComponentData spComponentData;
	m_spNodeMgr->GetComponentData(&spComponentData);

	// show the same page as the statis mapping properties
	CStaticMappingProperties * pMapping = 
    		new CStaticMappingProperties (pNode, 
									      spComponentData, 
										  NULL,
                                          NULL,
                                          TRUE);

    pMapping->m_ppageGeneral->m_uImage = ICON_IDX_CLIENT;

	pMapping->CreateModelessSheet(lpProvider, handle);

	return hr;
}


/*!--------------------------------------------------------------------------
	CActiveRegistrationsHandler::HasPropertyPages
		Implementation of ITFSResultHandler::HasPropertyPages
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CActiveRegistrationsHandler::HasPropertyPages
(
    ITFSComponent *         pComponent, 
	MMC_COOKIE  			cookie,
	LPDATAOBJECT			pDataObject
)
{
	return hrOK;
}


/*!--------------------------------------------------------------------------
	CActiveRegistrationsHandler::CreatePropertyPages
		Implementation of ITFSResultHandler::CreatePropertyPages
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CActiveRegistrationsHandler::CreatePropertyPages
(
    ITFSComponent *         pComponent, 
	MMC_COOKIE				cookie,
	LPPROPERTYSHEETCALLBACK	lpProvider, 
	LPDATAOBJECT			pDataObject, 
	LONG_PTR 				handle
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT	            hr = hrOK;
	HPROPSHEETPAGE      hPage;
    SPINTERNAL          spInternal;
	SPIComponentData    spComponentData;
	SPIComponent        spComponent;
    SPITFSNode          spNode;
	SPIResultData		spResultData;
	int					nIndex ;
	HROW				hRowSel;
	WinsRecord			wRecord;
	WinsStrRecord		*pwstrRecord;
	int					nCount;
			   
	// get the resultdata interface
    CORg (pComponent->GetResultData(&spResultData));

    spInternal = ExtractInternalFormat(pDataObject);

    // virtual listbox notifications come to the handler of the node 
	// that is selected. check to see if this notification is for a 
	// virtual listbox item or the active registrations node itself.

    if (spInternal->HasVirtualIndex())
    {
        // we gotta do special stuff for the virtual index items
        m_spNodeMgr->FindNode(cookie, &spNode);
		
        CORg(spComponent.HrQuery(pComponent));
        Assert(spComponent);

		m_nSelectedIndex = spInternal->GetVirtualIndex();
		nIndex = m_nSelectedIndex;

		// if an invalid index, return
		m_pCurrentDatabase->GetCurrentCount(&nCount);

		if (nIndex < 0 || nIndex >= nCount)
        {
			return hrOK;
        }

		// get the correct data for the record selected
		m_spWinsDatabase->GetHRow(nIndex, &hRowSel);
		m_spWinsDatabase->GetData(hRowSel, &wRecord);

        GetRecordOwner(spNode, &wRecord);

		// put up different page depending on wheter static or dynamic
		if (wRecord.dwState & WINSDB_REC_STATIC)
		{
			m_CurrentRecord = wRecord;

			CStaticMappingProperties * pStat = 
			    new CStaticMappingProperties(spNode, 
											spComponent, 
											NULL, 
											&wRecord, 
											FALSE);
			pStat->m_ppageGeneral->m_uImage = GetVirtualImage(nIndex);
			
			Assert(lpProvider != NULL);

			return pStat->CreateModelessSheet(lpProvider, handle);
		}
		// dynamic case
		else
		{
			CDynamicMappingProperties *pDyn = 
				new CDynamicMappingProperties(spNode, 
												spComponent, 
												NULL, 
												&wRecord);

			pDyn->m_pageGeneral.m_uImage = GetVirtualImage(nIndex);
			Assert(lpProvider != NULL);

			return pDyn->CreateModelessSheet(lpProvider, handle);
		}
    }
    else
    {
        Assert(FALSE);
    }

COM_PROTECT_ERROR_LABEL;
    return hr;
}

/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::OnPropertyChange
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CActiveRegistrationsHandler::OnPropertyChange
(	
	ITFSNode *		pNode, 
	LPDATAOBJECT	pDataobject, 
	DWORD			dwType, 
	LPARAM			arg, 
	LPARAM			lParam
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CStaticMappingProperties * pProp	= 
		reinterpret_cast<CStaticMappingProperties *>(lParam);

	LONG_PTR changeMask = 0;

	// tell the property page to do whatever now that we are back on the
	// main thread
	pProp->OnPropertyChange(TRUE, &changeMask);
	pProp->AcknowledgeNotify();

	// refresh the result pane
    if (changeMask)
	    UpdateListboxCount(pNode);    

	return hrOK;
}

/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::OnResultPropertyChange
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CActiveRegistrationsHandler::OnResultPropertyChange
(
	ITFSComponent * pComponent,
	LPDATAOBJECT	pDataObject,
	MMC_COOKIE		cookie,
	LPARAM			arg,
	LPARAM  		param
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = hrOK;
	SPINTERNAL      spInternal;
	SPITFSNode		spNode;
	
	m_spNodeMgr->FindNode(cookie, &spNode);

	CStaticMappingProperties * pProp = reinterpret_cast<CStaticMappingProperties *>(param);

	LONG_PTR changeMask = 0;

	// tell the property page to do whatever now that we are back on the
	// main thread
	pProp->SetComponent(pComponent);
    pProp->OnPropertyChange(TRUE, &changeMask);
	pProp->AcknowledgeNotify();
    
	// refresh the result pane
    if (changeMask)
	    UpdateListboxCount(spNode);    

	return hr;
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::OnResultDelete
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CActiveRegistrationsHandler::OnResultDelete
(
	ITFSComponent * pComponent, 
	LPDATAOBJECT	pDataObject,
	MMC_COOKIE		cookie, 
	LPARAM			arg, 
	LPARAM			lParam
)
{
	HRESULT hr = hrOK;

	Trace0("CActiveRegistrationsHandler::OnResultDelete received\n");

    SPINTERNAL      spInternal;

    spInternal = ExtractInternalFormat(pDataObject);

    // virtual listbox notifications come to the handler of the node 
	// that is selected. check to see if this notification is for a 
	// virtual listbox item or the active registrations node itself.
    if (spInternal->HasVirtualIndex())
    {
        // we gotta do special stuff for the virtual index items
        DeleteRegistration(pComponent, spInternal->GetVirtualIndex());
    }
    else
    {
        // just call the base class to update verbs for the 
        CMTWinsHandler::OnResultDelete(pComponent, 
										pDataObject, 
										cookie, 
										arg, 
										lParam);
    }

	return hr;
}


/*!--------------------------------------------------------------------------
	CActiveRegistrationsHandler::OnResultSelect
		Handles the MMCN_SELECT notifcation 
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CActiveRegistrationsHandler::OnResultSelect
(
	ITFSComponent * pComponent, 
	LPDATAOBJECT	pDataObject, 
    MMC_COOKIE      cookie,
	LPARAM			arg, 
	LPARAM			lParam
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT         hr = hrOK;
    int             i;
    WINSDB_STATE    uState = WINSDB_LOADING;
    SPINTERNAL      spInternal;
    SPIConsoleVerb  spConsoleVerb;
	SPIConsole	    spConsole;
    BOOL            bStates[ARRAYLEN(g_ConsoleVerbs)];
    SPITFSNode      spNode;

    // show the result pane message
    if (!m_fLoadedOnce)
    {
        CString strTitle, strBody, strTemp;
        
        m_spResultNodeMgr->FindNode(cookie, &spNode);

        strTitle.LoadString(IDS_ACTREG_MESSAGE_TITLE);

        for (i = 0; ; i++)
        {
            if (guActregMessageStrings[i] == -1)
                break;

            strTemp.LoadString(guActregMessageStrings[i]);
            strBody += strTemp;
        }
        
        ShowMessage(spNode, strTitle, strBody, Icon_Information);
    }
    else
    {
        ULARGE_INTEGER data, *pData;

        // fill in the result pane
        if (m_spWinsDatabase)
        {
            m_spWinsDatabase->GetCurrentState(&uState);

            // check to see if we are done
            if (m_winsdbState == WINSDB_LOADING &&
                uState != WINSDB_LOADING)
            {
	            Trace0("ActiveRegHandler::OnResultSelect - Done loading DB\n");
        
                DatabaseLoadingCleanup();
            }
        }

        if (m_pCurrentDatabase)
        {
            // Get the count from the database
            CORg (m_pCurrentDatabase->GetCurrentScanned((int*)&data.LowPart));
            CORg (m_pCurrentDatabase->GetCurrentCount((int*)&data.HighPart));
            pData = &data;
        }
        else
        {
            pData = NULL;
        }

   	    // now notify the virtual listbox
        CORg ( m_spNodeMgr->GetConsole(&spConsole) );
	    CORg ( spConsole->UpdateAllViews(pDataObject, 
									    (LPARAM)pData, 
									    RESULT_PANE_SET_VIRTUAL_LB_SIZE) ); 
    }

    // now update the verbs...
    spInternal = ExtractInternalFormat(pDataObject);
    Assert(spInternal);

    // virtual listbox notifications come to the handler of the node 
	// that is selected.check to see if this notification is for a 
	// virtual listbox item or the active registrations node itself.
    if (spInternal->HasVirtualIndex())
    {
        // is this a multiselect?
        BOOL fMultiSelect = spInternal->m_cookie == MMC_MULTI_SELECT_COOKIE ? TRUE : FALSE;
        
        if (!fMultiSelect)
        {
            // when something is selected in the result pane we want the default verb to be properties
            m_verbDefault = MMC_VERB_PROPERTIES;
        }
        else
        {
            // we don't support multi-select properties
            m_verbDefault = MMC_VERB_NONE;
        }

        // we gotta do special stuff for the virtual index items
        CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

        UpdateConsoleVerbs(spConsoleVerb, WINSSNAP_REGISTRATION, fMultiSelect);
    }
    else
    {
        // when the active registrations node itself is selected, default should be open
        m_verbDefault = MMC_VERB_OPEN;

        g_ConsoleVerbStates[WINSSNAP_ACTIVE_REGISTRATIONS][6] = ENABLED;

		// just call the base class to update verbs for the 
		CMTWinsHandler::OnResultSelect(pComponent, 
										pDataObject, 
										cookie, 
										arg, 
  									    lParam);
	}

COM_PROTECT_ERROR_LABEL;
    return hr;
}

/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::DatabaseLoadingCleanup
		Description
	Author: ericdav
 ---------------------------------------------------------------------------*/
void 
CActiveRegistrationsHandler::DatabaseLoadingCleanup()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    m_winsdbState = WINSDB_NORMAL;

    // check for any errors
    HRESULT hrLastError;
    m_spWinsDatabase->GetLastError(&hrLastError);

    // Kill the timer thread
	if (m_spQuery)
    {
		// Signal the thread to abort
		m_spQuery->SetAbortEvent();
    }

    if (FAILED(hrLastError))
    {
        CString strError, strIp;

        LPTSTR pBuf = strIp.GetBuffer(256);
        m_spWinsDatabase->GetIP(pBuf, 256);

        strIp.ReleaseBuffer();

        AfxFormatString1(strError, IDS_ERR_LOADING_DB, strIp);
        theApp.MessageBox(strError, WIN32_FROM_HRESULT(hrLastError));

        m_fForceReload = TRUE;
    }

    WaitForThreadToExit();
}


void 
CActiveRegistrationsHandler::FilterCleanup(ITFSNode *pNode)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    m_winsdbState = WINSDB_NORMAL;

    // check for any errors
    HRESULT hrLastError;
    m_spWinsDatabase->GetLastError(&hrLastError);

    // Kill the timer thread
	if (m_spQuery)
    {
		// Signal the thread to abort
		m_spQuery->SetAbortEvent();
    }

    if (FAILED(hrLastError))
    {
        CString strError, strIp;

        LPTSTR pBuf = strIp.GetBuffer(256);
        m_spWinsDatabase->GetIP(pBuf, 256);

        strIp.ReleaseBuffer();

        AfxFormatString1(strError, IDS_ERR_LOADING_DB, strIp);
        theApp.MessageBox(strError, WIN32_FROM_HRESULT(hrLastError));

        m_fForceReload = TRUE;
    }

    WaitForThreadToExit();

	// change the icon to normal
	pNode->SetData(TFS_DATA_IMAGEINDEX, GetImageIndex(FALSE));
	pNode->SetData(TFS_DATA_OPENIMAGEINDEX, GetImageIndex(TRUE));

	pNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM);
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::UpdateListboxCount
		Description
 ---------------------------------------------------------------------------*/
HRESULT
CActiveRegistrationsHandler::UpdateListboxCount(ITFSNode * pNode, BOOL bClear)
{
	HRESULT				hr = hrOK;
	SPIComponentData	spCompData;
	SPIConsole			spConsole;
	IDataObject*		pDataObject;
    LONG_PTR            hint;
    // need to pass up two counter values:one is the total number of records scanned
    // the other is the total number of records filtered. I put these two in a 64 bit
    // value: the most significant 32bits is the number of records actually filtered
    // the less significant 32bits is the total number of records scanned.
    ULARGE_INTEGER      data;
    ULARGE_INTEGER      *pData;


    COM_PROTECT_TRY
    {
        if (!m_pCurrentDatabase)
        {
            pData = NULL;
            hint = RESULT_PANE_CLEAR_VIRTUAL_LB;
        }
        else
        {
            CORg (m_pCurrentDatabase->GetCurrentScanned((int*)&data.LowPart));
			CORg (m_pCurrentDatabase->GetCurrentCount((int*)&data.HighPart));
            hint = RESULT_PANE_SET_VIRTUAL_LB_SIZE;
            pData = &data;
        }

	    m_spNodeMgr->GetComponentData(&spCompData);

	    CORg ( spCompData->QueryDataObject((MMC_COOKIE) pNode, 
											CCT_RESULT, 
											&pDataObject) );

	    CORg ( m_spNodeMgr->GetConsole(&spConsole) );

	    CORg ( spConsole->UpdateAllViews(pDataObject, 
										(LPARAM)pData, 
										hint) ); 

	    pDataObject->Release();

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}

/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::UpdateVerbs
		Description
 ---------------------------------------------------------------------------*/
HRESULT
CActiveRegistrationsHandler::UpdateVerbs(ITFSNode * pNode)
{
	HRESULT				hr = hrOK;
    LONG_PTR            hint;
    int                 i;

    COM_PROTECT_TRY
    {
        g_ConsoleVerbStates[WINSSNAP_ACTIVE_REGISTRATIONS][6] = ENABLED;

		if (!pNode)
		{
			hint = WINSSNAP_REGISTRATION;
		}
		else
		{
			hint = WINSSNAP_ACTIVE_REGISTRATIONS;
		}


		UpdateStandardVerbs(pNode, hint);

    }
    COM_PROTECT_CATCH

    return hr;
}


/*---------------------------------------------------------------------------
	Command handlers
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::GetServerIP
		Description
	Author: v-shubk
 ---------------------------------------------------------------------------*/
void 
CActiveRegistrationsHandler::GetServerIP(ITFSNode * pNode, 
										DWORD &dwIP,
										CString &strIP)
{
	SPITFSNode spServerNode;
    pNode->GetParent(&spServerNode);

    CWinsServerHandler * pServer = GETHANDLER(CWinsServerHandler, spServerNode);

	dwIP = pServer->GetServerIP();
	
	::MakeIPAddress(dwIP, strIP);
}

/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::OnCreateMapping
		Description
	Author: v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CActiveRegistrationsHandler::OnCreateMapping(ITFSNode *pNode)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = hrOK;
	
	// Object gets deleted when the page is destroyed
	SPIComponentData spComponentData;
	m_spNodeMgr->GetComponentData(&spComponentData);

	// HACK WARNING: because we do this in a MMC provided property sheet, we
	// need to invoke the correct mechanism so we get a callback handle.
	// otherwise when we create the static mapping, we're on another thread
	// and it can do bad things when we try to update the UI
	hr = DoPropertiesOurselvesSinceMMCSucks(pNode, spComponentData, _T(""));
	
	return hr;
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::OnDatabaseLoadStart
		Description
 ---------------------------------------------------------------------------*/
HRESULT 
CActiveRegistrationsHandler::OnDatabaseLoadStart(ITFSNode *pNode)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT				hr = hrOK;
	SPITFSNode			spNode;
	SPITFSNodeHandler	spHandler;
	ITFSQueryObject *	pQuery = NULL;
	SPITFSNode          spServerNode;
	DWORD               dwIP;
	CString             strIP;
    BOOL                fReload = FALSE;
    int                 nCount, pos;
	CTypeFilterInfo		typeFilterInfo;

    pNode->GetParent(&spServerNode);
    CWinsServerHandler * pServer = GETHANDLER(CWinsServerHandler, spServerNode);

   	dwIP = pServer->GetServerIP();

    if (!m_bExpanded)
    {
        m_dlgLoadRecords.ResetFiltering();
    }

    if (m_dlgLoadRecords.m_pageTypes.m_arrayTypeFilter.GetSize() == 0)
    {
        fReload = TRUE;

        // initialize the record type filter array
        for (nCount = 0; nCount < m_NameTypeMap.GetSize(); nCount++)
        {
            if (m_NameTypeMap[nCount].dwWinsType == -1)
			{
				typeFilterInfo.dwType = m_NameTypeMap[nCount].dwNameType;
				typeFilterInfo.fShow = TRUE;
                m_dlgLoadRecords.m_pageTypes.m_arrayTypeFilter.Add(typeFilterInfo);
			}
        }
    }

    // if a download is running, ask the user if they want to stop it
    if (m_winsdbState != WINSDB_NORMAL)
    {
        OnDatabaseLoadStop(pNode);
    }

    // bring up the Owner Dialog 
    // fill in the owner page info
    GetOwnerInfo(m_dlgLoadRecords.m_pageOwners.m_ServerInfoArray);
    // fill in the type filter page info
    m_dlgLoadRecords.m_pageTypes.m_pNameTypeMap = &m_NameTypeMap;
    // save the original number of owners. In case this is one
    // and several other are added, will reload the database.

    //------------------Display popup ----------------------------	
    {
        // for some reason, when activating the theme, the "load records" dialog
        // doesn't show the state boxes images in the "owner list" and "type list".
        CThemeContextActivator themeActivator;

        if (m_dlgLoadRecords.DoModal() != IDOK)
		    return hrFalse;
    }

	SetLoadedOnce(pNode);
	m_fDbLoaded = TRUE;

	Lock();

	MakeIPAddress(dwIP, strIP);

	// stop the database if we were loading or create one if we haven't yet
    if (!m_spWinsDatabase)
    {
        CORg (CreateWinsDatabase(strIP, strIP, &m_spWinsDatabase));
        fReload = TRUE;
    }
    else
    {
        CORg (m_spWinsDatabase->Stop());
    }
    
    //~~~~~~~~~~~~~~~~~~~~~~~~~ need to revise the logic for reloading ~~~~~~~~~~~~~~~~~~~~~~~~~
    //
    // we try to make the decision whether the records we already loaded (if we did) are sufficient
    // to apply the new filters: set fReload to TRUE if reload is needed or to FALSE otherwise.
    // Since fReload could have been already set go into this process only if reloading is not yet
    // decided. Assume reload will eventualy be decided and break out as soon as this is confirmed
    // If the end of the "while" block is reached, this means database doesn't need to be reloaded
    // so break out.
    while(!fReload)
    {
        BOOL bDbCacheEnabled;
        // assume a reload will be needed
        fReload = TRUE;
        // if reload imposed by external causes (first time call or refresh was done), break out
        if (m_fForceReload)
            break;

        m_spWinsDatabase->GetCachingFlag(&bDbCacheEnabled);

        if (bDbCacheEnabled)
        {
            BOOL bReload;

            // currently the database is loaded with "enable caching" checked. This means:
            // if db "owner" api setting is set (non 0xffffffff) then
            //     all records owned by "owner" are loaded (case 1)
            // else --> "owner" is set to "multiple" (0xffffffff)
            //     if db "name" api is set (non null) then
            //         all records prefixed with "name" are loaded (case 2)
            //     else
            //         entire database is loaded (case 3)
            //     .
            // .
            // if (case 1) applies then
            //     if we want to filter on a different or no owner then
            //         reload SUGGESTED
            //     else
            //         reload NOT SUGGESTED
            //     .
            // else if (case 2) applies then
            //     if we want to filter on a different or no name prefix then
            //         reload SUGGESTED
            //     else
            //         reload NOT SUGGESTED
            //     .
            // else if (case 3) applies)
            //     reload NOT SUGGESTED
            // .
            //         
            // This logic is followed in CheckApiInfoCovered call from below
            m_spWinsDatabase->ReloadSuggested(
                    m_dlgLoadRecords.m_pageOwners.GetOwnerForApi(),
                    m_dlgLoadRecords.m_pageIpAddress.GetNameForApi(),
                    &bReload);

            if (bReload)
                break;
        }
        else
        {
            // currently the database is loaded without "enable caching" checked. This means:
            // the records currentLy in the database match all the filters as they were specified
            // in the filtering dialog before it was popped-up. Consequently, if any of these
            // filters (owner, name, ipaddr, type) changed, database has to be reloaded. Otherwise,
            // since the filters are the same.
            if (m_dlgLoadRecords.m_pageIpAddress.m_bDirtyName ||
                m_dlgLoadRecords.m_pageIpAddress.m_bDirtyAddr ||
                m_dlgLoadRecords.m_pageIpAddress.m_bDirtyMask ||
                m_dlgLoadRecords.m_pageOwners.m_bDirtyOwners ||
                m_dlgLoadRecords.m_pageTypes.m_bDirtyTypes)
                break;
        }

        // if we are here it means reload is not actually needed, so reset the flag back and
        // break the loop
        fReload = FALSE;
        break;
    };

    // if the final decision is to reload the db, then prepare this operation
    if (fReload)
    {
        m_fForceReload = FALSE;
        m_spWinsDatabase->Clear();
        // set the Api parameters to be used by the database
        m_spWinsDatabase->SetApiInfo(
            m_dlgLoadRecords.m_pageOwners.GetOwnerForApi(),
            m_dlgLoadRecords.m_pageIpAddress.GetNameForApi(),
            m_dlgLoadRecords.m_bEnableCache);
    }
    //
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    UpdateCurrentView(pNode);

    // start loading records if necessary
    if (fReload)
    {
		// start loading records
        CORg (m_spWinsDatabase->Init());

        // update our internal state
		m_winsdbState = WINSDB_LOADING;

        // update the node's icon
		OnChangeState(pNode);

		// kick off the background thread to do the timer updates
		pQuery = OnCreateQuery(pNode);
		Assert(pQuery);

		Verify(StartBackgroundThread(pNode, 
									m_spTFSCompData->GetHiddenWnd(), 
									pQuery));
		
		pQuery->Release();
    }

    // fill in any record type filter information
    nCount = (int)m_dlgLoadRecords.m_pageTypes.m_arrayTypeFilter.GetSize();
    m_spWinsDatabase->ClearFilter(WINSDB_FILTER_BY_TYPE);
	for (pos = 0; pos < nCount; pos++)
	{
        m_spWinsDatabase->AddFilter(WINSDB_FILTER_BY_TYPE, 
									m_dlgLoadRecords.m_pageTypes.m_arrayTypeFilter[pos].dwType, 
									m_dlgLoadRecords.m_pageTypes.m_arrayTypeFilter[pos].fShow,
                                    NULL);
	}

    // fill in any owner filter information
    nCount = (int)m_dlgLoadRecords.m_pageOwners.m_dwaOwnerFilter.GetSize();
    m_spWinsDatabase->ClearFilter(WINSDB_FILTER_BY_OWNER);
    for (pos = 0; pos < nCount; pos++)
    {
        m_spWinsDatabase->AddFilter(WINSDB_FILTER_BY_OWNER,
                                    m_dlgLoadRecords.m_pageOwners.m_dwaOwnerFilter[pos],
                                    0,
                                    NULL);
    }

    // fill in any ip address filter information
    m_spWinsDatabase->ClearFilter(WINSDB_FILTER_BY_IPADDR);
    if (m_dlgLoadRecords.m_pageIpAddress.m_bFilterIpAddr)
    {
        nCount = (int)m_dlgLoadRecords.m_pageIpAddress.m_dwaIPAddrs.GetSize();
        for (pos = 0; pos < nCount; pos++)
        {
            m_spWinsDatabase->AddFilter(WINSDB_FILTER_BY_IPADDR,
                                        m_dlgLoadRecords.m_pageIpAddress.m_dwaIPAddrs[pos],
                                        m_dlgLoadRecords.m_pageIpAddress.GetIPMaskForFilter(pos),
                                        NULL);
        }
    }

    // fill in any name filter information
    m_spWinsDatabase->ClearFilter(WINSDB_FILTER_BY_NAME);
    if (m_dlgLoadRecords.m_pageIpAddress.m_bFilterName)
    {
        m_spWinsDatabase->AddFilter(WINSDB_FILTER_BY_NAME,
                                    m_dlgLoadRecords.m_pageIpAddress.m_bMatchCase,
                                    0,
                                    m_dlgLoadRecords.m_pageIpAddress.m_strName);
    }

    // now that the filters are all set database can start downloading
    if (fReload)
        // start loading records
        CORg (m_spWinsDatabase->Start());


	BEGIN_WAIT_CURSOR
    Sleep(100);

	// filter any records that may have been downloaded before we set the
	// filter information (in the case when we had to reload the database).  
	// any records that come in after we set the 
	// filter info will be filtered correctly.
    m_spWinsDatabase->FilterRecords(WINSDB_FILTER_BY_TYPE, 0,0);
	
	END_WAIT_CURSOR

	if (fReload)
	{
		// do the initial update of the virutal listbox
	    OnHaveData(pNode, 0, QDATA_TIMER);
	}
	else
    {
		// just a filter changed, just need to update the result pane
		UpdateListboxCount(pNode);
    }


COM_PROTECT_ERROR_LABEL;
    return hr;
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::OnDatabaseLoadStop
		Description
 ---------------------------------------------------------------------------*/
HRESULT 
CActiveRegistrationsHandler::OnDatabaseLoadStop(ITFSNode *pNode)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT				hr = hrOK;
    CThemeContextActivator themeActivator;

	if (IDYES != AfxMessageBox(IDS_STOP_DB_LOAD_CONFIRM, MB_YESNO))
    {
		return hrFalse;
    }

	if (m_spWinsDatabase)
	{
		CORg (m_spWinsDatabase->Stop());
        
        DatabaseLoadingCleanup();
        UpdateListboxCount(pNode);
    }

    m_fForceReload = TRUE;

COM_PROTECT_ERROR_LABEL;
    return hr;
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::OnGetResultViewType
		Description
 ---------------------------------------------------------------------------*/
HRESULT 
CActiveRegistrationsHandler::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = S_FALSE;

	if (cookie != NULL)
	{
        // call the base class to see if it is handling this
        if (CMTWinsHandler::OnGetResultViewType(pComponent, cookie, ppViewType, pViewOptions) != S_OK)
        {
			*pViewOptions = MMC_VIEW_OPTIONS_OWNERDATALIST |
							MMC_VIEW_OPTIONS_MULTISELECT;
			
			hr = S_FALSE;
		}
	}

    return hr;
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::GetVirtualImage
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
int 
CActiveRegistrationsHandler::GetVirtualImage
(
    int     nIndex
)
{
    HRESULT     hr = hrOK;
    WinsRecord  ws;
	HROW        hrow;
    int         nImage = ICON_IDX_CLIENT;

    COM_PROTECT_TRY
    {
        if (!m_pCurrentDatabase)
            return -1;

        CORg (m_pCurrentDatabase->GetHRow(nIndex, &hrow));
        CORg (m_pCurrentDatabase->GetData(hrow, &ws));

        if (HIWORD(ws.dwType) != WINSINTF_E_UNIQUE)
        {
            nImage = ICON_IDX_CLIENT_GROUP;
        }

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return nImage;
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::GetVirtualString
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
LPCWSTR 
CActiveRegistrationsHandler::GetVirtualString
(
    int     nIndex,
    int     nCol
)
{
	HRESULT hr;
	int nCount;

	if (m_pCurrentDatabase)
	{
		// check if nIndex is within limits, if not crashes when the last 
		// record deleted and properties chosen.
		m_pCurrentDatabase->GetCurrentCount(&nCount);

		// 0 based index
		if (nIndex < 0 || nIndex >= nCount)
        {
			return NULL;
        }
	}

    // check our cache to see if we have this one.
    WinsStrRecord * pwsr = m_RecList.FindItem(nIndex);
    if (pwsr == NULL)
    {
        Trace1("ActRegHandler::GetVirtualString - Index %d not in string cache\n", nIndex);
        
        // doesn't exist in our cache, need to add this one.
    	pwsr = BuildWinsStrRecord(nIndex);
		if (pwsr)
			m_RecList.AddTail(pwsr);
    }
    
	if (pwsr)
	{
		switch (nCol)
		{
			case ACTREG_COL_NAME:
				return pwsr->strName;
				break;

			case ACTREG_COL_TYPE:
				return pwsr->strType;
				break;

			case ACTREG_COL_IPADDRESS:
				return pwsr->strIPAdd;
				break;

			case ACTREG_COL_STATE:
				return pwsr->strActive;
				break;

			case ACTREG_COL_STATIC:
				return pwsr->strStatic;
				break;

			case ACTREG_COL_OWNER:
				return pwsr->strOwner;
				break;

            case ACTREG_COL_VERSION:
				return pwsr->strVersion;
				break;

			case ACTREG_COL_EXPIRATION:
				return pwsr->strExpiration;
				break;

			default:
				Panic0("ActRegHandler::GetVirtualString - Unknown column!\n");
				break;
		}
	}

	return NULL;
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::BuildWinsStrRecord
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
WinsStrRecord * 
CActiveRegistrationsHandler::BuildWinsStrRecord(int nIndex)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	int nCount;
	HRESULT hr = hrOK;
    WinsStrRecord * pwsr = NULL;
    WinsRecord ws;
	HROW hrow;
	CString strTemp;

    if (!m_pCurrentDatabase)
    {
        return NULL;
    }

    if (FAILED(m_pCurrentDatabase->GetHRow(nIndex, &hrow)))
		return NULL;
	
	if (FAILED(m_pCurrentDatabase->GetData(hrow, &ws)))
		return NULL;
    
	COM_PROTECT_TRY
    {
        pwsr = new WinsStrRecord;

        // set the index for this record
        pwsr->nIndex = nIndex;

        // build the name string
		CleanNetBIOSName(ws.szRecordName,
                         pwsr->strName,
				         TRUE,              // Expand
						 TRUE,              // Truncate
						 IsLanManCompatible(), 
						 TRUE,              // name is OEM
						 FALSE,             // No double backslash
                         ws.dwNameLen);

        // now the type
		CString strValue;
		strValue.Format(_T("[%02Xh] "), 
							((int) ws.szRecordName[15] & 0x000000FF));
  	
		CString strName;
		DWORD dwNameType = (0x000000FF & ws.szRecordName[15]);

        m_NameTypeMap.TypeToCString(dwNameType, MAKELONG(HIWORD(ws.dwType), 0), strName);
		
		pwsr->strType = strValue + strName;

        // IP address
		// Gets changed in the case of static records of the type Special Group,
		// where the first IP address in the list of IP addresses is of the Owner
        if ( (ws.dwState & WINSDB_REC_UNIQUE) ||
             (ws.dwState & WINSDB_REC_NORM_GROUP) )
        {
			MakeIPAddress(ws.dwIpAdd[0], pwsr->strIPAdd);
        }
        else
        {
            if (ws.dwNoOfAddrs > 0)
            {
                if (ws.dwIpAdd[1] == 0)
                {
                    pwsr->strIPAdd.Empty();
                }
                else
                {
    			    MakeIPAddress(ws.dwIpAdd[1], pwsr->strIPAdd);
                }
            }
            else
            {
    			pwsr->strIPAdd.Empty();
            }
        }

        // active status
        GetStateString(ws.dwState, pwsr->strActive);

        // static flag
	    if (ws.dwState & WINSDB_REC_STATIC)
        {
		    pwsr->strStatic =  _T("x");
        }
	    else
        {
            pwsr->strStatic =  _T("");
        }

        // expiration time
		if (ws.dwExpiration == INFINITE_EXPIRATION)
		{
			Verify(pwsr->strExpiration.LoadString(IDS_INFINITE));
		}
		else
		{	
            CTime time(ws.dwExpiration);
            FormatDateTime(pwsr->strExpiration, time);
		}
		
        // version
		GetVersionInfo(ws.liVersion.LowPart, 
						ws.liVersion.HighPart, 
						pwsr->strVersion);

		// owner
		if (m_Config.FSupportsOwnerId())
		{
			MakeIPAddress(ws.dwOwner, pwsr->strOwner);
		}
	}
    COM_PROTECT_CATCH

    return pwsr;
}

/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::GetStateString
		Description	Returns the state of the record, Active, Tomstoned, 
		realeased or deleted
	Author: v-shubk
 ---------------------------------------------------------------------------*/
void CActiveRegistrationsHandler::GetStateString(DWORD dwState, 
												 CString& strState)
{
    if (dwState & WINSDB_REC_ACTIVE )
    {
	    strState.LoadString(IDS_RECORD_STATE_ACTIVE);
    }
	else
    if (dwState & WINSDB_REC_DELETED )
    {
	    strState.LoadString(IDS_RECORD_STATE_DELETED);
    }
	else
    if (dwState & WINSDB_REC_RELEASED )
    {
	    strState.LoadString(IDS_RECORD_STATE_RELEASED);
    }
	else
    if (dwState & WINSDB_REC_TOMBSTONE )
    {
	    strState.LoadString(IDS_RECORD_STATE_TOMBSTONED);
    }
	else
    {
	    strState.LoadString(IDS_RECORD_STATE_UNKNOWN);
    }
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::GetStateString
		Description Returns the static type for the record, Unique, 
					Multihomed, Inetrne Group, Normal Group, Multihomed
	Author: v-shubk
 ---------------------------------------------------------------------------*/
void CActiveRegistrationsHandler::GetStaticTypeString(DWORD dwState, 
													  CString& strStaticType)
{
    if (dwState & WINSDB_REC_UNIQUE )
    {
	    strStaticType = g_strStaticTypeUnique;
    }
	else
    if (dwState & WINSDB_REC_SPEC_GROUP )
    {
	    strStaticType =  g_strStaticTypeDomainName;
    }
	else
    if (dwState & WINSDB_REC_MULTIHOMED )
    {
	    strStaticType =  g_strStaticTypeMultihomed;
    }
	else
    if (dwState & WINSDB_REC_NORM_GROUP )
    {
	    strStaticType =  g_strStaticTypeGroup;
    }
	else
    {
	    strStaticType =  g_strStaticTypeUnknown;
    }
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::GetVersionInfo
		Description Gives the version INfo as string in Hex Notation
	Author: v-shubk
 ---------------------------------------------------------------------------*/
void CActiveRegistrationsHandler::GetVersionInfo(LONG lLowWord, 
												 LONG lHighWord, 
												 CString& strVersionCount)
{
	strVersionCount.Empty();

	TCHAR sz[20];
    TCHAR *pch = sz;
    ::wsprintf(sz, _T("%08lX%08lX"), lHighWord, lLowWord);
    // Kill leading zero's
    while (*pch == '0')
    {
        ++pch;
    }
    // At least one digit...
    if (*pch == '\0')
    {
        --pch;
    }

    strVersionCount = pch;
}

BOOL
CActiveRegistrationsHandler::IsLanManCompatible()
{
    BOOL fCompatible = TRUE;

    if (m_spServerNode)
    {
        CWinsServerHandler * pServer = GETHANDLER(CWinsServerHandler, m_spServerNode);

        fCompatible = (pServer->m_dwFlags & FLAG_LANMAN_COMPATIBLE) ? TRUE : FALSE;
    }

    return fCompatible;
}

//
// Convert the netbios name to a displayable format, with
// beginning slashes, the unprintable characters converted
// to '-' characters, and the 16th character displayed in brackets.
// Convert the string to ANSI/Unicode before displaying it.
//
//
void
CActiveRegistrationsHandler::CleanNetBIOSName
(
    LPCSTR      lpszSrc,
    CString &   strDest,
    BOOL        fExpandChars,
    BOOL        fTruncate,
    BOOL        fLanmanCompatible,
    BOOL        fOemName,
    BOOL        fWackwack,
    int         nLength
)
{
	static CHAR szWacks[] = "\\\\";
    BYTE ch16 = 0;

	if (!lpszSrc || 
		(strcmp(lpszSrc, "") == 0) )
	{
		strDest = _T("---------");
        return;
	}

    int nLen, nDisplayLen;
    int nMaxDisplayLen = fLanmanCompatible ? 15 : 16;  

    if (!fWackwack && fLanmanCompatible)
    {
        //
        // Don't want backslahes, but if they do exist,
        // remove them.
        //
        if (!::strncmp(lpszSrc, szWacks, ::strlen(szWacks)))
        {
            lpszSrc += ::strlen(szWacks);
            if (nLength)
            {
                nLength -= 2;
            }
        }
    }

    if ((nDisplayLen = nLen = nLength ? nLength : ::strlen(lpszSrc)) > 15)
    {
        ch16 = (BYTE)lpszSrc[15];
        nDisplayLen = fTruncate ? nMaxDisplayLen : nLen;
    }

    char szTarget[MAX_PATH] = {0};
    char szRestore[MAX_PATH] = {0};
    char * pTarget = &szTarget[0];

    if (fWackwack)
    {
        ::strcpy(pTarget, szWacks);
        pTarget += ::strlen(szWacks);
    }

	if (lpszSrc == NULL)
	{
		int i = 1;
	}

    if (fOemName)
    {
        ::OemToCharBuffA(lpszSrc, pTarget, nLen);
    }
    else
    {
        ::memcpy(pTarget, lpszSrc, nLen);
    }

    int n = 0;
    while (n < nDisplayLen)
    {
        if (fExpandChars)
        {
#ifdef FE_SB
            if (::IsDBCSLeadByte(*pTarget))
            {
                ++n;
                ++pTarget;
            }
            else if (!WinsIsPrint(pTarget))
#else
            if (!WinsIsPrint(pTarget))
#endif // FE_SB
            {
                *pTarget = BADNAME_CHAR;
            }
        }

        ++n;
        ++pTarget;
    }

    if (fLanmanCompatible)
    {
        //
        // Back up over the spaces.  
        //
        while (*(--pTarget) == ' ') /**/ ;
        ++pTarget;
    }

    // if  there's a scope name attached, append the scope name 
	// to the strTarget before returning.

	// check the length of lpSrc, if greater than NetBIOS name 
	// length, it has a scope name attached
	if (nLength > 16)
	{
        if (lpszSrc[0x10] == '.')
        {
            ::OemToCharBuffA(&lpszSrc[0x10], szRestore, sizeof(szRestore));

            memcpy(pTarget, szRestore, nLength - 16);
            pTarget += (nLength - 16);
        }
	}

    *pTarget = '\0';

    // convert the string to unicode.  We've already done the oem to ansi
    // conversion so use the Ansi code page now
    MBCSToWide(szTarget, strDest, CP_ACP);
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::CacheHint
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CActiveRegistrationsHandler::CacheHint
(
    int nStartIndex, 
    int nEndIndex
)
{
	HRESULT hr = hrOK;
	HROW hrow;

    Trace2("CacheHint - Start %d, End %d\n", nStartIndex, nEndIndex);
    
    m_RecList.RemoveAllEntries();
	
	WinsRecord ws;
	WinsStrRecord * pwsr;

	for (int i = nStartIndex; i <= nEndIndex; i++)
	{
		pwsr = BuildWinsStrRecord(i);
		if (pwsr)
			m_RecList.AddTail(pwsr);
    }

	return hr;
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::SortItems
		Description
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CActiveRegistrationsHandler::SortItems
(
    int     nColumn, 
    DWORD   dwSortOptions, 
    LPARAM  lUserParam
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    CThemeContextActivator themeActivator;
	HRESULT hr = hrOK;

    WINSDB_STATE uState = WINSDB_NORMAL;
    if (!m_pCurrentDatabase)
    {
        return hr;
    }

    m_pCurrentDatabase->GetCurrentState(&uState);
	if (uState != WINSDB_NORMAL)
	{
		AfxMessageBox(IDS_RECORDS_DOWNLOADING, MB_OK|MB_ICONINFORMATION);
		return hr;
	}

	// put up the busy dialog
	CSortWorker * pWorker = new CSortWorker(m_pCurrentDatabase, 
											nColumn, 
											dwSortOptions);

    CLongOperationDialog dlgBusy(pWorker, IDR_AVI2);

	dlgBusy.LoadTitleString(IDS_SNAPIN_DESC);
    dlgBusy.LoadDescriptionString(IDS_SORTING);

	// disable the system menu and the cancel buttons
	dlgBusy.EnableCancel(FALSE);

	dlgBusy.DoModal();  
	
	return hr;
}

/*!--------------------------------------------------------------------------
	CActiveRegistrationsHandler::SetVirtualLbSize
		Sets the virtual listbox count.  Over-ride this if you need to 
        specify and options.
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CActiveRegistrationsHandler::SetVirtualLbSize
(
    ITFSComponent * pComponent,
    LPARAM          data
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = hrOK;
    SPIResultData spResultData;
    CString strDescBarText;
	CString strData;
    ULARGE_INTEGER nullData;
    ULARGE_INTEGER *pData = (ULARGE_INTEGER *)data;

    nullData.HighPart = nullData.LowPart = 0;
    pData = (data == NULL)? &nullData : (ULARGE_INTEGER*)data;

    // just to avoid those cases when filtered shows up larger than scanned
    if (pData->LowPart < pData->HighPart)
        pData->HighPart = pData->LowPart;

	strDescBarText.Empty();
    strDescBarText.LoadString(IDS_RECORDS_FILTERED);
    strData.Format(_T(" %d -- "), pData->HighPart);
    strDescBarText += strData;
    strData.LoadString(IDS_RECORDS_SCANNED);
    strDescBarText += strData;
    strData.Format(_T(" %d"), pData->LowPart);
    strDescBarText += strData;

    CORg (pComponent->GetResultData(&spResultData));

    if (pData->HighPart == 0)
    {
        //CORg (spResultData->DeleteAllRsltItems());
        CORg (spResultData->SetItemCount((int) pData->HighPart, MMCLV_UPDATE_NOSCROLL));
    }
    else
    {
        CORg (spResultData->SetItemCount((int) pData->HighPart, MMCLV_UPDATE_NOSCROLL));
    }
    
    CORg (spResultData->SetDescBarText((LPTSTR) (LPCTSTR) strDescBarText));

Error:
    return hr;
}


/*!--------------------------------------------------------------------------
	CActiveRegistrationsHandler::UpdateCurrentView
        Updates the current view -- the MenuButton control and the result 
        pane.

  Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CActiveRegistrationsHandler::UpdateCurrentView
(
    ITFSNode *  pNode
)
{
    HRESULT             hr = hrOK;
    SPIComponentData	spCompData;
	SPIConsole			spConsole;
    IDataObject*		pDataObject;

    // update our current database to point to the correct one
    m_pCurrentDatabase = m_spWinsDatabase;
    
    // update our current database to point to the correct one
    m_spWinsDatabase->SetActiveView(WINSDB_VIEW_FILTERED_DATABASE);

    // Need to tell all of the views up update themselves with the new state.
    m_spNodeMgr->GetComponentData(&spCompData);

    CORg ( spCompData->QueryDataObject((MMC_COOKIE) pNode, 
										CCT_RESULT, 
										&pDataObject) );

    CORg ( m_spNodeMgr->GetConsole(&spConsole) );

    pDataObject->Release();

    // update the listbox with the correct count for this view
    UpdateListboxCount(pNode);

	UpdateVerbs(pNode);

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CActiveRegistrationsHandler::CompareRecName
		Checks if the name matches the Find record criterion    
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
BOOL 
CActiveRegistrationsHandler::CompareRecName(LPSTR szNewName)
{
    // convert the MBCS name to a wide string using the OEM
    // code page so we can do the compare.
    CString strTemp;
    MBCSToWide(szNewName, strTemp, WINS_NAME_CODE_PAGE);

    // when some invalid records get passed
	if (strTemp.IsEmpty())
    {
		return FALSE;
    }

    CString strFindNameU = m_strFindName;

    if (!m_fMatchCase)
    {
        strTemp.MakeUpper();
    }

	int nLen = strFindNameU.GetLength();

	for (int nPos = 0; nPos < nLen; nPos++)
	{
		if (strFindNameU[nPos] == _T('*'))
        {
			break;
        }

		// the passed record has a smaller string length
		if (nPos >= strTemp.GetLength())
        {
			return FALSE;
        }

		if (strTemp[nPos] != strFindNameU[nPos])
        {
            return FALSE;
        }
	}

	return TRUE;
}


/*!--------------------------------------------------------------------------
	CActiveRegistrationsHandler::DeleteRegistration
        Removes a registration from the server and the virtual listbox.
        Need to remove the entry from both the find database and the
        full database.
    Author: v-shubk
 ---------------------------------------------------------------------------*/
HRESULT
CActiveRegistrationsHandler::DeleteRegistration
(
	ITFSComponent * pComponent,
    int             nIndex
)
{
	HRESULT             hr = hrOK;
    DWORD               err = 0;
    CVirtualIndexArray  arraySelectedIndicies;
    int                 i;
    int                 nCurrentCount;
	WinsRecord			ws;
	int					nCount;
	SPIConsole			spConsole;
	LPDATAOBJECT		pDataObject= NULL;
	BOOL				fDelete;

	// ask whether to delete or tombstone the record
	CDeleteRecordDlg    dlgDel;
    CThemeContextActivator themeActivator;
	SPIResultData       spResultData;
	SPITFSNode          spNode;
	    
	CORg (pComponent->GetResultData(&spResultData));

	// build a list of the selected indicies in the virtual listbox
    CORg (BuildVirtualSelectedItemList(pComponent, &arraySelectedIndicies));
	nCount = (int)arraySelectedIndicies.GetSize();

    dlgDel.m_fMultiple = (nCount > 1) ? TRUE : FALSE;

	if (IDOK != dlgDel.DoModal())
    {
		return hrOK;
    }
	    
	fDelete = (dlgDel.m_nDeleteRecord == 0);

	BEGIN_WAIT_CURSOR

	for (i = 0; i < nCount; i++)
    {
		HROW hrowDel;

		// remove each selected index
		int nDelIndex = arraySelectedIndicies.GetAt(nCount -1 - i);

		// from internal storage
		CORg(m_spWinsDatabase->GetHRow(nDelIndex, &hrowDel));
		CORg(m_spWinsDatabase->GetData(hrowDel, &ws));
                
        if (fDelete)
        {
            // delete this record
			err = DeleteMappingFromServer(pComponent, &ws, nDelIndex);
        }
		else
        {
    		// tombstone the record
			err = TombstoneRecords(pComponent, &ws);
        }

		// if a particular record could not be deleted, see if they want to cancel
		if (err != ERROR_SUCCESS)
        {
            // put up
			if (WinsMessageBox(err, MB_OKCANCEL) == IDCANCEL)
            {
                break;
            }
        }
        else
        {
            // remove from local storage if we are deleting this record
            if (fDelete)
            {
			    CORg(m_spWinsDatabase->DeleteRecord(hrowDel));
            }

		    // remove from UI if delete is selected, othewise update the state (tombstone)
			if (dlgDel.m_nDeleteRecord == 0)
            {
				CORg(spResultData->DeleteItem(nDelIndex, 0));
            }
			else
            {
				UpdateRecord(pComponent, &ws, nDelIndex);
            }
        }
	}

	END_WAIT_CURSOR

	// get the actreg node and redraw the list box
	pComponent->GetSelectedNode(&spNode);

    // now set the count.. this effectively redraws the contents
    CORg (m_pCurrentDatabase->GetCurrentCount(&nCurrentCount));
	
	UpdateListboxCount(spNode);

	// if we are tombstoning, then there will still be selections
	// in the result pane.  In this case we need to pass in NULL
	// for the node type so that the verbs get updated correctly.
	if (!fDelete)
		spNode.Set(NULL);

	// update the cuurent view
    UpdateCurrentView(spNode);
		 
Error:
    return hr;
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler:: AddMapping(ITFSNode* pNode)
		Adds a new Mapping to the server
	Author: v-shubk
---------------------------------------------------------------------------*/
HRESULT 
CActiveRegistrationsHandler::AddMapping(ITFSNode* pNode)
{
	HRESULT hr = hrOK;

	DWORD err = ERROR_SUCCESS;

	// get the server
	SPITFSNode spServerNode;
    pNode->GetParent(&spServerNode);

    CWinsServerHandler * pServer = GETHANDLER(CWinsServerHandler, spServerNode);

	BOOL fInternetGroup = FALSE;

	if (m_strStaticMappingType.CompareNoCase(g_strStaticTypeInternetGroup) == 0)
    {
		fInternetGroup = TRUE;
    }

	CString strName(m_strStaticMappingName);

	// check if valid NetBIOSNAme
	if (pServer->IsValidNetBIOSName(strName, IsLanManCompatible(), FALSE))
	{
		m_Multiples.SetNetBIOSName(m_strStaticMappingName);
        m_Multiples.SetNetBIOSNameLength(m_strStaticMappingName.GetLength());

		int nMappings = 0;
        int i;

		switch(m_nStaticMappingType)
        {
            case WINSINTF_E_UNIQUE:
            case WINSINTF_E_NORM_GROUP:
				{

                nMappings = 1;
                LONG l;

              	m_Multiples.SetIpAddress(m_lArrayIPAddress.GetAt(0));
			}
                break;

            case WINSINTF_E_SPEC_GROUP:
            case WINSINTF_E_MULTIHOMED:
                nMappings = (int)m_lArrayIPAddress.GetSize();
                ASSERT(nMappings <= WINSINTF_MAX_MEM);
                if (!fInternetGroup && nMappings == 0)
                {
                    //return E_FAIL;
                }
                for (i = 0; i < nMappings; ++i)
                {
                    m_Multiples.SetIpAddress(i,m_lArrayIPAddress.GetAt(i) );
                }
                break;

            default:
                ASSERT(0 && "Invalid mapping type!");
        }

		BEGIN_WAIT_CURSOR

		// add to the server
		err = AddMappingToServer(pNode,
								m_nStaticMappingType, 
								nMappings, 
								m_Multiples);

		END_WAIT_CURSOR

		if (err == ERROR_SUCCESS)
        {
            //
            // Added succesfully
            //
        }
        else
        {
            //
            // WINS disallowed the mapping.  Put up the
            // error message, and highlight the name
            //
            return HRESULT_FROM_WIN32(err);
        }
	}

    return hr;
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::EditMappingToServer(
									ITFSNode* pNode,
									int nType,
									int nCount,
									CMultipleIpNamePair& mipnp,
									BOOL fEdit,
									WinsRecord *pRecord
									)

	Edits the maping stored in the server database, WinsRecordAction is called
	
	Author:	v-shubk
---------------------------------------------------------------------------*/
HRESULT 
CActiveRegistrationsHandler::EditMappingToServer(
									ITFSNode* pNode,
									int nType,
									int nCount,
									CMultipleIpNamePair& mipnp,
									BOOL fEdit,      // Editing existing mapping?
									WinsRecord *pRecord
									)
{
	SPITFSNode spNode;
	pNode->GetParent(&spNode);

	CWinsServerHandler* pServer = GETHANDLER(CWinsServerHandler, spNode);

	HRESULT hr = hrOK;

	WINSINTF_RECORD_ACTION_T RecAction;
	PWINSINTF_RECORD_ACTION_T pRecAction;

	DWORD dwLastStatus;

    ASSERT(nType >= WINSINTF_E_UNIQUE && nType <= WINSINTF_E_MULTIHOMED);

	ZeroMemory(&RecAction, sizeof(RecAction));

    RecAction.TypOfRec_e = nType;
    RecAction.Cmd_e = WINSINTF_E_INSERT;
    RecAction.pAdd = NULL;
    RecAction.pName = NULL;
    pRecAction = &RecAction;

    if (nType == WINSINTF_E_UNIQUE ||
        nType == WINSINTF_E_NORM_GROUP)
    {
        RecAction.NoOfAdds = 1;
        RecAction.Add.IPAdd = (LONG)mipnp.GetIpAddress();
        RecAction.Add.Type = 0;
        RecAction.Add.Len = 4;
    }
    else
    {
        ASSERT(nCount <= WINSINTF_MAX_MEM);

        RecAction.pAdd = (WINSINTF_ADD_T *)::WinsAllocMem(
            sizeof(WINSINTF_ADD_T) * nCount);

        if (RecAction.pAdd == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        RecAction.NoOfAdds = nCount;
        int i;
        for (i = 0; i < nCount; ++i)
        {
            (RecAction.pAdd+i)->IPAdd = (LONG)mipnp.GetIpAddress(i);
            (RecAction.pAdd+i)->Type = 0;
            (RecAction.pAdd+i)->Len = 4;
        }

        RecAction.NodeTyp = WINSINTF_E_PNODE;
    }
    RecAction.fStatic = TRUE;

	// Don't copy the beginning slashes when adding.
    //
    int nLen = pRecord->dwNameLen;
    
    //
    // Must have at least enough room for 16 character string
    //
    RecAction.pName = (LPBYTE)::WinsAllocMem(nLen + 1);
    if (RecAction.pName == NULL)
    {
        if (RecAction.pAdd)
        {
            ::WinsFreeMem(RecAction.pAdd);
        }

        return ERROR_NOT_ENOUGH_MEMORY;
    }

	if (fEdit)
    {
        //
        // No need to convert if already existing in the database.
        //
		// convert to ASCII string and copy
         ::memcpy((char *)RecAction.pName,
                  (LPCSTR) pRecord->szRecordName,
                  nLen+1
                  );
		 RecAction.NameLen = nLen;
    }
    else
    {
        ::CharToOemBuff(mipnp.GetNetBIOSName(),
                    (char *)RecAction.pName,
                    nLen
                    );
    }

#ifdef WINS_CLIENT_APIS
    dwLastStatus = ::WinsRecordAction(pServer->GetBinding(), &pRecAction);
#else
	dwLastStatus = ::WinsRecordAction(&pRecAction);
#endif WINS_CLIENT_APIS

	if (RecAction.pName != NULL)
    {
        ::WinsFreeMem(RecAction.pName);
    }
    
    if (RecAction.pAdd != NULL)
    {
        ::WinsFreeMem(RecAction.pAdd);
    }

    return dwLastStatus;
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::AddMappingToServer(
									ITFSNode* pNode,
									int nType,
									int nCount,
									CMultipleIpNamePair& mipnp,
									BOOL fEdit      
									)
	Adds the cleaned record to the server, WinsRecordAction acalled with 
		WINSINTF_INSERT	option
	Author: v-shubk
---------------------------------------------------------------------------*/
DWORD 
CActiveRegistrationsHandler::AddMappingToServer(
									ITFSNode* pNode,
									int nType,
									int nCount,
									CMultipleIpNamePair& mipnp,
									BOOL fEdit      
									)
{
	HRESULT hr = hrOK;

	WINSINTF_RECORD_ACTION_T RecAction;
	PWINSINTF_RECORD_ACTION_T pRecAction;

	SPITFSNode spNode;
	pNode->GetParent(&spNode);

	CWinsServerHandler *pServer = GETHANDLER(CWinsServerHandler, spNode);

	DWORD dwLastStatus;

    ASSERT(nType >= WINSINTF_E_UNIQUE && nType <= WINSINTF_E_MULTIHOMED);

	ZeroMemory(&RecAction, sizeof(RecAction));

    RecAction.TypOfRec_e = nType;
    RecAction.Cmd_e = WINSINTF_E_INSERT;
    RecAction.pAdd = NULL;
    RecAction.pName = NULL;
    pRecAction = &RecAction;

    if (nType == WINSINTF_E_UNIQUE ||
        nType == WINSINTF_E_NORM_GROUP)
    {
        RecAction.NoOfAdds = 1;
        RecAction.Add.IPAdd = (LONG)mipnp.GetIpAddress();
        RecAction.Add.Type = 0;
        RecAction.Add.Len = 4;
    }
    else
    {
        ASSERT(nCount <= WINSINTF_MAX_MEM);

        RecAction.pAdd = (WINSINTF_ADD_T *)::WinsAllocMem(
            sizeof(WINSINTF_ADD_T) * nCount);

        if (RecAction.pAdd == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        RecAction.NoOfAdds = nCount;
        int i;
        for (i = 0; i < nCount; ++i)
        {
            (RecAction.pAdd+i)->IPAdd = (LONG)mipnp.GetIpAddress(i);
            (RecAction.pAdd+i)->Type = 0;
            (RecAction.pAdd+i)->Len = 4;
        }

        RecAction.NodeTyp = WINSINTF_E_PNODE;
    }
    
    RecAction.fStatic = TRUE;

    //
    // Don't copy the beginning slashes when adding.
    //
    int nLen = mipnp.GetNetBIOSNameLength();
    
    //
    // Must have at least enough room for 256 character string, 
	// includes the scope name too
    //
    RecAction.pName = (LPBYTE)::WinsAllocMem(257);
    if (RecAction.pName == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

	ZeroMemory(RecAction.pName, 257);

	LPSTR szTemp = (char *) alloca(100);
    CString strTemp = mipnp.GetNetBIOSName();

    // This should be OEM
    WideToMBCS(strTemp, szTemp, WINS_NAME_CODE_PAGE);
    
	nLen = strlen(szTemp);

	::memcpy((char *)RecAction.pName,
		  (LPCSTR) szTemp,
		  nLen+1
		  );

    if (nLen < 16)
    {
        if (nType == WINSINTF_E_SPEC_GROUP)
        {
            ::memset(RecAction.pName+nLen, (int)' ',16-nLen);
            RecAction.pName[15] = 0x1C;
            RecAction.pName[16] = '\0';
            RecAction.NameLen = nLen = 16;

			char szAppend[MAX_PATH];

			if (!m_strStaticMappingScope.IsEmpty())
			{
				AppendScopeName((LPSTR)RecAction.pName, (LPSTR)szAppend);
				strcpy((LPSTR)RecAction.pName, (LPSTR)szAppend);
				RecAction.NameLen = nLen = strlen((LPSTR)RecAction.pName);
			}

			pRecAction = &RecAction;
			
#ifdef WINS_CLIENT_APIS
            dwLastStatus = ::WinsRecordAction(pServer->GetBinding(), 
												&pRecAction);
#else
			dwLastStatus = ::WinsRecordAction(&pRecAction);
#endif WINS_CLIENT_APIS
			
			if (dwLastStatus != ERROR_SUCCESS)
            {
            }
			else
			{
				HRESULT hr = hrOK;

				// query the server for correct info
				PWINSINTF_RECORD_ACTION_T pRecAction1 = QueryForName(pNode, pRecAction);
				
				if (pRecAction1 == NULL)
                {
					//add it to the m_spWinsDatabase
					hr = AddToLocalStorage(pRecAction, pNode);
                }
				else
                {
    				// the record found and correct info displayed
					//add it to the m_spWinsDatabase
					hr = AddToLocalStorage(pRecAction1, pNode);
    				free(pRecAction1->pName);
                }

			}
        }
        else
        if (nType == WINSINTF_E_NORM_GROUP)
        {
            ::memset(RecAction.pName+nLen, (int)' ',16-nLen);
            RecAction.pName[15] = 0x1E;
            RecAction.pName[16] = '\0';
            RecAction.NameLen = nLen = 16;

			char szAppend[MAX_PATH];

			if (!m_strStaticMappingScope.IsEmpty())
			{
				AppendScopeName((LPSTR)RecAction.pName, (LPSTR)szAppend);
				strcpy((LPSTR)RecAction.pName, (LPSTR)szAppend);
				RecAction.NameLen = nLen = strlen((LPSTR)RecAction.pName);

			}

			pRecAction = &RecAction;

#ifdef WINS_CLIENT_APIS
            dwLastStatus = ::WinsRecordAction(pServer->GetBinding(),&pRecAction);
#else
			dwLastStatus = ::WinsRecordAction(&pRecAction);
#endif WINS_CLIENT_APIS

   		    if (dwLastStatus != ERROR_SUCCESS)
            {
            }
			else
			{
			    // query the server for correct info
				PWINSINTF_RECORD_ACTION_T pRecAction1 = QueryForName(pNode, pRecAction);
				if (pRecAction1 == NULL)
                {
					hr = AddToLocalStorage(pRecAction, pNode);
                }
    			else
                {
    				// the record found and correct info displayed
					//add it to the m_spWinsDatabase
					hr = AddToLocalStorage(pRecAction1, pNode);
    				free(pRecAction1->pName);
                }

			}
        }
        else
        {
            //
            // NOTICE:: When lanman compatible, the name is added
            //          three times - once each as worksta, server
            //          and messenger.  This will change when we allow
            //          different 16th bytes to be set.
            //
            if (IsLanManCompatible() && !fEdit)
            {
                BYTE ab[] = { 0x00, 0x03, 0x20 };
                ::memset(RecAction.pName + nLen, (int)' ', 16-nLen);
                int i;
                for (i = 0; i < sizeof(ab) / sizeof(ab[0]); ++i)
                {
					*(RecAction.pName+15) = ab[i];
                    *(RecAction.pName+16) = '\0';
                    RecAction.NameLen = nLen = 16;

					// append the scope name here, if present
				
					if (!m_strStaticMappingScope.IsEmpty())
					{
						// don't allow the scope to be appended if the 16th char is 00,
						// consistent with WinsCL
						if (i != 0)
						{
							char *lpAppend = new char [MAX_PATH];
					
							AppendScopeName((LPSTR)RecAction.pName, (LPSTR)lpAppend);
							strcpy((LPSTR)RecAction.pName, (LPSTR)lpAppend);
							RecAction.NameLen = nLen = strlen((LPSTR)RecAction.pName);

							delete [] lpAppend;
						}
					}
                    pRecAction = &RecAction;

#ifdef WINS_CLIENT_APIS
            dwLastStatus = ::WinsRecordAction(pServer->GetBinding(),&pRecAction);
#else
			dwLastStatus = ::WinsRecordAction(&pRecAction);
#endif WINS_CLIENT_APIS

					Trace1("WinsRecAction suceeded for '%lx'\n", ab[i]);

                    if (dwLastStatus != ERROR_SUCCESS)
                    {
                        break;
                    }
					else
					{
						// query the server for correct info
						PWINSINTF_RECORD_ACTION_T pRecAction1 = QueryForName(pNode, pRecAction);

						if (pRecAction1 == NULL)
                        {
							//add it to the m_spWinsDatabase
							hr = AddToLocalStorage(pRecAction, pNode);
                        }
						else
                        {
	    					// the record found and correct info displayed
    						//add it to the m_spWinsDatabase
							hr = AddToLocalStorage(pRecAction1, pNode);
    						free(pRecAction1->pName);
                        }
					}
                }
            }
            else
            {
                ::memset(RecAction.pName+nLen, (int)'\0',16-nLen);
                *(RecAction.pName+15) = 0x20;
                *(RecAction.pName+16) = '\0';
                RecAction.NameLen = nLen;

				char szAppend[MAX_PATH];

				if (!m_strStaticMappingScope.IsEmpty())
				{
					AppendScopeName((LPSTR)RecAction.pName, (LPSTR)szAppend);
					strcpy((LPSTR)RecAction.pName, (LPSTR)szAppend);
					RecAction.NameLen = nLen = strlen((LPSTR)RecAction.pName);
				}

#ifdef WINS_CLIENT_APIS
            dwLastStatus = ::WinsRecordAction(pServer->GetBinding(),&pRecAction);
#else
			dwLastStatus = ::WinsRecordAction(&pRecAction);
#endif WINS_CLIENT_APIS

				if (dwLastStatus != ERROR_SUCCESS)
                {
                }
				else
				{
					// query the server for correct info
					PWINSINTF_RECORD_ACTION_T pRecAction1 = QueryForName(pNode, pRecAction);

					if (pRecAction1 == NULL)
                    {
						//add it to the m_spWinsDatabase
						hr = AddToLocalStorage(pRecAction, pNode);
                    }
					else
                    {
    					// the record found and correct info displayed
						//add it to the m_spWinsDatabase
						hr = AddToLocalStorage(pRecAction1, pNode);
    					free(pRecAction1->pName);
                    }
				}
            }
        }
    }
    else
    {
        RecAction.NameLen = nLen;

#ifdef WINS_CLIENT_APIS
            dwLastStatus = ::WinsRecordAction(pServer->GetBinding(),&pRecAction);
#else
    		dwLastStatus = ::WinsRecordAction(&pRecAction);
#endif WINS_CLIENT_APIS

		if (dwLastStatus != ERROR_SUCCESS)
        {
        }
		else
		{
			// query the server for correct info
			PWINSINTF_RECORD_ACTION_T pRecAction1 = QueryForName(pNode, pRecAction);

			if (pRecAction1 == NULL)
            {
				//add it to the m_spWinsDatabase
				hr = AddToLocalStorage(pRecAction, pNode);
            }
			else
            {
    			// the record found and correct info displayed
 				//add it to the m_spWinsDatabase
				hr = AddToLocalStorage(pRecAction1, pNode);
	    		free(pRecAction1->pName);
            }
		}
    }

    if (RecAction.pName != NULL)
    {
        ::WinsFreeMem(RecAction.pName);
    }
    
    if (RecAction.pAdd != NULL)
    {
        ::WinsFreeMem(RecAction.pAdd);
    }

    return dwLastStatus;

}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::AddToLocalStorage(
											PWINSINTF_RECORD_ACTION_T pRecAction, 
											ITFSNode* pNode
											)
	add it to the m_spWinsDatabase, after getting all the information(Version, Exp etc)
	from the server

  Author: v-shubk
---------------------------------------------------------------------------*/
HRESULT 
CActiveRegistrationsHandler::AddToLocalStorage(PWINSINTF_RECORD_ACTION_T pRecAction, 
											   ITFSNode* pNode)
{
	HRESULT hr = hrOK;
    BOOL    bIPOk = FALSE;

	WinsRecord ws;

	// convert WINS_RECORD_ACTION to internal record
	WinsIntfToWinsRecord(pRecAction, ws);
	if (pRecAction->OwnerId < (UINT) m_pServerInfoArray->GetSize())
		ws.dwOwner = (*m_pServerInfoArray)[pRecAction->OwnerId].m_dwIp;

	if (m_spWinsDatabase)
	{
        hr = m_spWinsDatabase->AddRecord(&ws);
	}

	return hr;
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::OnImportLMHOSTS(ITFSNode* pNode)
		Command Handler for Import LMHosts 
	Author: v-shubk
---------------------------------------------------------------------------*/
HRESULT 
CActiveRegistrationsHandler::OnImportLMHOSTS(ITFSNode* pNode)
{
	HRESULT hr = hrOK;

	CString strTitle;
	CString strFilter;
	strFilter.LoadString(IDS_ALL_FILES);

    // put up the file dlg to get the file
	CFileDialog dlgFile(TRUE, 
						NULL, 
						NULL, 
						OFN_FILEMUSTEXIST | OFN_HIDEREADONLY, 
						strFilter);
    CThemeContextActivator themeActivator;

    dlgFile.m_ofn.lpstrTitle = strTitle;

	DWORD err = ERROR_SUCCESS;

	if (dlgFile.DoModal() == IDOK)
    {
        //
        // If this is a local connection, we copy the file to
        // temporary name (the source may be on a remote drive
        // which is not accessible to the WINS service.
        //
        // If this is not a local connection, attempt to copy
        // the file to a temp name on C$ of the WINS server
        //
   
        BEGIN_WAIT_CURSOR
        
        CString strMappingFile(dlgFile.GetPathName());
        
		do
        {
            if (IsLocalConnection(pNode))
            {
				CString strWins;
				strWins.LoadString(IDS_WINS);
                CString strTmpFile(_tempnam(NULL, "WINS"));
                //
                // First copy file to a temporary name (since the file
                // could be remote), and then import and delete this file
                //
                if (!CopyFile(strMappingFile, strTmpFile, TRUE) ||
                    !SetFileAttributes(strTmpFile, FILE_ATTRIBUTE_NORMAL))
                {
                    err = ::GetLastError();
                    break;
                }
                //
                // Now import the temporary file, and delete the file
                // afterwards.
                //
                err = ImportStaticMappingsFile(pNode, strTmpFile, TRUE);
            }
            else
            {
                //
                // Try copying to the remote machine C: drive
                //
				CString strServerName;
				GetServerName(pNode, strServerName);

				CString strWins;
				strWins.LoadString(IDS_WINS);

				CString strTemp;
				strTemp.Format(_T("\\\\%s\\C$"), strServerName);

				// Find a suitable remote file name
                CString strRemoteFile;
                DWORD dwErr = RemoteTmp(strTemp, strWins, strRemoteFile);

                if (dwErr != ERROR_SUCCESS)
                {
                    CString strError, strMessage;

                    ::GetSystemMessage(dwErr, strError.GetBuffer(1024), 1024);
                    strError.ReleaseBuffer();

                    AfxFormatString1(strMessage, IDS_ERR_REMOTE_IMPORT, strError);
                    AfxMessageBox(strMessage);

                    goto Error;
                }

                //
                // First copy file to a temporary name (since the file
                // could be remote), and then import and delete this file
                //
                if (!CopyFile(strMappingFile, strRemoteFile, TRUE) ||
                    !SetFileAttributes(strRemoteFile, FILE_ATTRIBUTE_NORMAL))
                {
                    err = ::GetLastError();
                    break;
                }

                //
                // fixup the filename so it looks local to the wins server
                //
                LPTSTR pch = strRemoteFile.GetBuffer(256);

                //
                // Now replace the remote path with a local path
                // for the remote WINS server
                //
                while (*pch != '$')
                {
                    ++pch;
                }
                *pch = ':';
                --pch;
                CString strRemoteFileNew(pch);
                strRemoteFile.ReleaseBuffer();
                
                //
                // Now import the temporary file, and delete the file
                // afterwards.
                //
                err = ImportStaticMappingsFile(pNode, strRemoteFileNew, TRUE);
            }
        }
        while(FALSE);

        END_WAIT_CURSOR
        
        if (err == ERROR_SUCCESS)
        {
            AfxMessageBox(IDS_MSG_IMPORT, MB_ICONINFORMATION);

			// refresh the result pane now.
			RefreshResults(pNode);
        }
        else
        {
            ::WinsMessageBox(err, MB_OK);
        }

		// refresh the server statistics

        SPITFSNode spServerNode;
		pNode->GetParent(&spServerNode);

		CWinsServerHandler * pServer = GETHANDLER(CWinsServerHandler, spServerNode);

		// rferesh the statistics
        pServer->GetStatistics(spServerNode, NULL);
	}

Error:
	return err;
}


/*---------------------------------------------------------------------------

	CActiveRegistrationsHandler::IsLocalConnection(ITFSNode *pNode)
		Check if the loacl machine is being managed
	Author: v-shubk
---------------------------------------------------------------------------*/
BOOL 
CActiveRegistrationsHandler::IsLocalConnection(ITFSNode *pNode)
{
	// get the server netbios name
	CString strServerName;
	GetServerName(pNode,strServerName);
	
	// address of name buffer
	TCHAR szBuffer[MAX_COMPUTERNAME_LENGTH + 1];   
	DWORD nSize = MAX_COMPUTERNAME_LENGTH + 1  ;
	
	::GetComputerName(szBuffer, &nSize);
	
	CString strCompName(szBuffer);

	if (strCompName == strServerName)
    {
		return TRUE;
    }
	
	return FALSE;
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::GetServerName(ITFSNode * pNode, 
												CString &strServerName)
		Talk to the parent node and get the server name
		we are managing
	Author: v-shubk
---------------------------------------------------------------------------*/
void
CActiveRegistrationsHandler::GetServerName(ITFSNode * pNode, 
										   CString &strServerName)
{
	SPITFSNode spServerNode;
    pNode->GetParent(&spServerNode);

    CWinsServerHandler * pServer = GETHANDLER(CWinsServerHandler, spServerNode);

	strServerName = pServer->GetServerAddress();
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::ImportStaticMappingsFile(CString strFile,
														BOOL fDelete)
		Call the WINS API to import the statis mappings text file
	Author: v-shubk
---------------------------------------------------------------------------*/
HRESULT 
CActiveRegistrationsHandler::ImportStaticMappingsFile(ITFSNode *pNode, 
													  CString strFile,
													  BOOL fDelete)
{
	HRESULT hr = hrOK;

	SPITFSNode spServerNode;
    pNode->GetParent(&spServerNode);

    CWinsServerHandler * pServer = GETHANDLER(CWinsServerHandler, spServerNode);

    LPTSTR lpszTemp = strFile.GetBuffer(MAX_PATH * 2);

#ifdef WINS_CLIENT_APIS
	DWORD dwLastStatus = ::WinsDoStaticInit(pServer->GetBinding(), 
											(LPTSTR)lpszTemp, 
											fDelete);
#else
	DWORD dwLastStatus = ::WinsDoStaticInit((LPTSTR)lpszTemp, fDelete);
#endif WINS_CLIENT_APIS

	strFile.ReleaseBuffer();

	return dwLastStatus;
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::RemoteTmp(CString strDir,CString strPrefix )
		 Get a temporary file on a remote drive
	Author: v-shubk
---------------------------------------------------------------------------*/
DWORD
CActiveRegistrationsHandler::RemoteTmp(CString & strDir, CString & strPrefix, CString & strRemoteFile)
{
    DWORD dwErr = ERROR_SUCCESS;
	CString strReturn;
	int n = 0;

    while (TRUE)
    {
		strReturn.Format(_T("%s\\%s%d"), strDir, strPrefix, ++n);

        if (GetFileAttributes(strReturn) == -1)
        {
            dwErr = GetLastError();
            if (dwErr == ERROR_FILE_NOT_FOUND)
            {
				strRemoteFile = strReturn;
                dwErr = ERROR_SUCCESS;
            }

            break;
        }
    }

	return dwErr;
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::DeleteMappingFromServer(ITFSComponent * pComponent,
													WinsRecord *pws,int nIndex)
		Deletes wins record from the Wins Server
	Author:	v-shubk
---------------------------------------------------------------------------*/
DWORD
CActiveRegistrationsHandler::DeleteMappingFromServer
(
    ITFSComponent *     pComponent,
	WinsRecord *        pws,
    int                 nIndex
)
{
	HRESULT hr = hrOK;

	//check if the record is static
	WINSINTF_RECORD_ACTION_T RecAction;
    PWINSINTF_RECORD_ACTION_T pRecAction;

	ZeroMemory(&RecAction, sizeof(RecAction));

	SPITFSNode spNode;
	pComponent->GetSelectedNode(&spNode);

	SPITFSNode spParentNode;
	spNode->GetParent(&spParentNode);

	CWinsServerHandler* pServer = GETHANDLER(CWinsServerHandler, spParentNode);

	if (pws->dwState & WINSDB_REC_STATIC)
	{
		RecAction.fStatic = TRUE;

		if (pws->dwState & WINSDB_REC_UNIQUE)
        {
			RecAction.TypOfRec_e = WINSINTF_E_UNIQUE;
        }
		else 
        if (pws->dwState & WINSDB_REC_SPEC_GROUP)
        {
			RecAction.TypOfRec_e = WINSINTF_E_SPEC_GROUP;
        }
		else 
        if (pws->dwState & WINSDB_REC_NORM_GROUP)
        {
			RecAction.TypOfRec_e = WINSINTF_E_NORM_GROUP;
        }
		else 
        if (pws->dwState & WINSDB_REC_MULTIHOMED)
        {
			RecAction.TypOfRec_e = WINSINTF_E_MULTIHOMED;
        }
	}
	else
	{
		RecAction.fStatic = FALSE;
	}

    RecAction.Cmd_e = WINSINTF_E_DELETE;
    RecAction.State_e = WINSINTF_E_DELETED;

    RecAction.pName = NULL;
    RecAction.pAdd = NULL;

    pRecAction = &RecAction;

    RecAction.pName = (LPBYTE)::WinsAllocMem(pws->dwNameLen+1);
	if (RecAction.pName == NULL)
    {
        return ::GetLastError();
    }

	ZeroMemory(RecAction.pName, pws->dwNameLen+1);
    memcpy(RecAction.pName, pws->szRecordName, pws->dwNameLen);

	if (pws->dwNameLen)
    {
		RecAction.NameLen = pws->dwNameLen;
    }
	else
    {
		RecAction.NameLen = ::strlen((LPSTR)RecAction.pName);
    }

	RecAction.OwnerId = pws->dwOwner;

	DWORD dwLastStatus = ERROR_SUCCESS;
	
#ifdef WINS_CLIENT_APIS
	dwLastStatus = ::WinsRecordAction(pServer->GetBinding(), &pRecAction);
#else
    dwLastStatus = ::WinsRecordAction(&pRecAction);
#endif WINS_CLIENT_APIS

    if (RecAction.pName != NULL)
    {
        ::WinsFreeMem(RecAction.pName);
    }

    if (RecAction.pAdd != NULL)
    {
        ::WinsFreeMem(RecAction.pAdd);
    }

    return dwLastStatus;
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::EditMapping(ITFSNode *pNode)
		Edit the already mapping , the user might have changed the IP address
	Author: v-shubk
---------------------------------------------------------------------------*/
HRESULT
CActiveRegistrationsHandler::EditMapping(ITFSNode *pNode, 
										 ITFSComponent *pComponent, 
										 int nIndex)
{
	HRESULT hr = hrOK;

	DWORD		err = ERROR_SUCCESS;
    int			i;
	int         nCurrentCount;

	// get the server
	SPITFSNode spServerNode;
    pNode->GetParent(&spServerNode);

    CWinsServerHandler * pServer = GETHANDLER(CWinsServerHandler, spServerNode);

	BOOL fInternetGroup = FALSE;

	if (m_strStaticMappingType.CompareNoCase(g_strStaticTypeInternetGroup) == 0)
    {
		fInternetGroup = TRUE;
    }

	// create the multiple IPNamePr
	if (pServer->IsValidNetBIOSName(m_strStaticMappingName, IsLanManCompatible(), FALSE))
	{
		m_Multiples.SetNetBIOSName(m_strStaticMappingName);
        m_Multiples.SetNetBIOSNameLength(m_strStaticMappingName.GetLength());

		int nMappings = 0;
        int i;

		switch(m_nStaticMappingType)
        {
            case WINSINTF_E_UNIQUE:
            case WINSINTF_E_NORM_GROUP:
			{
                nMappings = 1;
                LONG l;

              	m_Multiples.SetIpAddress(m_lArrayIPAddress.GetAt(0));
			}
            break;

            case WINSINTF_E_SPEC_GROUP:
            case WINSINTF_E_MULTIHOMED:
                nMappings = (int)m_lArrayIPAddress.GetSize();
                ASSERT(nMappings <= WINSINTF_MAX_MEM);
                if (!fInternetGroup && nMappings == 0)
                {
                    //return E_FAIL;
                }
                for (i = 0; i < nMappings; ++i)
                {
                    m_Multiples.SetIpAddress(i,m_lArrayIPAddress.GetAt(i) );
                }
                break;

            default:
                ASSERT(0 && "Invalid mapping type!");
        }

		HROW hrowDel;
		WinsRecord ws;

		// from internal storage
		CORg(m_spWinsDatabase->GetHRow(m_nSelectedIndex, &hrowDel));
		CORg(m_spWinsDatabase->GetData(hrowDel, &ws));

		if (m_nStaticMappingType == WINSINTF_E_SPEC_GROUP ||
            m_nStaticMappingType == WINSINTF_E_MULTIHOMED)
		{
			//
			// An internet group being edited cannot simply be
			// re-added, since it will add ip addresses, not
			// overwrite them, so it must first be removed.
			//
			err = DeleteMappingFromServer(pComponent, &ws, m_nSelectedIndex);
		}

		//
		// We edit the mapping by merely re-adding it, which
		// has the same effect.
		//
		if (err == ERROR_SUCCESS)
		{
			err = EditMappingToServer(pNode,
                                      m_nStaticMappingType, 
									  nMappings, 
                                      m_Multiples, 
                                      TRUE, 
                                      &m_CurrentRecord);
		}
		
		if (err != ERROR_SUCCESS)
        {
			return err;
        }

		WINSINTF_ADD_T OwnAdd;

		// 
		// Fill in current owner
		//
		OwnAdd.Len = 4;
		OwnAdd.Type = 0;
		OwnAdd.IPAdd = pServer->GetServerIP();

		WINSINTF_RECS_T Recs;
		Recs.pRow = NULL;

#ifdef WINS_CLIENT_APIS
		err = ::WinsGetDbRecsByName(pServer->GetBinding(), 
									&OwnAdd, 
									WINSINTF_BEGINNING,
									(LPBYTE) ws.szRecordName,
									ws.dwNameLen, 
									1, 
									(ws.dwState & WINSDB_REC_STATIC)
											? WINSINTF_STATIC : WINSINTF_DYNAMIC,
									&Recs);
	
#else
		err = ::WinsGetDbRecsByName(&OwnAdd, 
									WINSINTF_BEGINNING,
									(LPBYTE) ws.szRecordName,
									ws.dwNameLen, 
									1, 
									(ws.dwState & WINSDB_REC_STATIC)
											? WINSINTF_STATIC : WINSINTF_DYNAMIC,
									&Recs);
#endif WINS_CLIENT_APIS

		if (err == ERROR_SUCCESS)
		{
			TRY
			{
				ASSERT(Recs.NoOfRecs == 1);
				if (Recs.NoOfRecs == 0)
				{
					//
					// the record can not be found.
					// This should not happen!
					//
					//Trace("Unable to find the record to refresh:\n");
					return ERROR_REC_NON_EXISTENT;
				}

				PWINSINTF_RECORD_ACTION_T pRow1 = Recs.pRow;
                WinsRecord wRecord;
                
				WinsIntfToWinsRecord(pRow1, wRecord);
				if (pRow1->OwnerId < (UINT) m_pServerInfoArray->GetSize())
					wRecord.dwOwner = (*m_pServerInfoArray)[pRow1->OwnerId].m_dwIp;

				// RefreshData(Recs.pRow), delete this particular record and add it again;
				// from internal storage
				CORg(m_spWinsDatabase->DeleteRecord(hrowDel));
				CORg(m_spWinsDatabase->AddRecord(&wRecord));

    			// now set the count.. this effectively redraws the contents
				CORg (m_pCurrentDatabase->GetCurrentCount(&nCurrentCount));

				UpdateCurrentView(pNode);
			}
			CATCH_ALL(e)
			{
				return ::GetLastError();
			}
			END_CATCH_ALL;
		}

		if (Recs.pRow != NULL)
		{
			::WinsFreeMem(Recs.pRow);
		}
	}

Error:
    return err;
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::QueryForName()
		queries WINS server given the name and gets info to be displayed in the 
		result pane
	Author: v-shubk
---------------------------------------------------------------------------*/
PWINSINTF_RECORD_ACTION_T 
CActiveRegistrationsHandler::QueryForName
(
	ITFSNode *					pNode, 
  	PWINSINTF_RECORD_ACTION_T	pRecAction,
    BOOL                        fStatic
)
{
	SPITFSNode spNode;
	pNode->GetParent(&spNode);

	CWinsServerHandler *pServer = GETHANDLER(CWinsServerHandler, spNode);
	
	HRESULT hr = hrOK;

	pRecAction->pAdd = NULL;
    pRecAction->NoOfAdds = 0;

	pRecAction->fStatic = fStatic;
	pRecAction->Cmd_e   = WINSINTF_E_QUERY;
	
#ifdef WINS_CLIENT_APIS
	DWORD dwStatus = WinsRecordAction(pServer->GetBinding(), &pRecAction);
#else
	DWORD dwStatus = WinsRecordAction(&pRecAction);
#endif WINS_CLIENT_APIS

    // when we query for a record, the string length must not include the null terminator.
    // in the normal case using GetDbRecs, wins returns the name length as length + 1
    // for the null terminator.  Since all of the code expects any WINSINTFS_RECORD_ACTION_T
    // struct to be in that format, let's touch things up a bit and make a copy.
	if (dwStatus == 0)
    {
        pRecAction->NameLen++;
        LPBYTE pNew = (LPBYTE) malloc(pRecAction->NameLen);
        if (pNew)
        {
            ZeroMemory(pNew, pRecAction->NameLen);

            memcpy(pNew, pRecAction->pName, pRecAction->NameLen - 1);

            pRecAction->pName = pNew;
        }

        return pRecAction;
    }
	else
    {
		return NULL;
    }
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::ToString(DWORD dwParam, CString& strParam)
		converts DWORD to CString
	Author v-shubk
---------------------------------------------------------------------------*/
void 
CActiveRegistrationsHandler::ToString(DWORD dwParam, CString& strParam)
{
	TCHAR szStr[20];
	_ltot((LONG)dwParam, szStr, 10);
	CString str(szStr);
	strParam = str;
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::OnExportEntries()
		Command Handler for Export Database
	Author v-shubk
---------------------------------------------------------------------------*/
HRESULT	
CActiveRegistrationsHandler::OnExportEntries()
{
	HRESULT hr = hrOK;
    WinsRecord ws;
	HROW hrow;

    if (!m_pCurrentDatabase)
    {
        return NULL;
    }

	// Bring up the Save Dialog

	CString strType;
	strType.LoadString(IDS_FILE_EXTENSION);

	CString strDefFileName;
	strDefFileName.LoadString(IDS_FILE_DEFNAME);

	CString strFilter;
	strFilter.LoadString(IDS_STR_EXPORTFILE_FILTER);
	
	// put up the dlg to get the file name
	CFileDialog	cFileDlg(FALSE, 
						strType, 
						strDefFileName, 
						OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
						strFilter);
    CThemeContextActivator themeActivator;
	
	CString strTitle;
	strTitle.LoadString(IDS_EXPFILE_TITLE);

	cFileDlg.m_ofn.lpstrTitle  = strTitle;

	if ( cFileDlg.DoModal() != IDOK )
    {
		return hrFalse;
    }

	// getthe entire path
	CString strFileName = cFileDlg.GetPathName();

	COM_PROTECT_TRY
    {
		int nCount;
		m_pCurrentDatabase->GetCurrentCount(&nCount);

		CString strContent;
		strContent.Empty();

		CString strTemp;
		strTemp.Empty();

		CString strLine;
		strLine.Empty();

		CString strDelim = _T(',');
		CString strNewLine = _T("\r\n");

		// create a file named "WinsExp.txt" in the current directory
		CFile cFileExp(strFileName, 
						CFile::modeCreate | CFile::modeRead | CFile::modeWrite);

        // this is a unicode file, write the unicde lead bytes (2)
        cFileExp.Write(&gwUnicodeHeader, sizeof(WORD));

        CString strHead;
		strHead.LoadString(IDS_STRING_HEAD);
	
        strHead += strNewLine;

		cFileExp.Write(strHead, strHead.GetLength()*sizeof(TCHAR));
	
		BEGIN_WAIT_CURSOR

		#ifdef DEBUG
		CTime timeStart, timeFinish;
		timeStart = CTime::GetCurrentTime();
		#endif

        for (int i = 0; i < nCount; i++)
		{
			strLine.Empty();
			strTemp.Empty();

			hr = m_pCurrentDatabase->GetHRow(i, &hrow);
			hr = m_pCurrentDatabase->GetData(hrow, &ws);

			// build the name string
			CleanNetBIOSName(ws.szRecordName,  // input char *
                             strTemp,          // output LPTSTR
							 TRUE,             // Expand
							 TRUE,             // Truncate
							 IsLanManCompatible(), 
							 TRUE,             // name is OEM
							 FALSE,            // No double backslash
                             ws.dwNameLen);

			strLine += strTemp;
			strLine += strDelim;

			// now the type
	        m_NameTypeMap.TypeToCString((DWORD)ws.szRecordName[15], MAKELONG(HIWORD(ws.dwType), 0), strTemp);
			strLine += strTemp;
			strLine += strDelim;
			
			// IP address
			if ( (ws.dwState & WINSDB_REC_UNIQUE) ||
				 (ws.dwState & WINSDB_REC_NORM_GROUP) )
			{
				MakeIPAddress(ws.dwIpAdd[0], strTemp);
				strLine += strTemp;
			}
			else
			{
				CString strTemp2;

				// this record has multiple addresses.  The addresses are in the form of:
				// owner wins, then IP address
				// out put will look like address - owner IP;address - owner ip
				for (DWORD i = 0; i < ws.dwNoOfAddrs; i++)
				{
					if (i != 0)
						strLine += _T(";");

					// owner 
					::MakeIPAddress(ws.dwIpAdd[i++], strTemp);
					// actual address
					::MakeIPAddress(ws.dwIpAdd[i], strTemp2);

					strTemp2 += _T(" - ");
					strTemp2 += strTemp;

					strLine += strTemp2;
				}
			}

			strLine += strDelim;
			
			// active status
			GetStateString(ws.dwState, strTemp);
			strLine += strTemp;
			strLine += strDelim;
			
			// static flag
			if (ws.dwState & WINSDB_REC_STATIC)
				strTemp.LoadString(IDS_ACTIVEREG_STATIC);
			else
				strTemp =  _T("");
			strLine += strTemp;
			strLine += strDelim;

    		// version
			GetVersionInfo(ws.liVersion.LowPart, ws.liVersion.HighPart, strTemp);
			strLine += strTemp;
			strLine += strDelim;

			// expiration time
		    if (ws.dwExpiration == INFINITE_EXPIRATION)
		    {
			    Verify(strTemp.LoadString(IDS_INFINITE));
		    }
		    else
		    {	
                strTemp = TMST(ws.dwExpiration);
		    }

            strLine += strTemp;
    		strLine += strNewLine;

            strContent += strLine;

			//optimize
			// write to the file for every 1000 records converted
			if ( i % 1000 == 0)
			{
				cFileExp.Write(strContent, strContent.GetLength() * (sizeof(TCHAR)) );
				cFileExp.SeekToEnd();
				
				// clear all the strings now
				strContent.Empty();
			}
		}

		// write to the file
		
		cFileExp.Write(strContent, strContent.GetLength() * (sizeof(TCHAR)) );
		cFileExp.Close();

		#ifdef DEBUG
		timeFinish = CTime::GetCurrentTime();
		CTimeSpan timeDelta = timeFinish - timeStart;
		CString strTempTime = timeDelta.Format(_T("%H:%M:%S"));
		Trace2("WINS DB - Export Entries: %d records read, total time %s\n", i, strTempTime);
		#endif


		END_WAIT_CURSOR

	}
	COM_PROTECT_CATCH

	CString strDisp;
	AfxFormatString1(strDisp, IDS_EXPORT_SUCCESS, strFileName);

	AfxMessageBox(strDisp, MB_ICONINFORMATION );

	return hr;
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::BuildOwnerArray(ITFSNode *pNode)
		Builds the list of owners in the server
	Author:	v-shubk
---------------------------------------------------------------------------*/
HRESULT 
CActiveRegistrationsHandler::BuildOwnerArray(handle_t hBinding)
{
	HRESULT hr = hrOK;
    DWORD   err = 0;
    CWinsResults    winsResults;

	err = winsResults.Update(hBinding);

	if (err == ERROR_SUCCESS)
    {
		m_pServerInfoArray->RemoveAll();

        LARGE_INTEGER   liVersion;
		DWORD           dwIP;
        CString         strName;
        BOOL            fGetHostName = TRUE;

		for (int i = 0; i < winsResults.AddVersMaps.GetSize(); i++)
        {
            liVersion = winsResults.AddVersMaps[i].VersNo;
            dwIP = winsResults.AddVersMaps[i].Add.IPAdd;

            CServerInfo serverInfo(dwIP, strName, liVersion);

            int nIndex = (int)m_pServerInfoArray->Add(serverInfo);
    	}
    }

	return HRESULT_FROM_WIN32(err);
}

/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::OnCheckRegNames(ITFSNode* pNode)
		Command Handler for Check Registered names
	Author:	v-shubk
---------------------------------------------------------------------------*/
HRESULT 
CActiveRegistrationsHandler::OnCheckRegNames(ITFSNode* pNode)
{
	HRESULT hr = hrOK;

	CCheckRegNames dlgRegName;
    CThemeContextActivator themeActivator;
	
	if (IDOK != dlgRegName.DoModal())
    {
		return hr;
    }

	CCheckNamesProgress dlgCheckNames;

	dlgCheckNames.m_strNameArray.Copy(dlgRegName.m_strNameArray);
	dlgCheckNames.m_strServerArray.Copy(dlgRegName.m_strServerArray);
	dlgCheckNames.m_fVerifyWithPartners = dlgRegName.m_fVerifyWithPartners;

	dlgCheckNames.DoModal();

	return hr;
}

/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::OnDeleteOwner(ITFSNode* pNode)
		Command Handler for Tombstone all records
	Author:	EricDav
---------------------------------------------------------------------------*/
HRESULT 
CActiveRegistrationsHandler::OnDeleteOwner(ITFSNode* pNode)
{
	HRESULT hr = hrOK;

	CDeleteOwner	dlgDeleteOwner(pNode);
    CThemeContextActivator themeActivator;

	DWORD	dwErr, dwIp;
	CString strText, strIp;

	if (dlgDeleteOwner.DoModal() == IDOK)
	{
		BEGIN_WAIT_CURSOR

		if (dlgDeleteOwner.m_fDeleteRecords)
		{
			SPITFSNode spServerNode;
			pNode->GetParent(&spServerNode);
			
			CWinsServerHandler * pServer = GETHANDLER(CWinsServerHandler, spServerNode);
			
			dwErr = pServer->DeleteWinsServer(dlgDeleteOwner.m_dwSelectedOwner);

            if (dwErr == ERROR_SUCCESS)
            {
                // remove from list
                for (int i = 0; i < m_pServerInfoArray->GetSize(); i++)
                {
                    if (m_pServerInfoArray->GetAt(i).m_dwIp == dlgDeleteOwner.m_dwSelectedOwner)
                    {
                        m_pServerInfoArray->RemoveAt(i);
                        break;
                    }
                }
            }
		}
		else
		{
			dwErr = TombstoneAllRecords(dlgDeleteOwner.m_dwSelectedOwner, pNode);
		}

		END_WAIT_CURSOR

		if (dwErr != ERROR_SUCCESS)
		{
			WinsMessageBox(dwErr);
		}

		// TODO trigger an update of whatever is in the active registrations result pane
    }

	return hr;
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::AppendScopeName(char* lpName, 
													char* lpScopeAppended)

		Appends the scope name to the record name, when there isa  scope name 
		attached to the record
---------------------------------------------------------------------------*/
void 
CActiveRegistrationsHandler::AppendScopeName(char* lpName, char* lpScopeAppended)
{

	strcpy(lpScopeAppended, lpName);
	char szTemp[MAX_PATH];

	CString strScope = _T(".") + m_strStaticMappingScope;

    // INTL$ Should the scope name be OEM as well?
    WideToMBCS(strScope, szTemp, WINS_NAME_CODE_PAGE, WC_COMPOSITECHECK);

	strcat(lpScopeAppended, szTemp);
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::TombstoneRecords()
	    Handles Tomsstoning of records
	Author:	v-shubk
---------------------------------------------------------------------------*/
DWORD
CActiveRegistrationsHandler::TombstoneRecords
(
    ITFSComponent * pComponent, 
	WinsRecord *    pws
)
{
	DWORD err = ERROR_SUCCESS;

	// get the server node to retrive the handle for the WINS api
	SPITFSNode spNode;
	pComponent->GetSelectedNode(&spNode);

	SPITFSNode spParentNode;
	spNode->GetParent(&spParentNode);

	CWinsServerHandler* pServer = GETHANDLER(CWinsServerHandler, spParentNode);  

	WINSINTF_VERS_NO_T	MinVersNo;
	WINSINTF_VERS_NO_T	MaxVersNo;

	MinVersNo = pws->liVersion;
	MaxVersNo = MinVersNo;

    // gotta get the owner of this record
    WINSINTF_RECORD_ACTION_T recAction;
    WINSINTF_RECORD_ACTION_T * precAction = &recAction; 
    
	ZeroMemory(&recAction, sizeof(recAction));

    BYTE * pName = (BYTE*) WinsAllocMem(pws->dwNameLen + 1);
	if (pName == NULL)
    {
        return ERROR_OUTOFMEMORY;
    }

    memset(pName, 0, pws->dwNameLen + 1);
    memcpy(pName, pws->szRecordName, pws->dwNameLen);

	recAction.pName = pName;
	recAction.Cmd_e = WINSINTF_E_QUERY;
    recAction.TypOfRec_e = HIWORD(pws->dwType);
    recAction.fStatic = (pws->dwState & WINSDB_REC_STATIC) ? TRUE : FALSE;
    recAction.pAdd = NULL;
    recAction.NoOfAdds = 0;
    recAction.NameLen = pws->dwNameLen;

    // get the OwnerId for the mapping
    // have to do this because the OwnerId in the raw data is bogus
#ifdef WINS_CLIENT_APIS
    err = ::WinsRecordAction(pServer->GetBinding(), &precAction);
#else
	err = ::WinsRecordAction(&precAction);
#endif WINS_CLIENT_APIS

    WinsFreeMem(pName);
	if (err != WINSINTF_SUCCESS )
    {
        return err;
    }

    WINSINTF_ADD_T  WinsAdd;

    WinsAdd.Len  = 4;
    WinsAdd.Type = 0;
    //WinsAdd.IPAdd  = m_dwArrayOwner[precAction->OwnerId]; 
    WinsAdd.IPAdd = (*m_pServerInfoArray)[precAction->OwnerId].m_dwIp;

#ifdef WINS_CLIENT_APIS
	err = ::WinsTombstoneDbRecs(pServer->GetBinding(),
                                &WinsAdd,
								MinVersNo,
								MaxVersNo);
#else
	err = ::WinsTombstoneDbRecs(&WinsAdd,
								MinVersNo,
								MaxVersNo);
#endif
 
	return err;
}

/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::TombstoneAllRecords()
	    Tombstones all records owned by this server
	Author:	EricDav
---------------------------------------------------------------------------*/
DWORD
CActiveRegistrationsHandler::TombstoneAllRecords(DWORD dwServerIpAddress, ITFSNode * pNode)
{
	WINSINTF_VERS_NO_T	MinVersNo;
	WINSINTF_VERS_NO_T	MaxVersNo;
	WINSINTF_ADD_T  WinsAdd;

	SPITFSNode spParentNode;
	pNode->GetParent(&spParentNode);

	CWinsServerHandler * pServer = GETHANDLER(CWinsServerHandler, spParentNode);  

	DWORD err;

    CWinsResults winsResults;

    err = winsResults.Update(pServer->GetBinding());
	if (err != ERROR_SUCCESS)
		return err;

    MinVersNo.QuadPart = 0;

	for (UINT i = 0; i < winsResults.NoOfOwners; i++)
	{
		if (winsResults.AddVersMaps[i].Add.IPAdd == dwServerIpAddress)
		{
			MaxVersNo.QuadPart = winsResults.AddVersMaps[i].VersNo.QuadPart;
			break;
		}
	}

	// build the IP address
    WinsAdd.Len  = 4;
    WinsAdd.Type = 0;
    WinsAdd.IPAdd = dwServerIpAddress; 

#ifdef WINS_CLIENT_APIS
	err = ::WinsTombstoneDbRecs(pServer->GetBinding(),
                                &WinsAdd,
								MinVersNo,
								MaxVersNo);
#else
	err = ::WinsTombstoneDbRecs(&WinsAdd,
								MinVersNo,
								MaxVersNo);
#endif

	return err;
}

/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::UpdateRecord(ITFSComponent *pComponent, 
												WinsRecord *pws, 
												int nDelIndex)

		Called to update the record on the result pane when a records has been
		tombstoned
	Author:	v-shubk
---------------------------------------------------------------------------*/
HRESULT 
CActiveRegistrationsHandler::UpdateRecord(ITFSComponent *pComponent, 
										  WinsRecord *pws, 
										  int nDelIndex)
{
	HRESULT						hr = hrOK;
    WINSINTF_RECORD_ACTION_T	RecAction;
	PWINSINTF_RECORD_ACTION_T	pRecAction;
	PWINSINTF_RECORD_ACTION_T	pRecActionRet;
	DWORD						dwStatus = ERROR_SUCCESS;
	int							nLen;
	BYTE						bLast;
	SPITFSNode					spNode;
	SPITFSNode					spParentNode;
	WinsRecord					wsNew;
	HROW						hrowDel;

	pComponent->GetSelectedNode(&spNode);

	// get it's parent, which happens to be the server node
	spNode->GetParent(&spParentNode);

	// get the pointer to the server handler
	CWinsServerHandler *pServer = GETHANDLER(CWinsServerHandler, spParentNode);

	ZeroMemory(&RecAction, sizeof(RecAction));

	// form the PWINSINTFrecord from the info in WinsRecord
    //RecAction.TypOfRec_e = nType;
    RecAction.Cmd_e = WINSINTF_E_QUERY;
    RecAction.pAdd = NULL;
    RecAction.pName = NULL;
	RecAction.NoOfAdds = 0;
	RecAction.NameLen = nLen = pws->dwNameLen;
	bLast = LOBYTE(LOWORD(pws->dwType));
	
    pRecAction = &RecAction;
    
    RecAction.pName = (LPBYTE)::WinsAllocMem(nLen + 1);
    if (RecAction.pName == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

	// copy the name
	memset(pRecAction->pName, 0, nLen + 1);
    (void)memcpy(pRecAction->pName, pws->szRecordName, nLen);
	
	// now query for this particular record
	pRecActionRet = QueryForName(spNode, pRecAction);

	// if the function is successful, update the listbox
	if (pRecActionRet != NULL)
    {
        // convert PWinsINTF record to WinsRecord so that it can be added to the local storage
        WinsIntfToWinsRecord(pRecActionRet, wsNew);
        if (pRecActionRet->OwnerId < (UINT) m_pServerInfoArray->GetSize())
		    wsNew.dwOwner = (*m_pServerInfoArray)[pRecActionRet->OwnerId].m_dwIp;

        free(pRecActionRet->pName);
    
        // delete this particular record and add it back again to the local storage
        CORg(m_pCurrentDatabase->GetHRow(nDelIndex, &hrowDel));
        CORg(m_pCurrentDatabase->DeleteRecord(hrowDel));

        // add it to database
        m_pCurrentDatabase->AddRecord(&wsNew);   
    }

Error:
    if (RecAction.pName)
    {
        WinsFreeMem(RecAction.pName);
    }

	return hr;
}


/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::RefreshResults(ITFSNode *pNode)
		Refreshes the result pane of the active registrations node
---------------------------------------------------------------------------*/
HRESULT 
CActiveRegistrationsHandler::RefreshResults(ITFSNode *pNode)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT				hr = hrOK;
	SPITFSNode			spNode;
	SPITFSNodeHandler	spHandler;
	ITFSQueryObject *	pQuery = NULL;
	SPITFSNode			spServerNode;
	DWORD				dwIP;
	CString				strIP ;
	CWinsServerHandler* pServer = NULL;
	CString				strMachineName;
	int					nCount, pos;

	// if being loaded
	if (m_spWinsDatabase)
	{
		CORg (m_spWinsDatabase->Stop());
        
        DatabaseLoadingCleanup();
        UpdateListboxCount(pNode);
    }

	pNode->GetParent(&spServerNode);

    pServer = GETHANDLER(CWinsServerHandler, spServerNode);
	
	Lock();

	strMachineName = _T("\\\\") + pServer->GetServerAddress();

	dwIP = pServer->GetServerIP();
	MakeIPAddress(dwIP, strIP);

    if (!m_spWinsDatabase)
    {
        CORg(CreateWinsDatabase(strIP, strIP, &m_spWinsDatabase));
    }
    
    m_spWinsDatabase->SetApiInfo(
                            m_dlgLoadRecords.m_pageOwners.GetOwnerForApi(),
                            m_dlgLoadRecords.m_pageIpAddress.GetNameForApi(),
                            m_dlgLoadRecords.m_bEnableCache);

	// start loading records
    CORg (m_spWinsDatabase->Init());

    UpdateCurrentView(pNode);

    // update our internal state
	m_winsdbState = WINSDB_LOADING;

    // update the node's icon
	OnChangeState(pNode);

	// kick off the background thread to do the timer updates
	pQuery = OnCreateQuery(pNode);
	Assert(pQuery);

	Verify(StartBackgroundThread(pNode, 
								m_spTFSCompData->GetHiddenWnd(), 
								pQuery));
	
	pQuery->Release();

    // fill in any record type filter information
    nCount = (int)m_dlgLoadRecords.m_pageTypes.m_arrayTypeFilter.GetSize();
    m_spWinsDatabase->ClearFilter(WINSDB_FILTER_BY_TYPE);
	for (pos = 0; pos < nCount; pos++)
	{
        m_spWinsDatabase->AddFilter(WINSDB_FILTER_BY_TYPE, 
									m_dlgLoadRecords.m_pageTypes.m_arrayTypeFilter[pos].dwType, 
									m_dlgLoadRecords.m_pageTypes.m_arrayTypeFilter[pos].fShow,
                                    NULL);
	}

    // fill in any owner filter information
    nCount = (int)m_dlgLoadRecords.m_pageOwners.m_dwaOwnerFilter.GetSize();
    m_spWinsDatabase->ClearFilter(WINSDB_FILTER_BY_OWNER);
    for (pos = 0; pos < nCount; pos++)
    {
        m_spWinsDatabase->AddFilter(WINSDB_FILTER_BY_OWNER,
                                    m_dlgLoadRecords.m_pageOwners.m_dwaOwnerFilter[pos],
                                    0,
                                    NULL);
    }

    // fill in any ip address filter information
    m_spWinsDatabase->ClearFilter(WINSDB_FILTER_BY_IPADDR);
    if (m_dlgLoadRecords.m_pageIpAddress.m_bFilterIpAddr)
    {
        nCount = (int)m_dlgLoadRecords.m_pageIpAddress.m_dwaIPAddrs.GetSize();
        for (pos = 0; pos < nCount; pos++)
        {
            m_spWinsDatabase->AddFilter(WINSDB_FILTER_BY_IPADDR,
                                        m_dlgLoadRecords.m_pageIpAddress.m_dwaIPAddrs[pos],
                                        m_dlgLoadRecords.m_pageIpAddress.GetIPMaskForFilter(pos),
                                        NULL);
        }
    }

    // fill in any name filter information
    m_spWinsDatabase->ClearFilter(WINSDB_FILTER_BY_NAME);
    if (m_dlgLoadRecords.m_pageIpAddress.m_bFilterName)
    {
        m_spWinsDatabase->AddFilter(WINSDB_FILTER_BY_NAME,
                                    m_dlgLoadRecords.m_pageIpAddress.m_bMatchCase,
                                    0,
                                    m_dlgLoadRecords.m_pageIpAddress.m_strName);
    }

    // start loading records
    CORg (m_spWinsDatabase->Start());

	BEGIN_WAIT_CURSOR

	// filter any records that may have been downloaded before we set the
	// filter information (in the case when we had to reload the database).  
	// any records that come in after we set the 
	// filter info will be filtered correctly.
    m_spWinsDatabase->FilterRecords(WINSDB_FILTER_BY_TYPE, 0,0);
	
	END_WAIT_CURSOR

	// do the initial update of the virutal listbox
	OnHaveData(pNode, 0, QDATA_TIMER);

COM_PROTECT_ERROR_LABEL;

    return hr;
}

/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::GetRecordOwner()
		Gets the owner IP Address for a given record
    Author: EricDav
---------------------------------------------------------------------------*/
BOOL
CActiveRegistrationsHandler::GetRecordOwner(ITFSNode * pNode, WinsRecord * pWinsRecord)
{
	BOOL fSuccess = TRUE;
	SPITFSNode spServerNode;
    pNode->GetParent(&spServerNode);

    CWinsServerHandler * pServer = GETHANDLER(CWinsServerHandler, spServerNode);

	CConfiguration config = pServer->GetConfig();

	if (!config.FSupportsOwnerId())
	{
		// query the server for correct info
		WINSINTF_RECORD_ACTION_T RecAction;

		ZeroMemory(&RecAction, sizeof(RecAction));

		//
		// Must have at least enough room for 256 character string, 
		// includes the scope name too
		//
		RecAction.pName = (LPBYTE)::WinsAllocMem(257);
		if (RecAction.pName == NULL)
		{
			//return ERROR_NOT_ENOUGH_MEMORY;
			Trace0("GetRecordOwner - WinsAllocMemFailed!!\n");
			return FALSE;
		}
		
		// fill in the record action struct
        ::memset(RecAction.pName, 0, 257);
    
		::memcpy((char *)RecAction.pName,
			     (LPCSTR) pWinsRecord->szRecordName,
			     pWinsRecord->dwNameLen);

        RecAction.NameLen = strlen((char *) RecAction.pName);

        // for name records of type 0x00 or records that somehow have a NULL in the name
        // strlen will return an invalid string length.  So, if the length < 16 then set 
        // the length to 16.
        // name lengths with scopes will calculate correctly.
        if (RecAction.NameLen < 0x10)
        {
            RecAction.NameLen = 0x10;
        }

        BOOL fStatic = (pWinsRecord->dwState & WINSDB_REC_STATIC) ? TRUE : FALSE;

		// now query for the name
        PWINSINTF_RECORD_ACTION_T pRecActionResult = QueryForName(pNode, &RecAction, fStatic);

		if (pRecActionResult)
		{
        	free(pRecActionResult->pName);
		}
        else
        {
            pWinsRecord->dwOwner = INVALID_OWNER_ID;
        }
	}

	return fSuccess;
}

/*---------------------------------------------------------------------------
	CActiveRegistrationsHandler::GetOwnerInfo()
		Gets the owner info array
    Author: EricDav
---------------------------------------------------------------------------*/
void
CActiveRegistrationsHandler::GetOwnerInfo(CServerInfoArray & serverInfoArray)
{
    serverInfoArray.RemoveAll();

    serverInfoArray.Copy(*m_pServerInfoArray);
}

void CActiveRegistrationsHandler::SetLoadedOnce(ITFSNode * pNode)
{
	if (m_fLoadedOnce)
		return;

	m_fLoadedOnce = TRUE;

    // clear the result pane message
    ClearMessage(pNode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\common.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1995 - 1998 **/
/**********************************************************************/

/*
    FILE HISTORY:

*/

#ifndef _COMMON_H_
#define _COMMON_H_

#ifndef _IPADDR_H
#include "ipaddr.h"
#endif

//
//  Forward declarations
//
class CObjHelper ;
class CObjectPlus ;
class CObOwnedList ;
class CObListIter ;
class CObOwnedArray ;

//
//  Wrappers for the *BROKEN* C8 TRY/CATCH stuff
//
#define CATCH_MEM_EXCEPTION             \
    TRY

#define END_MEM_EXCEPTION(err)          \
    CATCH_ALL(e) {                      \
       err = ERROR_NOT_ENOUGH_MEMORY ;  \
    } END_CATCH_ALL

/****************************************************************************
DEBUGAFX.H
****************************************************************************/

//
//  ENUM for special debug output control tokens
//
enum ENUM_DEBUG_AFX { EDBUG_AFX_EOL = -1 } ;

#if defined(_DEBUG)
   #define TRACEFMTPGM      DbgFmtPgm( THIS_FILE, __LINE__ )
   #define TRACEOUT(x)      { afxDump << x ; }
   #define TRACEEOL(x)      { afxDump << x << EDBUG_AFX_EOL ; }
   #define TRACEEOLID(x)    { afxDump << TRACEFMTPGM << x << EDBUG_AFX_EOL ; }
   #define TRACEEOLERR(err,x)   { if (err) TRACEEOLID(x) }

#else
   #define TRACEOUT(x)      { ; }
   #define TRACEEOL(x)      { ; }
   #define TRACEEOLID(x)    { ; }
   #define TRACEEOLERR(err,x)   { ; }
#endif

//
//  Append an EOL onto the debug output stream
//
CDumpContext & operator << ( CDumpContext & out, ENUM_DEBUG_AFX edAfx ) ;

//
//  Format a program name and line number for output (removes the path info)
//
extern const char * DbgFmtPgm ( const char * szFn, int line ) ;

/****************************************************************************
OBJPLUS.H
****************************************************************************/

//
//  Helper class for control of construction and API errors
//
class CObjHelper
{
protected:
     LONG m_ctor_err ;
     LONG m_api_err ;
     DWORD m_time_created ;
     BOOL m_b_dirty ;

     CObjHelper () ;

public:
    void AssertValid () const ;

    virtual BOOL IsValid () const ;

    operator BOOL()
    {
        return (IsValid());
    }

    //
    //  Update the Dirty flag
    //
    void SetDirty ( BOOL bDirty = TRUE )
    {
        m_b_dirty = bDirty ;
    }

    //
    //  Query the Dirty flag
    //
    BOOL IsDirty () const
    {
        return m_b_dirty ;
    }

    //
    //  Return the creation time of this object
    //
    DWORD QueryCreationTime() const
    {
        return m_time_created ;
    }

    //
    //  Return the elapsed time this object has been alive.
    //
    DWORD QueryAge () const ;

    //
    //  Query/set constuction failure
    //
    void ReportError ( LONG errInConstruction ) ;
    LONG QueryError () const
    {
        return m_ctor_err ;
    }

    //
    //  Reset all error conditions.
    //
    void ResetErrors ()
    {
        m_ctor_err = m_api_err = 0 ;
    }

    //
    //  Query/set API errors.
    //
    LONG QueryApiErr () const
    {
        return m_api_err ;
    }

    //
    //  SetApiErr() echoes the error to the caller.for use in expressions.
    //
    LONG SetApiErr ( LONG errApi = 0 ) ;
};

class CObjectPlus : public CObject, public CObjHelper
{
public:
    CObjectPlus () ;

    //
    //  Compare one object with another
    //
    virtual int Compare ( const CObjectPlus * pob ) const ;

    //
    //  Define a typedef for an ordering function.
    //
    typedef int (CObjectPlus::*PCOBJPLUS_ORDER_FUNC) ( const CObjectPlus * pobOther ) const ;

    //
    //  Helper function to release RPC memory from RPC API calls.
    //
    static void FreeRpcMemory ( void * pvRpcData ) ;
};

class CObListIter : public CObjectPlus
{
protected:
    POSITION m_pos ;
    const CObOwnedList & m_obList ;

public:
    CObListIter ( const CObOwnedList & obList ) ;

    CObject * Next () ;

    void Reset () ;

    POSITION QueryPosition () const
    {
        return m_pos ;
    }

    void SetPosition(POSITION pos)
    {
        m_pos = pos;
    }
};

//
//  Object pointer list which "owns" the objects pointed to.
//
class CObOwnedList : public CObList, public CObjHelper
{
protected:
    BOOL m_b_owned ;

    static int _cdecl SortHelper ( const void * pa, const void * pb ) ;

public:
    CObOwnedList ( int nBlockSize = 10 ) ;
    virtual ~ CObOwnedList () ;

    BOOL SetOwnership ( BOOL bOwned = TRUE )
    {
        BOOL bOld = m_b_owned ;
        m_b_owned = bOwned ;

        return bOld ;
    }

    CObject * Index ( int index ) ;
    CObject * RemoveIndex ( int index ) ;
    BOOL Remove ( CObject * pob ) ;
    void RemoveAll () ;
    int FindElement ( CObject * pobSought ) const ;

    //
    //  Set all elements to dirty or clean.  Return TRUE if
    //  any element was dirty.
    //
    BOOL SetAll ( BOOL bDirty = FALSE ) ;

    //
    //  Override of CObList::AddTail() to control exception handling.
    //  Returns NULL if addition fails.
    //
    POSITION AddTail ( CObjectPlus * pobj, BOOL bThrowException = FALSE ) ;

    //
    //  Sort the list elements according to the
    //    given ordering function.
    //
    LONG Sort ( CObjectPlus::PCOBJPLUS_ORDER_FUNC pOrderFunc ) ;
};

//
//  Object array which "owns" the objects pointed to.
//
class CObOwnedArray : public CObArray, public CObjHelper
{
protected:
    BOOL m_b_owned ;

    static int _cdecl SortHelper ( const void * pa, const void * pb ) ;

public:
    CObOwnedArray () ;
    virtual ~ CObOwnedArray () ;

    BOOL SetOwnership ( BOOL bOwned = TRUE )
    {
        BOOL bOld = m_b_owned ;
        m_b_owned = bOwned ;
        return bOld ;
    }

    void RemoveAt( int nIndex, int nCount = 1);
    void RemoveAll () ;
    int FindElement ( CObject * pobSought ) const ;

    //
    //  Set all elements to dirty or clean.  Return TRUE if
    //  any element was dirty.
    //
    BOOL SetAll ( BOOL bDirty = FALSE ) ;

    //
    //  Sort the list elements according to the
    //    given ordering function.
    //
    LONG Sort ( CObjectPlus::PCOBJPLUS_ORDER_FUNC pOrderFunc ) ;

private:

    void QuickSort(
        int nLow,
        int nHigh,
        CObjectPlus::PCOBJPLUS_ORDER_FUNC pOrderFunc
        );

    void Swap(
        int nIndex1,
        int nIndex2
        );
};

/***************************************************************************
IPADDRES.H
***************************************************************************/

//
// IP Address Conversion Macros
//
/*
#ifndef MAKEIPADDRESS
  #define MAKEIPADDRESS(b1,b2,b3,b4) ((LONG)(((DWORD)(b1)<<24)+((DWORD)(b2)<<16)+((DWORD)(b3)<<8)+((DWORD)(b4))))

  #define GETIP_FIRST(x)             ((x>>24) & 0xff)
  #define GETIP_SECOND(x)            ((x>>16) & 0xff)
  #define GETIP_THIRD(x)             ((x>> 8) & 0xff)
  #define GETIP_FOURTH(x)            ((x)     & 0xff)
#endif // MAKEIPADDRESS
*/
/////////////////////////////////////////////////////////////////////////////
// CIpAddress class

class CIpAddress : public CObjectPlus
{
public:
    // Constructors
    CIpAddress()
    {
        m_lIpAddress = 0L;
        m_fInitOk = FALSE;
    }
    CIpAddress (LONG l)
    {
        m_lIpAddress = l;
        m_fInitOk = TRUE;
    }
    CIpAddress (BYTE b1, BYTE b2, BYTE b3, BYTE b4)
    {
        m_lIpAddress = MAKEIPADDRESS(b1,b2,b3,b4);
        m_fInitOk = TRUE;
    }
    CIpAddress(const CIpAddress& ia)
    {
        m_lIpAddress = ia.m_lIpAddress;
        m_fInitOk = ia.m_fInitOk;
    }

    CIpAddress (const CString & str);

    //
    // Assignment operators
    //
    const CIpAddress & operator =(const LONG l);
    const CIpAddress & operator =(const CString & str);
    const CIpAddress & operator =(const CIpAddress& ia)
    {
        m_lIpAddress = ia.m_lIpAddress;
        m_fInitOk = ia.m_fInitOk;
        return *this;
    }

    //
    // Conversion operators
    //
    operator const LONG() const
    {
        return m_lIpAddress;
    }
    operator const CString&() const;

public:
    BOOL IsValid() const
    {
        return m_fInitOk;
    }

private:
    LONG m_lIpAddress;
    BOOL m_fInitOk;
};

/****************************************************************************
INTLTIME.H
****************************************************************************/

//
// CIntlTime class definition
//
class CIntlTime : public CTime
{
//
// Attributes
//
public:
    enum _TIME_FORMAT_REQUESTS
    {
        TFRQ_TIME_ONLY,
        TFRQ_DATE_ONLY,
        TFRQ_TIME_AND_DATE,
        TFRQ_TIME_OR_DATE,
        TFRQ_MILITARY_TIME,
    };

public:
// Same contructors as CTime
    CIntlTime();
    CIntlTime(const CTime &timeSrc);
    CIntlTime(time_t time);
    CIntlTime(int nYear, int nMonth, int nDay, int nHour, int nMin, int nSec);
    CIntlTime(WORD wDosDate, WORD wDosTime);
#ifdef _WIN32
    CIntlTime(const SYSTEMTIME& sysTime);
    CIntlTime(const FILETIME& fileTime);
#endif // _WIN32

// New for CIntlTime
    CIntlTime(const CIntlTime &timeSrc);
    CIntlTime(const CString &strTime, int nFormat = TFRQ_TIME_OR_DATE, time_t * ptmOldValue = NULL);

public:
    virtual ~CIntlTime();

// Operations
public:
    // Assignment operators
    const CIntlTime& operator=(time_t tmValue);
    const CIntlTime& operator=(const CString& strValue);
    const CIntlTime& operator=(const CTime & time);
    const CIntlTime& operator=(const CIntlTime & time);

    // Conversion operators
    operator const time_t() const;
    operator CString() const;
    operator const CString() const;

    const CString IntlFormat(int nFormat) const
    {
        return(ConvertToString(nFormat));
    }

    // Validation checks

    BOOL IsValid() const
    {
        return(m_fInitOk);
    }

    static BOOL IsIntlValid()
    {
        return(CIntlTime::m_fIntlOk);
    }

public:
    // ... Input and output
    #ifdef _DEBUG
        friend CDumpContext& AFXAPI operator<<(CDumpContext& dc, const CIntlTime& tim);
    #endif // _DEBUG

    friend CArchive& AFXAPI operator <<(CArchive& ar, const CIntlTime& tim);
    friend CArchive& AFXAPI operator >>(CArchive& ar, CIntlTime& tim);

// Implementation

public:
    static void Reset();
    static void SetBadDateAndTime(CString strBadDate = "--", CString strBadTime = "--")
    {
        m_strBadDate = strBadDate;
        m_strBadTime = strBadTime;
    }
    static CString& GetBadDate()
    {
        return(m_strBadDate);
    }
    static CString& GetBadTime()
    {
        return(m_strBadTime);
    }
    static time_t ConvertFromString (const CString & str, int nFormat, time_t * ptmOldValue, BOOL * pfOk);
    static BOOL IsLeapYear(UINT nYear); // Complete year value
    static BOOL IsValidDate(UINT nMonth, UINT nDay, UINT nYear);
    static BOOL IsValidTime(UINT nHour, UINT nMinute, UINT nSecond);


private:
    enum _DATE_FORMATS
    {
        _DFMT_MDY,  // Day, month, year
        _DFMT_DMY,  // Month, day, year
        _DFMT_YMD,  // Year, month, day
    };

    typedef struct _INTL_TIME_SETTINGS
    {
        CString strDateSeperator; // String used between date fields
        CString strTimeSeperator; // String used between time fields.
        CString strAM;            // Suffix string used for 12 hour clock AM times
        CString strPM;            // Suffix string used for 12 hour clock PM times
        int nDateFormat;          // see _DATE_FORMATS enum above.
        BOOL f24HourClock;        // TRUE = 24 hours, FALSE is AM/PM
        BOOL fCentury;            // If TRUE, uses 4 digits for the century
        BOOL fLeadingTimeZero;    // If TRUE, uses leading 0 in time format
        BOOL fLeadingDayZero;     // If TRUE, uses leading 0 in day
        BOOL fLeadingMonthZero;   // If TRUE, uses leading 0 in month
    } INTL_TIME_SETTINGS;

    static INTL_TIME_SETTINGS m_itsInternationalSettings;
    static CString m_strBadTime;
    static CString m_strBadDate;

private:
    static BOOL SetIntlTimeSettings();
    static BOOL m_fIntlOk;

private:
    const CString GetDateString() const;
    const CString GetTimeString() const;
    const CString GetMilitaryTime() const;
    const CString ConvertToString(int nFormat) const;

private:
    BOOL m_fInitOk;
};

/****************************************************************************
NUMERIC.H
****************************************************************************/

class CIntlNumber : public CObjectPlus
{
public:
    CIntlNumber()
    {
        m_lValue = 0L;
        m_fInitOk = TRUE;
    }
    CIntlNumber(LONG lValue)
    {
        m_lValue = lValue;
        m_fInitOk = TRUE;
    }
    CIntlNumber(const CString & str);

    CIntlNumber(CIntlNumber const &x)
    {
        m_lValue = x.m_lValue;
        m_fInitOk = x.m_fInitOk;
    }

    CIntlNumber& operator =(CIntlNumber const &x)
    {
        m_lValue = x.m_lValue;
        m_fInitOk = x.m_fInitOk;
        return(*this);
    }

public:
    // Assignment Operators
    CIntlNumber& operator =(LONG l);
    CIntlNumber& operator =(const CString &str);

    // Shorthand operators.
    CIntlNumber& operator +=(const CIntlNumber& num);
    CIntlNumber& operator +=(const LONG l);
    CIntlNumber& operator -=(const CIntlNumber& num);
    CIntlNumber& operator -=(const LONG l);
    CIntlNumber& operator /=(const CIntlNumber& num);
    CIntlNumber& operator /=(const LONG l);
    CIntlNumber& operator *=(const CIntlNumber& num);
    CIntlNumber& operator *=(const LONG l);

    // Conversion operators
    operator const LONG() const
    {
        return(m_lValue);
    }
    operator const CString() const;

public:
    virtual BOOL IsValid() const
    {
        return(m_fInitOk);
    }

public:
    static void Reset();
    static void SetBadNumber(CString strBadNumber = "--")
    {
        m_strBadNumber = strBadNumber;
    }
    static CString ConvertNumberToString(const LONG l);
    static LONG ConvertStringToNumber(const CString & str, BOOL * pfOk);
    static CString& GetBadNumber()
    {
        return(m_strBadNumber);
    }

private:
    static CString GetThousandSeperator();

private:
    static CString m_strThousandSeperator;
    static CString m_strBadNumber;

private:
    LONG m_lValue;
    BOOL m_fInitOk;

public:
    #ifdef _DEBUG
        friend CDumpContext& AFXAPI operator<<(CDumpContext& dc, const CIntlNumber& num);
    #endif // _DEBUG

    friend CArchive& AFXAPI operator<<(CArchive& ar, const CIntlNumber& num);
    friend CArchive& AFXAPI operator>>(CArchive& ar, CIntlNumber& num);
};

class CIntlLargeNumber : public CObjectPlus
{
public:
    CIntlLargeNumber()
    {
        m_lLowValue = 0L;
        m_lHighValue = 0L;
        m_fInitOk = TRUE;
    }
    CIntlLargeNumber(LONG lHighWord, LONG lLowWord)
    {
        m_lLowValue = lLowWord;
        m_lHighValue = lHighWord;
        m_fInitOk = TRUE;
    }
    CIntlLargeNumber(const CString & str);

public:
    // Assignment Operators
    CIntlLargeNumber& operator =(const CString &str);
    operator const CString() { return ConvertNumberToString(); }
    operator CString() { return ConvertNumberToString(); }

public:
    virtual LONG GetLowWord() const { return m_lLowValue; }
    virtual LONG GetHighWord() const { return m_lHighValue; }
    virtual BOOL IsValid() const { return(m_fInitOk); }

private:
    static CString m_strBadNumber;
    CString ConvertNumberToString();
    void ConvertStringToNumber(const CString & str, BOOL * pfOk);

private:
    LONG m_lLowValue;
    LONG m_lHighValue;
    BOOL m_fInitOk;
};

/****************************************************************************
REGISTRY.H
****************************************************************************/

//
//  Forward declarations
//
//class CRegKey ;
class CRegValueIter ;
class CRegKeyIter ;

//
//  Maximum size of a Registry class name
//
#define CREGKEY_MAX_CLASS_NAME MAX_PATH

//
//  Wrapper for a Registry key handle.
//
/*
class CRegKey : public CObjectPlus
{
protected:
    HKEY m_hKey ;
    DWORD m_dwDisposition ;

    //  Prepare to read a value by finding the value's size.
    LONG PrepareValue (
        const char * pchValueName,
        DWORD * pdwType,
        DWORD * pcbSize,
        BYTE ** ppbData
        );

    //  Convert a CStringList to the REG_MULTI_SZ format
    static LONG FlattenValue (
        CStringList & strList,
        DWORD * pcbSize,
        BYTE ** ppbData
        );

    //  Convert a CByteArray to a REG_BINARY block
    static LONG FlattenValue (
        CByteArray & abData,
        DWORD * pcbSize,
        BYTE ** ppbData
        );

public:
    //
    //  Key information return structure
    //
    typedef struct
    {
        char chBuff [CREGKEY_MAX_CLASS_NAME] ;
        DWORD dwClassNameSize,
              dwNumSubKeys,
              dwMaxSubKey,
              dwMaxClass,
              dwMaxValues,
              dwMaxValueName,
              dwMaxValueData,
              dwSecDesc ;
        FILETIME ftKey ;
    } CREGKEY_KEY_INFO ;

    //
    //  Standard constructor for an existing key
    //
    CRegKey (
        HKEY hKeyBase,
        const char * pchSubKey = NULL,
        REGSAM regSam = KEY_ALL_ACCESS,
        const char * pchServerName = NULL
        );

    //
    //  Constructor creating a new key.
    //
    CRegKey (
        const char * pchSubKey,
        HKEY hKeyBase,
        DWORD dwOptions = 0,
        REGSAM regSam = KEY_ALL_ACCESS,
        LPSECURITY_ATTRIBUTES pSecAttr = NULL,
        const char * pchServerName = NULL
        );

    ~ CRegKey () ;

    //
    //  Allow a CRegKey to be used anywhere an HKEY is required.
    //
    operator HKEY ()
    {
        return m_hKey ;
    }

    //
    //  Fill a key information structure
    //
    LONG QueryKeyInfo ( CREGKEY_KEY_INFO * pRegKeyInfo ) ;

    //
    //  Overloaded value query members; each returns ERROR_INVALID_PARAMETER
    //  if data exists but not in correct form to deliver into result object.
    //
    LONG QueryValue ( const char * pchValueName, CString & strResult ) ;
    LONG QueryValue ( const char * pchValueName, CStringList & strList ) ;
    LONG QueryValue ( const char * pchValueName, DWORD & dwResult ) ;
    LONG QueryValue ( const char * pchValueName, CByteArray & abResult ) ;
    LONG QueryValue ( const char * pchValueName, CIntlTime & itmResult ) ;
    LONG QueryValue ( const char * pchValueName, CIntlNumber & inResult ) ;
    LONG QueryValue ( const char * pchValueName, void * pvResult, DWORD cbSize );

    //  Overloaded value setting members.
    LONG SetValue ( const char * pchValueName, CString & strResult ) ;
    LONG SetValue ( const char * pchValueName, CString & strResult , BOOL fRegExpand) ;
    LONG SetValue ( const char * pchValueName, CStringList & strList ) ;
    LONG SetValue ( const char * pchValueName, DWORD & dwResult ) ;
    LONG SetValue ( const char * pchValueName, CByteArray & abResult ) ;
    LONG SetValue ( const char * pchValueName, CIntlTime & itmResult ) ;
    LONG SetValue ( const char * pchValueName, CIntlNumber & inResult ) ;
    LONG SetValue ( const char * pchValueName, void * pvResult, DWORD cbSize );
};
*/

//
//  Iterate the values of a key, return the name and type
//  of each.
//
class CRegValueIter : public CObjectPlus
{
protected:
    //CRegKey & m_rk_iter ;
    DWORD m_dw_index ;
    char * m_p_buffer ;
    DWORD m_cb_buffer ;

public:
    //CRegValueIter ( CRegKey & regKey ) ;
    ~ CRegValueIter () ;

    //
    // Get the name (and optional last write time) of the next key.
    //
    LONG Next ( CString * pstrName, DWORD * pdwType ) ;

    //
    // Reset the iterator
    //
    void Reset ()
    {
        m_dw_index = 0 ;
    }
};

//
//  Iterate the sub-key names of a key.
//
class CRegKeyIter : public CObjectPlus
{
protected:
    //CRegKey & m_rk_iter ;
    DWORD m_dw_index ;
    char * m_p_buffer ;
    DWORD m_cb_buffer ;

public:
    //CRegKeyIter ( CRegKey & regKey ) ;
    ~ CRegKeyIter () ;

    // Get the name (and optional last write time) of the next key.
    LONG Next ( CString * pstrName, CTime * pTime = NULL ) ;

    // Reset the iterator
    void Reset ()
    {
        m_dw_index = 0 ;
    }
};

/****************************************************************************
LISTBOX.H
****************************************************************************/

class CListBoxExResources
{
public:
    CListBoxExResources
    (
        int bmId,
        int nBitmapWidth,
        COLORREF crBackground = RGB(0,255,0)
    );

    ~CListBoxExResources();

private:
    COLORREF m_ColorWindow;
    COLORREF m_ColorHighlight;
    COLORREF m_ColorWindowText;
    COLORREF m_ColorHighlightText;
    COLORREF m_ColorTransparent;

    CDC      m_dcFinal;
    HGDIOBJ  m_hOldBitmap;
    CBitmap  m_BmpScreen;
    int      m_BitMapId;
    int      m_BitmapHeight;
    int      m_BitmapWidth;
    int      m_nBitmaps;

private:
    void GetSysColors();
    void PrepareBitmaps( BOOL );
    void UnprepareBitmaps();
    void UnloadResources();
    void LoadResources();

public:
    void SysColorChanged();
    const CDC& DcBitMap() const
    {
        return m_dcFinal;
    }
    int BitmapHeight() const
    {
        return m_BitmapHeight;
    }
    int BitmapWidth() const
    {
        return m_BitmapWidth;
    }
    COLORREF ColorWindow() const
    {
        return m_ColorWindow;
    }
    COLORREF ColorHighlight() const
    {
        return m_ColorHighlight;
    }
    COLORREF ColorWindowText() const
    {
        return m_ColorWindowText;
    }
    COLORREF ColorHighlightText() const
    {
        return m_ColorHighlightText;
    }
};

class CListBoxExDrawStruct
{
public:
    CListBoxExDrawStruct(
        CDC* pdc,
        RECT* pRect,
        BOOL sel,
        DWORD item,
        int itemIndex,
        const CListBoxExResources* pres
        )
    {
        m_pDC = pdc;
        m_Sel = sel;
        m_ItemData = item;
        m_ItemIndex = itemIndex;
        m_pResources = pres;
        m_Rect.CopyRect(pRect);
    }

public:
    const CListBoxExResources * m_pResources;
    CDC*  m_pDC;
    CRect m_Rect;
    BOOL  m_Sel;
    DWORD m_ItemData;
    int   m_ItemIndex;

};

class CListBoxEx : public CListBox
{
protected:
    int m_lfHeight;

protected:
    const CListBoxExResources* m_pResources;

//
// Construction
//
public:
    CListBoxEx();
    void AttachResources(const CListBoxExResources* );

//
// Attributes
//
public:
    short TextHeight() const
    {
        return m_lfHeight;
    }

//
// Operations
//
public:
    BOOL ChangeFont(
        CFont*
        );

//
// Implementation
//
public:
    virtual ~CListBoxEx();

protected:
    virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMIS);
    virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);

protected:
    //
    // must override this to provide drawing of item
    //
    /* PURE */ virtual void DrawItemEx( CListBoxExDrawStruct& ) = 0;

    //
    // Helper function to display text in a limited rectangle
    //
    static BOOL ColumnText(CDC * pDC, int left, int top, int right, int bottom, const CString & str);

private:
    void CalculateTextHeight(CFont*);

protected:
    //{{AFX_MSG(CListBoxEx)
    afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    DECLARE_DYNAMIC(CListBoxEx)
};

/****************************************************************************
METAL.H
****************************************************************************/

class CMetalString : public CButton
{
public:
    CMetalString()
    {
    }

protected:
    afx_msg void OnPaint();
    DECLARE_MESSAGE_MAP()
};

/****************************************************************************
SPINCTRL.H
****************************************************************************/

class CSpinBox; // Forward decleration;

class CSpinButton : public CButton
{
public:
    CSpinButton();

    //
    // Associate with parent spinner control
    //
    void Associate(
        CSpinBox * pParent
        )
    {
        m_pParent = pParent;
    }

//
// Implementation
//
protected:
    void NotifyParent();
    void Paint(LPDRAWITEMSTRUCT lpDIS);
    virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);

    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnTimer(UINT nIDEvent);
    afx_msg BOOL OnEraseBkgnd(CDC* pDC);

    DECLARE_MESSAGE_MAP()

private:
    typedef enum tagArrowDirection
    {
        enumArrowUp,
        enumArrowDown
    } ARROWDIRECTION;

    ARROWDIRECTION m_ArrowType;

    CSpinBox * m_pParent; // Point back to the edit associated edit box
    BOOL m_fButton;
    BOOL m_fRealButton;
    CRect m_rcUp;
    CRect m_rcDown;
    UINT m_uScroll;
    UINT m_uTimer;
    BOOL m_fKeyDown;
};

class CSpinBox : public CEdit
{

public:
    typedef enum tagEDITTYPE
    {
        enumNormal,             // Perform no modification at all
        enumSeconds,            // Value represents the number of seconds
        enumMinutes,            // Value is in minutes.
        enumMinutesHigh,        // Value is in minutes, which is the highest unit
        enumHours,              // Value is in hours
        enumHoursHigh,          // Value is in hours, which is the highest unit
        enumDays,               // Value in in days
        enumDaysHigh,           // Value is in days, which is the highest unit

    } EDITTYPE;

public:
    CSpinBox(
        int nMin,
        int nMax,
        int nButtonId,
        EDITTYPE nType = enumNormal,
        BOOL fLeadingZero = FALSE
        );

    BOOL SubclassDlgItem(UINT nID, CWnd *pParent);
    BOOL EnableWindow(BOOL bEnable = TRUE);

public:
    void OnScrollUp();
    void OnScrollDown();
    void SetValue(int nValue);
    BOOL GetValue(int &nValue);

// Implementation
protected:
    virtual void OnBadInput();
    void IncreaseContent(int nDelta);

    afx_msg void OnChar(UINT, UINT, UINT); // for character validation

    DECLARE_MESSAGE_MAP()

protected:
    int m_nButtonId;
    int m_nMin;
    int m_nMax;
    EDITTYPE m_etType;
    BOOL m_fLeadingZero;

    CSpinButton m_button_Spin;      // Associated scroll bar
};

/////////////////////////////////////////////////////////////////////////////

#endif  // _COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\config.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	config.cpp
		Registry Values for WINS
		
    FILE HISTORY:
        
*/


#include "stdafx.h"
#include "config.h"
#include "tregkey.h"

// these are things not defined in winscnst.h.  

// Registry Entries under HKEY_LOCAL_MACHINE\system\currentcontrolset\services\wins
const CConfiguration::REGKEYNAME CConfiguration::lpstrRoot = _T("SYSTEM\\CurrentControlSet\\Services\\wins\\Parameters");

// consistency checking
const CConfiguration::REGKEYNAME CConfiguration::lpstrCCRoot = _T("SYSTEM\\CurrentControlSet\\Services\\wins\\Parameters\\ConsistencyCheck");
const CConfiguration::REGKEYNAME CConfiguration::lpstrCC = _T("ConsistencyCheck");

// default values for replication partners
const CConfiguration::REGKEYNAME CConfiguration::lpstrDefaultsRoot = _T("SYSTEM\\CurrentControlSet\\Services\\wins\\Parameters\\Defaults");
const CConfiguration::REGKEYNAME CConfiguration::lpstrPullDefaultsRoot = _T("SYSTEM\\CurrentControlSet\\Services\\wins\\Parameters\\Defaults\\Pull");
const CConfiguration::REGKEYNAME CConfiguration::lpstrPushDefaultsRoot = _T("SYSTEM\\CurrentControlSet\\Services\\wins\\Parameters\\Defaults\\Push");

// entries under HKEY_LOCAL_MACHINE\system\currentcontrolset\services\wins\partnets\pull
const CConfiguration::REGKEYNAME CConfiguration::lpstrPullRoot = _T("SYSTEM\\CurrentControlSet\\Services\\wins\\Partners\\Pull");

// entries under HKEY_LOCAL_MACHINE\system\currentcontrolset\services\wins\partnets\push
const CConfiguration::REGKEYNAME CConfiguration::lpstrPushRoot = _T("SYSTEM\\CurrentControlSet\\Services\\wins\\Partners\\Push");

// per-replication partner parameters
const CConfiguration::REGKEYNAME CConfiguration::lpstrNetBIOSName = _T("NetBIOSName");

// entry for global setting for persistence
const CConfiguration::REGKEYNAME CConfiguration::lpstrPersistence = _T("PersistentRplOn");

// for determining system version
const CConfiguration::REGKEYNAME CConfiguration::lpstrCurrentVersion = _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion");
const CConfiguration::REGKEYNAME CConfiguration::lpstrWinVersion = _T("CurrentVersion");
const CConfiguration::REGKEYNAME CConfiguration::lpstrSPVersion = _T("CSDVersion");
const CConfiguration::REGKEYNAME CConfiguration::lpstrBuildNumber = _T("CurrentBuildNumber");

/*---------------------------------------------------------------------------
	CConfiguration::CConfiguration(CString strNetBIOSName)	
		Constructor
---------------------------------------------------------------------------*/
CConfiguration::CConfiguration(CString strNetBIOSName)
    : m_strNetBIOSName(strNetBIOSName)
{
    m_dwMajorVersion = 0;
    m_dwMinorVersion = 0;
    m_dwBuildNumber = 0;
    m_dwServicePack = 0;

	m_dwPushPersistence = 0;
	m_dwPullPersistence = 0;

    m_fIsAdmin = FALSE;

	m_strDbName = _T("wins.mdb");  // default db name
}


/*---------------------------------------------------------------------------
	CConfiguration::~CConfiguration()
		Destructor
---------------------------------------------------------------------------*/
CConfiguration::~CConfiguration()
{
}


/*---------------------------------------------------------------------------
	CConfiguration:: operator =(const CConfiguration& configuration)
		Overloaded assignment operator
---------------------------------------------------------------------------*/
CConfiguration& 
CConfiguration:: operator =(const CConfiguration& configuration)
{
	m_strNetBIOSName = configuration.m_strNetBIOSName;
	m_strBackupPath = configuration.m_strBackupPath;
    
	m_dwRefreshInterval = configuration.m_dwRefreshInterval;
    m_dwTombstoneInterval = configuration.m_dwTombstoneInterval;
    m_dwTombstoneTimeout = configuration.m_dwTombstoneTimeout;
    m_dwVerifyInterval = configuration.m_dwVerifyInterval;
    m_dwVersCountStart_LowWord = configuration.m_dwVersCountStart_LowWord;
    m_dwVersCountStart_HighWord= configuration.m_dwVersCountStart_HighWord;
    m_dwNumberOfWorkerThreads = configuration.m_dwNumberOfWorkerThreads;

    m_fPullInitialReplication = configuration.m_fPullInitialReplication;
    m_dwPullRetryCount = configuration.m_dwPullRetryCount;
    m_dwPullTimeInterval = configuration.m_dwPullTimeInterval;
    m_dwPullSpTime = configuration.m_dwPullSpTime;

    m_fPushInitialReplication = configuration.m_fPushInitialReplication;
    m_fPushReplOnAddrChange = configuration.m_fPushReplOnAddrChange;
    m_dwPushUpdateCount = configuration.m_dwPushUpdateCount;

    m_fRplOnlyWithPartners = configuration.m_fRplOnlyWithPartners;
    m_fLogDetailedEvents = configuration.m_fLogDetailedEvents;
    m_fBackupOnTermination = configuration.m_fBackupOnTermination;
    m_fLoggingOn = configuration.m_fLoggingOn;
    m_fMigrateOn = configuration.m_fMigrateOn;
    
	m_fUseSelfFndPnrs = configuration.m_fUseSelfFndPnrs;
	m_dwMulticastInt =  configuration.m_dwMulticastInt;
	m_dwMcastTtl = configuration.m_dwMcastTtl;

	m_dwPullPersistence = configuration.m_dwPullPersistence;
	m_dwPushPersistence = configuration.m_dwPushPersistence;
	
    m_fBurstHandling = configuration.m_fBurstHandling;
    m_dwBurstQueSize = configuration.m_dwBurstQueSize;
	
    m_fPeriodicConsistencyCheck = configuration.m_fPeriodicConsistencyCheck;
    m_fCCUseRplPnrs = configuration.m_fCCUseRplPnrs;
    m_dwMaxRecsAtATime = configuration.m_dwMaxRecsAtATime;
    m_dwCCTimeInterval = configuration.m_dwCCTimeInterval;
    m_itmCCStartTime = configuration.m_itmCCStartTime;
    
    m_dwMajorVersion = configuration.m_dwMajorVersion;
    m_dwMinorVersion = configuration.m_dwMinorVersion;
    m_dwBuildNumber = configuration.m_dwBuildNumber;
    m_dwServicePack = configuration.m_dwServicePack;

    m_fIsAdmin = configuration.m_fIsAdmin;

    m_strDbPath = configuration.m_strDbPath;

    return *this;
}


HRESULT
CConfiguration::Touch()
{
	HRESULT hr = hrOK;
    return hr;
}


/*---------------------------------------------------------------------------
	CConfiguration::Load()
		Reads the values from the registry
 ---------------------------------------------------------------------------*/
HRESULT
CConfiguration::Load(handle_t hBinding)
{
	HRESULT hr = hrOK;

	DWORD err = ERROR_SUCCESS;
	CString strDefaultPullSpTime;

	err = GetSystemVersion();
    if (err)
        return err;

    RegKey rk;
    err = rk.Open(HKEY_LOCAL_MACHINE, (LPCTSTR) lpstrRoot, KEY_READ, m_strNetBIOSName);
    if (err)
    {
        // may not exist, try creating the key
	    err = rk.Create(HKEY_LOCAL_MACHINE,(LPCTSTR) lpstrRoot, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,NULL, m_strNetBIOSName);
    }

	RegKey rkPull;
    err = rkPull.Open(HKEY_LOCAL_MACHINE, (LPCTSTR) lpstrPullRoot, KEY_READ, m_strNetBIOSName);
    if (err)
    {
        // may not exist, try creating the key
	    err = rkPull.Create(HKEY_LOCAL_MACHINE, (LPCTSTR)lpstrPullRoot, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,NULL, m_strNetBIOSName);
    }

	RegKey rkPush;
    err = rkPush.Open(HKEY_LOCAL_MACHINE, (LPCTSTR) lpstrPushRoot, KEY_READ, m_strNetBIOSName);
    if (err)
    {
        // may not exist, try creating the key
    	err = rkPush.Create(HKEY_LOCAL_MACHINE, (LPCTSTR)lpstrPushRoot, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,NULL, m_strNetBIOSName);
    }

	RegKey rkPullDefaults;
    err = rkPullDefaults.Open(HKEY_LOCAL_MACHINE, (LPCTSTR) lpstrPullDefaultsRoot, KEY_READ, m_strNetBIOSName);
    if (err)
    {
        // may not exist, try creating the key
    	err = rkPullDefaults.Create(HKEY_LOCAL_MACHINE, (LPCTSTR)lpstrPullDefaultsRoot, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,NULL, m_strNetBIOSName);
    }

	RegKey rkPushDefaults;
    err = rkPushDefaults.Open(HKEY_LOCAL_MACHINE, (LPCTSTR) lpstrPushDefaultsRoot, KEY_READ, m_strNetBIOSName);
    if (err)
    {
        // may not exist, try creating the key
    	err = rkPushDefaults.Create(HKEY_LOCAL_MACHINE, (LPCTSTR)lpstrPushDefaultsRoot, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,NULL, m_strNetBIOSName);
    }

    // if you could not locate the key, no point continuing
	//if (err)
	//	return err;

    // now query for the various values
    err = ERROR_FILE_NOT_FOUND;
	if (
        ((HKEY) rk == NULL) ||
		(err = rk.QueryValue(WINSCNF_REFRESH_INTVL_NM,                  m_dwRefreshInterval)) ||
       	(err = rk.QueryValue(WINSCNF_DO_BACKUP_ON_TERM_NM,    (DWORD &) m_fBackupOnTermination)) ||
        (err = rk.QueryValue(WINSCNF_TOMBSTONE_INTVL_NM,                m_dwTombstoneInterval)) ||
        (err = rk.QueryValue(WINSCNF_TOMBSTONE_TMOUT_NM,                m_dwTombstoneTimeout)) ||
        (err = rk.QueryValue(WINSCNF_VERIFY_INTVL_NM,                   m_dwVerifyInterval)) ||
        (err = rk.QueryValue(WINSCNF_INIT_VERSNO_VAL_LW_NM,             m_dwVersCountStart_LowWord)) ||
        (err = rk.QueryValue(WINSCNF_INIT_VERSNO_VAL_HW_NM,             m_dwVersCountStart_HighWord)) ||
        (err = rk.QueryValue(WINSCNF_RPL_ONLY_W_CNF_PNRS_NM,  (DWORD &) m_fRplOnlyWithPartners)) ||
        (err = rk.QueryValue(WINSCNF_LOG_DETAILED_EVTS_NM,    (DWORD &) m_fLogDetailedEvents)) ||
        (err = rk.QueryValue(WINSCNF_LOG_FLAG_NM,             (DWORD &) m_fLoggingOn)) ||
        (err = rk.QueryValue(WINSCNF_MIGRATION_ON_NM,         (DWORD &) m_fMigrateOn))
	   )
    {
        if (err == ERROR_FILE_NOT_FOUND)
        {
            // This error is ok, because it just means
            // that the registry entries did not exist
            // for them yet.  Set some acceptible default
            // values.
            m_fBackupOnTermination = FALSE;
            m_dwVersCountStart_LowWord = 0;
            m_dwVersCountStart_HighWord = 0;
            m_fRplOnlyWithPartners = TRUE;
            m_fLogDetailedEvents = FALSE;
            m_fLoggingOn = TRUE;
            m_fMigrateOn = FALSE;

            m_dwNumberOfWorkerThreads = 1;

            err = ERROR_SUCCESS;
        }
        else
        {
              return err;
        }
    }

    // push stuff
    if (
        ((HKEY) rkPush == NULL) ||
        (err = rkPush.QueryValue(WINSCNF_INIT_TIME_RPL_NM,   (DWORD &) m_fPushInitialReplication)) ||
        (err = rkPush.QueryValue(WINSCNF_ADDCHG_TRIGGER_NM,  (DWORD &) m_fPushReplOnAddrChange)) 
       )
    {
        m_fPushInitialReplication = FALSE;
        m_fPushReplOnAddrChange = FALSE;

        err = ERROR_SUCCESS;
    }

    // pull stuff
    if (
        ((HKEY) rkPull == NULL) ||
        (err = rkPull.QueryValue(WINSCNF_INIT_TIME_RPL_NM, (DWORD &)  m_fPullInitialReplication)) ||
        (err = rkPull.QueryValue(WINSCNF_RETRY_COUNT_NM,              m_dwPullRetryCount))
       )
    {
        m_fPullInitialReplication = TRUE;
        m_dwPullRetryCount = WINSCNF_MAX_COMM_RETRIES;

        err = ERROR_SUCCESS;
    }

    // get the backup path.  
    if (err = rk.QueryValue(WINSCNF_BACKUP_DIR_PATH_NM, m_strBackupPath))
    {
        m_strBackupPath = "";

        err = ERROR_SUCCESS;
    }

    // get the defaults for push update count and pull time interval.
    if (
        ((HKEY) rkPushDefaults == NULL) ||
        ((HKEY) rkPullDefaults == NULL) ||
        (err = rkPushDefaults.QueryValue(WINSCNF_UPDATE_COUNT_NM, m_dwPushUpdateCount)) ||
        (err = rkPullDefaults.QueryValue(WINSCNF_RPL_INTERVAL_NM, m_dwPullTimeInterval)) 
        )
    {
        // set defaults
        m_dwPushUpdateCount = 0;
        m_dwPullTimeInterval = 1800;

        err = ERROR_SUCCESS;
    }

    // get the default pull sptime
    err = rkPullDefaults.QueryValue(WINSCNF_SP_TIME_NM, strDefaultPullSpTime);
    if (err == ERROR_FILE_NOT_FOUND)
    {
        m_dwPullSpTime = 0;
    }
    else
    {
        // a string was loaded so
        // conver the string into a DWORD which is what we use
        CIntlTime timeDefault(strDefaultPullSpTime);

        m_dwPullSpTime = (DWORD) timeDefault;
    }

	// query for the multicast stuff
    err = ERROR_FILE_NOT_FOUND;
	if(
        ((HKEY) rk == NULL) ||
		(err = rk.QueryValue(WINSCNF_USE_SELF_FND_PNRS_NM, (DWORD &) m_fUseSelfFndPnrs)) ||
		(err = rk.QueryValue(WINSCNF_MCAST_INTVL_NM,       (DWORD &) m_dwMulticastInt)) ||
		(err = rk.QueryValue(WINSCNF_MCAST_TTL_NM,         (DWORD &) m_dwMcastTtl)) 
	  )
	{
		// set the default values
		if (err == ERROR_FILE_NOT_FOUND)
        {
            m_fUseSelfFndPnrs = FALSE;
			m_dwMulticastInt = WINSCNF_DEF_MCAST_INTVL;
			m_dwMcastTtl = WINSCNF_DEF_MCAST_TTL;

            err = ERROR_SUCCESS;
        }
        else
        {
              return err;
        }
	}

	// query for the global persistence stuff
    err = ERROR_FILE_NOT_FOUND;

	if(
        ((HKEY) rkPush == NULL) ||
        ((HKEY) rkPull == NULL) ||
		(err = rkPush.QueryValue(lpstrPersistence, (DWORD &) m_dwPushPersistence)) ||
		(err = rkPull.QueryValue(lpstrPersistence, (DWORD &) m_dwPullPersistence)) 
	  )
	{
		// set the default values
		if (err == ERROR_FILE_NOT_FOUND)
        {
			m_dwPushPersistence = 1;
			m_dwPullPersistence = 1;

            err = ERROR_SUCCESS;
        }
        else
        {
            return err;
        }
	}

	// query for the burst handling stuff
    err = ERROR_FILE_NOT_FOUND;
	if(
        ((HKEY) rk == NULL) ||
		(err = rk.QueryValue(WINSCNF_BURST_HANDLING_NM, (DWORD &) m_fBurstHandling)) ||
		(err = rk.QueryValue(WINSCNF_BURST_QUE_SIZE_NM, (DWORD &) m_dwBurstQueSize))
	  )
	{
		// set the default values
		if (err == ERROR_FILE_NOT_FOUND)
        {
            // SP4 and greater burst handling is turned on by default
            // RamC changed m_dwServicePack == 4 check to 
            //              m_dwServicePack >= 4
            if ( (m_dwMajorVersion == 4 && m_dwServicePack >= 4) ||
                 (m_dwMajorVersion >= 5) )
            {
                m_fBurstHandling = TRUE;
            }
            else
            {
                m_fBurstHandling = FALSE;
            }

            m_dwBurstQueSize = WINS_QUEUE_HWM;
            
            err = ERROR_SUCCESS;
        }
        else
        {
              return err;
        }
	}

   	// read in the db name
	CString strDb;

	if (err = rk.QueryValue(WINSCNF_DB_FILE_NM, strDb))
	{
        m_strDbPath = _T("%windir%\\system32\\wins");
    }
	else
	{
		// take off the trailing filename
		int nLastBack = strDb.ReverseFind('\\');
		if (nLastBack != -1)
		{
			m_strDbPath = strDb.Left(nLastBack);
			m_strDbName = strDb.Right(strDb.GetLength() - nLastBack - 1);
		}
	}

	// consistency checking
    RegKey rkCC;
	err = rkCC.Open(HKEY_LOCAL_MACHINE, lpstrCCRoot, KEY_READ, m_strNetBIOSName);
    if (err == ERROR_FILE_NOT_FOUND)
    {
        // not there, use defaults
        m_fPeriodicConsistencyCheck = FALSE;
        m_fCCUseRplPnrs = FALSE;
        m_dwMaxRecsAtATime = WINSCNF_CC_DEF_RECS_AAT;
        m_dwCCTimeInterval = WINSCNF_CC_DEF_INTERVAL;
        
        CIntlTime timeDefault(_T("02:00:00"));
        m_itmCCStartTime = timeDefault;
    }
    else
    {
        m_fPeriodicConsistencyCheck = TRUE;

        CString strSpTime;

        // read in the values
	    if (err = rkCC.QueryValue(WINSCNF_CC_MAX_RECS_AAT_NM, m_dwMaxRecsAtATime))
        {
            m_dwMaxRecsAtATime = WINSCNF_CC_DEF_RECS_AAT;
        }

		if (err = rkCC.QueryValue(WINSCNF_CC_USE_RPL_PNRS_NM, (DWORD &) m_fCCUseRplPnrs))
        {
            m_fCCUseRplPnrs = FALSE;
        }
		
        if (err = rkCC.QueryValue(WINSCNF_SP_TIME_NM, strSpTime))
        {
            strSpTime = _T("02:00:00");
        }

        CIntlTime time(strSpTime);
        m_itmCCStartTime = time;

		if (err = rkCC.QueryValue(WINSCNF_CC_INTVL_NM, m_dwCCTimeInterval))
        {
            m_dwCCTimeInterval = WINSCNF_CC_DEF_INTERVAL;
        }
    }

    GetAdminStatus();

    // Now read the "live" values and override the values read from the registry
	if (hBinding)
	{
		WINSINTF_RESULTS_T Results;

		Results.WinsStat.NoOfPnrs = 0;
		Results.WinsStat.pRplPnrs = NULL;
		Results.NoOfWorkerThds = 1;

#ifdef WINS_CLIENT_APIS
		err = ::WinsStatus(hBinding, WINSINTF_E_CONFIG, &Results);
#else
		err = ::WinsStatus(WINSINTF_E_CONFIG, &Results);
#endif WINS_CLIENT_APIS

		m_dwRefreshInterval = Results.RefreshInterval;
		m_dwTombstoneInterval = Results.TombstoneInterval;
		m_dwTombstoneTimeout = Results.TombstoneTimeout;
		m_dwVerifyInterval = Results.VerifyInterval;
		m_dwNumberOfWorkerThreads =  Results.NoOfWorkerThds;

		if (err != ERROR_SUCCESS)
		{
			return err;
		}
	}

	return hr;
}


/*---------------------------------------------------------------------------
	CConfiguration::Store()
		Stores back the values to the registry
---------------------------------------------------------------------------*/
HRESULT
CConfiguration::Store()
{
	HRESULT hr = hrOK;
   
    DWORD err;

	RegKey rk;
	RegKey rkPull;
	RegKey rkPush;
	RegKey rkUser;
	RegKey rkPullDefaults;
	RegKey rkPushDefaults;
    RegKey rkCC;
    
	err = rk.Create(HKEY_LOCAL_MACHINE,(LPCTSTR) lpstrRoot, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,NULL, m_strNetBIOSName);
	err = rkPull.Create(HKEY_LOCAL_MACHINE, (LPCTSTR)lpstrPullRoot, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,NULL, m_strNetBIOSName);
	err= rkPush.Create(HKEY_LOCAL_MACHINE, (LPCTSTR)lpstrPushRoot, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,NULL, m_strNetBIOSName);
	err = rkPullDefaults.Create(HKEY_LOCAL_MACHINE, (LPCTSTR)lpstrPullDefaultsRoot, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,NULL, m_strNetBIOSName);
	err = rkPushDefaults.Create(HKEY_LOCAL_MACHINE, (LPCTSTR)lpstrPushDefaultsRoot, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,NULL, m_strNetBIOSName);

	if (err)
		return err;
	
    if(
		(err = rk.SetValue(WINSCNF_REFRESH_INTVL_NM,                  m_dwRefreshInterval)) ||
        (err = rk.SetValue(WINSCNF_DO_BACKUP_ON_TERM_NM,    (DWORD &) m_fBackupOnTermination)) ||
        (err = rk.SetValue(WINSCNF_TOMBSTONE_INTVL_NM,                m_dwTombstoneInterval)) ||
        (err = rk.SetValue(WINSCNF_TOMBSTONE_TMOUT_NM,                m_dwTombstoneTimeout)) ||
        (err = rk.SetValue(WINSCNF_VERIFY_INTVL_NM,                   m_dwVerifyInterval)) ||
        (err = rk.SetValue(WINSCNF_INIT_VERSNO_VAL_LW_NM,             m_dwVersCountStart_LowWord)) ||
        (err = rk.SetValue(WINSCNF_INIT_VERSNO_VAL_HW_NM,             m_dwVersCountStart_HighWord)) ||
        (err = rk.SetValue(WINSCNF_RPL_ONLY_W_CNF_PNRS_NM,  (DWORD &) m_fRplOnlyWithPartners)) ||
        (err = rk.SetValue(WINSCNF_LOG_DETAILED_EVTS_NM,    (DWORD &) m_fLogDetailedEvents)) ||
        (err = rk.SetValue(WINSCNF_LOG_FLAG_NM,             (DWORD &) m_fLoggingOn)) ||
        (err = rk.SetValue(WINSCNF_MIGRATION_ON_NM,         (DWORD &) m_fMigrateOn)) ||
		
        (err = rkPush.SetValue(WINSCNF_INIT_TIME_RPL_NM,    (DWORD &) m_fPushInitialReplication)) ||
        (err = rkPush.SetValue(WINSCNF_ADDCHG_TRIGGER_NM,   (DWORD &) m_fPushReplOnAddrChange)) ||
        (err = rkPush.SetValue(lpstrPersistence,                      m_dwPushPersistence)) ||

        (err = rkPull.SetValue(WINSCNF_INIT_TIME_RPL_NM,    (DWORD &) m_fPullInitialReplication)) ||
        (err = rkPull.SetValue(WINSCNF_RETRY_COUNT_NM,                m_dwPullRetryCount)) ||
		(err = rkPull.SetValue(lpstrPersistence,                      m_dwPullPersistence)) ||

        (err = rkPushDefaults.SetValue(WINSCNF_UPDATE_COUNT_NM,       m_dwPushUpdateCount)) ||
        (err = rkPullDefaults.SetValue(WINSCNF_RPL_INTERVAL_NM,       m_dwPullTimeInterval)) ||

        (err = rk.SetValue(WINSCNF_USE_SELF_FND_PNRS_NM,    (DWORD &) m_fUseSelfFndPnrs)) ||
		(err = rk.SetValue(WINSCNF_MCAST_INTVL_NM,                    m_dwMulticastInt)) ||
		(err = rk.SetValue(WINSCNF_MCAST_TTL_NM,                      m_dwMcastTtl)) || 

    	(err = rk.SetValue(WINSCNF_BURST_HANDLING_NM,       (DWORD &) m_fBurstHandling)) ||
		(err = rk.SetValue(WINSCNF_BURST_QUE_SIZE_NM,                 m_dwBurstQueSize)) 
	 )
	{
		 return err;
	}

    if (m_dwPullSpTime)
    {
        CIntlTime timeDefaultPullSpTime(m_dwPullSpTime);
	
        err = rkPullDefaults.SetValue(WINSCNF_SP_TIME_NM, timeDefaultPullSpTime.IntlFormat(CIntlTime::TFRQ_MILITARY_TIME));
    }
    else
    {
        rkPullDefaults.DeleteValue(WINSCNF_SP_TIME_NM);
    }

    // Consistency checking
    if (m_fPeriodicConsistencyCheck)
    {
	    err = rkCC.Open(HKEY_LOCAL_MACHINE, lpstrCCRoot, KEY_ALL_ACCESS, m_strNetBIOSName);
        if (err == ERROR_FILE_NOT_FOUND)
        {
            // isn't there, need to create
            err = rkCC.Create(HKEY_LOCAL_MACHINE, lpstrCCRoot, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, m_strNetBIOSName);
            if (err)
                return err;
        }

        // now update values
        if (
		    (err = rkCC.SetValue(WINSCNF_CC_MAX_RECS_AAT_NM,             m_dwMaxRecsAtATime)) ||
            (err = rkCC.SetValue(WINSCNF_CC_USE_RPL_PNRS_NM,   (DWORD &) m_fCCUseRplPnrs)) ||
            (err = rkCC.SetValue(WINSCNF_SP_TIME_NM,                     m_itmCCStartTime.IntlFormat(CIntlTime::TFRQ_MILITARY_TIME))) ||
            (err = rkCC.SetValue(WINSCNF_CC_INTVL_NM,                    m_dwCCTimeInterval)) 
           )
        {
            return err;
        }
    }
    else
    {
	    err = rkCC.Open(HKEY_LOCAL_MACHINE, lpstrCCRoot, KEY_ALL_ACCESS, m_strNetBIOSName);
        if (err == ERROR_FILE_NOT_FOUND)
        {
            // we're done.  to turn this off, the key needs to be deleted
        }
        else
        {
            // remove the key
            rkCC.Close();
            err = rk.RecurseDeleteKey(lpstrCC);
            if (err)
            {
                return err;
            }
        }
    }

	//
	// Database path
	//
	CString strDbFull;

	strDbFull = m_strDbPath + _T("\\") + m_strDbName;

	if ( (err = rk.SetValue(WINSCNF_DB_FILE_NM, strDbFull, TRUE)) ||
		 (err = rk.SetValue(WINSCNF_LOG_FILE_PATH_NM, m_strDbPath, TRUE)) )
	{
		return err;
	}

	//
	// NT 3.51 this key was REG_SZ, NT4 and above it is REG_EXPAND_SZ
	//
	BOOL fRegExpand = (m_dwMajorVersion < 4) ? FALSE : TRUE;

	err = rk.SetValue(WINSCNF_BACKUP_DIR_PATH_NM, m_strBackupPath, fRegExpand);
    if (err)
		return err;

    return ERROR_SUCCESS;
}


/*---------------------------------------------------------------------------
	CConfiguration::GetSystemVersion()
		Reads the windows system version information
---------------------------------------------------------------------------*/
DWORD
CConfiguration::GetSystemVersion()
{
    CString strBuf, strValue;
    RegKey  rk;
	int     nPos, nLength;
    DWORD   err = ERROR_SUCCESS;

    err = rk.Open(HKEY_LOCAL_MACHINE, (LPCTSTR) lpstrCurrentVersion, KEY_READ, m_strNetBIOSName);
    if (err)
        return err;

    // read the windows version and convert into our internal variables
    err = rk.QueryValue(lpstrWinVersion, strBuf.GetBuffer(256), 256, FALSE);
    strBuf.ReleaseBuffer();
    if (err)
        return err;

    nPos = strBuf.Find('.');
    nLength = strBuf.GetLength();

    strValue = strBuf.Left(nPos);
    m_dwMajorVersion = _ttoi(strValue);

    strValue = strBuf.Right(nLength - nPos - 1);
    m_dwMinorVersion = _ttoi(strValue);

    // now get the current build #
    err = rk.QueryValue(lpstrBuildNumber, strBuf.GetBuffer(256), 256, FALSE);
    strBuf.ReleaseBuffer();
    if (err)
        return err;

    m_dwBuildNumber = _ttoi(strBuf);

    // and finally the SP #
    err = rk.QueryValue(lpstrSPVersion, strBuf.GetBuffer(256), 256, FALSE);
    strBuf.ReleaseBuffer();

    if (err == ERROR_FILE_NOT_FOUND)
    {
        // this may not be there if a SP hasn't been installed.
        return ERROR_SUCCESS;
    }
    else
    if (err)
    {
        return err;
    }

    CString strServicePack = _T("Service Pack ");

    nLength = strBuf.GetLength();
    strValue = strBuf.Right(nLength - strServicePack.GetLength());

    m_dwServicePack = _ttoi(strValue);

    return err;
}

void 
CConfiguration::GetAdminStatus()
{
    DWORD   err = 0, dwDummy = 0;
	RegKey  rk;

    err = rk.Open(HKEY_LOCAL_MACHINE, (LPCTSTR) lpstrRoot, KEY_ALL_ACCESS, m_strNetBIOSName);
    if (!err)
    {
        m_fIsAdmin = TRUE;
    }
}

BOOL	
CConfiguration::IsNt5()
{
	if (m_dwMajorVersion >= 5)
		return TRUE;
	else
		return FALSE;
}

//
//  NT4 didn't support passing back the ownerId when we querried for bunches 
// of records.  Querrying for a specific record will return the correct 
// owner id in all cases.  This was fixed in NT5 and back proped into NT4
// SP6.
//
BOOL	
CConfiguration::FSupportsOwnerId()
{
//	if ( IsNt5() ||
//         ( (m_dwMajorVersion == 4) &&
//		   (m_dwServicePack >= 6) ) )
    if ( m_dwMajorVersion >= 5)
    {
		return TRUE;
    }
	else
    {
		return FALSE;
    }
}

BOOL    
CConfiguration::IsAdmin()
{
    return m_fIsAdmin;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\cprogdlg.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	cprogdlg.h
		progress dialog for checking version consistency
		
    FILE HISTORY:
        
*/


#if !defined _CPROGDLG_H
#define _CPROGDLG_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef _ACTREG_H
#include "actreg.h"
#endif

#ifndef _VERIFY_H
#include "verify.h"
#endif

#ifndef _CONFIG_H
#include "config.h"
#endif

#include "dialog.h"

#define	MAX_WINS				1000
#define INIT_SIZE		        100

#define VERSION_NT_50		    5
#define VERSION_NT_40		    4
#define VERSION_NT_351		    3

typedef CArray<u_long, u_long> CULongArray;

class CCheckNamesProgress;
class CCheckVersionProgress;
class CDBCompactProgress;

/*---------------------------------------------------------------------------
	Class:	CWinsThread
 ---------------------------------------------------------------------------*/
class CWinsThread : public CWinThread
{
public:
    CWinsThread();
    ~CWinsThread();

public:
    BOOL Start();
    void Abort(BOOL fAutoDelete = TRUE);
    void AbortAndWait();
    BOOL FCheckForAbort();
    BOOL IsRunning();
    
    virtual BOOL InitInstance() { return TRUE; }	// MFC override
    virtual int Run() { return 1; }

private:
    HANDLE              m_hEventHandle;
};

/*---------------------------------------------------------------------------
	Class:	CCheckNamesThread
 ---------------------------------------------------------------------------*/
class CCheckNamesThread : public CWinsThread
{
public:
	CCheckNamesThread() { m_bAutoDelete = FALSE; }
	virtual int Run();

	void AddStatusMessage(LPCTSTR pszMessage);
    void DisplayInfo(int uNames, u_long ulValidAddr);

public:
	CCheckNamesProgress * m_pDlg;

	CWinsNameArray		m_strNameArray;
	WinsServersArray	m_winsServersArray;
	CStringArray		m_strSummaryArray;
	CULongArray			m_verifiedAddressArray;
};

/*---------------------------------------------------------------------------
	Class:	CCheckVersionThread
 ---------------------------------------------------------------------------*/
class CCheckVersionThread : public CWinsThread
{
public:
	CCheckVersionThread() 
    {
        m_bAutoDelete = FALSE;
        m_uLATableDim = 0;
        m_pLISOTable = NULL;
        m_uLISOTableDim = 0;
    }

	virtual int Run();

	void AddStatusMessage(LPCTSTR pszMessage);

//helpers
protected:
	DWORD	InitLATable(PWINSINTF_ADD_VERS_MAP_T    pAddVersMaps,
					    DWORD                       NoOfOwners);
	DWORD	AddSOTableEntry(CString &                   strIP,
							PWINSINTF_ADD_VERS_MAP_T    pMasterMaps,
							DWORD                       NoOfOwners);
	LONG	IPToIndex(CString & strIP);
	BOOL	CheckSOTableConsistency();
	void	RemoveFromSOTable(CString & strIP);

    ULARGE_INTEGER& SOCell(UINT i, UINT j);

public:
	CCheckVersionProgress * m_pDlg;
	
	handle_t				m_hBinding;
	DWORD					m_dwIpAddress;

	CStringArray			m_strLATable;
    UINT                    m_uLATableDim;
	ULARGE_INTEGER          *m_pLISOTable;
    UINT                    m_uLISOTableDim;
};


/*---------------------------------------------------------------------------
	Class:	CDBCompactThread
 ---------------------------------------------------------------------------*/
class CDBCompactThread : public CWinsThread
{
public:
	CDBCompactThread() 
	{ 
		m_bAutoDelete = FALSE; 
		m_hHeapHandle = NULL;
	}

	~CDBCompactThread() 
	{ 
		if (m_hHeapHandle)
		{
			HeapDestroy(m_hHeapHandle);
			m_hHeapHandle = NULL;
		}
	}

	virtual int Run();

	void	AddStatusMessage(LPCTSTR pszMessage);

protected:
	void	    DisConnectFromWinsServer();
	DWORD	    ConnectToWinsServer();
	DWORD_PTR	RunApp(LPCTSTR input, LPCTSTR startingDirectory, LPSTR * output);

public:
	CDBCompactProgress *	m_pDlg;

	CConfiguration *		m_pConfig;
	handle_t				m_hBinding;
	DWORD					m_dwIpAddress;
	CString					m_strServerName;

    // for the output of RunApp
    HANDLE                  m_hHeapHandle;
};

/////////////////////////////////////////////////////////////////////////////
// CProgress dialog

class CProgress : public CBaseDialog
{
// Construction
public:
	CProgress(CWnd* pParent = NULL);   // standard constructor

	void AddStatusMessage(LPCTSTR pszMessage)
	{
		m_editMessage.SetFocus();

        int nLength = m_editMessage.GetWindowTextLength();
        m_editMessage.SetSel(nLength, nLength, TRUE);

        m_editMessage.ReplaceSel(pszMessage);
	}

// Dialog Data
	//{{AFX_DATA(CProgress)
	enum { IDD = IDD_VERSION_CONSIS };
	CButton	m_buttonCancel;
	CEdit	m_editMessage;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CProgress)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CProgress)
	virtual void OnCancel();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CProgress::IDD);};

};

/*---------------------------------------------------------------------------
	Class:	CCheckNamesProgress
 ---------------------------------------------------------------------------*/
class CCheckNamesProgress : public CProgress
{
public:
	CCheckNamesProgress()
	{
		m_fVerifyWithPartners = FALSE;
	}

	void NotifyCompleted();
	void BuildServerList();

protected:
	virtual BOOL OnInitDialog();
	virtual void OnCancel();
	void		 AddServerToList(u_long ip);

public:
	CWinsNameArray		m_strNameArray;
	CStringArray		m_strServerArray;
	WinsServersArray	m_winsServersArray;

	BOOL				m_fVerifyWithPartners;

protected:
	CCheckNamesThread 	m_Thread;
};

/*---------------------------------------------------------------------------
	Class:	CCheckVersionProgress
 ---------------------------------------------------------------------------*/
class CCheckVersionProgress : public CProgress
{
public:
	void NotifyCompleted();

protected:
	virtual BOOL OnInitDialog();
	virtual void OnCancel();

public:
	handle_t	m_hBinding;
	DWORD		m_dwIpAddress;

protected:
	CCheckVersionThread 	m_Thread;
};

/*---------------------------------------------------------------------------
	Class:	CDBCompactProgress
 ---------------------------------------------------------------------------*/
class CDBCompactProgress : public CProgress
{
public:
	void NotifyCompleted();

protected:
	virtual BOOL OnInitDialog();
	virtual void OnCancel();

public:
	CConfiguration *		m_pConfig;
	handle_t				m_hBinding;
	DWORD					m_dwIpAddress;
	CString					m_strServerName;

protected:
	CDBCompactThread 		m_Thread;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
#endif // !defined _CPROGDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\config.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	config.h
		Registry Values for WINS
		
    FILE HISTORY:
        
*/

#ifndef _CONFIG_H_
#define _CONFIG_H_

class CConfiguration
{
public:
    CConfiguration(CString strNetBIOSName = _T(""));
    ~CConfiguration();

// operator overriding
	CConfiguration& operator =(const CConfiguration& configuration);

public:
    const BOOL IsReady() const
    {
        return !m_strNetBIOSName.IsEmpty();
    }

    void SetOwner(CString strNetBIOSName)
    {
        m_strNetBIOSName = strNetBIOSName;   
    }

	LPCTSTR GetOwner()
	{
		return m_strNetBIOSName;
	}

    HRESULT Touch();
    HRESULT Load(handle_t hBinding);
    HRESULT Store();

    DWORD   GetSystemVersion();
	BOOL	IsNt5();
    BOOL    FSupportsOwnerId();
    BOOL    IsAdmin();

public:
	// entries under HKEY_LOCAL_MACHINE\system\currentcontrolset\services\wins
    DWORD		m_dwRefreshInterval;
    DWORD		m_dwTombstoneInterval;
    DWORD		m_dwTombstoneTimeout;
    DWORD		m_dwVerifyInterval;
    DWORD		m_dwVersCountStart_LowWord;
    DWORD		m_dwVersCountStart_HighWord;
    DWORD		m_dwNumberOfWorkerThreads;
	
	// PUSH partner stuff
    BOOL        m_fPushInitialReplication;
    BOOL        m_fPushReplOnAddrChange;
	DWORD		m_dwPushUpdateCount;
	DWORD		m_dwPushPersistence;

    // PULL partner suff
	BOOL        m_fPullInitialReplication;
    DWORD		m_dwPullTimeInterval;
	DWORD		m_dwPullSpTime;
	DWORD		m_dwPullPersistence;
    DWORD		m_dwPullRetryCount;

    BOOL        m_fLoggingOn;
    BOOL        m_fRplOnlyWithPartners;
    BOOL        m_fLogDetailedEvents;
    BOOL        m_fBackupOnTermination;
    BOOL        m_fMigrateOn;
	BOOL		m_fUseSelfFndPnrs;
	DWORD		m_dwMulticastInt;
	DWORD		m_dwMcastTtl;
    CString     m_strBackupPath;

    BOOL        m_fBurstHandling;
    DWORD       m_dwBurstQueSize;

    // consistency checking
    BOOL        m_fPeriodicConsistencyCheck;
    BOOL        m_fCCUseRplPnrs;
    DWORD       m_dwMaxRecsAtATime;
    DWORD       m_dwCCTimeInterval;
    CIntlTime   m_itmCCStartTime;

    // system version stuff
    DWORD       m_dwMajorVersion;
    DWORD       m_dwMinorVersion;
    DWORD       m_dwBuildNumber;
    DWORD       m_dwServicePack;

    // admin status
    BOOL        m_fIsAdmin;

    // database name
    CString     m_strDbName;
	CString		m_strDbPath;

protected:
    void        GetAdminStatus();

private:
    typedef CString REGKEYNAME;

// Registry Names
    static const REGKEYNAME lpstrRoot;
    static const REGKEYNAME lpstrPullRoot;
    static const REGKEYNAME lpstrPushRoot;
    static const REGKEYNAME lpstrNetBIOSName;
	static const REGKEYNAME lpstrPersistence;

    // consistency checking
    static const REGKEYNAME lpstrCCRoot;
    static const REGKEYNAME lpstrCC;

    // default value stuff
    static const REGKEYNAME lpstrDefaultsRoot;
    static const REGKEYNAME lpstrPullDefaultsRoot;
    static const REGKEYNAME lpstrPushDefaultsRoot;

    // for determining system version
    static const REGKEYNAME lpstrCurrentVersion;
	static const REGKEYNAME lpstrWinVersion;
	static const REGKEYNAME lpstrSPVersion;
	static const REGKEYNAME lpstrBuildNumber;

private:
    CString m_strNetBIOSName;
};

#endif // _CONFIG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\cprogdlg.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 -99             **/
/**********************************************************************/

/*
	cprogdlg.cpp
		The busy/progress dialog
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "winssnap.h"
#include "CProgdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

TCHAR * gsz_EOL = _T("\r\n");

/////////////////////////////////////////////////////////////////////////////
// CProgress dialog


CProgress::CProgress(CWnd* pParent /*=NULL*/)
	: CBaseDialog(CProgress::IDD, pParent)
{
	//{{AFX_DATA_INIT(CProgress)
	//}}AFX_DATA_INIT
}


void CProgress::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CProgress)
	DDX_Control(pDX, IDCANCEL, m_buttonCancel);
	DDX_Control(pDX, IDC_EDIT_MESSAGE, m_editMessage);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CProgress, CBaseDialog)
	//{{AFX_MSG_MAP(CProgress)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProgress message handlers

void CProgress::OnCancel() 
{
	// TODO: Add extra cleanup here
	
	CBaseDialog::OnCancel();
}

BOOL CProgress::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();
	
	m_editMessage.SetLimitText(0xFFFFFFFF);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
// CCheckNamesProgress dialog

BOOL CCheckNamesProgress::OnInitDialog()
{
	CProgress::OnInitDialog();
	
	m_Thread.m_pDlg = this;

	CWaitCursor wc;

	m_Thread.Start();
	
	CString strText;

	strText.LoadString(IDS_CANCEL);
	m_buttonCancel.SetWindowText(strText);

	strText.LoadString(IDS_CHECK_REG_TITLE);
	SetWindowText(strText);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CCheckNamesProgress::BuildServerList()
{
	CString strMessage;
	
	strMessage.LoadString(IDS_BUILDING_SERVER_LIST);
	strMessage += gsz_EOL;

	AddStatusMessage(strMessage);

	for (int i = 0; i < m_strServerArray.GetSize(); i++)
	{
		char szIP[MAX_PATH];
		
        // NOTE: this should be ACP because it's winsock related
        WideToMBCS(m_strServerArray[i], szIP);

		// add this machine to the list
		AddServerToList(inet_addr(szIP));

		// check to see if we should add known partners
		if (m_fVerifyWithPartners)
		{
			CWinsResults			  winsResults;
			handle_t                  hBind;
			WINSINTF_BIND_DATA_T      BindData;

			BindData.fTcpIp = TRUE;
			BindData.pServerAdd = (LPSTR) (LPCTSTR) m_strServerArray[i];

			hBind = ::WinsBind(&BindData);
			if (!hBind)
			{
				// unable to bind to this server
				AfxFormatString1(strMessage, IDS_UNABLE_TO_CONNECT, m_strServerArray[i]);
				strMessage += gsz_EOL;
				AddStatusMessage(strMessage);

				continue;
			}

			DWORD err = winsResults.Update(hBind);
			if (err)
			{
				strMessage.LoadString(IDS_GET_STATUS_FAILED);
				strMessage += gsz_EOL;
				AddStatusMessage(strMessage);
			}
			else
			{
				for (UINT j = 0; j < winsResults.NoOfOwners; j++) 
				{
                    // check to see if:
                    // 1. the address is not 0
                    // 2. the owner is not marked as deleted
                    // 3. the highest record count is not 0

                    if ( (winsResults.AddVersMaps[j].Add.IPAdd != 0) &&
                         (winsResults.AddVersMaps[j].VersNo.QuadPart != OWNER_DELETED) &&
                         (winsResults.AddVersMaps[j].VersNo.QuadPart != 0) )
                    {
					    AddServerToList(htonl(winsResults.AddVersMaps[j].Add.IPAdd));
                    }
				}
			}

			::WinsUnbind(&BindData, hBind);
		}
	}

	// now display the list
	strMessage.LoadString(IDS_SERVERS_TO_BE_QUERRIED);
	strMessage += gsz_EOL;
	AddStatusMessage(strMessage);

	for (i = 0; i < m_winsServersArray.GetSize(); i++)
	{
		MakeIPAddress(ntohl(m_winsServersArray[i].Server.s_addr), strMessage);
		strMessage += gsz_EOL;

		AddStatusMessage(strMessage);
	}

	AddStatusMessage(gsz_EOL);

	m_Thread.m_strNameArray.Copy(m_strNameArray);
	m_Thread.m_winsServersArray.Copy(m_winsServersArray);
}

void CCheckNamesProgress::AddServerToList(u_long ip)
{
	BOOL fFound = FALSE;

	if (ip == 0)
		return;

	//
	// Look to see if it is already in the list
	//
	for (int k = 0; k < m_winsServersArray.GetSize(); k++)
	{
		if (m_winsServersArray[k].Server.s_addr == ip)
		{
			fFound = TRUE;
			break;
		}
	}

	// if we didn't find it, add it.
	if (!fFound)
	{
		WINSERVERS server = {0};
		server.Server.s_addr = ip;
		m_winsServersArray.Add(server);
	}
}

void CCheckNamesProgress::OnCancel() 
{
	if (m_Thread.IsRunning())
	{
		CWaitCursor wc;

		CString strText;
		strText.LoadString(IDS_CLEANING_UP);
		strText += gsz_EOL;
		AddStatusMessage(strText);

		m_buttonCancel.EnableWindow(FALSE);

		m_Thread.Abort(FALSE);

		MSG msg;
		while (PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}

		return;
	}
	
	CProgress::OnCancel();
}

void CCheckNamesProgress::NotifyCompleted()
{
	CString strText;

	strText.LoadString(IDS_FINISHED);
	strText += gsz_EOL;
	AddStatusMessage(strText);

	strText.LoadString(IDS_CLOSE);
	m_buttonCancel.SetWindowText(strText);
	m_buttonCancel.EnableWindow(TRUE);
}

/*---------------------------------------------------------------------------
	CWinsThread
		Background thread base class
	Author: EricDav
 ---------------------------------------------------------------------------*/
CWinsThread::CWinsThread()
{
	m_bAutoDelete = TRUE;
    m_hEventHandle = NULL;
}

CWinsThread::~CWinsThread()
{
	if (m_hEventHandle != NULL)
	{
		VERIFY(::CloseHandle(m_hEventHandle));
		m_hEventHandle = NULL;
	}
}

BOOL CWinsThread::Start()
{
	ASSERT(m_hEventHandle == NULL); // cannot call start twice or reuse the same C++ object
	
    m_hEventHandle = ::CreateEvent(NULL,TRUE /*bManualReset*/,FALSE /*signalled*/, NULL);
	if (m_hEventHandle == NULL)
		return FALSE;
	
    return CreateThread();
}

void CWinsThread::Abort(BOOL fAutoDelete)
{
    m_bAutoDelete = fAutoDelete;

    SetEvent(m_hEventHandle);
}

void CWinsThread::AbortAndWait()
{
    Abort(FALSE);

    WaitForSingleObject(m_hThread, INFINITE);
}

BOOL CWinsThread::IsRunning()
{
    if (WaitForSingleObject(m_hThread, 0) == WAIT_OBJECT_0)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

BOOL CWinsThread::FCheckForAbort()
{
    if (WaitForSingleObject(m_hEventHandle, 0) == WAIT_OBJECT_0)
    {
        Trace0("CWinsThread::FCheckForAbort - abort detected, exiting...\n");
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


/*---------------------------------------------------------------------------
	CCheckNamesThread
		Background thread for check registered names
	Author: EricDav
 ---------------------------------------------------------------------------*/
int CCheckNamesThread::Run()
{
	int				i, nRetryCount, status;
	BOOL			fDone = FALSE;
	int				uNames, uServers;
	u_short			TransID = 0;
	char			szName[MAX_PATH];
    WINSERVERS *    pCurrentServer;
	CString			strStatus;
	CString			strTemp;
	CString			strTempName;
    struct in_addr  retaddr;

	// build up the list of servers
	m_pDlg->BuildServerList();
	
	// initialize some comm stuff
	InitNameCheckSocket();

    // if the query is sent to the local server, TranIDs less than 0x7fff are dropped by NetBT
    TransID = 0x8000;

	// initialize all of the servers
	for (i = 0; i < m_winsServersArray.GetSize(); i++)
	{
        m_winsServersArray[i].LastResponse = -1;
        m_winsServersArray[i].fQueried = FALSE;
        m_winsServersArray[i].Valid = 0;
        m_winsServersArray[i].Failed = 0;
        m_winsServersArray[i].Retries = 0;
        m_winsServersArray[i].Completed = 0;
	}

	// initialize the verified address stuff
	m_verifiedAddressArray.SetSize(m_strNameArray.GetSize());
	for (i = 0; i < m_verifiedAddressArray.GetSize(); i++)
		m_verifiedAddressArray[i] = 0;

	for (uNames = 0; uNames < m_strNameArray.GetSize(); uNames++)
	{
		// convert unicode string to MBCS
		memset(szName, 0, sizeof(szName));
		CWinsName winsName = m_strNameArray[uNames];

        // This should be OEM
		WideToMBCS(winsName.strName, szName, WINS_NAME_CODE_PAGE);

		// fill in the type (16th byte) and null terminate
		szName[15] = (BYTE) winsName.dwType & 0x000000FF;
		szName[16] = 0;

		// pad the name with spaces to the 16th character
		for (int nChar = 0; nChar < 16; nChar++)
		{
			if (szName[nChar] == 0)
				szName[nChar] = ' ';
		}

		for (uServers = 0; uServers < m_winsServersArray.GetSize(); uServers++)
		{
			fDone = FALSE;
			nRetryCount = 0;
			TransID++;

			pCurrentServer = &m_winsServersArray[uServers];

			while (!fDone)
			{
				// build a status string
				MakeIPAddress(ntohl(pCurrentServer->Server.S_un.S_addr), strTemp);
	
				strTempName.Format(_T("%s[%02Xh]"), m_strNameArray[uNames].strName, m_strNameArray[uNames].dwType);

				AfxFormatString2(strStatus, 
								 IDS_SEND_NAME_QUERY, 
								 strTemp,
								 strTempName);

				// send the name query out on the wire
				::SendNameQuery((unsigned char *)szName, pCurrentServer->Server.S_un.S_addr, TransID);

				if (FCheckForAbort())
					goto cleanup;

				// check for a response
				i = ::GetNameResponse(&retaddr.s_addr, TransID);

				if (FCheckForAbort())
					goto cleanup;

				switch (i)
				{
					case WINSTEST_FOUND:     // found
						pCurrentServer->RetAddr.s_addr = retaddr.s_addr;
						pCurrentServer->Valid = 1;
						pCurrentServer->LastResponse = uNames;

						if (retaddr.s_addr == m_verifiedAddressArray[uNames])
						{
							// this address has already been verified... don't
							// do the checking again
							strTemp.LoadString(IDS_OK);
							strStatus += strTemp;
							strStatus += gsz_EOL;

							AddStatusMessage(strStatus);
							fDone = TRUE;
							break;
						}

						status = VerifyRemote(inet_ntoa(pCurrentServer->RetAddr),
											  szName);

						if (WINSTEST_VERIFIED == status)
						{
							strTemp.LoadString(IDS_OK);
							strStatus += strTemp;
							strStatus += gsz_EOL;

							AddStatusMessage(strStatus);
                
							m_verifiedAddressArray[uNames] = retaddr.s_addr;
						}
						else
						{
							strTemp.LoadString(IDS_NOT_VERIFIED);
							strStatus += strTemp;
							strStatus += gsz_EOL;

							AddStatusMessage(strStatus);
						}
						fDone = TRUE;
						break;

					case WINSTEST_NOT_FOUND:     // responded -- name not found
						pCurrentServer->RetAddr.s_addr = retaddr.s_addr;
						pCurrentServer->Valid = 0;
						pCurrentServer->LastResponse = uNames;
                
						strTemp.LoadString(IDS_NAME_NOT_FOUND);
						strStatus += strTemp;
						strStatus += gsz_EOL;

						AddStatusMessage(strStatus);
					
						nRetryCount++;
						if (nRetryCount > 2)
						{
							pCurrentServer->Failed = 1;
							fDone = TRUE;
						}
						break;

					case WINSTEST_NO_RESPONSE:     // no response
						pCurrentServer->RetAddr.s_addr = retaddr.s_addr;
						pCurrentServer->Valid = 0;
						pCurrentServer->Retries++;

						strTemp.LoadString(IDS_NO_RESPONSE);
						strStatus += strTemp;
						strStatus += gsz_EOL;
						//strcat(lpResults, "; No response.\r\n");

						AddStatusMessage(strStatus);

						nRetryCount++;
						if (nRetryCount > 2)
						{
							pCurrentServer->Failed = 1;
							fDone = TRUE;
						}
						break;
					
					default:
						//unknown return
						break;

				}   // switch GetNameResponse
			
			} // while
		
		}   // for ServerInx

		// Find a valid address for this name
		for (uServers = 0; uServers < m_winsServersArray.GetSize(); uServers++)
        {
			pCurrentServer = &m_winsServersArray[uServers];

            if (pCurrentServer->Valid)
            {
                DisplayInfo(uNames, pCurrentServer->RetAddr.s_addr);
                break;
            }
        }   

	} // name for loop

	// mark all successful servers as completed
	for (uServers = 0; uServers < m_winsServersArray.GetSize(); uServers++)
    {
		pCurrentServer = &m_winsServersArray[uServers];
        if (!pCurrentServer->Failed)
        {
            pCurrentServer->Completed = 1;
        }
    } // for uServers

	// dump the summary info
	strStatus.LoadString(IDS_RESULTS);
	strStatus = gsz_EOL + strStatus + gsz_EOL + gsz_EOL;

	AddStatusMessage(strStatus);

	for (i = 0; i < m_strSummaryArray.GetSize(); i++)
	{
		AddStatusMessage(m_strSummaryArray[i]);
	}

	// generate some end of run summary status
	for (uServers = 0; uServers < m_winsServersArray.GetSize(); uServers++)
    {
		pCurrentServer = &m_winsServersArray[uServers];
        if ((-1) == pCurrentServer->LastResponse)
        {
			MakeIPAddress(ntohl(pCurrentServer->Server.S_un.S_addr), strTemp);
			AfxFormatString1(strStatus, IDS_SERVER_NEVER_RESPONDED, strTemp);
			
			strStatus += gsz_EOL;

            AddStatusMessage(strStatus);
        }
        else if (0 == pCurrentServer->Completed)
        {
			MakeIPAddress(ntohl(pCurrentServer->Server.S_un.S_addr), strTemp);
			AfxFormatString1(strStatus, IDS_SERVER_NOT_COMPLETE, strTemp);

			strStatus += gsz_EOL;

            AddStatusMessage(strStatus);
        }
    }   // for ServerInx

	for (uNames = 0; uNames < m_strNameArray.GetSize(); uNames++)
    {
        if (0 == m_verifiedAddressArray[uNames])
        {
			strTempName.Format(_T("%s[%02Xh]"), m_strNameArray[uNames].strName, m_strNameArray[uNames].dwType);
			AfxFormatString1(strStatus, IDS_NAME_NOT_VERIFIED, strTempName);

			strStatus += gsz_EOL;

            AddStatusMessage(strStatus);
        }
    }   // for uNames

cleanup:
	CloseNameCheckSocket();

	m_pDlg->NotifyCompleted();

	return 9;
}

void CCheckNamesThread::AddStatusMessage(LPCTSTR pszMessage)
{
	m_pDlg->AddStatusMessage(pszMessage);
}
		
void CCheckNamesThread::DisplayInfo(int uNames, u_long ulValidAddr)
{
    CString         strTemp, strTempName, strStatus;
    int             uServers;
    WINSERVERS *    pCurrentServer;
    struct in_addr  tempaddr;
    int             i;
    BOOL            fMismatchFound = FALSE;

	// now check and see which WINS servers didn't match
	for (uServers = 0; uServers < m_winsServersArray.GetSize(); uServers++)
    {
		pCurrentServer = &m_winsServersArray[uServers];
        if (pCurrentServer->Completed)
        {
            continue;
        }
        
        if ( (pCurrentServer->Valid) )
        {
            if ( (pCurrentServer->RetAddr.s_addr != ulValidAddr) || 
				 (m_verifiedAddressArray[uNames] != 0 && 
				  m_verifiedAddressArray[uNames] != ulValidAddr) )
            {
				// mismatch
				strTempName.Format(_T("%s[%02Xh]"), m_strNameArray[uNames].strName, m_strNameArray[uNames].dwType);
				AfxFormatString1(strStatus, IDS_INCONSISTENCY_FOUND, strTempName);
				strStatus += gsz_EOL;

				m_strSummaryArray.Add(strStatus);

                if (m_verifiedAddressArray[uNames] != 0)
                {
                    tempaddr.s_addr = m_verifiedAddressArray[uNames];
                    
					MakeIPAddress(ntohl(tempaddr.S_un.S_addr), strTemp);
					AfxFormatString1(strStatus, IDS_VERIFIED_ADDRESS, strTemp);
					strStatus += gsz_EOL;

					m_strSummaryArray.Add(strStatus);
                }
                
				// display the inconsistent name resolutions
                for (i = 0; i < m_winsServersArray.GetSize(); i++)
                {
                    if (m_winsServersArray[i].Valid &&
						m_verifiedAddressArray[uNames] != m_winsServersArray[i].RetAddr.S_un.S_addr)
                    {
						MakeIPAddress(ntohl(m_winsServersArray[i].Server.S_un.S_addr), strTemp);
					
						strTempName.Format(_T("%s[%02Xh]"), m_strNameArray[uNames].strName, m_strNameArray[uNames].dwType);
						AfxFormatString2(strStatus, 
										 IDS_NAME_QUERY_RESULT, 
										 strTemp,
										 strTempName);

						CString strTemp2;

						MakeIPAddress(ntohl(m_winsServersArray[i].RetAddr.S_un.S_addr), strTemp2);
						AfxFormatString1(strTemp, IDS_NAME_QUERY_RETURNED, strTemp2);

						strStatus += strTemp;
						strStatus += gsz_EOL;

						m_strSummaryArray.Add(strStatus);
                    }
                }

				m_strSummaryArray.Add(gsz_EOL);
                fMismatchFound = TRUE;
                break;
            }
        }
    }   // end check for invalid addresses

    if (!fMismatchFound)
    {
        // display the correct info
		strTempName.Format(_T("%s[%02Xh]"), m_strNameArray[uNames].strName, m_strNameArray[uNames].dwType);
		MakeIPAddress(ntohl(ulValidAddr), strTemp);

    	AfxFormatString2(strStatus, IDS_NAME_VERIFIED, strTempName, strTemp);
        strStatus += gsz_EOL;

		m_strSummaryArray.Add(strStatus);
    }
}


/*---------------------------------------------------------------------------
	CCheckVersionProgress
		Status dialog for check version consistency
	Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL CCheckVersionProgress::OnInitDialog()
{
	CProgress::OnInitDialog();
	
	CWaitCursor wc;

	m_Thread.m_dwIpAddress = m_dwIpAddress;
	m_Thread.m_pDlg = this;
	m_Thread.m_hBinding = m_hBinding;

	m_Thread.Start();

	CString strText;

	strText.LoadString(IDS_CANCEL);
	m_buttonCancel.SetWindowText(strText);

	strText.LoadString(IDS_CHECK_VERSION_TITLE);
	SetWindowText(strText);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CCheckVersionProgress::OnCancel() 
{
	if (m_Thread.IsRunning())
	{
		CWaitCursor wc;

		CString strText;
		strText.LoadString(IDS_CLEANING_UP);
		strText += gsz_EOL;
		AddStatusMessage(strText);
		
		m_buttonCancel.EnableWindow(FALSE);

		m_Thread.Abort(FALSE);

		MSG msg;
		while (PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}

		return;
	}
	
	CProgress::OnCancel();
}

void CCheckVersionProgress::NotifyCompleted()
{
	CString strText;

	strText.LoadString(IDS_FINISHED);
	strText += gsz_EOL;
	AddStatusMessage(strText);

	strText.LoadString(IDS_CLOSE);
	m_buttonCancel.SetWindowText(strText);
	m_buttonCancel.EnableWindow(TRUE);
}

/*---------------------------------------------------------------------------
	CCheckVersionThread
		Background thread for check version consistency
	Author: EricDav
 ---------------------------------------------------------------------------*/
void CCheckVersionThread::AddStatusMessage(LPCTSTR pszMessage)
{
	m_pDlg->AddStatusMessage(pszMessage);
}

// this is where the work gets done
int CCheckVersionThread::Run()
{
    CWinsResults    winsResults;
    CString         strMessage;
    CString         strIP;
    BOOL            bProblem;

    m_strLATable.RemoveAll();
    m_strLATable.SetSize(MAX_WINS); // table grows dynamically nevertheless
    m_uLATableDim = 0;

    DWORD status = winsResults.Update(m_hBinding);
    if (status != ERROR_SUCCESS)
    {
        strMessage.LoadString(IDS_ERROR_OCCURRED);
        strMessage += gsz_EOL;

        AddStatusMessage(strMessage);

        LPTSTR pBuf = strMessage.GetBuffer(1024);
			
        GetSystemMessage(status, pBuf, 1024);
        strMessage.ReleaseBuffer();
        strMessage += gsz_EOL;

        AddStatusMessage(strMessage);

        goto cleanup;
	}

    // add all the mappings for the target WINS to the Look Ahead table
    InitLATable(
        winsResults.AddVersMaps.GetData(),
        winsResults.NoOfOwners);

	// Place entry in the SO Table in proper order
    MakeIPAddress(m_dwIpAddress, strIP);
    AddSOTableEntry(
        strIP,
        winsResults.AddVersMaps.GetData(),
        winsResults.NoOfOwners);

	// For each of the owners, get the owner-version map
    for (UINT i = 0; i < m_uLATableDim; i++) 
    {
        WINSINTF_BIND_DATA_T	wbdBindData;
        handle_t				hBinding = NULL;
        CWinsResults	        winsResultsCurrent;

        // skip this one since we already did it!
        if (m_strLATable[i] == strIP) 
            continue;

        wbdBindData.fTcpIp = 1;
        wbdBindData.pPipeName = NULL;
        wbdBindData.pServerAdd = (LPSTR) (LPCTSTR) m_strLATable[i];
        // first bind to the machine
        if ((hBinding = ::WinsBind(&wbdBindData)) == NULL)
        {
            CString strBuf;
            LPTSTR pBuf = strBuf.GetBuffer(4096);

            ::GetSystemMessage(GetLastError(), pBuf, 4096);
            strBuf.ReleaseBuffer();

            Trace1("\n==> Machine %s is probably down\n\n", m_strLATable[i]);

            AfxFormatString2(strMessage, IDS_MSG_STATUS_DOWN, m_strLATable[i], strBuf);
            strMessage += gsz_EOL;

            AddStatusMessage(strMessage);

            RemoveFromSOTable(m_strLATable[i]);
            continue;
		}
        
        // now get the info
        status = winsResultsCurrent.Update(hBinding);
        if (status != ERROR_SUCCESS)
        {
            CString strBuf;
            LPTSTR pBuf = strBuf.GetBuffer(4096);

            ::GetSystemMessage(status, pBuf, 4096);
            strBuf.ReleaseBuffer();

            Trace1("\n==> Machine %s is probably down\n\n", m_strLATable[i]);

            AfxFormatString2(strMessage, IDS_MSG_STATUS_DOWN, m_strLATable[i], strBuf);
            strMessage += gsz_EOL;

            AddStatusMessage(strMessage);

            RemoveFromSOTable(m_strLATable[i]);
        }
        else
        {
            // ok, looks good
            AfxFormatString1(strMessage, IDS_MSG_STATUS_UP, m_strLATable[i]);
            strMessage += gsz_EOL;
            AddStatusMessage(strMessage);

            // add this mappings to the Look Ahead table
            InitLATable(
                winsResultsCurrent.AddVersMaps.GetData(),
                winsResultsCurrent.NoOfOwners);

            // Update the SO Table
            AddSOTableEntry(
                m_strLATable[i],
                winsResultsCurrent.AddVersMaps.GetData(), 
                winsResultsCurrent.NoOfOwners);
        }

        ::WinsUnbind(&wbdBindData, hBinding);
        hBinding = NULL;

        if (FCheckForAbort())
            goto cleanup;
    }

    // Check if diagonal elements in the [SO] table are the highest in their cols.
    bProblem = CheckSOTableConsistency();
    strMessage.LoadString(bProblem ? IDS_VERSION_CHECK_FAIL : IDS_VERSION_CHECK_SUCCESS);
    strMessage += gsz_EOL;
    AddStatusMessage(strMessage);

cleanup:
    if (m_pLISOTable)
    {
        delete [] m_pLISOTable;
        m_pLISOTable = NULL;
        m_uLISOTableDim = 0;
    }
    m_pDlg->NotifyCompleted();

    return 10;
}

DWORD 
CCheckVersionThread::InitLATable(
    PWINSINTF_ADD_VERS_MAP_T    pAddVersMaps,
    DWORD                       NoOfOwners)
{
    UINT n;

    // it is assumed pAddVersMaps doesn't contain duplicates within itself hence
    // we only check for duplicates with whatever is in the array at the moment
    // of the call and not with whatever we're adding there
    n = m_uLATableDim;
    for (UINT i = 0; i < NoOfOwners; i++, pAddVersMaps++)
    {
        UINT j;
        CString strIP;

        MakeIPAddress(pAddVersMaps->Add.IPAdd, strIP);

        for (j = 0; j < n; j++)
        {
            if (m_strLATable[j] == strIP)
                break;
        }

        if (j == n)
        {
            m_strLATable.InsertAt(m_uLATableDim,strIP);
            m_uLATableDim++;
        }
    }

    return ERROR_SUCCESS;
}

DWORD
CCheckVersionThread::AddSOTableEntry (
    CString &                   strIP,
    PWINSINTF_ADD_VERS_MAP_T    pAddVersMaps,
    DWORD                       NoOfOwners)
{
    UINT uRow = IPToIndex(strIP);

    // it is assumed here that m_strLATable is already updated
    // such that it includes already all the mappings from pAddVersMaps
    // and the address strIP provided as argument!

    // enlarge m_ppLISOTable if needed
    if (m_uLISOTableDim < m_uLATableDim)
    {
        ULARGE_INTEGER *pLISOTable = NULL;
        UINT           uLISOTableDim = m_uLATableDim;

        pLISOTable = new ULARGE_INTEGER[uLISOTableDim * uLISOTableDim];
        if (pLISOTable == NULL)
            return ERROR_NOT_ENOUGH_MEMORY;

        // transfer whatever we had in the original table (if anything)
        // and zero out the new empty space. Transfer & Zero is done line by line!
        for (UINT i = 0; i < m_uLISOTableDim; i++)
        {
            memcpy(
                (LPBYTE)(pLISOTable + i * uLISOTableDim),
                (LPBYTE)(m_pLISOTable + i * m_uLISOTableDim), 
                m_uLISOTableDim * sizeof(ULARGE_INTEGER));
            ZeroMemory(
                (LPBYTE)(pLISOTable + i * uLISOTableDim + m_uLISOTableDim),
                (uLISOTableDim - m_uLISOTableDim) * sizeof(ULARGE_INTEGER));
        }

        if (m_pLISOTable != NULL)
            delete [] m_pLISOTable;
        m_pLISOTable = pLISOTable;
        m_uLISOTableDim = uLISOTableDim;
    }

    for (UINT i=0; i < NoOfOwners; i++, pAddVersMaps++)
    {
        CString strOwnerIP;
        UINT    uCol;

        MakeIPAddress(pAddVersMaps->Add.IPAdd, strOwnerIP);
        uCol = IPToIndex(strOwnerIP);

        // lCol should definitely be less than m_uLISOTableDim since
        // the address is assumed already in m_dwLATable and m_pLISOTable is
        // large enough for the dimension of that table
        if (pAddVersMaps->VersNo.HighPart != MAXLONG ||
            pAddVersMaps->VersNo.LowPart != MAXLONG)
        {
            SOCell(uRow, uCol).QuadPart = (ULONGLONG)pAddVersMaps->VersNo.QuadPart;
        }
    }

    return ERROR_SUCCESS;
}
  
LONG
CCheckVersionThread::IPToIndex(
    CString &  strIP)
{
    // it is assumed the strIP does exist in the m_strLATable when
    // the index is looked for!
    for (UINT i = 0; i < m_uLATableDim; i++) 
	{
        if (m_strLATable[i] == strIP) 
            return i;
    }

    return m_uLATableDim;
}

BOOL
CCheckVersionThread::CheckSOTableConsistency()
{
    BOOLEAN fProblem = FALSE;

    for (UINT i = 0; i < m_uLISOTableDim; i++) 
	{
        for (UINT j = 0; j < m_uLISOTableDim; j++) 
		{
            // if the diagonal element is less than any other element on its column,
            // it means some other WINS pretends to have a better image about this WINS that itself!
            // This is an inconsistency!
            if (SOCell(i,i).QuadPart < SOCell(j,i).QuadPart)
			{
	            CString strMessage;

				AfxFormatString2(strMessage, IDS_VERSION_INCONSISTENCY_FOUND, m_strLATable[j], m_strLATable[i]);
				strMessage += gsz_EOL;
				AddStatusMessage(strMessage);
                fProblem = TRUE;
            }
        }
    }

	return fProblem;
}

void
CCheckVersionThread::RemoveFromSOTable(
    CString	&	strIP)
{
    UINT   uCol, uRow;

    // make the diagonal element corresponding to this WINS the
    // highest value possible (since WINS is not reachable, we'll
    // assume it is consistent!)
    uCol = uRow = IPToIndex(strIP);
    SOCell(uRow, uCol).HighPart = MAXLONG;
    SOCell(uRow, uCol).LowPart = MAXLONG;
}

ULARGE_INTEGER&
CCheckVersionThread::SOCell(UINT i, UINT j)
{
    return m_pLISOTable[i*m_uLISOTableDim + j];
}

/*---------------------------------------------------------------------------
	CDBCompactProgress
		Status dialog for DBCompact
	Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL CDBCompactProgress::OnInitDialog()
{
	CProgress::OnInitDialog();
	
	CWaitCursor wc;

	m_Thread.m_pDlg = this;
	m_Thread.m_hBinding = m_hBinding;
	m_Thread.m_dwIpAddress = m_dwIpAddress;
	m_Thread.m_strServerName = m_strServerName;
	m_Thread.m_pConfig = m_pConfig;

	m_Thread.Start();

	CString strText;

	strText.LoadString(IDS_CANCEL);
	m_buttonCancel.SetWindowText(strText);

	strText.LoadString(IDS_COMPACT_DATABASE_TITLE);
	SetWindowText(strText);

	// user cannot cancel this operation as that would be really bad...
	m_buttonCancel.EnableWindow(FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDBCompactProgress::OnCancel() 
{
	if (m_Thread.IsRunning())
	{
		CWaitCursor wc;

		CString strText;
		strText.LoadString(IDS_CLEANING_UP);
		strText += gsz_EOL;
		AddStatusMessage(strText);
		
		m_buttonCancel.EnableWindow(FALSE);

		m_Thread.Abort(FALSE);

		MSG msg;
		while (PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}

		return;
	}
	
	CProgress::OnCancel();
}

void CDBCompactProgress::NotifyCompleted()
{
	CString strText;

	strText.LoadString(IDS_FINISHED);
	strText += gsz_EOL;
	AddStatusMessage(strText);

	strText.LoadString(IDS_CLOSE);
	m_buttonCancel.SetWindowText(strText);
	m_buttonCancel.EnableWindow(TRUE);
}



/*---------------------------------------------------------------------------
	CDBCompactThread
		Background thread for DB Compact
	Author: EricDav
 ---------------------------------------------------------------------------*/

// this is where the work gets done
int CDBCompactThread::Run()
{
	DWORD       err = ERROR_SUCCESS;
	DWORD_PTR	dwLength;
    CString     strStartingDirectory, strWinsDb, strWinsTempDb, strCommandLine;
    CString     strTemp, strMessage, strOutput;
	LPSTR 		pszOutput;

    // get the version of NT running on this machine
    // we can do this because this command only runs locally.
	OSVERSIONINFO os;
	ZeroMemory(&os, sizeof(OSVERSIONINFO));
	os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

	BOOL bRet = GetVersionEx(&os);

	if (!bRet)
	{
		strMessage.LoadString(IDS_ERROR_OCCURRED);
		strMessage += gsz_EOL;

		AddStatusMessage(strMessage);

		LPTSTR pBuf = strMessage.GetBuffer(1024);
			
		GetSystemMessage(GetLastError(), pBuf, 1024);
		strMessage.ReleaseBuffer();
		strMessage += gsz_EOL;

		AddStatusMessage(strMessage);
		goto cleanup;
	}

    // all of the log files go into system32\wins so that's our starting dir
	if (!GetSystemDirectory(strStartingDirectory.GetBuffer(MAX_PATH), MAX_PATH))
	{
		strMessage.LoadString(IDS_ERROR_OCCURRED);
		strMessage += gsz_EOL;

		AddStatusMessage(strMessage);

		LPTSTR pBuf = strMessage.GetBuffer(1024);
			
		GetSystemMessage(GetLastError(), pBuf, 1024);
		strMessage.ReleaseBuffer();
		strMessage += gsz_EOL;

		AddStatusMessage(strMessage);

        goto cleanup;
	}

    strStartingDirectory.ReleaseBuffer();
    strStartingDirectory += _T("\\wins");

    // check to see if the database is in the correct location
    if (m_pConfig->m_strDbName.IsEmpty())
    {
        strWinsDb = _T("wins.mdb");
    }
    else
    {
        // the user has changed it...  
        strWinsDb = m_pConfig->m_strDbName;
    }

    strWinsTempDb = _T("winstemp.mdb");

    strCommandLine = _T("jetpack.exe ");

    switch (os.dwMajorVersion)
	{
        case VERSION_NT_50:
		    strCommandLine += strWinsDb + _T(" ") + strWinsTempDb;
		    break;

	    case VERSION_NT_40:
		    strCommandLine += _T("-40db" ) + strWinsDb + _T(" ") + strWinsTempDb;
            break;

	    case VERSION_NT_351:
		    strCommandLine += _T("-351db ") + strWinsDb + _T(" ") + strWinsTempDb;

	    default:
		    break;
	}
	

    // disconnect from the server and stop the service
	DisConnectFromWinsServer();

    strTemp.LoadString(IDS_COMPACT_STATUS_STOPPING_WINS);
    AddStatusMessage(strTemp);
    
    ControlWINSService(m_strServerName, TRUE);
	
    strTemp.LoadString(IDS_COMPACT_STATUS_COMPACTING);
    AddStatusMessage(strTemp);
    AddStatusMessage(strCommandLine);
    AddStatusMessage(gsz_EOL);

    dwLength = RunApp(strCommandLine, strStartingDirectory, &pszOutput);

    // the output comes back in ANSI.  Convert to unicode by using a CString
    strOutput = pszOutput;
    strOutput += gsz_EOL;

    AddStatusMessage(strOutput);
    
    strTemp.LoadString(IDS_COMPACT_STATUS_STARTING_WINS);
    AddStatusMessage(strTemp);

	//start the service again and connect to the server
	err = ControlWINSService(m_strServerName, FALSE);

	err = ConnectToWinsServer();

    strTemp.LoadString(IDS_COMPACT_STATUS_COMPLETED);
    AddStatusMessage(strTemp);

cleanup:
	m_pDlg->NotifyCompleted();

	return 11;
}

void CDBCompactThread::AddStatusMessage(LPCTSTR pszMessage)
{
	m_pDlg->AddStatusMessage(pszMessage);
}

void CDBCompactThread::DisConnectFromWinsServer()  
{
	if (m_hBinding)
	{
		CString					strIP;
		WINSINTF_BIND_DATA_T    wbdBindData;

		MakeIPAddress(m_dwIpAddress, strIP);

		wbdBindData.fTcpIp = 1;
		wbdBindData.pPipeName = NULL;
        wbdBindData.pServerAdd = (LPSTR) (LPCTSTR) strIP;
		
		::WinsUnbind(&wbdBindData, m_hBinding);
		
		m_hBinding = NULL;
	}
}

DWORD CDBCompactThread::ConnectToWinsServer()
{
	HRESULT hr = hrOK;

	CString					strServerName, strIP;
	DWORD					dwStatus = ERROR_SUCCESS;
    WINSINTF_ADD_T			waWinsAddress;
	WINSINTF_BIND_DATA_T    wbdBindData;

    // build some information about the server
    MakeIPAddress(m_dwIpAddress, strIP);

    DisConnectFromWinsServer();

    // now that the server name and ip are valid, call
	// WINSBind function directly.
	do
	{
        char szNetBIOSName[128] = {0};

        // call WinsBind function with the IP address
		wbdBindData.fTcpIp = 1;
		wbdBindData.pPipeName = NULL;
        wbdBindData.pServerAdd = (LPSTR) (LPCTSTR) strIP;

		BEGIN_WAIT_CURSOR

		if ((m_hBinding = ::WinsBind(&wbdBindData)) == NULL)
		{
			dwStatus = ::GetLastError();
			break;
		}

		// do we need to do this?  Is this just extra validation?
#ifdef WINS_CLIENT_APIS
		dwStatus = ::WinsGetNameAndAdd(m_hBinding, &waWinsAddress, (LPBYTE) szNetBIOSName);
#else
		dwStatus = ::WinsGetNameAndAdd(&waWinsAddress, (LPBYTE) szNetBIOSName);
#endif WINS_CLIENT_APIS

		END_WAIT_CURSOR

    } while (FALSE);

    return dwStatus;
}

/****************************************************************************
*
*    FUNCTION: RunApp
*
*    PURPOSE: Starts a process to run the command line specified
*
*    COMMENTS:
*
*
****************************************************************************/
DWORD_PTR CDBCompactThread::RunApp(LPCTSTR input, LPCTSTR startingDirectory, LPSTR * output)
{
	STARTUPINFO StartupInfo;
	PROCESS_INFORMATION ProcessInfo;
	SECURITY_ATTRIBUTES sa = {sizeof(SECURITY_ATTRIBUTES), 
		                      NULL,   // NULL security descriptor
							  TRUE};  // Inherit handles (necessary!)
	HANDLE  hReadHandle, hWriteHandle, hErrorHandle;
	LPSTR   outputbuffer, lpOutput;
	SIZE_T  AvailableOutput;
	BOOL    TimeoutNotReached = TRUE;
	DWORD   BytesRead;
	OVERLAPPED PipeOverlapInfo = {0,0,0,0,0};
    CHAR    szErrorMsg[1024];

    // Create the heap if it doesn't already exist
	if (m_hHeapHandle == 0)
	{
		if ((m_hHeapHandle = HeapCreate(0,
			                     8192,
								 0)) == NULL) return 0;
	}
	
	// Create buffer to receive stdout output from our process
	if ((outputbuffer = (LPSTR) HeapAlloc(m_hHeapHandle,
		                                 HEAP_ZERO_MEMORY,
							             4096)) == NULL) return 0;
	*output = outputbuffer;

	// Check input parameter
	if (input == NULL)
	{
		strcpy(outputbuffer, "ERROR: No command line specified");
		return strlen(outputbuffer);
	}

	// Zero init process startup struct
	FillMemory(&StartupInfo, sizeof(StartupInfo), 0);

	StartupInfo.cb = sizeof(StartupInfo);
	StartupInfo.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;  // Use the our stdio handles
    
	// Create pipe that will xfer process' stdout to our buffer
	if (!CreatePipe(&hReadHandle,
		           &hWriteHandle,
				   &sa,
				   0)) 
	{
        ::GetSystemMessageA(GetLastError(), szErrorMsg, sizeof(szErrorMsg));
		strcpy(outputbuffer, szErrorMsg);
		return strlen(outputbuffer);
	}
	// Set process' stdout to our pipe
	StartupInfo.hStdOutput = hWriteHandle;
	
	// We are going to duplicate our pipe's write handle
	// and pass it as stderr to create process.  The idea
	// is that some processes have been known to close
	// stderr which would also close stdout if we passed
	// the same handle.  Therefore we make a copy of stdout's
	// pipe handle.
	if (!DuplicateHandle(GetCurrentProcess(),
		            hWriteHandle,
					GetCurrentProcess(),
					&hErrorHandle,
					0,
					TRUE,
					DUPLICATE_SAME_ACCESS))
	{
        ::GetSystemMessageA(GetLastError(), szErrorMsg, sizeof(szErrorMsg));
		strcpy(outputbuffer, szErrorMsg);
		return strlen(outputbuffer);
	}
	StartupInfo.hStdError = hErrorHandle;

	// Initialize our OVERLAPPED structure for our I/O pipe reads
	PipeOverlapInfo.hEvent = CreateEvent(NULL,
		                                 TRUE,
										 FALSE,
										 NULL);
	if (PipeOverlapInfo.hEvent == NULL)
	{
        ::GetSystemMessageA(GetLastError(), szErrorMsg, sizeof(szErrorMsg));
		strcpy(outputbuffer, szErrorMsg);
		return strlen(outputbuffer);
	}

	// Create the Process!
	if (!CreateProcess(NULL,				 // name included in command line
		     (LPTSTR) input,				 // Command Line
					  NULL,					 // Default Process Sec. Attribs
					  NULL,					 // Default Thread Sec. Attribs
					  TRUE,					 // Inherit stdio handles
					  NORMAL_PRIORITY_CLASS, // Creation Flags
					  NULL,					 // Use this process' environment
					  startingDirectory,	 // Use the current directory
					  &StartupInfo,
					  &ProcessInfo))
	{
        ::GetSystemMessageA(GetLastError(), szErrorMsg, sizeof(szErrorMsg));
		strcpy(outputbuffer, szErrorMsg);
		return strlen(outputbuffer);
	}

	// lpOutput is moving output pointer
	lpOutput = outputbuffer;
	AvailableOutput = HeapSize(m_hHeapHandle,
		                       0,
							   outputbuffer);
	// Close the write end of our pipe (both copies)
	// so it will die when the child process terminates
	CloseHandle(hWriteHandle);
	CloseHandle(hErrorHandle);

	while (TimeoutNotReached)
	{
		// Keep a read posted on the output pipe
		if (ReadFile(hReadHandle,
				lpOutput,
				(DWORD) AvailableOutput,
				&BytesRead,
				&PipeOverlapInfo) == TRUE)
		{
			// Already received data...adjust buffer pointers
			AvailableOutput-=BytesRead;
			lpOutput += BytesRead;
			
            if (AvailableOutput == 0)
			{
				// We used all our buffer,  allocate more
				LPSTR TempBufPtr = (LPSTR) HeapReAlloc(m_hHeapHandle,
						                             HEAP_ZERO_MEMORY,
										             outputbuffer,
    									             HeapSize(m_hHeapHandle,
	    								                 0,
		    									         outputbuffer) + 4096);

				if (TempBufPtr == NULL)
				{
					// Copy error message to end of buffer
                    ::GetSystemMessageA(GetLastError(), szErrorMsg, sizeof(szErrorMsg));
					strcpy(outputbuffer 
						    + HeapSize(m_hHeapHandle,0, outputbuffer) 
							- strlen(szErrorMsg) - 1, 
							szErrorMsg);
					return strlen(outputbuffer);
				}
				
                // Fix pointers in case ouir buffer moved
				outputbuffer = TempBufPtr;
				lpOutput = outputbuffer + BytesRead;
				AvailableOutput = HeapSize(m_hHeapHandle, 0, outputbuffer) - BytesRead;
				*output = outputbuffer;
			}
		}
		else
		{
			// Switch on ReadFile result
			switch (GetLastError())
			{
			case ERROR_IO_PENDING:
				// No data yet, set event so we will be triggered
				// when there is data
				ResetEvent(PipeOverlapInfo.hEvent);
				break;
			
            case ERROR_MORE_DATA:
				{
					// Our buffer is too small...grow it
					DWORD_PTR CurrentBufferOffset = lpOutput 
						                        - outputbuffer 
												+ BytesRead;

					LPTSTR TempBufPtr = (LPTSTR) HeapReAlloc(m_hHeapHandle,
						                             HEAP_ZERO_MEMORY,
											         outputbuffer,
											         4096);

					if (TempBufPtr == NULL)
					{
						// Copy error message to end of buffer
                        ::GetSystemMessageA(GetLastError(), szErrorMsg, sizeof(szErrorMsg));
						strcpy(outputbuffer + HeapSize
						       (m_hHeapHandle,0, outputbuffer) - 
						       strlen(szErrorMsg) - 1, szErrorMsg);
						return strlen(outputbuffer);
					}
					
                    // Set parameters to post a new ReadFile
					lpOutput = outputbuffer + CurrentBufferOffset;
					AvailableOutput = HeapSize(m_hHeapHandle, 0, outputbuffer) 
						              - CurrentBufferOffset;
					*output = outputbuffer;
				}
				break;
			
            case ERROR_BROKEN_PIPE:
				// We are done..

				//Make sure we are null terminated
				*lpOutput = 0;
				return (lpOutput - outputbuffer);
				break;
			
            case ERROR_INVALID_USER_BUFFER:
			case ERROR_NOT_ENOUGH_MEMORY:
				// Too many I/O requests pending...wait a little while
				Sleep(2000);
				break;
			
            default:
				// Wierd error...return
                ::GetSystemMessageA(GetLastError(), szErrorMsg, sizeof(szErrorMsg));
		        strcpy(outputbuffer, szErrorMsg);
				return strlen(outputbuffer);
			}
		}

		// Wait for data to read
		if (WaitForSingleObject(PipeOverlapInfo.hEvent, 
			                    300000) == WAIT_TIMEOUT) 
			TimeoutNotReached = FALSE;
	}

    return strlen(outputbuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\delowner.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	delowner.cpp
		Delete owner dialog
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "DelOwner.h"
#include "server.h"
#include "actreg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDeleteOwner dialog

int CALLBACK DelOwnerCompareFunc
(
    LPARAM lParam1, 
    LPARAM lParam2, 
    LPARAM lParamSort
)
{
    return ((CDeleteOwner *) lParamSort)->HandleSort(lParam1, lParam2);
}

CDeleteOwner::CDeleteOwner(ITFSNode * pNode, CWnd* pParent /*=NULL*/)
	: CBaseDialog(CDeleteOwner::IDD, pParent)
{
	m_spActRegNode.Set(pNode);
    m_nSortColumn = -1; 

    for (int i = 0; i < COLUMN_MAX; i++)
    {
        m_aSortOrder[i] = TRUE; // ascending
    }

	//{{AFX_DATA_INIT(CDeleteOwner)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CDeleteOwner::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDeleteOwner)
	DDX_Control(pDX, IDC_RADIO_DELETE_RECORDS, m_radioDelete);
	DDX_Control(pDX, IDC_LIST_OWNER, m_listOwner);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDeleteOwner, CBaseDialog)
	//{{AFX_MSG_MAP(CDeleteOwner)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST_OWNER, OnItemchangedListOwner)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_LIST_OWNER, OnColumnclickListOwner)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDeleteOwner message handlers

BOOL CDeleteOwner::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();
	
	CString strOwner;
	strOwner.LoadString(IDS_OWNER);
	m_listOwner.InsertColumn(COLUMN_IP, strOwner, LVCFMT_LEFT, 100, 1);

	CString strID;
	strID.LoadString(IDS_HIGHESTID);
	m_listOwner.InsertColumn(COLUMN_VERSION, strID, LVCFMT_LEFT, 125, -1);

    CString strName;
    strName.LoadString(IDS_NAME);
    m_listOwner.InsertColumn(COLUMN_NAME, strName, LVCFMT_LEFT, 100, -1);

    m_listOwner.SetFullRowSel(TRUE);

    // grab the owner info array
	SPITFSNode spActRegNode;
	CActiveRegistrationsHandler * pActReg;

	spActRegNode = GetTFSNode();
    pActReg = GETHANDLER(CActiveRegistrationsHandler, spActRegNode);

    pActReg->GetOwnerInfo(m_ServerInfoArray);

    // set default radio selection
	m_radioDelete.SetCheck(TRUE);

	FillOwnerInfo();
	
	GetDlgItem(IDOK)->EnableWindow(FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDeleteOwner::OnOK() 
{
    CThemeContextActivator themeActivator;
	m_dwSelectedOwner = GetSelectedOwner();
	m_fDeleteRecords = m_radioDelete.GetState();

    // warn the user
    if (m_fDeleteRecords)
    {
        if (AfxMessageBox(IDS_WARN_DELETE_OWNER, MB_YESNO) == IDNO)
        {
            return;
        }
    }
    else
    {
        if (AfxMessageBox(IDS_WARN_TOMBSTONE, MB_YESNO) == IDNO)
        {
            return;
        }
    }

	CBaseDialog::OnOK();
}

void CDeleteOwner::OnItemchangedListOwner(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	BOOL fEnable = (GetSelectedOwner() != -1) ? TRUE : FALSE;

	GetDlgItem(IDOK)->EnableWindow(fEnable);

	*pResult = 0;
}

void CDeleteOwner::FillOwnerInfo()
{
	for (int i = 0; i < m_ServerInfoArray.GetSize(); i++)
    {
        if (m_ServerInfoArray[i].m_liVersion.QuadPart == OWNER_DELETED)
        {
            // this owner has been deleted...
            continue;
        }

        CString strIPAdd;
        ::MakeIPAddress(m_ServerInfoArray[i].m_dwIp, strIPAdd);

        CString strVers = GetVersionInfo(m_ServerInfoArray[i].m_liVersion.LowPart, 
                                         m_ServerInfoArray[i].m_liVersion.HighPart);

        int nItem = m_listOwner.InsertItem(i, strIPAdd, 0);

	    m_listOwner.SetItemText(nItem, 1, m_ServerInfoArray[i].m_strName);
        m_listOwner.SetItemText(nItem, 2, strVers);

        m_listOwner.SetItemData(nItem, i);
    }

    Sort(COLUMN_IP);
}

void CDeleteOwner::Sort(int nCol) 
{
    if (m_nSortColumn == nCol)
    {
        // if the user is clicking the same column again, reverse the sort order
        m_aSortOrder[nCol] = m_aSortOrder[nCol] ? FALSE : TRUE;
    }
    else
    {
        m_nSortColumn = nCol;
    }

    m_listOwner.SortItems(DelOwnerCompareFunc, (LPARAM) this);
}

int CDeleteOwner::HandleSort(LPARAM lParam1, LPARAM lParam2) 
{
    int nCompare = 0;

    switch (m_nSortColumn)
    {
        case COLUMN_IP:
            {
                DWORD dwIp1 = m_ServerInfoArray.GetAt((int) lParam1).m_dwIp;
                DWORD dwIp2 = m_ServerInfoArray.GetAt((int) lParam2).m_dwIp;
            
                if (dwIp1 > dwIp2)
                    nCompare = 1;
                else
                if (dwIp1 < dwIp2)
                    nCompare = -1;
            }
            break;

        case COLUMN_NAME:
            {
                CString strName1, strName2;
                
                if (!m_ServerInfoArray.GetAt((int) lParam1).m_strName.IsEmpty())
                    strName1 = m_ServerInfoArray.GetAt((int) lParam1).m_strName;

                if (!m_ServerInfoArray.GetAt((int) lParam2).m_strName.IsEmpty())
                    strName2 = m_ServerInfoArray.GetAt((int) lParam2).m_strName;

                nCompare = strName1.CompareNoCase(strName2);
            }
            break;

        case COLUMN_VERSION:
            {
                LARGE_INTEGER li1, li2;
                
                li1.QuadPart = m_ServerInfoArray.GetAt((int) lParam1).m_liVersion.QuadPart;
                li2.QuadPart = m_ServerInfoArray.GetAt((int) lParam2).m_liVersion.QuadPart;
            
                if (li1.QuadPart > li2.QuadPart)
                    nCompare = 1;
                else
                if (li1.QuadPart < li2.QuadPart)
                    nCompare = -1;
            }
            break;
    }

    if (m_aSortOrder[m_nSortColumn] == FALSE)
    {
        // descending
        return -nCompare;
    }
    else
    {
        // ascending
        return nCompare;
    }
}

DWORD 
CDeleteOwner::GetSelectedOwner()
{
	int nCount = m_listOwner.GetItemCount();
	int nSelected = -1;

	for (int i = 0; i < nCount; i++)
	{
		UINT uState = m_listOwner.GetItemState(i, LVIS_SELECTED);

		if (uState)
		{
            DWORD_PTR nData = m_listOwner.GetItemData(i);

            DWORD dwSelOwner = m_ServerInfoArray.GetAt((int) nData).m_dwIp;
			
            return dwSelOwner;
		}
	}

	return 0;
}

CString 
CDeleteOwner::GetVersionInfo(LONG lLowWord, LONG lHighWord)
{
	CString strVersionCount;

	TCHAR sz[20];
    TCHAR *pch = sz;
    ::wsprintf(sz, _T("%08lX%08lX"), lHighWord, lLowWord);
    // Kill leading zero's
    while (*pch == '0')
    {
        ++pch;
    }
    // At least one digit...
    if (*pch == '\0')
    {
        --pch;
    }

    strVersionCount = pch;

    return strVersionCount;
}

void CDeleteOwner::OnColumnclickListOwner(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    // sort depending on what column was clicked;
    Sort(pNMListView->iSubItem);

    *pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\delrcdlg.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	delrcdlg.h
		Delete/tombstone a record dialog
		
    FILE HISTORY:
        
*/

#if !defined _DELRCDLG_H
#define _DELRCDLG_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef _DIALOG_H
#include "dialog.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// CDeleteRecordDlg dialog

class CDeleteRecordDlg : public CBaseDialog
{
// Construction
public:
	CDeleteRecordDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDeleteRecordDlg)
	enum { IDD = IDD_DELTOMB_RECORD };
	int		m_nDeleteRecord;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDeleteRecordDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDeleteRecordDlg)
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CDeleteRecordDlg::IDD);};

public:
    BOOL        m_fMultiple;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined _DELRCDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\delrcdlg.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 -99             **/
/**********************************************************************/

/*
	delrcdlg.cpp
		The delete/tombstone record(s) dialog
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "winssnap.h"
#include "delrcdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDeleteRecordDlg dialog


CDeleteRecordDlg::CDeleteRecordDlg(CWnd* pParent /*=NULL*/)
	: CBaseDialog(CDeleteRecordDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDeleteRecordDlg)
	m_nDeleteRecord = 0;
	//}}AFX_DATA_INIT

    m_fMultiple = FALSE;
}


void CDeleteRecordDlg::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDeleteRecordDlg)
	DDX_Radio(pDX, IDC_RADIO_DELETE, m_nDeleteRecord);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDeleteRecordDlg, CBaseDialog)
	//{{AFX_MSG_MAP(CDeleteRecordDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDeleteRecordDlg message handlers

void CDeleteRecordDlg::OnOK() 
{
	UpdateData();

    // warn the user
    if (m_nDeleteRecord != 0)
    {
        if (AfxMessageBox(IDS_WARN_TOMBSTONE, MB_YESNO) == IDNO)
        {
            return;
        }
    }

	CBaseDialog::OnOK();
}

BOOL CDeleteRecordDlg::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();
	
    if (m_fMultiple)
    {
        CString strText;

        // update the strings, title first
        strText.LoadString(IDS_DELETE_MULTIPLE_TITLE);
        SetWindowText(strText);

        // now the static text
        strText.LoadString(IDS_DELETE_MULTIPLE_STATIC);
        GetDlgItem(IDC_STATIC_DELETE_DESC)->SetWindowText(strText);

        // now the radio buttons
        strText.LoadString(IDS_DELETE_MULTIPLE_THIS_SERVER);
        GetDlgItem(IDC_RADIO_DELETE)->SetWindowText(strText);

        strText.LoadString(IDS_DELETE_MULTIPLE_TOMBSTONE);
        GetDlgItem(IDC_RADIO_TOMBSTONE)->SetWindowText(strText);
    }
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\delowner.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	delowner.h
		Delete owner dialog
		
    FILE HISTORY:
        
*/

#ifndef _DELOWNER_H
#define _DELOWNER_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef _DIALOG_H
#include "..\common\dialog.h"
#endif

#ifndef _LISTVIEW_H
#include "listview.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// CDeleteOwner dialog

class CDeleteOwner : public CBaseDialog
{
// Construction
public:
	CDeleteOwner(ITFSNode * pNode, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDeleteOwner)
	enum { IDD = IDD_OWNER_DELETE };
	CButton	m_radioDelete;
	CListCtrlExt	m_listOwner;
	//}}AFX_DATA

    int HandleSort(LPARAM lParam1, LPARAM lParam2);

	DWORD	m_dwSelectedOwner;
	BOOL	m_fDeleteRecords;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDeleteOwner)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void    FillOwnerInfo();
	DWORD   GetSelectedOwner();
	CString GetVersionInfo(LONG lLowWord, LONG lHighWord);

    void    Sort(int nCol);

protected:
    CServerInfoArray        m_ServerInfoArray;

	SPITFSNode				m_spActRegNode;
    int                     m_nSortColumn;
    BOOL                    m_aSortOrder[COLUMN_MAX];

	// Generated message map functions
	//{{AFX_MSG(CDeleteOwner)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnItemchangedListOwner(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnclickListOwner(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	ITFSNode* GetTFSNode()
	{
		if (m_spActRegNode)
			m_spActRegNode->AddRef();
		return m_spActRegNode;
	}

public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CDeleteOwner::IDD); }

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif _DELOWNER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\dhcp.h ===
/*++

Copyright (C) Microsoft Corporation, 1994 - 1998

Module Name:

    dhcp.h

Abstract:

    This module defines the DHCP server service definitions and structures.

Author:

    Manny Weiser  (mannyw)  11-Aug-1992

Revision History:

    Madan Appiah (madana) 10-Oct-1993

--*/

#ifndef _DHCP_
#define _DHCP_

#define WS_VERSION_REQUIRED     MAKEWORD( 1, 1)

//
// update dhcpapi.h also if you modify the following three typedefs.
//

typedef DWORD DHCP_IP_ADDRESS, *PDHCP_IP_ADDRESS, *LPDHCP_IP_ADDRESS;
typedef DWORD DHCP_OPTION_ID;

typedef struct _DATE_TIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} DATE_TIME, *LPDATE_TIME;

#define DHCP_DATE_TIME_ZERO_HIGH        0
#define DHCP_DATE_TIME_ZERO_LOW         0

#define DHCP_DATE_TIME_INFINIT_HIGH     0x7FFFFFFF
#define DHCP_DATE_TIME_INFINIT_LOW      0xFFFFFFFF

#define DOT_IP_ADDR_SIZE                16          // XXX.XXX.XXX.XXX + '\0'
#define NO_DHCP_IP_ADDRESS              ((DHCP_IP_ADDRESS)-1)
#define DHCP_IP_KEY_LEN                 32          //arbitary size.

#define INFINIT_TIME                    0x7FFFFFFF  // time_t is int
#define INFINIT_LEASE                   0xFFFFFFFF  // in secs. (unsigned int.)

//
// hardware types.
//

#define HARDWARE_TYPE_10MB_EITHERNET    1
#define HARDWARE_TYPE_IEEE_802          6
#define HARDWARE_ARCNET                 7
#define HARDWARE_PPP                    8

//
// Client-server protoocol reserved ports
//

#define DHCP_CLIENT_PORT    68
#define DHCP_SERVR_PORT     67

//
// DHCP BROADCAST flag.
//

#define DHCP_BROADCAST      0x8000
#define DHCP_NO_BROADCAST   0x0000

#define DHCP_MESSAGE_SIZE       576
#define DHCP_SEND_MESSAGE_SIZE  548
#define BOOTP_MESSAGE_SIZE      300 // the options field for bootp is 64 bytes.

//
// The amount of time to wait for a DHCP response after a request
// has been sent.
//

#if !DBG
#define WAIT_FOR_RESPONSE_TIME          5
#else
#define WAIT_FOR_RESPONSE_TIME          10
#endif

//
// DHCP Operations
//

#define BOOT_REQUEST   1
#define BOOT_REPLY     2

//
// DHCP Standard Options.
//

#define OPTION_PAD                      0
#define OPTION_SUBNET_MASK              1
#define OPTION_TIME_OFFSET              2
#define OPTION_ROUTER_ADDRESS           3
#define OPTION_TIME_SERVERS             4
#define OPTION_IEN116_NAME_SERVERS      5
#define OPTION_DOMAIN_NAME_SERVERS      6
#define OPTION_LOG_SERVERS              7
#define OPTION_COOKIE_SERVERS           8
#define OPTION_LPR_SERVERS              9
#define OPTION_IMPRESS_SERVERS          10
#define OPTION_RLP_SERVERS              11
#define OPTION_HOST_NAME                12
#define OPTION_BOOT_FILE_SIZE           13
#define OPTION_MERIT_DUMP_FILE          14
#define OPTION_DOMAIN_NAME              15
#define OPTION_SWAP_SERVER              16
#define OPTION_ROOT_DISK                17
#define OPTION_EXTENSIONS_PATH          18

//
// IP layer parameters - per host
//

#define OPTION_BE_A_ROUTER              19
#define OPTION_NON_LOCAL_SOURCE_ROUTING 20
#define OPTION_POLICY_FILTER_FOR_NLSR   21
#define OPTION_MAX_REASSEMBLY_SIZE      22
#define OPTION_DEFAULT_TTL              23
#define OPTION_PMTU_AGING_TIMEOUT       24
#define OPTION_PMTU_PLATEAU_TABLE       25

//
// Link layer parameters - per interface.
//

#define OPTION_MTU                      26
#define OPTION_ALL_SUBNETS_MTU          27
#define OPTION_BROADCAST_ADDRESS        28
#define OPTION_PERFORM_MASK_DISCOVERY   29
#define OPTION_BE_A_MASK_SUPPLIER       30
#define OPTION_PERFORM_ROUTER_DISCOVERY 31
#define OPTION_ROUTER_SOLICITATION_ADDR 32
#define OPTION_STATIC_ROUTES            33
#define OPTION_TRAILERS                 34
#define OPTION_ARP_CACHE_TIMEOUT        35
#define OPTION_ETHERNET_ENCAPSULATION   36

//
// TCP Paramters - per host
//

#define OPTION_TTL                      37
#define OPTION_KEEP_ALIVE_INTERVAL      38
#define OPTION_KEEP_ALIVE_DATA_SIZE     39

//
// Application Layer Parameters
//

#define OPTION_NETWORK_INFO_SERVICE_DOM 40
#define OPTION_NETWORK_INFO_SERVERS     41
#define OPTION_NETWORK_TIME_SERVERS     42

//
// Vender specific information option
//

#define OPTION_VENDOR_SPEC_INFO         43

//
// NetBIOS over TCP/IP Name server option
//

#define OPTION_NETBIOS_NAME_SERVER      44
#define OPTION_NETBIOS_DATAGRAM_SERVER  45
#define OPTION_NETBIOS_NODE_TYPE        46
#define OPTION_NETBIOS_SCOPE_OPTION     47

//
// X Window System Options.
//

#define OPTION_XWINDOW_FONT_SERVER      48
#define OPTION_XWINDOW_DISPLAY_MANAGER  49

//
// Other extensions
//

#define OPTION_REQUESTED_ADDRESS        50
#define OPTION_LEASE_TIME               51
#define OPTION_OK_TO_OVERLAY            52
#define OPTION_MESSAGE_TYPE             53
#define OPTION_SERVER_IDENTIFIER        54
#define OPTION_PARAMETER_REQUEST_LIST   55
#define OPTION_MESSAGE                  56
#define OPTION_MESSAGE_LENGTH           57
#define OPTION_RENEWAL_TIME             58      // T1
#define OPTION_REBIND_TIME              59      // T2
#define OPTION_CLIENT_CLASS_INFO        60
#define OPTION_CLIENT_ID                61

#define OPTION_TFTP_SERVER_NAME         66
#define OPTION_BOOTFILE_NAME            67

//
//  Dynamic DNS Stuff.  Tells if we should do both A+PTR updates?
//
#define OPTION_DYNDNS_BOTH              81


#define OPTION_END                      255

//
// Different option values for the DYNDNS_BOTH option ...
//

#define DYNDNS_REGISTER_AT_CLIENT       0     // Client will do both registrations
#define DYNDNS_REGISTER_AT_SERVER       1     // Server will do registrations
#define DYNDNS_DOWNLEVEL_CLIENT         3     // arbitraty # diff from above

//
// Microsoft-specific options
//
#define OPTION_MSFT_DSDOMAINNAME_REQ    94    // send me your DS Domain name
#define OPTION_MSFT_DSDOMAINNAME_RESP   95    // sending my DS Domain name

//
// DHCP Message types
//

#define DHCP_DISCOVER_MESSAGE  1
#define DHCP_OFFER_MESSAGE     2
#define DHCP_REQUEST_MESSAGE   3
#define DHCP_DECLINE_MESSAGE   4
#define DHCP_ACK_MESSAGE       5
#define DHCP_NACK_MESSAGE      6
#define DHCP_RELEASE_MESSAGE   7
#define DHCP_INFORM_MESSAGE    8

#define DHCP_MAGIC_COOKIE_BYTE1     99
#define DHCP_MAGIC_COOKIE_BYTE2     130
#define DHCP_MAGIC_COOKIE_BYTE3     83
#define DHCP_MAGIC_COOKIE_BYTE4     99

#define BOOT_FILE_SIZE          128
#define BOOT_SERVER_SIZE        64
#define BOOT_FILE_SIZE_W        ( BOOT_FILE_SIZE * sizeof( WCHAR ))
#define BOOT_SERVER_SIZE_W      ( BOOT_SERVER_SIZE * sizeof( WCHAR ))

//
// DHCP APP names - used to indentify to the eventlogger.
//

#define DHCP_EVENT_CLIENT     TEXT("Dhcp")
#define DHCP_EVENT_SERVER     TEXT("DhcpServer")


typedef struct _OPTION {
    BYTE OptionType;
    BYTE OptionLength;
    BYTE OptionValue[1];
} OPTION, *POPTION, *LPOPTION;

//
// A DHCP message buffer
//


#pragma pack(1)         /* Assume byte packing */
typedef struct _DHCP_MESSAGE {
    BYTE Operation;
    BYTE HardwareAddressType;
    BYTE HardwareAddressLength;
    BYTE HopCount;
    DWORD TransactionID;
    WORD SecondsSinceBoot;
    WORD Reserved;
    DHCP_IP_ADDRESS ClientIpAddress;
    DHCP_IP_ADDRESS YourIpAddress;
    DHCP_IP_ADDRESS BootstrapServerAddress;
    DHCP_IP_ADDRESS RelayAgentIpAddress;
    BYTE HardwareAddress[16];
    BYTE HostName[ BOOT_SERVER_SIZE ];
    BYTE BootFileName[BOOT_FILE_SIZE];
    OPTION Option;
} DHCP_MESSAGE, *PDHCP_MESSAGE, *LPDHCP_MESSAGE;
#pragma pack()

#define DHCP_MESSAGE_FIXED_PART_SIZE \
            (sizeof(DHCP_MESSAGE) - sizeof(OPTION))

#define DHCP_MIN_SEND_RECV_PK_SIZE \
            (DHCP_MESSAGE_FIXED_PART_SIZE + 64)

//
// JET - DHCP database constants.
//

#define DB_TABLE_SIZE       10      // table size in 4K pages.
#define DB_TABLE_DENSITY    80      // page density
#define DB_LANGID           0x0409  // language id
#define DB_CP               1252    // code page

#if DBG

//
// debug functions.
//

#ifdef CHICAGO // No Tracing available on CHICAGO
#define DhcpPrintTrace
#endif

#define IF_DEBUG(flag) if (DhcpGlobalDebugFlag & (DEBUG_ ## flag))
#define DhcpPrint(_x_) DhcpPrintRoutine _x_
#define Trace          DhcpPrintTrace

#ifndef CHICAGO
VOID
DhcpPrintTrace(
    IN LPSTR Format,
    ...
    );

#endif

VOID
DhcpPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    );

#else

#define IF_DEBUG(flag) if (FALSE)
#define DhcpPrint(_x_)
#define Trace       (void)

#endif // DBG

#endif // _DHCP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\dynrecpp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 -99             **/
/**********************************************************************/

/*
    dynrecpp.cpp
        Comment goes here

    FILE HISTORY:

*/

#include "stdafx.h"
#include "winssnap.h"
#include "DynRecpp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDynamicPropGen property page

IMPLEMENT_DYNCREATE(CDynamicPropGen, CPropertyPageBase)

CDynamicPropGen::CDynamicPropGen() : CPropertyPageBase(CDynamicPropGen::IDD)
{
	//{{AFX_DATA_INIT(CDynamicPropGen)
	//}}AFX_DATA_INIT
}

CDynamicPropGen::~CDynamicPropGen()
{
}

void CDynamicPropGen::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDynamicPropGen)
	DDX_Control(pDX, IDC_EDIT_OWNER, m_editOwner);
	DDX_Control(pDX, IDC_LIST_ADDRESSES, m_listAddresses);
	DDX_Control(pDX, IDC_STATIC_IPADD, m_staticIPAdd);
	DDX_Control(pDX, IDC_EDIT_VERSION, m_editVersion);
	DDX_Control(pDX, IDC_EDIT_TYPE, m_editType);
	DDX_Control(pDX, IDC_EDIT_STATE, m_editState);
	DDX_Control(pDX, IDC_EDIT_NAME, m_editName);
	DDX_Control(pDX, IDC_EDIT_EXPIRATION, m_editExpiration);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDynamicPropGen, CPropertyPageBase)
	//{{AFX_MSG_MAP(CDynamicPropGen)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDynamicPropGen message handlers


/////////////////////////////////////////////////////////////////////////////
// CDynamicMappingProperties message handlers
CDynamicMappingProperties::CDynamicMappingProperties
(
	ITFSNode *			pNode,
	IComponent *	    pComponent,
	LPCTSTR				pszSheetName,
	WinsRecord*		    pwRecord
) : CPropertyPageHolderBase(pNode, pComponent, pszSheetName)

{
	m_bAutoDeletePages = FALSE; // we have the pages as embedded members
    m_bTheme = TRUE;

	AddPageToList((CPropertyPageBase*) &m_pageGeneral);

	if(pwRecord)
	{
		ZeroMemory(&m_wsRecord, sizeof(m_wsRecord));
        strcpy(m_wsRecord.szRecordName , pwRecord->szRecordName);

        m_wsRecord.dwExpiration = pwRecord->dwExpiration;
		m_wsRecord.dwExpiration = pwRecord->dwExpiration;
		m_wsRecord.dwNoOfAddrs = pwRecord->dwNoOfAddrs;

		for(DWORD i = 0; i < pwRecord->dwNoOfAddrs; i++)
		{
			m_wsRecord.dwIpAdd[i] = pwRecord->dwIpAdd[i];
		}
		m_wsRecord.liVersion = pwRecord->liVersion;
		m_wsRecord.dwNameLen = pwRecord->dwNameLen;
		m_wsRecord.dwOwner = pwRecord->dwOwner;
		m_wsRecord.dwState = pwRecord->dwState;
		m_wsRecord.dwType = pwRecord->dwType;
	}
}


CDynamicMappingProperties::~CDynamicMappingProperties()
{
	RemovePageFromList((CPropertyPageBase*) &m_pageGeneral, FALSE);
}

BOOL CDynamicPropGen::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();

	// get the actreg node
	CActiveRegistrationsHandler *pActReg;

	SPITFSNode  spNode;
	spNode = GetHolder()->GetNode();

	pActReg = GETHANDLER(CActiveRegistrationsHandler, spNode);

	WinsRecord ws = ((CDynamicMappingProperties*)GetHolder())->m_wsRecord;

	// build the name string
    CString strName;
    pActReg->CleanNetBIOSName(ws.szRecordName,
                              strName,
						      TRUE,   // Expand
							  TRUE,   // Truncate
							  pActReg->IsLanManCompatible(), 
							  TRUE,   // name is OEM
							  FALSE,  // No double backslash
                              ws.dwNameLen);

	m_editName.SetWindowText(strName);
	
	// setup the listbox
	CString strColumn;

	strColumn.LoadString(IDS_IP_ADDRESS);
	m_listAddresses.InsertColumn(0, strColumn, LVCFMT_LEFT, 90);
	ListView_SetExtendedListViewStyle(m_listAddresses.GetSafeHwnd(), LVS_EX_FULLROWSELECT);

    BOOL fMultiCol = !( (ws.dwState & WINSDB_REC_UNIQUE) ||
					    (ws.dwState & WINSDB_REC_NORM_GROUP) );
    if (fMultiCol)
	{
		strColumn.LoadString(IDS_ACTREG_OWNER);
		m_listAddresses.InsertColumn(1, strColumn, LVCFMT_LEFT, 90);
	}

	CString strIP, strOwnerIP;
	int nIndex = 0;

	for (DWORD i = 0; i < ws.dwNoOfAddrs; i++)
	{
        if (fMultiCol)
		{
			::MakeIPAddress(ws.dwIpAdd[i++], strOwnerIP);
            ::MakeIPAddress(ws.dwIpAdd[i], strIP);

            if (ws.dwIpAdd[i] != 0)
            {
			    m_listAddresses.InsertItem(nIndex, strIP);
			    m_listAddresses.SetItem(nIndex, 1, LVIF_TEXT, strOwnerIP, 0, 0, 0, 0);
            }
        }
		else
		{
			::MakeIPAddress(ws.dwIpAdd[i], strIP);
			m_listAddresses.InsertItem(nIndex, strIP);
		}

		nIndex++;
	}
	
	// now the type
	CString strType;
	pActReg->m_NameTypeMap.TypeToCString((DWORD)ws.szRecordName[15], MAKELONG(HIWORD(ws.dwType), 0), strType);
	m_editType.SetWindowText(strType);

	// active status
	CString strActive;
	pActReg->GetStateString(ws.dwState, strActive);
	m_editState.SetWindowText(strActive);

	// expiration time
	CString strExpiration;
    CTime timeExpiration(ws.dwExpiration);
    FormatDateTime(strExpiration, timeExpiration);
	m_editExpiration.SetWindowText(strExpiration);

	// version
	CString strVersion;
	pActReg->GetVersionInfo(ws.liVersion.LowPart, ws.liVersion.HighPart, strVersion);
	m_editVersion.SetWindowText(strVersion);

	// owner
    if (ws.dwOwner != INVALID_OWNER_ID)
    {
	    CString strOwner;
	    MakeIPAddress(ws.dwOwner, strOwner);
	    m_editOwner.SetWindowText(strOwner);
    }

    // load the correct icon
    for (i = 0; i < ICON_IDX_MAX; i++)
    {
        if (g_uIconMap[i][1] == m_uImage)
        {
            HICON hIcon = LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
            if (hIcon)
                ((CStatic *) GetDlgItem(IDC_STATIC_ICON))->SetIcon(hIcon);
            break;
        }
    }
	
	return TRUE;  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\dynrecpp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	dynrecpp.h
		Dynamic mapping property page
		
    FILE HISTORY:
        
*/

#if !defined _DYNRECPP_H
#define _DYNRECPP_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef _ACTREG_H
#include "actreg.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// CDynamicPropGen dialog

class CDynamicPropGen : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CDynamicPropGen)

// Construction
public:
	CDynamicPropGen();
	~CDynamicPropGen();

// Dialog Data
	//{{AFX_DATA(CDynamicPropGen)
	enum { IDD = IDD_DYN_PROPERTIES };
	CEdit	m_editOwner;
	CListCtrl	m_listAddresses;
	CStatic	m_staticIPAdd;
	CEdit	m_editVersion;
	CEdit	m_editType;
	CEdit	m_editState;
	CEdit	m_editName;
	CEdit	m_editExpiration;
	//}}AFX_DATA

	UINT	m_uImage;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDynamicPropGen)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CDynamicPropGen)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CDynamicPropGen::IDD);};//return NULL;}

};

class CDynamicMappingProperties:public CPropertyPageHolderBase
{
	
public:
	CDynamicMappingProperties(ITFSNode *	pNode,
							  IComponent *  pComponent,
							  LPCTSTR		pszSheetName,
							  WinsRecord*	pwRecord = NULL);

	virtual ~CDynamicMappingProperties();

public:
	CDynamicPropGen			m_pageGeneral;
	WinsRecord				m_wsRecord;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined _DYNRECPP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\fndrcdlg.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	fndrcdlg.h
		Find Record Dialog
		
    FILE HISTORY:

    2/15/98 RamC    Added Cancel button to the Find dialog
        
*/

#if !defined(AFX_FNDRCDLG_H__C13DD118_4999_11D1_B9A8_00C04FBF914A__INCLUDED_)
#define AFX_FNDRCDLG_H__C13DD118_4999_11D1_B9A8_00C04FBF914A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CFindRecord dialog
#ifndef _BASEDLG__
	#include "dialog.h"
#endif

class CActiveRegistrationsHandler;

class CFindRecord : public CBaseDialog
{
//	DECLARE_DYNCREATE(CFindRecord)

// Construction
public:
	CFindRecord(CActiveRegistrationsHandler *pActReg,CWnd* pParent = NULL);
	~CFindRecord();

	CActiveRegistrationsHandler *m_pActreg;

	BOOL IsDuplicate(const CString & strName);
    void EnableButtons(BOOL bEnable);

// Dialog Data
	//{{AFX_DATA(CFindRecord)
	enum { IDD = IDD_ACTREG_FIND_RECORD };
	CButton	m_buttonOK;
	CButton	m_buttonCancel;
	CComboBox	m_comboLokkForName;
	CButton	m_buttonStop;
	CButton	m_buttonNewSearch;
	CButton	m_buttonFindNow;
	CString	m_strFindName;
	BOOL	m_fMixedCase;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFindRecord)
	public:
	virtual void OnOK();
	virtual void OnCancel();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFindRecord)
	virtual BOOL OnInitDialog();
	afx_msg void OnEditchangeComboName();
	afx_msg void OnSelendokComboName();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CFindRecord::IDD);};//return NULL;}

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FNDRCDLG_H__C13DD118_4999_11D1_B9A8_00C04FBF914A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\fndrcdlg.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	FndRcDlg.cpp
		Replication Node Property page
		
    FILE HISTORY:
        
    2/15/98 RamC    Added Cancel button to the Find dialog
*/

#include "stdafx.h"
#include "winssnap.h"
#include "FndRcdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "actreg.h"
/////////////////////////////////////////////////////////////////////////////
// CFindRecord property page

//IMPLEMENT_DYNCREATE(CFindRecord, CBaseDialog)

CFindRecord::CFindRecord(CActiveRegistrationsHandler *pActreg, CWnd* pParent) :CBaseDialog(CFindRecord::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFindRecord)
	m_strFindName = _T("");
	m_fMixedCase = FALSE;
	//}}AFX_DATA_INIT
	m_pActreg = pActreg;
}

CFindRecord::~CFindRecord()
{
}

void CFindRecord::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFindRecord)
	DDX_Control(pDX, IDOK, m_buttonOK);
	DDX_Control(pDX, IDCANCEL, m_buttonCancel);
	DDX_Control(pDX, IDC_COMBO_NAME, m_comboLokkForName);
	DDX_CBString(pDX, IDC_COMBO_NAME, m_strFindName);
	DDX_Check(pDX, IDC_CHECK_MIXED_CASE, m_fMixedCase);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFindRecord, CBaseDialog)
	//{{AFX_MSG_MAP(CFindRecord)
	ON_CBN_EDITCHANGE(IDC_COMBO_NAME, OnEditchangeComboName)
	ON_CBN_SELENDOK(IDC_COMBO_NAME, OnSelendokComboName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFindRecord message handlers

BOOL 
CFindRecord::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();

	// disable the findnow button
	m_buttonOK.EnableWindow(FALSE);

	// fill the combobox from the array in the actreg handler
	int nCount = (int)m_pActreg->m_strFindNamesArray.GetSize();

	for(int i = 0; i < nCount; i++)
	{
		m_comboLokkForName.AddString(m_pActreg->m_strFindNamesArray[i]);
	}

	return TRUE;  
}

void 
CFindRecord::OnOK() 
{
	UpdateData();

	m_strFindName.TrimLeft();
	m_strFindName.TrimRight();

	// add the string to the cache in the act reg node
	if(!IsDuplicate(m_strFindName))
		m_pActreg->m_strFindNamesArray.Add(m_strFindName);

    if (!m_fMixedCase)
        m_strFindName.MakeUpper();

	m_pActreg->m_strFindName = m_strFindName;

    CBaseDialog::OnOK();
}

void 
CFindRecord::OnCancel() 
{
	CBaseDialog::OnCancel();
}

BOOL 
CFindRecord::IsDuplicate(const CString & strName)
{
	int nCount = (int)m_pActreg->m_strFindNamesArray.GetSize();

	for(int i = 0; i < nCount; i++)
	{
		// if found
		if(m_pActreg->m_strFindNamesArray[i].Compare(m_strFindName) == 0)
		{
			return TRUE;
		}
	}
	return FALSE;
}


void CFindRecord::OnEditchangeComboName() 
{
	UpdateData();

    EnableButtons(m_strFindName.IsEmpty() ? FALSE : TRUE);
}

void CFindRecord::OnSelendokComboName() 
{
    EnableButtons(TRUE);
}

void CFindRecord::EnableButtons(BOOL bEnable)
{
   	m_buttonOK.EnableWindow(bEnable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\getnetbi.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	getnetbi.h
		gets a netbios name for a given address
		
    FILE HISTORY:
        
*/

#ifndef _GETNETBI_H
#define _GETNETBI_H

/////////////////////////////////////////////////////////////////////////////
// CGetNetBIOSNameDlg dialog

class CGetNetBIOSNameDlg : public CDialog
{
// Construction
public:
    CGetNetBIOSNameDlg(
        CIpNamePair * pipnp,
        CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CGetNetBIOSNameDlg)
    enum { IDD = IDD_GETNETBIOSNAME };
    CButton m_button_Ok;
    CEdit   m_edit_NetBIOSName;
    CStatic m_static_IpAddress;
    //}}AFX_DATA

// Implementation
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

    // Generated message map functions
    //{{AFX_MSG(CGetNetBIOSNameDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    afx_msg void OnChangeEditNetbiosname();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    CIpNamePair * m_pipnp;

private:
    void HandleControlStates();

public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CGetNetBIOSNameDlg::IDD);};
};

#endif _GETNETBI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\getipadd.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 -99             **/
/**********************************************************************/

/*
    getipadd.cpp
        Comment goes here

    FILE HISTORY:

*/

#include "stdafx.h"
#include "getipadd.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CGetIpAddressDlg dialog

CGetIpAddressDlg::CGetIpAddressDlg(
    CIpNamePair * pipnp,
    CWnd* pParent /*=NULL*/)
    : CDialog(CGetIpAddressDlg::IDD, pParent)
{
    ASSERT(pipnp != NULL);
    m_pipnp = pipnp;

    //{{AFX_DATA_INIT(CGetIpAddressDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

void CGetIpAddressDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CGetIpAddressDlg)
    DDX_Control(pDX, IDOK, m_button_Ok);
    DDX_Control(pDX, IDC_STATIC_NETBIOSNAME, m_static_NetBIOSName);
    //}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_IPA_IPADDRESS, m_ipa_IpAddress);
}

BEGIN_MESSAGE_MAP(CGetIpAddressDlg, CDialog)
    //{{AFX_MSG_MAP(CGetIpAddressDlg)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_IPA_IPADDRESS, OnChangeIpControl)

END_MESSAGE_MAP()

void CGetIpAddressDlg::HandleControlStates()
{
    DWORD dwIp;
    BOOL f = m_ipa_IpAddress.GetAddress(&dwIp);

    m_button_Ok.EnableWindow(f);
}

/////////////////////////////////////////////////////////////////////////////
// CGetIpAddressDlg message handlers

BOOL CGetIpAddressDlg::OnInitDialog()
{
    CDialog::OnInitDialog();
    CString strNetBIOSName;

    strNetBIOSName = m_pipnp->GetNetBIOSName();

    m_static_NetBIOSName.SetWindowText(strNetBIOSName);
    m_ipa_IpAddress.SetFocusField(-1);

    HandleControlStates();
    
    return TRUE;  
}

void CGetIpAddressDlg::OnChangeIpControl()
{
    HandleControlStates();
}

void CGetIpAddressDlg::OnOK()
{
    ULONG l;
    if (m_ipa_IpAddress.GetAddress(&l))
    {
        m_pipnp->SetIpAddress((LONG)l);
        CDialog::OnOK();
        return;
    }
    theApp.MessageBox(IDS_ERR_INVALID_IP);
    m_ipa_IpAddress.SetFocusField(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\getipadd.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	getipadd.h
		gets an IP address for a given name
		
    FILE HISTORY:
        
*/

#ifndef _GETIPADD_H
#define _GETIPADD_H

/////////////////////////////////////////////////////////////////////////////
// CGetIpAddressDlg dialog

class CGetIpAddressDlg : public CDialog
{
// Construction
public:
    CGetIpAddressDlg(
        CIpNamePair * pipnp,
        CWnd* pParent = NULL); // standard constructor

// Dialog Data
    //{{AFX_DATA(CGetIpAddressDlg)
    enum { IDD = IDD_GETIPADDRESS };
    CButton m_button_Ok;
    CStatic m_static_NetBIOSName;
    //}}AFX_DATA

    CWndIpAddress m_ipa_IpAddress;

// Implementation
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

    // Generated message map functions
    //{{AFX_MSG(CGetIpAddressDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    afx_msg void OnChangeIpControl();
    void HandleControlStates();

private:
    CIpNamePair * m_pipnp;

public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CGetIpAddressDlg::IDD);};
};

#endif _GETIPADD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\getnetbi.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 -99             **/
/**********************************************************************/

/*
    getnetbi.cpp
        Comment goes here

    FILE HISTORY:

*/

#include "stdafx.h"
#include "getnetbi.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CGetNetBIOSNameDlg dialog

CGetNetBIOSNameDlg::CGetNetBIOSNameDlg(
    CIpNamePair * pipnp,
    CWnd* pParent /*=NULL*/)
    : CDialog(CGetNetBIOSNameDlg::IDD, pParent)
{
    ASSERT(pipnp != NULL);
    m_pipnp = pipnp;

    //{{AFX_DATA_INIT(CGetNetBIOSNameDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

void CGetNetBIOSNameDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CGetNetBIOSNameDlg)
    DDX_Control(pDX, IDOK, m_button_Ok);
    DDX_Control(pDX, IDC_EDIT_NETBIOSNAME, m_edit_NetBIOSName);
    DDX_Control(pDX, IDC_STATIC_IPADDRESS, m_static_IpAddress);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CGetNetBIOSNameDlg, CDialog)
    //{{AFX_MSG_MAP(CGetNetBIOSNameDlg)
    ON_EN_CHANGE(IDC_EDIT_NETBIOSNAME, OnChangeEditNetbiosname)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CGetNetBIOSNameDlg::HandleControlStates()
{
    CString str;
    m_edit_NetBIOSName.GetWindowText(str);
    str.TrimRight();
    str.TrimLeft();
    
    m_button_Ok.EnableWindow(!str.IsEmpty());
}

/////////////////////////////////////////////////////////////////////////////
// CGetNetBIOSNameDlg message handlers

BOOL CGetNetBIOSNameDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    HandleControlStates();
    // Allow for LM names + 2 backslashes
    m_edit_NetBIOSName.LimitText(LM_NAME_MAX_LENGTH + 2);
    m_edit_NetBIOSName.SetFocus();

    m_static_IpAddress.SetWindowText((CString)m_pipnp->GetIpAddress());
    
    return TRUE;  
}

void CGetNetBIOSNameDlg::OnChangeEditNetbiosname()
{
    HandleControlStates();    
}

void CGetNetBIOSNameDlg::OnOK()
{
    CString strAddress;

    m_edit_NetBIOSName.GetWindowText(strAddress);
    
    strAddress.TrimRight();
    strAddress.TrimLeft();
    
    if (::IsValidNetBIOSName(strAddress, TRUE, TRUE))
    {
        // Address may have been cleaned up in validation,
        // so it should be re-displayed at once.
        m_edit_NetBIOSName.SetWindowText(strAddress);
        m_edit_NetBIOSName.UpdateWindow();
        // Don't copy the slashes
        CString strName((LPCTSTR) strAddress+2);
        m_pipnp->SetNetBIOSName(strName);

        CDialog::OnOK();
        return;
    }
    
    // Invalid address was entered 
    theApp.MessageBox(IDS_ERR_BAD_NB_NAME);
    m_edit_NetBIOSName.SetSel(0,-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\guid.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	guids.cpp
		WINS snapin GUID definitions

	FILE HISTORY:
        
*/

#include "stdafx.h"

// {90901AF6-7A31-11d0-97E0-00C04FC3357A}
const CLSID CLSID_WinsSnapin = 
{ 0x60af234a, 0xd7d3, 0x11d0, { 0xab, 0xb0, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

// {524CCE97-A886-11d0-AB86-00C04FC3357A}
const CLSID CLSID_WinsSnapinExtension = 
{ 0x60af234b, 0xd7d3, 0x11d0, { 0xab, 0xb0, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

// {1CE57F61-A88A-11d0-AB86-00C04FC3357A}
const GUID CLSID_WinsSnapinAbout = 
{ 0x60af234c, 0xd7d3, 0x11d0, { 0xab, 0xb0, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

// {1AE7F339-AA00-11d0-AB88-00C04FC3357A}
const GUID GUID_WinsRootNodeType = 
{ 0x60af234d, 0xd7d3, 0x11d0, { 0xab, 0xb0, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

// {D5A5218E-BD09-11d0-AB96-00C04FC3357A}
const GUID GUID_WinsGenericNodeType = 
{ 0x60af234e, 0xd7d3, 0x11d0, { 0xab, 0xb0, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

// {4387C0E6-19C5-11d1-B954-00C04FBF914A}
static const GUID GUID_WinsServerNodeType = 
{ 0x4387c0e6, 0x19c5, 0x11d1, { 0xb9, 0x54, 0x0, 0xc0, 0x4f, 0xbf, 0x91, 0x4a } };

// {E220FD88-1FE6-11d1-B967-00C04FBF914A}
static const GUID GUID_WinsActiveRegNodeType = 
{ 0xe220fd88, 0x1fe6, 0x11d1, { 0xb9, 0x67, 0x0, 0xc0, 0x4f, 0xbf, 0x91, 0x4a } };

// {46036082-1FF8-11d1-B967-00C04FBF914A}
static const GUID GUID_WinsReplicationNodeType  = 
{ 0x46036082, 0x1ff8, 0x11d1, { 0xb9, 0x67, 0x0, 0xc0, 0x4f, 0xbf, 0x91, 0x4a } };

// {FEC2D41A-2DF7-11d1-B97B-00C04FBF914A}
static const GUID GUID_WinsActiveRegistrationLeafNodeType = 
{ 0xfec2d41a, 0x2df7, 0x11d1, { 0xb9, 0x7b, 0x0, 0xc0, 0x4f, 0xbf, 0x91, 0x4a } };

// {6A112BB1-4577-11d1-B99F-00C04FBF914A}
static const GUID GUID_WinsReplicationPartnerLeafNodeType = 
{ 0x6a112bb1, 0x4577, 0x11d1, { 0xb9, 0x9f, 0x0, 0xc0, 0x4f, 0xbf, 0x91, 0x4a } };

// {CC6473A7-A49C-11d1-BA4D-00C04FBF914A}
static const GUID GUID_WinsServerStatusNodeType = 
{ 0xcc6473a7, 0xa49c, 0x11d1, { 0xba, 0x4d, 0x0, 0xc0, 0x4f, 0xbf, 0x91, 0x4a } };

// {B708F542-A590-11d1-BA4F-00C04FBF914A}
static const GUID GUID_WinsServerStatusLeafNodeType = 
{ 0xb708f542, 0xa590, 0x11d1, { 0xba, 0x4f, 0x0, 0xc0, 0x4f, 0xbf, 0x91, 0x4a } };

// network console GUIDs
// {DA1BDD17-8E54-11d1-93DB-00C04FC3357A}
/*
static const GUID GUID_NetConsRootNodeType = 
{ 0xda1bdd17, 0x8e54, 0x11d1, { 0x93, 0xdb, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };
*/

const IID IID_IWinsDatabase = {0x7B0C8BBF,0x3117,0x11d1,{0xB9,0x81,0x00,0xC0,0x4F,0xBF,0x91,0x4A}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\ipadddlg.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 -99             **/
/**********************************************************************/

/*
    ipadddlg.cpp
        Comment goes here

    FILE HISTORY:

*/

#include "stdafx.h"
#include "winssnap.h"
#include "IPAddDlg.h"
#include "getipadd.h"
#include "getnetbi.h"

#include <objpick.h> // for CGetComputer

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Get replication trigger partner
BOOL CGetTriggerPartner::OnInitDialog() 
{
	CIPAddressDlg::OnInitDialog();
	
	CString strText;

	strText.LoadString(IDS_SELECT_TRIGGER_PARTNER_TITLE);

	// Set the title of the dialog
	SetWindowText(strText);

    // set the description text
    strText.LoadString(IDS_SELECT_TRIGGER_PARTNER);

	m_staticDescription.SetWindowText(strText);

    return TRUE;
}

// add WINS server dialog
BOOL CNewWinsServer::DoExtraValidation()
{
	// check to see if the server is in the list
	BOOL fIsIpInList = m_pRootHandler->IsIPInList(m_spRootNode, m_dwServerIp);
	BOOL fIsNameInList = m_pRootHandler->IsServerInList(m_spRootNode, m_strServerName);
	
	if (fIsIpInList && fIsNameInList)
	{
        CThemeContextActivator themeActivator;
		m_editServerName.SetFocus();
		m_editServerName.SetSel(0, -1);
		
		AfxMessageBox(IDS_ERR_WINS_EXISTS, MB_OK);
		
		return FALSE;
	}

	return TRUE;
}

// add Persona Non Grata dialog
BOOL CNewPersonaNonGrata::DoExtraValidation()
{
    CThemeContextActivator themeActivator;

    // check if the server already exists
	if (m_pRepPropDlg->IsDuplicate(m_strServerName))
	{
		m_editServerName.SetFocus();
		m_editServerName.SetSel(0,-1);
		
		AfxMessageBox(IDS_ERR_WINS_EXISTS, MB_OK|MB_ICONINFORMATION);
		
		return FALSE;
	}

	// check the same server is being added
	if (m_pRepPropDlg->IsCurrentServer(m_strServerName))
	{
		m_editServerName.SetFocus();
		m_editServerName.SetSel(0,-1);
		
		AfxMessageBox(IDS_LOCALSERVER, MB_OK | MB_ICONINFORMATION);

		return FALSE;
	}

	return TRUE;
}

// add new replication partner dialog
BOOL CNewReplicationPartner::OnInitDialog() 
{
	CIPAddressDlg::OnInitDialog();
	
	CString strText;

	strText.LoadString(IDS_NEW_REPLICATION_PARTNER_TITLE);

	// Set the title of the dialog
	SetWindowText(strText);

	strText.LoadString(IDS_NEW_REPLICATION_PARTNER_DESC);

	m_staticDescription.SetWindowText(strText);

	return TRUE;  
}

BOOL CNewReplicationPartner::DoExtraValidation()
{
	// check if the same servers is being added as a rep partner
	SPITFSNode spServerNode;
	m_spRepPartNode->GetParent(&spServerNode);

	CWinsServerHandler *pServer = GETHANDLER(CWinsServerHandler, spServerNode);
    CThemeContextActivator themeActivator;

	CString strThisServerName = pServer->m_strServerAddress;
	DWORD dwThisServerIP = pServer->m_dwIPAdd;

	if ( (m_dwServerIp == dwThisServerIP) && (m_strServerName.CompareNoCase(strThisServerName) == 0))
	{
		//The server is already present as replication partner
		AfxMessageBox(IDS_REP_PARTNER_LOCAL, MB_OK);
		
		m_editServerName.SetFocus();
		m_editServerName.SetSel(0,-1);
		
		return FALSE;
	}

	CIpNamePair ip;

	ip.SetIpAddress(m_dwServerIp);
	ip.SetNetBIOSName(m_strServerName);

	// check if the server already exists in the 
	// list of replication folderss
	if ( m_pRepPartHandler->IsInList(ip, TRUE) != -1)
	{
		//The server is already present as replication partner
		AfxMessageBox(IDS_REP_PARTNER_EXISTS, MB_OK);
		
		m_editServerName.SetFocus();
		m_editServerName.SetSel(0,-1);
		
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CIPAddressDlg dialog

CIPAddressDlg::CIPAddressDlg(CWnd* pParent /*=NULL*/)
	: CBaseDialog(CIPAddressDlg::IDD, pParent),
    m_fNameRequired(TRUE)
{
	//{{AFX_DATA_INIT(CIPAddressDlg)
	m_strNameOrIp = _T("");
	//}}AFX_DATA_INIT
}

void CIPAddressDlg::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CIPAddressDlg)
	DDX_Control(pDX, IDC_STATIC_WINS_SERVER_DESC, m_staticDescription);
	DDX_Control(pDX, IDC_EDIT_SERVER_NAME, m_editServerName);
	DDX_Control(pDX, IDOK, m_buttonOK);
	DDX_Text(pDX, IDC_EDIT_SERVER_NAME, m_strNameOrIp);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CIPAddressDlg, CBaseDialog)
	//{{AFX_MSG_MAP(CIPAddressDlg)
	ON_EN_CHANGE(IDC_EDIT_SERVER_NAME, OnChangeEditServerName)
	ON_BN_CLICKED(IDC_BUTTON_BROWSE_COMPUTERS, OnButtonBrowseComputers)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CIPAddressDlg message handlers

void CIPAddressDlg::OnOK() 
{
	UpdateData();

	m_strNameOrIp.TrimLeft();
	m_strNameOrIp.TrimRight();

	if(m_strNameOrIp.IsEmpty())
		return;

	// resolve the IP address, if not valid, return
	if (!ValidateIPAddress())
	{
		// set back the focus to the IP address control
		m_editServerName.SetFocus();
		m_editServerName.SetSel(0,-1);
		return;
	}

	CBaseDialog::OnOK();
}

BOOL 
CIPAddressDlg::ValidateIPAddress()
{
	CString				strAddress;
	BOOL				fIp = FALSE;
	DWORD				err = ERROR_SUCCESS;
	BOOL				bCheck = FALSE;
	DWORD				dwAddress;
	CString				strServerName;
    CThemeContextActivator themeActivator;
	
	strAddress = m_strNameOrIp;

	if (IsValidAddress(strAddress, &fIp, TRUE, TRUE))
	{
		// if not an IP adress, check if FQDN has been entered, if so
		// pass the letters before the first period
		if(!fIp)
		{
			int nPos = strAddress.Find(_T("."));

			if(nPos != -1)
			{
				CString strNetBIOSName = strAddress.Left(nPos);
				strAddress = strNetBIOSName;
			}
		}

		CWinsServerObj		ws(NULL,"", TRUE, TRUE);

        strAddress.MakeUpper();

        // machine name specified
		if (fIp) 
		    ws = CWinsServerObj(CIpAddress(strAddress), "", TRUE, TRUE);
		// IP address specified
        else 
		{
			ws = CWinsServerObj(CIpAddress(), strAddress, TRUE, TRUE);
        }

		BEGIN_WAIT_CURSOR

        err = ::VerifyWinsServer(strAddress, strServerName, dwAddress);
		
		END_WAIT_CURSOR

        if (err != ERROR_SUCCESS)
        {
            // The server isn't running wins.  Ask user for name/ip.
            if (fIp && m_fNameRequired)
            {
                CGetNetBIOSNameDlg dlgGetNB(&ws);
                if (dlgGetNB.DoModal() == IDCANCEL)
                {
                    return FALSE;
                }
            }   
            else
            if (!fIp)
            {
                CGetIpAddressDlg dlgGetIP(&ws);
                if (dlgGetIP.DoModal() == IDCANCEL)
                {
                    return FALSE;
                }
            }

            m_dwServerIp = (LONG) ws.QueryIpAddress();
            m_strServerName = ws.GetNetBIOSName();
            m_strServerName.MakeUpper();
        }
		else
		{
			m_dwServerIp = dwAddress;
			m_strServerName = strServerName;
		}

		::MakeIPAddress(m_dwServerIp, m_strServerIp);

		return DoExtraValidation();
	}
	else
	{
		AfxMessageBox(IDS_SERVER_NO_EXIST, MB_OK);
		
		// set focus to the IP address comntrol
		m_editServerName.SetFocus();
        m_editServerName.SetSel(0,-1);

        return FALSE;
	}
	
    return bCheck;
}


BOOL CIPAddressDlg::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();

    // limit the length of the edit ctrl
    m_editServerName.SetLimitText(MAX_PATH);

	// set the focus to the IP address control
	m_editServerName.SetFocus();

	return TRUE;  
}

void CIPAddressDlg::OnChangeEditServerName() 
{
	// set the ok button state here
	if(m_editServerName.GetWindowTextLength() == 0)
		m_buttonOK.EnableWindow(FALSE);
	else
		m_buttonOK.EnableWindow(TRUE);
}

void CIPAddressDlg::OnButtonBrowseComputers() 
{
    CGetComputer dlgGetComputer;
    
    if (!dlgGetComputer.GetComputer(::FindMMCMainWindow()))
        return;

    m_editServerName.SetWindowText(dlgGetComputer.m_strComputerName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\ipctrl.cpp ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    ipctrl.cpp
//
// History:
//              Tony Romano             Created.
//  06/17/96    Abolade Gbadegesin      Revised.
//
// Implements the C++ class encapsulating the IP-address custom control.
//============================================================================

#include "stdafx.h"
extern "C" {
#include "ipaddr.h"
};

#include "ipctrl.h"




IPControl::IPControl( ) { m_hIPaddr = 0; }

IPControl::~IPControl( ) { }



BOOL
IPControl::Create(
    HWND        hParent,
    UINT        nID
    ) {

    ASSERT(IsWindow(hParent));

    if (hParent)    
        m_hIPaddr   = GetDlgItem(hParent, nID);

    return m_hIPaddr != NULL;   
}



LRESULT
IPControl::SendMessage(
    UINT        uMsg,
    WPARAM      wParam,
    LPARAM      lParam
    ) {

    ASSERT(IsWindow(m_hIPaddr));

    return ::SendMessage(m_hIPaddr, uMsg, wParam, lParam);
}



BOOL
IPControl::IsBlank(
    ) {

    return (BOOL) SendMessage(IP_ISBLANK, 0, 0);
}



VOID
IPControl::SetAddress(
    DWORD       ardwAddress[4]
    ) {

    SendMessage(
        IP_SETADDRESS, 0,
        MAKEIPADDRESS(
            ardwAddress[0], ardwAddress[1], ardwAddress[2], ardwAddress[3]
            )
        );
}



VOID
IPControl::SetAddress(
    DWORD       a1,
    DWORD       a2,
    DWORD       a3,
    DWORD       a4
    ) {

    SendMessage(IP_SETADDRESS, 0, MAKEIPADDRESS(a1,a2,a3,a4));
}



VOID
IPControl::SetAddress(
    LPCTSTR     lpszString
    ) {

    if (!lpszString) { ClearAddress(); }

    SendMessage(WM_SETTEXT, 0, (LPARAM)lpszString);
}


INT
IPControl::GetAddress(
    DWORD       *a1,
    DWORD       *a2,
    DWORD       *a3,
    DWORD       *a4
    ) {

    LRESULT nSet;
    DWORD dwAddress;

    ASSERT(a1 && a2 && a3 && a4);

    if ((nSet = SendMessage(IP_GETADDRESS,0,(LPARAM)&dwAddress)) == 0) {

        *a1 = 0;
        *a2 = 0;
        *a3 = 0;
        *a4 = 0;
    }
    else {

        *a1 = FIRST_IPADDRESS( dwAddress );
        *a2 = SECOND_IPADDRESS( dwAddress );
        *a3 = THIRD_IPADDRESS( dwAddress );
        *a4 = FOURTH_IPADDRESS( dwAddress );
    }

    return (INT) nSet;
}


INT
IPControl::GetAddress(
    DWORD       ardwAddress[4]
    ) {

    LRESULT nSet;
    DWORD dwAddress;

    if ((nSet = SendMessage(IP_GETADDRESS, 0, (LPARAM)&dwAddress )) == 0) {

        ardwAddress[0] = 0;
        ardwAddress[1] = 0;
        ardwAddress[2] = 0;
        ardwAddress[3] = 0;
    }
    else {

        ardwAddress[0] = FIRST_IPADDRESS( dwAddress );
        ardwAddress[1] = SECOND_IPADDRESS( dwAddress );
        ardwAddress[2] = THIRD_IPADDRESS( dwAddress );
        ardwAddress[3] = FOURTH_IPADDRESS( dwAddress );
    }

    return (INT) nSet;
}


INT
IPControl::GetAddress(
    CString&    address
    ) {

    LRESULT nSet, c;
    DWORD dwAddress;

    nSet = SendMessage(IP_GETADDRESS, 0, (LPARAM)&dwAddress);

    address.ReleaseBuffer((int) (c = SendMessage(WM_GETTEXT, 256, (LPARAM)address.GetBuffer(256))));

    return (INT) nSet;
}


VOID
IPControl::SetFocusField(
    DWORD       dwField
    ) {

    SendMessage(IP_SETFOCUS, dwField, 0);
}


VOID
IPControl::ClearAddress(
    ) {

    SendMessage(IP_CLEARADDRESS, 0, 0);
}


VOID
IPControl::SetFieldRange(
    DWORD       dwField,
    DWORD       dwMin,
    DWORD       dwMax
    ) {

    SendMessage(IP_SETRANGE, dwField, MAKERANGE(dwMin,dwMax));
}

#if 0
WCHAR *
inet_ntoaw(
    struct in_addr  dwAddress
    ) {

    static WCHAR szAddress[16];

    mbstowcs(szAddress, inet_ntoa(*(struct in_addr *)&dwAddress), 16);

    return szAddress;
}


DWORD
inet_addrw(
    LPCWSTR     szAddressW
    ) {

    CHAR szAddressA[16];

    wcstombs(szAddressA, szAddressW, 16);

    return inet_addr(szAddressA);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\harray.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	hArray.cpp	
		Index manager for wins db

	FILE HISTORY:
    Oct 13  1997    EricDav     Created

*/

#include "stdafx.h"
#include "wins.h"
#include "memmngr.h"
#include "harray.h"
#include "mbstring.h"
#include "vrfysrv.h"

// the lstrcmpA fucntion converts the dbcs string to Unicode using the ACP 
// and then does a string compare.  So, we need to do the OEMCP conversion
// and then call the string compare ourselves.
int
lstrcmpOEM(
    LPCSTR lpString1,
    LPCSTR lpString2
    )
{
    CString str1, str2;

    MBCSToWide((LPSTR) lpString1, str1, WINS_NAME_CODE_PAGE);
    MBCSToWide((LPSTR) lpString2, str2, WINS_NAME_CODE_PAGE);

    return lstrcmp(str1, str2);
}

/*!--------------------------------------------------------------------------
    Class CHRowIndex
 ---------------------------------------------------------------------------*/
CHRowIndex::CHRowIndex(INDEX_TYPE IndexType)
    : m_dbType(IndexType), m_bAscending(TRUE)
{
}

CHRowIndex::~CHRowIndex()
{
}

/*!--------------------------------------------------------------------------
	CHRowIndex::GetType
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CHRowIndex::GetType(INDEX_TYPE * pIndexType)
{
    if (pIndexType)
        *pIndexType = m_dbType;

    return hrOK;  
}

/*!--------------------------------------------------------------------------
	CHRowIndex::SetArray
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CHRowIndex::SetArray(HRowArray & hrowArray)
{
    m_hrowArray.Copy(hrowArray);

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CHRowIndex::GetHRow
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HROW
CHRowIndex::GetHRow(int nIndex)
{
    Assert(nIndex >= 0);
    Assert(nIndex <= m_hrowArray.GetSize());

    if (nIndex < 0 || 
        nIndex >= m_hrowArray.GetSize())
    {
        return NULL;
    }

    return m_hrowArray.GetAt(nIndex);
}

/*!--------------------------------------------------------------------------
	CHRowIndex::GetIndex
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
int
CHRowIndex::GetIndex(HROW hrow)
{
    Assert(hrow != 0);

    LPHROW phrow = (LPHROW) BSearch((const void *)&hrow, 
                                    (const void *)m_hrowArray.GetData(), 
                                    (size_t) m_hrowArray.GetSize(), 
                                    (size_t) sizeof(HROW));

    int nIndex = (int) (phrow - (LPHROW) m_hrowArray.GetData());
    Assert(nIndex >= 0);
    Assert(nIndex <= m_hrowArray.GetSize());

    int nComp, nIndexTemp;
    
    nComp = BCompare(&hrow, phrow);
    if (nComp == 0)
    {
        // found the right one, check the previous one to return the first 
        // record in a list of duplicates
        nIndexTemp = nIndex;

        while (nIndexTemp && nComp == 0)
        {
            *phrow = (HROW) m_hrowArray.GetAt(--nIndexTemp);
            nComp = BCompare(&hrow, phrow);
        }

        if (nIndexTemp == nIndex)
			return nIndex; // nIndex should be zero here as well
		else
			if (nComp == 0)
				return nIndexTemp; // nIndexTemp should be 0 in this case
			else
				return nIndexTemp++;
    }

    return -1;
}

/*!--------------------------------------------------------------------------
	CHRowIndex::Add
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CHRowIndex::Add(HROW hrow, BOOL bEnd)
{
    // if we are loading the array then just stick this on the end
    if (bEnd)
    {
        m_hrowArray.Add(hrow);
    }
    else
    {
        if (m_hrowArray.GetSize() == 0)
        {
            m_hrowArray.Add(hrow);
        }
        else
        {
            LPHROW phrow = (LPHROW) BSearch((const void *)&hrow, 
                                            (const void *)m_hrowArray.GetData(), 
                                            (size_t) m_hrowArray.GetSize(), 
                                            (size_t) sizeof(HROW));
    
            int nIndex = (int) (phrow - (LPHROW) m_hrowArray.GetData());
            Assert(nIndex >= 0);
            Assert(nIndex <= m_hrowArray.GetSize());
    
			int nComp;

			if (m_bAscending)
				nComp = BCompare(&hrow, phrow);
			else
				nComp = BCompareD(&hrow, phrow);

            if (nComp < 0)
            {
			    // Insert before phrow
				m_hrowArray.InsertAt(nIndex, hrow);
            }
            else
            {
                // insert after phrow
                m_hrowArray.InsertAt(nIndex + 1, hrow);
            }
        }
    }

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CHRowIndex::Remove
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CHRowIndex::Remove(HROW hrow)
{
    // do a bsearch for the record and then remove
    LPHROW phrow = (LPHROW) BSearch((const void*)&hrow, 
                                    (const void*)m_hrowArray.GetData(), 
                                    (size_t)m_hrowArray.GetSize(), 
                                    (size_t)sizeof(HROW));
	
	// make sure the record is in the database, may not be if we aren't
	// filtering
	if (phrow)
	{
		int nComp = BCompare(&hrow, phrow);
		Assert(nComp == 0);
		if (nComp != 0)
			return E_FAIL;

		// calculate the index
		int nIndex = (int) (phrow - (LPHROW) m_hrowArray.GetData());
		Assert(nIndex >= 0);
		Assert(nIndex <= m_hrowArray.GetSize());

		m_hrowArray.RemoveAt((int) nIndex);
	}

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CHRowIndex::BSearch
		Modified bsearch which returns the closest or equal element in
        an array
	Author: EricDav
 ---------------------------------------------------------------------------*/
void * 
CHRowIndex::BSearch (const void *key,
                     const void *base,
                     size_t num,
                     size_t width)
{
        char *lo = (char *)base;
        char *hi = (char *)base + (num - 1) * width;
        char *mid = NULL;
        unsigned int half = 0;
        int result = 0;

        while (lo <= hi)
                if (half = num / 2)
                {
                        mid = lo + (num & 1 ? half : (half - 1)) * width;

						if (m_bAscending)
						{
							if (!(result = BCompare(key,mid)))
                                return(mid);

							else if (result < 0)
							{
									hi = mid - width;
									num = num & 1 ? half : half-1;
							}
							else    
							{
									lo = mid + width;
									num = half;
							}
						}
						else
						{
							if (!(result = BCompareD(key,mid)))
                                return(mid);
							
							else if (result < 0)
							{
									hi = mid - width;
									num = num & 1 ? half : half-1;
							}
							else    
							{
									lo = mid + width;
									num = half;
							}

						}
                       
                }
                else if (num)
                        return(lo);
                else
                        break;

        return(mid);
}






/*!--------------------------------------------------------------------------
    Class CIndexMgr
 ---------------------------------------------------------------------------*/

CIndexMgr::CIndexMgr()
{
    m_posCurrentIndex = NULL;
	m_posFilteredIndex = NULL;
	m_posLastIndex = NULL;
	m_posUpdatedIndex = NULL;
	m_bFiltered = FALSE;
}

CIndexMgr::~CIndexMgr()
{
    Reset();
}
	
/*!--------------------------------------------------------------------------
	CIndexMgr::Initialize
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CIndexMgr::Initialize()
{
    HRESULT hr = hrOK;

    CSingleLock cl(&m_cs);
    cl.Lock();

    COM_PROTECT_TRY
    {
        // cleanup
        Reset();

        // Create one index, the named index
        CIndexName * pName = new CIndexName();
    
        m_posCurrentIndex = m_listIndicies.AddTail((CHRowIndex *) pName);
		m_posUpdatedIndex = m_posCurrentIndex;

		// this will be the current index, we need the Named Index also
		// for the total count
		CFilteredIndexName *pFilteredName = new CFilteredIndexName() ;
		m_posFilteredIndex = m_listFilteredIndices.AddTail((CHRowIndex *) pFilteredName);

    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
	CIndexMgr::Reset
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CIndexMgr::Reset()
{
    CSingleLock cl(&m_cs);
    cl.Lock();

    while (m_listIndicies.GetCount() > 0)
    {
        delete m_listIndicies.RemoveHead();
	}
	while(m_listFilteredIndices.GetCount() > 0 )
	{
		delete m_listFilteredIndices.RemoveHead();
	}
        
    return hrOK;
}

/*!--------------------------------------------------------------------------
	CIndexMgr::GetTotalCount
        The index sorted by name contains the total database and should
        always be available. Use this for the total count.
	Author: EricDav
 ---------------------------------------------------------------------------*/
UINT
CIndexMgr::GetTotalCount()
{
    CSingleLock cl(&m_cs);
    cl.Lock();

    CHRowIndex * pIndex = GetNameIndex();
    if (pIndex == NULL)
        return 0;

    return (UINT)pIndex->GetArray().GetSize();
}

/*!--------------------------------------------------------------------------
	CIndexMgr::GetCurrentCount
        The current count may differ depending upon if the current Index
        is a filtered index.
	Author: EricDav
 ---------------------------------------------------------------------------*/
UINT
CIndexMgr::GetCurrentCount()
{
    CSingleLock cl(&m_cs);
    cl.Lock();

	CHRowIndex * pIndex ;

    if (!m_bFiltered)
		pIndex = m_listIndicies.GetAt(m_posUpdatedIndex);
    else
        pIndex = m_listFilteredIndices.GetAt(m_posUpdatedIndex);

    if (pIndex == NULL)
        return 0;

    return (UINT)pIndex->GetArray().GetSize();
}

/*!--------------------------------------------------------------------------
	CIndexMgr::AddHRow
        -
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CIndexMgr::AddHRow(HROW hrow, BOOL bEnd, BOOL bFilterChecked)
{
    CSingleLock cl(&m_cs);
    cl.Lock();

	INDEX_TYPE indexType;

    HRESULT hr = hrOK;
    POSITION pos = m_listIndicies.GetHeadPosition();
    
    COM_PROTECT_TRY
    {
        while (pos)
        {
            CHRowIndex * pIndex = m_listIndicies.GetNext(pos);

			// check the INDEX type of the HRowIndex,
			// if filtered, need to add, depending on
			// whether the filter holds good

			pIndex->GetType(&indexType);
        
			if (indexType != INDEX_TYPE_FILTER)
				pIndex->Add(hrow, bEnd);
		}

		pos = m_listFilteredIndices.GetHeadPosition();

		while(pos)
		{
			CHRowIndex * pIndex = m_listFilteredIndices.GetNext(pos);

		 	pIndex->GetType(&indexType);
        
			if (indexType != INDEX_TYPE_FILTER)
				break;

			BOOL bCheck = bFilterChecked ? 
                             TRUE :
                             ((CFilteredIndexName*)pIndex)->CheckForFilter(&hrow);
			if (bCheck)
				pIndex->Add(hrow, bEnd);
		}

    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
	CIndexMgr::AcceptHRow
		-
	Author: FlorinT
 ---------------------------------------------------------------------------*/
BOOL    
CIndexMgr::AcceptWinsRecord(WinsRecord *pWinsRecord)
{
    CSingleLock cl(&m_cs);
    cl.Lock();

    POSITION    pos = m_listFilteredIndices.GetHeadPosition();

	while(pos)
	{
		CHRowIndex  *pIndex = m_listFilteredIndices.GetNext(pos);
        INDEX_TYPE  indexType;

		pIndex->GetType(&indexType);
		if (indexType != INDEX_TYPE_FILTER)
			break;

		if (((CFilteredIndexName*)pIndex)->CheckWinsRecordForFilter(pWinsRecord))
            return TRUE;
	}

    return FALSE;
}

/*!--------------------------------------------------------------------------
	CIndexMgr::RemoveHRow
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CIndexMgr::RemoveHRow(HROW hrow)
{
    CSingleLock cl(&m_cs);
    cl.Lock();

    HRESULT hr = hrOK;
    POSITION pos = m_listIndicies.GetHeadPosition();
    
    COM_PROTECT_TRY
    {
        // remove from the normal list
        while (pos)
        {
            CHRowIndex * pIndex = m_listIndicies.GetNext(pos);
        
            pIndex->Remove(hrow);
        }

        // now remove from the filtered list
        pos = m_listFilteredIndices.GetHeadPosition();
        while (pos)
        {
            CHRowIndex * pIndex = m_listFilteredIndices.GetNext(pos);
        
            pIndex->Remove(hrow);
        }

    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
	CIndexMgr::Sort
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CIndexMgr::Sort(WINSDB_SORT_TYPE SortType, DWORD dwSortOptions)
{
    CSingleLock cl(&m_cs);
    cl.Lock();

    HRESULT hr = hrOK;
    CHRowIndex * pNameIndex;
    CHRowIndex * pNewIndex;
    POSITION pos;
    INDEX_TYPE indexType;
    BOOL bAscending = (dwSortOptions & WINSDB_SORT_ASCENDING) ? TRUE : FALSE;

	if (!m_bFiltered)
	{
		// check to see if we have an index for this.
		pos = m_listIndicies.GetHeadPosition();
		while (pos)
		{
			POSITION posTemp = pos;
			CHRowIndex * pIndex = m_listIndicies.GetNext(pos);
    
			pIndex->GetType(&indexType);

			if (indexType == SortType)
			{
				if (pIndex->IsAscending() != bAscending)
				{
					pIndex->SetAscending(bAscending);
					pIndex->Sort();
				}

				m_posCurrentIndex = posTemp;
				m_posUpdatedIndex = m_posCurrentIndex;
//				m_posLastIndex = m_posCurrentIndex;
				return hrOK;
			}
		
		}
	}
    
    // to save memory, remove all old indicies, except the name index
    CleanupIndicies();

    COM_PROTECT_TRY
    {
        // if not, create one
        switch (SortType)
        {
            case INDEX_TYPE_NAME:
                pNewIndex = new CIndexName();
                break;

            case INDEX_TYPE_IP:
                pNewIndex = new CIndexIpAddr();
                break;

            case INDEX_TYPE_VERSION:
                pNewIndex = new CIndexVersion();
                break;

            case INDEX_TYPE_TYPE:
                pNewIndex = new CIndexType();
                break;

            case INDEX_TYPE_EXPIRATION:
                pNewIndex = new CIndexExpiration();
                break;

            case INDEX_TYPE_STATE:
                pNewIndex = new CIndexState();
                break;

            case INDEX_TYPE_STATIC:
                pNewIndex = new CIndexStatic();
                break;

            case INDEX_TYPE_OWNER:
                pNewIndex = new CIndexOwner();
                break;

            case INDEX_TYPE_FILTER:
                //pNewIndex = new CIndexFilter();
                break;

            default:
                Panic1("Invalid sort type passed to IndexMgr::Sort %d\n", SortType);
                break;
        }
    }
    COM_PROTECT_CATCH

    if (FHrSucceeded(hr))
    {
        Assert(pNewIndex);

	    if (!m_bFiltered)
		    pNameIndex = GetNameIndex();
	    else
		    pNameIndex = GetFilteredNameIndex();

        Assert(pNameIndex);

        COM_PROTECT_TRY
        {
            // copy the array from the named index
            pNewIndex->SetArray(pNameIndex->GetArray());
        }
        COM_PROTECT_CATCH
    }

    if (FHrSucceeded(hr))
    {
        pNewIndex->SetAscending(bAscending);
        pNewIndex->Sort();

	    if (!m_bFiltered)
	    {
		    m_posCurrentIndex = m_listIndicies.AddTail(pNewIndex);
		    m_posUpdatedIndex = m_posCurrentIndex;
	    }
	    else
	    {
		    POSITION posTemp = m_posFilteredIndex = m_listFilteredIndices.AddTail(pNewIndex);
		    m_posUpdatedIndex = posTemp;// m_posFilteredIndex;
	    }

        Assert(m_posCurrentIndex);
    }

    if (!FHrSucceeded(hr))
    {
        if (pNewIndex != NULL)
            delete pNewIndex;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
	CIndexMgr::GetNameIndex
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
CHRowIndex *
CIndexMgr::GetNameIndex()
{
    CSingleLock cl(&m_cs);
    cl.Lock();

    INDEX_TYPE  indexType;

    POSITION pos = m_listIndicies.GetHeadPosition();
    while (pos)
    {
        CHRowIndex * pIndex = m_listIndicies.GetNext(pos);
    
        pIndex->GetType(&indexType);
        if (indexType == INDEX_TYPE_NAME)
            return pIndex;
    }
    return NULL;
}

/*!--------------------------------------------------------------------------
	CIndexMgr::GetFilteredNameIndex
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
CHRowIndex *
CIndexMgr::GetFilteredNameIndex()
{
    CSingleLock cl(&m_cs);
    cl.Lock();

    INDEX_TYPE  indexType;

    POSITION pos = m_listFilteredIndices.GetHeadPosition();
    while (pos)
    {
        CHRowIndex * pIndex = m_listFilteredIndices.GetNext(pos);
    
        pIndex->GetType(&indexType);
        if (indexType == INDEX_TYPE_FILTER)
            return pIndex;
    }
    return NULL;
}


/*!--------------------------------------------------------------------------
	CIndexMgr::CleanupIndicies
		Removes all indicies except the name index, and a filtered view
	Author: EricDav
 ---------------------------------------------------------------------------*/
void
CIndexMgr::CleanupIndicies()
{
    CSingleLock cl(&m_cs);
    cl.Lock();

    INDEX_TYPE  indexType;

    // clean up the non-filtered indicies
    POSITION pos = m_listIndicies.GetHeadPosition();
    while (pos)
    {
        POSITION posLast = pos;
        CHRowIndex * pIndex = m_listIndicies.GetNext(pos);
    
        pIndex->GetType(&indexType);
        if (indexType == INDEX_TYPE_NAME || 
            indexType == INDEX_TYPE_FILTER)
            continue;

        m_listIndicies.RemoveAt(posLast);
        delete pIndex;
    }

    // now clean up the filtered indicies
    pos = m_listFilteredIndices.GetHeadPosition();

	// delete all except the first one which is the filetered
	// name index
	//CHRowIndex * pIndex = m_listFilteredIndices.GetNext(pos);
	while (pos)
	{
		POSITION posLast = pos;
        CHRowIndex * pIndex = m_listFilteredIndices.GetNext(pos);
    
        pIndex->GetType(&indexType);
        if (indexType == INDEX_TYPE_NAME || 
            indexType == INDEX_TYPE_FILTER)
            continue;

        m_listFilteredIndices.RemoveAt(posLast);
        delete pIndex;
	}
}

/*!--------------------------------------------------------------------------
	CIndexMgr::GetHRow
		Returns an hrow based on an index into the current sorted list
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CIndexMgr::GetHRow(int nIndex, LPHROW phrow)
{
    CSingleLock cl(&m_cs);
    cl.Lock();

    Assert(m_posCurrentIndex != NULL);

    //CHRowIndex * pIndex = m_listIndicies.GetAt(m_posCurrentIndex);

	CHRowIndex * pIndex;
	
	if (!m_bFiltered)
		pIndex = m_listIndicies.GetAt(m_posUpdatedIndex);
	else
		pIndex = m_listFilteredIndices.GetAt(m_posFilteredIndex);

    Assert(pIndex);

    if (phrow)
        *phrow = pIndex->GetHRow(nIndex);

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CIndexMgr::GetIndex
		Returns the index of an hrow from the current sorted list
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CIndexMgr::GetIndex(HROW hrow, int * pIndex)
{
    CSingleLock cl(&m_cs);
    cl.Lock();

    Assert(m_posCurrentIndex != NULL);

    //CHRowIndex * pCurrentIndex = m_listIndicies.GetAt(m_posCurrentIndex);

	CHRowIndex * pCurrentIndex;

	if (!m_bFiltered)
		pCurrentIndex = m_listIndicies.GetAt(m_posUpdatedIndex);
	else
		pCurrentIndex = m_listFilteredIndices.GetAt(m_posFilteredIndex);

    Assert(pCurrentIndex);

    if (pIndex)
        *pIndex = pCurrentIndex->GetIndex(hrow);

    return hrOK;
}

HRESULT
CIndexMgr::Filter(WINSDB_FILTER_TYPE FilterType, DWORD dwParam1, DWORD dwParam2)
{
	CSingleLock cl(&m_cs);
	cl.Lock();

	HRESULT hr = hrOK;
	CHRowIndex*		pNameIndex;
	CHRowIndex*		pNewIndex;
	POSITION		pos;
	INDEX_TYPE		indexType;
	UINT			uCount;
	UINT			i;
	BOOL			bCheck = FALSE;
	HROW			hrow;
	HRowArray		hrowArray;

	pNewIndex = GetFilteredNameIndex();
	Assert(pNewIndex);

	// clear the filtered name index first.
	pNewIndex->SetArray(hrowArray);

	pNameIndex = GetNameIndex();
	Assert(pNameIndex);

	// do the filtering here.
	uCount = GetTotalCount();

	for(i = 0; i< uCount; i++)
	{
		hrow =	pNameIndex->GetHRow(i);

		if (hrow)
			bCheck = ((CFilteredIndexName *)pNewIndex)->CheckForFilter(&hrow);
		
		if (bCheck)
			pNewIndex->Add(hrow, TRUE);
	}

	// check to see if the filtered view has been sorted on something else besides
	// the name.  If so, switch back the index to the named index because 
	// otherwise we will need to resort which can be time consuming...
	if (m_listFilteredIndices.GetAt(m_posFilteredIndex) != pNewIndex)
	{
		m_posFilteredIndex = m_listFilteredIndices.Find(pNewIndex);
	}

	// get the current position of the filtered index in the list of indices
    m_posUpdatedIndex = m_posFilteredIndex;

	Assert(m_posUpdatedIndex);

	m_bFiltered = TRUE;
	
	return hr;
}

HRESULT 
CIndexMgr::AddFilter(WINSDB_FILTER_TYPE FilterType, DWORD dwParam1, DWORD dwParam2, LPCOLESTR strParam3)
{
	CSingleLock cl(&m_cs);
	cl.Lock();

	HRESULT hr = hrOK;

	CFilteredIndexName *pFilterName = (CFilteredIndexName *)GetFilteredNameIndex();
	pFilterName->AddFilter(FilterType, dwParam1, dwParam2, strParam3);
	m_bFiltered = TRUE;
	
	return hr;
}

HRESULT 
CIndexMgr::ClearFilter(WINSDB_FILTER_TYPE FilterType)
{
	CSingleLock cl(&m_cs);
	cl.Lock();

	HRESULT hr = hrOK;

	CFilteredIndexName *pFilterName = (CFilteredIndexName *)GetFilteredNameIndex();
	pFilterName->ClearFilter(FilterType);
	m_bFiltered = FALSE;
//	m_posCurrentIndex = m_posLastIndex;

	return hr;
}

HRESULT 
CIndexMgr::SetActiveView(WINSDB_VIEW_TYPE ViewType)
{
	CSingleLock cl(&m_cs);
	cl.Lock();

	HRESULT hr = hrOK;

	switch(ViewType)
	{
	
	case WINSDB_VIEW_FILTERED_DATABASE:
		m_bFiltered = TRUE;
		//m_posCurrentIndex = m_posFilteredIndex;
		m_posUpdatedIndex = m_posFilteredIndex;
		break;
	
	case WINSDB_VIEW_ENTIRE_DATABASE:
		m_bFiltered = FALSE;
		//m_posCurrentIndex = m_posLastIndex;
		m_posUpdatedIndex = m_posCurrentIndex;
		break;
	
	default:
		break;
	}

	return hr;
}

/*!--------------------------------------------------------------------------
    Class CIndexName
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	CIndexName::BCompare
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
int
CIndexName::BCompare(const void * elem1, const void * elem2)
{
    LPHROW phrow1 = (LPHROW) elem1;
    LPHROW phrow2 = (LPHROW) elem2;

    LPWINSDBRECORD pRec1 = (LPWINSDBRECORD) *phrow1;
    LPWINSDBRECORD pRec2 = (LPWINSDBRECORD) *phrow2;

    LPCSTR puChar1 = (IS_DBREC_LONGNAME(pRec1)) ? (LPCSTR) *((char **) pRec1->szRecordName) :
                                                        (LPCSTR) &pRec1->szRecordName[0];
    LPCSTR puChar2 = (IS_DBREC_LONGNAME(pRec2)) ? (LPCSTR) *((char **) pRec2->szRecordName) :
                                                        (LPCSTR) &pRec2->szRecordName[0];
    return lstrcmpOEM(puChar1, puChar2);
}

int
CIndexName::BCompareD(const void *elem1, const void *elem2)
{
	return -BCompare(elem1, elem2);
}

/*!--------------------------------------------------------------------------
	CIndexName::Sort
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CIndexName::Sort()
{
    if (m_bAscending)
        qsort(m_hrowArray.GetData(), (size_t)m_hrowArray.GetSize(), sizeof(HROW), QCompareA);
    else
        qsort(m_hrowArray.GetData(), (size_t)m_hrowArray.GetSize(), sizeof(HROW), QCompareD);

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CIndexName::QCompare
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
int __cdecl
CIndexName::QCompareA(const void * elem1, const void * elem2)
{
	LPHROW phrow1 = (LPHROW) elem1;
    LPHROW phrow2 = (LPHROW) elem2;
    
    LPWINSDBRECORD pRec1 = (LPWINSDBRECORD) *phrow1;
    LPWINSDBRECORD pRec2 = (LPWINSDBRECORD) *phrow2;
    
    LPCSTR puChar1 = (IS_DBREC_LONGNAME(pRec1)) ? (LPCSTR) *((char **) pRec1->szRecordName) :
                                                        (LPCSTR) &pRec1->szRecordName[0];
    LPCSTR puChar2 = (IS_DBREC_LONGNAME(pRec2)) ? (LPCSTR) *((char **) pRec2->szRecordName) :
                                                        (LPCSTR) &pRec2->szRecordName[0];
    return lstrcmpOEM(puChar1, puChar2);
}

int __cdecl
CIndexName::QCompareD(const void * elem1, const void * elem2)
{
    return -QCompareA(elem1, elem2);
}

/*!--------------------------------------------------------------------------
    Class CIndexType
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	CIndexType::BCompare
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
int
CIndexType::BCompare(const void * elem1, const void * elem2)
{
    LPHROW phrow1 = (LPHROW) elem1;
    LPHROW phrow2 = (LPHROW) elem2;
    
    LPWINSDBRECORD pRec1 = (LPWINSDBRECORD) *phrow1;
    LPWINSDBRECORD pRec2 = (LPWINSDBRECORD) *phrow2;
    
    LPCSTR puChar1 = (IS_DBREC_LONGNAME(pRec1)) ? (LPCSTR) *((char **) pRec1->szRecordName) :
                                                        (LPCSTR) &pRec1->szRecordName[0];
    LPCSTR puChar2 = (IS_DBREC_LONGNAME(pRec2)) ? (LPCSTR) *((char **) pRec2->szRecordName) :
                                                        (LPCSTR) &pRec2->szRecordName[0];

    if ((unsigned char) puChar1[15] > (unsigned char) puChar2[15])
        return 1;
    else
    if ((unsigned char) puChar1[15] < (unsigned char) puChar2[15])
        return -1;
    else 
        return lstrcmpOEM(puChar1, puChar2);
}

int
CIndexType::BCompareD(const void *elem1, const void *elem2)
{
	return -BCompare(elem1, elem2);
}


/*!--------------------------------------------------------------------------
	CIndexType::Sort
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CIndexType::Sort()
{
    if (m_bAscending)
        qsort(m_hrowArray.GetData(), (size_t)m_hrowArray.GetSize(), sizeof(HROW), QCompareA);
    else
        qsort(m_hrowArray.GetData(), (size_t)m_hrowArray.GetSize(), sizeof(HROW), QCompareD);

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CIndexType::QCompare
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
int __cdecl
CIndexType::QCompareA(const void * elem1, const void * elem2)
{
    LPHROW phrow1 = (LPHROW) elem1;
    LPHROW phrow2 = (LPHROW) elem2;
    
    LPWINSDBRECORD pRec1 = (LPWINSDBRECORD) *phrow1;
    LPWINSDBRECORD pRec2 = (LPWINSDBRECORD) *phrow2;
    
    LPCSTR puChar1 = (IS_DBREC_LONGNAME(pRec1)) ? (LPCSTR) *((char **) pRec1->szRecordName) :
                                                        (LPCSTR) &pRec1->szRecordName[0];
    LPCSTR puChar2 = (IS_DBREC_LONGNAME(pRec2)) ? (LPCSTR) *((char **) pRec2->szRecordName) :
                                                        (LPCSTR) &pRec2->szRecordName[0];

    DWORD dwAddr1, dwAddr2;
    
    if (pRec1->szRecordName[18] & WINSDB_REC_MULT_ADDRS)
    {
        // if this record has multiple addresses, we want the 2nd
        // address, because the 1st address is always the WINS server
        // first dword is the count.
        LPDWORD pdwIpAddrs = (LPDWORD) pRec1->dwIpAdd;
        dwAddr1 = pdwIpAddrs[2];
    }
    else
    {
        dwAddr1 = (DWORD) pRec1->dwIpAdd;
    }
    
    if (pRec2->szRecordName[18] & WINSDB_REC_MULT_ADDRS)
    {
        // if this record has multiple addresses, we want the 2nd
        // address, because the 1st address is always the WINS server
        // first dword is the count.
        LPDWORD pdwIpAddrs = (LPDWORD) pRec2->dwIpAdd;
        dwAddr2 = pdwIpAddrs[2];
    }
    else
    {
        dwAddr2 = (DWORD) pRec2->dwIpAdd;
    }

    // check the types first.  If they are the same, sort by IP address.  
    // if for some reason the IP addresses are the same then sort by name.                                                    
    if ((unsigned char) puChar1[15] > (unsigned char) puChar2[15])
        return 1;
    else
    if ((unsigned char) puChar1[15] < (unsigned char) puChar2[15])
        return -1;
    else 
    if (dwAddr1 > dwAddr2)
            return 1;
    else
    if (dwAddr1 < dwAddr2)
            return -1;
    else
        return lstrcmpOEM(puChar1, puChar2);
}

int __cdecl
CIndexType::QCompareD(const void * elem1, const void * elem2)
{
    return -QCompareA(elem1, elem2);
}

/*!--------------------------------------------------------------------------
    Class CIndexIpAddr
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	CIndexIpAddr::BCompare
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
int
CIndexIpAddr::BCompare(const void * elem1, const void * elem2)
{
    LPHROW phrow1 = (LPHROW) elem1;
    LPHROW phrow2 = (LPHROW) elem2;
    
    LPWINSDBRECORD pRec1 = (LPWINSDBRECORD) *phrow1;
    LPWINSDBRECORD pRec2 = (LPWINSDBRECORD) *phrow2;
    
    DWORD dwAddr1, dwAddr2;
    
    if (pRec1->szRecordName[18] & WINSDB_REC_MULT_ADDRS)
    {
        // if this record has multiple addresses, we want the 2nd
        // address, because the 1st address is always the WINS server
        // first dword is the count.
        LPDWORD pdwIpAddrs = (LPDWORD) pRec1->dwIpAdd;
        dwAddr1 = pdwIpAddrs[2];
    }
    else
    {
        dwAddr1 = (DWORD) pRec1->dwIpAdd;
    }
    
    if (pRec2->szRecordName[18] & WINSDB_REC_MULT_ADDRS)
    {
        // if this record has multiple addresses, we want the 2nd
        // address, because the 1st address is always the WINS server
        // first dword is the count.
        LPDWORD pdwIpAddrs = (LPDWORD) pRec2->dwIpAdd;
        dwAddr2 = pdwIpAddrs[2];
    }
    else
    {
        dwAddr2 = (DWORD) pRec2->dwIpAdd;
    }

    if (dwAddr1 > dwAddr2)
            return 1;
    else
    if (dwAddr1 < dwAddr2)
            return -1;
    else 
    {
        // if the addresses are the same, compare types, then names
        LPCSTR puChar1 = (IS_DBREC_LONGNAME(pRec1)) ? (LPCSTR) *((char **) pRec1->szRecordName) :
                                                            (LPCSTR) &pRec1->szRecordName[0];
        LPCSTR puChar2 = (IS_DBREC_LONGNAME(pRec2)) ? (LPCSTR) *((char **) pRec2->szRecordName) :
                                                            (LPCSTR) &pRec2->szRecordName[0];

        if ((unsigned char) puChar1[15] > (unsigned char) puChar2[15])
            return 1;
        else
        if ((unsigned char) puChar1[15] < (unsigned char) puChar2[15])
            return -1;
        else 
            return lstrcmpOEM(puChar1, puChar2);
    }
}

int
CIndexIpAddr::BCompareD(const void *elem1, const void *elem2)
{
	return -BCompare(elem1, elem2);
}


/*!--------------------------------------------------------------------------
	CIndexIpAddr::Sort
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CIndexIpAddr::Sort()
{
    if (m_bAscending)
        qsort(m_hrowArray.GetData(), (size_t)m_hrowArray.GetSize(), sizeof(HROW), QCompareA);
    else
        qsort(m_hrowArray.GetData(), (size_t)m_hrowArray.GetSize(), sizeof(HROW), QCompareD);

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CIndexIpAddr::QCompare
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
int __cdecl
CIndexIpAddr::QCompareA(const void * elem1, const void * elem2)
{
    LPHROW phrow1 = (LPHROW) elem1;
    LPHROW phrow2 = (LPHROW) elem2;
    
    LPWINSDBRECORD pRec1 = (LPWINSDBRECORD) *phrow1;
    LPWINSDBRECORD pRec2 = (LPWINSDBRECORD) *phrow2;
    
    DWORD dwAddr1, dwAddr2;
    
    if (pRec1->szRecordName[18] & WINSDB_REC_MULT_ADDRS)
    {
        // if this record has multiple addresses, we want the 2nd
        // address, because the 1st address is always the WINS server
        // first dword is the count.
        LPDWORD pdwIpAddrs = (LPDWORD) pRec1->dwIpAdd;
        dwAddr1 = pdwIpAddrs[2];
    }
    else
    {
        dwAddr1 = (DWORD) pRec1->dwIpAdd;
    }
    
    if (pRec2->szRecordName[18] & WINSDB_REC_MULT_ADDRS)
    {
        // if this record has multiple addresses, we want the 2nd
        // address, because the 1st address is always the WINS server
        // first dword is the count.
        LPDWORD pdwIpAddrs = (LPDWORD) pRec2->dwIpAdd;
        dwAddr2 = pdwIpAddrs[2];
    }
    else
    {
        dwAddr2 = (DWORD) pRec2->dwIpAdd;
    }

    if (dwAddr1 > dwAddr2)
            return 1;
    else
    if (dwAddr1 < dwAddr2)
            return -1;
    else 
    {
        // if the addresses are the same, compare types, then names
        LPCSTR puChar1 = (IS_DBREC_LONGNAME(pRec1)) ? (LPCSTR) *((char **) pRec1->szRecordName) :
                                                            (LPCSTR) &pRec1->szRecordName[0];
        LPCSTR puChar2 = (IS_DBREC_LONGNAME(pRec2)) ? (LPCSTR) *((char **) pRec2->szRecordName) :
                                                            (LPCSTR) &pRec2->szRecordName[0];

        if ((unsigned char) puChar1[15] > (unsigned char) puChar2[15])
            return 1;
        else
        if ((unsigned char) puChar1[15] < (unsigned char) puChar2[15])
            return -1;
        else 
            return lstrcmpOEM(puChar1, puChar2);
    }
}

int __cdecl
CIndexIpAddr::QCompareD(const void * elem1, const void * elem2)
{
    return -QCompareA(elem1, elem2);
}

/*!--------------------------------------------------------------------------
    Class CIndexVersion
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	CIndexVersion::BCompare
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
int
CIndexVersion::BCompare(const void * elem1, const void * elem2)
{
    LPHROW phrow1 = (LPHROW) elem1;
    LPHROW phrow2 = (LPHROW) elem2;
    
    LPWINSDBRECORD pRec1 = (LPWINSDBRECORD) *phrow1;
    LPWINSDBRECORD pRec2 = (LPWINSDBRECORD) *phrow2;
    
    if (pRec1->liVersion.QuadPart > pRec2->liVersion.QuadPart)
            return 1;
    else
    if (pRec1->liVersion.QuadPart < pRec2->liVersion.QuadPart)
            return -1;
    else 
        return 0;
}

int
CIndexVersion::BCompareD(const void *elem1, const void *elem2)
{
	return -BCompare(elem1, elem2);
}


/*!--------------------------------------------------------------------------
	CIndexVersion::Sort
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CIndexVersion::Sort()
{
	if (m_bAscending)
        qsort(m_hrowArray.GetData(), (size_t)m_hrowArray.GetSize(), sizeof(HROW), QCompareA);
    else
        qsort(m_hrowArray.GetData(), (size_t)m_hrowArray.GetSize(), sizeof(HROW), QCompareD);

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CIndexVersion::QCompare
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
int __cdecl
CIndexVersion::QCompareA(const void * elem1, const void * elem2)
{
    LPHROW phrow1 = (LPHROW) elem1;
    LPHROW phrow2 = (LPHROW) elem2;
    
    LPWINSDBRECORD pRec1 = (LPWINSDBRECORD) *phrow1;
    LPWINSDBRECORD pRec2 = (LPWINSDBRECORD) *phrow2;
    
    if (pRec1->liVersion.QuadPart > pRec2->liVersion.QuadPart)
            return 1;
    else
    if (pRec1->liVersion.QuadPart < pRec2->liVersion.QuadPart)
            return -1;
    else 
        return 0;
}

int __cdecl
CIndexVersion::QCompareD(const void * elem1, const void * elem2)
{
    return -QCompareA(elem1, elem2);
}

/*!--------------------------------------------------------------------------
    Class CIndexExpiration
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	CIndexExpiration::BCompare
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
int
CIndexExpiration::BCompare(const void * elem1, const void * elem2)
{
    LPHROW phrow1 = (LPHROW) elem1;
    LPHROW phrow2 = (LPHROW) elem2;
    
    LPWINSDBRECORD pRec1 = (LPWINSDBRECORD) *phrow1;
    LPWINSDBRECORD pRec2 = (LPWINSDBRECORD) *phrow2;
    
    if (pRec1->dwExpiration > pRec2->dwExpiration)
            return 1;
    else
    if (pRec1->dwExpiration < pRec2->dwExpiration)
            return -1;
    else 
        return 0;
}

int
CIndexExpiration::BCompareD(const void *elem1, const void *elem2)
{
	return -BCompare(elem1, elem2);
}


/*!--------------------------------------------------------------------------
	CIndexExpiration::Sort
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CIndexExpiration::Sort()
{
	if (m_bAscending)
        qsort(m_hrowArray.GetData(), (size_t)m_hrowArray.GetSize(), sizeof(HROW), QCompareA);
    else
        qsort(m_hrowArray.GetData(), (size_t)m_hrowArray.GetSize(), sizeof(HROW), QCompareD);

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CIndexExpiration::QCompare
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
int __cdecl
CIndexExpiration::QCompareA(const void * elem1, const void * elem2)
{
    LPHROW phrow1 = (LPHROW) elem1;
    LPHROW phrow2 = (LPHROW) elem2;
    
    LPWINSDBRECORD pRec1 = (LPWINSDBRECORD) *phrow1;
    LPWINSDBRECORD pRec2 = (LPWINSDBRECORD) *phrow2;
    
    if (pRec1->dwExpiration > pRec2->dwExpiration)
            return 1;
    else
    if (pRec1->dwExpiration < pRec2->dwExpiration)
            return -1;
    else 
        return 0;
}

int __cdecl
CIndexExpiration::QCompareD(const void * elem1, const void * elem2)
{
    return -QCompareA(elem1, elem2);
}

/*!--------------------------------------------------------------------------
    Class CIndexState
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	CIndexState::BCompare
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
int
CIndexState::BCompare(const void * elem1, const void * elem2)
{
    LPHROW phrow1 = (LPHROW) elem1;
    LPHROW phrow2 = (LPHROW) elem2;
    
    LPWINSDBRECORD pRec1 = (LPWINSDBRECORD) *phrow1;
    LPWINSDBRECORD pRec2 = (LPWINSDBRECORD) *phrow2;
    
    int nPri1 = 0, nPri2 = 0;
    
    // calculate relative priorities
    if (pRec1->szRecordName[18] & WINSDB_REC_ACTIVE)
        nPri1 = 0;
    else
    if (pRec1->szRecordName[18] & WINSDB_REC_RELEASED)
        nPri1 = 1;
    else
    if (pRec1->szRecordName[18] & WINSDB_REC_TOMBSTONE)
        nPri1 = 2;
    else
    if (pRec1->szRecordName[18] & WINSDB_REC_DELETED)
        nPri1 = 3;

    // now for record 2
    if (pRec2->szRecordName[18] & WINSDB_REC_ACTIVE)
        nPri2 = 0;
    else
    if (pRec2->szRecordName[18] & WINSDB_REC_RELEASED)
        nPri2 = 1;
    else
    if (pRec2->szRecordName[18] & WINSDB_REC_TOMBSTONE)
        nPri2 = 2;
    else
    if (pRec2->szRecordName[18] & WINSDB_REC_DELETED)
        nPri2 = 3;
    
    if (nPri1 > nPri2)
        return 1;
    else
    if (nPri1 < nPri2)
        return -1;
    else 
    {
        LPCSTR puChar1 = (IS_DBREC_LONGNAME(pRec1)) ? (LPCSTR) *((char **) pRec1->szRecordName) :
                                                            (LPCSTR) &pRec1->szRecordName[0];
        LPCSTR puChar2 = (IS_DBREC_LONGNAME(pRec2)) ? (LPCSTR) *((char **) pRec2->szRecordName) :
                                                            (LPCSTR) &pRec2->szRecordName[0];
        return lstrcmpOEM(puChar1, puChar2);
    }
}

int
CIndexState::BCompareD(const void *elem1, const void *elem2)
{
	return -BCompare(elem1, elem2);
}


/*!--------------------------------------------------------------------------
	CIndexState::Sort
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CIndexState::Sort()
{
	if (m_bAscending)
        qsort(m_hrowArray.GetData(), (size_t)m_hrowArray.GetSize(), sizeof(HROW), QCompareA);
    else
        qsort(m_hrowArray.GetData(), (size_t)m_hrowArray.GetSize(), sizeof(HROW), QCompareD);

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CIndexState::QCompare
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
int __cdecl
CIndexState::QCompareA(const void * elem1, const void * elem2)
{
    LPHROW phrow1 = (LPHROW) elem1;
    LPHROW phrow2 = (LPHROW) elem2;
    
    LPWINSDBRECORD pRec1 = (LPWINSDBRECORD) *phrow1;
    LPWINSDBRECORD pRec2 = (LPWINSDBRECORD) *phrow2;
    
    int nPri1 = 0, nPri2 = 0;
    
    // calculate relative priorities
    if (pRec1->szRecordName[18] & WINSDB_REC_ACTIVE)
        nPri1 = 0;
    else
    if (pRec1->szRecordName[18] & WINSDB_REC_RELEASED)
        nPri1 = 1;
    else
    if (pRec1->szRecordName[18] & WINSDB_REC_TOMBSTONE)
        nPri1 = 2;
    else
    if (pRec1->szRecordName[18] & WINSDB_REC_DELETED)
        nPri1 = 3;

    // now for record 2
    if (pRec2->szRecordName[18] & WINSDB_REC_ACTIVE)
        nPri2 = 0;
    else
    if (pRec2->szRecordName[18] & WINSDB_REC_RELEASED)
        nPri2 = 1;
    else
    if (pRec2->szRecordName[18] & WINSDB_REC_TOMBSTONE)
        nPri2 = 2;
    else
    if (pRec2->szRecordName[18] & WINSDB_REC_DELETED)
        nPri2 = 3;
    
    if (nPri1 > nPri2)
        return 1;
    else
    if (nPri1 < nPri2)
        return -1;
    else 
    {
        LPCSTR puChar1 = (IS_DBREC_LONGNAME(pRec1)) ? (LPCSTR) *((char **) pRec1->szRecordName) :
                                                            (LPCSTR) &pRec1->szRecordName[0];
        LPCSTR puChar2 = (IS_DBREC_LONGNAME(pRec2)) ? (LPCSTR) *((char **) pRec2->szRecordName) :
                                                            (LPCSTR) &pRec2->szRecordName[0];
        return lstrcmpOEM(puChar1, puChar2);
    }
}

int __cdecl
CIndexState::QCompareD(const void * elem1, const void * elem2)
{
    return -QCompareA(elem1, elem2);
}

/*!--------------------------------------------------------------------------
    Class CIndexStatic
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	CIndexStatic::BCompare
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
int
CIndexStatic::BCompare(const void * elem1, const void * elem2)
{
    LPHROW phrow1 = (LPHROW) elem1;
    LPHROW phrow2 = (LPHROW) elem2;
    
    LPWINSDBRECORD pRec1 = (LPWINSDBRECORD) *phrow1;
    LPWINSDBRECORD pRec2 = (LPWINSDBRECORD) *phrow2;
    
    BOOL bStatic1 = pRec1->szRecordName[18] & LOBYTE(LOWORD(WINSDB_REC_STATIC));
    BOOL bStatic2 = pRec2->szRecordName[18] & LOBYTE(LOWORD(WINSDB_REC_STATIC));

    if (bStatic1 && !bStatic2)
        return 1;
    else
    if (!bStatic1 && bStatic2)
        return -1;
    else
    {
        LPCSTR puChar1 = (IS_DBREC_LONGNAME(pRec1)) ? (LPCSTR) *((char **) pRec1->szRecordName) :
                                                            (LPCSTR) &pRec1->szRecordName[0];
        LPCSTR puChar2 = (IS_DBREC_LONGNAME(pRec2)) ? (LPCSTR) *((char **) pRec2->szRecordName) :
                                                            (LPCSTR) &pRec2->szRecordName[0];
        return lstrcmpOEM(puChar1, puChar2);
    }
}

int
CIndexStatic::BCompareD(const void *elem1, const void *elem2)
{
	return -BCompare(elem1, elem2);
}


/*!--------------------------------------------------------------------------
	CIndexStatic::Sort
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CIndexStatic::Sort()
{
	if (m_bAscending)
        qsort(m_hrowArray.GetData(), (size_t)m_hrowArray.GetSize(), sizeof(HROW), QCompareA);
    else
        qsort(m_hrowArray.GetData(), (size_t)m_hrowArray.GetSize(), sizeof(HROW), QCompareD);

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CIndexStatic::QCompare
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
int __cdecl
CIndexStatic::QCompareA(const void * elem1, const void * elem2)
{
    LPHROW phrow1 = (LPHROW) elem1;
    LPHROW phrow2 = (LPHROW) elem2;
    
    LPWINSDBRECORD pRec1 = (LPWINSDBRECORD) *phrow1;
    LPWINSDBRECORD pRec2 = (LPWINSDBRECORD) *phrow2;
    
    BOOL bStatic1 = pRec1->szRecordName[18] & LOBYTE(LOWORD(WINSDB_REC_STATIC));
    BOOL bStatic2 = pRec2->szRecordName[18] & LOBYTE(LOWORD(WINSDB_REC_STATIC));

    if (bStatic1 && !bStatic2)
        return 1;
    else
    if (!bStatic1 && bStatic2)
        return -1;
    else
    {
        LPCSTR puChar1 = (IS_DBREC_LONGNAME(pRec1)) ? (LPCSTR) *((char **) pRec1->szRecordName) :
                                                            (LPCSTR) &pRec1->szRecordName[0];
        LPCSTR puChar2 = (IS_DBREC_LONGNAME(pRec2)) ? (LPCSTR) *((char **) pRec2->szRecordName) :
                                                            (LPCSTR) &pRec2->szRecordName[0];
        return lstrcmpOEM(puChar1, puChar2);
    }
}

int __cdecl
CIndexStatic::QCompareD(const void * elem1, const void * elem2)
{
    return -QCompareA(elem1, elem2);
}


/*!--------------------------------------------------------------------------
    Class CIndexOwner
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	CIndexOwner::BCompare
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
int
CIndexOwner::BCompare(const void * elem1, const void * elem2)
{
    LPHROW phrow1 = (LPHROW) elem1;
    LPHROW phrow2 = (LPHROW) elem2;
    
    LPWINSDBRECORD pRec1 = (LPWINSDBRECORD) *phrow1;
    LPWINSDBRECORD pRec2 = (LPWINSDBRECORD) *phrow2;
    
	if (pRec1->dwOwner > pRec2->dwOwner)
	{
		return 1;
	}
	else
	if (pRec1->dwOwner < pRec2->dwOwner)
	{
		return -1;
	}
	else
    {
        // if the addresses are the same, compare names
        LPCSTR puChar1 = (IS_DBREC_LONGNAME(pRec1)) ? (LPCSTR) *((char **) pRec1->szRecordName) :
                                                            (LPCSTR) &pRec1->szRecordName[0];
        LPCSTR puChar2 = (IS_DBREC_LONGNAME(pRec2)) ? (LPCSTR) *((char **) pRec2->szRecordName) :
                                                            (LPCSTR) &pRec2->szRecordName[0];
        return lstrcmpOEM(puChar1, puChar2);
    }
}

int
CIndexOwner::BCompareD(const void *elem1, const void *elem2)
{
	return -BCompare(elem1, elem2);
}


/*!--------------------------------------------------------------------------
	CIndexStatic::Sort
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CIndexOwner::Sort()
{
	if (m_bAscending)
        qsort(m_hrowArray.GetData(), (size_t)m_hrowArray.GetSize(), sizeof(HROW), QCompareA);
    else
        qsort(m_hrowArray.GetData(), (size_t)m_hrowArray.GetSize(), sizeof(HROW), QCompareD);

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CIndexStatic::QCompare
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
int __cdecl
CIndexOwner::QCompareA(const void * elem1, const void * elem2)
{
    LPHROW phrow1 = (LPHROW) elem1;
    LPHROW phrow2 = (LPHROW) elem2;
    
    LPWINSDBRECORD pRec1 = (LPWINSDBRECORD) *phrow1;
    LPWINSDBRECORD pRec2 = (LPWINSDBRECORD) *phrow2;
    
	if (pRec1->dwOwner > pRec2->dwOwner)
	{
		return 1;
	}
	else
	if (pRec1->dwOwner < pRec2->dwOwner)
	{
		return -1;
	}
	else
    {
        // if the addresses are the same, compare names
        LPCSTR puChar1 = (IS_DBREC_LONGNAME(pRec1)) ? (LPCSTR) *((char **) pRec1->szRecordName) :
                                                            (LPCSTR) &pRec1->szRecordName[0];
        LPCSTR puChar2 = (IS_DBREC_LONGNAME(pRec2)) ? (LPCSTR) *((char **) pRec2->szRecordName) :
                                                            (LPCSTR) &pRec2->szRecordName[0];
        return lstrcmpOEM(puChar1, puChar2);
    }
}

int __cdecl
CIndexOwner::QCompareD(const void * elem1, const void * elem2)
{
    return -QCompareA(elem1, elem2);
}


HRESULT CFilteredIndexName::AddFilter(WINSDB_FILTER_TYPE FilterType, DWORD dwData1, DWORD dwData2, LPCOLESTR strData3)
{
	HRESULT         hr = hrOK;
    tIpReference    ipRef;

	switch (FilterType)
	{
		case WINSDB_FILTER_BY_TYPE:
			m_mapFilterTypes.SetAt(dwData1, (BOOL&) dwData2);
			break;

		case WINSDB_FILTER_BY_OWNER:
			m_dwaFilteredOwners.Add(dwData1);
			break;

        case WINSDB_FILTER_BY_IPADDR:
            ipRef.Address = dwData1;
            ipRef.Mask = dwData2;
            m_taFilteredIp.Add(ipRef);
            break;

        case WINSDB_FILTER_BY_NAME:
            UINT nData3Len;

            nData3Len = (_tcslen(strData3)+1)*sizeof(TCHAR);
            m_pchFilteredName = new char[nData3Len];
            if (m_pchFilteredName != NULL)
            {
#ifdef _UNICODE
                if (WideCharToMultiByte(CP_OEMCP,
                                        0,
                                        strData3,
                                        -1,
                                        m_pchFilteredName,
                                        nData3Len,
                                        NULL,
                                        NULL) == 0)
                {
                    delete m_pchFilteredName;
                    m_pchFilteredName = NULL;
                }
           
#else
                CharToOem(strData3, m_pchFilteredName);
#endif
                //m_pchFilteredName = _strupr(m_pchFilteredName);
                m_bMatchCase = dwData1;
            }
            break;

		default:
			Panic0("Invalid filter type passed to CFilteredIndexName::AddFilter");
			break;
	}

	return hr;
}

BOOL CFilteredIndexName::CheckForFilter(LPHROW hrowCheck)
{
    UINT nCountOwner    = (UINT)m_dwaFilteredOwners.GetSize();
	UINT nCountType     = m_mapFilterTypes.GetHashTableSize();
    UINT nCountIPAddrs  = (UINT)m_taFilteredIp.GetSize();
	BOOL bOwnerFilter   = (nCountOwner == 0);
    BOOL bTypeFilter    = (nCountType == 0);
    BOOL bIPAddrsFilter = (nCountIPAddrs == 0);
    BOOL bNameFilter    = (m_pchFilteredName == NULL);
	LPWINSDBRECORD pRec = (LPWINSDBRECORD) *hrowCheck;
    UINT i, j;
    LPCSTR puChar;

	for (i = 0; !bOwnerFilter && i < nCountOwner; i++)
	{
		if (pRec->dwOwner == m_dwaFilteredOwners.GetAt(i))
			bOwnerFilter = TRUE;
	}

    if (!bOwnerFilter)
        return FALSE;

    puChar = (IS_DBREC_LONGNAME(pRec)) ?
                (LPCSTR) *((char **) pRec->szRecordName) :
                (LPCSTR) &pRec->szRecordName[0];

    if (!bTypeFilter)
    {
        DWORD dwType = puChar[0xF];

	    if (!m_mapFilterTypes.Lookup(dwType, bTypeFilter))
	    {
		    // no entry for this name type.  Check the FFFF name type (other) to see if we should
		    // show it.
		    dwType = 0xFFFF;
		    m_mapFilterTypes.Lookup(dwType, bTypeFilter);
	    }
    }
    
    if (!bTypeFilter)
        return FALSE;

    for (i = 0; !bIPAddrsFilter && i < nCountIPAddrs; i++)
    {
        if (pRec->szRecordName[18] & WINSDB_REC_MULT_ADDRS)
        {
            LPDWORD pdwIpAddrs = (LPDWORD) pRec->dwIpAdd;

            for (j=0; !bIPAddrsFilter && j < pdwIpAddrs[0]; j+=2)
            {
                bIPAddrsFilter = SubnetMatching(m_taFilteredIp[i], pdwIpAddrs[j+2]);
            }
        }
        else
        {
            bIPAddrsFilter = SubnetMatching(m_taFilteredIp[i], (DWORD)pRec->dwIpAdd);
        }
    }
    if(!bIPAddrsFilter)
        return FALSE;

    if (!bNameFilter)
    {
        bNameFilter = (PatternMatching(puChar, m_pchFilteredName, 16) == NULL);
    }

    return bNameFilter;
}

BOOL CFilteredIndexName::CheckWinsRecordForFilter(WinsRecord *pWinsRecord)
{
    UINT nCountOwner    = (UINT)m_dwaFilteredOwners.GetSize();
	UINT nCountType     = m_mapFilterTypes.GetHashTableSize();
    UINT nCountIPAddrs  = (UINT)m_taFilteredIp.GetSize();
	BOOL bOwnerFilter   = (nCountOwner == 0);
    BOOL bTypeFilter    = (nCountType == 0);
    BOOL bIPAddrsFilter = (nCountIPAddrs == 0);
    BOOL bNameFilter    = (m_pchFilteredName == NULL);
    UINT i, j;

    //-------------------------------------
    // check the owner filter first, if any
	for (i = 0; !bOwnerFilter && i < nCountOwner; i++)
	{
		if (pWinsRecord->dwOwner == m_dwaFilteredOwners.GetAt(i))
			bOwnerFilter = TRUE;
	}
    if (!bOwnerFilter)
        return FALSE;

    //-------------------------------------
    // check the type filter if any
    if (!bTypeFilter)
    {
        DWORD dwType;
        // keep in mind the name's type is in the lowest 16 bits of pWinsRecord->dwType
        // (see WinsIntfToWinsRecord())
        dwType = pWinsRecord->dwType & 0x0000ffff;
	    if (!m_mapFilterTypes.Lookup(dwType, bTypeFilter))
	    {
		    // no entry for this name type.  Check the FFFF name type (other) to see if we should
		    // show it.
            dwType = 0xFFFF;
		    m_mapFilterTypes.Lookup(dwType, bTypeFilter);
	    }
    }
    if (!bTypeFilter)
        return FALSE;

    //-------------------------------------
    // check the IP address filter if any
    for (i = 0; !bIPAddrsFilter && i < nCountIPAddrs; i++)
    {
        if (pWinsRecord->dwState & WINSDB_REC_MULT_ADDRS)
        {
            for (j=0; !bIPAddrsFilter && j < pWinsRecord->dwNoOfAddrs; j++)
            {
                bIPAddrsFilter = SubnetMatching(m_taFilteredIp[i], pWinsRecord->dwIpAdd[j]);
            }
        }
        else
        {
            bIPAddrsFilter = SubnetMatching(m_taFilteredIp[i], pWinsRecord->dwIpAdd[0]);
        }
    }
    if(!bIPAddrsFilter)
        return FALSE;

    //-------------------------------------
    // check the name filter if any
    if (!bNameFilter)
    {
        bNameFilter = (PatternMatching(pWinsRecord->szRecordName, m_pchFilteredName, 16) == NULL);
    }

    return bNameFilter;
}

LPCSTR CFilteredIndexName::PatternMatching(LPCSTR pName, LPCSTR pPattern, INT nNameLen)
{
    LPCSTR pNameBak = pName;

    // it is guaranteed here we have a valid (not NULL) pattern
    while (*pPattern != '\0' && pName-pNameBak < nNameLen)
    {
        BOOL bChMatch = (*pPattern == *pName);
        if (!m_bMatchCase && !bChMatch)
        {
            bChMatch = (islower(*pPattern) && _toupper(*pPattern) == *pName) || 
                       (islower(*pName) && *pPattern == _toupper(*pName));
        }

        if (*pPattern == '?' || bChMatch)
        {
            pPattern++;
        }
        else if (*pPattern == '*')
        {
            LPCSTR pTrail = pName;
            INT    nTrailLen = nNameLen-(UINT)(pTrail-pNameBak);

            pPattern++;
            while ((pName = PatternMatching(pTrail, pPattern, nTrailLen)) != NULL)
            {
                pTrail++;
                nTrailLen--;
                if (*pTrail == '\0' || nTrailLen <= 0)
                    break;
            }

            return pName;
        }
        else if (!bChMatch)
        {
            // in the test above, note that even in the unikely case *pName == '\0'
            // *pName will not match *pPattern so the loop is still broken - which is
            // the desired behavior. In this case the pattern was not consummed 
            // and the name was, so the return will indicate the matching failed
            break;
        }

        pName++;
    }

    return *pPattern == '\0' ? NULL : pName;
}

BOOL CFilteredIndexName::SubnetMatching(tIpReference &IpRefPattern, DWORD dwIPAddress)
{
    DWORD dwMask;

    return (IpRefPattern.Address & IpRefPattern.Mask) == (dwIPAddress & IpRefPattern.Mask);
}

HRESULT CFilteredIndexName::ClearFilter(WINSDB_FILTER_TYPE FilterType)
{
	HRESULT hr = hrOK;

	switch(FilterType)
	{
		case WINSDB_FILTER_BY_TYPE:
			m_mapFilterTypes.RemoveAll();
			break;

		case WINSDB_FILTER_BY_OWNER:
			m_dwaFilteredOwners.RemoveAll();
			break;

        case WINSDB_FILTER_BY_IPADDR:
            m_taFilteredIp.RemoveAll();
            break;

        case WINSDB_FILTER_BY_NAME:
            if (m_pchFilteredName != NULL)
            {
                delete m_pchFilteredName;
                m_pchFilteredName = NULL;
            }
            break;
		
		default:
			Panic0("Invalid filter type passed to CFilteredIndexName::ClearFilter");
			break;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\harray.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	harray.h
		Index mgr for wins db

	FILE HISTORY:
    Oct 13  1997    EricDav     Created        

*/

#ifndef _HARRAY_H
#define _HARRAY_H

#include "afxmt.h"

class CVerifyWins ;

typedef enum _INDEX_TYPE
{
    INDEX_TYPE_NAME,
    INDEX_TYPE_IP,
    INDEX_TYPE_VERSION,
    INDEX_TYPE_TYPE,
    INDEX_TYPE_EXPIRATION,
    INDEX_TYPE_STATE,
    INDEX_TYPE_STATIC,
	INDEX_TYPE_OWNER,
    INDEX_TYPE_FILTER

} INDEX_TYPE;

class CHRowIndex;

typedef CArray<HROW, HROW>			    HRowArray;
typedef CList<CHRowIndex *, CHRowIndex *> HRowArrayList;

// base class for a sorted index
class CHRowIndex 
{
public:
    CHRowIndex(INDEX_TYPE IndexType);
	virtual ~CHRowIndex();

public:
    // used for insertion into the list
    virtual int     BCompare(const void *, const void *) = 0;
	virtual int     BCompareD(const void *, const void *) = 0;
    virtual HRESULT Sort() = 0;
    
    virtual HRESULT Add(HROW hrow, BOOL bEnd);
    virtual HRESULT Remove(HROW hrow);
    virtual HRESULT GetType(INDEX_TYPE * pIndexType);
    virtual HROW    GetHRow(int nIndex);
    virtual int     GetIndex(HROW hrow);
    
    BOOL    IsAscending() { return m_bAscending; }
    void    SetAscending(BOOL bAscending) { m_bAscending = bAscending; }

    HRESULT SetArray(HRowArray & hrowArray);
    HRowArray & GetArray() { return m_hrowArray; }
	
	void SetType(INDEX_TYPE indexType)
	{
		m_dbType = indexType;
	}

    void * BSearch(const void * key, const void * base, size_t num, size_t width);

	
protected:
    INDEX_TYPE          m_dbType;
    HRowArray           m_hrowArray;
    BOOL                m_bAscending;
};


// the Index manager
class CIndexMgr : public HRowArrayList
{
public:
	CIndexMgr();
	virtual ~CIndexMgr();

public:
    HRESULT Initialize();
    HRESULT Reset();

    UINT    GetTotalCount();
    UINT    GetCurrentCount();
    BOOL    AcceptWinsRecord(WinsRecord *pWinsRecord);

    HRESULT AddHRow(HROW hrow, BOOL bLoading = FALSE, BOOL bFilterChecked = FALSE);
    HRESULT RemoveHRow(HROW hrow);
    HRESULT Sort(WINSDB_SORT_TYPE SortType, DWORD dwSortOptions);
	HRESULT Filter(WINSDB_FILTER_TYPE FilterType, DWORD dwParam1, DWORD dwParam2);
	HRESULT AddFilter(WINSDB_FILTER_TYPE FilterType, DWORD dwParam1, DWORD dwParam2, LPCOLESTR strParam3);
	HRESULT ClearFilter(WINSDB_FILTER_TYPE FilterType);
	HRESULT SetActiveView(WINSDB_VIEW_TYPE ViewType);

    HRESULT GetHRow(int nIndex, LPHROW phrow);
    HRESULT GetIndex(HROW hrow, int * pIndex);

    CHRowIndex * GetNameIndex();
	CHRowIndex * GetFilteredNameIndex();
    void CleanupIndicies();

	
protected:
    HRowArrayList				m_listIndicies;
	POSITION					m_posCurrentIndex;
	POSITION					m_posFilteredIndex;
	POSITION					m_posLastIndex;
	// points to either Filtered index or the index depending on whether the 
	// view is filtered or not
	POSITION					m_posUpdatedIndex;
    CCriticalSection			m_cs;
	HRowArrayList				m_listFilteredIndices;
	BOOL						m_bFiltered;
	
};

// Index for name sorted
class CIndexName : public CHRowIndex
{
public:
    CIndexName() : CHRowIndex(INDEX_TYPE_NAME) { };

public:
    // used for insertion into the list
    int     BCompare(const void *, const void *);
	int		BCompareD(const void *, const void *);
    
    // used for sorting the list
    virtual HRESULT Sort();
    static int __cdecl QCompareA(const void *, const void *);
    static int __cdecl QCompareD(const void *, const void *);
};

// Index for type sorted
class CIndexType : public CHRowIndex
{
public:
    CIndexType() : CHRowIndex(INDEX_TYPE_TYPE) { };

public:
    // used for insertion into the list
    int     BCompare(const void *, const void *);
	int		BCompareD(const void *, const void *);
    
    // used for sorting the list
    virtual HRESULT Sort();
    static int __cdecl QCompareA(const void *, const void *);
    static int __cdecl QCompareD(const void *, const void *);
};

// Index for IP address sorted
class CIndexIpAddr : public CHRowIndex
{
public:
    CIndexIpAddr() : CHRowIndex(INDEX_TYPE_IP) { };

public:
    // used for insertion into the list
    int     BCompare(const void *, const void *);
	int		BCompareD(const void *, const void *);
    
    // used for sorting the list
    virtual HRESULT Sort();
    static int __cdecl QCompareA(const void *, const void *);
    static int __cdecl QCompareD(const void *, const void *);
};

// Index for Expiration sorted
class CIndexExpiration : public CHRowIndex
{
public:
    CIndexExpiration() : CHRowIndex(INDEX_TYPE_EXPIRATION) { };

public:
    // used for insertion into the list
    int     BCompare(const void *, const void *);
	int		BCompareD(const void *, const void *);
    
    // used for sorting the list
    virtual HRESULT Sort();
    static int __cdecl QCompareA(const void *, const void *);
    static int __cdecl QCompareD(const void *, const void *);
};

// Index for version sorted
class CIndexVersion : public CHRowIndex
{
public:
    CIndexVersion() : CHRowIndex(INDEX_TYPE_VERSION) { };

public:
    // used for insertion into the list
    int     BCompare(const void *, const void *);
	int		BCompareD(const void *, const void *);
    
    // used for sorting the list
    virtual HRESULT Sort();
    static int __cdecl QCompareA(const void *, const void *);
    static int __cdecl QCompareD(const void *, const void *);
};

// Index for version sorted
class CIndexState : public CHRowIndex
{
public:
    CIndexState() : CHRowIndex(INDEX_TYPE_STATE) { };

public:
    // used for insertion into the list
    int     BCompare(const void *, const void *);
	int		BCompareD(const void *, const void *);
    
    // used for sorting the list
    virtual HRESULT Sort();
    static int __cdecl QCompareA(const void *, const void *);
    static int __cdecl QCompareD(const void *, const void *);
};

// Index for version sorted
class CIndexStatic : public CHRowIndex
{
public:
    CIndexStatic() : CHRowIndex(INDEX_TYPE_STATIC) { };

public:
    // used for insertion into the list
    int     BCompare(const void *, const void *);
	int		BCompareD(const void *, const void *);
    
    // used for sorting the list
    virtual HRESULT Sort();
    static int __cdecl QCompareA(const void *, const void *);
    static int __cdecl QCompareD(const void *, const void *);
};

// Index for Owner sorted
class CIndexOwner : public CHRowIndex
{
public:
    CIndexOwner() : CHRowIndex(INDEX_TYPE_OWNER) { };

public:
    // used for insertion into the list
    int     BCompare(const void *, const void *);
	int		BCompareD(const void *, const void *);
    
    // used for sorting the list
    virtual HRESULT Sort();
    static int __cdecl QCompareA(const void *, const void *);
    static int __cdecl QCompareD(const void *, const void *);
};

typedef CMap<DWORD, DWORD&, BOOL, BOOL&> CFilterTypeMap;

typedef struct
{
    DWORD   Mask;
    DWORD   Address;
} tIpReference;

// Filtered Index for name sorted
class CFilteredIndexName : public CIndexName
{
    // returns the pointer to the pName where the matching failed
    // or NULL if the matching succeeded.
    LPCSTR PatternMatching(LPCSTR pName, LPCSTR pPattern, INT nNameLen);
    BOOL   SubnetMatching(tIpReference &IpRefPattern, DWORD dwIPAddress);

public:
    CFilteredIndexName()
	{
		SetType(INDEX_TYPE_FILTER);
        m_pchFilteredName = NULL;
	};
    ~CFilteredIndexName()
    {
        if (m_pchFilteredName != NULL)
            delete m_pchFilteredName;
    }

public:
	HRESULT AddFilter(WINSDB_FILTER_TYPE FilterType, DWORD dwData1, DWORD dwData2, LPCOLESTR strData3);
	HRESULT ClearFilter(WINSDB_FILTER_TYPE FilterType);
	BOOL CheckForFilter(LPHROW hrowCheck);
    BOOL CheckWinsRecordForFilter(WinsRecord *pWinsRecord);


	CFilterTypeMap			            m_mapFilterTypes;
	CDWordArray				            m_dwaFilteredOwners;
    CArray <tIpReference, tIpReference> m_taFilteredIp;
    LPSTR                               m_pchFilteredName;
    BOOL                                m_bMatchCase;
};


#endif //_HARRAY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\ipaddres.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1995 - 1998 **/
/**********************************************************************/

/*
    ipaddres.h
        Ip address control

    FILE HISTORY:

*/

#ifndef _IPADDRES_H
#define _IPADDRES_H

//
// IP Address Conversion Macros
//
/*
#ifndef MAKEIPADDRESS
  #define MAKEIPADDRESS(b1,b2,b3,b4) ((LONG)(((DWORD)(b1)<<24)+((DWORD)(b2)<<16)+((DWORD)(b3)<<8)+((DWORD)(b4))))

  #define GETIP_FIRST(x)             ((x>>24) & 0xff)
  #define GETIP_SECOND(x)            ((x>>16) & 0xff)
  #define GETIP_THIRD(x)             ((x>> 8) & 0xff)
  #define GETIP_FOURTH(x)            ((x)     & 0xff)
#endif // MAKEIPADDRESS*/

/////////////////////////////////////////////////////////////////////////////
// CIpAddress class

class CIpAddress : public CObjectPlus
{
public:
    // Constructors
    CIpAddress()
    {
        m_lIpAddress = 0L;
        m_fInitOk = FALSE;
    }
    CIpAddress (LONG l)
    {
        m_lIpAddress = l;
        m_fInitOk = TRUE;
    }
    CIpAddress (BYTE b1, BYTE b2, BYTE b3, BYTE b4)
    {
        m_lIpAddress = (LONG) MAKEIPADDRESS(b1,b2,b3,b4);
        m_fInitOk = TRUE;
    }
    CIpAddress(const CIpAddress& ia)
    {
        m_lIpAddress = ia.m_lIpAddress;
        m_fInitOk = ia.m_fInitOk;
    }

    CIpAddress (const CString & str);

    //
    // Assignment operators
    //
    const CIpAddress & operator =(const LONG l);
    const CIpAddress & operator =(const CString & str);
    const CIpAddress & operator =(const CIpAddress& ia)
    {
        m_lIpAddress = ia.m_lIpAddress;
        m_fInitOk = ia.m_fInitOk;
        return *this;
    }

    //
    // Conversion operators
    //
    operator const LONG() const
    {
        return m_lIpAddress;
    }
    operator const CString&() const;

public:
    BOOL IsValid() const
    {
        return m_fInitOk;
    }

private:
    LONG m_lIpAddress;
    BOOL m_fInitOk;
};

#endif _IPADDRES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\helparr.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 -99             **/
/**********************************************************************/

/*
    helparr.h
        Comment goes here

    FILE HISTORY:

*/

#define	IDH_BUTTON_ADD	400000603
#define	IDH_BUTTON_ADD_TYPE	400000201
#define	IDH_BUTTON_ADD_WINS	400001056
#define	IDH_BUTTON_BROWSE	400000955
#define	IDH_BUTTON_BROWSE_COMPUTERS	400000401
#define IDH_BUTTON_DELETE_TYPE  400000861
#define	IDH_BUTTON_MODIFY_TYPE	400000202
#define	IDH_BUTTON_PULL_SET_DEFAULT	400000708
#define	IDH_BUTTON_PUSH_SET_DEFAULT	400000711
#define	IDH_BUTTON_REMOVE_WIINS	400001057
#define	IDH_BUTTON_REMOVE_WINS_REP	400000604
#define	IDH_BUTTON_SET_DEFAULT	400000912
#define IDH_BUTTON_SELECT_ALL  400000862
#define IDH_BUTTON_UNSELECT_ALL  400000863
#define	IDH_CHECK_BACKUPDB	400000956
#define	IDH_CHECK_BURST_HANDLING	400000852
#define	IDH_CHECK_ENABLE_AUTO_PARTNER_CONFIG	400000605
#define	IDH_CHECK_ENABLE_AUTOREFRESH	400000950
#define	IDH_CHECK_LANNAMES	400000859
#define	IDH_CHECK_LOGCHANGES	400000850
#define	IDH_CHECK_LOGEVENTS	400000851
#define	IDH_CHECK_MIGRATE	400000651
#define	IDH_CHECK_MIXED_CASE	400000001
#define	IDH_CHECK_PARTNERS	400000066
#define	IDH_CHECK_PERIODIC_CC	400000913
#define	IDH_CHECK_PULL_PERSIST	400000601
#define	IDH_CHECK_PULL_PERSIST_PROP	400000701
#define	IDH_CHECK_PUSH_ON_ADDRESS_CHANGE	400000661
#define	IDH_CHECK_PUSH_ON_STARTUP	400000660
#define	IDH_CHECK_PUSH_PERSIST	400000600
#define	IDH_CHECK_PUSH_PERSISTENCE	400000709
#define	IDH_CHECK_REP_WITH_PARTNERS	400000650
#define	IDH_CHECK_TRIGGER_PULL_STARTUP	400000652
#define	IDH_CHECK1_WINS	400001002
#define	IDH_CHECK2_WINS	400001003
#define	IDH_COMBO_NAME	400000000
#define	IDH_COMBO_TYPE	400000700
#define	IDH_COMBO_STATIC_TYPE	400000864
#define	IDH_EDIT_BACKUPPATH	400000954
#define	IDH_EDIT_CC_INTERVAL	400000917
#define	IDH_EDIT_CC_MAX_CHECKED	400000914
#define	IDH_EDIT_CC_START_HOUR	400000918
#define	IDH_EDIT_CC_START_MINUTE	400000919
#define	IDH_EDIT_CC_START_SECOND	400000920
#define	IDH_EDIT_COMPNAME	400001050
#define	IDH_EDIT_CUSTOM_VALUE	400000857
#define IDH_EDIT_DATABASE_PATH  400000860
#define	IDH_EDIT_DYN_REC_TYPE	400001052
#define	IDH_EDIT_EXPIRATION	400000154
#define	IDH_EDIT_EXTINCT_INT_DAY	400000903
#define	IDH_EDIT_EXTINCT_INT_HOUR	400000904
#define	IDH_EDIT_EXTINCT_INT_MINUTE	400000905
#define	IDH_EDIT_EXTINCT_TIMEOUT_DAY	400000906
#define	IDH_EDIT_EXTINCT_TIMEOUT_HOUR	400000907
#define	IDH_EDIT_EXTINCT_TIMEOUT_MINUTE	400000908
#define	IDH_EDIT_IPADDRESS	400000751
#define	IDH_EDIT_MESSAGE	400001200
#define	IDH_EDIT_MULTICAST_HOUR	400000606
#define	IDH_EDIT_MULTICAST_MINUTE	400000607
#define	IDH_EDIT_MULTICAST_SECOND	400000608
#define	IDH_EDIT_MULTICAST_TTL	400000609
#define	IDH_EDIT_NAME_CHECK	400000051
#define	IDH_EDIT_NAME_DYN	400000150
#define	IDH_EDIT_NAME_LIST	400000054
#define	IDH_EDIT_NAME_REP	400000750
#define	IDH_EDIT_NAME_TYPE_DESCRIPTION	400000451
#define	IDH_EDIT_NAME_TYPE_ID	400000450
#define	IDH_EDIT_NETBIOSNAME	400000350
#define	IDH_EDIT_OWNER	400000156
#define	IDH_EDIT_OWNER_STATIC	400001053
#define	IDH_EDIT_REFRESH_HOURS2	400000951
#define	IDH_EDIT_REFRESH_MINUTES2	400000952
#define	IDH_EDIT_REFRESH_SECONDS2	400000953
#define	IDH_EDIT_RENEW_DAY	400000900
#define	IDH_EDIT_RENEW_HOUR	400000901
#define	IDH_EDIT_RENEW_MINUTE	400000902
#define	IDH_EDIT_REP_DAY	400000705
#define	IDH_EDIT_REP_HOUR	400000706
#define	IDH_EDIT_REP_INT_DAY	400000656
#define	IDH_EDIT_REP_INT_HOUR	400000657
#define	IDH_EDIT_REP_INT_MINUTE	400000658
#define	IDH_EDIT_REP_MINUTE	400000707
#define	IDH_EDIT_RETRY_COUNT	400000659
#define	IDH_EDIT_SCOPE_NAME_WINS	400001051
#define	IDH_EDIT_SERVER	400000059
#define	IDH_EDIT_SERVER_NAME_IPADDRESS	400000400
#define	IDH_EDIT_START_HOUR	400000653
#define	IDH_EDIT_START_HOUR_PROP	400000702
#define	IDH_EDIT_START_MINUTE	400000654
#define	IDH_EDIT_START_MINUTE_PROP	400000703
#define	IDH_EDIT_START_SECOND	400000655
#define	IDH_EDIT_START_SECOND_PROP	400000704
#define	IDH_EDIT_START_VERSION	400000858
#define	IDH_EDIT_STATE	400000153
#define	IDH_EDIT_TYPE	400000151
#define	IDH_EDIT_UPDATE	400001150
#define	IDH_EDIT_UPDATE_COUNT	400000710
#define	IDH_EDIT_VERIFY_DAY	400000909
#define	IDH_EDIT_VERIFY_HOUR	400000910
#define	IDH_EDIT_VERIFY_MINUTE	400000911
#define	IDH_EDIT_VERSION	400000155
#define	IDH_IPA_IPADDRESS	400000300
#define	IDH_IPADD	400001054
#define	IDH_IPADDRESS	400000062
#define	IDH_LIST_ADDRESSES	400000152
#define	IDH_LIST_IPADD	400001055
#define	IDH_LIST_NAME	400000055
#define	IDH_LIST_OWNER	400000552
#define	IDH_LIST_OWNERS	400000602
#define	IDH_LIST_SERVER	400000063
#define	IDH_LIST1	400000200
#define	IDH_NAME_ADD	400000056
#define	IDH_NAME_BROWSE	400000052
#define	IDH_NAME_REMOVE	400000057
#define	IDH_RADIO_ALL_OWNERS	400000550
#define	IDH_RADIO_CHECK_OWNER	400000915
#define	IDH_RADIO_CHECK_RANDOM	400000916
#define	IDH_RADIO_CUSTOM	400000856
#define	IDH_RADIO_DELETE	400000100
#define	IDH_RADIO_DELETE_RECORDS	400000501
#define	IDH_RADIO_HIGH	400000855
#define	IDH_RADIO_LOW	400000853
#define	IDH_RADIO_MEDIUM	400000854
#define	IDH_RADIO_NAME_FILE	400000050
#define	IDH_RADIO_NAME_LIST	400000053
#define	IDH_RADIO_PUSH_ALL_PARTNERS	400000800
#define	IDH_RADIO_PUSH_THIS_PARTNER	400000801
#define	IDH_RADIO_SELCTED_OWNER	400000551
#define	IDH_RADIO_SERVER_FILE	400000058
#define	IDH_RADIO_SERVER_LIST	400000061
#define	IDH_RADIO_TOMBSTONE	400000101
#define	IDH_RADIO_TOMBSTONE_RECORDS	400000502
#define	IDH_RADIO1	400001000
#define	IDH_RADIO2	400001001
#define	IDH_SERVER_ADD	400000064
#define	IDH_SERVER_BROWSE	400000060
#define	IDH_SERVER_REMOVE	400000065
#define IDH_ENABLE_CACHING      400000766
#define IDH_BUTTON_LOCAL        400000767
#define IDH_CHECK_NAME          400000768
#define IDH_EDIT_NAME           400000769
#define IDH_CHECK_MATCHCASE     400000776
#define IDH_CHECK_IPADDR        400000770
#define IDH_IPADDRESS_FILTER    400000771
#define IDH_CHECK_IPMASK        400000772
#define IDH_SUBNETMASK          400000773
#define IDH_OKFIND              400000774
#define IDH_CANCELFIND          400000775

#define IDH_DISABLEHELP	((DWORD)-1)

const DWORD g_aHelpIDs_[]=
{
	0, 0
};


const DWORD g_aHelpIDs_IDD_ACTREG_FIND_RECORD[]=
{
	IDC_CHECK_MIXED_CASE, IDH_CHECK_MIXED_CASE,
	IDC_COMBO_NAME, IDH_COMBO_NAME,
	0,0
};

const DWORD g_aHelpIDs_IDD_CHECK_REG_NAMES[]=
{
	IDC_LIST_SERVER,IDH_LIST_SERVER,
	IDC_CHECK_PARTNERS,IDH_CHECK_PARTNERS,
	IDC_SERVER_ADD,IDH_SERVER_ADD,
	IDC_IPADDRESS,IDH_IPADDRESS,
	IDC_RADIO_SERVER_LIST,IDH_RADIO_SERVER_LIST,
	IDC_SERVER_BROWSE,IDH_SERVER_BROWSE,
	IDC_EDIT_SERVER,IDH_EDIT_SERVER,
	IDC_RADIO_SERVER_FILE,IDH_RADIO_SERVER_FILE,
	IDC_NAME_ADD,IDH_NAME_ADD,
	IDC_LIST_NAME,IDH_LIST_NAME,
	IDC_EDIT_NAME_LIST,IDH_EDIT_NAME_LIST,
	IDC_RADIO_NAME_LIST,IDH_RADIO_NAME_LIST,
	IDC_NAME_BROWSE,IDH_NAME_BROWSE,
	IDC_EDIT_NAME,IDH_EDIT_NAME_CHECK,
	IDC_RADIO_NAME_FILE,IDH_RADIO_NAME_FILE,
	IDC_NAME_REMOVE,IDH_NAME_REMOVE,
	IDC_SERVER_REMOVE,IDH_SERVER_REMOVE,
	0, 0
};

const DWORD g_aHelpIDs_IDD_DELTOMB_RECORD[]=
{
	IDC_RADIO_TOMBSTONE,IDH_RADIO_TOMBSTONE,
	IDC_RADIO_DELETE,IDH_RADIO_DELETE,
	IDC_STATIC_DELETE_DESC,IDH_DISABLEHELP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_DYN_PROPERTIES[]=
{
	IDC_EDIT_OWNER,IDH_EDIT_OWNER,
	IDC_EDIT_VERSION,IDH_EDIT_VERSION,
	IDC_EDIT_EXPIRATION,IDH_EDIT_EXPIRATION,
	IDC_EDIT_STATE,IDH_EDIT_STATE,
	IDC_LIST_ADDRESSES,IDH_LIST_ADDRESSES,
	IDC_EDIT_NAME,IDH_EDIT_NAME_DYN,
	IDC_EDIT_TYPE,IDH_EDIT_TYPE,
	IDC_STATIC_ICON,IDH_DISABLEHELP,
    IDC_STATIC_ICON_DESC,IDH_DISABLEHELP,
    0, 0
};

const DWORD g_aHelpIDs_IDD_FILTER_SELECT[]=
{
	IDC_LIST1,IDH_LIST1,
	IDC_BUTTON_ADD_TYPE,IDH_BUTTON_ADD_TYPE,
	IDC_BUTTON_MODIFY_TYPE,IDH_BUTTON_MODIFY_TYPE,
    IDC_BUTTON_DELETE_TYPE,IDH_BUTTON_DELETE_TYPE,
    IDC_BUTTON_SELECT_ALL,IDH_BUTTON_SELECT_ALL,
    IDC_BUTTON_UNSELECT_ALL,IDH_BUTTON_UNSELECT_ALL,
    IDC_ENABLE_CACHING, IDH_ENABLE_CACHING,
	0, 0
};

const DWORD g_aHelpIDs_IDD_FILTER_IPADDR[] =
{
    IDC_CHECK_NAME, IDH_CHECK_NAME,
    IDC_EDIT_NAME, IDH_EDIT_NAME,
    IDC_CHECK_MATCHCASE, IDH_CHECK_MATCHCASE,
    IDC_CHECK_IPADDR, IDH_CHECK_IPADDR,
    IDC_IPADDRESS, IDH_IPADDRESS_FILTER,
    IDC_CHECK_IPMASK, IDH_CHECK_IPMASK,
    IDC_SUBNETMASK, IDH_SUBNETMASK,
    IDC_ENABLE_CACHING, IDH_ENABLE_CACHING,
    0, 0
};

const DWORD g_aHelpIDs_IDD_GETIPADDRESS[] =
{
	IDC_IPA_IPADDRESS,IDH_IPA_IPADDRESS,
	0, 0
};

const DWORD g_aHelpIDs_IDD_GETNETBIOSNAME[]=
{
	IDC_EDIT_NETBIOSNAME,IDH_EDIT_NETBIOSNAME,
	0, 0
};

const DWORD g_aHelpIDs_IDD_IPADDRESS[]=
{
	IDC_EDIT_SERVER_NAME,IDH_EDIT_SERVER_NAME_IPADDRESS,
	IDC_BUTTON_BROWSE_COMPUTERS,IDH_BUTTON_BROWSE_COMPUTERS,
	IDC_STATIC_WINS_SERVER_DESC, IDH_DISABLEHELP,
    0, 0
};

const DWORD g_aHelpIDs_IDD_NAME_TYPE[]=
{
	IDC_EDIT_NAME_TYPE_ID,IDH_EDIT_NAME_TYPE_ID,
	IDC_EDIT_NAME_TYPE_DESCRIPTION,IDH_EDIT_NAME_TYPE_DESCRIPTION,
	0, 0
};

const DWORD g_aHelpIDs_IDD_OWNER_DELETE[]=
{
	IDC_LIST_OWNER, IDH_LIST_OWNER,
	IDC_RADIO_DELETE_RECORDS,IDH_RADIO_DELETE_RECORDS,
	IDC_RADIO_TOMBSTONE_RECORDS,IDH_RADIO_TOMBSTONE_RECORDS,
	0, 0
};

const DWORD g_aHelpIDs_IDD_OWNER_FILTER[]=
{
	IDC_LIST_OWNER, IDH_LIST_OWNER,
    IDC_BUTTON_SELECT_ALL, IDH_BUTTON_SELECT_ALL,
    IDC_BUTTON_UNSELECT_ALL, IDH_BUTTON_UNSELECT_ALL,
    IDC_BUTTON_LOCAL, IDH_BUTTON_LOCAL,
    IDC_ENABLE_CACHING, IDH_ENABLE_CACHING,
	0, 0
};

const DWORD g_aHelpIDs_IDD_REP_NODE_ADVANCED[]=
{
	IDC_CHECK_ENABLE_AUTO_PARTNER_CONFIG,IDH_CHECK_ENABLE_AUTO_PARTNER_CONFIG,
	IDC_EDIT_MULTICAST_TTL,IDH_EDIT_MULTICAST_TTL,
	IDC_SPIN_MULTICAST_TTL,IDH_EDIT_MULTICAST_TTL,
	IDC_EDIT_MULTICAST_HOUR,IDH_EDIT_MULTICAST_HOUR,
	IDC_SPIN_MULTICAST_HOUR,IDH_EDIT_MULTICAST_HOUR,
	IDC_EDIT_MULTICAST_MINUTE,IDH_EDIT_MULTICAST_MINUTE,
	IDC_SPIN_MULTICAST_MINUTE,IDH_EDIT_MULTICAST_MINUTE,
	IDC_EDIT_MULTICAST_SECOND,IDH_EDIT_MULTICAST_SECOND,
	IDC_SPIN_MULTICAST_SECOND,IDH_EDIT_MULTICAST_SECOND,
	IDC_BUTTON_ADD,IDH_BUTTON_ADD,
	IDC_LIST_OWNERS,IDH_LIST_OWNERS,
	IDC_BUTTON_REMOVE,IDH_BUTTON_REMOVE_WINS_REP,
	IDC_STATIC_DESP,IDH_DISABLEHELP,
	IDC_STATIC_MUTICASTINT,IDH_DISABLEHELP,
	IDC_STATIC_MULTICAST_TTL,IDH_DISABLEHELP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_REP_NODE_GENERAL[]=
{
	IDC_CHECK_MIGRATE,IDH_CHECK_MIGRATE,
	IDC_CHECK_REP_WITH_PARTNERS,IDH_CHECK_REP_WITH_PARTNERS,
	IDC_STATIC_ICON,IDH_DISABLEHELP,
    IDC_STATIC_ICON_DESC,IDH_DISABLEHELP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_REP_NODE_PUSH[]=
{
	IDC_CHECK_PUSH_ON_ADDRESS_CHANGE,IDH_CHECK_PUSH_ON_ADDRESS_CHANGE,
	IDC_CHECK_PUSH_ON_STARTUP,IDH_CHECK_PUSH_ON_STARTUP,
	IDC_EDIT_UPDATE_COUNT, IDH_EDIT_UPDATE_COUNT,
	IDC_SPIN_UPDATE_COUNT, IDH_EDIT_UPDATE_COUNT,
	IDC_CHECK_PUSH_PERSIST,IDH_CHECK_PUSH_PERSIST,
	0, 0
};

const DWORD g_aHelpIDs_IDD_REP_NODE_PULL[]=
{
	IDC_EDIT_RETRY_COUNT,IDH_EDIT_RETRY_COUNT,
	IDC_SPIN_RETRY_COUNT,IDH_EDIT_RETRY_COUNT,
	IDC_EDIT_REP_INT_HOUR,IDH_EDIT_REP_INT_HOUR,
	IDC_EDIT_REP_INT_MINUTE,IDH_EDIT_REP_INT_MINUTE,
	IDC_EDIT_REP_INT_DAY,IDH_EDIT_REP_INT_DAY,
	IDC_SPIN_REP_INT_HOUR,IDH_EDIT_REP_INT_HOUR,
	IDC_SPIN_REP_INT_MINUTE,IDH_EDIT_REP_INT_MINUTE,
	IDC_SPIN_REP_INT_DAY,IDH_EDIT_REP_INT_DAY,
	IDC_EDIT_START_HOUR,IDH_EDIT_START_HOUR,
	IDC_EDIT_START_MINUTE,IDH_EDIT_START_MINUTE,
	IDC_EDIT_START_SECOND,IDH_EDIT_START_SECOND,
	IDC_SPIN_START_HOUR,IDH_EDIT_START_HOUR,
	IDC_SPIN_START_MINUTE,IDH_EDIT_START_MINUTE,
	IDC_SPIN_START_SECOND,IDH_EDIT_START_SECOND,
	IDC_CHECK_TRIGGER_PULL_STARTUP,IDH_CHECK_TRIGGER_PULL_STARTUP,
	IDC_CHECK_PULL_PERSIST,IDH_CHECK_PULL_PERSIST,
	0, 0
};

const DWORD g_aHelpIDs_IDD_REP_PROP_ADVANCED[]=
{
	IDC_CHECK_PUSH_PERSISTENCE,IDH_CHECK_PUSH_PERSISTENCE,
	IDC_COMBO_TYPE,IDH_COMBO_TYPE,
	IDC_EDIT_UPDATE_COUNT,IDH_EDIT_UPDATE_COUNT,
	IDC_SPIN_UPDATE_COUNT,IDH_EDIT_UPDATE_COUNT,
	IDC_BUTTON_PULL_SET_DEFAULT,IDH_BUTTON_PULL_SET_DEFAULT,
	IDC_EDIT_REP_DAY,IDH_EDIT_REP_DAY,
	IDC_SPIN_REP_DAY,IDH_EDIT_REP_DAY,
	IDC_EDIT_REP_HOUR,IDH_EDIT_REP_HOUR,
	IDC_SPIN_REP_HOUR,IDH_EDIT_REP_HOUR,
	IDC_EDIT_REP_MINUTE,IDH_EDIT_REP_MINUTE,
	IDC_SPIN_REP_MINUTE,IDH_EDIT_REP_MINUTE,
	IDC_EDIT_START_HOUR,IDH_EDIT_START_HOUR_PROP,
	IDC_SPIN_START_HOUR,IDH_EDIT_START_HOUR_PROP,
	IDC_EDIT_START_MINUTE,IDH_EDIT_START_MINUTE_PROP,
	IDC_SPIN_START_MINUTE,IDH_EDIT_START_MINUTE_PROP,
	IDC_EDIT_START_SECOND,IDH_EDIT_START_SECOND_PROP,
	IDC_SPIN_START_SECOND,IDH_EDIT_START_SECOND_PROP,
	IDC_CHECK_PULL_PERSIST,IDH_CHECK_PULL_PERSIST_PROP,
	IDC_BUTTON_PUSH_SET_DEFAULT,IDH_BUTTON_PUSH_SET_DEFAULT,
    IDC_STATIC_PULL_GROUP,IDH_DISABLEHELP,
    IDC_STATIC_START_TIME,IDH_DISABLEHELP,
    IDC_STATIC_REP_TIME,IDH_DISABLEHELP,
    IDC_STATIC_PUSH_GROUP,IDH_DISABLEHELP,
    IDC_STATIC_UPDATE,IDH_DISABLEHELP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_REP_PROP_GENERAL[]=
{
	IDC_EDIT_NAME,IDH_EDIT_NAME_REP,
	IDC_EDIT_IPADDRESS,IDH_EDIT_IPADDRESS,
	IDC_STATIC_ICON,IDH_DISABLEHELP,
    IDC_STATIC_ICON_DESC,IDH_DISABLEHELP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_SEND_PUSH_TRIGGER[]=
{
    IDC_RADIO_PUSH_THIS_PARTNER,IDH_RADIO_PUSH_THIS_PARTNER,
	IDC_RADIO_PUSH_ALL_PARTNERS,IDH_RADIO_PUSH_ALL_PARTNERS,
	0, 0
};

const DWORD g_aHelpIDs_IDD_SERVER_PROP_ADVANCED[]=
{
	IDC_CHECK_BURST_HANDLING,IDH_CHECK_BURST_HANDLING,
	IDC_CHECK_LANNAMES,IDH_CHECK_LANNAMES,
	IDC_EDIT_START_VERSION,IDH_EDIT_START_VERSION,
	IDC_EDIT_CUSTOM_VALUE,IDH_EDIT_CUSTOM_VALUE,
	IDC_RADIO_CUSTOM,IDH_RADIO_CUSTOM,
	IDC_RADIO_LOW,IDH_RADIO_LOW,
	IDC_CHECK_LOGEVENTS,IDH_CHECK_LOGEVENTS,
	IDC_RADIO_HIGH,IDH_RADIO_HIGH,
	IDC_RADIO_MEDIUM,IDH_RADIO_MEDIUM,
    IDC_STATIC_DATABASE,IDH_EDIT_DATABASE_PATH,
    IDC_EDIT_DATABASE_PATH,IDH_EDIT_DATABASE_PATH,
	0, 0
};

const DWORD g_aHelpIDs_IDD_SERVER_PROP_DBRECORD[]=
{
	IDC_BUTTON_SET_DEFAULT,IDH_BUTTON_SET_DEFAULT,
	IDC_EDIT_EXTINCT_TIMEOUT_MINUTE,IDH_EDIT_EXTINCT_TIMEOUT_MINUTE,
	IDC_EDIT_EXTINCT_TIMEOUT_HOUR,IDH_EDIT_EXTINCT_TIMEOUT_HOUR,
	IDC_EDIT_EXTINCT_TIMEOUT_DAY,IDH_EDIT_EXTINCT_TIMEOUT_DAY,
	IDC_SPIN_EXTINCT_TM_MINUTE,IDH_EDIT_EXTINCT_TIMEOUT_MINUTE,
	IDC_SPIN_EXTINCT_TM_HOUR,IDH_EDIT_EXTINCT_TIMEOUT_HOUR,
	IDC_SPIN_EXTINCT_TM_DAY,IDH_EDIT_EXTINCT_TIMEOUT_DAY,
	IDC_EDIT_EXTINCT_INT_MINUTE,IDH_EDIT_EXTINCT_INT_MINUTE,
	IDC_EDIT_EXTINCT_INT_HOUR,IDH_EDIT_EXTINCT_INT_HOUR,
	IDC_EDIT_EXTINCT_INT_DAY,IDH_EDIT_EXTINCT_INT_DAY,
	IDC_SPIN_EXTINCT_INT_MINUTE,IDH_EDIT_EXTINCT_INT_MINUTE,
	IDC_SPIN_EXTINCT_INT_HOUR,IDH_EDIT_EXTINCT_INT_HOUR,
	IDC_SPIN_EXTINCT_INT_DAY,IDH_EDIT_EXTINCT_INT_DAY,
	IDC_EDIT_RENEW_MINUTE,IDH_EDIT_RENEW_MINUTE,
	IDC_EDIT_RENEW_HOUR,IDH_EDIT_RENEW_HOUR,
	IDC_EDIT_RENEW_DAY,IDH_EDIT_RENEW_DAY,
	IDC_SPIN_RENEW_INT_MINUTE,IDH_EDIT_RENEW_MINUTE,
	IDC_SPIN_RENEW_INT_HOUR,IDH_EDIT_RENEW_HOUR,
	IDC_SPIN_RENEW_INT_DAY,IDH_EDIT_RENEW_DAY,
	IDC_EDIT_VERIFY_DAY,IDH_EDIT_VERIFY_DAY,
	IDC_EDIT_VERIFY_HOUR,IDH_EDIT_VERIFY_HOUR,
	IDC_EDIT_VERIFY_MINUTE,IDH_EDIT_VERIFY_MINUTE,
	IDC_SPIN_VERIFY_INT_DAY,IDH_EDIT_VERIFY_DAY,
	IDC_SPIN_VERIFY_INT_HOUR,IDH_EDIT_VERIFY_HOUR,
	IDC_SPIN_VERIFY_INT_MINUTE,IDH_EDIT_VERIFY_MINUTE,
	0, 0
};

const DWORD g_aHelpIDs_IDD_SERVER_PROP_DBVERIFICATION[]=
{
	IDC_CHECK_PERIODIC_CC,IDH_CHECK_PERIODIC_CC,
	IDC_EDIT_CC_INTERVAL,IDH_EDIT_CC_INTERVAL,
	IDC_EDIT_CC_MAX_CHECKED,IDH_EDIT_CC_MAX_CHECKED,
	IDC_EDIT_CC_START_HOUR,IDH_EDIT_CC_START_HOUR,
	IDC_EDIT_CC_START_MINUTE,IDH_EDIT_CC_START_MINUTE,
	IDC_EDIT_CC_START_SECOND,IDH_EDIT_CC_START_SECOND,
	IDC_SPIN_CC_START_HOUR,IDH_EDIT_CC_START_HOUR,
	IDC_SPIN_CC_START_MINUTE,IDH_EDIT_CC_START_MINUTE,
	IDC_SPIN_CC_START_SECOND,IDH_EDIT_CC_START_SECOND,
	IDC_RADIO_CHECK_OWNER,IDH_RADIO_CHECK_OWNER,
	IDC_RADIO_CHECK_RANDOM,IDH_RADIO_CHECK_RANDOM,
	0, 0
};

const DWORD g_aHelpIDs_IDD_SERVER_PROP_GEN[]=
{
	IDC_EDIT_BACKUPPATH,IDH_EDIT_BACKUPPATH,
	IDC_BUTTON_BROWSE,IDH_BUTTON_BROWSE,
	IDC_EDIT_REFRESH_HOURS2,IDH_EDIT_REFRESH_HOURS2,
	IDC_SPIN_REFRESH_HOURS2,IDH_EDIT_REFRESH_HOURS2,
	IDC_EDIT_REFRESH_MINUTES2,IDH_EDIT_REFRESH_MINUTES2,
	IDC_SPIN_REFRESH_MINUTES2,IDH_EDIT_REFRESH_MINUTES2,
	IDC_EDIT_REFRESH_SECONDS2,IDH_EDIT_REFRESH_SECONDS2,
	IDC_SPIN_REFRESH_SECONDS2,IDH_EDIT_REFRESH_SECONDS2,
	IDC_CHECK_ENABLE_AUTOREFRESH,IDH_CHECK_ENABLE_AUTOREFRESH,
	IDC_CHECK_BACKUPDB,IDH_CHECK_BACKUPDB,
	IDC_STATIC_ICON,IDH_DISABLEHELP,
    IDC_STATIC_ICON_DESC,IDH_DISABLEHELP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_SNAPIN_PP_GENERAL[]=
{
	IDC_RADIO1,IDH_RADIO1,
	IDC_RADIO2,IDH_RADIO2,
	IDC_CHECK1,IDH_CHECK1_WINS,
	IDC_CHECK2,IDH_CHECK2_WINS,
	IDC_STATIC_ICON,IDH_DISABLEHELP,
    IDC_STATIC_ICON_DESC,IDH_DISABLEHELP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_STATIC_MAPPING_PROPERTIES[]=
{
	IDC_EDIT_COMPNAME,IDH_EDIT_COMPNAME,
	IDC_BUTTON_REMOVE,IDH_BUTTON_REMOVE_WIINS,
	IDC_BUTTON_ADD,IDH_BUTTON_ADD_WINS,
	IDC_LIST_IPADD,IDH_LIST_IPADD,
	IDC_IPADD,IDH_IPADD,
	IDC_EDIT_OWNER,IDH_EDIT_OWNER_STATIC,
	IDC_EDIT_SCOPE_NAME,IDH_EDIT_SCOPE_NAME_WINS,
	IDC_EDIT_DYN_REC_TYPE,IDH_EDIT_DYN_REC_TYPE,
    IDC_COMBO_STATIC_TYPE,IDH_COMBO_STATIC_TYPE,
	IDC_STATIC_ICON,IDH_DISABLEHELP,
    IDC_STATIC_ICON_DESC,IDH_DISABLEHELP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_STATIC_MAPPING_WIZARD[]=
{
	IDC_EDIT_COMPNAME,IDH_EDIT_COMPNAME,
	IDC_BUTTON_REMOVE,IDH_BUTTON_REMOVE_WIINS,
	IDC_BUTTON_ADD,IDH_BUTTON_ADD_WINS,
	IDC_LIST_IPADD,IDH_LIST_IPADD,
	IDC_IPADD,IDH_IPADD,
	IDC_EDIT_OWNER,IDH_EDIT_OWNER_STATIC,
	IDC_EDIT_SCOPE_NAME,IDH_EDIT_SCOPE_NAME_WINS,
    IDC_EDIT_DYN_REC_TYPE,IDH_EDIT_DYN_REC_TYPE,
    IDC_COMBO_STATIC_TYPE,IDH_COMBO_STATIC_TYPE,
    IDC_STATIC_DESC,IDH_DISABLEHELP,
	IDC_STATIC_ICON,IDH_DISABLEHELP,
    IDC_STATIC_ICON_DESC,IDH_DISABLEHELP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_STATUS_NODE_PROPERTIES[]=
{
	IDC_EDIT_UPDATE,IDH_EDIT_UPDATE,
	IDC_STATIC_ICON,IDH_DISABLEHELP,
    IDC_STATIC_ICON_DESC,IDH_DISABLEHELP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_VERSION_CONSIS[]=
{
	IDC_EDIT_MESSAGE,IDH_EDIT_MESSAGE,
	0, 0
};

const DWORD g_aHelpIDs_DisplayRecords_PpSheet[]=
{
    IDOK,   IDH_OKFIND,
    IDCANCEL, IDH_CANCELFIND,
    0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\ipadddlg.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ipadddlg.h
		
		
    FILE HISTORY:
        
*/

#if !defined(AFX_IPADDDLG_H__24EB4276_990D_11D1_BA31_00C04FBF914A__INCLUDED_)
#define AFX_IPADDDLG_H__24EB4276_990D_11D1_BA31_00C04FBF914A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <ipaddr.hpp>
#include "dialog.h"

#ifndef _REPNODPP_H
#include "repnodpp.h"
#endif

#ifndef _ROOT_H
#include "root.h"
#endif

#ifndef _REPPART_H
#include "reppart.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// CIPAddressDlg dialog

class CIPAddressDlg : public CBaseDialog
{
// Construction
public:
	CIPAddressDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CIPAddressDlg)
	enum { IDD = IDD_IPADDRESS };
	CStatic	m_staticDescription;
	CEdit	m_editServerName;
	CButton	m_buttonOK;
	CString	m_strNameOrIp;
	//}}AFX_DATA

	virtual BOOL DoExtraValidation() { return TRUE; }

	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CIPAddressDlg::IDD);};

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CIPAddressDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CIPAddressDlg)
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeEditServerName();
	afx_msg void OnButtonBrowseComputers();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	BOOL ValidateIPAddress();

	CString		m_strServerIp;
	CString		m_strServerName;
	DWORD		m_dwServerIp;

protected:
    BOOL        m_fNameRequired;
};

class CNewWinsServer : public CIPAddressDlg
{
public:
	virtual BOOL DoExtraValidation();

public:
	CWinsRootHandler *		m_pRootHandler;
	SPITFSNode  			m_spRootNode;
};

class CNewPersonaNonGrata : public CIPAddressDlg
{
public:
    CNewPersonaNonGrata()
    {
        m_fNameRequired = FALSE;
    }

	virtual BOOL DoExtraValidation();

public:
	CRepNodePropAdvanced *	m_pRepPropDlg;
};

class CNewReplicationPartner : public CIPAddressDlg
{
public:
	virtual BOOL DoExtraValidation();

protected:
	virtual BOOL OnInitDialog();

public:
	CReplicationPartnersHandler *	m_pRepPartHandler;
	SPITFSNode  					m_spRepPartNode;
};

class CGetTriggerPartner : public CIPAddressDlg
{
public:
    CGetTriggerPartner()
    {
        m_fNameRequired = FALSE;
    }

protected:
	virtual BOOL OnInitDialog();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_IPADDDLG_H__24EB4276_990D_11D1_BA31_00C04FBF914A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\ipctrl.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    ipcontrol.h
//
// History:
//  ??/??/??    Tony Romano         Created.
//  05/16/96    Abolade Gbadegesin  Revised.
//============================================================================

#ifndef _IPCTRL_H
#define _IPCTRL_H


//----------------------------------------------------------------------------
// Class:       IPControl
//
// Controls an IP-address edit-control.
//----------------------------------------------------------------------------

class IPControl {
    
    public:

        IPControl( );
        ~IPControl( );
    
        BOOL
        Create(
            HWND        hParent,
            UINT        nID );

        operator
        HWND( ) { ASSERT(m_hIPaddr); return m_hIPaddr; }
    
        BOOL
        IsBlank( );

        VOID
        SetFocusField(
            DWORD       dwField );

        VOID
        SetFieldRange(
            DWORD       dwField,
            DWORD       dwMin,
            DWORD       dwMax );

        VOID
        ClearAddress( );
    
        VOID
        SetAddress(
            DWORD       ardwAddress[4] );

        VOID
        SetAddress(
            DWORD       a1,
            DWORD       a2,
            DWORD       a3,
            DWORD       a4 );

        VOID
        SetAddress(
            LPCTSTR     lpszString );
    
        INT 
        GetAddress(
            DWORD       ardwAddress[4] );

        INT 
        GetAddress(
            DWORD*      a1,
            DWORD*      a2,
            DWORD*      a3,
            DWORD*      a4 );

        INT
        GetAddress(
            CString&    address );
    
        LRESULT
        SendMessage(
            UINT        uMsg,
            WPARAM      wParam,
            LPARAM      lParam );
    
    protected:

        HWND            m_hIPaddr;
};



//----------------------------------------------------------------------------
// Macro:   MAKEADDR
//
// Given an a, b, c, and d, constructs a network-order DWORD corresponding
// to the IP-address a.b.c.d
//----------------------------------------------------------------------------

#define MAKEADDR(a, b, c, d) \
    (((a) & 0xff) | (((b) & 0xff) << 8) | (((c) & 0xff) << 16) | (((d) & 0xff) << 24))


//----------------------------------------------------------------------------
// Macros:      INET_NTOA
//              INET_ADDR
//
// Generic-text macros for IP-address conversion.
//----------------------------------------------------------------------------

#ifndef UNICODE
#define INET_NTOA(a)    inet_ntoa(*(struct in_addr *)&(a))
#define INET_ADDR       inet_addr
#else
#define INET_NTOA(a)    inet_ntoaw(*(struct in_addr *)&(a))
#define INET_ADDR       inet_addrw
#endif


//----------------------------------------------------------------------------
// Macro:       INET_CMP
//
// Comparison macro for IP addresses.
//
// This macro compares two IP addresses in network order by
// masking off each pair of octets and doing a subtraction;
// the result of the final subtraction is stored in the third argument
//----------------------------------------------------------------------------

inline int INET_CMP(DWORD a, DWORD b)
{
	DWORD	t;
	
	return ((t = ((a & 0x000000ff) - (b & 0x000000ff))) ? t :  
	((t = ((a & 0x0000ff00) - (b & 0x0000ff00))) ? t :   
	((t = ((a & 0x00ff0000) - (b & 0x00ff0000))) ? t :  
	((t = (((a>>8) & 0x00ff0000) - ((b>>8) & 0x00ff0000)))))));
}




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\listview.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	listview.cpp
		Individual option property page
	
	FILE HISTORY:
        
*/

#include "stdafx.h"
#include "ListView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CListCtrlExt

IMPLEMENT_DYNCREATE(CListCtrlExt, CListCtrl)

BEGIN_MESSAGE_MAP(CListCtrlExt, CListCtrl)
	//{{AFX_MSG_MAP(CListCtrlExt)
	ON_WM_LBUTTONDOWN()
    ON_WM_CHAR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CListCtrlExt construction/destruction

CListCtrlExt::CListCtrlExt()
{
	m_bFullRowSel = TRUE;
}

CListCtrlExt::~CListCtrlExt()
{
}

BOOL CListCtrlExt::PreCreateWindow(CREATESTRUCT& cs)
{
	// default is report view and full row selection
	cs.style &= ~LVS_TYPEMASK;
	cs.style |= (LVS_REPORT | LVS_SHAREIMAGELISTS | LVS_SINGLESEL | LVS_SHOWSELALWAYS | LVS_NOCOLUMNHEADER);
	m_bFullRowSel = TRUE;

	return(CListCtrl::PreCreateWindow(cs));
}

BOOL CListCtrlExt::SetFullRowSel(BOOL bFullRowSel)
{
	// full row selection is the only extended style this
	// class supports...
	BOOL bRet = FALSE;

	if (!m_hWnd)
		return bRet;

	if (bFullRowSel)
		bRet = ListView_SetExtendedListViewStyle(m_hWnd, LVS_EX_FULLROWSELECT);
	else
		bRet = ListView_SetExtendedListViewStyle(m_hWnd, 0);

	return(bRet);
}

BOOL CListCtrlExt::GetFullRowSel()
{
	return(m_bFullRowSel);
}

BOOL CListCtrlExt::SelectItem(int nItemIndex)
{
	LV_ITEM lvItem;

	ZeroMemory(&lvItem, sizeof(lvItem));

	lvItem.iItem = nItemIndex;
	lvItem.mask = LVIF_STATE;
	lvItem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
	lvItem.state = LVIS_SELECTED | LVIS_FOCUSED;
	
	return SetItem(&lvItem);
}

BOOL CListCtrlExt::IsSelected(int nItemIndex)
{
	return GetItemState(nItemIndex, LVIS_SELECTED);
}

BOOL CListCtrlExt::CheckItem(int nItemIndex)
{
	// this just toggles the check mark state
	UINT uState = GetItemState(nItemIndex, LVIS_STATEIMAGEMASK);
	UINT uCheckMask = INDEXTOSTATEIMAGEMASK(LISTVIEWEX_CHECKED);
	
	uState = (uState == uCheckMask) ? LISTVIEWEX_NOT_CHECKED : LISTVIEWEX_CHECKED;

	return SetItemState(nItemIndex,
				INDEXTOSTATEIMAGEMASK(uState), LVIS_STATEIMAGEMASK);
}

BOOL CListCtrlExt::SetCheck(int nItemIndex, BOOL fCheck)
{
	// this just toggles the check mark state
	UINT uState;
	
    uState = (fCheck) ? LISTVIEWEX_CHECKED : LISTVIEWEX_NOT_CHECKED;

	return SetItemState(nItemIndex,
				INDEXTOSTATEIMAGEMASK(uState), LVIS_STATEIMAGEMASK);
}

UINT CListCtrlExt::GetCheck(int nItemIndex)
{
	// return 1 for checked item, 0 for unchecked
	UINT uState = GetItemState(nItemIndex, LVIS_STATEIMAGEMASK);
	UINT uCheckMask = INDEXTOSTATEIMAGEMASK(LISTVIEWEX_CHECKED);

	return uState == uCheckMask;
}

int CListCtrlExt::AddItem
(
	LPCTSTR		pText,
	int			nRow
)
{
	// insert items
    LV_ITEM lvi = {0};

	lvi.mask = LVIF_TEXT | LVIF_STATE;
	//lvi.iItem = GetItemCount();
	lvi.iItem = nRow;
	lvi.iSubItem = 0;
	lvi.pszText = (LPTSTR) pText;
	lvi.iImage = 0;
	lvi.stateMask = LVIS_STATEIMAGEMASK;
	lvi.state = INDEXTOSTATEIMAGEMASK(LISTVIEWEX_NOT_CHECKED);

	return InsertItem(&lvi);
}

int CListCtrlExt::GetSelectedItem()
{
	// NOTE:  This list object assumes single selection and will return the 
	//        first selection in the list.  Returns -1 for nothing selected.
	int nSelectedItem = -1;

	for (int i = 0; i < GetItemCount(); i++)
	{
		UINT uState = GetItemState(i, LVIS_SELECTED);

		if (uState)
		{
			// item is selected
			nSelectedItem = i;
			break;
		}
	}

	return nSelectedItem;
}

void CListCtrlExt::OnLButtonDown(UINT nFlags, CPoint point) 
{
	UINT uFlags = 0;
	int nHitItem = HitTest(point, &uFlags);

	// only check the item if the user clicks on the state icon.
	// if the user clicks outside the text and icon, we get
	// a LVHT_ONITEM message which is:
	// LVHT_ONITEMSTATEICON | LVHT_ONITEMICON | LVHT_ONITEMLABEL
	// so we need to filter out the state icon hit
	
	BOOL bHit = FALSE;
	if ((uFlags & LVHT_ONITEMSTATEICON) &&
		!((uFlags & LVHT_ONITEMICON) ||
		  (uFlags & LVHT_ONITEMLABEL)) )
	{
		bHit = TRUE;
	}

	if (bHit)
		CheckItem(nHitItem);
	else	
		CListCtrl::OnLButtonDown(nFlags, point);
}

//----------------------------------------------------------------------------
// Function:    CListCtrlExt::OnChar
//
// Handles the 'WM_CHAR' message for the list-control.
// This allows users to change items' checked-states using the keyboard.
//----------------------------------------------------------------------------

VOID
CListCtrlExt::OnChar(
    UINT    nChar,
    UINT    nRepCnt,
    UINT    nFlags
    ) 
{
    BOOL    fSet = FALSE;
    BOOL    fClear = FALSE;
    BOOL    fToggle = FALSE;
    INT     iItem;

    //
    // Handle characters with special meaning for us
    //

    switch (nChar) {

        case TEXT(' '): { fToggle = TRUE; break; }

        case TEXT('+'):
        case TEXT('='): { fSet = TRUE; break; }

        case TEXT('-'): { fClear = TRUE; break; }
    }

    if (!fToggle && !fSet && !fClear) 
    {
        CListCtrl::OnChar(nChar, nRepCnt, nFlags);
    }
    else 
    {
        //
        // Change the state of all the selected items
        //

        for (iItem = GetNextItem(-1, LVNI_SELECTED);
             iItem != -1;
             iItem = GetNextItem(iItem, LVNI_SELECTED)) 
        {
            if (fToggle) 
            {
                SetCheck(iItem, !GetCheck(iItem));
            }
            else
            if (fSet) 
            {
                if (!GetCheck(iItem)) 
                {
                    SetCheck(iItem, TRUE); 
                }
            }
            else 
            {
                if (GetCheck(iItem)) 
                { 
                    SetCheck(iItem, FALSE); 
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\ipnamepr.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 -99             **/
/**********************************************************************/

/*
    IPNamePr.cpp
        Comment goes here

    FILE HISTORY:

*/

#include "stdafx.h"
#include "ipnamepr.h"

//
// Compare two ip/name pairs.  Return
// 0 if the same, 1 otherwise.  fBoth
// indicates if both addresses need to
// match, or if a match in either
// produces a match.
//
int
CIpNamePair::Compare(
    const CIpNamePair& inpTarget,
    BOOL fBoth
    ) const
{
    if (fBoth)
    {
        if (((LONG)inpTarget.m_iaIpAddress == (LONG)m_iaIpAddress) &&
            ((LONG)inpTarget.m_strNetBIOSName.CompareNoCase(m_strNetBIOSName) == 0))
        {
            return 0;
        }

        return 1;
    }

    //
    // Match if either matches
    //
    if (((LONG)inpTarget.m_iaIpAddress == (LONG)m_iaIpAddress) ||
        ((LONG)inpTarget.m_strNetBIOSName.CompareNoCase(m_strNetBIOSName) == 0))
    {
        return 0;
    }

    return 1;
}

//
// Sort helper function
//
int
CIpNamePair::OrderByName (
    const CObjectPlus * pobMapping
    ) const
{
    return ((CIpNamePair *)pobMapping)->m_strNetBIOSName.CompareNoCase(m_strNetBIOSName);
}

//
// Sort helper function
//
int
CIpNamePair::OrderByIp (
    const CObjectPlus * pobMapping
    ) const
{
    LONG l1 = (LONG)m_iaIpAddress;
    LONG l2 = (LONG)((CIpNamePair *)pobMapping)->m_iaIpAddress;

    return l2 > l1 ? -1 : l2 == l1 ? 0 : +1;
}

CIpNamePair::CIpNamePair()
{
}

CIpNamePair::CIpNamePair(const CIpAddress& ia, const CString& str)
    : m_iaIpAddress(ia), m_strNetBIOSName(str)
{
    m_nNameLength = str.GetLength();
}

CIpNamePair::CIpNamePair(const CIpNamePair& inpAddress)
    : m_iaIpAddress(inpAddress.m_iaIpAddress),
      m_strNetBIOSName(inpAddress.m_strNetBIOSName),
      m_nNameLength(inpAddress.m_nNameLength)
{
}


//CWinsServerObj::CWinsServerObj(): CIpNamePair(),m_iaPrimaryAddress()
CWinsServerObj::CWinsServerObj():CIpNamePair(),m_iaPrimaryAddress()
{
	

    m_fPushInitially = m_fPush = FALSE;
    m_fPullInitially = m_fPull = FALSE;
}

//
// For both constructors below, we initially set
// the primary ip address to the initial ip address
// Use SetPrimaryIpAddress to change
//
CWinsServerObj::CWinsServerObj(
    const CIpAddress& ia,
    const CString& str,
    BOOL fPush,
    BOOL fPull,
    CIntlNumber inPushUpdateCount,
    CIntlNumber inPullReplicationInterval,
    CIntlTime   itmPullStartTime
    )
    : CIpNamePair(ia, str),
      m_inPushUpdateCount(inPushUpdateCount),
      m_inPullReplicationInterval(inPullReplicationInterval),
      m_itmPullStartTime(itmPullStartTime),
      m_iaPrimaryAddress(ia)
{
    m_fPushInitially = m_fPush = fPush;
    m_fPullInitially = m_fPull = fPull;
}

CWinsServerObj::CWinsServerObj(
    const CIpNamePair& inpAddress,
    BOOL fPush,
    BOOL fPull,
    CIntlNumber inPushUpdateCount,
    CIntlNumber inPullReplicationInterval,
    CIntlTime   itmPullStartTime
    )
    : CIpNamePair(inpAddress),
      m_inPushUpdateCount(inPushUpdateCount),
      m_inPullReplicationInterval(inPullReplicationInterval),
      m_itmPullStartTime(itmPullStartTime),
      m_iaPrimaryAddress(inpAddress.QueryIpAddress())
{
    m_fPushInitially = m_fPush = fPush;
    m_fPullInitially = m_fPull = fPull;
}

CWinsServerObj::CWinsServerObj(
    const CWinsServerObj& wsServer
    )
    : CIpNamePair(wsServer),
      m_inPushUpdateCount(wsServer.m_inPushUpdateCount),
      m_inPullReplicationInterval(wsServer.m_inPullReplicationInterval),
      m_itmPullStartTime(wsServer.m_itmPullStartTime)
{
    m_fPushInitially = m_fPush = wsServer.IsPush();
    m_fPullInitially = m_fPull = wsServer.IsPull();

	m_fPullPersistence = wsServer.m_fPullPersistence;
	m_fPushPersistence = wsServer.m_fPushPersistence;

	m_strIPAddress = wsServer.m_strIPAddress;
}

CWinsServerObj &
CWinsServerObj::operator=(
    const CWinsServerObj& wsNew
    )
{
    m_iaIpAddress = wsNew.m_iaIpAddress;
    m_strNetBIOSName = wsNew.m_strNetBIOSName;
    m_inPushUpdateCount = wsNew.m_inPushUpdateCount;
    m_inPullReplicationInterval = wsNew.m_inPullReplicationInterval;
    m_itmPullStartTime = wsNew.m_itmPullStartTime;
    m_fPull = wsNew.m_fPull;
    m_fPush = wsNew.m_fPush;
    m_fPullInitially = wsNew.m_fPullInitially;
    m_fPushInitially = wsNew.m_fPullInitially;
	m_strIPAddress = wsNew.m_strIPAddress;

	m_fPullPersistence = wsNew.m_fPullPersistence;
	m_fPushPersistence = wsNew.m_fPushPersistence;

    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\loadrecs.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	loadrecs.h
		dialog to load records from the datbase, includes by owner
        and by record type.
		
    FILE HISTORY:
        
*/

#ifndef _LOADRECS_H
#define _LOADRECS_H

#ifndef _DIALOG_H
#include "..\common\dialog.h"
#endif

#ifndef _LISTVIEW_H
#include "listview.h"
#endif

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// COwnerPage dialog

class COwnerPage : public CPropertyPage
{
// Construction
public:
	COwnerPage();   // standard constructor
	~COwnerPage();
    DWORD GetOwnerForApi();

// Dialog Data
	//{{AFX_DATA(COwnerPage)
	enum { IDD = IDD_OWNER_FILTER };
	CButton	m_btnEnableCache;
	CListCtrlExt	m_listOwner;
	//}}AFX_DATA

    int HandleSort(LPARAM lParam1, LPARAM lParam2);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COwnerPage)
	public:
	virtual BOOL OnKillActive();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(COwnerPage)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnColumnclickListOwner(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnButtonSelectAll();
	afx_msg void OnButtonUnselectAll();
	afx_msg void OnButtonLocal();
	afx_msg void OnEnableCaching();
	afx_msg void OnItemchangedListOwner(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CImageList		m_ImageList;

	void    FillOwnerInfo();
	CString GetVersionInfo(LONG lLowWord, LONG lHighWord);
    void    Sort(int nCol);

protected:
    int                     m_nSortColumn;
    BOOL                    m_aSortOrder[COLUMN_MAX];
    UINT                    m_nChecked;

public:
    CServerInfoArray        m_ServerInfoArray;
    CDWordArray             m_dwaOwnerFilter;
    BYTE                    *m_pbaDirtyFlags;
    BOOL                    m_bDirtyOwners;

public:
    DWORD * GetHelpMap() { return WinsGetHelpMap(COwnerPage::IDD); }
};


/////////////////////////////////////////////////////////////////////////////
// CFilterPage dialog
typedef struct
{
    BYTE    bFlags;
    DWORD   dwType;
} tDirtyFlags;

class CFilterPage : public CPropertyPage
{
// Construction
public:
	CFilterPage();   // standard constructor
    ~CFilterPage();

// Dialog Data
	//{{AFX_DATA(CFilterPage)
	enum { IDD = IDD_FILTER_SELECT };
	CButton	m_btnEnableCache;
	CButton	m_buttonDelete;
	CButton	m_buttonModify;
	CListCtrlExt	m_listType;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFilterPage)
	public:
	virtual BOOL OnKillActive();
	virtual BOOL OnSetActive();
	virtual void OnOK();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFilterPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnItemchangedList1(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnButtonAddType();
	afx_msg void OnButtonModifyType();
	afx_msg void OnButtonDelete();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnButtonSelectAll();
	afx_msg void OnButtonUnselectAll();
	afx_msg void OnEnableCaching();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CTypeFilterInfoArray m_arrayTypeFilter;
    NameTypeMapping *    m_pNameTypeMap;
    BOOL                 m_bDirtyTypes;
    tDirtyFlags          *m_pbaDirtyFlags;
    UINT                 m_nDirtyFlags;

private:
	CImageList		m_ImageList;

	void    FillTypeInfo();
	void    CheckItems();
	int     GetIndex(DWORD dwFound);
    BOOL    IsDefaultType(DWORD dwType);

public:
    DWORD * GetHelpMap() { return WinsGetHelpMap(CFilterPage::IDD); }
};

/////////////////////////////////////////////////////////////////////////////
// CNameTypeDlg dialog

class CNameTypeDlg : public CBaseDialog
{
// Construction
public:
	CNameTypeDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CNameTypeDlg)
	enum { IDD = IDD_NAME_TYPE };
	CEdit	m_editDescription;
	CEdit	m_editId;
	CString	m_strDescription;
	CString	m_strId;
	//}}AFX_DATA

    BOOL                m_fCreate;
    DWORD               m_dwId;
    NameTypeMapping *   m_pNameTypeMap;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNameTypeDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL


// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNameTypeDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CNameTypeDlg::IDD);};//return NULL;}
};

/////////////////////////////////////////////////////////////////////////////
// CIPAddrPage dialog
class CIPAddrPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CIPAddrPage)

// Construction
public:
	CIPAddrPage();
	~CIPAddrPage();
    LPCOLESTR GetNameForApi();
    DWORD     GetIPMaskForFilter(UINT nMask);

// Dialog Data
	//{{AFX_DATA(CIPAddrPage)
	enum { IDD = IDD_FILTER_IPADDR };
	CButton	m_ckbMatchCase;
	CButton	m_ckbIPMask;
	CButton	m_ckbName;
	CButton	m_ckbIPAddr;
	CButton	m_btnEnableCache;
	CEdit	m_editName;
	CIPAddressCtrl	m_ctrlIPAddress;
	CIPAddressCtrl	m_ctrlIPMask;
	//}}AFX_DATA
    BOOL        m_bFilterName;
    BOOL        m_bMatchCase;
    CString     m_strName;
    BOOL        m_bDirtyName;

    BOOL        m_bFilterIpAddr;
    CDWordArray m_dwaIPAddrs;
    BOOL        m_bDirtyAddr;

    BOOL        m_bFilterIpMask;
    CDWordArray m_dwaIPMasks;
    BOOL        m_bDirtyMask;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CIPAddrPage)
	public:
	virtual void OnOK();
	virtual BOOL OnKillActive();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CIPAddrPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckIpaddr();
	afx_msg void OnCheckName();
	afx_msg void OnEnableCaching();
	afx_msg void OnCheckIpmask();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
public:
    DWORD * GetHelpMap() { return WinsGetHelpMap(CIPAddrPage::IDD); }
};

/////////////////////////////////////////////////////////////////////////////
// CLoadRecords
#define RESOURCE_API_MASK     0x00000003
#define RESOURCE_API_NAME     0x00000001
#define RESOURCE_API_OWNER    0x00000002
#define RESOURCE_CACHE        0x00000004

class CLoadRecords : public CPropertySheet
{
	DECLARE_DYNAMIC(CLoadRecords)

// Construction
public:
	CLoadRecords(UINT nIDCaption);
    VOID ResetFiltering();

// Attributes
public:
    COwnerPage  m_pageOwners;
    CFilterPage m_pageTypes;
    CIPAddrPage m_pageIpAddress;
    UINT        m_nActivePage;
    BOOL        m_bCaching;
    BOOL        m_bEnableCache;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLoadRecords)
	public:
	virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CLoadRecords();

	// Generated message map functions
protected:
	//{{AFX_MSG(CLoadRecords)
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif _LOADRECS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\listview.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	listview.h
		Listview control
	
	FILE HISTORY:
        
*/

#ifndef _LISTVIEW_H
#define _LISTVIEW_H

#define LISTVIEWEX_NOT_CHECKED	1
#define LISTVIEWEX_CHECKED		2

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CListCtrlExt : public CListCtrl
{
	DECLARE_DYNCREATE(CListCtrlExt)

// Construction
public:
	CListCtrlExt();

// Attributes
protected:
	BOOL m_bFullRowSel;

public:
	BOOL SetFullRowSel(BOOL bFillRowSel);
	BOOL GetFullRowSel();
	
	int  AddItem(LPCTSTR pText, int nRow);
	BOOL SelectItem(int nItemIndex);
	BOOL IsSelected(int nItemIndex);
	BOOL CheckItem(int nItemIndex);
	BOOL SetCheck(int nItemIndex, BOOL fCheck);
	UINT GetCheck(int nItemIndex);
	int  GetSelectedItem();

// Overrides
protected:
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CListCtrlExt)
	public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CListCtrlExt();

// Generated message map functions
protected:
	//{{AFX_MSG(CListCtrlExt)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg VOID OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#endif _LISTVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\loadrecs.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	loadrecs.cpp
		dialog to load records from the datbase, includes by owner
        and by record type.
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "winssnap.h"
#include "loadrecs.h"
#include "server.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BOOL MyCreateImageList(CImageList& imgList, UINT nBitmapID, int cx, int nGrow, COLORREF crMask)
{
 ASSERT(HIWORD(nBitmapID) == 0);
 HINSTANCE hInst = AfxFindResourceHandle((LPCTSTR)ULongToPtr(nBitmapID), RT_BITMAP);
 ASSERT(hInst != NULL);
 return imgList.Attach(ImageList_LoadBitmap(hInst, (LPCTSTR)ULongToPtr(nBitmapID), cx, nGrow, crMask));
}

/////////////////////////////////////////////////////////////////////////////
// CLoadRecords

IMPLEMENT_DYNAMIC(CLoadRecords, CPropertySheet)

CLoadRecords::CLoadRecords(UINT nIDCaption)
	:CPropertySheet(nIDCaption)
{
    AddPage(&m_pageIpAddress);
    AddPage(&m_pageOwners);
    AddPage(&m_pageTypes);

    m_psh.dwFlags |= PSH_NOAPPLYNOW;
    m_nActivePage = 0;
    m_bEnableCache = FALSE;
    m_bCaching = FALSE;
}

CLoadRecords::~CLoadRecords()
{
}

VOID CLoadRecords::ResetFiltering()
{
    m_pageOwners.m_dwaOwnerFilter.RemoveAll();
    m_pageIpAddress.m_dwaIPAddrs.RemoveAll();
    m_pageIpAddress.m_dwaIPMasks.RemoveAll();
    m_pageIpAddress.m_bFilterIpAddr = FALSE;
    m_pageIpAddress.m_bFilterIpMask = FALSE;
    m_pageIpAddress.m_bFilterName = FALSE;
    m_pageIpAddress.m_bMatchCase = FALSE;
}

BEGIN_MESSAGE_MAP(CLoadRecords, CPropertySheet)
	//{{AFX_MSG_MAP(CLoadRecords)
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CLoadRecords::OnInitDialog() 
{
    CPropertySheet::OnInitDialog();

    m_bCaching = m_bEnableCache;
	SetActivePage(m_nActivePage);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CLoadRecords message handlers
//
extern const DWORD g_aHelpIDs_DisplayRecords_PpSheet[];
BOOL CLoadRecords::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	int		i;
	DWORD	dwCtrlId;

    if (pHelpInfo->iContextType == HELPINFO_WINDOW)
	{
		DWORD *	pdwHelp	= (LPDWORD)g_aHelpIDs_DisplayRecords_PpSheet;

        if (pdwHelp)
        {
			::WinHelp ((HWND)pHelpInfo->hItemHandle,
			           AfxGetApp()->m_pszHelpFilePath,
			           HELP_WM_HELP,
			           (ULONG_PTR)pdwHelp);
        }
	}
	
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// COwnerPage dialog

int CALLBACK OwnerPageCompareFunc
(
    LPARAM lParam1, 
    LPARAM lParam2, 
    LPARAM lParamSort
)
{
    return ((COwnerPage *) lParamSort)->HandleSort(lParam1, lParam2);
}

COwnerPage::COwnerPage()
	: CPropertyPage(COwnerPage::IDD)
{
    m_nSortColumn = -1; 

    for (int i = 0; i < COLUMN_MAX; i++)
    {
        m_aSortOrder[i] = TRUE; // ascending
    }

    m_pbaDirtyFlags = NULL;
    m_bDirtyOwners = FALSE;
    //{{AFX_DATA_INIT(COwnerPage)
	//}}AFX_DATA_INIT
}

COwnerPage::~COwnerPage()
{
    if (m_pbaDirtyFlags != NULL)
        delete m_pbaDirtyFlags;
}

DWORD COwnerPage::GetOwnerForApi()
{
    return m_dwaOwnerFilter.GetSize() == 1 ? m_dwaOwnerFilter[0] : (DWORD)-1;
}

void COwnerPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(COwnerPage)
	DDX_Control(pDX, IDC_ENABLE_CACHING, m_btnEnableCache);
	DDX_Control(pDX, IDC_LIST_OWNER, m_listOwner);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(COwnerPage, CPropertyPage)
	//{{AFX_MSG_MAP(COwnerPage)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_LIST_OWNER, OnColumnclickListOwner)
	ON_WM_HELPINFO()
	ON_BN_CLICKED(IDC_BUTTON_SELECT_ALL, OnButtonSelectAll)
	ON_BN_CLICKED(IDC_BUTTON_UNSELECT_ALL, OnButtonUnselectAll)
	ON_BN_CLICKED(IDC_BUTTON_LOCAL, OnButtonLocal)
	ON_BN_CLICKED(IDC_ENABLE_CACHING, OnEnableCaching)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST_OWNER, OnItemchangedListOwner)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COwnerPage message handlers

BOOL COwnerPage::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();

    //BOOL ftest = m_ImageList.Create(IDB_LIST_STATE, 16, 1, RGB(255, 0, 0));
    MyCreateImageList(m_ImageList, IDB_LIST_STATE, 16, 1, RGB(255, 0, 0));

    
    // set the list item images
    m_listOwner.SetImageList(NULL, LVSIL_NORMAL);
	m_listOwner.SetImageList(NULL, LVSIL_SMALL);
	m_listOwner.SetImageList(&m_ImageList, LVSIL_STATE);

    // fill the header informnation for the list control
	CString strOwner;
	strOwner.LoadString(IDS_OWNER);
	m_listOwner.InsertColumn(COLUMN_IP, strOwner, LVCFMT_LEFT, 100, 1);

    CString strName;
    strName.LoadString(IDS_NAME);
    m_listOwner.InsertColumn(COLUMN_NAME, strName, LVCFMT_LEFT, 95, -1);

    CString strID;
	strID.LoadString(IDS_HIGHESTID);
	m_listOwner.InsertColumn(COLUMN_VERSION, strID, LVCFMT_LEFT, 75, -1);

	m_listOwner.SetFullRowSel(TRUE);

    // update the UI
    FillOwnerInfo();

	return TRUE;  
}

void 
COwnerPage::FillOwnerInfo()
{
    int i;

    m_nChecked = 0;

    if (m_ServerInfoArray.GetSize() > 0)
    {
        int nDirtySize = (int)m_ServerInfoArray.GetSize();

        if (m_pbaDirtyFlags != NULL)
            delete m_pbaDirtyFlags;

        m_pbaDirtyFlags = new BYTE[nDirtySize];
        if (m_pbaDirtyFlags != NULL)
            RtlZeroMemory(m_pbaDirtyFlags, nDirtySize);
    }

	for (i = 0; i < m_ServerInfoArray.GetSize(); i++)
    {
        //
        // if this owner is deleted or doesn't have any records to show
        // then don't add it to the list.  Owners can have an ID of 0 if they don't 
        // have any records but were found owning an address in a 1c record in the database
        //
        if ( (m_ServerInfoArray[i].m_liVersion.QuadPart == OWNER_DELETED) ||
             (m_ServerInfoArray[i].m_liVersion.QuadPart == 0) )
        {
            // skip this one
            continue;
        }

        CString strIPAdd;
        ::MakeIPAddress(m_ServerInfoArray[i].m_dwIp, strIPAdd);

        CString strVers = GetVersionInfo(m_ServerInfoArray[i].m_liVersion.LowPart, 
                                         m_ServerInfoArray[i].m_liVersion.HighPart);

        int nItem = m_listOwner.InsertItem(i, strIPAdd, 0);

	    m_listOwner.SetItemText(nItem, 1, m_ServerInfoArray[i].m_strName);
        m_listOwner.SetItemText(nItem, 2, strVers);
        m_listOwner.SetItemData(nItem, i);

        // empty filter array means all owners should be selected
        if (m_dwaOwnerFilter.GetSize() == 0)
        {
            m_listOwner.SetCheck(nItem, TRUE);
            m_pbaDirtyFlags[i] |= 2;
        }
        else
        {
            // filter array is not empty, we check the item if it is found in the filter
            for (int j = (int)m_dwaOwnerFilter.GetSize()-1; j >= 0; j--)
            {
                if (m_ServerInfoArray[i].m_dwIp == m_dwaOwnerFilter[j])
                {
                    m_listOwner.SetCheck(nItem, TRUE);
                    m_pbaDirtyFlags[i] |= 2;
                    break;
                }
            }

            if (j < 0)
            {
                // m_nChecked keeps a count of how many items are checked in the list.
                // each SetCheck() balances the counter -> ++ if an item is checked
                // -- if an item in unchecked. However, initially, we need to set the items
                // that are unchecked explicitly otherwise the checkbox doesn't show up.
                // this could unballance the counter if we don't correct it by incrementing
                // it first. Whatever we add here is decremented immediately after because
                // of the SetCheck(..FALSE) below.
                m_nChecked++;
                m_listOwner.SetCheck(nItem, FALSE);
            }
        }
    }

    Sort(COLUMN_IP);

    for (i = m_listOwner.GetItemCount()-1; i >=0; i--)
    {
        if (m_listOwner.GetCheck(i))
        {
            m_listOwner.EnsureVisible(i,FALSE);
            break;
        }
    }

    m_listOwner.SetFocus();
}

CString 
COwnerPage::GetVersionInfo(LONG lLowWord, LONG lHighWord)
{
	CString strVersionCount;

	TCHAR sz[20];
    TCHAR *pch = sz;
    ::wsprintf(sz, _T("%08lX%08lX"), lHighWord, lLowWord);
    // Kill leading zero's
    while (*pch == '0')
    {
        ++pch;
    }
    // At least one digit...
    if (*pch == '\0')
    {
        --pch;
    }

    strVersionCount = pch;

    return strVersionCount;
}

void COwnerPage::OnOK() 
{
    int i;
    BOOL bAllSelected;

    UpdateData();

    // clear any previous owners in the array since
    // GetSelectedOwner() is copying over the new
    // selected owners
    m_dwaOwnerFilter.RemoveAll();

    for (i = (int)m_ServerInfoArray.GetSize()-1; i>=0; i--)
    {
        if ( (m_ServerInfoArray[i].m_liVersion.QuadPart != OWNER_DELETED) &&
             (m_ServerInfoArray[i].m_liVersion.QuadPart != 0)             &&
             !(m_pbaDirtyFlags[i] & 1) )
        {
            bAllSelected = FALSE;
            break;
        }
    }

    // mark owners as dirty only if some new owners are added - removing an owner shouldn't
    // force the database to be reloaded in any way since the records are already there.
    m_bDirtyOwners = FALSE;
    for (i = (int)m_ServerInfoArray.GetSize()-1; i >=0; i--)
    {

        // 0 - owner was not in the list and it is not now
        // 1 - owner was not in the list but it is now
        // 2 - owner was in the list and it is not now
        // 3 - owner was in the list and it is now
        if (!m_bDirtyOwners && m_pbaDirtyFlags[i] == 1)
        {
            m_bDirtyOwners = TRUE;
        }
        if (!bAllSelected && (m_pbaDirtyFlags[i] & 1))
        {
            m_dwaOwnerFilter.Add(m_ServerInfoArray[i].m_dwIp);
        }
    }

	CPropertyPage::OnOK();
}

void COwnerPage::Sort(int nCol) 
{
    if (m_nSortColumn == nCol)
    {
        // if the user is clicking the same column again, reverse the sort order
        m_aSortOrder[nCol] = m_aSortOrder[nCol] ? FALSE : TRUE;
    }
    else
    {
        m_nSortColumn = nCol;
    }

    m_listOwner.SortItems(OwnerPageCompareFunc, (LPARAM) this);
}

int COwnerPage::HandleSort(LPARAM lParam1, LPARAM lParam2) 
{
    int nCompare = 0;

    switch (m_nSortColumn)
    {
        case COLUMN_IP:
            {
                DWORD dwIp1 = m_ServerInfoArray.GetAt((int) lParam1).m_dwIp;
                DWORD dwIp2 = m_ServerInfoArray.GetAt((int) lParam2).m_dwIp;
            
                if (dwIp1 > dwIp2)
                    nCompare = 1;
                else
                if (dwIp1 < dwIp2)
                    nCompare = -1;
            }
            break;

        case COLUMN_NAME:
            {
                CString strName1 = m_ServerInfoArray[(int) lParam1].m_strName;
                CString strName2 = m_ServerInfoArray[(int) lParam2].m_strName;

                nCompare = strName1.CompareNoCase(strName2);
            }
            break;

        case COLUMN_VERSION:
            {
                LARGE_INTEGER li1, li2;
                
                li1.QuadPart = m_ServerInfoArray.GetAt((int) lParam1).m_liVersion.QuadPart;
                li2.QuadPart = m_ServerInfoArray.GetAt((int) lParam2).m_liVersion.QuadPart;
            
                if (li1.QuadPart > li2.QuadPart)
                    nCompare = 1;
                else
                if (li1.QuadPart < li2.QuadPart)
                    nCompare = -1;
            }
            break;
    }

    if (m_aSortOrder[m_nSortColumn] == FALSE)
    {
        // descending
        return -nCompare;
    }
    else
    {
        // ascending
        return nCompare;
    }
}

void COwnerPage::OnColumnclickListOwner(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    // sort depending on what column was clicked;
    Sort(pNMListView->iSubItem);

    *pResult = 0;
}

BOOL COwnerPage::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	int		i;
	DWORD	dwCtrlId;

    if (pHelpInfo->iContextType == HELPINFO_WINDOW)
	{
		DWORD *	pdwHelp	= GetHelpMap();

        if (pdwHelp)
        {
			::WinHelp ((HWND)pHelpInfo->hItemHandle,
			           AfxGetApp()->m_pszHelpFilePath,
			           HELP_WM_HELP,
			           (ULONG_PTR)pdwHelp);
        }
	}
	
	return TRUE;
}

void COwnerPage::OnButtonLocal() 
{
    int iLocal = 0;

    for (int i = 0; i < m_listOwner.GetItemCount(); i++)
    {
        // item data has the owner id and the local server always
        // has the owner id = 0
        if ((DWORD)m_listOwner.GetItemData(i) == 0)
            iLocal = i;

        m_listOwner.SetCheck(i, (DWORD)m_listOwner.GetItemData(i) == 0);
    }

    m_listOwner.EnsureVisible(iLocal, FALSE);
}

void COwnerPage::OnButtonSelectAll() 
{
	for (int i = 0; i < m_listOwner.GetItemCount(); i++)
	{
		m_listOwner.SetCheck(i, TRUE);
	}
}

void COwnerPage::OnButtonUnselectAll() 
{
	for (int i = 0; i < m_listOwner.GetItemCount(); i++)
	{
		m_listOwner.SetCheck(i, FALSE);
	}
}

BOOL COwnerPage::OnKillActive() 
{
    int i;

	for (i = m_listOwner.GetItemCount()-1; i >=0 ; i--)
	{
		if (m_listOwner.GetCheck(i) == TRUE)
			break;
	}

    if (i<0)
    {
        // tell the user to select at least one name type to display
        WinsMessageBox(IDS_ERR_NO_OWNER_SPECIFIED);
        PropSheet_SetCurSel(GetSafeHwnd(), NULL, 0); 
        m_listOwner.SetFocus();

		return FALSE;
    }

    return CPropertyPage::OnKillActive();
}

BOOL COwnerPage::OnSetActive() 
{
    CLoadRecords *pParent = (CLoadRecords *)GetParent();
    m_btnEnableCache.SetCheck(pParent->m_bCaching);
	return CPropertyPage::OnSetActive();
}

void COwnerPage::OnEnableCaching() 
{
    CLoadRecords *pParent = (CLoadRecords *)GetParent();
    pParent->m_bCaching = (m_btnEnableCache.GetCheck() == 1);
}

void COwnerPage::OnItemchangedListOwner(NMHDR* pNMHDR, LRESULT* pResult) 
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    BOOL         bInc;

    // if the checkbox isn't changed we don't care
    if ( pNMListView->uChanged & LVIF_STATE &&
         (pNMListView->uOldState & LVIS_STATEIMAGEMASK) != (pNMListView->uNewState & LVIS_STATEIMAGEMASK))
    {
        CLoadRecords *pParent = (CLoadRecords *)GetParent();

        if ((pNMListView->uNewState & INDEXTOSTATEIMAGEMASK(2)) != 0)
        {
            m_pbaDirtyFlags[pNMListView->lParam] |= 1;
            m_nChecked++;
            bInc = TRUE;
        }
        else
        {
            m_pbaDirtyFlags[pNMListView->lParam] &= ~1;
            m_nChecked--;
            bInc = FALSE;
        }
    }
    
	*pResult = 0;
}

/////////////////////////////////////////////////////////////////////////////
// CFilterPage dialog

int CALLBACK FilterPageCompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    if (lParam1 < lParam2)
        return -1;
    else 
    if (lParam1 > lParam2)
        return 1;
    else
        return 0;
}


CFilterPage::CFilterPage()
	: CPropertyPage(CFilterPage::IDD)
{
	//{{AFX_DATA_INIT(CFilterPage)
	//}}AFX_DATA_INIT
    m_bDirtyTypes = FALSE;
    m_pbaDirtyFlags = NULL;
    m_nDirtyFlags = 0;
}

CFilterPage::~CFilterPage()
{
    if (m_pbaDirtyFlags != NULL)
        delete m_pbaDirtyFlags;
}


void CFilterPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFilterPage)
	DDX_Control(pDX, IDC_ENABLE_CACHING, m_btnEnableCache);
	DDX_Control(pDX, IDC_BUTTON_DELETE_TYPE, m_buttonDelete);
	DDX_Control(pDX, IDC_BUTTON_MODIFY_TYPE, m_buttonModify);
	DDX_Control(pDX, IDC_LIST1, m_listType);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFilterPage, CPropertyPage)
	//{{AFX_MSG_MAP(CFilterPage)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST1, OnItemchangedList1)
	ON_BN_CLICKED(IDC_BUTTON_ADD_TYPE, OnButtonAddType)
	ON_BN_CLICKED(IDC_BUTTON_MODIFY_TYPE, OnButtonModifyType)
	ON_BN_CLICKED(IDC_BUTTON_DELETE_TYPE, OnButtonDelete)
	ON_WM_HELPINFO()
	ON_BN_CLICKED(IDC_BUTTON_SELECT_ALL, OnButtonSelectAll)
	ON_BN_CLICKED(IDC_BUTTON_UNSELECT_ALL, OnButtonUnselectAll)
	ON_BN_CLICKED(IDC_ENABLE_CACHING, OnEnableCaching)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFilterPage message handlers

BOOL CFilterPage::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();

	//BOOL ftest = m_ImageList.Create(IDB_LIST_STATE, 16, 1, RGB(255, 0, 0));
    MyCreateImageList(m_ImageList, IDB_LIST_STATE, 16, 1, RGB(255, 0, 0));

	m_listType.SetImageList(NULL, LVSIL_NORMAL);
	m_listType.SetImageList(NULL, LVSIL_SMALL);
	m_listType.SetImageList(&m_ImageList, LVSIL_STATE);
    m_listType.InsertColumn(0, _T("Test"), LVCFMT_LEFT, 250);

    m_buttonModify.EnableWindow(FALSE);
    m_buttonDelete.EnableWindow(FALSE);

    FillTypeInfo();

    m_nDirtyFlags = (UINT)m_arrayTypeFilter.GetSize();
    if (m_pbaDirtyFlags != NULL)
        delete m_pbaDirtyFlags;
    m_pbaDirtyFlags = new tDirtyFlags[m_nDirtyFlags];
    if ( m_pbaDirtyFlags != NULL)
    {
        RtlZeroMemory(m_pbaDirtyFlags, m_nDirtyFlags*sizeof(tDirtyFlags));

        for (UINT i = 0; i<m_nDirtyFlags; i++)
        {
            m_pbaDirtyFlags[i].dwType = m_arrayTypeFilter[i].dwType;

            if (m_arrayTypeFilter[i].fShow)
            {
                m_pbaDirtyFlags[i].bFlags = 2;
            }
        }
    }
    else
    {
        m_nDirtyFlags = 0;
    }

	return TRUE;  
}

void CFilterPage::OnOK() 
{
    if (m_pbaDirtyFlags == NULL)
    {
        m_bDirtyTypes = TRUE;
    }
    else
    {
        int i,j;

        m_bDirtyTypes = FALSE;

        for (i = (int)m_arrayTypeFilter.GetSize()-1; i>=0; i--)
        {
            for (j = m_nDirtyFlags-1; j>=0; j--)
            {
                if (m_arrayTypeFilter[i].dwType == m_pbaDirtyFlags[j].dwType)
                {
                    if (m_arrayTypeFilter[i].fShow)
                        m_pbaDirtyFlags[j].bFlags |= 1;
                    break;
                }
            }

            if (j<0 && m_arrayTypeFilter[i].fShow)
            {
                m_bDirtyTypes = TRUE;
                break;
            }
        }

        for (j = m_nDirtyFlags-1; j>=0; j--)
        {
            if (m_pbaDirtyFlags[j].bFlags == 1)
            {
                m_bDirtyTypes = TRUE;
                break;
            }
        }
    }

	CPropertyPage::OnOK();
}

BOOL CFilterPage::OnKillActive() 
{
	BOOL fShowOneType = FALSE;

	for (int i = 0; i < m_arrayTypeFilter.GetSize(); i++)
	{
		if (m_arrayTypeFilter[i].fShow == TRUE)
		{
			fShowOneType = TRUE;
			break;
		}
	}

    if (!fShowOneType)
    {
        // tell the user to select at least one name type to display
        WinsMessageBox(IDS_ERR_NO_NAME_TYPE_SPECIFIED);
        PropSheet_SetCurSel(GetSafeHwnd(), NULL, 0); 
        m_listType.SetFocus();

		return FALSE;
    }

    return CPropertyPage::OnKillActive();
}

BOOL CFilterPage::OnSetActive() 
{
    CLoadRecords *pParent = (CLoadRecords *)GetParent();
    m_btnEnableCache.SetCheck(pParent->m_bCaching);
	return CPropertyPage::OnSetActive();
}

void CFilterPage::OnEnableCaching() 
{
    CLoadRecords *pParent = (CLoadRecords *)GetParent();
    pParent->m_bCaching = (m_btnEnableCache.GetCheck() == 1);
}

void CFilterPage::OnItemchangedList1(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
		// check to see if this item is checked
	BOOL bChecked = m_listType.GetCheck(pNMListView->iItem);

	int nIndex = pNMListView->iItem;
	DWORD dwType = (DWORD) m_listType.GetItemData(nIndex);

    // if the state isn't changing, then we don't care
    if ( !(pNMListView->uChanged & LVIF_STATE) )
        return;

	for (int i = 0; i < m_arrayTypeFilter.GetSize(); i++)
	{
		if (m_arrayTypeFilter[i].dwType == dwType)
        {
			m_arrayTypeFilter[i].fShow = bChecked;
		}
	}

    if (m_listType.IsSelected(nIndex) &&
        !IsDefaultType(dwType) )
    {
        m_buttonModify.EnableWindow(TRUE);
        m_buttonDelete.EnableWindow(TRUE);
    }
    else
    {
        m_buttonModify.EnableWindow(FALSE);
        m_buttonDelete.EnableWindow(FALSE);
    }

    *pResult = 0;
}

void CFilterPage::OnButtonAddType() 
{
    CNameTypeDlg dlgNameType;

    dlgNameType.m_pNameTypeMap = m_pNameTypeMap;

    if (dlgNameType.DoModal() == IDOK)
    {
        // add new type here
        HRESULT hr = m_pNameTypeMap->AddEntry(dlgNameType.m_dwId, dlgNameType.m_strDescription);
        if (FAILED(hr))
        {
            WinsMessageBox(WIN32_FROM_HRESULT(hr));
            return;
        }

		// update our array that keeps track of check state
		CTypeFilterInfo		typeFilterInfo;
	
		typeFilterInfo.dwType = dlgNameType.m_dwId;
		typeFilterInfo.fShow = TRUE;
        m_arrayTypeFilter.Add(typeFilterInfo);

        // update the listbox
        m_listType.DeleteAllItems();
        FillTypeInfo();
    }
}

void CFilterPage::OnButtonModifyType() 
{
    CNameTypeDlg dlgNameType;
    int nSelected;

    dlgNameType.m_pNameTypeMap = m_pNameTypeMap;

    nSelected = m_listType.GetNextItem(-1, LVNI_SELECTED);

    dlgNameType.m_fCreate = FALSE;

    dlgNameType.m_dwId = (DWORD) m_listType.GetItemData(nSelected);
    m_pNameTypeMap->TypeToCString(dlgNameType.m_dwId, -1, dlgNameType.m_strDescription);

    if (dlgNameType.DoModal() == IDOK)
    {
        // modify type here
        HRESULT hr = m_pNameTypeMap->ModifyEntry(dlgNameType.m_dwId, dlgNameType.m_strDescription);
        if (FAILED(hr))
        {
            WinsMessageBox(WIN32_FROM_HRESULT(hr));
            return;
        }

        // move the focus
        m_listType.SetFocus();
        SetDefID(IDOK);

        // update the listbox
        m_listType.DeleteAllItems();
        FillTypeInfo();
    }
}

void CFilterPage::OnButtonDelete() 
{
    HRESULT hr = hrOK;
    int     nSelected;
    DWORD   dwNameType;

    nSelected = m_listType.GetNextItem(-1, LVNI_SELECTED);
    dwNameType = (DWORD) m_listType.GetItemData(nSelected);

    // are you sure?
    if (AfxMessageBox(IDS_WARN_DELETE_NAME_TYPE, MB_YESNO) == IDYES)
    {
        hr = m_pNameTypeMap->RemoveEntry(dwNameType);
        if (SUCCEEDED(hr))
        {
            // remove from the list box
            m_listType.DeleteItem(nSelected);

            // remove from the active filters if it is in the list
            for (int i = 0; i < m_arrayTypeFilter.GetSize(); i++)
            {
                if (dwNameType == m_arrayTypeFilter[i].dwType)
                {
                    m_arrayTypeFilter.RemoveAt(i);
                    break;
                }
            }
        }
        else
        {
            WinsMessageBox(WIN32_FROM_HRESULT(hr));
        }

        // move the focus
        m_listType.SetFocus();
        SetDefID(IDOK);
    }
}

void 
CFilterPage::FillTypeInfo() 
{
	m_listType.DeleteAllItems();

    SPITFSNode spNode;
    CString strDisplay;
    CStringMapEntry mapEntry;
	int nColWidth, nColWidthTemp = 0;

	nColWidth = m_listType.GetColumnWidth(0);

	for (int i = 0; i < m_pNameTypeMap->GetSize(); i++)
	{
        mapEntry = m_pNameTypeMap->GetAt(i);
		
		// only display the default name type mapping strings, not the special
		// ones based on the wins type of record
		if (mapEntry.dwWinsType == -1)
		{
			if (mapEntry.dwNameType == NAME_TYPE_OTHER)
			{
				strDisplay.Format(_T("%s"), mapEntry.st);
			}
			else
			{
				strDisplay.Format(_T("[%02Xh] %s"), mapEntry.dwNameType, mapEntry.st);
			}

			if (m_listType.GetStringWidth(strDisplay) > nColWidthTemp)
			{
				nColWidthTemp = m_listType.GetStringWidth(strDisplay);
			}

			int nIndex = m_listType.AddItem(strDisplay, i);
			m_listType.SetItemData(nIndex, mapEntry.dwNameType);
		}
	}

	// if the strings are too long, update the column width
	if (nColWidthTemp > nColWidth)
	{
		m_listType.SetColumnWidth(0, nColWidthTemp + 50);
	}


	CheckItems();

    m_listType.SortItems(FilterPageCompareFunc, 0);
}

void 
CFilterPage::CheckItems()
{
	int nCount = (int)m_arrayTypeFilter.GetSize();

	for (int i = 0; i < nCount; i++)
	{
		if (m_arrayTypeFilter[i].fShow)
		{
			DWORD dwFound = m_arrayTypeFilter[i].dwType;
	
			m_listType.CheckItem(GetIndex(dwFound));
		}
	}
}

void CFilterPage::OnButtonSelectAll() 
{
	for (int i = 0; i < m_listType.GetItemCount(); i++)
	{
		m_listType.SetCheck(i, TRUE);
	}
}

void CFilterPage::OnButtonUnselectAll() 
{
	for (int i = 0; i < m_listType.GetItemCount(); i++)
	{
		m_listType.SetCheck(i, FALSE);
	}
}

int
CFilterPage::GetIndex(DWORD dwIndex)
{
	int nResult = -1;

	int nCount = m_listType.GetItemCount();
	
	for (int i = 0; i < nCount; i++)
	{
		if (m_listType.GetItemData(i) == dwIndex)
			return i;
	}

	return nResult;
}

BOOL
CFilterPage::IsDefaultType(DWORD dwType) 
{
    BOOL bDefault = FALSE;

    for (int i = 0; i < DimensionOf(s_NameTypeMappingDefault); i++)
    {
        if (s_NameTypeMappingDefault[i][0] == dwType)
        {
            bDefault = TRUE;
            break;
        }
    }

    return bDefault;
}

BOOL CFilterPage::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	int		i;
	DWORD	dwCtrlId;

    if (pHelpInfo->iContextType == HELPINFO_WINDOW)
	{
		DWORD *	pdwHelp	= GetHelpMap();

        if (pdwHelp)
        {
			::WinHelp ((HWND)pHelpInfo->hItemHandle,
			           AfxGetApp()->m_pszHelpFilePath,
			           HELP_WM_HELP,
			           (ULONG_PTR)pdwHelp);
        }
	}
	
	return TRUE;
}
	

/////////////////////////////////////////////////////////////////////////////
// CNameTypeDlg dialog


CNameTypeDlg::CNameTypeDlg(CWnd* pParent /*=NULL*/)
	: CBaseDialog(CNameTypeDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CNameTypeDlg)
	m_strDescription = _T("");
	m_strId = _T("");
	//}}AFX_DATA_INIT

    m_fCreate = TRUE;
    m_dwId = 0;
}

void CNameTypeDlg::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNameTypeDlg)
	DDX_Control(pDX, IDC_EDIT_NAME_TYPE_DESCRIPTION, m_editDescription);
	DDX_Control(pDX, IDC_EDIT_NAME_TYPE_ID, m_editId);
	DDX_Text(pDX, IDC_EDIT_NAME_TYPE_DESCRIPTION, m_strDescription);
	DDX_Text(pDX, IDC_EDIT_NAME_TYPE_ID, m_strId);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNameTypeDlg, CBaseDialog)
	//{{AFX_MSG_MAP(CNameTypeDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNameTypeDlg message handlers

BOOL CNameTypeDlg::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (!m_fCreate)
    {
        CString strTitle;
        strTitle.LoadString(IDS_MODIFY_NAME_TYPE);

        SetWindowText(strTitle);

        m_editId.SetReadOnly(TRUE);

	    CString strId;

        strId.Format(_T("%lx"), m_dwId);
        m_editId.SetWindowText(strId);
    }

    m_editId.LimitText(2);
    m_editDescription.LimitText(STRING_LENGTH_MAX);

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CNameTypeDlg::OnOK() 
{
    UpdateData();
    
    TCHAR * pEnd;
    
    // convert the id
    m_dwId = _tcstol(m_strId, &pEnd, 16);
    if (*pEnd != NULL)
    {
        AfxMessageBox(IDS_ERR_INVALID_HEX_STRING);

        m_editId.SetSel(0, -1);
        m_editId.SetFocus();

        return;
    }

    if (m_fCreate && m_pNameTypeMap->EntryExists(m_dwId))
    {
        AfxMessageBox(IDS_ERROR_NAME_TYPE_EXISTS);
        m_editId.SetFocus();
        return;
    }

    CBaseDialog::OnOK();
}
/////////////////////////////////////////////////////////////////////////////
// CIPAddrPage property page

IMPLEMENT_DYNCREATE(CIPAddrPage, CPropertyPage)

CIPAddrPage::CIPAddrPage() : CPropertyPage(CIPAddrPage::IDD)
{
	//{{AFX_DATA_INIT(CIPAddrPage)
	//}}AFX_DATA_INIT
}

CIPAddrPage::~CIPAddrPage()
{
}

LPCOLESTR CIPAddrPage::GetNameForApi()
{
    return m_bFilterName == TRUE ? (LPCOLESTR)m_strName : NULL;
}

DWORD CIPAddrPage::GetIPMaskForFilter(UINT nMask)
{
    return m_bFilterIpMask == TRUE ? m_dwaIPMasks[nMask] : INADDR_BROADCAST;
}

void CIPAddrPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CIPAddrPage)
	DDX_Control(pDX, IDC_CHECK_MATCHCASE, m_ckbMatchCase);
	DDX_Control(pDX, IDC_CHECK_IPMASK, m_ckbIPMask);
	DDX_Control(pDX, IDC_CHECK_NAME, m_ckbName);
	DDX_Control(pDX, IDC_CHECK_IPADDR, m_ckbIPAddr);
	DDX_Control(pDX, IDC_ENABLE_CACHING, m_btnEnableCache);
	DDX_Control(pDX, IDC_EDIT_NAME, m_editName);
	DDX_Control(pDX, IDC_IPADDRESS, m_ctrlIPAddress);
	DDX_Control(pDX, IDC_SUBNETMASK, m_ctrlIPMask);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CIPAddrPage, CPropertyPage)
	//{{AFX_MSG_MAP(CIPAddrPage)
	ON_BN_CLICKED(IDC_CHECK_IPADDR, OnCheckIpaddr)
	ON_BN_CLICKED(IDC_CHECK_NAME, OnCheckName)
	ON_BN_CLICKED(IDC_ENABLE_CACHING, OnEnableCaching)
	ON_BN_CLICKED(IDC_CHECK_IPMASK, OnCheckIpmask)
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CIPAddrPage message handlers

void CIPAddrPage::OnOK() 
{
    DWORD   dwAddress, dwMask;
    CString oldName;
 
    CLoadRecords *pSheet = (CLoadRecords *)GetParent();
    pSheet->m_nActivePage = pSheet->GetActiveIndex();
    pSheet->m_bEnableCache = pSheet->m_bCaching;

    //------------check the name field--------------
    m_bFilterName = (m_ckbName.GetCheck() == 1);
    m_bMatchCase = (m_ckbMatchCase.GetCheck() == 1);
    // get a hand on the original name
    oldName = m_strName;
    // get the current name
    m_editName.GetWindowText(m_strName);
   
    if (!m_bDirtyName && !m_bFilterName)
        // if we didn't filter by name before and we don't now, the name is clean
        m_bDirtyName = FALSE;
    else if (m_bDirtyName && !m_bFilterName)
        // if we did filter before and we don't now, the name is dirty
        m_bDirtyName = TRUE;
    else if (!m_bDirtyName && m_bFilterName)
        // if we didn't filter before and we do now, the name is clean
        m_bDirtyName = FALSE;
    else
    {
        // we did filter by name before, we do now
        // the filter might have changed
        LPCTSTR pOldName, pNewName;

        // we should mark the name "dirty" only if the old prefix is included in the new one
        // meaning all new names should already be loaded in the database view since
        // they match the old prefix
        for (pOldName = (LPCTSTR)oldName, pNewName = (LPCTSTR)m_strName;
             *pNewName != _T('\0') && *pNewName != _T('*') && *pNewName != _T('?');
             pOldName++, pNewName++)
        {
            if (*pOldName != *pNewName)
                break;
        }
        m_bDirtyName = (*pOldName != _T('\0') &&
                        *pOldName != _T('*')  &&
                        *pOldName != _T('?'));
    }

    //------------check the IP address and mask fields--------------
    m_bFilterIpAddr = (m_ckbIPAddr.GetCheck() == 1);
    m_bFilterIpMask = (m_ckbIPMask.GetCheck() == 1);

    // get the current address and mask
    m_ctrlIPAddress.GetAddress(dwAddress);
    m_ctrlIPMask.GetAddress(dwMask);

    if (m_bDirtyAddr && m_bDirtyMask)
    {
        // we did have a mask before
        if (m_bFilterIpAddr && m_bFilterIpMask)
        {
            // we do have a mask now - if the new mask is less specific, => definitely dirty
            m_bDirtyMask = ((dwMask|m_dwaIPMasks[0])^dwMask) != 0;
        }
        else
        {
            // we don't have a mask now => 255.255.255.255 (which is assumed) is as specific
            // as possible => we do have the record we need already => definitely clean
            m_bDirtyMask = FALSE;
        }
    }
    else
    {
        // we didn't have a mask before => 255.255.255.255 was assumed = the most specific
        if (m_bFilterIpAddr && m_bFilterIpMask)
        {
            // we do have a mask now
            // the mask is dirty only if we actually did IP filtering before,
            // otherwise, all the records are already there, regardless their IPs
            m_bDirtyMask = m_bDirtyAddr && (dwMask != INADDR_BROADCAST);
        }
        else
        {
            // we don't have a mask now => nothing changed => definitely clean
            m_bDirtyMask = FALSE;
        }
    }

    if (m_bDirtyAddr)
    {
        // we did filter on IP address
        if (m_bFilterIpAddr)
        {
            // we do filter on IP address now
            // we need to see if the new Ip (or subnet address) has changed
            //DWORD dwNewSubnet, dwOldSubnet;

            //dwNewSubnet = m_bFilterIpMask ? dwAddress & dwMask : dwAddress;
            //dwOldSubnet = m_bDirtyMask ? m_dwaIPAddrs[0] & m_dwaIPMasks[0] : m_dwaIPAddrs[0];
            m_bDirtyAddr = (dwAddress != m_dwaIPAddrs[0]);
        }
        else
        {
            // we don't filter on IP address now => definitely dirty
            m_bDirtyAddr = TRUE;
        }
    }
    else
    {
        // we didn't filter on IP address originally => we have all records => definitely clean
        m_bDirtyAddr = FALSE;
    }

    // save the current address but only if there is one! The ip ctrl could very well be empty and we
    // risk to see this as 0.0.0.0 which would be wrong
    m_dwaIPAddrs.RemoveAll();
    if (!m_ctrlIPAddress.IsBlank())
        m_dwaIPAddrs.Add(dwAddress);

    // save the current mask but only if there is one! The ip ctrl could very well be empty and we
    // risk to see this as 0.0.0.0 which would be wrong
    m_dwaIPMasks.RemoveAll();
    if (!m_ctrlIPMask.IsBlank())
        m_dwaIPMasks.Add(dwMask);

	CPropertyPage::OnOK();
}

BOOL CIPAddrPage::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();

    // turn on the ? in the title bar
    CWnd * pWnd = GetParent();
    if (pWnd)
    {
        CWnd * pButton = pWnd->GetDlgItem(IDOK);

        if (pButton)
        {
            CString strText;
            strText.LoadString(IDS_FIND_NOW);
            pButton->SetWindowText(strText);
        }

        pWnd->ModifyStyleEx(0, WS_EX_CONTEXTHELP, 0);
    }

    SetModified();

    // just save the previous "filter by name" bit
    m_bDirtyName = m_bFilterName;
    m_ckbName.SetCheck(m_bFilterName);
    m_ckbMatchCase.SetCheck(m_bMatchCase);
    m_ckbMatchCase.EnableWindow(m_bFilterName);
    m_editName.SetWindowText(m_strName);
    m_editName.EnableWindow(m_bFilterName);

    // just save the previous "filter by ip" bit
    m_bDirtyAddr = m_bFilterIpAddr;
    m_ckbIPAddr.SetCheck(m_bFilterIpAddr);
    if (m_dwaIPAddrs.GetSize() != 0)
        m_ctrlIPAddress.SetAddress(m_dwaIPAddrs[0]);
    m_ctrlIPAddress.EnableWindow(m_bFilterIpAddr);
    m_ckbIPMask.EnableWindow(m_bFilterIpAddr);

    // just save the previous "filter by subnet" bit
    m_bDirtyMask = m_bFilterIpMask;
    m_ckbIPMask.SetCheck(m_bFilterIpMask);
    if (m_dwaIPMasks.GetSize() != 0)
        m_ctrlIPMask.SetAddress(m_dwaIPMasks[0]);
    m_ctrlIPMask.EnableWindow(m_bFilterIpAddr && m_bFilterIpMask);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CIPAddrPage::OnCheckIpaddr() 
{
    BOOL bFIpAddr = (m_ckbIPAddr.GetCheck() == 1);
    BOOL bFIpMask = (m_ckbIPMask.GetCheck() == 1);

    m_ctrlIPAddress.EnableWindow(bFIpAddr);
    m_ckbIPMask.EnableWindow(bFIpAddr);
    m_ctrlIPMask.EnableWindow(bFIpAddr && bFIpMask);
    m_ctrlIPAddress.SetFieldFocus((WORD)-1);
}

void CIPAddrPage::OnCheckIpmask() 
{
    BOOL bFIpMask = (m_ckbIPMask.GetCheck() == 1);
    m_ctrlIPMask.EnableWindow(bFIpMask);
    m_ctrlIPMask.SetFieldFocus((WORD)-1);    
}

void CIPAddrPage::OnCheckName() 
{
    TCHAR pName[3];
    BOOL bFName = (m_ckbName.GetCheck() == 1);
    CLoadRecords *pParent = (CLoadRecords *)GetParent();
    m_editName.EnableWindow(bFName);
    m_ckbMatchCase.EnableWindow(bFName);
}

BOOL CIPAddrPage::OnKillActive() 
{
    BOOL bFName = (m_ckbName.GetCheck() == 1);
    BOOL bFIpAddr = (m_ckbIPAddr.GetCheck() == 1);
    BOOL bFIpMask = (m_ckbIPMask.GetCheck() == 1);

    if (bFName && m_editName.GetWindowTextLength()==0)
    {
        WinsMessageBox(IDS_ERR_NO_NAME);
        return FALSE;
    }

    if (bFIpAddr && m_ctrlIPAddress.IsBlank())
    {
        WinsMessageBox(IDS_ERR_NO_IPADDR);
        return FALSE;
    }

    if (bFIpAddr && bFIpMask)
    {
        if (m_ctrlIPMask.IsBlank())
        {
            WinsMessageBox(IDS_ERR_NO_IPMASK);
            return FALSE;
        }
        else
        {
            DWORD dwMask;

            m_ctrlIPMask.GetAddress(dwMask);
            if (dwMask != ~(((dwMask-1)|dwMask)^dwMask))
            {
                WinsMessageBox(IDS_ERR_INVALID_IPMASK);
                return FALSE;
            }
        }
    }

	return CPropertyPage::OnKillActive();
}

BOOL CIPAddrPage::OnSetActive() 
{
    CLoadRecords *pParent = (CLoadRecords *)GetParent();
    m_btnEnableCache.SetCheck(pParent->m_bCaching);
	return CPropertyPage::OnSetActive();
}

void CIPAddrPage::OnEnableCaching() 
{
    CLoadRecords *pParent = (CLoadRecords *)GetParent();
    pParent->m_bCaching = (m_btnEnableCache.GetCheck() == 1);
}

BOOL CIPAddrPage::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	int		i;
	DWORD	dwCtrlId;

    if (pHelpInfo->iContextType == HELPINFO_WINDOW)
	{
		DWORD *	pdwHelp	= GetHelpMap();

        if (pdwHelp)
        {
			::WinHelp ((HWND)pHelpInfo->hItemHandle,
			           AfxGetApp()->m_pszHelpFilePath,
			           HELP_WM_HELP,
			           (ULONG_PTR)pdwHelp);
        }
	}
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\ipnamepr.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	ipnamepr.h
		Ip name pair (name/ip) class
		
    FILE HISTORY:
        
*/

#ifndef _IPNAMEPR_H
#define _IPNAMEPR_H

#ifndef _IPADDRES_H
#include "ipaddres.h"
#endif

class CIpNamePair : public CObjectPlus
{
public:
    CIpNamePair();
    CIpNamePair(const CIpAddress& ia, const CString& str);
    CIpNamePair(const CIpNamePair& inpAddress);

public:
    int Compare(const CIpNamePair& inpTarget, BOOL fBoth) const;
    CIpNamePair & operator=(const CIpNamePair& inpNew)
    {
        m_iaIpAddress = inpNew.m_iaIpAddress;
        m_strNetBIOSName = inpNew.m_strNetBIOSName;
        return *this;
    }
    inline CIpAddress QueryIpAddress() const
    {
        return m_iaIpAddress;
    }
    inline virtual CIpAddress& GetIpAddress()
    {
        return m_iaIpAddress;
    }
    inline virtual void SetIpAddress(CIpAddress& ip)
    {
        m_iaIpAddress = ip;
    }
    inline virtual void SetIpAddress(long ip)
    {
        m_iaIpAddress = ip;
    }
    inline virtual void SetIpAddress(CString& str)
    {
        m_iaIpAddress = str;
    }
    inline CString& GetNetBIOSName()
    {
        return m_strNetBIOSName;
    }
    inline void SetNetBIOSName(CString& str)
    {
        m_strNetBIOSName = str;
    }
    inline int GetNetBIOSNameLength()
    {
        return m_nNameLength;
    }
    inline void SetNetBIOSNameLength(int nLength)
    {
        m_nNameLength = nLength;
    }

    int OrderByName ( const CObjectPlus * pobMapping ) const ;
    int OrderByIp ( const CObjectPlus * pobMapping ) const ;

protected:
    CIpAddress m_iaIpAddress;
    CString m_strNetBIOSName;
    int m_nNameLength;
};



class CWinsServerObj : public CIpNamePair
{
public:
    CWinsServerObj();

    CWinsServerObj(
        const CIpAddress& ia, 
        const CString& str, 
        BOOL fPush = FALSE, 
        BOOL fPull = FALSE,
        CIntlNumber inPushUpdateCount = 0,
        CIntlNumber inPullReplicationInterval = 0,
        CIntlTime   itmPullStartTime = (time_t)0
        );

    CWinsServerObj(
        const CIpNamePair& inpAddress, 
        BOOL fPush = FALSE, 
        BOOL fPull = FALSE,
        CIntlNumber inPushUpdateCount = 0,
        CIntlNumber inPullReplicationInterval = 0,
        CIntlTime   itmPullStartTime = (time_t)0
        );
    CWinsServerObj(const CWinsServerObj& wsServer);

public:
    CWinsServerObj & operator=(const CWinsServerObj& wsNew);

public:
    inline const BOOL IsPush() const
    {
        return m_fPush;
    }
    inline const BOOL IsPull() const
    {
        return m_fPull;
    }
    void SetPush(BOOL fPush = TRUE, BOOL fClean = FALSE)
    {
        m_fPush = fPush;
        if (fClean)
        {
            m_fPushInitially = fPush;
        }
    }
    void SetPull(BOOL fPull = TRUE, BOOL fClean = FALSE)
    {
        m_fPull = fPull;
        if (fClean)
        {
            m_fPullInitially = fPull;
        }
    }

    inline BOOL IsClean() const
    {
        return m_fPullInitially == m_fPull 
            && m_fPushInitially == m_fPush;
    }

    inline void SetPullClean(BOOL fClean = TRUE)
    {
        m_fPullInitially = m_fPull;
    }

    inline void SetPrimaryIpAddress(const CIpAddress ia)
    {
        m_iaPrimaryAddress = ia;
    }

    inline CIpAddress QueryPrimaryIpAddress() const
    {
        return m_iaPrimaryAddress;
    }

    void SetPushClean(BOOL fClean = TRUE)
    {
        m_fPushInitially = m_fPush;
    }

    inline CIntlNumber& GetPushUpdateCount()
    {
        return m_inPushUpdateCount;
    }

    inline void SetPushUpdateCount(LONG lUpdateCount)
    {
        m_inPushUpdateCount = lUpdateCount;
    }

    inline CIntlNumber& GetPullReplicationInterval()
    {
        return m_inPullReplicationInterval;
    }

    inline void SetPullReplicationInterval(LONG lPullTimeInterval)
    {
        m_inPullReplicationInterval = lPullTimeInterval;
    }

    inline CIntlTime& GetPullStartTime()
    {
        return m_itmPullStartTime;
    }

    inline void SetPullStartTime(LONG lSpTime)
    {
        m_itmPullStartTime = lSpTime;
    }

    CString& GetstrIPAddress()
	{
		return m_strIPAddress;
	}

	void SetstrIPAddress(CString &strIP)
	{
		m_strIPAddress = strIP;
	}

	BOOL GetPullPersistence()
	{
		return m_fPullPersistence;
	}

	void SetPullPersistence(BOOL bValue)
	{
		m_fPullPersistence = bValue;
	}

	BOOL GetPushPersistence()
	{
		return m_fPushPersistence;
	}

	void SetPushPersistence(BOOL bValue)
	{
		m_fPushPersistence = bValue;
	}
	
private:
    CIntlNumber m_inPushUpdateCount;    // 0 means not specified.
    CIntlNumber m_inPullReplicationInterval; // 0 means not specified
    CIntlTime   m_itmPullStartTime;     // 0 means no time selected.
    BOOL m_fPull;
    BOOL m_fPush;
    //
    // Change flags
    //
    BOOL m_fPullInitially;              
    BOOL m_fPushInitially;
    CIpAddress m_iaPrimaryAddress;
	CString m_strIPAddress;

	// For persistence connection
	BOOL m_fPushPersistence;
	BOOL m_fPullPersistence;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\multip.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 -99             **/
/**********************************************************************/

/*
    multip.cpp
        Comment goes here

    FILE HISTORY:

*/

#include "stdafx.h"
#include "multip.h"

CMultipleIpNamePair::CMultipleIpNamePair()
    : CIpNamePair()
{
    m_nCount = 0;
}

CMultipleIpNamePair::CMultipleIpNamePair(
    const CMultipleIpNamePair& pair
    )
    : CIpNamePair(pair)
{
    m_nCount = pair.m_nCount;

    for (int i = 0; i < WINSINTF_MAX_MEM; ++i)
    {
        m_iaIpAddress[i] = pair.m_iaIpAddress[i];
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\memmngr.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	memmngr.cpp	
		memory manager for the WINS db object

	FILE HISTORY:
    Oct 13  1997    EricDav     Created        

*/

#ifndef _MEMMNGR_H
#define _MEMMNGR_H

#include "afxmt.h"

// the format of the record name is as follows:
// Byte     Description
// 0 - 15   are for the name
// 16       reserved, must be 0
// 17       internal flags, the two low bits store the RECTYPE
//          defined in WINSINTF_RECTYPE_E
//          The upper 4 bits are reserved for internal use
// 18       WINS flags (active, static, tombstoned)
// 19       NameLength
// 20		Static Record Type, WINSDB_UNIQUe etc
// byte 15 is assumed to be the type 

typedef enum _WINSDB_INTERNAL
{
    WINSDB_INTERNAL_LONG_NAME = 0x40,
    WINSDB_INTERNAL_DELETED = 0x80
} WINSDB_INTERNAL;

typedef struct _WinsDBRecord
{
	char					szRecordName [21];	
	DWORD					dwExpiration;						
	DWORD_PTR				dwIpAdd;			
	LARGE_INTEGER			liVersion;	
	DWORD					dwOwner;	
} WinsDBRecord, * LPWINSDBRECORD;

#define IS_WINREC_LONGNAME(wRecord) ((wRecord)->dwNameLen > 16)
#define IS_DBREC_LONGNAME(wdbRecord) ((wdbRecord)->szRecordName[17] & WINSDB_INTERNAL_LONG_NAME)

#define RECORDS_PER_BLOCK	4080
#define RECORD_SIZE		    sizeof(WinsDBRecord)		// bytes
#define BLOCK_SIZE		    RECORDS_PER_BLOCK * RECORD_SIZE

typedef CArray<HGLOBAL, HGLOBAL>	BlockArray;

class CMemoryManager
{
public:
	CMemoryManager();
	~CMemoryManager();
	
private:
	BlockArray		m_BlockArray;

public:
	BlockArray*	GetBlockArray()
	{
		return &m_BlockArray;
	};

    // Free's up all memory and pre-allocates one block
    HRESULT Initialize();

    // Free's up all memory
    HRESULT Reset();
    
    // verifies the given HROW is valid
    BOOL    IsValidHRow(HROW hrow);
	
    // allocates a new block of memory
    HRESULT Allocate();
	
    // adds the record in the internal structure format
	HRESULT AddData(const WinsRecord & wRecord, LPHROW phrow);
    HRESULT GetData(HROW hrow, LPWINSRECORD pWinsRecord);
    HRESULT Delete(HROW hrow);

private:
    LPWINSDBRECORD      m_hrowCurrent;
	CCriticalSection	m_cs;
    HANDLE              m_hHeap;
};

extern void WinsRecordToWinsDbRecord(HANDLE hHeap, const WinsRecord & wRecord, const LPWINSDBRECORD pRec);
extern void WinsDbRecordToWinsRecord(const LPWINSDBRECORD pDbRec, LPWINSRECORD pWRec);

#endif //_MEMMNGR__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\multip.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	multip.h
		
    FILE HISTORY:
        
*/

#ifndef _MULTIP_H
#define _MULTIP_H

class CMultipleIpNamePair : public CIpNamePair
{
public:
    CMultipleIpNamePair();
    CMultipleIpNamePair(const CMultipleIpNamePair& pair);

public:
    inline virtual CIpAddress& GetIpAddress()
    {
        return m_iaIpAddress[0];
    }
    inline virtual CIpAddress& GetIpAddress(int n)
    {
        ASSERT(n >= 0 && n < WINSINTF_MAX_MEM);
        return m_iaIpAddress[n];
    }
    inline virtual void SetIpAddress(CIpAddress& ip)
    {
        m_iaIpAddress[0] = ip;
    }
    inline virtual void SetIpAddress(long ip)
    {
        m_iaIpAddress[0] = ip;
    }
    inline virtual void SetIpAddress(CString& str)
    {
        m_iaIpAddress[0] = str;
    }
    inline virtual void SetIpAddress(int n, CIpAddress& ip)
    {
        ASSERT(n >= 0 && n < WINSINTF_MAX_MEM);
        m_iaIpAddress[n] = ip;
    }
    inline virtual void SetIpAddress(int n, long ip)
    {
        ASSERT(n >= 0 && n < WINSINTF_MAX_MEM);
        m_iaIpAddress[n] = ip;
    }
    inline virtual void SetIpAddress(int n, CString& str)
    {
        ASSERT(n >= 0 && n < WINSINTF_MAX_MEM);
        m_iaIpAddress[n] = str;
    }
    inline const int GetCount() const
    {
        return m_nCount;
    }
    inline void SetCount(int n)
    {
        ASSERT(n >= 0 && n <= WINSINTF_MAX_MEM);
        m_nCount = n;
    }

protected:
    int m_nCount;
    CIpAddress m_iaIpAddress[WINSINTF_MAX_MEM];
};

#endif //_MULTIP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\memmngr.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	memmngr.cpp	
		memory manager for the WINS db object

	FILE HISTORY:
    Oct 13  1997    EricDav     Modifed

*/

#include "stdafx.h"
#include "wins.h"
#include "memmngr.h"

CMemoryManager::CMemoryManager()
{
    m_hHeap = NULL;
}

CMemoryManager::~CMemoryManager()
{
    Reset();
}
	
/*!--------------------------------------------------------------------------
	CMemoryManager::Initialize
		Initializes the memory manager to free up and existing blocks
        and pre-allocate one block
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT
CMemoryManager::Initialize()
{
    HRESULT hr = hrOK;

    CORg (Reset());
    CORg (Allocate());

    // create a heap for allocation of the multiple IP address blocks
    m_hHeap = HeapCreate(0, 4096, 0);
    if (m_hHeap == NULL)
    {
        Trace1("CMemoryManager::Initialize - HeapCreate failed! %d\n", GetLastError());
        return E_FAIL;
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CMemoryManager::Reset
		Free's up all memory
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT
CMemoryManager::Reset()
{
	// free the memory allocated
	for (int i = 0; i< m_BlockArray.GetSize(); i++)
	{
		::GlobalFree(m_BlockArray.GetAt(i));
	}
	
	m_BlockArray.RemoveAll();

    if (m_hHeap)
    {
        HeapDestroy(m_hHeap);
        m_hHeap = NULL;
    }

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CMemoryManager::Allocate
		Allocates one memory block
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT
CMemoryManager::Allocate()
{
    HGLOBAL hMem = GlobalAlloc(GMEM_FIXED, BLOCK_SIZE);
	
	if (hMem != NULL)
	{
		m_hrowCurrent = (LPWINSDBRECORD) hMem;
		m_BlockArray.Add(hMem);

        return hrOK;
	}

	return E_FAIL;
}

/*!--------------------------------------------------------------------------
	CMemoryManager::IsvalidHRow
		Verifies that the given HROW is valid
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
BOOL 
CMemoryManager::IsValidHRow(HROW hrow)
{
	// check to see thet this HROW lies between the 
	// limits, i.e b/n hMem and hMem + INIT_SIZE
	for (int i = 0; i < m_BlockArray.GetSize(); i++)
	{
		if (hrow >= (HROW)(m_BlockArray.GetAt(i)) && (hrow < (HROW)(m_BlockArray.GetAt(i)) + BLOCK_SIZE))
		    return TRUE;
	}

	return FALSE;
}

/*!--------------------------------------------------------------------------
	CMemoryManager::AddData
		Copies a record into our internal store
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT
CMemoryManager::AddData(const WinsRecord & wRecord, LPHROW phrow)
{
    HRESULT hr = hrOK;

	CSingleLock     cLock(&m_cs);
	cLock.Lock();

    Assert((BYTE) wRecord.szRecordName[15] == (BYTE) wRecord.dwType);

    // check if for the validity fo the current 
	// m_hrowCurrent
	if (!IsValidHRow((HROW) m_hrowCurrent))
	{
		Allocate();
		m_hrowCurrent = (LPWINSDBRECORD) (m_BlockArray.GetAt(m_BlockArray.GetSize() - 1));
	}

    WinsRecordToWinsDbRecord(m_hHeap, wRecord, m_hrowCurrent);

    if (phrow)
        *phrow = (HROW) m_hrowCurrent;	
	
    // move our pointer to the next record
    m_hrowCurrent++;

	return hr;
}

/*!--------------------------------------------------------------------------
	CMemoryManager::GetData
		Copies a record into our internal store
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT
CMemoryManager::GetData(HROW hrow, LPWINSRECORD pWinsRecord)
{
    HRESULT hr = hrOK;
    LPWINSDBRECORD pDbRec = (LPWINSDBRECORD) hrow;

	CSingleLock     cLock(&m_cs);
	cLock.Lock();

    // check if for the validity fo the current 
	// m_hrowCurrent
	if (!IsValidHRow(hrow))
	{
        return E_FAIL;
    }

    WinsDbRecordToWinsRecord(pDbRec, pWinsRecord);

	return hr;
}

/*!--------------------------------------------------------------------------
	CMemoryManager::Delete
		Marks a record as deleted
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CMemoryManager::Delete(HROW hrow)
{
    HRESULT hr = hrOK;

	CSingleLock     cLock(&m_cs);
	cLock.Lock();

    LPWINSDBRECORD pRec = (LPWINSDBRECORD) hrow;

    pRec->szRecordName[17] |= WINSDB_INTERNAL_DELETED;

    return hr;
}

void
WinsRecordToWinsDbRecord(HANDLE hHeap, const WinsRecord & wRecord, const LPWINSDBRECORD pRec)
{
    ZeroMemory(pRec, sizeof(WinsDBRecord));

    // fill in our internal struct, first the name
    if (IS_WINREC_LONGNAME(&wRecord))
    {
        // name is too long for our internal struct, allocate space off of our heap
        // this shouldn't happen very often.  Only for scoped names.
        pRec->szRecordName[17] |= WINSDB_INTERNAL_LONG_NAME;
        char * pName = (char *) ::HeapAlloc(hHeap, HEAP_ZERO_MEMORY, (wRecord.dwNameLen + 1));
        if (pName)
        {
            memcpy(pName, &wRecord.szRecordName[0], wRecord.dwNameLen);
            memcpy(&pRec->szRecordName[0], &pName, sizeof(char *));
        }
    }
    else
    {
        memcpy(&pRec->szRecordName[0], &wRecord.szRecordName[0], 16);
    }

    pRec->dwExpiration = (DWORD) wRecord.dwExpiration;
    pRec->liVersion.QuadPart = wRecord.liVersion.QuadPart;
    pRec->dwOwner = wRecord.dwOwner;

    // max length is 255, so this is OK
    pRec->szRecordName[19] = LOBYTE(LOWORD(wRecord.dwNameLen));

	BYTE bTest = HIBYTE(LOWORD(wRecord.dwState));

	pRec->szRecordName[20] = HIBYTE(LOWORD(wRecord.dwState));

    // only the low byte of the dwState field is used
    pRec->szRecordName[18] = (BYTE) wRecord.dwState;
    pRec->szRecordName[17] |= HIWORD (wRecord.dwType);

    // now figure out how many IP addrs there are
    if (wRecord.dwNoOfAddrs > 1)
    {
        Assert(hHeap);
        LPDWORD pdwIpAddrs = (LPDWORD) ::HeapAlloc(hHeap, HEAP_ZERO_MEMORY, (wRecord.dwNoOfAddrs + 1) * sizeof(DWORD));

        if (pdwIpAddrs)
        {
            // first DWORD contains the # of addrs
            pdwIpAddrs[0] = wRecord.dwNoOfAddrs;
            for (UINT i = 0; i < wRecord.dwNoOfAddrs; i++)
                pdwIpAddrs[i+1] = wRecord.dwIpAdd[i];

            // now store our pointer off
            pRec->dwIpAdd = (DWORD_PTR) pdwIpAddrs;
        }
    }
    else
    {
        pRec->dwIpAdd = wRecord.dwIpAdd[0];
    }

    Assert((BYTE) pRec->szRecordName[16] == NULL);
}

void 
WinsDbRecordToWinsRecord(const LPWINSDBRECORD pDbRec, LPWINSRECORD pWRec)
{
    Assert((BYTE) pDbRec->szRecordName[16] == NULL);

    ZeroMemory(pWRec, sizeof(WinsRecord));
    DWORD dwType = 0;

	size_t length = pDbRec->szRecordName[19] & 0x000000FF;

    // fill in our internal struct, name first
    if (IS_DBREC_LONGNAME(pDbRec))
    {
        char * pName = *((char **) pDbRec->szRecordName);

        memcpy(&pWRec->szRecordName[0], pName, length);
        dwType = (DWORD) pName[15];
    }
    else
    {
        memcpy(&pWRec->szRecordName[0], &pDbRec->szRecordName[0], 16);
        dwType = (DWORD) pWRec->szRecordName[15];
    }

    pWRec->dwExpiration = pDbRec->dwExpiration;
    pWRec->liVersion.QuadPart = pDbRec->liVersion.QuadPart;
    pWRec->dwOwner = pDbRec->dwOwner;
    pWRec->dwNameLen = length;
    
	WORD wState = MAKEWORD(pDbRec->szRecordName[18], pDbRec->szRecordName[20]);
	pWRec->dwState = wState;

	//pWRec->dwState = pDbRec->szRecordName[18];

    pWRec->dwType = pDbRec->szRecordName[17] & 0x03;
    pWRec->dwType = pWRec->dwType << 16;

    pWRec->dwType |= dwType;

    // now the ip address(es)
    if (pWRec->dwState & (BYTE) WINSDB_REC_MULT_ADDRS)
    {
        LPDWORD pdwIpAddrs = (LPDWORD) pDbRec->dwIpAdd;
        
        // the first DWORD is the count
        int nCount = pdwIpAddrs[0];
        for (int i = 0; i < nCount; i++)
            pWRec->dwIpAdd[i] = pdwIpAddrs[i+1];

        pWRec->dwNoOfAddrs = (DWORD) nCount;
    }
    else
    {
        pWRec->dwIpAdd[0] = (DWORD) pDbRec->dwIpAdd;
        pWRec->dwNoOfAddrs = 1;
    }
 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\nodes.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	nodes.h
		result pane node definitions
		
    FILE HISTORY:
        
*/

#ifndef _NODES_H
#define _NODES_H

#ifndef _WINSHAND_H
#include "winshand.h"
#endif

#ifndef _SERVER_H
#include "server.h"
#endif

class CReplicationPartner : public CWinsHandler
{
public:
	CReplicationPartner(ITFSComponentData * pTFSCompData, CWinsServerObj *pobj);
	~CReplicationPartner(){	};

// Interface
public:
	// Result handler functionality
	OVERRIDE_ResultHandler_HasPropertyPages() { return hrOK; }
	OVERRIDE_ResultHandler_CreatePropertyPages();
	OVERRIDE_ResultHandler_AddMenuItems();
	OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_GetString();

	 // base result handler overrides
	OVERRIDE_BaseResultHandlerNotify_OnResultPropertyChange();
	
	// Implementation
public:
	// CWinsHandler overrides
	virtual HRESULT InitializeNode(ITFSNode * pNode);

	// Get/Set Functions
	const CString &GetServerName()
	{
		return m_strServerName;
	}

	void SetRecordName(CString& strName)
	{
		m_strServerName = strName;
	}

	const CString &GetType()
	{
		return m_strType;
	}

	void SetType(CString &strType)
	{
		m_strType = strType;
	}

	const CString &GetIPAddress()
	{
		return m_strIPAddress;
	}

	void SetIPAddress(CString& strName)
	{
		m_strIPAddress = strName;
	}

	const CString &GetReplicationTime()
	{
		return m_strReplicationTime;
	}

	void SetReplicationTime(CString& strName)
	{
		m_strReplicationTime = strName;
	}

	CWinsServerObj	m_Server;
	
private:
	CString			m_strServerName;
	CString			m_strType;
	CString			m_strIPAddress;
	CString			m_strReplicationTime;
	
	// info from the Wins Record Object
	DWORD			m_dwIPAddress;
	DWORD			m_dwReplicationTime;
	
	// functions 
	CString ToIPAddressString();
	HRESULT OnSendPushTrigger(CWinsServerHandler *pServer);
	HRESULT OnSendPullTrigger(CWinsServerHandler *pServer);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\nodes.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	nodes.cpp
		Replication partner leaf node

	FILE HISTORY:
        
*/

#include "stdafx.h"
#include "nodes.h"

#include "repprtpp.h"
#include "pushtrig.h"
#include "fndrcdlg.h"
#include "resource.h"

CString g_strPartnerTypePushPull;
CString g_strPartnerTypePush;
CString g_strPartnerTypePull;
CString g_strPartnerTypeUnknown;

CReplicationPartner::CReplicationPartner(
											ITFSComponentData *pCompData,
											CWinsServerObj *pObj
										):	CWinsHandler(pCompData),
											m_strServerName(pObj->GetNetBIOSName()),
											m_strIPAddress(pObj->GetstrIPAddress())
{
	m_bExpanded = FALSE;
	m_Server = *pObj;
	m_nState = loaded;
    m_verbDefault = MMC_VERB_PROPERTIES;

    if (g_strPartnerTypePushPull.IsEmpty())
    {
        g_strPartnerTypePushPull.LoadString(IDS_PUSHPULL);
        g_strPartnerTypePush.LoadString(IDS_PUSH);
        g_strPartnerTypePull.LoadString(IDS_PULL);
        g_strPartnerTypeUnknown.LoadString(IDS_NONE);
    }
}


HRESULT
CReplicationPartner::InitializeNode
(
	ITFSNode * pNode
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	SetDisplayName(m_strServerName);

	if (m_Server.IsPull() && m_Server.IsPush())
		m_strType = g_strPartnerTypePushPull;
	else if(m_Server.IsPull() && !m_Server.IsPush())
		m_strType = g_strPartnerTypePull;
	else if(!m_Server.IsPull() && m_Server.IsPush())
		m_strType = g_strPartnerTypePush;
	else
		m_strType = g_strPartnerTypeUnknown;

	// Make the node immediately visible
	pNode->SetVisibilityState(TFS_VIS_SHOW);
	pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
	pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, WINSSNAP_REPLICATION_PARTNER);
	pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_PARTNER);
	pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_PARTNER);

	SetColumnStringIDs(&aColumns[WINSSNAP_REPLICATION_PARTNER][0]);
	SetColumnWidths(&aColumnWidths[WINSSNAP_REPLICATION_PARTNER][0]);
	
	return hrOK;
}


/*!--------------------------------------------------------------------------
	CActiveRegistration::AddMenuItems
		Implementation of ITFSResultHandler::AddMenuItems
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CReplicationPartner::AddMenuItems
(
	ITFSComponent *         pComponent, 
	MMC_COOKIE  			cookie,
	LPDATAOBJECT			pDataObject, 
	LPCONTEXTMENUCALLBACK	pContextMenuCallback, 
	long *					pInsertionAllowed
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr;

	CString strMenuItem;
    BOOL bEnablePush, bEnablePull;

    bEnablePush = bEnablePull = FALSE;

    if (m_strType.Compare(g_strPartnerTypePushPull) == 0)
    {
        bEnablePush = bEnablePull = TRUE;
    }
    else 
    if (m_strType.Compare(g_strPartnerTypePush) == 0)
    {
        bEnablePush = TRUE;
    }
    else 
    if (m_strType.Compare(g_strPartnerTypePull) == 0)
    {
        bEnablePull = TRUE;
    }

	// these menu items go in the new menu, 
	// only visible from scope pane

    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
    {
        if (bEnablePush)
        {
	        strMenuItem.LoadString(IDS_REP_SEND_PUSH_TRIGGER);
	        hr = LoadAndAddMenuItem( pContextMenuCallback, 
							         strMenuItem, 
							         IDS_REP_SEND_PUSH_TRIGGER,
							         CCM_INSERTIONPOINTID_PRIMARY_TOP, 
							         0 );
    	    ASSERT( SUCCEEDED(hr) );
        }

	    if (bEnablePull)
        {
            strMenuItem.LoadString(IDS_REP_SEND_PULL_TRIGGER);
	        hr = LoadAndAddMenuItem( pContextMenuCallback, 
							         strMenuItem, 
							         IDS_REP_SEND_PULL_TRIGGER,
							         CCM_INSERTIONPOINTID_PRIMARY_TOP, 
							         0 );
	        ASSERT( SUCCEEDED(hr) );
        }
    }

	return hrOK;    
}



/*---------------------------------------------------------------------------
	Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	CActiveRegistration::GetString
		Implementation of ITFSNodeHandler::GetString
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) 
CReplicationPartner::GetString
(
	ITFSComponent * pComponent,	
	MMC_COOKIE		cookie,
	int				nCol
)
{
	if (nCol == 0 || nCol == -1)
		return GetDisplayName();
	switch(nCol)
	{
	case -1:
	case 0:
		return GetDisplayName();
	case 1:
		return	m_strIPAddress;
	case 2:
		return m_strType;
	case 3:
		return m_strReplicationTime;
	default:
		return NULL;
	}
}


/*---------------------------------------------------------------------------
	CReplicationPartner::Command
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CReplicationPartner::Command
(
    ITFSComponent * pComponent, 
	MMC_COOKIE		cookie, 
	int				nCommandID,
	LPDATAOBJECT	pDataObject
)
{
	HRESULT hr;

	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	SPITFSNode spNode;
	m_spNodeMgr->FindNode(cookie, &spNode);

	// get the server node now
	SPITFSNode spRepNode, spServerNode;
	spNode->GetParent(&spRepNode);
    spRepNode->GetParent(&spServerNode);

	CWinsServerHandler *pServer = GETHANDLER(CWinsServerHandler, spServerNode);
	
	//
	// Object gets deleted when the page is destroyed
	//
	switch (nCommandID)
	{
	    case IDS_REP_SEND_PUSH_TRIGGER:
		    hr = OnSendPushTrigger(pServer);
		    break;

	    case IDS_REP_SEND_PULL_TRIGGER:
		    hr = OnSendPullTrigger(pServer);
		    break;

	    default:
		    break;
	}

    return hr;
}


/*---------------------------------------------------------------------------
	CActiveRegistration::CreatePropertyPages
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CReplicationPartner::CreatePropertyPages
(	
	ITFSComponent *			pComponent, 
	MMC_COOKIE				cookie, 
	LPPROPERTYSHEETCALLBACK	lpProvider, 
	LPDATAOBJECT			pDataObject, 
	LONG_PTR					handle
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = hrOK;

	SPITFSNode spNode;
	m_spNodeMgr->FindNode(cookie, &spNode);

	//
	// Object gets deleted when the page is destroyed
	//
	SPIComponentData spComponentData;
	m_spNodeMgr->GetComponentData(&spComponentData);

	CReplicationPartnerProperties * pProp = 
		new CReplicationPartnerProperties(spNode, spComponentData, m_spTFSCompData, NULL);
	pProp->m_pageGeneral.m_uImage = (UINT) spNode->GetData(TFS_DATA_IMAGEINDEX);
    pProp->SetServer(&m_Server);

	Assert(lpProvider != NULL);

	return pProp->CreateModelessSheet(lpProvider, handle);
}


/*---------------------------------------------------------------------------
	Command handlers
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
	CReplicationPartner::ToIPAddressString()
		Returns a CString IP address
 ---------------------------------------------------------------------------*/
CString 
CReplicationPartner::ToIPAddressString()
{
	CString strIP;

	DWORD dwFirst = GETIP_FIRST(m_dwIPAddress);
	DWORD dwSecond = GETIP_SECOND(m_dwIPAddress);
	DWORD dwThird = GETIP_THIRD(m_dwIPAddress);
	DWORD dwLast = GETIP_FOURTH(m_dwIPAddress);

	// wrap it into CString object
	TCHAR szStr[20];

	_itot(dwFirst, szStr, 10);
	CString strTemp(szStr);
	strIP = strTemp + _T(".");

	_itot(dwSecond, szStr, 10);
	strTemp = (CString)szStr;
	strIP += strTemp + _T(".");

	_itot(dwThird, szStr, 10);
	strTemp = (CString)szStr;
	strIP += strTemp + _T(".");

	_itot(dwLast, szStr, 10);
	strTemp = (CString)szStr;
	strIP += strTemp;

	return strIP;
}


/*---------------------------------------------------------------------------
	CReplicationPartner::OnResultPropertyChange
		Base class override
 ---------------------------------------------------------------------------*/
HRESULT 
CReplicationPartner::OnResultPropertyChange
(
	ITFSComponent * pComponent,
	LPDATAOBJECT	pDataObject,
	MMC_COOKIE		cookie,
	LPARAM			arg,
	LPARAM			param
)
{
	HRESULT hr = hrOK;
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	SPITFSNode spNode;
	m_spNodeMgr->FindNode(cookie, &spNode);

	CReplicationPartnerProperties * pProp = reinterpret_cast<CReplicationPartnerProperties *>(param);

	LONG_PTR changeMask = 0;

	// tell the property page to do whatever now that we are back on the
	// main thread
	pProp->OnPropertyChange(TRUE, &changeMask);

	pProp->AcknowledgeNotify();

	if (changeMask)
		spNode->ChangeNode(changeMask);

	return hr;

}


/*---------------------------------------------------------------------------
	CReplicationPartner::OnSendPushTrigger()
		Sends Push replication trigger
 ---------------------------------------------------------------------------*/
HRESULT 
CReplicationPartner::OnSendPushTrigger(CWinsServerHandler *pServer)
{
	HRESULT hr = hrOK;
	DWORD   err = ERROR_SUCCESS;

	CPushTrig cPushDlg;
    CThemeContextActivator themeActivator;
	
	if (cPushDlg.DoModal() != IDOK)
		return hr;

    err = ::SendTrigger(pServer->GetBinding(), 
                        (LONG) m_Server.GetIpAddress(),
                        TRUE, 
                        cPushDlg.GetPropagate());

	if (err == ERROR_SUCCESS)
	{
		AfxMessageBox(IDS_REPL_QUEUED, MB_ICONINFORMATION);
	}
    else
    {
        WinsMessageBox(err);
    }

	return HRESULT_FROM_WIN32(err);
}


/*---------------------------------------------------------------------------
	CReplicationPartner::OnSendPullTrigger()
		Sends Pull replication trigger
 ---------------------------------------------------------------------------*/
HRESULT 
CReplicationPartner::OnSendPullTrigger(CWinsServerHandler *pServer)
{
	HRESULT hr = hrOK;
	DWORD   err = ERROR_SUCCESS;

	CPullTrig cPullTrig;
    CThemeContextActivator themeActivator;

	if (cPullTrig.DoModal() != IDOK)
		return hr;

    err = ::SendTrigger(pServer->GetBinding(), 
                        (LONG) m_Server.GetIpAddress(),
                        FALSE, 
                        FALSE);

	if (err == ERROR_SUCCESS)
	{
		AfxMessageBox(IDS_REPL_QUEUED, MB_ICONINFORMATION);
	}
	else
	{
		::WinsMessageBox(err);
	}

	return HRESULT_FROM_WIN32(err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\pushtrig.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 -99             **/
/**********************************************************************/

/*
    pushtrig.cpp
        Comment goes here

    FILE HISTORY:

*/

#include "stdafx.h"
#include "winssnap.h"
#include "PushTrig.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPushTrig dialog


CPushTrig::CPushTrig(CWnd* pParent /*=NULL*/)
	: CBaseDialog(CPushTrig::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPushTrig)
	//}}AFX_DATA_INIT

    m_fPropagate = FALSE;
}


void CPushTrig::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPushTrig)
	DDX_Control(pDX, IDC_RADIO_PUSH_THIS_PARTNER, m_buttonThisPartner);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPushTrig, CBaseDialog)
	//{{AFX_MSG_MAP(CPushTrig)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPushTrig message handlers

BOOL CPushTrig::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();
	
    m_buttonThisPartner.SetCheck(TRUE);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPushTrig::OnOK() 
{
    m_fPropagate = (m_buttonThisPartner.GetCheck()) ? FALSE : TRUE;
	
	CBaseDialog::OnOK();
}


/////////////////////////////////////////////////////////////////////////////
// CPullTrig dialog


CPullTrig::CPullTrig(CWnd* pParent /*=NULL*/)
	: CBaseDialog(CPullTrig::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPullTrig)
	//}}AFX_DATA_INIT
}


void CPullTrig::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPullTrig)
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPullTrig, CBaseDialog)
	//{{AFX_MSG_MAP(CPullTrig)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPullTrig message handlers

BOOL CPullTrig::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\pushtrig.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	pushtrib.h
		confirm push trigger dialog
		
    FILE HISTORY:
        
*/

#if !defined(AFX_PUSHTRIG_H__815C103D_4D77_11D1_B9AF_00C04FBF914A__INCLUDED_)
#define AFX_PUSHTRIG_H__815C103D_4D77_11D1_B9AF_00C04FBF914A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CPushTrig dialog

#ifndef _DIALOG_H
#include "dialog.h"
#endif

class CPushTrig : public CBaseDialog
{
// Construction
public:
	CPushTrig(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CPushTrig)
	enum { IDD = IDD_SEND_PUSH_TRIGGER };
	CButton	m_buttonThisPartner;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPushTrig)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CPushTrig)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    BOOL    m_fPropagate;

public:
	BOOL GetPropagate()
	{
		return m_fPropagate;
	}

public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CPushTrig::IDD);};

};

/////////////////////////////////////////////////////////////////////////////
// CPullTrig dialog

class CPullTrig : public CBaseDialog
{
// Construction
public:
	CPullTrig(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CPullTrig)
	enum { IDD = IDD_PULL_TRIGGER };
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPullTrig)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CPullTrig)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CPullTrig::IDD);};
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PUSHTRIG_H__815C103D_4D77_11D1_B9AF_00C04FBF914A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\reppart.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	reppart.h
		WINS replication partners node information. 
		
    FILE HISTORY:
        
*/

#ifndef _REPPART_H
#define _REPPART_H

#ifndef _WINSHAND_H
#include "winshand.h"
#endif

class CWinsServerObj;
class CIpNamePair;

#ifndef _TREGKEY_H
#include "tregkey.h"
#endif

#ifndef _SERVER_H
#include "server.h"
#endif

typedef CArray<CWinsServerObj, CWinsServerObj>  RepPartnersArray;
/*---------------------------------------------------------------------------
	Class:	CReplicationPartnersHandler
 ---------------------------------------------------------------------------*/
class CReplicationPartnersHandler : public CWinsHandler
{
// Interface
public:
	CReplicationPartnersHandler(ITFSComponentData *pCompData);

	// base handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages();
	OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();

    OVERRIDE_BaseHandlerNotify_OnCreateNodeId2();
    
    OVERRIDE_ResultHandler_CompareItems();

	STDMETHODIMP_(LPCTSTR) GetString(ITFSNode * pNode, int nCol);

    // helper routines
	HRESULT GetGroupName(CString * pstrGroupName);
	HRESULT SetGroupName(LPCTSTR pszGroupName);

public:
	// CWinsHandler overrides
	virtual HRESULT InitializeNode(ITFSNode * pNode);

    OVERRIDE_BaseHandlerNotify_OnPropertyChange();
	OVERRIDE_BaseHandlerNotify_OnExpand();

    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();
    OVERRIDE_BaseResultHandlerNotify_OnResultDelete();

    OVERRIDE_ResultHandler_OnGetResultViewType();
	
	HRESULT Load(ITFSNode *	pNode);
	HRESULT Store(ITFSNode * pNode);
	void    GetServerName(ITFSNode * pNode,CString &strName);
	int     IsInList(const CIpNamePair & inpTarget, BOOL bBoth = TRUE ) const;
	HRESULT CreateNodes(ITFSNode * pNode);
	HRESULT OnReplicateNow(ITFSNode * pNode);
	HRESULT OnCreateRepPartner(ITFSNode * pNode);
	HRESULT OnRefreshNode(ITFSNode * spNode, LPDATAOBJECT pDataObject);
	HRESULT RemoveChildren(ITFSNode * pNode);
	DWORD   UpdateReg(ITFSNode * pNode, CWinsServerObj * ws);
	DWORD   AddRegEntry(ITFSNode * pNode, CWinsServerObj & ws);

    HRESULT HandleResultMessage(ITFSNode * pNode);


public:
    RepPartnersArray	m_RepPartnersArray;

	typedef CString REGKEYNAME;

//
// Registry Names
//
    static const REGKEYNAME lpstrPullRoot;
    static const REGKEYNAME lpstrPushRoot;
    static const REGKEYNAME lpstrNetBIOSName;
	static const REGKEYNAME	lpstrPersistence;
    
// Implementation
private:
	CString m_strDescription;
};

#endif _REPPART_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\repprtpp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	repprtpp.h
		replication partner property page
		
    FILE HISTORY:
        
*/

#if !defined(AFX_REPPRTPP_H__3D0612A2_4756_11D1_B9A5_00C04FBF914A__INCLUDED_)
#define AFX_REPPRTPP_H__3D0612A2_4756_11D1_B9A5_00C04FBF914A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef _IPCTRL_H
#include "ipctrl.h"
#endif

#ifndef _CONFIG_H
#include "config.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// CRepPartnerPropGen dialog

class CRepPartnerPropGen : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CRepPartnerPropGen)

// Construction
public:
	CRepPartnerPropGen();
	~CRepPartnerPropGen();

// Dialog Data
	//{{AFX_DATA(CRepPartnerPropGen)
	enum { IDD = IDD_REP_PROP_GENERAL };
	CEdit	m_editName;
	CEdit	m_editIpAdd;
	//}}AFX_DATA

	CEdit m_customIPAdd;

	UINT	m_uImage;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRepPartnerPropGen)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRepPartnerPropGen)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	void GetServerNameIP(CString &strName, CString& strIP) ;

	IPControl				m_ipControl;

	CWinsServerObj *        m_pServer;

public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CRepPartnerPropGen::IDD);};

};

/////////////////////////////////////////////////////////////////////////////
// CRepPartnerPropAdv dialog

class CRepPartnerPropAdv : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CRepPartnerPropAdv)

// Construction
public:
	CRepPartnerPropAdv();
	~CRepPartnerPropAdv();

// Dialog Data
	//{{AFX_DATA(CRepPartnerPropAdv)
	enum { IDD = IDD_REP_PROP_ADVANCED };
	CButton	m_buttonPushPersistence;
	CButton	m_buttonPullPersistence;
	CButton	m_GroupPush;
	CButton	m_GroupPull;
	CStatic	m_staticUpdate;
	CStatic	m_staticStartTime;
	CStatic	m_staticRepTime;
	CSpinButtonCtrl	m_spinUpdateCount;
	CSpinButtonCtrl	m_spinStartSecond;
	CSpinButtonCtrl	m_spinStartMinute;
	CSpinButtonCtrl	m_spinStartHour;
	CSpinButtonCtrl	m_spinRepMinute;
	CSpinButtonCtrl	m_spinRepHour;
	CSpinButtonCtrl	m_spinRepDay;
	CEdit	m_editUpdateCount;
	CEdit	m_editStartSecond;
	CEdit	m_editStartMinute;
	CEdit	m_editStartHour;
	CEdit	m_editRepMinute;
	CEdit	m_editRepHour;
	CEdit	m_editRepDay;
	CComboBox	m_comboType;
	CButton	m_buttonPush;
	CButton	m_buttonPull;
	CString	m_strType;
	DWORD	m_nUpdateCount;
	int		m_nRepDay;
	int		m_nRepHour;
	int		m_nRepMinute;
	int		m_nStartHour;
	int		m_nStartMinute;
	int		m_nStartSecond;
	//}}AFX_DATA

    CWinsServerObj * m_pServer;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRepPartnerPropAdv)
	public:
	virtual void OnOK();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRepPartnerPropAdv)
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonPullSetDefault();
	afx_msg void OnButtonPushSetDefault();
	afx_msg void OnChangeEditRepHour();
	afx_msg void OnSelchangeComboType();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	void    FillPullParameters();
	void    FillPushParameters();
	CString ToString(int nNum);
	void    ReadFromServerPref(DWORD &dwPullTime, DWORD& dwPullSpTime, DWORD &dwUpdateCount, DWORD & dwPushPersistence, DWORD & dwPullPersistence);
	void    UpdateRep();
	DWORD   UpdateReg();
	void    CalculateRepInt(DWORD& dwRepInt);
	void    CalculateStartInt(CTime & time);
	int     ToInt(CString strNumber);
	void    UpdateUI();
	void    EnablePushControls(BOOL bEnable = TRUE);
	void    EnablePullControls(BOOL bEnable = TRUE);
	void    SetState(CString & strType, BOOL bPush, BOOL bPull);
	DWORD	GetConfig(CConfiguration & config);
	
	DWORD	UpdatePullParameters();
	DWORD	UpdatePushParameters();
	DWORD	RemovePullPartner();
	DWORD	RemovePushPartner();

public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CRepPartnerPropAdv::IDD);};

};

class CReplicationPartnerProperties : public CPropertyPageHolderBase
{
	
public:
	CReplicationPartnerProperties(ITFSNode *		  pNode,
								  IComponentData *	  pComponentData,
								  ITFSComponentData * pTFSCompData,
								  LPCTSTR			  pszSheetName
								  );
	virtual ~CReplicationPartnerProperties();

	ITFSComponentData * GetTFSCompData()
	{
		if (m_spTFSCompData)
			m_spTFSCompData->AddRef();
		return m_spTFSCompData;
	}

    void SetServer(CWinsServerObj * pServer)
    {
        m_Server = *pServer;
    }

    CWinsServerObj * GetServer()
    {
        return &m_Server;
    }

public:
	CRepPartnerPropGen			m_pageGeneral;
	CRepPartnerPropAdv			m_pageAdvanced;
    CWinsServerObj              m_Server;       // replication partner this is for
    
protected:
	SPITFSComponentData		m_spTFSCompData;
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REPPRTPP_H__3D0612A2_4756_11D1_B9A5_00C04FBF914A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\repprtpp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 -99             **/
/**********************************************************************/

/*
    repprtpp.cpp
        Comment goes here

    FILE HISTORY:

*/

#include "stdafx.h"
#include "winssnap.h"
#include "RepPrtpp.h"
#include "nodes.h"
#include "server.h"
#include "tregkey.h"
#include "reppart.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRepPartnerPropGen property page

IMPLEMENT_DYNCREATE(CRepPartnerPropGen, CPropertyPageBase)

CRepPartnerPropGen::CRepPartnerPropGen() : CPropertyPageBase(CRepPartnerPropGen::IDD)
{
	//{{AFX_DATA_INIT(CRepPartnerPropGen)
	//}}AFX_DATA_INIT

    m_pServer = NULL;
}


CRepPartnerPropGen::~CRepPartnerPropGen()
{
}


void CRepPartnerPropGen::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRepPartnerPropGen)
	DDX_Control(pDX, IDC_EDIT_NAME, m_editName);
	DDX_Control(pDX, IDC_EDIT_IPADDRESS, m_editIpAdd);
	//}}AFX_DATA_MAP
	DDX_Control(pDX, IDC_IPADD, m_customIPAdd);
}


BEGIN_MESSAGE_MAP(CRepPartnerPropGen, CPropertyPageBase)
	//{{AFX_MSG_MAP(CRepPartnerPropGen)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRepPartnerPropGen message handlers

BOOL 
CRepPartnerPropGen::OnInitDialog() 
{
    // get our server info from the holder
    m_pServer = ((CReplicationPartnerProperties *) GetHolder())->GetServer();

    // Initialize the IP address controls
	m_ipControl.Create(m_hWnd, IDC_IPADD);
	m_ipControl.SetFieldRange(0, 0, 255);

	CPropertyPageBase::OnInitDialog();
	
	CString strName, strIP;
	GetServerNameIP(strName, strIP);

	m_editName.SetWindowText(strName);
	m_editIpAdd.SetWindowText(strIP);
	m_ipControl.SetAddress(strIP);
	m_customIPAdd.SetWindowText(strIP);

	m_editName.SetReadOnly(TRUE);
	m_editIpAdd.SetReadOnly(TRUE);
	m_customIPAdd.SetReadOnly();

    // load the correct icon
    for (int i = 0; i < ICON_IDX_MAX; i++)
    {
        if (g_uIconMap[i][1] == m_uImage)
        {
            HICON hIcon = LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
            if (hIcon)
                ((CStatic *) GetDlgItem(IDC_STATIC_ICON))->SetIcon(hIcon);
            break;
        }
    }

	SetDirty(FALSE);
	
	return TRUE;  
}


void 
CRepPartnerPropGen::GetServerNameIP(CString &strName, CString& strIP) 
{
	HRESULT hr = hrOK;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	strIP = m_pServer->GetstrIPAddress();
	strName = m_pServer->GetNetBIOSName();
}

/////////////////////////////////////////////////////////////////////////////
// CRepPartnerPropAdv property page

IMPLEMENT_DYNCREATE(CRepPartnerPropAdv, CPropertyPageBase)

CRepPartnerPropAdv::CRepPartnerPropAdv() : CPropertyPageBase(CRepPartnerPropAdv::IDD)
{
	//{{AFX_DATA_INIT(CRepPartnerPropAdv)
	m_strType = _T("");
	m_nUpdateCount = 0;
	m_nRepDay = 0;
	m_nRepHour = 0;
	m_nRepMinute = 0;
	m_nStartHour = 0;
	m_nStartMinute = 0;
	m_nStartSecond = 0;
	//}}AFX_DATA_INIT

    m_pServer = NULL;
}


CRepPartnerPropAdv::~CRepPartnerPropAdv()
{
}


void CRepPartnerPropAdv::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRepPartnerPropAdv)
	DDX_Control(pDX, IDC_CHECK_PUSH_PERSISTENCE, m_buttonPushPersistence);
	DDX_Control(pDX, IDC_CHECK_PULL_PERSIST, m_buttonPullPersistence);
	DDX_Control(pDX, IDC_STATIC_PUSH_GROUP, m_GroupPush);
	DDX_Control(pDX, IDC_STATIC_PULL_GROUP, m_GroupPull);
	DDX_Control(pDX, IDC_STATIC_UPDATE, m_staticUpdate);
	DDX_Control(pDX, IDC_STATIC_START_TIME, m_staticStartTime);
	DDX_Control(pDX, IDC_STATIC_REP_TIME, m_staticRepTime);
	DDX_Control(pDX, IDC_SPIN_UPDATE_COUNT, m_spinUpdateCount);
	DDX_Control(pDX, IDC_SPIN_START_SECOND, m_spinStartSecond);
	DDX_Control(pDX, IDC_SPIN_START_MINUTE, m_spinStartMinute);
	DDX_Control(pDX, IDC_SPIN_START_HOUR, m_spinStartHour);
	DDX_Control(pDX, IDC_SPIN_REP_MINUTE, m_spinRepMinute);
	DDX_Control(pDX, IDC_SPIN_REP_HOUR, m_spinRepHour);
	DDX_Control(pDX, IDC_SPIN_REP_DAY, m_spinRepDay);
	DDX_Control(pDX, IDC_EDIT_UPDATE_COUNT, m_editUpdateCount);
	DDX_Control(pDX, IDC_EDIT_START_SECOND, m_editStartSecond);
	DDX_Control(pDX, IDC_EDIT_START_MINUTE, m_editStartMinute);
	DDX_Control(pDX, IDC_EDIT_START_HOUR, m_editStartHour);
	DDX_Control(pDX, IDC_EDIT_REP_MINUTE, m_editRepMinute);
	DDX_Control(pDX, IDC_EDIT_REP_HOUR, m_editRepHour);
	DDX_Control(pDX, IDC_EDIT_REP_DAY, m_editRepDay);
	DDX_Control(pDX, IDC_COMBO_TYPE, m_comboType);
	DDX_Control(pDX, IDC_BUTTON_PUSH_SET_DEFAULT, m_buttonPush);
	DDX_Control(pDX, IDC_BUTTON_PULL_SET_DEFAULT, m_buttonPull);
	DDX_CBStringExact(pDX, IDC_COMBO_TYPE, m_strType);
	DDX_Text(pDX, IDC_EDIT_UPDATE_COUNT, m_nUpdateCount);
	DDX_Text(pDX, IDC_EDIT_REP_DAY, m_nRepDay);
	DDV_MinMaxInt(pDX, m_nRepDay, 0, 365);
	DDX_Text(pDX, IDC_EDIT_REP_HOUR, m_nRepHour);
	DDV_MinMaxInt(pDX, m_nRepHour, 0, 23);
	DDX_Text(pDX, IDC_EDIT_REP_MINUTE, m_nRepMinute);
	DDV_MinMaxInt(pDX, m_nRepMinute, 0, 59);
	DDX_Text(pDX, IDC_EDIT_START_HOUR, m_nStartHour);
	DDV_MinMaxInt(pDX, m_nStartHour, 0, 23);
	DDX_Text(pDX, IDC_EDIT_START_MINUTE, m_nStartMinute);
	DDV_MinMaxInt(pDX, m_nStartMinute, 0, 59);
	DDX_Text(pDX, IDC_EDIT_START_SECOND, m_nStartSecond);
	DDV_MinMaxInt(pDX, m_nStartSecond, 0, 59);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRepPartnerPropAdv, CPropertyPageBase)
	//{{AFX_MSG_MAP(CRepPartnerPropAdv)
	ON_BN_CLICKED(IDC_BUTTON_PULL_SET_DEFAULT, OnButtonPullSetDefault)
	ON_BN_CLICKED(IDC_BUTTON_PUSH_SET_DEFAULT, OnButtonPushSetDefault)
	ON_CBN_SELCHANGE(IDC_COMBO_TYPE, OnSelchangeComboType)
	ON_EN_CHANGE(IDC_EDIT_REP_DAY, OnChangeEditRepHour)
	ON_EN_CHANGE(IDC_EDIT_REP_HOUR, OnChangeEditRepHour)
	ON_EN_CHANGE(IDC_EDIT_REP_MINUTE, OnChangeEditRepHour)
	ON_EN_CHANGE(IDC_EDIT_START_HOUR, OnChangeEditRepHour)
	ON_EN_CHANGE(IDC_EDIT_START_MINUTE, OnChangeEditRepHour)
	ON_EN_CHANGE(IDC_EDIT_START_SECOND, OnChangeEditRepHour)
	ON_EN_CHANGE(IDC_EDIT_UPDATE_COUNT, OnChangeEditRepHour)
	ON_BN_CLICKED(IDC_CHECK_PULL_PERSIST, OnChangeEditRepHour)
	ON_BN_CLICKED(IDC_CHECK_PUSH_PERSISTENCE, OnChangeEditRepHour)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRepPartnerPropAdv message handlers


BOOL 
CRepPartnerPropAdv::OnInitDialog() 
{
	int		ids;
	BOOL	bPush, bPull;

	CPropertyPageBase::OnInitDialog();

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // get our server info from the holder
    m_pServer = ((CReplicationPartnerProperties *) GetHolder())->GetServer();

    // init push spin controls
	m_spinUpdateCount.SetRange(0, UD_MAXVAL);
	
	// init pull spin controls
	m_spinRepMinute.SetRange(0, 59);
	m_spinRepHour.SetRange(0, 23);
	m_spinRepDay.SetRange(0, UD_MAXVAL);

	m_spinStartSecond.SetRange(0, 59);
	m_spinStartMinute.SetRange(0, 59);
	m_spinStartHour.SetRange(0, 23);

	// fill the combobox
    CString	st;
	int nIndex = 0; 

    st.LoadString(IDS_PUSHPULL);
    nIndex = m_comboType.AddString(st);
	m_comboType.SetItemData(nIndex, 0);

    st.LoadString(IDS_PUSH);
    nIndex = m_comboType.AddString(st);
	m_comboType.SetItemData(nIndex, 1);
    
	st.LoadString(IDS_PULL);
    nIndex = m_comboType.AddString(st);
	m_comboType.SetItemData(nIndex, 2);

    bPush = m_pServer->IsPush();
	bPull = m_pServer->IsPull();

	if (bPush && bPull)
		ids = IDS_PUSHPULL;
	else if (bPush)
		ids = IDS_PUSH;
	else if (bPull)
		ids = IDS_PULL;
	else
		ids = IDS_NONE;
    
    st.LoadString(ids);
	SetState(st, bPush, bPull);

	FillPushParameters();
	FillPullParameters();

	SetDirty(FALSE);
	
	return TRUE;  
}


void 
CRepPartnerPropAdv::FillPushParameters()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	EnablePushControls(m_pServer->IsPush());

	DWORD nUpdate = (LONG) m_pServer->GetPushUpdateCount();

	m_spinUpdateCount.SetPos(nUpdate);

	// set the persistence parameter
    CConfiguration Config;

	GetConfig(Config);

	if (Config.m_dwMajorVersion < 5)
	{
		// no persistent connections for anything less that NT5
		m_buttonPushPersistence.SetCheck(FALSE);
	}
	else
	{
		BOOL bCheck = m_pServer->GetPushPersistence() ? TRUE : FALSE;

		m_buttonPushPersistence.SetCheck(bCheck);
	}
}


void 
CRepPartnerPropAdv::FillPullParameters()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	EnablePullControls(m_pServer->IsPull());

	DWORD nPullRep = (LONG) m_pServer->GetPullReplicationInterval();

	DWORD dwPullTime, dwPullSpTime, dwUpdateCount;

	//if (nPullRep !=0 )
	{
		int nDays =0, nHours = 0, nMinutes = 0;

		nDays = nPullRep/ SEC_PER_DAY;
		nPullRep -= nDays * SEC_PER_DAY;

		if (nPullRep)
		{
			nHours = nPullRep / SEC_PER_HOUR;
			nPullRep -= nHours * SEC_PER_HOUR;

			if (nPullRep)
			{
				nMinutes = nPullRep / SEC_PER_MINUTE;
				nPullRep -= nMinutes * SEC_PER_MINUTE;
			}
		}

		m_spinRepDay.SetPos(nDays);
		m_spinRepHour.SetPos(nHours);
		m_spinRepMinute.SetPos(nMinutes);
	}
	
	int nHours = 0, nMinutes = 0, nSeconds = 0;

    if (m_pServer->GetPullStartTime())
    {
	    nHours = m_pServer->GetPullStartTime().GetHour();
	    nMinutes = m_pServer->GetPullStartTime().GetMinute();
	    nSeconds = m_pServer->GetPullStartTime().GetSecond();
    }

	m_spinStartHour.SetPos(nHours);
	m_spinStartMinute.SetPos(nMinutes);
	m_spinStartSecond.SetPos(nSeconds);

	// set the persistence parameter
    CConfiguration Config;

    GetConfig(Config);

	if (Config.m_dwMajorVersion < 5)
	{
		// no persistent connections for anything less that NT5
		m_buttonPullPersistence.SetCheck(FALSE);
	}
	else
	{
		BOOL bCheck = m_pServer->GetPullPersistence() ? TRUE : FALSE;

		m_buttonPullPersistence.SetCheck(bCheck);
	}
}


CString 
CRepPartnerPropAdv::ToString(int nNumber)
{
	TCHAR szStr[20];
	_itot(nNumber, szStr, 10);
	CString str(szStr);
	return str;
}

DWORD
CRepPartnerPropAdv::GetConfig(CConfiguration & config)
{
	// leaf node
	SPITFSNode spNode ;
	spNode = GetHolder()->GetNode();

	// scope pane rep node
	SPITFSNode spRepNode;
	spNode->GetParent(&spRepNode);

	// server node
	SPITFSNode spServerNode;
	spRepNode->GetParent(&spServerNode);

	CWinsServerHandler *pServer;

	pServer = GETHANDLER(CWinsServerHandler, spServerNode);

    config = pServer->GetConfig();

	return NOERROR;
}

// read from the preferences
void 
CRepPartnerPropAdv::ReadFromServerPref
(
    DWORD &     dwPullTime, 
    DWORD &     dwPullSpTime, 
    DWORD &     dwUpdateCount,
    DWORD &     dwPushPersistence,
    DWORD &     dwPullPersistence
)
{
    CConfiguration Config;

    GetConfig(Config);

	dwPullTime = Config.m_dwPullTimeInterval;
	dwPullSpTime = Config.m_dwPullSpTime;

	dwUpdateCount = Config.m_dwPushUpdateCount;

    dwPushPersistence = Config.m_dwPushPersistence;
    dwPullPersistence = Config.m_dwPullPersistence;
}


void 
CRepPartnerPropAdv::OnButtonPullSetDefault() 
{
	// read from the preferences of the server and display the values
	DWORD dwPullTime, dwPullSpTime, dwUpdate, dwPushPersistence, dwPullPersistence;
	
	ReadFromServerPref(dwPullTime, dwPullSpTime, dwUpdate, dwPushPersistence, dwPullPersistence);

	// fill the controls
	CTime PullSpTime(dwPullSpTime);
    int nHours = 0, nMinutes = 0, nSeconds = 0;

	if (dwPullSpTime)
    {
        nHours = PullSpTime.GetHour();
        nMinutes = PullSpTime.GetMinute();
        nSeconds = PullSpTime.GetSecond();
    }

	m_spinStartHour.SetPos(nHours);
	m_spinStartMinute.SetPos(nMinutes);
	m_spinStartSecond.SetPos(nSeconds);

	int nDays = 0;

	nDays = dwPullTime / SEC_PER_DAY;
	dwPullTime -= nDays * SEC_PER_DAY;

	nHours = dwPullTime / SEC_PER_HOUR;
	dwPullTime -= nHours * SEC_PER_HOUR;

	nMinutes = dwPullTime / SEC_PER_MINUTE;
	dwPullTime -= nMinutes * SEC_PER_MINUTE;

	m_spinRepDay.SetPos(nDays);
	m_spinRepHour.SetPos(nHours);
	m_spinRepMinute.SetPos(nMinutes);

	// clear off the persistence check box
	m_buttonPullPersistence.SetCheck(dwPullPersistence);

    // mark the page dirty so changes get saved
    SetDirty(TRUE);
}


void 
CRepPartnerPropAdv::OnButtonPushSetDefault() 
{
	// read from the preferences of the server and display the values
	DWORD dwPullTime, dwPullSpTime, dwUpdate, dwPushPersistence, dwPullPersistence;
	
	ReadFromServerPref(dwPullTime, dwPullSpTime, dwUpdate, dwPushPersistence, dwPullPersistence);

	m_spinUpdateCount.SetPos(dwUpdate);

	m_buttonPushPersistence.SetCheck(dwPushPersistence);

    // mark the page dirty so changes get saved
    SetDirty(TRUE);
}


void 
CRepPartnerPropAdv::OnOK() 
{
	UpdateRep();
	UpdateReg();
	CPropertyPageBase::OnOK();
}


void 
CRepPartnerPropAdv::UpdateRep()
{
	// get the replication partner server item
	BOOL bPullPersist;
	BOOL bPushPersist;
    CThemeContextActivator themeActivator;

	UpdateData();

  	// get the persistence data for the server object 
	bPullPersist = (m_buttonPullPersistence.GetCheck() == 0) ? FALSE : TRUE;
	bPushPersist = (m_buttonPushPersistence.GetCheck() == 0) ? FALSE : TRUE;

    if ( ( (m_nUpdateCount > 0) & 
           (m_nUpdateCount < WINSCNF_MIN_VALID_UPDATE_CNT) ) &
         (!bPushPersist) )
    {
        CString strMessage, strValue;
        strValue.Format(_T("%d"), WINSCNF_MIN_VALID_UPDATE_CNT);

        AfxFormatString1(strMessage, IDS_ERR_UPDATE_COUNT, strValue);

        AfxMessageBox(strMessage);
        m_editUpdateCount.SetFocus();

        return;
    }

	int nPullRep = m_pServer->GetPullReplicationInterval();

	int nIndex = m_comboType.GetCurSel();
	switch (m_comboType.GetItemData(nIndex))
	{
		// pull/push partner
		case 0:
			m_pServer->SetPull(TRUE);
			m_pServer->SetPush(TRUE);
			break;

		// push partner
		case 1:
		m_pServer->SetPull(FALSE);
		m_pServer->SetPush(TRUE);
			break;

		// pull partner
		case 2:
		default:
			m_pServer->SetPull(TRUE);
			m_pServer->SetPush(FALSE);
			break;
	}

	// get the replication interval
    DWORD dwRepInt;
    CalculateRepInt(dwRepInt);
	m_pServer->GetPullReplicationInterval() = dwRepInt;

    // get the start time
    CTime timeStart;
    CalculateStartInt(timeStart);
    m_pServer->GetPullStartTime() = timeStart;

    m_pServer->GetPushUpdateCount() = m_nUpdateCount;

	//SetPersistence(bPersist);
	m_pServer->SetPullPersistence(bPullPersist);
	m_pServer->SetPushPersistence(bPushPersist);
}

int 
CRepPartnerPropAdv::ToInt(CString strNumber)
{
	int nNumber = _ttoi(strNumber);
	return nNumber;
}

DWORD 
CRepPartnerPropAdv::UpdateReg()
{
	UpdateData();

	DWORD				  err;
	SPITFSNode			  spNode;
	CReplicationPartner * pRepParItem;

	// get the replication partner node & handler
	spNode = GetHolder()->GetNode();
	pRepParItem = GETHANDLER(CReplicationPartner, spNode);

	// if none, delete the key from registry, no need to worry about the 
	// persistence it gets deleted anyway
	if (!m_pServer->IsPush() && !m_pServer->IsPull())
	{
		err = RemovePushPartner();
        if (err)
			goto Error;

		err = RemovePullPartner();
	}

	// if only push
	else if (m_pServer->IsPush() && !m_pServer->IsPull())
	{
		// update the push stuff
		err = UpdatePushParameters();
		if (err)
			goto Error;

		// remove if configured as a pull partner
		err = RemovePullPartner();
	}

	//if only pull
	else if (!m_pServer->IsPush() && m_pServer->IsPull())
	{
		// update the pull stuff
		err = UpdatePullParameters();
		if (err)
			goto Error;
		
		// remove if configured as a push partner
		err = RemovePushPartner();
	}

	// if both push and pull
	else if (m_pServer->IsPush() && m_pServer->IsPull())
	{
		// update the push stuff
		err = UpdatePushParameters();
		if (err)
			goto Error;
	
		err = UpdatePullParameters();
	}

Error:
    if (err == ERROR_SUCCESS)
    {
        // update our local cahced node with the changes from the property page
        pRepParItem->m_Server = *m_pServer;
    }

	return err;  
}

DWORD
CRepPartnerPropAdv::UpdatePullParameters()
{
	SPITFSNode spNode, spRepNode;
	CReplicationPartnersHandler * pRep;

	// first get the replication partner node & handler
	spNode = GetHolder()->GetNode();

	// Now get the replication partners node & handle
	spNode->GetParent(&spRepNode);
	pRep = GETHANDLER(CReplicationPartnersHandler, spRepNode);
		
	// build the server name
	CString strServerName;
	pRep->GetServerName(spRepNode, strServerName);
	strServerName = _T("\\\\") + strServerName;

	DWORD dwResult, dwRepInt, dwValue;
	DWORD err = ERROR_SUCCESS;

	// make sure it is setup as a pull partner
	RegKey rk;
	CString strKey = pRep->lpstrPullRoot + _T("\\") + (CString) m_pServer->GetstrIPAddress();
	err = rk.Create(HKEY_LOCAL_MACHINE, strKey, 0, KEY_ALL_ACCESS, NULL, strServerName);
	if (err)
		goto Error;

	err = rk.SetValue(pRep->lpstrNetBIOSName, m_pServer->GetNetBIOSName());
	if (err)
	{
		Trace1("CRepPartnerPropAdv::UpdatePullParameters - error writing netbios name! %d\n", err);
		goto Error;
	}

	err = rk.QueryValue(WINSCNF_SELF_FND_NM, (DWORD&) dwResult);

	if (err)
	{
		Trace0("CRepPartnerPropAdv::UpdatePullParameters - No selfFind value, setting to 0\n");
		dwValue = 0;
		err = rk.SetValue(WINSCNF_SELF_FND_NM, dwValue);
	}

	dwRepInt = (LONG) m_pServer->GetPullReplicationInterval();

	if ((LONG) m_pServer->GetPullReplicationInterval() > 0)
	{
		err = rk.SetValue(WINSCNF_RPL_INTERVAL_NM, (DWORD&) dwRepInt);
		if (err)
		{
			Trace1("CRepPartnerPropAdv::UpdatePullParameters - error writing Pull time interval! %d\n", err);
			goto Error;
		}
	}

	if (m_pServer->GetPullStartTime().GetTime() > (time_t) 0)
    {
		err = rk.SetValue(WINSCNF_SP_TIME_NM, m_pServer->GetPullStartTime().IntlFormat(CIntlTime::TFRQ_MILITARY_TIME));
		if (err)
		{
			Trace1("CRepPartnerPropAdv::UpdatePullParameters - error writing Pull SpTime! %d\n", err);
			goto Error;
		}
    }
    else
    {
		err = rk.DeleteValue(WINSCNF_SP_TIME_NM);
    }

	// set the value to 0 or 1 depending on the PushPersistence
	dwValue = m_pServer->GetPullPersistence() ? 1 : 0;

	// Set the Persist key 
	err = rk.SetValue(pRep->lpstrPersistence, (DWORD &)dwValue);
	if (err)
	{
		Trace1("CRepPartnerPropAdv::UpdatePullParameters - Error writing persistence! %d\n", err);
	}

Error:
	return err;
}

DWORD
CRepPartnerPropAdv::UpdatePushParameters()
{
	SPITFSNode spNode, spRepNode;
	CReplicationPartnersHandler * pRep;

	// first get the replication partner node & handler
	spNode = GetHolder()->GetNode();

	// Now get the replication partners node & handle
	spNode->GetParent(&spRepNode);
	pRep = GETHANDLER(CReplicationPartnersHandler, spRepNode);
		
	// build the server name
	CString strServerName;
	pRep->GetServerName(spRepNode, strServerName);
	strServerName = _T("\\\\") + strServerName;

	DWORD dwResult, dwValue;
	DWORD err = ERROR_SUCCESS;

	RegKey rk;
	
	// make sure it is setup as a push partner
	CString strKey = pRep->lpstrPushRoot + _T("\\") + (CString) m_pServer->GetstrIPAddress();
	err = rk.Create(HKEY_LOCAL_MACHINE, strKey, 0, KEY_ALL_ACCESS, NULL, strServerName);
	if (err)
		goto Error;

	err = rk.SetValue(pRep->lpstrNetBIOSName, m_pServer->GetNetBIOSName());
	if (err)
	{
		Trace1("CRepPartnerPropAdv::UpdatePushParameters - error writing netbios name! %d\n", err);
		goto Error;
	}

	err = rk.QueryValue(WINSCNF_SELF_FND_NM, (DWORD&) dwResult);

	if (err)
	{
		Trace0("CRepPartnerPropAdv::UpdatePushParameters - No selfFind value, setting to 0\n");
		dwValue = 0;
		err = rk.SetValue(WINSCNF_SELF_FND_NM, dwValue);
	}

	// set the push update count
    if (m_nUpdateCount == 0)
    {
        err = rk.DeleteValue(WINSCNF_UPDATE_COUNT_NM);
    }
    else
    {
        err = rk.SetValue(WINSCNF_UPDATE_COUNT_NM, (DWORD&) m_nUpdateCount);
		if (err)
		{
			Trace1("CRepPartnerPropAdv::UpdatePushParameters - Error writing update count! %d\n", err);
			goto Error;
		}
    }

	// set the value to 0 or 1 depending on the PushPersistence
	dwValue = m_pServer->GetPushPersistence() ? 1 : 0;

	// Set the Persist key is present
	err = rk.SetValue(pRep->lpstrPersistence, (DWORD &) dwValue);
	if (err)
	{
		Trace1("CRepPartnerPropAdv::UpdatePushParameters - Error writing persistence! %d\n", err);
	}

Error:
	return err;
}

DWORD
CRepPartnerPropAdv::RemovePullPartner()
{
	SPITFSNode						spNode, spRepNode;
	CReplicationPartnersHandler *	pRep;
	DWORD	err, errDel = 0;
	CString csKeyName;

	// first get the replication partner node & handler
	spNode = GetHolder()->GetNode();

	// Now get the replication partners node & handle
	spNode->GetParent(&spRepNode);
	pRep = GETHANDLER(CReplicationPartnersHandler, spRepNode);

	// build the server name
	CString strServerName;
	pRep->GetServerName(spRepNode, strServerName);
	strServerName = _T("\\\\") + strServerName;

	RegKey rkPull;

	// get the pull root key
	CString strKey = pRep->lpstrPullRoot + _T("\\") + (CString) m_pServer->GetstrIPAddress();
	err = rkPull.Create(HKEY_LOCAL_MACHINE, (CString) pRep->lpstrPullRoot, 0, KEY_ALL_ACCESS,	NULL, strServerName);
	if (err)
		return err;

	RegKeyIterator iterPullkey;
	err = iterPullkey.Init(&rkPull);

	err = iterPullkey.Next (&csKeyName, NULL);
	while (!err)
    {
        if (csKeyName == m_pServer->GetstrIPAddress())
		{
            errDel = RegDeleteKey (HKEY(rkPull), csKeyName);
            iterPullkey.Reset();
        }
        err = iterPullkey.Next (&csKeyName, NULL);
    }

	if (errDel)
		err = errDel;
	else
		err = ERROR_SUCCESS;

	return err;
}

DWORD
CRepPartnerPropAdv::RemovePushPartner()
{
	SPITFSNode						spNode, spRepNode;
	CReplicationPartnersHandler *	pRep;
	DWORD	err, errDel = 0;
	CString csKeyName;

	// first get the replication partner node & handler
	spNode = GetHolder()->GetNode();

	// Now get the replication partners node & handle
	spNode->GetParent(&spRepNode);
	pRep = GETHANDLER(CReplicationPartnersHandler, spRepNode);

	// build the server name
	CString strServerName;
	pRep->GetServerName(spRepNode, strServerName);
	strServerName = _T("\\\\") + strServerName;

	RegKey rkPush;

	CString strKey = pRep->lpstrPushRoot + _T("\\") + (CString) m_pServer->GetstrIPAddress();
	err = rkPush.Create(HKEY_LOCAL_MACHINE, (CString) pRep->lpstrPushRoot, 0, KEY_ALL_ACCESS, NULL, strServerName);
	if (err)
		return err;

	RegKeyIterator iterPushkey;
	err = iterPushkey.Init(&rkPush);

    err = iterPushkey.Next (&csKeyName, NULL);
	while (!err)
    {
        if (csKeyName == m_pServer->GetstrIPAddress())
		{
            errDel = RegDeleteKey (HKEY(rkPush), csKeyName);
            iterPushkey.Reset();
        }
        err = iterPushkey.Next (&csKeyName, NULL);
    }

	if (errDel)
		err = errDel;
	else
		err = ERROR_SUCCESS;

	return err;
}

void 
CRepPartnerPropAdv::CalculateRepInt(DWORD& dwRepInt)
{
	UpdateData();

	int nDays = m_spinRepDay.GetPos();
	int nHour = m_spinRepHour.GetPos();
	int nMinute = m_spinRepMinute.GetPos();

	DWORD nVerifyInt = nDays * SEC_PER_DAY +
					   nHour * SEC_PER_HOUR	+
					   nMinute * SEC_PER_MINUTE;

	dwRepInt = nVerifyInt;
}


void 
CRepPartnerPropAdv::CalculateStartInt(CTime & time)
{
    CTime tempTime;

	UpdateData();

	int nHour = m_spinStartHour.GetPos();
	int nMinute = m_spinStartMinute.GetPos();
	int nSecond = m_spinStartSecond.GetPos();

    if (nHour || nMinute || nSecond)
    {
        CTime curTime = CTime::GetCurrentTime();

        int nYear = curTime.GetYear();
        int nMonth = curTime.GetMonth();
        int nDay = curTime.GetDay();

        CTime tempTime(nYear, nMonth, nDay, nHour, nMinute, nSecond);
        time = tempTime;
    }
    else
    {
        CTime tempTime(0);
        time = tempTime;
    }
}


BOOL 
CRepPartnerPropAdv::OnApply() 
{
	// if not dirtied return
	if ( !IsDirty())
		return TRUE;

	UpdateRep();
	DWORD err = UpdateReg();

	if (!err)
    {
		UpdateUI();
    }
	else
	{
		WinsMessageBox(err);
		return FALSE;
	}

    return CPropertyPageBase::OnApply();
}


void 
CRepPartnerPropAdv::UpdateUI()
{
	SPITFSNode spNode;
	CReplicationPartner *pRepParItem;

	spNode = GetHolder()->GetNode();
	pRepParItem = GETHANDLER(CReplicationPartner, spNode);
	
	//change the type depending on the type set
	pRepParItem->SetType(m_strType);

	VERIFY(SUCCEEDED(spNode->ChangeNode(RESULT_PANE_CHANGE_ITEM)));
}

void CRepPartnerPropAdv::OnChangeEditRepHour() 
{
	SetDirty(TRUE);	
}

void CRepPartnerPropAdv::OnSelchangeComboType() 
{
	SetDirty(TRUE);	

	UpdateData();

	// depending on the type selected enable or disable 
	// the set of controls
	int nIndex = m_comboType.GetCurSel();
	switch (m_comboType.GetItemData(nIndex))
	{
		// pull/push partner
		case 0:
			EnablePullControls(TRUE);
			EnablePushControls(TRUE);
			break;

		// push partner
		case 1:
			EnablePullControls(FALSE);
			EnablePushControls(TRUE);
			break;

		// pull partner
		case 2:
		default:
			EnablePullControls(TRUE);
			EnablePushControls(FALSE);
			break;
	}
}

void
CRepPartnerPropAdv::EnablePushControls(BOOL bEnable )
{
	m_buttonPush.EnableWindow(bEnable);
	m_editUpdateCount.EnableWindow(bEnable);
	m_spinUpdateCount.EnableWindow(bEnable);
	m_staticUpdate.EnableWindow(bEnable);

    CConfiguration Config;
	GetConfig(Config);

	if (Config.m_dwMajorVersion < 5)
	{
		// no persistent connections for anything less that NT5
		m_buttonPushPersistence.EnableWindow(FALSE);
	}
	else
	{
        m_buttonPushPersistence.EnableWindow(bEnable);
	}

	m_GroupPush.EnableWindow(bEnable);
}

void
CRepPartnerPropAdv::EnablePullControls(BOOL bEnable)
{
	m_spinRepDay.EnableWindow(bEnable);
	m_spinRepHour.EnableWindow(bEnable);
	m_spinRepMinute.EnableWindow(bEnable);

	m_spinStartHour.EnableWindow(bEnable);
	m_spinStartMinute.EnableWindow(bEnable);
	m_spinStartSecond.EnableWindow(bEnable);

	m_editRepDay.EnableWindow(bEnable);
	m_editRepHour.EnableWindow(bEnable);
	m_editRepMinute.EnableWindow(bEnable);

	m_editStartHour.EnableWindow(bEnable);
	m_editStartMinute.EnableWindow(bEnable);
	m_editStartSecond.EnableWindow(bEnable);

	m_buttonPull.EnableWindow(bEnable);

	m_GroupPull.EnableWindow(bEnable);

	m_staticRepTime.EnableWindow(bEnable);
	m_staticStartTime.EnableWindow(bEnable);

    CConfiguration Config;
	GetConfig(Config);

	if (Config.m_dwMajorVersion < 5)
	{
		// no persistent connections for anything less that NT5
        m_buttonPullPersistence.EnableWindow(FALSE);
	}
	else
	{
        m_buttonPullPersistence.EnableWindow(bEnable);
    }
}

void
CRepPartnerPropAdv::SetState(CString & strType, BOOL bPush, BOOL bPull)
{
	int nIndex = m_comboType.FindStringExact(-1, strType);
	m_comboType.SetCurSel(nIndex);
	
	EnablePullControls(bPull);
	EnablePushControls(bPush);
}

/////////////////////////////////////////////////////////////////////////////
//
// CReplicationPartnerProperties holder
//
/////////////////////////////////////////////////////////////////////////////
CReplicationPartnerProperties::CReplicationPartnerProperties
(
	ITFSNode *			pNode,
	IComponentData *	pComponentData,
	ITFSComponentData * pTFSCompData,
	LPCTSTR				pszSheetName
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName)

{
	m_bAutoDeletePages = FALSE; // we have the pages as embedded members
    m_bTheme = TRUE;

	AddPageToList((CPropertyPageBase*) &m_pageGeneral);
	AddPageToList((CPropertyPageBase*) &m_pageAdvanced);

	Assert(pTFSCompData != NULL);
	m_spTFSCompData.Set(pTFSCompData);
}

CReplicationPartnerProperties::~CReplicationPartnerProperties()
{
	RemovePageFromList((CPropertyPageBase*) &m_pageGeneral, FALSE);
	RemovePageFromList((CPropertyPageBase*) &m_pageAdvanced, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\repnodpp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	repnodpp.h
		Replication Node Property page
		
    FILE HISTORY:
        
*/

#if !defined(AFX_REPNODPP_H__04D55B71_4E32_11D1_B9B0_00C04FBF914A__INCLUDED_)
#define AFX_REPNODPP_H__04D55B71_4E32_11D1_B9B0_00C04FBF914A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef _CONFIG_H
#include "config.h"
#endif

#ifndef _LISTVIEW_H
#include "listview.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// CRepNodePropGen dialog

class CRepNodePropGen : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CRepNodePropGen)

// Construction
public:
	CRepNodePropGen();
	~CRepNodePropGen();

// Dialog Data
	//{{AFX_DATA(CRepNodePropGen)
	enum { IDD = IDD_REP_NODE_GENERAL };
	CButton	m_checkPushwithPartners;
	CButton	m_checkMigrate;
	BOOL	m_fMigrate;
	BOOL	m_fPushwithPartners;
	//}}AFX_DATA

	UINT	m_uImage;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRepNodePropGen)
	public:
	virtual BOOL OnApply();
	virtual void OnOK();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRepNodePropGen)
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckMigrate();
	afx_msg void OnCheckRepWithPartners();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    CConfiguration * m_pConfig;

	void    UpdateConfig();
	HRESULT UpdateServerConfiguration();
		
	HRESULT GetConfig();

public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CRepNodePropGen::IDD);};
};

/////////////////////////////////////////////////////////////////////////////
// CRepNodePropPush dialog

class CRepNodePropPush : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CRepNodePropPush)

// Construction
public:
	CRepNodePropPush();
	~CRepNodePropPush();

// Dialog Data
	//{{AFX_DATA(CRepNodePropPush)
	enum { IDD = IDD_REP_NODE_PUSH };
	CButton	m_checkPushPersistence;
	CSpinButtonCtrl	m_spinUpdateCount;
	CEdit	m_editUpdateCount;
	CButton	m_checkPushStartup;
	CButton	m_checkRepOnAddrChange;
	BOOL	m_fRepOnAddrChange;
	BOOL	m_fPushStartup;
	DWORD	m_dwPushUpdateCount;
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRepNodePropPush)
	public:
	virtual BOOL OnApply();
	virtual void OnOK();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRepNodePropPush)
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckPushOnAddressChange();
	afx_msg void OnCheckPushOnStartup();
	afx_msg void OnCheckPushPersist();
	afx_msg void OnChangeEditUpdateCount();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    CConfiguration * m_pConfig;

	void    UpdateConfig();
	HRESULT UpdateServerConfiguration();
		
	HRESULT GetConfig();
	CString ToString(int nNumber);

public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CRepNodePropPush::IDD);};
};


/////////////////////////////////////////////////////////////////////////////
// CRepNodePropPull dialog

class CRepNodePropPull : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CRepNodePropPull)

// Construction
public:
	CRepNodePropPull();
	~CRepNodePropPull();

// Dialog Data
	//{{AFX_DATA(CRepNodePropPull)
	enum { IDD = IDD_REP_NODE_PULL };
	CButton	m_checkPullPersistence;
	CSpinButtonCtrl	m_spinStartSecond;
	CSpinButtonCtrl	m_spinStartMinute;
	CSpinButtonCtrl	m_spinStartHour;
	CSpinButtonCtrl	m_spinRetryCount;
	CSpinButtonCtrl	m_spinRepIntMinute;
	CSpinButtonCtrl	m_spinRepIntHour;
	CSpinButtonCtrl	m_spinRepIntDay;
	CEdit	m_editStartSecond;
	CEdit	m_editStartMinute;
	CEdit	m_editStartHour;
	CEdit	m_editRetryCount;
	CEdit	m_editRepIntMinute;
	CEdit	m_editRepIntHour;
	CEdit	m_editRepIntDay;
	CButton	m_checkpullTrigOnStartup;
	BOOL	m_fpullTrigOnStartup;
	DWORD	m_dwRetryCount;
	int		m_nPullStartHour;
	int		m_nPullStartMinute;
	int		m_nPullStartSecond;
	int		m_nRepliDay;
	int		m_nRepliHour;
	int		m_nRepliMinute;
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRepNodePropPull)
	public:
	virtual BOOL OnApply();
	virtual void OnOK();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRepNodePropPull)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeEditRepIntHour();
	afx_msg void OnCheckPullPersist();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    CConfiguration * m_pConfig;

	DWORD   CalculatePullStartInt();
	DWORD   CalculateReplInt();
	
	void    UpdateConfig();
	HRESULT UpdateServerConfiguration();
		
	void    SetPullStartTimeData(DWORD dwPullStartTime);
	void    SetPullTimeIntData(DWORD dwPullInternal);
	
	HRESULT GetConfig();
	CString ToString(int nNumber);

public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CRepNodePropPull::IDD);};
};

/////////////////////////////////////////////////////////////////////////////
// CRepNodePropAdvanced dialog
#define PERSMODE_NON_GRATA   0
#define PERSMODE_GRATA       1

class CRepNodePropAdvanced : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CRepNodePropAdvanced)

// Construction
public:
	CRepNodePropAdvanced();
	~CRepNodePropAdvanced();

// Dialog Data
	//{{AFX_DATA(cRepNodePropAdvanced)
	enum { IDD = IDD_REP_NODE_ADVANCED };
	CButton	m_buttonAdd;
	CButton	m_buttonRemove;
	CButton	m_checkPushPersistence;
	CButton	m_checkPullPersistence;
	CListCtrl	m_listOwners;
	CStatic	m_staticDesp;
	CStatic	m_staticMulticastTTL;
	CStatic	m_staticMulticastInt;
	CSpinButtonCtrl	m_spinMulticastTTL;
	CSpinButtonCtrl	m_spinMulticastSecond;
	CSpinButtonCtrl	m_spinMulticastMinute;
	CSpinButtonCtrl	m_spinMulticastHour;
	CEdit	m_editMulticastSecond;
	CEdit	m_editMulticastTTL;
	CEdit	m_editMulticastMinute;
	CEdit	m_editMulticastHour;
	CButton	m_checkenableAutoConfig;
	BOOL	m_fEnableAuto;
	DWORD	m_dwHours;
	DWORD	m_dwMinutes;
	DWORD	m_dwSeconds;
	DWORD	m_dwMulticastTTL;
	//}}AFX_DATA

    int HandleSort(LPARAM lParam1, LPARAM lParam2);

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(cRepNodePropAdvanced)
	public:
	virtual BOOL OnApply();
	virtual void OnOK();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(cRepNodePropAdvanced)
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckEnableAutoPartnerConfig();
	afx_msg void OnChangeEditMulticastHour();
	afx_msg void OnButtonAdd();
	afx_msg void OnButtonRemove();
	afx_msg void OnItemchangedListOwners(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnclickListOwners(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnRadioGrata();
	afx_msg void OnRadioNonGrata();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    int                     m_nSortColumn;
    BOOL                    m_aSortOrder[COLUMN_MAX];

private:
	CConfiguration*			m_pConfig;

    DWORD                   m_dwPersonaMode;
    CStringArray            m_strPersonaNonGrata;
    CStringArray            m_strPersonaGrata;

	HRESULT GetConfig();
	CString ToString(int nNumber);

	void    EnableControls(BOOL bEnable = TRUE);
	void    FillControls();

	HRESULT UpdateServerConfiguration();
	void    UpdateConfig();
	void    InitializeControls();
    void    Sort(int nCol);
	
public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CRepNodePropAdvanced::IDD);};
	
    BOOL    IsDuplicate(CString &strServerName);
	BOOL    IsCurrentServer(CString &strServerName);

	// for reading and writing the servers to the registry
	DWORD   ReadFromRegistry();
	DWORD   WriteToRegistry();
	DWORD   ResolveIPAddress(CString &strIP, CString &strServerName);
	
    void    FillServerInfo();
	void    GetServerName(CString &strServerName);
	void    RemoveFromArray(CString &strSel);
	void    SetRemoveButtonState();
	
	CString			m_strIPAddress;
	CString			m_strServerName;

	typedef CString REGKEYNAME;

	static const REGKEYNAME lpstrPartnersRoot;
};


class CRepNodeProperties : public CPropertyPageHolderBase
{
	
public:
	CRepNodeProperties(ITFSNode *		  pNode,
					  IComponentData *	  pComponentData,
					  ITFSComponentData * pTFSCompData,
					  LPCTSTR			  pszSheetName
					  );
	virtual ~CRepNodeProperties();

	ITFSComponentData * GetTFSCompData()
	{
		if (m_spTFSCompData)
			m_spTFSCompData->AddRef();
		return m_spTFSCompData;
	}

	void SetConfig(CConfiguration * pConfig)
	{
		m_Config = *pConfig;
	}

    CConfiguration * GetConfig()
    {
        return &m_Config;
    }

public:
	CRepNodePropGen				m_pageGeneral;
	CRepNodePropPush			m_pagePush;
	CRepNodePropPull			m_pagePull;
	CRepNodePropAdvanced		m_pageAdvanced;
    CConfiguration              m_Config;

protected:
	SPITFSComponentData		m_spTFSCompData;
	
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REPNODPP_H__04D55B71_4E32_11D1_B9B0_00C04FBF914A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\reppart.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	reppart.cpp
		WINS replication partners node information. 
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "reppart.h"
#include "server.h"
#include "nodes.h"
#include "repnodpp.h"
#include "ipadddlg.h"

UINT guReplicationPartnersMessageStrings[] =
{
    IDS_REPLICATION_PARTNERS_MESSAGE_BODY1,
    IDS_REPLICATION_PARTNERS_MESSAGE_BODY2,
    IDS_REPLICATION_PARTNERS_MESSAGE_BODY3,
    IDS_REPLICATION_PARTNERS_MESSAGE_BODY4,
    -1
};

// various registry keys
const CReplicationPartnersHandler::REGKEYNAME CReplicationPartnersHandler::lpstrPullRoot = _T("SYSTEM\\CurrentControlSet\\Services\\wins\\Partners\\Pull");
const CReplicationPartnersHandler::REGKEYNAME CReplicationPartnersHandler::lpstrPushRoot = _T("SYSTEM\\CurrentControlSet\\Services\\wins\\Partners\\Push");
const CReplicationPartnersHandler::REGKEYNAME CReplicationPartnersHandler::lpstrNetBIOSName = _T("NetBIOSName");
const CReplicationPartnersHandler::REGKEYNAME CReplicationPartnersHandler::lpstrPersistence = _T("PersistentRplOn");


/*---------------------------------------------------------------------------
	CReplicationPartnersHandler::CReplicationPartnersHandler
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
CReplicationPartnersHandler::CReplicationPartnersHandler(
							ITFSComponentData *pCompData) 
							: CWinsHandler(pCompData)
{
	m_bExpanded = FALSE;
	//m_verbDefault = MMC_VERB_PROPERTIES;
	m_nState = loaded;
}


/*---------------------------------------------------------------------------
	CReplicationPartnersHandler::InitializeNode
		Initializes node specific data
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CReplicationPartnersHandler::InitializeNode
(
	ITFSNode * pNode
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	CString strTemp;
	strTemp.LoadString(IDS_REPLICATION);

	SetDisplayName(strTemp);

	m_strDescription.LoadString(IDS_REPLICATION_DISC);

	// Make the node immediately visible
	pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
	pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_REP_PARTNERS_FOLDER_CLOSED);
	pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_REP_PARTNERS_FOLDER_OPEN);
	pNode->SetData(TFS_DATA_USER, (LPARAM) this);
	pNode->SetData(TFS_DATA_TYPE, WINSSNAP_REPLICATION_PARTNERS);
    pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

	SetColumnStringIDs(&aColumns[WINSSNAP_REPLICATION_PARTNERS][0]);
	SetColumnWidths(&aColumnWidths[WINSSNAP_REPLICATION_PARTNERS][0]);

	return hrOK;
}

/*---------------------------------------------------------------------------
	CReplicationPartnersHandler::OnCreateNodeId2
		Returns a unique string for this node
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CReplicationPartnersHandler::OnCreateNodeId2(ITFSNode * pNode, CString & strId, DWORD * dwFlags)
{
    const GUID * pGuid = pNode->GetNodeType();

    CString strGuid;

    StringFromGUID2(*pGuid, strGuid.GetBuffer(256), 256);
    strGuid.ReleaseBuffer();

	SPITFSNode spServerNode;
    pNode->GetParent(&spServerNode);

    CWinsServerHandler * pServer = GETHANDLER(CWinsServerHandler, spServerNode);

    strId = pServer->m_strServerAddress + strGuid;

    return hrOK;
}


/*---------------------------------------------------------------------------
	Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
	CReplicationPartnersHandler::GetString
		Implementation of ITFSNodeHandler::GetString
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) 
CReplicationPartnersHandler::GetString
(
	ITFSNode *	pNode, 
	int			nCol
)
{
	if (nCol == 0 || nCol == -1)
		return GetDisplayName();

	else if(nCol == 1)
		return m_strDescription;

	else
		return NULL;
}


/*---------------------------------------------------------------------------
	CReplicationPartnersHandler::OnAddMenuItems
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CReplicationPartnersHandler::OnAddMenuItems
(
	ITFSNode *				pNode,
	LPCONTEXTMENUCALLBACK	pContextMenuCallback, 
	LPDATAOBJECT			lpDataObject, 
	DATA_OBJECT_TYPES		type, 
	DWORD					dwType,
	long *					pInsertionAllowed
)
{ 
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;
	CString strMenuItem;

	if (type == CCT_SCOPE)
	{
		// these menu items go in the new menu, 
		// only visible from scope pane
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
		    strMenuItem.LoadString(IDS_REP_NEW_REPLICATION_PARTNER);
		    hr = LoadAndAddMenuItem( pContextMenuCallback, 
								     strMenuItem, 
								     IDS_REP_NEW_REPLICATION_PARTNER,
								     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
								     0 );
		    ASSERT( SUCCEEDED(hr) );

		    strMenuItem.LoadString(IDS_REP_REPLICATE_NOW);
		    hr = LoadAndAddMenuItem( pContextMenuCallback, 
								     strMenuItem, 
								     IDS_REP_REPLICATE_NOW,
								     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
								     0 );
		    ASSERT( SUCCEEDED(hr) );
        }
	}
	return hr; 
}


/*---------------------------------------------------------------------------
	CReplicationPartnersHandler::OnCommand
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CReplicationPartnersHandler::OnCommand
(
	ITFSNode *			pNode, 
	long				nCommandId, 
	DATA_OBJECT_TYPES	type, 
	LPDATAOBJECT		pDataObject, 
	DWORD				dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = S_OK;

	switch(nCommandId)
	{

	case IDS_REP_REPLICATE_NOW:
		hr = OnReplicateNow(pNode);
		break;
	
	case IDS_REP_NEW_REPLICATION_PARTNER:
		hr = OnCreateRepPartner(pNode);
		break;
	
	default:
		break;
	}

	return hr;
}


/*!--------------------------------------------------------------------------
	CReplicationPartnersHandler::HasPropertyPages
		Implementation of ITFSNodeHandler::HasPropertyPages
	NOTE: the root node handler has to over-ride this function to 
	handle the snapin manager property page (wizard) case!!!
	
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CReplicationPartnersHandler::HasPropertyPages
(
	ITFSNode *			pNode,
	LPDATAOBJECT		pDataObject, 
	DATA_OBJECT_TYPES   type, 
	DWORD               dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = hrOK;
	
	if (dwType & TFS_COMPDATA_CREATE)
	{
		// This is the case where we are asked to bring up property
		// pages when the user is adding a new snapin.  These calls
		// are forwarded to the root node to handle.
		hr = hrOK;
	}
	else
	{
		// we have property pages in the normal case
		hr = hrOK;
	}
	return hr;
}


/*---------------------------------------------------------------------------
	CReplicationPartnersHandler::CreatePropertyPages
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CReplicationPartnersHandler::CreatePropertyPages
(
	ITFSNode *				pNode,
	LPPROPERTYSHEETCALLBACK lpProvider,
	LPDATAOBJECT			pDataObject, 
	LONG_PTR				handle, 
	DWORD					dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT	hr = hrOK;

	Assert(pNode->GetData(TFS_DATA_COOKIE) != 0);

    // get the server info
	SPITFSNode spServerNode;
    pNode->GetParent(&spServerNode);

    CWinsServerHandler * pServer = GETHANDLER(CWinsServerHandler, spServerNode);
    
	// Object gets deleted when the page is destroyed
	SPIComponentData spComponentData;
	m_spNodeMgr->GetComponentData(&spComponentData);

	CRepNodeProperties * pRepProp = 
				new CRepNodeProperties(	pNode, 
										spComponentData, 
										m_spTFSCompData, 
										NULL);
	pRepProp->m_pageGeneral.m_uImage = (UINT) pNode->GetData(TFS_DATA_IMAGEINDEX);
    pRepProp->SetConfig(&pServer->GetConfig());

	Assert(lpProvider != NULL);

	return pRepProp->CreateModelessSheet(lpProvider, handle);
}


/*---------------------------------------------------------------------------
	CReplicationPartnersHandler::OnPropertyChange
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CReplicationPartnersHandler::OnPropertyChange
(	
	ITFSNode *		pNode, 
	LPDATAOBJECT	pDataobject, 
	DWORD			dwType, 
	LPARAM			arg, 
	LPARAM			lParam
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CRepNodeProperties * pProp 
		= reinterpret_cast<CRepNodeProperties *>(lParam);

	LONG_PTR changeMask = 0;

	// tell the property page to do whatever now that we are back on the
	// main thread
	pProp->OnPropertyChange(TRUE, &changeMask);

	pProp->AcknowledgeNotify();

	if (changeMask)
		pNode->ChangeNode(changeMask);

	return hrOK;
}

/*---------------------------------------------------------------------------
	CReplicationPartnersHandler::CompareItems
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int)
CReplicationPartnersHandler::CompareItems
(
	ITFSComponent * pComponent, 
	MMC_COOKIE		cookieA, 
	MMC_COOKIE		cookieB, 
	int				nCol
) 
{ 
	SPITFSNode spNode1, spNode2;

	m_spNodeMgr->FindNode(cookieA, &spNode1);
	m_spNodeMgr->FindNode(cookieB, &spNode2);
	
	int nCompare = 0; 

	CReplicationPartner *pRepPart1 = GETHANDLER(CReplicationPartner, spNode1);
	CReplicationPartner *pRepPart2 = GETHANDLER(CReplicationPartner, spNode2);

	switch (nCol)
	{
		case 0:
		{
			//
            // Name compare 
			//
            CString strName1 = pRepPart1->GetServerName();
    			
            nCompare = strName1.CompareNoCase(pRepPart2->GetServerName());
		}
		break;

        case 1:
        {
            // compare the IP Addresses 
            CString strIp1, strIp2;

            strIp1 = pRepPart1->GetIPAddress();
            strIp2 = pRepPart2->GetIPAddress();

            CIpAddress ipa1(strIp1);
            CIpAddress ipa2(strIp2);

            if ((LONG) ipa1 < (LONG) ipa2)
                nCompare = -1;
            else
            if ((LONG) ipa1 > (LONG) ipa2)
                nCompare = 1;

            // default is equal
        }
        break;

        case 2:
        {
            // compare the types
            CString str1;
            
            str1 = pRepPart1->GetType();

            nCompare = str1.CompareNoCase(pRepPart2->GetType());
        }
        break;
	}

	return nCompare;
}


/*---------------------------------------------------------------------------
	Command handlers
 ---------------------------------------------------------------------------*/

HRESULT 
CReplicationPartnersHandler::OnExpand
(
	ITFSNode *		pNode, 
	LPDATAOBJECT	pDataObject,
	DWORD			dwType,
	LPARAM			arg, 
	LPARAM			param
)
{
	HRESULT hr = hrOK;

	if (m_bExpanded)
		return hr;

	BEGIN_WAIT_CURSOR

	// read the values from the registry
	hr = Load(pNode);
	if (SUCCEEDED(hr))
	{
		// remove any nodes that may have been created before we were expanded.
		pNode->DeleteAllChildren(FALSE);
		hr = CreateNodes(pNode);
	}
	else
	{
		WinsMessageBox(WIN32_FROM_HRESULT(hr));
	}

	END_WAIT_CURSOR
	
	return hr;
}


/*---------------------------------------------------------------------------
	CReplicationPartnersHandler::CreateNodes(ITFSNode *pNode)
		Adds the replication partnes to the result pane
	Author: v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CReplicationPartnersHandler::CreateNodes
(
	ITFSNode *	pNode
)
{
	HRESULT hr = hrOK;
	
	for (int i = 0; i < m_RepPartnersArray.GetSize(); i++)
	{
		SPITFSNode spRepNode;

		CReplicationPartner * pRep = 
			new CReplicationPartner(m_spTFSCompData,
									&m_RepPartnersArray.GetAt(i) );

		CreateLeafTFSNode(&spRepNode,
						  &GUID_WinsReplicationPartnerLeafNodeType,
						  pRep, 
						  pRep,
						  m_spNodeMgr);

		// Tell the handler to initialize any specific data
		pRep->InitializeNode((ITFSNode *) spRepNode);

		// Add the node as a child to the Active Leases container
		pNode->AddChild(spRepNode);
		
		pRep->Release();
	}
	
    return hr;
}


/*---------------------------------------------------------------------------
	CReplicationPartnersHandler::Load(ITFSNode *pNode)
		Loads the rpelication partners by reading from the registry
	Author: v-shubk
 ---------------------------------------------------------------------------*/
HRESULT
CReplicationPartnersHandler::Load
(
    ITFSNode *pNode
)
{
	DWORD err = ERROR_SUCCESS;
    HRESULT hr = hrOK;

	CString strServerName;
	GetServerName(pNode, strServerName);

    CString strTemp =_T("\\\\");
	strServerName = strTemp + strServerName;

	RegKey rkPull;
    err = rkPull.Open(HKEY_LOCAL_MACHINE, (LPCTSTR) lpstrPullRoot, KEY_READ, strServerName);
    if (err)
    {
        // might not be there, try to create
	    err = rkPull.Create(HKEY_LOCAL_MACHINE, 
						    (LPCTSTR)lpstrPullRoot, 
						    REG_OPTION_NON_VOLATILE, 
						    KEY_ALL_ACCESS,
						    NULL, 
						    strServerName);
    }

	RegKey rkPush;
    err = rkPush.Open(HKEY_LOCAL_MACHINE, (LPCTSTR) lpstrPushRoot, KEY_READ, strServerName);
	if (err)
    {
        err = rkPush.Create(HKEY_LOCAL_MACHINE, 
						    (LPCTSTR)lpstrPushRoot, 
						    REG_OPTION_NON_VOLATILE, 
						    KEY_ALL_ACCESS,
						    NULL, 
						    strServerName);
    }

	if (err)
		return HRESULT_FROM_WIN32(err);

	RegKeyIterator iterPushkey;
	RegKeyIterator iterPullkey;
	
	hr = iterPushkey.Init(&rkPush);
    if (FAILED(hr))
        return hr;

	hr = iterPullkey.Init(&rkPull);
    if (FAILED(hr))
        return hr;

	m_RepPartnersArray.RemoveAll();

	CWinsServerObj ws;
	CString strName;
	
	// Read in push partners
    hr = iterPushkey.Next(&strName, NULL);
    while (hr != S_FALSE && SUCCEEDED(hr))
    {
        // Key name is the IP address.
        ws.SetIpAddress(strName);
		ws.SetstrIPAddress(strName);

        CString strKey = (CString)lpstrPushRoot + _T("\\") + strName;
    
		RegKey rk;
        err = rk.Open(HKEY_LOCAL_MACHINE, strKey, KEY_READ, strServerName);
        if (err)
        {
            hr = HRESULT_FROM_WIN32(err);
            break;
        }

		if (err = rk.QueryValue(lpstrNetBIOSName, ws.GetNetBIOSName()))
        {
            // This replication partner is does not have a netbios
            // name listed with it.  This is not a major problem,
            // as the name is for display purposes only.
            CString strTemp;
            strTemp.LoadString(IDS_NAME_UNKNOWN);
            ws.GetNetBIOSName() = strTemp;
        }

		DWORD dwTest;

        if (rk.QueryValue(WINSCNF_UPDATE_COUNT_NM, (DWORD&) dwTest)
            != ERROR_SUCCESS)
        {
            ws.GetPushUpdateCount() = 0;
        }
		else
		{
			ws.GetPushUpdateCount() = dwTest;
		}
	
        ws.SetPush(TRUE, TRUE);

		// check for the persistence stuff
		dwTest = (rk.QueryValue(lpstrPersistence, dwTest) == ERROR_SUCCESS) ? dwTest : 0;
		ws.SetPushPersistence(dwTest);

        // Make sure the Pull intervals are reset.
        ws.SetPull(FALSE, TRUE);
        ws.GetPullReplicationInterval() = 0;
        ws.GetPullStartTime() = (time_t)0;

        m_RepPartnersArray.Add(ws);

        hr = iterPushkey.Next(&strName, NULL);
    }

    if (FAILED(hr))
        return hr;

	// Read in pull partners
    hr = iterPullkey.Next(&strName, NULL);
    while (hr != S_FALSE && SUCCEEDED(hr))
	{
		// Key name is the IP address.
		ws.SetIpAddress(strName);
		ws.SetstrIPAddress(strName);

        CString strKey = (CString)lpstrPullRoot + _T("\\") + strName;
		
        RegKey rk;
		err = rk.Open(HKEY_LOCAL_MACHINE, strKey, KEY_READ, strServerName);
		if (err)
		{
            hr = HRESULT_FROM_WIN32(err);
			break;
		}

        err = rk.QueryValue(lpstrNetBIOSName, ws.GetNetBIOSName());
		if (err)
		{
			// No netbios name given.
            CString strTemp;
            strTemp.LoadString(IDS_NAME_UNKNOWN);
            ws.GetNetBIOSName() = strTemp;
		}
		
		DWORD dwPullInt;

		err = rk.QueryValue(WINSCNF_RPL_INTERVAL_NM, (DWORD &)dwPullInt);
		if (err != ERROR_SUCCESS)
		{
			ws.GetPullReplicationInterval() = 0;
		}
		else
		{
			ws.GetPullReplicationInterval() = dwPullInt;
		}

        CString strSpTime;

		err = rk.QueryValue(WINSCNF_SP_TIME_NM, strSpTime);
		if (err != ERROR_SUCCESS)
		{
			ws.GetPullStartTime() = (time_t)0;
		}
		else
		{
            CIntlTime spTime(strSpTime);

			ws.GetPullStartTime() = spTime;
		}

		DWORD dwTest = 0;

		// check for the persistence stuff
		dwTest = (rk.QueryValue(lpstrPersistence, dwTest) == ERROR_SUCCESS) ? dwTest : 0;
		ws.SetPullPersistence(dwTest);

		int pos;
		CWinsServerObj wsTarget;

		// If it's already in the list as a push partner,
		// then simply set the push flag, as this replication
		// partner is both a push and a pull partner.
		if ((pos = IsInList(ws))!= -1)
		{
			wsTarget = (CWinsServerObj)m_RepPartnersArray.GetAt(pos);
			ASSERT(wsTarget != NULL);
			
			wsTarget.SetPull(TRUE, TRUE);
			wsTarget.GetPullReplicationInterval() = ws.GetPullReplicationInterval();
			wsTarget.GetPullStartTime() = ws.GetPullStartTime();
			wsTarget.SetPullPersistence(ws.GetPullPersistence());
			
			m_RepPartnersArray.SetAt(pos, wsTarget);
		}

		else
		{
			ws.SetPull(TRUE, TRUE);
			ws.SetPullPersistence(dwTest);

			// Reset push flags
			ws.SetPush(FALSE, TRUE);
			ws.GetPushUpdateCount() = 0;
			
			m_RepPartnersArray.Add(ws);
		}

        hr = iterPullkey.Next(&strName, NULL);
	}

    return hr;
}


/*---------------------------------------------------------------------------
	CReplicationPartnersHandler::IsInList
		Checks if the given server is present in the list of 
		replication partners, returns a valid value if found 
		else returns -1
	Author: v-shubk
 ---------------------------------------------------------------------------*/
int 
CReplicationPartnersHandler::IsInList
(
 const CIpNamePair& inpTarget, 
 BOOL bBoth 
) const

{
    CIpNamePair Current;
	int pos1;
   
    for (pos1 = 0;pos1 <m_RepPartnersArray.GetSize(); pos1++)
    {
        Current = (CIpNamePair)m_RepPartnersArray.GetAt(pos1);
        if (Current.Compare(inpTarget, bBoth) == 0)
        {
            return pos1;
        }
    }

    return -1;
}


/*---------------------------------------------------------------------------
	CReplicationPartnersHandler::GetServerName
		Gets the server name from the server node
	Suthor:v-shubk
 ---------------------------------------------------------------------------*/
void 
CReplicationPartnersHandler::GetServerName
(
	ITFSNode *	pNode,
	CString &	strName
)
{
	SPITFSNode spServerNode;
    pNode->GetParent(&spServerNode);

    CWinsServerHandler * pServer = GETHANDLER(CWinsServerHandler, spServerNode);

	strName = pServer->GetServerAddress();
}


/*---------------------------------------------------------------------------
	CReplicationPartnersHandler::OnReplicateNow(ITFSNode* pNode)
		Send the replication triger to all it's partners
	Author: v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CReplicationPartnersHandler::OnReplicateNow
(
    ITFSNode * pNode
)
{
	HRESULT hr = hrOK;
	SPITFSNode spServerNode;
    CThemeContextActivator themeActivator;    

    pNode->GetParent(&spServerNode);
    CWinsServerHandler * pServer = GETHANDLER(CWinsServerHandler, spServerNode);

	if (IDYES != AfxMessageBox(IDS_REP_START_CONFIRM, MB_YESNO))
		return hrOK;

	int nItems = (int)m_RepPartnersArray.GetSize();
	DWORD err;

	for (int n = 0; n < nItems; n++)
    {
		CWinsServerObj  ws;

        ws = m_RepPartnersArray.GetAt(n);

		BEGIN_WAIT_CURSOR

        if (ws.IsPull())
        {
            if ((err = ::SendTrigger(pServer->GetBinding(), (LONG) ws.GetIpAddress(), FALSE, FALSE)) != ERROR_SUCCESS)
            {
				::WinsMessageBox(WIN32_FROM_HRESULT(err));
				continue;
            }
		}
		if (ws.IsPush())
        {
            if ((err = ::SendTrigger(pServer->GetBinding(), (LONG) ws.GetIpAddress(), TRUE, TRUE)) != ERROR_SUCCESS)
            {
                ::WinsMessageBox(WIN32_FROM_HRESULT(err));
                continue;
            }
        }

		END_WAIT_CURSOR
    }
    
    if (err == ERROR_SUCCESS)
    {
        AfxMessageBox(IDS_REPL_QUEUED, MB_ICONINFORMATION);
    }

	return HRESULT_FROM_WIN32(err);
}


/*---------------------------------------------------------------------------
	CReplicationPartnersHandler::OnCreateRepPartner
		Invokes	new replication partner Wizard
	Author: v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CReplicationPartnersHandler::OnCreateRepPartner
(
	ITFSNode *	pNode
)
{
	HRESULT hr = hrOK;

	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// check to see if the user has access
    SPITFSNode spServerNode;
	pNode->GetParent(&spServerNode);

	CWinsServerHandler * pServer = GETHANDLER(CWinsServerHandler, spServerNode);

    if (!pServer->GetConfig().IsAdmin())
    {
        // access denied
        WinsMessageBox(ERROR_ACCESS_DENIED);
        
        return hr;
    }

    // the user has access.  ask for the partner info
    CNewReplicationPartner dlg;
    CThemeContextActivator themeActivator;

	dlg.m_spRepPartNode.Set(pNode);
	dlg.m_pRepPartHandler = this;

	if (dlg.DoModal() == IDOK)
	{
		// create the new replication partner
		CWinsServerObj ws;

		// grab the name and ip from the dlg
        ws.SetstrIPAddress(dlg.m_strServerIp);
        ws.SetIpAddress(dlg.m_strServerIp);
		ws.SetNetBIOSName(dlg.m_strServerName);

		// default is push/pull partner
		ws.SetPush(TRUE, TRUE);
		ws.SetPull(TRUE, TRUE);
		ws.SetPullClean(TRUE);
		ws.SetPushClean(TRUE);

		DWORD dwErr = AddRegEntry(pNode, ws);
		if (dwErr != ERROR_SUCCESS)
		{
			WinsMessageBox(dwErr);
		}
        else
        {
            HandleResultMessage(pNode);
        }
	}

	return hrOK;
}


/*---------------------------------------------------------------------------
	CReplicationPartnersHandler::Store(ITFSNode *pNode)
		Adds the new replication partner info to the registry
	Author: v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CReplicationPartnersHandler::Store
(
	ITFSNode * pNode
)
{
	DWORD err = ERROR_SUCCESS;

	CString strServerName;
	GetServerName(pNode, strServerName);

	CString strTemp =_T("\\\\");

	strServerName = strTemp + strServerName;

	RegKey rkPull;
	err = rkPull.Create(HKEY_LOCAL_MACHINE, 
						(LPCTSTR)lpstrPullRoot, 
						REG_OPTION_NON_VOLATILE, 
						KEY_ALL_ACCESS,
						NULL, 
						strServerName);

	RegKey rkPush;
	err = rkPush.Create(HKEY_LOCAL_MACHINE, 
						(LPCTSTR)lpstrPushRoot, 
						REG_OPTION_NON_VOLATILE, 
						KEY_ALL_ACCESS,
						NULL, 
						strServerName);

	if (err)
        return HRESULT_FROM_WIN32(err);

	RegKeyIterator iterPushkey;
	RegKeyIterator iterPullkey;
	
	err = iterPushkey.Init(&rkPush);
	err = iterPullkey.Init(&rkPull);

	if (err)
        return HRESULT_FROM_WIN32(err);

	CWinsServerObj ws;

	CString strName;
	
    // Read in push partners
    while ((err = iterPushkey.Next(&strName, NULL)) == ERROR_SUCCESS )
    {
        // Key name is the IP address.
        ws.SetIpAddress(strName);
		ws.SetstrIPAddress(strName);

        CString strKey = (CString)lpstrPushRoot + _T("\\") + strName;
        RegKey rk;
		err = rk.Create(HKEY_LOCAL_MACHINE,
						strKey, 
						0, 
						KEY_ALL_ACCESS, 
						NULL,
						strServerName);
        
		if (err)
        {
            return HRESULT_FROM_WIN32(err);
        }
       
		if (err = rk.QueryValue(lpstrNetBIOSName, ws.GetNetBIOSName()))
        {
            // This replication partner is does not have a netbios
            // name listed with it.  This is not a major problem,
            // as the name is for display purposes only.
            CString strTemp;
            strTemp.LoadString(IDS_NAME_UNKNOWN);
            ws.GetNetBIOSName() = strTemp;
        }

		DWORD dwTest;

        if (rk.QueryValue(WINSCNF_UPDATE_COUNT_NM, (DWORD&) dwTest)	!= ERROR_SUCCESS)
        {
            ws.GetPushUpdateCount() = 0;
        }
        
        ws.SetPush(TRUE, TRUE);

        // Make sure the Pull intervals are reset.
        ws.SetPull(FALSE, TRUE);
        ws.GetPullReplicationInterval() = 0;
        ws.GetPullStartTime() = (time_t)0;

        m_RepPartnersArray.Add(ws);
	}

	// Read in pull partners
	while ((err = iterPullkey.Next(&strName, NULL)) == ERROR_SUCCESS)
	{
		// Key name is the IP address.
		ws.SetIpAddress(strName);
		ws.SetstrIPAddress(strName);
		
        CString strKey = (CString)lpstrPullRoot + _T("\\") + strName;
		
        RegKey rk;
		err = rk.Create(HKEY_LOCAL_MACHINE, strKey, 0, KEY_ALL_ACCESS, NULL, strServerName);
		if (err)
		{
			return HRESULT_FROM_WIN32(err);
		}

		if (err = rk.QueryValue(lpstrNetBIOSName, ws.GetNetBIOSName()))
		{
			// No netbios name given.
            CString strTemp;
            strTemp.LoadString(IDS_NAME_UNKNOWN);
            ws.GetNetBIOSName() = strTemp;
		}
		
        DWORD dwPullInt;

		if (rk.QueryValue(WINSCNF_RPL_INTERVAL_NM, (DWORD &)dwPullInt) != ERROR_SUCCESS)
		{
			ws.GetPullReplicationInterval() = 0;
		}
		else
		{
			ws.GetPullReplicationInterval() = dwPullInt;
		}

		if (rk.QueryValue(WINSCNF_SP_TIME_NM, (DWORD &)dwPullInt) != ERROR_SUCCESS)
		{
			ws.GetPullStartTime() = (time_t)0;
		}
		else
		{
			ws.GetPullStartTime() = (time_t)dwPullInt;
		}

		int pos;
		CWinsServerObj wsTarget;

		// If it's already in the list as a push partner,
		// then simply set the push flag, as this replication
		// partner is both a push and a pull partner.
		if ((pos = IsInList(ws))!= -1)
		{
			wsTarget = (CWinsServerObj)m_RepPartnersArray.GetAt(pos);
			ASSERT(wsTarget != NULL);
		
            wsTarget.SetPull(TRUE, TRUE);
			wsTarget.GetPullReplicationInterval() = ws.GetPullReplicationInterval();
			wsTarget.GetPullStartTime() = ws.GetPullStartTime();
			
            m_RepPartnersArray.SetAt(pos, wsTarget);
		}
		else
		{
			ws.SetPull(TRUE, TRUE);

            // Reset push flags
			ws.SetPush(FALSE, TRUE);
			ws.GetPushUpdateCount() = 0;
			m_RepPartnersArray.Add(ws);
		}
	}
	
    return hrOK;
}


/*---------------------------------------------------------------------------
	CReplicationPartnersHandler::OnResultDelete
		Deletes replication partner
	Author: v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CReplicationPartnersHandler::OnResultDelete
(
	ITFSComponent * pComponent, 
	LPDATAOBJECT	pDataObject,
	MMC_COOKIE		cookie,
	LPARAM			arg, 
	LPARAM			param
)
{
	HRESULT hr = hrOK;
	DWORD err = ERROR_SUCCESS;
    CThemeContextActivator themeActivator;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// translate the cookie into a node pointer
	SPITFSNode spReplicationPartnersHandler, spSelectedNode;

    m_spNodeMgr->FindNode(cookie, &spReplicationPartnersHandler);
    pComponent->GetSelectedNode(&spSelectedNode);

	Assert(spSelectedNode == spReplicationPartnersHandler);
	
	if (spSelectedNode != spReplicationPartnersHandler)
		return hr;

	SPITFSNode spServerNode ;
	spReplicationPartnersHandler->GetParent(&spServerNode);
	
	CWinsServerHandler *pServer = GETHANDLER(CWinsServerHandler, spServerNode);
	
	// build the list of selected nodes
	CTFSNodeList listNodesToDelete;
	hr = BuildSelectedItemList(pComponent, &listNodesToDelete);

	// Confirm with the user
	CString strMessage, strTemp;
	int nNodes = (int)listNodesToDelete.GetCount();
	if (nNodes > 1)
	{
		strTemp.Format(_T("%d"), nNodes);
		AfxFormatString1(strMessage, IDS_DELETE_ITEMS, (LPCTSTR) strTemp);
	}
	else
	{
		strMessage.LoadString(IDS_DELETE_ITEM);
	}

	if (AfxMessageBox(strMessage, MB_YESNO) == IDNO)
	{
		return NOERROR;
	}
	
    BOOL fAskedPurge = FALSE;
    BOOL fPurge = FALSE;

    while (listNodesToDelete.GetCount() > 0)
	{
		SPITFSNode spRepNode;
		spRepNode = listNodesToDelete.RemoveHead();
		
		CReplicationPartner * pItem = GETHANDLER(CReplicationPartner , spRepNode);
		CString str = pItem->GetServerName();

		// Do we also need to remove all references to this
		// WINS server from the database?
        if (!fAskedPurge)
        {
		    int nReturn = AfxMessageBox(IDS_MSG_PURGE_WINS, MB_YESNOCANCEL | MB_DEFBUTTON2 | MB_ICONQUESTION);
		    
            fAskedPurge = TRUE;

		    if (nReturn == IDYES)
		    {
			    fPurge = TRUE;
		    }
		    else if (nReturn == IDCANCEL)
		    {
			    //
			    // Forget the whole thing
			    //
			    return NOERROR;
		    }
        }

		CWinsServerObj pws = pItem->m_Server;

        if (pws.IsPush() || pws.IsPull())
        {
			pws.SetPush(FALSE);
			pws.SetPushClean(FALSE);
			pws.SetPull(FALSE);
			pws.SetPullClean(FALSE);

			err = UpdateReg(spReplicationPartnersHandler, &pws);
        }
       
        if (err == ERROR_SUCCESS && fPurge)
        {
            BEGIN_WAIT_CURSOR
            
			err = pServer->DeleteWinsServer((LONG) pws.GetIpAddress());
            
			END_WAIT_CURSOR
        }

		if (err == ERROR_SUCCESS)
        {
			int pos = IsInList(pws);
            m_RepPartnersArray.RemoveAt(pos,pws);
			
            //
			// Remove from UI now
			//
			spReplicationPartnersHandler->RemoveChild(spRepNode);
			spRepNode.Release();
        }

        if (err != ERROR_SUCCESS)
        {
            if (::WinsMessageBox(err, MB_OKCANCEL) == IDCANCEL)
                break;
        }
    }

    HandleResultMessage(spReplicationPartnersHandler);

    return hr;
}

/*---------------------------------------------------------------------------
	CReplicationPartnersHandler::OnResultRefresh
		Base handler override
	Author: v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CReplicationPartnersHandler::OnResultRefresh
(
    ITFSComponent *     pComponent,
    LPDATAOBJECT        pDataObject,
    MMC_COOKIE          cookie,
    LPARAM              arg,
    LPARAM              lParam
)
{
	HRESULT     hr = hrOK;
    SPITFSNode  spNode;

	CORg (m_spNodeMgr->FindNode(cookie, &spNode));

	BEGIN_WAIT_CURSOR

    OnRefreshNode(spNode, pDataObject);

	END_WAIT_CURSOR

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CReplicationPartnersHandler::OnResultSelect
		Handles the MMCN_SELECT notifcation 
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CReplicationPartnersHandler::OnResultSelect
(
	ITFSComponent * pComponent, 
	LPDATAOBJECT	pDataObject, 
    MMC_COOKIE      cookie,
	LPARAM			arg, 
	LPARAM			lParam
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT         hr = hrOK;
    SPITFSNode      spNode;

    CORg(CWinsHandler::OnResultSelect(pComponent, pDataObject, cookie, arg, lParam));

    m_spResultNodeMgr->FindNode(cookie, &spNode);

    HandleResultMessage(spNode);

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CReplicationPartnersHandler::HandleResultMessage
		Displays the message in the result pane 
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CReplicationPartnersHandler::HandleResultMessage(ITFSNode * pNode)
{
    HRESULT hr = hrOK;

    if (m_RepPartnersArray.GetSize() == 0)
    {
        CString strTitle, strBody, strTemp;
        int i;
        
        strTitle.LoadString(IDS_REPLICATION_PARTNERS_MESSAGE_TITLE);

        for (i = 0; ; i++)
        {
            if (guReplicationPartnersMessageStrings[i] == -1)
                break;

            strTemp.LoadString(guReplicationPartnersMessageStrings[i]);
            strBody += strTemp;
        }

        ShowMessage(pNode, strTitle, strBody, Icon_Information);
    }
    else
    {
        ClearMessage(pNode);
    }

    return hr;
}

/*---------------------------------------------------------------------------
	CReplicationPartnersHandler::OnRefreshNode
		refreshes the list of replication partners
	Author: v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CReplicationPartnersHandler::OnRefreshNode
(
	ITFSNode *		pNode, 
	LPDATAOBJECT	pDataObject
)
{
	HRESULT hr = hrOK;

	// remove the nodes first
	hr = RemoveChildren(pNode);
	
	hr = Load(pNode);

	if (SUCCEEDED(hr))
    {
		DWORD err = CreateNodes(pNode);

        HandleResultMessage(pNode);
    }

	return hr;

}


/*---------------------------------------------------------------------------
	CReplicationPartnersHandler:: RemoveChildren
		Deletes the child nodes 
	Author: v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CReplicationPartnersHandler:: RemoveChildren
(
 ITFSNode* pNode
)
{
	// enumerate thro' all the nodes
	HRESULT hr = hrOK;
	SPITFSNodeEnum spNodeEnum;
	SPITFSNode spCurrentNode;
	ULONG nNumReturned = 0;
	
	// get the enumerator for this node
	pNode->GetEnum(&spNodeEnum);

	spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	while (nNumReturned)
	{
		// walk the list of replication servers 
		pNode->RemoveChild(spCurrentNode);
		spCurrentNode.Release();
		
		// get the next Server in the list
		spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	}

	return hr;
}


/*---------------------------------------------------------------------------
	CReplicationPartnersHandler::OnGetResultViewType
		Overridden for multiple selection
	Author: v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CReplicationPartnersHandler::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    HRESULT hr = hrOK;

    // call the base class to see if it is handling this
    if (CWinsHandler::OnGetResultViewType(pComponent, cookie, ppViewType, pViewOptions) != S_OK)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;
		
		hr = S_FALSE;
	}

    return hr;
}


/*---------------------------------------------------------------------------
	CReplicationPartnersHandler::UpdateReg()

			Updates the regisrty, called from OnApply()
---------------------------------------------------------------------------*/
DWORD 
CReplicationPartnersHandler::UpdateReg(ITFSNode *pNode, CWinsServerObj* pws)
{
	DWORD err = ERROR_SUCCESS;
    HRESULT hr = hrOK;

	CString strServerName;
	GetServerName(pNode, strServerName);

	const DWORD dwZero = 0;

	CString strTemp =_T("\\\\");

	strServerName = strTemp + strServerName;


	RegKey rkPush;
	RegKey rkPull;

	CString strKey = lpstrPushRoot + _T("\\") + (CString)pws->GetstrIPAddress();
	err = rkPush.Create(HKEY_LOCAL_MACHINE, 
						(CString)lpstrPushRoot,
						0, 
						KEY_ALL_ACCESS,
						NULL, 
						strServerName);
    if (err)
        return err;

	strKey = lpstrPullRoot + _T("\\") + (CString)pws->GetstrIPAddress();
	
	err = rkPull.Create(HKEY_LOCAL_MACHINE, 
						(CString)lpstrPullRoot,
						0, 
						KEY_ALL_ACCESS,
						NULL, 
						strServerName);
    if (err)
        return err;

	RegKeyIterator iterPushkey;
	RegKeyIterator iterPullkey;
	
	hr = iterPushkey.Init(&rkPush);
    if (FAILED(hr))
        return WIN32_FROM_HRESULT(hr);

	hr = iterPullkey.Init(&rkPull);
    if (FAILED(hr))
        return WIN32_FROM_HRESULT(hr);

	DWORD errDel;
	CString csKeyName;

	// if none, delete the key from registry
	if (!pws->IsPush() && !pws->IsPull())
	{
		// cleanup push partners list
		
        hr = iterPushkey.Next (&csKeyName, NULL);
		while (hr != S_FALSE && SUCCEEDED(hr))
        {
           	if (csKeyName == pws->GetstrIPAddress())
			{
                errDel = RegDeleteKey (HKEY(rkPush), csKeyName);
                iterPushkey.Reset();
            }
            hr = iterPushkey.Next (&csKeyName, NULL);
        }

        if (FAILED(hr))
            err = WIN32_FROM_HRESULT(hr);

		hr = iterPullkey.Next (&csKeyName, NULL);
		while (hr != S_FALSE && SUCCEEDED(hr))
        {
           	if (csKeyName == pws->GetstrIPAddress())
			{
                errDel = RegDeleteKey (HKEY(rkPull), csKeyName);
                iterPullkey.Reset();
            }
            hr = iterPullkey.Next (&csKeyName, NULL);
        }

        if (FAILED(hr))
            err = WIN32_FROM_HRESULT(hr);
	}

	return err;
}

/*---------------------------------------------------------------------------
	CReplicationPartnersHandler::UpdateReg(ITFSNode *pNode, 
											CWinsServerObj* pws)

		Creates a new replication partner entry
---------------------------------------------------------------------------*/
DWORD 
CReplicationPartnersHandler::AddRegEntry(ITFSNode * pNode, CWinsServerObj & ws)
{
    // get the server handler for default values
	SPITFSNode spServerNode;
	pNode->GetParent(&spServerNode);

	CWinsServerHandler * pServer = GETHANDLER(CWinsServerHandler, spServerNode);

	// Set the defaults
    ws.SetPushUpdateCount(pServer->GetConfig().m_dwPushUpdateCount);
    ws.SetPullReplicationInterval(pServer->GetConfig().m_dwPullTimeInterval);
    ws.SetPullStartTime(pServer->GetConfig().m_dwPullSpTime);

	ws.SetPullPersistence(pServer->GetConfig().m_dwPullPersistence);
	ws.SetPushPersistence(pServer->GetConfig().m_dwPushPersistence);

	// write the information to the registry
	CString strTemp =_T("\\\\");
	CString strServerName;
	GetServerName(pNode, strServerName);

	strServerName = strTemp + strServerName;

	DWORD err;
    DWORD dwZero = 0;

	RegKey rk;

    if (ws.IsPush())
	{
		CString strKey = lpstrPushRoot + _T("\\") + (CString)ws.GetstrIPAddress();
		err = rk.Create(HKEY_LOCAL_MACHINE, strKey, 0, KEY_ALL_ACCESS, NULL, strServerName);

		DWORD dwResult;

		if (!err)
        {
			err = rk.SetValue(lpstrNetBIOSName, ws.GetNetBIOSName());

		    if (!err)
			    err = rk.QueryValue(WINSCNF_SELF_FND_NM, (DWORD&)dwResult);

		    if (err)
			    err = rk.SetValue(WINSCNF_SELF_FND_NM,(DWORD&) dwZero);

		    DWORD dwPushUpdateCount = (LONG) ws.GetPushUpdateCount();

		    if (dwPushUpdateCount > 0)
			    err = rk.SetValue(WINSCNF_UPDATE_COUNT_NM, (DWORD&)dwPushUpdateCount);

            DWORD dwPersistence = ws.GetPushPersistence();
            err = rk.SetValue(lpstrPersistence, dwPersistence);
        }
	
    }

	if (ws.IsPull())
	{
		CString strKey = lpstrPullRoot + _T("\\") + (CString)ws.GetstrIPAddress();
		err = rk.Create(HKEY_LOCAL_MACHINE, strKey, 0, KEY_ALL_ACCESS, NULL, strServerName);

		DWORD dwResult;

		if (!err)
        {
			err = rk.SetValue(lpstrNetBIOSName, ws.GetNetBIOSName());

		    if (!err)
			    err = rk.QueryValue(WINSCNF_SELF_FND_NM, dwResult);

		    if (err)
			    err = rk.SetValue(WINSCNF_SELF_FND_NM, (DWORD) dwZero);

		    DWORD dwPullTimeInterval = (LONG) ws.GetPullReplicationInterval();
		    
            if (dwPullTimeInterval > 0)
		    {
			    err = rk.SetValue(WINSCNF_RPL_INTERVAL_NM, dwPullTimeInterval);
		    }

            DWORD dwSpTime = (DWORD) ws.GetPullStartTime();
		    
            if (!err)
		    {
                if (dwSpTime > (time_t)0)
				    err = rk.SetValue(WINSCNF_SP_TIME_NM, ws.GetPullStartTime().IntlFormat(CIntlTime::TFRQ_MILITARY_TIME));
		    }

            DWORD dwPersistence = ws.GetPullPersistence();
            err = rk.SetValue(lpstrPersistence, dwPersistence);
        }
    }

	if (err == ERROR_SUCCESS)
	{
		// add to the list of replication partners
		m_RepPartnersArray.Add(ws);

		SPITFSNode	  spNode;
		SPITFSNodeMgr spNodeMgr;
		pNode->GetNodeMgr(&spNodeMgr);

		// Create a new node for this partner
		CReplicationPartner *pRepNew = new CReplicationPartner(m_spTFSCompData, &ws);

		CreateLeafTFSNode(&spNode,
						   &GUID_WinsReplicationPartnerLeafNodeType,
						   pRepNew,
						   pRepNew,
						   spNodeMgr);

		// Tell the handler to initialize any specific data
		pRepNew->InitializeNode((ITFSNode *) spNode);

		pNode->AddChild(spNode);
		pRepNew->Release();
	}

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\repnodpp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	repnodpp.cpp
		Replication Node Property page
		
    FILE HISTORY:
        
*/

// RepNodpp.cpp : implementation file
//

#include "stdafx.h"
#include "winssnap.h"
#include "server.h"
#include "ipadddlg.h"
#include "tregkey.h"
#include "RepNodpp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define MAX_DAY		UD_MAXVAL
#define MAX_HOUR	23
#define	MAX_MINUTE	59

const CRepNodePropAdvanced::REGKEYNAME CRepNodePropAdvanced::lpstrPartnersRoot = _T("SYSTEM\\CurrentControlSet\\Services\\wins\\Partners");

const LPCTSTR lpstrPersonaMode = _T("PersonaMode");
const LPCTSTR lpstrPersonaNonGrata = _T("PersonaNonGrata");
const LPCTSTR lpstrPersonaGrata = _T("PersonaGrata");

/////////////////////////////////////////////////////////////////////////////
// CRepNodePropGen property page

IMPLEMENT_DYNCREATE(CRepNodePropGen, CPropertyPageBase)

CRepNodePropGen::CRepNodePropGen() : CPropertyPageBase(CRepNodePropGen::IDD)
{
	//{{AFX_DATA_INIT(CRepNodePropGen)
	m_fMigrate = FALSE;
	m_fPushwithPartners = FALSE;
	//}}AFX_DATA_INIT
}


CRepNodePropGen::~CRepNodePropGen()
{

}


void CRepNodePropGen::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRepNodePropGen)
	DDX_Control(pDX, IDC_CHECK_REP_WITH_PARTNERS, m_checkPushwithPartners);
	DDX_Control(pDX, IDC_CHECK_MIGRATE, m_checkMigrate);
	DDX_Check(pDX, IDC_CHECK_MIGRATE, m_fMigrate);
	DDX_Check(pDX, IDC_CHECK_REP_WITH_PARTNERS, m_fPushwithPartners);
	//}}AFX_DATA_MAP
}



BEGIN_MESSAGE_MAP(CRepNodePropGen, CPropertyPageBase)
	//{{AFX_MSG_MAP(CRepNodePropGen)
	ON_BN_CLICKED(IDC_CHECK_MIGRATE, OnCheckMigrate)
	ON_BN_CLICKED(IDC_CHECK_REP_WITH_PARTNERS, OnCheckRepWithPartners)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CRepNodePropGen message handlers

BOOL 
CRepNodePropGen::OnApply() 
{
	if (!IsDirty())
		return TRUE;

	HRESULT hr = UpdateServerConfiguration();
	if (FAILED(hr))
    {
        return FALSE;
    }
    else
    {
	    return CPropertyPageBase::OnApply();
    }
}

void 
CRepNodePropGen::OnOK() 
{
	CPropertyPageBase::OnOK();
}


BOOL 
CRepNodePropGen::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();

	SPITFSNode				spNode;
	CWinsServerHandler		*pServer;
	SPITFSNode				spParentNode;

	GetConfig();

	m_checkMigrate.SetCheck(m_pConfig->m_fMigrateOn);
	m_checkPushwithPartners.SetCheck(m_pConfig->m_fRplOnlyWithPartners);

    // load the correct icon
    for (int i = 0; i < ICON_IDX_MAX; i++)
    {
        if (g_uIconMap[i][1] == m_uImage)
        {
            HICON hIcon = LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
            if (hIcon)
                ((CStatic *) GetDlgItem(IDC_STATIC_ICON))->SetIcon(hIcon);
            break;
        }
    }

	return TRUE;  
}

void CRepNodePropGen::OnCheckMigrate() 
{
    SetDirty(TRUE);    
}

void CRepNodePropGen::OnCheckRepWithPartners() 
{
    SetDirty(TRUE);    
}

/*---------------------------------------------------------------------------
	CRepNodePropGen::GetConfig()
		Gets the CConfiguration object from the server node
 ---------------------------------------------------------------------------*/
HRESULT 
CRepNodePropGen::GetConfig()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT	hr = hrOK;

    m_pConfig = ((CRepNodeProperties *) GetHolder())->GetConfig();

    return hr;
}


/*---------------------------------------------------------------------------
	CRepNodePropGen::UpdateServerConfiguration()	
		Updates the values for the CConfiguration object in the Server Node
 ---------------------------------------------------------------------------*/
HRESULT 
CRepNodePropGen::UpdateServerConfiguration()
{
	// Reflect the changes in the server's CConfiguration object
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT				hr = hrOK;
	SPITFSNode			spNode;
	CWinsServerHandler	*pServer;
	SPITFSNode			spParentNode;

	UpdateData();

	// get the server
	spNode = GetHolder()->GetNode();
	
    // get it's parent
	spNode->GetParent(&spParentNode);

	pServer = GETHANDLER(CWinsServerHandler, spParentNode);

	UpdateConfig();

    // now write to server
    DWORD err = m_pConfig->Store();
    if (err != ERROR_SUCCESS)
    {
        // something bad happened
        WinsMessageBox(err);
    }
    else
    {   
        // success update our local copy
        pServer->SetConfig(*m_pConfig);
    }

    return HRESULT_FROM_WIN32(err);
}


/*---------------------------------------------------------------------------
	CRepNodePropGen::UpdateConfig()	
		Updates the values for the CConfiguration object in the Server Node
 ---------------------------------------------------------------------------*/
void 
CRepNodePropGen::UpdateConfig()
{
	m_pConfig->m_fMigrateOn = m_fMigrate;
	m_pConfig->m_fRplOnlyWithPartners = m_fPushwithPartners;
}



/////////////////////////////////////////////////////////////////////////////
// CRepNodePropPush property page

IMPLEMENT_DYNCREATE(CRepNodePropPush, CPropertyPageBase)

CRepNodePropPush::CRepNodePropPush() : CPropertyPageBase(CRepNodePropPush::IDD)
{
	//{{AFX_DATA_INIT(CRepNodePropPush)
	m_fRepOnAddrChange = FALSE;
	m_fPushStartup = FALSE;
	m_dwPushUpdateCount = 0;
	//}}AFX_DATA_INIT
}


CRepNodePropPush::~CRepNodePropPush()
{

}


void CRepNodePropPush::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRepNodePropPush)
	DDX_Control(pDX, IDC_CHECK_PUSH_PERSIST, m_checkPushPersistence);
	DDX_Control(pDX, IDC_SPIN_UPDATE_COUNT, m_spinUpdateCount);
	DDX_Control(pDX, IDC_EDIT_UPDATE_COUNT, m_editUpdateCount);
	DDX_Control(pDX, IDC_CHECK_PUSH_ON_STARTUP, m_checkPushStartup);
	DDX_Control(pDX, IDC_CHECK_PUSH_ON_ADDRESS_CHANGE, m_checkRepOnAddrChange);
	DDX_Check(pDX, IDC_CHECK_PUSH_ON_ADDRESS_CHANGE, m_fRepOnAddrChange);
	DDX_Check(pDX, IDC_CHECK_PUSH_ON_STARTUP, m_fPushStartup);
	DDX_Text(pDX, IDC_EDIT_UPDATE_COUNT, m_dwPushUpdateCount);
	//}}AFX_DATA_MAP
}



BEGIN_MESSAGE_MAP(CRepNodePropPush, CPropertyPageBase)
	//{{AFX_MSG_MAP(CRepNodePropPush)
	ON_BN_CLICKED(IDC_CHECK_PUSH_ON_ADDRESS_CHANGE, OnCheckPushOnAddressChange)
	ON_BN_CLICKED(IDC_CHECK_PUSH_ON_STARTUP, OnCheckPushOnStartup)
	ON_BN_CLICKED(IDC_CHECK_PUSH_PERSIST, OnCheckPushPersist)
	ON_EN_CHANGE(IDC_EDIT_UPDATE_COUNT, OnChangeEditUpdateCount)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CRepNodePropPush message handlers

BOOL 
CRepNodePropPush::OnApply() 
{
	if (!IsDirty())
		return TRUE;

	HRESULT hr = UpdateServerConfiguration();
	if (FAILED(hr))
    {
        return FALSE;
    }
    else
    {
	    return CPropertyPageBase::OnApply();
    }
}

void 
CRepNodePropPush::OnOK() 
{
	CPropertyPageBase::OnOK();
}


BOOL 
CRepNodePropPush::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();

	SPITFSNode				spNode;
	CWinsServerHandler		*pServer;
	SPITFSNode				spParentNode;

	GetConfig();

	m_checkPushStartup.SetCheck(m_pConfig->m_fPushInitialReplication);
    m_checkRepOnAddrChange.SetCheck(m_pConfig->m_fPushReplOnAddrChange);

	m_spinUpdateCount.SetRange(0, UD_MAXVAL);
	m_editUpdateCount.SetWindowText(ToString(m_pConfig->m_dwPushUpdateCount));

	// now for the persistence info
	if (m_pConfig->m_dwMajorVersion < 5)
	{
		// not supported, disable controls
		m_checkPushPersistence.SetCheck(FALSE);
		m_checkPushPersistence.EnableWindow(FALSE);
	}
	else
	{
		if (m_pConfig->m_dwPushPersistence)
			m_checkPushPersistence.SetCheck(TRUE);
		else
			m_checkPushPersistence.SetCheck(FALSE);
	}
    
    
    return TRUE;  
}

void CRepNodePropPush::OnCheckPushOnAddressChange() 
{
    SetDirty(TRUE);
}

void CRepNodePropPush::OnCheckPushOnStartup() 
{
    SetDirty(TRUE);
}

void CRepNodePropPush::OnCheckPushPersist() 
{
    SetDirty(TRUE);	
}

void CRepNodePropPush::OnChangeEditUpdateCount() 
{
    SetDirty(TRUE);
}

/*---------------------------------------------------------------------------
	CRepNodePropPush::GetConfig()
		Gets the CConfiguration object from the server node
 ---------------------------------------------------------------------------*/
HRESULT 
CRepNodePropPush::GetConfig()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT	hr = hrOK;

    m_pConfig = ((CRepNodeProperties *) GetHolder())->GetConfig();

    return hr;
}


/*---------------------------------------------------------------------------
	CRepNodePropPush::UpdateServerConfiguration()	
		Updates the values for the CConfiguration object in the Server Node
 ---------------------------------------------------------------------------*/
HRESULT 
CRepNodePropPush::UpdateServerConfiguration()
{
	// Reflect the changes in the server's CConfiguration object
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT				hr = hrOK;
	SPITFSNode			spNode;
	CWinsServerHandler	*pServer;
	SPITFSNode			spParentNode;
    CThemeContextActivator themeActivator;

	UpdateData();

    if ( ( (m_dwPushUpdateCount > 0) & 
           (m_dwPushUpdateCount < WINSCNF_MIN_VALID_UPDATE_CNT) ) &
         (!m_pConfig->m_dwPushPersistence) )
    {
        CString strMessage, strValue;
        strValue.Format(_T("%d"), WINSCNF_MIN_VALID_UPDATE_CNT);

        AfxFormatString1(strMessage, IDS_ERR_UPDATE_COUNT, strValue);

        AfxMessageBox(strMessage);
        m_editUpdateCount.SetFocus();

        return E_FAIL;
    }

	// get the server
	spNode = GetHolder()->GetNode();
	
    // get it's parent
	spNode->GetParent(&spParentNode);

	pServer = GETHANDLER(CWinsServerHandler, spParentNode);

	UpdateConfig();

    // now write to server
    DWORD err = m_pConfig->Store();
    if (err != ERROR_SUCCESS)
    {
        // something bad happened
        WinsMessageBox(err);
    }
    else
    {   
        // success update our local copy
        pServer->SetConfig(*m_pConfig);
    }

    return HRESULT_FROM_WIN32(err);
}


/*---------------------------------------------------------------------------
	CRepNodePropPush::UpdateConfig()	
		Updates the values for the CConfiguration object in the Server Node
 ---------------------------------------------------------------------------*/
void 
CRepNodePropPush::UpdateConfig()
{
	m_pConfig->m_fPushInitialReplication = m_fPushStartup;
	m_pConfig->m_fPushReplOnAddrChange = m_fRepOnAddrChange;
	
    m_pConfig->m_dwPushUpdateCount = m_dwPushUpdateCount;

	// persistence stuff
	BOOL bPushPersist = m_checkPushPersistence.GetCheck() ? TRUE: FALSE;

	m_pConfig->m_dwPushPersistence = bPushPersist ? 1:0;
}


/*---------------------------------------------------------------------------
	CRepNodePropPush::ToString(int nNumber)
		converts integet to string
 ---------------------------------------------------------------------------*/
CString 
CRepNodePropPush::ToString(int nNumber)
{
	TCHAR szStr[20];
	_itot(nNumber, szStr, 10);
	CString str(szStr);
	return str;
}









/////////////////////////////////////////////////////////////////////////////
// CRepNodePropPull property page

IMPLEMENT_DYNCREATE(CRepNodePropPull, CPropertyPageBase)

CRepNodePropPull::CRepNodePropPull() : CPropertyPageBase(CRepNodePropPull::IDD)
{
	//{{AFX_DATA_INIT(CRepNodePropPull)
	m_fpullTrigOnStartup = FALSE;
	m_dwRetryCount = 0;
	m_nPullStartHour = 0;
	m_nPullStartMinute = 0;
	m_nPullStartSecond = 0;
	m_nRepliDay = 0;
	m_nRepliHour = 0;
	m_nRepliMinute= 0;
	//}}AFX_DATA_INIT
}


CRepNodePropPull::~CRepNodePropPull()
{

}


void CRepNodePropPull::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRepNodePropPull)
	DDX_Control(pDX, IDC_CHECK_PULL_PERSIST, m_checkPullPersistence);
	DDX_Control(pDX, IDC_SPIN_START_SECOND, m_spinStartSecond);
	DDX_Control(pDX, IDC_SPIN_START_MINUTE, m_spinStartMinute);
	DDX_Control(pDX, IDC_SPIN_START_HOUR, m_spinStartHour);
	DDX_Control(pDX, IDC_SPIN_RETRY_COUNT, m_spinRetryCount);
	DDX_Control(pDX, IDC_SPIN_REP_INT_MINUTE, m_spinRepIntMinute);
	DDX_Control(pDX, IDC_SPIN_REP_INT_HOUR, m_spinRepIntHour);
	DDX_Control(pDX, IDC_SPIN_REP_INT_DAY, m_spinRepIntDay);
	DDX_Control(pDX, IDC_EDIT_START_SECOND, m_editStartSecond);
	DDX_Control(pDX, IDC_EDIT_START_MINUTE, m_editStartMinute);
	DDX_Control(pDX, IDC_EDIT_START_HOUR, m_editStartHour);
	DDX_Control(pDX, IDC_EDIT_RETRY_COUNT, m_editRetryCount);
	DDX_Control(pDX, IDC_EDIT_REP_INT_MINUTE, m_editRepIntMinute);
	DDX_Control(pDX, IDC_EDIT_REP_INT_HOUR, m_editRepIntHour);
	DDX_Control(pDX, IDC_EDIT_REP_INT_DAY, m_editRepIntDay);
	DDX_Control(pDX, IDC_CHECK_TRIGGER_PULL_STARTUP, m_checkpullTrigOnStartup);
	DDX_Check(pDX, IDC_CHECK_TRIGGER_PULL_STARTUP, m_fpullTrigOnStartup);
	DDX_Text(pDX, IDC_EDIT_RETRY_COUNT, m_dwRetryCount);
	DDX_Text(pDX, IDC_EDIT_START_HOUR, m_nPullStartHour);
	DDV_MinMaxInt(pDX, m_nPullStartHour, 0, 23);
	DDX_Text(pDX, IDC_EDIT_START_MINUTE, m_nPullStartMinute);
	DDV_MinMaxInt(pDX, m_nPullStartMinute, 0, 59);
	DDX_Text(pDX, IDC_EDIT_START_SECOND, m_nPullStartSecond);
	DDV_MinMaxInt(pDX, m_nPullStartSecond, 0, 59);
	DDX_Text(pDX, IDC_EDIT_REP_INT_DAY, m_nRepliDay);
	DDV_MinMaxInt(pDX, m_nRepliDay, 0, 365);
	DDX_Text(pDX, IDC_EDIT_REP_INT_HOUR, m_nRepliHour);
	DDV_MinMaxInt(pDX, m_nRepliHour, 0, 23);
	DDX_Text(pDX, IDC_EDIT_REP_INT_MINUTE, m_nRepliMinute);
	DDV_MinMaxInt(pDX, m_nRepliMinute, 0, 59);
	//}}AFX_DATA_MAP
}



BEGIN_MESSAGE_MAP(CRepNodePropPull, CPropertyPageBase)
	//{{AFX_MSG_MAP(CRepNodePropPull)
	ON_EN_CHANGE(IDC_EDIT_REP_INT_DAY, OnChangeEditRepIntHour)
	ON_EN_CHANGE(IDC_EDIT_REP_INT_HOUR, OnChangeEditRepIntHour)
	ON_EN_CHANGE(IDC_EDIT_REP_INT_MINUTE, OnChangeEditRepIntHour)
	ON_EN_CHANGE(IDC_EDIT_RETRY_COUNT, OnChangeEditRepIntHour)
	ON_EN_CHANGE(IDC_EDIT_START_HOUR, OnChangeEditRepIntHour)
	ON_EN_CHANGE(IDC_EDIT_START_MINUTE, OnChangeEditRepIntHour)
	ON_EN_CHANGE(IDC_EDIT_START_SECOND, OnChangeEditRepIntHour)
	ON_EN_CHANGE(IDC_EDIT_UPDATE_COUNT, OnChangeEditRepIntHour)
	ON_BN_CLICKED(IDC_CHECK_MIGRATE, OnChangeEditRepIntHour)
	ON_BN_CLICKED(IDC_CHECK_PUSH_ON_ADDRESS_CHANGE, OnChangeEditRepIntHour)
	ON_BN_CLICKED(IDC_CHECK_REP_WITH_PARTNERS, OnChangeEditRepIntHour)
	ON_BN_CLICKED(IDC_CHECK_TRIGGER_PULL_STARTUP, OnChangeEditRepIntHour)
	ON_BN_CLICKED(IDC_CHECK_PUSH_PERSIST, OnChangeEditRepIntHour)
	ON_BN_CLICKED(IDC_CHECK_PUSH_ON_STARTUP, OnChangeEditRepIntHour)
	ON_BN_CLICKED(IDC_CHECK_PULL_PERSIST, OnCheckPullPersist)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CRepNodePropPull message handlers

BOOL 
CRepNodePropPull::OnApply() 
{
	if (!IsDirty())
		return TRUE;

	HRESULT hr = UpdateServerConfiguration();
	if (FAILED(hr))
    {
        return FALSE;
    }
    else
    {
	    return CPropertyPageBase::OnApply();
    }
}

void 
CRepNodePropPull::OnOK() 
{
	CPropertyPageBase::OnOK();
}


BOOL 
CRepNodePropPull::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();

	SPITFSNode				spNode;
	CWinsServerHandler		*pServer;
	SPITFSNode				spParentNode;

	GetConfig();

	m_checkpullTrigOnStartup.SetCheck(m_pConfig->m_fPullInitialReplication);

	m_spinRetryCount.SetRange(0, UD_MAXVAL);
	m_editRetryCount.SetWindowText(ToString(m_pConfig->m_dwPullRetryCount));

	SetPullStartTimeData(m_pConfig->m_dwPullSpTime);
	SetPullTimeIntData(m_pConfig->m_dwPullTimeInterval);
	
	// now for the persistence info
	if (m_pConfig->m_dwMajorVersion < 5)
	{
		// not supported, disable controls
		m_checkPullPersistence.SetCheck(FALSE);
		m_checkPullPersistence.EnableWindow(FALSE);
	}
	else
	{
		if (m_pConfig->m_dwPullPersistence)
			m_checkPullPersistence.SetCheck(TRUE);
		else
			m_checkPullPersistence.SetCheck(FALSE);
	}
	return TRUE;  
}

void CRepNodePropPull::OnCheckPullPersist() 
{
    SetDirty(TRUE);
}

/*---------------------------------------------------------------------------
	CRepNodePropPull::SetPullStartTimeData(DWORD dwPullStartTime)
		Sets the PullSpTime in the controls
 ---------------------------------------------------------------------------*/
void 
CRepNodePropPull::SetPullStartTimeData(DWORD dwPullStartTime)
{
	int nHours = 0, nMinutes = 0, nSeconds = 0;

    CTime time(dwPullStartTime);

	m_spinStartSecond.SetRange(0, 59);
	m_spinStartMinute.SetRange(0, 59);
	m_spinStartHour.SetRange(0, 23);

    if (dwPullStartTime)
    {
	    nHours = time.GetHour();
	    nMinutes = time.GetMinute();
	    nSeconds = time.GetSecond();
    }

	m_spinStartHour.SetPos(nHours);
	m_spinStartMinute.SetPos(nMinutes);
	m_spinStartSecond.SetPos(nSeconds);
}


/*---------------------------------------------------------------------------
	CRepNodePropPull::SetPullTimeIntData(DWORD dwPullInternal)
		Sets the Pull Replication Interval in the controls
 ---------------------------------------------------------------------------*/
void 
CRepNodePropPull::SetPullTimeIntData(DWORD dwPullInternal)
{
	m_spinRepIntMinute.SetRange(0, 59);
	m_spinRepIntHour.SetRange(0, 23);
	m_spinRepIntDay.SetRange(0, UD_MAXVAL);

	int nDays = 0, nHours = 0, nMinutes = 0;

	if (dwPullInternal)
	{
		nDays = dwPullInternal / SEC_PER_DAY;
		dwPullInternal -= nDays * SEC_PER_DAY;

		if (dwPullInternal)
		{
			nHours = dwPullInternal / SEC_PER_HOUR;
			dwPullInternal -= nHours * SEC_PER_HOUR;

			if (dwPullInternal)
			{
				nMinutes = dwPullInternal / SEC_PER_MINUTE;
				dwPullInternal -= nMinutes * SEC_PER_MINUTE;
			}
		}
	}

	m_spinRepIntDay.SetPos(nDays);
	m_spinRepIntHour.SetPos(nHours);
	m_spinRepIntMinute.SetPos(nMinutes);
}


/*---------------------------------------------------------------------------
	CRepNodePropPull::GetConfig()
		Gets the CConfiguration object from the server node
 ---------------------------------------------------------------------------*/
HRESULT 
CRepNodePropPull::GetConfig()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT	hr = hrOK;

    m_pConfig = ((CRepNodeProperties *) GetHolder())->GetConfig();

    return hr;
}


/*---------------------------------------------------------------------------
	CRepNodePropGen::UpdateServerConfiguration()	
		Updates the values for the CConfiguration object in the Server Node
 ---------------------------------------------------------------------------*/
HRESULT 
CRepNodePropPull::UpdateServerConfiguration()
{
	// Reflect the changes in the server's CConfiguration object
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT				hr = hrOK;
	SPITFSNode			spNode;
	CWinsServerHandler	*pServer;
	SPITFSNode			spParentNode;

	UpdateData();

	// get the server
	spNode = GetHolder()->GetNode();
	
    // get it's parent
	spNode->GetParent(&spParentNode);

	pServer = GETHANDLER(CWinsServerHandler, spParentNode);

	UpdateConfig();

    // now write to server
    DWORD err = m_pConfig->Store();
    if (err != ERROR_SUCCESS)
    {
        // something bad happened
        WinsMessageBox(err);
    }
    else
    {   
        // success update our local copy
        pServer->SetConfig(*m_pConfig);
    }

    return HRESULT_FROM_WIN32(err);
}


/*---------------------------------------------------------------------------
	CRepNodePropPull::UpdateConfig()	
		Updates the values for the CConfiguration object in the Server Node
 ---------------------------------------------------------------------------*/
void 
CRepNodePropPull::UpdateConfig()
{
	m_pConfig->m_fPullInitialReplication = m_fpullTrigOnStartup;
	
	m_pConfig->m_dwPullRetryCount = m_dwRetryCount;

    m_pConfig->m_dwPullTimeInterval = CalculateReplInt();
	m_pConfig->m_dwPullSpTime = CalculatePullStartInt();

	// persistence stuff
	BOOL bPullPersist = m_checkPullPersistence.GetCheck() ? TRUE: FALSE;

	m_pConfig->m_dwPullPersistence = bPullPersist ? 1:0;
}


/*---------------------------------------------------------------------------
	CRepNodePropPull ::CalculatePullStartInt()
		Calculates the pullSPTime from the values in the controls
 ---------------------------------------------------------------------------*/
DWORD 
CRepNodePropPull ::CalculatePullStartInt()
{
    CTime timePull;

	DWORD dwPullStartTime;

    if (m_nPullStartHour || m_nPullStartMinute || m_nPullStartSecond)
    {
        CTime time = CTime::GetCurrentTime();

        CTime timeStart(time.GetYear(), 
                        time.GetMonth(), 
                        time.GetDay(), 
                        m_nPullStartHour,
                        m_nPullStartMinute,
                        m_nPullStartSecond);
        timePull = timeStart;
    }
    else
    {
        CTime time(0);

        timePull = time;
    }

	m_spinStartHour.SetPos(m_nPullStartHour);
	m_spinStartMinute.SetPos(m_nPullStartMinute);
	m_spinStartMinute.SetPos(m_nPullStartSecond);

    dwPullStartTime = (DWORD) timePull.GetTime();

    return dwPullStartTime;
}


/*---------------------------------------------------------------------------
	CRepNodePropPull ::CalculateReplInt()
		Calculates the pullReplInt from the values in the controls
 ---------------------------------------------------------------------------*/
DWORD 
CRepNodePropPull::CalculateReplInt()
{
	
	DWORD dwReplInt = m_nRepliDay *SEC_PER_DAY +
					  m_nRepliHour *SEC_PER_HOUR +
					  m_nRepliMinute * SEC_PER_MINUTE;

	m_spinRepIntDay.SetPos(m_nRepliDay);
	m_spinRepIntHour.SetPos(m_nRepliHour);
	m_spinRepIntMinute.SetPos(m_nRepliMinute);
	
	return dwReplInt;
}


/*---------------------------------------------------------------------------
	CRepNodePropPull::ToString(int nNumber)
		converts integet to string
 ---------------------------------------------------------------------------*/
CString 
CRepNodePropPull::ToString(int nNumber)
{
	TCHAR szStr[20];
	_itot(nNumber, szStr, 10);
	CString str(szStr);
	return str;
}

void CRepNodePropPull::OnChangeEditRepIntHour() 
{
	SetDirty(TRUE);	
}





int CALLBACK RepNodeAdvancedPageCompareFunc
(
    LPARAM lParam1, 
    LPARAM lParam2, 
    LPARAM lParamSort
)
{
    return ((CRepNodePropAdvanced *) lParamSort)->HandleSort(lParam1, lParam2);
}



/////////////////////////////////////////////////////////////////////////////
// CRepNodePropAdvanced property page

IMPLEMENT_DYNCREATE(CRepNodePropAdvanced, CPropertyPage)


CRepNodePropAdvanced::CRepNodePropAdvanced() : CPropertyPageBase(CRepNodePropAdvanced::IDD)
{
	//{{AFX_DATA_INIT(cRepNodePropAdvanced)
	m_fEnableAuto = FALSE;
	m_dwHours = 0;
	m_dwMinutes = 0;
	m_dwSeconds = 0;
	m_dwMulticastTTL = 0;
    m_dwPersonaMode = PERSMODE_NON_GRATA;
	//}}AFX_DATA_INIT

    m_nSortColumn = -1; 

    for (int i = 0; i < COLUMN_MAX; i++)
    {
        m_aSortOrder[i] = TRUE; // ascending
    }
}


CRepNodePropAdvanced::~CRepNodePropAdvanced()
{
}


void 
CRepNodePropAdvanced::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(cRepNodePropAdvanced)
	DDX_Control(pDX, IDC_BUTTON_ADD, m_buttonAdd);
	DDX_Control(pDX, IDC_BUTTON_REMOVE, m_buttonRemove);
	DDX_Control(pDX, IDC_LIST_OWNERS, m_listOwners);
	DDX_Control(pDX, IDC_STATIC_DESP, m_staticDesp);
	DDX_Control(pDX, IDC_STATIC_MUTICASTINT, m_staticMulticastTTL);
	DDX_Control(pDX, IDC_STATIC_MULTICAST_TTL, m_staticMulticastInt);
	DDX_Control(pDX, IDC_SPIN_MULTICAST_TTL, m_spinMulticastTTL);
	DDX_Control(pDX, IDC_SPIN_MULTICAST_SECOND, m_spinMulticastSecond);
	DDX_Control(pDX, IDC_SPIN_MULTICAST_MINUTE, m_spinMulticastMinute);
	DDX_Control(pDX, IDC_SPIN_MULTICAST_HOUR, m_spinMulticastHour);
	DDX_Control(pDX, IDC_EDIT_MULTICAST_SECOND, m_editMulticastSecond);
	DDX_Control(pDX, IDC_EDIT_MULTICAST_TTL, m_editMulticastTTL);
	DDX_Control(pDX, IDC_EDIT_MULTICAST_MINUTE, m_editMulticastMinute);
	DDX_Control(pDX, IDC_EDIT_MULTICAST_HOUR, m_editMulticastHour);
	DDX_Control(pDX, IDC_CHECK_ENABLE_AUTO_PARTNER_CONFIG, m_checkenableAutoConfig);
	DDX_Check(pDX, IDC_CHECK_ENABLE_AUTO_PARTNER_CONFIG, m_fEnableAuto);
	DDX_Text(pDX, IDC_EDIT_MULTICAST_HOUR, m_dwHours);
	DDV_MinMaxDWord(pDX, m_dwHours, 0, 23);
	DDX_Text(pDX, IDC_EDIT_MULTICAST_MINUTE, m_dwMinutes);
	DDV_MinMaxDWord(pDX, m_dwMinutes, 0, 59);
	DDX_Text(pDX, IDC_EDIT_MULTICAST_SECOND, m_dwSeconds);
	DDV_MinMaxDWord(pDX, m_dwSeconds, 0, 59);
	DDX_Text(pDX, IDC_EDIT_MULTICAST_TTL, m_dwMulticastTTL);
	DDV_MinMaxDWord(pDX, m_dwMulticastTTL, WINSCNF_MIN_MCAST_TTL, WINSCNF_MAX_MCAST_TTL);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRepNodePropAdvanced, CPropertyPageBase)
	//{{AFX_MSG_MAP(cRepNodePropAdvanced)
	ON_BN_CLICKED(IDC_CHECK_ENABLE_AUTO_PARTNER_CONFIG, OnCheckEnableAutoPartnerConfig)
	ON_EN_CHANGE(IDC_EDIT_MULTICAST_HOUR, OnChangeEditMulticastHour)
	ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
	ON_BN_CLICKED(IDC_BUTTON_REMOVE, OnButtonRemove)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST_OWNERS, OnItemchangedListOwners)
	ON_EN_CHANGE(IDC_EDIT_MULTICAST_MINUTE, OnChangeEditMulticastHour)
	ON_EN_CHANGE(IDC_EDIT_MULTICAST_SECOND, OnChangeEditMulticastHour)
	ON_EN_CHANGE(IDC_EDIT_MULTICAST_TTL, OnChangeEditMulticastHour)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_LIST_OWNERS, OnColumnclickListOwners)
	ON_BN_CLICKED(IDC_RADIO_GRATA, OnRadioGrata)
	ON_BN_CLICKED(IDC_RADIO_NON_GRATA, OnRadioNonGrata)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// cRepNodePropAdvanced message handlers

BOOL 
CRepNodePropAdvanced::OnApply() 
{
	if (!IsDirty())
		return TRUE;

	HRESULT hr = UpdateServerConfiguration();
	if (FAILED(hr))
    {
        return FALSE;
    }
    else
    {
	    return CPropertyPageBase::OnApply();
    }
}

void 
CRepNodePropAdvanced::OnOK() 
{
	// TODO: Add your specialized code here and/or call the base class
	
	CPropertyPageBase::OnOK();
}

BOOL 
CRepNodePropAdvanced::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();

	GetConfig();

	InitializeControls();
	
	if (m_pConfig->m_fUseSelfFndPnrs)
	{
		m_checkenableAutoConfig.SetCheck(TRUE);
		EnableControls();
		FillControls();
	}
	else
	{
		m_checkenableAutoConfig.SetCheck(FALSE);
		// disable the controls
		FillControls();
		EnableControls(FALSE);
	}

	// now for the owner list box 

	// fill the header informnation for the list control

	//CString strOwner;
	//strOwner.LoadString(IDS_WINSSERVER);

	//m_listOwners.InsertColumn(0,strOwner, LVCFMT_LEFT, 150,1);

	CString strID;
	strID.LoadString(IDS_IPADDRESS);

	m_listOwners.InsertColumn(0, strID, LVCFMT_LEFT, 150, -1);

	FillServerInfo();

	SetRemoveButtonState();

	SetDirty(FALSE);
	return TRUE;  
}


void 
CRepNodePropAdvanced::InitializeControls()
{
	m_spinMulticastHour.SetRange(0, UD_MAXVAL);
	m_spinMulticastMinute.SetRange(0, 59);
	m_spinMulticastSecond.SetRange(0, 59);
	m_spinMulticastTTL.SetRange(WINSCNF_MIN_MCAST_TTL, WINSCNF_MAX_MCAST_TTL);
}


void 
CRepNodePropAdvanced::EnableControls(BOOL bEnable )
{
	m_staticMulticastInt.EnableWindow(bEnable);
	m_staticMulticastTTL.EnableWindow(bEnable);
	m_staticDesp.EnableWindow(bEnable);

	m_editMulticastHour.EnableWindow(bEnable);
	m_editMulticastMinute.EnableWindow(bEnable);
	m_editMulticastSecond.EnableWindow(bEnable);

	m_spinMulticastHour.EnableWindow(bEnable);
	m_spinMulticastMinute.EnableWindow(bEnable);
	m_spinMulticastSecond.EnableWindow(bEnable);

	m_spinMulticastTTL.EnableWindow(bEnable);
	m_editMulticastTTL.EnableWindow(bEnable);

}


void 
CRepNodePropAdvanced::FillControls()
{
	DWORD dwMulticastInt = m_pConfig->m_dwMulticastInt;

	int nHours = dwMulticastInt / SEC_PER_HOUR;
	dwMulticastInt -= nHours * SEC_PER_HOUR;

	int nMinutes = dwMulticastInt / SEC_PER_MINUTE;
	dwMulticastInt -= nMinutes * SEC_PER_MINUTE;

	int nSeconds = dwMulticastInt;

	m_spinMulticastHour.SetPos(nHours);
	m_spinMulticastMinute.SetPos(nMinutes);
	m_spinMulticastSecond.SetPos(nSeconds);

	m_editMulticastTTL.SetWindowText(ToString(m_pConfig->m_dwMcastTtl));
}


CString 
CRepNodePropAdvanced::ToString(int nNumber)
{
	TCHAR szStr[20];
	_itot(nNumber, szStr, 10);
	CString str(szStr);
	return str;
}

void 
CRepNodePropAdvanced::UpdateConfig()
{
	if (m_fEnableAuto)
	{
		DWORD dwInt = m_dwHours*SEC_PER_HOUR +
					  m_dwMinutes *SEC_PER_MINUTE +
					  m_dwSeconds;

		m_pConfig->m_dwMulticastInt = dwInt;
		m_pConfig->m_dwMcastTtl = m_dwMulticastTTL;
		m_pConfig->m_fUseSelfFndPnrs = m_fEnableAuto;
	}
	else
	{
		m_pConfig->m_fUseSelfFndPnrs = m_fEnableAuto;
	}
}


HRESULT 
CRepNodePropAdvanced::UpdateServerConfiguration()
{
	// Reflect the changes in the server's CConfiguration object
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT				hr = hrOK;
	SPITFSNode			spNode;
	CWinsServerHandler	*pServer;
	SPITFSNode			spParentNode;
    DWORD               err = ERROR_SUCCESS;

	// get the server
	spNode = GetHolder()->GetNode();

	// get it's parent
	spNode->GetParent(&spParentNode);
	pServer = GETHANDLER(CWinsServerHandler, spParentNode);

	UpdateData();

    UpdateConfig();
	
    // update persona non grata
    err = WriteToRegistry();     
    if (err != ERROR_SUCCESS)
    {
        // something bad happened
        WinsMessageBox(err);
        goto Error;
    }

    // now write to server
    err = m_pConfig->Store();
    if (err != ERROR_SUCCESS)
    {
        // something bad happened
        WinsMessageBox(err);
    }
    else
    {   
        // success update our local copy
        pServer->SetConfig(*m_pConfig);
    }

Error:
    return HRESULT_FROM_WIN32(err);
}

HRESULT 
CRepNodePropAdvanced::GetConfig()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT	hr = hrOK;
    
    m_pConfig = ((CRepNodeProperties *) GetHolder())->GetConfig();

    return hr;
}


void CRepNodePropAdvanced::OnCheckEnableAutoPartnerConfig() 
{
	SetDirty(TRUE);

	if (m_checkenableAutoConfig.GetCheck())
	{
		EnableControls();
		FillControls();
	}
	else
	{
		FillControls();
		EnableControls(FALSE);
	}
	SetRemoveButtonState();
	
}


void CRepNodePropAdvanced::OnChangeEditMulticastHour() 
{
	SetDirty(TRUE);	
}

void CRepNodePropAdvanced::OnButtonAdd() 
{
	BOOL fDuplicate = FALSE;
	CNewPersonaNonGrata dlg;
    CThemeContextActivator themeActivator;
    CStringArray *pPersonaList;

	// empty the strings 
	m_strServerName.Empty();
	m_strIPAddress.Empty();

	dlg.m_pRepPropDlg = this;

	// show the dialog
	if (IDOK != dlg.DoModal())
		return;

	m_strServerName = dlg.m_strServerName;
	m_strIPAddress = dlg.m_strServerIp;

    pPersonaList = (m_dwPersonaMode == PERSMODE_NON_GRATA) ? 
                        &m_strPersonaNonGrata : 
                        &m_strPersonaGrata;

	// check to make sure it already isn't in the list
	for (int i = 0; i < pPersonaList->GetSize(); i++)
	{
		if ((*pPersonaList)[i] == m_strIPAddress)
		{
			// oh no, duplicate
			AfxMessageBox(IDS_ERR_WINS_EXISTS);
			fDuplicate = TRUE;
		}
	}
	
	if (!fDuplicate)
	{
		int nCount = m_listOwners.GetItemCount();
		
		// add to the list control
		int ntest = m_listOwners.InsertItem(nCount, m_strIPAddress, 0);
        CIpAddress ipaddr1(m_strIPAddress);

        m_listOwners.SetItemData(ntest, (LONG) ipaddr1);

		// add to the list of the IP address array too.
		pPersonaList->Add(m_strIPAddress);

		// set focus to the Add button
		m_buttonAdd.SetFocus();

		SetRemoveButtonState();

		// mark the page as dirty
		SetDirty(TRUE);
	}
}

void CRepNodePropAdvanced::OnButtonRemove() 
{
	int				nSel;
	CString			strSel;

	nSel = m_listOwners.GetNextItem(-1, LVNI_SELECTED);

	if (nSel == -1)
		return;

	strSel = m_listOwners.GetItemText(nSel, 0);
	
	// remove from the list of IP addresses
	RemoveFromArray(strSel);

	m_listOwners.DeleteItem(nSel);

    if (m_listOwners.GetItemCount() > 0)
        m_listOwners.SetItemState(0,LVIS_SELECTED,LVIS_SELECTED);

	// set focus to the owners list box
	m_listOwners.SetFocus();
	m_buttonAdd.SetFocus();

	SetRemoveButtonState();

	// mark the page dirty
	SetDirty(TRUE);
}

void 
CRepNodePropAdvanced::RemoveFromArray(CString &strSel)
{
	int				nCount;
	int				i;
    CStringArray    *pPersonaList;

    pPersonaList = (m_dwPersonaMode == PERSMODE_NON_GRATA) ? 
                        &m_strPersonaNonGrata : 
                        &m_strPersonaGrata;

	nCount = (int)pPersonaList->GetSize();

	for(i = 0 ; i < nCount; i++)
	{
		// get the string that matches with the one selected
		if (pPersonaList->GetAt(i).CompareNoCase(strSel) == 0)
		{
			pPersonaList->RemoveAt(i);
			break;
		}
	}
}



BOOL CRepNodePropAdvanced::IsDuplicate(CString &strServerName)
{
	BOOL			bFound = FALSE;
	LV_FINDINFO		lvFindInfo;
	int				nFound ;

	lvFindInfo.flags = LVFI_STRING;
	lvFindInfo.psz = strServerName;
	lvFindInfo.lParam = NULL;

	nFound = m_listOwners.FindItem(&lvFindInfo);

	bFound = (nFound != -1) ? TRUE : FALSE;
	
	return bFound;
}

BOOL CRepNodePropAdvanced::IsCurrentServer(CString &strServerName)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	BOOL				bCurrent = FALSE;
	SPITFSNode			spNode;
	CWinsServerHandler	*pServer = NULL;
	SPITFSNode			spParentNode;

	// get the server
	spNode = GetHolder()->GetNode();

	// get it's parent
    if (spNode != NULL)
	    spNode->GetParent(&spParentNode);

    if (spParentNode != NULL)
	    pServer = GETHANDLER(CWinsServerHandler, spParentNode);

	// check if the same server is being added
	if (pServer != NULL &&
        pServer->m_strServerAddress.CompareNoCase(m_strServerName) == 0)
	{
		return TRUE;
	}

	return FALSE;
}

DWORD CRepNodePropAdvanced::ReadFromRegistry()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	DWORD			err = ERROR_SUCCESS;
	CString			strServerName;
	CString			strTemp =_T("\\\\");
	CString			strName;
	CStringList		strList;
	RegKey			rk;

	GetServerName(strServerName);
	strServerName = strTemp + strServerName;

	// clear the IP array first
	m_strPersonaNonGrata.RemoveAll();
    m_strPersonaGrata.RemoveAll();

    err = rk.Open(HKEY_LOCAL_MACHINE, (LPCTSTR) lpstrPartnersRoot, KEY_READ, strServerName);
    if (err)
    {
	    err = rk.Create(HKEY_LOCAL_MACHINE,
				        (LPCTSTR) lpstrPartnersRoot,
					    REG_OPTION_NON_VOLATILE,
					    KEY_ALL_ACCESS,
					    NULL,
					    strServerName);
    }

	if (err == ERROR_SUCCESS)
	{
		err = rk.QueryValue(lpstrPersonaNonGrata, strList);
		if (err == ERROR_SUCCESS)
		{
			POSITION pos = strList.GetHeadPosition();
			while (pos)
			{
				strName = strList.GetNext(pos);
				if (!strName.IsEmpty())
					m_strPersonaNonGrata.Add(strName);
			}
		}

        err = rk.QueryValue(lpstrPersonaGrata, strList);
        if (err == ERROR_SUCCESS)
        {
            POSITION pos = strList.GetHeadPosition();
            while (pos)
            {
                strName = strList.GetNext(pos);
                if (!strName.IsEmpty())
                    m_strPersonaGrata.Add(strName);
            }
        }
        // don't worry here about the return code. In case of failure  (entry doesn't exist)
        // rely on default which is 'NON_GRATA' 
        rk.QueryValue(lpstrPersonaMode, m_dwPersonaMode);
        // normalize the value - if > 0 it is set to 1
        if (m_dwPersonaMode > 0)
            m_dwPersonaMode = PERSMODE_GRATA;
	}
		
	return ERROR_SUCCESS;
}

DWORD 
CRepNodePropAdvanced::WriteToRegistry()
{
	DWORD				err = ERROR_SUCCESS;
	RegKey				rk;
	CString				strServerName;
	CString				strTemp =_T("\\\\");
	int					i = 0;
	CStringList			strList;

	// get the servername
	GetServerName(strServerName);
	strServerName = strTemp + strServerName;

	err = rk.Create(HKEY_LOCAL_MACHINE,
				    (LPCTSTR) lpstrPartnersRoot,
					REG_OPTION_NON_VOLATILE,
					KEY_ALL_ACCESS,
					NULL,
					strServerName);

	if (err == ERROR_SUCCESS)
	{
	    for (i = 0; i < m_strPersonaNonGrata.GetSize(); i++)
	    {
		    if (!m_strPersonaNonGrata[i].IsEmpty())
			    strList.AddTail(m_strPersonaNonGrata.GetAt(i));
	    }

		err = rk.SetValue(lpstrPersonaNonGrata, strList);
        strList.RemoveAll();
    }
    if (err == ERROR_SUCCESS)
    {
        for (i = 0; i < m_strPersonaGrata.GetSize(); i++)
	    {
		    if (!m_strPersonaGrata[i].IsEmpty())
			    strList.AddTail(m_strPersonaGrata.GetAt(i));
	    }

		err = rk.SetValue(lpstrPersonaGrata, strList);
	}
    if (err == ERROR_SUCCESS)
    {
        err = rk.SetValue(lpstrPersonaMode, m_dwPersonaMode);
    }

	return err;
}

DWORD 
CRepNodePropAdvanced::ResolveIPAddress(CString &strIP, CString &strServerName)
{
	DWORD	err = ERROR_SUCCESS;
	DWORD	dwIPDummy;

	// check by resolving the name thro' WINS api
	BEGIN_WAIT_CURSOR

	err = ::VerifyWinsServer(strIP, strServerName, dwIPDummy);

	END_WAIT_CURSOR

	return err;
}

void 
CRepNodePropAdvanced::FillServerInfo()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	int				nSize;
	int				i;
	DWORD			err;
    CStringArray    *pPersonaList;
		
	// read from the registry
	ReadFromRegistry();

    if (m_dwPersonaMode == PERSMODE_NON_GRATA)
    {
        pPersonaList = &m_strPersonaNonGrata;
        CheckRadioButton(IDC_RADIO_NON_GRATA,IDC_RADIO_GRATA, IDC_RADIO_NON_GRATA);
    }
    else
    {
        pPersonaList = &m_strPersonaGrata;
        CheckRadioButton(IDC_RADIO_NON_GRATA,IDC_RADIO_GRATA, IDC_RADIO_GRATA);
    }

	// now for each of the IP addresses, get the server name
	nSize = (int)pPersonaList->GetSize();

	for (i = 0; i < nSize; i++)
	{
		int nPos = m_listOwners.InsertItem(i, pPersonaList->GetAt(i));
        CIpAddress ipaddr1(pPersonaList->GetAt(i));

        m_listOwners.SetItemData(nPos, (LONG) ipaddr1);
	}

    Sort(COLUMN_IP);
}

void 
CRepNodePropAdvanced::GetServerName(CString &ServerName)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	DWORD					err = ERROR_SUCCESS;
	HKEY					hkeyMachine = HKEY_LOCAL_MACHINE;
	SPITFSNode				spNode;
	CWinsServerHandler		*pServer;
	HRESULT					hr = hrOK;
	SPITFSNode				spParentNode;
	// get the server
	

	spNode = GetHolder()->GetNode();

	// get it's parent
	spNode->GetParent(&spParentNode);

	pServer = GETHANDLER(CWinsServerHandler, spParentNode);
	ServerName = pServer->GetServerAddress();
}

void CRepNodePropAdvanced::SetRemoveButtonState()
{
	int nSel;

	// check if any item is seleted in the list ctrl.
	nSel = m_listOwners.GetNextItem(-1, LVNI_SELECTED);

	if (nSel == -1)
		m_buttonRemove.EnableWindow(FALSE);
	else
		m_buttonRemove.EnableWindow(TRUE);
}

void CRepNodePropAdvanced::OnItemchangedListOwners(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    SetRemoveButtonState();

	*pResult = 0;
}

void CRepNodePropAdvanced::OnColumnclickListOwners(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    // sort depending on what column was clicked;
    Sort(pNMListView->iSubItem);
    
	*pResult = 0;
}

void CRepNodePropAdvanced::Sort(int nCol) 
{
    if (m_nSortColumn == nCol)
    {
        // if the user is clicking the same column again, reverse the sort order
        m_aSortOrder[nCol] = m_aSortOrder[nCol] ? FALSE : TRUE;
    }
    else
    {
        m_nSortColumn = nCol;
    }

    m_listOwners.SortItems(RepNodeAdvancedPageCompareFunc, (LPARAM) this);
}

int CRepNodePropAdvanced::HandleSort(LPARAM lParam1, LPARAM lParam2) 
{
    int nCompare = 0;

    switch (m_nSortColumn)
    {
        case COLUMN_IP:
            {
                CIpAddress ipaddr1((LONG) lParam1);
                CIpAddress ipaddr2((LONG) lParam2);
            
                UINT uIpAddr1 = (UINT) ((LONG) ipaddr1);
                UINT uIpAddr2 = (UINT) ((LONG) ipaddr2);

                if (uIpAddr1 > uIpAddr2)
                    nCompare = 1;
                else
                if (uIpAddr1 < uIpAddr2)
                    nCompare = -1;
            }
            break;
    }

    if (m_aSortOrder[m_nSortColumn] == FALSE)
    {
        // descending
        return -nCompare;
    }
    else
    {
        // ascending
        return nCompare;
    }
}

void CRepNodePropAdvanced::OnRadioGrata() 
{
    if (m_dwPersonaMode != PERSMODE_GRATA)
    {
        INT i, nSize;

        m_listOwners.DeleteAllItems();
	    nSize = (int)m_strPersonaGrata.GetSize();
	    for (i = 0; i < nSize; i++)
	    {
		    int nPos = m_listOwners.InsertItem(i, m_strPersonaGrata[i]);
	    }

        m_dwPersonaMode = PERSMODE_GRATA;
        SetDirty(TRUE);
    }
}

void CRepNodePropAdvanced::OnRadioNonGrata() 
{
    if (m_dwPersonaMode != PERSMODE_NON_GRATA)
    {
        INT i, nSize;

        m_listOwners.DeleteAllItems();
	    nSize = (int)m_strPersonaNonGrata.GetSize();
	    for (i = 0; i < nSize; i++)
	    {
		    int nPos = m_listOwners.InsertItem(i, m_strPersonaNonGrata[i]);
	    }

        m_dwPersonaMode = PERSMODE_NON_GRATA;
        SetDirty(TRUE);
    }
}

/////////////////////////////////////////////////////////////////////////////
//	CRepNodeProperties Handlers
/////////////////////////////////////////////////////////////////////////////
CRepNodeProperties::CRepNodeProperties
(
	ITFSNode *			pNode,
	IComponentData *	pComponentData,
	ITFSComponentData * pTFSCompData,
	LPCTSTR				pszSheetName
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName)

{
	m_bAutoDeletePages = FALSE; // we have the pages as embedded members
    m_bTheme = TRUE;

	AddPageToList((CPropertyPageBase*) &m_pageGeneral);
	AddPageToList((CPropertyPageBase*) &m_pagePush);
	AddPageToList((CPropertyPageBase*) &m_pagePull);
	AddPageToList((CPropertyPageBase*) &m_pageAdvanced);

	Assert(pTFSCompData != NULL);
	m_spTFSCompData.Set(pTFSCompData);
}


CRepNodeProperties::~CRepNodeProperties()
{
	RemovePageFromList((CPropertyPageBase*) &m_pageGeneral, FALSE);
	RemovePageFromList((CPropertyPageBase*) &m_pagePush, FALSE);
	RemovePageFromList((CPropertyPageBase*) &m_pagePull, FALSE);
	RemovePageFromList((CPropertyPageBase*) &m_pageAdvanced, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WinsSnap.rc
//
#define IDS_SNAPIN_DESC                 1
#define IDS_NAME                        2
#define IDI_WINS_SNAPIN                 2
#define IDS_SIZE                        3
#define IDS_TYPE                        4
#define IDS_ROOT_NODENAME               5
#define IDS_ROOT_NAME                   6
#define IDS_SERVER_NAME                 7
#define IDS_DESCRIPTION                 8
#define IDS_STATUS                      9
#define IDB_UP                          10
#define IDS_SERVER_CONNECTED            10
#define IDB_UPFOC                       11
#define IDS_VIEW_RECORDS                11
#define IDB_UPDIS                       12
#define IDS_LOCAL_MACHINE               12
#define IDB_UPINV                       13
#define IDS_IP_ADDRESS                  13
#define IDB_DOWN                        14
#define IDS_FIND_NOW                    14
#define IDB_DOWNFOC                     15
#define IDS_SNAPIN_EXTENSION_DESC       15
#define IDB_DOWNDIS                     16
#define IDS_ROOT_DESC                   16
#define IDB_DOWNINV                     17
#define IDS_SERVER_NAME_FORMAT          17
#define IDS_ABOUT_DESCRIPTION           100
#define IDS_ABOUT_PROVIDER              101
#define IDS_ABOUT_VERSION               102
#define IDS_SERVICE_NAME                103
#define IDI_ICON19                      110
#define IDD_GETNETBIOSNAME              115
#define IDD_GETIPADDRESS                116
#define IDC_EDIT_SERVER_NAME            139
#define IDD_SNAPIN_PP_GENERAL           140
#define IDC_EDIT_NAME                   148
#define IDS_ACTREG_OWNER                200
#define IDS_DO_CONSISTENCY_CHECK_STR    201
#define IDS_CREATE_STATIC_MAPPING       202
#define IDS_SERVER_STATS_TITLE          203
#define IDB_ROOT_SMALL                  216
#define IDB_ROOT_LARGE                  217
#define IDB_LIST_STATE                  218
#define IDC_EDIT_SCOPE_NAME             227
#define IDC_EDIT_REFRESH_HOURS2         229
#define IDC_SPIN_REFRESH_HOURS2         230
#define IDC_EDIT_REFRESH_MINUTES2       231
#define IDC_SPIN_REFRESH_MINUTES2       232
#define IDC_EDIT_REFRESH_SECONDS2       233
#define IDC_SPIN_REFRESH_SECONDS2       234
#define IDC_RADIO2                      235
#define IDC_RADIO_SERVER_LIST           236
#define IDD_ACTREG_FIND_RECORD          237
#define IDD_STATIC_MAPPING_PROPERTIES   243
#define IDD_REP_PROP_GENERAL            246
#define IDD_REP_PROP_ADVANCED           247
#define IDD_SERVER_PROP_GEN             249
#define IDD_SERVER_PROP_DBRECORD        250
#define IDC_EDIT_START_VERSION          251
#define IDC_EDIT_START_HOUR             251
#define IDD_SERVER_PROP_ADVANCED        251
#define IDC_EDIT_MESSAGE                251
#define IDC_EDIT_RENEW_HOUR             252
#define IDC_EDIT_START_MINUTE           252
#define IDC_EDIT_MULTICAST_MINUTE       252
#define IDC_EDIT_SERVER                 252
#define IDC_EDIT_RENEW_MINUTE           253
#define IDC_EDIT_START_SECOND           253
#define IDC_EDIT_MULTICAST_SECOND       253
#define IDC_EDIT_EXTINCT_INT_DAY        254
#define IDC_EDIT_MULTICAST_TTL          254
#define IDC_EDIT_EXTINCT_INT_HOUR       255
#define IDC_EDIT_REP_DAY                255
#define IDC_EDIT_REP_INT_DAY            255
#define IDC_EDIT_EXTINCT_INT_MINUTE     256
#define IDC_EDIT_REP_HOUR               256
#define IDD_SEND_PUSH_TRIGGER           256
#define IDC_EDIT_REP_INT_HOUR           256
#define IDC_LIST1                       257
#define IDC_EDIT_EXTINCT_TIMEOUT_DAY    257
#define IDC_EDIT_REP_MINUTE             257
#define IDD_PULL_TRIGGER                257
#define IDC_EDIT_REP_INT_MINUTE         257
#define IDC_EDIT_EXTINCT_TIMEOUT_HOUR   258
#define IDC_EDIT_RETRY_COUNT            258
#define IDC_LIST_SERVER                 258
#define IDC_EDIT_EXTINCT_TIMEOUT_MINUTE 259
#define IDD_REP_NODE_GENERAL            259
#define IDC_EDIT_VERIFY_DAY             260
#define IDD_REP_NODE_ADVANCED           260
#define IDC_EDIT_VERIFY_HOUR            261
#define IDC_EDIT_VERIFY_MINUTE          262
#define IDC_EDIT_CC_START_HOUR          263
#define IDD_OWNER_FILTER                264
#define IDC_EDIT_CC_START_MINUTE        264
#define IDC_EDIT_CC_START_SECOND        265
#define IDD_CHECK_REG_NAMES             267
#define IDD_FILTER_SELECT               269
#define IDD_DYN_PROPERTIES              270
#define IDD_VERSION_CONSIS              271
#define IDD_VERIFY_WINS                 272
#define IDR_AVI2                        277
#define IDD_DELTOMB_RECORD              278
#define IDD_IPADDRESS                   280
#define IDD_STATUS_NODE_PROPERTIES      285
#define IDC_EDIT_TYPE                   286
#define IDC_EDIT_IPADDRESS              286
#define IDC_EDIT_UPDATE_COUNT           286
#define IDC_EDIT_NAME_LIST              286
#define IDC_EDIT_CUSTOM_VALUE           286
#define IDD_NAME_TYPE                   291
#define IDI_ICON01                      292
#define IDD_OWNER_DELETE                292
#define IDI_ICON02                      293
#define IDD_STATIC_MAPPING_WIZARD       293
#define IDI_ICON03                      294
#define IDD_SERVER_PROP_DBVERIFICATION  294
#define IDI_ICON04                      295
#define IDD_REP_NODE_PULL               295
#define IDI_ICON05                      296
#define IDD_REP_NODE_PUSH               296
#define IDI_ICON06                      297
#define IDI_ICON07                      298
#define IDI_ICON08                      299
#define IDC_STATIC_NAME                 300
#define IDI_ICON09                      300
#define IDC_BUTTON_ADD                  301
#define IDI_ICON10                      301
#define IDI_ICON11                      302
#define IDI_ICON12                      303
#define IDI_ICON13                      304
#define IDI_ICON14                      305
#define IDI_ICON15                      306
#define IDI_ICON16                      307
#define IDI_ICON17                      308
#define IDB_TOOLBAR                     310
#define IDI_ICON18                      312
#define IDI_ICON20                      313
#define IDD_FILTER_IPADDR               315
#define IDC_RADIO1                      335
#define IDC_CHECK1                      336
#define IDC_RADIO_SERVER_FILE           336
#define IDC_NAME_BROWSE                 337
#define IDC_NAME_ADD                    338
#define IDC_SERVER_BROWSE               339
#define IDC_SERVER_ADD                  340
#define IDC_CHECK_LOGEVENTS             341
#define IDC_CHECK_ENABLE_AUTOREFRESH    345
#define IDC_EDIT_BACKUPPATH             347
#define IDC_BUTTON_BROWSE               348
#define IDC_CHECK_BACKUPDB              349
#define IDC_EDIT_RENEW_DAY              361
#define IDC_CHECK_LANNAMES              362
#define IDC_BUTTON_SET_DEFAULT          366
#define IDC_COMBO_NAME                  371
#define IDC_BUTTON_BROWSE_DATABASE      387
#define IDC_EDIT_EXPIRATION             389
#define IDC_EDIT_DATABASE_PATH          389
#define IDC_EDIT_VERSION                390
#define IDC_EDIT_COMPNAME               392
#define IDC_COMBO_TYPE                  393
#define IDC_STATIC_DATABASE             397
#define IDC_SPIN_START_HOUR             400
#define IDC_SPIN_START_MINUTE           401
#define IDC_SPIN_MULTICAST_MINUTE       401
#define IDC_SPIN_START_SECOND           402
#define IDC_SPIN_MULTICAST_SECOND       402
#define IDC_SPIN_MULTICAST_TTL          403
#define IDC_SPIN_REP_DAY                404
#define IDC_SPIN_REP_INT_DAY            404
#define IDC_SPIN_REP_HOUR               405
#define IDC_SPIN_REP_INT_HOUR           405
#define IDC_SPIN_REP_MINUTE             406
#define IDC_SPIN_REP_INT_MINUTE         406
#define IDC_BUTTON_PULL_SET_DEFAULT     407
#define IDC_SPIN_RETRY_COUNT            407
#define IDC_BUTTON_PUSH_SET_DEFAULT     408
#define IDC_SPIN_UPDATE_COUNT           409
#define IDC_SPIN_RENEW_INT_DAY          410
#define IDC_SPIN_RENEW_INT_HOUR         411
#define IDC_SPIN_RENEW_INT_MINUTE       412
#define IDC_SPIN_EXTINCT_INT_DAY        413
#define IDC_SPIN_EXTINCT_INT_HOUR       414
#define IDC_SPIN_EXTINCT_INT_MINUTE     415
#define IDC_SPIN_EXTINCT_TM_DAY         416
#define IDC_SPIN_EXTINCT_TM_HOUR        417
#define IDC_SPIN_EXTINCT_TM_MINUTE      418
#define IDC_SPIN_VERIFY_INT_DAY         419
#define IDC_SPIN_VERIFY_INT_HOUR        420
#define IDC_SPIN_VERIFY_INT_MINUTE      421
#define IDC_SPIN_CC_START_HOUR          422
#define IDC_SPIN_CC_START_MINUTE        423
#define IDC_SPIN_CC_START_SECOND        424
#define IDC_IPADD                       430
#define IDC_CHECK_MIGRATE               432
#define IDC_CHECK_TRIGGER_PULL_STARTUP  433
#define IDC_CHECK_PUSH_ON_STARTUP       434
#define IDC_CHECK_PUSH_ON_ADDRESS_CHANGE 435
#define IDC_BUTTON_REMOVE               436
#define IDC_CHECK_REP_WITH_PARTNERS     437
#define IDC_CHECK_ENABLE_AUTO_PARTNER_CONFIG 442
#define IDC_EDIT_MULTICAST_HOUR         443
#define IDC_SPIN_MULTICAST_HOUR         444
#define IDC_STATIC_DESC                 448
#define IDC_EDIT_DYN_REC_TYPE           449
#define IDC_LIST_IPADD                  451
#define IDC_STATIC_MUTICASTINT          452
#define IDC_STATIC_MULTICAST_TTL        453
#define IDC_STATIC_DESP                 454
#define IDC_LIST_OWNER                  459
#define IDC_NAME_REMOVE                 466
#define IDC_SERVER_REMOVE               467
#define IDC_LIST_NAME                   468
#define IDC_RADIO_NAME_FILE             469
#define IDC_RADIO_NAME_LIST             470
#define IDC_STATIC_UPDATE               473
#define IDC_STATIC_START_TIME           474
#define IDC_STATIC_REP_TIME             475
#define IDC_STATIC_PULL_GROUP           476
#define IDC_STATIC_PUSH_GROUP           477
#define IDC_EDIT_STATE                  480
#define IDC_IPADDRESS                   487
#define IDC_CHECK2                      488
#define IDC_SUBNETMASK                  488
#define IDC_STATIC_IPADD                489
#define IDC_STATIC_SERVERNAME           490
#define IDC_RADIO_DELETE                491
#define IDC_RADIO_TOMBSTONE             492
#define IDC_LIST_OWNERS                 493
#define IDC_CHECK_PULL_PERSIST          495
#define IDC_CHECK_PUSH_PERSIST          496
#define IDC_CHECK_PUSH_PERSISTENCE      497
#define IDC_EDIT_UPDATE                 499
#define IDC_CHECK_BURST_HANDLING        500
#define IDS_ADD_SERVER                  501
#define IDC_RADIO_CUSTOM                501
#define IDC_RADIO_LOW                   502
#define IDC_RADIO_MEDIUM                503
#define IDS_DO_CONSISTENCY_CHECK        503
#define IDC_RADIO_HIGH                  504
#define IDS_ACTIVEREG_CREATE_STATIC_MAPPING 504
#define IDS_ACTIVEREG_IMPORT_LMHOSTS    505
#define IDC_CHECK_PERIODIC_CC           506
#define IDC_BUTTON_ADD_TYPE             506
#define IDC_EDIT_NAME_TYPE_DESCRIPTION  506
#define IDS_ACTIVEREG_EXPORT_WINSENTRIES 506
#define IDC_EDIT_CC_MAX_CHECKED         507
#define IDC_BUTTON_MODIFY_TYPE          507
#define IDC_EDIT_NAME_TYPE_ID           507
#define IDS_SERVER_COMPACT              507
#define IDC_EDIT_OWNER                  507
#define IDS_SHOW_SERVER_STATS           508
#define IDC_EDIT_CC_INTERVAL            508
#define IDC_RADIO_CHECK_OWNER           509
#define IDS_ACTREG_DELETE_OWNER         509
#define IDC_RADIO_CHECK_RANDOM          510
#define IDC_LIST_ADDRESSES              510
#define IDS_SERVER_START_SERVICE        510
#define IDC_STATIC_WINS_SERVER_DESC     511
#define IDS_SERVER_STOP_SERVICE         511
#define IDC_STATIC_ICON                 512
#define IDS_SERVER_PAUSE_SERVICE        512
#define IDC_RADIO_DELETE_RECORDS        513
#define IDS_SERVER_RESUME_SERVICE       513
#define IDC_RADIO_TOMBSTONE_RECORDS     514
#define IDS_SERVER_RESTART_SERVICE      514
#define IDC_CHECK_PARTNERS              515
#define IDS_REFRESH                     515
#define IDS_SERVER_BACKUP               516
#define IDC_CHECK_MIXED_CASE            517
#define IDS_SERVER_RESTORE              517
#define IDS_SERVER_SCAVENGE             518
#define IDS_DATABASE_LOAD_START         519
#define IDS_DATABASE_LOAD_STOP          520
#define IDC_BUTTON_DELETE_TYPE          521
#define IDS_VIEW_TASKPAD                521
#define IDC_BUTTON_SELECT_ALL           522
#define IDS_ACTREG_CHECK_REG_NAMES      522
#define IDC_BUTTON_UNSELECT_ALL         523
#define IDS_ACTREG_SHOW_ENTIRE          523
#define IDC_COMBO_STATIC_TYPE           524
#define IDS_ACTREG_SHOW_FIND            524
#define IDC_BUTTON_LOCAL                524
#define IDC_BUTTON_BROWSE_COMPUTERS     525
#define IDS_CHECK_VERSION_CONSISTENCY   525
#define IDS_REP_NEW_REPLICATION_PARTNER 526
#define IDC_RADIO_PUSH_THIS_PARTNER     527
#define IDS_REP_REPLICATE_NOW           527
#define IDC_RADIO_PUSH_ALL_PARTNERS     528
#define IDS_REP_SEND_PUSH_TRIGGER       528
#define IDS_REP_SEND_PULL_TRIGGER       529
#define IDC_STATIC_DELETE_DESC          530
#define IDC_STATIC_ICON_DESC            531
#define IDC_RADIO_NON_GRATA             532
#define IDC_RADIO_GRATA                 533
#define IDC_CHECK_NAME                  536
#define IDC_CHECK_IPADDR                537
#define IDC_ENABLE_CACHING              538
#define IDC_CHECK_IPMASK                539
#define IDC_WARN_ICON                   540
#define IDC_CHECK_MATCHCASE             540
#define IDC_WARN_MSG                    541
#define IDC_WARN_CACHE                  542
#define IDC_WARN_NAME                   543
#define IDC_WARN_OWNER                  544
#define IDS_DELETE_MULTIPLE_TITLE       600
#define IDS_DELETE_MULTIPLE_STATIC      601
#define IDS_DELETE_MULTIPLE_THIS_SERVER 602
#define IDS_DELETE_MULTIPLE_TOMBSTONE   603
#define IDS_DELETE_ITEMS                1000
#define IDS_DELETE_ITEM                 1001
#define IDS_DELETE_SERVER               1005
#define IDC_EDIT_NETBIOSNAME            1042
#define IDC_IPA_IPADDRESS               1055
#define IDC_STATIC_NETBIOSNAME          1129
#define IDC_STATIC_IPADDRESS            1178
#define IDS_ERR_LOADING_DB              2000
#define IDS_ERR_SERVER_NODE             2001
#define IDS_ERR_UPDATE_COUNT            2002
#define IDS_WARN_DELETE_OWNER           2003
#define IDS_WARN_TOMBSTONE              2004
#define IDS_ROOT_TASK_ADD_SERVER        3000
#define IDS_ROOT_TASK_ADD_SERVER_HELP   3001
#define IDS_ROOT_TASK_GETTING_STARTED   3002
#define IDS_ROOT_TASK_GETTING_STARTED_HELP 3003
#define IDS_ROOT_TASK_MANAGE_WINS       3004
#define IDS_ROOT_TASK_MANAGE_WINS_HELP  3005
#define IDS_ROOT_TASK_LAUNCH_WINS       3006
#define IDS_ROOT_TASK_LAUNCH_WINS_HELP  3007
#define IDS_ROOT_TASK_TITLE             3010
#define IDS_SERVER_TASK_GETTING_STARTED 3100
#define IDS_SERVER_TASK_FIND_RECORD     3101
#define IDS_SERVER_TASK_SET_FILTER      3102
#define IDS_SERVER_TASK_REP_PARTNER     3103
#define IDS_SERVER_TASK_GETTING_STARTED_HELP 3104
#define IDS_SERVER_TASK_FIND_RECORD_HELP 3105
#define IDS_SERVER_TASK_SET_FILTER_HELP 3106
#define IDS_SERVER_TASK_REP_PARTNER_HELP 3107
#define IDS_SERVER_TASK_TITLE           3108
#define IDS_SERVER_STATS_START_TIME     4000
#define IDS_SERVER_STATS_DB_INIT_TIME   4001
#define IDS_SERVER_STATS_LAST_CLEAR_TIME 4002
#define IDS_SERVER_STATS_LAST_PREP      4003
#define IDS_SERVER_STATS_LAST_AREP      4004
#define IDS_SERVER_STATS_LAST_NREP      4005
#define IDS_SERVER_STATS_LAST_ACREP     4006
#define IDS_SERVER_STATS_TOTAL_QUERRIES 4007
#define IDS_SERVER_STATS_SUCCESSFUL     4008
#define IDS_SERVER_STATS_FAILED         4009
#define IDS_SERVER_STATS_TOTAL_RELEASES 4010
#define IDS_SERVER_STATS_TOTAL_REGISTRATIONS 4011
#define IDS_SERVER_STATS_LAST_PSCAV     4012
#define IDS_SERVER_STATS_LAST_ASCAV     4013
#define IDS_SERVER_STATS_LAST_ESCAV     4014
#define IDS_SERVER_STATS_LAST_VSCAV     4015
#define IDS_SERVER_STATS_UNIQUE_REGISTRATIONS 4016
#define IDS_SERVER_STATS_CONFLICTS      4017
#define IDS_SERVER_STATS_RENEWALS       4018
#define IDS_SERVER_STATS_GROUP_REGISTRATIONS 4019
#define IDS_BLANK                       4020
#define IDS_SERVER_STATS_PARTNERS_HEADER 4021
#define IDS_SERVER_STATS_NO_OF_REPLS    4022
#define IDS_SERVER_STATS_NO_OF_FAILED   4023
#define IDS_COMPACT_STATUS_STOPPING_WINS 5000
#define IDS_COMPACT_STATUS_COMPACTING   5001
#define IDS_COMPACT_STATUS_STARTING_WINS 5002
#define IDS_COMPACT_STATUS_COMPLETED    5003
#define IDS_COMPACT_DATABASE_TITLE      5004
#define IDS_NAMETYPE_MAP_WORKSTATION    5100
#define IDS_NAMETYPE_MAP_DC             5101
#define IDS_NAMETYPE_MAP_FILE_SERVER    5102
#define IDS_NAMETYPE_MAP_DMB            5103
#define IDS_NAMETYPE_MAP_OTHER          5104
#define IDS_NAMETYPE_MAP_NETDDE         5105
#define IDS_NAMETYPE_MAP_MESSENGER      5106
#define IDS_NAMETYPE_MAP_RAS_SERVER     5107
#define IDS_NAMETYPE_MAP_NORMAL_GROUP_NAME 5108
#define IDS_NAMETYPE_MAP_NW_MON_AGENT   5109
#define IDS_NAMETYPE_MAP_UNKNOWN        5110
#define IDS_NAMETYPE_MAP_NMN            5111
#define IDS_NAMETYPE_MAP_WORKGROUP      5112
#define IDS_NAMETYPE_MAP_SPECIAL_INTERNET_GROUP 5113
#define IDS_RECORD_STATE_ACTIVE         5200
#define IDS_RECORD_STATE_DELETED        5201
#define IDS_RECORD_STATE_RELEASED       5202
#define IDS_RECORD_STATE_TOMBSTONED     5203
#define IDS_RECORD_STATE_UNKNOWN        5204
#define IDS_STATIC_RECORD_TYPE_UNIQUE   5210
#define IDS_STATIC_RECORD_TYPE_DOMAIN_NAME 5211
#define IDS_STATIC_RECORD_TYPE_MULTIHOMED 5212
#define IDS_STATIC_RECORD_TYPE_GROUP    5213
#define IDS_STATIC_RECORD_TYPE_INTERNET_GROUP 5214
#define IDS_STATIC_RECORD_TYPE_UNKNOWN  5215
#define IDS_SEND_NAME_QUERY             5500
#define IDS_OK                          5501
#define IDS_RESULTS                     5502
#define IDS_NOT_VERIFIED                5503
#define IDS_NAME_NOT_FOUND              5504
#define IDS_NO_RESPONSE                 5505
#define IDS_INCONSISTENCY_FOUND         5506
#define IDS_VERIFIED_ADDRESS            5507
#define IDS_NAME_QUERY_RESULT           5508
#define IDS_NAME_QUERY_RETURNED         5509
#define IDS_SERVER_NEVER_RESPONDED      5510
#define IDS_SERVER_NOT_COMPLETE         5511
#define IDS_NAME_NOT_VERIFIED           5512
#define IDS_CANCEL                      5513
#define IDS_CHECK_REG_TITLE             5514
#define IDS_BUILDING_SERVER_LIST        5515
#define IDS_UNABLE_TO_CONNECT           5516
#define IDS_GET_STATUS_FAILED           5517
#define IDS_SERVERS_TO_BE_QUERRIED      5518
#define IDS_CLEANING_UP                 5519
#define IDS_CLOSE                       5520
#define IDS_FINISHED                    5521
#define IDS_ERROR_OCCURRED              5522
#define IDS_CHECK_VERSION_TITLE         5523
#define IDS_VERSION_INCONSISTENCY_FOUND 5524
#define IDS_INVALID_NAME_IN_FILE        5525
#define IDS_NAME_VERIFIED               5526
#define IDS_SELECT_TRIGGER_PARTNER      5527
#define IDS_SELECT_TRIGGER_PARTNER_TITLE 5528
#define IDS_DATABASE_PATH_CHANGE        5529
#define IDS_ACTREG_MESSAGE_TITLE        6000
#define IDS_ACTREG_MESSAGE_BODY1        6001
#define IDS_ACTREG_MESSAGE_BODY2        6002
#define IDS_ACTREG_MESSAGE_BODY3        6003
#define IDS_ACTREG_MESSAGE_BODY4        6004
#define IDS_SERVER_MESSAGE_TITLE        6005
#define IDS_SERVER_MESSAGE_BODY         6006
#define IDS_SERVER_MESSAGE_BODY_REFRESH 6007
#define IDS_REPLICATION_PARTNERS_MESSAGE_TITLE 6010
#define IDS_REPLICATION_PARTNERS_MESSAGE_BODY1 6011
#define IDS_REPLICATION_PARTNERS_MESSAGE_BODY2 6012
#define IDS_REPLICATION_PARTNERS_MESSAGE_BODY3 6013
#define IDS_REPLICATION_PARTNERS_MESSAGE_BODY4 6014
#define IDS_ROOT_MESSAGE_TITLE          6020
#define IDS_ROOT_MESSAGE_BODY1          6021
#define IDS_ROOT_MESSAGE_BODY2          6022
#define IDS_ROOT_MESSAGE_BODY3          6023
#define IDM_FILTER_DATABASE             40002
#define IDS_ERR_INVALID_IP              50000
#define IDS_ERR_BASE                    50000
#define IDS_ERR_NO_TIMER                50001
#define IDS_ERR_TOOMANY_IP              50002
#define IDS_ERR_BAD_NB_NAME             50003
#define IDS_ERR_ERRSPACE                50004
#define IDS_ERR_CANT_CREATE_THREAD      50005
#define IDS_ERR_BACKUP                  50006
#define IDS_ERR_RESTORE                 50007
#define IDS_ERR_BAD_NUMBER              50008
#define IDS_ERR_TIME_INVALID            50009
#define IDS_ERR_WINS_EXISTS             50010
#define IDS_ERR_CANT_DELETE_PUSHPULL    50011
#define IDS_ERR_IP_EXISTS               50012
#define IDS_ERR_NO_COMPUTERNAME         50013
#define IDS_ERR_INVALID_NETBIOS_MASK    50014
#define IDS_ERR_GRP_HAS_TOOMANY_IP      50015
#define IDS_ERR_WINS_DOWN               50016
#define IDS_ERR_FILE_EMPTY              50017
#define IDS_ERR_INVALID_HEX_STRING      50018
#define IDS_ERR_INVALID_NAME            50019
#define IDS_NOTIFY_NO_RECORDS_FOUND     50020
#define IDS_ERR_NO_NAME_TYPE_SPECIFIED  50021
#define IDS_WARN_DELETE_NAME_TYPE       50022
#define IDS_ACCESS_DENIED_HELP          50023
#define IDS_ERR_CANT_CONVERT_STRING     50024
#define IDS_ERR_EXTINCTION_TIMEOUT      50025
#define IDS_ERR_EXTINCTION_INTERVAL     50026
#define IDS_ERR_RENEW_INTERVAL          50027
#define IDS_ERR_VERIFY_INTERVAL_24_DAYS 50028
#define IDS_ERR_VERIFY_INTERVAL_CALC    50029
#define IDS_ERR_EXTINCTION_TIMEOUT_MIN  50030
#define IDS_ERR_NO_OWNER_SPECIFIED      50031
#define IDS_ERR_NO_NAME                 50032
#define IDS_ERR_NO_IPADDR               50033
#define IDS_ERR_NO_IPMASK               50034
#define IDS_ERR_INVALID_IPMASK          50035
#define IDS_MSG_CONFIRM_CLOSE           52000
#define IDS_MSG_CLEAR_STATISTICS        52001
#define IDS_WARN_SERVICE_STOP           52002
#define IDS_MSG_BACKUP                  52003
#define IDS_MSG_RESTORE                 52004
#define IDS_MSG_IMPORT                  52005
#define IDS_MSG_NO_MAPPINGS             52006
#define IDS_MSG_NO_STATIC_MAPPINGS      52007
#define IDS_BACKUP_WARNING              52013
#define IDS_MSG_PURGE_WINSS             52014
#define IDS_STATUS_PURGING              52015
#define IDS_MSG_PURGE_WINSS2            52016
#define IDS_WARNING_SAVE_CHANGES        52017
#define IDS_ERR_CURRENTWINS             52018
#define IDS_ERR_VERSION_NUMBER          52019
#define IDS_ERR_REMOTE_IMPORT           52020
#define IDS_MSG_VALIDATE                52021
#define IDS_ERR_DELETESELF              52022
#define IDS_ERR_LISTBOX_FULL            52023
#define IDS_ERR_PULLTRIGGER             52024
#define IDS_MSG_PURGE_WINSS3            52025
#define IDS_INVALID_INTERNETGROUPNAME   52026
#define IDS_ERR_BURST_QUE_SIZE          52027
#define IDS_ERR_NAME_CHECK_NO_SERVERS   52028
#define IDS_ERR_NAME_CHECK_NO_NAMES     52029
#define IDS_MSG_LAST                    52999
#define IDS_WINSSERVER_NAME             57345
#define IDS_REPLICATION                 57346
#define IDS_ACTIVEREG_DISC              57347
#define IDS_REPLICATION_DISC            57348
#define IDS_ACTIVEREG                   57349
#define IDS_STATSDLG_TITLE              57350
#define IDS_ACTIVEREG_RECORD_NAME       57351
#define IDS_ACTIVEREG_TYPE              57352
#define IDS_ACTIVEREG_IPADDRESS         57353
#define IDS_ACTIVEREG_ACTIVE            57354
#define IDS_ACTIVEREG_STATIC            57355
#define IDS_ACTIVEREG_EXPIRATION        57356
#define IDS_ACTIVEREG_VERSION           57357
#define IDS_REPLICATION_SERVERNAME      57358
#define IDS_REPLICATION_LASTREPLTIME    57359
#define IDS_MSG_CONFIRMBACKUPPATH       57366
#define IDS_SERVER_NOTCONNECTED         57367
#define IDS_REPL_QUEUED                 57370
#define IDS_NEW_REPLICATION_PARTNER_TITLE 57371
#define IDS_MSG_PURGE_WINS              57376
#define IDS_REP_REMOVE_ERR              57378
#define IDS_ERR_MESSAGE_GENERIC         62027
#define IDS_ERR_VALUE_OUT_OF_RANGE      63014
#define IDS_ERR_GET_OWNERS_FAILED       63015
#define IDS_MSG_MAX                     65000
#define IDS_SELECT_STATIC_MAPPING_FILE  65012
#define IDS_ERR_REMOTE_IMPOR            65013
#define IDS_CONFIRM_DELETE_REG          65014
#define IDS_EXPORT_SUCCESS              65015
#define IDS_CONSISTENCY_CONFIRM         65017
#define IDS_STOP_DB_LOAD_CONFIRM        65018
#define IDS_VERSION_CHECK_SUCCESS       65020
#define IDS_VERSION_CHECK_FAIL          65021
#define IDS_QUEUED_MESSAGE              65022
#define IDS_DB_CONSISTENCY_CHK_FAIL     65023
#define IDS_STRING_PRESENT              65025
#define IDS_LOAD_DB_WARNING             65026
#define IDS_DB_BACKUP_SUCCESS           65027
#define IDS_DB_BACKUP_FAIL              65028
#define IDS_DB_RESTORE_SUCCESS          65029
#define IDS_DB_RESTORE_FAIL             65030
#define IDS_CONSISTENCY_CHECK_COMPLETE  65031
#define IDS_INVALID_IPADDRESS           65032
#define IDS_INVALID_NAME                65033
#define IDS_INVALID_TYPE                65034
#define IDS_INVALID_INTERNET_GROUP_NAME 65035
#define IDS_ERR_ADD_MAPPING             65036
#define IDS_REP_START_CONFIRM           65037
#define IDS_ERR_REPLICATION             65038
#define IDS_RECORDS_DOWNLOADING         65039
#define IDS_STRING_HEAD                 65042
#define IDS_WINS                        65043
#define IDS_IMPORT_FAIL                 65044
#define IDS_EXPFILE_TITLE               65045
#define IDS_LOGFILENAME                 65046
#define IDS_FILE_EXTENSION              65047
#define IDS_FILE_DEFNAME                65048
#define IDS_OWNER                       65049
#define IDS_HIGHESTID                   65050
#define IDS_PROPERTY_SET_FAIL           65051
#define IDS_PUSHPULL                    65052
#define IDS_PUSH                        65053
#define IDS_PULL                        65054
#define IDS_NONE                        65055
#define IDS_REP_PARTNER_EXISTS          65056
#define IDS_SERVER_NO_EXIST             65057
#define IDS_SCAVENGE_COMMAND            65058
#define IDS_SCAVENGE_FAILED             65059
#define IDS_SELECT_FOLDER               65060
#define IDS_ERR_WINS_EXISTS_DELETE      65061
#define IDS_INFINITE                    65062
#define IDS_INVALID_NETBIOSNAME         65063
#define IDS_MESG_LAST                   65064
#define IDS_ALL_FILES                   65065
#define IDS_STR_EXPORTFILE_FILTER       65066
#define IDS_REP_PARTNER_LOCAL           65067
#define IDS_TEXT_FILES                  65068
#define IDS_VERSION_CONSIS_CHECK_WARNING 65079
#define IDS_MSG_STATUS_DOWN             65080
#define IDS_MSG_STATUS_UP               65081
#define IDS_IPADDRESS_SINGLE            65082
#define IDS_IPADDRESS_MULTIPLE          65083
#define IDS_SELECT_BACKUP_DIRECTORY     65084
#define IDS_BACKUP_LOCATION             65085
#define IDS_SORTING                     65086
#define IDS_WINSSERVER                  65088
#define IDS_IPADDRESS                   65089
#define IDS_LOCALSERVER                 65090
#define IDS_ROOT_NODE_STATUS            65101
#define IDS_ROOTNODE_STATUS_UP          65102
#define IDS_ROOTNODE_STATUS_DOWN        65103
#define IDS_RECORDS_SCANNED             65105
#define IDS_RECORDS_FIND                65106
#define IDS_RECORDS_FILTERED            65107
#define IDS_NUM_ITEMS                   65109
#define IDS_ROOTNODE_STATUS_WORKING     65110
#define IDS_INVALID_TIME                65111
#define IDS_SERVER_STATUS_FOLDER        65112
#define IDS_NAME_UNKNOWN                65113
#define IDS_SELECT_RESTORE_FOLDER       65114
#define IDS_LAST_UPDATE                 65115
#define IDS_MODIFY_NAME_TYPE            65116
#define IDS_ERROR_NAME_TYPE_EXISTS      65117
#define IDS_NEW_REPLICATION_PARTNER_DESC 65118
#define IDS_SPECIFY_DEFAULT_BACKUP_PATH 65119
#define IDS_SELECT_BACKUP_FOLDER        65120

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        319
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         548
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\root.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	croot.cpp
		WINS root node information (the root node is not displayed
		in the MMC framework but contains information such as 
		all of the servers in this snapin).
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "root.h"			// definition for this file
#include "snappp.h"			// property pages for this node
#include "server.h"			// server node definitions
#include "service.h"		// Service routings
#include "ncglobal.h"		// network console global defines
#include "status.h"			// status node stuff
#include "ipadddlg.h"		// for adding WINS servers
#include <clusapi.h>
#include "..\tfscore\cluster.h"

unsigned int g_cfMachineName = RegisterClipboardFormat(L"MMC_SNAPIN_MACHINE_NAME");

#define WINS_MESSAGE_SIZE   576
#define ANSWER_TIMEOUT      20000

#define ROOT_MESSAGE_MAX_STRING  6

typedef enum _ROOT_MESSAGES
{
    ROOT_MESSAGE_NO_SERVERS,
    ROOT_MESSAGE_MAX
};

UINT g_uRootMessages[ROOT_MESSAGE_MAX][ROOT_MESSAGE_MAX_STRING] =
{
    {IDS_ROOT_MESSAGE_TITLE, Icon_Information, IDS_ROOT_MESSAGE_BODY1, IDS_ROOT_MESSAGE_BODY2, IDS_ROOT_MESSAGE_BODY3, 0},
};


/*---------------------------------------------------------------------------
	CWinsRootHandler::CWinsRootHandler
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
CWinsRootHandler::CWinsRootHandler(ITFSComponentData *pCompData) : 
					CWinsHandler(pCompData),
                    m_dwFlags(0),
					m_dwUpdateInterval(5*60*1000)
{
	m_nState = loaded;
    m_bMachineAdded = FALSE;
}


/*---------------------------------------------------------------------------
	CWinsRootHandler::~CWinsRootHandler
		Cleanup function
	Author: EricDav
 ---------------------------------------------------------------------------*/
CWinsRootHandler::~CWinsRootHandler()
{

}


/*--------------------------------------------------------------------------
	CWinsRootHandler::InitializeNode
		Initializes node specific data
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CWinsRootHandler::InitializeNode
(
	ITFSNode * pNode
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CString strDisp;
	strDisp.LoadString(IDS_ROOT_NODENAME);
	SetDisplayName(strDisp);

	m_fValidate = m_dwFlags & FLAG_VALIDATE_CACHE ? TRUE : FALSE;

	pNode->SetVisibilityState(TFS_VIS_SHOW);
	pNode->SetData(TFS_DATA_COOKIE, 0);
	pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_WINS_PRODUCT);
	pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_WINS_PRODUCT);
	pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, WINSSNAP_ROOT);

	SetColumnStringIDs(&aColumns[WINSSNAP_ROOT][0]);
	SetColumnWidths(&aColumnWidths[WINSSNAP_ROOT][0]);

	return hrOK;
}

/*---------------------------------------------------------------------------
	Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	CWinsRootHandler::GetString
		Implementation of ITFSNodeHandler::GetString
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) 
CWinsRootHandler::GetString
(
	ITFSNode *	pNode, 
	int			nCol
)
{
	if (nCol == 0 || nCol == -1)
		return GetDisplayName();
	else
		return NULL;
}


HRESULT
CWinsRootHandler::SetGroupName(LPCTSTR pszGroupName)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CString strSnapinBaseName;
	strSnapinBaseName.LoadString(IDS_ROOT_NODENAME);
		
	CString szBuf;
	szBuf.Format(_T("%s %s"), 
				(LPCWSTR)strSnapinBaseName, 
				(LPCWSTR)pszGroupName);
			
	SetDisplayName(strSnapinBaseName);
	
	return hrOK;
}


HRESULT
CWinsRootHandler::GetGroupName(CString * pstrGroupName)	
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	CString strSnapinBaseName, strDisplayName;
	strSnapinBaseName.LoadString(IDS_ROOT_NODENAME);

	int nBaseLength = strSnapinBaseName.GetLength() + 1; // For the space
	strDisplayName = GetDisplayName();

	if (strDisplayName.GetLength() == nBaseLength)
		pstrGroupName->Empty();
	else
		*pstrGroupName = strDisplayName.Right(strDisplayName.GetLength() - nBaseLength);

	return hrOK;
}


/*---------------------------------------------------------------------------
	CWinsRootHandler::OnExpand
		Handles enumeration of a scope item
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsRootHandler::OnExpand
(
	ITFSNode *		pNode, 
	LPDATAOBJECT	pDataObject,
	DWORD			dwType,
	LPARAM			arg, 
	LPARAM			param
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	HRESULT				hr = hrOK;

	CWinsStatusHandler	*pStatus = NULL;
	SPITFSNodeHandler	spHandler;
	SPITFSNode			spRootNode;
	DWORD				err = ERROR_SUCCESS;
	CString				strServerName;
	DWORD				dwIPVerified;
	BOOL				fValidate;
	CVerifyWins			*pDlg = NULL;
	
    if (m_bExpanded) 
        return hr;
    
    // do the default handling
    hr = CWinsHandler::OnExpand(pNode, pDataObject, dwType, arg, param);

    if (dwType & TFS_COMPDATA_EXTENSION)
    {
        // we are extending somebody.  Get the computer name 
		// and check that machine
        hr = CheckMachine(pNode, pDataObject);
    }
    else
    {
        // only possibly add the local machine if the list is currently empty
        if (IsServerListEmpty(pNode))
        {
            // check to see if we need to add the local machine to the list
            hr = CheckMachine(pNode, NULL);
        }

        // Create a handler for the node
	    try
	    {
		    pStatus = new CWinsStatusHandler(m_spTFSCompData, m_dwUpdateInterval);
									    
		    
		    // Do this so that it will get released correctly
		    spHandler = pStatus;

	    }
	    catch(...)
	    {
		    hr = E_OUTOFMEMORY;
	    }

	    CORg( hr );
	    
	    // Create the server container information
	    CreateContainerTFSNode(&m_spStatusNode,
						       &GUID_WinsServerStatusNodeType,
						       pStatus,
						       pStatus,
						       m_spNodeMgr);

	    // Tell the handler to initialize any specific data
	    pStatus->InitializeNode((ITFSNode *) m_spStatusNode);

	    pNode->AddChild(m_spStatusNode);
    }

Error:
	return hr;
}


/*---------------------------------------------------------------------------
	CWinsRootHandler::OnAddMenuItems
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsRootHandler::OnAddMenuItems
(
	ITFSNode *				pNode,
	LPCONTEXTMENUCALLBACK	pContextMenuCallback, 
	LPDATAOBJECT			lpDataObject, 
	DATA_OBJECT_TYPES		type, 
	DWORD					dwType,
	long*					pInsertionAllowed
)
{ 
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;
	CString strMenuItem;

	if (type == CCT_SCOPE)
	{
		// these menu items go in the new menu, 
		// only visible from scope pane
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
		    strMenuItem.LoadString(IDS_ADD_SERVER);
		    hr = LoadAndAddMenuItem( pContextMenuCallback, 
								     strMenuItem, 
								     IDS_ADD_SERVER,
								     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
								     0 );
		    ASSERT( SUCCEEDED(hr) );
        }
	}
	return hr; 
}


/*---------------------------------------------------------------------------
	CWinsRootHandler::OnCommand
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsRootHandler::OnCommand
(
	ITFSNode *			pNode, 
	long				nCommandId, 
	DATA_OBJECT_TYPES	type, 
	LPDATAOBJECT		pDataObject, 
	DWORD				dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = S_OK;
	switch (nCommandId)
	{
		case IDS_ADD_SERVER:
			hr = OnCreateNewServer(pNode);
			break;

        default:
            break;
	}
	return hr;
}


/*!--------------------------------------------------------------------------
	CWinsRootHandler::AddMenuItems
		Over-ride this to add our view menu item
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsRootHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
	MMC_COOKIE				cookie,
	LPDATAOBJECT			pDataObject, 
	LPCONTEXTMENUCALLBACK	pContextMenuCallback, 
	long *					pInsertionAllowed
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;

    // figure out if we need to pass this to the scope pane menu handler
    hr = HandleScopeMenus(cookie, pDataObject, pContextMenuCallback, pInsertionAllowed);
    
    return hr;
}


/*!--------------------------------------------------------------------------
	CWinsRootHandler::Command
		Handles commands for the current view
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsRootHandler::Command
(
    ITFSComponent * pComponent, 
	MMC_COOKIE		cookie, 
	int				nCommandID,
	LPDATAOBJECT	pDataObject
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = S_OK;

	switch (nCommandID)
	{
        case MMCC_STANDARD_VIEW_SELECT:
            break;

        // this may have come from the scope pane handler, so pass it up
        default:
            hr = HandleScopeCommand(cookie, nCommandID, pDataObject);
            break;
    }

    return hr;
}


/*!--------------------------------------------------------------------------
	CWinsRootHandler::HasPropertyPages
		Implementation of ITFSNodeHandler::HasPropertyPages
	NOTE: the root node handler has to over-ride this function to 
	handle the snapin manager property page (wizard) case!!!
	
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsRootHandler::HasPropertyPages
(
	ITFSNode *			pNode,
	LPDATAOBJECT		pDataObject, 
	DATA_OBJECT_TYPES   type, 
	DWORD               dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = hrOK;
	
	if (dwType & TFS_COMPDATA_CREATE)
	{
		// This is the case where we are asked to bring up property
		// pages when the user is adding a new snapin.  These calls
		// are forwarded to the root node to handle.
		hr = hrFalse;
	}
	else
	{
		// we have property pages in the normal case
		hr = hrOK;
	}
	return hr;
}


/*---------------------------------------------------------------------------
	CWinsRootHandler::CreatePropertyPages
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsRootHandler::CreatePropertyPages
(
	ITFSNode *				pNode,
	LPPROPERTYSHEETCALLBACK lpProvider,
	LPDATAOBJECT			pDataObject, 
	LONG_PTR				handle, 
	DWORD					dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT	hr = hrOK;
	HPROPSHEETPAGE hPage;

	Assert(pNode->GetData(TFS_DATA_COOKIE) == 0);
	
	if (dwType & TFS_COMPDATA_CREATE)
	{
		//
		// We are loading this snapin for the first time, put up a property
		// page to allow them to name this thing.
		// 
		//CSnapinWizName *pPage = new CSnapinWizName (this);

        //VERIFY(SUCCEEDED(MMCPropPageCallback(&pPage->m_psp)));
		//hPage = CreatePropertySheetPage(&pPage->m_psp);

		//if (hPage == NULL)
		//	return E_UNEXPECTED;
	
		//Assert(lpProvider != NULL);
		//CORg ( lpProvider->AddPage(hPage) );
	}
	else
	{
		//
		// Object gets deleted when the page is destroyed
		//
		SPIComponentData spComponentData;
		m_spNodeMgr->GetComponentData(&spComponentData);

		CSnapinProperties * pSnapinProp = 
			new CSnapinProperties(pNode, spComponentData, m_spTFSCompData, NULL);

		Assert(lpProvider != NULL);

		return pSnapinProp->CreateModelessSheet(lpProvider, handle);
	}

	return hr;
}


/*---------------------------------------------------------------------------
	CWinsRootHandler::OnPropertyChange
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsRootHandler::OnPropertyChange
(	
	ITFSNode *		pNode, 
	LPDATAOBJECT	pDataobject, 
	DWORD			dwType, 
	LPARAM			arg, 
	LPARAM			lParam
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CSnapinProperties * pSnapinProp 
		= reinterpret_cast<CSnapinProperties *>(lParam);

	// tell the property page to do whatever now that we are back on the
	// main thread
	LONG_PTR changeMask = 0;

	pSnapinProp->OnPropertyChange(TRUE, &changeMask);

	pSnapinProp->AcknowledgeNotify();

	pNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM_DATA);

	return hrOK;
}


/*---------------------------------------------------------------------------
	CWinsRootHandler::OnRemoveChildren
		Description
	Author: FlorinT
 ---------------------------------------------------------------------------*/
HRESULT
CWinsRootHandler::OnRemoveChildren(
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataObject,
    LPARAM          arg, 
    LPARAM          param
)
{
    HRESULT hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
    SPITFSNode      spCurrentNode;
    ULONG           nNumReturned = 0;

   
    if (!m_bExpanded)
        return hr;

    m_bExpanded = FALSE;

    // do the default handling
    hr = CWinsHandler::OnRemoveChildren(pNode, pDataObject, arg, param);

    // get the enumerator for this node
    CORg(pNode->GetEnum(&spNodeEnum));

    CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));

    // walk the list of child nodes and remove each node
    while (nNumReturned)
    {
        CORg (pNode->RemoveChild(spCurrentNode));

        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    }

 Error:
    return hr;
}


/*!--------------------------------------------------------------------------
	CWinsRootHandler::OnResultSelect
		For nodes with task pads, we override the select message to set 
        the selected node.  Nodes with taskpads do not get the MMCN_SHOW
        message which is where we normall set the selected node
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CWinsRootHandler::OnResultSelect(ITFSComponent *pComponent, 
										LPDATAOBJECT pDataObject, 
										MMC_COOKIE cookie, 
										LPARAM arg, 
										LPARAM lParam)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT         hr = hrOK;
	SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;

    CORg(CWinsHandler::OnResultSelect(pComponent, pDataObject, cookie, arg, lParam));

	CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

	spConsoleVerb->SetVerbState(MMC_VERB_RENAME, 
                               ENABLED, 
                               FALSE);
	
	spConsoleVerb->SetVerbState(MMC_VERB_RENAME, 
                               HIDDEN, 
                               TRUE);

    m_spNodeMgr->GetRootNode(&spNode);

    UpdateResultMessage(spNode);

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	CWinsRootHandler::UpdateResultMessage
        Determines what to display (if anything) in the result pane.
    Author: EricDav
 ---------------------------------------------------------------------------*/
void CWinsRootHandler::UpdateResultMessage(ITFSNode * pNode)
{
    HRESULT hr = hrOK;
    int nMessage = ROOT_MESSAGE_NO_SERVERS;   // default
    int i;
    CString strTitle, strBody, strTemp;

    if (!IsServerListEmpty(pNode))
	{
		ClearMessage(pNode);
	}
	else
	{
        nMessage = ROOT_MESSAGE_NO_SERVERS;

		// now build the text strings
		// first entry is the title
		strTitle.LoadString(g_uRootMessages[nMessage][0]);

		// second entry is the icon
		// third ... n entries are the body strings

		for (i = 2; g_uRootMessages[nMessage][i] != 0; i++)
		{
			strTemp.LoadString(g_uRootMessages[nMessage][i]);
			strBody += strTemp;
		}

		ShowMessage(pNode, strTitle, strBody, (IconIdentifier) g_uRootMessages[nMessage][1]);
    }
}

/*---------------------------------------------------------------------------
	Command handlers
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
	CWinsRootHandler::OnCreateNewServer
		Description
	Author: EricDav

	Date Modified: 08/14/97
 ---------------------------------------------------------------------------*/
HRESULT
CWinsRootHandler::OnCreateNewServer
(
	ITFSNode *	pNode
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CNewWinsServer dlg;
    CThemeContextActivator themeActivator;

	dlg.m_spRootNode.Set(pNode);
	dlg.m_pRootHandler = this;

	if (dlg.DoModal() == IDOK)
	{
		AddServer(dlg.m_strServerName,
			      TRUE,
				  dlg.m_dwServerIp,
				  FALSE,
				  WINS_SERVER_FLAGS_DEFAULT,
				  WINS_SERVER_REFRESH_DEFAULT,
				  FALSE);

        UpdateResultMessage(pNode);
	}

	return hrOK;
}


/*---------------------------------------------------------------------------
	CWinsRootHandler::AddServerSortedIp
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsRootHandler::AddServerSortedIp
(
    ITFSNode *      pNewNode,
    BOOL            bNewServer
)
{	
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT         hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
	SPITFSNode      spCurrentNode;
	SPITFSNode      spPrevNode;
    SPITFSNode      spRootNode;
	ULONG           nNumReturned = 0;
	CString			strCurrent;
	CString			strTarget;
	DWORD			dwTarIP;
	DWORD			dwCurIP;

    CWinsServerHandler *   pServer;

    // get our target address
	pServer = GETHANDLER(CWinsServerHandler, pNewNode);
	
	strTarget = pServer->GetServerAddress();
	dwTarIP = pServer->GetServerIP();
	
    // need to get our node descriptor
	CORg(m_spNodeMgr->GetRootNode(&spRootNode));

    // get the enumerator for this node
	CORg(spRootNode->GetEnum(&spNodeEnum));

	CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
	while (nNumReturned)
	{
		const GUID *pGuid ;
		pGuid = spCurrentNode->GetNodeType();

		if(*pGuid == GUID_WinsServerStatusNodeType)
		{
			spPrevNode.Set(spCurrentNode);

			spCurrentNode.Release();
			spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
			continue;
		}
		// walk the list of servers and see if it exists
		pServer = GETHANDLER(CWinsServerHandler, spCurrentNode);

		strCurrent = pServer->GetServerAddress();
		
		dwCurIP = pServer->GetServerIP();

		// in case of servers being ordered by the name
		if (GetOrderByName())
		{
			//if (strTarget.Compare(strCurrent) < 0)
			if (lstrcmp(strTarget, strCurrent) < 0)
			{
				// Found where we need to put it, break out
				break;
			}
		}
		// in case of servers being ordered by the IP
		else
		{
			// case where the server name not resolved
			if (dwTarIP == 0)
				break;

			if (dwCurIP > dwTarIP)
			{
				// Found where we need to put it, break out
				break;
			}

		}

		// get the next Server in the list
		spPrevNode.Set(spCurrentNode);

        spCurrentNode.Release();
		spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	}

    // Add the node in based on the PrevNode pointer
    if (spPrevNode)
    {
		if (spPrevNode->GetData(TFS_DATA_SCOPEID) != NULL)
        {
			pNewNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_PREVIOUS);
			pNewNode->SetData(TFS_DATA_RELATIVE_SCOPEID, spPrevNode->GetData(TFS_DATA_SCOPEID));
		}
        
        CORg(spRootNode->InsertChild(spPrevNode, pNewNode));
    }
    else
    {   
        CORg(spRootNode->AddChild(pNewNode));
    }

Error:
    return hr;

}


/*---------------------------------------------------------------------------
	CWinsRootHandler::IsServerInList(ITFSNode *pRootNode, CString strNewAddr)
		Checks if a particular servers name already exists
---------------------------------------------------------------------------*/
BOOL 
CWinsRootHandler::IsServerInList(ITFSNode *pRootNode, CString strNewAddr)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// enumerate thro' all the nodes
	HRESULT hr = hrOK;
	SPITFSNodeEnum spNodeEnum;
	SPITFSNode spCurrentNode;
	ULONG nNumReturned = 0;
	BOOL bFound = FALSE;

	// get the enumerator for this node
	pRootNode->GetEnum(&spNodeEnum);

	spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	while (nNumReturned)
	{
		// if the status node encountered, just iterate

		const GUID *pGuid;
		pGuid = spCurrentNode->GetNodeType();

		if(*pGuid == GUID_WinsServerStatusNodeType)
		{
			// get the next Server in the list
			spCurrentNode.Release();
			spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
			continue;
		}

		// walk the list of servers and see if it already exists
		CWinsServerHandler * pServer 
			= GETHANDLER(CWinsServerHandler, spCurrentNode);

		CString strCurAddr = pServer->GetServerAddress();

		if (strNewAddr.CompareNoCase(strCurAddr) == 0)
		{
			bFound = TRUE;
			break;
		}

		// get the next Server in the list
		spCurrentNode.Release();
		spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	}

	return bFound;
}


/*---------------------------------------------------------------------------
	CWinsRootHandler::IsIPInList(ITFSNode *pRootNode, DWORD dwNewAddr)
		Checks if a partiular IP address is alreay listed
---------------------------------------------------------------------------*/
BOOL 
CWinsRootHandler::IsIPInList(ITFSNode *pRootNode, DWORD dwNewAddr)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// enumerate thro' all the nodes
	HRESULT hr = hrOK;
	SPITFSNodeEnum spNodeEnum;
	SPITFSNode spCurrentNode;
	ULONG nNumReturned = 0;
	BOOL bFound = FALSE;

	// get the enumerator for this node
	pRootNode->GetEnum(&spNodeEnum);

	spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	while (nNumReturned)
	{
		// just iterate if the status node enountered
		const GUID *pGuid;
		pGuid = spCurrentNode->GetNodeType();

		if(*pGuid == GUID_WinsServerStatusNodeType)
		{
			// get the next Server in the list
			spCurrentNode.Release();
			spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
			continue;

		}
		
		// walk the list of servers and see if it already exists
		CWinsServerHandler * pServer 
			= GETHANDLER(CWinsServerHandler, spCurrentNode);

		DWORD dwIPCur = pServer->GetServerIP();
		
		if (dwNewAddr == dwIPCur)
		{
			bFound = TRUE;
			break;
		}

		// get the next Server in the list
		spCurrentNode.Release();
		spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	}

	return bFound;
}


/*---------------------------------------------------------------------------
	CWinsRootHandler::AddServer
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CWinsRootHandler::AddServer
(
	LPCWSTR			 pServerName,
	BOOL			 bNewServer,
	DWORD			 dwIP,
	BOOL			 fConnected,
	DWORD			 dwFlags,
	DWORD			 dwRefreshInterval,
	BOOL			 fValidateNow
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT				hr = hrOK;
	CWinsServerHandler  *pWinsServer = NULL;
	SPITFSNodeHandler	spHandler;
	SPITFSNode			spNode, spRootNode;
	DWORD				err = ERROR_SUCCESS;
	CString				strServerName;
	DWORD				dwIPVerified;
	BOOL				fValidate;
	CVerifyWins			*pDlg = NULL;

	// if the validate servers caption is on, validate the server 
	// before adding it
	if ((m_dwFlags & FLAG_VALIDATE_CACHE) && m_fValidate && fValidateNow)
	{
		CString strServerNameIP(pServerName);

		if (m_dlgVerify.GetSafeHwnd() == NULL)
		{
			m_dlgVerify.Create(IDD_VERIFY_WINS);
		}

		// check the current server
		CString strDisp;
		strDisp = _T("\\\\") + strServerNameIP;
		m_dlgVerify.SetServerName(strDisp);

		BEGIN_WAIT_CURSOR

		err = ::VerifyWinsServer(strServerNameIP, strServerName, dwIPVerified);

		END_WAIT_CURSOR

		if (err == ERROR_SUCCESS)
		{
			pServerName = strServerName;
			dwIP = dwIPVerified;
		}

		// process some messages since we were dead while verifying
		MSG msg;
		while (PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}

		if (m_dlgVerify.IsCancelPressed())
        {
			m_fValidate = FALSE;
			m_dlgVerify.Dismiss();
        }
	}
	
	if (err)
	{
		// display a message Box asking if the node is to be removed
		CString strMessage;
		AfxFormatString1(strMessage, IDS_MSG_VALIDATE, pServerName);
        CThemeContextActivator themeActivator;

		int nRet = AfxMessageBox(strMessage, MB_YESNOCANCEL);
		if (nRet == IDYES)
		{
			return hrOK;
		}
		else
		if (nRet == IDCANCEL)
		{
			m_dlgVerify.Dismiss();
			m_fValidate = FALSE;
		}
	}

	// Create a handler for the node
	try
	{
		pWinsServer = new CWinsServerHandler(m_spTFSCompData, 
											pServerName, 
											FALSE, 
											dwIP, 
											dwFlags,
											dwRefreshInterval);
		
		// Do this so that it will get released correctly
		spHandler = pWinsServer;
	}
	catch(...)
	{
		hr = E_OUTOFMEMORY;
	}
	CORg( hr );
	
	// Create the server container information
	CreateContainerTFSNode(&spNode,
						   &GUID_WinsServerNodeType,
						   pWinsServer,
						   pWinsServer,
						   m_spNodeMgr);

	// Tell the handler to initialize any specific data
	pWinsServer->InitializeNode((ITFSNode *) spNode);

    // tell the server how to display it's name
    if (dwFlags & FLAG_EXTENSION)
    {
        m_bMachineAdded = TRUE;
        pWinsServer->SetExtensionName();
    }
	else
	{
	    pWinsServer->SetDisplay(NULL, GetShowLongName());
	}

    AddServerSortedIp(spNode, bNewServer);

    if (bNewServer)
    {
        // need to get our node descriptor
	    CORg(m_spNodeMgr->GetRootNode(&spRootNode));
		spRootNode->SetData(TFS_DATA_DIRTY, TRUE);

        // add a node to the status list
        AddStatusNode(spRootNode, pWinsServer);
    }

Error:
	return hr;
}


/*!--------------------------------------------------------------------------
	CBaseResultHandler::LoadColumns
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CWinsRootHandler::LoadColumns(ITFSComponent * pComponent, 
										MMC_COOKIE cookie, 
										LPARAM arg, 
										LPARAM lParam)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SPIHeaderCtrl spHeaderCtrl;
	pComponent->GetHeaderCtrl(&spHeaderCtrl);

	CString str;
	int i = 0;

	CString strDisp, strTemp;
	GetGroupName(&strDisp);

	int nPos = strDisp.Find(_T("["));

	strTemp = strDisp.Right(strDisp.GetLength() - nPos -1);
	strTemp = strTemp.Left(strTemp.GetLength() - 1);
	
	while (i < ARRAYLEN(aColumnWidths[WINSSNAP_ROOT]))
	{
		if (i == 0)
		{
			if(nPos != -1)
			{
				AfxFormatString1(str, IDS_ROOT_NAME, strTemp);
			}
			else
			{
				str.LoadString(IDS_ROOT_NODENAME);
			}

			int nTest = spHeaderCtrl->InsertColumn(i, 
									   const_cast<LPTSTR>((LPCWSTR)str), 
									   LVCFMT_LEFT,
									   aColumnWidths[WINSSNAP_ROOT][0]);
			i++;
		}
		else if (i == 1)
		{
			str.LoadString(IDS_STATUS);
			int nTest = spHeaderCtrl->InsertColumn(1, 
									   const_cast<LPTSTR>((LPCWSTR)str), 
									   LVCFMT_LEFT,
									   aColumnWidths[WINSSNAP_ROOT][1]);
			i++;
		}
	
		if (aColumns[WINSSNAP_ROOT][i] == 0)
			break;
	}

	return hrOK;
}


/*---------------------------------------------------------------------------
	CWinsRootHandler::CheckMachine
		Checks to see if the WINS server service is running on the local
        machine.  If it is, it adds it to the list of servers.
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsRootHandler::CheckMachine
(
    ITFSNode *      pRootNode,
    LPDATAOBJECT    pDataObject
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = hrOK;

    // Get the local machine name and check to see if the service
    // is installed.
    CString strMachineName;
    CString strIp;
    LPTSTR  pBuf;
    DWORD   dwLength = MAX_COMPUTERNAME_LENGTH + 1;
    BOOL    bExtension = (pDataObject != NULL);

    if (!bExtension)
    {
        // just check the local machine
        pBuf = strMachineName.GetBuffer(dwLength);
        GetComputerName(pBuf, &dwLength);
        strMachineName.ReleaseBuffer();
    }
    else
    {
        // get the machine name from the data object
        strMachineName = Extract<TCHAR>(pDataObject, 
										(CLIPFORMAT) g_cfMachineName, 
										COMPUTERNAME_LEN_MAX);
    }

    if (strMachineName.IsEmpty())
    {
        DWORD dwSize = 256;
        LPTSTR pBuf = strMachineName.GetBuffer(dwSize);
        GetComputerName(pBuf, &dwSize);
        strMachineName.ReleaseBuffer();
    }

	if (bExtension)
		RemoveOldEntries(pRootNode, strMachineName);

    //
    // if the local machine is part of a cluster, get the WINS resource
    // IP to use instead of the local machine.
    //
    if (::FIsComputerInRunningCluster(strMachineName))
    {
        if (GetClusterResourceIp(strMachineName, _T("WINS Service"), strIp) == ERROR_SUCCESS)
        {
            strMachineName = strIp;
        }
    }

    BOOL bServiceRunning;
	DWORD dwError = ::TFSIsServiceRunning(strMachineName, 
										_T("WINS"), 
										&bServiceRunning);

	if (dwError != ERROR_SUCCESS ||
        !bServiceRunning)
	{
		// The following condition could happen to get here:
        //  o The service is not installed.
        //  o Couldn't access for some reason.
        //  o The service isn't running.
		
        // Don't add to the list.
		
        return hrOK;
	}

    // OK.  The service is installed, so lets get the IP address for the machine
    // and add it to the list.
    DWORD                   dwIp;
	SPITFSNodeHandler	    spHandler;
	SPITFSNodeMgr           spNodeMgr;
	CWinsServerHandler *    pServer = NULL;
	SPITFSNode              spNode;
	CString					strName;

    if (::VerifyWinsServer(strMachineName, strName, dwIp) == ERROR_SUCCESS)
    {
        strIp.Empty();

        MakeIPAddress(dwIp, strIp);

        if (IsServerInList(pRootNode, strName))
            return hr;

        // looks good, add to list
	    try
	    {
	        pServer = new CWinsServerHandler(m_spTFSCompData, 
										     (LPCTSTR) strName, 
										     FALSE,
										     dwIp );

		    // Do this so that it will get released correctly
		    spHandler = pServer;
	    }
	    catch(...)
	    {
		    hr = E_OUTOFMEMORY;
	    }

	    CORg(hr);  

        pRootNode->GetNodeMgr(&spNodeMgr);

	    //
	    // Store the server object in the holder
	    //
	    CreateContainerTFSNode(&spNode,
						       &GUID_WinsServerNodeType,
						       pServer,
						       pServer,
						       spNodeMgr);

	    // Tell the handler to initialize any specific data
	    pServer->InitializeNode((ITFSNode *) spNode);

        if (bExtension)
        {
            pServer->m_dwFlags |= FLAG_EXTENSION;
            pServer->SetExtensionName();
        }

        AddServerSortedIp(spNode, TRUE);
	    
	    // mark the data as dirty so that we'll ask the user to save.
        pRootNode->SetData(TFS_DATA_DIRTY, TRUE);
    
        m_bMachineAdded = TRUE;
    }

Error:
    return hr;
} 

// when running as an extension, it is possible that we were saved as "local machine"
// which means that if the saved console file was moved to another machine we need to remove 
// the old entry that was saved
HRESULT 
CWinsRootHandler::RemoveOldEntries(ITFSNode * pNode, LPCTSTR pszAddr)
{
	HRESULT         hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
	SPITFSNode      spCurrentNode;
	ULONG           nNumReturned = 0;
	CWinsServerHandler * pServer;
	CString			strCurAddr;

    // get the enumerator for this node
	CORg(pNode->GetEnum(&spNodeEnum));

	CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
	while (nNumReturned)
	{
		// walk the list of servers and see if it already exists
		pServer = GETHANDLER(CWinsServerHandler, spCurrentNode);

		strCurAddr = pServer->GetServerAddress();

		//if (strCurAddr.CompareNoCase(pszAddr) != 0)
		{
			CORg (pNode->RemoveChild(spCurrentNode));
		}

        spCurrentNode.Release();
		spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	}

Error:
    return hr;
}

void
CWinsRootHandler::AddStatusNode(ITFSNode * pRoot, CWinsServerHandler * pServer)
{
	SPITFSNodeEnum spNodeEnum;
	SPITFSNode spCurrentNode;
	ULONG nNumReturned = 0;

	// get the enumerator for this node
	pRoot->GetEnum(&spNodeEnum);

	spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	while (nNumReturned)
	{
		// iterate to teh next node, if the status handler node is seen
		const GUID*  pGuid;
		
		pGuid = spCurrentNode->GetNodeType();

		if (*pGuid == GUID_WinsServerStatusNodeType)
		{
            CWinsStatusHandler * pStatus = GETHANDLER(CWinsStatusHandler, spCurrentNode);
            pStatus->AddNode(spCurrentNode, pServer);

            break;
        }

		// get the next Server in the list
		spCurrentNode.Release();
		spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    }
}

BOOL
CWinsRootHandler::IsServerListEmpty(ITFSNode * pRoot)
{
    BOOL fEmpty = TRUE;

	SPITFSNodeEnum spNodeEnum;
	SPITFSNode spCurrentNode;
	ULONG nNumReturned = 0;

	// get the enumerator for this node
	pRoot->GetEnum(&spNodeEnum);

	spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	while (nNumReturned)
	{
		const GUID*  pGuid;
		
		pGuid = spCurrentNode->GetNodeType();

		if (*pGuid != GUID_WinsServerStatusNodeType)
        {
            fEmpty = FALSE;
            break;
        }

		// get the next Server in the list
		spCurrentNode.Release();
		spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    }

    return fEmpty;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\root.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	root.h
		WINS root node information (the root node is not displayed
		in the MMC framework but contains information such as 
		all of the servers in this snapin).
		
    FILE HISTORY:
        
*/

#ifndef _ROOT_H
#define _ROOT_H

#ifndef _WINSHAND_H
#include "winshand.h"
#endif

#ifndef _TASK_H
#include <task.h>
#endif

#ifndef _WINSMON_H
#include "winsmon.h"
#endif

#ifndef _SERVER_H
#include "server.h"
#endif

#ifndef _VRFYSRV_H
#include "vrfysrv.h"
#endif 

#define COMPUTERNAME_LEN_MAX			255

/*---------------------------------------------------------------------------
	Class:	CWinsRootHandler
 ---------------------------------------------------------------------------*/
class CWinsRootHandler : public CWinsHandler
{
// Interface
public:
	CWinsRootHandler(ITFSComponentData *pCompData);
	~CWinsRootHandler();

	// base handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages();
	OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();
	OVERRIDE_NodeHandler_GetString();
	HRESULT LoadColumns(ITFSComponent * pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam);

    // Result handler functionality
    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();
    OVERRIDE_BaseHandlerNotify_OnRemoveChildren();
    OVERRIDE_BaseHandlerNotify_OnExpand();
	OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();

    // CWinsHandler overrides
	virtual HRESULT InitializeNode(ITFSNode * pNode);
	
    // helper routines
	HRESULT GetGroupName(CString * pstrGroupName);
	HRESULT SetGroupName(LPCTSTR pszGroupName);

	// adds the server to the root node in a sorted fashion, based 
	// on the name  or IP address
	HRESULT AddServerSortedIp(ITFSNode * pNewNode,BOOL bNewServer);

	// adds the server node to the root node
	HRESULT AddServer(	LPCWSTR			pServerName,
						BOOL			bNewServer, 
						DWORD			dwIP, 
						BOOL			fConnected,
						DWORD			dwFlags,
						DWORD			dwrefreshInterval,
						BOOL			fValidateNow = TRUE
					);

	// check for the server IP and name in the list of servers present
	BOOL IsIPInList(ITFSNode *pNode,DWORD add);
	BOOL IsServerInList(ITFSNode *pNode,CString str);

	// checks if the service is running on the local machine
	HRESULT CheckMachine(ITFSNode * pRootNode, LPDATAOBJECT pDataObject);
	HRESULT	RemoveOldEntries(ITFSNode * pRootNode, LPCTSTR pszAddr);

    void    AddStatusNode(ITFSNode * pRoot, CWinsServerHandler * pServer);
    void    UpdateResultMessage(ITFSNode * pNode);
    BOOL    IsServerListEmpty(ITFSNode * pRoot);

public:
	CDWordArray* GetIPAddList()
	{
		return &m_IPAddList;
	}
	
    void SetOrderByName(BOOL fOrderByName)
	{
        if (fOrderByName)
            m_dwFlags &= ~FLAG_SERVER_ORDER_IP;
        else
            m_dwFlags |= FLAG_SERVER_ORDER_IP;
	}
	
    int GetOrderByName()
	{
        return (m_dwFlags & FLAG_SERVER_ORDER_IP) ? FALSE : TRUE;
	}
	
    void SetShowLongName(BOOL fShowLongName)
	{
		if (fShowLongName)
            m_dwFlags |= FLAG_SHOW_FQDN;
        else
            m_dwFlags &= ~FLAG_SHOW_FQDN;
	}
	
    BOOL GetShowLongName()
	{
        return (m_dwFlags & FLAG_SHOW_FQDN) ? TRUE : FALSE;
	}
	
	DWORD GetUpdateInterval()
	{
		return m_dwUpdateInterval;
	}

    void SetUpdateInterval(DWORD dwValue)
	{
		m_dwUpdateInterval = dwValue;
	}

	void DismissVerifyDialog()
	{
		if (m_dlgVerify.GetSafeHwnd())
			m_dlgVerify.Dismiss();
	}
	
	BOOL m_fValidate;

	// flags - set if the servers in the list need to be validated
	//         how the names are to be displayed... FQDN or host
    //         sort order of servers in the list... Name or IP
    DWORD			m_dwFlags;

	SPITFSNode		m_spStatusNode;
    BOOL            m_bMachineAdded;

private:
    CString			m_strConnected;
    CString         m_strTaskpadTitle;
    CDWordArray		m_IPAddList;

	CVerifyWins		m_dlgVerify;
	
	DWORD			m_dwUpdateInterval;	// Holds the value in milliSec
	
	// Command Handlers 
	HRESULT OnCreateNewServer(	ITFSNode *	pNode  );
};

#endif _ROOT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\snappp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	snappp.h
		Brings up the Snapin property page
		
    FILE HISTORY:
        
*/


// Snappp.cpp : implementation file
//

#include "stdafx.h"
#include "Snappp.h"
#include "root.h"
#include "server.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define MILLISEC_PER_MINUTE  60 * 1000

/////////////////////////////////////////////////////////////////////////////
// CSnapinPropGeneral property page

IMPLEMENT_DYNCREATE(CSnapinPropGeneral, CPropertyPageBase)

CSnapinPropGeneral::CSnapinPropGeneral() : CPropertyPageBase(CSnapinPropGeneral::IDD)
{
	//{{AFX_DATA_INIT(CSnapinPropGeneral)
	m_fLongName = FALSE;
	m_nOrderByName = 0;
	m_fValidateServers = FALSE;
	//}}AFX_DATA_INIT
}


CSnapinPropGeneral::~CSnapinPropGeneral()
{
}


void CSnapinPropGeneral::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSnapinPropGeneral)
	DDX_Control(pDX, IDC_CHECK2, m_checkValidateServers);
	DDX_Check(pDX, IDC_CHECK1, m_fLongName);
	DDX_Radio(pDX, IDC_RADIO1, m_nOrderByName);
	DDX_Control(pDX, IDC_CHECK1, m_checkLongName);
	DDX_Control(pDX, IDC_RADIO1, m_buttonSortByName);
	DDX_Control(pDX, IDC_RADIO2, m_buttonSortByIP);
	DDX_Check(pDX, IDC_CHECK2, m_fValidateServers);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSnapinPropGeneral, CPropertyPageBase)
	//{{AFX_MSG_MAP(CSnapinPropGeneral)
	ON_BN_CLICKED(IDC_CHECK2, OnChange)
	ON_BN_CLICKED(IDC_CHECK1, OnChange)
	ON_BN_CLICKED(IDC_RADIO1, OnChange)
	ON_BN_CLICKED(IDC_RADIO2, OnChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSnapinPropGeneral message handlers

BOOL CSnapinPropGeneral::OnApply() 
{
	if(!IsDirty())
		return TRUE;

	UpdateData();

    GetHolder()->EnablePeekMessageDuringNotifyConsole(TRUE);

	// get the root node 
	SPITFSNode spRootNode;
    CWinsRootHandler * pRoot;

	spRootNode = ((CSnapinProperties*)(GetHolder()))->GetNode();
    pRoot = GETHANDLER(CWinsRootHandler, spRootNode);

	// set the values in the root handler
	if (m_fValidateServers)
		pRoot->m_dwFlags |= FLAG_VALIDATE_CACHE;
	else
		pRoot->m_dwFlags &= ~FLAG_VALIDATE_CACHE;

	// need to do this bcoz' changing the server order and the display name takes a
	// long time
    BOOL fOrderByName = (m_nOrderByName == 0) ? TRUE : FALSE;

	m_bDisplayServerOrderChanged = (fOrderByName == pRoot->GetOrderByName()) ? FALSE : TRUE;

	m_bDisplayFQDNChanged = (m_fLongName == pRoot->GetShowLongName()) ? FALSE : TRUE;

	// don't do anything, if the properties remained the same
	if (!m_bDisplayFQDNChanged && !m_bDisplayServerOrderChanged)
		return TRUE;
		
	// set the servername of the rootnode to the one updated
	pRoot->SetShowLongName(m_fLongName);
    pRoot->SetOrderByName(fOrderByName);

    spRootNode->SetData(TFS_DATA_DIRTY, TRUE);

    return CPropertyPageBase::OnApply();
}


BOOL CSnapinPropGeneral::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();

	// get the root node 
	// now add the node to the tree
	
	SPITFSNode spRootNode;
    CWinsRootHandler * pRoot;

	spRootNode = ((CSnapinProperties*)(GetHolder()))->GetNode();
    pRoot = GETHANDLER(CWinsRootHandler, spRootNode);

	m_uImage = (UINT) spRootNode->GetData(TFS_DATA_IMAGEINDEX);

	m_fLongName = pRoot->GetShowLongName();
	BOOL fOrderByName = pRoot->GetOrderByName();

    m_nOrderByName = (fOrderByName) ? 0 : 1;

	if (m_fLongName)
		m_checkLongName.SetCheck(TRUE);
	else
		m_checkLongName.SetCheck(FALSE);

	if (m_nOrderByName == 0)
	{
		m_buttonSortByName.SetCheck(TRUE);
		m_buttonSortByIP.SetCheck(FALSE);
	}
	else
	{
		m_buttonSortByName.SetCheck(FALSE);
		m_buttonSortByIP.SetCheck(TRUE);
	}

	if (pRoot->m_dwFlags & FLAG_VALIDATE_CACHE)
		m_checkValidateServers.SetCheck(TRUE);
	else
		m_checkValidateServers.SetCheck(FALSE);

    // load the correct icon
    for (int i = 0; i < ICON_IDX_MAX; i++)
    {
        if (g_uIconMap[i][1] == m_uImage)
        {
            HICON hIcon = LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
            if (hIcon)
                ((CStatic *) GetDlgItem(IDC_STATIC_ICON))->SetIcon(hIcon);
            break;
        }
    }

	SetDirty(FALSE);
	
	return TRUE;  
}


/////////////////////////////////////////////////////////////////////////////
//
// CSnapinProperties holder
//
/////////////////////////////////////////////////////////////////////////////
CSnapinProperties::CSnapinProperties
(
	ITFSNode *			pNode,
	IComponentData *	pComponentData,
	ITFSComponentData * pTFSCompData,
	LPCTSTR				pszSheetName
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName)
{
	m_bAutoDeletePages = FALSE; // we have the pages as embedded members
    m_bTheme = TRUE;

	AddPageToList((CPropertyPageBase*) &m_pageGeneral);
	Assert(pTFSCompData != NULL);
	m_spTFSCompData.Set(pTFSCompData);
}

CSnapinProperties::~CSnapinProperties()
{
	RemovePageFromList((CPropertyPageBase*) &m_pageGeneral, FALSE);
}

BOOL 
CSnapinPropGeneral::OnPropertyChange(BOOL bScope, LONG_PTR * ChangeMask)
{
	SPITFSNode spRootNode;
    CWinsRootHandler * pRoot;

	spRootNode = ((CSnapinProperties*)(GetHolder()))->GetNode();
    pRoot = GETHANDLER(CWinsRootHandler, spRootNode);

	// enumerate thro' all the nodes
	HRESULT hr = hrOK;
	SPITFSNodeEnum spNodeEnum;
	SPITFSNodeEnum spNodeEnumAdd;
    SPITFSNode spCurrentNode;
	ULONG nNumReturned = 0;
	
    BEGIN_WAIT_CURSOR;

    if (m_bDisplayFQDNChanged)
	{
		CHAR szStringName[MAX_PATH] = {0};
		
		// get the enumerator for this node
		spRootNode->GetEnum(&spNodeEnum);

		spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
		
		while (nNumReturned)
		{
			// if the status node is encountered, just ignore
			const GUID *pGuid;

			pGuid = spCurrentNode->GetNodeType();

			if(*pGuid == GUID_WinsServerStatusNodeType)
			{
				spCurrentNode.Release();
			
				// get the next Server in the list
				spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);

				continue;
			}

			// walk the list of servers 
            CWinsServerHandler * pServer = GETHANDLER(CWinsServerHandler, spCurrentNode);

            pServer->SetDisplay(spCurrentNode, m_fLongName);

            spCurrentNode.Release();
			
            // get the next Server in the list
            spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);

        }// while
	}

    END_WAIT_CURSOR;

    BOOL fValidate = pRoot->m_fValidate;

    // turn off validation if it is on.
    pRoot->m_fValidate = FALSE;

    if (spNodeEnum)
        spNodeEnum.Set(NULL);

    if (m_bDisplayServerOrderChanged)
	{
		const GUID *pGuid;
        CTFSNodeList tfsNodeList;

        // get the enumerator for this node
		spRootNode->GetEnum(&spNodeEnum);

        // first remove all of the server nodes from the UI
		spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
		while (nNumReturned)
		{
			pGuid = spCurrentNode->GetNodeType();

			if (*pGuid == GUID_WinsServerStatusNodeType)
			{
				spCurrentNode.Release();
			
				// get the next Server in the list
				spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);

				continue;
			}

            // remove from the UI
            spRootNode->ExtractChild(spCurrentNode);

            // add ref the pointer since we need to put it on the list
            // and adding it to the list doesn't addref
            spCurrentNode->AddRef();
            tfsNodeList.AddTail(spCurrentNode);

            // reset our smart pointer
            spCurrentNode.Set(NULL);

            // get the next Server in the list
			spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        }

        // Next put them back in sorted
		while (tfsNodeList.GetCount() > 0)
		{
			// get the next Server in the list
    		spCurrentNode = tfsNodeList.RemoveHead();

            // if the status node is encountered, just ignore
			pGuid = spCurrentNode->GetNodeType();

			if (*pGuid == GUID_WinsServerStatusNodeType)
			{
				spCurrentNode.Release();
			
				continue;
			}

            // walk the list of servers 
			CWinsServerHandler *pServer = GETHANDLER(CWinsServerHandler, spCurrentNode);

			pRoot->AddServer(pServer->m_strServerAddress,
							FALSE,
							pServer->m_dwIPAdd,
							pServer->GetConnected(),
							pServer->m_dwFlags,
							pServer->m_dwRefreshInterval);

            // releasing here destroys the object
            spCurrentNode.Release();
		}
	}

    // restore the flag
    pRoot->m_fValidate = fValidate;

	return FALSE;
}


void CSnapinPropGeneral::OnChange() 
{
	SetDirty(TRUE);	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\srvlatpp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	srvlatpp.cpp
		Brings up the property page for the server node
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "winssnap.h"
#include "shlobj.h"
#include "srvlatpp.h"

#include "server.h"
#include "service.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define MAX_HOURS       23
#define MAX_MINUTES     59
#define MAX_SECONDS     59

/////////////////////////////////////////////////////////////////////////////
// CServerPropGeneral property page

IMPLEMENT_DYNCREATE(CServerPropGeneral, CPropertyPageBase)

CServerPropGeneral::CServerPropGeneral() : CPropertyPageBase(CServerPropGeneral::IDD)
{
	//{{AFX_DATA_INIT(CServerPropGeneral)
	m_fBackupDB = FALSE;
	m_fEnableAutoRefresh = FALSE;
	m_strBackupPath = _T("");
	m_nRefreshHours = 0;
	m_nRefreshMinutes = 0;
	m_nRefreshSeconds = 0;
	//}}AFX_DATA_INIT

    m_fUpdateConfig = FALSE;
}

CServerPropGeneral::~CServerPropGeneral()
{
}


void 
CServerPropGeneral::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServerPropGeneral)
	DDX_Control(pDX, IDC_EDIT_REFRESH_MINUTES2, m_editRefreshMn);
	DDX_Control(pDX, IDC_EDIT_REFRESH_HOURS2, m_editRefreshHr);
	DDX_Control(pDX, IDC_EDIT_REFRESH_SECONDS2, m_editRefreshSc);
	DDX_Control(pDX, IDC_SPIN_REFRESH_SECONDS2, m_spinRefreshSc);
	DDX_Control(pDX, IDC_SPIN_REFRESH_MINUTES2, m_spinRefreshmn);
	DDX_Control(pDX, IDC_SPIN_REFRESH_HOURS2, m_spinRefreshHr);
	DDX_Control(pDX, IDC_EDIT_BACKUPPATH, m_editBackupPath);
	DDX_Control(pDX, IDC_CHECK_BACKUPDB, m_check_BackupOnTermination);
	DDX_Control(pDX, IDC_CHECK_ENABLE_AUTOREFRESH, m_check_EnableAutoRefresh);
	DDX_Control(pDX, IDC_BUTTON_BROWSE, m_button_Browse);
	DDX_Check(pDX, IDC_CHECK_BACKUPDB, m_fBackupDB);
	DDX_Check(pDX, IDC_CHECK_ENABLE_AUTOREFRESH, m_fEnableAutoRefresh);
	DDX_Text(pDX, IDC_EDIT_BACKUPPATH, m_strBackupPath);
	DDX_Text(pDX, IDC_EDIT_REFRESH_HOURS2, m_nRefreshHours);
	DDV_MinMaxInt(pDX, m_nRefreshHours, 0, MAX_HOURS);
	DDX_Text(pDX, IDC_EDIT_REFRESH_MINUTES2, m_nRefreshMinutes);
	DDV_MinMaxInt(pDX, m_nRefreshMinutes, 0, MAX_MINUTES);
	DDX_Text(pDX, IDC_EDIT_REFRESH_SECONDS2, m_nRefreshSeconds);
	DDV_MinMaxInt(pDX, m_nRefreshSeconds, 0, MAX_SECONDS);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CServerPropGeneral, CPropertyPageBase)
	//{{AFX_MSG_MAP(CServerPropGeneral)
	ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
	ON_BN_CLICKED(IDC_CHECK_ENABLE_AUTOREFRESH, OnCheckEnableAutorefresh)
	ON_EN_CHANGE(IDC_EDIT_BACKUPPATH, OnChangeEditBackuppath)
	ON_EN_CHANGE(IDC_EDIT_REFRESH_HOURS2, OnChangeRefresh)
	ON_EN_CHANGE(IDC_EDIT_REFRESH_MINUTES2, OnChangeRefresh)
	ON_EN_CHANGE(IDC_EDIT_REFRESH_SECONDS2, OnChangeRefresh)
	ON_BN_CLICKED(IDC_CHECK_BACKUPDB, OnChangeCheckBackupdb)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServerPropGeneral message handlers
BOOL 
CServerPropGeneral::OnApply() 
{
	HRESULT hr = UpdateServerConfiguration();
	if (FAILED(hr))
    {
        return FALSE;
    }
    else
    {
        m_fUpdateConfig = FALSE;

	    return CPropertyPageBase::OnApply();
    }
}


void 
CServerPropGeneral::OnOK() 
{
	HRESULT hr = UpdateServerConfiguration();
	if (SUCCEEDED(hr))
    {
    	CPropertyPageBase::OnOK();
    }
}


BOOL 
CServerPropGeneral::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();
	
	GetConfig();

    m_fBackupDB = m_pConfig->m_fBackupOnTermination;

	// get the server
	SPITFSNode spNode;
	CWinsServerHandler *pServer;

	spNode = GetHolder()->GetNode();
	pServer = GETHANDLER(CWinsServerHandler, spNode);

	SetRefreshData();

    if (pServer->m_dwFlags & FLAG_AUTO_REFRESH)
	{
		m_fEnableAutoRefresh = TRUE;
		m_check_EnableAutoRefresh.SetCheck(1);
	}
	else
	{
		m_fEnableAutoRefresh = FALSE;
		m_check_EnableAutoRefresh.SetCheck(0);

		// diable the controls
		m_spinRefreshHr.EnableWindow(FALSE);
		m_spinRefreshmn.EnableWindow(FALSE);
		m_spinRefreshSc.EnableWindow(FALSE);
		
		m_editRefreshHr.EnableWindow(FALSE);
		m_editRefreshMn.EnableWindow(FALSE);
		m_editRefreshSc.EnableWindow(FALSE);
	}

	m_spinRefreshHr.SetRange(0, 23);
	m_spinRefreshmn.SetRange(0, 59);
	m_spinRefreshSc.SetRange(0, 59);

    // browse only available on local machine
    m_button_Browse.EnableWindow(IsLocalConnection());

   	m_check_BackupOnTermination.SetCheck(m_pConfig->m_fBackupOnTermination);

	m_editBackupPath.SetWindowText(m_pConfig->m_strBackupPath);

    // load the correct icon
    for (int i = 0; i < ICON_IDX_MAX; i++)
    {
        if (g_uIconMap[i][1] == m_uImage)
        {
            HICON hIcon = LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
            if (hIcon)
                ((CStatic *) GetDlgItem(IDC_STATIC_ICON))->SetIcon(hIcon);
            break;
        }
    }
	
    m_fUpdateConfig = FALSE;

    SetDirty(FALSE);

	return TRUE;  
}

void CServerPropGeneral::OnChangeEditBackuppath() 
{
    m_fUpdateConfig = TRUE;
    SetDirty(TRUE);	
}

void CServerPropGeneral::OnChangeRefresh() 
{
    SetDirty(TRUE);
}

void CServerPropGeneral::OnChangeCheckBackupdb()
{
    m_fUpdateConfig = TRUE;

    SetDirty(TRUE);
}

/*---------------------------------------------------------------------------
	CServerPropGeneral::IsLocalConnection()
		Checks if the local machine is being monitored
---------------------------------------------------------------------------*/
BOOL
CServerPropGeneral::IsLocalConnection()
{
	// get the server
	SPITFSNode spNode;
	CWinsServerHandler *pServer;

	spNode = GetHolder()->GetNode();
	pServer = GETHANDLER(CWinsServerHandler, spNode);

	return pServer->IsLocalConnection();
}

void 
CServerPropGeneral::OnButtonBrowse() 
{
	TCHAR szBuffer[MAX_PATH];

	LPITEMIDLIST pidlPrograms = NULL; //CSIDL_DRIVES
	SHGetSpecialFolderLocation(m_hWnd, CSIDL_DRIVES, &pidlPrograms);

	BROWSEINFO		browseInfo;
	browseInfo.hwndOwner = m_hWnd;
	browseInfo.pidlRoot = pidlPrograms;            
	browseInfo.pszDisplayName = szBuffer; 
	
    CString strSel;
	strSel.LoadString(IDS_SELECT_FOLDER);

    browseInfo.lpszTitle = strSel;        
    browseInfo.ulFlags =  BIF_NEWDIALOGSTYLE | BIF_DONTGOBELOWDOMAIN  | BIF_RETURNONLYFSDIRS ;            
    browseInfo.lpfn = NULL;        
    browseInfo.lParam = 0;
	
	LPITEMIDLIST pidlBrowse = SHBrowseForFolder(&browseInfo);

	if (pidlBrowse)
	{
		SHGetPathFromIDList(pidlBrowse, szBuffer); 

		CString strBackupPath(szBuffer);

		// check if it's a network drive, if yes, don't allow.
/*		int nPos = strBackupPath.Find(_T("\\"));

		if (nPos != -1)
		{
			CString strDrive = strBackupPath.Left(nPos);

			UINT uType = GetDriveType(strDrive);

			if(uType == DRIVE_REMOTE)
			{
				// tell the user that the files ccanot be backed up the location chosen
				CString strBackup;
				AfxFormatString1(strBackup, IDS_BACKUP_LOCATION, strBackupPath);
				AfxMessageBox(strBackup, MB_OK | MB_ICONINFORMATION);
				return;
			}
		}
*/		
		if (!strBackupPath.IsEmpty())
			m_editBackupPath.SetWindowText(strBackupPath);
	}
}


/*---------------------------------------------------------------------------
	CServerPropGeneral::UpdateServerConfiguration()
		Updates the variables in the Server Handler
---------------------------------------------------------------------------*/
HRESULT 
CServerPropGeneral::UpdateServerConfiguration()
{
    UpdateData();

	// Reflect the changes in the server's CConfiguration object
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// get the server
	SPITFSNode spNode;
	CWinsServerHandler *pServer;

	spNode = GetHolder()->GetNode();
	pServer = GETHANDLER(CWinsServerHandler, spNode);

    // update config displays any necessary error dialogs
    if (!UpdateConfig())
        return E_FAIL;

    DWORD err = ERROR_SUCCESS;

    // now write to server
    if (m_fUpdateConfig)
    {
        err = m_pConfig->Store();
        if (err != ERROR_SUCCESS)
        {
            // something bad happened
            WinsMessageBox(err);
        }
        else
        {   
            // success update our local copy
            pServer->SetConfig(*m_pConfig);
        }
    }

    return HRESULT_FROM_WIN32(err);
}


/*---------------------------------------------------------------------------
	CServerPropGeneral::UpdateConfig()
		Updates the Config object in the server handler
---------------------------------------------------------------------------*/
BOOL 
CServerPropGeneral::UpdateConfig()
{
	// get the server
	SPITFSNode spNode;
	CWinsServerHandler *pServer;

	spNode = GetHolder()->GetNode();
	pServer = GETHANDLER(CWinsServerHandler, spNode);
	
	CString strTemp;
	m_editBackupPath.GetWindowText(strTemp);

    // backup path needs to be non-null when backup on termination is set
    if (m_fBackupDB && strTemp.IsEmpty())
    {
        CThemeContextActivator themeActivator;
        AfxMessageBox(IDS_SPECIFY_DEFAULT_BACKUP_PATH);
        return FALSE;
    }

    if (m_fUpdateConfig)
    {
        m_pConfig->m_strBackupPath = strTemp;
	    m_pConfig->m_fBackupOnTermination = m_fBackupDB;
    }

    pServer->m_dwRefreshInterval = CalculateRefrInt();
	
    if (m_fEnableAutoRefresh)
	{
		pServer->m_dwFlags |= FLAG_AUTO_REFRESH;
	}
	else
	{
		pServer->m_dwFlags &= ~FLAG_AUTO_REFRESH;
	}

    // since these settins are stored in the console file, mark it as dirty
    SPITFSNode spRootNode;
    spNode->GetParent(&spRootNode);
    spRootNode->SetData(TFS_DATA_DIRTY, TRUE);

    return TRUE;
}


/*---------------------------------------------------------------------------
	CServerPropGeneral::CalculateRefrInt()
		Rteurns the refresh interval in seconds
---------------------------------------------------------------------------*/
int 
CServerPropGeneral::CalculateRefrInt()
{
	UpdateData();
	CString strValue;

	// get the server
	SPITFSNode spNode;
	CWinsServerHandler *pServer;

	spNode = GetHolder()->GetNode();
	pServer = GETHANDLER(CWinsServerHandler, spNode);

	int nHour = m_spinRefreshHr.GetPos();
	int nMinute = m_spinRefreshmn.GetPos();
	int nSecond = m_spinRefreshSc.GetPos();

	int nRenewInterval = nHour * SEC_PER_HOUR + 
						 nMinute * SEC_PER_MINUTE +
  						 nSecond;

	pServer->m_dwRefreshInterval = nRenewInterval;
    pServer->m_dlgStats.ReInitRefresherThread();

	return nRenewInterval;
}


/*---------------------------------------------------------------------------
	CServerPropGeneral::ToString(int nNumber)
		Returns string value of an integer
---------------------------------------------------------------------------*/
CString 
CServerPropGeneral::ToString(int nNumber)
{
	TCHAR szStr[20];
	_itot(nNumber, szStr, 10);
	CString str(szStr);
	return str;
}


/*---------------------------------------------------------------------------
		CServerPropGeneral::SetRefreshData()
		 Sets the variables' dtata for the refresh group.
---------------------------------------------------------------------------*/
void 
CServerPropGeneral::SetRefreshData()
{
	// get the server
	SPITFSNode spNode;
	CWinsServerHandler *pServer;

	spNode = GetHolder()->GetNode();
	pServer = GETHANDLER(CWinsServerHandler, spNode);
	
	DWORD dwInterval = pServer->m_dwRefreshInterval;

	m_spinRefreshmn.SetRange(0, MAX_MINUTES);
	m_spinRefreshSc.SetRange(0, MAX_SECONDS);
	m_spinRefreshHr.SetRange(0, UD_MAXVAL);

	int nHours, nMinutes, nSeconds;

	nHours = dwInterval / SEC_PER_HOUR;
	
	dwInterval -= nHours * SEC_PER_HOUR;

	nMinutes = dwInterval / SEC_PER_MINUTE;
	dwInterval -= nMinutes * SEC_PER_MINUTE;

	nSeconds = dwInterval ;

	// convert them to strings
	CString strHr = ToString(nHours);
	CString strMn = ToString(nMinutes);
	CString strSc = ToString(nSeconds);
	
	m_spinRefreshHr.SetPos(nHours);
	m_spinRefreshmn.SetPos(nMinutes);
	m_spinRefreshSc.SetPos(nSeconds);
}


/*---------------------------------------------------------------------------
	CServerPropGeneral::GetConfig()
		Gets the Configuration object from the server
---------------------------------------------------------------------------*/
HRESULT 
CServerPropGeneral::GetConfig()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;

    m_pConfig = ((CServerProperties *) GetHolder())->GetConfig();

	return hr;
}


void CServerPropGeneral::OnCheckEnableAutorefresh() 
{
	SetDirty(TRUE);

	UpdateData();
	
    if (m_check_EnableAutoRefresh.GetCheck() == 1)
	{
		m_fEnableAutoRefresh = TRUE;
		m_spinRefreshHr.EnableWindow(TRUE);
		m_spinRefreshmn.EnableWindow(TRUE);
		m_spinRefreshSc.EnableWindow(TRUE);
		
		m_editRefreshHr.EnableWindow(TRUE);
		m_editRefreshMn.EnableWindow(TRUE);
		m_editRefreshSc.EnableWindow(TRUE);
	}
	else
	{
		m_fEnableAutoRefresh = FALSE;
		m_spinRefreshHr.EnableWindow(FALSE);
		m_spinRefreshmn.EnableWindow(FALSE);
		m_spinRefreshSc.EnableWindow(FALSE);
		
		m_editRefreshHr.EnableWindow(FALSE);
		m_editRefreshMn.EnableWindow(FALSE);
		m_editRefreshSc.EnableWindow(FALSE);
	}

	// mark the snap-in as dirty, so as to prompt the user
		// mark the snap-in as dirty
	SPITFSNode spNode ;
	spNode = GetHolder()->GetNode();
	
	SPITFSNodeMgr spNodeManager;
	SPITFSNode spRootNode;

	spNode->GetNodeMgr(&spNodeManager);
	spNodeManager->GetRootNode(&spRootNode);

	// mark the data as dirty so that we'll ask the user to save.
    spRootNode->SetData(TFS_DATA_DIRTY, TRUE);
	
}






/////////////////////////////////////////////////////////////////////////////
// CServerPropDBRecord property page

IMPLEMENT_DYNCREATE(CServerPropDBRecord, CPropertyPageBase)

CServerPropDBRecord::CServerPropDBRecord() : CPropertyPageBase(CServerPropDBRecord::IDD)
{
	//{{AFX_DATA_INIT(CServerPropDBRecord)
	m_nExtintDay = 0;
	m_nExtIntHour = 0;
	m_nExtIntMinute = 0;
	m_nExtTmDay = 0;
	m_nExtTmHour = 0;
	m_nExtTmMinute = 0;
	m_nRenewDay = 0;
	m_nrenewMinute = 0;
	m_nRenewMinute = 0;
	m_nVerifyDay = 0;
	m_nVerifyHour = 0;
	m_nVerifyMinute = 0;
	//}}AFX_DATA_INIT
}


CServerPropDBRecord::~CServerPropDBRecord()
{
}


void CServerPropDBRecord::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServerPropDBRecord)
	DDX_Control(pDX, IDC_EDIT_EXTINCT_INT_MINUTE, m_editExtIntMinute);
	DDX_Control(pDX, IDC_SPIN_VERIFY_INT_MINUTE, m_spinVerifyMinute);
	DDX_Control(pDX, IDC_SPIN_VERIFY_INT_HOUR, m_spinVerifyHour);
	DDX_Control(pDX, IDC_SPIN_VERIFY_INT_DAY, m_spinVerifyDay);
	DDX_Control(pDX, IDC_SPIN_RENEW_INT_MINUTE, m_spinRefrIntMinute);
	DDX_Control(pDX, IDC_SPIN_RENEW_INT_HOUR, m_spinRefrIntHour);
	DDX_Control(pDX, IDC_SPIN_RENEW_INT_DAY, m_spinRefrIntDay);
	DDX_Control(pDX, IDC_SPIN_EXTINCT_TM_MINUTE, m_spinExtTmMinute);
	DDX_Control(pDX, IDC_SPIN_EXTINCT_TM_HOUR, m_spinExtTmHour);
	DDX_Control(pDX, IDC_SPIN_EXTINCT_TM_DAY, m_spinExtTmDay);
	DDX_Control(pDX, IDC_SPIN_EXTINCT_INT_MINUTE, m_spinExtIntMinute);
	DDX_Control(pDX, IDC_SPIN_EXTINCT_INT_HOUR, m_spinExtIntHour);
	DDX_Control(pDX, IDC_SPIN_EXTINCT_INT_DAY, m_spinExtIntDay);
	DDX_Control(pDX, IDC_EDIT_VERIFY_MINUTE, m_editVerifyMinute);
	DDX_Control(pDX, IDC_EDIT_VERIFY_HOUR, m_editVerifyHour);
	DDX_Control(pDX, IDC_EDIT_VERIFY_DAY, m_editVerifyDay);
	DDX_Control(pDX, IDC_EDIT_RENEW_MINUTE, m_editRefrIntMinute);
	DDX_Control(pDX, IDC_EDIT_RENEW_HOUR, m_editRefrIntHour);
	DDX_Control(pDX, IDC_EDIT_RENEW_DAY, m_editRefrIntDay);
	DDX_Control(pDX, IDC_EDIT_EXTINCT_TIMEOUT_HOUR, m_editExtTmHour);
	DDX_Control(pDX, IDC_EDIT_EXTINCT_TIMEOUT_MINUTE, m_editExtTmMinute);
	DDX_Control(pDX, IDC_EDIT_EXTINCT_TIMEOUT_DAY, m_editExtTmDay);
	DDX_Control(pDX, IDC_EDIT_EXTINCT_INT_HOUR, m_editExtIntHour);
	DDX_Control(pDX, IDC_EDIT_EXTINCT_INT_DAY, m_editExtIntDay);
	DDX_Text(pDX, IDC_EDIT_EXTINCT_INT_DAY, m_nExtintDay);
	DDV_MinMaxInt(pDX, m_nExtintDay, 0, 365);
	DDX_Text(pDX, IDC_EDIT_EXTINCT_INT_HOUR, m_nExtIntHour);
	DDV_MinMaxInt(pDX, m_nExtIntHour, 0, MAX_HOURS);
	DDX_Text(pDX, IDC_EDIT_EXTINCT_INT_MINUTE, m_nExtIntMinute);
	DDV_MinMaxInt(pDX, m_nExtIntMinute, 0, MAX_MINUTES);
	DDX_Text(pDX, IDC_EDIT_EXTINCT_TIMEOUT_DAY, m_nExtTmDay);
	DDV_MinMaxInt(pDX, m_nExtTmDay, 0, 365);
	DDX_Text(pDX, IDC_EDIT_EXTINCT_TIMEOUT_HOUR, m_nExtTmHour);
	DDV_MinMaxInt(pDX, m_nExtTmHour, 0, MAX_HOURS);
	DDX_Text(pDX, IDC_EDIT_EXTINCT_TIMEOUT_MINUTE, m_nExtTmMinute);
	DDV_MinMaxInt(pDX, m_nExtTmMinute, 0, MAX_MINUTES);
	DDX_Text(pDX, IDC_EDIT_RENEW_DAY, m_nRenewDay);
	DDV_MinMaxInt(pDX, m_nRenewDay, 0, 365);
	DDX_Text(pDX, IDC_EDIT_RENEW_HOUR, m_nrenewMinute);
	DDV_MinMaxInt(pDX, m_nrenewMinute, 0, MAX_HOURS);
	DDX_Text(pDX, IDC_EDIT_RENEW_MINUTE, m_nRenewMinute);
	DDV_MinMaxInt(pDX, m_nRenewMinute, 0, MAX_MINUTES);
	DDX_Text(pDX, IDC_EDIT_VERIFY_DAY, m_nVerifyDay);
	DDV_MinMaxInt(pDX, m_nVerifyDay, 0, 365);
	DDX_Text(pDX, IDC_EDIT_VERIFY_HOUR, m_nVerifyHour);
	DDV_MinMaxInt(pDX, m_nVerifyHour, 0, MAX_HOURS);
	DDX_Text(pDX, IDC_EDIT_VERIFY_MINUTE, m_nVerifyMinute);
	DDV_MinMaxInt(pDX, m_nVerifyMinute, 0, MAX_MINUTES);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CServerPropDBRecord, CPropertyPageBase)
	//{{AFX_MSG_MAP(CServerPropDBRecord)
	ON_BN_CLICKED(IDC_BUTTON_SET_DEFAULT, OnButtonSetDefault)
	ON_EN_CHANGE(IDC_EDIT_EXTINCT_INT_DAY, OnChangeEditExtinctIntHour)
	ON_EN_CHANGE(IDC_EDIT_EXTINCT_INT_HOUR, OnChangeEditExtinctIntHour)
	ON_EN_CHANGE(IDC_EDIT_EXTINCT_INT_MINUTE, OnChangeEditExtinctIntHour)
	ON_EN_CHANGE(IDC_EDIT_EXTINCT_TIMEOUT_DAY, OnChangeEditExtinctIntHour)
	ON_EN_CHANGE(IDC_EDIT_EXTINCT_TIMEOUT_HOUR, OnChangeEditExtinctIntHour)
	ON_EN_CHANGE(IDC_EDIT_EXTINCT_TIMEOUT_MINUTE, OnChangeEditExtinctIntHour)
	ON_EN_CHANGE(IDC_EDIT_RENEW_DAY, OnChangeEditExtinctIntHour)
	ON_EN_CHANGE(IDC_EDIT_RENEW_HOUR, OnChangeEditExtinctIntHour)
	ON_EN_CHANGE(IDC_EDIT_RENEW_MINUTE, OnChangeEditExtinctIntHour)
	ON_EN_CHANGE(IDC_EDIT_VERIFY_DAY, OnChangeEditExtinctIntHour)
	ON_EN_CHANGE(IDC_EDIT_VERIFY_HOUR, OnChangeEditExtinctIntHour)
	ON_EN_CHANGE(IDC_EDIT_VERIFY_MINUTE, OnChangeEditExtinctIntHour)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServerPropDBRecord message handlers

BOOL 
CServerPropDBRecord::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();

		// get the server
	SPITFSNode spNode;
	CWinsServerHandler *pServer;

	spNode = GetHolder()->GetNode();
	pServer = GETHANDLER(CWinsServerHandler, spNode);
	
	// get the interval stuff from the server and display in the spinner controlss
	HRESULT hr = GetConfig();
	
	DWORD m_dwRefreshInterval = m_pConfig->m_dwRefreshInterval;

	m_spinRefrIntHour.SetRange(0, MAX_HOURS);
	m_spinRefrIntMinute.SetRange(0, MAX_MINUTES);
	m_spinRefrIntDay.SetRange(0, UD_MAXVAL);       

    int nDays = 0, nHours = 0, nMinutes = 0;

	nDays = m_dwRefreshInterval /86400;// SEC_PER_DAY;
	m_dwRefreshInterval -= (nDays * SEC_PER_DAY);

	if (m_dwRefreshInterval)
	{
		nHours = m_dwRefreshInterval / SEC_PER_HOUR;

		m_dwRefreshInterval -= (nHours * SEC_PER_HOUR);
		
		if(m_dwRefreshInterval)
		{
			nMinutes = m_dwRefreshInterval / SEC_PER_MINUTE;
			m_dwRefreshInterval -= (nMinutes * SEC_PER_MINUTE);
		}
	}

	m_spinRefrIntDay.SetPos(nDays);
	m_spinRefrIntHour.SetPos(nHours);
	m_spinRefrIntMinute.SetPos(nMinutes);

	SetVerifyData();
	SetExtTimeData();
	SetExtIntData();

    SetDirty(FALSE);
 
    return TRUE;  
}


BOOL 
CServerPropDBRecord::OnApply() 
{
	if (!CheckValues())
    {
        return FALSE;
    }

	HRESULT hr = UpdateServerConfiguration();
    if (FAILED(hr))
    {
        return FALSE;
    }
    else
    {
	    return CPropertyPageBase::OnApply();
    }
}


void 
CServerPropDBRecord::OnOK() 
{
	HRESULT hr = UpdateServerConfiguration();
    if (FAILED(hr))
    {
        return;
    }
    else
    {
    	CPropertyPageBase::OnOK();
    }
}

/*---------------------------------------------------------------------------
	CServerPropDBRecord::CalculateRenewInt()
		Returns the Renew interval in seconds
---------------------------------------------------------------------------*/
DWORD 
CServerPropDBRecord::CalculateRenewInt()
{
	UpdateData();

	int nDay = m_spinRefrIntDay.GetPos();
	int nHour = m_spinRefrIntHour.GetPos();
	int nMinute = m_spinRefrIntMinute.GetPos();

	int nRenewInterval = nDay * SEC_PER_DAY +
 						 nHour * SEC_PER_HOUR +
						 nMinute * SEC_PER_MINUTE;

	return nRenewInterval;
}


/*---------------------------------------------------------------------------
	CServerPropDBRecord::CalculateExtInt()
		Returns the Extinction interval in seconds
---------------------------------------------------------------------------*/
DWORD
CServerPropDBRecord::CalculateExtInt()
{
	UpdateData();

	int nDay = m_spinExtIntDay.GetPos();
	int nHour = m_spinExtIntHour.GetPos();
	int nMinute = m_spinExtIntMinute.GetPos();

	int nExtInterval = nDay * SEC_PER_DAY +
						nHour * SEC_PER_HOUR +
						nMinute * SEC_PER_MINUTE;

	return nExtInterval;
}


/*---------------------------------------------------------------------------
	CServerPropDBRecord::CalculateExtTm()
		Returns the Extinction timeout interval in seconds
---------------------------------------------------------------------------*/
DWORD
CServerPropDBRecord::CalculateExtTm()
{
	UpdateData();

	int nDay = m_spinExtTmDay.GetPos();
	int nHour = m_spinExtTmHour.GetPos();
	int nMinute = m_spinExtTmMinute.GetPos();

	int nExtTm = nDay * SEC_PER_DAY +
				 nHour * SEC_PER_HOUR +
				 nMinute * SEC_PER_MINUTE;

	return nExtTm;
}


/*----------------------------------------------------------------------------
	CServerPropDBRecord::CalculateVerifyInt()
		Returns the Verify interval in seconds
---------------------------------------------------------------------------*/
DWORD
CServerPropDBRecord::CalculateVerifyInt()
{
	UpdateData();

	int nDay = m_spinVerifyDay.GetPos();
	int nHour = m_spinVerifyHour.GetPos();
	int nMinute = m_spinVerifyMinute.GetPos();

	int nVerifyInt = nDay * SEC_PER_DAY +
					 nHour * SEC_PER_HOUR +
 					 nMinute * SEC_PER_MINUTE;

    return nVerifyInt;
}

/*---------------------------------------------------------------------------
	CServerPropDBRecord::UpdateServerConfiguration()
		Updates the server handler variables
---------------------------------------------------------------------------*/
HRESULT
CServerPropDBRecord::UpdateServerConfiguration()
{
    UpdateData();

	// Reflect the changes in the server's CConfiguration object
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// get the server
	SPITFSNode spNode;
	CWinsServerHandler *pServer;

	spNode = GetHolder()->GetNode();
	pServer = GETHANDLER(CWinsServerHandler, spNode);

 	m_pConfig->m_dwRefreshInterval = CalculateRenewInt();
	m_pConfig->m_dwTombstoneInterval = CalculateExtInt();
	m_pConfig->m_dwTombstoneTimeout = CalculateExtTm();
	m_pConfig->m_dwVerifyInterval = CalculateVerifyInt();

    // now write to server
    DWORD err = m_pConfig->Store();
    if (err != ERROR_SUCCESS)
    {
        // something bad happened
        WinsMessageBox(err);
    }
    else
    {   
        // success update our local copy
        pServer->SetConfig(*m_pConfig);
    }

    return HRESULT_FROM_WIN32(err);
}


void 
CServerPropDBRecord::OnButtonSetDefault() 
{
	SetDefaultRenewInt();
	SetDefaultExtInt();
	SetDefaultExtTm();
	SetDefaultVerifyInt();
}

//
//  note, these defaults come from winscnf.c in the wins server code.
//  if that code changes, these function will need to change as well.
//

/*---------------------------------------------------------------------------
	CServerPropDBRecord::SetDefaultRenewInt() 
		Sets the defalut values for the Renew interval
---------------------------------------------------------------------------*/
void 
CServerPropDBRecord::SetDefaultRenewInt() 
{
	int nValue = WINSCNF_DEF_REFRESH_INTERVAL;

    int nDays = 0, nHours = 0, nMinutes = 0;

    CalcDaysHoursMinutes(nValue, nDays, nHours, nMinutes);

	m_spinRefrIntDay.SetPos(nDays);
	m_spinRefrIntHour.SetPos(nHours);
	m_spinRefrIntMinute.SetPos(nMinutes);
}


/*---------------------------------------------------------------------------
	CServerPropDBRecord::SetDefaultExtInt() 
		Sets the defalut values for the Extinction interval
---------------------------------------------------------------------------*/
void 
CServerPropDBRecord::SetDefaultExtInt() 
{
	int nValue = WINSCNF_MAKE_TOMB_INTVL_M(WINSCNF_DEF_REFRESH_INTERVAL, 0);

    int nDays = 0, nHours = 0, nMinutes = 0;

    CalcDaysHoursMinutes(nValue, nDays, nHours, nMinutes);

    m_spinExtIntDay.SetPos(nDays);
	m_spinExtIntHour.SetPos(nHours);
	m_spinExtIntMinute.SetPos(nMinutes);
}


/*---------------------------------------------------------------------------
	CServerPropDBRecord::SetDefaultExtTm() 
		Sets the defalut values for the Extinction timeout interval
---------------------------------------------------------------------------*/
void 
CServerPropDBRecord::SetDefaultExtTm() 
{
	int nValue = WINSCNF_DEF_REFRESH_INTERVAL;

    int nDays = 0, nHours = 0, nMinutes = 0;

    CalcDaysHoursMinutes(nValue, nDays, nHours, nMinutes);

    m_spinExtTmDay.SetPos(nDays);
	m_spinExtTmHour.SetPos(nHours);
	m_spinExtTmMinute.SetPos(nMinutes);
}


/*---------------------------------------------------------------------------
	CServerPropDBRecord::SetDefaultExtTm() 
		Sets the defalut values for the verify interval
---------------------------------------------------------------------------*/
void 
CServerPropDBRecord::SetDefaultVerifyInt() 
{
	int nValue = WINSCNF_MAKE_VERIFY_INTVL_M(WINSCNF_MAKE_TOMB_INTVL_M(WINSCNF_DEF_REFRESH_INTERVAL, 0));

    int nDays = 0, nHours = 0, nMinutes = 0;

    CalcDaysHoursMinutes(nValue, nDays, nHours, nMinutes);

    m_spinVerifyDay.SetPos(nDays);
	m_spinVerifyHour.SetPos(nHours);
	m_spinVerifyMinute.SetPos(nMinutes);
}


void 
CServerPropDBRecord::CalcDaysHoursMinutes(int nValue, int & nDays, int & nHours, int & nMinutes)
{
    nDays = 0;
    nHours = 0;
    nMinutes = 0;

	nDays = nValue / SEC_PER_DAY; // 86400;
	nValue -= (nDays * SEC_PER_DAY);

	if (nValue)
	{
		nHours = nValue / SEC_PER_HOUR;

		nValue -= (nHours * SEC_PER_HOUR);
		
		if (nValue)
		{
			nMinutes = nValue / SEC_PER_MINUTE;
			nValue -= (nMinutes * SEC_PER_MINUTE);
		}
	}
}

/*---------------------------------------------------------------------------
	CServerPropDBRecord::GetConfig()
		Updates the configuration object from the server handler
---------------------------------------------------------------------------*/
HRESULT 
CServerPropDBRecord::GetConfig()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = hrOK;

    m_pConfig = ((CServerProperties *) GetHolder())->GetConfig();

	return hr;
}

/*---------------------------------------------------------------------------
	CServerPropDBRecord::SetVerifyData()
		Sets the controls' data for verify interval
---------------------------------------------------------------------------*/
void 
CServerPropDBRecord::SetVerifyData()
{
	DWORD dwInterval = m_pConfig->m_dwVerifyInterval;

	m_spinVerifyHour.SetRange(0, MAX_HOURS);
	m_spinVerifyMinute.SetRange(0, MAX_MINUTES);
	m_spinVerifyDay.SetRange(0, UD_MAXVAL);

	int nDays =0, nHours =0, nMinutes =0;

	if(dwInterval)
	{
		nDays = dwInterval / SEC_PER_DAY;
		dwInterval -= nDays * SEC_PER_DAY;
		if(dwInterval)
		{
			nHours = dwInterval / SEC_PER_HOUR;
			dwInterval -= nHours * SEC_PER_HOUR;
			if(dwInterval)
			{

				nMinutes = dwInterval / SEC_PER_MINUTE;
				dwInterval -= nMinutes * SEC_PER_MINUTE;
			}
		}
	}

	m_spinVerifyDay.SetPos(nDays);
	m_spinVerifyHour.SetPos(nHours);
	m_spinVerifyMinute.SetPos(nMinutes);
}


/*---------------------------------------------------------------------------
	CServerPropDBRecord::SetExtTimeData()
		Sets the controls' data for extinction timeout interval
---------------------------------------------------------------------------*/
void 
CServerPropDBRecord::SetExtTimeData()
{
	DWORD dwInterval = m_pConfig->m_dwTombstoneTimeout;

	m_spinExtTmHour.SetRange(0, MAX_HOURS);
	m_spinExtTmMinute.SetRange(0, MAX_MINUTES);
	m_spinExtTmDay.SetRange(0, UD_MAXVAL);

	int nHours = 0, nMinutes =0, nDays =0;

	if(dwInterval)
	{
		nDays = dwInterval / SEC_PER_DAY;
		dwInterval -= nDays * SEC_PER_DAY;
		if(dwInterval)
		{
			nHours = dwInterval / SEC_PER_HOUR;
			dwInterval -= nHours * SEC_PER_HOUR;

			if(dwInterval)
			{
				nMinutes = dwInterval / SEC_PER_MINUTE;
				dwInterval -= nMinutes * SEC_PER_MINUTE;
			}
		}
	}

	m_spinExtTmDay.SetPos(nDays);
	m_spinExtTmHour.SetPos(nHours);
	m_spinExtTmMinute.SetPos(nMinutes);

}

/*---------------------------------------------------------------------------
	CServerPropDBRecord::SetExtData()
		Sets the controls' data for extinction interval
---------------------------------------------------------------------------*/
void 
CServerPropDBRecord::SetExtIntData()
{
	DWORD dwInterval = m_pConfig->m_dwTombstoneInterval;

	m_spinExtIntHour.SetRange(0, MAX_HOURS);
	m_spinExtIntMinute.SetRange(0, MAX_MINUTES);
	m_spinExtIntDay.SetRange(0, UD_MAXVAL);

	int nHours =0, nMinutes =0, nDays =0;

	if(dwInterval)
	{
		nDays = dwInterval / SEC_PER_DAY;
		dwInterval -= nDays * SEC_PER_DAY;

		if(dwInterval)
		{
			nHours = dwInterval / SEC_PER_HOUR;
			dwInterval -= nHours * SEC_PER_HOUR;

			if(dwInterval)
			{
				nMinutes = dwInterval / SEC_PER_MINUTE;
				dwInterval -= nMinutes * SEC_PER_MINUTE;
			}
		}
		
	}
	m_spinExtIntDay.SetPos(nDays);
	m_spinExtIntHour.SetPos(nHours);
	m_spinExtIntMinute.SetPos(nMinutes);

}


void CServerPropDBRecord::OnChangeEditExtinctIntHour() 
{
	SetDirty(TRUE);	
	
}


/*---------------------------------------------------------------------------
	CServerPropDBRecord::CheckValues() 
        checks if the values are valid
        NOTE: All of these checks mimic what the server does since we write
        directly to the registry and don't go through an API.  If these
        every change, the error messages will need to be updated as well.
    Author: EricDav
---------------------------------------------------------------------------*/
BOOL
CServerPropDBRecord::CheckValues() 
{
    BOOL  fValid = TRUE;

	UpdateData();

    do 
    {
        DWORD dwRenew = CalculateRenewInt();
    
        if (dwRenew < WINSCNF_MIN_REFRESH_INTERVAL)
        {
            AfxMessageBox(IDS_ERR_RENEW_INTERVAL);
            fValid = FALSE;
            break;
        }

        DWORD dwExtTm = CalculateExtTm();

        if (dwExtTm < WINSCNF_MIN_TOMBSTONE_TIMEOUT)
        {
            // minimum value
            AfxMessageBox(IDS_ERR_EXTINCTION_TIMEOUT_MIN);
            fValid = FALSE;
            break;
        }

        if (dwExtTm < dwRenew)
        {
            // bad... must be at least this value
            AfxMessageBox(IDS_ERR_EXTINCTION_TIMEOUT);
            fValid = FALSE;
            break;
        }

        DWORD dwExtInt = CalculateExtInt();
        
        //--ft:07/10/00--
        // replaced WINSCNF_MAKE_TOMB_INTVL_M macro with its expansion..
        // otherwise, the compiler with CLEAN64_BIT=1 reports an error
        // since max(any_dword, 0) is always true - and the compiler is dumb enough
        // to signal this as an error..
        //
        //if (dwExtInt < WINSCNF_MAKE_TOMB_INTVL_M(dwRenew, 0))
        if (dwExtInt < min(dwRenew, FOUR_DAYS))
        {
            // bad...  must be at least that value
            AfxMessageBox(IDS_ERR_EXTINCTION_INTERVAL);
            fValid = FALSE;
            break;
        }

        DWORD dwVerifyInt = CalculateVerifyInt();

        if (dwVerifyInt < WINSCNF_MAKE_VERIFY_INTVL_M(dwExtInt))
        {
            // bad... must be at least this value
            if (WINSCNF_MAKE_VERIFY_INTVL_M(dwExtInt) == TWENTY_FOUR_DAYS)
            {
                AfxMessageBox(IDS_ERR_VERIFY_INTERVAL_24_DAYS);
            }
            else
            {
                CString strTemp;
                strTemp.Format(IDS_ERR_VERIFY_INTERVAL_CALC, TOMB_MULTIPLIER_FOR_VERIFY);
                AfxMessageBox(strTemp);
            }

            fValid = FALSE;
            break;
        }
    }
    while (FALSE);

    return fValid;
}





/////////////////////////////////////////////////////////////////////////////
// CServerPropDBVerification property page

IMPLEMENT_DYNCREATE(CServerPropDBVerification, CPropertyPageBase)

CServerPropDBVerification::CServerPropDBVerification() : CPropertyPageBase(CServerPropDBVerification::IDD)
{
	//{{AFX_DATA_INIT(CServerPropDBVerification)
	m_fCCPeriodic = FALSE;
	m_nCCCheckRandom = -1;
	m_nCCHour = 0;
	m_nCCMinute = 0;
	m_nCCSecond = 0;
	m_nCCMaxChecked = 0;
	m_nCCTimeInterval = 0;
	//}}AFX_DATA_INIT
}


CServerPropDBVerification::~CServerPropDBVerification()
{
}


void CServerPropDBVerification::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServerPropDBVerification)
	DDX_Control(pDX, IDC_EDIT_CC_START_SECOND, m_editCCSecond);
	DDX_Control(pDX, IDC_EDIT_CC_START_MINUTE, m_editCCMinute);
	DDX_Control(pDX, IDC_EDIT_CC_START_HOUR, m_editCCHour);
	DDX_Control(pDX, IDC_SPIN_CC_START_MINUTE, m_spinCCMinute);
	DDX_Control(pDX, IDC_EDIT_CC_INTERVAL, m_editCCInterval);
	DDX_Control(pDX, IDC_EDIT_CC_MAX_CHECKED, m_editCCMaxChecked);
	DDX_Control(pDX, IDC_RADIO_CHECK_OWNER, m_radioCheckOwner);
	DDX_Control(pDX, IDC_CHECK_PERIODIC_CC, m_checkEnableCC);
	DDX_Control(pDX, IDC_SPIN_CC_START_SECOND, m_spinCCSecond);
	DDX_Control(pDX, IDC_SPIN_CC_START_HOUR, m_spinCCHour);
	DDX_Check(pDX, IDC_CHECK_PERIODIC_CC, m_fCCPeriodic);
	DDX_Radio(pDX, IDC_RADIO_CHECK_OWNER, m_nCCCheckRandom);
	DDX_Text(pDX, IDC_EDIT_CC_START_HOUR, m_nCCHour);
	DDV_MinMaxInt(pDX, m_nCCHour, 0, MAX_HOURS);
	DDX_Text(pDX, IDC_EDIT_CC_START_MINUTE, m_nCCMinute);
	DDV_MinMaxInt(pDX, m_nCCMinute, 0, MAX_MINUTES);
	DDX_Text(pDX, IDC_EDIT_CC_START_SECOND, m_nCCSecond);
	DDV_MinMaxInt(pDX, m_nCCSecond, 0, MAX_SECONDS);
	DDX_Text(pDX, IDC_EDIT_CC_MAX_CHECKED, m_nCCMaxChecked);
	DDV_MinMaxUInt(pDX, m_nCCMaxChecked, WINSCNF_CC_MIN_RECS_AAT, 4294967295);
	DDX_Text(pDX, IDC_EDIT_CC_INTERVAL, m_nCCTimeInterval);
	DDV_MinMaxUInt(pDX, m_nCCTimeInterval, WINSCNF_CC_MIN_INTERVAL/(60*60), 24);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CServerPropDBVerification, CPropertyPageBase)
	//{{AFX_MSG_MAP(CServerPropDBVerification)
	ON_BN_CLICKED(IDC_CHECK_PERIODIC_CC, OnCheckPeriodicCc)
	ON_EN_CHANGE(IDC_EDIT_CC_INTERVAL, OnChangeEditCcInterval)
	ON_EN_CHANGE(IDC_EDIT_CC_MAX_CHECKED, OnChangeEditCcMaxChecked)
	ON_EN_CHANGE(IDC_EDIT_CC_START_HOUR, OnChangeEditCcStartHour)
	ON_EN_CHANGE(IDC_EDIT_CC_START_MINUTE, OnChangeEditCcStartMinute)
	ON_EN_CHANGE(IDC_EDIT_CC_START_SECOND, OnChangeEditCcStartSecond)
	ON_BN_CLICKED(IDC_RADIO_CHECK_OWNER, OnRadioCheckOwner)
	ON_BN_CLICKED(IDC_RADIO_CHECK_RANDOM, OnRadioCheckRandom)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServerPropDBVerification message handlers

BOOL 
CServerPropDBVerification::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();

		// get the server
	SPITFSNode spNode;
	CWinsServerHandler *pServer;

	spNode = GetHolder()->GetNode();
	pServer = GETHANDLER(CWinsServerHandler, spNode);
	
	// get the interval stuff from the server and display in the spinner controlss
	HRESULT hr = GetConfig();
	
	m_spinCCHour.SetRange(0, MAX_HOURS);
	m_spinCCMinute.SetRange(0, MAX_MINUTES);
	m_spinCCSecond.SetRange(0, MAX_SECONDS);       
    
    SetCCInfo();
    UpdateCCControls();

    SetDirty(FALSE);
 
    return TRUE;  
}

BOOL 
CServerPropDBVerification::OnApply() 
{
	HRESULT hr = UpdateServerConfiguration();
    if (FAILED(hr))
    {
        return FALSE;
    }
    else
    {
	    return CPropertyPageBase::OnApply();
    }
}


void 
CServerPropDBVerification::OnOK() 
{
	HRESULT hr = UpdateServerConfiguration();
    if (FAILED(hr))
    {
        return;
    }
    else
    {
    	CPropertyPageBase::OnOK();
    }
}

void CServerPropDBVerification::OnCheckPeriodicCc() 
{
    UpdateCCControls();
    SetDirty(TRUE);
}

void CServerPropDBVerification::OnChangeEditCcInterval() 
{
    SetDirty(TRUE);
}

void CServerPropDBVerification::OnChangeEditCcMaxChecked() 
{
    SetDirty(TRUE);
}

void CServerPropDBVerification::OnChangeEditCcStartHour() 
{
    SetDirty(TRUE);
}

void CServerPropDBVerification::OnChangeEditCcStartMinute() 
{
    SetDirty(TRUE);
}

void CServerPropDBVerification::OnChangeEditCcStartSecond() 
{
    SetDirty(TRUE);
}

void CServerPropDBVerification::OnRadioCheckOwner() 
{
    SetDirty(TRUE);
}

void CServerPropDBVerification::OnRadioCheckRandom() 
{
    SetDirty(TRUE);
}

/*---------------------------------------------------------------------------
	CServerPropDBVerification::UpdateServerConfiguration()
		Updates the server handler variables
---------------------------------------------------------------------------*/
HRESULT
CServerPropDBVerification::UpdateServerConfiguration()
{
    UpdateData();

	// Reflect the changes in the server's CConfiguration object
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// get the server
	SPITFSNode spNode;
	CWinsServerHandler *pServer;

	spNode = GetHolder()->GetNode();
	pServer = GETHANDLER(CWinsServerHandler, spNode);

    // consistency check
	m_pConfig->m_fPeriodicConsistencyCheck = m_fCCPeriodic;
    m_pConfig->m_fCCUseRplPnrs = m_nCCCheckRandom;
    m_pConfig->m_dwMaxRecsAtATime = m_nCCMaxChecked;
        
    // convert to seconds
    m_pConfig->m_dwCCTimeInterval = m_nCCTimeInterval * (60*60);
    
    // start time
    CTime curTime = CTime::GetCurrentTime();

    int nYear = curTime.GetYear();
    int nMonth = curTime.GetMonth();
    int nDay = curTime.GetDay();

    CTime tempTime(nYear, nMonth, nDay, m_nCCHour, m_nCCMinute, m_nCCSecond);
    m_pConfig->m_itmCCStartTime = tempTime;

    // now write to server
    DWORD err = m_pConfig->Store();
    if (err != ERROR_SUCCESS)
    {
        // something bad happened
        WinsMessageBox(err);
    }
    else
    {   
        // success update our local copy
        pServer->SetConfig(*m_pConfig);
    }

    return HRESULT_FROM_WIN32(err);
}

/*---------------------------------------------------------------------------
	CServerPropDBVerification::GetConfig()
		Updates the configuration object from the server handler
---------------------------------------------------------------------------*/
HRESULT 
CServerPropDBVerification::GetConfig()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = hrOK;

    m_pConfig = ((CServerProperties *) GetHolder())->GetConfig();

	return hr;
}

/*---------------------------------------------------------------------------
	CServerPropDBVerification::UpdateCCControls()
		Enables/disables depending on checkbox
    Author: EricDav
---------------------------------------------------------------------------*/
void 
CServerPropDBVerification::UpdateCCControls()
{
    UpdateData();
    BOOL fEnable = FALSE;

    if (m_fCCPeriodic)
    {
        fEnable = TRUE;
    }

    m_spinCCHour.EnableWindow(fEnable);
    m_spinCCMinute.EnableWindow(fEnable);
    m_spinCCSecond.EnableWindow(fEnable);

    m_editCCHour.EnableWindow(fEnable);
    m_editCCMinute.EnableWindow(fEnable);
    m_editCCSecond.EnableWindow(fEnable);

    m_editCCMaxChecked.EnableWindow(fEnable);
    m_editCCInterval.EnableWindow(fEnable);
    m_radioCheckOwner.EnableWindow(fEnable);
    GetDlgItem(IDC_RADIO_CHECK_RANDOM)->EnableWindow(fEnable);

    // TODO: static text
}

/*---------------------------------------------------------------------------
	CServerPropDBVerification::SetCCInfo()
		Sets the interval values for Consistency checking
    Author: EricDav
---------------------------------------------------------------------------*/
void 
CServerPropDBVerification::SetCCInfo()
{
	CString strTemp;
    CButton * pRadio;

    m_checkEnableCC.SetCheck(m_pConfig->m_fPeriodicConsistencyCheck);
    
    if (m_pConfig->m_fCCUseRplPnrs)
    {
        pRadio = (CButton *) GetDlgItem(IDC_RADIO_CHECK_RANDOM);
    }
    else
    {
        pRadio = (CButton *) GetDlgItem(IDC_RADIO_CHECK_OWNER);
    }

    pRadio->SetCheck(TRUE);

    strTemp.Format(_T("%lu"), m_pConfig->m_dwMaxRecsAtATime);
    m_editCCMaxChecked.SetWindowText(strTemp);

    // convert the TimeInterval into hours from seconds
    int nTimeTemp = m_pConfig->m_dwCCTimeInterval / (60 * 60);

    strTemp.Format(_T("%lu"), nTimeTemp);
    m_editCCInterval.SetWindowText(strTemp);
    
    m_spinCCHour.SetPos(m_pConfig->m_itmCCStartTime.GetHour());
    m_spinCCMinute.SetPos(m_pConfig->m_itmCCStartTime.GetMinute());
    m_spinCCSecond.SetPos(m_pConfig->m_itmCCStartTime.GetSecond());
}


/////////////////////////////////////////////////////////////////////////////
// CServerPropAdvanced property page

IMPLEMENT_DYNCREATE(CServerPropAdvanced, CPropertyPageBase)

CServerPropAdvanced::CServerPropAdvanced() : CPropertyPageBase(CServerPropAdvanced::IDD)
{
	//{{AFX_DATA_INIT(CServerPropAdvanced)
	m_fLogEvents = FALSE;
	m_strStartVersion = _T("");
	m_fLanNames = FALSE;
	m_fBurstHandling = FALSE;
	m_nQueSelection = -1;
	m_strDbPath = _T("");
	//}}AFX_DATA_INIT

	m_fRestart = FALSE;
}

CServerPropAdvanced::~CServerPropAdvanced()
{
}

void CServerPropAdvanced::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServerPropAdvanced)
	DDX_Control(pDX, IDC_BUTTON_BROWSE_DATABASE, m_buttonBrowse);
	DDX_Control(pDX, IDC_EDIT_DATABASE_PATH, m_editDbPath);
	DDX_Control(pDX, IDC_CHECK_BURST_HANDLING, m_checkBurstHandling);
	DDX_Control(pDX, IDC_CHECK_LANNAMES, m_checkLanNames);
	DDX_Control(pDX, IDC_EDIT_START_VERSION, m_editVersionCount);
	DDX_Control(pDX, IDC_CHECK_LOGEVENTS, m_checkLogDetailedEvents);
	DDX_Check(pDX, IDC_CHECK_LOGEVENTS, m_fLogEvents);
	DDX_Text(pDX, IDC_EDIT_START_VERSION, m_strStartVersion);
	DDV_MaxChars(pDX, m_strStartVersion, 16);
	DDX_Check(pDX, IDC_CHECK_LANNAMES, m_fLanNames);
	DDX_Check(pDX, IDC_CHECK_BURST_HANDLING, m_fBurstHandling);
	DDX_Radio(pDX, IDC_RADIO_LOW, m_nQueSelection);
	DDX_Text(pDX, IDC_EDIT_DATABASE_PATH, m_strDbPath);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CServerPropAdvanced, CPropertyPageBase)
	//{{AFX_MSG_MAP(CServerPropAdvanced)
	ON_BN_CLICKED(IDC_CHECK_LANNAMES, OnCheckLannames)
	ON_BN_CLICKED(IDC_CHECK_BURST_HANDLING, OnCheckBurstHandling)
	ON_BN_CLICKED(IDC_RADIO_CUSTOM, OnRadioCustom)
	ON_BN_CLICKED(IDC_RADIO_HIGH, OnRadioHigh)
	ON_BN_CLICKED(IDC_RADIO_LOW, OnRadioLow)
	ON_BN_CLICKED(IDC_RADIO_MEDIUM, OnRadioMedium)
	ON_EN_CHANGE(IDC_EDIT_CUSTOM_VALUE, OnChangeEditCustomValue)
	ON_BN_CLICKED(IDC_BUTTON_BROWSE_DATABASE, OnButtonBrowseDatabase)
	ON_BN_CLICKED(IDC_CHECK_LOGEVENTS, MarkDirty)
	ON_EN_CHANGE(IDC_EDIT_START_VERSION, MarkDirty)
	ON_EN_CHANGE(IDC_EDIT_DATABASE_PATH, OnChangeEditDatabasePath)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServerPropAdvanced message handlers

BOOL 
CServerPropAdvanced::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();
	GetConfig();

	// get the server
	SPITFSNode spNode;
	CWinsServerHandler *pServer;

	spNode = GetHolder()->GetNode();
	pServer = GETHANDLER(CWinsServerHandler, spNode);
	
	m_fLogEvents =  m_pConfig->m_fLogDetailedEvents;
	if (m_fLogEvents)
	{
		m_checkLogDetailedEvents.SetCheck(1);
	}
	else
	{
		m_checkLogDetailedEvents.SetCheck(0);
	}

	if (pServer->m_dwFlags & FLAG_LANMAN_COMPATIBLE)
	{
		m_fLanNames = TRUE;
		m_checkLanNames.SetCheck(TRUE);
	}
	else
	{
		m_fLanNames = FALSE;
		m_checkLanNames.SetCheck(FALSE);
	}

	LONG lLowWord = m_pConfig->m_dwVersCountStart_LowWord;
    LONG lHighWord = m_pConfig->m_dwVersCountStart_HighWord;

	CString strVersion = GetVersionInfo(lLowWord, lHighWord);
	m_editVersionCount.SetWindowText(strVersion);

    // burst que stuff   
    m_checkBurstHandling.SetCheck(m_pConfig->m_fBurstHandling);
    
    ((CEdit *) GetDlgItem(IDC_EDIT_CUSTOM_VALUE))->LimitText(5);
    SetQueSize();
    UpdateBurstHandling();

	// db path stuff
    // browse only available on local machine
	// get the server
	m_buttonBrowse.ShowWindow(FALSE);  // we may add this back in later
    m_buttonBrowse.EnableWindow(pServer->IsLocalConnection());

	m_editDbPath.EnableWindow(pServer->IsLocalConnection());
	m_editDbPath.SetWindowText(m_pConfig->m_strDbPath);

    SetDirty(FALSE);
	m_fRestart = FALSE;

    return TRUE;  
}

void 
CServerPropAdvanced::OnOK() 
{
    HRESULT hr = UpdateServerConfiguration();
    if (FAILED(hr))
    {
        return;
    }
    else
    {
    	CPropertyPageBase::OnOK();
    }
}

BOOL 
CServerPropAdvanced::OnApply() 
{
	BOOL fRestartNow = FALSE;

	UpdateData();

	// validate the value for Hex
	for (int i=0; i < m_strStartVersion.GetLength(); i++)
    {
        if (!(((m_strStartVersion[i] >= _T('0') ) &&
               (m_strStartVersion[i] <= _T('9') )) ||
              ((m_strStartVersion[i] >= _T('A') ) &&
               (m_strStartVersion[i] <= _T('F') )) ||
			  ((m_strStartVersion[i] >= _T('a') ) &&
               (m_strStartVersion[i] <= _T('f') ))
		   )) 
		{
            ::WinsMessageBox(IDS_ERR_VERSION_NUMBER);
			m_editVersionCount.SetFocus();
            m_editVersionCount.SetSel(0,-1);
            return FALSE;
        }
    }

    DWORD dwSize = GetQueSize();
    if (dwSize < WINS_QUEUE_HWM_MIN ||
        dwSize > WINS_QUEUE_HWM_MAX)
    {
        CString strMin, strMax, strDisplay;

        strMin.Format(_T("%d"), WINS_QUEUE_HWM_MIN);
        strMax.Format(_T("%d"), WINS_QUEUE_HWM_MAX);

        AfxFormatString2(strDisplay, IDS_ERR_BURST_QUE_SIZE, strMin, strMax);

        AfxMessageBox(strDisplay);

        GetDlgItem(IDC_EDIT_CUSTOM_VALUE)->SetFocus();
        return FALSE;
    }

	// warn the user 
	if (m_fRestart)
	{
		int nRet = AfxMessageBox(IDS_DATABASE_PATH_CHANGE, MB_YESNOCANCEL);
		if (nRet == IDCANCEL)
		{
			return FALSE;
		}
		else
		if (nRet == IDYES)
		{
			fRestartNow = TRUE;
		}
	}

    HRESULT hr = UpdateServerConfiguration();
    if (FAILED(hr))
    {
        return FALSE;
    }

	if (fRestartNow)
	{
		CString strServiceName;
		strServiceName.LoadString(IDS_SERVICE_NAME);


		// get the server
		SPITFSNode spNode;
		CWinsServerHandler *pServer;

		spNode = GetHolder()->GetNode();
		pServer = GETHANDLER(CWinsServerHandler, spNode);

		DWORD dwError = TFSStopServiceEx(m_pConfig->GetOwner(), _T("WINS"), _T("WINS Service"), strServiceName);
		if (dwError)
		{
			WinsMessageBox(dwError);
		}
		else
		{
			dwError = TFSStartServiceEx(m_pConfig->GetOwner(), _T("WINS"), _T("WINS Service"), strServiceName);
			if (dwError)
			{
				WinsMessageBox(dwError);
			}
		}

		pServer->ConnectToWinsServer(spNode);
	}

	m_fRestart = FALSE;

    return CPropertyPageBase::OnApply();
}


/*---------------------------------------------------------------------------
	CServerPropAdvanced::GetConfig()
		Updates the configuration object from the server handler
----------------------------