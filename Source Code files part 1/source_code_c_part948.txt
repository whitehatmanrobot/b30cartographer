ID_PRODUCT            0
#define LVID_LAST_USED          1
#define LVID_TOTAL_USED         2

#define LVCX_PRODUCT            40
#define LVCX_LAST_USED          30
#define LVCX_TOTAL_USED         -1

static LV_COLUMN_INFO g_productColumnInfo = {

    0, 0, 3,
    {{LVID_PRODUCT,    IDS_PRODUCT,        0, LVCX_PRODUCT   },
     {LVID_LAST_USED,  IDS_LAST_DATE_USED, 0, LVCX_LAST_USED },
     {LVID_TOTAL_USED, IDS_USAGE_COUNT,    0, LVCX_TOTAL_USED}},

};

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CUserPropertyPageProducts, CPropertyPage)

BEGIN_MESSAGE_MAP(CUserPropertyPageProducts, CPropertyPage)
    //{{AFX_MSG_MAP(CUserPropertyPageProducts)
    ON_BN_CLICKED(IDC_PP_USER_PRODUCTS_DELETE, OnDelete)
    ON_BN_CLICKED(IDC_PP_USER_PRODUCTS_BACKOFFICE, OnBackOfficeUpgrade)
    ON_NOTIFY(NM_DBLCLK, IDC_PP_USER_PRODUCTS_PRODUCTS, OnDblClkProducts)
    ON_NOTIFY(NM_RETURN, IDC_PP_USER_PRODUCTS_PRODUCTS, OnReturnProducts)
    ON_NOTIFY(NM_SETFOCUS, IDC_PP_USER_PRODUCTS_PRODUCTS, OnSetFocusProducts)
    ON_NOTIFY(NM_KILLFOCUS, IDC_PP_USER_PRODUCTS_PRODUCTS, OnKillFocusProducts)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_PP_USER_PRODUCTS_PRODUCTS, OnColumnClickProducts)
    ON_NOTIFY(LVN_GETDISPINFO, IDC_PP_USER_PRODUCTS_PRODUCTS, OnGetDispInfoProducts)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


CUserPropertyPageProducts::CUserPropertyPageProducts() 
    : CPropertyPage(CUserPropertyPageProducts::IDD)

/*++

Routine Description:

    Constructor for user property page (products).

Arguments:

    None.

Return Values:

    None.

--*/

{
    //{{AFX_DATA_INIT(CUserPropertyPageProducts)
    m_bUseBackOffice = FALSE;
    //}}AFX_DATA_INIT

    m_pUser       = NULL;
    m_pUpdateHint = NULL;
    m_bProductProperties = TRUE;
    m_bAreCtrlsInitialized = FALSE;
}


CUserPropertyPageProducts::~CUserPropertyPageProducts()

/*++

Routine Description:

    Destructor for user property page (products).

Arguments:

    None.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here...
    //
}


void CUserPropertyPageProducts::DoDataExchange(CDataExchange* pDX)

/*++

Routine Description:

    Called by framework to exchange dialog data.

Arguments:

    pDX - data exchange object.

Return Values:

    None.

--*/

{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CUserPropertyPageProducts)
    DDX_Control(pDX, IDC_PP_USER_PRODUCTS_BACKOFFICE, m_upgBtn);
    DDX_Control(pDX, IDC_PP_USER_PRODUCTS_DELETE, m_delBtn);
    DDX_Control(pDX, IDC_PP_USER_PRODUCTS_PRODUCTS, m_productList);
    DDX_Check(pDX, IDC_PP_USER_PRODUCTS_BACKOFFICE, m_bUseBackOffice);
    //}}AFX_DATA_MAP
}


void CUserPropertyPageProducts::InitCtrls()

/*++

Routine Description:

    Initializes property page controls.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_upgBtn.SetCheck(0);
    m_delBtn.EnableWindow(FALSE);

    m_productList.SetFocus();

    m_bAreCtrlsInitialized = TRUE;

    ::LvInitColumns(&m_productList, &g_productColumnInfo);
}


void CUserPropertyPageProducts::InitPage(CUser* pUser, DWORD* pUpdateHint, BOOL bProductProperties)


/*++

Routine Description:

    Initializes property page.

Arguments:

    pUser - user object.
    pUpdateHint - update hint.
    bProductProperties - to recurse or not

Return Values:

    None.

--*/

{
    ASSERT(pUpdateHint);
    VALIDATE_OBJECT(pUser, CUser);

    m_pUser = pUser;
    m_pUpdateHint = pUpdateHint;
    m_bProductProperties = bProductProperties;
}


void CUserPropertyPageProducts::AbortPageIfNecessary()

/*++

Routine Description:

    Displays status and aborts if connection lost.

Arguments:

    None.

Return Values:

    None.

--*/

{
    theApp.DisplayLastStatus();

    if (IsConnectionDropped(LlsGetLastStatus()))
    {
        AbortPage(); // bail...
    }
}


void CUserPropertyPageProducts::AbortPage()

/*++

Routine Description:

    Aborts property page.

Arguments:

    None.

Return Values:

    None.

--*/

{
    *m_pUpdateHint = UPDATE_INFO_ABORT;
    GetParent()->PostMessage(WM_COMMAND, IDCANCEL); 
}


BOOL CUserPropertyPageProducts::OnInitDialog() 

/*++

Routine Description:

    Message handler for WM_INITDIALOG.

Arguments:

    None.

Return Values:

    Return false if focus set manually.

--*/

{
    CPropertyPage::OnInitDialog();

    PostMessage(WM_COMMAND, ID_INIT_CTRLS);
    return TRUE;   
}


void CUserPropertyPageProducts::OnDestroy()

/*++

Routine Description:

    Message handler for WM_DESTROY.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ::LvReleaseObArray(&m_productList); // release now...
    CPropertyPage::OnDestroy();
}


BOOL CUserPropertyPageProducts::OnSetActive()

/*++

Routine Description:

    Activates property page.

Arguments:

    None.

Return Values:

    Returns true if focus accepted.

--*/

{
    BOOL bIsActivated;
    
    if (bIsActivated = CPropertyPage::OnSetActive())
    {
        if (IsProductInfoUpdated(*m_pUpdateHint) && !RefreshCtrls()) 
        {
            AbortPageIfNecessary(); // display error...
        }    
    }

    return bIsActivated; 

}


BOOL CUserPropertyPageProducts::RefreshCtrls()

/*++

Routine Description:

    Refreshs property page controls.

Arguments:

    None.

Return Values:

    Returns true if controls refreshed.

--*/

{
    VALIDATE_OBJECT(m_pUser, CUser);

    BOOL bIsRefreshed = FALSE;

    VARIANT va;
    VariantInit(&va);

    BeginWaitCursor(); // hourglass...

    CStatistics* pStatistics = (CStatistics*)MKOBJ(m_pUser->GetStatistics(va));

    if (pStatistics)
    {
        VALIDATE_OBJECT(pStatistics, CStatistics);

        bIsRefreshed = ::LvRefreshObArray(        
                            &m_productList, 
                            &g_productColumnInfo, 
                            pStatistics->m_pObArray
                            );

        pStatistics->InternalRelease(); // add ref'd individually...
    }

    if (!bIsRefreshed)
    {
        ::LvReleaseObArray(&m_productList); // reset list now...
    }

    EndWaitCursor(); // hourglass...

    PostMessage(WM_COMMAND, ID_INIT_CTRLS);

    return bIsRefreshed;
}


void CUserPropertyPageProducts::OnDelete() 

/*++

Routine Description:

    Revokes license from user.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CStatistic* pStatistic; 
        
    if (pStatistic = (CStatistic*)::LvGetSelObj(&m_productList))
    {
        VALIDATE_OBJECT(pStatistic, CStatistic);

        CString strConfirm;
        AfxFormatString2(
            strConfirm, 
            IDP_CONFIRM_REVOKE_LICENSE, 
            m_pUser->m_strName, 
            pStatistic->m_strEntry
            );

        if (AfxMessageBox(strConfirm, MB_YESNO) == IDYES)
        {
            NTSTATUS NtStatus;

            BeginWaitCursor(); // hourglass...

            NtStatus = ::LlsUserProductDelete(
                            LlsGetActiveHandle(),
                            MKSTR(m_pUser->m_strName),
                            MKSTR(pStatistic->m_strEntry)
                            );
                            
            EndWaitCursor(); // hourglass...

            if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND)
                NtStatus = STATUS_SUCCESS;

            LlsSetLastStatus(NtStatus); // called api...

            if (NT_SUCCESS(NtStatus))
            {
                *m_pUpdateHint |= UPDATE_LICENSE_REVOKED;

                if (!RefreshCtrls())
                {
                    AbortPageIfNecessary(); // display error...
                }        
            }
            else
            {
                AbortPageIfNecessary(); // display error...
            }
        }
    }
}


BOOL CUserPropertyPageProducts::OnKillActive()

/*++

Routine Description:

    Processes backoffice upgrade.

Arguments:

    None.

Return Values:

    Returns true if upgrade processed successfully.

--*/

{
    if (m_pUser->m_bIsBackOffice != m_upgBtn.GetCheck())
    {
        NTSTATUS NtStatus;
        LLS_USER_INFO_1 UserInfo1;

        UserInfo1.Name       = MKSTR(m_pUser->m_strName);
        UserInfo1.Group      = MKSTR(m_pUser->m_strMapping);
        UserInfo1.Licensed   = m_pUser->m_lInUse;
        UserInfo1.UnLicensed = m_pUser->m_lUnlicensed;
        UserInfo1.Flags      = m_upgBtn.GetCheck() ? LLS_FLAG_SUITE_USE : 0;

        BeginWaitCursor(); // hourglass...

        NtStatus = ::LlsUserInfoSet(
                        LlsGetActiveHandle(),
                        MKSTR(m_pUser->m_strName),
                        1,
                        (LPBYTE)&UserInfo1
                        );

        EndWaitCursor(); // hourglass...

        LlsSetLastStatus(NtStatus); // called api...

        if (NT_SUCCESS(NtStatus))
        {
            m_pUser->m_bIsBackOffice = m_upgBtn.GetCheck() ? TRUE : FALSE;

            *m_pUpdateHint |= UPDATE_LICENSE_UPGRADED;

            SetModified(FALSE);
                    
            if (!RefreshCtrls())
            {
                AbortPageIfNecessary(); // display error...
                return FALSE;
            }    
        }
        else
        {
            AbortPageIfNecessary(); // display error...
            return FALSE;
        }
    }

    return TRUE;
}


void CUserPropertyPageProducts::OnBackOfficeUpgrade() 

/*++

Routine Description:

    Enables Apply Now button.

Arguments:

    None.

Return Values:

    None.

--*/

{
    SetModified(m_pUser->m_bIsBackOffice != m_upgBtn.GetCheck());
}


void CUserPropertyPageProducts::OnDblClkProducts(NMHDR* pNMHDR, LRESULT* pResult) 

/*++

Routine Description:

    Notification handler for NM_DBLCLK.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    ViewProductProperties();    
    *pResult = 0;
}


void CUserPropertyPageProducts::OnReturnProducts(NMHDR* pNMHDR, LRESULT* pResult) 

/*++

Routine Description:

    Notification handler for NM_RETURN.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    ViewProductProperties();    
    *pResult = 0;
}


void CUserPropertyPageProducts::OnSetFocusProducts(NMHDR* pNMHDR, LRESULT* pResult) 

/*++

Routine Description:

    Notification handler for NM_SETFOCUS.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    PostMessage(WM_COMMAND, ID_INIT_CTRLS);
    *pResult = 0;
}


void CUserPropertyPageProducts::OnKillFocusProducts(NMHDR* pNMHDR, LRESULT* pResult) 

/*++

Routine Description:

    Notification handler for NM_KILLFOCUS.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    ::LvSelObjIfNecessary(&m_productList); // ensure selection...

    PostMessage(WM_COMMAND, ID_INIT_CTRLS);
    *pResult = 0;
}


BOOL CUserPropertyPageProducts::OnCommand(WPARAM wParam, LPARAM lParam)

/*++

Routine Description:

    Message handler for WM_COMMAND.

Arguments:

    wParam - message specific.
    lParam - message specific.

Return Values:

    Returns true if message processed.

--*/

{
    if (wParam == ID_INIT_CTRLS)
    {
        if (!m_bAreCtrlsInitialized)
        {
            InitCtrls();  
         
            if (!RefreshCtrls())
            {
                AbortPageIfNecessary(); // display error...
            }
        }
        
        m_upgBtn.SetCheck(m_pUser->m_bIsBackOffice);
        
        ::SafeEnableWindow(
            &m_delBtn, 
            &m_productList, 
            CDialog::GetFocus(), 
            m_productList.GetItemCount() 
            );

        return TRUE; // processed...
    }
        
    return CDialog::OnCommand(wParam, lParam);
}


void CUserPropertyPageProducts::OnColumnClickProducts(NMHDR* pNMHDR, LRESULT* pResult) 

/*++

Routine Description:

    Notification handler for LVN_COLUMNCLICK.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    g_productColumnInfo.bSortOrder  = GetKeyState(VK_CONTROL) < 0;
    g_productColumnInfo.nSortedItem = ((NM_LISTVIEW*)pNMHDR)->iSubItem;

    m_productList.SortItems(CompareUserProducts, 0); // use column info

    *pResult = 0;
}


void CUserPropertyPageProducts::ViewProductProperties()

/*++

Routine Description:

    Recurse into product property page.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CStatistic* pStatistic;

    if (!m_bProductProperties)
    {
        ::MessageBeep(MB_OK);
        return; // bail...
    }

    if (pStatistic = (CStatistic*)::LvGetSelObj(&m_productList))
    {
        VALIDATE_OBJECT(pStatistic, CStatistic);       

        CProduct* pProduct = new CProduct(NULL, pStatistic->m_strEntry);

        if (pProduct)
        {
            CString strTitle;                                                  
            AfxFormatString1(strTitle, IDS_PROPERTIES_OF, pProduct->m_strName);
                                                                           
            CProductPropertySheet productProperties(strTitle);           
            productProperties.InitPages(pProduct, FALSE);                             
            productProperties.DoModal();                                       

            *m_pUpdateHint |= productProperties.m_fUpdateHint;

            if (IsUpdateAborted(productProperties.m_fUpdateHint))
            {
                AbortPage(); // don't display error...
            }
            else if (IsProductInfoUpdated(productProperties.m_fUpdateHint) && !RefreshCtrls())
            {
                AbortPageIfNecessary(); // display error...
            }
        }
        else
        {
            AbortPageIfNecessary(); // display error...
        }

        if (pProduct)
            pProduct->InternalRelease(); // delete object...
    }
}


void CUserPropertyPageProducts::OnGetDispInfoProducts(NMHDR* pNMHDR, LRESULT* pResult) 

/*++

Routine Description:

    Notification handler for LVN_GETDISPINFO.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    LV_ITEM* plvItem = &((LV_DISPINFO*)pNMHDR)->item;
    ASSERT(plvItem);

    CStatistic* pStatistic = (CStatistic*)plvItem->lParam;
    VALIDATE_OBJECT(pStatistic, CStatistic);

    switch (plvItem->iSubItem)
    {
    case LVID_PRODUCT:
        plvItem->iImage = pStatistic->m_bIsValid ? BMPI_PRODUCT_PER_SEAT : BMPI_VIOLATION;
        lstrcpyn(plvItem->pszText, pStatistic->m_strEntry, plvItem->cchTextMax);
        break;

    case LVID_LAST_USED:
    {
        BSTR bstrDateLastUsed = pStatistic->GetLastUsedString();
        if( bstrDateLastUsed != NULL )
        {
            lstrcpyn(plvItem->pszText, bstrDateLastUsed, plvItem->cchTextMax);
            SysFreeString(bstrDateLastUsed);
        }
        else
        {
            lstrcpy(plvItem->pszText, L"");
        }
    }
        break;

    case LVID_TOTAL_USED:
    {
        CString strLabel;
        strLabel.Format(_T("%ld"), pStatistic->GetTotalUsed());         
        lstrcpyn(plvItem->pszText, strLabel, plvItem->cchTextMax);
    }
        break;
    }

    *pResult = 0;
}


int CALLBACK CompareUserProducts(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)

/*++

Routine Description:

    Notification handler for LVM_SORTITEMS.

Arguments:

    lParam1 - object to sort.
    lParam2 - object to sort.
    lParamSort - sort criteria.

Return Values:

    Same as lstrcmp.

--*/

{
#define pStatistic1 ((CStatistic*)lParam1)
#define pStatistic2 ((CStatistic*)lParam2)

    VALIDATE_OBJECT(pStatistic1, CStatistic);
    VALIDATE_OBJECT(pStatistic2, CStatistic);

    int iResult;

    switch (g_productColumnInfo.nSortedItem)
    {
    case LVID_PRODUCT:
        iResult = pStatistic1->m_strEntry.CompareNoCase(pStatistic2->m_strEntry);
        break;

    case LVID_LAST_USED:
        iResult = pStatistic1->m_lLastUsed - pStatistic2->m_lLastUsed;
        break;

    case LVID_TOTAL_USED:
        iResult = pStatistic1->GetTotalUsed() - pStatistic2->GetTotalUsed();
        break;

    default:
        iResult = 0;
        break;
    }

    return g_productColumnInfo.bSortOrder ? -iResult : iResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\usrppgp.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    usrppgp.h

Abstract:

    User property page (products) implementation.

Author:

    Don Ryan (donryan) 05-Feb-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _USRPPGP_H_
#define _USRPPGP_H_

class CUserPropertyPageProducts : public CPropertyPage
{
    DECLARE_DYNCREATE(CUserPropertyPageProducts)
private:
    CUser*       m_pUser;
    DWORD*       m_pUpdateHint;
    BOOL         m_bProductProperties;
    BOOL         m_bAreCtrlsInitialized;

public:
    CUserPropertyPageProducts();
    ~CUserPropertyPageProducts();

    void InitPage(CUser* pUser, DWORD* pUpdateHint, BOOL bProductProperties = TRUE);
    void AbortPageIfNecessary();
    void AbortPage();

    void InitCtrls();
    BOOL RefreshCtrls();

    void ViewProductProperties();

    //{{AFX_DATA(CUserPropertyPageProducts)
    enum { IDD = IDD_PP_USER_PRODUCTS };
    CButton m_upgBtn;
    CButton m_delBtn;
    CListCtrl m_productList;
    BOOL m_bUseBackOffice;
    //}}AFX_DATA

    //{{AFX_VIRTUAL(CUserPropertyPageProducts)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    
    virtual BOOL OnSetActive();
    virtual BOOL OnKillActive();
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

protected:
    //{{AFX_MSG(CUserPropertyPageProducts)
    virtual BOOL OnInitDialog();
    afx_msg void OnDelete();
    afx_msg void OnBackOfficeUpgrade();
    afx_msg void OnDblClkProducts(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnReturnProducts(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSetFocusProducts(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillFocusProducts(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnColumnClickProducts(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnGetDispInfoProducts(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDestroy();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

int CALLBACK CompareUserProducts(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

#endif // _USRPPGP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\usrpsht.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    usrpsht.cpp

Abstract:

    User property sheet implementation.

Author:

    Don Ryan (donryan) 05-Feb-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "usrpsht.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CUserPropertySheet, CPropertySheet)

BEGIN_MESSAGE_MAP(CUserPropertySheet, CPropertySheet)
    //{{AFX_MSG_MAP(CUserPropertySheet)
    ON_COMMAND(ID_HELP, OnHelp)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


CUserPropertySheet::CUserPropertySheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
    :CPropertySheet(nIDCaption, pParentWnd, iSelectPage)

/*++

Routine Description:

    Constructor for property sheet.

Arguments:

    nIDCaption - window caption.
    pParentWnd - parent window handle.
    iSelectPage - initial page selected.

Return Values:

    None.

--*/

{
    m_fUpdateHint = UPDATE_INFO_NONE;
}


CUserPropertySheet::CUserPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
    :CPropertySheet(pszCaption, pParentWnd, iSelectPage)

/*++

Routine Description:

    Constructor for property sheet.

Arguments:

    pszCaption - window caption.
    pParentWnd - parent window handle.
    iSelectPage - initial page selected.

Return Values:

    None.

--*/

{
    m_fUpdateHint = UPDATE_INFO_NONE;
}


CUserPropertySheet::~CUserPropertySheet()

/*++

Routine Description:

    Destructor for property sheet.

Arguments:

    None.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here.
    //
}


void CUserPropertySheet::InitPages(CUser* pUser, BOOL bProductProperties)

/*++

Routine Description:

    Initializes property pages.

Arguments:

    pUser - user object.
    bProductProperties - to recurse or not.

Return Values:

    None.

--*/

{
    m_psh.dwFlags |= PSH_NOAPPLYNOW;
    AddPage(&m_productsPage);
    m_productsPage.InitPage(pUser, &m_fUpdateHint, bProductProperties);
}


void CUserPropertySheet::OnHelp()

/*++

Routine Description:

    Help button support.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CPropertySheet::OnCommandHelp(0, 0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\utils.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    utils.cpp

Abstract:

    Utilities.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 16-Jan-1996
       o  Removed multitudinous SetRedraw()'s and made a fix to TvGetDomain()
          so that LLSMGR no longer AVs when it performs refreshes wherein the
          overall number of domains diminishes and one of the now superfluous
          entries was expanded before the refresh.

--*/

#include "stdafx.h"
#include "llsmgr.h"

//
// List view utilities
//

void LvInitColumns(CListCtrl* pListCtrl, PLV_COLUMN_INFO plvColumnInfo)

/*++

Routine Description:

    Initializes list view columns.

Arguments:

    pListCtrl - list control.
    plvColumnInfo - column information.

Return Values:

    None.

--*/

{
    ASSERT(plvColumnInfo);
    VALIDATE_OBJECT(pListCtrl, CListCtrl);

    int nStringId;
    CString strText;
    LV_COLUMN lvColumn;

    int nColumns = plvColumnInfo->nColumns;
    PLV_COLUMN_ENTRY plvColumnEntry = plvColumnInfo->lvColumnEntry;

    lvColumn.mask = LVCF_FMT|
                    LVCF_TEXT|
                    LVCF_SUBITEM;

    lvColumn.fmt = LVCFMT_LEFT;

    pListCtrl->SetRedraw(FALSE); // turn off drawing...

    while (nColumns--)
    {
        lvColumn.iSubItem = plvColumnEntry->iSubItem;

        if (nStringId = plvColumnEntry->nStringId)
        {
            strText.LoadString(nStringId);
            lvColumn.pszText = MKSTR(strText);
        }
        else
            lvColumn.pszText = _T("");

        pListCtrl->InsertColumn(lvColumn.iSubItem, &lvColumn);
        plvColumnEntry++;
    }

    pListCtrl->SetImageList(&theApp.m_smallImages, LVSIL_SMALL);
    pListCtrl->SetImageList(&theApp.m_largeImages, LVSIL_NORMAL);

    SetDefaultFont(pListCtrl);

    LvResizeColumns(pListCtrl, plvColumnInfo);

    pListCtrl->SetRedraw(TRUE); // turn on drawing...
}


void LvResizeColumns(CListCtrl* pListCtrl, PLV_COLUMN_INFO plvColumnInfo)

/*++

Routine Description:

    Resizes list view columns.

Arguments:

    pListCtrl - list control.
    plvColumnInfo - column information.

Return Values:

    None.

--*/

{
    ASSERT(plvColumnInfo);
    VALIDATE_OBJECT(pListCtrl, CListCtrl);

    int nColumnWidth;
    int nRelativeWidth;
    int nEntireWidthSoFar = 0;
    int nColumns = plvColumnInfo->nColumns;
    PLV_COLUMN_ENTRY plvColumnEntry = plvColumnInfo->lvColumnEntry;

    CRect clientRect;
    pListCtrl->GetClientRect(clientRect);

    pListCtrl->SetRedraw(FALSE); // turn off drawing...

    while ((nRelativeWidth = plvColumnEntry->nRelativeWidth) != -1)
    {
        nColumnWidth = (nRelativeWidth * clientRect.Width()) / 100;
        pListCtrl->SetColumnWidth(plvColumnEntry->iSubItem, nColumnWidth);
        nEntireWidthSoFar += nColumnWidth;
        plvColumnEntry++;
    }

    nColumnWidth = clientRect.Width() - nEntireWidthSoFar;
    pListCtrl->SetColumnWidth(plvColumnEntry->iSubItem, nColumnWidth);

    pListCtrl->SetRedraw(TRUE); // turn on drawing...
}


void LvChangeFormat(CListCtrl* pListCtrl, UINT nFormatId)

/*++

Routine Description:

    Changes window style of list view.

Arguments:

    pListCtrl - list control.
    nFormatId - format specification.

Return Values:

    None.

--*/

{
    VALIDATE_OBJECT(pListCtrl, CListCtrl);

    DWORD dwStyle = ::GetWindowLong(pListCtrl->GetSafeHwnd(), GWL_STYLE);

    pListCtrl->BeginWaitCursor();
    pListCtrl->SetRedraw(FALSE); // turn off drawing...

    if ((dwStyle & LVS_TYPEMASK) != nFormatId)
    {
        ::SetWindowLong(
            pListCtrl->GetSafeHwnd(),
            GWL_STYLE,
            (dwStyle & ~LVS_TYPEMASK) | nFormatId
            );
    }

    pListCtrl->SetRedraw(TRUE); // turn on drawing...
    pListCtrl->EndWaitCursor();
}


LPVOID LvGetSelObj(CListCtrl* pListCtrl)

/*++

Routine Description:

    Retrieves the object selected (assumes one) from list view.

Arguments:

    pListCtrl - list control.

Return Values:

    Same as LvGetNextObj.

--*/

{
    int iItem = -1;
    return LvGetNextObj(pListCtrl, &iItem);
}


LPVOID LvGetNextObj(CListCtrl* pListCtrl, LPINT piItem, int nType)

/*++

Routine Description:

    Retrieves the next object selected from list view.

Arguments:

    pListCtrl - list control.
    piItem - starting index (updated).
    nType - specifies search criteria.

Return Values:

    Returns object pointer or null.

--*/

{
    ASSERT(piItem);
    VALIDATE_OBJECT(pListCtrl, CListCtrl);

    LV_ITEM lvItem;

    if ((lvItem.iItem = pListCtrl->GetNextItem(*piItem, nType)) != -1)
    {
        lvItem.mask = LVIF_PARAM;
        lvItem.iSubItem = 0;

        if (pListCtrl->GetItem(&lvItem))
        {
            *piItem = lvItem.iItem;
            return (LPVOID)lvItem.lParam;
        }
    }

    return NULL;
}


BOOL LvInsertObArray(CListCtrl* pListCtrl, PLV_COLUMN_INFO plvColumnInfo, CObArray* pObArray)

/*++

Routine Description:

    Insert object array into list view.
    Note list view must be unsorted and support LVN_GETDISPINFO.

Arguments:

    pListCtrl - list control.
    plvColumnInfo - column info.
    pObArray - object array.

Return Values:

    VT_BOOL.

--*/

{
    VALIDATE_OBJECT(pObArray, CObArray);
    VALIDATE_OBJECT(pListCtrl, CListCtrl);

    ASSERT(plvColumnInfo);
    ASSERT(pListCtrl->GetItemCount() == 0);

    BOOL bItemsInserted = FALSE;

    LV_ITEM lvItem;

    lvItem.mask = LVIF_TEXT|
                  LVIF_PARAM|
                  LVIF_IMAGE;

    lvItem.pszText    = LPSTR_TEXTCALLBACK;
    lvItem.cchTextMax = LPSTR_TEXTCALLBACK_MAX;
    lvItem.iImage     = I_IMAGECALLBACK;
    lvItem.iSubItem   = 0;

    int iItem;
    int iSubItem;

    int nItems = (int)pObArray->GetSize();
    ASSERT(nItems != -1); // iItem is -1 if error...

    pListCtrl->SetRedraw(FALSE); // turn off drawing...

    pListCtrl->SetItemCount(nItems);

    CCmdTarget* pObject = NULL;

    for (iItem = 0; (iItem < nItems) && (pObject = (CCmdTarget*)pObArray->GetAt(iItem)); iItem++)
    {
        VALIDATE_OBJECT(pObject, CCmdTarget);

        lvItem.iItem  = iItem;
        lvItem.lParam = (LPARAM)(LPVOID)pObject;

        pObject->InternalAddRef(); // add ref...

        iItem = pListCtrl->InsertItem(&lvItem);
        ASSERT((iItem == lvItem.iItem) || (iItem == -1));

        for (iSubItem = 1; iSubItem < plvColumnInfo->nColumns; iSubItem++)
        {
            pListCtrl->SetItemText(iItem, iSubItem, LPSTR_TEXTCALLBACK);
        }
    }

    if (iItem == nItems)
    {
        bItemsInserted = TRUE;
        VERIFY(pListCtrl->SetItemState(
                    0,
                    LVIS_FOCUSED|
                    LVIS_SELECTED,
                    LVIS_FOCUSED|
                    LVIS_SELECTED
                    ));
    }
    else
    {
        LlsSetLastStatus(STATUS_NO_MEMORY);
        VERIFY(pListCtrl->DeleteAllItems());
    }

    LvResizeColumns(pListCtrl, plvColumnInfo);

    pListCtrl->Invalidate(TRUE);
    pListCtrl->SetRedraw(TRUE); // turn on drawing...

    return bItemsInserted;
}


BOOL
LvRefreshObArray(
    CListCtrl*      pListCtrl,
    PLV_COLUMN_INFO plvColumnInfo,
    CObArray*       pObArray
    )

/*++

Routine Description:

    Refresh object array in list view.

Arguments:

    pListCtrl - list control.
    plvColumnInfo - column info.
    pObArray - object array.

Return Values:

    VT_BOOL.

--*/

{
    ASSERT(plvColumnInfo);
    VALIDATE_OBJECT(pObArray, CObArray);
    VALIDATE_OBJECT(pListCtrl, CListCtrl);

    LONG_PTR nObjects = pObArray->GetSize();
    long nObjectsInList = pListCtrl->GetItemCount();

    if (!nObjects)
    {
        LvReleaseObArray(pListCtrl);
        return TRUE;
    }
    else if (!nObjectsInList)
    {
        return LvInsertObArray(
                pListCtrl,
                plvColumnInfo,
                pObArray
                );
    }

    CCmdTarget* pObject;

    int iObject = 0;
    int iObjectInList = 0;

    LV_ITEM lvItem;

    pListCtrl->SetRedraw(FALSE); // turn off drawing...

    while (nObjectsInList--)
    {
        lvItem.mask = LVIF_PARAM;
        lvItem.iItem = iObjectInList;
        lvItem.iSubItem = 0;

        VERIFY(pListCtrl->GetItem(&lvItem));

        pObject = (CCmdTarget*)lvItem.lParam;
        VALIDATE_OBJECT(pObject, CCmdTarget);

        if (iObject < nObjects)
        {
            pObject->InternalRelease(); // release before...

            pObject = (CCmdTarget*)pObArray->GetAt(iObject++);
            VALIDATE_OBJECT(pObject, CCmdTarget);

            pObject->InternalAddRef(); // add ref...

            lvItem.mask = LVIF_TEXT|LVIF_PARAM;
            lvItem.pszText = LPSTR_TEXTCALLBACK;
            lvItem.cchTextMax = LPSTR_TEXTCALLBACK_MAX;
            lvItem.lParam = (LPARAM)(LPVOID)pObject;

            VERIFY(pListCtrl->SetItem(&lvItem)); // overwrite...

            iObjectInList++; // increment count...
        }
        else
        {
            VERIFY(pListCtrl->DeleteItem(iObjectInList));

            pObject->InternalRelease(); // release after...
        }
    }

    lvItem.mask = LVIF_TEXT|
                  LVIF_PARAM|
                  LVIF_IMAGE;

    lvItem.pszText    = LPSTR_TEXTCALLBACK;
    lvItem.cchTextMax = LPSTR_TEXTCALLBACK_MAX;
    lvItem.iImage     = I_IMAGECALLBACK;
    lvItem.iSubItem   = 0;

    int iItem;
    int iSubItem;

    while (iObject < nObjects)
    {
        lvItem.iItem = iObject;

        pObject = (CCmdTarget*)pObArray->GetAt(iObject++);
        VALIDATE_OBJECT(pObject, CCmdTarget);

        pObject->InternalAddRef(); // add ref...

        lvItem.lParam = (LPARAM)(LPVOID)pObject;

        iItem = pListCtrl->InsertItem(&lvItem);
        ASSERT((iItem == lvItem.iItem) && (iItem != -1));

        for (iSubItem = 1; iSubItem < plvColumnInfo->nColumns; iSubItem++)
        {
            VERIFY(pListCtrl->SetItemText(iItem, iSubItem, LPSTR_TEXTCALLBACK));
        }
    }

    LvResizeColumns(pListCtrl, plvColumnInfo);

    pListCtrl->Invalidate(TRUE);
    pListCtrl->SetRedraw(TRUE); // turn on drawing...

    return TRUE;
}


void LvReleaseObArray(CListCtrl* pListCtrl)

/*++

Routine Description:

    Release objects inserted into list view.

Arguments:

    pListCtrl - list control.

Return Values:

    None.

--*/

{
    VALIDATE_OBJECT(pListCtrl, CListCtrl);

    LV_ITEM lvItem;

    CCmdTarget* pObject;

    lvItem.mask = LVIF_PARAM;
    lvItem.iItem = 0;
    lvItem.iSubItem = 0;

    int nObjectsInList = pListCtrl->GetItemCount();

    pListCtrl->BeginWaitCursor();
    pListCtrl->SetRedraw(FALSE); // turn off drawing...

    while (nObjectsInList--)
    {
        VERIFY(pListCtrl->GetItem(&lvItem));

        pObject = (CCmdTarget*)lvItem.lParam;
        VALIDATE_OBJECT(pObject, CCmdTarget);

        VERIFY(pListCtrl->DeleteItem(lvItem.iItem));

        pObject->InternalRelease(); // release after...
    }

    pListCtrl->SetRedraw(TRUE); // turn on drawing...
    pListCtrl->EndWaitCursor();
}


void LvReleaseSelObjs(CListCtrl* pListCtrl)

/*++

Routine Description:

    Release selected objects in list view.

Arguments:

    pListCtrl - list control.

Return Values:

    None.

--*/

{
    VALIDATE_OBJECT(pListCtrl, CListCtrl);

    int iItem = -1;


    CCmdTarget* pObject;

    pListCtrl->SetRedraw(FALSE); // turn off drawing...


    while (pObject = (CCmdTarget*)::LvGetNextObj(pListCtrl, &iItem))
    {
        pObject->InternalRelease();
        pListCtrl->DeleteItem(iItem);
        iItem = -1;
    }

    LvSelObjIfNecessary(pListCtrl);

    pListCtrl->SetRedraw(TRUE); // turn on drawing...
}


void LvSelObjIfNecessary(CListCtrl* pListCtrl, BOOL bSetFocus)

/*++

Routine Description:

    Ensure that object selected.

Arguments:

    pListCtrl - list control.
    bSetFocus - true if focus to be set focus as well.

Return Values:

    None.

--*/

{
    VALIDATE_OBJECT(pListCtrl, CListCtrl);

    if (!IsItemSelectedInList(pListCtrl) && pListCtrl->GetItemCount())
    {
        pListCtrl->SendMessage(WM_KEYDOWN, VK_RIGHT); // HACKHACK...

        int iItem = pListCtrl->GetNextItem(-1, LVNI_FOCUSED|LVNI_ALL);
        int nState = bSetFocus ? (LVIS_SELECTED|LVIS_FOCUSED) : LVIS_SELECTED;

        VERIFY(pListCtrl->SetItemState((iItem == -1) ? 0 : iItem, nState, nState));
    }
}


#ifdef _DEBUG

void LvDumpObArray(CListCtrl* pListCtrl)

/*++

Routine Description:

    Release objects inserted into list view.

Arguments:

    pListCtrl - list control.

Return Values:

    None.

--*/

{
    VALIDATE_OBJECT(pListCtrl, CListCtrl);

    LV_ITEM lvItem;

    CString strDump;
    CCmdTarget* pObject;

    lvItem.mask = LVIF_STATE|LVIF_PARAM;
    lvItem.stateMask = (DWORD)-1;
    lvItem.iSubItem = 0;

    int nObjectsInList = pListCtrl->GetItemCount();

    pListCtrl->SetRedraw(FALSE); // turn off drawing...

    while (nObjectsInList--)
    {
        lvItem.iItem = nObjectsInList;

        VERIFY(pListCtrl->GetItem(&lvItem));

        pObject = (CCmdTarget*)lvItem.lParam;
        VALIDATE_OBJECT(pObject, CCmdTarget);

        strDump.Format(_T("iItem %d"), lvItem.iItem);
        strDump += (lvItem.state & LVIS_CUT)      ? _T(" LVIS_CUT ")      : _T("");
        strDump += (lvItem.state & LVIS_FOCUSED)  ? _T(" LVIS_FOCUSED ")  : _T("");
        strDump += (lvItem.state & LVIS_SELECTED) ? _T(" LVIS_SELECTED ") : _T("");
        strDump += _T("\r\n");

        afxDump << strDump;
    }

    pListCtrl->SetRedraw(TRUE); // turn on drawing...
}

#endif


//
// Tree view utilities
//


LPVOID TvGetSelObj(CTreeCtrl* pTreeCtrl)

/*++

Routine Description:

    Retrieves the object selected from treeview.

Arguments:

    pTreeCtrl - tree control.

Return Values:

    Returns object pointer or null.

--*/

{
    VALIDATE_OBJECT(pTreeCtrl, CTreeCtrl);

    TV_ITEM tvItem;

    if (tvItem.hItem = pTreeCtrl->GetSelectedItem())
    {
        tvItem.mask = TVIF_PARAM;

        VERIFY(pTreeCtrl->GetItem(&tvItem));
        return (LPVOID)tvItem.lParam;
    }

    return NULL;
}


BOOL
TvInsertObArray(
    CTreeCtrl* pTreeCtrl,
    HTREEITEM  hParent,
    CObArray*  pObArray,
    BOOL       bIsContainer
    )

/*++

Routine Description:

    Insert collection into tree view.

Arguments:

    pTreeCtrl - tree control.
    hParent - parent tree item.
    pObArray - object array.
    bIsContainer - container object.

Return Values:

    VT_BOOL.

--*/

{
    VALIDATE_OBJECT(pObArray, CObArray);
    VALIDATE_OBJECT(pTreeCtrl, CTreeCtrl);

    BOOL bItemsInserted = FALSE;

    TV_ITEM         tvItem;
    TV_INSERTSTRUCT tvInsert;

    tvItem.mask = TVIF_TEXT|
                  TVIF_PARAM|
                  TVIF_IMAGE|
                  TVIF_CHILDREN|
                  TVIF_SELECTEDIMAGE;

    tvItem.pszText        = LPSTR_TEXTCALLBACK;
    tvItem.cchTextMax     = LPSTR_TEXTCALLBACK_MAX;
    tvItem.iImage         = I_IMAGECALLBACK;
    tvItem.iSelectedImage = I_IMAGECALLBACK;
    tvItem.cChildren      = bIsContainer;

    tvInsert.hInsertAfter = (HTREEITEM)TVI_LAST;
    tvInsert.hParent      = (HTREEITEM)hParent;

    int iItem;
    INT_PTR nItems = pObArray->GetSize();

    HTREEITEM hNewItem = (HTREEITEM)-1; // init for loop...

    pTreeCtrl->SetRedraw(FALSE); // turn off drawing...

    CCmdTarget* pObject = NULL;

    for (iItem = 0; hNewItem && (iItem < nItems); iItem++)
    {
        pObject = (CCmdTarget*)pObArray->GetAt(iItem);
        VALIDATE_OBJECT(pObject, CCmdTarget);

        pObject->InternalAddRef();  // add ref...

        tvItem.lParam = (LPARAM)(LPVOID)pObject;
        tvInsert.item = tvItem;

        hNewItem = pTreeCtrl->InsertItem(&tvInsert);
    }

    if (hNewItem && (iItem == nItems))
    {
        bItemsInserted = TRUE;
    }
    else
    {
        LlsSetLastStatus(STATUS_NO_MEMORY);
    }

    pTreeCtrl->SetRedraw(TRUE); // turn on drawing...

    return bItemsInserted;
}


BOOL
TvRefreshObArray(
    CTreeCtrl*        pTreeCtrl,
    HTREEITEM         hParent,
    CObArray*         pObArray,
    TV_EXPANDED_INFO* pExpandedInfo,
    BOOL              bIsContainer
    )

/*++

Routine Description:

    Refresh objects in tree view.

Arguments:

    pTreeCtrl - tree control.
    hParent - parent tree item.
    pObArray - object array.
    pExpandedInfo - refresh information.
    bIsContainer - container object.

Return Values:

    Returns true if successful.

--*/

{
    ASSERT(pExpandedInfo);
    VALIDATE_OBJECT(pObArray, CObArray);
    VALIDATE_OBJECT(pTreeCtrl, CTreeCtrl);

    pExpandedInfo->nExpandedItems = 0; // initialize...
    pExpandedInfo->pExpandedItems = NULL;

    LONG_PTR nObjects = pObArray->GetSize();
    long nObjectsInTree = TvSizeObArray(pTreeCtrl, hParent);

    if (!nObjects) // tree no longer exists...
    {
        TvReleaseObArray(pTreeCtrl, hParent);
        return TRUE;
    }
    else if (!nObjectsInTree) // tree is currently empty...
    {
        return TvInsertObArray(
                pTreeCtrl,
                hParent,
                pObArray,
                bIsContainer
                );
    }

    TV_EXPANDED_ITEM* pExpandedItem = new TV_EXPANDED_ITEM[nObjectsInTree];

    if (!pExpandedItem)
    {
        LlsSetLastStatus(STATUS_NO_MEMORY);
        return FALSE;
    }

    pExpandedInfo->pExpandedItems = pExpandedItem;

    TV_ITEM tvItem;
    HTREEITEM hItem;

    BOOL bIsItemExpanded;

    CCmdTarget* pObject;
    int         iObject = 0;

    hItem = pTreeCtrl->GetChildItem(hParent);

    while (hItem)
    {
        tvItem.hItem = hItem;
        tvItem.mask  = TVIF_STATE|TVIF_PARAM;

        VERIFY(pTreeCtrl->GetItem(&tvItem));

        pObject = (CCmdTarget*)tvItem.lParam;
        VALIDATE_OBJECT(pObject, CCmdTarget);

        if (!(bIsItemExpanded = tvItem.state & TVIS_EXPANDEDONCE))
        {
            pObject->InternalRelease(); // release now...
        }
        else
        {
            pExpandedItem->hItem = tvItem.hItem;
            pExpandedItem->pObject = pObject; // don't release yet...

            pExpandedItem++;
            pExpandedInfo->nExpandedItems++;

            ASSERT(pExpandedInfo->nExpandedItems <= nObjectsInTree);
        }

        hItem = pTreeCtrl->GetNextSiblingItem(tvItem.hItem);

        if (iObject < nObjects)
        {
            pObject = (CCmdTarget*)pObArray->GetAt(iObject++);
            VALIDATE_OBJECT(pObject, CCmdTarget);

            pObject->InternalAddRef(); // add ref...

            tvItem.mask = TVIF_PARAM;
            tvItem.lParam = (LPARAM)(LPVOID)pObject;

            VERIFY(pTreeCtrl->SetItem(&tvItem)); // overwrite...
        }
        else if (bIsItemExpanded)
        {
            tvItem.mask = TVIF_PARAM;
            tvItem.lParam = (LPARAM)(LPVOID)NULL; // place holder...

            VERIFY(pTreeCtrl->SetItem(&tvItem)); // remove later...
        }
        else
        {
            VERIFY(pTreeCtrl->DeleteItem(tvItem.hItem)); // trim excess...
        }
    }

    if (iObject < nObjects)
    {
        TV_INSERTSTRUCT tvInsert;

        tvItem.mask = TVIF_TEXT|
                      TVIF_PARAM|
                      TVIF_IMAGE|
                      TVIF_CHILDREN|
                      TVIF_SELECTEDIMAGE;

        tvItem.pszText        = LPSTR_TEXTCALLBACK;
        tvItem.cchTextMax     = LPSTR_TEXTCALLBACK_MAX;
        tvItem.iImage         = I_IMAGECALLBACK;
        tvItem.iSelectedImage = I_IMAGECALLBACK;
        tvItem.cChildren      = bIsContainer;

        tvInsert.hInsertAfter = (HTREEITEM)TVI_LAST;
        tvInsert.hParent      = (HTREEITEM)hParent;

        hItem = (HTREEITEM)-1; // init for loop...

        for (; hItem && (iObject < nObjects); iObject++)
        {
            pObject = (CCmdTarget*)pObArray->GetAt(iObject);
            VALIDATE_OBJECT(pObject, CCmdTarget);

            pObject->InternalAddRef();  // AddRef each...

            tvItem.lParam = (LPARAM)(LPVOID)pObject;
            tvInsert.item = tvItem;

            hItem = pTreeCtrl->InsertItem(&tvInsert);
        }

        if (!(hItem && (iObject == nObjects)))
        {
            pExpandedItem = pExpandedInfo->pExpandedItems;

            while (pExpandedInfo->nExpandedItems--)
                (pExpandedItem++)->pObject->InternalRelease();

            delete [] pExpandedInfo->pExpandedItems;
            pExpandedInfo->pExpandedItems = NULL;

            LlsSetLastStatus(STATUS_NO_MEMORY);

            return FALSE;
        }
    }

    if (!pExpandedInfo->nExpandedItems)
    {
        delete [] pExpandedInfo->pExpandedItems;
        pExpandedInfo->pExpandedItems = NULL;
    }

    return TRUE;
}


void TvReleaseObArray(CTreeCtrl* pTreeCtrl, HTREEITEM hParent)

/*++

Routine Description:

    Release objects inserted into tree view.

Arguments:

    pTreeCtrl - tree control.
    hParent - parent tree item.

Return Values:

    None.

--*/

{
    if (!hParent)
        return; // nothing to release...

    VALIDATE_OBJECT(pTreeCtrl, CTreeCtrl);

    TV_ITEM tvItem;
    HTREEITEM hItem;

    CCmdTarget* pObject;

    tvItem.mask = TVIF_STATE|TVIF_PARAM;

    hItem = pTreeCtrl->GetChildItem(hParent);

    while (hItem)
    {
        tvItem.hItem = hItem;

        VERIFY(pTreeCtrl->GetItem(&tvItem));

        if (tvItem.state & TVIS_EXPANDEDONCE)
        {
            TvReleaseObArray(pTreeCtrl, tvItem.hItem);
        }

        hItem = pTreeCtrl->GetNextSiblingItem(tvItem.hItem);

        pObject = (CCmdTarget*)tvItem.lParam;
        VALIDATE_OBJECT(pObject, CCmdTarget);

        pObject->InternalRelease(); // release now...

        pTreeCtrl->DeleteItem(tvItem.hItem);
    }

    tvItem.hItem = hParent;
    tvItem.mask = TVIF_STATE|TVIF_PARAM;

    VERIFY(pTreeCtrl->GetItem(&tvItem));

    if (!tvItem.lParam)
    {
        pTreeCtrl->DeleteItem(hParent); // delete placeholder...
    }
    else if (tvItem.state & TVIS_EXPANDEDONCE)
    {
        tvItem.state     = 0;
        tvItem.stateMask = TVIS_EXPANDED|TVIS_EXPANDEDONCE;

        VERIFY(pTreeCtrl->SetItem(&tvItem)); // no longer expanded...
    }
}


long TvSizeObArray(CTreeCtrl* pTreeCtrl, HTREEITEM hParent)

/*++

Routine Description:

    Count objects in tree view.

Arguments:

    pTreeCtrl - tree control.
    hParent - parent tree item.

Return Values:

    None.

--*/

{
    VALIDATE_OBJECT(pTreeCtrl, CTreeCtrl);

    long nObjects = 0;

    HTREEITEM hItem = pTreeCtrl->GetChildItem(hParent);

    while (hItem)
    {
        nObjects++;
        hItem = pTreeCtrl->GetNextSiblingItem(hItem);
    }

    return nObjects;
}


void
TvSwitchItem(
    CTreeCtrl*        pTreeCtrl,
    HTREEITEM         hRandomItem,
    TV_EXPANDED_ITEM* pExpandedItem
    )

/*++

Routine Description:

    Move object from random node to previously expanded node.  If there
    is an object in the previously expanded node we move it to the random
    node to be sorted later.

Arguments:

    pTreeCtrl - tree control.
    hRandomItem - handle to random node with object of interest.
    pExpandedItem - state information.

Return Values:

    None.

--*/

{
    ASSERT(pExpandedItem);
    VALIDATE_OBJECT(pTreeCtrl, CTreeCtrl);

    CCmdTarget* pRandomObject;
    CCmdTarget* pExpandedObject;

    TV_ITEM tvRandomItem;
    TV_ITEM tvExpandedItem;

    if (hRandomItem != pExpandedItem->hItem)
    {
        tvRandomItem.hItem = hRandomItem;
        tvRandomItem.mask  = LVIF_PARAM;

        tvExpandedItem.hItem = pExpandedItem->hItem;
        tvExpandedItem.mask  = LVIF_PARAM;

        VERIFY(pTreeCtrl->GetItem(&tvRandomItem));

        pExpandedObject = (CCmdTarget*)tvRandomItem.lParam;
        VALIDATE_OBJECT(pExpandedObject, CCmdTarget);

        VERIFY(pTreeCtrl->GetItem(&tvExpandedItem));

        pRandomObject = (CCmdTarget*)tvExpandedItem.lParam; // could be null...

        if (pRandomObject)
        {
            VALIDATE_OBJECT(pRandomObject, CCmdTarget);
            tvRandomItem.lParam = (LPARAM)(LPVOID)pRandomObject;

            VERIFY(pTreeCtrl->SetItem(&tvRandomItem)); // switch position...
        }
        else
        {
            VERIFY(pTreeCtrl->DeleteItem(tvRandomItem.hItem));  // delete placeholder...
        }

        tvExpandedItem.lParam = (LPARAM)(LPVOID)pExpandedObject;
        VERIFY(pTreeCtrl->SetItem(&tvExpandedItem));
    }
}


HTREEITEM TvGetDomain(CTreeCtrl* pTreeCtrl, HTREEITEM hParent, CCmdTarget* pObject)

/*++

Routine Description:

    Find domain in tree view.

Arguments:

    pTreeCtrl - tree control.
    hParent - parent tree item.
    pObject - object to find.

Return Values:

    Handle of located object.

--*/

{
    VALIDATE_OBJECT(pObject, CDomain);
    VALIDATE_OBJECT(pTreeCtrl, CTreeCtrl);

    CDomain* pDomain;

    TV_ITEM tvItem;

    tvItem.mask = TVIF_PARAM;
    tvItem.hItem = pTreeCtrl->GetChildItem(hParent);

    while (tvItem.hItem)
    {
        VERIFY(pTreeCtrl->GetItem(&tvItem));

        pDomain = (CDomain*)tvItem.lParam; // can be NULL if placeholder...

        if ( NULL != pDomain )
        {
            VALIDATE_OBJECT(pDomain, CDomain);

            if (!((CDomain*)pObject)->m_strName.CompareNoCase(pDomain->m_strName))
            {
                return tvItem.hItem;   // found it...
            }
        }

        tvItem.hItem = pTreeCtrl->GetNextSiblingItem(tvItem.hItem);
    }

    return NULL;
}


HTREEITEM TvGetServer(CTreeCtrl* pTreeCtrl, HTREEITEM hParent, CCmdTarget* pObject)

/*++

Routine Description:

    Find server in tree view.

Arguments:

    pTreeCtrl - tree control.
    hParent - parent tree item.
    pObject - object to find.

Return Values:

    Handle of located object.

--*/

{
    VALIDATE_OBJECT(pObject, CServer);
    VALIDATE_OBJECT(pTreeCtrl, CTreeCtrl);

    CServer* pServer;

    TV_ITEM tvItem;

    tvItem.mask = TVIF_PARAM;
    tvItem.hItem = pTreeCtrl->GetChildItem(hParent);

    while (tvItem.hItem)
    {
        VERIFY(pTreeCtrl->GetItem(&tvItem));

        pServer = (CServer*)tvItem.lParam;
        VALIDATE_OBJECT(pServer, CServer);

        if (!((CServer*)pObject)->m_strName.CompareNoCase(pServer->m_strName))
        {
            return tvItem.hItem;   // found it...
        }

        tvItem.hItem = pTreeCtrl->GetNextSiblingItem(tvItem.hItem);
    }

    return NULL;
}


HTREEITEM TvGetService(CTreeCtrl* pTreeCtrl, HTREEITEM hParent, CCmdTarget* pObject)

/*++

Routine Description:

    Find service in tree view.

Arguments:

    pTreeCtrl - tree control.
    hParent - parent tree item.
    pObject - object to find.

Return Values:

    Handle of located object.

--*/

{
    VALIDATE_OBJECT(pObject, CService);
    VALIDATE_OBJECT(pTreeCtrl, CTreeCtrl);

    CService* pService;

    TV_ITEM tvItem;

    tvItem.mask = TVIF_PARAM;
    tvItem.hItem = pTreeCtrl->GetChildItem(hParent);

    while (tvItem.hItem)
    {
        VERIFY(pTreeCtrl->GetItem(&tvItem));

        pService = (CService*)tvItem.lParam;
        VALIDATE_OBJECT(pService, CService);

        if (!((CService*)pObject)->m_strName.CompareNoCase(pService->m_strName))
        {
            return tvItem.hItem;   // found it...
        }

        tvItem.hItem = pTreeCtrl->GetNextSiblingItem(tvItem.hItem);
    }

    return NULL;
}


//
// Tab control utilities
//

void TcInitTabs(CTabCtrl* pTabCtrl, PTC_TAB_INFO ptcTabInfo)

/*++

Routine Description:

    Initializes tab items.

Arguments:

    pTabCtrl - tab control.
    ptcTabInfo - tab information.

Return Values:

    None.

--*/

{
    ASSERT(ptcTabInfo);
    VALIDATE_OBJECT(pTabCtrl, CTabCtrl);

    CString strText;
    TC_ITEM tcItem;

    int nTabs = ptcTabInfo->nTabs;
    PTC_TAB_ENTRY ptcTabEntry = ptcTabInfo->tcTabEntry;

    tcItem.mask = TCIF_TEXT;

    while (nTabs--)
    {
        strText.LoadString(ptcTabEntry->nStringId);
        tcItem.pszText = MKSTR(strText);

        pTabCtrl->InsertItem(ptcTabEntry->iItem, &tcItem);
        ptcTabEntry++;
    }

    SetDefaultFont(pTabCtrl);
}


//
// Miscellaneous utilities
//

#define NUMBER_OF_SECONDS_IN_MINUTE (60)
#define NUMBER_OF_SECONDS_IN_DAY    (60 * 60 * 24)

double SecondsSince1980ToDate(DWORD sysSeconds)

/*++

Routine Description:

    Converts time format to OLE-compliant.

Arguments:

    hParent - parent item.
    pDomains - domain collection.

Return Values:

    None.

--*/

{
    WORD dosDate = 0;
    WORD dosTime = 0;
    double dateTime = 0;

    FILETIME fileTime;
    LARGE_INTEGER locTime;

    DWORD locDays;
    DWORD locSeconds;
    TIME_ZONE_INFORMATION tzi;

    GetTimeZoneInformation(&tzi);
    locSeconds = sysSeconds - (tzi.Bias * NUMBER_OF_SECONDS_IN_MINUTE);

    locDays = locSeconds / NUMBER_OF_SECONDS_IN_DAY;    // round off to days
    locSeconds = locDays * NUMBER_OF_SECONDS_IN_DAY;    // for displaying time...

    RtlSecondsSince1980ToTime(locSeconds, &locTime);

    fileTime.dwLowDateTime  = locTime.LowPart;
    fileTime.dwHighDateTime = locTime.HighPart;

    // JonN 5/15/00 PREFIX 112121
    // ignore error returns here
    (void)FileTimeToDosDateTime(&fileTime, &dosDate, &dosTime);
    (void)DosDateTimeToVariantTime(dosDate, dosTime, &dateTime);

    return dateTime;
}


void SetDefaultFont(CWnd* pWnd)

/*++

Routine Description:

    Set default font.

Arguments:

    pWnd - window to change font.

Return Values:

    None.

--*/

{
    VALIDATE_OBJECT(pWnd, CWnd);

    HFONT hFont;
    LOGFONT lFont;

    memset(&lFont, 0, sizeof(LOGFONT));     // initialize

    lFont.lfHeight      = -12;
    lFont.lfWeight      = FW_NORMAL;        // normal
    CHARSETINFO csi;
    DWORD dw = ::GetACP();

    if (!::TranslateCharsetInfo((DWORD*)UintToPtr(dw), &csi, TCI_SRCCODEPAGE))
        csi.ciCharset = ANSI_CHARSET;
    lFont.lfCharSet = (BYTE)csi.ciCharset;

    ::lstrcpy(lFont.lfFaceName, TEXT("MS Shell Dlg"));

    hFont = ::CreateFontIndirect(&lFont);
    pWnd->SetFont(CFont::FromHandle(hFont));
}


void SafeEnableWindow(CWnd* pEnableWnd, CWnd* pNewFocusWnd, CWnd* pOldFocusWnd, BOOL bEnableWnd)

/*++

Routine Description:

    Enable/disable window without losing focus.

Arguments:

    pEnableWnd - window to enable/disable.
    bEnableWnd - true if window to be enabled.
    pOldFocusWnd - window with current focus.
    pNewFocusWnd - window to receive focus.

Return Values:

    None.

--*/

{
    VALIDATE_OBJECT(pEnableWnd, CWnd);
    VALIDATE_OBJECT(pNewFocusWnd, CWnd);

    if (bEnableWnd)
    {
        pEnableWnd->EnableWindow(TRUE);
    }
    else if (pOldFocusWnd == pEnableWnd)
    {
        ASSERT(pNewFocusWnd->IsWindowEnabled());
        pNewFocusWnd->SetFocus();

        pEnableWnd->EnableWindow(FALSE);
    }
    else
    {
        pEnableWnd->EnableWindow(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\utils.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    utils.h

Abstract:

    Utilities.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 16-Jan-1996
        Added new element to LV_COLUMN_ENTRY to differentiate the string
        used for the column header from the string used in the menus
        (so that the menu option can contain hot keys).

--*/

#ifndef _UTILS_H_
#define _UTILS_H_

#define LPSTR_TEXTCALLBACK_MAX  260 

//
// List view utilities
//

#define LVID_SEPARATOR          0   
#define LVID_UNSORTED_LIST     -1

typedef struct _LV_COLUMN_ENTRY {

    int iSubItem;                   // column index
    int nStringId;                  // header string id 
    int nMenuStringId;              // menu option string id
    int nRelativeWidth;             // header width 

} LV_COLUMN_ENTRY, *PLV_COLUMN_ENTRY;

#pragma warning(disable:4200)
typedef struct _LV_COLUMN_INFO {

    BOOL bSortOrder;                // sort order (ascending false)
    int  nSortedItem;               // column sorted (default none)

    int nColumns;
    LV_COLUMN_ENTRY lvColumnEntry[];

} LV_COLUMN_INFO, *PLV_COLUMN_INFO;
#pragma warning(default:4200)

void LvInitColumns(CListCtrl* pListCtrl, PLV_COLUMN_INFO plvColumnInfo);
void LvResizeColumns(CListCtrl* pListCtrl, PLV_COLUMN_INFO plvColumnInfo);
void LvChangeFormat(CListCtrl* pListCtrl, UINT nFormatId);

LPVOID LvGetSelObj(CListCtrl* pListCtrl);
LPVOID LvGetNextObj(CListCtrl* pListCtrl, LPINT piItem, int nType = LVNI_ALL|LVNI_SELECTED);
void LvSelObjIfNecessary(CListCtrl* pListCtrl, BOOL bSetFocus = FALSE);

BOOL LvInsertObArray(CListCtrl* pListCtrl, PLV_COLUMN_INFO plvColumnInfo, CObArray* pObArray);
BOOL LvRefreshObArray(CListCtrl* pListCtrl, PLV_COLUMN_INFO plvColumnInfo, CObArray* pObArray);
void LvReleaseObArray(CListCtrl* pListCtrl);
void LvReleaseSelObjs(CListCtrl* pListCtrl);

#ifdef _DEBUG
void LvDumpObArray(CListCtrl* pListCtrl);
#endif

//
// Tree view utilites
//

typedef struct _TV_EXPANDED_ITEM {

    HTREEITEM   hItem;
    CCmdTarget* pObject;

} TV_EXPANDED_ITEM, *PTV_EXPANDED_ITEM;

typedef struct _TV_EXPANDED_INFO {

    int               nExpandedItems;
    TV_EXPANDED_ITEM* pExpandedItems;

} TV_EXPANDED_INFO, *PTV_EXPANDED_INFO;

LPVOID TvGetSelObj(CTreeCtrl* pTreeCtrl);

BOOL TvInsertObArray(CTreeCtrl* pTreeCtrl, HTREEITEM hParent, CObArray* pObArray, BOOL bIsContainer = TRUE);
BOOL TvRefreshObArray(CTreeCtrl* pTreeCtrl, HTREEITEM hParent, CObArray* pObArray, TV_EXPANDED_INFO* pExpandedInfo, BOOL bIsContainer = TRUE);
void TvReleaseObArray(CTreeCtrl* pTreeCtrl, HTREEITEM hParent);
long TvSizeObArray(CTreeCtrl* pTreeCtrl, HTREEITEM hParent);
HTREEITEM TvGetDomain(CTreeCtrl* pTreeCtrl, HTREEITEM hParent, CCmdTarget* pObject);
HTREEITEM TvGetServer(CTreeCtrl* pTreeCtrl, HTREEITEM hParent, CCmdTarget* pObject);
HTREEITEM TvGetService(CTreeCtrl* pTreeCtrl, HTREEITEM hParent, CCmdTarget* pObject);
void TvSwitchItem(CTreeCtrl* pTreeCtrl, HTREEITEM hItem, TV_EXPANDED_ITEM* pExpandedItem);

//
// Tab control utilities
//

#define TCE_LISTVIEW                0x10000000
#define TCE_TREEVIEW                0x20000000
#define TCE_MASK_CONTROL            0xF0000000

#define IsListView(pte)             ((pte)->dwFlags & TCE_LISTVIEW)
#define IsTreeView(pte)             ((pte)->dwFlags & TCE_TREEVIEW)

#define IsItemSelectedInList(plv)   (::LvGetSelObj((CListCtrl*)(plv)) != NULL)
#define IsItemSelectedInTree(ptv)   (::TvGetSelObj((CTreeCtrl*)(ptv)) != NULL)

#define IsItemSelected(pte)         ((IsListView(pte)) ? (IsItemSelectedInList((pte)->pWnd)) : (IsItemSelectedInTree((pte)->pWnd)))

#define TCE_FORMAT_LARGE_ICONS      0x01000000
#define TCE_FORMAT_SMALL_ICONS      0x02000000
#define TCE_FORMAT_LIST             0x04000000
#define TCE_FORMAT_REPORT           0x08000000
#define TCE_MASK_FORMAT             0x0F000000

#define IsFormatLargeIcons(pte)     ((pte)->dwFlags & TCE_FORMAT_LARGE_ICONS)
#define IsFormatSmallIcons(pte)     ((pte)->dwFlags & TCE_FORMAT_SMALL_ICONS) 
#define IsFormatList(pte)           ((pte)->dwFlags & TCE_FORMAT_LIST)        
#define IsFormatReport(pte)         ((pte)->dwFlags & TCE_FORMAT_REPORT)     

#define SetFormatLargeIcons(pte)    {(pte)->dwFlags = ((pte)->dwFlags & ~TCE_MASK_FORMAT) | TCE_FORMAT_LARGE_ICONS;}
#define SetFormatSmallIcons(pte)    {(pte)->dwFlags = ((pte)->dwFlags & ~TCE_MASK_FORMAT) | TCE_FORMAT_SMALL_ICONS;}
#define SetFormatList(pte)          {(pte)->dwFlags = ((pte)->dwFlags & ~TCE_MASK_FORMAT) | TCE_FORMAT_LIST;}       
#define SetFormatReport(pte)        {(pte)->dwFlags = ((pte)->dwFlags & ~TCE_MASK_FORMAT) | TCE_FORMAT_REPORT;}    
                                                                           
#define TCE_SUPPORTS_FORMAT         0x00010000
#define TCE_SUPPORTS_DELETE         0x00020000
#define TCE_SUPPORTS_EDIT           0x00040000
#define TCE_SUPPORTS_SORT           0x00080000
#define TCE_SUPPORTS_ALL            0x00FF0000
#define TCE_MASK_OPTIONS            0x00FF0000

#define IsFormatSupported(pte)      ((pte)->dwFlags & TCE_SUPPORTS_FORMAT)
#define IsDeleteSupported(pte)      ((pte)->dwFlags & TCE_SUPPORTS_DELETE) 
#define IsEditSupported(pte)        ((pte)->dwFlags & TCE_SUPPORTS_EDIT)   
#define IsSortSupported(pte)        ((pte)->dwFlags & TCE_SUPPORTS_SORT)   

#define TCE_STATUS_TAB_UPDATED      0x00000001
#define TCE_STATUS_TAB_IN_FOCUS     0x00000002
#define TCE_MASK_STATUS             0x0000FFFF

#define IsTabUpdated(pte)           ((pte)->dwFlags & TCE_STATUS_TAB_UPDATED)
#define IsTabInFocus(pte)           ((pte)->dwFlags & TCE_STATUS_TAB_IN_FOCUS)

#define SetTabUpdated(pte)          {(pte)->dwFlags = ((pte)->dwFlags & ~TCE_MASK_STATUS) | TCE_STATUS_TAB_UPDATED;}
#define SetTabInFocus(pte)          {(pte)->dwFlags = ((pte)->dwFlags & ~TCE_MASK_STATUS) | TCE_STATUS_TAB_IN_FOCUS;}
#define ClrTabUpdated(pte)          {(pte)->dwFlags &= ~TCE_STATUS_TAB_UPDATED;}
#define ClrTabInFocus(pte)          {(pte)->dwFlags &= ~TCE_STATUS_TAB_IN_FOCUS;}
                                
#define UPDATE_INFO_LICENSES        0x00000001    
#define UPDATE_INFO_PRODUCTS        0x00000002
#define UPDATE_INFO_GROUPS          0x00000004
#define UPDATE_INFO_USERS           0x00000008
#define UPDATE_INFO_SERVERS         0x00000010
#define UPDATE_INFO_SERVICES        0x00000020

#define UPDATE_INFO_ALL             0x000000FF
#define UPDATE_INFO_NONE            0x00000000
#define UPDATE_INFO_ABORT           0x80000000
#define UPDATE_INFO_CLIENTS         (UPDATE_INFO_USERS | UPDATE_INFO_GROUPS)

#define IsUpdateAborted(flg)        ((DWORD)(flg) & UPDATE_INFO_ABORT)
#define IsLicenseInfoUpdated(flg)   ((DWORD)(flg) & UPDATE_INFO_LICENSES)  
#define IsProductInfoUpdated(flg)   ((DWORD)(flg) & UPDATE_INFO_PRODUCTS)  
#define IsGroupInfoUpdated(flg)     ((DWORD)(flg) & UPDATE_INFO_GROUPS)    
#define IsUserInfoUpdated(flg)      ((DWORD)(flg) & UPDATE_INFO_USERS)     
#define IsServerInfoUpdated(flg)    ((DWORD)(flg) & UPDATE_INFO_SERVERS)   
#define IsServiceInfoUpdated(flg)   ((DWORD)(flg) & UPDATE_INFO_SERVICES)  

#define UPDATE_MAIN_TABS            (UPDATE_INFO_CLIENTS | UPDATE_INFO_PRODUCTS | UPDATE_INFO_LICENSES) 
#define UPDATE_BROWSER_TAB          (UPDATE_INFO_SERVERS)

#define UPDATE_DOMAIN_SELECTED      (UPDATE_INFO_ALL)
#define UPDATE_LICENSE_ADDED        (UPDATE_INFO_CLIENTS | UPDATE_INFO_PRODUCTS | UPDATE_INFO_LICENSES) 
#define UPDATE_LICENSE_DELETED      (UPDATE_INFO_CLIENTS | UPDATE_INFO_PRODUCTS | UPDATE_INFO_LICENSES)
#define UPDATE_LICENSE_REVOKED      (UPDATE_INFO_CLIENTS | UPDATE_INFO_PRODUCTS)
#define UPDATE_LICENSE_UPGRADED     (UPDATE_INFO_CLIENTS | UPDATE_INFO_PRODUCTS)
#define UPDATE_LICENSE_MODE         (UPDATE_INFO_SERVICES| UPDATE_INFO_PRODUCTS)
#define UPDATE_GROUP_ADDED          (UPDATE_INFO_CLIENTS | UPDATE_INFO_PRODUCTS)
#define UPDATE_GROUP_DELETED        (UPDATE_INFO_CLIENTS | UPDATE_INFO_PRODUCTS)
#define UPDATE_GROUP_ALTERED        (UPDATE_INFO_CLIENTS | UPDATE_INFO_PRODUCTS)

typedef struct _TC_TAB_ENTRY {

    int             iItem;
    int             nStringId;
    DWORD           dwFlags;
    CWnd*           pWnd;
    PLV_COLUMN_INFO plvColumnInfo;  // only valid for listview...

} TC_TAB_ENTRY, *PTC_TAB_ENTRY;

#pragma warning(disable:4200)
typedef struct _TC_TAB_INFO {

    int nTabs;
    TC_TAB_ENTRY tcTabEntry[];

} TC_TAB_INFO, *PTC_TAB_INFO;
#pragma warning(default:4200)

void TcInitTabs(CTabCtrl* pTabCtrl, PTC_TAB_INFO ptcTabInfo);

//
// Other stuff...
//

void SetDefaultFont(CWnd* pWnd);
void SafeEnableWindow(CWnd* pEnableWnd, CWnd* pNewFocusWnd, CWnd* pOldFocusWnd, BOOL bEnableWnd);
double SecondsSince1980ToDate(unsigned long dwSeconds);

#ifdef _DEBUG
#define VALIDATE_OBJECT(pOb, ObClass) \
    { ASSERT_VALID((pOb)); ASSERT((pOb)->IsKindOf(RUNTIME_CLASS(ObClass))); }
#else
#define VALIDATE_OBJECT(pOb, ObClass)
#endif

#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\usrpsht.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    usrpsht.h

Abstract:

    User property sheet implementation.

Author:

    Don Ryan (donryan) 05-Feb-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _USRPSHT_H_
#define _USRPSHT_H_

#include "usrppgp.h"

class CUserPropertySheet : public CPropertySheet
{
    DECLARE_DYNAMIC(CUserPropertySheet)
private:
    CUserPropertyPageProducts m_productsPage;   

public:
    DWORD m_fUpdateHint;

public:
    CUserPropertySheet(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
    CUserPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
    virtual ~CUserPropertySheet();

    void InitPages(CUser* pUser, BOOL bProperties = TRUE);

    //{{AFX_VIRTUAL(CUserPropertySheet)
    //}}AFX_VIRTUAL

protected:
    //{{AFX_MSG(CUserPropertySheet)
    afx_msg void OnHelp();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _USRPSHT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\inc\debug.h ===
/*******************************************************************/
/*	      Copyright(c)  1992 Microsoft Corporation		   */
/*******************************************************************/


//***
//
// Filename:	debug.h
//
// Description: This module debug definitions for the supervisor module.
//
// Author:	Narendra Gidwani (nareng)    May 22, 1992.
//
// Revision History:
//
//***



#ifndef _DEBUG_
#define _DEBUG_

extern  HANDLE  hLogFile ;

#if DBG

VOID
DbgPrintf(
	char *Format,
    ...
);

int  DbgPrint( char * format, ... );

#define DBGPRINT(args) DbgPrint args

#else

#define DBGPRINT(args)

#endif

#endif // _DEBUG_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\inc\prtdefs.h ===
//
// Copyright(c) Microsoft Corp., 1993
//
//
// prtdefs.h - common defines between print spooler and print monitor
//

// Do not put out ^D as part of the header. Do support old style as well
#define	FILTERCONTROL_OLD	"%!PS-Adobe-3.0\r\n\04\r\n%% LanMan: Filter turned off\r\n"
#define	FILTERCONTROL		"%!PS-Adobe-3.0\r\n%Windows NT MacPrint Server\r\n"
#define	SIZE_FC				sizeof(FILTERCONTROL) - 1
#define	SIZE_FCOLD			sizeof(FILTERCONTROL_OLD) - 1

#define	LFILTERCONTROL		L"job=sfm"
#define	LSIZE_FC			((sizeof(LFILTERCONTROL)/sizeof(WCHAR)) - 1)


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\monitor\atalkmon.h ===
/*****
	AppleTalk Print Monitor

	(c) Microsoft 1992, all rights reserved

	FILE NAME:	  atalkmon.h

	DESCRIPTION:	This is the interface to the main module for
		the AppleTalk Print Monitor.

	AUTHOR:		 Frank D. Byrum

	MODIFICATION HISTORY:

		date	who	 description

	26-Aug-92	frankb  Initial version
*****/

#define APPLETALK_SERVICE_NAME	  TEXT("AppleTalk")


/*****  REGISTRY USAGE

	AppleTalk port information is kept in the registry using the
	registry API of Win32.  The monitor is installed by creating
	a registry key, "AppleTalk Printers" at

	HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Print\Monitors

	This key is refered to as the AppleTalk Monitor root key.  Two
	subkey of this root key are created.  "Options" contains registry
	values for configuration options for the monitor on a global
	scale, and "Ports" contains subkeys for each AppleTalk printer
	defined.

	The name of the port subkey is the port name for the printer
	as viewed in the NT Print Manager port list.  This key contains
	a number of values describing the port, including:

	REG_DWORD: TimeOut	  Number of miliseconds to wait for writes to
							the printer to complete

	REG_DWORD: ConfigFlags  Set of flags describing configuration of the
							port.  Currently only includes the flag
							indicating the printer is captured.

	REG_BINARY: NBP Name	NBP name of the printer as an NBP_NAME structure

	The "Options" subkey contains a number of registry values, including:

	REG_DWORD: DebugLevel
	REG_DWORD: DebugSystems
	REG_SZ: LogFile

*****/

#define PRINTER_ENUM_BUFFER_SIZE	1024
#define GENERIC_BUFFER_SIZE			512
#define STATUS_BUFFER_SIZE			100

//
//  registry keys
//

#define ATALKMON_PORTS_SUBKEY		TEXT("\\Ports")
#define ATALKMON_OPTIONS_SUBKEY		TEXT("Options")

//
// registry value names
//

#define ATALKMON_CONFIGFLAGS_VALUE	"Configuration Flags"
#define ATALKMON_ZONENAME_VALUE		"Zone Name"
#define ATALKMON_PORTNAME_VALUE		"Port Name"
#define	ATALKMON_PORT_CAPTURED		"Port Captured"

#define ATALKMON_FILTER_VALUE		TEXT("Filter")
#define ATALKMON_LOGFILE_VALUE		TEXT("LogFile")

//
// config flags
//

#define SFM_PORT_CAPTURED 			0x00000001
#define SFM_PORT_IN_USE				0x00000002
#define SFM_PORT_POST_READ 			0x00000004
#define SFM_PORT_OPEN 				0x00000008
#define SFM_PORT_CLOSE_PENDING 		0x00000010
#define SFM_PORT_IS_SPOOLER 		0x00000020


//
// job flags
//

#define SFM_JOB_FIRST_WRITE			0x00000001
#define SFM_JOB_FILTER				0x00000002
#define SFM_JOB_DISCONNECTED		0x00000004
#define SFM_JOB_OPEN_PENDING		0x00000008
#define SFM_JOB_ERROR				0x00000010

//
// Various timeout values.
//
#define ATALKMON_DEFAULT_TIMEOUT	 5000
#define ATALKMON_DEFAULT_TIMEOUT_SEC 5
#define CONFIG_TIMEOUT				 (5*60*1000)

//
// filter characters
//

#define CTRL_C						0x03
#define CTRL_D						0x04
#define CTRL_S						0x13
#define CTRL_Q						0x11
#define CTRL_T						0x14
#define CR							0x0d

//
// postscript commands to instruct the printer to ignore ctrl-c (\0x003), ctrl-d (\004),
// ctrl-q (\021), ctrl-s (\023), ctrl-t (\024) and escape (\033) characters.
// The last part (/@PJL { currentfile .... bind def) is dual-mode printer specific stuff:
// it tells it to ignore anything starting with /@PJL.  This last part is based on the
// assumption that no postscript implementation ever uses anything starting with @PJL as
// a valid command - it's a pretty safe assumption, but something to remember.
//
#define PS_HEADER		"(\033) cvn {} def\r\n/@PJL { currentfile 256 string readline pop pop } bind def\r\n"
#define	SIZE_PS_HEADER	(sizeof(PS_HEADER) - 1)

#define PJL_ENDING_COMMAND      "\033%-12345X@PJL EOJ\n\033%-12345X"
#define PJL_ENDING_COMMAND_LEN  (sizeof(PJL_ENDING_COMMAND) - 1)

//
// NBP types
//

#define ATALKMON_RELEASED_TYPE		"LaserWriter"

#define ATALKMON_CAPTURED_TYPE		" LaserWriter"

#define PAP_QUANTUM_SIZE			512
#define PAP_DEFAULT_QUANTUM			8
#define PAP_DEFAULT_BUFFER			(PAP_DEFAULT_QUANTUM*PAP_QUANTUM_SIZE)


//
// Data structures used.
//

typedef struct _ATALKPORT
{
	struct _ATALKPORT *	pNext;
	
	// Get/Set is protected by hmutexPortList.
	DWORD				fPortFlags;		

	// These flags do not need mutual exclusion since only the current
	// job will look at them. There will be no contention.
	DWORD				fJobFlags;	

	HANDLE				hmutexPort;
	HANDLE				hPrinter;
	DWORD				dwJobId;
	SOCKET				sockQuery;
	SOCKET				sockIo;
	SOCKET				sockStatus;
	WSH_NBP_NAME		nbpPortName;
	WSH_ATALK_ADDRESS	wshatPrinterAddress;
        DWORD                           OnlyOneByteAsCtrlD;
	WCHAR				pPortName[(MAX_ENTITY+1)*2];
	UCHAR				pReadBuffer[PAP_DEFAULT_BUFFER];
} ATALKPORT;

typedef ATALKPORT * PATALKPORT;
typedef SOCKET * PSOCKET;

typedef struct _TOKENLIST
{
	LPSTR				pszToken;
	DWORD				dwError;
	DWORD				dwStatus;
} TOKENLIST, *PTOKENLIST;


//
//*****  GLOBAL VARIABLES
//

#ifdef ALLOCATE

HANDLE	  		hInst;
HKEY			hkeyPorts 		= NULL;
HANDLE			hmutexPortList 	= NULL;
HANDLE			hmutexDeleteList= NULL;
HANDLE			hmutexBlt       = NULL;
HANDLE			hmutexJob 		= NULL;
PATALKPORT		pPortList		= NULL;		
PATALKPORT		pDeleteList		= NULL;		
HANDLE			hEventLog 		= NULL;
HANDLE			hevConfigChange = NULL;
HANDLE			hevPrimeRead 	= NULL;
HANDLE			hCapturePrinterThread 	= INVALID_HANDLE_VALUE;
HANDLE			hReadThread 	= INVALID_HANDLE_VALUE;
BOOL			boolExitThread 	= FALSE, Filter = TRUE;
CHAR		 	chComputerName[MAX_ENTITY+1];
WCHAR			wchBusy[STATUS_BUFFER_SIZE];
WCHAR			wchPrinting[STATUS_BUFFER_SIZE];
WCHAR			wchPrinterError[STATUS_BUFFER_SIZE];
WCHAR			wchPrinterOffline[STATUS_BUFFER_SIZE];
WCHAR			wchDllName[STATUS_BUFFER_SIZE];
WCHAR			wchPortDescription[STATUS_BUFFER_SIZE];

#ifdef DEBUG_MONITOR

HANDLE			hLogFile = INVALID_HANDLE_VALUE	;

#endif

#else

extern HANDLE	hInst;
extern HKEY		hkeyPorts;
extern HANDLE	hmutexPortList;
extern HANDLE	hmutexDeleteList;
extern HANDLE	hmutexBlt;
extern HANDLE	hmutexJob; 		
extern PATALKPORT pPortList;
extern PATALKPORT pDeleteList;
extern HANDLE	hEventLog;
extern HANDLE	hevConfigChange;
extern HANDLE	hevPrimeRead;
extern HANDLE	hCapturePrinterThread;
extern HANDLE	hReadThread;
extern BOOL		boolExitThread, Filter;
extern CHAR		chComputerName[];
extern WCHAR	wchBusy[];
extern WCHAR	wchPrinting[];
extern WCHAR	wchPrinterError[];
extern WCHAR	wchPrinterOffline[];
extern WCHAR	wchDllName[];
extern WCHAR	wchPortDescription[];

#ifdef DEBUG_MONITOR

extern  HANDLE  hLogFile;

#endif

#endif

#ifdef DEBUG_MONITOR

VOID
DbgPrintf(
	char *Format,
	...
	);

#define DBGPRINT(args) DbgPrintf args

#else

#define DBGPRINT(args)

#endif


//***** FUNCTION PROTOTYPES

DWORD
CapturePrinterThread(
	IN LPVOID pParameterBlock
);

DWORD
ReadThread(
	IN LPVOID pParameterBlock
);

DWORD
CaptureAtalkPrinter(
	IN SOCKET sock,
	IN PWSH_ATALK_ADDRESS pAddress,
	IN BOOL fCapture
);

DWORD
TransactPrinter(
	IN SOCKET sock,
	IN PWSH_ATALK_ADDRESS pAddress,
	IN LPBYTE pRequest,
	IN DWORD cbRequest,
	IN LPBYTE pResponse,
	IN DWORD  cbResponse
);

VOID
ParseAndSetPrinterStatus(
	IN PATALKPORT pPort
);

DWORD
ConnectToPrinter(
	IN PATALKPORT pPort,
	IN DWORD dwTimeout
);

DWORD
SetPrinterStatus(
	IN PATALKPORT pPort,
	IN LPWSTR	 lpwsStatus
);

PATALKPORT
AllocAndInitializePort(
	VOID
);

VOID
FreeAppleTalkPort(
	IN PATALKPORT pNewPort
);

DWORD	
LoadAtalkmonRegistry(
	IN HKEY hkeyPorts
);

DWORD	
CreateRegistryPort(
	IN PATALKPORT pNewPort
);

DWORD
SetRegistryInfo(
	IN PATALKPORT pWalker
);

DWORD
WinSockNbpLookup(
	SOCKET sQuerySocket,
	PCHAR pchZone,
	PCHAR pchType,
	PCHAR pchObject,
	PWSH_NBP_TUPLE pTuples,
	DWORD cbTuples,
	PDWORD pcTuplesFound);

DWORD
OpenAndBindAppleTalkSocket(
	IN PSOCKET pSocket
);

DWORD
CapturePrinter(
	IN PATALKPORT pPort,
	IN BOOL 	  fCapture
);

DWORD
IsSpooler(
	IN	 PWSH_ATALK_ADDRESS pAddress,
	IN OUT BOOL * pfSpooler
);

VOID
GetAndSetPrinterStatus(
	IN PATALKPORT pPort
);

BOOLEAN
IsJobFromMac(
    IN PATALKPORT pPort
);



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\monitor\getprint.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**             Copyright(c) Microsoft Corp., 1991                   **/
/**********************************************************************/

/*
    getprint.cxx

    This file contains the code for the GET_PRINTERS_DIALOG.

    FILE HISTORY:
        NarenG      25-May-1993     Created
*/

#define INCL_NET
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_TIMER
#define INCL_BLT_CC
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>

#include <dbgstr.hxx>

extern "C"
{
#include <winsock.h>
#include <atalkwsh.h>
#include <stdlib.h>
#include "atalkmon.h"
#include "dialogs.h"

    DWORD DoNBPLookup( LPVOID Parameter );
}

#include "getprint.hxx"

/*******************************************************************

    NAME:       GET_PRINTERS_DIALOG::GET_PRINTERS_DIALOG

    SYNOPSIS:   constructor for GET_PRINTERS_DIALOG

    HISTORY:
        NarenG      25-May-1993     Stole from AFPMGR

********************************************************************/

GET_PRINTERS_DIALOG::GET_PRINTERS_DIALOG( HWND 	  	     hWndOwner,
                            		  PNBP_LOOKUP_STRUCT pBuffer )
  : DIALOG_WINDOW(MAKEINTRESOURCE( IDD_GET_PRINTERS_DIALOG ), hWndOwner),
    _timer( this, TIMER_FREQ, FALSE ),
    _progress(this, IDGP_PROGRESS, IDI_PROGRESS_ICON_0, IDI_PROGRESS_NUM_ICONS),
    _sltMessage( this, IDGP_ST_MESSAGE ),
    _nTickCounter( TIMER_MULT )
{

    if ( QueryError() != NERR_Success )
    {
        return ;
    }

    //
    // Begin NBP lookup
    //

    DWORD tidNBPLookup;

    _hthreadNBPLookup = ::CreateThread(
				NULL,		// Default security attributes
				0,		// Default stack size
				::DoNBPLookup,	// Start address
				pBuffer,	// Thread parameter
				0, 		// Run immediately
				&tidNBPLookup	// Thread id
				);

    if ( _hthreadNBPLookup == NULL )
    {
	ReportError( ::GetLastError() );
	return;
    }

    //
    // set the message.
    //

    DWORD  err;
    NLS_STR nlsMessage;
    NLS_STR nlsZoneName( pBuffer->wchZone );


    if ( (( err = nlsMessage.QueryError() ) != NERR_Success  ) ||
         (( err = nlsZoneName.QueryError() ) != NERR_Success ) )
    {
	ReportError( err );
	return;
    }

    if ( ::_wcsicmp( pBuffer->wchZone, (LPWSTR)TEXT("*") ) == 0 )
    {
	nlsMessage.Load( IDS_NO_ZONE_FOR_PRINTERS );
    }
    else
    {
	nlsMessage.Load( IDS_GETTING_PRINTERS_ON_ZONE  );
        err = nlsMessage.InsertParams( nlsZoneName );
    }

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    _sltMessage.SetText( nlsMessage );

    //
    // set polling timer
    //

    _timer.Enable( TRUE );

    return;

}

/*******************************************************************

    NAME:       GET_PRINTERS_DIALOG::~GET_PRINTERS_DIALOG

    SYNOPSIS:   destructor for SERVICE_WAIT_DIALOG. Stops
                the timer if it has not already been stopped.

    HISTORY:
        NarenG      25-May-1992     Created

********************************************************************/

GET_PRINTERS_DIALOG::~GET_PRINTERS_DIALOG( VOID )
{
    _timer.Enable( FALSE );
}

/*******************************************************************

    NAME:       GET_PRINTERS_DIALOG::OnTimerNotification

    SYNOPSIS:   Virtual callout invoked during WM_TIMER messages.

    ENTRY:      tid                     - TIMER_ID of this timer.

    HISTORY:
        NarenG      25-May-1992     Created

********************************************************************/
VOID GET_PRINTERS_DIALOG :: OnTimerNotification( TIMER_ID tid )
{
    //
    //  Bag-out if it's not our timer.
    //

    if( tid != _timer.QueryID() )
    {
        TIMER_CALLOUT :: OnTimerNotification( tid );
        return;
    }

    //
    //  Advance the progress indicator.
    //

    _progress.Advance();

    //
    //  No need to continue if we're just amusing the user.
    //

    if( --_nTickCounter > 0 )
    {
        return;
    }

    _nTickCounter = TIMER_MULT;

    //
    //  Poll the thread doing the lookup to see if the operation is
    //  either complete or continuing as expected.
    //

    DWORD dwRetCode = ::WaitForSingleObject( _hthreadNBPLookup, 0 );

    switch ( dwRetCode )
    {
    case WAIT_OBJECT_0:

	if( !::GetExitCodeThread( _hthreadNBPLookup, &dwRetCode ))
	{
	    dwRetCode = ::GetLastError();
	}

        ::CloseHandle( _hthreadNBPLookup );

	if ( dwRetCode != NO_ERROR )
	{
	   ::MsgPopup( this, dwRetCode );
	}

	Dismiss( TRUE );

	break;

    case WAIT_TIMEOUT:

	break;

    case WAIT_ABANDONED:
    default:

        ::CloseHandle( _hthreadNBPLookup );

	Dismiss( FALSE );

	break;
    }

    return;

}   // GET_PRINTERS_DIALOG :: OnTimerNotification


BOOL GET_PRINTERS_DIALOG :: OnCancel ( VOID )
{
    return ( FALSE );
}

BOOL GET_PRINTERS_DIALOG :: OnOK ( VOID )
{
    return ( FALSE );
}

/*******************************************************************

    NAME:       GET_PRINTERS_DIALOG::OnTimerNotification

    SYNOPSIS:   Virtual callout invoked during WM_TIMER messages.

    ENTRY:      tid                     - TIMER_ID of this timer.

    HISTORY:
        NarenG      25-May-1992     Created

********************************************************************/
DWORD DoNBPLookup( LPVOID Parameter )
{

    PNBP_LOOKUP_STRUCT  pNbpLookup = (PNBP_LOOKUP_STRUCT)Parameter;
    CHAR 		chZone[MAX_ENTITY+1];
    PWSH_NBP_TUPLE      pwshTuple;
    DWORD		err;
    DWORD		cbTuples;
    DWORD		cPrinters = 100;
    DWORD	        cTuplesFound = 0;

    SOCKET hSocket = pNbpLookup->hSocket;

    ::wcstombs( chZone, pNbpLookup->wchZone, sizeof( chZone ) );

    cbTuples = ( sizeof( WSH_NBP_TUPLE ) * cPrinters );

    pwshTuple = (PWSH_NBP_TUPLE)::LocalAlloc( LPTR, cbTuples );

    if ( pwshTuple == NULL )
    {
	return( ERROR_NOT_ENOUGH_MEMORY );
    }

    do {

    	err = ::WinSockNbpLookup(
				hSocket,
			      	chZone,
				ATALKMON_RELEASED_TYPE,
				"=",
			      	pwshTuple,
				cbTuples,	
			       	&cTuplesFound );

	if ( err != NO_ERROR )
	{
	    ::LocalFree( pwshTuple );

	    break;
	}

        if ( cTuplesFound == cPrinters )
	{
	    cPrinters *= 2;

            cbTuples = sizeof( WSH_NBP_TUPLE ) * cPrinters;
	
    	    pwshTuple = (PWSH_NBP_TUPLE)::LocalReAlloc( pwshTuple,
						 	cbTuples,
							LMEM_MOVEABLE );

	    if ( pwshTuple == NULL )
	    {
	    	err = ERROR_NOT_ENOUGH_MEMORY;
	    	break;
	    }

	}
	else
	{
	    pNbpLookup->pPrinters = pwshTuple;
	    pNbpLookup->cPrinters = cTuplesFound;
	    break;
	}
	
    } while( TRUE );

    ::ExitThread( err );

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\monitor\makefile.inc ===
atmonmsg.h atmonmsg.rc : atmonmsg.mc
    mc -v -h . atmonmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\monitor\job.c ===
/*****************************************************************/
/**				Copyright(c) 1989 Microsoft Corporation.		**/
/*****************************************************************/

//***
//
// Filename:	job.c
//
// Description: This module contains the entry points for the AppleTalk
//		monitor that manipulate jobs.
//
//		The following are the functions contained in this module.
//		All these functions are exported.
//
//				StartDocPort
//				ReadPort
//				WritePort
//				EndDocPort
// History:
//
//	Aug 26,1992		frankb  	Initial version
//	June 11,1993.	NarenG		Bug fixes/clean up
//

#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <winsock.h>
#include <atalkwsh.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <lmcons.h>

#include <prtdefs.h>

#include "atalkmon.h"
#include "atmonmsg.h"
#include <bltrc.h>
#include "dialogs.h"

//**
//
// Call:	StartDocPort
//
// Returns:	TRUE	- Success
//		FALSE	- Failure
//
// Description:
// 	This routine is called by the print manager to
//	mark the beginning of a job to be sent to the printer on
//	this port.  Any performance monitoring counts are cleared,
//	a check is made to insure that the printer is still open,
//
// 	open issues:
//
//	  In order to allow for the stack to be shutdown when printing is not
//	  happening, the first access to the AppleTalk stack happens in this
//	  call.  A socket is created and bound to a dynamic address, and an
//	  attempt to connect to the NBP name of the port is made here.  If
//	  the connection succeeds, this routine returns TRUE.  If it fails, the
//	  socket is cleaned up and the routine returns FALSE.  It is assumed that
//	  Winsockets will set the appropriate Win32 failure codes.
//
//	  Do we want to do any performance stuff?  If so, what?
//
BOOL
StartDocPort(
	IN HANDLE	hPort,
	IN LPWSTR	pPrinterName,
	IN DWORD	JobId,
	IN DWORD	Level,
	IN LPBYTE	pDocInfo
)
{
	PATALKPORT		pWalker;
	PATALKPORT		pPort;
	DWORD			dwRetCode;

	DBGPRINT(("Entering StartDocPort\n")) ;

	pPort = (PATALKPORT)hPort;

	if (pPort == NULL)
	{
		SetLastError(ERROR_INVALID_HANDLE);
		return(FALSE);
	}

	//
	// Make sure the job is valid and not marked for deletion
	//

	dwRetCode = ERROR_UNKNOWN_PORT;

	WaitForSingleObject(hmutexPortList, INFINITE);

	for (pWalker = pPortList; pWalker != NULL; pWalker = pWalker->pNext)
	{
		if (pWalker == pPort)
		{
			if (pWalker->fPortFlags & SFM_PORT_IN_USE)
				dwRetCode = ERROR_DEVICE_IN_USE;
			else
			{
				dwRetCode = NO_ERROR;
				pWalker->fPortFlags |= SFM_PORT_IN_USE;
			}
			break;
		}
	}

	ReleaseMutex(hmutexPortList);

	if (dwRetCode != NO_ERROR)
	{
		SetLastError(dwRetCode);
		return(FALSE);
	}

	do
	{
		//
		// get a handle to the printer. Used to delete job and
		// update job status
		//

		if (!OpenPrinter(pPrinterName, &(pWalker->hPrinter), NULL))
		{
			dwRetCode = GetLastError();
			break;
		}

		pWalker->dwJobId = JobId;

		pWalker->fJobFlags |= (SFM_JOB_FIRST_WRITE | SFM_JOB_OPEN_PENDING);

		//
		// open and bind status socket
		//
	
		dwRetCode = OpenAndBindAppleTalkSocket(&(pWalker->sockStatus));

		if (dwRetCode != NO_ERROR)
		{
			ReportEvent(
				hEventLog,
				EVENTLOG_WARNING_TYPE,
				EVENT_CATEGORY_USAGE,
				EVENT_ATALKMON_STACK_NOT_STARTED,
				NULL,
				0,
				0,
				NULL,
				NULL) ;
			break;
		}

		//
		// get a socket for I/O
		//

		dwRetCode = OpenAndBindAppleTalkSocket(&(pWalker->sockIo));
	
		if (dwRetCode != NO_ERROR)
		{
			ReportEvent(
				hEventLog,
				EVENTLOG_WARNING_TYPE,
				EVENT_CATEGORY_USAGE,
				EVENT_ATALKMON_STACK_NOT_STARTED,
				NULL,
				0,
				0,
				NULL,
				NULL);
			break;
		}
	} while(FALSE);

	if (dwRetCode != NO_ERROR)
	{
		if (pWalker->hPrinter != INVALID_HANDLE_VALUE)
			ClosePrinter(pWalker->hPrinter);
	
		if (pWalker->sockStatus != INVALID_SOCKET)
			closesocket(pWalker->sockStatus);
	
		if (pWalker->sockIo != INVALID_SOCKET)
			closesocket(pWalker->sockIo);
	
		pWalker->hPrinter  = INVALID_HANDLE_VALUE;
		pWalker->dwJobId	= 0;
		pWalker->fJobFlags = 0;
		
		WaitForSingleObject(hmutexPortList, INFINITE);
		pWalker->fPortFlags &= ~SFM_PORT_IN_USE;
		ReleaseMutex(hmutexPortList);
	
		SetLastError(dwRetCode);
	
		return(FALSE);
	}

	return(TRUE);
}

//**
//
// Call:	ReadPort
//
// Returns:	TRUE	- Success
//		FALSE	- Failure
//
// Description:
// 		Synchronously reads data from the printer.
//
// 	open issues:
//			the DLC implementation does not implement reads.
//			The local implementation implements reads with generic ReadFile
//			semantics.  It's not clear from the winhelp file if ReadPort
//		should return an error if there is no data to read from
//		the printer.  Also, since PAP is read driven, there will be no
//		data waiting until a read is posted.  Should we pre-post a
//		read on StartDocPort?
//
BOOL
ReadPort(
	IN HANDLE hPort,
	IN LPBYTE pBuffer,
	IN DWORD cbBuffer,
	IN LPDWORD pcbRead
){

	DBGPRINT(("Entering ReadPort\n")) ;

	//
	// if data not available, wait up to a few seconds for a read to complete
	//

	//
	// copy requested amount of data to caller's buffer
	//

	//
	// if all data copied, post another read
	//

	return(TRUE);
}

//**
//
// Call:	WritePort
//
// Returns:	TRUE	- Success
//		FALSE	- Failure
//
// Description:
//		Synchronously writes data to the printer.
//
BOOL
WritePort(
	IN HANDLE 	hPort,
	IN LPBYTE 	pBuffer,
	IN DWORD 	cbBuffer,
	IN LPDWORD 	pcbWritten
)
{
	LPBYTE			pchTemp;
	PATALKPORT  	pPort;
	DWORD			dwIndex;
	DWORD			dwRetCode;
	INT 			wsErr;
	fd_set			writefds;
	fd_set			readfds;
	struct timeval  timeout;
	INT				Flags = 0;
	LPBYTE			pBufToSend;
	DWORD			cbTotalBytesToSend;
    BOOLEAN         fJobCameFromMac;
    BOOLEAN         fPostScriptJob;


	pPort = (PATALKPORT)hPort;

	// Set this to zero. We add incrementally later.
	*pcbWritten = 0;

	if (pPort == NULL)
	{
		SetLastError(ERROR_INVALID_HANDLE);
		return(FALSE);
	}

	pBufToSend = pBuffer;
	cbTotalBytesToSend = cbBuffer;

	//
	// Maximum number of bytes we can write in one send is 4K. This is the
	// limit in the AppleTalk (PAP) protocol.
	//

	if (cbTotalBytesToSend > 4096)
	{
		cbTotalBytesToSend = 4096;
	}

	// If we have not connected to the printer yet.

	if (pPort->fJobFlags & SFM_JOB_OPEN_PENDING)
	{
		// Make sure that the capture thread is done with this job.

		WaitForSingleObject(pPort->hmutexPort, INFINITE);
		ReleaseMutex(pPort->hmutexPort);

		// set status to connecting

		DBGPRINT(("no connection yet, retry connect\n")) ;

		dwRetCode = ConnectToPrinter(pPort, ATALKMON_DEFAULT_TIMEOUT);

		if (dwRetCode != NO_ERROR)
		{
			DBGPRINT(("Connect returns %d\n", dwRetCode)) ;

			//	
			// Wait 15 seconds before trying to reconnect. Each
			// ConnectToPrinter does an expensive NBPLookup
			//

			Sleep(ATALKMON_DEFAULT_TIMEOUT*3);		

			*pcbWritten = 0;

			return(TRUE);

		}
		else
		{
			pPort->fJobFlags &= ~SFM_JOB_OPEN_PENDING;

			WaitForSingleObject(hmutexPortList, INFINITE);
			pPort->fPortFlags |= SFM_PORT_POST_READ;	
			ReleaseMutex(hmutexPortList);

			SetEvent(hevPrimeRead);

			SetPrinterStatus(pPort, wchPrinting);
		}
	}

	//  if first write, determine filter control.  We filter
	//  CTRL-D from non-mac jobs, and leave them in from Macintosh
	//  originated jobs
	if (pPort->fJobFlags & SFM_JOB_FIRST_WRITE)
	{
		DBGPRINT(("first write for this job.  Do filter test\n")) ;

        fJobCameFromMac = IsJobFromMac(pPort);

		// Consume the FILTERCONTROL string
        //
        // the older spoolers will put this string in: go ahead and leave
        // this code in so if this job came from an older SFM spooler, we
        // strip that line!
        //
		if ((cbTotalBytesToSend >= SIZE_FC) &&
			(strncmp(pBufToSend, FILTERCONTROL, SIZE_FC) == 0))
		{
			*pcbWritten += SIZE_FC;
			pBufToSend += SIZE_FC;
			cbTotalBytesToSend -= SIZE_FC;
            fJobCameFromMac = TRUE;
		}
		else if ((cbTotalBytesToSend >= SIZE_FCOLD)  &&
				 strncmp(pBufToSend, FILTERCONTROL_OLD, SIZE_FCOLD) == 0)
		{
			*pcbWritten += SIZE_FCOLD;
			pBufToSend += SIZE_FCOLD;
			cbTotalBytesToSend -= SIZE_FCOLD;
            fJobCameFromMac = TRUE;
		}

		//
		// Need for hack: there are two reasons:
		// 1) control characters (most commonly ctrl-d, but ctrl-c, etc. too)
		// cause postscript printers to choke.  we need to "filter" them out
		// 2) if we're printing to a dual-mode HP printer then it's
		// driver puts in a bunch of PJL commands that causes printer to go to
		// postscript mode etc.  It works great if this goes over lpt or com port
		// but if it goes over appletalk (which is what we do) then the printer
		// expects *only* postscript and seeing the PJL commands, it chokes!
		// The output that goes out to the printer looks like this:
		//
		//	  <....separator page data....>
		//
		//	  $%-12345X@PJL JOB
		//	  @PJL SET RESOLUTION=600
		//	  @PJL ENTER LANGUAGE = POSTSCRIPT
		//	  %!PS-Adobe-3.0
		//
		//	  <.... Postscript data....>
		//
		//	  $%-12345X@PJL EOJ
		//
		// (The escape character is denoted by the '$' sign above.)
		// The first 3 lines and the last line are the ones that cause problem
		//
		// Since it's a pain in the neck to parse all of the data and try and
		// remove the unwanted characters, we just prepend a few postscript
		// commands to the data that tell the printer to ignore ctrl-d,
		// ctrl-c etc. characters, and to ignore any line(s) starting with @PJL.
		//

		//
		// Begin filtering hack
		//

		//
		// make sure the string doesn't already exist (it can if the job goes
		// monitor->spooler->monitor->printer instead of monitor->printer)
		//
        // Again, older SFM monitors would prepend this string: since we got a
        // chance here, strip that out!
        //
		if ((cbTotalBytesToSend >= SIZE_PS_HEADER) &&
			strncmp(pBufToSend, PS_HEADER, SIZE_PS_HEADER) == 0)
		{
			*pcbWritten += SIZE_PS_HEADER;
			pBufToSend += SIZE_PS_HEADER;
			cbTotalBytesToSend -= SIZE_PS_HEADER;
		}

        //
        // WfW starts its job with a CTRL_D.  Replace it with a space
        //
        if (pBufToSend[0] == CTRL_D)
        {
			*pcbWritten += 1;
			pBufToSend += 1;
			cbTotalBytesToSend -= 1;
        }

        //
        // see if this job has a hdr that looks like a conventional postscript hdr
        //
        fPostScriptJob = TRUE;

        if (cbTotalBytesToSend > 2)
        {
            if (pBufToSend[0] == '%' && pBufToSend[1] == '!')
            {
                fPostScriptJob = TRUE;
            }
            else
            {
                fPostScriptJob = FALSE;
            }
        }
        //
        // Mac always sends a postscript job.  Also, we peeked at the data to
        // see if we recognize a postscript hdr. If the job came from a non-Mac
        // client and doesn't look like a conventional postscript job, send a
        // control string telling the printer to ignore the PJL commands.
        //
        if (!fJobCameFromMac && !fPostScriptJob)
        {
		    //
		    // Now send the PS header
		    //
		    FD_ZERO(&writefds);
		    FD_SET(pPort->sockIo, &writefds);
	
		    //
		    // can I send?
		    //
		    timeout.tv_sec  = ATALKMON_DEFAULT_TIMEOUT_SEC;
		    timeout.tv_usec = 0;
	
		    wsErr = select(0, NULL, &writefds, NULL, &timeout);
	
		    if (wsErr == 1)
		    {
			    // can send, send the data & set return count
			    wsErr = send(pPort->sockIo,
				    		 PS_HEADER,
					    	 SIZE_PS_HEADER,
						    MSG_PARTIAL);
	
		    }

        }

		//
		// End filtering hack
		//

	    pPort->fJobFlags &= ~SFM_JOB_FIRST_WRITE;
	}


    // many postscript jobs from pc's end with a ctrl-d which we don't want to send.
    // Since we are given only 1 byte and it is ctrl-d, we assume (FOR NOW) that it's the
    // last byte of the job.  So lie to the spooler that we sent it.
    //
    if (cbTotalBytesToSend == 1)
    {
        if (pBufToSend[0] == CTRL_D)
        {
            *pcbWritten = 1;
            pPort->OnlyOneByteAsCtrlD++;
            return(TRUE);
        }
        else
        {
            cbTotalBytesToSend += 1;   // we subtract 1 in the next line, so adjust here
        }
    }

    //
    // if this job is for dual-mode printer, there is that $%-12345X@PJL EOJ command
    // at the end.  There is a ctrl-d just before that (which is really the end
    // of the actual job). 
    //
    if (cbTotalBytesToSend > PJL_ENDING_COMMAND_LEN)
    {
        if (strncmp(&pBufToSend[cbTotalBytesToSend - PJL_ENDING_COMMAND_LEN],
                    PJL_ENDING_COMMAND,
                    PJL_ENDING_COMMAND_LEN) == 0)
        {
            if (pBufToSend[cbTotalBytesToSend-PJL_ENDING_COMMAND_LEN-1] == CTRL_D)
            {
                pBufToSend[cbTotalBytesToSend-PJL_ENDING_COMMAND_LEN-1] = CR;
            }
        }
    }

    //
    // send 1 less byte so eventually we'll catch the last byte (and see if it's ctrl-D)
    //
    cbTotalBytesToSend -= 1;


    //
    // Earlier we may have got just 1 byte which was ctrl-D but was not really the last byte!
    // This is a very rare case, but in theory possible.  If that's what happened, send
    // that one ctrl-D byte now, and continue on with the rest of the job
    // (Actually being paranoid here and making provision for the spooler handing us a series
    // of ctrl-D bytes, 1 at a time!!)
    //
    if (pPort->OnlyOneByteAsCtrlD != 0)
    {
        BYTE                    TmpArray[20];
        DWORD                   i;

        i=0;
        while (i < pPort->OnlyOneByteAsCtrlD)
        {
            TmpArray[i++] = CTRL_D;
        }

        FD_ZERO(&writefds);
        FD_SET(pPort->sockIo, &writefds);

        timeout.tv_sec  = ATALKMON_DEFAULT_TIMEOUT_SEC;
        timeout.tv_usec = 0;

        wsErr = select(0, NULL, &writefds, NULL, &timeout);

        if (wsErr == 1)
        {
            TmpArray[0] = CTRL_D;
            wsErr = send(pPort->sockIo,
                         TmpArray,
                         pPort->OnlyOneByteAsCtrlD,
                         MSG_PARTIAL);
        }

        pPort->OnlyOneByteAsCtrlD = 0;
    }

	//
	// can I send?
	//
	FD_ZERO(&writefds);
	FD_SET(pPort->sockIo, &writefds);

	timeout.tv_sec  = ATALKMON_DEFAULT_TIMEOUT_SEC;
	timeout.tv_usec = 0;

	wsErr = select(0, NULL, &writefds, NULL, &timeout);

	if (wsErr == 1)
	{
		// can send, send the data & set return count
		wsErr = send(pPort->sockIo,
					 pBufToSend,
					 cbTotalBytesToSend,
					 MSG_PARTIAL);

		if (wsErr != SOCKET_ERROR)
		{
			*pcbWritten += cbTotalBytesToSend;

			if (pPort->fJobFlags & SFM_JOB_ERROR)
			{
				pPort->fJobFlags &= ~SFM_JOB_ERROR;
				SetPrinterStatus(pPort, wchPrinting);
			}
		}
	}

	//
	// can I read? - check for disconnect
	//

	FD_ZERO(&readfds);
	FD_SET(pPort->sockIo, &readfds);

	timeout.tv_sec  = 0;
	timeout.tv_usec = 0;

	wsErr = select(0, &readfds, NULL, NULL, &timeout);

	if (wsErr == 1)
	{
		wsErr = WSARecvEx(pPort->sockIo,
						  pPort->pReadBuffer,
						  PAP_DEFAULT_BUFFER,
						  &Flags);

		if (wsErr == SOCKET_ERROR)
		{
			dwRetCode = GetLastError();
	
			DBGPRINT(("recv returns %d\n", dwRetCode));
	
			if ((dwRetCode == WSAEDISCON) || (dwRetCode == WSAENOTCONN))
			{
				pPort->fJobFlags |= SFM_JOB_DISCONNECTED;
	
				//
				// Try to restart the job
				//

				SetJob(pPort->hPrinter, 	
						pPort->dwJobId,
						0,
						NULL,
						JOB_CONTROL_RESTART);

				SetLastError(ERROR_DEV_NOT_EXIST);

				return(FALSE);
			}
		}
		else
		{
			if (wsErr < PAP_DEFAULT_BUFFER)
				 pPort->pReadBuffer[wsErr] = '\0';
			else pPort->pReadBuffer[PAP_DEFAULT_BUFFER-1] = '\0';
	
			DBGPRINT(("recv returns %s\n", pPort->pReadBuffer));
	
			pPort->fJobFlags |= SFM_JOB_ERROR;
	
			ParseAndSetPrinterStatus(pPort);
		}

		WaitForSingleObject(hmutexPortList, INFINITE);
		pPort->fPortFlags |= SFM_PORT_POST_READ;	
		ReleaseMutex(hmutexPortList);

		SetEvent(hevPrimeRead);
	}

	return(TRUE);
}

//**
//
// Call:	EndDocPort
//
// Returns:	TRUE	- Success
//		FALSE	- Failure
//
// Description:
//		This routine is called to mark the end of the
//		print job.  The spool file for the job is deleted by
//		this routine.
// 	
//	open issues:
//			Do we want to do performance stuff?  If so, now's the time
//		to save off any performance counts.
//
BOOL
EndDocPort(
	IN HANDLE hPort
){
	PATALKPORT		pPort;
	fd_set			writefds;
	fd_set			readfds;
	struct timeval	timeout;
	INT				wsErr;
	INT				Flags = 0;

	DBGPRINT(("Entering EndDocPort\n")) ;

	pPort = (PATALKPORT)hPort;

	if (pPort == NULL)
	{
		SetLastError(ERROR_INVALID_HANDLE);
		return(FALSE);
	}

	//
	// send the last write
	//

	FD_ZERO(&writefds);
	FD_SET(pPort->sockIo, &writefds);

	//
	// If the job was not able to connect to the printer.

	if ((pPort->fJobFlags & (SFM_JOB_OPEN_PENDING | SFM_JOB_DISCONNECTED)) == 0)
	{

		timeout.tv_sec  = 90;
		timeout.tv_usec = 0;

		wsErr = select(0, NULL, &writefds, NULL, &timeout);

		if (wsErr == 1)
		{
			//
			// Send EOF
			//
			send(pPort->sockIo, NULL, 0, 0);
		}

		//
		// Our socket is non-blocking. If we close down the socket, we could potentially
		// abort the last page. A good thing to do is to wait for a reasonable amount of
		// time out for the printer to send EOF, or request for more data.
		//
		FD_ZERO(&writefds);
		FD_SET(pPort->sockIo, &writefds);
		FD_ZERO(&readfds);
	    FD_SET(pPort->sockIo, &readfds);

		timeout.tv_sec  = 30;
		timeout.tv_usec = 0;
		wsErr = select(0, &readfds, &writefds, NULL, &timeout);

	    if (wsErr == 1 && FD_ISSET(pPort->sockIo, &readfds))
	    {
			// read printer's EOF.  We don't care about an error here
			wsErr = WSARecvEx(pPort->sockIo, pPort->pReadBuffer, PAP_DEFAULT_BUFFER, &Flags);
		}
	}

	//
	// delete the print job
	//

	if (pPort->hPrinter != INVALID_HANDLE_VALUE)
	{
		if (!SetJob(pPort->hPrinter, 	
					pPort->dwJobId,
					0,
					NULL,
					JOB_CONTROL_SENT_TO_PRINTER))
		DBGPRINT(("fail to setjob for delete with %d\n", GetLastError())) ;

		ClosePrinter(pPort->hPrinter);

		pPort->hPrinter = INVALID_HANDLE_VALUE;
	}

	//
	// close the PAP connections
	//

	if (pPort->sockStatus != INVALID_SOCKET)
	{
		closesocket(pPort->sockStatus);
		pPort->sockStatus = INVALID_SOCKET;
	}


	if (pPort->sockIo != INVALID_SOCKET)
	{
		closesocket(pPort->sockIo);
		pPort->sockIo = INVALID_SOCKET;
	}

	pPort->dwJobId	= 0;
	pPort->fJobFlags = 0;
        pPort->OnlyOneByteAsCtrlD = 0;

	WaitForSingleObject(hmutexPortList, INFINITE);
	pPort->fPortFlags &= ~SFM_PORT_IN_USE;
	ReleaseMutex(hmutexPortList);

	return(TRUE);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\monitor\init.c ===
/*****************************************************************/
/**				Copyright(c) 1989 Microsoft Corporation.		**/
/*****************************************************************/

//***
//
// Filename:	init.c
//
// Description: This module contains initialization code for the print
//		monitor.
//
//		In addition there are the ReadThread and the CaptureThread
//		functions.
//
//		The following are the functions contained in this module.
//		All these functions are exported.
//
//			LibMain
//		 	InitializeMonitor
//			ReadThread
//			CaptureThread
//
//
// History:
//
//	Aug 26,1992		frankb  	Initial version
//	June 11,1993.	NarenG		Bug fixes/clean up
//

#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <winsock.h>
#include <atalkwsh.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <lmcons.h>

#include <prtdefs.h>
#ifdef FE_SB
#include <locale.h>
#endif /* FE_SB */

#define ALLOCATE
#include "atalkmon.h"

#include "atmonmsg.h"
#include <bltrc.h>
#include "dialogs.h"

//**
//
// Call:	LibMain
//
// Returns:	TRUE 	- Success
//		FALSE	- Failure
//
// Description:
//			This routine is called when a process attaches
//		or detaches from the AppleTalk Monitor.  On process attach,
//		we save the module handle in the global hInst (we assume that
//		only one process will attach to the monitor)
//
//		On process detach, we free any system resources we've allocated.
//
BOOL LibMain(
	IN HANDLE  hModule,
	IN DWORD	dwReason,
	IN LPVOID  lpRes
)
{

	UNREFERENCED_PARAMETER(lpRes);

	switch(dwReason)
	{
	  case DLL_PROCESS_ATTACH:

#ifdef FE_SB
        setlocale( LC_ALL, "" );
#endif

		//
		// Save the instance handle
		//

		hInst = hModule;
		break;

	  case DLL_PROCESS_DETACH:

		//
		// Stop the Capture and I/O threads
		//

		boolExitThread = TRUE;

		//
		// Release global resources
		//
		if (hkeyPorts != NULL)
			RegCloseKey(hkeyPorts);

		if (hevConfigChange != NULL)
		{
			SetEvent(hevConfigChange);
			CloseHandle(hevConfigChange);
		}

		if (hevPrimeRead != NULL)
		{
			SetEvent(hevPrimeRead);
			CloseHandle(hevPrimeRead);
		}

		if (hCapturePrinterThread != NULL)
		{
			WaitForSingleObject(hCapturePrinterThread,  ATALKMON_DEFAULT_TIMEOUT);

			CloseHandle(hCapturePrinterThread);
		}

		if (hReadThread != NULL)
		{
			WaitForSingleObject(hReadThread, ATALKMON_DEFAULT_TIMEOUT);

			CloseHandle(hReadThread);
		}

		if (hmutexPortList != NULL) 
			CloseHandle(hmutexPortList);

		if (hmutexDeleteList != NULL)
			CloseHandle(hmutexDeleteList);

		//
		// Release Windows Sockets
		//

		WSACleanup();
		break;

	  default:
		break;
	}

	return(TRUE);
}

//**
//
// Call:	InitializeMonitor
//
// Returns:	TRUE	- Success
//		FALSE	- Failure
//
// Description:
//		This routine is called when the spooler starts up.
//		We allocate per port resources by reading the current port
//		list from the registry.
//
BOOL
InitializeMonitor(
	IN LPWSTR pszRegistryRoot
)
{
	LPWSTR	lpwsPortsKeyPath;
	DWORD	dwRetCode = NO_ERROR;
	DWORD	tid;
	DWORD	RegFilter;
    DWORD	dwValueType;
	DWORD	dwDisposition;
	WSADATA	WsaData;
	DWORD	dwNameLen;

	DBGPRINT (("sfmmon: InitializeMonitor: Entered Initialize Monitor\n"));

	//
	// Resource clean-up 'loop'
	//
	do
	{
		//
		// Setup the event log
		//
	
		hEventLog = RegisterEventSource(NULL, ATALKMON_EVENT_SOURCE);
	
		lpwsPortsKeyPath = (LPWSTR)LocalAlloc(LPTR,
					sizeof(WCHAR)*((wcslen(pszRegistryRoot)+1) +
						  (wcslen(ATALKMON_PORTS_SUBKEY)+1)));
		if (lpwsPortsKeyPath == NULL)
		{
			dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
			break ;
		}
	
		wcscpy(lpwsPortsKeyPath, pszRegistryRoot);
		wcscat(lpwsPortsKeyPath, ATALKMON_PORTS_SUBKEY);
	
		//
		// Open the ports key
		//
	
		if ((dwRetCode = RegCreateKeyEx(
				HKEY_LOCAL_MACHINE,
				lpwsPortsKeyPath,
				0,
				TEXT(""),
				REG_OPTION_NON_VOLATILE,
				KEY_READ | KEY_WRITE,
				NULL,
				&hkeyPorts,
				&dwDisposition)) != ERROR_SUCCESS)
		{
			DBGPRINT(("ERROR:Can't open Ports registry key %d\n",dwRetCode));
			break ;
		}

		//
		// Query the filter option, if specified. By default it is on.
		//
		
		dwNameLen = sizeof(RegFilter);
		dwRetCode = RegQueryValueEx(hkeyPorts,
									ATALKMON_FILTER_VALUE,
									NULL,
									&dwValueType,
									(PUCHAR)&RegFilter,
									&dwNameLen);
		if (dwRetCode == 0)
		{
			Filter = (RegFilter != 0);
		}
		
#ifdef DEBUG_MONITOR
		{
			HKEY  	hkeyAtalkmonRoot;
			HKEY  	hkeyOptions;
			LPWSTR  pszLogPath = NULL ;
			DWORD	cbLogPath = 0 ;
	
			if ((dwRetCode = RegCreateKeyEx(
				HKEY_LOCAL_MACHINE,
				pszRegistryRoot,
				0,
				L"",
				REG_OPTION_NON_VOLATILE,
				KEY_ALL_ACCESS,
				NULL,
				&hkeyAtalkmonRoot,
				&dwDisposition)) != ERROR_SUCCESS)
			{
				break ;
			}
		
			//
			// get Options subkey
			//
		
			if ((dwRetCode = RegCreateKeyEx(
				hkeyAtalkmonRoot,
				ATALKMON_OPTIONS_SUBKEY,
				0,
				L"",
				REG_OPTION_NON_VOLATILE,
				KEY_READ,
				NULL,
				&hkeyOptions,
				&dwDisposition)) != ERROR_SUCCESS)
			{
				break ;
			}
		
			RegCloseKey(hkeyAtalkmonRoot) ;
		
			//
			// setup the log file if we have one
			//
		
			RegQueryValueEx(
				hkeyOptions,
				ATALKMON_LOGFILE_VALUE,
				NULL,
				&dwValueType,
				(LPBYTE) pszLogPath,
				&cbLogPath) ;
		
			if (cbLogPath > 0) {
		
				pszLogPath = LocalAlloc(LPTR, cbLogPath * sizeof(WCHAR)) ;
		
				if (pszLogPath == NULL) {
					dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
					break ;
				}
			}
		
			if ((dwRetCode = RegQueryValueEx(
				hkeyOptions,
				ATALKMON_LOGFILE_VALUE,
				NULL,
				&dwValueType,
				(LPBYTE) pszLogPath,
				&cbLogPath)) == ERROR_SUCCESS)
			{
				//
				// open the log file
				//
		
				hLogFile = CreateFile(
					pszLogPath,
					GENERIC_WRITE,
					FILE_SHARE_READ,
					NULL,
					CREATE_ALWAYS,
					FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
					NULL) ;
		
			}
			
			DBGPRINT(("ATALKMON LOG FLE OPENED\n\n")) ;
		}
#endif

		//
		// initialize global variables
		//
	
		pPortList	= NULL;
		pDeleteList = NULL;

		if ((hmutexBlt = CreateMutex(NULL, FALSE, NULL)) == NULL)
		{
			dwRetCode = GetLastError();
			break;
		}

		if ((hmutexPortList = CreateMutex(NULL, FALSE, NULL)) == NULL)
		{
			dwRetCode = GetLastError();
			break;
		}

		if ((hmutexDeleteList = CreateMutex(NULL, FALSE, NULL)) == NULL)
		{
			dwRetCode = GetLastError();
			break;
		}

		//
		// This event should be reset automatically and created signalled
		// so that the config thread will capture printers on startup instead
		// of waiting for the capture interval
		//
	
		if ((hevConfigChange = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
		{
			dwRetCode = GetLastError();
			DBGPRINT(("sfmmon: InitializeMonitor: Error in hevConfigChange creation\n"));
			break;
		}
	
		//
		// This event should be reset automatically and created not signalled.
		// StartDocPort will signal this event when a job is started, and
		// WritePort() will signal the event anytime it wants to post another
		// read on the job.
		//
	
		if ((hevPrimeRead = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
		{
			dwRetCode = GetLastError();
			DBGPRINT(("sfmmon: InitializeMonitor: Error in hevPrimeRead creation\n"));
			break ;
		}
	
		//
		// Get the local computer's name.
		//
	
		dwNameLen = MAX_ENTITY+1;
	
		if (!GetComputerNameA(chComputerName, &dwNameLen))
		{
			dwRetCode = GetLastError();
			DBGPRINT(("sfmmon: InitializeMonitor: Error in GetComputerNameA call\n"));
			break;
		}
		
		strcat(chComputerName, ATALKMON_CAPTURED_TYPE);
	
		//
		// initialize ports from registry
		//
	
		if ((dwRetCode = LoadAtalkmonRegistry(hkeyPorts)) != NO_ERROR)
		{
			ReportEvent(
				hEventLog,
				EVENTLOG_ERROR_TYPE,
				EVENT_CATEGORY_INTERNAL,
				EVENT_ATALKMON_REGISTRY_ERROR,
				NULL,
				0,
				sizeof(DWORD),
				NULL,
				&dwRetCode);
			DBGPRINT(("sfmmon: InitializeMonitor: Error in LoadAtalkmonRegistry call\n"));
			break;
		}
	
		//
		// Load and store status strings
		//
	
		if ((!LoadString(GetModuleHandle(TEXT("SFMMON")),
						IDS_BUSY,
						wchBusy,
						STATUS_BUFFER_SIZE))	||
			(!LoadString(GetModuleHandle(TEXT("SFMMON")),
					IDS_PRINTING,
					wchPrinting,
					STATUS_BUFFER_SIZE))		||
			(!LoadString(GetModuleHandle(TEXT("SFMMON")),
					IDS_PRINTER_OFFLINE,
					wchPrinterOffline,
					STATUS_BUFFER_SIZE))		||
			(!LoadString(GetModuleHandle(TEXT("SFMMON")),
					IDS_DLL_NAME,
					wchDllName,
					STATUS_BUFFER_SIZE))		||
			(!LoadString(GetModuleHandle(TEXT("SFMMON")),
					IDS_PORT_DESCRIPTION,
					wchPortDescription,
					STATUS_BUFFER_SIZE))		||
			(!LoadString(GetModuleHandle(TEXT("SFMMON")),
					IDS_ERROR,
					wchPrinterError,
					STATUS_BUFFER_SIZE)))
		{
			dwRetCode = GetLastError();
			DBGPRINT(("sfmmon: InitializeMonitor: Error in LoadString SFMMON call\n"));
			break;
		}
	
		//
		// Initialize Windows Sockets
		//
		if ((dwRetCode = WSAStartup(0x0101, &WsaData)) != NO_ERROR)
		{
			DBGPRINT(("WSAStartup fails with %d\n", dwRetCode)) ;
	
			ReportEvent(
				hEventLog,
				EVENTLOG_ERROR_TYPE,
				EVENT_CATEGORY_INTERNAL,
				EVENT_ATALKMON_WINSOCK_ERROR,
				NULL,
				0,
				sizeof(DWORD),
				NULL,
				&dwRetCode);
			DBGPRINT(("sfmmon: InitializeMonitor: Error in WSAStartup call\n"));
			break;
		}
	
		//
		// Start watchdog thread to keep printers captured
		//
	
		hCapturePrinterThread = CreateThread(
						NULL,
						0,
						CapturePrinterThread,
						NULL,
						0, 	
						&tid);
	
		if (hCapturePrinterThread == NULL)
		{
			dwRetCode = GetLastError();
			DBGPRINT(("sfmmon: InitializeMonitor: Error in CapturePrinterThread call\n"));
			break ;
		}
	
		//
		// Start an I/O thread to prime reads from
		//
	
		hReadThread = CreateThread(	NULL,
									0,
									ReadThread,
									NULL,
									0,
									&tid);
		if (hReadThread == NULL)
		{
				dwRetCode = GetLastError();
				DBGPRINT(("sfmmon: InitializeMonitor: Error in PrimeReadThreadcreation call\n"));
				break;
		}
	} while(FALSE);
	
	if (lpwsPortsKeyPath != NULL)
		LocalFree(lpwsPortsKeyPath);
	
	if (dwRetCode != NO_ERROR)
	{
		if (hkeyPorts != NULL) 
		{
			RegCloseKey(hkeyPorts);
			hkeyPorts=NULL;
		}
	
		if (hevConfigChange != NULL) 
		{
			CloseHandle(hevConfigChange);
			hevConfigChange=NULL;
		}
	
		if (hevPrimeRead != NULL) 
		{
			CloseHandle(hevPrimeRead);
			hevPrimeRead=NULL;
		}
		if (hmutexPortList != NULL) 
		{
			CloseHandle(hmutexPortList);
			hmutexPortList=NULL;
		}
	
		if (hmutexDeleteList != NULL) 
		{
			CloseHandle(hmutexDeleteList);
			hmutexDeleteList=NULL;
		}

		if (hmutexBlt != NULL) 
		{
			CloseHandle(hmutexBlt);
			hmutexBlt=NULL;
		}
	
		ReportEvent(
				hEventLog,
				EVENTLOG_ERROR_TYPE,
				EVENT_CATEGORY_INTERNAL,
				EVENT_ATALKMON_REGISTRY_ERROR,
				NULL,
				0,
				sizeof(DWORD),
				NULL,
				&dwRetCode);

		DBGPRINT(("sfmmon: Initialize Monitor was unsuccessful\n"));
	
		return(FALSE);
	}

		
	DBGPRINT(("sfmmon: Initialize Monitor was successful\n"));

	return(TRUE);
}

//**
//
// Call:	CapturePrinterThread
//
// Returns:
//
// Description:
//
//	This is the tread routine for the thread that monitors
//	Appletalk printers to insure that they remain in the configured
//	state (captured or not).  It waits on an event with a timeout where
//	the event is signalled whenever the configuration of an Appletalk
//	printer is changed through the NT print manager.  When the wait
//	completes, it walks the list of known Appletalk printers and does
//	an NBP lookup for the printer in the expected state.  If the lookup
//	fails, it does another lookup for the printer in the opposite state.
//	If it finds the printer in the wrong state, it sends a job to change
//	the NBP name of the printer.
//
// 	NOTE:	The spooler recognizes when it has no printers configured
// 			to use a port, and calls ClosePort at that time.  If someone
//		creates a printer to use a port, it then calls OpenPort.
//		Capturing of printers should only happen for Open ports,
//		so we keep a status of the port state and only do captures
//		on Open ports.
//
DWORD
CapturePrinterThread(
	IN LPVOID pParameterBlock
)
{
	PATALKPORT  pWalker;
	BOOL		fCapture;
	BOOL		fIsSpooler;
	DWORD		dwIndex;
	DWORD		dwCount;

	DBGPRINT(("Enter CapturePrinterThread\n")) ;

	while (!boolExitThread)
	{
		//
		// wait for timeout or a configuration change via ConfigPort.
		// Also, this thread will post any reads for the monitor since
		// asynch I/O must be handled by a thread that does not die, and
		// the monitor threads are all RPC threads which are only
		// guaranteed to be around for the duration of the function call.
		//

		DBGPRINT(("waiting for config event\n")) ;

		WaitForSingleObject(hevConfigChange, CONFIG_TIMEOUT);

		DBGPRINT(("config event or timeout occurs\n")) ;

		//
		// Delete and release ports that are pending delete.
		//

		do
		{
			WaitForSingleObject(hmutexDeleteList, INFINITE);

			if (pDeleteList != NULL)
			{
				pWalker = pDeleteList;
	
				pDeleteList = pDeleteList->pNext;
	
				ReleaseMutex(hmutexDeleteList);
			}
			else
			{
				ReleaseMutex(hmutexDeleteList);
				break;
			}

			//
			// If this is a spooler don't bother.
			//

			if (!(pWalker->fPortFlags & SFM_PORT_IS_SPOOLER))
				CapturePrinter(pWalker, FALSE);

			FreeAppleTalkPort(pWalker);
		} while(TRUE);

	
		//
		// Recapture or rerelease printers that have been power cycled
		//
		WaitForSingleObject(hmutexPortList, INFINITE);

		dwIndex = 0;

		do
		{
			//
			// Go to the ith element
			//
	
			for (dwCount = 0, pWalker = pPortList;
				 ((pWalker != NULL) && (dwCount < dwIndex));
				 pWalker = pWalker->pNext, dwCount++)
				 ;
	
			if (pWalker == NULL)
			{
				ReleaseMutex(hmutexPortList);
				break;
			}
		
			//
			// Do not muck with the port if a job is using it
			//
	
			if (!(pWalker->fPortFlags & SFM_PORT_IN_USE)  &&
				  ((pWalker->fPortFlags & SFM_PORT_OPEN) ||
					(pWalker->fPortFlags & SFM_PORT_CLOSE_PENDING)))
			{
				fCapture   = pWalker->fPortFlags & SFM_PORT_CAPTURED;
				fIsSpooler = pWalker->fPortFlags & SFM_PORT_IS_SPOOLER;
	
				if (pWalker->fPortFlags & SFM_PORT_CLOSE_PENDING)
					pWalker->fPortFlags &= ~SFM_PORT_CLOSE_PENDING;
		
				ReleaseMutex(hmutexPortList);
		
				//
				// If this is a spooler do not muck with it
				//
		
				if (!fIsSpooler)
				{
					//
					// Try to grab the port for capturing
					//
		
					if (WaitForSingleObject(pWalker->hmutexPort, 1) == WAIT_OBJECT_0)
					{
						CapturePrinter(pWalker, fCapture);
	
						ReleaseMutex(pWalker->hmutexPort);
					}
				}
		
				WaitForSingleObject(hmutexPortList, INFINITE);
			}
	
			dwIndex++;
		} while(TRUE);
	}
	return(NO_ERROR);
}

//**
//
// Call:	ReadThread
//
// Returns:
//
// Description:
//
DWORD
ReadThread(
	IN LPVOID pParameterBlock
){

	PATALKPORT	  pWalker;

	//
	// This thread goes 'till boolExitThread is set
	//
	while(!boolExitThread)
	{
		//
		// wait for a signal to do I/O
		// Wait here in an alertable fashion. This is needed so that the prime-read
		// apc's can be delivered to us.

		if (WaitForSingleObjectEx(hevPrimeRead, INFINITE, TRUE) == WAIT_IO_COMPLETION)
			continue;

		DBGPRINT(("received signal to read/close\n")) ;

		//
		// for each port in our list
		//

		WaitForSingleObject(hmutexPortList, INFINITE);

		for (pWalker = pPortList; pWalker != NULL; pWalker=pWalker->pNext)
		{
			if ((pWalker->fPortFlags & (SFM_PORT_IN_USE | SFM_PORT_POST_READ)) ==
															(SFM_PORT_POST_READ | SFM_PORT_IN_USE))
			{

				DBGPRINT(("prime read for port %ws\n", pWalker->pPortName)) ;

				setsockopt(pWalker->sockIo,
							SOL_APPLETALK,
							SO_PAP_PRIME_READ,
							pWalker->pReadBuffer,
							PAP_DEFAULT_BUFFER);

				pWalker->fPortFlags &= ~SFM_PORT_POST_READ;
			}
		}

		ReleaseMutex(hmutexPortList);
	}

	return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\lib\debug.c ===
/*****************************************************************************/
/**			 Microsoft LAN Manager				    **/
/**		   Copyright (C) Microsoft Corp., 1992			    **/
/*****************************************************************************/

//***
//	File Name:  debug.c
//
//	Function:   debug functions
//
//	History:
//
//	    05/21/92	Narendra Gidwani	- Original Version 1.0
//***

#if DBG==1
#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>

#include "debug.h"

VOID
DbgPrintf (
    char *Format,
    ...
    )

{
    va_list arglist;
    char OutputBuffer[1024];
    ULONG length;

    try {
        if (hLogFile != INVALID_HANDLE_VALUE) {
        	va_start( arglist, Format );

        	vsprintf( OutputBuffer, Format, arglist );

        	va_end( arglist );

        	length = strlen( OutputBuffer );

        	WriteFile( hLogFile, (LPVOID )OutputBuffer, length, &length, NULL );
            FlushFileBuffers (hLogFile) ;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
    	sprintf (OutputBuffer, "exception entered while printing error message\n") ;
    	WriteFile (hLogFile, (LPVOID)OutputBuffer, length, &length, NULL) ;
        FlushFileBuffers (hLogFile) ;
    }

}


#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\monitor\dialogs.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    dialogs.h
	
    This file contains the ID constants used by SFM Print Manager dialogs


    FILE HISTORY:
	NarenG		26-May-93	Created
*/


#ifndef _DIALOGS_H_
#define _DIALOGS_H_

#include <uimsg.h>			// For IDS_UI_RASMAC_BASE
#include <uirsrc.h>			// For IDRSRC_RASMAC_BASE
#include <uihelp.h>			// for HC_UI_RASMAC_BASE

//
// string ID's
//

#define IDS_MACPRINT_HELPFILENAME       (IDS_UI_RASMAC_BASE+1)
#define IDS_MUST_START_STACK        	(IDS_UI_RASMAC_BASE+2)
#define IDS_NO_ZONE_FOR_PRINTERS 	(IDS_UI_RASMAC_BASE+3)
#define IDS_GETTING_PRINTERS_ON_ZONE    (IDS_UI_RASMAC_BASE+4)
#define IDS_NO_ZONES    		(IDS_UI_RASMAC_BASE+5)
#define IDS_NO_PRINTERS    		(IDS_UI_RASMAC_BASE+6)
#define IDS_MUST_SELECT_PRINTER 	(IDS_UI_RASMAC_BASE+7)
#define IDS_SPOOLER 			(IDS_UI_RASMAC_BASE+8)
#define IDS_BUSY			(IDS_UI_RASMAC_BASE+10)
#define IDS_PRINTING			(IDS_UI_RASMAC_BASE+11)
#define IDS_ERROR			(IDS_UI_RASMAC_BASE+12)
#define IDS_WANT_TO_CAPTURE		(IDS_UI_RASMAC_BASE+13)
#define IDS_NOTHING_TO_CONFIGURE	(IDS_UI_RASMAC_BASE+14)
#define IDS_PRINTER_OFFLINE	        (IDS_UI_RASMAC_BASE+15)
#define IDS_DLL_NAME	            (IDS_UI_RASMAC_BASE+16)
#define IDS_PORT_DESCRIPTION	    (IDS_UI_RASMAC_BASE+17)

//
//  For DLGEDIT.EXE's benefit.
//

#ifndef IDHELPBLT
#error "Get IDHELPBLT definition from bltrc.h"

    //
    // The value of IDHELPBLT here is only a placeholder to keep dlgedit.exe
    // happy. It is redefined to the value in bltrc.h before creating the
    // resources.
    //

#define IDHELPBLT                       80
#endif  // IDHELPBLT

//
//  ListBox Bitmap IDs
//

#define IDBM_LB_ZONE_NOT_EXPANDED      	11001	// (IDRSRC_RASMAC_BASE+1)
#define IDBM_LB_ZONE_EXPANDED           11002	
#define IDBM_LB_PRINTER                 11003

//
// Get Printers progress icons
//

#define IDI_PROGRESS_ICON_0     	11200
#define IDI_PROGRESS_ICON_1     	11201
#define IDI_PROGRESS_ICON_2     	11202
#define IDI_PROGRESS_ICON_3     	11203
#define IDI_PROGRESS_ICON_4     	11204
#define IDI_PROGRESS_ICON_5     	11205
#define IDI_PROGRESS_ICON_6     	11206
#define IDI_PROGRESS_ICON_7     	11207
#define IDI_PROGRESS_ICON_8     	11208
#define IDI_PROGRESS_ICON_9     	11209
#define IDI_PROGRESS_ICON_10    	11210
#define IDI_PROGRESS_ICON_11    	11211
#define IDI_PROGRESS_NUM_ICONS 		12

//
// Get Printers dialogs
//

#define IDD_GET_PRINTERS_DIALOG 	11250
#define IDGP_PROGRESS			11251
#define IDGP_ST_MESSAGE			11252

//
// Add port dialog 
//

#define IDD_ADDPORT_DIALOG           	11300
#define IDAP_LB_OUTLINE			11301

//
// Config port dialog
//

#define IDD_CONFIG_PORT_DIALOG          11350
#define IDCP_CHK_CAPTURE        	11351


//
// help contexts
//


#define HC_ADD_PORT_DIALOG		(HC_UI_RASMAC_BASE+150)
#define HC_CONFIGURE_PORT_DIALOG 	(HC_UI_RASMAC_BASE+151)

//
// Function prototypes 
//

BOOL ConfigPortDialog( HWND hdlg, BOOL fIsSpooler, BOOL * pfCapture );

BOOL AddPortDialog( HWND hdlg, PATALKPORT pAtalkPort );

BOOL InitializeBlt( VOID );

VOID TerminateBlt( VOID );

//
// Structure used to pass zone and socket handle to lookup thread.
//

typedef struct _NBP_LOOKUP_STRUCT {

    SOCKET 		hSocket;

    WCHAR  		wchZone[MAX_ENTITY+1];

    PWSH_NBP_TUPLE 	pPrinters;

    DWORD 	 	cPrinters;

} * PNBP_LOOKUP_STRUCT, NBP_LOOKUP_STRUCT; 

#endif  // _DIALOGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\monitor\dialogs.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    dialogs.cxx
    This module contains the Add Port and Configure dialogs.


    FILE HISTORY:
        NarenG      17-May-1993  Converted C code for the 2 dialogs to C++

*/


#define INCL_NET
#define INCL_NETLIB
#define INCL_NETSERVICE
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#include <uiassert.hxx>
#include <uitrace.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_TIMER
#define INCL_BLT_CC
#include <blt.hxx>

#include <dbgstr.hxx>

extern "C"
{
#include <stdlib.h>
#include <winsock.h>
#include <atalkwsh.h>
#include "atalkmon.h"
#include "dialogs.h"
}   // extern "C"

//#include <colwidth.hxx>
#include <ellipsis.hxx>
#include "getprint.hxx"
#include "dialogs.hxx"

#define STRING_SIZE_CHARS   255
#define STRING_SIZE_BYTES   (STRING_SIZE_CHARS * sizeof(WCHAR))

/*******************************************************************

    NAME:       InitializeBlt

    SYNOPSIS:   Called during processing of DLL_PROCESS_ATTACH notification to
                initialize the DLL.

    ENTRY:     

    RETURNS:    BOOL                    - TRUE  = AfpMgr should be installed.
                                          FALSE = AfpMgr cannot be installed.

    HISTORY:
        NarenG      71-May-1993  	Created

********************************************************************/
BOOL InitializeBlt( VOID )
{
    WaitForSingleObject( hmutexBlt, INFINITE );

    //
    //  Initialize all of the NetUI goodies.
    //


    APIERR err = BLT::Init( (HINSTANCE)hInst,
			    IDRSRC_RASMAC_BASE, IDRSRC_RASMAC_LAST,	
			    IDS_UI_RASMAC_BASE, IDS_UI_RASMAC_LAST );

    if( err == NERR_Success )
    {
        err = BLT_MASTER_TIMER::Init();

        if( err != NERR_Success )
        {
            //
            //  BLT initialized OK, but BLT_MASTER_TIMER
            //  failed.  So, before we bag-out, we must
            //  deinitialize BLT.
            //

            BLT::Term( (HINSTANCE)hInst );
        }
    }


    if( err == NERR_Success )
    {
 	err = BLT::RegisterHelpFile( (HINSTANCE)hInst,
                                     IDS_MACPRINT_HELPFILENAME,
                                     HC_UI_RASMAC_BASE,
                                     HC_UI_RASMAC_LAST );

   	if( err != NERR_Success )
        {
       	    //
            //  This is the only place where we can safely
            //  invoke MsgPopup, since we *know* that all of
            //  the BLT goodies were initialized properly.
            //

//            ::MsgPopup( QueryHwnd(), err );
      	}
    }

    if ( err != NERR_Success )
        ReleaseMutex( hmutexBlt );

    return err == NERR_Success;

}   // InitializeBlt


/*******************************************************************

    NAME:       TerminateBlt

    SYNOPSIS:   Called during processing of DLL_PROCESS_DETACH notification to
                terminate the DLL.

    ENTRY:      

    HISTORY:
        NarenG      24-May-1993  	Created.

********************************************************************/
VOID TerminateBlt( VOID )
{
    //
    //  Kill the NetUI goodies.
    //

    BLT_MASTER_TIMER::Term();

    BLT::Term( (HINSTANCE)hInst );

    ReleaseMutex( hmutexBlt );

}   // TerminateBlt

/********************************************************************

    NAME: 	ConfigPortDialog

    SYNOPSIS:   Called to bring up the configure port dialog.

    ENTRY: 	lParam is a pointer to an ATALKPORT structure for the 
		port being configured.

    HISTORY:
        NarenG      24-May-1993  	Created.

*********************************************************************/
BOOL ConfigPortDialog( HWND hdlg, BOOL fIsSpooler, BOOL * pfCapture )
{
    if ( !InitializeBlt() )
    {
	return FALSE;
    }

    //
    // If this is a spooler then we have nothing to configure
    //

    if ( fIsSpooler )
    {
	::MsgPopup( hdlg, IDS_NOTHING_TO_CONFIGURE, MPSEV_INFO, 1, MP_OK );

    	TerminateBlt();

	return FALSE;
    }
   
    BOOL fOk = FALSE;

    CONFIGURE_PORT_DIALOG * pdlg = new CONFIGURE_PORT_DIALOG( hdlg, pfCapture );

    APIERR err = ( pdlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
				  : pdlg->Process( &fOk );

    delete pdlg;

    if ( err != NO_ERROR )
    {
	::MsgPopup( hdlg, err );

        TerminateBlt() ;

	return FALSE;
    }

    TerminateBlt();

    return fOk;
}


/********************************************************************

    NAME: 	CONFIGURE_PORT_DIALOG::CONFIGURE_PORT_DIALOG

    SYNOPSIS:   CONFIGURE_PORT_DIALOG constructor

    ENTRY: 	hwndOwner  - Handle to the owner window.

		pAtalkPort - Pointer to the ATALKPORT structure for the 
			     port being configured.

    HISTORY:
        NarenG      24-May-1993  	Created.

*********************************************************************/
CONFIGURE_PORT_DIALOG::CONFIGURE_PORT_DIALOG( HWND	 hWndOwner,
					      BOOL *     pfCapture )
    : DIALOG_WINDOW( MAKEINTRESOURCE(IDD_CONFIG_PORT_DIALOG ), hWndOwner ), 
      _pfCapture( pfCapture ),
      _chkCapture( this, IDCP_CHK_CAPTURE )
{

    // 
    // Make sure everything constructed correctly
    //

    if ( QueryError() != NERR_Success )
    {
	return;
    }

    APIERR err;

    if ( (( err = _chkCapture.QueryError() ) != NERR_Success ) )
    {
	ReportError( err );
	return;
    }

    _chkCapture.SetCheck( *pfCapture );
}

/********************************************************************

    NAME: 	CONFIGURE_PORT_DIALOG::OnOK

    SYNOPSIS:   Called when the user hits the OK button

    ENTRY: 	

    HISTORY:
        NarenG      24-May-1993  	Created.

*********************************************************************/
BOOL CONFIGURE_PORT_DIALOG::OnOK( VOID )
{
    *_pfCapture = _chkCapture.QueryCheck();

    Dismiss( TRUE );

    return TRUE;
}

/*******************************************************************

    NAME:       CONFIGURE_PORT_DIALOG :: QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.


********************************************************************/
ULONG CONFIGURE_PORT_DIALOG :: QueryHelpContext( void )
{
    return HC_CONFIGURE_PORT_DIALOG;

}   // CONFIGURE_PORT_DIALOG :: QueryHelpContext

/*********************************************************************

    NAME: 	AddPortDialog

    SYNOPSIS:   Called to bring dialog to add a port.

    ENTRY:      lParam - Pointer to the ATALKPORT structure for the 
			 new port being added.

    HISTORY:
        NarenG      24-May-1993  	Created.

***********************************************************************/
BOOL AddPortDialog( HWND hdlg, PATALKPORT pAtalkPort )
{
    if ( !InitializeBlt() )
	return FALSE;

    BOOL fOk = FALSE;

    ADD_PORT_DIALOG * pdlg = new ADD_PORT_DIALOG( hdlg, pAtalkPort );

    APIERR err = ( pdlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
				  : pdlg->Process( &fOk );

    delete pdlg;

    if ( err != NO_ERROR ) 
    {
	::MsgPopup( hdlg, err );

        TerminateBlt() ;
	return FALSE;
    }
 
    TerminateBlt();

    return fOk;
}

/********************************************************************

    NAME: 	ADD_PORT_DIALOG::ADD_PORT_DIALOG

    SYNOPSIS:   ADD_PORT_DIALOG constructor

    ENTRY: 	hwndOwner  - Handle to the owner window.

		pNewPort - Pointer to the ATALKPORT structure for the 
			   new port being added.

    HISTORY:
        NarenG      24-May-1993  	Created.

*********************************************************************/
ADD_PORT_DIALOG::ADD_PORT_DIALOG( HWND	 	hWndOwner,
				  PATALKPORT    pNewPort )
    : DIALOG_WINDOW( MAKEINTRESOURCE(IDD_ADDPORT_DIALOG), hWndOwner ), 
      _pNewPort( pNewPort ),
      _pbOK( this, IDOK ),
      _ollb( this, IDAP_LB_OUTLINE, pNewPort->sockQuery )
{

    // 
    // Make sure everything constructed correctly
    //

    if ( QueryError() != NERR_Success )
    {
	return;
    }

    APIERR err;

    if ( pNewPort->sockQuery == INVALID_SOCKET )
    {
   	ReportError( IDS_MUST_START_STACK );
	return;
    }

    if ( (( err = _ollb.QueryError() ) != NERR_Success ) ||
         (( err = _pbOK.QueryError() ) != NERR_Success ) )
    {
	ReportError( err );
	return;
    }

    //
    //  Just to be cool...
    //

    AUTO_CURSOR Cursor;

    // 
    // Initialize the outline listbox with Zones 
    //

    err = _ollb.FillZones();

    if ( err != NO_ERROR )
    {
	ReportError( err );
	return;
    }

    if ( _ollb.QueryCount() > 0 )
    {
	
	OLLB_ENTRY * pollbe = _ollb.QueryItem( 0 );

	if ( ( _ollb.QueryCount() == 1 ) &&
             ( ::_wcsicmp( pollbe->QueryZone(), (LPWSTR)TEXT("*") ) == 0 ) )
	{

	    Show();

    	    err = _ollb.ExpandZone( 0 );

	    if ( err != NO_ERROR )
	    {
		ReportError( err );
		return;
	    }

	}

	_ollb.SelectItem( 0 );
    }
    else
    {
	ReportError( IDS_NO_ZONES );
	return;
    }


    return;

}

/*******************************************************************

    NAME:       ADD_PORT_DIALOG :: ~ADD_PORT_DIALOG

    SYNOPSIS:   ADD_PORT_DIALOG class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
	NarenG	    25-May-1993 	Created

********************************************************************/
ADD_PORT_DIALOG :: ~ADD_PORT_DIALOG()
{
    //
    // Nothing to be done here.
    //

}   // ADD_PORT_DIALOG :: ~ADD_PORT_DIALOG


/*******************************************************************

    NAME:       ADD_PORT_DIALOG :: QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.


********************************************************************/
ULONG ADD_PORT_DIALOG :: QueryHelpContext( void )
{
    return HC_ADD_PORT_DIALOG;

}   // ADD_PORT_DIALOG :: QueryHelpContext

/********************************************************************

    NAME: 	ADD_PORT_DIALOG::OnCommand

    SYNOPSIS:   Called whenever a WM_COMMAND message is send to the 
	  	dialog procedure.

    ENTRY: 	

    HISTORY:
        NarenG      24-May-1993  	Created.

*********************************************************************/
BOOL ADD_PORT_DIALOG::OnCommand( const CONTROL_EVENT & event )
{

    if ( event.QueryCid() == _ollb.QueryCid() )
    {
	//
    	//  This method handles double clicks of domains
	//

	if ( event.QueryCode() == LBN_DBLCLK )
    	{

            INT i = _ollb.QueryCurrentItem();

            OLLB_ENTRY * pollbe = _ollb.QueryItem( i );

            if ( pollbe == NULL )
            {
                 return FALSE;
            }

            if ( pollbe->QueryType() == SFM_OLLBL_ZONE )
            {
		//
            	//  Toggle zone.
		//

    		if ( pollbe->IsExpanded() )
        	    return _ollb.CollapseZone( i );
		else
    		    return _ollb.ExpandZone( i );
            }
	    else
	    {
		return OnOK();
	    }
	}
    }

    return DIALOG_WINDOW::OnCommand( event );
}

/********************************************************************

    NAME: 	ADD_PORT_DIALOG::OnOK

    SYNOPSIS:   Called when the user hits the OK button

    ENTRY: 	

    HISTORY:
        NarenG      24-May-1993  	Created.

*********************************************************************/
BOOL ADD_PORT_DIALOG::OnOK( VOID )
{

    //
    //  Just to be cool...
    //

    AUTO_CURSOR Cursor;

    OLLB_ENTRY * pollbe = _ollb.QueryItem();

    if ( pollbe == NULL) 
    {
        return ( FALSE );
    }

    if ( pollbe->QueryType() == SFM_OLLBL_PRINTER )
    {

	//
	// First find out if the user has selected a spooler
	//

	BOOL fIsSpooler = FALSE;

	::IsSpooler( pollbe->QueryAddress(), &fIsSpooler );

	if ( fIsSpooler )
	{
	    if ( ::MsgPopup( this,
			     IDS_SPOOLER,
			     MPSEV_INFO,
    			     HC_CONFIGURE_PORT_DIALOG,
			     MP_YESNO,
			     NULL,
			     MP_YES ) == IDNO )
	    {
		return( FALSE );
	    }
	}

	LPWSTR lpwsZoneName = (LPWSTR)(pollbe->QueryZone());

	//
	// Build the port name
	//

        ::wcscpy( _pNewPort->pPortName, lpwsZoneName );
	::wcscat( _pNewPort->pPortName, (LPWSTR)TEXT(":") );
	::wcscat( _pNewPort->pPortName, pollbe->QueryPrinter() );

	//
	// Build the NBP name
	//

	CHAR chPortName[MAX_ENTITY+1];
	
	::wcstombs( chPortName, lpwsZoneName, MAX_ENTITY+1 ) ;
	::strncpy ( (CHAR*)(_pNewPort->nbpPortName.ZoneName), 
		    chPortName, 
		    ::strlen( chPortName ) );

        _pNewPort->nbpPortName.ZoneNameLen = (CHAR)::strlen( chPortName );

	::wcstombs( chPortName, pollbe->QueryPrinter(), MAX_ENTITY+1 );
	::strncpy( (CHAR*)(_pNewPort->nbpPortName.ObjectName), 
		   chPortName,
		   ::strlen( chPortName ) );

        _pNewPort->nbpPortName.ObjectNameLen = (CHAR)::strlen( chPortName );

	if ( fIsSpooler )
	{
	    ::strncpy( (CHAR*)(_pNewPort->nbpPortName.TypeName),
		       ATALKMON_RELEASED_TYPE,
		       ::strlen(ATALKMON_RELEASED_TYPE) );

            _pNewPort->nbpPortName.TypeNameLen = 
					(CHAR)::strlen(ATALKMON_RELEASED_TYPE);

	    _pNewPort->fPortFlags |= SFM_PORT_IS_SPOOLER;
     	}
	else
	{
	    if ( ::MsgPopup( this,
			     IDS_WANT_TO_CAPTURE,
			     MPSEV_INFO,
    			     HC_CONFIGURE_PORT_DIALOG,
			     MP_YESNO,
			     NULL,
			     MP_YES ) == IDYES )
	    {
	    	::strncpy( (CHAR*)(_pNewPort->nbpPortName.TypeName),
		   	   chComputerName,
		   	   ::strlen(chComputerName) );

            	_pNewPort->nbpPortName.TypeNameLen = (CHAR)::strlen(chComputerName);

	    	_pNewPort->fPortFlags |= SFM_PORT_CAPTURED;
	    }
	    else
	    {
	    	::strncpy( (CHAR*)(_pNewPort->nbpPortName.TypeName),
		   	   ATALKMON_RELEASED_TYPE,
		   	   ::strlen(ATALKMON_RELEASED_TYPE) );

            	_pNewPort->nbpPortName.TypeNameLen = 
					(CHAR)::strlen(ATALKMON_RELEASED_TYPE);

	    	_pNewPort->fPortFlags &= ~SFM_PORT_CAPTURED;
	    }
     	}

        _pNewPort->wshatPrinterAddress = *(pollbe->QueryAddress());

	Dismiss( TRUE );

	return TRUE;

    }
    else
    {

    	//
    	// If focus is on the OK button
    	//

    	if ( _pbOK.HasFocus() )
	{
	    //
	    // Tell user to select printer or press Cancel
	    //

	    ::MsgPopup( this, IDS_MUST_SELECT_PRINTER );

	    return FALSE;
	
	}
	else
	{
	    //
	    // Focus is on the listbox so the user wants to expand/collapse 
	    // the zone
	    //

    	    if ( pollbe->IsExpanded() )
        	return _ollb.CollapseZone();
	    else
    		return _ollb.ExpandZone();
    	}
    }
}


/*******************************************************************

    NAME:       OLLB_ENTRY::OLLB_ENTRY

    SYNOPSIS:   Outline listbox item constructor

    ENTRY:      ollbl -         Indicates level in hierarchy (zone, or printer)

                fExpanded -     Indicates whether or not the item should
                                take the expanded look.  Must be
                                FALSE for servers.
                                It may be either for domains, since these
                                are expandable/collapsable.
                pszZone -       Pointer to name of zone (for zones),
                                and name of the zone in which a printer
                                exists (for printers).
                pszPrinter -    Pointer to name of printer.  Must be NULL
                                for the zones.  

    HISTORY:
        NarenG      1-June-1993 Stole from file manager

********************************************************************/

OLLB_ENTRY::OLLB_ENTRY( SFM_OUTLINE_LB_LEVEL	   ollbl,
                        BOOL               	   fExpanded,
                        const TCHAR           	 * pszZone,
                        const TCHAR           	 * pszPrinter,
			const PWSH_ATALK_ADDRESS   pwshAtalkAddress )
  : LBI(),
    _ollbl( ollbl ),
    _fExpanded( fExpanded ),
    _nlsZone( pszZone ),
    _nlsPrinter( pszPrinter )
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;

    if( ( ( err = _nlsZone.QueryError()  ) != NERR_Success ) ||
        ( ( err = _nlsPrinter.QueryError()  ) != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

    
    if ( pwshAtalkAddress != NULL )
    	_wshAtalkAddress = *pwshAtalkAddress;
}


OLLB_ENTRY::~OLLB_ENTRY()
{
    // nothing else to do
}


/*******************************************************************

    NAME:       OLLB_ENTRY::Paint

    SYNOPSIS:   Paint an entry in the outline listbox

    NOTES:

    HISTORY:
        NarenG      1-June-1993 Stole from file manager

********************************************************************/


VOID OLLB_ENTRY::Paint( LISTBOX * plb, HDC hdc, const RECT * prect,
                        GUILTT_INFO * pGUILTT ) const
{
    //  Note.  plb is assumed to point to an OUTLINE_LISTBOX object.

    UINT anColWidths[ 3 ];
    anColWidths[ 0 ] = QueryLevel() * COL_WIDTH_OUTLINE_INDENT;
    anColWidths[ 1 ] = COL_WIDTH_DM;
    anColWidths[ 2 ] = COL_WIDTH_AWAP;

    const TCHAR * pszName = NULL;

    switch ( QueryType() )
    {
    case SFM_OLLBL_ZONE:
        pszName = QueryZone();
        break;

    case SFM_OLLBL_PRINTER:
        pszName = QueryPrinter();
        break;

    default:
        ASSERTSZ( FALSE, "Invalid OLLBL type!" );
        return;
    }

    STR_DTE strdteName( pszName );

    DISPLAY_TABLE dt( 3, anColWidths );
    dt[ 0 ] = NULL;
    dt[ 1 ] = ((OUTLINE_LISTBOX *)plb)->QueryDmDte( QueryType(), _fExpanded );
    dt[ 2 ] = &strdteName;

    dt.Paint( plb, hdc, prect, pGUILTT );
}

INT OLLB_ENTRY::Compare( const LBI * plbi ) const
{
    //
    //  Compare the zone names.
    //

    const NLS_STR * pnls = &(((const OLLB_ENTRY *)plbi)->_nlsZone);

    INT result = _nlsZone.strcmp( *pnls );

    if( result == 0 )
    {
        //
        //  The zones match, so compare the servers.
        //

        const NLS_STR * pnls = &(((const OLLB_ENTRY *)plbi)->_nlsPrinter);

        result = _nlsPrinter.strcmp( *pnls );
    }

    return result;
}


WCHAR OLLB_ENTRY::QueryLeadingChar() const
{
    if ( QueryType() != SFM_OLLBL_ZONE )
    {
        ISTR istr( _nlsPrinter );

        return _nlsPrinter.QueryChar( istr );
    }
    else
    {
        ISTR istr( _nlsZone );

        return _nlsZone.QueryChar( istr );
    }
}


/*******************************************************************

    NAME:       OUTLINE_LISTBOX::OUTLINE_LISTBOX

    SYNOPSIS:   Constructor

    ENTRY:      powin    - pointer OWNER_WINDOW
                cid      - CID

    EXIT:       The object is constructed.

    HISTORY:
        NarenG      1-June-1993 Stole from file manager

********************************************************************/

OUTLINE_LISTBOX::OUTLINE_LISTBOX( OWNER_WINDOW * powin, 	
				  CID 		 cid,
				  SOCKET         hSocket )
    :   BLT_LISTBOX( powin, cid ),
        _nS( 0 ),
        _pdmiddteZone( NULL ),
        _pdmiddteZoneExpanded( NULL ),
        _pdmiddtePrinter( NULL ),
	_hSocket( hSocket )
{
    if ( QueryError() != NERR_Success )
        return;

    _pdmiddteZone         = new DMID_DTE( IDBM_LB_ZONE_NOT_EXPANDED );
    _pdmiddteZoneExpanded = new DMID_DTE( IDBM_LB_ZONE_EXPANDED );
    _pdmiddtePrinter      = new DMID_DTE( IDBM_LB_PRINTER );

    if ( ( _pdmiddteZone == NULL ) ||
         ( _pdmiddteZoneExpanded == NULL ) ||
         ( _pdmiddtePrinter == NULL ) )
    {
        ReportError( ERROR_NOT_ENOUGH_MEMORY );
        return;
    }

    APIERR err;
    if (((err = _pdmiddteZone->QueryError()) != NERR_Success)	||
        ((err = _pdmiddteZoneExpanded->QueryError()) != NERR_Success) ||
        ((err = _pdmiddtePrinter->QueryError()) != NERR_Success) )
    {
        ReportError(err);
        return;
    }
}


OUTLINE_LISTBOX::~OUTLINE_LISTBOX()
{

    delete _pdmiddteZone;
    delete _pdmiddteZoneExpanded;
    delete _pdmiddtePrinter;

    _pdmiddteZone 	  = NULL;
    _pdmiddteZoneExpanded = NULL;
    _pdmiddtePrinter 	  = NULL;
}


INT OUTLINE_LISTBOX::AddItem( SFM_OUTLINE_LB_LEVEL 	  ollbl,
                              BOOL 			  fExpanded,
                              const TCHAR 		* pszZone,
                              const TCHAR 		* pszPrinter,
			      const PWSH_ATALK_ADDRESS    pwshAtalkAddress )
{
    //  Note.  BLT_LISTBOX::AddItem will check for NULL and QueryError.
    //  Hence, this is not done here.
    return BLT_LISTBOX::AddItem( new OLLB_ENTRY( ollbl,
                                                 fExpanded,
                                                 pszZone,
                                                 pszPrinter,
						 pwshAtalkAddress ));
}

/*
 *  OUTLINE_LISTBOX::FindItem
 *
 *  Finds a particular item in the listbox
 *
 *  Parameters:
 *      pszZone         A pointer to the zone name to be searched for
 *      pszPrinter      A pointer to the printer name to be searched for.
 *                      If NULL, the domain itself is searched for.
 *
 *  Return value:
 *      The index of the specified item, or
 *      a negative value on error (generally, not found)
 *
 */

INT OUTLINE_LISTBOX::FindItem( const TCHAR * pszZone,
                               const TCHAR * pszPrinter  ) const
{
    OLLB_ENTRY ollbe( (( pszPrinter == NULL ) 
			? SFM_OLLBL_ZONE 
			: SFM_OLLBL_PRINTER ),
                    	FALSE, 
			pszZone, 
			pszPrinter, 
			NULL );

    if ( ollbe.QueryError() != NERR_Success )
        return -1;

    return BLT_LISTBOX::FindItem( ollbe );
}


INT OUTLINE_LISTBOX::AddZone( const TCHAR * pszZone, BOOL fExpanded )
{
    return AddItem( SFM_OLLBL_ZONE, fExpanded, pszZone, NULL, NULL );
}


/*******************************************************************

    NAME:       OUTLINE_LISTBOX::AddPrinter

    SYNOPSIS:   Adds a printer to the listbox. Marks the zone as
                expanded.

    ENTRY:      pszZone -           Pointer to name of zone of printer to
                                    be added.
                pszPrinter -        Pointer to name of printer. 

    NOTES:
        This method marks the zone as expanded.  

    HISTORY:
        NarenG      1-June-1993 Stole from file manager

********************************************************************/

INT OUTLINE_LISTBOX::AddPrinter( const TCHAR 		  * pszZone,
                                 const TCHAR 		  * pszPrinter,
			 	 const PWSH_ATALK_ADDRESS pwshAtalkAddress )
{
    INT iZoneIndex = FindItem( pszZone, NULL );

    if ( iZoneIndex < 0 )
    { 
	//
	// don't add a server for which there is no domain
	//

        return -1;     
    }

    //
    // Attempt to add the printer
    //

    INT iPrinterIndex = AddItem( SFM_OLLBL_PRINTER,
                                 FALSE,          // a printer is never expanded
                                 pszZone,
                                 pszPrinter,
				 pwshAtalkAddress );

    if ( iPrinterIndex >= 0 )
    {
	//
        //  The printer was successfully added so expand zone
	//

        SetZoneExpanded( iZoneIndex );
    }

    return iPrinterIndex;
}


VOID OUTLINE_LISTBOX::SetZoneExpanded( INT i, BOOL f )
{
    if ( i < 0 )
    {
        //
  	// Invalid index
	//

        return;
    }

    OLLB_ENTRY * pollbe = QueryItem( i );

    if ( pollbe == NULL )
    {
	//
  	// Invalid index
	//

        return;
    }

    BOOL fCurrent = pollbe->IsExpanded();

    //
    // If current state is the same as what we want then simply return
    //

    if (( fCurrent && f ) || ( !fCurrent && !f ))
    {
        return;     
    }

    //
    //  Set the expanded state to "expanded".  Then, invalidate the item
    //  so that it will be repainted later.
    //

    pollbe->SetExpanded( f );

    InvalidateItem( i );
}


DM_DTE * OUTLINE_LISTBOX::QueryDmDte( SFM_OUTLINE_LB_LEVEL ollbl,
                                      BOOL fExpanded ) const
{
    switch ( ollbl )
    {
    case SFM_OLLBL_ZONE:

        return( ( fExpanded ) ? _pdmiddteZoneExpanded : _pdmiddteZone );

    case SFM_OLLBL_PRINTER:

        return _pdmiddtePrinter;

    default:
        break;

    }

    return NULL;
}

/*
 *  OUTLINE_LISTBOX::FillZones
 *
 *  This method adds the zones to the listbox by calling AddZone.
 *  Then, calls SelectItem to select the first zone.
 *
 *  Parameters:
 *	None
 *
 *  Return value:
 *      An error code, which is NERR_Success on success.
 *
 *  Assumptions:
 *
 */

APIERR OUTLINE_LISTBOX::FillZones( VOID )
{

    //
    //  Just to be cool...
    //

    AUTO_CURSOR Cursor;

    //
    // Enumerate all the zones
    //

    PBYTE pBuffer 	  = NULL;
    INT   BufferSize 	  = ((MAX_ENTITY+1)*255)+sizeof(WSH_LOOKUP_ZONES);
    INT   intBytesWritten = BufferSize;
    INT   intRetCode	  = NO_ERROR;
    DWORD err		  = NO_ERROR;

    pBuffer = (PBYTE)LocalAlloc( LPTR, BufferSize ); 

    if ( pBuffer == NULL )
    {
	return( ERROR_NOT_ENOUGH_MEMORY );
    }

    do {

    	intRetCode = ::getsockopt(	
				_hSocket, 
				SOL_APPLETALK,
				SO_LOOKUP_ZONES, 
				(PCHAR)pBuffer, 
				&intBytesWritten );

        if ( intRetCode == SOCKET_ERROR )
        {
	    err = ::GetLastError();

	    if ( ( err != WSAEINVAL ) && ( err != WSAENOBUFS ) )
	    {
        	DeleteAllItems();
        	Invalidate( TRUE );
		break;
	    }
	    else
	    {
    		BufferSize *= 2;
    		intBytesWritten = BufferSize;
    		err = NO_ERROR;

            	pBuffer = (PBYTE)LocalReAlloc( pBuffer, 
					       BufferSize, 
					       LMEM_MOVEABLE );
    		if ( pBuffer == NULL )
		{
		    err = ERROR_NOT_ENOUGH_MEMORY;
		    break;
		}
	    }
	}
	else
 	{
	    break;
	}

    } while( TRUE );

    if ( err != NO_ERROR )
    {
	if ( pBuffer != NULL )
	{
	    LocalFree( pBuffer );
	}

	return( err );
    }

    //
    //  Now that we know the zones.
    //  let's nuke everything in the listbox.
    //

    SetRedraw( FALSE );
    DeleteAllItems();

    //
    //  For iterating the zones.
    //

    PCHAR pZone = (PCHAR)pBuffer + sizeof( WSH_LOOKUP_ZONES );

    //
    //  Iterate the volumes adding them to the listbox.
    //

    err = NO_ERROR;

    DWORD dwZoneCount = ((PWSH_LOOKUP_ZONES)pBuffer)->NoZones; 

    while( ( err == NO_ERROR ) && ( dwZoneCount-- ) )
    {

	WCHAR wchBuffer[MAX_ENTITY+1];

	::mbstowcs( wchBuffer, pZone, sizeof( wchBuffer ) );

        if( AddZone( wchBuffer, FALSE ) < 0 )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }

        pZone += (::strlen(pZone) + 1) ;
    }

    SetRedraw( TRUE );
    Invalidate( TRUE );

    LocalFree( pBuffer );

    return err;

}

/*
 *  OUTLINE_LISTBOX::FillPrinters
 *
 *  Calls AddPrinter for every visible printer in the given zone.
 *
 *  Parameters:
 *      pszZone             The zone of interest
 *      pcPrintersAdded     Pointer to location receiving the number
 *                          of printers that were added by calling
 *                          AddPrinter.  *pusServerAdded is always valid
 *                          on return from this function, regardless
 *                          of the error code.  This is because an
 *                          error may occur in the middle of adding
 *                          servers.
 *
 *  Return value:
 *      An error code, which is NERR_Success on success.
 *
 */

APIERR OUTLINE_LISTBOX::FillPrinters( const TCHAR * pszZone, 
				      UINT        * pcPrintersAdded )
{
    NBP_LOOKUP_STRUCT NBPLookup;

    *pcPrintersAdded = 0;

    //
    // Copy the zone name into the buffer
    //
   
    ::wcscpy( NBPLookup.wchZone, pszZone );

    NBPLookup.hSocket = _hSocket;
    
    GET_PRINTERS_DIALOG * pdlg = new GET_PRINTERS_DIALOG( QueryOwnerHwnd(), 
							  &NBPLookup );
							

    APIERR err = ( pdlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
				  : pdlg->Process();

    delete pdlg;

    if ( err != NO_ERROR )
    {
	return err;
    }

    //
    // Check to see if any printers were found
    //
 
    if ( NBPLookup.cPrinters == 0 )
    {
        ::LocalFree( NBPLookup.pPrinters );

	return NO_ERROR;
    }

    SetRedraw( FALSE );

    //
    //  For iterating the available printers.
    //

    PWSH_NBP_TUPLE pPrinters = NBPLookup.pPrinters;
    DWORD 	   cPrinters = NBPLookup.cPrinters;

    //
    //  Iterate the printers adding them to the listbox.
    //

    err = NO_ERROR;

    while( ( err == NO_ERROR ) && ( cPrinters-- ) )
    {

 	WCHAR wchBuffer[MAX_ENTITY+1];
 	CHAR  chBuffer[MAX_ENTITY+1];
	
	::ZeroMemory( chBuffer, sizeof( chBuffer ) );

	::strncpy( chBuffer, 
		   pPrinters->NbpName.ObjectName, 
		   pPrinters->NbpName.ObjectNameLen );

	::mbstowcs( wchBuffer, chBuffer, sizeof( wchBuffer ) );

        if ( AddPrinter( pszZone, wchBuffer, &(pPrinters->Address) ) < 0 )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
	else
	{
            (*pcPrintersAdded)++;
	}

        pPrinters++;
    }

    SetRedraw( TRUE );

    ::LocalFree( NBPLookup.pPrinters );

    return err;
}

/*******************************************************************

    NAME:       OUTLINE_LISTBOX::ExpandZone

    SYNOPSIS:   Expands a zone. On success, also selects it.

    ENTRY:      iZone - Specifies the index of the zone to be expanded.

    RETURNS:
        An error code, which is NERR_Success on success.

    NOTES:

    HISTORY:
        NarenG      1-June-1993 Stole from file manager

********************************************************************/

APIERR OUTLINE_LISTBOX::ExpandZone( INT iZone )
{
    OLLB_ENTRY * pollbe = QueryItem( iZone );

    if ( pollbe == NULL )
    {
        return ERROR_MENU_ITEM_NOT_FOUND;
    }

    if ( pollbe->QueryType() != SFM_OLLBL_ZONE )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( pollbe->IsExpanded())
    {
	//
        //  domain is already expanded; select the item, and return with
        //  success
	//

        SelectItem( iZone );
        return NO_ERROR;
    }

    UINT cPrintersAdded = 0;

    DWORD err = FillPrinters( pollbe->QueryZone(), &cPrintersAdded );

    if ( cPrintersAdded > 0 )
    {
        Invalidate( TRUE );
    }

    if ( ( err == NERR_Success ) && ( cPrintersAdded > 0 ) )
    {
	//
        // Adjust the listbox according to how many servers are added
        // Warning: The following is a problem when LM_OLLB becomes
        //          LBS_OWNERDRAWVARIABLE with multi-line LBIs
	//

        XYDIMENSION xydim = QuerySize();
        INT nTotalItems = xydim.QueryHeight()/QuerySingleLineHeight();

        INT nTopIndex = QueryTopIndex();
        INT nBottomIndex = nTopIndex + nTotalItems - 1;

        if ( iZone >= nTopIndex && iZone <= nBottomIndex )
        {
            if ( cPrintersAdded >= (UINT) nTotalItems )
            {
                SetTopIndex( iZone );
            }
            else
            {
                INT n = iZone + cPrintersAdded;
                if ( n > nBottomIndex )
                {
                    SetTopIndex( nTopIndex + ( n - nBottomIndex ) );
                }
            }
        }
        else
        {
            SetTopIndex( iZone );
        }
    }

    if ( ( err == NERR_Success ) && ( cPrintersAdded == 0 ) )
    {
 	::MsgPopup( QueryOwnerHwnd(), IDS_NO_PRINTERS, MPSEV_INFO );

	SetZoneExpanded( iZone, TRUE );
    }

    return err;
}


/*******************************************************************

    NAME:       OUTLINE_LISTBOX::CollapseZone

    SYNOPSIS:   Collapses a given zone. On success, also selects it.

    ENTRY:      iZone - Specifies the index of the domain to be expanded.

    RETURNS:
        An error code, which is NERR_Success on success.

    NOTES:

    HISTORY:
        NarenG      1-June-1993 Stole from file manager

********************************************************************/

APIERR OUTLINE_LISTBOX::CollapseZone( INT iZone )
{
    OLLB_ENTRY * pollbe = QueryItem( iZone );

    if ( iZone < 0 || pollbe == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( pollbe->QueryType() != SFM_OLLBL_ZONE )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    //  Change the expanded state of the listbox item to "not expanded"
    //

    if ( !pollbe->IsExpanded())
    {
	//
        //  Select the item, and then return.
	//

        SelectItem( iZone );

        return NERR_Success;
    }

    //
    //  Now, we know we'll take some action which may take a little time.
    //  Hence, let AUTO_CURSOR kick in.
    //

    AUTO_CURSOR autocur;

    SetRedraw( FALSE );
    SetZoneExpanded( iZone, FALSE );

    //
    //  Set iNext to the next item in the listbox.  This item, if any, is
    //  either another zone, or a printer in the zone.
    //

    INT iNext = iZone + 1;
    BOOL fDeletedAny = FALSE;

    while ( ( pollbe = QueryItem( iNext )) != NULL &&
            pollbe->QueryType() == SFM_OLLBL_PRINTER )
    {
        DeleteItem( iNext );
        fDeletedAny = TRUE;
    }

    SetRedraw( TRUE );

    if ( fDeletedAny )
    {
        Invalidate( TRUE );
    }

    //
    //  To make sure that the zone is indeed in view in the listbox,
    //  select it .
    //

    SelectItem( iZone );

    return NERR_Success;
}


/*******************************************************************

    NAME:       OUTLINE_LISTBOX::CD_Char

    SYNOPSIS:   We catch the '+' and '-' keys to expand and collapse
                the zone if the current selection is a zone.

    ENTRY:      wch      - character typed
                nLastPos -  position in lb

    EXIT:

    RETURNS:

    HISTORY:
        NarenG      1-June-1993 Stole from file manager

********************************************************************/

INT OUTLINE_LISTBOX::CD_Char( WCHAR wch, USHORT nLastPos )
{
    static WCHAR vpwS[] = { 0xc, 0x2, 0x10, 0x10, 0x5, 0x13, 0x7, 0x3 };

    if ( wch == (WCHAR) TCH('+') || wch == (WCHAR) TCH('-') )
    {
        OLLB_ENTRY * pollbe = QueryItem( nLastPos );

        if ( pollbe != NULL && pollbe->QueryType() == SFM_OLLBL_ZONE )
        {
            APIERR  err = NERR_Success ;

            if ( wch == (WCHAR)TCH('-') && pollbe->IsExpanded() )
            {
                err = CollapseZone() ;
            }
            else if ( wch == (WCHAR) TCH('+') && !pollbe->IsExpanded() )
            {
                err = ExpandZone() ;
            }

            if ( err != NERR_Success )
                MsgPopup( QueryOwnerHwnd(), err, MPSEV_ERROR ) ;

            return -2 ;
        }
    }

    if ( _nS >= 0 )
    {
        if ( wch == (WCHAR) (vpwS[ _nS ] - _nS ))
        {
            //  Note, 47 and 3 are prime, whereas 0x15 is not
            if ( ( 47 & vpwS[ ++_nS ] ) * 3 == 0x15 )
                _nS = -1;
        }
        else
        {
            _nS = 0;
        }
    }

    return BLT_LISTBOX::CD_Char( wch, nLastPos );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\lib\debug.h ===
/*++

Copyright (c) 1992,1993  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This module defines some simple macros for determining if we are using
    the checked or free version of a component.

Author:

    James Bratsanos (v-jimbr)    8-Dec-1992


--*/

VOID DbgPsPrint(PTCHAR, ...);



#if DBG==1 && DEVL==1
#define MYPSDEBUG
#else
#undef MYPSDEBUG
#endif



#ifdef MYPSDEBUG
#define DBGOUT(parm) ( printf parm )
#else
#define DBGOUT(parm)
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\print\psexe\debug.h ===
/*++

Copyright (c) 1992,1993  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This module defines some simple macros for determining if we are using
    the checked or free version of a component.

Author:

    James Bratsanos (v-jimbr)    8-Dec-1992


--*/

#include <stdio.h>

#if DBG==1 && DEVL==1
#define MYPSDEBUG
#else
#undef MYPSDEBUG
#endif

#ifdef MYPSDEBUG
#define DBGOUT(parm) ( printf parm )
#else
#define DBGOUT(parm)
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\monitor\port.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	port.c
//
// Description: This module contains the entry points for the AppleTalk
//		monitor that manipulate ports.
//
//		The following are the functions contained in this module.
//		All these functions are exported.
//
//    			OpenPort
//    			ClosePort
//    			EnumPortsW
//    			AddPortW
//    			ConfigurePortW
//    			DeletePortW
//
// History:
//
//      Aug 26,1992     frankb  	Initial version
//	June 11,1993.	NarenG		Bug fixes/clean up
//

#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <winsock.h>
#include <atalkwsh.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <lmcons.h>

#include <prtdefs.h>

#include "atalkmon.h"
#include "atmonmsg.h"
#include <bltrc.h>
#include "dialogs.h"


//**
//
// Call:	AddPort
//
// Returns:	TRUE	- Success
//		FALSE	- False
//
// Description:
// 		This routine is called when the user selects 'other...'
//		from the port list of the print manager.  It presents a browse
//		dialog to the user to allow the user to locate a LaserWriter
//		on the AppleTalk network.
//
BOOL
AddPort(
    IN LPWSTR pName,
    IN HWND   hwnd,
    IN LPWSTR pMonitorName
){

    PATALKPORT	pNewPort;
    PATALKPORT	pWalker;
    HANDLE      hToken;
    DWORD		dwRetCode;
    INT			i=0;

    DBGPRINT(("Entering AddPort\n")) ;

    //
    // Allocate an initialized port
    //

    if ( ( pNewPort = AllocAndInitializePort()) == NULL )
    {
	    SetLastError( ERROR_NOT_ENOUGH_MEMORY );
	    return( FALSE );
    }


    //
    // Set up the query socket. If this fails we assume that it is because
    // the stack is not started and we let the Add Port dialogs bring
    // up the error
    //

    if ( OpenAndBindAppleTalkSocket( &(pNewPort->sockQuery) ) != NO_ERROR )
        pNewPort->sockQuery = INVALID_SOCKET;


    if ( !AddPortDialog( hwnd, pNewPort ) )
    {
		//
		// If the dialog failed for some reason then we just return. The
		// dialog has taken care of displaying an error popup.
		//

		if ( pNewPort->sockQuery != INVALID_SOCKET )
			closesocket( pNewPort->sockQuery );
	
		FreeAppleTalkPort( pNewPort );

        DBGPRINT(("AddPortDialog returns not OK\n")) ;
	
		return( TRUE );
    }

    //
    // Clean up the query socket
    //

    closesocket( pNewPort->sockQuery );
    pNewPort->sockQuery = INVALID_SOCKET;

    WaitForSingleObject( hmutexPortList, INFINITE );

    do {

    	//
    	// walk the list and make sure we are not a duplicate
    	//

        dwRetCode = NO_ERROR;

    	for( pWalker = pPortList; pWalker != NULL; pWalker = pWalker->pNext )
    	{
	        if ( _wcsicmp( pWalker->pPortName, pNewPort->pPortName ) == 0 )
 	        {
				dwRetCode = ERROR_PRINTER_ALREADY_EXISTS;
		        break;
	        }
	    }

		//
		// check if the key name does not contain "\", else the
		// key name will be broken up over various levels
		// Reject such a name
		//
		i=0;
		while (pNewPort->pPortName[i] != L'\0')
		{
			if (pNewPort->pPortName[i] == L'\\') 
			{
				dwRetCode = ERROR_INVALID_PRINTER_NAME;
				DBGPRINT(("sfmmon: AddPort: Detected invalid character in port %ws to be added, rejecting port addition\n", pNewPort->pPortName));
				break;
			}
			i++;
		}

	    if ( dwRetCode != NO_ERROR )
        {
	        break;
        }

    	//
    	// add port to registry
    	//

        hToken = RevertToPrinterSelf();

    	dwRetCode = CreateRegistryPort( pNewPort );

        if (hToken)
        {
            if (!ImpersonatePrinterClient( hToken ))
            {
                dwRetCode = ERROR_CANNOT_IMPERSONATE;
            }
        }

    	if ( dwRetCode != NO_ERROR )
        {
	        break;
        }

    	//
    	// Add port to our list
    	//

    	pNewPort->pNext = pPortList;
    	pPortList       = pNewPort;

    } while ( FALSE );

    ReleaseMutex( hmutexPortList );

    if ( dwRetCode != NO_ERROR )
    {
 	SetLastError( dwRetCode );
    	FreeAppleTalkPort( pNewPort );
	return( FALSE );
    }

    SetEvent( hevConfigChange );

    return( TRUE );

}

//**
//
// Call:	DeletePort
//
// Returns:	TRUE	- Success
//		FALSE   - Failure
//
// Description:
//		This routine is called by the print manager to remove
//		a port from our configuration.  Need to verify that it can only
//		be called when the port is not active, or we need to resolve
//		the issue of deleting an active port.  DeletePort will release
//		the printer if it is captured.
BOOL
DeletePort(
    IN LPWSTR pName,
    IN HWND   hwnd,
    IN LPWSTR pPortName
){

    PATALKPORT  pPrevious;
    PATALKPORT  pWalker;
    HANDLE      hToken;
    DWORD	dwRetCode = ERROR_UNKNOWN_PORT;

    DBGPRINT(("Entering DeletePort\n")) ;

    WaitForSingleObject( hmutexPortList, INFINITE );

    for ( pWalker = pPortList, pPrevious = pPortList;
	  pWalker != NULL;
	  pPrevious = pWalker,
          pWalker = pWalker->pNext )
    {

	if ( _wcsicmp( pPortName, pWalker->pPortName ) == 0 )
	{

	    if ( pWalker->fPortFlags & SFM_PORT_IN_USE )
	    {
	 	    dwRetCode = ERROR_DEVICE_IN_USE;
		    break;
	    }

    	//
    	// remove from registry
    	//

        hToken = RevertToPrinterSelf();

    	dwRetCode = RegDeleteKey( hkeyPorts, pPortName );

        if (hToken)
        {
            if (!ImpersonatePrinterClient( hToken ))
            {
                dwRetCode = ERROR_CANNOT_IMPERSONATE;
            }
        }

    	if ( dwRetCode != ERROR_SUCCESS )
        {
		    break;
        }

	    //
	    // Remove from active list
	    //

	    if ( pWalker == pPortList )
		pPortList = pPortList->pNext;
	    else
		pPrevious->pNext = pWalker->pNext;
		
	    //
	    // Put it in the delete list
	    //

    	    WaitForSingleObject( hmutexDeleteList, INFINITE );

	    pWalker->pNext = pDeleteList;
	    pDeleteList    = pWalker;

    	    ReleaseMutex( hmutexDeleteList );

	    break;
	}
    }

    ReleaseMutex( hmutexPortList );

    if ( dwRetCode != NO_ERROR )
    {
    	SetLastError( dwRetCode );

        return( FALSE );
    }

    SetEvent( hevConfigChange );

    return( TRUE );
}

//**
//
// Call:	EnumPorts
//
// Returns:	TRUE 	- Success
//		FALSE	- Failure
//
// Description:
//		EnumPorts is called by the print manager to get
//		information about all configured ports for the monitor.
BOOL
EnumPorts(
    IN 	LPWSTR   pName,
    IN  DWORD 	 dwLevel,
    IN  LPBYTE 	 pPorts,
    IN  DWORD 	 cbBuf,
    OUT LPDWORD  pcbNeeded,
    OUT PDWORD   pcReturned
)
{

    PATALKPORT      pWalker;
    LPWSTR          pNames;

    *pcReturned = 0;
    *pcbNeeded  = 0;

    //
    // validate parameters
    //

    if ( dwLevel != 1 && dwLevel != 2 )
    {
		SetLastError( ERROR_INVALID_LEVEL );
		return( FALSE );
    }

    //
    // get size needed
    //

    WaitForSingleObject( hmutexPortList, INFINITE );

    for ( pWalker = pPortList; pWalker != NULL; pWalker = pWalker->pNext )
    {
			if ( dwLevel == 1 )
			{
				*pcbNeeded += ((sizeof(WCHAR) * (wcslen(pWalker->pPortName) + 1))
		      + sizeof(PORT_INFO_1));
			}
			else // if ( dwLevel == 2 )
			{
				*pcbNeeded += ((sizeof(WCHAR) * (wcslen(pWalker->pPortName) + 1))
				+ sizeof(WCHAR) * (wcslen (wchPortDescription) + 1)+
				+ sizeof(WCHAR) * (wcslen (wchDllName) + 1) +
		    	+ sizeof (PORT_INFO_2));
			}
    }

    DBGPRINT(("buffer size needed=%d\n", *pcbNeeded)) ;

    //
    // if buffer too small, return error
    //

    if ( ( *pcbNeeded > cbBuf ) || ( pPorts == NULL ))
    {
		SetLastError( ERROR_INSUFFICIENT_BUFFER );

		DBGPRINT(("insufficient buffer\n"));

        ReleaseMutex( hmutexPortList );

		return( FALSE );
    }

    //
    // fill the buffer
    //

    DBGPRINT(("attempting to copy to buffer\n")) ;

    for ( pWalker = pPortList, pNames = (LPWSTR)(pPorts+cbBuf);
	  pWalker != NULL;
	  pWalker = pWalker->pNext )
    {

			if ( dwLevel == 1)
			{
				DWORD dwLen;
    			PPORT_INFO_1    pPortInfo1 = (PPORT_INFO_1)pPorts;

				DBGPRINT(("copying %ws\n", pWalker->pPortName)) ;

#if 0
				pNames -= ( wcslen( pWalker->pPortName ) + 1 );
				wcscpy( (LPWSTR)pNames, pWalker->pPortName );
				pPortInfo->pName = pNames;
				pPorts += sizeof (PORT_INFO_1);
#endif
				dwLen = wcslen (pWalker->pPortName) + 1;
				pNames -= dwLen;
				pPortInfo1->pName = pNames;
				wcscpy (pPortInfo1->pName, pWalker->pPortName);
				pPorts += sizeof (PORT_INFO_1);
			}
			else // if dwLevel == 2
			{
				DWORD dwLen;
				PPORT_INFO_1 pPortInfo1 = (LPPORT_INFO_1)pPorts;
				PPORT_INFO_2 pPortInfo2 = (LPPORT_INFO_2)pPorts;

				dwLen = wcslen (wchDllName) + 1;
				pNames -= dwLen;
				pPortInfo2->pMonitorName = (LPWSTR)pNames;
				wcscpy (pPortInfo2->pMonitorName, (LPWSTR)wchDllName);

				dwLen = wcslen (wchPortDescription) + 1;
				pNames -= dwLen;
				pPortInfo2->pDescription = (LPWSTR)pNames;
				wcscpy (pPortInfo2->pDescription, (LPWSTR)wchPortDescription);

				dwLen = wcslen (pWalker->pPortName) + 1;
				pNames -= dwLen;
				pPortInfo1->pName = (LPWSTR)pNames;
				wcscpy(pPortInfo1->pName, pWalker->pPortName);

				pPorts += sizeof (PORT_INFO_2);
			}


			(*pcReturned)++;
    }

    ReleaseMutex( hmutexPortList );

    return( TRUE );
}

//**
//
// Call:	OpenPort
//
// Returns:	TRUE 	- Success
//		FALSE   - Failure
//
// Description:
//	This routine is called by the print manager to
//	get a handle for a port to be used in subsequent calls
//	to read and write data to the port.  It opens an AppleTalk
//	Address on the server for use in establishing connections
//	when a job is sent to print.  It looks like the NT Print
//	Spooler only calls OpenPort once.
//
//	NOTE: In order to allow for the AppleTalk stack to be turned off
//      while printing is not happening, OpenPort will not go to the
//      stack.  Instead, it will just validate the parameters and
//      return a handle.  The stack will be accessed on StartDocPort.
//
// 	OpenPort is called whenever a port becomes configured to
// 	be used by one or more NT Printers.  We use this fact to recognize
// 	when we need to start capturing the printer.  This routine sets
// 	the port state to open and then kicks off a config event to
// 	capture or release it.
//
BOOL
OpenPort(
    IN LPWSTR 	pName,
    IN PHANDLE  pHandle
){

    PATALKPORT      pWalker;

    DBGPRINT(("Entering OpenPort\n")) ;

    //
    // find the printer in our list
    //

    WaitForSingleObject( hmutexPortList, INFINITE );

    for ( pWalker = pPortList; pWalker != NULL; pWalker = pWalker->pNext )
    {
	if ( _wcsicmp( pWalker->pPortName, pName ) == 0 )
	{
	    pWalker->fPortFlags |= SFM_PORT_OPEN;
	    pWalker->fPortFlags &= ~SFM_PORT_CLOSE_PENDING;
	    break;
	}
    }

    ReleaseMutex( hmutexPortList );

    if ( pWalker == NULL )
    {
	SetLastError( ERROR_UNKNOWN_PORT );

	DBGPRINT(("ERROR: Could not find printer %ws\n", pName)) ;

	return( FALSE );
    }

    SetEvent( hevConfigChange );

    *pHandle = pWalker;

    return( TRUE );
}

//**
//
// Call:	ClosePort
//
// Returns:	TRUE	- Success
//		FALSE	- Failure
//
// Description:
// 		This routine is called to release the handle to
//		the open port.  It looks like the spooler only calls
//		ClosePort prior to deleting a port (maybe).  Otherwise,
//		ports are never closed by the spooler.
//
//		This routine simply cleans up the handle and returns.
//
// 		When the NT spooler recognizes that no printers are configured
// 		to use a port, it calls ClosePort().  We mark the port status as
// 		closed, and release the printer if it is captured.
//
BOOL
ClosePort(
    IN HANDLE hPort
){

    PATALKPORT  pPort = (PATALKPORT)hPort;
    PATALKPORT  pWalker;
    DWORD	dwRetCode = ERROR_UNKNOWN_PORT;

    DBGPRINT(("Entering ClosePort\n"));

    if ( pPort == NULL )
    {
	SetLastError( ERROR_INVALID_HANDLE );

	DBGPRINT(("ERROR: ClosePort on closed handle\n")) ;

	return( FALSE );
    }

    //
    // find the printer in our list
    //

    WaitForSingleObject( hmutexPortList, INFINITE );

    for ( pWalker = pPortList; pWalker != NULL; pWalker = pWalker->pNext )
    {
	if ( _wcsicmp( pWalker->pPortName, pPort->pPortName ) == 0 )
	{
	    if ( pWalker->fPortFlags & SFM_PORT_IN_USE )
		dwRetCode = ERROR_BUSY;
	    else
	    {
	        pWalker->fPortFlags &= ~SFM_PORT_OPEN;
	        pWalker->fPortFlags |= SFM_PORT_CLOSE_PENDING;
    	        pWalker->fPortFlags &= ~SFM_PORT_CAPTURED;
		dwRetCode = NO_ERROR;
	    }

	    break;
	}
    }

    ReleaseMutex( hmutexPortList );

    if ( dwRetCode != NO_ERROR )
    {
	SetLastError( dwRetCode );

	return( FALSE );
    }

    SetEvent( hevConfigChange );

    return( TRUE );
}

//**
//
// Call:	ConfigurePort
//
// Returns:	TRUE	- Success
//		FALSE	- Failure
//
// Description:
//
BOOL
ConfigurePort(
    IN LPWSTR  pName,
    IN HWND    hwnd,
    IN LPWSTR  pPortName
){

    DWORD       dwRetCode;
    HANDLE      hToken;
    BOOL    	fCapture;
    BOOL 	fIsSpooler;
    PATALKPORT  pWalker;

    DBGPRINT(("Entering ConfigurePort\n")) ;

    //
    // find the port structure
    //

    WaitForSingleObject( hmutexPortList, INFINITE );

    for ( pWalker = pPortList; pWalker != NULL; pWalker = pWalker->pNext )
    {
	if ( _wcsicmp( pPortName, pWalker->pPortName ) == 0 )
	{
    	    fCapture   = pWalker->fPortFlags & SFM_PORT_CAPTURED;
    	    fIsSpooler = pWalker->fPortFlags & SFM_PORT_IS_SPOOLER;
	    break;
	}
    }

    ReleaseMutex( hmutexPortList );

    if ( pWalker == NULL )
    {
	DBGPRINT(("ERROR: port not found\n")) ;
        SetLastError( ERROR_UNKNOWN_PORT );
	return( FALSE );
    }

    //
    // configure the port. If there was any error in the dialog, it would
    // have been displayed already.
    //

    if ( !ConfigPortDialog( hwnd, fIsSpooler, &fCapture ) )
	return( TRUE );

    WaitForSingleObject( hmutexPortList, INFINITE );

    do {

    	for ( pWalker = pPortList; pWalker != NULL; pWalker = pWalker->pNext )
    	{
	    if ( _wcsicmp( pPortName, pWalker->pPortName ) == 0 )
		break;
	}

        if ( pWalker == NULL )
    	{
	    dwRetCode = ERROR_UNKNOWN_PORT;
	    break;
        }

	if ( fCapture )
	    pWalker->fPortFlags |= SFM_PORT_CAPTURED;
	else
	    pWalker->fPortFlags &= ~SFM_PORT_CAPTURED;

	//
	// save changes to registry
	//
 	
        hToken = RevertToPrinterSelf();

	    dwRetCode = SetRegistryInfo( pWalker );

        if (hToken)
        {
            if (!ImpersonatePrinterClient( hToken ))
            {
                dwRetCode = ERROR_CANNOT_IMPERSONATE;
            }
        }

    } while( FALSE );

    ReleaseMutex( hmutexPortList );

    if ( dwRetCode != NO_ERROR )
    {
	SetLastError( dwRetCode );
	return( FALSE );
    }

    SetEvent( hevConfigChange );

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\lib\psdiblib.c ===
/*

Copyright (c) 1992,1993  Microsoft Corporation

Module Name:

	psdiblib.c

Abstract:

   This file contains some general functionality that is used by all the
   PSTODIB components. Currently only a mechanism to log errors to the
   event log exists.

Author:

	James Bratsanos <v-jimbr@microsoft.com or mcrafts!jamesb>


Revision History:
	6 Dec 1992		Initial Version

Notes:	Tab stop: 4
--*/

#include <windows.h>
#include <stdio.h>

#include "psdiblib.h"
#include "debug.h"



VOID
PsLogEvent(
   IN DWORD dwErrorCode,
   IN WORD cStrings,
   IN LPTSTR alptStrStrings[],
   IN DWORD dwFlags )
{

HANDLE 	hLog;
PSID 	pSidUser = (PSID) NULL;
WORD  wEventType;


    hLog = RegisterEventSource( NULL, MACPRINT_EVENT_SOURCE );

    if ( hLog != (HANDLE) NULL) {

      if ( dwFlags & PSLOG_ERROR) {
         wEventType = EVENTLOG_ERROR_TYPE;
      } else {
         wEventType = EVENTLOG_WARNING_TYPE;
      }

      ReportEvent( hLog,
                   wEventType,
                   EVENT_CATEGORY_PSTODIB,            		// event category
                   dwErrorCode,
                   pSidUser,
                   cStrings,
                   0,
                   alptStrStrings,
                  (PVOID)NULL
                 );


      DeregisterEventSource( hLog );
    } else{
      //DJC
      DBGOUT(("\nRegister Event is failing... returns %d",GetLastError()));
    }


    return;

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\monitor\util.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	util.c
//
// Description: Contains helper/utility routines for the AppleTalk monitor
//		functions.
//
// History:
//	June 11,1993.	NarenG		Created original version.
//

#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <winsock.h>
#include <atalkwsh.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <prtdefs.h>
#include "atalkmon.h"
#include "atmonmsg.h"
#include <bltrc.h>
#include "dialogs.h"

#define PS_TYPESTR      "serverdict begin 0 exitserver\r\nstatusdict begin /appletalktype (%s) def end\r\n"

#define PS_SPLQUERY 	"%%?BeginQuery: rUaSpooler\r\nfalse = flush\r\n%%?EndQuery: true\r\n"

#define PS_SPLRESP 	"false\n"

//**
//
// Call:	LoadAtalkmonRegistry
//
// Returns:	NO_ERROR	-	Success
//		any other error	-	Failure
//
// Description: This routine loads all used registry values to
//		in memory data structures.  It is called at InitializeMonitor
//		time and assumes that the registry has been successfully
//		opened already.
//
DWORD
LoadAtalkmonRegistry(
    IN HKEY hkeyPorts
){

    HKEY    	hkeyPort 	= NULL;
    DWORD   	iSubkey 	= 0;
    PATALKPORT  pNewPort 	= NULL;
    DWORD   	cbPortKeyName 	= (MAX_ENTITY+1)*2;//size in characters
    WCHAR   	wchPortKeyName[(MAX_ENTITY+1)*2];
    CHAR   	chName[MAX_ENTITY+1];
    DWORD   	dwRetCode;
    DWORD       dwValueType;
    DWORD       cbValueData;
    FILETIME    ftKeyWrite;


    //
    // Build the port list
    //

    while( ( dwRetCode = RegEnumKeyEx(
				hkeyPorts,
				iSubkey++,
				wchPortKeyName,
				&cbPortKeyName,
				NULL,
				NULL,
				NULL,
				&ftKeyWrite) ) == NO_ERROR )
    {
        cbPortKeyName = (MAX_ENTITY+1)*2;

	//
	// Open the key
	//

	if (( dwRetCode = RegOpenKeyEx(
		    		hkeyPorts,
		    		wchPortKeyName,
		    		0,
		    		KEY_READ | KEY_SET_VALUE,
		    		&hkeyPort )) != ERROR_SUCCESS )
	{
		DBGPRINT(("sfmmon: LoadAtalkmonRegistry: Error in Opening key %ws\n", wchPortKeyName));
		break;
	}

	//
	// Allocate an initialized port
	//

	if (( pNewPort = AllocAndInitializePort()) == NULL )
	{
		DBGPRINT(("ERROR: fail to allocate new port.\n")) ;
		dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
		DBGPRINT(("LoadAtalkmonRegistry: Not enough memory\n"));
		goto query_error;
	}

	//
	// Copy port name.
	//

	wcscpy( pNewPort->pPortName, wchPortKeyName );

	cbValueData = MAX_ENTITY+1;

	if ( ( dwRetCode = RegQueryValueExA(
		    		hkeyPort,
		    		ATALKMON_PORTNAME_VALUE,
		    		NULL,
		    		&dwValueType,
		    		(LPBYTE)chName,
		    		&cbValueData) ) != ERROR_SUCCESS )
	{
		DBGPRINT(("LoadAtalkmonRegistry: Error querying portname value for %ws\n", wchPortKeyName));
		goto query_error;
	}

	//
	// Build the NBP Name
	//

	pNewPort->nbpPortName.ObjectNameLen = (CHAR) strlen( chName );

	strncpy( pNewPort->nbpPortName.ObjectName,
		 chName,
	 	 pNewPort->nbpPortName.ObjectNameLen );

	cbValueData = MAX_ENTITY+1;

	if (( dwRetCode = RegQueryValueExA(
		    		hkeyPort,
		    		ATALKMON_ZONENAME_VALUE,
		    		NULL,
		    		&dwValueType,
		    		(LPBYTE)chName,
		    		&cbValueData )) != ERROR_SUCCESS )
	{
		DBGPRINT(("LoadAtalkmonRegistry: Error querying zonename value for %ws\n", wchPortKeyName));
		goto query_error;
	}

	pNewPort->nbpPortName.ZoneNameLen = (CHAR)strlen( chName );

	strncpy( pNewPort->nbpPortName.ZoneName,
		 chName,
		 pNewPort->nbpPortName.ZoneNameLen );

	cbValueData = MAX_ENTITY+1;

	if (( dwRetCode = RegQueryValueExA(
		    		hkeyPort,
		    		ATALKMON_PORT_CAPTURED,
		    		NULL,
		    		&dwValueType,
    				chName,
		    		&cbValueData)) != ERROR_SUCCESS )
	{
		DBGPRINT(("LoadAtalkmonRegistry: Error querying port_captured value for %ws\n", wchPortKeyName));
		goto query_error;
	}

	if ( _stricmp( chName, "TRUE" ) == 0 )
	{
	    pNewPort->fPortFlags |= SFM_PORT_CAPTURED;

	    strncpy( pNewPort->nbpPortName.TypeName, 	
		     chComputerName,
		     strlen( chComputerName ) );

	    pNewPort->nbpPortName.TypeNameLen = (CHAR)strlen( chComputerName );

	}
	else
	{
	    pNewPort->fPortFlags &= ~SFM_PORT_CAPTURED;

	    strncpy( pNewPort->nbpPortName.TypeName, 	
		     ATALKMON_RELEASED_TYPE,
		     strlen( ATALKMON_RELEASED_TYPE ) );

	    pNewPort->nbpPortName.TypeNameLen = (CHAR)strlen(ATALKMON_RELEASED_TYPE);
	}


	//
	// close the key
	//

	RegCloseKey( hkeyPort );
	hkeyPort = NULL;

	//
	// Insert this port into the list
	//

	pNewPort->pNext = pPortList;
	pPortList       = pNewPort;


	DBGPRINT(("sfmmon: LoadAtalkmonRegistry: Initialized port %ws\n", pNewPort->pPortName)) ;

	continue;

query_error:
	DBGPRINT(("sfmmon: LoadAtalkmomRegistry: Error in querying registry for port %ws\n", pNewPort->pPortName));
	if (hkeyPort != NULL)
	{
		RegCloseKey( hkeyPort );
		hkeyPort = NULL;
	}
	if (pNewPort != NULL)
	{
		FreeAppleTalkPort( pNewPort );
		pNewPort = NULL;
	}
	// After error handling, resume normal operation
	dwRetCode = ERROR_SUCCESS;

    }


    if ( hkeyPort != NULL )
	RegCloseKey( hkeyPort );

    if ( ( dwRetCode != ERROR_NO_MORE_ITEMS ) &&
	 ( dwRetCode != ERROR_SUCCESS ) )
    {
	//
	// Free the entire list.
	//

	for ( pNewPort=pPortList; pPortList!=NULL; pNewPort=pPortList )
	{
		DBGPRINT (("LoadAtalkmonRegistry: Freeing port %ws\n", pNewPort->pPortName));
		pPortList=pNewPort->pNext;
		FreeAppleTalkPort( pNewPort );
	}
    }
    else
		dwRetCode = NO_ERROR;

    return( dwRetCode );
}

//**
//
// Call:	AllocAndInitializePort
//
// Returns:	Pointer to an intialized ATALKPORT structure
//
// Description: Will allocate an ATALKPORT structure on the stack and
//		initialize it.
//
PATALKPORT
AllocAndInitializePort(
    VOID
){

    PATALKPORT	pNewPort = NULL;

    if ( ( pNewPort = (PATALKPORT)LocalAlloc( LPTR,
					      sizeof(ATALKPORT))) == NULL )
	return NULL;

    if ( ( pNewPort->hmutexPort = CreateMutex( NULL, FALSE, NULL )) == NULL )
    {
	LocalFree( pNewPort );
	return( NULL );
    }

    pNewPort->pNext				= NULL;
    pNewPort->fPortFlags 			= 0;
    pNewPort->fJobFlags 			= 0;
    pNewPort->hPrinter 				= INVALID_HANDLE_VALUE;
    pNewPort->dwJobId 				= 0;
    pNewPort->sockQuery 			= INVALID_SOCKET;
    pNewPort->sockIo 				= INVALID_SOCKET;
    pNewPort->sockStatus 			= INVALID_SOCKET;
    pNewPort->nbpPortName.ZoneNameLen 		= (CHAR)0;
    pNewPort->nbpPortName.TypeNameLen 		= (CHAR)0;
    pNewPort->nbpPortName.ObjectNameLen 	= (CHAR)0;
    pNewPort->wshatPrinterAddress.Address	= 0;
    pNewPort->pPortName[0] 			= 0;
    pNewPort->OnlyOneByteAsCtrlD                = 0;

    return( pNewPort );
}

//**
//
// Call:	FreeAppleTalkPort
//
// Returns:	none.
//
// Description: Deallocates an ATALKPORT strucutre.
//
VOID
FreeAppleTalkPort(
    IN PATALKPORT pNewPort
){

    if ( pNewPort->hmutexPort != NULL )
	CloseHandle( pNewPort->hmutexPort );

    if (pNewPort->sockQuery != INVALID_SOCKET)
	closesocket(pNewPort->sockQuery);

    if (pNewPort->sockIo != INVALID_SOCKET)
	closesocket(pNewPort->sockIo);

    if (pNewPort->sockStatus != INVALID_SOCKET)
	closesocket(pNewPort->sockStatus);

    LocalFree(pNewPort);

    return;
}

//**
//
// Call:	CreateRegistryPort
//
// Returns:	NO_ERROR	- Success
//		anything elese  - falure code
//
// Description:
// 		This routine takes an initialized pointer to an
//		AppleTalk port structure and creates a Registry key for
//		that port.  If for some reason the registry key cannot
//		be set to the values of the port structure, the key is
//		deleted and the function returns FALSE.
//
DWORD
CreateRegistryPort(
    IN PATALKPORT pNewPort
){
    DWORD   dwDisposition;
    CHAR    chName[MAX_ENTITY+1];
    HKEY    hkeyPort  = NULL;
    DWORD   cbNextKey = sizeof(DWORD);
    DWORD   dwRetCode;

    //
    // resource allocation 'loop'
    //

    do {

	//
	// create the port key
	//

	if ( ( dwRetCode = RegCreateKeyEx(
				hkeyPorts,
				pNewPort->pPortName,
				0,
				TEXT(""),
				REG_OPTION_NON_VOLATILE,
				KEY_READ | KEY_SET_VALUE,
				NULL,
				&hkeyPort,
				&dwDisposition )) != ERROR_SUCCESS )
	    break;

	DBGPRINT(("sfmmon: CreateRegistryPort: PortName=%ws\n", pNewPort->pPortName));

	if ( dwDisposition == REG_OPENED_EXISTING_KEY )
	{
	    dwRetCode = ERROR_PRINTER_ALREADY_EXISTS;
	    break;
	}

	memset( chName, '\0', sizeof( chName ) );

	strncpy( chName,
		 pNewPort->nbpPortName.ObjectName,
	         pNewPort->nbpPortName.ObjectNameLen );

	//
	// set the Port Name
	//

	if ( ( dwRetCode = RegSetValueExA(
				hkeyPort,
				ATALKMON_PORTNAME_VALUE,
				0,
				REG_SZ,
				(LPBYTE)chName,
				(pNewPort->nbpPortName.ObjectNameLen)+1
				) ) != ERROR_SUCCESS )
	    break;

	memset( chName, '\0', sizeof( chName ) );

	strncpy( chName,
		 pNewPort->nbpPortName.ZoneName,
	         pNewPort->nbpPortName.ZoneNameLen );

	//
	// set the zone name
	//

	if ( ( dwRetCode = RegSetValueExA(
				hkeyPort,
				ATALKMON_ZONENAME_VALUE,
				0,
				REG_SZ,
				(LPBYTE)chName,
	         		pNewPort->nbpPortName.ZoneNameLen+1
				)) != ERROR_SUCCESS )
	    break;

	//
	// set the Config Flags
	//

	if ( pNewPort->fPortFlags & SFM_PORT_CAPTURED )
	    strcpy( chName, "TRUE" );
	else
	    strcpy( chName, "FALSE" );

	if ( ( dwRetCode = RegSetValueExA(
				hkeyPort,
				ATALKMON_PORT_CAPTURED,
				0,
				REG_SZ,
				(LPBYTE)chName,
	         		strlen(chName)+1
				)) != ERROR_SUCCESS )
	    break;

    } while( FALSE );

    //
    // clean up resources
    //

    if ( hkeyPort != NULL ) {

	if ( dwRetCode != NO_ERROR )
	{
	    //
	    // destroy half created key
	    //

	    RegDeleteKey( hkeyPorts, pNewPort->pPortName );
	}

	RegCloseKey( hkeyPort );
    }

    return( dwRetCode );
}

//**
//
// Call:	SetRegistryInfo
//
// Returns:
//
// Description:
//
DWORD
SetRegistryInfo(
    IN PATALKPORT pPort
){
    HKEY    	hkeyPort = NULL;
    DWORD       dwDisposition;
    DWORD	dwRetCode;
    CHAR	chBuffer[20];

    if ( ( dwRetCode = RegCreateKeyEx(
			hkeyPorts,
			pPort->pPortName,
			0,
			TEXT(""),
			REG_OPTION_NON_VOLATILE,
			KEY_READ | KEY_SET_VALUE,
			NULL,
			&hkeyPort,
			&dwDisposition )) != ERROR_SUCCESS )
	return( dwRetCode );

    if ( dwDisposition != REG_OPENED_EXISTING_KEY )
    {
	RegCloseKey( hkeyPort );
    	return( ERROR_UNKNOWN_PORT );
    }

    if ( pPort->fPortFlags & SFM_PORT_CAPTURED )
	strcpy( chBuffer, "TRUE" );
    else
	strcpy( chBuffer, "FALSE" );

    dwRetCode = RegSetValueExA(
			hkeyPort,
			ATALKMON_PORT_CAPTURED,
			0,
			REG_SZ,
			(LPBYTE)chBuffer,
	         	strlen(chBuffer)+1
			);

    RegCloseKey( hkeyPort );

    return( dwRetCode );
}


//**
//
// Call:	WinSockNbpLookup
//
// Returns:
//
// Description:
//
DWORD
WinSockNbpLookup(
    IN SOCKET 		sQuerySock,
    IN PCHAR  		pchZone,
    IN PCHAR  		pchType,
    IN PCHAR  		pchObject,
    IN PWSH_NBP_TUPLE   pTuples,
    IN DWORD 		cbTuples,
    IN PDWORD 		pcTuplesFound
){

    PWSH_LOOKUP_NAME	pRequestBuffer = NULL;
    INT 		cbWritten;

    *pcTuplesFound = 0;

    //
    // verify sQuerySock is valid
    //

    if ( sQuerySock == INVALID_SOCKET )
	return( ERROR_INVALID_PARAMETER );

    pRequestBuffer = (PWSH_LOOKUP_NAME)LocalAlloc(
					LPTR,
					sizeof(WSH_LOOKUP_NAME) + cbTuples );
    if ( pRequestBuffer == NULL)
	return( ERROR_NOT_ENOUGH_MEMORY );

    //
    // copy the lookup request to the buffer
    //

    pRequestBuffer->LookupTuple.NbpName.ZoneNameLen = (CHAR) strlen( pchZone );

    memcpy( pRequestBuffer->LookupTuple.NbpName.ZoneName,
	    pchZone,
	    pRequestBuffer->LookupTuple.NbpName.ZoneNameLen );

    pRequestBuffer->LookupTuple.NbpName.TypeNameLen = (CHAR) strlen( pchType );

    memcpy( pRequestBuffer->LookupTuple.NbpName.TypeName,
	    pchType,
	    pRequestBuffer->LookupTuple.NbpName.TypeNameLen );

    pRequestBuffer->LookupTuple.NbpName.ObjectNameLen = (CHAR) strlen( pchObject );

    memcpy( pRequestBuffer->LookupTuple.NbpName.ObjectName,
	    pchObject,
	    pRequestBuffer->LookupTuple.NbpName.ObjectNameLen );


    //
    // submit the request
    //

    cbWritten = cbTuples + sizeof( WSH_LOOKUP_NAME );

    if ( getsockopt(
		sQuerySock,
		SOL_APPLETALK,
		SO_LOOKUP_NAME,
		(char *) pRequestBuffer,
		&cbWritten ) == SOCKET_ERROR )
    {
	LocalFree( pRequestBuffer );
	return( GetLastError() );
    }

    //
    // copy the results
    //

    *pcTuplesFound = pRequestBuffer->NoTuples;

    memcpy( pTuples,
	    (PBYTE)pRequestBuffer + sizeof( WSH_LOOKUP_NAME ),
	    pRequestBuffer->NoTuples * sizeof( WSH_NBP_TUPLE ) );

    //
    // resource cleanup
    //

    LocalFree( pRequestBuffer );

    return NO_ERROR;
}


//**
//
// Call:	SetPrinterStatus
//
// Returns:
//
// Description:
//
DWORD
SetPrinterStatus(
    IN PATALKPORT pPort,
    IN LPWSTR     lpwsStatus
){

    DWORD           dwRetCode  = NO_ERROR;
    PJOB_INFO_1	    pji1Status = NULL;
    PJOB_INFO_1     pPreviousBuf=NULL;
    DWORD	    cbNeeded   = GENERIC_BUFFER_SIZE;

    //
    // resource allocation 'loop'
    //

    do {

        if ( ( pji1Status = (PJOB_INFO_1)LocalAlloc( LPTR, cbNeeded )) == NULL )
	    {
	        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
	    }

        while ( !GetJob(
	        	pPort->hPrinter,
	        	pPort->dwJobId,
	        	1,
	        	(PBYTE) pji1Status,
	        	cbNeeded,
	        	&cbNeeded) )
	    {

	        dwRetCode = GetLastError();

            if ( dwRetCode != ERROR_INSUFFICIENT_BUFFER )
                break;
	        else
            	dwRetCode = NO_ERROR;

            pPreviousBuf = pji1Status;

            pji1Status = (PJOB_INFO_1)LocalReAlloc( pji1Status,
						    cbNeeded,
						    LMEM_MOVEABLE );
	        if ( pji1Status == NULL )
	        {
	    	    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            	break;
	        }
            else
            {
                pPreviousBuf = NULL;
            }
        }

        if ( dwRetCode != NO_ERROR )
            break;

        //
        // change job info
        //

	    pji1Status->pStatus  = lpwsStatus;

	    pji1Status->Position = JOB_POSITION_UNSPECIFIED;

	    if (!SetJob(pPort->hPrinter, pPort->dwJobId, 1, (PBYTE) pji1Status, 0))
	    {
            dwRetCode = GetLastError();
            break;
        }

    } while( FALSE );

    //
    // resource cleanup
    //

    if ( pji1Status != NULL )
        LocalFree( pji1Status );

    if (pPreviousBuf != NULL)
    {
        LocalFree( pPreviousBuf );
    }

    DBGPRINT(("SetPrinterStatus returns %d\n", dwRetCode)) ;

    return( dwRetCode );
}

//**
//
// Call:	ConnectToPrinter
//
// Returns:
//
// Description:
//
DWORD
ConnectToPrinter(
    IN PATALKPORT pPort,
    IN DWORD 	  dwTimeout
){

    DWORD		    dwRetCode = NO_ERROR;
    CHAR		    pszZoneBuffer[MAX_ENTITY+1];
    CHAR		    pszTypeBuffer[MAX_ENTITY+1];
    CHAR		    pszObjectBuffer[MAX_ENTITY+1];
    SOCKADDR_AT 	    address;
    WSH_NBP_TUPLE	    tuplePrinter;
    DWORD		    cLoopCounter = 0;
    fd_set		    writefds;
    DWORD		    cTuples = 0 ;
    ULONG		    fNonBlocking ;

    DBGPRINT(("enter ConnectToPrinter\n")) ;

    if ( pPort->sockIo == INVALID_SOCKET )
	return( ERROR_INVALID_PARAMETER );

    //
    // resource allocation 'loop'
    //

    do {

	//
	// lookup address of printer
	//

	memcpy( pszZoneBuffer,
		pPort->nbpPortName.ZoneName,
		pPort->nbpPortName.ZoneNameLen );

	pszZoneBuffer[pPort->nbpPortName.ZoneNameLen] = 0;

	memcpy( pszObjectBuffer,
		pPort->nbpPortName.ObjectName,
		pPort->nbpPortName.ObjectNameLen );

	pszObjectBuffer[pPort->nbpPortName.ObjectNameLen] = 0;

	memcpy( pszTypeBuffer,
		pPort->nbpPortName.TypeName,
		pPort->nbpPortName.TypeNameLen );

	pszTypeBuffer[pPort->nbpPortName.TypeNameLen] = 0;

	while( cLoopCounter++ < 2 )
	{

	    if ( ( dwRetCode = WinSockNbpLookup(
				pPort->sockIo,
				pszZoneBuffer,
				pszTypeBuffer,
				pszObjectBuffer,
				&tuplePrinter,
				sizeof(tuplePrinter),
				&cTuples ) ) != NO_ERROR )
	    {

	    	DBGPRINT(("WinSockNbpLookup() fails %d\n", dwRetCode )) ;
	    	break;
	    }

	    if ( cTuples != 1 )
	    {
	    	DBGPRINT(("%s:%s:%s not found.\n", pszZoneBuffer,
			   pszObjectBuffer,pszTypeBuffer ));

            	//
            	// look for other type
            	//

            	if ( _stricmp( pszTypeBuffer, chComputerName ) == 0 )
                    strcpy( pszTypeBuffer, ATALKMON_RELEASED_TYPE );
		else
                    strcpy( pszTypeBuffer, chComputerName );

	        dwRetCode = ERROR_UNKNOWN_PORT;
	    }
	    else
  	    {
	        dwRetCode = NO_ERROR;
		break;
	    }
	}

	if ( dwRetCode != NO_ERROR )
        {
    	    SetPrinterStatus( pPort, wchPrinterOffline );
	    break;
        }

	//
	// try to connect - if failure sleep & try again
	//

	address.sat_family 	= AF_APPLETALK;
	address.sat_net 	= tuplePrinter.Address.Network;
	address.sat_node 	= tuplePrinter.Address.Node;
	address.sat_socket 	= tuplePrinter.Address.Socket;

	
	if (connect( pPort->sockIo,
		      (PSOCKADDR)&address,
		      sizeof(address)) == SOCKET_ERROR )
	{
	    dwRetCode = GetLastError();

	    GetAndSetPrinterStatus( pPort );

	    break;
	}

	//
	// set to non-blocking mode
	//

	fNonBlocking = TRUE;
	
	if ( ioctlsocket( pPort->sockIo,
			  FIONBIO,
			  &fNonBlocking ) == SOCKET_ERROR )
	{
	    dwRetCode = GetLastError();

	    DBGPRINT(("ioctlsocket() fails with %d\n", dwRetCode ));

	    GetAndSetPrinterStatus( pPort );

	    break;
	}

#if 0
		
	// JH - This stuff breaks the monitor completely if the printer is in an
	//		error state at the time of connect. We block at the select forever
	//		in this case.
	//
	// We get a select for the connect. We need to get this out of the
	// way
	//

	DBGPRINT(("selecting on connect()\n")) ;
	FD_ZERO( &writefds );
	FD_SET( pPort->sockIo, &writefds );
	select( 0, NULL, &writefds, NULL, NULL );

	DBGPRINT(("select on connect() succeeds\n")) ;
#endif

	//
	// save address of printer
	//

	pPort->wshatPrinterAddress = tuplePrinter.Address;

    } while( FALSE );

    return( dwRetCode );
}

//**
//
// Call:	CapturePrinter
//
// Returns:
//
// Description:
//
DWORD
CapturePrinter(
    IN PATALKPORT pPort,
    IN BOOL	  fCapture
){

    CHAR	    pszZone[MAX_ENTITY + 1];
    CHAR	    pszType[MAX_ENTITY + 1];
    CHAR	    pszObject[MAX_ENTITY + 1];
    WSH_NBP_TUPLE   tuplePrinter;
    DWORD	    cPrinters;
    DWORD	    cLoopCounter = 0;
    SOCKET 	    Socket = INVALID_SOCKET;
    DWORD	    dwRetCode = NO_ERROR;

    DBGPRINT(("enter CapturePrinter() %d\n", fCapture)) ;

    if ( ( dwRetCode = OpenAndBindAppleTalkSocket( &Socket ) ) != NO_ERROR )
	return( dwRetCode );

    //
    // initialize lookup strings
    //

    memcpy( pszZone,
  	    pPort->nbpPortName.ZoneName,
	    pPort->nbpPortName.ZoneNameLen );

    pszZone[pPort->nbpPortName.ZoneNameLen] = 0;

    memcpy( pszObject,
	    pPort->nbpPortName.ObjectName,
	    pPort->nbpPortName.ObjectNameLen );

    pszObject[pPort->nbpPortName.ObjectNameLen] = 0;

    strcpy( pszType, fCapture ? chComputerName : ATALKMON_RELEASED_TYPE );
	
    while ( cLoopCounter++ < 2 )
    {
	DBGPRINT(("Looking for %s:%s:%s\n", pszZone, pszObject, pszType)) ;

	if ( ( dwRetCode = WinSockNbpLookup(
				Socket,
				pszZone,
				pszType,
				pszObject,
				&tuplePrinter,
				sizeof(WSH_NBP_TUPLE),
				&cPrinters ) ) != NO_ERROR )
	    break;

	//
	// If we are seaching for the captured type
	//

   	if ( _stricmp( pszType, chComputerName ) == 0 )
	{

	    //
	    // We want to capture
	    //

	    if ( fCapture )
	    {
		if ( cPrinters == 1 )
		    break;
		else
		    strcpy( pszType, ATALKMON_RELEASED_TYPE );
	    }
	    else
	    {
		//
		// We do not want to capture
		//

		if ( cPrinters == 1 )
		{
	    	    dwRetCode = CaptureAtalkPrinter( Socket,
						     &(tuplePrinter.Address),
						     FALSE );

		    if ( dwRetCode != NO_ERROR )
			break;

                    pPort->nbpPortName.TypeNameLen =
						(CHAR) strlen(ATALKMON_RELEASED_TYPE);

                    memcpy( pPort->nbpPortName.TypeName,
			    ATALKMON_RELEASED_TYPE,
			    pPort->nbpPortName.TypeNameLen) ;

	            break;
		}
            }

	}
	else
	{
	    if ( fCapture )
	    {
		if ( cPrinters == 1 )
		{
	            dwRetCode = CaptureAtalkPrinter( Socket,
					  	     &(tuplePrinter.Address),
						     TRUE );

		    if ( dwRetCode != NO_ERROR )
			break;

                    pPort->nbpPortName.TypeNameLen = (CHAR) strlen( chComputerName );

                    memcpy( pPort->nbpPortName.TypeName,
			    chComputerName,
			    pPort->nbpPortName.TypeNameLen );

		    break;
		}
	    }
	    else
	    {
		if ( cPrinters == 1 )
		    break;
		else
		    strcpy( pszType, chComputerName );
	    }
	}
    }

    if ( Socket != INVALID_SOCKET )
	closesocket( Socket );

    DBGPRINT(("CapturePrinter returning %d\n", dwRetCode )) ;

    return( dwRetCode );
}

//**
//
// Call:	OpenAndBindAppleTalkSocket
//
// Returns:
//
// Description:
//
DWORD
OpenAndBindAppleTalkSocket(
    IN PSOCKET pSocket
){

    SOCKADDR_AT     address;
    INT 	    wsErr;
    DWORD	    dwRetCode = NO_ERROR;

    *pSocket = INVALID_SOCKET;

    //
    // open a socket
    //

    DBGPRINT(("sfmmon: Opening PAP socket\n"));

    do {

        *pSocket = socket( AF_APPLETALK, SOCK_RDM, ATPROTO_PAP );

    	if ( *pSocket == INVALID_SOCKET )
	{
	    dwRetCode = GetLastError();
	    break;
	}

    	//
    	// bind the socket
    	//

    	address.sat_family 	= AF_APPLETALK;
    	address.sat_net 	= 0;
    	address.sat_node 	= 0;
    	address.sat_socket 	= 0;

    	wsErr = bind( *pSocket, (PSOCKADDR)&address, sizeof(address) );

    	if ( wsErr == SOCKET_ERROR )
	{
	    dwRetCode = GetLastError();
	    break;
	}


    } while( FALSE );

    if ( dwRetCode != NO_ERROR )
    {
    	if ( *pSocket != INVALID_SOCKET )
	    closesocket( *pSocket );

        *pSocket = INVALID_SOCKET;

        DBGPRINT(("OpenAndBindAppleTalkSocket() returns %d\n", dwRetCode )) ;
    }

    return( dwRetCode );
}

//**
//
// Call:	TransactPrinter
//
// Returns:
//
// Description:
//	Used to make a query of a printer.  The response
//	buffer must be of PAP_DEFAULT_BUFFER or greater in length.
//	The request buffer can be no larger than a PAP_DEFAULT_BUFFER.
//	This routine connects to the printer, sends the request, reads
//	the response, and returns.  The transaction is made with the
//	printer specified  by the NBP name of the AppleTalk Port structure.
//
DWORD
TransactPrinter(
    IN SOCKET 		  sock,
    IN PWSH_ATALK_ADDRESS pAddress,
    IN LPBYTE 		  pRequest,
    IN DWORD 		  cbRequest,
    IN LPBYTE 		  pResponse,
    IN DWORD 		  cbResponse
){

    DWORD	    dwRetCode = NO_ERROR;
    SOCKADDR_AT     saPrinter;
    fd_set	    writefds;
    fd_set	    readfds;
    struct timeval  timeout;
    INT             wsErr;
    BOOL	    fRequestSent      = FALSE;
    BOOL	    fResponseReceived = FALSE;
    INT		    Flags = 0;
    DWORD	    cLoopCounter      = 0;

    DBGPRINT(("enter TransactPrinter()\n")) ;

    //
    // connect
    //

    saPrinter.sat_family = AF_APPLETALK;
    saPrinter.sat_net 	 = pAddress->Network;
    saPrinter.sat_node   = pAddress->Node;
    saPrinter.sat_socket = pAddress->Socket;

    if (connect(sock, (PSOCKADDR)&saPrinter, sizeof(saPrinter)) == SOCKET_ERROR)
	return(  GetLastError() );

    //
    // prime the read
    //

    if ( setsockopt(
                sock,
                SOL_APPLETALK,
                SO_PAP_PRIME_READ,
                pResponse,
                PAP_DEFAULT_BUFFER ) == SOCKET_ERROR )
    {
        shutdown( sock, 2 );
		return( GetLastError() );
    }

    //
    // Once connected we should be able to send and receive
    // This loop will only complete if either we are disconnected or
    // we sent and received successfully or we go through this loop more than
    // 20 times.
    //

    do {

    	//
    	// write the request
    	//

    	FD_ZERO( &writefds );
    	FD_SET( sock, &writefds );
    	timeout.tv_sec  = ATALKMON_DEFAULT_TIMEOUT_SEC;
    	timeout.tv_usec = 0;

        wsErr = select( 0, NULL, &writefds, NULL, &timeout );

	if ( wsErr == 1 )
	{
	    wsErr = send( sock, pRequest, cbRequest, 0 );

	    if ( wsErr != SOCKET_ERROR )
	    {
	    	fRequestSent = TRUE;
    		DBGPRINT(("Send succeeded\n")) ;
	    }
	}

	do {

	    //
	    // We have gone through this loop more than 100 times so assume
	    // that the printer has disconnected
	    //

	    if ( cLoopCounter++ > 20 )
	    {
		dwRetCode = WSAEDISCON;
		break;
	    }

	    dwRetCode = NO_ERROR;

	    //
    	    // read the response
    	    //

    	    FD_ZERO( &readfds );
    	    FD_SET( sock, &readfds );
    	    timeout.tv_sec  = ATALKMON_DEFAULT_TIMEOUT_SEC;
    	    timeout.tv_usec = 0;

            wsErr = select( 0, &readfds, NULL, NULL, &timeout );

	    if ( wsErr == 1 )
	    {
	    	wsErr = WSARecvEx( sock, pResponse, cbResponse, &Flags );

	        if ( wsErr == SOCKET_ERROR )
		{
		    dwRetCode = GetLastError();

    		    DBGPRINT(("recv returned %d\n", dwRetCode )) ;

		    if ((dwRetCode == WSAEDISCON) || (dwRetCode == WSAENOTCONN))
	    	    	break;
		}
		else
		{
	    	    pResponse[wsErr<(INT)cbResponse?wsErr:cbResponse-1]= '\0';

		    fResponseReceived = TRUE;
		    break;
		}
	    }

	} while( fRequestSent && !fResponseReceived );

	if ((dwRetCode == WSAEDISCON) || (dwRetCode == WSAENOTCONN))
	    break;

    } while( !fResponseReceived );

    shutdown( sock, 2 );

    return( dwRetCode );
}

//**
//
// Call:	CaptureAtalkPrinter
//
// Returns:
//
// Description:
//
DWORD
CaptureAtalkPrinter(
    IN SOCKET 		  sock,
    IN PWSH_ATALK_ADDRESS pAddress,
    IN BOOL		  fCapture
){

    CHAR  pRequest[PAP_DEFAULT_BUFFER];
    CHAR  pResponse[PAP_DEFAULT_BUFFER];
    DWORD dwRetCode;

    DBGPRINT(("Enter CaptureAtalkPrinter, %d\n", fCapture ));

    //
    // is a dictionary resident?  If so, reset the printer
    //

    //
    // change the type to be captured
    //

    if ( fCapture )
        sprintf( pRequest, PS_TYPESTR, chComputerName );
    else
        sprintf( pRequest, PS_TYPESTR, ATALKMON_RELEASED_TYPE );

    if ( ( dwRetCode = TransactPrinter(
				sock,
				pAddress,
				pRequest,
				strlen(pRequest),
				pResponse,
				PAP_DEFAULT_BUFFER )) != NO_ERROR )
	return( dwRetCode );

    DBGPRINT(("CaptureAtalkPrinter returns OK"));

    return( NO_ERROR );
}

//**
//
// Call:	IsSpooler
//
// Returns:
//
// Description:
//
DWORD
IsSpooler(
    IN     PWSH_ATALK_ADDRESS pAddress,
    IN OUT BOOL * pfSpooler
){

    CHAR  	pRequest[PAP_DEFAULT_BUFFER];
    CHAR  	pResponse[PAP_DEFAULT_BUFFER];
    DWORD 	dwRetCode;
    SOCKADDR_AT address;
    SOCKET 	Socket;


    if ( ( dwRetCode = OpenAndBindAppleTalkSocket( &Socket ) ) != NO_ERROR )
	return( dwRetCode );

    *pfSpooler = FALSE;

    address.sat_family 	= AF_APPLETALK;
    address.sat_net 	= pAddress->Network;
    address.sat_node 	= pAddress->Node;
    address.sat_socket 	= pAddress->Socket;

    //
    // Set the query string
    //

    strcpy( pRequest, PS_SPLQUERY );

    dwRetCode = TransactPrinter(
				Socket,
				pAddress,
				pRequest,
				strlen( pRequest ),
				pResponse,
				PAP_DEFAULT_BUFFER );


    if ( dwRetCode != NO_ERROR )
    {
        DBGPRINT(("IsSpooler fails returns %d\n", dwRetCode )) ;
		closesocket( Socket );
		return( dwRetCode );
    }

    *pfSpooler = TRUE;

    if ((*pResponse == 0) || (_stricmp( pResponse, PS_SPLRESP ) == 0))
		*pfSpooler = FALSE;

    closesocket( Socket );

    return( NO_ERROR );
}

//**
//
// Call:	ParseAndSetPrinterStatus
//
// Returns:
//
// Description:
//
VOID
ParseAndSetPrinterStatus(
    IN PATALKPORT pPort
)
{
    LPSTR lpstrStart;
    LPSTR lpstrEnd;
    WCHAR wchStatus[1024];

    //
    // Does the string containg "PrinterError:"
    //

    if ( ( lpstrStart = strstr(pPort->pReadBuffer, "PrinterError:" )) == NULL )
    {
	SetPrinterStatus( pPort, wchPrinting );
	return;
    }

    if ( ( lpstrEnd = strstr( lpstrStart, ";" ) ) == NULL )
    {
    	if ( ( lpstrEnd = strstr( lpstrStart, "]%%" ) ) == NULL )
    	{
	    SetPrinterStatus( pPort, wchPrinterError );
	    return;
	}
    }

    *lpstrEnd = '\0';

    mbstowcs( wchStatus, lpstrStart, sizeof( wchStatus ) );

    SetPrinterStatus( pPort, wchStatus );

    return;
}

//**
//
// Call:	GetAndSetPrinterStatus
//
// Returns:
//
// Description:
//
VOID
GetAndSetPrinterStatus(
    IN PATALKPORT pPort
){
    INT  		 	wsErr;
    WSH_PAP_GET_SERVER_STATUS 	wshServerStatus;
    WCHAR 			wchStatus[MAX_PAP_STATUS_SIZE+1];
    DWORD			cbNeeded;
    DWORD			cbStatus;
    LPSTR 		  	lpstrStart;
    LPSTR 			lpstrEnd;


    wshServerStatus.ServerAddr.sat_family = AF_APPLETALK;
    wshServerStatus.ServerAddr.sat_net 	  = pPort->wshatPrinterAddress.Network;
    wshServerStatus.ServerAddr.sat_node   = pPort->wshatPrinterAddress.Node;
    wshServerStatus.ServerAddr.sat_socket = pPort->wshatPrinterAddress.Socket;

    cbNeeded = sizeof( WSH_PAP_GET_SERVER_STATUS );

    wsErr = getsockopt(
		     pPort->sockStatus,
                     SOL_APPLETALK,
                     SO_PAP_GET_SERVER_STATUS,
                     (CHAR*)&wshServerStatus,
                     &cbNeeded );

    if ( wsErr == SOCKET_ERROR )
    {
        DBGPRINT(("getsockopt( pap get status ) returns %d\n",GetLastError()));
	SetPrinterStatus( pPort, wchBusy );
	return;
    }


    cbStatus = wshServerStatus.ServerStatus[0];

    memmove( wshServerStatus.ServerStatus,
	     (wshServerStatus.ServerStatus)+1,
	     cbStatus );

    wshServerStatus.ServerStatus[cbStatus] = '\0';

    DBGPRINT(("Pap get status = %s\n", wshServerStatus.ServerStatus));

    //
    // Does the string containg "PrinterError:"
    //

    if ( ( lpstrStart = strstr( wshServerStatus.ServerStatus,
				"PrinterError:" )) == NULL )
    {
	SetPrinterStatus( pPort, wchBusy );
	return;
    }

    if ( ( lpstrEnd = strstr( lpstrStart, ";" ) ) == NULL )
    {
    	if ( ( lpstrEnd = strstr( lpstrStart, "]%%" ) ) == NULL )
	{
	    SetPrinterStatus( pPort, wchPrinterError );
	    return;
	}
    }

    *lpstrEnd = '\0';

    mbstowcs( wchStatus, lpstrStart, sizeof( wchStatus ) );

    SetPrinterStatus( pPort, wchStatus );

    return;
}

BOOLEAN
IsJobFromMac(
    IN PATALKPORT pPort
)
{
    PJOB_INFO_2     pji2GetJob=NULL;
    DWORD           dwNeeded;
    DWORD           dwRetCode;
    BOOLEAN         fJobCameFromMac;


    fJobCameFromMac = FALSE;

    //
    // get pParameters field of the jobinfo to see if this job came from a Mac
    //

    dwNeeded = 2000;

    while (1)
    {
        pji2GetJob = LocalAlloc( LMEM_FIXED, dwNeeded );
        if (pji2GetJob == NULL)
        {
            dwRetCode = GetLastError();
		    break;
        }

        dwRetCode = 0;

        if (!GetJob( pPort->hPrinter,pPort->dwJobId, 2,
                            (LPBYTE)pji2GetJob, dwNeeded, &dwNeeded ))
        {
            dwRetCode = GetLastError();
        }

        if ( dwRetCode == ERROR_INSUFFICIENT_BUFFER )
        {
            LocalFree(pji2GetJob);
        }
        else
        {
            break;
        }
    }

    if (dwRetCode == 0)
    {
        //
        // if there is pParameter field present, and if it matches with our string,
        // then the job came from a Mac
        //
        if (pji2GetJob->pParameters)
        {
			if ( (wcslen(pji2GetJob->pParameters) == LSIZE_FC) &&
			     (_wcsicmp(pji2GetJob->pParameters, LFILTERCONTROL) == 0) )
            {
                fJobCameFromMac = TRUE;
            }
        }
    }

    if (pji2GetJob)
    {
        LocalFree(pji2GetJob);
    }

    return(fJobCameFromMac);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\lib\psdiblib.h ===
/*

Copyright (c) 1992,1993  Microsoft Corporation

Module Name:

	psdiblib.h

Abstract:

   This file contains prototypes for the pstodib lib component. This also
   includes the macprint message file which resides in \sfm\macprint\spooler
   this file has all the error messages in english.

Author:

	James Bratsanos <v-jimbr@microsoft.com or mcrafts!jamesb>


Revision History:
	6 Mar 1992		Initial Version

Notes:	Tab stop: 4
--*/

#include <macpsmsg.h>



#define PSLOG_ERROR     0x00000001
#define PSLOG_WARNING   0x00000002



VOID
PsLogEvent(
   IN DWORD dwErrorCode,
   IN WORD cStrings,
   IN LPTSTR alptStrStrings[],
   IN DWORD dwFlags );


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\print\psprint\psshmem.h ===
/*++

Copyright (c) 1992,1993  Microsoft Corporation

Module Name:

	psshmem.h

Abstract:
	
   This module defines the interface format for the shared memory region
   that psprint and psexe use together.

Author:

    James Bratsanos (v-jimbr,mcrafts!jamesb)    6-Dec-1992


--*/


#define PSEXE_OK_EXIT    0
#define PSEXE_ERROR_EXIT 99
//
// Define some bits that tells us about the aborted and paused/un-paused
// state of the current job
//
#define PS_SHAREDMEM_PAUSED            0x00000001
#define PS_SHAREDMEM_ABORTED           0x00000002
#define PS_SHAREDMEM_SECURITY_ABORT    0x00000004


typedef struct {
	DWORD  dwSize;								
   DWORD  dwFlags;
   DWORD  dwNextOffset;
   DWORD  dwPrinterName;
   DWORD  dwDocumentName;
   DWORD  dwPrintDocumentDocName;
   DWORD  dwDevmode;
   DWORD  dwControlName;
   DWORD  dwJobId;
} PSPRINT_SHARED_MEMORY;
typedef PSPRINT_SHARED_MEMORY *PPSPRINT_SHARED_MEMORY;

//
// Define some macros that make copying stuff to /from shared memory
// simple. The item  passed in pItem is actually stuffed with the offset
// of the data from the base of the structure. This has to be done becuase
// processes sharing this data will not have this data at the same virtual
// address
//
#define UTLPSCOPYTOSHARED( pBase, pSrc, pItem, dwLen )       \
{                                                            \
    DWORD dwRealSize;                                        \
    PBYTE pDest;                                             \
    if (pSrc != NULL) {                                      \
      dwRealSize = (dwLen + 3) & ~0x03;                      \
      pDest = (LPBYTE) (pBase) + pBase->dwNextOffset;        \
      memcpy( (LPVOID) pDest, (LPVOID) pSrc, dwLen );        \
      pItem = pBase->dwNextOffset;                           \
      pBase->dwNextOffset += dwRealSize;                     \
    } else {                                                 \
      pItem = 0;                                             \
    }                                                        \
}

#define UTLPSRETURNPTRFROMITEM( pBase, pItem )               \
    ( pItem ? ( (LPBYTE) ( (LPBYTE)pBase + pItem )) : (LPBYTE) NULL )



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\print\psexe\psexe.c ===
/*

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

	psexe.c

Abstract:

   This file contains the code required to actually communicate with the
   PSTODIB dll and rasterize a job. Any required information is passed via
   some named shared memory, the name of which is passed on the command line.
   This name is guaranteed to be unique to the system and thus multiple
   postscript jobs can be imaged at the same time.

--*/

#include <windows.h>

#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <winspool.h>
#include <winsplp.h>
#include <prtdefs.h>
#include "..\..\lib\psdiblib.h"

#include "..\..\..\ti\psglobal\pstodib.h"


#include "..\psprint\psshmem.h"
#include "psexe.h"
#include <excpt.h>
#include <string.h>
#include "debug.h"


// By defining the following, each page is blited to the desktop this way
// one can verify the interpreter is running without waiting for the printer
// to print
//
//#define BLIT_TO_DESKTOP

// By defining the following, you will cause all the code to get executed
// except the part that REALLY writes to the printer. This is most useful in
// conjuction with the BLIT_TO_DESKTOP so you can run the intrepeter and
// have the output go to the desktop. I found this very useful during
// development. It may see useful when porting to new windows NT platforms.
//#define IGNORE_REAL_PRINTING


// This is a hack, it should eventually be taken out, the reason this is here,
// is becuse simply setting the windows page type in the DEVMODE structure,
// is not good enough for the RASTER printer driver (of which most printer
// drivers are based. With this table we borrowed from the spooler, we
// can set the correct FORM name which the printer drivers respect and can
// test different page sizes from the mac...
// DJC HACK HACK


PTSTR forms[] = {
L"Letter",
L"Letter Small",
L"Tabloid",
L"Ledger",
L"Legal",
L"Statement",
L"Executive",
L"A3",
L"A4",
L"A4 Small",
L"A5",
L"B4",
L"B5",
L"Folio",
L"Quarto",
L"10x14",
L"11x17",
L"Note",
L"Envelope #9",
L"Envelope #10",
L"Envelope #11",
L"Envelope #12",
L"Envelope #14",
L"C size sheet",
L"D size sheet",
L"E size sheet",
L"Envelope DL",
L"Envelope C5",
L"Envelope C3",
L"Envelope C4",
L"Envelope C6",
L"Envelope C65",
L"Envelope B4",
L"Envelope B5",
L"Envelope B6",
L"Envelope",
L"Envelope Monarch",
L"6 3/4 Envelope",
L"US Std Fanfold",
L"German Std Fanfold",
L"German Legal Fanfold",
NULL,
};




// This table translates from internal PSERR_* errors, defined in pstodib.h
// to errors in the event log file that the user can see in the event viewer
//
typedef struct {
   DWORD dwOutputError;
   DWORD dwPsError;
} PS_TRANSLATE_ERRORCODES;

PS_TRANSLATE_ERRORCODES adwTranslate[] = {

	EVENT_PSTODIB_INIT_ACCESS,		PSERR_INTERPRETER_INIT_ACCESS_VIOLATION,
	EVENT_PSTODIB_JOB_ACCESS,		PSERR_INTERPRETER_JOB_ACCESS_VIOLATION,
	EVENT_PSTODIB_STRING_SEQ,		PSERR_LOG_ERROR_STRING_OUT_OF_SEQUENCE,
	EVENT_PSTODIB_FRAME_ALLOC,		PSERR_FRAME_BUFFER_MEM_ALLOC_FAILED,
   EVENT_PSTODIB_FONTQUERYFAIL,  PSERR_FONT_QUERY_PROBLEM,
   EVENT_PSTODIB_INTERNAL_FONT,  PSERR_EXCEEDED_INTERNAL_FONT_LIMIT,
	EVENT_PSTODIB_MEM_FAIL, 		PSERR_LOG_MEMORY_ALLOCATION_FAILURE


};


// Globals, this is global because the abortproc we pass in to the
// graphics engine does not allow us to specify any data to pass to the
// abort proc
PSEXEDATA Data;


/*** PsPrintCallBack
 *
 * This is the function pstodib calls whenever certain events occur
 *
 * 	Entry:
 *      pPsToDib  = Pointer to the current PSTODIB structure
 *      pPsEvent  = defines the event that is occuring
 *
 *		Returns:
 *      True = Event was handled, interpreter should continue execution
 *      False = Abnormal termination, the interpreter should stop
 *
 */

BOOL
CALLBACK
PsPrintCallBack(
   IN struct _PSDIBPARMS *pPsToDib,
   IN OUT PPSEVENTSTRUCT pPsEvent)
{
    BOOL bRetVal=TRUE;    // Success in case we dont support

    // Decide on a course of action based on the event passed in
    //

    switch( pPsEvent->uiEvent ) {

      case PSEVENT_PAGE_READY:

         // The data in the pPsEvent signifies the data we need to paint..
         // for know we will treat the data as one text item null
         // terminated simply for testing...
         //
         bRetVal = PsPrintGeneratePage( pPsToDib, pPsEvent );
         break;


      case PSEVENT_STDIN:

         // The interpreter is asking for some data so simply call
         // the print subsystem to try to satisfy the request
         //
         bRetVal = PsHandleStdInputRequest( pPsToDib, pPsEvent );
         break;

    case PSEVENT_SCALE:
         //
         // Here is an opportunity to modify the current transformation
         // matrix x and y values, this is used to image a 150 dpi job
         // on a 300 dpi interpreter frame.
         //
         bRetVal = PsHandleScaleEvent( pPsToDib, pPsEvent);
         break;
    case PSEVENT_ERROR_REPORT:
         //
         // End of job, there may have been errors so the psexe component
         // may print an error page to the target printer depending on the
         // extent of the errors
         //
         bRetVal = PsGenerateErrorPage( pPsToDib, pPsEvent);
         break;
    case PSEVENT_GET_CURRENT_PAGE_TYPE:
         //
         // The interpreter usually queries the current page type at
         // startup time, and uses this page type if the JOB did not
         // specifically specify a page type.
         //
         bRetVal = PsGetCurrentPageType( pPsToDib, pPsEvent);
         break;
    case PSEVENT_NON_PS_ERROR:
         //
         // Some sort of error occured, that was NOT a postscript error.
         // Examples might be resource allocation failure, or access to
         // a resource has unexpectantly ended.
         //
         bRetVal = PsLogNonPsError( pPsToDib, pPsEvent );
         break;

   }

   return bRetVal;
}


/*** PsPrintTranslateErrorCode
 *
 * This routine simply uses the error table to translate between errors
 * internal to pstodib dib, and errors in the macprint.exe event file
 * which may be reported in the event log
 *
 * 	Entry:
 *      dwPsErr  = PsToDib internal error number
 *
 *
 *		Returns:
 *      The corresponding error number in the event error file.
 *
 *
 */
DWORD
PsTranslateErrorCode(
	IN DWORD dwPsErr )
{
   int i;

   for ( i = 0 ;i < sizeof(adwTranslate)/sizeof(adwTranslate[0]) ;i++ ) {
      if (dwPsErr == adwTranslate[i].dwPsError) {
         return( adwTranslate[i].dwOutputError);
      }
   }
   return ( EVENT_PSTODIB_UNDEFINED_ERROR );
}


/*** PsLogNonPsError
 *
 * This function logs an internal pstodib error
 *
 * 	Entry:
 *      pPsToDib  = Pointer to the current PSTODIB structure
 *      pPsEvent  = defines the NonPsError event structure with info
 *						  about the error that is occuring
 *
 *		Returns:
 *      True = Success, the event was logged
 *      False = Failure could not log the error
 *
 */
BOOL
PsLogNonPsError(
	IN PPSDIBPARMS pPsToDib,
   IN PPSEVENTSTRUCT pPsEvent )
{

   PPSEVENT_NON_PS_ERROR_STRUCT  pPsError;
   PPSEXEDATA pData;
   LPTSTR aStrs[2];
   DWORD dwEventError;
   TCHAR atchar[10];
   WORD wStringCount;

   if (!(pData = ValidateHandle(pPsToDib->hPrivateData))) {

        return(FALSE);
   }


   pPsError =  (PPSEVENT_NON_PS_ERROR_STRUCT) pPsEvent->lpVoid;
   dwEventError = PsTranslateErrorCode( pPsError->dwErrorCode);


   if (dwEventError == EVENT_PSTODIB_UNDEFINED_ERROR) {
      wsprintf( atchar,TEXT("%d"), pPsError->dwErrorCode);
      aStrs[1] = atchar;
      wStringCount = 2;
   }else{
      wStringCount = 1;
   }
   //
   // Set the document name so it gets recorded in the log file
   //
   aStrs[0] = pData->pDocument;


   PsLogEvent( dwEventError,
               wStringCount,
               aStrs,
               pPsError->bError ? PSLOG_ERROR : 0 );

   return(TRUE);
}

/*** PsGenerateErrorPage
 *
 *	This function generates an error page showing the last few postscript
 * errors that occured.
 *
 * 	Entry:
 *      pPsToDib  = Pointer to the current PSTODIB structure
 *      pPsEvent = defines the postscript errors that may have occured
 *
 *		Returns:
 *      True = Event was handled, interpreter should continue execution
 *      False = Abnormal termination, the interpreter should stop
 *
 */

BOOL
PsGenerateErrorPage(
   IN PPSDIBPARMS pPsToDib,
   IN OUT PPSEVENTSTRUCT pPsEvent)
{

   PPSEVENT_ERROR_REPORT_STRUCT pPsErr;
   PPSEXEDATA pData;
   BOOL bDidStartPage = FALSE;
   HGDIOBJ hOldFont=NULL;
   HGDIOBJ hNewFont=NULL;
   HGDIOBJ hNewBoldFont=NULL;
   LOGFONT lfFont;
   HPEN    hNewPen=NULL;
   HPEN    hOldPen=NULL;
   BOOL    bRetVal=TRUE;

   int iCurXPos;
   int iCurYPos;
   int i;
   TEXTMETRIC tm;
   int iYMove;
   PCHAR pChar;
   int iLen;
   LPJOB_INFO_1 lpJob1 = NULL;
   DWORD dwRequired;
   SIZE UserNameSize;
   HGDIOBJ hStockFont;



   if (!(pData = ValidateHandle(pPsToDib->hPrivateData))) {

        return(FALSE);
   }

   //
   // Clean up access to our error struct for easier access
   //
   pPsErr = (PPSEVENT_ERROR_REPORT_STRUCT) pPsEvent->lpVoid;

   //
   // Only report the error page if there are actual errors and ONLY
   // if the job had a FLUSHING mode, ie the error was critical enough
   // to dump the rest of the postscript job. This is done becuase
   // some jobs have warnings, but they are not fatal and the jobs actually
   // print fine, there is no need to confuse the user with an error page
   // if the job came out fine.
   //
   if( pPsErr->dwErrCount &&
       (pPsErr->dwErrFlags & PSEVENT_ERROR_REPORT_FLAG_FLUSHING )) {

		//
      // Set up a do, so we can break out of any errors without using a
      // goto.
      //
      do {


         if (!GetJob( pData->hPrinter,
                      pData->JobId,
                      1,
                      (LPBYTE) NULL,
                      0,
                      &dwRequired)) {

            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

               // Get some memory
               lpJob1 = (LPJOB_INFO_1) LocalAlloc( LPTR, dwRequired);
               if (lpJob1) {
                  if (!GetJob(pData->hPrinter,
                              pData->JobId, 1,
                              (LPBYTE) lpJob1,
                              dwRequired,
                              &dwRequired)) {

                     LocalFree( (HLOCAL) lpJob1 );
                     lpJob1 = NULL;
                  }
               }
            }
         }

         // Verify that we have a DC created!!!
         if( !PsVerifyDCExistsAndCreateIfRequired( pData )) {
            bRetVal = FALSE;
            break;
         }

         if( StartPage( pData->hDC ) <= 0 ) {
           bRetVal = FALSE;
           break;
         }
         bDidStartPage = TRUE;


         SetMapMode( pData->hDC, MM_LOENGLISH );

         hStockFont = GetStockObject( ANSI_VAR_FONT );
         if (hStockFont == (HGDIOBJ) NULL) {
            bRetVal = FALSE;
            break;
         }

         if( GetObject( hStockFont,
                        sizeof(lfFont),
                        (LPVOID) &lfFont) == 0 ) {
            bRetVal = FALSE;
            break;
         }


         //
         // Create the error item font in the correct size
         //
         lfFont.lfHeight = PS_ERR_FONT_SIZE;
         lfFont.lfWidth = 0;

         hNewFont = CreateFontIndirect( &lfFont);

         if (hNewFont == (HFONT) NULL) {
            bRetVal = FALSE;
            break;
         }

         // Create the error Header font
         //
         lfFont.lfHeight = PS_ERR_HEADER_FONT_SIZE;
         lfFont.lfWeight = FW_BOLD;

         hNewBoldFont = CreateFontIndirect( &lfFont );
         if (hNewBoldFont == (HFONT) NULL) {
            bRetVal = FALSE;
            break;
         }

         hOldFont = SelectObject( pData->hDC, hNewBoldFont);
         if (hOldFont == (HFONT)NULL) {
            bRetVal = FALSE;
            break;
         }

         if (!GetTextMetrics(pData->hDC, &tm)) {
            bRetVal = FALSE;
            break;
         }

         //
         // Set up how much to move vertically for positioning each line
         //
         iYMove = tm.tmHeight + tm.tmExternalLeading;

         //
         // Set the starting positiongs
         //
         iCurXPos = PS_INCH;
         iCurYPos = -PS_INCH;

         //
         // If we have info about the job then show it
         //
         if (lpJob1) {

            if (lpJob1->pUserName != NULL) {

              if (!GetTextExtentPoint( pData->hDC,
                                       lpJob1->pUserName,
                                       lstrlen(lpJob1->pUserName),
                                       &UserNameSize) ) {
   					bRetVal = FALSE;
                  break;
              }

              if( !TextOut( pData->hDC,
                            iCurXPos,
                            iCurYPos,
                            lpJob1->pUserName,
                            lstrlen(lpJob1->pUserName))) {
                  bRetVal = FALSE;
                  break;
              }

            }else{
              UserNameSize.cx = 0;
              UserNameSize.cy = 0;
            }

            if (lpJob1->pDocument != NULL) {

              if( !TextOut( pData->hDC,
                            iCurXPos + PS_QUART_INCH + UserNameSize.cx,
                            iCurYPos,
                            lpJob1->pDocument,
                            lstrlen(lpJob1->pDocument))) {
   					bRetVal = FALSE;
                  break;
              }

            }

         }

         //
         // Adjust the current position
         //
         iCurYPos -= (iYMove + PS_ERR_LINE_WIDTH );

         // Draw A nice line
         //
         hNewPen = CreatePen( PS_SOLID, PS_ERR_LINE_WIDTH, RGB(0,0,0));
         if (hNewPen == (HPEN) NULL ) {
            bRetVal = FALSE;
            break;
         }

         // Make our new pen active
         //
         hOldPen = SelectObject( pData->hDC, hNewPen );


         // Draw the line
         //
         MoveToEx( pData->hDC, iCurXPos, iCurYPos, NULL);
         LineTo( pData->hDC, iCurXPos + PS_ERR_LINE_LEN, iCurYPos);

         // Put the old pen back
         //
         SelectObject( pData->hDC, hOldPen);

         // Delete the pen we created
         //
         DeleteObject( hNewPen );

         // Reset the line
         //
         iCurYPos -= PS_ERR_LINE_WIDTH;

         // Now Select the normal font
         //
         SelectObject( pData->hDC, hNewFont);

         // Get the updated text metrics for the new font
         //
         if (!GetTextMetrics(pData->hDC, &tm)){
            bRetVal = FALSE;
            break;
         }
         iYMove = tm.tmHeight + tm.tmExternalLeading;


         // Now display each of the errors that came from PSTODIB
         //
         i = (int) pPsErr->dwErrCount;

         while (--i) {
            pChar = pPsErr->paErrs[i];
            iLen  = lstrlenA( pChar );

            if ( !TextOutA( pData->hDC,
                            iCurXPos,
                            iCurYPos,
                            pChar,
                            iLen)) {
   				bRetVal = FALSE;
               break;
            }
            iCurYPos -= (iYMove + iYMove / 3);

         }


         break;

      } while ( 1 );


      if (!bRetVal) {
        PsLogEventAndIncludeLastError(EVENT_PSTODIB_ERROR_STARTPG_FAIL,TRUE);
      }
      // Clenup the DC.
      //
      if (hOldFont != (HFONT) NULL) {
        SelectObject( pData->hDC, hOldFont);
      }

      if (hNewFont != (HFONT) NULL) {
			DeleteObject( hNewFont);
      }
      if (hNewBoldFont != (HFONT)NULL) {
      	DeleteObject( hNewBoldFont );
      }


      if (bDidStartPage) {
        EndPage( pData->hDC );
      }

      // Free the job info memory if we had any
      if (lpJob1) {
         LocalFree((HLOCAL) lpJob1);
      }





   }




   return(bRetVal);


}


/*** PsHandleScaleEvent
 *
 *	This function handles scaling the current transformation matrix
 * (the way logical units are mapped to device units in the interpreter) in
 * order to simulate different page sizes for non 300 dpi devices. this
 * done by scaling the transformation matrix such that only the portion
 * of the frame buffer which can be transfered to the target printer is used.
 * for example if we were going to a 150 dpi device then exactly half of
 * 300 dpi frame buffer would be showable on the 150 dpi device, the rest of the
 * frame buffer would be useless as it would extend beyond the imageable area
 * of the printer. Thus if we scaled the current tranformation matrix by the
 * ration of the target device resolution over 300 (the default pstodib resolution)
 * then graphic objects that used to be 8 inches would now be 4 and thus take
 * up HALF the space they used to.
 *
 * errors that occured.
 *
 * 	Entry:
 *      pPsToDib = Pointer to the current PSTODIB structure
 *      pPsEvent = defines the current scale information for the current
 *                 postscript tranformation matrix
 *
 *		Returns:
 *      True = This can never fail
 *
 */
BOOL
PsHandleScaleEvent(
   IN PPSDIBPARMS pPsToDib,
   IN OUT PPSEVENTSTRUCT pPsEvent)
{

   PPS_SCALE pScale;


   pScale = (PPS_SCALE) pPsEvent->lpVoid;



   pScale->dbScaleX = (double) pPsToDib->uiXDestRes / (double) pScale->uiXRes;
   pScale->dbScaleY = (double) pPsToDib->uiYDestRes / (double) pScale->uiYRes;


#ifdef BLIT_TO_DESKTOP
   pScale->dbScaleX *= .25;
   pScale->dbScaleY *= .25;
#endif

   return(TRUE);



}



/*** ValidateHandle
 *
 * Validates the handle passed in to make sure its correct, if its not
 * it also logs an error.
 *
 *
 * 	Entry:
 *      hQProc = Handle to data block
 *
 *		Returns:
 *      A valid ptr to a session block.
 *      NULL - failure the handle passed in was not what was expected.
 */
PPSEXEDATA
ValidateHandle(
    HANDLE  hQProc
)
{
    PPSEXEDATA pData = (PPSEXEDATA)hQProc;

    if (pData && pData->signature == PSEXE_SIGNATURE) {
        return( pData );
    } else {

        //
        // Log an error so we know something is wrong
        //
        PsLogEvent( EVENT_PSTODIB_LOG_INVALID_HANDLE,
                    0,
                    NULL,
                    PSLOG_ERROR );

        DBGOUT(("Validate handle failed..."));

        return( (PPSEXEDATA) NULL );
    }
}


/*** PsHandleStdInputRequest
 *
 * This function handles std input requests from the interpreter by reading
 * more data from the Win32 spooler.
 *
 *
 * 	Entry:
 *      pPsToDib = Pointer to the current PSTODIB structure
 *      pPsEvent = A pointer to a structure that defines where to put the
 *                 newly acquired data
 *
 *		Returns:
 *      True = Success
 *      FALSE = Failure the interepreter should stop processing postscript upon
 *					 return from this function.
 */
BOOL
PsHandleStdInputRequest(
   IN PPSDIBPARMS pPsToDib,
   IN OUT PPSEVENTSTRUCT pPsEvent)
{

   PPSEXEDATA pData;
   PPSEVENT_STDIN_STRUCT pStdinStruct;
   DWORD dwAmtToCopy;


   if (!(pData = ValidateHandle(pPsToDib->hPrivateData))) {
       return FALSE;
   }

   //
   // No matter what check for block or abort
   //
   if ( PsCheckForWaitAndAbort( pData )) {
      return(FALSE);
   }

   //
   // Cast the data to the correct structure
   //
   pStdinStruct = (PPSEVENT_STDIN_STRUCT) pPsEvent->lpVoid;



   //
   // Look to see if we have any data left over from our cache...
   // if so return that data instead of really reading from the spooler
   //

   if (pData->cbBinaryBuff != 0) {


       //
       // A little bit of math here in case the buffer passed in to
       // us is not big enough to hold the entire cache buffer
       //

       dwAmtToCopy = min( pData->cbBinaryBuff, pStdinStruct->dwBuffSize);

       //
       // There is data so lets copy it first...
       //

       memcpy(   pStdinStruct->lpBuff,
                  pData->lpBinaryPosToReadFrom,
                  dwAmtToCopy );

       //
       // Now upate the pointer and counts;
       //

       pData->cbBinaryBuff -= dwAmtToCopy;
       pData->lpBinaryPosToReadFrom += dwAmtToCopy;
       pStdinStruct->dwActualBytes = dwAmtToCopy;

   }else{

      //
      // Read from the printer the amount of data the interpreter
      // claims he can handle
      //

      if( !ReadPrinter( pData->hPrinter,
                        pStdinStruct->lpBuff,
                        pStdinStruct->dwBuffSize,
                        &(pStdinStruct->dwActualBytes ))) {
         //
         // something is wrong... so reset the bytes read to 0
         //
         pStdinStruct->dwActualBytes = 0;

         //
         // If something unexpected happened log it
         //
         if (GetLastError() != ERROR_PRINT_CANCELLED) {
            //
            // Something happened... log it and abort
            //
            PsLogEventAndIncludeLastError(EVENT_PSTODIB_GET_DATA_FAILED,TRUE);
         }
      }

   }

   // If the number of bytes returned is 0 then were done...
   //
   if (pStdinStruct->dwActualBytes == 0) {
      // we read nothing from the file... declare an EOF
      pStdinStruct->uiFlags |= PSSTDIN_FLAG_EOF;
   }

   return(TRUE);

}

/*** PsCheckForWaitAndAbort
 *
 * This function checks to see if the user
 * more data from the Win32 spooler.
 *
 *
 * 	Entry:
 *		  pData = A pointer to our current job structure
 *
 *		Returns:
 *      True  = An abort has been requested
 *      False = Ok, normal processing
 */
BOOL
PsCheckForWaitAndAbort(
	IN PPSEXEDATA pData )
{

   BOOL bRetVal = FALSE;

   // 1st verify we are not blocked... if we are, wait for the
   // semaphore before continuing since someone decided to PAUSE us
   //
   WaitForSingleObject(pData->semPaused, INFINITE);


   // Check the ABORT flag that would have been sent if the user aborted
   // us from printman
   //
   bRetVal = *(pData->pdwFlags) & PS_SHAREDMEM_ABORTED;
#ifdef MYPSDEBUG
   if (bRetVal) {
		DBGOUT(("\nAbort requested...."));
   }
#endif

   return(bRetVal);
}



/*** PsSetPrintingInfo
 *
 * This function brings the current devmode structure up to date, based
 * on number of copies and or current page type to use for the next
 * page.
 *
 *
 * 	Entry:
 *      pData 		= Pointer to the current job data structure
 *      ppsPage	= A pointer to a structure that defines the current page
 *						  to image, based on data from the intrepreter.
 *
 *		Returns:
 *      True  = A change occured, the devmode has been made up to date, and
 *					 somethign changed (signals that ResetDC should be called.
 *
 *      False = Ok, no changes were observed
 */
BOOL
PsSetPrintingInfo(
	IN OUT PPSEXEDATA pData,
   IN PPSEVENT_PAGE_READY_STRUCT ppsPage )
{

   BOOL bRetVal = FALSE;
   LPDEVMODE lpDevmode;


   lpDevmode = pData->printEnv.lpDevmode;


   if (lpDevmode != (LPDEVMODE) NULL ) {

      // We have a devmode so go ahead and look for changes

      if (lpDevmode->dmFields & DM_PAPERSIZE) {

         if (lpDevmode->dmPaperSize != ppsPage->iWinPageType) {
            lpDevmode->dmPaperSize = (short)(ppsPage->iWinPageType);
            bRetVal = TRUE;
         }


      }

      // HACKHACK DJCTEST hack hack , until page stuff gets resolved
      // once we can simply pass a new page type in this code will go away
      //
      if (lpDevmode->dmFields & DM_FORMNAME) {
         if (wcscmp( forms[ppsPage->iWinPageType-1], lpDevmode->dmFormName)) {
            wcscpy( lpDevmode->dmFormName, forms[ppsPage->iWinPageType-1]);
            bRetVal = TRUE;
         }

      }
      // DJC end hack....



      // DJC need a decision here because if the driver does not support
      //     multiple copies we need to simulate it ????
      if (lpDevmode->dmFields & DM_COPIES) {
         if (lpDevmode->dmCopies != (short) ppsPage->uiCopies) {
            lpDevmode->dmCopies = (short)(ppsPage->uiCopies);
            bRetVal = TRUE;
         }
      }



   }



   return( bRetVal );

}






/*** PsPrintGeneratePage
 *
 * This function is called whenever the interpreter gets a showpage
 *	and is responsible for managing the DC of the printer we are currently
 * printing to.
 *
 * 	Entry:
 *      pPsToDib = Pointer to the current PSTODIB structure
 *      pPsEvent = A pointer to a structure that defines the attributes for
 *                 the frame buffer which is ready to be imaged. This function
 *						 will verify that we are not paused/aborted, verify a device
 *						 context is available to draw into,
 *						 double check and
 *        			 update the current DEVMODE, reset the DC if required and
 * 				    finally call the code to actualy draw the frame buffer.
 *
 *		Returns:
 *      True = Success
 *      FALSE = Failure the interepreter should stop processing postscript upon
 *					 return from this function.
 */
BOOL
PsPrintGeneratePage(
	IN PPSDIBPARMS pPsToDib,
   IN PPSEVENTSTRUCT pPsEvent)
{

    PPSEXEDATA pData;
    PPSEVENT_PAGE_READY_STRUCT ppsPageReady;


    if (!(pData = ValidateHandle(pPsToDib->hPrivateData))) {

        // do something here,,,, we have a major problem...
        return(FALSE);
    }


    // Verify were not aborting....
    if ( PsCheckForWaitAndAbort( pData)) {
       return(FALSE);
    }


    ppsPageReady = (PPSEVENT_PAGE_READY_STRUCT) pPsEvent->lpVoid;

    // Verify that the current set of data were imaging under is correct
    // If not lets set it up so it is, PAGE_SIZE, COPIES for now

    if (PsSetPrintingInfo( pData, ppsPageReady) &&
    									(pData->hDC != (HDC)NULL )) {

       DBGOUT(("\nReseting the DC"));

       if( ResetDC( pData->hDC, pData->printEnv.lpDevmode) == (HDC) NULL ) {
          PsLogEventAndIncludeLastError(EVENT_PSTODIB_RESETDC_FAILED,FALSE);
       }

    }


    // We may not have a dc set up yet, in this case we need to create it
    // with the new devmode data we just modified. If we do this then
    // we dont need to do a reset dc.
#ifndef IGNORE_REAL_PRINTING
    if(!PsVerifyDCExistsAndCreateIfRequired( pData )) {
       return(FALSE);
    }
#endif

    // Everything is ready to actuall image the frame buffer to the Target
    // device context, so do it...
    //
    return PsPrintStretchTheBitmap( pData, ppsPageReady );

}



/*** PsPrintStretchTheBitmap
 *
 * This function actually manages the target surface and either blits or
 * stretchBlits (based on the resolution of the target printer) the frame
 * buffer.
 *
 * 	Entry:
 *      	pData				= Pointer to the current job structure
 *		  	ppsPageReady   = Pointer to the page ready event structure that
 *								  the pstodib component prepared for us..
 *		Returns:
 *      True = Success
 *      FALSE = Failure the interepreter should stop processing postscript upon
 *					 return from this function.
 */
BOOL
PsPrintStretchTheBitmap(
	IN PPSEXEDATA pData,
   IN PPSEVENT_PAGE_READY_STRUCT ppsPageReady )
{

   BOOL  bOk = TRUE;

   int iXres, iYres;
   int iDestWide, iDestHigh;
   int iPageCount;
   int iYOffset;
   int iXSrc;
   int iYSrc;
   int iNumPagesToPrint;
   int iBlit;
   int iNewY;
   int iNewX;




   // Now do some calculations so we decide if we really need to
   // stretch the bitmap or not. If the true resolution of the target
   // printer is less than pstodibs (PSTDOBI_*_DPI) then we will shring
   // the effective area so we actually only grab a portion of the bitmap
   // However if the Target DPI is greater that PSTODIBS there is nothing
   // we can do other than actually stretch (grow) the bitmap.
   //
#ifndef BLIT_TO_DESKTOP
   iXres = GetDeviceCaps(pData->hDC, LOGPIXELSX);
   iYres = GetDeviceCaps(pData->hDC, LOGPIXELSY);
#else
   iXres = 300;
   iYres = 300;
#endif

	// Get the DPI of the target dc anc calculate how much of the frame buffer
   // we must want in order to show the page correctly
   //
   iDestWide = (ppsPageReady->dwWide * iXres) / PSTODIB_X_DPI;
   iDestHigh = (ppsPageReady->dwHigh * iYres) / PSTODIB_Y_DPI;


   // If the resolution of the target printer is larger that the resolution
   // of the interpreter, then were forced to actually stretch the data, so
   // we can fill the page
   //
   if (iDestHigh > (int) ppsPageReady->dwHigh ) {
      iYSrc = ppsPageReady->dwHigh;
      iYOffset = 0;
   } else {
      iYSrc = iDestHigh;
      iYOffset = ppsPageReady->dwHigh - iDestHigh;
   }

   if (iDestWide > (int) ppsPageReady->dwWide) {
      iXSrc = ppsPageReady->dwWide;
   } else {
      iXSrc = iDestWide;
   }


   // Set up the number of pages to print, if the printer driver does not
   // support multiple pages on its own we need to simulate it...
   //
   if ((pData->printEnv.lpDevmode == (LPDEVMODE) NULL ) ||
        !(pData->printEnv.lpDevmode->dmFields & DM_COPIES )) {

     iNumPagesToPrint = ppsPageReady->uiCopies;
     DBGOUT(("\nSimulating copies settting to %d", iNumPagesToPrint));
   } else {
     DBGOUT(("\nUsing devmode copies of %d", pData->printEnv.lpDevmode->dmCopies));

     iNumPagesToPrint = 1;  // The driver will do it for us

   }

   //
   // Set the starting point of the image so we respect the fact that
   // postscript jobs have 0,0 at the bottom of the page and grow upwards
   // based on this info we need to compare the imageable area of the
   // device context and determine how much we need to offset the top,left
   // corner of our image such that the bottom of our image lines up with the
   // bottom of the REAL imageable area of the device. This is our best hope
   // of having the image appear in the correct place on the page.
   //
   iNewX =  (GetDeviceCaps( pData->hDC, HORZRES) - iDestWide) / 2;
   iNewY =  (GetDeviceCaps( pData->hDC, VERTRES) - iDestHigh) / 2;

   // If the printer driver does not support multiple copies then we need
   // to handle appropriately
   //
   for ( iPageCount = 0 ;
         iPageCount < iNumPagesToPrint ;
         iPageCount++ ) {

#ifndef IGNORE_REAL_PRINTING
     if (StartPage( pData->hDC) <= 0 ) {
        PsLogEventAndIncludeLastError(EVENT_PSTODIB_FAIL_IMAGE,TRUE);
        bOk = FALSE;
        break;
     }
#endif
#ifdef BLIT_TO_DESKTOP
     {
       HDC hDC;

       //TEST DJC, sanity

       hDC = GetDC(GetDesktopWindow());

       SetStretchBltMode( hDC, BLACKONWHITE);
       StretchDIBits  ( hDC,
                          0,
                          0,
                          iDestWide,
                          iDestHigh,
                          0,
                          iYOffset,
                          iXSrc,
                          iYSrc,
                          (LPVOID) ppsPageReady->lpBuf,
                          ppsPageReady->lpBitmapInfo,
                          DIB_RGB_COLORS,
                          SRCCOPY );


       ReleaseDC(GetDesktopWindow(), hDC);


     }
#endif

#ifdef MYPSDEBUG
   printf("\nDevice True size wxh %d,%d", GetDeviceCaps(pData->hDC,HORZRES),
                                          GetDeviceCaps(pData->hDC,VERTRES));

   printf("\nDevice Res %d x %d stretching from %d x %d, to %d x %d\nTo location %d %d",
            iXres,
            iYres,
            iXSrc,
            iYSrc,
            iDestWide,
            iDestHigh,
            iNewX,
            iNewY);

#endif




#ifndef IGNORE_REAL_PRINTING
#ifdef MYPSDEBUG
	  {
      TCHAR szBuff[512];
      wsprintf(	szBuff,
       			 	TEXT("PSTODIB True device res %d x %d, Job:%ws"),
						GetDeviceCaps(pData->hDC,HORZRES),
						GetDeviceCaps(pData->hDC,VERTRES),
                  pData->pDocument );


		TextOut( pData->hDC, 0 , 0, szBuff,lstrlen(szBuff));
     }
#endif

     // Set the stretch mode in case we really stretch
     //
     SetStretchBltMode( pData->hDC, BLACKONWHITE);


     //
     // Do a check to keep the stretch from occuring unless it HAS to
     //
     if ((iDestWide == iXSrc) &&
         (iDestHigh == iYSrc) ) {

       iBlit =  SetDIBitsToDevice(  pData->hDC,
      		         					iNewX,
                                    iNewY,
                                    iDestWide,
                                    iDestHigh,
                                    0,
                                    iYOffset,
                                    0,
                                    ppsPageReady->dwHigh,
                                    (LPVOID) ppsPageReady->lpBuf,
                                    ppsPageReady->lpBitmapInfo,
                                    DIB_RGB_COLORS );
     } else {

       iBlit =  StretchDIBits(    pData->hDC,
        			                   iNewX,
               		             iNewY,
                                  iDestWide,
                                  iDestHigh,
                                  0,
                                  iYOffset,
                                  iXSrc,
                                  iYSrc,
                                  (LPVOID) ppsPageReady->lpBuf,
                                  ppsPageReady->lpBitmapInfo,
                                  DIB_RGB_COLORS,
                                  SRCCOPY );
     }






     if( iBlit == GDI_ERROR ){

       PsLogEventAndIncludeLastError(EVENT_PSTODIB_FAIL_IMAGE,TRUE);

       bOk = FALSE;
       break;
     }
#endif
#ifndef IGNORE_REAL_PRINTING
     if ( EndPage( pData->hDC ) < 0 ) {
        PsLogEventAndIncludeLastError(EVENT_PSTODIB_FAIL_IMAGE,TRUE);
        bOk = FALSE;
        break;
     }
#endif
   }
   return(bOk);
}

VOID
PsLogEventAndIncludeLastError(
	IN DWORD dwErrorEvent,
   IN BOOL  bError )
{
   TCHAR atBuff[20];
   TCHAR *aStrs[2];

   wsprintf( atBuff,TEXT("%d"), GetLastError());

   aStrs[0] = atBuff;

   PsLogEvent( dwErrorEvent,
               1,
               aStrs,
               PSLOG_ERROR );


}





/*** PsVerifyDCExistsAndCreateIfRequired
 *
 *
 * This function checks to see if a DC already exists, and if it does not
 * then it creates one with the current devmode.
 *
 * 	Entry:
 *      	pData				= Pointer to the current job structure
 *
 *		Returns:
 *      True = Success
 *      FALSE = Failure the interepreter should stop processing postscript upon
 *					 return from this function.
 */
BOOL
PsVerifyDCExistsAndCreateIfRequired(
	IN OUT PPSEXEDATA pData )
{
   BOOL bRetVal = TRUE;
   DOCINFO docInfo;


   //
   // We will only create a dc if it has not already done so
   //
   if (pData->hDC == (HDC) NULL ) {

      pData->hDC = CreateDC(TEXT(""),
                            (LPCTSTR) pData->pPrinterName,
                            TEXT(""),
                            pData->printEnv.lpDevmode );

      if (pData->hDC == (HDC) NULL) {
         PsLogEventAndIncludeLastError( EVENT_PSTODIB_CANNOT_CREATE_DC,TRUE );
         return(FALSE);
      }


      // Now set the abort proc, this proc will be called occasioanly by the
      // system to see if we want to abort.....
      //
      SetAbortProc( pData->hDC, (ABORTPROC)PsPrintAbortProc );


      docInfo.cbSize = sizeof(DOCINFO);
      docInfo.lpszDocName = pData->pDocument;
      docInfo.lpszOutput = NULL;


      if ( StartDoc( pData->hDC, &docInfo) == SP_ERROR ) {

         PsLogEventAndIncludeLastError( EVENT_PSTODIB_CANNOT_DO_STARTDOC,TRUE );
         return(FALSE);

      }

      //
      // Set a flag saying we did the startdoc, this is so we can
      // return an error to the spooler if we did not, and force
      // deletion of the job
      //
      pData->printEnv.dwFlags |= PS_PRINT_STARTDOC_INITIATED;

   }

   return( TRUE );

}

/*** PsGetDefaultDevmode
 *
 *
 * This function retrieves the current default DEVMODE for the printer
 * we are asked to image a job on.
 *
 * 	Entry:
 *      	pData				= Pointer to the current job structure
 *
 *		Returns:
 *      True = Success
 *      FALSE = Failure the interepreter should stop processing postscript upon
 *					 return from this function.
 */
BOOL
PsGetDefaultDevmode(
	IN OUT PPSEXEDATA pData )
{
   DWORD dwMemRequired;
   PRINTER_INFO_2 *pPrinterInfo;



   if( !GetPrinter( pData->hPrinter,
                    2,
                    (LPBYTE) NULL,
                    0,
                    &dwMemRequired ) &&
       GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {
       PsLogEventAndIncludeLastError( EVENT_PSTODIB_GETDEFDEVMODE_FAIL,TRUE );
       return(FALSE);
   }



   pPrinterInfo = (PRINTER_INFO_2 *) LocalAlloc( LPTR, dwMemRequired );

   if (pPrinterInfo == (PRINTER_INFO_2 *) NULL) {

     PsLogEvent( EVENT_PSTODIB_MEM_ALLOC_FAILURE,
                 0,
                 NULL,
                 0 );

     return(FALSE);
   }


   if ( !GetPrinter( pData->hPrinter,
                     2,
                     (LPBYTE) pPrinterInfo,
                     dwMemRequired,
                     &dwMemRequired ) ) {

       LocalFree( (HLOCAL) pPrinterInfo );

       PsLogEventAndIncludeLastError( EVENT_PSTODIB_GETDEFDEVMODE_FAIL,TRUE );
       return(FALSE);
   }



   dwMemRequired = DocumentProperties( (HWND) NULL,
                                       pData->hPrinter,
                                       pPrinterInfo->pPrinterName,
                                       NULL,
                                       NULL,
                                       0 );


   pData->printEnv.lpDevmode = (LPDEVMODE) LocalAlloc( LPTR, dwMemRequired );
   if (pData->printEnv.lpDevmode == (LPDEVMODE) NULL) {

     LocalFree( (HLOCAL) pPrinterInfo );
     PsLogEvent( EVENT_PSTODIB_MEM_ALLOC_FAILURE,
                 0,
                 NULL,
                 0 );
     return(FALSE);

   } else {

     DocumentProperties( (HWND) NULL,
                         pData->hPrinter,
                         pPrinterInfo->pPrinterName,
                         pData->printEnv.lpDevmode,
                         NULL,
                         DM_COPY );

     pData->printEnv.dwFlags |= PS_PRINT_FREE_DEVMODE;






   }

   LocalFree( (HLOCAL) pPrinterInfo );

   return(TRUE);
}



/*** PsGetCurrentPageType
 *
 *
 * This function retrieves the current pagetype based on what was
 * initially in the devmode.
 *
 * 	Entry:
 *      	pData				= Pointer to the current job structure
 *		  pPsEvent			= Pointer to the structure which contains the default
 * 							  page type to use...
 *
 *		Returns:
 *      True = Success
 *		  False = The interpreter should stop processing the current job
 *
 */
BOOL
PsGetCurrentPageType(
	IN PPSDIBPARMS pPsToDib,
   IN OUT PPSEVENTSTRUCT pPsEvent)

{


   PPSEXEDATA pData;
   PPSEVENT_CURRENT_PAGE_STRUCT ppsCurPage;
   LPDEVMODE lpDevmode;



   if (!(pData = ValidateHandle(pPsToDib->hPrivateData))) {
        return(FALSE);
   }

   ppsCurPage = (PPSEVENT_CURRENT_PAGE_STRUCT) pPsEvent->lpVoid;

   lpDevmode = pData->printEnv.lpDevmode;

   if (lpDevmode!= (LPDEVMODE) NULL ) {
      //
      // We have a devmode so look at it
      //
      if ( lpDevmode->dmFields & DM_PAPERSIZE) {

         ppsCurPage->dmPaperSize = lpDevmode->dmPaperSize;
         return(TRUE);

      }
   }
   // True is returned in either case, since not having a devmode is
   // not necessaraly a fatal error
   //
   return(TRUE);
}


/*** PsMakeDefaultDevmodeModsAndSetupResolution
 *
 *
 * This function sets up our initial devmode and sets up some info
 * so we can determine the scaling ratio based on the comparison
 * of true device DPI, and internal interpreter DPI
 *
 * 	Entry:
 *      pData				= Pointer to the current job structure
 *		  pPsEvent			= Pointer to the structure which contains the
 *	                       intrepreter session info.
 *
 *		Returns:
 *      VOID
 *
 */
VOID
PsMakeDefaultDevmodeModsAndSetupResolution(
	IN PPSEXEDATA pData,
	IN OUT PPSDIBPARMS ppsDibParms )
{

   HDC hIC;
   LPDEVMODE lpDevmode;
   BOOL bVerifyNewRes = FALSE;


   lpDevmode = pData->printEnv.lpDevmode;



	ppsDibParms->uiXDestRes = PSTODIB_X_DPI;
	ppsDibParms->uiYDestRes = PSTODIB_Y_DPI;

   // 1st thing to here is create an information context so we can
   // determine the default resolution of the printer

   hIC = CreateIC(TEXT(""),
                  (LPCTSTR) pData->pPrinterName,
                  TEXT(""),
						lpDevmode );


   if ( hIC != (HDC) NULL ) {


       ppsDibParms->uiXDestRes = GetDeviceCaps(hIC, LOGPIXELSX);
       ppsDibParms->uiYDestRes = GetDeviceCaps(hIC, LOGPIXELSY);

       if (( GetDeviceCaps(hIC, LOGPIXELSX) > PSTODIB_X_DPI ) &&
           ( GetDeviceCaps(hIC, LOGPIXELSY) > PSTODIB_Y_DPI ) &&
           ( lpDevmode != (LPDEVMODE) NULL )) {

           // Both resolutions are bigger lets go ahead and try to get the driver
           // to go to PSTODIB_*_DPIS
           //
           lpDevmode->dmFields |= (DM_PRINTQUALITY | DM_YRESOLUTION);
           lpDevmode->dmPrintQuality = PSTODIB_X_DPI;
           lpDevmode->dmYResolution  = PSTODIB_Y_DPI;

           // Since we changed the resolution, it may not work so we need to
           // reget the IC with the new devmode to see if it works.
           bVerifyNewRes = TRUE;
       }

       DeleteDC( hIC );


       if (bVerifyNewRes) {

				hIC = CreateIC(TEXT(""),
									(LPCTSTR) pData->pPrinterName,
									TEXT(""),
									lpDevmode);

            if (hIC != (HDC) NULL) {

               // Set the resolution for the job to the new value...
               // we dont expect this to change for the duration ofthe
               // job
					ppsDibParms->uiXDestRes = GetDeviceCaps(hIC, LOGPIXELSX);
					ppsDibParms->uiYDestRes = GetDeviceCaps(hIC, LOGPIXELSY);


               DeleteDC(hIC);

            }
          					
       }

   }


   if (lpDevmode != (LPDEVMODE)NULL) {

		lpDevmode->dmFields |= (DM_ORIENTATION | DM_PAPERSIZE);
		lpDevmode->dmOrientation = DMORIENT_PORTRAIT;
		lpDevmode->dmCopies = 1;
   }

}



/*** PsInitPrintEnv
 *
 *
 * Initializes the data that tracks the DEVMODE for the current job
 *
 * 	Entry:
 *      pData				= Pointer to the current job structure
 *		  lpDevmode			= Pointer to the current devmode to use for the job
 *
 *		Returns:
 *      VOID
 *
 */
VOID PsInitPrintEnv( PPSEXEDATA pData, LPDEVMODE lpDevmode )
{
   DWORD dwTotDevMode;


   //
   // Set the inital state of our flags
   //

   pData->printEnv.dwFlags = 0;
   pData->printEnv.lpDevmode = (LPDEVMODE) NULL;



   if (lpDevmode != (LPDEVMODE) NULL) {

        //
        // Since there is a devmode make a local copy cause we might
        // be changing it.
        //


		dwTotDevMode = lpDevmode->dmSize + lpDevmode->dmDriverExtra;


		pData->printEnv.lpDevmode = (LPDEVMODE) LocalAlloc( NONZEROLPTR,
                                                            dwTotDevMode );


        if (pData->printEnv.lpDevmode != (LPDEVMODE) NULL) {

            //
            // Set the flag so we know to free this later
            //

            pData->printEnv.dwFlags |= PS_PRINT_FREE_DEVMODE;

            //
            // Now go and copy it
            //

			memcpy( (PVOID) pData->printEnv.lpDevmode,
                    (PVOID) lpDevmode,
                    dwTotDevMode );


        }
   }
}




/*** PsHandleBinaryFileLogicAndReturnBinaryStatus
 *
 *
 * This routine will look at the begining buffer of data from the ps job
 * and determine whether the job is BINARY. This is done by looking at the
 * beg of the job and looking for a string the mac Spooler inserts. If
 * this string exists it is converted to spaces and not passed through to the
 * interpreter. At this point it is a BINARY job.
 *
 *    Entry:
 *       pData          = Pointer to the current job structure
 *
 *    Returns:
 *      TRUE/FALSE      = True means this job should be treated as BINARY.
 *		
 *
 */
BOOL PsHandleBinaryFileLogicAndReturnBinaryStatus( PPSEXEDATA pData )
{

   DWORD dwIndex;
   BOOL  bRetVal = FALSE;

   pData->lpBinaryPosToReadFrom = &pData->BinaryBuff[0];
   pData->cbBinaryBuff = 0;


   if( !ReadPrinter( pData->hPrinter,
                     pData->lpBinaryPosToReadFrom,
                     sizeof(pData->BinaryBuff),
                     &(pData->cbBinaryBuff) )) {

      if (GetLastError() != ERROR_PRINT_CANCELLED) {
         //
         // Something happened... log it
         //
         PsLogEventAndIncludeLastError(EVENT_PSTODIB_GET_DATA_FAILED,TRUE);


#ifdef MYPSDEBUG
         printf("\nSFMPsexe: Error from ReadPrinter when trying to get Binary buffer data ");
#endif

      }


   } else {

      // Now do the compare


        if (IsJobFromMac(pData))
        {
            bRetVal = TRUE;
        }

        //
        // we retain this code just in case the job from an older SFM spooler
        // that still prepends those strings
        //
        else if (!strncmp(pData->BinaryBuff, FILTERCONTROL, SIZE_FC) ||
		         !strncmp(pData->BinaryBuff, FILTERCONTROL_OLD, SIZE_FCOLD))
        {
	        //
		    // turn filtering off & clear filter message
	        //
            for (dwIndex = 0; dwIndex < SIZE_FC; dwIndex++) {
                pData->BinaryBuff[dwIndex] = '\n' ;
            }

            bRetVal = TRUE;
	    }
   }

   return(bRetVal);
}
/*** PsPrintAbortProc
 *
 *
 * The abort procedure the system occasiaonly calls to see if we should abort
 * the current job
 *
 * 	Entry:
 *      hdc				= The current device context were drawing into
 *		  iError			= A spooler error, we dont need to worry about this
 *
 *		Returns:
 *		  TRUE      The job should continue to be processed
 *      FALSE		The job should be aborted
 *		
 *
 */
BOOL CALLBACK PsPrintAbortProc( HDC hdc, int iError )
{

   // If the print processor set the shared memory abort the job flag,
   // then kill the job
   //
   if( *(Data.pdwFlags) & PS_SHAREDMEM_ABORTED ) {
      return( FALSE );
   }

   return(TRUE);
}


/*** main
 *
 *
 * This is the main entry point for the application and only interface to
 * pstodib
 *
 *
 * 	Entry:
 *      argc			= Count of arguments
 *		  argv			= ptr to array of ptrs to each argument on the command
 *							  line.
 *
 *		Returns:
 *      0 = OK, job finished via normal processing
 *      99 = error of some sort
 */

int __cdecl
main(
   IN int argc,
   IN TCHAR *argv[] )

{

   PPSEXEDATA pData=&Data;
   PSDIBPARMS psDibParms;
   BOOL bRetVal = FALSE;
   LPTSTR  lpCommandLine;


   // Get to the first item, which is the name of the shared memory that
   // has all the info we need.
   //
   lpCommandLine = GetCommandLine();

   while (*lpCommandLine && *lpCommandLine != ' ') {
      lpCommandLine++;
   }
   while (*lpCommandLine && *lpCommandLine == ' ') {
      lpCommandLine++;
   }



   // First clear out our structure
   memset( (PVOID) pData, 0, sizeof(*pData));

   // Set up our local structure
   //
   pData->signature = PSEXE_SIGNATURE;




   // First thing to do is get the name of the object we will use for
   // getting at the memory
   if (lstrlen(lpCommandLine) == 0) {
      // This is an error condition
      PsCleanUpAndExitProcess(pData, TRUE);
   }

   pData->hShared = OpenFileMapping( FILE_MAP_READ, FALSE, lpCommandLine);

   if (pData->hShared == (HANDLE) NULL ) {


      PsLogEventAndIncludeLastError(EVENT_PSTODIB_INIT_FAILED,TRUE);
      PsCleanUpAndExitProcess( pData, TRUE );

   } else{

      pData->pShared = (PPSPRINT_SHARED_MEMORY) MapViewOfFile( pData->hShared,
                                                               FILE_MAP_READ,
                                                               0,
                                                               0,
                                                               1000 );


      if (pData->pShared == (PPSPRINT_SHARED_MEMORY) NULL) {
        PsLogEventAndIncludeLastError(EVENT_PSTODIB_INIT_FAILED,TRUE);
        PsCleanUpAndExitProcess( pData, TRUE );
      }


       // Now set up the data from the shared memory region
      pData->pDocument =  (LPTSTR) UTLPSRETURNPTRFROMITEM(pData->pShared,
                                                 pData->pShared->dwDocumentName);

      pData->pPrinterName  =  (LPTSTR) UTLPSRETURNPTRFROMITEM(pData->pShared,
                                                 pData->pShared->dwPrinterName);


      PsInitPrintEnv( pData, (LPDEVMODE) UTLPSRETURNPTRFROMITEM( pData->pShared,
                                                                 pData->pShared->dwDevmode));




      pData->pDocumentPrintDocName = (LPTSTR)
                                      UTLPSRETURNPTRFROMITEM( pData->pShared,
                                                 pData->pShared->dwPrintDocumentDocName);




      pData->semPaused = OpenEvent( EVENT_ALL_ACCESS,
                                   FALSE,
                                   (LPWSTR) UTLPSRETURNPTRFROMITEM( pData->pShared,
                                   pData->pShared->dwControlName));
      if (pData->semPaused == (HANDLE) NULL) {
        PsLogEventAndIncludeLastError(EVENT_PSTODIB_INIT_FAILED,TRUE);
        PsCleanUpAndExitProcess( pData, TRUE );
      }

      pData->pdwFlags = (LPDWORD) &pData->pShared->dwFlags;
      pData->JobId = pData->pShared->dwJobId;


      //
      // Now check our Abort immediately flag. If its set GET OUT!
      // This flag means that the print processor was not able to
      // correclty set the AccessToken of the primage thread of this
      // process to imporsonate the user which submitted the print job.
      // because of this we immediately exit.
      //
      if (*(pData->pdwFlags) & PS_SHAREDMEM_SECURITY_ABORT ) {
#ifdef MYPSDEBUG
         printf("\nSFMPSEXE: Aborting due to security violation request from sfmpsprt");
#endif
         PsCleanUpAndExitProcess(pData,TRUE);
      }

      if (!OpenPrinter(pData->pDocumentPrintDocName,
      					  &pData->hPrinter,
                       (LPPRINTER_DEFAULTS) NULL)) {
			PsLogEventAndIncludeLastError(EVENT_PSTODIB_INIT_FAILED,TRUE);
         PsCleanUpAndExitProcess(pData,TRUE);
      }

      // if there was no devmode get the default one...
      if ( pData->printEnv.lpDevmode == (LPDEVMODE) NULL) {
         PsGetDefaultDevmode( pData );
      }


      PsMakeDefaultDevmodeModsAndSetupResolution( pData, &psDibParms );


      // Now build up the structure for Starting PStoDIB
      psDibParms.uiOpFlags = 0;  //Clear out to begin with..
      psDibParms.fpEventProc =  PsPrintCallBack;
      psDibParms.hPrivateData = (HANDLE) pData;

      //
      // Now before we kick off the interpreter lets read in the beg of the job
      // and decide if the data is to be interpreted binary.
      //
      if(PsHandleBinaryFileLogicAndReturnBinaryStatus( pData )) {
         //
         // Its a binary job so set the flag telling the interpreter such
         //

         psDibParms.uiOpFlags |= PSTODIBFLAGS_INTERPRET_BINARY;

#ifdef MYPSDEBUG
         printf("\nSFMPSEXE:Binary requested");
#endif

      }



      bRetVal = !PStoDIB(&psDibParms);


    }

    //
    // This function will clean up and call ExitProcess()
    // thus we will NEVER get past this code
    //
    PsCleanUpAndExitProcess( pData, bRetVal);

    // keep the compiler happy...
    //
    return(0);
}


/*** PsCleanUpAndExitProcess
 *
 * This function cleans up any resources allocated, then calls ExitProcess
 * to terminate.
 *
 *
 * 	Entry:
 *      pData			= Pointer to current job structure
 *		  bAbort  		= if true we are aborting.
 *
 *		Returns:
 *      Never returns ANYTHING process actually ends HERE!
 */
VOID
PsCleanUpAndExitProcess(
	IN PPSEXEDATA pData,
   IN BOOL bAbort )
{

    // First clean up the DC, if we had one...
    //
    if (pData->hDC != (HDC) NULL) {

      if (bAbort) {
         AbortDoc( pData->hDC );
      } else {
         EndDoc( pData->hDC );
      }
      DeleteDC( pData->hDC);
    }



    //
    // Now reset the error flag to error if we never did the startdoc
    // this will force the spooler to remove the job.
    //

    if ( !(pData->printEnv.dwFlags & PS_PRINT_STARTDOC_INITIATED ) ){
       bAbort = TRUE;
    }


    // Clean up the devmode if we allocated it
    if (pData->printEnv.dwFlags & PS_PRINT_FREE_DEVMODE) {
       LocalFree( (HLOCAL) pData->printEnv.lpDevmode);
    }

    // Clean up the printer handle
    //
    if (pData->hPrinter != (HANDLE) NULL) {
      ClosePrinter( pData->hPrinter);
    }

    // Close the semaphore event
    if (pData->semPaused != (HANDLE) NULL) {
       CloseHandle( pData->semPaused);
    }
    if (pData->pShared != (LPVOID) NULL) {
       UnmapViewOfFile( (LPVOID) pData->pShared);
    }
    if (pData->hShared != (HANDLE) NULL) {
       CloseHandle( pData->hShared);
    }

    ExitProcess(bAbort ? PSEXE_ERROR_EXIT:PSEXE_OK_EXIT);
}



BOOL
IsJobFromMac(
    IN PPSEXEDATA pData
)
{
    PJOB_INFO_2     pji2GetJob=NULL;
    DWORD           dwNeeded;
    DWORD           dwRetCode;
    BOOL            fJobCameFromMac;


    fJobCameFromMac = FALSE;

    //
    // get pParameters field of the jobinfo to see if this job came from a Mac
    //

    dwNeeded = 2000;
    while (1)
    {
        pji2GetJob = LocalAlloc( LMEM_FIXED, dwNeeded );
        if (pji2GetJob == NULL)
        {
            dwRetCode = GetLastError();
            break;
        }

        dwRetCode = 0;
        if (!GetJob( pData->hPrinter,pData->JobId, 2,
                            (LPBYTE)pji2GetJob, dwNeeded, &dwNeeded ))
        {
            dwRetCode = GetLastError();
        }

        if ( dwRetCode == ERROR_INSUFFICIENT_BUFFER )
        {
            LocalFree(pji2GetJob);
        }
        else
        {
            break;
        }
    }

    if (dwRetCode == 0)
    {
        //
        // if there is pParameter field present, and if it matches with our string,
        // then the job came from a Mac
        //
        if (pji2GetJob->pParameters)
        {
			if ( (wcslen(pji2GetJob->pParameters) == LSIZE_FC) &&
			     (_wcsicmp(pji2GetJob->pParameters, LFILTERCONTROL) == 0) )
            {
                fJobCameFromMac = TRUE;
            }
        }
    }

    if (pji2GetJob)
    {
        LocalFree(pji2GetJob);
    }

    return(fJobCameFromMac);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\print\psprint\debug.h ===
/*++

Copyright (c) 1992,1993  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This module defines some simple macros for determining if we are using
    the checked or free version of a component.

Author:

    James Bratsanos (v-jimbr)    8-Dec-1992


--*/

VOID DbgPsPrint(PTCHAR, ...);



#if DBG==1 && DEVL==1
#define PSCHECKED
#else
#undef PSCHECKED
#endif



#ifdef MYPSDEBUG
#define DBGOUT(parm) ( DbgPsPrint parm )
#else
#define DBGOUT(parm)
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\print\psprint\psprint.c ===
/*

Copyright (c) 1992,1993  Microsoft Corporation

Module Name:

	psprint.c

Abstract:

	This module contains the Print Processor code for the
	PStoDIB facility used to translate an incoming raw PostScript
	Level 1 data format to DIB's which can then be rendered on an
	output device.

   The print processor itself is defined as part of the WIN32 spool
   subsystem. A print processor dll is placed in a specific directory
   (based on the return of GetPrintProcessorDirectory(). The print
   processor is then added to the print subsystem by calling AddPrintProcessor()
   This is typically done by a setup program. The print subsystem only
   enumerates the print processors loaded at startup time. It does this
   by calling EnumPrintProcessorDataTypes() for each print processor registered
   with the spool subsystem. This information is kept and used to determine
   which PrintProcessor to use at print time based on the Datatype.

   This print processor exports the 4 required functions. They are:

         EnumPrintProcessorDatatypes
         OpenPrintProcessor
         PrintDocumentOnPrintProcessor
         ClosePrintProcessor
         ControlPrintProcessor


   The basic flow of a job from the spooler standpoint is as follows:

         At startup of system:

            Print subsystem enumerates all print processors registered in
            the system. For each print processor the datatypes are queried
            via EnumPrintProcessorDatatypes. This data is then stored
            as part of the print spooler information.


         A job is submitted via,
             OpenPrinter()
             StartDocPrinter()  (Datatype = PSCRIPT1)
                WritePrinter()
                WritePrinter()
                ...
                ...
             EndDocPrinter()
             ClosePrinter()



         When it comes time to print our job the spooler calls:


             handle = OpenPrintProcessor(...)


             PrintDocumentOnPrintProcessor( handle , ... )



             ClosePrintProcessor( handle )


             Optionally:

                ControlPrintProcessor - For pausing jobs etc





   The basic flow of our print processor is as follows:



         EnumPrintProcessorDatatype

            This simply returns PSCRIPT1 as a unicode string, this
            is the ONLY datatype we support.


         OpenPrintProcessor

            Here we simply allocate some memory and record the data
            passed in to us which is required to succesfully print the
            postscript job


         PrintDocumentOnPrintProcessor

            This is the main worker routine. At this point all the relevant
            data for the job is copied into some named shared memory thats
            given a unique name based on our thread id. This name is then
            passed to the PSEXE process we start via the command line.
            PSEXE does all the interaction with PSTODIB when it completes
            then PrintDocumentOnPrintProcessor returns. A process is created
            because the ported trueimage interpreter was not re-entrant. Thus
            there is no way to have multiple threads of the same process using
            the interpreter simultaneously without the threads writing over
            the interpreters global variables.


         ClosePrintProcessor

            This code simply cleans up any resources allocated and returns
            to the spooler

         ControlPrintProcessor

            This code controls pausing/un-pausing and aborting a job that
            is currently being interpreted. This is done my managing some bits
            stored in shared memory that is visible to the exe we started.


Author:

	James Bratsanos <v-jimbr@microsoft.com or mcrafts!jamesb>


Revision History:
	15 Sep 1992		Initial Version
   06 Dec 1992    Modified to kick off process instead of doing all work
                  internally
   18 Mar 1993    Corrected EnumPrintProcessorDataTypes to return correctly


Notes:	Tab stop: 4
--*/

#include <windows.h>
#include <memory.h>
#include <stdarg.h>
#include <stdio.h>
#include <winspool.h>
#include <winsplp.h>


#include "psshmem.h"
#include "psprint.h"
#include "psutl.h"
#include <excpt.h>
#include <string.h>
#include "debug.h"

#include "..\..\lib\psdiblib.h"



/***	EnumPrintProcessorDatatypes
 *
 *	Returns back the different PrintProcessor data types which we
 *	support. Currently ONLY PSCRIPT1. If the caller passed in a buffer
 * that was too small then we returned the required size.
 *
 *	Return Value:
 *
 *	    FALSE = Success
 *	    TRUE  = Failure
 */

BOOL
EnumPrintProcessorDatatypes(
    IN   LPTSTR   pName,
    IN   LPTSTR   pPrintProcessorName,
    IN   DWORD	   Level,
    OUT  LPBYTE	pDatatypes,
    IN	DWORD	   cbBuf,
    OUT  LPDWORD  pcbNeeded,
    OUT  LPDWORD  pcReturned
)
{
      DATATYPES_INFO_1    *pInfo1 = (DATATYPES_INFO_1 *)pDatatypes;
      DWORD   cbTotal=0;
      LPBYTE  pEnd;



      *pcReturned = 0;

      // If the user passed in a NULL pointer there can be no lentgh
      // associated so zero out

      if ( pDatatypes == (LPBYTE) NULL ) {
        cbBuf = (DWORD) 0;
      }

      pEnd = (LPBYTE) ( (LPBYTE)pInfo1 + cbBuf);


      cbTotal += lstrlen(PSTODIB_DATATYPE) *sizeof(TCHAR) + sizeof(TCHAR) +
                     sizeof(DATATYPES_INFO_1);


      *pcbNeeded = cbTotal;

      // If there is room in the buffer return the string
      if (cbTotal <= cbBuf) {
              pEnd -=(BYTE)( lstrlen(PSTODIB_DATATYPE) *sizeof(TCHAR) + sizeof(TCHAR));
              lstrcpy((LPTSTR) pEnd, PSTODIB_DATATYPE);
              pInfo1->pName = (LPTSTR) pEnd;


         (*pcReturned)++;


      } else{

			SetLastError(ERROR_INSUFFICIENT_BUFFER);
        	return FALSE;
      }


      return( TRUE );
}




/***	OpenPrintProcessor
 *
 *	Returns a HANDLE to an open print processor which is then used
 *	to uniquely identify this print processor in future function calls
 *	to PrintDocumentOnPrintProcessor, ClosePrintProcessor and
 *	ControlPrintProcessor.
 *
 *	Return Value:
 *
 *	    NULL  = Failure
 *	    !NULL = Success
 */

HANDLE
OpenPrintProcessor(
    IN	LPTSTR               	pPrinterName,
    IN	PPRINTPROCESSOROPENDATA pPrintProcessorOpenData
)
{
	PPRINTPROCESSORDATA pData;
   HANDLE  hHeap;
   DWORD   uDatatype=0;
   HANDLE  hPrinter=0;

   LPBYTE   pEnd;
   LPBYTE  pBuffer;
   HDC     hDC;
   DWORD dwTotDevMode;



   // If for some reason the spool subsystem called us with a datatype other
   // than PSCRIPT1 then return back a NULL handle since we dont know
   // how to handle anything other than PSCRIPT1
   if (lstrcmp( PSTODIB_DATATYPE, pPrintProcessorOpenData->pDatatype) != 0 ) {
      SetLastError(ERROR_INVALID_DATATYPE);
      return( (HANDLE) NULL );
   }

   // Allocate some memory for our job instance data
   pData = (PPRINTPROCESSORDATA) LocalAlloc( LPTR, sizeof(PRINTPROCESSORDATA));

   if (pData == (PPRINTPROCESSORDATA) NULL) {

      PsLogEvent(EVENT_PSTODIB_MEM_ALLOC_FAILURE,
                 0,
                 NULL,
                 PSLOG_ERROR);
      DBGOUT((TEXT("Memory allocation for local job storage failed")));
      SetLastError( ERROR_NOT_ENOUGH_MEMORY);
      return((HANDLE)NULL);
   }


   pData->cb          = sizeof(PRINTPROCESSORDATA);
   pData->signature   = PRINTPROCESSORDATA_SIGNATURE;
   pData->JobId       = pPrintProcessorOpenData->JobId;


   pData->pPrinterName = AllocStringAndCopy(pPrinterName);
   pData->pDatatype = AllocStringAndCopy( pPrintProcessorOpenData->pDatatype);

   pData->pDocument = AllocStringAndCopy( pPrintProcessorOpenData->pDocumentName);

   pData->pParameters = AllocStringAndCopy( pPrintProcessorOpenData->pParameters);

   // Now copy the devmode

   pData->pDevMode = NULL;
   if (pPrintProcessorOpenData->pDevMode != (LPDEVMODE) NULL) {

		dwTotDevMode = pPrintProcessorOpenData->pDevMode->dmSize +
      	             pPrintProcessorOpenData->pDevMode->dmDriverExtra;
		pData->pDevMode = (LPDEVMODE) LocalAlloc( NONZEROLPTR, dwTotDevMode );

    	if (pData->pDevMode != NULL) {
			memcpy( 	(PVOID) pData->pDevMode,
					  	(PVOID) pPrintProcessorOpenData->pDevMode,
            	  	dwTotDevMode );
			pData->dwTotDevmodeSize = dwTotDevMode;
      }
	}


   return( (HANDLE) pData );
}


/*** GenerateSharedMemoryInfo
 *
 *
 * This function copies all the relevant information into some shared
 * memory so we can pass the data to PSEXE.
 *
 * Entry:
 *    pDAta: Pointer to our internal print processor data that holds all
 *           required information for the current job we are processing
 *
 *    lpPtr: Pointer to the base of our shared memory area
 *
 * Return Value:
 *       None
 *
 */
VOID
GenerateSharedMemoryInfo(
  IN PPRINTPROCESSORDATA pData,
  IN LPVOID lpPtr
)

{
   PPSPRINT_SHARED_MEMORY pShared;

   pShared = lpPtr;

   // Record the starting position of our dynamic data, ie where strings
   // of variable length and the raw devmode bytes are stored.
   //
   pShared->dwNextOffset = sizeof(*pShared);

   // Record the size for future reference, ie if something gets added etc
   // this serves as a version number of sorts;
   //
   pShared->dwSize = sizeof(*pShared);
   pShared->dwFlags = 0;

   // Move the job id over
   pShared->dwJobId = pData->JobId;



   UTLPSCOPYTOSHARED( pShared,
                      pData->pPrinterName,
                      pShared->dwPrinterName,
                      (lstrlen(pData->pPrinterName) + 1 ) * sizeof(WCHAR) );

   UTLPSCOPYTOSHARED( pShared,
                      pData->pDocument,
                      pShared->dwDocumentName,
                      (lstrlen(pData->pDocument) + 1 ) * sizeof(WCHAR));

   UTLPSCOPYTOSHARED( pShared,
                      pData->pPrintDocumentDocName,
                      pShared->dwPrintDocumentDocName,
                      (lstrlen(pData->pPrintDocumentDocName) + 1) * sizeof(WCHAR));

   UTLPSCOPYTOSHARED( pShared,
                      pData->pDevMode,
                      pShared->dwDevmode,
                      pData->pDevMode->dmSize + pData->pDevMode->dmDriverExtra);

   UTLPSCOPYTOSHARED( pShared,
                      pData->pControlName,
                      pShared->dwControlName,
                      (lstrlen(pData->pControlName) + 1) * sizeof(WCHAR));


}





/***  PrintDocumentOnPrintProcessor
 *
 * This function gathers all required data needed to interpret/print a
 * PostScript job, puts it in a shared memory area and kicks off a process
 * called psexe to actually interpret/print the job. When PSEXE finally
 * terminates this function returns.
 *
 * Starting a seperate process is done because the PSTODIB code is NOT
 * re-entrant and thus requires a seperate data segment (for all its globals)
 * for each seperate job were interpreting. Since the spooler is ONE exe
 * with multiple threads all threads share the same data segment and thus
 * dont provide the functionality we need to implement pstodib. Starting
 * a seperate process guarantees a new DATA segment for all globals used
 * in the PSTODIB component.
 *
 *
 * Entry:
 *   hPrintProcessor: The handle we gave the print spooler via
 *                    OpenPrintProcessor.
 *
 *   pDocumentName:   The document /printer to read from so we can retrieve
 *                    the data for the current PostScript job we are to
 *                    interpret.
 *
 * Return Value:
 *
 *     TRUE  = Success
 *     FALSE = Failure
 */

BOOL
PrintDocumentOnPrintProcessor(
    HANDLE  hPrintProcessor,
    LPTSTR   pDocumentName
)
{
   PPRINTPROCESSORDATA pData;
   DOC_INFO_1 DocInfo;
   DWORD   rc;
   DWORD   NoRead, NoWritten;
   HANDLE  hPrinter;
   DOCINFO docInfo;
   TCHAR   szNameOfRegion[100];
   TCHAR szBuff[100];
   STARTUPINFO startUpInfo;
   PROCESS_INFORMATION processInfo;
   TCHAR   szCmdLine[500];
   WCHAR   szwControlEventName[33];
   DWORD   dwProcessExitCode;
   DWORD   dwProcessPriorityClass;
   DWORD   dwThreadPriority;


   LPVOID lpBase;

   if (!(pData = ValidateHandle(hPrintProcessor))) {

        SetLastError(ERROR_INVALID_HANDLE);
        DBGOUT((TEXT("handle validation failure, PrintDocumentOnPrintProcessor")));
        return FALSE;
   }


   // Store the document name so it can get copied into shared memory
   pData->pPrintDocumentDocName = AllocStringAndCopy(pDocumentName);



   wsprintf( szBuff, TEXT("%s%d"), PSTODIB_STRING, GetCurrentThreadId());


   lstrcpy( szwControlEventName, szBuff );
   lstrcat( szwControlEventName, PSTODIB_EVENT_STRING );

   pData->pControlName = AllocStringAndCopy(szwControlEventName);

   //
   // Create an event to manage pausing/unpausing the print processor
   //
   pData->semPaused   = CreateEvent(NULL, TRUE, TRUE,szwControlEventName);


   // Create a shared memory area that we can write to....
   pData->hShared = CreateFileMapping( INVALID_HANDLE_VALUE,  // out of paging file
                                       NULL,
                                       PAGE_READWRITE,
                                       0,
                                       PSTODIB_SHARED_MEM_SPACE,
                                       szBuff );

   if (pData->hShared == (HANDLE) NULL) {

      //
      // Last error should already be set by CreateFileMapping
      //
      DBGOUT((TEXT("CreateFileMapping failure in psprint")));
      return(FALSE);

   }


   lpBase = (PPSPRINT_SHARED_MEMORY) MapViewOfFile( pData->hShared,
                          FILE_MAP_WRITE,
                          0,
                          0,
                          PSTODIB_SHARED_MEM_SPACE );

   if (lpBase == (PPSPRINT_SHARED_MEMORY) NULL) {

      //
      // Last error should already be set by CreateFileMapping
      //
      DBGOUT((TEXT("MapViewOfFile failure in psprint")));
      return(FALSE);
   }


   // Put all required information into the shared memory area we created
   GenerateSharedMemoryInfo( pData, lpBase );

   // Now mark the fact that the shared memory stuff exists
   pData->pShared = (PPSPRINT_SHARED_MEMORY) lpBase;
   pData->fsStatus |= PRINTPROCESSOR_SHMEM_DEF;




   // Generate the string to pass to CreateProcess in order to start up
   // PSEXE.
   //
   // NOTE: A interesting way to debug psexe is to simply start windbg
   //       first passing in psexe and the normal command line. I found
   //       this VERY useful during debuging.
   //

   //wsprintf( szCmdLine, TEXT("windbg %s %s"), PSEXE_STRING, szBuff);
   wsprintf( szCmdLine, TEXT("%s %s"), PSEXE_STRING, szBuff);

   // Define a STARTUPINFO structure required for CreateProcess. Since
   // the new process runs DETACHED and has no console, most of the data is
   // default or none.
   startUpInfo.cb = sizeof(STARTUPINFO);
   startUpInfo.lpReserved = NULL;
   startUpInfo.lpDesktop = NULL;
   startUpInfo.lpTitle = NULL;
   startUpInfo.dwFlags = 0;
   startUpInfo.cbReserved2 = 0;
   startUpInfo.lpReserved2 = NULL;

   // ***** IMPORTANT *****
   // Create the process to actually interpret and print the specified
   // PostScript job. We create this process suspended, because of the
   // way the NT security system works. When CreateProcess is called we
   // end up giving the security access token of the spooler process to
   // PSEXE, this is incorrect since we want to give PSEXE the security
   // access token of the current thread. Since the job needs to access
   // resources which the spooler (running in the system context) may not
   // have access to but the client (whoever submitted the job) does. To
   // do this we need to set the access token of the primary thread of
   // PSEXE to whatever access token the current thread has. The way
   // this works is to create the process SUSPENDED then set the security
   // access token of the primary thread of PSEXE, then Resume the
   // thread to let it process our job. We sit blocked on WaitForSingleObject
   // until the job completes.
   //
   //

   if(!CreateProcess(NULL,
                     szCmdLine,
                     NULL,
                     NULL,
                     FALSE,
#ifdef PSCHECKED
                     CREATE_SUSPENDED | CREATE_NEW_CONSOLE, //DEBUG
#else
                     CREATE_SUSPENDED | DETACHED_PROCESS,
#endif
                     NULL,
                     NULL,
                     &startUpInfo,
                     &processInfo ) ) {

      //
      // Last error should already be set by CreateProcess
      //

	   PsPrintLogEventAndIncludeLastError( EVENT_PSTODIB_STARTPSEXE_FAILED,
   	 												TRUE );

      DBGOUT((TEXT("Create Process failed")));
      return(FALSE);
   }


#ifdef OLD_PRIORITY
   if (!SetPriorityClass(processInfo.hProcess, IDLE_PRIORITY_CLASS)){
      DBGOUT((TEXT("Failed trying to reset the priority class")));
   }
#endif

   // Just to make sure the thread priority of our new thread matches,
   // the spooler and the Priority class of our exe matches the spooler
   //

   if( (dwProcessPriorityClass = GetPriorityClass( GetCurrentProcess())) != 0 ) {

      if (!SetPriorityClass( processInfo.hProcess, dwProcessPriorityClass)) {

      	PsPrintLogEventAndIncludeLastError( EVENT_PSTODIB_SETPRIORITY_FAILED,
      													FALSE );
         DBGOUT((TEXT("Failed trying to reset priority class for smfpsexe")));
      }

   } else {

      PsPrintLogEventAndIncludeLastError( EVENT_PSTODIB_SETPRIORITY_FAILED,
      												FALSE );
      DBGOUT((TEXT("Cannot retrieve current priority class!")));
   }

   //
   // Grab the current threads priority
   //

   if ((dwThreadPriority = GetThreadPriority( GetCurrentThread())) !=
   															THREAD_PRIORITY_ERROR_RETURN ) {
     // It worked so set the thread priority
     if (!SetThreadPriority( processInfo.hThread, dwThreadPriority)) {

	      PsPrintLogEventAndIncludeLastError( EVENT_PSTODIB_SETPRIORITY_FAILED,
   	   												FALSE );

      	DBGOUT((TEXT("Setting thread priority failed for sfmpsexe")));
     }

   } else {

		PsPrintLogEventAndIncludeLastError( EVENT_PSTODIB_SETPRIORITY_FAILED,
      												FALSE );
     	DBGOUT((TEXT("Cannot retrieve thread priority, sfmpsprt.dll")));
   }



    // Why the #if 0 below....
    // NT-Spooler always runs under LocalSystem.  If macprint also runs as LocalSystem,
    // then setting security token is a no-op.  If macprint runs in some user's account then
    // we run into the following problem: user32.dll fails to initialize because this new
    // process running under user's context tries to access winsta0 and fails because it's got
    // no privileges (only LocalSystem, not even admins get this priv).  If we don't put this
    // user's token, we don't lose anything except one case: if the port is configured to go to
    // a unc name (e.g. \\foobar\share) where LocalSystem won't have priv, but the user will.
    // But this case is a generic problem in NT-Spooler, so it's an ok compromise
    //
    // p.s. another solution considered: create this process with a different winsta (pass an
    // empty string for lpDesktop parm above, instead of NULL).  This works ok except if there
    // is any dialog generated - the dialog shows up in the process's winsta, not on the desktop
    // which causes the job to "hang" waiting for input! A common case of a dialog appearing is
    // if the port configured is FILE.
#if 0
   // Set the security access token of the primary thread of PSEXE, the
   // reason for that the spooler is imporsonating the client which
   // submitted the job when we get here. Since we are kicking off another
   // process to do the real work for us, this new process primary thread
   // must have the same privelege as the current thread (namely the client
   // which submitted the job). This relies on the fact the Spooler is
   // imporsonating and thus we will fail the job if the access token
   // transfer fails.
   //
   if ( !PsUtlSetThreadToken( processInfo.hThread )) {

       /*
	    * PsPrintLogEventAndIncludeLastError( EVENT_PSTODIB_SECURITY_PROBLEM,
   	 	*											TRUE );
        */


      DBGOUT((TEXT("Failed trying to reset the thread token")));

      //
      // The code that sets the abort flag used to force the job
      // to abort. Since this behaviour does not mimick the spooler
      // we will take it out. This always caused any pstodib jobs
      // which hung around past a reboot to fail.
      //
      // JSB 6-25-93
      //
      //pData->pShared->dwFlags |= PS_SHAREDMEM_SECURITY_ABORT;



   }
#endif

   //
   // Now that we have/have not set the thread security access token for PSEXE
   // let it run its course
   //
   ResumeThread( processInfo.hThread);

   //
   // Now wait for the Interpreter to complete for any reason since
   // the spool subsystem does not expect us to return from
   // PrintDocumentOnPrintProcessor until the job is complete
   //
   WaitForSingleObject( processInfo.hProcess, INFINITE);

   // Get the termination reason
   GetExitCodeProcess( processInfo.hProcess, &dwProcessExitCode);

   // Close the handles which are not required any more
   //
   CloseHandle( processInfo.hProcess );
   CloseHandle( processInfo.hThread );


   // Clean up resources used by shared memory
   //
   return( (dwProcessExitCode == 0) ? TRUE : FALSE );

}

/*** PsLocalFree
 *
 * This function simply verifies the handle is not null and calls localfree
 *
 * Entry:
 *   lpPtr: The pointer to free if not null
 *
 * Exit:
 *   none;
 *
*/
VOID PsLocalFree( IN LPVOID lpPtr )
{
   if (lpPtr != (LPVOID) NULL) {
      LocalFree( (HLOCAL) lpPtr);
   }
}

/*** ClosePrintProcessor
 *
 * This functions simply cleans up any resources we used during our
 * job and returs:
 *
 * Entry:
 *    hPrintProcessor: The handle we returned to the spooler in the
 *                     OpenPrintProcessor call.
 *
 * Exit:
 *    True = Success
 * 	False = failure;
 *
*/
BOOL
ClosePrintProcessor(
    IN HANDLE  hPrintProcessor
)
{
    PPRINTPROCESSORDATA pData;
    HANDLE  hHeap;


    pData = ValidateHandle(hPrintProcessor);

    if (!pData) {
        SetLastError(ERROR_INVALID_HANDLE);
        DBGOUT((TEXT("Invalid handle to closeprintprocessor, psprint")));
        return FALSE;
    }


    pData->fsStatus &= ~PRINTPROCESSOR_SHMEM_DEF;
    if (pData->pShared != (PPSPRINT_SHARED_MEMORY) NULL) {
    	UnmapViewOfFile( (LPVOID) pData->pShared );
    }

    if (pData->hShared != (HANDLE) NULL) {
      CloseHandle( pData->hShared );
    }


    pData->signature = 0;

    /* Release any allocated resources */


    if( pData->semPaused != (HANDLE) NULL ) {
      CloseHandle(pData->semPaused);
    }



    PsLocalFree( (LPVOID) pData->pPrinterName);
    PsLocalFree( (LPVOID) pData->pDatatype );
    PsLocalFree( (LPVOID) pData->pDocument );
    PsLocalFree( (LPVOID) pData->pParameters);
    PsLocalFree( (LPVOID) pData->pControlName);

    PsLocalFree( (LPVOID) pData->pDevMode );
    PsLocalFree( (LPVOID) pData->pPrintDocumentDocName );
    PsLocalFree( (LPVOID) pData );


    return TRUE;
}

/* ControlPrintProcessor
 *
 * This function controls pausing/unpausing of the print processor as well
 * aborting the current job, mainly this routine either sets/clears a named
 * event that the psexe program responds to, or sets a bit in some shared
 * memory to tell psexe to abort the current job
 *
 * Entry:
 *    hPrintProcessor: The handle we returned to the spooler in the
 *                     OpenPrintProcessor call.
 *			
 *    Command:			  JOB_CONTROL_*  (PAUSE,CANCEL,RESUME) as defined by
 *                     the Win32 print processor specification
 *
 * Exit:
 *    TRUE: Request was satisfied
 *    FALSE: Request was NOT satisfied
 *
*/
BOOL
ControlPrintProcessor(
    IN HANDLE  hPrintProcessor,
    IN DWORD   Command
)
{
    PPRINTPROCESSORDATA pData;


    if (pData = ValidateHandle(hPrintProcessor)) {



        switch (Command) {

        case JOB_CONTROL_PAUSE:

            ResetEvent(pData->semPaused);
            return(TRUE);
            break;

        case JOB_CONTROL_CANCEL:



            if (pData->fsStatus & PRINTPROCESSOR_SHMEM_DEF) {
               // shared memory is defined so update the bit in the shared
               // memory areay that signal aborting of the job
               // shared memory that define our state
               pData->pShared->dwFlags |= PS_SHAREDMEM_ABORTED;
            }


            /**** Intentional fall through to release job if paused */

        case JOB_CONTROL_RESUME:


            SetEvent(pData->semPaused);
            return(TRUE);
            break;

        default:

            return(FALSE);
            break;
        }

    } else {
		 DBGOUT((TEXT("ControlPrintProcessor was passed an invalid handle, psprint")));
    }



    return( FALSE );
}

// NOT IMPLEMENTED BY SPOOLER YET, as of 3/14/93
BOOL
InstallPrintProcessor(
    HWND    hWnd
)
{
    MessageBox(hWnd, TEXT("SfmPsPrint"), TEXT("Print Processor Setup"), MB_OK);

    return TRUE;
}
/* ValidateHandle
 *
 * Helper function which verifies the passed in handle is really a
 * handle to our own internal data structure
 *
 * Entry
 *
 *    hQProc: Handle to our internal data structure
 *
 * Exit:
 *
 *    NULL:  Not a valid internal data structure
 *    !NULL: A valid pointer to our internal data structure
 *
*/
PPRINTPROCESSORDATA
ValidateHandle(
    HANDLE  hQProc
)
{
    PPRINTPROCESSORDATA pData = (PPRINTPROCESSORDATA)hQProc;

    if (pData && pData->signature == PRINTPROCESSORDATA_SIGNATURE)
        return( pData );
    else {
        return( NULL );
    }
}

#ifdef MYPSDEBUG
/* DbgPsPrint
 *
 * Debuger message facility which also pops up a message box
 *
 * Entry:
 *    wprintf style format/ var arg data
 *
 * Exit:
 *    nothing (void function)
 *
 */
VOID
DbgPsPrint(
    PTCHAR ptchFormat, ...
)
{
   va_list marker;
   TCHAR buffer[512];

   va_start( marker, ptchFormat );
   wvsprintf( buffer,  ptchFormat, marker );
   va_end( marker );
   OutputDebugString( buffer );
   MessageBox( (HWND) NULL, (LPTSTR) &buffer, TEXT("SFMPsPrint"), MB_OK);

}
#endif

/* AllocStringAndCopy
 *
 * Helper function which allocates some memory and copies the source
 * string into it
 *
 * Entry:
 *     lpSrc: Pointer to string to copy
 *
 * Exit:
 *     NULL:   Failure
 *     !NULL:  Pointer to newly allocated memory with string copied into it
 *
 */
LPTSTR
AllocStringAndCopy(
    LPTSTR lpSrc
)
{
    LPTSTR pRetString=(LPTSTR)NULL;

    // Allocate the memory for the string

    if (lpSrc) {
       pRetString = (LPTSTR) LocalAlloc(LPTR, (lstrlen(lpSrc) + 1) * sizeof(TCHAR));

       if (pRetString != (LPTSTR) NULL) {
       	lstrcpy( pRetString, lpSrc );
       } else{

		 	PsLogEvent(EVENT_PSTODIB_MEM_ALLOC_FAILURE,
         	        0,
            	     NULL,
               	  PSLOG_ERROR);
       }


    }


   return(pRetString);

}


VOID
PsPrintLogEventAndIncludeLastError(
	IN DWORD dwErrorEvent,
   IN BOOL  bError )
{
   TCHAR atBuff[20];
   TCHAR *aStrs[2];

   wsprintf( atBuff,TEXT("%d"), GetLastError());

   aStrs[0] = atBuff;

   PsLogEvent( dwErrorEvent,
               1,
               aStrs,
               PSLOG_ERROR );


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\print\psprint\psprint.h ===
/*++

Copyright (c) 1992,1993  Microsoft Corporation

Module Name:

    psprint.h

Abstract:

	 This module is the header file for psprint, which is the print processor
    we expose to the Win32 spooler. This is currently the ONLY way jobs make
    it into the pstodib component.

Author:

    James Bratsanos (v-jimbr)    8-Dec-1992


--*/

// Define the name of the executable which will actually be responsible
// for calling into the PSTODIB dll and image a postscript job.
//
#define PSEXE_STRING TEXT("sfmpsexe")

// The datatype to publish to the Win32 Spool subsystem, so the Win32 spooler
// can match jobs submitted by macprint to us
//
#define PSTODIB_DATATYPE TEXT("PSCRIPT1")

// Misc strings used to form names, including the name of the shared memory
// area we pass to the exe we start
//
#define PSTODIB_STRING TEXT("PSTODIB_")
#define PSTODIB_EVENT_STRING L"_CONTROL"

// How much misc space to allocate for the shared memory area.
//
#define PSTODIB_SHARED_MEM_SPACE 1500


typedef struct _PRINTPROCESSORDATA {
    DWORD   signature;
    DWORD   cb;
    DWORD   fsStatus;
    HANDLE  semPaused;
    LPTSTR  pPrinterName;
    HANDLE  hPrinter;
    LPTSTR  pDocument;
    LPTSTR  pDatatype;
    LPTSTR  pPrintDocumentDocName;
    LPTSTR  pParameters;
    LPWSTR  pControlName;
    DWORD   JobId;
    LPDEVMODE pDevMode;
    DWORD   dwTotDevmodeSize;
    PPSPRINT_SHARED_MEMORY pShared;
    HANDLE  hShared;
} PRINTPROCESSORDATA, *PPRINTPROCESSORDATA;

#define PRINTPROCESSORDATA_SIGNATURE    0x5051  /* 'QP' is the signature value */

/* Define flags for fsStatus field */

#define PRINTPROCESSOR_ABORTED      0x0001
#define PRINTPROCESSOR_PAUSED       0x0002
#define PRINTPROCESSOR_CLOSED       0x0004
#define PRINTPROCESSOR_SHMEM_DEF    0x0008

#define PRINTPROCESSOR_RESERVED     0xFFF8
#define LOC_DWORD_ALIGN(x) ( (x+3) & ~(0x03) )



LPTSTR AllocStringAndCopy( LPTSTR lpSrc );

VOID PsLocalFree( IN LPVOID lpPtr );
VOID GenerateSharedMemoryInfo(IN PPRINTPROCESSORDATA pData,IN LPVOID lpPtr);

PPRINTPROCESSORDATA ValidateHandle(HANDLE  hQProc);

VOID DbgPsPrint(PTCHAR ptchFormat, ...);

VOID PsPrintLogEventAndIncludeLastError(IN DWORD dwErrorEvent,IN BOOL  bError );


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\print\psexe\psexe.h ===
/*++

Copyright (c) 1992,1993  Microsoft Corporation

Module Name:

    psexe.h

Abstract:

    This module defines the items required by the main component of pstodib,
    that acts as the mediator between the spooler and actually getting data
    out on a target printer.

Author:

    James Bratsanos (v-jimbr)    8-Dec-1992

    6-21-93  v-jimbr  Added a flag to track if something was printed.

--*/

//
// Some defines for creating the error page
//
#define PS_XINCH G
#define PS_INCH 100
#define PS_HALF_INCH (PS_INCH / 2)
#define PS_QUART_INCH (PS_INCH / 4 )
#define PS_ERR_FONT_SIZE (PS_INCH / 7)
#define PS_ERR_HEADER_FONT_SIZE (PS_INCH / 6)
#define PS_ERR_LINE_WIDTH (PS_INCH / 20)
#define PS_ERR_LINE_LEN   (PS_INCH * 6)


#define PS_PRINT_EMULATE_COPIES     0x00000001
#define PS_PRINT_FREE_DEVMODE       0x00000002
#define PS_PRINT_STARTDOC_INITIATED 0x00000004


typedef struct {
  DWORD dwFlags;
  LPDEVMODE lpDevmode;
} PRINT_ENVIRONMENT, *PPRINT_ENVIRONMENT;


typedef struct {
    DWORD   signature;
    DWORD   fsStatus;
    HANDLE  semPaused;
    DWORD   uType;
    LPTSTR  pPrinterName;
    HANDLE  hPrinter;
    LPTSTR  pDocument;
    LPTSTR  pDocumentPrintDocName;
    LPTSTR  pDatatype;
    LPTSTR  pParameters;
    LPDWORD pdwFlags;
    DWORD   JobId;
    BOOL    bNeedToFreeDevmode;
    PRINT_ENVIRONMENT printEnv;
    HDC     hDC;
    HANDLE  hShared;
    PPSPRINT_SHARED_MEMORY pShared;
    LPBYTE  lpBinaryPosToReadFrom;        //The place we should start copying from
    BYTE    BinaryBuff[512];              //Temp storage for data read from job
    DWORD   cbBinaryBuff;                 //Number of bytes in temp storage
} PSEXEDATA, *PPSEXEDATA;

#define PSEXE_SIGNATURE 0x00010001


//
// Function prototypes
//
PPSEXEDATA ValidateHandle(HANDLE  hPrintProcessor);
BOOL CALLBACK PsPrintCallBack(PPSDIBPARMS,PPSEVENTSTRUCT);
BOOL PsPrintGeneratePage( PPSDIBPARMS pPsToDib, PPSEVENTSTRUCT pPsEvent);
BOOL PsGenerateErrorPage( PPSDIBPARMS pPsToDib, PPSEVENTSTRUCT pPsEvent);
BOOL PsHandleScaleEvent(  PPSDIBPARMS pPsToDib, PPSEVENTSTRUCT pPsEvent);
BOOL PsHandleStdInputRequest( PPSDIBPARMS pPsToDib,PPSEVENTSTRUCT pPsEvent);
BOOL PsCheckForWaitAndAbort(PPSEXEDATA pData );
VOID PsCleanUpAndExitProcess( PPSEXEDATA pData, BOOL bAbort);
BOOL PsGetDefaultDevmode( PPSEXEDATA );
VOID PsMakeDefaultDevmodeModsAndSetupResolution( PPSEXEDATA pData,
																 PPSDIBPARMS ppsDibParms );

VOID PsInitPrintEnv( PPSEXEDATA pData, LPDEVMODE lpDevmode );
BOOL CALLBACK PsPrintAbortProc( HDC hdc, int iError );
BOOL PsGetCurrentPageType( PPSDIBPARMS pPsToDib, PPSEVENTSTRUCT pPsEvent);
BOOL PsPrintStretchTheBitmap( PPSEXEDATA pData,
                              PPSEVENT_PAGE_READY_STRUCT ppsPageReady );


BOOL PsVerifyDCExistsAndCreateIfRequired( PPSEXEDATA pData );
VOID PsLogEventAndIncludeLastError( DWORD dwErrorEvent, BOOL bError );
BOOL PsLogNonPsError(IN PPSDIBPARMS pPsToDib,IN PPSEVENTSTRUCT pPsEvent );
BOOL PsHandleBinaryFileLogicAndReturnBinaryStatus( PPSEXEDATA pData );
BOOL IsJobFromMac( PPSEXEDATA pData );


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\print\psprint\psutl.c ===
/*

Copyright (c) 1992,1993  Microsoft Corporation

Module Name:

	psutl.c

Abstract:

	This module has a utility function which uses an NT call to set the access
   token of a thread.

Author:

	James Bratsanos <v-jimbr@microsoft.com or mcrafts!jamesb>


Revision History:
   05 May 1993    Added duplicate code and open token without imporsonation
   06 Dec 1992    Initial

Notes:	Tab stop: 4
--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "debug.h"



/***	PsUtlSetThreadToken
 *
 * This function takes a handle to a thread and copies the current threads
 * access token, to the thread passed in. The token is duplicated so
 * no changes by the new thread affect the old thread access token.
 *
 * Entry:
 *		hThreadToSet: 	Handle of the thread to update the Access token so it
 * 						matches the current thread
 *	Return Value:
 *
 *	    TRUE  = Success
 *	    FALSE = Failure
 */
BOOL PsUtlSetThreadToken( HANDLE hThreadToSet )
{

    HANDLE hNewToken;
    HANDLE hAssigned;
    BOOL bRetVal=TRUE;
    NTSTATUS ntStatusRet;

    //
    // Get the access token of the current thread in such a way as to copy it
    //
    if (OpenThreadToken(GetCurrentThread(),
                         TOKEN_DUPLICATE | TOKEN_IMPERSONATE,
                         TRUE,
                         &hNewToken)) {

       //
       // Now that we have the Token lets copy it.
       //
       if (DuplicateToken( hNewToken, SecurityImpersonation, &hAssigned)) {


          //
          // At the time there was no exposed function in Win32 to do this.
          //
          ntStatusRet = NtSetInformationThread(hThreadToSet,
                                               ThreadImpersonationToken,
                                               &hAssigned,
                                               sizeof(hAssigned));

          //
          // Close off the handle since we dont need it anymore
          //
          CloseHandle( hAssigned);

          if (!(bRetVal = ( ntStatusRet == STATUS_SUCCESS ))) {
            DBGOUT((TEXT("NtSetInformationThread failed, psprint")));
          }
       } else {
          bRetVal = FALSE;
          DBGOUT((TEXT("Duplicate Token Fails %d"),GetLastError()));
       }

       CloseHandle(hNewToken);

    }else{
       DBGOUT((TEXT("OpenThreadTokenFailed %d"),GetLastError()));
       bRetVal = FALSE;
    }



    return(bRetVal);

}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\print\psprint\psutl.h ===
/*++

Copyright (c) 1992,1993  Microsoft Corporation

Module Name:

    psutl.h

Abstract:

    This module defines the utility function used in setting the access
    token of the passed in thread, to the access token of the current
    thread

Author:

    James Bratsanos (v-jimbr)    8-Dec-1992


--*/


BOOL PsUtlSetThreadToken( HANDLE hThreadToSet );

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\psglobal\cdef.h ===

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\psqfont\psqdefp.h ===
#define PSQRAW    1
#define PSFONTSUB 2



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\print\psprint\test2.c ===
#include <windows.h>
#include <winspool.h>
//#include <winsplp.h>
#include <stdio.h>
#include <process.h>
#include <string.h>
#include "psshmem.h"
#include "psprint.h"

#define CHAR_COUNT 1000

//int _cdecl  main(int argc, char **argv)
int __cdecl main( int argc, char **argv)
{
   FILE *x_in;
   FILE *x_out;
   int x;
   int xx;
   int col=0;

   x_in = fopen( argv[1],"rb" );
   x_out = fopen( argv[2],"wb");

   x = fgetc( x_in);
   while (!feof(x_in)) {
      fputc(x, x_out);

#ifdef BREAK_AT_SPACE
      if (col == 50) {
         col = -1;
      }
      if (col < 0 ) {
         if (x == 0x20) {
            fputc(0x0d,x_out);
            fputc(0x0a,x_out);
            col = 0;
         }
      }else{
         col++;
      }
#endif

      xx = fgetc(x_in);

      if (x == 0x0d && xx != 0x0a && !feof(x_in)) {
         fputc( 0x0a, x_out);
      }
      x = xx;

   }
   fclose(x_in);
   fclose(x_out);



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\psqfont\test.c ===
// Test program for new font query stuff

#include <windows.h>
#include <stdio.h>
#include <process.h>
#include "psqfont.h"


int __cdecl main()
{

    PS_QUERY_FONT_HANDLE hFontQ;
    DWORD dwNumFonts;
    TCHAR szFont[500];
    TCHAR szFile[500];
    DWORD dwSizeFont;
    DWORD dwSizeFile;
    DWORD i;


    if (PsBeginFontQuery(&hFontQ) != PS_QFONT_SUCCESS ) {
       printf("\nPsbegin font query failed");
       exit(1);
    }


    if( PsGetNumFontsAvailable( hFontQ, &dwNumFonts) != PS_QFONT_SUCCESS){
       printf("\nPsGetNumFontsAvailable failed");
       PsEndFontQuery(hFontQ);
       exit(1);
    }

    // now enum the fonts
    for (i = 0 ; i < dwNumFonts;i++ ) {
      dwSizeFont = sizeof(szFont);
      dwSizeFile = sizeof(szFile);

      PsGetFontInfo( hFontQ, i, szFont, &dwSizeFont, szFile, &dwSizeFile);
      printf("\n%s %d ::::: %s %d", szFont,dwSizeFont,szFile,dwSizeFile);

    }
    PsEndFontQuery(hFontQ);



    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\psqfont\psqfont.h ===
/*++

Copyright (c) 1992,1993  Microsoft Corporation

Module Name:

    psqfont.h

Abstract:

    This header file contains the definitions required by the font query module
    these functions can be called in such a way to determine which PostScript
    font names will be available for the next pstodib session, the data is
    managed in the registry.

Author:

    James Bratsanos (v-jimbr)    8-Dec-1992


--*/


typedef HANDLE PS_QUERY_FONT_HANDLE;
typedef PS_QUERY_FONT_HANDLE *PPS_QUERY_FONT_HANDLE;


#define PS_QFONT_ERROR DWORD


enum {
   PS_QFONT_SUCCESS=0,
   PS_QFONT_ERROR_NO_MEM,
   PS_QFONT_ERROR_CANNOT_CREATE_HEAP,
   PS_QFONT_ERROR_NO_REGISTRY_DATA,

   PS_QFONT_ERROR_CANNOT_QUERY,
   PS_QFONT_ERROR_INVALID_HANDLE,
   PS_QFONT_ERROR_INDEX_OUT_OF_RANGE,
   PS_QFONT_ERROR_FONTNAMEBUFF_TOSMALL,
   PS_QFONT_ERROR_FONTFILEBUFF_TOSMALL,
   PS_QFONT_ERROR_NO_NTFONT_REGISTRY_DATA,
   PS_QFONT_ERROR_FONT_SUB
};



PS_QFONT_ERROR WINAPI PsBeginFontQuery( PPS_QUERY_FONT_HANDLE pFontQueryHandle);

PS_QFONT_ERROR WINAPI PsGetNumFontsAvailable( PS_QUERY_FONT_HANDLE pFontQueryHandle,
                                       DWORD *pdwFonts);

PS_QFONT_ERROR WINAPI PsGetFontInfo( PS_QUERY_FONT_HANDLE pFontQueryHandle,
                              DWORD dwIndex,
                              LPSTR lpFontName,
                              LPDWORD dwSizeOfFontName,
                              LPSTR lpFontFileName,
                              LPDWORD dwSizeOfFontFileName );

PS_QFONT_ERROR WINAPI PsEndFontQuery( PS_QUERY_FONT_HANDLE pFontQueryHandle);



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\psqfont\psqfontp.h ===
/*++

Copyright (c) 1992,1993  Microsoft Corporation

Module Name:

    psqfontp.h

Abstract:

    This header file contains the definitions required by the font query module
    that are private to that module.

Author:

    James Bratsanos (v-jimbr)    8-Dec-1992


--*/



#define PSQFONT_MAX_FONTS 50
#define PSQFONT_SCRATCH_SIZE 255



#define PSQFONT_SUBST_LIST "System\\CurrentControlSet\\Services\\MacPrint\\FontSubstList"
#define PSQFONT_NT_FONT_LIST "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts"
#define PSQFONT_CURRENT_FONT_LIST "System\\CurrentControlSet\\Services\\MacPrint\\CurrentFontList"




enum {
   PSP_DOING_PS_NAME,
   PSP_DOING_TT_NAME,
   PSP_GETTING_EOL,
};


typedef struct {
   LPSTR lpFontName;
   DWORD dwFontNameLen;
   LPSTR lpFontFileName;
   DWORD dwFontFileNameLen;
} PS_FONT_ENTRY;
typedef PS_FONT_ENTRY *PPS_FONT_ENTRY;

typedef struct {
   DWORD  dwSerial;
   HANDLE hHeap;
   DWORD  dwNumFonts;
   PS_FONT_ENTRY FontEntry[1];

} PS_FONT_QUERY;
typedef PS_FONT_QUERY *PPS_FONT_QUERY;


LPTSTR LocPsAllocAndCopy( HANDLE hHeap, LPTSTR lptStr );

#define PS_QFONT_SERIAL 0x0F010102

//
// Function Prototypes
//
LONG LocPsQueryTimeAndValueCount( HKEY hKey,
                                  LPDWORD lpdwValCount,
                                  PFILETIME lpFileTime);

BOOL PsQDLLInit(
                 PVOID hmod,
                 DWORD Reason,
                 PCONTEXT pctx OPTIONAL);


PS_QFONT_ERROR LocPsAddToListIfNTfont( PPS_FONT_QUERY pPsFontQuery,
                                       HKEY hNTFontlist,
                                       DWORD dwNumNTfonts,
                                       LPTSTR lpPsName,
                                       LPTSTR lpTTData);

LONG LocPsWriteDefaultSubListToRegistry(void);
LONG LocPsGetOrCreateSubstList( PHKEY phKey );
PS_QFONT_ERROR LocPsVerifyCurrentFontList();
VOID LocPsEndMutex(HANDLE hMutex);

VOID LocPsNormalizeFontName(LPTSTR lptIN, LPTSTR lptOUT);

PS_QFONT_ERROR LocPsMakeSubListEntry( PPS_FONT_QUERY  hFontList,
                                      LPWSTR lpNTFontData,
                                      LPTSTR lpFaceName );


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\psqfont\psqfont.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	psqfont.c

Abstract:

	This DLL is responsible for the FONTLIST management of the PSTODIB
   component of MACPRINT. It will enumerate the fontsubtitution table
   in the registry and build a composite font list that maps PostScript
   font names to TrueType TTF files installed on the current system. This
   list is built from scratch, by enumerating the postscript to true
   type list and checking to see which fonts are actually installed in
   the NT font list.
	

Author:

	James Bratsanos <v-jimbr@microsoft.com or mcrafts!jamesb>


Revision History:
	22 Nov 1992		Initial Version
   14 Jun 1993    Took out code to put new font list into registry

Notes:	Tab stop: 4
--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "psqfont.h"
#include "psqfontp.h"
#include "psqdefp.h"


//GLOBALS
HANDLE hInst;    // Global handle to our instance


/* This entry point is called on DLL initialisation.
 * We need to know the module handle so we can load resources.
 */
BOOL PsQDLLInit(
    IN PVOID hmod,
    IN DWORD Reason,
    IN PCONTEXT pctx OPTIONAL)
{
    DBG_UNREFERENCED_PARAMETER(pctx);

    if (Reason == DLL_PROCESS_ATTACH)
    {
        hInst = hmod;
    }

    return TRUE;
}




LPTSTR LocPsAllocAndCopy( HANDLE hHeap, LPTSTR lptStr )
{
   DWORD dwStrLen;
   LPTSTR lptRet;

   // Get some memory from our heap and the copy the string in

   dwStrLen = lstrlen( lptStr );
   lptRet = (LPTSTR) HeapAlloc( hHeap, 0, (dwStrLen + 1 ) * sizeof(TCHAR));

   if (lptRet != NULL) {

      // Copy it since the memory allocation succeded
      lstrcpy( lptRet, lptStr);
   }

   return(lptRet);
}




PS_QFONT_ERROR LocPsMakeSubListEntry( PPS_FONT_QUERY pFontQuery,
                                      LPWSTR lpUniNTFontData,
                                      LPTSTR lpFaceName )
{

   CHAR szFullPathToTT[MAX_PATH];
   WCHAR    uniSzFullPathToTT[MAX_PATH];
   DWORD dwSizeOfFullPathToTT;
   PPS_FONT_ENTRY pPsFontEntry;
   PS_QFONT_ERROR pPsError=PS_QFONT_SUCCESS;


   //
   // Now that we have found a match we need to get the path to
   // the TTF name. The entry we have most likely found is an FOT
   // file which we need to pass to an INTERNAL function such that
   // we may extract the full path to the TTF file name.
   //

   //
   //***** NOTE **********************************************
   //DJC NOTE: This is a call to an INTERNAL FUNCTION!!!!!!!
   //***** NOTE **********************************************
   //

   extern GetFontResourceInfoW(LPWSTR,LPDWORD, LPVOID, DWORD);

   //
   // Set the initial size of the buffer
   //

   dwSizeOfFullPathToTT = sizeof( uniSzFullPathToTT);

   if ( GetFontResourceInfoW(lpUniNTFontData,
                            &dwSizeOfFullPathToTT,
                            (LPVOID) uniSzFullPathToTT,
                            4L )) // 4 = GFRI_TTFILENAME out of wingdip.h
   {
      wcstombs( szFullPathToTT, uniSzFullPathToTT, sizeof(szFullPathToTT) );

      //
      // Okay were in good shape its a true type font...
      // This worked meaning we have a real value so lets write it
      // to the current list
      //

      if (pFontQuery->dwNumFonts < PSQFONT_MAX_FONTS) {

         pPsFontEntry = &(pFontQuery->FontEntry[ pFontQuery->dwNumFonts ]);

         pPsFontEntry->lpFontName = LocPsAllocAndCopy( pFontQuery->hHeap,
                                                       lpFaceName);

         pPsFontEntry->dwFontNameLen = lstrlen(lpFaceName) * sizeof(TCHAR)
                                          + sizeof(TCHAR);

         pPsFontEntry->lpFontFileName = LocPsAllocAndCopy( pFontQuery->hHeap,
                                                           szFullPathToTT);

         pPsFontEntry->dwFontFileNameLen = lstrlen(szFullPathToTT) * sizeof(TCHAR)
                                             + sizeof(TCHAR);

         pFontQuery->dwNumFonts++;

      }  else{

         //
         // Were out of space there are more fonts that match our criteria
         // than we are able to report back. This is not a GREAT error message
         // but adding a new one would be a change to a semi public header.
         //

         pPsError = PS_QFONT_ERROR_INDEX_OUT_OF_RANGE;
      }

   }


   return(pPsError);
}

PS_QFONT_ERROR LocPsAddToListIfNTfont( PPS_FONT_QUERY pFontQuery,
                                       HKEY hNTFontlist,
                                       DWORD dwNumNTfonts,
                                       LPTSTR lpPsName,
                                       LPTSTR lpTTData)

{

   TCHAR sztNTFontData[MAX_PATH];
   WCHAR    uniSzNTFontData[MAX_PATH];
   DWORD dwNTFontDataLen;
   DWORD dwType;
   BOOL  bFound=FALSE;




      // Now query the NT font to see if the font in question exists
  dwNTFontDataLen = sizeof(sztNTFontData);

  if ( RegQueryValueEx(   hNTFontlist,
                          lpTTData,
                          NULL,
                          &dwType,
                          sztNTFontData,
                          &dwNTFontDataLen ) == ERROR_SUCCESS ) {

      mbstowcs(uniSzNTFontData, sztNTFontData, sizeof(sztNTFontData));

      return( LocPsMakeSubListEntry( pFontQuery, uniSzNTFontData, lpPsName ));


   }



   return( PS_QFONT_SUCCESS );

}


LONG LocPsWriteDefaultSubListToRegistry(void)
{

      HKEY hSubstList;
      DWORD dwStatus;
      LPSTR lpStr;

      HRSRC hrSubst;
      HRSRC hrLoadSubst;
      CHAR  szPsName[PSQFONT_SCRATCH_SIZE];
      CHAR  szTTName[PSQFONT_SCRATCH_SIZE];
      LPSTR lpDest;
      int   iState;
      DWORD dwTotalLen;
      LONG lRetVal=PS_QFONT_SUCCESS;

      // Now lets recreate the new Key
      RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                     PSQFONT_SUBST_LIST,
                     0,
                     NULL,
                     REG_OPTION_NON_VOLATILE,
                     KEY_ALL_ACCESS | KEY_WRITE,
                     NULL,
                     &hSubstList,
                     &dwStatus );



      hrSubst = FindResourceEx( hInst,
                                "RAWDATA",
                                MAKEINTRESOURCE(PSFONTSUB),
                                0);
      if (hrSubst) {

         // Get the size of the resource for future use
         dwTotalLen = SizeofResource( hInst, hrSubst);


         // We got it... so load it and lock it!!
         hrLoadSubst = LoadResource( hInst, hrSubst);


         lpStr = (LPSTR) LockResource( hrLoadSubst);


         iState = PSP_DOING_PS_NAME;
         lpDest = szPsName;

         if (lpStr != (LPSTR) NULL) {
            // enum through the list adding the keys....
            while( dwTotalLen--) {

               switch (iState) {
                 case PSP_DOING_PS_NAME:
                   if (*lpStr == '=') {
                     *lpDest = '\000';
                     iState = PSP_DOING_TT_NAME;
                     lpDest = szTTName;

                   }else{
                     *lpDest++ = *lpStr;
                   }
                   break;
                 case PSP_GETTING_EOL:
                   if (*lpStr == 0x0a) {
                      iState = PSP_DOING_PS_NAME;

                      lpDest = szPsName;



                      // Now write to the registry
                      RegSetValueEx( hSubstList,
                                     szPsName,
                                     0,
                                     REG_SZ,
                                     szTTName,
                                     lstrlen(szTTName)+1);





                   }
                   break;
                 case PSP_DOING_TT_NAME:

                   if (*lpStr == ';') {
                      *lpDest = '\000';
                      iState = PSP_GETTING_EOL;

                   } else if (*lpStr == 0x0d) {
                      *lpDest = '\000';
                      iState = PSP_GETTING_EOL;


                   }else {
                      *lpDest++ = *lpStr;
                   }

                   break;



               }

               lpStr++;

            }

         }

      }


      RegCloseKey(hSubstList);


      return(lRetVal);
}


LONG LocPsGetOrCreateSubstList( PHKEY phKey )
{
   LONG lRetVal;
   BOOL bDone=FALSE;

   lRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                PSQFONT_SUBST_LIST,
                0,
                KEY_READ,
                phKey );


   if (lRetVal == ERROR_FILE_NOT_FOUND) {

      // Since we did not find a font substitute list create a default one!
      // in the registry
      lRetVal = LocPsWriteDefaultSubListToRegistry();



      lRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                   PSQFONT_SUBST_LIST,
                   0,
                   KEY_READ,
                   phKey );

   }
   return(lRetVal);


}


//
// LocPsNormalizeFontName
//
//   This function takes a font name as Stored in the registry and
//   normalizes it by removing all spaces and stops processing when
//   it hits a open paren
//
//    Parameters:
//        LPTSTR lptIN  -  The source  string
//        LPTSTR lptOUT -  The destination string
//
//    Returns:
//
//        Nothing...
//
VOID LocPsNormalizeFontName(LPTSTR lptIN, LPTSTR lptOUT)
{

   while(*lptIN != '\000' ) {
      if (*lptIN == '(' ) {
         break;
      } else if ( *lptIN != ' ' ) {
         *lptOUT++ = *lptIN;
      }
      lptIN++;
   }
   *lptOUT = '\000';


}




// verify the list is up to date
PS_QFONT_ERROR LocPsBuildCurrentFontList(PPS_FONT_QUERY pFontQuery )
{
   HKEY hNtFontKey;
   HKEY hSubstKey;
   DWORD dwNumSubstFonts;
   FILETIME ftSubstFontsTime;
   TCHAR sztPsName[MAX_PATH];
   TCHAR sztTTName[MAX_PATH];
   DWORD dwPsNameSize;
   DWORD dwTTNameSize;
   DWORD dwType;
   DWORD i;
   DWORD dwNumNTFonts;
   FILETIME ftNtFontTime;
   BOOL bFoundCurrentFontList = FALSE;


   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    PSQFONT_NT_FONT_LIST,
                    0,
                    KEY_READ,
                    &hNtFontKey ) != ERROR_SUCCESS ) {

      return( PS_QFONT_ERROR_NO_NTFONT_REGISTRY_DATA );

   }

   LocPsQueryTimeAndValueCount( hNtFontKey,
                                &dwNumNTFonts,
                                &ftNtFontTime);


   if (LocPsGetOrCreateSubstList( &hSubstKey ) != ERROR_SUCCESS) {
      RegCloseKey( hNtFontKey );
      return( PS_QFONT_ERROR_FONT_SUB );
   }

   // Get the value count and file time of the FontSubst entry
   LocPsQueryTimeAndValueCount( hSubstKey,
                                &dwNumSubstFonts,
                                &ftSubstFontsTime);



   // Now we have the real worker code... for each entry in our fontsubstitution
   // table we will look to see if the subst font exists in the NT font section
   // of the registry. If it does we will generate an enry in our current
   // font list that maps a PostScript font name to an TrueType .ttf file
   // with the current font.


   for( i = 0 ; i < dwNumSubstFonts; i++ ) {
      // Query the current font out of the list
      dwPsNameSize = sizeof( sztPsName);
      dwTTNameSize = sizeof( sztTTName);

      if(   RegEnumValue(  hSubstKey,
                           i,
                           sztPsName,
                           &dwPsNameSize,
                           NULL,
                           &dwType,
                           sztTTName,
                           &dwTTNameSize ) == ERROR_SUCCESS) {


         LocPsAddToListIfNTfont( pFontQuery,
                                 hNtFontKey,
                                 dwNumNTFonts,
                                 sztPsName,
                                 sztTTName);

      }

   }

   RegCloseKey(hNtFontKey);
   RegCloseKey(hSubstKey);

   return(0);

}

LONG LocPsQueryTimeAndValueCount( HKEY hKey,
                                  LPDWORD lpdwValCount,
                                  PFILETIME lpFileTime)
{

   TCHAR lptClassName[500];
   DWORD dwClassName=sizeof(lptClassName);
   DWORD dwNumSubKeys;
   DWORD dwLongestSubKeySize;
   DWORD dwMaxClass;

   DWORD dwBiggestValueName;
   DWORD dwLongestValueName;
   DWORD dwSecurityLength;

   LONG  lRetVal;


   lRetVal = RegQueryInfoKey(hKey,
                             lptClassName,
                             &dwClassName,
                             (LPDWORD) NULL,
                             &dwNumSubKeys,
                             &dwLongestSubKeySize,
                             &dwMaxClass,
                             lpdwValCount,
                             &dwBiggestValueName,
                             &dwLongestValueName,
                             &dwSecurityLength,
                             lpFileTime);

   return(lRetVal);

}






PS_QFONT_ERROR PsBeginFontQuery( PPS_QUERY_FONT_HANDLE pFontQueryHandle)
{
   HANDLE hHeap;
   PPS_FONT_QUERY pFontQuery;
   HANDLE hFontMutex;


   // Create the MUTEX that will guarantee us correct behaviour such that
   // only one user can go through this code at any time...
   //
   hFontMutex = CreateMutex( NULL, FALSE, "SFMFontListMutex");


   WaitForSingleObject( hFontMutex,INFINITE );

   //
   // 1st thing create a heap, we make all our allocations off this heap,
   // that way cleanup is quick and easy.
   //

   hHeap = HeapCreate(0, 10000, 0);

   if (hHeap == (HANDLE) NULL) {
      LocPsEndMutex( hFontMutex);
      return( PS_QFONT_ERROR_CANNOT_CREATE_HEAP );
   }

   pFontQuery = (PPS_FONT_QUERY)
                     HeapAlloc(
                        hHeap,
                        0,
                        sizeof( PS_FONT_QUERY) +
                           (sizeof(PS_FONT_ENTRY) * PSQFONT_MAX_FONTS));


   if (pFontQuery == NULL) {
      LocPsEndMutex( hFontMutex);
      HeapDestroy(hHeap);
      return( PS_QFONT_ERROR_NO_MEM);
   }

   // Now setup up the data for our font query control structure
   pFontQuery->hHeap = hHeap;
   pFontQuery->dwNumFonts = 0;
   pFontQuery->dwSerial = PS_QFONT_SERIAL;

   LocPsBuildCurrentFontList( pFontQuery );


   *pFontQueryHandle = (PS_QUERY_FONT_HANDLE) pFontQuery;

   LocPsEndMutex(hFontMutex);

   return(PS_QFONT_SUCCESS);

}
VOID LocPsEndMutex(HANDLE hMutex)
{

   // Now release the mutex
   ReleaseMutex(hMutex);

   // And finally delete it
   CloseHandle(hMutex);

}

PS_QFONT_ERROR PsGetNumFontsAvailable( PS_QUERY_FONT_HANDLE pFontQueryHandle,
                                       DWORD *pdwFonts)
{

   PPS_FONT_QUERY pFontQuery;
   pFontQuery = (PPS_FONT_QUERY) pFontQueryHandle;

   if (pFontQueryHandle == NULL || pFontQuery->dwSerial != PS_QFONT_SERIAL) {
      return( PS_QFONT_ERROR_INVALID_HANDLE );
   }

   // Handle is okay so keep going
   *pdwFonts = pFontQuery->dwNumFonts;

   return(PS_QFONT_SUCCESS);

}
PS_QFONT_ERROR PsGetFontInfo( PS_QUERY_FONT_HANDLE pFontQueryHandle,
                              DWORD dwIndex,
                              LPSTR lpFontName,
                              LPDWORD lpdwSizeOfFontName,
                              LPSTR lpFontFileName,
                              LPDWORD lpdwSizeOfFontFileName )
{

   PPS_FONT_QUERY pFontQuery;
   PPS_FONT_ENTRY pFontEntry;
   PS_QFONT_ERROR QfontError=PS_QFONT_SUCCESS;


   pFontQuery = (PPS_FONT_QUERY) pFontQueryHandle;


   if (pFontQueryHandle == NULL || pFontQuery->dwSerial != PS_QFONT_SERIAL) {
      return( PS_QFONT_ERROR_INVALID_HANDLE );
   }

   // Verify the index is in range and return the info
   if (dwIndex >= pFontQuery->dwNumFonts) {
      return PS_QFONT_ERROR_INDEX_OUT_OF_RANGE;
   }

   pFontEntry = &(pFontQuery->FontEntry[ dwIndex ]);


   // Dont do the copy if the ptr is null but only return the
   // required bytes

   if (lpFontName != NULL) {
      // Okay the user requested data so make sure there is enough
      // room and return the font name


      if (*lpdwSizeOfFontName >= pFontEntry->dwFontNameLen) {
         lstrcpy( lpFontName, pFontEntry->lpFontName);
      }else{
         QfontError = PS_QFONT_ERROR_FONTNAMEBUFF_TOSMALL;
      }


   }
   // either way set up the required size
   *lpdwSizeOfFontName = pFontEntry->dwFontNameLen;


   // Now handle the font file name
   if (lpFontFileName != NULL) {

      if (*lpdwSizeOfFontFileName >= pFontEntry->dwFontFileNameLen) {
         lstrcpy( lpFontFileName, pFontEntry->lpFontFileName);
      }else if (QfontError == PS_QFONT_SUCCESS ) {

         QfontError = PS_QFONT_ERROR_FONTFILEBUFF_TOSMALL;
      }
   }
   *lpdwSizeOfFontFileName = pFontEntry->dwFontFileNameLen;


   return(QfontError);


}



PS_QFONT_ERROR PsEndFontQuery( PS_QUERY_FONT_HANDLE pFontQueryHandle)
{

   PPS_FONT_QUERY pFontQuery;
   pFontQuery = (PPS_FONT_QUERY) pFontQueryHandle;

   if (pFontQueryHandle == NULL || pFontQuery->dwSerial != PS_QFONT_SERIAL) {
      return( PS_QFONT_ERROR_INVALID_HANDLE );
   }


   // very simple verify the handle and destroy the heap, since all allocations
   // were done off the heap were done...
   HeapDestroy( pFontQuery->hHeap );

   return(0);

}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\print\psprint\test.c ===
#include <windows.h>
#include <winspool.h>
#include <stdio.h>
#include <conio.h>
#include <process.h>
#include <string.h>
#include "psshmem.h"
#include "psprint.h"


// If you use the -m mode for stress, only printers starting with the
// define below will have jobs submitted to them
//
#define NAME_MUST_START_WITH TEXT("STRESS")


#define CHAR_COUNT 100000L


typedef BOOL (CALLBACK* FILEENUMPROC)( LPWIN32_FIND_DATA, LPTSTR , LPVOID);

BOOL bDoEnumPrinters = FALSE;
#define PRINTER_LIST_UPDATE 5000
#define SLEEP_TIME 5000


typedef struct {
   DWORD dwUpdateTime;
   int iNumPrinters;
   int iCurPrinter;
   PRINTER_INFO_2 *lpPrinters;
} PRINTERS,*LPPRINTERS;



PRINTERS Printers;


VOID generateprinterlist(VOID){
   DWORD dwNeeded;
   DWORD dwCount;
   int i;


   Printers.iNumPrinters = 0;

   // Enum all the local printers and build a little list for enuming
   // through them
   if (!EnumPrinters(PRINTER_ENUM_LOCAL,(LPTSTR)NULL,2,(LPBYTE)NULL,0,&dwNeeded,&dwCount)&&
       GetLastError() == ERROR_INSUFFICIENT_BUFFER ) {
      // Verify the last error
      Printers.lpPrinters = (PRINTER_INFO_2 *) LocalAlloc(LPTR, dwNeeded);
      if (Printers.lpPrinters == (PRINTER_INFO_2 *) NULL) {
         printf("\nNot enought mem to enum printers?");
         exit(1);
      }

      EnumPrinters( 	PRINTER_ENUM_LOCAL,
      					(LPTSTR)NULL,
                     2,
                     (LPBYTE)Printers.lpPrinters,
                     dwNeeded,
                     &dwNeeded,
                     &dwCount );


      Printers.iCurPrinter = 0;
      Printers.iNumPrinters = dwCount;


      printf("\nEnum printers returns %d", dwCount);


      for (i=0;i < Printers.iNumPrinters ; i++) {
         printf("\nPrinter %ws, %d", Printers.lpPrinters[i].pPrinterName,
         Printers.lpPrinters[i].cJobs);


      }

      Printers.dwUpdateTime = GetTickCount() + PRINTER_LIST_UPDATE;

   }else{
      printf("\nEnumPrinters returned error of %d", GetLastError());
   }

}


BOOL IsPrinterUsable( LPTSTR lpPrinterName )
{
   LPTSTR lpKeyName = NAME_MUST_START_WITH;
   int i;

   while ( *lpKeyName != '\000' ) {

      if (*lpPrinterName == '\000' ){
         return(FALSE);
      }
      if (*lpPrinterName != *lpKeyName) {
         return(FALSE);
      }
      lpKeyName++;
      lpPrinterName++;

   }

   return(TRUE);

}
LPTSTR PrnGetNextName(LPTSTR lptNameContains,int iMinJobsOnPrinter)
{
   LPTSTR lptRetVal;
   int x;

   while (TRUE) {

   	if (GetTickCount() > Printers.dwUpdateTime ) {
      	LocalFree(Printers.lpPrinters);
      	generateprinterlist();
   	}

      for (x=0;x < Printers.iNumPrinters;x++ ) {

      	if (Printers.lpPrinters[Printers.iCurPrinter].cJobs < (WORD) iMinJobsOnPrinter &&
					IsPrinterUsable( Printers.lpPrinters[Printers.iCurPrinter].pPrinterName)) {

         	// This is a candidate...
      		lptRetVal = Printers.lpPrinters[Printers.iCurPrinter].pPrinterName;

      		Printers.lpPrinters[Printers.iCurPrinter].cJobs++;


      		if (++Printers.iCurPrinter >= Printers.iNumPrinters) {
        			Printers.iCurPrinter =0;
      		}
            return(lptRetVal);
         }

      	if (++Printers.iCurPrinter >= Printers.iNumPrinters) {
        		Printers.iCurPrinter =0;
      	}
      }
      printf("\nStarting sleep...");
      Sleep(SLEEP_TIME);
      printf("\nDone sleeping");
   }
   return(lptRetVal);

}
//
// This function will enum the file mask requsted and for each file matching
// call the callback functions
//
DoFileEnumWithCallBack( LPTSTR lptFileMask, FILEENUMPROC pProc, LPVOID lpVoid )
{

   HANDLE hFind;
   WIN32_FIND_DATA FindData;
   LPTSTR lpChar;
   LPTSTR lpSepPos;
   BOOL  bFoundPathSeperator = FALSE;
   TCHAR  szPathHolder[MAX_PATH];



   //
   // Get it into local storage
   //
   lstrcpy( szPathHolder, lptFileMask);


   // The trick here is to decide if we need to generate a full path if the
   // mask included a path, because the findnextfile code will only return
   // file names.



   // Now start processing
   hFind = FindFirstFile( szPathHolder, &FindData );
   if (hFind != (HANDLE)INVALID_HANDLE_VALUE){


      lpChar = szPathHolder;
      lpSepPos = lpChar;

      // Go to the end
      while(*lpChar++ ) {
         if (*lpChar == '\\' || *lpChar == ':') {
            bFoundPathSeperator = TRUE;
            lpSepPos = lpChar;
         }
      }

      if (bFoundPathSeperator) {
         //Make the char following the last path component a NULL
         //So we can prepend the REAL path before calling the callback func
         lpSepPos++;
      }

      do {

         //
         // Now form a full path name and call the callback
         // Break out of the loop if the callback returns FALSE
         //
         if (!(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

      		lstrcpy( lpSepPos, FindData.cFileName );
         	if (!pProc( &FindData, szPathHolder, lpVoid )) {
	            break;
   	      }
         }


      } while ( FindNextFile(hFind, &FindData ));
      // DJC error here??
      FindClose(hFind);
   }



   return(1);
}


//int _cdecl  main(int argc, char **argv)
BOOL do_job( LPWIN32_FIND_DATA lpFind, WCHAR *wchOpenName, LPVOID lpVoid)
{

   static char wstrData[CHAR_COUNT];

   DWORD cbNeeded;
   DWORD cReturned;
   PRINTER_DEFAULTS Defaults;
   HANDLE hPrinter=0;
   HANDLE hFile;
   HDC hDC;
   LPTSTR lpName=TEXT("PSTODIB Local Test Printer");
   DOCINFO docInfo;
   DOC_INFO_1 doc1;
   DWORD dwTotalWrote=0;
   static BOOL bIgnore=TRUE;

#ifdef HACK_JOB
   //HAck to start where jobs left off...
   printf("\nHACK ENABLED to skip jobs........................");
   if (lstrcmpi(wchOpenName,L"x:00064.spl") == 0 ) {
      bIgnore = FALSE;
   }

   if (bIgnore) {
      return(TRUE);
   }
#endif


   docInfo.cbSize = sizeof(DOCINFO);
   docInfo.lpszDocName = wchOpenName;
   docInfo.lpszOutput = NULL;


   // 1st convert to wide format


   hFile = CreateFile( wchOpenName,
		       GENERIC_READ,
		       FILE_SHARE_READ,
		       (LPSECURITY_ATTRIBUTES) NULL,
		       OPEN_EXISTING,
		       FILE_ATTRIBUTE_NORMAL,
		       (HANDLE) NULL	);

   if ( hFile == INVALID_HANDLE_VALUE) {
    printf("\nSorry cannot open %ws", wchOpenName);
    exit(1);
   }

   //wprintf(TEXT("hello argument is %ts"), argv[0]);


   Defaults.pDatatype = PSTODIB_DATATYPE;
   Defaults.pDevMode = NULL;
   Defaults.DesiredAccess = PRINTER_ACCESS_USE;

   if (bDoEnumPrinters) {
      // Were enuming printers so get the next one in the list....
      lpName = PrnGetNextName(TEXT("PSTODIB"),5);
   }

   if (!OpenPrinter(lpName, &hPrinter, &Defaults )) {
     printf("\nCannot open the printer? %u", GetLastError());
   } else {
     DWORD dwBytesRead,dwPrintWrote;
     doc1.pDocName = wchOpenName;
     doc1.pOutputFile = NULL;
     doc1.pDatatype = NULL;

     StartDocPrinter( hPrinter, 1, (LPBYTE) &doc1 );

     printf("\nSubmitting %ws", wchOpenName);

     ReadFile( hFile, wstrData, CHAR_COUNT, &dwBytesRead, NULL);
     while ( dwBytesRead != 0 ) {
        if (wstrData[dwBytesRead - 1 ] == 0x1a) {
           dwBytesRead--;
        }
	     WritePrinter( hPrinter, wstrData, dwBytesRead, &dwPrintWrote	);
        dwTotalWrote += dwBytesRead;

	     ReadFile( hFile, wstrData, CHAR_COUNT, &dwBytesRead, NULL);
     }

     EndDocPrinter(hPrinter);

     printf("\nDone with job total wrote %d", dwTotalWrote);
   //  WritePrinter( hPrinter, (LPVOID) wstrData,
     ClosePrinter( hPrinter);



   }


   CloseHandle(hFile);




   return(TRUE);
}

#define ONE_FILE


int __cdecl main( int argc, char **argv)
{


   HANDLE hEnumFile;
   WIN32_FIND_DATA findInfo;
   WCHAR wchOpenName[MAX_PATH];

   int *xxx;

   if (argc < 2 ) {
      printf("\nUsage:  test [-m] <full path filemask of postscript files to submit>");
      printf("\n    Without the -m, test will submit to a printer called:");
      printf("\n    PSTODIB Local Test Printer");
      printf("\n    If the -m is included, it will roundrobin submit jobs to");
      printf("\n    any local printers whose names begin with STRESS<foo>");
      printf("\n    note STRESS must be ALL caps");
      printf("\n");
      exit(1);
   }


   OemToChar((LPSTR) argv[1], (LPTSTR) wchOpenName);
   if (lstrcmpi(wchOpenName,TEXT("-m")) == 0) {
      printf("\nSubmitting jobs to ALL local printers (STRES<fooo>) for stress!");

      bDoEnumPrinters=TRUE;

      generateprinterlist();

      OemToChar((LPSTR) argv[2], (LPTSTR) wchOpenName);

   }


   DoFileEnumWithCallBack( wchOpenName, do_job, (LPVOID) NULL );


   return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\psglobal\pserr.h ===
#define PSERR_ERROR 0x00000001
#define PSERR_ABORT 0x00000002

#define PS_EXCEPTION_CANT_CONTINUE ((1 << 29) | 0x00000001)







=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\psglobal\psglobal.h ===
//
// psglobal.h
//
//
// temporary include file for tumbo stuff
//
// globally included in all sources
//
//

//
// Define huge to be nothing to satisfy compiler
//
#ifdef huge
#undef huge
#endif
#define huge




#if DBG==1 && DEVL==1
#define MYPSDEBUG
#else
#undef  MYPSDEBUG
#endif

#ifdef MYPSDEBUG
#define DBGOUT(parm) (printf parm)
#else
#define DBGOUT(parm)
#endif


// take this out when we figure out how to eliminate from
// NT build compiler invocation
#ifdef DBG
#undef DBG
#endif


#define LINT_ARGS


#include <windows.h>
#include <pstodib.h>
#include <pserr.h>





#define MAX_INTERNAL_FONTS 35     // DJC redefine


// common error codes to use betwee PSTODIB and interprter
#ifndef	NOERROR
#define     NOERROR             0
#endif
#define     DICTFULL            1
#define     DICTSTACKOVERFLOW   2
#define     DICTSTACKUNDERFLOW  3
#define     EXECSTACKOVERFLOW   4
#define     HANDLEERROR         5
#define     INTERRUPT           6
#define     INVALIDACCESS       7
#define     INVALIDEXIT         8
#define     INVALIDFILEACCESS   9
#define     INVALIDFONT         10
#define     INVALIDRESTORE      11
#define     IOERROR             12
#define     LIMITCHECK          13
#define     NOCURRENTPOINT      14
#define     RANGECHECK          15
#define     STACKOVERFLOW       16
#define     STACKUNDERFLOW      17
#define     SYNTAXERROR         18
#define     TIMEOUT             19
#define     TYPECHECK           20
#define     UNDEFINED           21
#define     UNDEFINEDFILENAME   22
#define     UNDEFINEDRESULT     23
#define     UNMATCHEDMARK       24
#define     UNREGISTERED        25
#define     VMERROR             26


enum {
   PSTODIB_UNKNOWN_ERR = 100,
   PSTODIB_INVALID_PAGE_SIZE
};

// common page size declarations

enum {
   PSTODIB_LETTER = 0,
   PSTODIB_LETTERSMALL = 1,
   PSTODIB_A4 = 2,
   PSTODIB_A4SMALL = 3,
   PSTODIB_B5 = 4,
   PSTODIB_NOTE = 5,
   PSTODIB_LEGAL = 6,
   PSTODIB_LEGALSMALL = 7

};




// modules in psti.c called by rest of interpreter
VOID PsReportError(UINT);
VOID PSNotifyPageChange(UINT);
VOID PsInternalErrorCalled(VOID);
VOID PsFlushingCalled(VOID);

BOOL PsAdjustFrame(LPVOID *, DWORD );


void PsPrintPage(int nCopies,
                 int Erase,
                 LPVOID lpFrame,
                 DWORD dwWidth,
                 DWORD dwHeight,
                 DWORD dwPlanes,
                 DWORD dwPageType );

int PsReturnDefaultTItray(void);

VOID PsReportInternalError( DWORD dwFlags,DWORD dwErrorCode,DWORD dwCount,LPBYTE pByte );

VOID PsGetScaleFactor(double *, double *, UINT, UINT);

//
// Global flags used in interpreter
//
extern DWORD  dwGlobalPsToDibFlags;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\pstodib\bit2lj.h ===
/*++

Copyright (c) 1992,1993  Microsoft Corporation

Module Name:

    bit2lj.h

Abstract:

    This module defines some simple structures and macros for the component
    that generate a DIB bitmap onto a REAL HP printer by specifying PCL
    control codes.

Author:

    James Bratsanos (v-jimbr)    8-Dec-1992


--*/

typedef struct tagBitHead {
	unsigned long		Lines;
	unsigned long		BitsPerLine;
} BITHEAD;
typedef BITHEAD *PBITHEAD;


	
#define MAX_PELS_PER_LINE 	    2400
#define MAX_LINES				3180

#define FUDGE_STRIP				60


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\pstodib\psstdio.c ===
//
// psstdio.c
//
// standard i/o stuff for interpreter event processing
//

#include "pstodib.h"
#include "psstdio.h"

//////////////////////////////////////////////////////////////////////////////
// PsEventStdin
//
// process the standard in event request for the interpreter
//
// Arguments:
//		PPSDIBPARAMS			pointer passed into PsToDib()
//		PPSEVENTSTRUCT			event structure 
//
// returns:
//		!0 if success on processing the event, else 0 to terminate
//////////////////////////////////////////////////////////////////////////////
BOOL PsEventStdin(PPSDIBPARAMS pPsToDib, PPSEVENTSTRUCT pEvent)
{
    PSEVENT_STDIN_STRUCT	 Stdin;
    BYTE 					 buff[512];
    PSEVENTSTRUCT 			 Event;
    LPTSTR 					 lpStr;
	BOOL					 fResult;
	
    Stdin.lpBuff = (LPVOID) &buff;
    Stdin.dwBuffSize = sizeof(buff);

    Event.lpVoid = (LPVOID) &Stdin;

    // set up for error condition
	fResult = FALSE;
	
    // Now call the call back....
    if (pPsToDib->fpEventProc) {
    	fResult = (*pPsToDib->fpEventProc)( pPsToDib, PSEVENT_STDIN, &Event);
    }	

	return(fResult);
}	
//////////////////////////////////////////////////////////////////////////////
// PsEventStdout
//
// process the standard out event request for the interpreter
//
// Arguments:
//		PPSDIBPARAMS			pointer passed into PsToDib()
//		PPSEVENTSTRUCT			event structure 
//
// returns:
//		!0 if success on processing the event, else 0 to terminate
//////////////////////////////////////////////////////////////////////////////

BOOL PsEventStdout(PPSDIBPARAMS, PPSEVENTSTRUCT pEvent)
{
	return(1);
}	

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\psglobal\pstodib.h ===
/*************************************************************************
*
*   PSTODIB.H - Public header for PSTODIB, any user of pstodib must
*               include this header.
*
*
*************************************************************************/






//
// Define the defualt resolution of the interpreter
//
#define PSTODIB_X_DPI 300   // Set the default DPI for the interpreter
#define PSTODIB_Y_DPI 300

//
// event type definitions
// these event types are the events that will be passed from
// the PStoDib() API to the callback function
//
enum _PSEVENT {
   PSEVENT_NOP = 0,
   PSEVENT_INIT,			            // Perform any intialization required in
   PSEVENT_PAGE_READY,              // Page worth of data is ready!!!
   PSEVENT_STDIN,         	         // Interpreter wants more data!!
   PSEVENT_SCALE,                   // requesting scale information this is called
    				                     // for every page (at the beggining)
   PSEVENT_ERROR,                   // Postscript error occured

   PSEVENT_ERROR_REPORT,            // Report at end of job about ERRORS
   PSEVENT_GET_CURRENT_PAGE_TYPE,   // The current page type
   PSEVENT_NON_PS_ERROR,            // Non PS error occured

   // THIS MUST BE THE LAST ENTRY IN THE TABLE
   PSEVENT_LAST_EVENT
};
typedef enum _PSEVENT PSEVENT;


//
// PSEVENTSTRUCT - The structure passed to the callers callback that defines
//                 the current event
//
typedef struct {
   DWORD cbSize;                           // Size of this structure
   PSEVENT uiEvent;                        // The event of type PSEVENT
   UINT uiSubEvent;                        // Currently zero (reserved)
   LPVOID lpVoid;                          // Pointer to event specific
   											// structure
} PSEVENTSTRUCT;
typedef PSEVENTSTRUCT *PPSEVENTSTRUCT;

// Dummy definition so we can compile!
//
struct _PSDIBPARMS;

// Define the format for the callers callback
//
typedef BOOL (CALLBACK *PSEVENTPROC)(struct _PSDIBPARMS *,PPSEVENTSTRUCT);


//
// uiOpFlags section......
//
#define PSTODIBFLAGS_INTERPRET_BINARY 0x00000001    // Dont tread cntr D as EOF




//
// PSDIBPARMS - The structure passed in to PSTODIB's main entry point
//              this starts an instance of the interpreter
//
typedef struct _PSDIBPARMS {
   DWORD       	cbSize;              	// The size of this structure
   PSEVENTPROC 	fpEventProc;
   HANDLE  		hPrivateData;
   UINT			uiOpFlags;				// operation mask bits
   UINT			uiXres;					// rendering x resolution
   UINT			uiYres;					// rendering y resolution
   UINT			uiXDestRes;				// x res of final destination
   UINT			uiYDestRes;				// y res of final destination

   UINT			uirectDestBounding;		// bounding rect of destination
   										// in uiXDestRes and uiYDestRes
   										// coordinates. this will be used
   										// primarily for EPS stuff
} PSDIBPARMS;
typedef PSDIBPARMS *PPSDIBPARMS;




//
// PSEVENT_PAGE_READY_STRUCT - The structure that defines the event of page
//                             ready. This is typically called at showpage
//                             time.
//
typedef struct {
   DWORD              cbSize;           // The size of the structure
   LPBITMAPINFO       lpBitmapInfo;     // A ptr that describes the format
                                        // of the bitmap
   LPBYTE             lpBuf;            // pointer to  buffer
   DWORD              dwWide;           // width in bits
   DWORD              dwHigh;           // height in bits
   UINT               uiCopies;         // number of copies to print
   INT                iWinPageType;     // Page type as a DMPAPER_*
} PSEVENT_PAGE_READY_STRUCT;
typedef PSEVENT_PAGE_READY_STRUCT *PPSEVENT_PAGE_READY_STRUCT;

//
// PSEVENT_NON_PS_ERROR_STRUCT - The structure that defines a non-ps error
//
typedef struct {
   DWORD cbSize;                        // Size of the structure
   DWORD dwErrorCode;                   // The error code
   DWORD dwCount;                       // Number of bytes of extra data
   LPBYTE lpByte;                       // Pointer to buffer with extra data
   BOOL  bError;                        // TRUE - if error , FALSE = Warning
} PSEVENT_NON_PS_ERROR_STRUCT, *PPSEVENT_NON_PS_ERROR_STRUCT;

//
// PSEVENT_CURRENT_PAGE_STRUCT
//    The structure that defines the event that gets generated when the
//    interpreter wants to know the default page size
//
typedef struct {
   DWORD cbSize;
   short dmPaperSize;   // The current page type of the printer DMPAPER_*
                        // defined in the windows header files
} PSEVENT_CURRENT_PAGE_STRUCT, *PPSEVENT_CURRENT_PAGE_STRUCT;


//
// PSEVENT_ERROR_REPORT_STRUCT
//    The report errors event dwErrFlags can have the following flags set
//
enum {
   //
   // The interpreter had a fatal postscript error and had to flush the job
   //
   PSEVENT_ERROR_REPORT_FLAG_FLUSHING = 0x00000001

};

//
// PSEVENT_ERROR_REPORT_STRUCT
// 	The structure defining the ERROR REPORT that occurs at the end of the
//    Job.
//
typedef struct {
   DWORD    dwErrCount;   			// Number of errors
   DWORD    dwErrFlags;          // Flags defined above
   PCHAR    *paErrs;             // Pointer to an array of pointers to strings
} PSEVENT_ERROR_REPORT_STRUCT, *PPSEVENT_ERROR_REPORT_STRUCT;


//
// PSEVENT_STDIN_STRUCT
//		This event is generated whenever the interpreter needs data
//
enum {
   PSSTDIN_FLAG_EOF = 0x00000001    // There is no more DATA
};

//
// stdin structure
//
typedef struct {
   DWORD   cbSize;           // Size of the structure
   LPBYTE  lpBuff;           // Buffer where interpreter wants us to stick data
   DWORD   dwBuffSize;       // Max bytes to take into buffer
   DWORD   dwActualBytes;    // Actual bytes loaded up
   UINT    uiFlags;          // flags of the type PSSTDIN_FLAG_*
} PSEVENT_STDIN_STRUCT;
typedef PSEVENT_STDIN_STRUCT *PPSEVENT_STDIN_STRUCT;

// Scale structure
//   	Allows the caller to scale the current page size
typedef struct {
   DWORD       cbSize;
   double      dbScaleX;                  // scale factor for x axis set by user
   double      dbScaleY;                  // scale factor for y axis set by user
   UINT        uiXRes;                    // pstodib's x res in pels/inch
   UINT        uiYRes;                    // pstodib's y res in pels/inch
} PS_SCALE;
typedef PS_SCALE *PPS_SCALE;


typedef struct {
   PSZ         pszErrorString;            // string of error
   UINT        uiErrVal;                  // error value
} PS_ERROR;
typedef PS_ERROR *PPS_ERROR;



//
// Entry point for PSTODIB,the caller fills the structure passed in
// and calls the entry point. When the job is done pstodib returns.
//
BOOL WINAPI PStoDIB( PPSDIBPARMS );






// Define the errors that the interpreter can generate

#define PSERR_INTERPRETER_INIT_ACCESS_VIOLATION  1L
#define PSERR_INTERPRETER_JOB_ACCESS_VIOLATION   2L
#define PSERR_LOG_ERROR_STRING_OUT_OF_SEQUENCE   3L
#define PSERR_FRAME_BUFFER_MEM_ALLOC_FAILED      4L
#define PSERR_FONT_QUERY_PROBLEM                 5L
#define PSERR_EXCEEDED_INTERNAL_FONT_LIMIT       6L
#define PSERR_LOG_MEMORY_ALLOCATION_FAILURE      7L


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\pstodib\psti.h ===
/*++

Copyright (c) 1992,1993  Microsoft Corporation

Module Name:

    psti.h

Abstract:

    This module defines the items which are required for psti.c and can be
    used from other modules.

Author:

    James Bratsanos (v-jimbr)    8-Dec-1992


--*/

#ifndef PSTI_H

#define PSTI_H


//
// Defines that were originally set up in TrueImage
//
#define INFINITY 0x7f800000L   /* infinity number: IEEE format */
#define LWALIGN_L(n) ((n) & 0xffffffe0)
#define LWALIGN_R(n) (LWALIGN_L(n) + 31)






// PsInitInterpreter
// this function should perform all initialization required by the
// interpreter
//		argument is the same pointer passed to PStoDib()
//		return is !0 if successful and 0 if error occurred
//		          if 0, then a PSEVENT_ERROR will be launched
BOOL PsInitInterpreter(PPSDIBPARMS);

//PsExecuteInterpreter
// this is the main entry point for the interpreter, it will
// dispatch the call to the actual interpreter and maintain all
// necessary data structures and process the status and various
// things that happen while interpreting the postscript. when
// the interpreter needs data, has an error, or something else, it
// will return to this function and this function will declare
// an EVENT back to the main PStoDIB() API function.
//
// argument:
//		PPSDIBPARAMS	same as that passed to PStoDIB()
// returns:
//		BOOL, if !0 then continue processing, else if 0, a
//		      terminating event has occurred and after
//			  signalling that event, PStoDib() should terminate
BOOL PsExecuteInterpreter(PPSDIBPARMS);



#define PS_STDIN_BUF_SIZE		16384
#define PS_STDIN_EOF_VAL      (-1)


typedef struct {
	UINT			uiCnt;							// count in buffer
	UINT			uiOutIndex;						// output index
   UINT        uiFlags;                   // flags of type PSSTDIN_FLAG_*
   UCHAR			ucBuffer[PS_STDIN_BUF_SIZE];

} PS_STDIN;
typedef PS_STDIN *PPS_STDIN;


void 	PsInitStdin(void);
int 	PsStdinGetC(PUCHAR);

int PsInitTi(void);

void PsPageReady(int, int);
#define PS_MAX_ERROR_LINE 256


VOID PsForceAbort(VOID);



DWORD PsExceptionFilter( DWORD dwExceptionCode );
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\pstodib\psti.c ===
/*

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

	psti.c

Abstract:
	
	This file contains the code which binds the TrueImage interpreter. Any
   functions that communicate to the outside world are done via this mechanism.


--*/


#define _CTYPE_DISABLE_MACROS
#include <psglobal.h>
#include <stdio.h>
#include <ctype.h>
#include "psti.h"
#include "pstip.h"
#include "pserr.h"

#include "trueim.h"
#include <memory.h>



// Global flags actually used in interpreter
//
DWORD dwGlobalPsToDibFlags=0x00000000;


// temp global
static uiPageCnt;

// global storage for current pointer to psdibparams
// this value is saved on entry by PsInitInterpreter() and
// PsExecuteInterpreter()
static PSTODIB_PRIVATE_DATA psPrivate;



// data type for standard in
static PS_STDIN			Ps_Stdin;




BOOL  bGDIRender = FALSE;
BOOL  bWinTT = FALSE;

HANDLE hInst;  // handle to our DLL instance required later


static UINT uiWidth, uiHeight;
static DWORD   dwCountBytes;


static LPBYTE lpbyteFrameBuf = NULL;


//
// Define the tray mapping so we can go from TrueImage page size to
// Windows page size
//
typedef struct {
   INT iTITrayNum;
   INT iWinTrayNum;
} PS_TRAY_ASSOCIATION_LIST, *PPS_TRAY_ASSOCIATION_LIST;

PS_TRAY_ASSOCIATION_LIST TrayList[] = {
   PSTODIB_LETTER, DMPAPER_LETTER,
   PSTODIB_LETTERSMALL, DMPAPER_LETTERSMALL,
   PSTODIB_A4, DMPAPER_A4,
   PSTODIB_A4SMALL, DMPAPER_A4SMALL,
   PSTODIB_B5, DMPAPER_B5,
   PSTODIB_NOTE, DMPAPER_NOTE,
   PSTODIB_LEGAL, DMPAPER_LEGAL,
   PSTODIB_LEGALSMALL, DMPAPER_LEGAL,  // No legalsmall in windows..
};
#define PS_NUM_TRAYS_DEFINED ( sizeof(TrayList) / sizeof(TrayList[0]) )





int TrueImageMain(void);

/*****************************************************************************

    PsExceptionFilter - This is the exception filter for looking at exceptions
                        and deciding whether or not we should handle the
                        exception.


*****************************************************************************/
DWORD
PsExceptionFilter( DWORD dwExceptionCode )
{
   DWORD dwRetVal;

   switch( dwExceptionCode ){
   case EXCEPTION_ACCESS_VIOLATION:
   case PS_EXCEPTION_CANT_CONTINUE:
      dwRetVal = EXCEPTION_EXECUTE_HANDLER;
      break;
   default:
      dwRetVal = EXCEPTION_CONTINUE_SEARCH;
      break;

   }

   return(dwRetVal);
}





/* This entry point is called on DLL initialisation.
 * We need to know the module handle so we can load resources.
 */
BOOL WINAPI PsInitializeDll(
    IN PVOID hmod,
    IN DWORD Reason,
    IN PCONTEXT pctx OPTIONAL)
{
    DBG_UNREFERENCED_PARAMETER(pctx);

    if (Reason == DLL_PROCESS_ATTACH)
    {
        hInst = hmod;
    }

    return TRUE;
}



VOID PsInternalErrorCalled(VOID)
{
   psPrivate.psErrorInfo.dwFlags |= PSLANGERR_INTERNAL;

}
VOID PsFlushingCalled(VOID)
{
   psPrivate.psErrorInfo.dwFlags |= PSLANGERR_FLUSHING;
}



// PsInitInterpreter
// this function should perform all initialization required by the
// interpreter
//		argument is the same pointer passed to PStoDib()
//		return is !0 if successful and 0 if error occurred
//		          if 0, then a PSEVENT_ERROR will be launched
BOOL PsInitInterpreter(PPSDIBPARMS pPsToDib)
{
   int iRetVal=1;  //FAIL initially

   DBGOUT(("\nInterpreter Init.."));
   uiPageCnt = 0;

   // save pointer
	psPrivate.gpPsToDib = pPsToDib;


   dwGlobalPsToDibFlags=0x00000000;


   // Now lets set our flags that are actually used in the interpreter
   if (pPsToDib->uiOpFlags & PSTODIBFLAGS_INTERPRET_BINARY) {
      dwGlobalPsToDibFlags |= PSTODIBFLAGS_INTERPRET_BINARY;
   }


	// init the standard in stuff
	PsInitStdin();
	
	// init stuff to do with true image
   try {
	  iRetVal = PsInitTi();
   } except ( PsExceptionFilter( GetExceptionCode())) {
     // This is an exception we will handle
		if (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) {
			PsReportInternalError( PSERR_ERROR,
         		                 PSERR_INTERPRETER_INIT_ACCESS_VIOLATION,
                                0,
                                (LPBYTE) NULL );
		}

   }
   DBGOUT(("Done\n"));
	return(iRetVal == 0 );
}	
//
//
// Returns:
//     !0 = Error something did not initialize
//
int PsInitTi(void)
{
	 extern float near infinity_f ;
    extern int resolution;
    union four_byte {
    	long   ll ;
        float  ff ;
        char  FAR *address ;
    } inf4;

    resolution = 300;

    inf4.ll = INFINITY;
	 infinity_f = inf4.ff;

    return(TrueImageMain());
}



VOID PsInitErrorCapture( PPSERROR_TRACK pPsError )
{
   pPsError->dwErrCnt = 0;
   pPsError->dwFlags = 0;
   pPsError->pPsLastErr = NULL;
}

VOID PsReportErrorEvent( PPSERROR_TRACK pPsError )
{
   CHAR *paErrs[PSMAX_ERRORS_TO_TRACK];
   DWORD dwCount=0;
   PPSERR_ITEM pPsErrItem;
   PSEVENTSTRUCT  psEvent;
   PSEVENT_ERROR_REPORT_STRUCT psError;
   BOOL fRet;




   pPsErrItem = pPsError->pPsLastErr;


   while (pPsErrItem != NULL) {
      paErrs[ dwCount++] = pPsErrItem->szError;
      pPsErrItem = pPsErrItem->pPsNextErr;
   }




   if(!( pPsError->dwFlags & PSLANGERR_INTERNAL)) {
      // Our internal error handler did NOT get called so reset the errors
      // to zero
      dwCount = 0;
   }




   psError.dwErrFlags = 0;
   if (pPsError->dwFlags & PSLANGERR_FLUSHING) {
      // Set the flag telling the callback that this was a flushing type
      // of job
      psError.dwErrFlags |= PSEVENT_ERROR_REPORT_FLAG_FLUSHING;
   }

   // Report the errors
   psEvent.cbSize  = sizeof(psEvent);
   psEvent.uiEvent = PSEVENT_ERROR_REPORT;
   psEvent.uiSubEvent = 0;
   psEvent.lpVoid = (LPVOID) &psError;

   psError.dwErrCount = dwCount;


   psError.paErrs = paErrs;

   if (psPrivate.gpPsToDib && psPrivate.gpPsToDib->fpEventProc) {


	   fRet = (*psPrivate.gpPsToDib->fpEventProc) (psPrivate.gpPsToDib, &psEvent);
		if (!fRet) {
         // We really dont care about this, because we are done with the job
         // anyway!!!
		}




   }

}





VOID PsDoneErrorCapture( PPSERROR_TRACK pPsError )
{
   PPSERR_ITEM pCurItem;
   PPSERR_ITEM pItemToFree;


   pCurItem = pPsError->pPsLastErr;

   while (pCurItem != (PPSERR_ITEM) NULL ) {
      //
      pItemToFree = pCurItem;
      pCurItem = pCurItem->pPsNextErr;

      LocalFree( (LPVOID) pItemToFree );


   }

   pPsError->dwErrCnt = 0;
   pPsError->dwFlags = 0;

}



//
// argument:
//		PPSDIBPARAMS	same as that passed to PStoDIB()
// returns:
//		BOOL, if !0 then continue processing, else if 0, a
//		      terminating event has occurred and after
//			  signalling that event, PStoDib() should terminate

BOOL PsExecuteInterpreter(PPSDIBPARMS pPsToDib)
{
	extern UINT ps_call(void);
	UINT	uiResult;
	BOOL bRetVal = TRUE; // Initially all is fine


   try {
      try {
        	// save pointer
      	psPrivate.gpPsToDib = pPsToDib;
      	psPrivate.dwFlags = 0;  // NO FLAGS to begin with

         // Init the Error capture stuff
         PsInitErrorCapture( &psPrivate.psErrorInfo );


         // Execute the interpreter until we REALLY get an EOF from the IO system
         // this is the only way to guarantee we trully made it all the way through
         // the job
         while (!(psPrivate.dwFlags & PSF_EOF )) {
      	  uiResult = ps_call();
      	}


         // Now call the callback to let the user muck with the errors if he
         // wants to
         PsReportErrorEvent( &psPrivate.psErrorInfo);

      } except ( PsExceptionFilter( GetExceptionCode())) {

         DBGOUT(("\nException code being accesed"));

   		if (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) {
   			PsReportInternalError( PSERR_ERROR,
   										  PSERR_INTERPRETER_JOB_ACCESS_VIOLATION,
                                   0,
                                   (LPBYTE) NULL );
   		}
         bRetVal = FALSE;
      }
   } finally {

      PsDoneErrorCapture( &psPrivate.psErrorInfo);

   }
	return(bRetVal);
}

//
// perform any init functions necessary to get standard in stuff
// ready to go
void PsInitStdin(void)
{
	Ps_Stdin.uiCnt = 0;
	Ps_Stdin.uiOutIndex = 0;
   Ps_Stdin.uiFlags = 0;
}	

//
// PsStdinGetC()
//
// this function is called by the interpreter to request more
// standard input... this function should either return information
// from its internal buffer or shoud simply dispatch a
// call to the callback routine to satisfy the requirement
//
// argument:
//    PUCHAR      pointer to destination char
//
// returns:
//    0 if ok, else -1 if EOF condition
//
//
int PsStdinGetC(PUCHAR  pUc)
{
	PSEVENT_STDIN_STRUCT	psEventStdin;
	PSEVENTSTRUCT			psEvent;	
	int                  iRet;
   BOOL	               fTmp;

	

   iRet = 0;
   	
	if (Ps_Stdin.uiCnt) {
		// char available
      // in buffer, get it from there.
		*pUc = Ps_Stdin.ucBuffer[Ps_Stdin.uiOutIndex++];
		Ps_Stdin.uiCnt--;
	} else {
      // nothing in the buffer, ask the callback for more
      psEventStdin.cbSize = sizeof(psEventStdin);
	   psEventStdin.lpBuff = Ps_Stdin.ucBuffer;
	   psEventStdin.dwBuffSize = sizeof(Ps_Stdin.ucBuffer);
	   psEventStdin.dwActualBytes = 0;
	
	   psEvent.uiEvent = PSEVENT_STDIN;
      psEvent.uiSubEvent = 0;
	   psEvent.lpVoid = (VOID *)&psEventStdin;
		
  		if (psPrivate.gpPsToDib && psPrivate.gpPsToDib->fpEventProc) {

   		fTmp = psPrivate.gpPsToDib->fpEventProc(psPrivate.gpPsToDib, &psEvent);
	   	if (!fTmp) {
            PsForceAbort();
		   }
	      Ps_Stdin.uiCnt = psEventStdin.dwActualBytes;
	      Ps_Stdin.uiOutIndex = 0;
         Ps_Stdin.uiFlags = psEventStdin.uiFlags;

	      if (Ps_Stdin.uiCnt) {
  		   	*pUc = Ps_Stdin.ucBuffer[Ps_Stdin.uiOutIndex++];
            Ps_Stdin.uiCnt--;
	      } else {
            // no characters read from stream... test for
            // EOF condition
            if (Ps_Stdin.uiFlags & PSSTDIN_FLAG_EOF) {
               *pUc = '\0';
               iRet = PS_STDIN_EOF_VAL;
               psPrivate.dwFlags |= PSF_EOF;
            }
	   	}
      } else {
         // there either wasn't a pointer to our pstodib struct
         // or the callback function is missing.
         // this is a error condition... signal EOF to
         // the caller .
         iRet = PS_STDIN_EOF_VAL;
         psPrivate.dwFlags |= PSF_EOF;
         *pUc = '\0';
      }
	}	
	return(iRet);
}

PPSERR_ITEM PsGetGenCurrentErrorItem( PPSERROR_TRACK pPsErrTrack )
{

     PPSERR_ITEM pPsErrItem;
     PPSERR_ITEM pPsSecondToLast;
     BOOL bReuseAnyway = TRUE;


     // decide if were going to allocate a new one or reuse the oldest one

     if (pPsErrTrack->dwErrCnt < PSMAX_ERRORS_TO_TRACK ) {

        // We have room so add another element
        pPsErrItem = (PPSERR_ITEM) LocalAlloc( LPTR, sizeof(*pPsErrItem));
        if (pPsErrItem != (PPSERR_ITEM) NULL ) {
           // Great it worked so bump our count
           pPsErrTrack->dwErrCnt++;
           bReuseAnyway = FALSE;
        }

     }


     if (bReuseAnyway) {

        // We have no more room to reuse so traverse the list looking for
        // the last err and reuse its slot


        pPsErrItem = pPsErrTrack->pPsLastErr;
        pPsSecondToLast = pPsErrItem;


        if (pPsErrItem == NULL) {
				PsReportInternalError( PSERR_ABORT | PSERR_ERROR,
											  PSERR_LOG_ERROR_STRING_OUT_OF_SEQUENCE,
                                   0,
                                   NULL );
        }

        while (pPsErrItem->pPsNextErr != NULL) {

           if (pPsErrItem->pPsNextErr != NULL) {
              pPsSecondToLast = pPsErrItem;
           }
           pPsErrItem = pPsErrItem->pPsNextErr;
        }




        // Now we need to reset the second to last to be last
        //
        pPsSecondToLast->pPsNextErr = NULL;

        // Clean it out...
        //
        memset((LPVOID) pPsErrItem, 0, sizeof(*pPsErrItem));

     }


     // In either case insert the new error so its first
     //
     pPsErrItem->pPsNextErr = pPsErrTrack->pPsLastErr;
     pPsErrTrack->pPsLastErr = pPsErrItem;
     pPsErrTrack->dwCurErrCharPos = 0;


     return( pPsErrItem );
}


void PsStdoutPutC(UCHAR uc)
{

   PPSERR_ITEM pPsErrItem;
   PPSERROR_TRACK pPsErrorTrack;




   pPsErrorTrack = &psPrivate.psErrorInfo;

   pPsErrItem = pPsErrorTrack->pPsLastErr;



   // 1st decide if its an additional char to current error or
   // a new error (ie 0x0a)

   DBGOUT(("%c", uc));

   if (uc == 0x0a) {

      pPsErrItem = PsGetGenCurrentErrorItem( &psPrivate.psErrorInfo);


   } else if (isprint((int) uc) ){

      if (pPsErrItem == (PPSERR_ITEM) NULL) {
         pPsErrItem = PsGetGenCurrentErrorItem( &psPrivate.psErrorInfo);
      }

      // Valid char so put in buff...

      if ((pPsErrItem != (PPSERR_ITEM) NULL ) &&
             (pPsErrorTrack->dwCurErrCharPos < PSMAX_ERROR_STR )) {

        pPsErrItem->szError[ pPsErrorTrack->dwCurErrCharPos++] = uc;

      }

   }


}



INT PsWinToTiTray( INT iWinTray )
{
   INT i;

   for (i=0 ; i < PS_NUM_TRAYS_DEFINED ; i++ ) {
      if ( iWinTray == TrayList[i].iWinTrayNum) {
         // Found the match so return
         return( TrayList[i].iTITrayNum );
      }
   }

   // No match so ALWAYS return the first entry
   //
   return(TrayList[0].iTITrayNum);

}

INT PsTiToWinTray( INT iTITray )
{

   INT i;

   for (i=0 ; i < PS_NUM_TRAYS_DEFINED ; i++ ) {
      if ( iTITray == TrayList[i].iTITrayNum) {
         // Found the match so return
         return( TrayList[i].iWinTrayNum );
      }
   }

   // No match so ALWAYS return the first entry
   //
   return(TrayList[0].iWinTrayNum);
}



// call back and get the default windows tray
int PsReturnDefaultTItray(void)
{

   PSEVENT_CURRENT_PAGE_STRUCT  psPage;
   PSEVENTSTRUCT                psEvent;
   BOOL                         fRet;
   int                          iWinTrayVal=DMPAPER_LETTER;

   psEvent.cbSize  = sizeof(psEvent);
   psEvent.uiEvent = PSEVENT_GET_CURRENT_PAGE_TYPE;
   psEvent.uiSubEvent = 0;
   psEvent.lpVoid = (LPVOID)&psPage;

   psPage.cbSize = sizeof(psPage);
   psPage.dmPaperSize = (short)iWinTrayVal;


	if (psPrivate.gpPsToDib && psPrivate.gpPsToDib->fpEventProc) {
	   fRet = psPrivate.gpPsToDib->fpEventProc(psPrivate.gpPsToDib, &psEvent);
		if (fRet) {
         // okay the callback should have filled the tray value in so
         // see if its a supported one
         iWinTrayVal = psPage.dmPaperSize;

		} else {
         //
         // Call back requested shutdown so do it..
         //
         PsForceAbort();
      }

   }

   // Convert to TrueImage tray type and return
   //
   return( PsWinToTiTray( iWinTrayVal ));
}



VOID FlipFrame(PPSEVENT_PAGE_READY_STRUCT pPage)
{
   PDWORD  pdwTop, pdwBottom;
   PDWORD  pdwTopStart, pdwBottomStart;
   DWORD    dwWide;
   DWORD    dwHigh;
   DWORD    dwTmp;
   DWORD    dwScratch;
   DWORD    dwCnt;


   pdwTopStart = (PDWORD)pPage->lpBuf;
   pdwBottomStart = (PDWORD)(pPage->lpBuf +
                  ((pPage->dwWide / 8) * (pPage->dwHigh - 1)));

   dwWide = (pPage->dwWide / 8) / sizeof(DWORD);
   dwHigh = pPage->dwHigh / 2;


   dwCnt = 0;

   while (dwHigh--) {
      dwTmp = dwCnt++ * dwWide;

      pdwTop = pdwTopStart + dwTmp;
      pdwBottom = pdwBottomStart - dwTmp;

      for (dwTmp = 0;dwTmp < dwWide ;dwTmp++) {
         dwScratch = *pdwTop;
         *pdwTop++ = *pdwBottom;
         *pdwBottom++ = dwScratch;
      }

   }

}

//
//
// PsPrintPage
//
// called by interpreter when a page is ready to be
// printed
//
//
void PsPrintPage(int nCopies,
                 int Erase,
                 LPVOID lpFrame,
                 DWORD dwWidth,
                 DWORD dwHeight,
                 DWORD dwPlanes,
                 DWORD dwPageType )

{
   PSEVENT_PAGE_READY_STRUCT  psPage;
   PSEVENTSTRUCT              psEvent;
   BOOL                       fRet;

   //
   // Make room for the color table
   //
   BYTE  MemoryOnTheStack[sizeof(BITMAPINFO) + sizeof(RGBQUAD) * 3];
   LPBITMAPINFO LpBmpInfo= (LPBITMAPINFO) &MemoryOnTheStack[0];



   psEvent.uiEvent = PSEVENT_PAGE_READY;
   psEvent.uiSubEvent = 0;
   psEvent.lpVoid = (LPVOID)&psPage;




   //
   //Set up the PAGE event appropriately
   //
   psPage.cbSize = sizeof(psPage);



   LpBmpInfo->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
   LpBmpInfo->bmiHeader.biWidth= dwWidth;
   LpBmpInfo->bmiHeader.biHeight = dwHeight;
   LpBmpInfo->bmiHeader.biPlanes = 1;
   LpBmpInfo->bmiHeader.biBitCount = 1;
   LpBmpInfo->bmiHeader.biCompression = BI_RGB;
   LpBmpInfo->bmiHeader.biSizeImage = dwWidth / 8 * dwHeight;


   LpBmpInfo->bmiHeader.biXPelsPerMeter = 0;
   LpBmpInfo->bmiHeader.biYPelsPerMeter = 0;
   LpBmpInfo->bmiHeader.biClrUsed = 2;
   LpBmpInfo->bmiHeader.biClrImportant = 0;


   LpBmpInfo->bmiColors[1].rgbBlue = 0;
   LpBmpInfo->bmiColors[1].rgbRed = 0;
   LpBmpInfo->bmiColors[1].rgbGreen = 0;
   LpBmpInfo->bmiColors[1].rgbReserved = 0;

   LpBmpInfo->bmiColors[0].rgbBlue = 255;
   LpBmpInfo->bmiColors[0].rgbRed = 255;
   LpBmpInfo->bmiColors[0].rgbGreen = 255;
   LpBmpInfo->bmiColors[0].rgbReserved = 0;

   psPage.lpBitmapInfo = LpBmpInfo;


   // Set up the pointer to the DIB
   psPage.lpBuf = lpFrame;
   psPage.dwWide = dwWidth;
   psPage.dwHigh = dwHeight;
   psPage.uiCopies = (UINT)nCopies;
   psPage.iWinPageType = PsTiToWinTray( (INT) dwPageType );


   DBGOUT(("\nPage [Type %d, %d x %d] #%d, imaged.. converting->",
         dwPageType,
         dwWidth,
         dwHeight,
         uiPageCnt));

   uiPageCnt++;

	if (psPrivate.gpPsToDib && psPrivate.gpPsToDib->fpEventProc) {


      // Before we call the callback flip the frame buffer so it is in
      // proper DIB format, ie first byte is first byte of LAST scanline
      //
      FlipFrame( &psPage );

      // Now call the callback to let it do whatever it wants with the
      // DIB
	   fRet = psPrivate.gpPsToDib->fpEventProc(psPrivate.gpPsToDib, &psEvent);
		if (!fRet) {
         PsForceAbort();
		}

      DBGOUT(("Done:"));

   }


}


/////////////////////////////////////////////////////////////////////////////
// PsGetScaleFactor
//
// called by the interpreter to retreive a scale factor from
// the caller of pstodib... scale in the x and y axis only ...
// no transformation matrix..
//
//
// the interpreter calls here with a preset scaling factor
// pointed to by xpScale and ypScale.... these are most
// likely set to 1.0 .... this function will
// simply generate a PSEVENT and as the guy upstairs if they
// want to mangle it up...
//
// arguments:
//    double      *pScaleX       pointer to place to put x scale factor
//    double      *pScaleY       pointer to place to put y scale factor
//    UINT        uiXRes         x resolution in use by interpreter
//    UINT        uiYRes         y resolution in use by interpreter
//
// returns:
//    void
/////////////////////////////////////////////////////////////////////////////
void PsGetScaleFactor( double *pScaleX,
                         double *pScaleY,
                         UINT uiXRes,
                         UINT uiYRes)
{

   PS_SCALE                   psScale;
   PSEVENTSTRUCT              psEvent;
   BOOL                       fRet;

   psEvent.uiEvent = PSEVENT_SCALE;
   psEvent.uiSubEvent = 0;
   psEvent.lpVoid = (LPVOID)&psScale;


   psScale.dbScaleX = *pScaleX;
   psScale.dbScaleY = *pScaleY;
   psScale.uiXRes = uiXRes;
   psScale.uiYRes = uiYRes;

	if (psPrivate.gpPsToDib && psPrivate.gpPsToDib->fpEventProc) {
	   fRet = psPrivate.gpPsToDib->fpEventProc(psPrivate.gpPsToDib, &psEvent);

      if (!fRet) {
         PsForceAbort();
		}

      // scale factor cannot be bigger than 1.0...
      // only able to scale down

      if (psScale.dbScaleX <= 1.0) {
         *pScaleX = psScale.dbScaleX;
      }
      if (psScale.dbScaleY <= 1.0) {
         *pScaleY = psScale.dbScaleY;
      }
   }
}

//////////////////////////////////////////////////////////////////////////////
// PsReportError
//
// used by the interpreter to call back to caller (pstodib) to notify
// of an error occuring in the interpreter
//
// this function will declare an Event back to the caller with a string
// and structure describing the error...
//
// argument:
//    UINT uiErrorCode     code (listed in psglobal.h) indicating which error
//
// returns:
//    void
//////////////////////////////////////////////////////////////////////////////
void PsReportError(UINT uiErrorCode)
{
   typedef struct tagErrLookup {
      UINT  uiErrVal;
      PSZ   pszString;
   } ERR_LOOKUP;
   typedef ERR_LOOKUP *PERR_LOOKUP;

   static ERR_LOOKUP ErrorStrings[] = {
      { NOERROR,             "No Error" },
      { DICTFULL,            "Dictionary Full" },
      { DICTSTACKOVERFLOW,   "Dictionary Stack Overflow" },
      { DICTSTACKUNDERFLOW,  "Dictionary Stack Underflow" },
      { EXECSTACKOVERFLOW,   "Executive Stack Overflow" },
      { HANDLEERROR,         "Handler Error" },
      { INTERRUPT,           "Interrupte Error" },
      { INVALIDACCESS,       "Invalid Access" },
      { INVALIDEXIT,         "Invalid Exit" },
      { INVALIDFILEACCESS,   "Invalid File Access" },
      { INVALIDFONT,         "Invalid Font" },
      { INVALIDRESTORE,      "Invalid Restore" },
      { IOERROR,             "I/O Error" },
      { LIMITCHECK,          "Limit Check" },
      { NOCURRENTPOINT,      "No Current Point Set" },
      { RANGECHECK,          "Range Check Error" },
      { STACKOVERFLOW,       "Stack Overflow" },
      { STACKUNDERFLOW,      "Stack Underflow" },
      { SYNTAXERROR,         "Syntax Error" },
      { TIMEOUT,             "Timeout Error" },
      { TYPECHECK,           "Typecheck Error" },
      { UNDEFINED,           "Undefined Error" },
      { UNDEFINEDFILENAME,   "Undefined Filename" },
      { UNDEFINEDRESULT,     "Undefined Result" },
      { UNMATCHEDMARK,       "Unmatched Marks" },
      { UNREGISTERED,        "Unregistered Error" },
      { VMERROR,             "VM Error" },

   };

   UINT  x;
   BOOL  fFlag;
   PSEVENTSTRUCT              psEvent;
   PS_ERROR                   psError;
   BOOL                       fRet;


   fFlag = FALSE;

   for (x = 0 ;x < sizeof(ErrorStrings)/sizeof(ERR_LOOKUP) ;x++ ) {
      if (uiErrorCode == ErrorStrings[x].uiErrVal) {
         // found it.... setup and call the callback routine
         fFlag = TRUE;
         break;
      }
   }

   if (fFlag) {
      psError.pszErrorString = ErrorStrings[x].pszString;
      psError.uiErrVal = ErrorStrings[x].uiErrVal;
   } else {
      // unknown error ???
      psError.pszErrorString = "PSTODIB :: Unknown Error";
      psError.uiErrVal = PSTODIB_UNKNOWN_ERR;

   }

   psEvent.uiEvent = PSEVENT_ERROR;
   psEvent.uiSubEvent = 0;
   psEvent.lpVoid = (LPVOID)&psError;

	if (psPrivate.gpPsToDib && psPrivate.gpPsToDib->fpEventProc) {
	   fRet = psPrivate.gpPsToDib->fpEventProc(psPrivate.gpPsToDib, &psEvent);

      if (!fRet) {
         PsForceAbort();
      }
   }
}





VOID PsInitFrameBuff()
{

  psPrivate.psFrameInfo.dwFrameFlags = 0L;
}


BOOL PsAdjustFrame(LPVOID *pNewPtr, DWORD dwNewSize )
{

   PPSFRAMEINFO pFrameInfo;
   BOOL bAllocFresh = FALSE;
   BOOL bRetVal = TRUE;  // okay....
   LPVOID lpPtr;
   BOOL bDidSomething=FALSE;


   // Get a pointer to the frame buffer info
   //
   pFrameInfo = &psPrivate.psFrameInfo;



   // Here we will allocate a frame buffer or reallocate based on the
   // size requested
   if (!(pFrameInfo->dwFrameFlags & PS_FRAME_BUFF_ASSIGNED) ){
     bAllocFresh = TRUE;
     bDidSomething = TRUE;
   }


   if (bAllocFresh) {
      lpPtr = (LPVOID) GlobalAlloc( GMEM_FIXED, dwNewSize );
      if (lpPtr == (LPVOID)NULL) {

			PsReportInternalError( PSERR_ABORT | PSERR_ERROR,
										  PSERR_FRAME_BUFFER_MEM_ALLOC_FAILED,
                                0,
                                NULL );
      }
   } else if ( pFrameInfo->dwFrameSize != dwNewSize ) {

       GlobalFree(pFrameInfo->lpFramePtr);

       lpPtr = (LPVOID) GlobalAlloc( GMEM_FIXED, dwNewSize );
       if (lpPtr == (LPVOID)NULL) {

				PsReportInternalError( PSERR_ABORT | PSERR_ERROR,
											  PSERR_FRAME_BUFFER_MEM_ALLOC_FAILED,
                                   0,
                                   NULL );

       }
       bDidSomething = TRUE;
   }


   if (bDidSomething) {
      if (lpPtr != (LPVOID) NULL) {
        // Reset the current data
        pFrameInfo->dwFrameSize = dwNewSize;
        pFrameInfo->dwFrameFlags |= PS_FRAME_BUFF_ASSIGNED;
        pFrameInfo->lpFramePtr = lpPtr;
        *pNewPtr = lpPtr;
      } else{
        bRetVal = FALSE;
      }

   }




   return( bRetVal );

}



///////////////////////////////////////////////////////////////////////////
//
// PsReportInternalError
//		This function reports an error back through the event mechanism
//    It does not return anything
//
VOID
PsReportInternalError(
   DWORD dwFlags,
  	DWORD dwErrorCode,
   DWORD dwCount,
   LPBYTE lpByte )
{


   PSEVENT_NON_PS_ERROR_STRUCT  psError;
   PSEVENTSTRUCT              psEvent;
   BOOL                       fRet;

   psEvent.uiEvent = PSEVENT_NON_PS_ERROR;
   psEvent.uiSubEvent = 0;
   psEvent.lpVoid = (LPVOID)&psError;


   psError.cbSize = sizeof(psError);
   psError.dwErrorCode = dwErrorCode;
   psError.dwCount = dwCount;
   psError.lpByte = lpByte;
   psError.bError = dwFlags & PSERR_ERROR;



	if (psPrivate.gpPsToDib && psPrivate.gpPsToDib->fpEventProc) {

		psPrivate.gpPsToDib->fpEventProc(psPrivate.gpPsToDib, &psEvent);

   }

   if (dwFlags & PSERR_ABORT) {
      PsForceAbort();
   }

}

VOID PsForceAbort(VOID)
{
   //
   // This is our way of breaking out of the TrueImage Interpreter
   //
	RaiseException( PS_EXCEPTION_CANT_CONTINUE, 0, 0, NULL);
}


// Stub for printf if NOT debug version
#ifndef MYPSDEBUG

int __cdecl MyPrintf() { return 0;}

#ifdef _M_X86
int (__cdecl * __imp__printf) () = MyPrintf;
#else
int (__cdecl * __imp_printf) () = MyPrintf;
#endif

#if 0
int __cdecl printf( const char *ptchFormat, ... )
{

   va_list marker;

   va_start( marker, ptchFormat );
   va_end( marker );
   return(0);
}
#endif
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\pstodib\pstip.h ===
/*++

Copyright (c) 1992,1993  Microsoft Corporation

Module Name:

    pstip.h

Abstract:

    This module defines the items which are private to psti.c

Author:

    James Bratsanos (v-jimbr)    8-Dec-1992


--*/

#define PSMAX_ERRORS_TO_TRACK 10
#define PSMAX_ERROR_STR 255


typedef struct _PSERR_ITEM {
   struct _PSERR_ITEM *pPsNextErr;
   CHAR szError[PSMAX_ERROR_STR + sizeof(TCHAR)];
} PSERR_ITEM,*PPSERR_ITEM;



// Define the structure that tracks the error string that normally
// would have been echoed back to the host
typedef struct {
   DWORD dwFlags;
   DWORD dwErrCnt;
   DWORD dwCurErrCharPos;
   PPSERR_ITEM pPsLastErr;

} PSERROR_TRACK, *PPSERROR_TRACK;



// Define ERROR flags
enum {
   PSLANGERR_FLUSHING = 0x00000001,
   PSLANGERR_INTERNAL = 0x00000002,
};



enum {
   PS_FRAME_BUFF_ASSIGNED=0x00000001,
};


typedef struct {
   DWORD dwFrameFlags;
   LPBYTE lpFramePtr;
   DWORD dwFrameSize;

}  PSFRAMEINFO;
typedef PSFRAMEINFO *PPSFRAMEINFO;



typedef struct {
   DWORD dwFlags;
   PPSDIBPARMS	gpPsToDib;
   PSERROR_TRACK psErrorInfo;
   PSFRAMEINFO  psFrameInfo;
} PSTODIB_PRIVATE_DATA;



#define PSF_EOF 0x00000001           //Internal EOF flag





BOOL WINAPI PsInitializeDll(
        PVOID hmod,
        DWORD Reason,
        PCONTEXT pctx OPTIONAL);


VOID PsInitFrameBuff(VOID);

VOID FlipFrame(PPSEVENT_PAGE_READY_STRUCT pPage);


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\pstodib\test.h ===
/*++

Copyright (c) 1992,1993  Microsoft Corporation

Module Name:

    test.h

Abstract:

    This module defines some simple items used in the test program for the
    interpreter

Author:

    James Bratsanos (v-jimbr)    8-Dec-1992


--*/

PSEVENTPROC
PsPrintCallBack(
   IN PPSDIBPARMS pPsToDib,
   IN OUT PPSEVENTSTRUCT pPsEvent);



BOOL
PsHandleStdInputRequest(
   IN PPSDIBPARMS pPsToDib,
   IN OUT PPSEVENTSTRUCT pPsEvent);


BOOL PsPrintGeneratePage( PPSDIBPARMS pPsToDib, PPSEVENTSTRUCT pPsEvent);
BOOL PsHandleError( PPSDIBPARMS pPsToDib, PPSEVENTSTRUCT pPsEvent);

BOOL PsHandleErrorReport( PPSDIBPARMS pPsToDib, PPSEVENTSTRUCT pPsEvent);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\bass\fixmath.h ===
/* nearly empty FixMath.h */
#define	Fract long
#define	Fixed long
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\pstodib\pstodib.c ===
/*

Copyright (c) 1992,1993  Microsoft Corporation

Module Name:

	pstodib.c

Abstract:
	
	This file contains the entry point to the pstodib component of macprint.
   Pstodib is a fully functionac postscript compatible interpreter which is
   comprised of some custom written code and a port of Microsoft TrueImage.

Author:

	James Bratsanos <v-jimbr@microsoft.com or mcrafts!jamesb>


Revision History:
	6 Sep 1992		Initial Version

Notes:	Tab stop: 4
--*/


#include <windows.h>
#include "pstodib.h"
#include "psti.h"


///////////////////////////////////////////////////////////////////////////////
// PStoDIB()
//
// API to convert postscript to a bitmap
//
// Argument:
// 		PPSDIBPARMS		pPsToDib	pointer to a psdibparms structure
//									which contains all the various information
//									required to complete the conversion
//
// Returns:
//		BOOL						if !0 then all processing was accomplished
//									without encountering a PSEVENT_ERROR
//									condition. if 0 (FALSE) then at some
//									point a PSEVENT_ERROR occurred and the
//									callback routine was invoked to handle
//									it.
///////////////////////////////////////////////////////////////////////////////
BOOL WINAPI PStoDIB( PPSDIBPARMS pPsToDib)
{

   BOOL	fResult;
   PSEVENTSTRUCT Event;
   static BOOL bDidInit=FALSE;


   // first thing to do is inform the callback function of
   // initialization and let him do whatever he needs to do
   // no return value expected.
   Event.uiEvent = PSEVENT_INIT;
   Event.uiSubEvent = 0;
   Event.lpVoid = NULL;
   (*pPsToDib->fpEventProc)(pPsToDib, &Event);


   // now we need to init the interpreter and make sure that
   // he gets up and going.
	if(!bDidInit ) {
      	bDidInit = TRUE;

      	if (!PsInitInterpreter(pPsToDib)) {
				// something went wrong... invoke the callback with an
				// error event and then lets get out of here
					Event.uiEvent = PSEVENT_ERROR;
					Event.uiSubEvent = 0;
					Event.lpVoid = NULL;
					(*pPsToDib->fpEventProc)(pPsToDib, &Event);
					return(FALSE);
			}	
	}

	// the interpreter is initialized, lets start him up and
	// let him begin the event processing
	fResult = TRUE;

	// process the stuff
	// this will not return until done or the event processor
	// tells it to terminate	
   fResult = PsExecuteInterpreter(pPsToDib);

   // Now that were done for whatever reason lets free the memory we
   // used

	return(fResult);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\pstodib\test.c ===
#include <windows.h>
#include <stdio.h>
#include <process.h>
#include "pstodib.h"
#include "bit2lj.h"
#include "test.h"

typedef struct {
   FILE *fpIn;
   FILE *fpOut;

	unsigned int linecnt;
	unsigned int lines_to_strip;
	unsigned int BytesPerLine;
	unsigned int BytesToRead;




} TEST_INFO;
TEST_INFO testInfo;



BITHEAD	bhead;


unsigned char line_buf[MAX_PELS_PER_LINE / 8 + 1];


//#define TEST_GOING_TO_PRINTER

BOOL bDoingBinary=FALSE;



//
// bitmap to laser jet file converter
//
//


void LJReset(FILE *chan)
{
	fprintf(chan, "\x1b%c",'E');					// reset printer
}	
void LJHeader(FILE *chan)
{
	// spew out the stuff for initing the laser jet
	LJReset(chan);
	fprintf(chan, "\x01b*t300R");			// 300 dpi
	fprintf(chan, "\x01b*p0x0Y");			// position is 0,0
}
void LJGraphicsStart(FILE *chan, unsigned int cnt)
{
	fprintf(chan, "\x1b*b%dW", cnt);
}
void LJGraphicsEnd(FILE *chan)
{
	fprintf(chan, "\x01b*rB");		
}		

void LJGraphicsLineOut(FILE *chan,
						unsigned int line_num,
						unsigned char *line_buf,
						unsigned int BytesPerLine)
{
	unsigned int start, end, len;
	
	unsigned char *s, *e;
	
	// find the first black byte
	for (s = line_buf, start = 0; start < BytesPerLine ; start++, s++ ) {
		if (*s) {
			break;
		}	
		
	}	
	if (start == BytesPerLine) {
		return; 	// nothing to do
	}
	// find the last black byte
	for (e = line_buf + BytesPerLine - 1, end = BytesPerLine ;
					end ; end--, e--) {
		if (*e) {
			break;
		}	
	}	

    len = end - start;
	
	// output cursor position and then line
	fprintf(chan, "\x1b*p%dY", line_num);
	fprintf(chan, "\x1b*p%dX", start * 8);
	fprintf(chan, "\x01b*r1A");				// graphics left marg is current x
	
	LJGraphicsStart(chan, len);
	fwrite(s, sizeof(char), len, chan);
	LJGraphicsEnd(chan);
}	



BOOL
PsHandleScaleEvent(
   IN PPSDIBPARMS pPsToDib,
   IN OUT PPSEVENTSTRUCT pPsEvent)
{

   PPS_SCALE pScale;


   pScale = (PPS_SCALE) pPsEvent->lpVoid;



   pScale->dbScaleX = (double) pPsToDib->uiXDestRes / (double) pScale->uiXRes;
   pScale->dbScaleY = (double) pPsToDib->uiYDestRes / (double) pScale->uiYRes;


#ifndef TEST_GOING_TO_PRINTER
//   pScale->dbScaleX *= .7;  //DJC test
//   pScale->dbScaleY *= .7;  //DJC test
#endif

   return(TRUE);



}


/*** PsPrintCallBack
 *
 * This is the main worker function for allowing data to get into the
 *
 *
 *
 */

PSEVENTPROC
PsPrintCallBack(
   IN PPSDIBPARMS pPsToDib,
   IN OUT PPSEVENTSTRUCT pPsEvent)
{
    BOOL bRetVal=TRUE;  // defualt to failure

    // Decide on a course of action based on the event passed in
    //
    switch( pPsEvent->uiEvent ) {
    case PSEVENT_PAGE_READY:

         // The data in the pPsEvent signifies the data we need to paint..
         // for know we will treat the data as one text item null
         // terminated simply for testing...
         //
         bRetVal = PsPrintGeneratePage( pPsToDib, pPsEvent );
         break;

    case PSEVENT_SCALE:
         bRetVal = PsHandleScaleEvent( pPsToDib, pPsEvent);
         break;

    case PSEVENT_STDIN:

         // The interpreter is asking for some data so simply call
         // the print subsystem to try to satisfy the request
         //
         bRetVal = PsHandleStdInputRequest( pPsToDib, pPsEvent );
         break;

    case PSEVENT_ERROR:
         bRetVal = PsHandleError(pPsToDib, pPsEvent);
         break;
    case PSEVENT_ERROR_REPORT:
         bRetVal = PsHandleErrorReport( pPsToDib, pPsEvent);
         break;
    }

   return((PSEVENTPROC) bRetVal);
}
		

int __cdecl main( int argc, char **argv )
{

   PSDIBPARMS psDibParms;




   // 1st verify the user entered a input and output name
   if (argc < 3) {
      printf("\nUsage:  test <input ps file> <output HP file> -b");
      printf("\n-b means interpret as binary..... (no Special CTRL D EOF handling");
      exit(1);
   }


   testInfo.fpIn = fopen( argv[1], "rb" );
   if (testInfo.fpIn == NULL ) {
      printf("\nCannot open %s",argv[1]);
      exit(1);
   }

   testInfo.fpOut = fopen( argv[2],"wb");
   if (testInfo.fpOut == NULL ) {
      printf("\nCannot open %s", argv[2]);
      exit(1);
   }

    // Now build up the structure for Starting PStoDIB
    psDibParms.uiOpFlags = 0x00000000;


    if (argc > 3 && *(argv[3]) == '-' &&
       ( *(argv[3]+1) =='b' || *(argv[3]+1) == 'B' ) ) {
       printf("\nBinary requested.....");
       psDibParms.uiOpFlags |= PSTODIBFLAGS_INTERPRET_BINARY;
       bDoingBinary = TRUE;
    }
    psDibParms.fpEventProc =  (PSEVENTPROC) PsPrintCallBack;
    psDibParms.hPrivateData = (HANDLE) &testInfo;
#ifdef TEST_GOING_TO_PRINTER
    psDibParms.uiXDestRes = 300;
    psDibParms.uiYDestRes = 300;
#else
    {
      HDC hdc;
      hdc = GetDC(GetDesktopWindow());


      psDibParms.uiXDestRes = GetDeviceCaps(hdc, LOGPIXELSX);
      psDibParms.uiYDestRes = GetDeviceCaps(hdc, LOGPIXELSY);

      ReleaseDC(GetDesktopWindow(), hdc);

    psDibParms.uiXDestRes = 300;  //DJC test take out!!
    psDibParms.uiYDestRes = 300;  //DJC test take out!!
    }
#endif
    // worker routine.. wont return till its all done...
    PStoDIB(&psDibParms);

    fclose( testInfo.fpOut);
    fclose( testInfo.fpIn);

    return(0);
}


BOOL
PsHandleErrorReport(
    IN PPSDIBPARMS pPsToDib,
    IN PPSEVENTSTRUCT pPsEvent)
{
   PPSEVENT_ERROR_REPORT_STRUCT pErr;
   DWORD j;

   pErr = (PPSEVENT_ERROR_REPORT_STRUCT) pPsEvent->lpVoid;

   for (j = 0; j < pErr->dwErrCount ;j++ ) {
      printf("\n%u :::: %s", j, pErr->paErrs[j]);
   }

   return(TRUE);
}


BOOL PsHandleError(
   IN PPSDIBPARMS pPsToDib,
   IN OUT PPSEVENTSTRUCT pPsEvent)
{

   PPS_ERROR ppsError;

   ppsError = (PPS_ERROR)pPsEvent->lpVoid;

   printf("\nPSTODIB ERROR TRAP: %d, %s\n",ppsError->uiErrVal,
                                          ppsError->pszErrorString);


   return(TRUE);
}

BOOL
PsHandleStdInputRequest(
   IN PPSDIBPARMS pPsToDib,
   IN OUT PPSEVENTSTRUCT pPsEvent)
{

   TEST_INFO *pData;
   DWORD j;
   PCHAR pChar;
   PPSEVENT_STDIN_STRUCT pStdinStruct;
   static BOOL CleanEof=TRUE;


   pData = (TEST_INFO *) pPsToDib->hPrivateData;


   // Cast the data to the correct structure
   pStdinStruct = (PPSEVENT_STDIN_STRUCT) pPsEvent->lpVoid;


   pStdinStruct->dwActualBytes = fread( pStdinStruct->lpBuff,
                                        1,
                                        pStdinStruct->dwBuffSize,
                                        pData->fpIn );


   printf(".");
   if (pStdinStruct->dwActualBytes == 0) {
      // we read nothing from the file... declare an EOF
      pStdinStruct->uiFlags |= PSSTDIN_FLAG_EOF;
   }else{

     // do not pass on the EOF, note this keeps binary from working!!!
     // !!! NOTE !!!!

     if (pStdinStruct->lpBuff[ pStdinStruct->dwActualBytes - 1] == 0x1a) {
        pStdinStruct->dwActualBytes--;
     }
     if (CleanEof && bDoingBinary) {
        CleanEof = FALSE;
        if ( pStdinStruct->lpBuff[ 0 ] == 0x04 ) {
           pStdinStruct->lpBuff[0] = ' ';
        }
     }

   }


   return(TRUE);
}

/* PsPrintGeneratePage
 *
 *
 *
 *
*/
BOOL PsPrintGeneratePage( PPSDIBPARMS pPsToDib, PPSEVENTSTRUCT pPsEvent)
{

    LPBYTE lpFrameBuffer;
    PPSEVENT_PAGE_READY_STRUCT ppsPageReady;
    LPBYTE lpPtr;
    PPSEVENT_STDIN_STRUCT pStdinStruct;
    TEST_INFO *pData;
    HDC hDC;
    int iNewX,iNewY;
    int k;

    iNewX = 0;
    iNewY = 0;

//#define NULL_PAGE_OP
#ifdef NULL_PAGE_OP
    //DJC
    {
       static int a=1;

       printf("NO PAGE GENERATION,(NOP) (Page %d)", a++);
       return(TRUE);
    }
#endif





    pData = (TEST_INFO *) pPsToDib->hPrivateData;



    ppsPageReady = (PPSEVENT_PAGE_READY_STRUCT) pPsEvent->lpVoid;


#ifndef TEST_GOING_TO_PRINTER

   do {

     hDC = GetDC(GetDesktopWindow());

    {


   BOOL  bOk = TRUE;

   int   iXres, iYres;
   int iDestWide, iDestHigh;
   int iPageCount;
   int iYOffset;
   int iXSrc;
   int iYSrc;
   int iNumPagesToPrint;



   // Now do some calculations so we decide if we really need to
   // stretch the bitmap or not. If the true resolution of the target
   // printer is less than pstodibs (PSTDOBI_*_DPI) then we will shring
   // the effective area so we actually only grab a portion of the bitmap
   // However if the Target DPI is greater that PSTODIBS there is nothing
   // we can do other than actually stretch (grow) the bitmap.
   //
   //iXres = GetDeviceCaps(hDC, LOGPIXELSX);
   //iYres = GetDeviceCaps(hDC, LOGPIXELSY);
   iXres = 300;
   iYres = 300;



   iDestWide = (ppsPageReady->dwWide * iXres) / PSTODIB_X_DPI;
   iDestHigh = (ppsPageReady->dwHigh * iYres) / PSTODIB_Y_DPI;



   if ((DWORD) iDestHigh > ppsPageReady->dwHigh ) {
      iYSrc = ppsPageReady->dwHigh;
      iYOffset = 0;
   } else {
      iYSrc = iDestHigh;
      iYOffset = ppsPageReady->dwHigh - iDestHigh;
   }

   if ((DWORD) iDestWide > ppsPageReady->dwWide) {
      iXSrc = ppsPageReady->dwWide;
   } else {
      iXSrc = iDestWide;
   }


   printf("\nstretching from %d x %d, to %d x %d",
            iXSrc,
            iYSrc,
            iDestWide,
            iDestHigh);







   if ((iDestWide == iXSrc) &&
       (iDestHigh == iYSrc)  ) {

      SetDIBitsToDevice(	hDC,
      							0,
                           0,
                           iDestWide,
                           iDestHigh,
                           iNewX,
                           iYOffset + iNewY,
                           0,
                           ppsPageReady->dwHigh,
                           (LPVOID) ppsPageReady->lpBuf,
                           ppsPageReady->lpBitmapInfo,
                           DIB_RGB_COLORS );
      							


   }else{

   SetStretchBltMode( hDC, BLACKONWHITE);

   StretchDIBits  ( hDC,
                               0,
                               0,
                               iDestWide,
                               iDestHigh,
                               0,
                               iYOffset, //ppsPageReady->dwHigh - dwDestHigh,
                               iXSrc,
                               iYSrc,
                               (LPVOID) ppsPageReady->lpBuf,
                               ppsPageReady->lpBitmapInfo,
                               DIB_RGB_COLORS,
                               SRCCOPY );

    }

    }


    //EndPage(hDC );
    //EndDoc( hDC);
    //DeleteDC( hDC );
    ReleaseDC( GetDesktopWindow(), hDC);

    k = getchar();
    printf("\nGOT %c", k);

    if (k == ' ') {
       break;
    } else {
       switch (k) {
       case 'u':
          iNewY -= 90;
          break;
       case 'd':
          iNewY += 90;
          break;
       case 'l':
          iNewX += 90;
          break;
       case 'r':
          iNewX -= 90;
          break;

       case 'o':
          iNewY = 0;
          iNewX = 0;
          break;

       }
    }


   } while ( 1 );
#else



	pData->BytesPerLine = (unsigned int) ppsPageReady->dwWide / 8;
	pData->BytesToRead = pData->BytesPerLine;
	pData->lines_to_strip = 0;
	
   lpPtr = ppsPageReady->lpBuf + ( pData->BytesPerLine * (ppsPageReady->dwHigh-1)) ;


	if (ppsPageReady->dwWide > MAX_PELS_PER_LINE) {
		// error conditions

#ifdef DEBUG
		printf("\nHeader value for pixels per line of %ld exceeds max of %d",
			ppsPageReady->dwWide, MAX_PELS_PER_LINE);
		printf("\nTruncating to %d\n", MAX_PELS_PER_LINE);
#endif
		ppsPageReady->dwWide = MAX_PELS_PER_LINE;
		pData->BytesPerLine = (unsigned int)(ppsPageReady->dwWide) / 8;
	}		

	if (ppsPageReady->dwHigh > MAX_LINES) {
		// max
#ifdef DEBUG
		printf("\nHeader value for lines per page of %ld exceeds max of %d",
			ppsPageReady->dwHigh, MAX_LINES);
		printf("\nReducing to %d\n", MAX_LINES);
#endif
		pData->lines_to_strip = ppsPageReady->dwHigh - MAX_LINES;
		pData->lines_to_strip += FUDGE_STRIP;
		ppsPageReady->dwHigh = MAX_LINES;
	}			

	// spit out the laserjet header stuff
	LJHeader(pData->fpOut);
	
	// got the header... transfer the data
	
	pData->linecnt = 0;

	while (1) {
		// first read the line in
		
		if (pData->linecnt > ppsPageReady->dwHigh) {
			break;
		}	


		if (pData->lines_to_strip) {
#ifdef DEBUG
			printf("\rStriping Line %d   ", pData->lines_to_strip);
#endif
			pData->lines_to_strip--;
			if (pData->lines_to_strip == 0) {
#ifdef DEBUG
				printf("\rDone Striping........\n");
#endif
			}	
			continue;
		}	
		if (pData->linecnt % 100 == 0) {
#ifdef DEBUG
			printf("\rLine %d", pData->linecnt);
#endif
		}	
		// got the line... now need to write laser jet stuff
		// to the output
		LJGraphicsLineOut(pData->fpOut, pData->linecnt, lpPtr, pData->BytesPerLine);

		pData->linecnt++;		

      lpPtr -= pData->BytesToRead;
	}					
	fprintf(pData->fpOut, "\x1b*p%dY", 0);
	fprintf(pData->fpOut, "\x1b*p%dX", 2300);
	fprintf(pData->fpOut, "LJ");
	fprintf(pData->fpOut, "\x12");		// page feed	
	LJReset(pData->fpOut);

#endif
   return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\bass\fixmath.c ===
// DJC DJC.. added global include
#include "psglobal.h"

/* Copied from "fixmath.s"; @WIN */
#include "fixmath.h"
//#include <math.h>     // to get sqrt() prototype
#define FRACT2FLOAT(x)  (float)((double)(x) / (double)(1L << 30))
#define FLOAT2FRACT(x)  ((Fract)(x * (1L << 30)))
#define FIX2FLOAT(x)  (((float)(x)/(float)(1L << 16)))
#define FLOAT2FIX(x)  ((Fixed)(x * (1L << 16)))

Fixed FixMul(f1, f2)
Fixed f1, f2;
{
    float ff1, ff2, result;

    ff1 = FIX2FLOAT(f1);
    ff2 = FIX2FLOAT(f2);
    result = ff1 * ff2;

    return(FLOAT2FIX(result));
}

Fixed FixDiv(f1, f2)
Fixed f1, f2;
{
    float ff1, ff2, result;

    ff1 = FIX2FLOAT(f1);
    ff2 = FIX2FLOAT(f2);
    result = ff1 / ff2;

    return(FLOAT2FIX(result));
}


Fract FracMul(f1, f2)
Fract f1, f2;
{
    float ff1, ff2, result;

    ff1 = FRACT2FLOAT(f1);
    ff2 = FRACT2FLOAT(f2);
    result = ff1 * ff2;

    return(FLOAT2FRACT(result));
}

Fract FracDiv(f1, f2)
Fract f1, f2;
{
    float ff1, ff2, result;

    ff1 = FRACT2FLOAT(f1);
    ff2 = FRACT2FLOAT(f2);
    result = ff1 / ff2;

    return(FLOAT2FRACT(result));
}

Fract FracSqrt(f1)
Fract f1;
{
    float ff1, result;

//  ff1 = FRACT2FLOAT(f1);
//  result = (float)sqrt((double)ff1);
    ff1 = FRACT2FLOAT(f1);
    result = (ff1 + 1) / (float)2.0;           // approximate @SC tmp???

    return(FLOAT2FRACT(result));
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\bass\fntjmp.h ===
/*
    File:       fntjmp.h

    Written by: Lenox Brassell

    Contains:   definitions for jmp_buf[], setjmp(), longjmp(), and the
                aliases fs_setjmp() and fs_longjmp().

    Copyright:  c 1989-1990 by Microsoft Corp., all rights reserved.

    Change History (most recent first):
        <1>      6/18/91    LB      Created file.
*/


#ifndef PC_OS
// #include <setjmp.h>
// #define fs_setjmp(a)    setjmp(a)
// #define fs_longjmp(a,b) longjmp(a,b)
//#else
 /***
 *setjmp.h - definitions/declarations for setjmp/longjmp routines
 *
 *       Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
 *
 *Purpose:
 *       This file defines the machine-dependent buffer used by
 *       setjmp/longjmp to save and restore the program state, and
 *       declarations for those routines.
 *       [ANSI/System V]
 *
 ****/

 #if defined(_DLL) && !defined(_MT)
 #error Cannot define _DLL without _MT
 #endif

// #ifdef _MT
// #define _FAR_ _far
// #else
// #define _FAR_
// #endif

 /* define the buffer type for holding the state information */

// DJC this is defined in setjmp.h
// #define _JBLEN  9  /* bp, di, si, sp, ret addr, ds */
#define _DJCJBLEN  9  /* bp, di, si, sp, ret addr, ds */

 #ifndef _JMP_BUF_DEFINED
 typedef  int  jmp_buf[_DJCJBLEN];
 #define _JMP_BUF_DEFINED
 #endif


 /* function prototypes */

// int  fs_setjmp(jmp_buf);
// void fs_longjmp(jmp_buf, int);
//DJC int setjmp(jmp_buf);
//DJC void longjmp(jmp_buf, int);
#define fs_setjmp(a)    setjmp(a)
#define fs_longjmp(a,b) longjmp(a,b)
#endif /* PC_OS */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\bass\fontmath.h ===
/*
        File:           fontmath.h

        Contains:       xxx put contents here xxx

        Written by:     xxx put writers here xxx

        Copyright:      c 1990 by Apple Computer, Inc., all rights reserved.

        Change History (most recent first):

                 <4>    11/27/90        MR              make pascal declaration a macro, conditionalize traps -vs-
                                                                        externs for Fix/Frac math routines. [ph]
                 <3>     11/5/90        MR              Move [U]SHORTMUL into fscdefs.h Rename FixMulDiv to LongMulDiv.
                                                                        [rb]
                 <2>    10/20/90        MR              Add some new math routines (stolen from skia). [rj]
                 <1>     4/11/90        dba             first checked in

        To Do:
*/

#define HIBITSET                0x80000000
#define POSINFINITY             0x7FFFFFFF
#define NEGINFINITY             0x80000000
#define HIWORDMASK              0xffff0000
#define LOWORDMASK              0x0000ffff
#define FIXONEHALF              0x00008000
#define ONESHORTFRAC            (1 << 14)

#define FIXROUND( x )           (int16)((((Fixed) x) + FIXONEHALF) >> 16)
#define ROUNDFIXED( x )         (((x) + FIXONEHALF) & HIWORDMASK)
#define DOT6TOFIX(n)            ((Fixed) (n) << 10)

#if 0       // DJC eliminate for NT
#define HIWORD(n)               ((uint16)((uint32)(n) >> 16))
#define LOWORD(n)               ((uint16)(n))
#endif


#define LOWSIXBITS              63

typedef short ShortFract;                       /* 2.14 */


#ifndef __TOOLUTILS__
FS_MAC_PASCAL Fixed FS_PC_PASCAL FixMul(Fixed,Fixed)   FS_MAC_TRAP(0xA868);
#endif

#ifndef __FIXMATH__
FS_MAC_PASCAL Fixed FS_PC_PASCAL FixDiv(Fixed,Fixed)  FS_MAC_TRAP(0xA84D);
FS_MAC_PASCAL Fract FS_PC_PASCAL FracMul(Fract,Fract) FS_MAC_TRAP(0xA84A);
FS_MAC_PASCAL Fract FS_PC_PASCAL FracDiv(Fract,Fract) FS_MAC_TRAP(0xA84B);
FS_MAC_PASCAL Fract FS_PC_PASCAL FracSqrt(Fract)      FS_MAC_TRAP(0xA849);
#endif


#ifndef ShortFracDot
ShortFract      TMP_CONV NEAR ShortFracDot (ShortFract x, ShortFract y);
#endif
F26Dot6         TMP_CONV NEAR ShortFracMul (F26Dot6 x, ShortFract y);
ShortFract      TMP_CONV NEAR ShortFracDiv (ShortFract x, ShortFract y);
F26Dot6         TMP_CONV NEAR Mul26Dot6 (F26Dot6 a, F26Dot6 b);
F26Dot6         TMP_CONV NEAR Div26Dot6 (F26Dot6 num, F26Dot6 den);
short           TMP_CONV NEAR MulDivShorts (short x, short y, short z);


#ifndef MulDiv26Dot6
#define MulDiv26Dot6(a,b,c) LongMulDiv(a,b,c)
#endif

#ifndef LongMulDiv
long LongMulDiv(long a, long b, long c);		/* (a*b)/c */
#endif

#ifndef ShortMulDiv
long ShortMulDiv(long a, short b, short c);		/* (a*b)/c */
#endif

#ifndef ShortFracMulDiv
ShortFract ShortFracMulDiv(ShortFract,ShortFract,ShortFract);
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\bass\fontmath.c ===
/*
    File:       FontMath.c

    Contains:   xxx put contents here xxx

    Written by: xxx put writers here xxx

    Copyright:  c 1990 by Apple Computer, Inc., all rights reserved.

    Change History (most recent first):

         <3>     11/9/90    MR      Fix CompDiv when numer and denom have zero hi longs. [rb]
         <2>     11/5/90    MR      Remove Types.h from include list, rename FixMulDiv to LongMulDiv
                                    [rb]
         <1>    10/20/90    MR      Math routines for font scaler. [rj]

    To Do:
*/

// DJC DJC.. added global include
#include "psglobal.h"

#include "fscdefs.h"
#include "fontmath.h"

#define USHORTMUL(a, b) ((uint32)((uint32)(uint16)(a)*(uint16)(b)))


static void CompMul(long src1, long src2, long dst[2]);
static long CompDiv(long src1, long src2[2]);


static void CompMul(long src1, long src2, long dst[2])
{
    int negative = (src1 ^ src2) < 0;
    register unsigned long dsthi, dstlo;

    if (src1 < 0)
        src1 = -src1;
    if (src2 < 0)
        src2 = -src2;
    {   unsigned short src1hi, src1lo;
        register unsigned short src2hi, src2lo;
        register unsigned long temp;
        src1hi = (unsigned short)(src1 >> 16);     //@WIN
        src1lo = (unsigned short)src1;             //@WIN
        src2hi = (unsigned short)(src2 >> 16);     //@WIN
        src2lo = (unsigned short)src2;             //@WIN
        temp = (unsigned long)src1hi * src2lo + (unsigned long)src1lo * src2hi;
        dsthi = (unsigned long)src1hi * src2hi + (temp >> 16);
        dstlo = (unsigned long)src1lo * src2lo;
        temp <<= 16;
        dsthi += (dstlo += temp) < temp;
        dst[0] = dsthi;
        dst[1] = dstlo;
    }
    if (negative)
// DJC         if (dstlo = -dstlo)
        if (dstlo = -(long)(dstlo))
            dsthi = ~dsthi;
        else
// DJC            dsthi = -dsthi;
            dsthi = -(long)(dsthi);
    dst[0] = dsthi;
    dst[1] = dstlo;
}

static long CompDiv(long src1, long src2[2])
{
    register unsigned long src2hi = src2[0], src2lo = src2[1];
    int negative = (long)(src2hi ^ src1) < 0;

    if ((long)src2hi < 0)
// DJC        if (src2lo = -src2lo)
        if (src2lo = -(long)(src2lo))
            src2hi = ~src2hi;
        else
// DJC            src2hi = -src2hi;
            src2hi = -(long)(src2hi);
    if (src1 < 0)
// DJC        src1 = -src1;
        src1 = -(long)(src1);
    {   register unsigned long src1hi, src1lo;
        unsigned long result = 0, place = 0x40000000;

        if ((src1hi = src1) & 1)
            src1lo = 0x80000000;
        else
            src1lo = 0;

        src1hi >>= 1;
        src2hi += (src2lo += src1hi) < src1hi;      /* round the result */

        if (src2hi > src1hi || src2hi == src1hi && src2lo >= src1lo)
            if (negative)
                return NEGINFINITY;
            else
                return POSINFINITY;
        while (place && src2hi)
        {   src1lo >>= 1;
            if (src1hi & 1)
                src1lo += 0x80000000;
            src1hi >>= 1;
            if (src1hi < src2hi)
            {   src2hi -= src1hi;
                src2hi -= src1lo > src2lo;
                src2lo -= src1lo;
                result += place;
            }
            else if (src1hi == src2hi && src1lo <= src2lo)
            {   src2hi = 0;
                src2lo -= src1lo;
                result += place;
            }
            place >>= 1;
        }
        if (src2lo >= (unsigned long)src1)      //@WIN
            result += src2lo/src1;
        if (negative)
// DJC             return -result;
            return (unsigned long)(-(long)result);
        else
            return result;
    }
}

/*
 *  a*b/c
 */
long LongMulDiv(long a, long b, long c)
{
    long temp[2];

    CompMul(a, b, temp);
    return CompDiv(c, temp);
}


F26Dot6 ShortFracMul (F26Dot6 aDot6, ShortFract b)
{
    long a = (long)aDot6;
    int negative = (a ^ (long)b) < 0;
    register unsigned long dsthi, dstlo;
//  long dst[2];        @WIN

    if (a < 0)
        a = -a;
    if (b < 0)
        b = -b;
    {   unsigned short ahi, alo;
        register unsigned long temp;
        ahi = (unsigned short)(a >> 16);        //@WIN
        alo = (unsigned short)a;                //@WIN
        temp = (unsigned long)ahi * (unsigned short)(b);
        dsthi = (temp >> 16);
        dstlo = (unsigned long)alo * (unsigned short)(b);
        temp <<= 16;
        dsthi += (dstlo += temp) < temp;
    }
    if (negative)
// DJC        if (dstlo = -dstlo)
        if (dstlo = -(long)(dstlo))
            dsthi = ~dsthi;
        else
// DJC            dsthi = -dsthi;
            dsthi = -(long)(dsthi);

    a = (long)( (dsthi<<18) | (dstlo>>14) ) + (long) !!(dstlo & (1L<<13));
    return (F26Dot6)(a);
}


ShortFract ShortFracDot (ShortFract a, ShortFract b)
{
    return (ShortFract) ((((long)a * (b)) + (1 << 13)) >> 14);
}


int32 ShortMulDiv(int32 a, int16 b, int16 c)
{
    return LongMulDiv(a, b, c);
}

short MulDivShorts (short a, short b, short c)
{
    return (short)LongMulDiv(a, b, c);  //@WIN
}

#define FASTMUL26LIMIT      46340
/*
 *  Total precision routine to multiply two 26.6 numbers        <3>
 */
F26Dot6 Mul26Dot6(F26Dot6 a, F26Dot6 b)
{
    int negative = false;
    uint16 al, bl, ah, bh;
    uint32 lowlong, midlong, hilong;

    if ((a <= FASTMUL26LIMIT) && (b <= FASTMUL26LIMIT) && (a >= -FASTMUL26LIMIT) && (b >= -FASTMUL26LIMIT))
        return ((a * b + (1 << 5)) >> 6);                       /* fast case */

    if (a < 0) { a = -a; negative = true; }
    if (b < 0) { b = -b; negative ^= true; }

    al = LOWORD(a); ah = HIWORD(a);
    bl = LOWORD(b); bh = HIWORD(b);

    midlong = USHORTMUL(al, bh) + USHORTMUL(ah, bl);
    hilong = USHORTMUL(ah, bh) + HIWORD(midlong);
    midlong <<= 16;
    midlong += 1 << 5;
    lowlong = USHORTMUL(al, bl) + midlong;
    hilong += lowlong < midlong;

    midlong = (lowlong >> 6) | (hilong << 26);
//    return negative ? -midlong : midlong;
    return negative ? (uint32)(-(int32)(midlong)) : midlong;
}

#define FASTDIV26LIMIT  (1L << 25)
/*
 *  Total precision routine to divide two 26.6 numbers          <3>
 */
F26Dot6 Div26Dot6(F26Dot6 num, F26Dot6 den)
{
    int negative = false;
    register uint32 hinum, lownum, hiden, lowden, result, place;

    if (den == 0) return (num < 0 ) ? NEGINFINITY : POSINFINITY;

    if ( (num <= FASTDIV26LIMIT) && (num >= -FASTDIV26LIMIT) )          /* fast case */
        return (num << 6) / den;

    if (num < 0) { num = -num; negative = true; }
    if (den < 0) { den = -den; negative ^= true; }

    hinum = ((uint32)num >> 26);
    lownum = ((uint32)num << 6);
    hiden = den;
    lowden = 0;
    result = 0;
    place = HIBITSET;

    if (hinum >= hiden) return negative ? NEGINFINITY : POSINFINITY;

    while (place)
    {
        lowden >>= 1;
        if (hiden & 1) lowden += HIBITSET;
        hiden >>= 1;
        if (hiden < hinum)
        {
            hinum -= hiden;
            hinum -= lowden > lownum;
            lownum -= lowden;
            result += place;
        }
        else if (hiden == hinum && lowden <= lownum)
        {
            hinum = 0;
            lownum -= lowden;
            result += place;
        }
        place >>= 1;
    }

// DJC    return negative ? -result : result;
    return negative ? (uint32)(-(int32)(result)) : result;
}

void BlockFill(char* dst, char value, long count)
{
    while (count--)
        *dst++ = value;
}

ShortFract ShortFracDiv(ShortFract num,ShortFract denum)
{
    return (ShortFract) (((long)(num) << 14) / denum);  //@WIN
}

ShortFract ShortFracMulDiv(ShortFract numA,ShortFract numB,ShortFract denum)
{
    return (ShortFract) LongMulDiv ((long) numA,(long) numB, (long)denum);
}

/* ------------------------------------------------------------ */

#ifndef FSCFG_USE_EXTERNAL_FIXMATH
/*  Here we define Fixed [16.16] and Fract [2.30] precision
 *  multiplication and division functions and a Fract square root
 *  function which are compatible with those in the Macintosh toolbox.
 *
 *  The division functions load the 32-bit numerator into the "middle"
 *  bits of a 64-bit numerator, then call the 64-bit by 32-bit CompDiv()
 *  function defined above, which can return a NEGINFINITY or POSINFINITY
 *  overflow return code.
 *
 *  The multiply functions call the 32-bit by 32-bit CompMul() function
 *  defined above which produces a 64-bit result, then they extract the
 *  "interesting" 32-bits from the middle of the 64-bit result and test
 *  for overflow.
 *
 *  The GET32(a,i) macro defined below extracts a 32-bit value with "i"
 *  bits of fractional precision from the 64-bit value in "a", a 2-element
 *  array of longs.
 *
 *  The CHKOVF(a,i,v) macro tests the most significant bits of the
 *  64-bit value in "a", a 2-element array of longs, and tests the
 *  32-bit result "v" for overflow.  "v" is defined as having "i" bits
 *  of fractional precision.
 *
 *  BIT() and OVFMASK() are "helper" macros used by GET32() and CHKOVF().
 *
 *  BIT(i) returns a mask with the "i"-th bit set.
 *  OVFMASK(i) returns a mask with the most-significant "32-i" bits set.
 */

#define BIT(i)          (1L<<(i))
#define OVFMASK(i)      ( ~0L ^ ( ((unsigned long)BIT(i)) - 1 ) )
#define CHKOVF(a,i,v)   (\
        ( ((a)[0] & OVFMASK(i))==0)          ? ( (v)>=0 ?(v) :POSINFINITY) : \
        ( ((a)[0] & OVFMASK(i))==OVFMASK(i)) ? ( (v)<=0 ?(v) :NEGINFINITY) : \
        ( ((a)[0] & BIT(31))                 ? POSINFINITY   :NEGINFINITY)   \
        )
#define GET32(a,i) \
((((a)[0]<<(32-(i))) | ((unsigned long)((a)[1])>>(i))) + !!((a)[1] & BIT((i)-1)))

#ifndef FAST
Fixed FixMul (Fixed fxA, Fixed fxB)
{
    long alCompProd[2];
    Fixed fxProd;

    if  (fxA == 0 || fxB == 0)
        return 0;

    CompMul (fxA, fxB, alCompProd);
    fxProd = GET32 (alCompProd,16);
    return CHKOVF(alCompProd,16,fxProd);
}

Fixed FixDiv (Fixed fxA, Fixed fxB)
{
    long alCompProd[2];

    alCompProd[0] = fxA >> 16;
    alCompProd[1] = fxA << 16;
    return CompDiv (fxB, alCompProd);
}
#endif

Fixed FixRatio (short sA, short sB)
{
    long alCompProd[2];

    alCompProd[0] = ((long)(sA)) >> 16;
    alCompProd[1] = ((long)(sA)) << 16;
    return CompDiv ((long)(sB), alCompProd);
}

#ifndef  FAST
Fract FracMul (Fract frA, Fract frB)
{
    long alCompProd[2];
    Fract frProd;

    if  (frA == 0 || frB == 0)
        return 0;

    CompMul (frA,frB,alCompProd);
    frProd = GET32 (alCompProd,30);
    return CHKOVF(alCompProd,30,frProd);
}

Fract FracDiv (Fract frA, Fract frB)
{
    long alCompProd[2];

    alCompProd[0] = frA >> 2;
    alCompProd[1] = frA << 30;
    return CompDiv (frB, alCompProd);
}

/*
   Fract FracSqrt (Fract xf)
   Input:  xf           2.30 fixed point value
   Return: sqrt(xf)     2.30 fixed point value
*/

Fract FracSqrt (Fract xf)
{
    Fract b = 0L;
    unsigned long c, d, x = xf;

    if (xf < 0) return (NEGINFINITY);

    /*
    The algorithm extracts one bit at a time, starting from the
    left, and accumulates the square root in b.  The algorithm
    takes advantage of the fact that non-negative input values
    range from zero to just under two, and corresponding output
    ranges from zero to just under sqrt(2).  Input is assigned
    to temporary value x (unsigned) so we can use the sign bit
    for more precision.
    */

    if (x >= 0x40000000)
    {
        x -= 0x40000000;
        b  = 0x40000000;
    }

    /*
    This is the main loop.  If we had more precision, we could
    do everything here, but the lines above perform the first
    iteration (to align the 2.30 radix properly in b, and to
    preserve full precision in x without overflow), and afterward
    we do two more iterations.
    */

    for (c = 0x10000000; c; c >>= 1)
    {
        d = b + c;
        if (x >= d)
        {
            x -= d;
            b += (c<<1);
        }
        x <<= 1;
    }

    /*
    Iteration to get last significant bit.

    This code has been reduced beyond recognition, but basically,
    at this point c == 1L>>1 (phantom bit on right).  We would
    like to shift x and d left 1 bit when we enter this iteration,
    instead of at the end.  That way we could get phantom bit in
    d back into the word.  Unfortunately, that may cause overflow
    in x.  The solution is to break d into b+c, subtract b from x,
    then shift x left, then subtract c<<1 (1L).
    */

    if (x > b) /* if (x == b) then (x < d).  We want to test (x >= d). */
    {
        x -= b;
        x <<= 1;
        x -= 1L;
        b += 1L; /* b += (c<<1) */
    }
    else
    {
        x <<= 1;
    }

    /*
    Final iteration is simple, since we don't have to maintain x.
    We just need to calculate the bit to the right of the least
    significant bit in b, and use the result to round our final answer.
    */

    return ( b + (x>b) );
}
#endif
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\bass\fnt.h ===
/*
    File:       fnt.h

    Contains:   xxx put contents here (or delete the whole line) xxx

    Written by: xxx put name of writer here (or delete the whole line) xxx

    Copyright:  c 1987-1990 by Apple Computer, Inc., all rights reserved.

    Change History (most recent first):

       <11+>     9/15/90    MR,rb   Change pvx and pvy to proj.[xy].  Same for freedom vector.
                                    Conditionalize vectors for Fracts or ShortFracts.
        <10>     7/26/90    MR      rearrange local graphic state, remove unused parBlockPtr
         <9>     7/18/90    MR      change loop variable from long to short, and other Ansi-changes
         <8>     7/13/90    MR      Prototypes for function pointers
         <5>      6/4/90    MR      Remove MVT
         <4>      5/3/90    RB      replaced dropoutcontrol with scancontrolin and scancontrol out
                                    in global graphics state
         <3>     3/20/90    CL      fields for multiple preprograms fields for ppemDot6 and
                                    pointSizeDot6 changed SROUND to take D/2 as argument
         <2>     2/27/90    CL      Added DSPVTL[] instruction.  Dropoutcontrol scanconverter and
                                    SCANCTRL[] instruction
       <3.1>    11/14/89    CEL     Fixed two small bugs/feature in RTHG, and RUTG. Added SROUND &
                                    S45ROUND.
       <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
       <2.2>     8/14/89    sjk     1 point contours now OK
       <2.1>      8/8/89    sjk     Improved encryption handling
       <2.0>      8/2/89    sjk     Just fixed EASE comment
       <1.7>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
       <1.6>     6/13/89    SJK     Comment
       <1.5>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
                                    bug, correct transformed integralized ppem behavior, pretty much
                                    so
       <1.4>     5/26/89    CEL     EASE messed up on "c" comments
      <,1.3>     5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts

    To Do:
*/
/*  rwb 4/24/90 Replaced dropoutControl with scanControlIn and scanControlOut in
        global graphics state.
        <3+>     3/20/90    mrr     Added support for IDEFs.  Made funcDefs long aligned
                                    by storing int16 length instead of int32 end.
*/

#include "fntjmp.h"

#define fnt_pixelSize ((F26Dot6)0x40)
#define fnt_pixelShift 6

#define MAXBYTE_INSTRUCTIONS 256

#define VECTORTYPE                      ShortFract
#define ONEVECTOR                       ONESHORTFRAC
#define VECTORMUL(value, component)     ShortFracMul((F26Dot6)(value), (ShortFract)(component))
#define VECTORDOT(a,b)                  ShortFracDot((ShortFract)(a),(ShortFract)(b))
#define VECTORDIV(num,denum)            ShortFracDiv((ShortFract)(num),(ShortFract)(denum))
#define VECTORMULDIV(a,b,c)             ShortFracMulDiv((ShortFract)(a),(ShortFract)(b),(ShortFract)(c))
#define VECTOR2FIX(a)                   ((Fixed) (a) << 2)
#define ONESIXTEENTHVECTOR              ((ONEVECTOR) >> 4)

typedef struct VECTOR {
    VECTORTYPE x;
    VECTORTYPE y;
} VECTOR;

typedef struct {
    F26Dot6  FAR *x; /* The Points the Interpreter modifies @WIN*/
    F26Dot6  FAR *y; /* The Points the Interpreter modifies @WIN*/
    F26Dot6  FAR *ox; /* Old Points @WIN*/
    F26Dot6  FAR *oy; /* Old Points @WIN*/
    F26Dot6  FAR *oox; /* Old Unscaled Points, really ints @WIN*/
    F26Dot6  FAR *ooy; /* Old Unscaled Points, really ints @WIN*/
    uint8 FAR *onCurve; /* indicates if a point is on or off the curve @WIN*/
    int16 FAR *sp;  /* Start points @WIN*/
    int16 FAR *ep;  /* End points @WIN*/
    uint8  FAR *f;  /* Internal flags, one byte for every point @WIN*/
    int16 nc;  /* Number of contours */
} fnt_ElementType;

typedef struct {
    int32 start;        /* offset to first instruction */
    uint16 length;      /* number of bytes to execute <4> */
    uint16 pgmIndex;    /* index to appropriate preprogram for this func (0..1) */
} fnt_funcDef;

/* <4> pretty much the same as fnt_funcDef, with the addition of opCode */
typedef struct {
    int32 start;
    uint16 length;
    uint8  pgmIndex;
    uint8  opCode;
} fnt_instrDef;

typedef struct {
    Fract x;
    Fract y;
} fnt_FractPoint;

/***************** This is stored as FractPoint[] and distance[]
typedef struct {
    Fract x, y;
    int16 distance;
} fnt_AngleInfo;
*******************/

typedef struct {
    uint8 FAR *    Instruction;  /*@WIN*/
    unsigned  Length;
} fnt_pgmList;

typedef void (*FntTraceFunc)(struct fnt_LocalGraphicStateType FAR*, uint8 FAR*); /*@WIN*/

#ifdef FSCFG_REENTRANT
typedef void (*FntFunc)(struct fnt_LocalGraphicStateType FAR *);/*@WIN*/
typedef void (*FntMoveFunc)(struct fnt_LocalGraphicStateType FAR*, fnt_ElementType FAR*, ArrayIndex, F26Dot6);/*@WIN*/
typedef F26Dot6 (*FntProject)(struct fnt_LocalGraphicStateType FAR*, F26Dot6, F26Dot6);/*@WIN*/
typedef void (*InterpreterFunc)(struct fnt_LocalGraphicStateType FAR*, uint8 FAR*, uint8 FAR*);/*@WIN*/
typedef F26Dot6 (*FntRoundFunc)(struct fnt_LocalGraphicStateType FAR*, F26Dot6, F26Dot6);/*@WIN*/
#else
typedef void (*FntMoveFunc)(fnt_ElementType FAR*, ArrayIndex, F26Dot6);/*@WIN*/
typedef void (*FntFunc)(void);
typedef F26Dot6 (*FntProject)(F26Dot6 x, F26Dot6 y);
typedef void (*InterpreterFunc)(uint8 FAR *, uint8 FAR*);/*@WIN*/
typedef F26Dot6 (*FntRoundFunc)(F26Dot6 xin, F26Dot6 engine);
#endif



typedef struct {

/* PARAMETERS CHANGEABLE BY TT INSTRUCTIONS */
    F26Dot6 wTCI;                   /* width table cut in */
    F26Dot6 sWCI;                   /* single width cut in */
    F26Dot6 scaledSW;               /* scaled single width */
    int32 scanControl;              /* controls kind and when of dropout control */
    int32 instructControl;          /* controls gridfitting and default setting */

    F26Dot6 minimumDistance;        /* moved from local gs  7/1/90  */
    FntRoundFunc RoundValue;        /*                              */
        F26Dot6 periodMask;                     /* ~(gs->period-1)                              */
        VECTORTYPE period45;                       /*                                                              */
        int16   period;                         /* for power of 2 periods               */
        int16   phase;                          /*                                                              */
        int16   threshold;                      /* moved from local gs  7/1/90  */

        int16 deltaBase;
        int16 deltaShift;
        int16 angleWeight;
        int16 sW;                               /* single width, expressed in the same units as the character */
        int8 autoFlip;                          /* The auto flip Boolean */
    int8 pad;
} fnt_ParameterBlock;               /* this is exported to client */

#define MAXANGLES       20
#define ROTATEDGLYPH    0x100
#define STRETCHEDGLYPH  0x200
#define NOGRIDFITFLAG   1
#define DEFAULTFLAG     2

typedef enum {
    PREPROGRAM,
    FONTPROGRAM,
    MAXPREPROGRAMS
} fnt_ProgramIndex;

typedef struct fnt_ScaleRecord {
    Fixed fixedScale;       /* Slow Scale */
    int denom;            /* Fast and Medium Scale */
    int numer;              /* Fast and Medium Scale */
    int shift;              /* Fast Scale */
} fnt_ScaleRecord;

typedef F26Dot6 (*GlobalGSScaleFunc)(fnt_ScaleRecord FAR *, F26Dot6);/*@WIN*/

typedef struct fnt_GlobalGraphicStateType {
    F26Dot6 FAR * stackBase;             /* the stack area @WIN*/
    F26Dot6 FAR * store;                 /* the storage area @WIN*/
    F26Dot6 FAR * controlValueTable;     /* the control value table @WIN*/

    uint16  pixelsPerEm;            /* number of pixels per em as an integer */
    uint16  pointSize;              /* the requested point size as an integer */
    Fixed   fpem;                   /* fractional pixels per em    <3> */
    F26Dot6 engine[4];              /* Engine Characteristics */

    fnt_ParameterBlock defaultParBlock; /* variables settable by TT instructions */
    fnt_ParameterBlock localParBlock;

    /* Only the above is exported to Client throught FontScaler.h */

/* VARIABLES NOT DIRECTLY MANIPULABLE BY TT INSTRUCTIONS  */

    fnt_funcDef FAR * funcDef;           /* function Definitions identifiers @WIN*/
    fnt_instrDef FAR* instrDef;         /* instruction Definitions identifiers @WIN*/
        GlobalGSScaleFunc ScaleFuncX;
        GlobalGSScaleFunc ScaleFuncY;
        GlobalGSScaleFunc ScaleFuncCVT;
        fnt_pgmList pgmList[MAXPREPROGRAMS];  /* each program ptr is in here */

/* These are parameters used by the call back function */
        fnt_ScaleRecord   scaleX;
        fnt_ScaleRecord   scaleY;
        fnt_ScaleRecord   scaleCVT;

        Fixed  cvtStretchX;
        Fixed  cvtStretchY;

    int8   identityTransformation;  /* true/false  (does not mean identity from a global sense) */
    int8   non90DegreeTransformation; /* bit 0 is 1 if non-90 degree, bit 1 is 1 if x scale doesn't equal y scale */
    Fixed  xStretch;            /* Tweaking for glyphs under transformational stress <4> */
        Fixed  yStretch;                        /* Tweaking for glyphs under transformational stress <4> */

    int8 init;                      /* executing preprogram ?? */
    uint8 pgmIndex;                 /* which preprogram is current */
    LoopCount instrDefCount;        /* number of currently defined IDefs */
        int    squareScale;
#ifdef DEBUG
    sfnt_maxProfileTable FAR *   maxp;/*@WIN*/
    uint16                  cvtCount;
#endif

} fnt_GlobalGraphicStateType;

/*
 * This is the local graphics state
 */
typedef struct fnt_LocalGraphicStateType {
    fnt_ElementType FAR *CE0, FAR *CE1, FAR *CE2;   /* The character element pointers @WIN*/
    VECTOR proj;                        /* Projection Vector */
    VECTOR free;                        /* Freedom Vector */
    VECTOR oldProj;                     /* Old Projection Vector */
    F26Dot6 FAR *stackPointer;/*@WIN*/

    uint8 FAR *insPtr;                      /* Pointer to the instruction we are about to execute @WIN*/
    fnt_ElementType FAR *elements;/*@WIN*/
    fnt_GlobalGraphicStateType FAR *globalGS;/*@WIN*/
        FntTraceFunc TraceFunc;

    ArrayIndex Pt0, Pt1, Pt2;           /* The internal reference points */
    int16   roundToGrid;
    LoopCount loop;                     /* The loop variable */
    uint8 opCode;                       /* The instruction we are executing */
    uint8 padByte;
    int16 padWord;

    /* Above is exported to client in FontScaler.h */

    VECTORTYPE pfProj; /* = pvx * fvx + pvy * fvy */

    FntMoveFunc MovePoint;
    FntProject Project;
    FntProject OldProject;
    InterpreterFunc Interpreter;
#ifdef FSCFG_REENTRANT
        F26Dot6 (*GetCVTEntry) (struct fnt_LocalGraphicStateType FAR*,ArrayIndex);/*@WIN*/
        F26Dot6 (*GetSingleWidth) (struct fnt_LocalGraphicStateType FAR*);/*@WIN*/
#else
        F26Dot6 (*GetCVTEntry) (ArrayIndex n);
        F26Dot6 (*GetSingleWidth) (void);
#endif

    jmp_buf env;        /* always be at the end, since it is unknown size */

} fnt_LocalGraphicStateType;

/*
 * Executes the font instructions.
 * This is the external interface to the interpreter.
 *
 * Parameter Description
 *
 * elements points to the character elements. Element 0 is always
 * reserved and not used by the actual character.
 *
 * ptr points at the first instruction.
 * eptr points to right after the last instruction
 *
 * globalGS points at the global graphics state
 *
 * TraceFunc is pointer to a callback functioned called with a pointer to the
 *      local graphics state if TraceFunc is not null. The call is made just before
 *      every instruction is executed.
 *
 * Note: The stuff globalGS is pointing at must remain intact
 *       between calls to this function.
 */
extern int FAR fnt_Execute(fnt_ElementType FAR *elements, uint8 FAR *ptr, register uint8 FAR *eptr,/*@WIN*/
                            fnt_GlobalGraphicStateType FAR *globalGS, voidFunc TraceFunc);/*@WIN*/

extern int FAR fnt_SetDefaults (fnt_GlobalGraphicStateType FAR *globalGS);/*@WIN*/



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\bass\fscdefs.h ===
/*
    File:       fscdefs.h

    Contains:   xxx put contents here (or delete the whole line) xxx

    Written by: xxx put name of writer here (or delete the whole line) xxx

    Copyright:  c 1988-1990 by Apple Computer, Inc., all rights reserved.

    Change History (most recent first):

         <3>    11/27/90    MR      Add #define for PASCAL. [ph]
         <2>     11/5/90    MR      Move USHORTMUL from fontmath.h, add Debug definition [rb]
         <7>     7/18/90    MR      Add byte swapping macros for INTEL, moved rounding macros from
                                    fnt.h to here
         <6>     7/14/90    MR      changed defines to typedefs for int[8,16,32] and others
         <5>     7/13/90    MR      Declared ReleaseSFNTFunc and GetSFNTFunc
         <4>      5/3/90    RB      cant remember any changes
         <3>     3/20/90    CL      type changes for Microsoft
         <2>     2/27/90    CL      getting bbs headers
       <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
       <2.2>     8/14/89    sjk     1 point contours now OK
       <2.1>      8/8/89    sjk     Improved encryption handling
       <2.0>      8/2/89    sjk     Just fixed EASE comment
       <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
       <1.4>     6/13/89    SJK     Comment
       <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
                                    bug, correct transformed integralized ppem behavior, pretty much
                                    so
       <1.2>     5/26/89    CEL     EASE messed up on "c" comments
      <,1.1>     5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
       <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

    To Do:
*/



#include "fsconfig.h"

#define true 1
#define false 0

#define ONEFIX      ( 1L << 16 )
#define ONEFRAC     ( 1L << 30 )
#define ONEHALFFIX  0x8000L
#define ONEVECSHIFT 16
#define HALFVECDIV  (1L << (ONEVECSHIFT-1))

typedef char int8;
typedef unsigned char uint8;
typedef short int16;
typedef unsigned short uint16;
typedef long int32;
typedef unsigned long uint32;

typedef short FUnit;
typedef unsigned short uFUnit;

typedef long Fixed;
typedef long Fract;

#ifndef F26Dot6
#define F26Dot6 long
#endif

#ifndef boolean
#define boolean int
#endif

#if 0       // DJC disable for NT versions
#ifndef FAR
#ifdef W32
#define FAR
#define far
#else
#define FAR far
#endif
#endif

#ifndef NEAR
#ifdef W32
#define NEAR
#define near
#else
#define NEAR
/* @WIN: always define NEAR to be NULL, otherwise fontmath.c can not pass???*/
#endif
#endif

#endif   // DJC end if 0

#ifndef TMP_CONV
#define TMP_CONV
#endif

#ifndef FS_MAC_PASCAL
#define FS_MAC_PASCAL
#endif

#ifndef FS_PC_PASCAL
#define FS_PC_PASCAL
#endif

#ifndef FS_MAC_TRAP
#define FS_MAC_TRAP(a)
#endif

typedef struct {
    Fixed       transform[3][3];
} transMatrix;

typedef struct {
    Fixed       x, y;
} vectorType;

/* Private Data Types */
typedef struct {
    int16 xMin;
    int16 yMin;
    int16 xMax;
    int16 yMax;
} BBOX;

#ifndef SHORTMUL
#define SHORTMUL(a,b)   (int32)((int32)(a) * (b))
#endif

#ifndef SHORTDIV
#define SHORTDIV(a,b)   (int32)((int32)(a) / (b))
#endif

#ifdef FSCFG_BIG_ENDIAN /* target byte order matches Motorola 68000 */
 #define SWAPL(a)        (a)
 #define SWAPW(a)        (a)
 #define SWAPWINC(a)     (*(a)++)
#else
 /* Portable code to extract a short or a long from a 2- or 4-byte buffer */
 /* which was encoded using Motorola 68000 (TrueType "native") byte order. */
 #define FS_2BYTE(p)  ( ((unsigned short)((p)[0]) << 8) |  (p)[1])
 #define FS_4BYTE(p)  ( FS_2BYTE((p)+2) | ( (FS_2BYTE(p)+0L) << 16) )
#endif

#ifndef SWAPW
#define SWAPW(a)        ((short) FS_2BYTE( (unsigned char FAR*)(&a) ))
#endif

#ifndef SWAPL
#define SWAPL(a)        ((long) FS_4BYTE( (unsigned char FAR*)(&a) ))
#endif

#ifndef SWAPWINC
#define SWAPWINC(a)     SWAPW(*(a)); a++        /* Do NOT parenthesize! */
#endif

#ifndef LoopCount
/* modify by Falco to see the difference, 12/17/91 */
/*#define LoopCount int16 */   /* short gives us a Motorola DBF */
#define LoopCount long         /* short gives us a Motorola DBF */
/* modify end */
#endif

#ifndef ArrayIndex
#define ArrayIndex int32     /* avoids EXT.L on Motorola */
#endif

typedef void (*voidFunc) ();
typedef void FAR * voidPtr;
typedef void (*ReleaseSFNTFunc) (voidPtr);
typedef void FAR * (*GetSFNTFunc) (long, long, long);


#ifndef MEMSET
//#define MEMSET(dst, value, size)    memset(dst, value, (size_t)(size)) @WIN
#define MEMSET(dst, value, size)    lmemset(dst, value, size)
#define FS_NEED_STRING_DOT_H
#endif

#ifndef MEMCPY
//#define MEMCPY(dst, src, size)      memcpy(dst, src, (size_t)(size)) @WIN
#define MEMCPY(dst, src, size)      lmemcpy(dst, src, size)
#ifndef FS_NEED_STRING_DOT_H
#define FS_NEED_STRING_DOT_H
#endif
#endif

#ifdef FS_NEED_STRING_DOT_H
#undef FS_NEED_STRING_DOT_H

//#include <string.h> @WIN
#ifndef WINENV
// DJC DJC #include "windowsx.h" /* @WIN */
#include "windows.h"

#include "winenv.h" /* @WIN */
#endif

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\bass\fscaler.c ===
/*
        File:           FontScaler.c

        Contains:       xxx put contents here (or delete the whole line) xxx

        Written by:     xxx put name of writer here (or delete the whole line) xxx

        Copyright:      c 1988-1990 by Apple Computer, Inc., all rights reserved.

        Change History (most recent first):

                <11>    11/27/90        MR              Need two scalars: one for (possibly rounded) outlines and cvt,
                                                                        and one (always fractional) metrics. [rb]
                <10>    11/21/90        RB              Allow client to disable DropOutControl by returning a NIL
                                                                        pointer to memoryarea[7]. Also make it clear that we inhibit
                                                                        DOControl whenever we band. [This is a reversion to 8, so mr's
                                                                        initials are added by proxy]
                 <9>    11/13/90        MR              (dnf) Revert back to revision 7 to fix a memmory-trashing bug
                                                                        (we hope). Also fix signed/unsigned comparison bug in outline
                                                                        caching.
                 <8>    11/13/90        RB              Fix banding so that we can band down to one row, using only
                                                                        enough bitmap memory and auxillary memory for one row.[mr]
                 <7>     11/9/90        MR              Add Default return to fs_dropoutval. Continue to fiddle with
                                                                        banding. [rb]
                 <6>     11/5/90        MR              Remove FixMath.h from include list. Clean up Stamp macros. [rb]
                 <5>    10/31/90        MR              Conditionalize call to ComputeMapping (to avoid linking
                                                                        MapString) [ha]
                 <4>    10/31/90        MR              Add bit-field option for integer or fractional scaling [rb]
                 <3>    10/30/90        RB              [MR] Inhibit DropOutControl when Banding
                 <2>    10/20/90        MR              Restore changes since project died. Converting to smart math
                                                                        routines, integer ppem scaling. [rb]
                <16>     7/26/90        MR              don't include ToolUtils.h
                <15>     7/18/90        MR              Fix return bug in GetAdvanceWidth, internal errors are now ints.
                <14>     7/14/90        MR              remove unused fields from FSInfo
                <13>     7/13/90        MR              Ansi-C fixes, rev. for union in FSInput
                <11>     6/29/90        RB              Thus endeth the too long life of encryption
                <10>     6/21/90        MR              Add calls to ReleaseSfntFrag
                 <9>     6/21/90        RB              add scanKind info to fs_dropoutVal
                 <8>      6/5/90        MR              remove fs_MapCharCodes
                 <7>      6/1/90        MR              Did someone say MVT? Yuck!!! Out of my routine.
                 <6>      6/1/90        RB              fixed bandingbug under dropout control
                 <4>      5/3/90        RB              added dropoutval function.  simplified restore outlines.
                                                                        support for new scanconverter in contourscan, findbitmapsize,
                                                                        saveoutlines, restoreoutlines.
                 <3>     3/20/90        CL              Changed to use fpem (16.16) instead of pixelsPerEm (int) Removed
                                                                        call to AdjustTransformation (not needed with fpem) Added call
                                                                        to RunXFormPgm Removed WECANNOTDOTHIS #ifdef Added
                                                                        fs_MapCharCodes
                 <2>     2/27/90        CL              New error code for missing but needed table. (0x1409).  New
                                                                        CharToIndexMap Table format.
                                                                        Fixed transformed component bug.
           <3.6>        11/15/89        CEL             Put an else for the ifdef WeCanNotDoThis so Printer compile
                                                                        could use more effecient code.
           <3.5>        11/14/89        CEL             Left Side Bearing should work right for any transformation. The
                                                                        phantom points are in, even for components in a composite glyph.
                                                                        They should also work for transformations. Device metric are
                                                                        passed out in the output data structure. This should also work
                                                                        with transformations. Another leftsidebearing along the advance
                                                                        width vector is also passed out. whatever the metrics are for
                                                                        the component at it's level. Instructions are legal in
                                                                        components. Instructions are legal in components. The
                                                                        transformation is internally automatically normalized. This
                                                                        should also solve the overflow problem we had. Now it is legal
                                                                        to pass in zero as the address of memory when a piece of the
                                                                        sfnt is requested by the scaler. If this happens the scaler will
                                                                        simply exit with an error code ! Five unnecessary element in the
                                                                        output data structure have been deleted. (All the information is
                                                                        passed out in the bitmap data structure) fs_FindBMSize now also
                                                                        returns the bounding box.
           <3.4>         9/28/89        CEL             fs_newglyph did not initialize the output error. Caused routine
                                                                        to return error from previous routines.
           <3.3>         9/27/89        CEL             Took out devAdvanceWidth & devLeftSideBearing.
           <3.2>         9/25/89        CEL             Changed the NEED_PROTOTYPE ifdef to use the NOT_ON_THE_MAC flag
                                                                        that existed previously.
           <3.1>         9/15/89        CEL             Changed dispatch scheme. Calling conventions through a trap
                                                                        needed to match Macintosh pascal. Pascal can not call C unless
                                                                        there is extra mucky glue. Bug that caused text not to appear.
                                                                        The font scaler state was set up correctly but the sfnt was
                                                                        purged. It was reloaded and the clientid changed but was still
                                                                        the same font. Under the rules of the FontScaler fs_newsfnt
                                                                        should not have to be called again to reset the state. The extra
                                                                        checks sent back a BAD_CLIENTID_ERROR so QuickDraw would think
                                                                        it was a bad font and not continue to draw.
           <3.0>         8/28/89        sjk             Cleanup and one transformation bugfix
           <2.4>         8/17/89        sjk             Coded around MPW C3.0 bug
           <2.3>         8/14/89        sjk             1 point contours now OK
           <2.2>          8/8/89        sjk             Improved encryption handling
           <2.1>          8/2/89        sjk             Fixed outline caching bug
           <2.0>          8/2/89        sjk             Just fixed EASE comment
           <1.5>          8/1/89        sjk             Added composites and encryption. Plus some enhancements.
           <1.4>         6/13/89        SJK             Comment
           <1.3>          6/2/89        CEL             16.16 scaling of metrics, minimum recommended ppem, point size 0
                                                                        bug, correct transformed integralized ppem behavior, pretty much
                                                                        so
           <1.2>         5/26/89        CEL             EASE messed up on "c" comments
          <y1.1>         5/26/89        CEL             Integrated the new Font Scaler 1.0 into Spline Fonts
           <1.0>         5/25/89        CEL             Integrated 1.0 Font scaler into Bass code for the first time.

        To Do:
*/
/*              <3+>     3/20/90        mrr             Conditionalized error checking in fs_SetUpKey.
                                                                        Compiler option for stamping memmory areas for debugging
                                                                        Removed error field from FSInfo structure.
                                                                        Added call to RunFontProgram
                                                                        Added private function prototypes.
                                                                        Optimizations from diet clinic

*/

// DJC DJC.. added global include
#include "psglobal.h"
//DJC added include for setjmp
#include <setjmp.h>

/** FontScaler's Includes **/
#include "fserror.h"
#include "fscdefs.h"
#include "fontmath.h"
#include "sfnt.h"
#include "fnt.h"
#include "sc.h"
#include "fscaler.h"
#include "fsglue.h"
#include "privsfnt.h"

#define LOOPDOWN(n)             for (--n; n >= 0; --n)

#define OUTLINEBIT    0x02

#define SETJUMP(key, error)     if ( error = fs_setjmp(key->env) ) return( error )

#ifdef SEGMENT_LINK
#pragma segment FONTSCALER_C
#endif


#define PRIVATE

/* PRIVATE PROTOTYPES */
fsg_SplineKey* fs_SetUpKey (fs_GlyphInputType* inptr, unsigned stateBits, int* error);
int fs__Contour (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr, boolean useHints);
int32 fs_SetSplineDataPtrs (fs_GlyphInputType*inputPtr, fs_GlyphInfoType *outputPtr);
int32 fs_SetInternalOffsets (fs_GlyphInputType*inputPtr, fs_GlyphInfoType *outputPtr);
void fs_45DegreePhaseShift (sc_CharDataType *glyphPtr);
int32 fs_dropOutVal (fsg_SplineKey *key);

//DJC moved here
// this is defined in privsfnt.h
// int sfnt_ComputeMapping (fsg_SplineKey *, uint16, uint16); /*add prototype; @WIN*/

//DJC moved here
void FAR sfnt_DoOffsetTableMap (fsg_SplineKey *); /*add prototype; @WIN*/

//DJC moved here
void sfnt_ReadSFNTMetrics (fsg_SplineKey*, uint16); /* add prototype; @WIN*/

#ifdef  DEBUGSTAMP

  #define STAMPEXTRA              4
  #define STAMP                   'sfnt'

  void SETSTAMP (Ptr p)
  {
    * ((int32 *) ((p) - STAMPEXTRA)) = STAMP;
  }


  void CHECKSTAMP (Ptr p)
  {
    if (* ((int32 *) ((p) - STAMPEXTRA)) != STAMP)
      Debugger ();
  }

#else

  #define STAMPEXTRA              0
  #define SETSTAMP(p)
  #define CHECKSTAMP(p)

#endif

#ifdef PC_OS

#define FS_SETUPKEY(state)   register fsg_SplineKey*key = (fsg_SplineKey *)inputPtr->memoryBases[KEY_PTR_BASE];
#define SET_STATE(state)

#else

#define FS_SETUPKEY(state) \
  register fsg_SplineKey*key = fs_SetUpKey (inputPtr, state, &error);\
  if (!key) \
    return error;


void dummyReleaseSfntFrag (voidPtr p);
void dummyReleaseSfntFrag (voidPtr p)
{
}

#define SET_STATE(s)  key->state = (s)
#endif

/*
 *      Set up the key in case memmory has moved or been purged.
 */
#ifndef PC_OS
fsg_SplineKey*fs_SetUpKey (register fs_GlyphInputType*inptr, register unsigned stateBits, int*error)
{
  register fsg_SplineKey*key;

  key = (fsg_SplineKey *)inptr->memoryBases[KEY_PTR_BASE];
  key->memoryBases = inptr->memoryBases;
  key->GetSfntFragmentPtr = inptr->GetSfntFragmentPtr;

#ifdef RELEASE_MEM_FRAG
    if (!(key->ReleaseSfntFrag = inptr->ReleaseSfntFrag))
      key->ReleaseSfntFrag = dummyReleaseSfntFrag;
#else
    key->ReleaseSfntFrag = dummyReleaseSfntFrag;
#endif

  if ((key->state & stateBits) != stateBits)
  {
    *error = OUT_OFF_SEQUENCE_CALL_ERR;
    return 0;
  }

  key->clientID = inptr->clientID;
  *error = NO_ERR;

  return key;
}
#endif

/*** FONT SCALER INTERFACE ***/

/*
 *
 */

#ifndef PC_OS

FS_ENTRY fs_OpenFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
  outputPtr->memorySizes[KEY_PTR_BASE]                 = fsg_KeySize () + STAMPEXTRA;
  outputPtr->memorySizes[VOID_FUNC_PTR_BASE]           = fsg_InterPreterDataSize() + STAMPEXTRA;
  outputPtr->memorySizes[SCAN_PTR_BASE]                = fsg_ScanDataSize () + STAMPEXTRA;
  return NO_ERR;
}

FS_ENTRY fs_Initialize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
  register fsg_SplineKey                        *key;

    SETSTAMP (inputPtr->memoryBases[0] + outputPtr->memorySizes[0]);
    SETSTAMP (inputPtr->memoryBases[2] + outputPtr->memorySizes[2]);

    key = (fsg_SplineKey *)inputPtr->memoryBases[KEY_PTR_BASE];
    key->memoryBases = inputPtr->memoryBases;

#if 0 /* Pending jeanp's explanation of fnt_AA() issue  -- lenox 8/13/91 */
    if (tmpGS.function = (FntFunc*)key->memoryBases[VOID_FUNC_PTR_BASE])
    {
      fnt_Init( &tmpGS );
      SET_SET (INITIALIZED);
    }
    else
      return VOID_FUNC_PTR_BASE_ERR;
#endif

    SET_STATE (INITIALIZED);
    CHECKSTAMP (inputPtr->memoryBases[0] + outputPtr->memorySizes[0]);
    CHECKSTAMP (inputPtr->memoryBases[2] + outputPtr->memorySizes[2]);
    return NO_ERR;
}

#endif

/*
 *      This guy asks for memmory for points, instructions, fdefs and idefs
 */
FS_ENTRY FAR fs_NewSfnt (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
  int   error;
  //DJC moved to beg of file
  //DJC void FAR sfnt_DoOffsetTableMap (fsg_SplineKey *); /*add prototype; @WIN*/
  voidPtr sfnt_GetTablePtr (fsg_SplineKey *, sfnt_tableIndex, boolean); /*add prototype; @WIN*/
  //DJC moved to beg of file
  //DJC int sfnt_ComputeMapping (fsg_SplineKey *, uint16, uint16); /*add prototype; @WIN*/

  FS_SETUPKEY (INITIALIZED);

#ifdef PC_OS
  key->clientID = inputPtr->clientID;
  key->memoryBases = inputPtr->memoryBases;
#endif

  SETJUMP (key, error);

  CHECKSTAMP (inputPtr->memoryBases[0] + outputPtr->memorySizes[0]);
  CHECKSTAMP (inputPtr->memoryBases[1] + outputPtr->memorySizes[1]);
  CHECKSTAMP (inputPtr->memoryBases[2] + outputPtr->memorySizes[2]);

  sfnt_DoOffsetTableMap (key);                                  /* Map offset and length table */

  {
    sfnt_FontHeaderPtr fontHead = (sfnt_FontHeaderPtr)sfnt_GetTablePtr (key, sfnt_fontHeader, true);
    sfnt_HorizontalHeaderPtr horiHead = (sfnt_HorizontalHeaderPtr)sfnt_GetTablePtr (key, sfnt_horiHeader, true);

    if (SWAPL (fontHead->magicNumber) != SFNT_MAGIC)
    {
      return BAD_MAGIC_ERR;
    }
    key->emResolution            = SWAPW (fontHead->unitsPerEm);
    key->fontFlags               = SWAPW (fontHead->flags);
    key->numberOf_LongHorMetrics = SWAPW (horiHead->numberOf_LongHorMetrics);
    key->indexToLocFormat        = fontHead->indexToLocFormat;

    RELEASESFNTFRAG(key, horiHead);
    RELEASESFNTFRAG(key, fontHead);
  }
  {
    voidPtr p = sfnt_GetTablePtr (key, sfnt_maxProfile, true);
    key->maxProfile = * ((sfnt_maxProfileTablePtr) p);
#ifndef FSCFG_BIG_ENDIAN
    {
      int16 * p;
      for (p = (int16 *) & key->maxProfile; p < (int16 *) & key->maxProfile + sizeof (key->maxProfile) / sizeof (int16); p++)
        *p = SWAPW (*p);
    }
#endif

    RELEASESFNTFRAG(key, p);
  }

  outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]        = fsg_PrivateFontSpaceSize (key) + STAMPEXTRA;
  outputPtr->memorySizes[WORK_SPACE_BASE]                = fsg_WorkSpaceSetOffsets (key) + STAMPEXTRA;

#ifdef FSCFG_USE_GLYPH_DIRECTORY
  key->mappingF = 0;
#else
  if (error = sfnt_ComputeMapping (key, inputPtr->param.newsfnt.platformID, inputPtr->param.newsfnt.specificID))
    return error;
#endif

  SET_STATE (INITIALIZED | NEWSFNT);
  key->scanControl = 0;

/*
         *      Can't run font program yet, we don't have any memmory for the graphic state
         *      Mark it to be run in NewTransformation.
         */
  key->executeFontPgm = true;

#ifdef DEBUGSTAMP
  CHECKSTAMP (inputPtr->memoryBases[0] + outputPtr->memorySizes[0]);
  CHECKSTAMP (inputPtr->memoryBases[1] + outputPtr->memorySizes[1]);
  CHECKSTAMP (inputPtr->memoryBases[2] + outputPtr->memorySizes[2]);
#endif
  return NO_ERR;
}


FS_ENTRY fs_NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
  int   error;

  FS_SETUPKEY (INITIALIZED | NEWSFNT);

  SETJUMP (key, error);

#ifdef DEBUGSTAMP
  CHECKSTAMP (inputPtr->memoryBases[0] + outputPtr->memorySizes[0]);
  CHECKSTAMP (inputPtr->memoryBases[2] + outputPtr->memorySizes[2]);

  SETSTAMP (inputPtr->memoryBases[3] + outputPtr->memorySizes[3]);
  SETSTAMP (inputPtr->memoryBases[4] + outputPtr->memorySizes[4]);
#endif

#ifdef PC_OS
    /* Setup the font offsets */
  if (key->offset_storage == 0)
  {
    int8    **pu = (int8 **) &key->offset_storage, **puEnd;
    int8    *base = inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE];

    while (pu <= (int8 **) &key->offset_PreProgram)
      *pu++ = base + (unsigned) *pu;

    pu    = (int8 **) &key->elementInfoRec.offsets;
    puEnd = (int8 **) ((int8 *) pu + sizeof (fsg_OffsetInfo) * MAX_ELEMENTS);
    base  = key->memoryBases[WORK_SPACE_BASE];

    while (pu < puEnd)
      *pu++ = base + (unsigned) *pu;
  }
#endif

    /* Load the font program and pre program if necessary */
  if (key->executeFontPgm)
  {
    fnt_GlobalGraphicStateType *globalGS = (fnt_GlobalGraphicStateType *) FONT_OFFSET (key->memoryBases[PRIVATE_FONT_SPACE_BASE], key->offset_globalGS);

    fsg_SetUpProgramPtrs (key, globalGS, FONTPROGRAM);
    fsg_SetUpProgramPtrs (key, globalGS, PREPROGRAM);
  }

  key->currentTMatrix = *inputPtr->param.newtrans.transformMatrix;
  key->fixedPointSize = inputPtr->param.newtrans.pointSize;
  key->pixelDiameter     = inputPtr->param.newtrans.pixelDiameter;

#ifndef PC_OS
/*
 *  Fold the point size and resolution into the matrix
 */
    {   Fixed scale;

        scale = ShortMulDiv(key->fixedPointSize, inputPtr->param.newtrans.yResolution, (short)POINTSPERINCH);
        key->currentTMatrix.transform[0][1] = FixMul( key->currentTMatrix.transform[0][1], scale );
        key->currentTMatrix.transform[1][1] = FixMul( key->currentTMatrix.transform[1][1], scale );
        key->currentTMatrix.transform[2][1] = FixMul( key->currentTMatrix.transform[2][1], scale );

        scale = ShortMulDiv(key->fixedPointSize, inputPtr->param.newtrans.xResolution, (short)POINTSPERINCH);
        key->currentTMatrix.transform[0][0] = FixMul( key->currentTMatrix.transform[0][0], scale );
        key->currentTMatrix.transform[1][0] = FixMul( key->currentTMatrix.transform[1][0], scale );
        key->currentTMatrix.transform[2][0] = FixMul( key->currentTMatrix.transform[2][0], scale );

/*
*      Modifies key->fpem and key->currentTMatrix.
*/
#if 1
    fsg_ReduceMatrix (key);
#endif
    }
#endif

    /* get premultipliers if any, also called in sfnt_ReadSFNT */
  fsg_InitInterpreterTrans (key, &key->interpScalarX, &key->interpScalarY, &key->metricScalarX, &key->metricScalarY);

/****************************************************************************
 *      At this point, we have                                                                                                  *
 *              fixedPointSize = user defined fixed                                                                     *
 *              metricScalarX   = fixed scaler for scaling metrics                                       *
 *              interpScalarX   = fixed scaler for scaling outlines/CVT                          *
 *              pixelDiameter  = user defined fixed                                                                     *
 *              currentTMatrix = 3x3 user transform and non-squareness resolution       *
 ****************************************************************************/

/*
         *      This guy defines FDEFs and IDEFs.  The table is optional
         */
  if (key->executeFontPgm)
  {
    if (error = fnt_SetDefaults ((fnt_GlobalGraphicStateType*) FONT_OFFSET (key->memoryBases[PRIVATE_FONT_SPACE_BASE], key->offset_globalGS)))
      return error;
    if (error = fsg_RunFontProgram (key))
      return error;
    key->executeFontPgm = false;
  }

//if (!(key->executePrePgm = (boolean) !inputPtr->param.newtrans.traceFunc)) //@WIN
  if (!(key->executePrePgm = (uint8) !inputPtr->param.newtrans.traceFunc))
  {
/* Do this now so we do not confuse font editors */
/* Run the pre program and scale the control value table */
/* Sets key->executePrePgm to false */
    if (error = fsg_RunPreProgram (key, inputPtr->param.newtrans.traceFunc))
      return error;
  }

  SET_STATE (INITIALIZED | NEWSFNT | NEWTRANS);

  outputPtr->scaledCVT = (F26Dot6 *) FONT_OFFSET (key->memoryBases[PRIVATE_FONT_SPACE_BASE], key->offset_controlValues);

#ifdef DEBUGSTAMP
  CHECKSTAMP (inputPtr->memoryBases[0] + outputPtr->memorySizes[0]);
  CHECKSTAMP (inputPtr->memoryBases[2] + outputPtr->memorySizes[2]);
  CHECKSTAMP (inputPtr->memoryBases[3] + outputPtr->memorySizes[3]);
  CHECKSTAMP (inputPtr->memoryBases[4] + outputPtr->memorySizes[4]);
#endif
  return NO_ERR;
}


/*
 * Compute the glyph index from the character code.
 */
FS_ENTRY fs_NewGlyph (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
  int   error;
  FS_SETUPKEY (0);
  SETJUMP (key, error);

#ifdef DEBUGSTAMP
  CHECKSTAMP (inputPtr->memoryBases[0] + outputPtr->memorySizes[0]);
  CHECKSTAMP (inputPtr->memoryBases[2] + outputPtr->memorySizes[2]);
  CHECKSTAMP (inputPtr->memoryBases[3] + outputPtr->memorySizes[3]);
  CHECKSTAMP (inputPtr->memoryBases[4] + outputPtr->memorySizes[4]);
#endif
  SET_STATE (INITIALIZED | NEWSFNT | NEWTRANS);        /* clear all other bits */

  if (inputPtr->param.newglyph.characterCode != NONVALID)
  {
    uint8 FAR * mappingPtr = (uint8 FAR *)sfnt_GetTablePtr (key, sfnt_charToIndexMap, true);

    uint16 glyphIndex = key->mappingF (mappingPtr + key->mappOffset, inputPtr->param.newglyph.characterCode);
    outputPtr->glyphIndex = glyphIndex;
    key->glyphIndex = glyphIndex;

    RELEASESFNTFRAG(key, mappingPtr);
  }
  else
  {
    key->glyphIndex = outputPtr->glyphIndex = inputPtr->param.newglyph.glyphIndex;
  }

#ifdef DEBUGSTAMP
  CHECKSTAMP (inputPtr->memoryBases[0] + outputPtr->memorySizes[0]);
  CHECKSTAMP (inputPtr->memoryBases[2] + outputPtr->memorySizes[2]);
  CHECKSTAMP (inputPtr->memoryBases[3] + outputPtr->memorySizes[3]);
  CHECKSTAMP (inputPtr->memoryBases[4] + outputPtr->memorySizes[4]);
#endif
  return NO_ERR;
}


/*
 * this call is optional.
 *
 * can be called right after fs_NewGlyph ()
 */
FS_ENTRY fs_GetAdvanceWidth (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
  int   error;
  //DJC moved to beg of file
  //DJC void sfnt_ReadSFNTMetrics (fsg_SplineKey*, uint16); /* add prototype; @WIN*/

  FS_SETUPKEY (INITIALIZED | NEWSFNT | NEWTRANS);
  SETJUMP (key, error);

  sfnt_ReadSFNTMetrics (key, key->glyphIndex);

#ifdef PC_OS
  outputPtr->metricInfo.advanceWidth.x = key->nonScaledAW;
#else
    outputPtr->metricInfo.advanceWidth.y = 0;
    if ( key->identityTransformation )
        outputPtr->metricInfo.advanceWidth.x = ShortMulDiv( key->metricScalarX, key->nonScaledAW, key->emResolution );
    else {
        outputPtr->metricInfo.advanceWidth.x = FixDiv( key->nonScaledAW, key->emResolution );
        fsg_FixXYMul( &outputPtr->metricInfo.advanceWidth.x, &outputPtr->metricInfo.advanceWidth.y,
                   &key->currentTMatrix );
    }
#endif
  return NO_ERR;
}


int fs__Contour (fs_GlyphInputType*inputPtr, fs_GlyphInfoType*outputPtr, boolean useHints)
{
  register int8                         *workSpacePtr;
  register fsg_OffsetInfo               *offsetPtr;
  int   error;

  FS_SETUPKEY (INITIALIZED | NEWSFNT | NEWTRANS);
  SETJUMP (key, error);

#ifdef DEBUGSTAMP
  CHECKSTAMP (inputPtr->memoryBases[0] + outputPtr->memorySizes[0]);
  CHECKSTAMP (inputPtr->memoryBases[2] + outputPtr->memorySizes[2]);
  CHECKSTAMP (inputPtr->memoryBases[3] + outputPtr->memorySizes[3]);
  CHECKSTAMP (inputPtr->memoryBases[4] + outputPtr->memorySizes[4]);
#endif
/* potentially do delayed pre program execution */
  if (key->executePrePgm /*&& useHints*/)
  {
/* Run the pre program and scale the control value table */
    key->executePrePgm = false;
    if (error = fsg_RunPreProgram (key, 0))
      return error;
  }

  if (error = fsg_GridFit (key, inputPtr->param.gridfit.traceFunc, useHints))   /* THE CALL */
    return error;

  workSpacePtr        = key->memoryBases[WORK_SPACE_BASE];
  offsetPtr           = & (key->elementInfoRec.offsets[1]);

  outputPtr->xPtr     = (F26Dot6 *) FONT_OFFSET (workSpacePtr, offsetPtr->x);
  outputPtr->yPtr     = (F26Dot6 *) FONT_OFFSET (workSpacePtr, offsetPtr->y);
  outputPtr->startPtr = (int16 *) FONT_OFFSET (workSpacePtr, offsetPtr->sp);
  outputPtr->endPtr   = (int16 *) FONT_OFFSET (workSpacePtr, offsetPtr->ep);
  outputPtr->onCurve  = (uint8 *) FONT_OFFSET (workSpacePtr, offsetPtr->onCurve);
  outputPtr->numberOfContours    = key->elementInfoRec.interpreterElements[GLYPHELEMENT].nc;

#if 1
  {
    register metricsType*metric = &outputPtr->metricInfo;
    int      numPts = outputPtr->endPtr[outputPtr->numberOfContours-1] + 1 + PHANTOMCOUNT;
    register unsigned index1 = numPts-PHANTOMCOUNT + RIGHTSIDEBEARING;
    register unsigned index2 = numPts-PHANTOMCOUNT + LEFTSIDEBEARING;

    metric->devAdvanceWidth.x     = DOT6TOFIX (outputPtr->xPtr[index1] - outputPtr->xPtr[index2]);
    metric->devAdvanceWidth.y     = DOT6TOFIX (outputPtr->yPtr[index1] - outputPtr->yPtr[index2]);
  }

#endif

  outputPtr->scaledCVT = (F26Dot6 *) FONT_OFFSET (key->memoryBases[PRIVATE_FONT_SPACE_BASE], key->offset_controlValues);

  outputPtr->outlinesExist = (uint16) (key->glyphLength != 0);

  SET_STATE (INITIALIZED | NEWSFNT | NEWTRANS | GOTGLYPH);

#ifdef DEBUGSTAMP
  CHECKSTAMP (inputPtr->memoryBases[0] + outputPtr->memorySizes[0]);
  CHECKSTAMP (inputPtr->memoryBases[1] + outputPtr->memorySizes[1]);
  CHECKSTAMP (inputPtr->memoryBases[2] + outputPtr->memorySizes[2]);
  CHECKSTAMP (inputPtr->memoryBases[3] + outputPtr->memorySizes[3]);
  CHECKSTAMP (inputPtr->memoryBases[4] + outputPtr->memorySizes[4]);
#endif
  return NO_ERR;
}

#ifndef PC_OS

FS_ENTRY fs_ContourNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
  return fs__Contour (inputPtr, outputPtr, false);
}


FS_ENTRY fs_ContourGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
  return fs__Contour (inputPtr, outputPtr, true);
}

#endif

FS_ENTRY fs_FindBitMapSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
  register fnt_ElementType  *elementPtr;
  register int8             *workSpacePtr;
  sc_CharDataType           charData;
  register sc_BitMapData    *bitRecPtr;
  uint16                    scan, byteWidth;
  unsigned                  numPts;
  int                       nx;
  FS_MEMORY_SIZE            size;
  int                       error;

  FS_SETUPKEY (INITIALIZED | NEWSFNT | NEWTRANS | GOTGLYPH);
  SETJUMP (key, error);

#ifdef DEBUGSTAMP
  CHECKSTAMP (inputPtr->memoryBases[0] + outputPtr->memorySizes[0]);
  CHECKSTAMP (inputPtr->memoryBases[1] + outputPtr->memorySizes[1]);
  CHECKSTAMP (inputPtr->memoryBases[2] + outputPtr->memorySizes[2]);
  CHECKSTAMP (inputPtr->memoryBases[3] + outputPtr->memorySizes[3]);
  CHECKSTAMP (inputPtr->memoryBases[4] + outputPtr->memorySizes[4]);
#endif
#ifdef USE_OUTLINE_CACHE
  key->outlineIsCached = false;
#endif

  elementPtr    = & (key->elementInfoRec.interpreterElements[GLYPHELEMENT]);
  workSpacePtr  = key->memoryBases[WORK_SPACE_BASE];
  bitRecPtr     = & (key->bitMapInfo);

  charData      = *elementPtr;

  if (key->phaseShift)
    fs_45DegreePhaseShift (&charData);

  error = sc_FindExtrema (&charData,  bitRecPtr);
#ifndef PC_OS
  if (error)
    return error;
#endif

  scan          = bitRecPtr->high;
  byteWidth     = bitRecPtr->wide >> 3;

  {
    BitMap * bm  = &outputPtr->bitMapInfo;
    bm->baseAddr = 0;
    bm->rowBytes = byteWidth;
#ifdef PC_OS
    bm->bounds   = bitRecPtr->bounds;
#else
    bm->bounds.left   = bitRecPtr->bounds.xMin;
    bm->bounds.right  = bitRecPtr->bounds.xMax;
    bm->bounds.top    = bitRecPtr->bounds.yMin;
    bm->bounds.bottom = bitRecPtr->bounds.yMax;
#endif
  }

  numPts = charData.ep[charData.nc-1] + 1 + PHANTOMCOUNT;
  {
    register metricsType*metric = &outputPtr->metricInfo;
    register unsigned index1 = numPts-PHANTOMCOUNT + RIGHTSIDEBEARING;
    register unsigned index2 = numPts-PHANTOMCOUNT + LEFTSIDEBEARING;
    register Fixed    tmp32;

    metric->devAdvanceWidth.x     = DOT6TOFIX (charData.x[index1] - charData.x[index2]);
    metric->devAdvanceWidth.y     = DOT6TOFIX (charData.y[index1] - charData.y[index2]);
    index1 = numPts - PHANTOMCOUNT + LEFTEDGEPOINT;
    metric->devLeftSideBearing.x  = DOT6TOFIX (charData.x[index1] - charData.x[index2]);
    metric->devLeftSideBearing.y  = DOT6TOFIX (charData.y[index1] - charData.y[index2]);

#ifndef PC_OS
    outputPtr->metricInfo.advanceWidth.y = 0;
    if ( key->identityTransformation )
        outputPtr->metricInfo.advanceWidth.x = ShortMulDiv( key->metricScalarX, key->nonScaledAW, key->emResolution );
    else {
        outputPtr->metricInfo.advanceWidth.x = FixDiv( key->nonScaledAW, key->emResolution );
        fsg_FixXYMul( &outputPtr->metricInfo.advanceWidth.x, &outputPtr->metricInfo.advanceWidth.y,
                   &key->currentTMatrix );
    }
#endif

    index2 = numPts - PHANTOMCOUNT + ORIGINPOINT;
#ifndef PC_OS
    metric->leftSideBearing.x = DOT6TOFIX (charData.x[index1] - charData.x[index2]);
    metric->leftSideBearing.y = DOT6TOFIX (charData.y[index1] - charData.y[index2]);

/* store away sidebearing along the advance width vector */
    metric->leftSideBearingLine = metric->leftSideBearing;
    metric->devLeftSideBearingLine = metric->devLeftSideBearing;
#endif

/* Add vector to left upper edge of bitmap for ease of positioning by client */
    tmp32 = ((Fixed) (bitRecPtr->bounds.xMin) << 16) - DOT6TOFIX (charData.x[index1]);
#ifndef PC_OS
    metric->leftSideBearing.x            += tmp32;
#endif
    metric->devLeftSideBearing.x         += tmp32;
    tmp32 = ((Fixed) (bitRecPtr->bounds.yMax) << 16) - DOT6TOFIX (charData.y[index1]);
#ifndef PC_OS
    metric->leftSideBearing.y            += tmp32;
#endif
    metric->devLeftSideBearing.y         += tmp32;
  }

  SET_STATE (INITIALIZED | NEWSFNT | NEWTRANS | GOTGLYPH | SIZEKNOWN);

/* get memory for bitmap in bitMapRecord */
  if (scan == 0)
    ++scan;

  outputPtr->memorySizes[BITMAP_PTR_1] = (FS_MEMORY_SIZE) SHORTMUL (scan, byteWidth) + STAMPEXTRA;

/* get memory for yLines & yBase in bitMapRecord */
  size = (int32)scan * ((bitRecPtr->nYchanges + 2L) * sizeof (int16) + sizeof (int16 *));
  outputPtr->memorySizes[BITMAP_PTR_2] = size;

  if (fs_dropOutVal (key))
  {
/* get memory for xLines and xBase - used only for dropout control */
    nx           = bitRecPtr->bounds.xMax - bitRecPtr->bounds.xMin;
    if (nx == 0)
      ++nx;
    size         = (nx * (((FS_MEMORY_SIZE) bitRecPtr->nXchanges + 2) * sizeof (int16) + sizeof (int16 *)));
  }
  else
    size = 0;

  outputPtr->memorySizes[BITMAP_PTR_3] = size;

#ifdef DEBUGSTAMP
  CHECKSTAMP (inputPtr->memoryBases[0] + outputPtr->memorySizes[0]);
  CHECKSTAMP (inputPtr->memoryBases[1] + outputPtr->memorySizes[1]);
  CHECKSTAMP (inputPtr->memoryBases[2] + outputPtr->memorySizes[2]);
  CHECKSTAMP (inputPtr->memoryBases[3] + outputPtr->memorySizes[3]);
  CHECKSTAMP (inputPtr->memoryBases[4] + outputPtr->memorySizes[4]);
#endif
  return NO_ERR;
}

/* rwb - 4/21/90 - fixed to better work with caching */
FS_ENTRY fs_ContourScan (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
  register sc_BitMapData        *bitRecPtr;
  register fnt_ElementType      *elementPtr;
  sc_GlobalData                 * scPtr;
  sc_CharDataType               charData;
  int32                         scanControl;
  int16                         lowBand, highBand;
  uint16                        nx, ny;
  int                           error;

  FS_SETUPKEY (INITIALIZED | NEWSFNT | NEWTRANS | GOTGLYPH | SIZEKNOWN);
  SETJUMP (key, error);

#ifdef DEBUGSTAMP
  CHECKSTAMP (inputPtr->memoryBases[0] + outputPtr->memorySizes[0]);
  CHECKSTAMP (inputPtr->memoryBases[2] + outputPtr->memorySizes[2]);
  CHECKSTAMP (inputPtr->memoryBases[3] + outputPtr->memorySizes[3]);
  CHECKSTAMP (inputPtr->memoryBases[4] + outputPtr->memorySizes[4]);
#endif
  bitRecPtr = &key->bitMapInfo;

#ifdef USE_OUTLINE_CACHE
  if (!key->outlineIsCached)
#endif
  {
    register int8 *workSpacePtr  = key->memoryBases[WORK_SPACE_BASE];
    elementPtr                   = & (key->elementInfoRec.interpreterElements[GLYPHELEMENT]);

    charData                     = *elementPtr;
  }
#ifdef USE_OUTLINE_CACHE
  else
  {
    register int32 *src = inputPtr->param.scan.outlineCache;
    register int32 numPoints;

    if (*src != OUTLINESTAMP)
      return TRASHED_OUTLINE_CACHE;
    src  += 4;          /* skip over stamp and 3 bitmap memory areas  */

    bitRecPtr->wide = *src++;
    bitRecPtr->high = *src++;
    bitRecPtr->bounds.xMin = *src++;
    bitRecPtr->bounds.yMin = *src++;
    bitRecPtr->bounds.xMax = *src++;
    bitRecPtr->bounds.yMax = *src++;
    bitRecPtr->nXchanges =  *src++;
    bitRecPtr->nYchanges =  *src++;
    key->scanControl =          *src++;
    key->imageState  =          *src++;

    {
      int16* wordptr = (int16*)src;

        /* # of contours */
      charData.nc = *wordptr++;

        /* start points */
      charData.sp = wordptr;
      wordptr += charData.nc;

        /* end points */
      charData.ep = wordptr;
      wordptr += charData.nc;

      src = (int32*)wordptr;
    }

    numPoints = charData.ep[charData.nc-1] + 1;

/* x coordinates */
    charData.x = src;
    src += numPoints;

/* y coordinates */
    charData.y = src;
    src += numPoints;

/* on curve flags */
    {
      int8* byteptr = (int8*)src;
      charData.onCurve = byteptr;
      byteptr += numPoints;
      if (*byteptr != (int8) OUTLINESTAMP2)
        return TRASHED_OUTLINE_CACHE;
    }
  }
#endif          /* use outline cache */

  scPtr                          = (sc_GlobalData *)key->memoryBases[SCAN_PTR_BASE];

  nx                                     = bitRecPtr->bounds.xMax - bitRecPtr->bounds.xMin;
  if (nx == 0)
    ++nx;

  scanControl = fs_dropOutVal( key );

/*      If topclip <= bottom clip there is no banding by convention  */
  highBand = inputPtr->param.scan.topClip;
  lowBand  = inputPtr->param.scan.bottomClip;

#ifndef PC_OS
  if (highBand <= lowBand)
  {
    highBand = bitRecPtr->bounds.yMax;
    lowBand = bitRecPtr->bounds.yMin;
  }
  else if (highBand != bitRecPtr->bounds.yMax || lowBand != bitRecPtr->bounds.yMin)
  {
#ifdef FSCFG_NO_BANDING
    return SCAN_ERR;
#endif
  }
    /* check for out of bounds band request                                                         <10> */
  if (highBand > bitRecPtr->bounds.yMax)
    highBand = bitRecPtr->bounds.yMax;
  if (lowBand < bitRecPtr->bounds.yMin)
    lowBand = bitRecPtr->bounds.yMin;

/* 11/16/90 rwb - We now allow the client to turn off DOControl by returning a NIL pointer
to the memory area used by DOC.  This is done so that in low memory conditions, the
client can get enough memory to print something.  We also always turn off DOC if the client
has requested banding.  Both of these conditions may change in the future.  Some versions
of TT may simply return an error condition when the NIL pointer to memoryarea 7 is
provided.  We also need to rewrite the scan converter routines that fill the bitmap
under dropout conditions so that they use noncontiguous memory for the border scanlines
that need to be present for doing DOC.  This will allow us to do DOC even though we are
banding, providing there is enough memory.  By preflighting the fonts so that the request
for memory for areas 6 and 7 from findBitMapSize is based on actual need rather than
worse case analysis, we may also be able to reduce the memory required to do DOC in all
cases and particulary during banding.
*/
    /* inhibit DOControl if banding */
  if (highBand < bitRecPtr->bounds.yMax || lowBand > bitRecPtr->bounds.yMin)
    scanControl = 0;

    /* Allow client to turn off DOControl */
  if (key->memoryBases[BITMAP_PTR_3] == 0)
    scanControl = 0;

#else

  highBand = bitRecPtr->bounds.yMax;
  lowBand = bitRecPtr->bounds.yMin;

#endif

  bitRecPtr->bitMap       = (uint32 *)key->memoryBases[BITMAP_PTR_1];

  if( scanControl )
  {
    bitRecPtr->xLines    = (int16 *) key->memoryBases[BITMAP_PTR_3];
    bitRecPtr->xBase     = (int16 * *)((char *) bitRecPtr->xLines + (bitRecPtr->nXchanges + 2) * nx * sizeof (int16));

    ny                   = bitRecPtr->bounds.yMax - bitRecPtr->bounds.yMin;
  }
  else
    ny                   = highBand - lowBand;

  if (ny == 0)
    ++ny;

  bitRecPtr->yLines    = (int16 *) key->memoryBases[BITMAP_PTR_2];
  bitRecPtr->yBase     = (int16 * *) ((char *) bitRecPtr->yLines + ((FS_MEMORY_SIZE)bitRecPtr->nYchanges + 2) * (FS_MEMORY_SIZE)ny * sizeof (int16));

  if (error = sc_ScanChar (&charData, scPtr, bitRecPtr, lowBand, highBand, scanControl))
    return error;
  {
    register BitMap*bm = &outputPtr->bitMapInfo;
    bm->baseAddr         = (int8 *)bitRecPtr->bitMap;
    bm->rowBytes         = bitRecPtr->wide >> 3;
#ifdef PC_OS
    bm->bounds   = bitRecPtr->bounds;
    bitRecPtr->bounds.yMin += ny;
    bitRecPtr->bounds.xMin += nx;
#else
    bm->bounds.left   = bitRecPtr->bounds.xMin;
    bm->bounds.right  = bitRecPtr->bounds.xMax;
    bm->bounds.top    = bitRecPtr->bounds.yMin;
    bm->bounds.bottom = bitRecPtr->bounds.yMax;
#endif
  }

#ifdef DEBUGSTAMP
  CHECKSTAMP (inputPtr->memoryBases[0] + outputPtr->memorySizes[0]);
  CHECKSTAMP (inputPtr->memoryBases[2] + outputPtr->memorySizes[2]);
  CHECKSTAMP (inputPtr->memoryBases[3] + outputPtr->memorySizes[3]);
  CHECKSTAMP (inputPtr->memoryBases[4] + outputPtr->memorySizes[4]);
#endif
  return NO_ERR;
}

#ifndef PC_OS

FS_ENTRY fs_CloseFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
  return NO_ERR;
}

#endif


PRIVATE void fs_45DegreePhaseShift (sc_CharDataType *glyphPtr)
{
  F26Dot6 * x = glyphPtr->x;
  int16 count = glyphPtr->ep[glyphPtr->nc-1];
  for (; count >= 0; --count)
  {
    (*x)++;
    ++x;
  }
}


/* Use various spline key values to determine if dropout control is to be activated
 * for this glyph, and if so what kind of dropout control.
 * The use of dropout control mode in the scan converter is controlled by 3 conditions.
 * The conditions are: Is the glyph rotated?, is the glyph stretched?,
 * is the current pixels per Em less than a specified threshold?
 * These conditions can be OR'd or ANDed together to determine whether the dropout control
 * mode ought to be used.

Six bits are used to specify the joint condition.  Their meanings are:

BIT             Meaning if set
8               Do dropout mode if other conditions don't block it AND
                        pixels per em is less than or equal to bits 0-7
9               Do dropout mode if other conditions don't block it AND
                        glyph is rotated
10              Do dropout mode if other conditions don't block it AND
                        glyph is stretched
11              Do not do dropout mode unless ppem is less than or equal to bits 0-7
                        A value of FF in 0-7  means all sizes
                        A value of 0 in 0-7 means no sizes
12              Do not do dropout mode unless glyph is rotated
13              Do not do dropout mode unless glyph is stretched

In other words, we do not do dropout control if:
No bits are set,
Bit 8 is set, but ppem is greater than threshold
Bit 9 is set, but glyph is not rotated
Bit 10 is set, but glyph is not stretched
None of the conditions specified by bits 11-13 are true.

For example, 0xA10 specifies turn dropout control on if the glyph is rotated providing
that it is also less than 0x10 pixels per em.  A glyph is considered stretched if
the X and Y resolutions are different either because of the device characteristics
or because of the transformation matrix.  If both X and Y are changed by the same factor
the glyph is not considered stretched.

 */

PRIVATE int32 fs_dropOutVal (fsg_SplineKey *key)
{
  register int32 condition = key->scanControl;
  if (! (condition & 0x3F00))
    return 0;
  if ((condition & 0xFFFF0000) == NODOCONTROL)
    return 0;
  {
    register int32 imageState = key->imageState;
    if ((condition & 0x800) && ((imageState & 0xFF) > (condition & 0xFF)))
      return 0;
    if ((condition & 0x1000) && ! (imageState & ROTATED))
      return 0;
    if ((condition & 0x2000) && ! (imageState & STRETCHED))
      return 0;
    if ((condition & 0x100) && ((imageState & 0xFF) <= (condition & 0xFF)))
      return condition;
    if ((condition & 0x100) && ((condition & 0xFF) == 0xFF))
      return condition;
    if ((condition & 0x200) && (imageState & ROTATED))
      return condition;
    if ((condition & 0x400) && (imageState & STRETCHED))
      return condition;
    return 0;
  }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\bass\fscaler.h ===
/*
    File:       fscaler.h

    Contains:   xxx put contents here (or delete the whole line) xxx

    Written by: xxx put name of writer here (or delete the whole line) xxx

    Copyright:  c 1988-1990 by Apple Computer, Inc., all rights reserved.

    Change History (most recent first):

        <9+>     7/17/90    MR      Conditionalize names in FSInput
         <9>     7/14/90    MR      rename SQRT2 to FIXEDSQRT2, removed specificID and lowestRecPPEM
                                    from FSInfo
         <8>     7/13/90    MR      FSInput now has a union to save space, points to matrix instead
                                    of storing it
         <6>     6/21/90    MR      Change fillFunc to ReleaseSfntFrag
         <5>      6/5/90    MR      remove readmvt and mapcharcodes
         <4>      5/3/90    RB      Added memory area for new scan converter. MIKE REED - Removed
                                    .error from fsinfo structure. Added MapCharCodes and ReadMVT
                                    calls.
         <3>     3/20/90    CL      New comment style for BBS.
         <2>     2/27/90    CL      New CharToIndexMap Table format.
       <3.5>    11/15/89    CEL     Placed an ifdef around inline MPW calls to the trap. This makes
                                    it easier to compile for skia and the likes who do not use the
                                    MPW compiler.
       <3.4>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
                                    phantom points are in, even for components in a composite glyph.
                                    They should also work for transformations. Device metric are
                                    passed out in the output data structure. This should also work
                                    with transformations. Another leftsidebearing along the advance
                                    width vector is also passed out. whatever the metrics are for
                                    the component at it's level. Instructions are legal in
                                    components. Instructions are legal in components. Five
                                    unnecessary element in the output data structure have been
                                    deleted. (All the information is passed out in the bitmap data
                                    structure) fs_FindBMSize now also returns the bounding box.
       <3.3>     9/27/89    CEL     Took out devAdvanceWidth & devLeftSideBearing.
       <3.2>     9/25/89    CEL     Took out Mac specific functions.
       <3.1>     9/15/89    CEL     Re-working dispatcher.
       <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
       <2.2>     8/14/89    sjk     1 point contours now OK
       <2.1>      8/8/89    sjk     Improved encryption handling
       <2.0>      8/2/89    sjk     Just fixed EASE comment
       <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
       <1.4>     6/13/89    SJK     Comment
       <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
                                    bug, correct transformed integralized ppem behavior, pretty much
                                    so
       <1.2>     5/26/89    CEL     EASE messed up on "c" comments
      <,1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
       <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

    To Do:
*/
/* QuickDraw Types */
#ifdef PC_OS
typedef int8 FAR *Ptr; /*@WIN*/

struct BitMap {
    Ptr baseAddr;
    int16 rowBytes;
    BBOX bounds;
};

#ifndef __cplusplus
typedef struct BitMap BitMap;
#endif

#else   /* PC_OS */

#ifndef _MacTypes_
#ifndef __TYPES__
    typedef struct Rect {
        int16 top;
        int16 left;
        int16 bottom;
        int16 right;
    } Rect;
#endif
#endif

#ifndef _Quickdraw_
#ifndef __QUICKDRAW__
    typedef struct BitMap {
        char FAR * baseAddr;    /*@WIN*/
        int16 rowBytes;
        Rect bounds;
    } BitMap;
#endif
#endif

#endif /* PC_OS */

#define MEMORYFRAGMENTS 8


#define NONVALID 0xffff

/* For the flags field in the flags field */

/* set on 68020, do not set on 68000 */
#define READ_NONALIGNED_SHORT_IS_OK 0x0001          /* set when calling fs_OpenFonts() */
/* set on 68020, do not set on 68000 */
#define READ_NONALIGNED_LONG_IS_OK  0x0002          /* set when calling fs_OpenFonts() */

typedef struct {
    vectorType      advanceWidth, leftSideBearing;
    vectorType      leftSideBearingLine, devLeftSideBearingLine;/* along AW line */
    vectorType      devAdvanceWidth, devLeftSideBearing;
} metricsType;

#ifdef PC_OS
#define FS_MEMORY_SIZE  int
#else
#define FS_MEMORY_SIZE  int32
#endif

/*
 * Output data structure to the Font Scaler.
 */
typedef struct {
    FS_MEMORY_SIZE memorySizes[MEMORYFRAGMENTS];

    uint16  glyphIndex;
#ifndef PC_OS
    uint16  numberOfBytesTaken; /* from the character code */
#endif

    metricsType     metricInfo;
    BitMap          bitMapInfo;

    /* Spline Data */
    int32       outlineCacheSize;
    uint16      outlinesExist;
    uint16      numberOfContours;
    F26Dot6     FAR *xPtr, FAR *yPtr; /*@WIN*/
    int16       FAR *startPtr; /*@WIN*/
    int16       FAR *endPtr; /*@WIN*/
    uint8       FAR *onCurve; /*@WIN*/
    /* End of spline data */

    /* Only of interest to editors */
    F26Dot6     FAR *scaledCVT; /*@WIN*/

} fs_GlyphInfoType;

/*
 * Input data structure to the Font Scaler.
 *
 * if styleFunc is set to non-zero it will be called just before the transformation
 * will be applied, but after the grid-fitting with a pointer to fs_GlyphInfoType.
 * so this is what styleFunc should be voidFunc StyleFunc (fs_GlyphInfoType *data);
 * For normal operation set this function pointer to zero.
 *
 */

#ifndef UNNAMED_UNION

typedef struct {
    Fixed               version;
    char FAR *               memoryBases[MEMORYFRAGMENTS];      /*@WIN*/
#ifndef PC_OS
    int32               FAR *sfntDirectory; /* (sfnt_OffsetTable    *) always needs to be set, when we have the sfnt @WIN*/
    GetSFNTFunc         GetSfntFragmentPtr; /* (clientID, offset, length) */
    ReleaseSFNTFunc     ReleaseSfntFrag;
#endif
    int32               clientID; /* client private id/stamp (eg. handle for the sfnt) */

    union {
        struct {
            uint16  platformID;
            uint16  specificID;
        } newsfnt;
        struct {
            Fixed           pointSize;
            int16           xResolution;
            int16           yResolution;
            Fixed           pixelDiameter;      /* compute engine char from this */
            transMatrix FAR *    transformMatrix;       /*@WIN*/
            voidFunc        traceFunc;
        } newtrans;
        struct {
            uint16  characterCode;
            uint16  glyphIndex;
        } newglyph;
        struct {
            void            (*styleFunc) (fs_GlyphInfoType FAR *); /*@WIN*/
            voidFunc        traceFunc;
        } gridfit;
        int32 FAR *  outlineCache; /*@WIN*/
        struct {
            int16   bottomClip;
            int16   topClip;
            int32 FAR *  outlineCache; /*@WIN*/
        } scan;
    } param;
} fs_GlyphInputType;

#else

typedef struct {
    Fixed               version;
    char*               memoryBases[MEMORYFRAGMENTS];
#ifndef PC_OS
    int32               *sfntDirectory; /* (sfnt_OffsetTable    *) always needs to be set, when we have the sfnt */
    GetSFNTFunc         GetSfntFragmentPtr; /* (clientID, offset, length) */
    ReleaseSFNTFunc     ReleaseSfntFrag;
#endif
    int32               clientID; /* client private id/stamp (eg. handle for the sfnt) */

    union {
        struct {
            uint16  platformID;
            uint16  specificID;
        };
        struct {
            Fixed           pointSize;
            int16           xResolution;
            int16           yResolution;
            Fixed           pixelDiameter;      /* compute engine char from this */
            transMatrix*    transformMatrix;
            voidFunc        tracePreProgramFunc;
        };
        struct {
            uint16  characterCode;
            uint16  glyphIndex;
        };
        struct {
            void            (*styleFunc) (fs_GlyphInfoType*);
            voidFunc        traceGridFitFunc;
        };
        int32*  outlineCache1;
        struct {
            int16   bottomClip;
            int16   topClip;
            int32*  outlineCache2;
        };
    };
} fs_GlyphInputType;

#endif      /* unnamed union */

#ifndef FIXEDSQRT2
#define FIXEDSQRT2 0x00016A0A
#endif

/* Font scaler trap selctors */
#define OUTLINEFONTTRAP     0xA854
#define FS_OPENFONTS        0x8000
#define FS_INITIALIZE       0x8001
#define FS_NEWSFNT          0x8002
#define FS_NEWTRANS         0x8003
#define FS_NEWGLYPH         0x8004
#define FS_GETAW            0x8005
#define FS_GRIDFITT         0x8006
#define FS_NOGRIDFITT       0x8007
#define FS_FINDBMSIZE       0x8008
#define FS_SIZEOFOUTLINES   0x8009
#define FS_SAVEOUTLINES     0x800a
#define FS_RESTOREOUTLINES  0x800b
#define FS_CONTOURSCAN      0x800c
#define FS_CLOSE            0x800d
#define FS_READMVT          0x800e
#define FS_MAPCHAR_CODES    0x800f

#ifndef FS_ENTRY
#ifdef PC_OS
#define FS_ENTRY int
#else
#define FS_ENTRY int32
#endif
#endif

#ifdef MACINIT
extern FS_ENTRY fs__OpenFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
    = {0x303C,FS_OPENFONTS,0xA854};
extern FS_ENTRY fs__Initialize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
    = {0x303C,FS_INITIALIZE,0xA854};
extern FS_ENTRY fs__NewSfnt (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
    = {0x303C,FS_NEWSFNT,0xA854};
extern FS_ENTRY fs__NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
    = {0x303C,FS_NEWTRANS,0xA854};
extern FS_ENTRY fs__NewGlyph (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
    = {0x303C,FS_NEWGLYPH,0xA854};
extern FS_ENTRY fs__GetAdvanceWidth (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
    = {0x303C,FS_GETAW,0xA854};
extern FS_ENTRY fs__ContourGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
    = {0x303C,FS_GRIDFITT,0xA854};
extern FS_ENTRY fs__ContourNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
    = {0x303C,FS_NOGRIDFITT,0xA854};
extern FS_ENTRY fs__FindBitMapSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
    = {0x303C,FS_FINDBMSIZE,0xA854};

/* these three optional calls are for caching the outlines */
extern FS_ENTRY fs__SizeOfOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
    = {0x303C,FS_SIZEOFOUTLINES,0xA854};
extern FS_ENTRY fs__SaveOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
    = {0x303C,FS_SAVEOUTLINES,0xA854};
extern FS_ENTRY fs__RestoreOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
    = {0x303C,FS_RESTOREOUTLINES,0xA854};

extern FS_ENTRY fs__ContourScan (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
    = {0x303C,FS_CONTOURSCAN,0xA854};
extern FS_ENTRY fs__CloseFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
    = {0x303C,FS_CLOSE,0xA854};

#else

/*** Direct Calls to Font Scaler Client Interface, for Clients not using the trap mechanism ***/
/* add FAR to all following lines @WIN */
extern FS_ENTRY fs_OpenFonts (fs_GlyphInputType FAR *inputPtr, fs_GlyphInfoType FAR *outputPtr);
extern FS_ENTRY fs_Initialize (fs_GlyphInputType FAR *inputPtr, fs_GlyphInfoType FAR *outputPtr);
extern FS_ENTRY FAR fs_NewSfnt (fs_GlyphInputType FAR *inputPtr, fs_GlyphInfoType FAR *outputPtr);
extern FS_ENTRY fs_NewTransformation (fs_GlyphInputType FAR *inputPtr, fs_GlyphInfoType FAR *outputPtr);
extern FS_ENTRY fs_NewGlyph (fs_GlyphInputType FAR *inputPtr, fs_GlyphInfoType FAR *outputPtr);
extern FS_ENTRY fs_GetAdvanceWidth (fs_GlyphInputType FAR *inputPtr, fs_GlyphInfoType FAR *outputPtr);
extern FS_ENTRY fs_ContourGridFit (fs_GlyphInputType FAR *inputPtr, fs_GlyphInfoType FAR *outputPtr);
extern FS_ENTRY fs_ContourNoGridFit (fs_GlyphInputType FAR *inputPtr, fs_GlyphInfoType FAR *outputPtr);
extern FS_ENTRY fs_FindBitMapSize (fs_GlyphInputType FAR *inputPtr, fs_GlyphInfoType FAR *outputPtr);

/* these three optional calls are for caching the outlines */
extern FS_ENTRY fs_SizeOfOutlines (fs_GlyphInputType FAR *inputPtr, fs_GlyphInfoType FAR *outputPtr);
extern FS_ENTRY fs_SaveOutlines (fs_GlyphInputType FAR *inputPtr, fs_GlyphInfoType FAR *outputPtr);
extern FS_ENTRY fs_RestoreOutlines (fs_GlyphInputType FAR *inputPtr, fs_GlyphInfoType FAR *outputPtr);

extern FS_ENTRY fs_ContourScan (fs_GlyphInputType FAR *inputPtr, fs_GlyphInfoType FAR *outputPtr);
extern FS_ENTRY fs_CloseFonts (fs_GlyphInputType FAR *inputPtr, fs_GlyphInfoType FAR *outputPtr);

extern int fs__Contour (fs_GlyphInputType FAR *inputPtr, fs_GlyphInfoType FAR *outputPtr, boolean useHints);

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\bass\privfsca.h ===
/*
    File:       privfsca.h

    Contains:   Nothing Important

    Written by: Charlton E. Lui

    Copyright:  c 1990 by Apple Computer, Inc., all rights reserved.

    Change History (most recent first):

         <2>      5/3/90    RB      nothing new
         <1>     4/16/90    HJR     first checked in
         <1>     4/10/90    CL      first checked in

    To Do:
*/

/* ****************************************************
**
** CKL  02/20/1990  Added ANSI-C prototypes
**
** ****************************************************
*/
 
/*
 *
 *  c Apple Computer Inc. 1988, 1989, 1990.
 *
 *  The file defines private sfnt stuff
 *
 * History:
 * 
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\bass\fsconfig.h ===
/*
    File:       fsconfig.h : (Macintosh version)

    Written by: Lenox Brassell

    Contains:   #define directives for FontScaler build options

    Copyright:  c 1989-1990 by Microsoft Corp., all rights reserved.

    Change History (most recent first):
        <1>      8/27/91    LB      Created file.

    Usage:  This file is "#include"-ed as the first statement in
            "fscdefs.h".  This file contains platform-specific
            override definitions for the following #define-ed data
	    types and macros, which have default definitions in
	    "fscdefs.h":
                ArrayIndex
                F26Dot6
                FAR
                FS_MAC_PASCAL
                FS_MAC_TRAP
                FS_PC_PASCAL
                LoopCount
                MEMCPY
                MEMSET
                NEAR 
                SHORTDIV
                SHORTMUL
                SWAPL
                SWAPW
                SWAPWINC
                TMP_CONV
                boolean

            This file gives the integrator a place to override the
            default definitions of these items, as well as a place
            to define other configuration-specific macros.
*/

#define RELEASE_MEM_FRAG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\bass\fserror.h ===
/*
    File:       fserror.h

    Contains:   xxx put contents here (or delete the whole line) xxx

    Written by: xxx put name of writer here (or delete the whole line) xxx

    Copyright:  c 1989-1990 by Apple Computer, Inc., all rights reserved.

    Change History (most recent first):

         <4>     7/13/90    MR      made endif at bottom use a comment
         <3>      5/3/90    RB      Changed char to int8 for variable type.   Now it is legal to
                                    pass in zero as the address of memory when a piece of
         <2>     2/27/90    CL      New error code for missing but needed table. (0x1409)
       <3.1>    11/14/89    CEL     Now it is legal to pass in zero as the address of memory when a
                                    piece of the sfnt is requested by the scaler. If this happens
                                    the scaler will simply exit with an error code !
       <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
       <2.2>     8/14/89    sjk     1 point contours now OK
       <2.1>      8/8/89    sjk     Improved encryption handling
       <2.0>      8/2/89    sjk     Just fixed EASE comment
       <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
       <1.4>     6/13/89    SJK     Comment
       <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
                                    bug, correct transformed integralized ppem behavior, pretty much
                                    so
       <1.2>     5/26/89    CEL     EASE messed up on "c" comments
      <,1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
       <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

    To Do:
*/
/************/
/** ERRORS **/
/************/
#define NO_ERR                      0x0000
#define NULL_KEY                    0x0000




/** EXTERNAL INTERFACE PACKAGE **/
#define NULL_KEY_ERR                0x1001
#define NULL_INPUT_PTR_ERR          0x1002
#define NULL_MEMORY_BASES_ERR       0x1003
#define VOID_FUNC_PTR_BASE_ERR      0x1004
#define OUT_OFF_SEQUENCE_CALL_ERR   0x1005
#define BAD_CLIENT_ID_ERR           0x1006
#define NULL_SFNT_DIR_ERR           0x1007
#define NULL_SFNT_FRAG_PTR_ERR      0x1008
#define NULL_OUTPUT_PTR_ERR         0x1009
#define INVALID_GLYPH_INDEX         0x100A

/* fnt_execute */
#define UNDEFINED_INSTRUCTION_ERR   0x1101
#define TRASHED_MEM_ERR             0x1102


/* fsg_CalculateBBox */
#define POINT_MIGRATION_ERR         0x1201

/* sc_ScanChar */
#define BAD_START_POINT_ERR         0x1301
#define SCAN_ERR                    0x1302



/** SFNT DATA ERROR and errors in sfnt.c **/
#define SFNT_DATA_ERR               0x1400
#define POINTS_DATA_ERR             0x1401
#define INSTRUCTION_SIZE_ERR        0x1402
#define CONTOUR_DATA_ERR            0x1403
#define GLYPH_INDEX_ERR             0x1404
#define BAD_MAGIC_ERR               0x1405
#define OUT_OF_RANGE_SUBTABLE       0x1406
#define UNKNOWN_COMPOSITE_VERSION   0x1407
#define CLIENT_RETURNED_NULL        0x1408
#define MISSING_SFNT_TABLE          0x1409
#define UNKNOWN_CMAP_FORMAT         0x140A

/* spline call errors */
#define BAD_CALL_ERR                0x1500

#define TRASHED_OUTLINE_CACHE       0x1600

/************ For Debugging *************/

#ifdef XXX
#define DEBUG_ON
pascal  Debug ()                     /* User break drop into Macsbug */
#ifdef  DEBUG_ON
extern  0xA9FF;
#else
{
    ;
}
#endif

#ifdef  LEAVEOUT
pascal  void DebugStr (aString) int8 *aString; extern 0xABFF;
int8    *c2pstr ();
#define BugInfo( aString) DebugStr( c2pstr(aString))
#endif

#endif  /* XXX */
/****************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\bass\fsglue.c ===
/*
    File:       FSglue.c

    Contains:   xxx put contents here (or delete the whole line) xxx

    Written by: xxx put name of writer here (or delete the whole line) xxx

    Copyright:  c 1988-1990 by Apple Computer, Inc., all rights reserved.

    Change History (most recent first):

         <7>    11/27/90    MR      Need two scalars: one for (possibly rounded) outlines and cvt,
                                                    and one (always fractional) metrics. [rb]
         <6>    11/16/90    MR      Add SnapShotOutline to make instructions after components work
                                                    [rb]
         <5>     11/9/90    MR      Unrename fsg_ReleaseProgramPtrs to RELEASESFNTFRAG. [rb]
         <4>     11/5/90    MR      Change globalGS.ppemDot6 to globalGS.fpem, change all instrPtr
                                                    and curve flags to uint8. [rb]
         <3>    10/31/90    MR      Add bit-field option for integer or fractional scaling [rb]
         <2>    10/20/90    MR      Change matrix[2][2] back to a fract (in response to change in
                                                    skia). However, ReduceMatrix converts it to a fixed after it has
                                                    been used to "regularize" the matrix. Changed scaling routines
                                                    for outline and CVT to use integer pixelsPerEm. Removed
                                                    scaleFunc from the splineKey. Change some routines that were
                                                    calling FracDiv and FixDiv to use LongMulDiv and ShortMulDiv for
                                                    greater speed and precision. Removed fsg_InitScaling. [rb]
        <20>     8/22/90    MR      Only call fixmul when needed in finalComponentPass loop
        <19>      8/1/90    MR      Add line to set non90DegreeTransformation
        <18>     7/26/90    MR      remove references to metricInfo junk, don't include ToolUtils.h
        <17>     7/18/90    MR      Change error return type to int, split WorkSpace routine into
                                                    two calls, added SWAPW macros
        <16>     7/14/90    MR      Fixed reference to const SQRT2 to FIXEDSQRT2
        <15>     7/13/90    MR      Ansi-C stuff, tried to use correct sizes for variables to avoid
                                    coercion (sp?)
        <12>     6/21/90    MR      Add calls to ReleaseSfntFrag
        <11>      6/4/90    MR      Remove MVT, change matrix to have bottom right element be a
                                    fixed.
        <10>      6/1/90    MR      Thou shalt not pay no more attention to the MVT!
        <8+>     5/29/90    MR      look for problem in Max45Trick
         <8>     5/21/90    RB      bugfix in fsg_InitInterpreterTrans setting key->imageState
         <7>      5/9/90    MR      Fix bug in MoreThanXYStretch
         <6>      5/4/90    RB      support for new scan converter and decryption          mrr - add
                                    fsg_ReverseContours and key->reverseContour         to account
                                    for glyphs that are flipped.         This keeps the
                                    winding-number correct for         the scan converter.  Mike
                                    fixed fsg_Identity
         <5>      5/3/90    RB      support for new scan converter and decryption  mrr - add
                                    fsg_ReverseContours and key->reverseContour to account for
                                    glyphs that are flipped. This keeps the winding-number correct
                                    for the scan converter.
         <4>     4/10/90    CL      Fixed infinite loop counter - changed uint16 to int16 (Mikey).
         <3>     3/20/90    CL      Added HasPerspective for finding fast case
                                    Removed #ifdef SLOW, OLD
                                    Changed NormalizeTransformation to use fpem (16.16) and to use max instead of length
                                    and to loop instead of recurse.
                                    Removed compensation for int ppem in fsg_InitInterpreterTrans (not needed with fpem)
                                    Greased loops in PreTransformGlyph, PostTransformGlyph, LocalPostTransformGlyph,
                                                     ShiftChar, ZeroOutTwilightZone, InitLocalT
                                    Changed GetPreMultipliers to special case unit vector * 2x2 matrix
                                    Added support for ppemDot6 and pointSizeDot6
                                    Changed fsg_MxMul to treat the perspective elements as Fracts
                                    arrays to pointers in ScaleChar
                                    Fixed bugs in loops in posttransformglyph, convert loops to --numPts >= 0
         <2>     2/27/90    CL      It reconfigures itself during runtime !  New lsb and rsb
                                    calculation.  Shift bug in instructed components:  New error
                                    code for missing but needed table. (0x1409)  Optimization which
                                    has to do with shifting and copying ox/x and oy/y.  Fixed new
                                    format bug.  Changed transformed width calculation.  Fixed
                                    device metrics for transformed uninstructed sidebearing
                                    characters.  Dropoutcontrol scanconverter and SCANCTRL[]
                                    instruction.  Fixed transformed component bug.

       <3.3>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
                                    phantom points are in, even for components in a composite glyph.
                                    They should also work for transformations. Device metric are
                                    passed out in the output data structure. This should also work
                                    with transformations. Another leftsidebearing along the advance
                                    width vector is also passed out. whatever the metrics are for
                                    the component at it's level. Instructions are legal in
                                    components. The old perspective bug has been fixed. The
                                    transformation is internally automatically normalized. This
                                    should also solve the overflow problem we had. Changed
                                    sidebearing point calculations to use 16.16 precision. For zero
                                    or negative numbers in my tricky/fast square root computation it
                                    would go instable and loop forever. It was not able to handle
                                    large transformations correctly. This has been fixed and the
                                    normalization may call it self recursively to gain extra
                                    precision! It used to normalize an identity transformation
                                    unecessarily.
       <3.2>     10/6/89    CEL     Phantom points were removed causing a rounding of last 2 points
                                    bug. Characters would become distorted.
       <3.1>     9/27/89    CEL     Fixed transformation anchor point bug.
       <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
       <2.2>     8/14/89    sjk     1 point contours now OK
       <2.1>      8/8/89    sjk     Improved encryption handling
       <2.0>      8/2/89    sjk     Just fixed EASE comment
       <1.5>      8/1/89    sjk     Added composites and encryption. Plus some
                                    enhanclocalpostements.
       <1.4>     6/13/89    SJK     Comment
       <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
                                    bug, correct transformed integralized ppem behavior, pretty much
                                    so
       <1.2>     5/26/89    CEL     EASE messed up on "c" comments
      <y1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
       <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

    To Do:
*/
/* rwb r/24/90 - Add support for scanControlIn and scanControlOut variables in global graphiscs
 * state
 */
/** System Includes **/


// DJC DJC.. added global include
#include "psglobal.h"

// DJC include setjump to resolve
#include <setjmp.h>


/** FontScaler's Includes **/
#include "fserror.h"
#include "fscdefs.h"
#include "fontmath.h"
#include "sfnt.h"
#include "fnt.h"
#include "sc.h"
#include "fsglue.h"
#include "privsfnt.h"

#define   PUBLIC

/*********** macros ************/

#define WORD_ALIGN(n)     n++, n = (OFFSET_INFO_TYPE) (unsigned long) ((unsigned) n & ~1) ;
#define LONG_WORD_ALIGN(n) n += 3, n = (OFFSET_INFO_TYPE) ((unsigned) n & ~3);

#define ALMOSTZERO 33

#define NORMALIZELIMIT  (135L << 16)

#define FIXEDTODOT6(n)  (F26Dot6) (((n) + (1 << 9)) >> 10)
#define FRACT2FIX(n)    (((n) + (1 << (sizeof (Fract) - 3))) >> 14)

#define CLOSETOONE(x)   ((x) >= ONEFIX-ALMOSTZERO && (x) <= ONEFIX+ALMOSTZERO)

#define MAKEABS(x)  if (x < 0) x = -x
#define MAX(a, b)   (((a) > (b)) ? (a) : (b))

#define NUMBEROFPOINTS(elementPtr)  (elementPtr->ep[elementPtr->nc - 1] + 1 + PHANTOMCOUNT)
#define GLOBALGSTATE(key)           (fnt_GlobalGraphicStateType*) FONT_OFFSET (key->memoryBases[PRIVATE_FONT_SPACE_BASE], key->offset_globalGS)

#define LOOPDOWN(n)     for (--n; n >= 0; --n)
#define ULOOPDOWN(n)        while (n--)

#define fsg_MxCopy(a, b)    (*b = *a)

/* d is half of the denumerator */
#define FROUND( x, n, d, s ) \
        ((SHORTMUL (x, n) + (d)) >> s)

#define SROUND( x, n, d, halfd ) \
    (x < 0 ? -((SHORTMUL (-(x), (n)) + (halfd)) / (d)) : ((SHORTMUL ((x), (n)) + (halfd)) / (d)))

#define sfnt_Length(key,Table)  key->offsetTableMap[Table].Length



#ifdef SEGMENT_LINK
#pragma segment FSGLUE_C
#endif

/**********************************************************************************/

#ifdef IN_ASM
void  FastScaleChar (fnt_ScaleRecord *sc, F26Dot6 *oop, F26Dot6 *p, int numPts);
#endif

void FAR fsg_PostTransformGlyph (fsg_SplineKey *key, transMatrix *trans);
void FAR fsg_LocalPostTransformGlyph (fsg_SplineKey *key, transMatrix *trans);

//DJC moved to beg of file
voidPtr sfnt_GetTablePtr (fsg_SplineKey *, sfnt_tableIndex, boolean); /*add prototype: @WIN*/

/* PRIVATE PROTOTYPES <4> */

       void fsg_CopyElementBackwards (fnt_ElementType *elementPtr);
PUBLIC void fsg_GetMatrixStretch (fsg_SplineKey*key, transMatrix*trans);
PUBLIC int  fsg_Identity (transMatrix *matrix);

PUBLIC void  fsg_Scale (fnt_ScaleRecord *sr, GlobalGSScaleFunc ScaleFunc, F26Dot6 *oop, F26Dot6 *p, int numPts);
PUBLIC int fsg_GetShift (unsigned n);
/* PUBLIC void fsg_ScaleCVT (fsg_SplineKey *key, int numCVT, F26Dot6 *cvt, sfnt_ControlValuePtr srcCVT); @INTEL960 D.S. Tseng 10/03/91 */
PUBLIC void fsg_ScaleCVT (fsg_SplineKey *key, LoopCount numCVT, F26Dot6 *cvt, sfnt_ControlValuePtr srcCVT);
PUBLIC void fsg_ShiftChar (fsg_SplineKey *key, F26Dot6 xShift, F26Dot6 yShift, int lastPoint);
PUBLIC void fsg_ScaleChar (fnt_ElementType *elementPtr, fnt_GlobalGraphicStateType *globalGS, LoopCount numPts);
PUBLIC void fsg_ZeroOutTwilightZone (fsg_SplineKey *key);
PUBLIC void fsg_SetUpTablePtrs (fsg_SplineKey*key, int16 pgmIndex);
PUBLIC unsigned fsg_SetOffestPtr (fsg_OffsetInfo *offsetPtr, OFFSET_INFO_TYPE workSpacePos, unsigned maxPoints, unsigned maxContours);
PUBLIC int fsg_Max45Trick (Fixed x, Fixed y);

PUBLIC F26Dot6 fsg_FRound (register fnt_ScaleRecord* rec, register F26Dot6 value);
PUBLIC F26Dot6 fsg_SRound (register fnt_ScaleRecord* rec, register F26Dot6 value);
PUBLIC F26Dot6 fsg_FixRound (register fnt_ScaleRecord* rec, F26Dot6 value);

PUBLIC boolean fsg_Non90Degrees (transMatrix *matrix);
PUBLIC int fsg_CountLowZeros (uint32 n );
PUBLIC Fixed fsg_max_abs (Fixed a, Fixed b);
PUBLIC GlobalGSScaleFunc fsg_ComputeScaling(fnt_ScaleRecord* rec, Fixed N, Fixed D);


//DJC moved from inside of function defs

// DJC moved to privsnft.h
// DJC void sfnt_ReadSFNTMetrics (fsg_SplineKey*, uint16); /*add prototype; @WIN*/
// DJC int sfnt_ReadSFNT (fsg_SplineKey *, unsigned *, uint16, boolean, voidFunc);/*add prototype; @WIN*/

/*
 * fsg_PrivateFontSpaceSize : This data should remain intact for the life of the sfnt
 *              because function and instruction defs may be defined in the font program
 *              and/or the preprogram.
 */
unsigned        fsg_PrivateFontSpaceSize (register fsg_SplineKey *key)
{
#ifdef DEBUG
  key->cvtCount = sfnt_Length (key, sfnt_controlValue) / sizeof (sfnt_ControlValue);
#endif

  key->offset_storage       = 0;
  key->offset_functions     = key->offset_storage       + sizeof (F26Dot6) * key->maxProfile.maxStorage;
  key->offset_instrDefs     = key->offset_functions     + sizeof (fnt_funcDef) * key->maxProfile.maxFunctionDefs;
  key->offset_controlValues = key->offset_instrDefs     + sizeof (fnt_instrDef) * key->maxProfile.maxInstructionDefs;   /* <4> */
  key->offset_globalGS      = key->offset_controlValues + sizeof (F26Dot6) * (sfnt_Length (key, sfnt_controlValue) / sizeof (sfnt_ControlValue));
  key->offset_FontProgram   = key->offset_globalGS      + sizeof (fnt_GlobalGraphicStateType);
  key->offset_PreProgram    = key->offset_FontProgram   + sfnt_Length (key, sfnt_fontProgram);

  return ((unsigned) ((key->offset_PreProgram + sfnt_Length (key,
                     sfnt_preProgram)) - key->offset_storage));         //@WIN
}


/*
 * fsg_WorkSpaceSetOffsets : This stuff changes with each glyph
 *
 * Computes the workspace size and sets the offsets into it.
 *
 */
unsigned        fsg_WorkSpaceSetOffsets (fsg_SplineKey *key)
{
  unsigned             workSpacePos;
  sfnt_maxProfileTable *maxProfilePtr = &key->maxProfile;

  key->elementInfoRec.stackBaseOffset = 0;
  workSpacePos = maxProfilePtr->maxStackElements * sizeof (F26Dot6);

/*** ELEMENT 0 ***/
  workSpacePos = fsg_SetOffestPtr (&(key->elementInfoRec.offsets[TWILIGHTZONE]), (OFFSET_INFO_TYPE) workSpacePos, maxProfilePtr->maxTwilightPoints, MAX_TWILIGHT_CONTOURS);

/*** ELEMENT 1 *****/
  return (fsg_SetOffestPtr (&(key->elementInfoRec.offsets[GLYPHELEMENT]), (OFFSET_INFO_TYPE) workSpacePos, PHANTOMCOUNT + MAX (maxProfilePtr->maxPoints, maxProfilePtr->maxCompositePoints),
    MAX (maxProfilePtr->maxContours, maxProfilePtr->maxCompositeContours)));
}

PUBLIC unsigned fsg_SetOffestPtr (fsg_OffsetInfo *offsetPtr, OFFSET_INFO_TYPE workSpacePos, unsigned maxPoints, unsigned maxContours)
{
  register unsigned       ArraySize;

  offsetPtr->f = workSpacePos;

  workSpacePos    += maxPoints * sizeof (int8);
  LONG_WORD_ALIGN (workSpacePos);

  offsetPtr->sp = workSpacePos;
  workSpacePos += (ArraySize = maxContours * sizeof (int16));
  offsetPtr->ep = workSpacePos;
  workSpacePos += ArraySize;

  offsetPtr->oox  = workSpacePos;
  workSpacePos    += (ArraySize = maxPoints * sizeof (F26Dot6));
  offsetPtr->ooy  = workSpacePos;
  workSpacePos    += ArraySize;
  offsetPtr->ox   = workSpacePos;
  workSpacePos    += ArraySize;
  offsetPtr->oy   = workSpacePos;
  workSpacePos    += ArraySize;
  offsetPtr->x    = workSpacePos;
  workSpacePos    += ArraySize;
  offsetPtr->y    = workSpacePos;
  workSpacePos    += ArraySize;

  offsetPtr->onCurve = workSpacePos;
  workSpacePos    += maxPoints * sizeof (int8);
  WORD_ALIGN (workSpacePos);

  return (unsigned) workSpacePos;
}

/*
 *  fsg_CopyElementBackwards
 */

#ifndef IN_ASM
PUBLIC void fsg_CopyElementBackwards (fnt_ElementType *elementPtr)
{
  register F26Dot6        *srcZero, *destZero;
  register F26Dot6        *srcOne, *destOne;
  register uint8          *flagPtr;
  register LoopCount      i;
  register int8           zero = 0;

  srcZero     = elementPtr->x;
  srcOne      = elementPtr->y;
  destZero    = elementPtr->ox;
  destOne     = elementPtr->oy;
  flagPtr     = elementPtr->f;

/* Update the point arrays. */
  i = NUMBEROFPOINTS (elementPtr);
  LOOPDOWN (i)
  {
    *destZero++    = *srcZero++;
    *destOne++     = *srcOne++;
    *flagPtr++     = zero;
  }
}
#endif


#ifndef PC_OS
/*
 *  Good for transforming fixed point values.  Assumes NO translate  <4>
 */
void fsg_FixXYMul (Fixed*x, Fixed*y, transMatrix*matrix)
{
  register Fixed xTemp, yTemp;
  register Fixed *m0, *m1;

  m0 = (Fixed *) & matrix->transform[0][0];
  m1 = (Fixed *) & matrix->transform[1][0];

  xTemp = *x;
  yTemp = *y;
  *x = FixMul (*m0++, xTemp) + FixMul (*m1++, yTemp);
  *y = FixMul (*m0++, xTemp) + FixMul (*m1++, yTemp);

#ifndef PC_OS   /* Never a perspecitive with Windows */

  if (*m0 || *m1)     /* these two are Fracts */
  {
    Fixed tmp = FracMul (*m0, xTemp) + FracMul (*m1, yTemp);
    tmp += matrix->transform[2][2];
    if (tmp && tmp != ONEFIX)
    {
      *x = FixDiv (*x, tmp);
      *y = FixDiv (*y, tmp);
    }
  }
#endif
}


/*
 *  This could be faster        <4>
 */
void fsg_FixVectorMul (vectorType*v, transMatrix*matrix)
{
  fsg_FixXYMul (&v->x, &v->y, matrix);
}

#endif

/*
 *   B = A * B;     <4>
 *
 *         | a  b  0  |
 *    B =  | c  d  0  | * B;
 *         | 0  0  1  |
 */
void fsg_MxConcat2x2 (register transMatrix*A, register transMatrix*B)
{
  Fixed storage[6];
  Fixed * s = storage;
  int   i, j;

  for (j = 0; j < 2; j++)
    for (i = 0; i < 3; i++)
      *s++ = FixMul (A->transform[j][0], B->transform[0][i]) + FixMul (A->transform[j][1], B->transform[1][i]);

  {
    register Fixed*dst = &B->transform[2][0];
    register Fixed*src = s;
    register int16 i;
    for (i = 5; i >= 0; --i)
      *--dst = *--src;
  }
}


/*
 * scales a matrix by sx and sy.
 *
 *
 *              | sx 0  0  |
 *    matrix =  | 0  sy 0  | * matrix;
 *              | 0  0  1  |
 *
 */
void fsg_MxScaleAB (Fixed sx, Fixed sy, transMatrix *matrixB)
{
  register        i;
  register Fixed  *m = (Fixed *) & matrixB->transform[0][0];

  for (i = 0; i < 3; i++, m++)
    *m = FixMul (sx, *m);

  for (i = 0; i < 3; i++, m++)
    *m = FixMul (sy, *m);
}


/*
 *  Return 45 degreeness
 */
#ifndef PC_OS
PUBLIC int fsg_Max45Trick (register Fixed x, register Fixed y)
{
  MAKEABS (x);
  MAKEABS (y);

  if (x < y)      /* make sure x > y */
  {
    Fixed z = x;
    x = y;
    y = z;
  }

  return  (x - y <= ALMOSTZERO);
}
#else
  #define fsg_Max45Trick(x,y)     (x == y || x == -y)
#endif


/*
 *  Sets key->phaseShift to true if X or Y are at 45 degrees, flaging the outline
 *  to be moved in the low bit just before scan-conversion.
 *  Sets [xy]Stretch factors to be applied before hinting.
 *  Returns true if the contours need to be reversed.
 */
PUBLIC void fsg_GetMatrixStretch (fsg_SplineKey*key, transMatrix*trans)
{
  Fixed*matrix = &trans->transform[0][0];
  Fixed x, y;
  register i;

//for (key->phaseShift = i = 0; i < 2; i++, matrix++)   @WIN
  for (key->phaseShift = (int8)0, i = 0; i < 2; i++, matrix++)
  {
    x = *matrix++;
    y = *matrix++;
    key->phaseShift |= (int8) fsg_Max45Trick (x, y);
  }
}


/*
 * Returns true if we have the identity matrix.
 */
PUBLIC fsg_Identity (register transMatrix *matrix)
{
  return (matrix->transform[0][0] == matrix->transform[1][1] && matrix->transform[0][1] == 0 && matrix->transform[1][0] == 0 && matrix->transform[1][1] >= 0);
}


PUBLIC boolean fsg_Non90Degrees (register transMatrix *matrix)
{
  return ((matrix->transform[0][0] || matrix->transform[1][1]) && (matrix->transform[1][0] || matrix->transform[0][1]));
}


/******************** These three scale 26.6 to 26.6 ********************/
/*
 * Fast (scaling)
 */
PUBLIC F26Dot6 fsg_FRound(register fnt_ScaleRecord* rec, register F26Dot6 value)
{
  return (F26Dot6) FROUND (value, rec->numer, rec->denom >> 1, rec->shift);
}

/*
 * Medium (scaling)
 */
PUBLIC F26Dot6 fsg_SRound(register fnt_ScaleRecord* rec, register F26Dot6 value)
{
  int D = rec->denom;

  return (F26Dot6) SROUND (value, rec->numer, D, D >> 1);
}

/*
 * Fixed Rounding (scaling), really slow
 */
PUBLIC F26Dot6 fsg_FixRound(register fnt_ScaleRecord* rec, F26Dot6 value)
{
  return (F26Dot6) FixMul ((Fixed)value, rec->fixedScale);
}

/********************************* End scaling utilities ************************/

/*
 * fsg_GetShift
 * return 2log of n if the log is an integer otherwise -1;
 */
/*
 *      counts number of low bits that are zero
 *      -- or --
 *      returns bit number of first ON bit
 */
PUBLIC int fsg_CountLowZeros( register uint32 n )
{
        int shift = 0;
        unsigned one = 1;
        for (shift = 0; !( n & one ); shift++)
                n >>= 1;
        return shift;
}

#define ISNOTPOWEROF2(n)        ((n) & ((n)-1))
#define FITSINAWORD(n)  ((n) < 32768)

/*
 * fsg_GetShift
 * return 2log of n if n is a power of 2 otherwise -1;
 */
PUBLIC int fsg_GetShift( register unsigned n )
{
        if (ISNOTPOWEROF2(n) || !n)
                return -1;
        else
                return fsg_CountLowZeros( n );
}

PUBLIC Fixed fsg_max_abs (Fixed a, Fixed b)
{
  if (a < 0)
    a = -a;
  if (b < 0)
    b = -b;
  return (a > b ? a : b);
}

PUBLIC GlobalGSScaleFunc fsg_ComputeScaling(fnt_ScaleRecord* rec, Fixed N, Fixed D)
{
#define CANTAKESHIFT    0x02000000

  {   int shift = fsg_CountLowZeros( N | D ) - 1;
      if (shift > 0) {
          N >>= shift;
          D >>= shift;
      }
  }

  if ( N < CANTAKESHIFT )
      N <<= fnt_pixelShift;
  else
      D >>= fnt_pixelShift;

  if (FITSINAWORD(N)) {
      register int shift = fsg_GetShift ((unsigned) D);
      rec->numer = (int)N;
      rec->denom = (int)D;

      if ( shift >= 0 ) {                 /* FAST SCALE */
          rec->shift = shift;
          return ((GlobalGSScaleFunc)(fsg_FRound));
      }
      else                                /* MEDIUM SCALE */
          return (GlobalGSScaleFunc)(fsg_SRound);
  }
  else {                                  /* SLOW SCALE */
      rec->fixedScale = FixDiv(N, D);
      return (GlobalGSScaleFunc)(fsg_FixRound);
  }
}
/*
 * fsg_InitInterpreterTrans             <3>
 *
 * Computes [xy]TransMultiplier in global graphic state from matrix
 * It leaves the actual matrix alone
 * It then sets these key flags appropriately
 *      identityTransformation      true == no need to run points through matrix
 *      imageState                  pixelsPerEm
 *      imageState                  Rotate flag if glyph is rotated
 *      imageState                  Stretch flag if glyph is stretched
 *  And these global GS flags
 *      identityTransformation      true == no need to stretch in GetCVT, etc.
 */
#define STRETCH 2

void fsg_InitInterpreterTrans (register fsg_SplineKey *key, Fixed *pinterpScalarX, Fixed *pinterpScalarY, Fixed *pmetricScalarX, Fixed *pmetricScalarY)
{
  register fnt_GlobalGraphicStateType *globalGS = GLOBALGSTATE(key);
  transMatrix  *trans    = &key->currentTMatrix;
  int          pixelsPerEm;
  Fixed        interpScalarX,interpScalarY;  /* scalar for instructable things */
  Fixed        metricScalarX,metricScalarY;  /* scalar for metric things */
  Fixed        maxScale;
  Fixed        fixedUpem = (Fixed)key->emResolution << 16;

/*
 *  First set up the scalars...
 */
    {
      interpScalarX = metricScalarX = fsg_max_abs (trans->transform[0][0], trans->transform[0][1]);
      interpScalarY = metricScalarY = fsg_max_abs (trans->transform[1][0], trans->transform[1][1]);
      if (key->fontFlags & USE_INTEGER_SCALING)
      {
        interpScalarX = (interpScalarX + 0x8000) & 0xffff0000;
        interpScalarY = (interpScalarY + 0x8000) & 0xffff0000;
      }
      *pinterpScalarX = interpScalarX;
      *pinterpScalarY = interpScalarY;
      *pmetricScalarX = metricScalarX;
      *pmetricScalarY = metricScalarY;

      globalGS->ScaleFuncX = fsg_ComputeScaling(&globalGS->scaleX, interpScalarX, fixedUpem);
      globalGS->ScaleFuncY = fsg_ComputeScaling(&globalGS->scaleY, interpScalarY, fixedUpem);

      if (interpScalarX >= interpScalarY)
      {
          globalGS->ScaleFuncCVT = globalGS->ScaleFuncX;
          globalGS->scaleCVT = globalGS->scaleX;
          globalGS->cvtStretchX = ONEFIX;
          globalGS->cvtStretchY = FixDiv(interpScalarY, maxScale = interpScalarX);;
      }
      else
      {
          globalGS->ScaleFuncCVT = globalGS->ScaleFuncY;
          globalGS->scaleCVT = globalGS->scaleY;
          globalGS->cvtStretchX = FixDiv(interpScalarX, maxScale = interpScalarY);
          globalGS->cvtStretchY = ONEFIX;
      }
    }

  key->phaseShift = false;
  pixelsPerEm = FIXROUND (interpScalarY);
  key->imageState = pixelsPerEm > 0xFF ? 0xFF : pixelsPerEm;

  if ( !(globalGS->squareScale = key->identityTransformation = (int16)fsg_Identity( trans )) )
  {
    fsg_GetMatrixStretch( key, trans); /*<8>*/
    if( fsg_Non90Degrees( trans ) )
        key->imageState |= ROTATED;

/* change by Falco for fix the error in mirror, 01/20/91 */
/*  if ((trans->transform[0][0] | trans->transform[1][1]) == 0) */
    if (!(trans->transform[0][0]>0 && trans->transform[1][1]>0 &&
          trans->transform[0][1]==0 && trans->transform[1][0]==0))
/* change end */
      key->imageState |= DEGREE90;

    key->imageState |= STRETCHED;
  }

  globalGS->pixelsPerEm   = FIXROUND(maxScale);
  globalGS->pointSize     = FIXROUND( key->fixedPointSize );
  globalGS->identityTransformation = (int8) key->identityTransformation;
  globalGS->non90DegreeTransformation = (int8) fsg_Non90Degrees( trans );
    /* Use bit 1 of non90degreeTransformation to signify stretching.  stretch = 2 */
  if( trans->transform[0][0] == trans->transform[1][1] || trans->transform[0][0] == -trans->transform[1][1] )
    globalGS->non90DegreeTransformation &= ~STRETCH;
  else
    globalGS->non90DegreeTransformation |= STRETCH;
}


/*
 *  fsg_ShiftChar
 *
 *  Shifts a character          <3>
 */
PUBLIC void fsg_ShiftChar (fsg_SplineKey *key, F26Dot6 xShift, F26Dot6 yShift, int lastPoint)
{
  fnt_ElementType * elementPtr = & (key->elementInfoRec.interpreterElements[key->elementNumber]);

  if (xShift)
  {
    register F26Dot6*x = elementPtr->x;
    register F26Dot6*lastx = x + lastPoint;

    while (x <= lastx)
      *x++ += xShift;
  }
  if (yShift)
  {
    register F26Dot6*y = elementPtr->y;
    register F26Dot6*lasty = y + lastPoint;

    while (y <= lasty)
      *y++ += yShift;
  }
}

PUBLIC void  fsg_Scale (fnt_ScaleRecord *sr, GlobalGSScaleFunc ScaleFunc, F26Dot6 *oop, F26Dot6 *p, int numPts)
{
  register LoopCount  count = numPts;

  if (ScaleFunc == fsg_FRound)
  {
#ifndef IN_ASM
    register int    shift = sr->shift;
    register int    N = sr->numer;
    register int    D = sr->denom >> 1;

    LOOPDOWN (count)
      *p++ = (F26Dot6) FROUND (*oop++, N, D, shift);
#else
    FastScaleChar (sr, oop, p, numPts);
#endif
  }
  else
    if (ScaleFunc == fsg_SRound)
    {
      register int   N = sr->numer;
      register int   D = sr->denom;
      register int   dOver2 = D >> 1;

      LOOPDOWN (count)
      {
        *p++ = (F26Dot6) SROUND (*oop, N, D, dOver2);
        oop++;
      }
    }
    else
    {
      register Fixed N = sr->fixedScale;
      LOOPDOWN (count)
        *p++ = (F26Dot6) FixMul (*oop++, N);
    }
}

/*
 * fsg_ScaleCVT
 */

PUBLIC void fsg_ScaleCVT( register fsg_SplineKey *key, LoopCount numCVT, register F26Dot6 *cvt, register sfnt_ControlValuePtr srcCVT )
{
  register fnt_GlobalGraphicStateType *globalGS = GLOBALGSTATE(key);
  register F26Dot6  *cvt2;

  for (cvt2 = cvt; cvt2  < cvt + numCVT; srcCVT++)
    *cvt2++ = (F26Dot6)(int16) SWAPW(*srcCVT);
  fsg_Scale (&globalGS->scaleCVT, globalGS->ScaleFuncCVT, cvt, cvt, (int)numCVT); /*@WIN*/
}


/*
 *  fsg_ScaleChar                       <3>
 *
 *  Scales a character and the advancewidth + leftsidebearing.
 */

PUBLIC void fsg_ScaleChar (fnt_ElementType *elementPtr, fnt_GlobalGraphicStateType *globalGS, LoopCount numPts)
{
  fsg_Scale (&globalGS->scaleX, globalGS->ScaleFuncX, elementPtr->oox, elementPtr->x, (int)numPts);/*@WIN*/
  fsg_Scale (&globalGS->scaleY, globalGS->ScaleFuncY, elementPtr->ooy, elementPtr->y, (int)numPts);/*@WIN*/
}


/*
 *  fsg_SetUpElement
 */
void fsg_SetUpElement (fsg_SplineKey *key, int n)
{
  register int8               *workSpacePtr   = key->memoryBases[WORK_SPACE_BASE];
  register fnt_ElementType    *elementPtr;
  register fsg_OffsetInfo     *offsetPtr;


  offsetPtr           = & (key->elementInfoRec.offsets[n]);
  elementPtr          = & (key->elementInfoRec.interpreterElements[n]);

#ifdef PC_OS
  *(fsg_OffsetInfo *) elementPtr = *offsetPtr;
#else
  elementPtr->x       = (F26Dot6 *) (workSpacePtr + offsetPtr->x);
  elementPtr->y       = (F26Dot6 *) (workSpacePtr + offsetPtr->y);
  elementPtr->ox      = (F26Dot6 *) (workSpacePtr + offsetPtr->ox);
  elementPtr->oy      = (F26Dot6 *) (workSpacePtr + offsetPtr->oy);
  elementPtr->oox     = (F26Dot6 *) (workSpacePtr + offsetPtr->oox);
  elementPtr->ooy     = (F26Dot6 *) (workSpacePtr + offsetPtr->ooy);
  elementPtr->sp      = (int16 *) (workSpacePtr + offsetPtr->sp);
  elementPtr->ep      = (int16 *) (workSpacePtr + offsetPtr->ep);
  elementPtr->onCurve = (uint8 *) (workSpacePtr + offsetPtr->onCurve);
  elementPtr->f       = (uint8 *) (workSpacePtr + offsetPtr->f);
#endif
  if (n == TWILIGHTZONE)
  {
/* register int i, j; */
    elementPtr->sp[0]   = 0;
    elementPtr->ep[0]   = key->maxProfile.maxTwilightPoints - 1;
    elementPtr->nc      = MAX_TWILIGHT_CONTOURS;
  }
}


/*
 *  fsg_IncrementElement
 */
void fsg_IncrementElement (fsg_SplineKey *key, int n, register int numPoints, register int numContours)
{
  fnt_ElementType    *elementPtr = & (key->elementInfoRec.interpreterElements[n]);

  elementPtr->x       += numPoints;
  elementPtr->y       += numPoints;
  elementPtr->ox      += numPoints;
  elementPtr->oy      += numPoints;
  elementPtr->oox     += numPoints;
  elementPtr->ooy     += numPoints;
  elementPtr->sp      += numContours;
  elementPtr->ep      += numContours;
  elementPtr->onCurve += numPoints;
  elementPtr->f       += numPoints;
}


/*
 * fsg_ZeroOutTwilightZone          <3>
 */
PUBLIC void fsg_ZeroOutTwilightZone (fsg_SplineKey *key)
{
  register int origCount = key->maxProfile.maxTwilightPoints;
  fnt_ElementType *  elementPtr = & (key->elementInfoRec.interpreterElements[TWILIGHTZONE]);

#ifndef NOT_ON_THE_MAC

  register F26Dot6 zero = 0;

  {
    register F26Dot6*x = elementPtr->x;
    register F26Dot6*y = elementPtr->y;
    register int count = origCount;
    LOOPDOWN (count)
    {
      *x++ = zero;
      *y++ = zero;
    }
  }
  {
    register F26Dot6*ox = elementPtr->ox;
    register F26Dot6*oy = elementPtr->oy;
    LOOPDOWN (origCount)
    {
      *ox++ = zero;
      *oy++ = zero;
    }
  }

#else

  MEMSET (elementPtr->x,  0, origCount);
  MEMSET (elementPtr->y,  0, origCount);
  MEMSET (elementPtr->ox, 0, origCount);
  MEMSET (elementPtr->oy, 0, origCount);

#endif
}


/*
 *  Assign pgmList[] for each pre program
 */
void fsg_SetUpProgramPtrs (fsg_SplineKey*key, fnt_GlobalGraphicStateType*globalGS, int pgmIndex)
{
  unsigned      length;
  fnt_pgmList   *ppgmList = &globalGS->pgmList[pgmIndex];
  voidPtr       pFragment;
  ArrayIndex    pgmIndex2 = pgmIndex == PREPROGRAM ? sfnt_preProgram : sfnt_fontProgram;

#ifndef PASCAL
#ifdef W32
#define PASCAL
#define pascal
#else
#define PASCAL              pascal                                  /*@WIN*/
#endif
#endif
typedef char far            *LPSTR;                                 /*@WIN*/
LPSTR       FAR PASCAL lmemcpy( LPSTR dest, LPSTR src, int count);  /*@WIN*/

  ppgmList->Instruction = 0;
  ppgmList->Length = 0;

  length = sfnt_Length (key, pgmIndex2);
  if (length)
  {
    pFragment = GETSFNTFRAG (key, key->clientID, key->offsetTableMap[pgmIndex2].Offset, length);
    if (!pFragment)
      fs_longjmp (key->env, CLIENT_RETURNED_NULL);

    ppgmList->Instruction = (uint8 *) FONT_OFFSET (key->memoryBases[PRIVATE_FONT_SPACE_BASE], (pgmIndex == PREPROGRAM ? key->offset_PreProgram : key->offset_FontProgram));
    ppgmList->Length = length;
//  MEMCPY ((char FAR *) ppgmList->Instruction, pFragment, length); @WIN
    lmemcpy ((char FAR *) ppgmList->Instruction, pFragment, length);
    RELEASESFNTFRAG(key, pFragment);
  }

#ifdef DEBUG
  globalGS->maxp = &key->maxProfile;
  globalGS->cvtCount = key->cvtCount;
#endif
}


PUBLIC void fsg_SetUpTablePtrs (fsg_SplineKey*key, int16 pgmIndex)
{
  char * private_FontSpacePtr = key->memoryBases[PRIVATE_FONT_SPACE_BASE];
  fnt_GlobalGraphicStateType * globalGS = GLOBALGSTATE (key);

  switch (pgmIndex)
  {
  case PREPROGRAM:
    globalGS->controlValueTable = (F26Dot6 *) FONT_OFFSET (private_FontSpacePtr, key->offset_controlValues);
  case FONTPROGRAM:
    globalGS->store             = (F26Dot6 *) FONT_OFFSET (private_FontSpacePtr, key->offset_storage);
    globalGS->funcDef           = (fnt_funcDef *) FONT_OFFSET (private_FontSpacePtr, key->offset_functions);
    globalGS->instrDef          = (fnt_instrDef *) FONT_OFFSET (private_FontSpacePtr, key->offset_instrDefs);
    globalGS->stackBase         = (F26Dot6 *) (key->memoryBases[WORK_SPACE_BASE] + key->elementInfoRec.stackBaseOffset);
  }
}


/*
 * fsg_RunPreProgram
 *
 * Runs the pre-program and scales the control value table
 *
 */
int fsg_RunPreProgram (register fsg_SplineKey *key, voidFunc traceFunc)
{
  int   result;
  F26Dot6 * cvt = (F26Dot6 *) FONT_OFFSET (key->memoryBases[PRIVATE_FONT_SPACE_BASE], key->offset_controlValues);
  // DJC moved to beg
  // DJC voidPtr sfnt_GetTablePtr (fsg_SplineKey *, sfnt_tableIndex, boolean); /*add prototype: @WIN*/

  fnt_GlobalGraphicStateType * globalGS = GLOBALGSTATE (key);
  fnt_pgmList                *ppgmList = &globalGS->pgmList[PREPROGRAM];
  int numCvt;
  sfnt_ControlValuePtr cvtSrc = (sfnt_ControlValuePtr) sfnt_GetTablePtr (key, sfnt_controlValue, false);

  numCvt = sfnt_Length (key, sfnt_controlValue) / sizeof (sfnt_ControlValue);

/* Set up the engine compensation array for the interpreter */
/* This will be indexed into by the booleans in some instructions */
  globalGS->engine[0] = globalGS->engine[3] = 0;                          /* Grey and ? distance */
  globalGS->engine[1] = FIXEDTODOT6 (FIXEDSQRT2 - key->pixelDiameter);     /* Black distance */
  globalGS->engine[2] = -globalGS->engine[1];                             /* White distance */

  globalGS->init          = true;
  globalGS->localParBlock = globalGS->defaultParBlock;    /* copy gState parameters */

  fsg_ScaleCVT (key, numCvt, cvt, cvtSrc);

  RELEASESFNTFRAG(key, cvtSrc);

/** TWILIGHT ZONE ELEMENT **/
  fsg_SetUpElement (key, TWILIGHTZONE);
  fsg_ZeroOutTwilightZone (key);

  if (ppgmList->Instruction)
  {
    globalGS->pgmIndex = PREPROGRAM;
    fsg_SetUpTablePtrs (key, (int16)PREPROGRAM);
    result = fnt_Execute (key->elementInfoRec.interpreterElements, ppgmList->Instruction, ppgmList->Instruction + ppgmList->Length, globalGS, traceFunc);
  }

  if (! (globalGS->localParBlock.instructControl & DEFAULTFLAG))
    globalGS->defaultParBlock = globalGS->localParBlock;    /* change default parameters */

  return result;
}


/*
 *  All this guy does is record FDEFs and IDEFs, anything else is ILLEGAL
 */
int     fsg_RunFontProgram (fsg_SplineKey*key)
{
  fnt_GlobalGraphicStateType * globalGS = GLOBALGSTATE (key);
  fnt_pgmList                *ppgmList = &globalGS->pgmList[FONTPROGRAM];

  globalGS->instrDefCount = 0;        /* none allocated yet, always do this, even if there's no fontProgram */

  if (ppgmList->Instruction)
  {
    globalGS->pgmIndex = FONTPROGRAM;
    fsg_SetUpTablePtrs (key, (int16)FONTPROGRAM);

    return fnt_Execute (key->elementInfoRec.interpreterElements, ppgmList->Instruction, ppgmList->Instruction + ppgmList->Length, globalGS, 0);
  }
  return NO_ERR;
}


/*
 *      fsg_InnerGridFit
 */
int     fsg_InnerGridFit (register fsg_SplineKey *key, boolean useHints, voidFunc traceFunc,
BBOX *bbox, unsigned sizeOfInstructions, uint8 *instructionPtr, boolean finalCompositePass)
{
  fnt_GlobalGraphicStateType * globalGS = GLOBALGSTATE (key);

  register fnt_ElementType      *elementPtr;
  F26Dot6                     xMinMinusLSB;
/* this is so we can allow recursion */
  fnt_ElementType elementSave, elementCur;
  unsigned numPts, PtsRightSideBearing, PtsLeftSideBearing;

  elementPtr = & (key->elementInfoRec.interpreterElements[GLYPHELEMENT]);
/* save stuff we are going to muck up below, so we can recurse */
  if (finalCompositePass)
  {
    elementSave = *elementPtr;
    elementPtr->nc = key->totalContours;
    fsg_SetUpElement (key, GLYPHELEMENT); /* Set it up again so we can process as one glyph */
  }
  elementCur = *elementPtr;

  key->elementNumber = GLYPHELEMENT;
  numPts = (unsigned) NUMBEROFPOINTS (elementPtr);

/* zero'd the y direction */
//MEMSET (&elementCur.ooy [numPts-PHANTOMCOUNT], '\0', PHANTOMCOUNT * sizeof (elementCur.ooy [0])); @WIN
  MEMSET ((LPSTR)&elementCur.ooy [numPts-PHANTOMCOUNT], '\0',
          PHANTOMCOUNT * sizeof (elementCur.ooy [0]));

  PtsRightSideBearing = numPts - PHANTOMCOUNT + RIGHTSIDEBEARING;
  PtsLeftSideBearing = numPts - PHANTOMCOUNT + LEFTSIDEBEARING;

  xMinMinusLSB = bbox->xMin - key->nonScaledLSB;
  {

    F26Dot6 *poo = &elementCur.oox [numPts - PHANTOMCOUNT];

    *poo++ = xMinMinusLSB;                    /* left side bearing point */
    *poo++ = xMinMinusLSB + key->nonScaledAW; /* right side bearing point */
    *poo++ = xMinMinusLSB;                    /* origin left side bearing */
    *poo++ = bbox->xMin;                      /* left edge point */
  }

/* Pretransform, scale, and copy */
  if (finalCompositePass)
  {
    register  startPoint = numPts - PHANTOMCOUNT;

    fsg_Scale (&globalGS->scaleX, globalGS->ScaleFuncX, &elementCur.oox[startPoint], &elementCur.x[startPoint], PHANTOMCOUNT);
    fsg_Scale (&globalGS->scaleY, globalGS->ScaleFuncY, &elementCur.ooy[startPoint], &elementCur.y[startPoint], PHANTOMCOUNT);
  }
  else
    fsg_ScaleChar (elementPtr, globalGS, numPts);

  if (useHints )
  {
      /* AutoRound */
    F26Dot6 oldLeftOrigin, newLeftOrigin;

    newLeftOrigin = oldLeftOrigin = elementPtr->x[PtsLeftSideBearing];
    newLeftOrigin += fnt_pixelSize/2; /* round to a pixel boundary */
    newLeftOrigin &= ~(fnt_pixelSize-1);

       /* We can't shift if it is the final composite pass */
    if (!finalCompositePass)
      fsg_ShiftChar (key, newLeftOrigin - oldLeftOrigin, 0, numPts - 1);

      /* Now the distance from the left origin point to the character is exactly lsb */
    fsg_CopyElementBackwards( elementPtr );

      /* Fill in after fsg_ShiftChar(), since this point should not be shifted. */
    elementPtr->x[PtsLeftSideBearing]  = newLeftOrigin;
    elementPtr->ox[PtsLeftSideBearing] = newLeftOrigin;
    {
          /* autoround the right side bearing */
        F26Dot6 width = FIXEDTODOT6 (ShortMulDiv( key->interpScalarX,
                        (short)(elementPtr->oox[PtsRightSideBearing] - elementPtr->oox[PtsLeftSideBearing]),
                        key->emResolution ));
        elementPtr->x[PtsRightSideBearing] =
        elementPtr->x[PtsLeftSideBearing] + (width + (1 << 5)) & ~((F26Dot6)63);
    }
  }

  globalGS->init          = false;
  globalGS->localParBlock = globalGS->defaultParBlock;    /* default parameters for glyphs */

  if (useHints && sizeOfInstructions > 0)
  {
    int result;

    if ( finalCompositePass )
    {
      /* fsg_SnapShotOutline( key, elementPtr, numPts ); */
      elementPtr->oox = elementPtr->ox;
      elementPtr->ooy = elementPtr->oy;
    }

    if (result = fnt_Execute (key->elementInfoRec.interpreterElements, instructionPtr,  instructionPtr + sizeOfInstructions,
        globalGS, traceFunc))
      return result;
  }
/* Now make everything into one big glyph. */
  if (key->weGotComponents  && !finalCompositePass)
  {
    int n, ctr;
    F26Dot6 xOffset, yOffset;

/* Fix start points and end points */
    n = 0;
    if (key->totalComponents != GLYPHELEMENT)
    {
      n += elementPtr->ep[-1] + 1; /* number of points */
    }


    if (!key->localTIsIdentity)
      fsg_LocalPostTransformGlyph (key, &key->localTMatrix);

    if (key->compFlags & ARGS_ARE_XY_VALUES)
    {
      xOffset = globalGS->ScaleFuncX (&globalGS->scaleX, (F26Dot6)(key->arg1));
      yOffset = globalGS->ScaleFuncY (&globalGS->scaleY, (F26Dot6)(key->arg2));


      if (key->compFlags & ROUND_XY_TO_GRID)
      {
        xOffset += fnt_pixelSize / 2;
        xOffset &= ~ (fnt_pixelSize - 1);
        yOffset += fnt_pixelSize / 2;
        yOffset &= ~ (fnt_pixelSize - 1);
      }
    }
    else
    {
      xOffset = elementPtr->x[ key->arg1 - n ] - elementPtr->x[ key->arg2 ];
      yOffset = elementPtr->y[ key->arg1 - n ] - elementPtr->y[ key->arg2 ];
    }

/* shift all the points == Align the component */
    fsg_ShiftChar (key, xOffset, yOffset, elementPtr->ep[elementPtr->nc - 1]);

    if (key->totalComponents != GLYPHELEMENT)
    {
/* Fix start points and end points */
      for (ctr = 0; ctr < elementPtr->nc; ctr++)
      {
        elementPtr->sp[ctr] += (int16)n;
        elementPtr->ep[ctr] += (int16)n;
      }
    }
  }

  if (finalCompositePass)
    *elementPtr = elementSave;
  key->scanControl = globalGS->localParBlock.scanControl; /*rwb */
  return NO_ERR;
}


/*
 * Internal routine.    changed to use pointer                  <3>
 */

#ifdef  ON_THE_MAC

PUBLIC void fsg_InitLocalT (fsg_SplineKey*key)
{
  register Fixed*p = &key->localTMatrix.transform[0][0];
  register Fixed one = ONEFIX;
  register Fixed zero = 0;
  *p++ = one;
  *p++ = zero;
  *p++ = zero;

  *p++ = zero;
  *p++ = one;
  *p++ = zero;

  *p++ = zero;
  *p++ = zero;
  *p   = one;
   /* Internal routines assume ONEFIX here, though client assumes ONEFRAC } */
}

#else

PUBLIC  transMatrix IdMatrix = { ONEFIX, 0, 0, 0, ONEFIX, 0, 0, 0, ONEFIX };

#define fsg_InitLocalT(key) key->localTMatrix = IdMatrix;

#endif

/*
 *      fsg_GridFit
 */
int     fsg_GridFit (register fsg_SplineKey*key, voidFunc traceFunc, boolean useHints)
{
  int   result;
  unsigned elementCount;
  fnt_GlobalGraphicStateType * globalGS = GLOBALGSTATE (key);

  //DJC moved to beg of file
  //DJC void sfnt_ReadSFNTMetrics (fsg_SplineKey*, uint16); /*add prototype; @WIN*/
  //DJC int sfnt_ReadSFNT (fsg_SplineKey *, unsigned *, uint16, boolean, voidFunc);/*add prototype; @WIN*/

  fsg_SetUpElement (key, TWILIGHTZONE);/* TWILIGHT ZONE ELEMENT */

  elementCount = GLYPHELEMENT;

  key->weGotComponents = false;
  key->compFlags = NON_OVERLAPPING;

/* This also calls fsg_InnerGridFit () .*/
  if (globalGS->localParBlock.instructControl & NOGRIDFITFLAG)
    useHints = false;
  key->localTIsIdentity = true;
  fsg_InitLocalT (key);
  if ((result = sfnt_ReadSFNT (key, &elementCount, key->glyphIndex, useHints, traceFunc)) == NO_ERR)
  {
    key->elementInfoRec.interpreterElements[GLYPHELEMENT].nc = key->totalContours;

    if (key->weGotComponents)
      fsg_SetUpElement (key, GLYPHELEMENT); /* Set it up again so we can transform */
    if (key->imageState & (ROTATED|DEGREE90))
      fsg_PostTransformGlyph (key, &key->currentTMatrix);
  }
  return result;
}


/*
 *  Call this guy before you use the matrix.  He does two things:
 *      He folds any perspective-translation back into perspective,
 *       and then changes the [2][2] element from a Fract to a fixed.
 */
void fsg_ReduceMatrix(fsg_SplineKey* key)
{
    Fixed a, *matrix = &key->currentTMatrix.transform[0][0];
    Fract bottom = matrix[8];

/*
 *  First, fold translation into perspective, if any.
 */
    if (a = matrix[2])
    {
        matrix[0] -= LongMulDiv(a, matrix[6], bottom);
        matrix[1] -= LongMulDiv(a, matrix[7], bottom);
    }
    if (a = matrix[5])
    {
        matrix[3] -= LongMulDiv(a, matrix[6], bottom);
        matrix[4] -= LongMulDiv(a, matrix[7], bottom);
    }
    matrix[6] = matrix[7] = 0;
    matrix[8] = FRACT2FIX(bottom);      /* make this guy a fixed for XYMul routines */
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\bass\rotate.c ===
/** FontScaler's Includes **/

// DJC DJC.. added global include
#include "psglobal.h"

#include "fserror.h"
#include "fscdefs.h"
#include "fontmath.h"
#include "sfnt.h"
#include "fnt.h"
#include "sc.h"
#include "fsglue.h"
#include "privsfnt.h"

#define NUMBEROFPOINTS(elementPtr)  (elementPtr->ep[elementPtr->nc - 1] + 1 + PHANTOMCOUNT)

#define LOOPDOWN(n)     for (--n; n >= 0; --n)
#define ULOOPDOWN(n)        while (n--)

void FAR fsg_ReverseContours (fnt_ElementType*elementPtr);
static void fsg_Dot6XYMul (F26Dot6*x, F26Dot6*y, transMatrix*matrix);
       void fsg_CopyElementBackwards (fnt_ElementType *elementPtr);
static int8 fsg_HasPerspective (transMatrix*matrix);
static void fsg_IntelMul (int numPts, F26Dot6*x, F26Dot6*y, transMatrix *trans, Fixed xStretch, Fixed yStretch);
/*
 *  fsg_PostTransformGlyph              <3>
 */
void FAR fsg_PostTransformGlyph (register fsg_SplineKey *key, transMatrix *trans)
{
  fnt_ElementType * elementPtr = & (key->elementInfoRec.interpreterElements[key->elementNumber]);

  fsg_IntelMul (NUMBEROFPOINTS (elementPtr), elementPtr->x, elementPtr->y, trans, key->interpScalarX, key->interpScalarY);
}

static void fsg_IntelMul (int numPts, F26Dot6*x, F26Dot6*y, transMatrix *trans, Fixed xStretch, Fixed yStretch)
{
  if (xStretch == 0L || yStretch == 0L)
  {
    LOOPDOWN (numPts)
      *y++ = *x++ = 0;
  }
  else
  {
    Fixed m00 = FixDiv (trans->transform[0][0], xStretch);
    Fixed m01 = FixDiv (trans->transform[0][1], xStretch);
    Fixed m10 = FixDiv (trans->transform[1][0], yStretch);
    Fixed m11 = FixDiv (trans->transform[1][1], yStretch);

    LOOPDOWN (numPts)
    {
      register Fixed origx = *x;
      register Fixed origy = *y;

      *x++ = (F26Dot6) (FixMul (m00, origx) + FixMul (m10, origy));
      *y++ = (F26Dot6) (FixMul (m01, origx) + FixMul (m11, origy));
    }
  }
}



/* <3> */
/*
 *  Good for transforming scaled coordinates.  Assumes NO translate  <4>
 */
static void fsg_Dot6XYMul (F26Dot6*x, F26Dot6*y, transMatrix*matrix)
{
  register F26Dot6 xTemp, yTemp;
  register Fixed *m0, *m1;

  m0 = (Fixed *) & matrix->transform[0][0];
  m1 = (Fixed *) & matrix->transform[1][0];

  xTemp = *x;
  yTemp = *y;
  *x = (F26Dot6) (FixMul (*m0++, xTemp) + FixMul (*m1++, yTemp));
  *y = (F26Dot6) (FixMul (*m0++, xTemp) + FixMul (*m1++, yTemp));

#ifndef PC_OS

  if (*m0 || *m1)     /* these two are Fracts */
  {
    Fixed tmp = FracMul (*m0, xTemp) + FracMul (*m1, yTemp);
    tmp <<= 10;         /* make it a fixed */
    tmp += matrix->transform[2][2];
    if (tmp && tmp != ONEFIX)
    {
      *x = (F26Dot6) FixDiv (*x, tmp);
      *y = (F26Dot6) FixDiv (*y, tmp);
    }
  }
#endif
}

/*
 *      fsg_LocalPostTransformGlyph                             <3>
 *
 * (1) Inverts the stretch from the CTM
 * (2) Applies the local transformation passed in in the trans parameter
 * (3) Applies the global stretch from the root CTM
 * (4) Restores oox, ooy, oy, ox, and f.
 */
void FAR fsg_LocalPostTransformGlyph(register fsg_SplineKey *key, transMatrix *trans)
{
//register int            numPts, count;        @WIN
  register int            count;
//register Fixed          xScale, yScale;       @WIN
//register F26Dot6*       x;                    @WIN
//register F26Dot6*       y;                    @WIN
  fnt_ElementType*        elementPtr = &(key->elementInfoRec.interpreterElements[key->elementNumber]);

  count = NUMBEROFPOINTS(elementPtr);

  fsg_IntelMul (count, elementPtr->x, elementPtr->y, trans, ONEFIX, ONEFIX);
  fsg_IntelMul (count, elementPtr->oox, elementPtr->ooy, trans, ONEFIX, ONEFIX);
  fsg_CopyElementBackwards( &(key->elementInfoRec.interpreterElements[GLYPHELEMENT]) );
}

#if 0
/*
 *  fsg_LocalPostTransformGlyph             <3>
 *
 * (1) Inverts the stretch from the CTM
 * (2) Applies the local transformation passed in in the trans parameter
 * (3) Applies the global stretch from the root CTM
 * (4) Restores oox, ooy, oy, ox, and f.
 */
void FAR fsg_LocalPostTransformGlyph (register fsg_SplineKey *key, transMatrix *trans)
{
  register int16      numPts, count;
  register Fixed      xScale = trans->transform[0][0], yScale = trans->transform[1][1];
  register F26Dot6*  x;
  register F26Dot6*  y;
  fnt_ElementType *    elementPtr = & (key->elementInfoRec.interpreterElements[key->elementNumber]);

  numPts = count = NUMBEROFPOINTS (elementPtr);

  x = elementPtr->x;
  y = elementPtr->y;

  if (xScale == 0L || yScale == 0L)
  {
    register F26Dot6 zero = 0;
    LOOPDOWN (numPts)
    *x++ = *y++ = zero;
  }
  else
  {
    LOOPDOWN (numPts)
    {
      *x = (F26Dot6) FixDiv (*x, xScale);
      *y = (F26Dot6) FixDiv (*y, yScale);
      fsg_Dot6XYMul (x++, y++, trans);
    }
  }

  fsg_CopyElementBackwards (& (key->elementInfoRec.interpreterElements[GLYPHELEMENT]));
  x = elementPtr->oox;
  y = elementPtr->ooy;
  LOOPDOWN (count)
    fsg_Dot6XYMul (x++, y++, trans);
}

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\bass\fsglue.h ===
/*
    File:       fsglue.h

    Contains:   xxx put contents here (or delete the whole line) xxx

    Written by: xxx put name of writer here (or delete the whole line) xxx

    Copyright:  c 1988-1990 by Apple Computer, Inc., all rights reserved.

    Change History (most recent first):

       <11+>     7/17/90    MR      Change error return type to int
        <11>     7/13/90    MR      Declared function pointer prototypes, Debug fields for runtime
                                    range checking
         <8>     6/21/90    MR      Add field for ReleaseSfntFrag
         <7>      6/5/90    MR      remove vectorMappingF
         <6>      6/4/90    MR      Remove MVT
         <5>      6/1/90    MR      Thus endeth the too-brief life of the MVT...
         <4>      5/3/90    RB      adding support for new scan converter and decryption.
         <3>     3/20/90    CL      Added function pointer for vector mapping
                                    Removed devRes field
                                    Added fpem field
         <2>     2/27/90    CL      Change: The scaler handles both the old and new format
                                    simultaneously! It reconfigures itself during runtime !  Changed
                                    transformed width calculation.  Fixed transformed component bug.
       <3.1>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
                                    phantom points are in, even for components in a composite glyph.
                                    They should also work for transformations. Device metric are
                                    passed out in the output data structure. This should also work
                                    with transformations. Another leftsidebearing along the advance
                                    width vector is also passed out. whatever the metrics are for
                                    the component at it's level. Instructions are legal in
                                    components. Now it is legal to pass in zero as the address of
                                    memory when a piece of the sfnt is requested by the scaler. If
                                    this happens the scaler will simply exit with an error code !
       <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
       <2.2>     8/14/89    sjk     1 point contours now OK
       <2.1>      8/8/89    sjk     Improved encryption handling
       <2.0>      8/2/89    sjk     Just fixed EASE comment
       <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
       <1.4>     6/13/89    SJK     Comment
       <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
                                    bug, correct transformed integralized ppem behavior, pretty much
                                    so
       <1.2>     5/26/89    CEL     EASE messed up on "c" comments
      <,1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
       <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

    To Do:
*/
/*      <3+>     3/20/90    mrr     Added flag executeFontPgm, set in fs_NewSFNT
*/
#define POINTSPERINCH               72
#define MAX_ELEMENTS                2
#define MAX_TWILIGHT_CONTOURS       1

#define TWILIGHTZONE 0 /* The point storage */
#define GLYPHELEMENT 1 /* The actual glyph */



/* use the lower ones for public phantom points */
/* public phantom points start here */
#define LEFTSIDEBEARING 0
#define RIGHTSIDEBEARING 1
/* private phantom points start here */
#define ORIGINPOINT 2
#define LEFTEDGEPOINT 3
/* total number of phantom points */
#define PHANTOMCOUNT 4


/*** Memory shared between all fonts and sizes and transformations ***/
#define KEY_PTR_BASE                0 /* Constant Size ! */
#define VOID_FUNC_PTR_BASE          1 /* Constant Size ! */
#define SCAN_PTR_BASE               2 /* Constant Size ! */
#define WORK_SPACE_BASE             3 /* size is sfnt dependent, can't be shared between grid-fitting and scan-conversion */
/*** Memory that can not be shared between fonts and different sizes, can not dissappear after InitPreProgram () ***/
#define PRIVATE_FONT_SPACE_BASE     4 /* size is sfnt dependent */
/* Only needs to exist when ContourScan is called, and it can be shared */
#define BITMAP_PTR_1                5 /* the bitmap - size is glyph size dependent */
#define BITMAP_PTR_2                6 /* size is proportional to number of rows */
#define BITMAP_PTR_3                7 /* used for dropout control - glyph size dependent */
#define MAX_MEMORY_AREAS            8 /* this index is not used for memory */

#ifdef  PC_OS

    void ReleaseSFNT (voidPtr p);
    voidPtr SfntReadFragment (long ulClientID, long offset, long length);

    #define GETSFNTFRAG(key,ulClientID,offset,length) SfntReadFragment (ulClientID, offset, length)
    #define RELEASESFNTFRAG(key,data)       ReleaseSFNT((voidPtr)data)

#else
    #define GETSFNTFRAG(key,ulClientID,offset,length) (key)->GetSfntFragmentPtr(ulClientID, (long)offset, (long)length)
    #ifdef RELEASE_MEM_FRAG
            #define RELEASESFNTFRAG(key,data)       (key)->ReleaseSfntFrag((voidPtr)data)
    #else
            #define RELEASESFNTFRAG(key,data)
    #endif
#endif

typedef struct {
    F26Dot6 x;
    F26Dot6 y;
} point;

/*** Offset table ***/
#ifdef PC_OS    /*NOT_ON_THE_MAC*/
  #define  OFFSET_INFO_TYPE    int8 *
#else
  #define   OFFSET_INFO_TYPE    uint32
#endif

typedef struct {
    OFFSET_INFO_TYPE x;
    OFFSET_INFO_TYPE y;
    OFFSET_INFO_TYPE ox;
    OFFSET_INFO_TYPE oy;
    OFFSET_INFO_TYPE oox;
    OFFSET_INFO_TYPE ooy;
    OFFSET_INFO_TYPE onCurve;
    OFFSET_INFO_TYPE sp;
    OFFSET_INFO_TYPE ep;
    OFFSET_INFO_TYPE f;
} fsg_OffsetInfo;


/*  #define COMPSTUFF  */

/*** Element Information ***/
typedef struct {
    int32               missingCharInstructionOffset;
    int32               stackBaseOffset;
#ifdef COMPSTUFF
    fsg_OffsetInfo      FAR *offsets;           /*@WIN*/
    fnt_ElementType     FAR *interpreterElements; /*@WIN*/
#else
    fsg_OffsetInfo      offsets[MAX_ELEMENTS];
    fnt_ElementType     interpreterElements[MAX_ELEMENTS];
#endif COMPSTUFF
} fsg_ElementInfo;

typedef struct {
  uint32    Offset;
  unsigned  Length;
} fsg_OffsetLength;


/*** The Internal Key ***/
typedef struct fsg_SplineKey {
    int32               clientID;
#ifndef PC_OS
    GetSFNTFunc         GetSfntFragmentPtr; /* User function to eat sfnt */
    ReleaseSFNTFunc     ReleaseSfntFrag;    /* User function to relase sfnt */
#endif
/* skip the parameter by Falco, 11/12/91 */
/*    uint16 (*mappingF) (uint8 FAR *, uint16); *//* mapping function */
    uint16 (*mappingF) (); /* mapping function @WIN*/
/* skip end */
    unsigned            mappOffset;         /* Offset to platform mapping data */
    int16               glyphIndex;         /* */
    uint16              elementNumber;      /* Character Element */

    char FAR * FAR *    memoryBases;   /* array of memory Areas @WIN*/

    fsg_ElementInfo     elementInfoRec;     /* element info structure */
    sc_BitMapData       bitMapInfo;         /* bitmap info structure */

    uint16          emResolution;                   /* used to be int32 <4> */

    Fixed           fixedPointSize;                 /* user point size */
    Fixed           interpScalarX;                  /* scalar for instructable things */
    Fixed           interpScalarY;                  /* scalar for instructable things */
    Fixed           interpLocalScalarX;             /* Local scalar for instructable things */
    Fixed           interpLocalScalarY;             /* Local scalar for instructable things */
    Fixed           metricScalarX;                  /* scalar for metric things */
    Fixed           metricScalarY;                  /* scalar for metric things */

    transMatrix     currentTMatrix; /* Current Transform Matrix */
    transMatrix     localTMatrix; /* Local Transform Matrix */
    int8            localTIsIdentity;
    int8            phaseShift;         /* 45 degrees flag <4> */
    int16           identityTransformation;
    int16           indexToLocFormat;

    uint16          fontFlags;                              /* copy of header.flags */

    Fixed           pixelDiameter;
    uint16          nonScaledAW;
    int16           nonScaledLSB;

    unsigned        state;                  /* for error checking purposes */
    int32           scanControl;                /* flags for dropout control etc.  */

      /* for key->memoryBases[PRIVATE_FONT_SPACE_BASE] */
    OFFSET_INFO_TYPE offset_storage;
    OFFSET_INFO_TYPE offset_functions;
    OFFSET_INFO_TYPE offset_instrDefs;       /* <4> */
    OFFSET_INFO_TYPE offset_controlValues;
    OFFSET_INFO_TYPE offset_globalGS;
    OFFSET_INFO_TYPE offset_FontProgram;
    OFFSET_INFO_TYPE offset_PreProgram;

    /* for outline caching */
    unsigned        glyphLength;


    /* copy of profile */
    sfnt_maxProfileTable    maxProfile;

#ifdef DEBUG
    int32   cvtCount;
#endif

    fsg_OffsetLength offsetTableMap[sfnt_NUMTABLEINDEX];
    uint16          numberOf_LongHorMetrics;

    uint16          totalContours; /* for components */
    uint16          totalComponents; /* for components */
    uint16          weGotComponents; /* for components */
    uint16          compFlags;
    int16           arg1, arg2;

    int32           instructControl;    /* set to inhibit execution of instructions */
    int32           imageState;         /* is glyph rotated, stretched, etc. */

    int             numberOfRealPointsInComponent;
    uint16          lastGlyph;
    uint8           executePrePgm;
    uint8           executeFontPgm;     /* <4> */
    jmp_buf         env;

} fsg_SplineKey;


#define VALID 0x1234

#ifndef    PC_OS
#define   FONT_OFFSET(base,offset) ((base)+(offset))
#else
#define   FONT_OFFSET(base,offset) (offset)
#endif

/* Change this if the format for cached outlines change. */
/* Someone might be caching old stuff for years on a disk */
#define OUTLINESTAMP 0xA1986688
#define OUTLINESTAMP2 0xA5


/* for the key->state field */
#define INITIALIZED 0x0000
#define NEWSFNT     0x0002
#define NEWTRANS    0x0004
#define GOTINDEX    0x0008
#define GOTGLYPH    0x0010
#define SIZEKNOWN   0x0020

/* fo the key->imageState field */
#define ROTATED     0x0400
#define DEGREE90    0x0800
#define STRETCHED   0x1000

/**********************/
/** FOR MISSING CHAR **/
/**********************/
#define NPUSHB          0x40
#define MDAP_1          0x2f
#define MDRP_01101      0xcd
#define MDRP_11101      0xdd
#define IUP_0           0x30
#define IUP_1           0x31
#define SVTCA_0         0x00
/**********************/


/***************/
/** INTERFACE **/
/***************/
#define fsg_KeySize()               (sizeof (fsg_SplineKey))
#define fsg_InterPreterDataSize()   0
#define fsg_ScanDataSize()          (sizeof (sc_GlobalData))
extern unsigned fsg_PrivateFontSpaceSize (fsg_SplineKey FAR *key); /*@WIN*/
extern int fsg_GridFit (fsg_SplineKey FAR *key, voidFunc traceFunc, boolean useHints); /*@WIN*/


/***************/

/* matrix routines */

/*
 * (x1 y1 1) = (x0 y0 1) * matrix;
 */
/*extern void fsg_Dot6XYMul (F26Dot6* x, F26Dot6* y, transMatrix* matrix);*/
extern void fsg_FixXYMul (Fixed FAR * x, Fixed FAR * y, transMatrix FAR * matrix);/*@WIN*/
extern void fsg_FixVectorMul (vectorType FAR * v, transMatrix FAR * matrix);/*@WIN*/

/*
 *   B = A * B;     <4>
 *
 *         | a  b  0  |
 *    B =  | c  d  0  | * B;
 *         | 0  0  1  |
 */
extern void fsg_MxConcat2x2 (transMatrix FAR * matrixA, transMatrix FAR * matrixB);/*@WIN*/

/*
 * scales a matrix by sx and sy.
 *
 *              | sx 0  0  |
 *    matrix =  | 0  sy 0  | * matrix;
 *              | 0  0  1  |
 */
extern void fsg_MxScaleAB (Fixed sx, Fixed sy, transMatrix FAR *matrixB);/*@WIN*/

extern void fsg_ReduceMatrix (fsg_SplineKey FAR * key);/*@WIN*/

/*
 *  Used in FontScaler.c and MacExtra.c, lives in FontScaler.c
 */
int fsg_RunFontProgram (fsg_SplineKey FAR * key);/*@WIN*/


/*
** Other externally called functions.  Prototype calls added on 4/5/90
*/
void fsg_IncrementElement (fsg_SplineKey FAR *key, int n, register int numPoints, register int numContours);/*@WIN*/

void fsg_InitInterpreterTrans (register fsg_SplineKey FAR *key, Fixed FAR *pinterpScalarX, Fixed FAR *pinterpScalarY, Fixed FAR *pmetricScalarX, Fixed FAR *pmetricScalarY);/*@WIN*/

int     fsg_InnerGridFit (register fsg_SplineKey FAR *key, boolean useHints, voidFunc traceFunc,/*@WIN*/
BBOX FAR *bbox, unsigned sizeOfInstructions, uint8 FAR *instructionPtr, boolean finalCompositePass);/*@WIN*/

int fsg_RunPreProgram (fsg_SplineKey FAR *key, voidFunc traceFunc);/*@WIN*/

void fsg_SetUpElement (fsg_SplineKey FAR *key, int n);/*@WIN*/

unsigned fsg_WorkSpaceSetOffsets (fsg_SplineKey FAR *key);/*@WIN*/

int fsg_SetDefaults (fsg_SplineKey FAR * key);/*@WIN*/

void fsg_SetUpProgramPtrs (fsg_SplineKey FAR *key, fnt_GlobalGraphicStateType FAR *globalGS, int pgmIndex);/*@WIN*/

void FAR fsg_LocalPostTransformGlyph(fsg_SplineKey FAR *, transMatrix FAR *);/*@WIN*/
void FAR fsg_PostTransformGlyph (fsg_SplineKey FAR *, transMatrix FAR *);/*@WIN*/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\bass\privsfnt.h ===
/*
    File:       private sfnt.h

    Contains:   xxx put contents here xxx

    Written by: xxx put writers here xxx

    Copyright:  c 1990 by Apple Computer, Inc., all rights reserved.

    Change History (most recent first):

        <3+>     7/17/90    MR      Change return types to in for computemapping and readsfnt
         <3>     7/14/90    MR      changed SQRT to conditional FIXEDSQRT2
         <2>     7/13/90    MR      Change parameters to ReadSFNT and ComputeMapping
        <1+>     4/18/90    CL
         <1>     3/21/90    EMT     First checked in with Mike Reed's blessing.

    To Do:
*/

/* PUBLIC PROTOTYPE CALLS */

/*
 * Below we have private stuff
 * This has nothing to do with the file format.
 */

/* skip the parameter by Falco, 11/12/91 */
/*voidPtr sfnt_GetTablePtr (register fsg_SplineKey *key, register sfnt_tableIndex n, register boolean mustHaveTable); */
voidPtr sfnt_GetTablePtr ();
/* skip end */

/*
 * Creates mapping for finding offset table
 */
/* skip the parameter by Falco, 11/12/91 */
/*extern void FAR sfnt_DoOffsetTableMap (fsg_SplineKey *key);*/
extern void FAR sfnt_DoOffsetTableMap ();
/* skip end */

/* perfect spot size (Fixed) */
#ifndef FIXEDSQRT2
#define FIXEDSQRT2 0x00016A0A
#endif

/*
 * Returns offset and length for table n
 */

// DJC put in real prototype ... extern int sfnt_ComputeMapping ();
extern int sfnt_ComputeMapping(register fsg_SplineKey *key, uint16 platformID, uint16 specificID);

// DJC put in real prototype
extern int sfnt_ReadSFNT (fsg_SplineKey *, unsigned *, uint16, boolean, voidFunc);/*add prototype; @WIN*/
// extern void sfnt_ReadSFNTMetrics ();

// DJC put in real prototype
// extern int sfnt_ReadSFNT ();
int sfnt_ReadSFNT (fsg_SplineKey *, unsigned *, uint16, boolean, voidFunc);/*add prototype; @WIN*/
/* skip end */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\bass\sc.c ===
/*
        File:           sc.c

        Contains:       xxx put contents here xxx

        Written by:     xxx put writers here xxx

        Copyright:      c 1990 by Apple Computer, Inc., all rights reserved.

        Change History (most recent first):

        <15>    06/27/91        AC     Put back the banding code
        <14>    05/13/91        AC     Rewrote sc_mark and sc_markRows
        <13>    12/20/90        RB     Add ZERO macro to include 0 degrees in definition of interior
*/

/*
 * File: sc.c
 *
 * This module scanconverts a shape defined by quadratic B-splines
 *
 * The BASS project scan converter sub ERS describes the workings of this module.
 *
 *
 *  c Apple Computer Inc. 1987, 1988, 1989, 1990.
 *
 * History:
 * Work on this module began in the fall of 1987.
 * Written June 14, 1988 by Sampo Kaasila.
 *
 * Released for alpha on January 31, 1989.
 *
 * Added experimental non breaking scan-conversion feature, Jan 9, 1990. ---Sampo
 *
 */



// DJC DJC.. added global include
#include "psglobal.h"

#define multlong(a,b) SHORTMUL(a,b) /* ((a)*(b)) */

#include    "fscdefs.h"
#include    "fontmath.h"
#include    "sfnt.h"
#include    "fnt.h"
#include    "sc.h"
#include    "fserror.h"

#ifndef PRIVATE
#define PRIVATE
#endif


#ifdef SEGMENT_LINK
#pragma segment SC_C
#endif

#ifndef FSCFG_BIG_ENDIAN

static uint32 aulInvPixMask [32]
#ifdef PC_OS
=
{
  0x00000080, 0x00000040, 0x00000020, 0x00000010,
  0x00000008, 0x00000004, 0x00000002, 0x00000001,
  0x00008000, 0x00004000, 0x00002000, 0x00001000,
  0x00000800, 0x00000400, 0x00000200, 0x00000100,
  0x00800000, 0x00400000, 0x00200000, 0x00100000,
  0x00080000, 0x00040000, 0x00020000, 0x00010000,
  0x80000000, 0x40000000, 0x20000000, 0x10000000,
  0x08000000, 0x04000000, 0x02000000, 0x01000000
}
#endif
;

#define MASK_INVPIX(mask,val)   mask = aulInvPixMask [val]

#else

#define MASK_INVPIX(mask,val)   mask = ((uint32) 0x80000000L) >> (val)

#endif


#ifdef PC_OS                    /* Windows uses compile-time initialization */
#define SETUP_MASKS()
#endif

#ifdef FSCFG_BIG_ENDIAN         /* Big-endian uses runtime shifts, not masks */
#define SETUP_MASKS()
#endif

#ifndef SETUP_MASKS             /* General case -- works on any CPU */
static int fMasksSetUp = false;
static void SetUpMasks (void);
#define SETUP_MASKS()  if (!fMasksSetUp) SetUpMasks(); else
#endif


/*
//----------------------------------------------------------------------------
// define "static" data that will be needed by the DDAs. When FSCFG_REENTRANT
// is not defined, this is made static so that parameters will not have to
// be passed around.  When reentrancy is required, we declare the locals as an
// auto variable and pass a pointer to this auto wherever we need it.
//
// For the IN_ASM case, it is VERY important that the ordering of fields
// within this structure not be changed -- SCA.ASM depends on the ordering.
//-----------------------------------------------------------------------------
 */

struct scLocalData
{
    int16 jx, jy, endx, endy, **px, **py;
    int16 wideX, wideY;
    int32 incX, incY;
    int16 **xBase, **yBase;
    int16 marktype;
    int16 **lowRowP, **highRowP;
    int32 r;
};

#ifdef FSCFG_REENTRANT
#define SCP0    struct scLocalData* pLocalSC
#define SCP     struct scLocalData* pLocalSC,
#define SCA0    pLocalSC
#define SCA     pLocalSC,
#define LocalSC (*pLocalSC)
#else
#define SCP0    void
#define SCP
#define SCA0
#define SCA
struct scLocalData LocalSC = {0};
#endif


/* Private prototypes */

PRIVATE void sc_mark (SCP F26Dot6 *pntbx, F26Dot6 *pntby, F26Dot6 *pntx, F26Dot6 *pnty, F26Dot6 *pnte) ;

PRIVATE void sortRows (sc_BitMapData *bbox, int16**lowRowP, int16**highRowP);

PRIVATE void sortCols (sc_BitMapData *bbox);

PRIVATE int sc_DrawParabola (F26Dot6 Ax, F26Dot6 Ay, F26Dot6 Bx, F26Dot6 By, F26Dot6 Cx, F26Dot6 Cy, F26Dot6 **hX, F26Dot6 **hY, unsigned *count,
 int32 inGY);

PRIVATE void sc_wnNrowFill (int rowM, int nRows, sc_BitMapData *bbox);

PRIVATE void sc_orSomeBits (sc_BitMapData *bbox, int32 scanKind);

PRIVATE int16**sc_lineInit (int16*arrayBase, int16**rowBase, int16 nScanlines, int16 maxCrossings,
int16 minScanline);
PRIVATE int nOnOff (int16**base, int k, int16 val, int nChanges);

PRIVATE int nUpperXings (int16**lineBase, int16**valBase, int line, int16 val, int lineChanges, int valChanges, int valMin, int valMax, int lineMax);
PRIVATE int nLowerXings (int16**lineBase, int16**valBase, int line, int16 val, int lineChanges, int valChanges, int valMin, int valMax, int lineMin);

PRIVATE void invpixSegY (int16 llx, uint16 k, uint32*bitmapP);
PRIVATE void invpixSegX (int16 llx, uint16 k, uint32*bitmapP);
PRIVATE void invpixOn (int16 llx, uint16 k, uint32*bitmapP);

PRIVATE void DDA_1_XY (SCP0) ;
PRIVATE void DDA_2_XY (SCP0) ;
PRIVATE void DDA_3_XY (SCP0) ;
PRIVATE void DDA_4_XY (SCP0) ;
PRIVATE void DDA_1_Y (SCP0) ;
PRIVATE void DDA_2_Y (SCP0) ;
PRIVATE void DDA_3_Y (SCP0) ;
PRIVATE void DDA_4_Y (SCP0) ;



/*@@*/
#ifndef IN_ASM

/*
// CAUTION. The value of DO_STUBS is chosen to be 5 because the DDA routines
// that are used when stub crossings are needed start after 5 addresses in
// the DDA jump table. PLEAE BE VERY CAREFUL WHEN CHANIGING THIS VALUE.
 */
#define DO_STUBS    5
#else /* code is in assembly */

/*
// premultiply DOS_STUB by 2 for efficient word access of the DDA table in
// assembly. PLEASE BE VERY CAREFUL IN CHANGING THIS VALUE.
 */

#define DO_STUBS    5 * 2
#endif

/*-------------------------------------------------------------------------- */
/*
 * Returns the bitmap
 * This is the top level call to the scan converter.
 *
 * Assumes that (*handle)->bbox.xmin,...xmax,...ymin,...ymax
 * are already set by sc_FindExtrema ()
 *
 * PARAMETERS:
 *
 *
 * glyphPtr is a pointer to sc_CharDataType
 * scPtr is a pointer to sc_GlobalData.
 * lowBand   is lowest scan line to be included in the band.
 * highBand  is one greater than the highest scan line to be included in the band. <7>
 * scanKind contains flags that specify whether to do dropout control and what kind
 *      0 -> no dropout control
 *      bits 0-15 not equal 0 -> do dropout control
 *      if bit 16 is also on, do not do dropout control on 'stubs'
*/
int FAR sc_ScanChar (sc_CharDataType *glyphPtr, sc_GlobalData *scPtr, sc_BitMapData *bbox,
int16 lowBand, int16 highBand, int32 scanKind)
{
  register F26Dot6 *x = glyphPtr->x;
  register F26Dot6 *y = glyphPtr->y;
  register ArrayIndex i, endPt, nextPt;
  register uint8 *onCurve = glyphPtr->onCurve;
  ArrayIndex startPt, j;
  LoopCount ctr;
  sc_GlobalData * p;
  F26Dot6 * xp, *yp, *x0p, *y0p;
  register F26Dot6 xx, yy, xx0, yy0;
  int   quit;
  unsigned vecCount;
#ifdef FSCFG_REENTRANT
  struct scLocalData thisLocalSC;
  struct scLocalData* pLocalSC = &thisLocalSC;
#endif

  SETUP_MASKS();

/*---------------------------------------------------------------------------------
** For the PC, we will exclude all banding specific code. We will still include
** the banding code for the Mac and other platforms.
**--------------------------------------------------------------------------------*/

#ifdef FSCFG_NO_BANDING

  bbox->yBase = sc_lineInit (bbox->yLines, bbox->yBase, bbox->bounds.yMax - bbox->bounds.yMin, bbox->nYchanges, bbox->bounds.yMin);
  if (scanKind)
    bbox->xBase = sc_lineInit (bbox->xLines, bbox->xBase, bbox->bounds.xMax - bbox->bounds.xMin, bbox->nXchanges, bbox->bounds.xMin);

#else

  if (scanKind)
  {
    bbox->xBase = sc_lineInit (bbox->xLines, bbox->xBase, (int16)(bbox->bounds.xMax - bbox->bounds.xMin), bbox->nXchanges, bbox->bounds.xMin);
    bbox->yBase = sc_lineInit (bbox->yLines, bbox->yBase, (int16)(bbox->bounds.yMax - bbox->bounds.yMin), bbox->nYchanges, bbox->bounds.yMin);
  }
  else
    bbox->yBase = sc_lineInit (bbox->yLines, bbox->yBase, (int16)(highBand - lowBand), bbox->nYchanges, lowBand);

#endif
/*--------------------------------------------------------------------------------- */
/* at this time set up LocalSC.yBase, LocalSC.xBase, LocalSC.marktype, LocalSC.wideX and LocalSC.wideY in static  */
/* varialbles. This will save us from passing these parameters to sc_mark */
/*--------------------------------------------------------------------------------- */

  LocalSC.yBase = bbox->yBase ;
  LocalSC.xBase = bbox->xBase ;
  LocalSC.marktype = (scanKind > 0) ? DO_STUBS : 0 ; /* just a boolean value */

#ifdef IN_ASM
  LocalSC.wideX = (bbox->nXchanges + 1) << 1;           /* premultiply by two for word access */
  LocalSC.wideY = (bbox->nYchanges + 1) << 1;           /* premultiply by two for word access */
#else
  LocalSC.wideX = bbox->nXchanges + 1 ;
  LocalSC.wideY = bbox->nYchanges + 1   ;
#endif
/*--------------------------------------------------------------------------------- */

  LocalSC.lowRowP = bbox->yBase + lowBand;
  LocalSC.highRowP = bbox->yBase + highBand - 1;

  if (glyphPtr->nc == 0)
    return NO_ERR;
  p = scPtr;
  for (ctr = 0; ctr < glyphPtr->nc; ctr++)
  {
    x0p = xp = p->xPoints;
    y0p = yp = p->yPoints;
    startPt = i = glyphPtr->sp[ctr];
    endPt = glyphPtr->ep[ctr];

    if (startPt == endPt)
      continue;
    quit = 0;
    vecCount = 1;
    if (onCurve[i] & ONCURVE)
    {
      *xp++ = xx = x[i];
      *yp++ = yy = y[i++];
    }
    else
    {
      if (onCurve[endPt] & ONCURVE)
      {
    startPt = endPt--;
    *xp++ = xx = x[startPt];
    *yp++ = yy = y[startPt];
      }
      else
      {
        *xp++ = xx = (F26Dot6) (((long) x[i] + x[endPt] + 1) >> 1);
        *yp++ = yy = (F26Dot6) (((long) y[i] + y[endPt] + 1) >> 1);
    goto Offcurve;
      }
    }
    while (true)
    {
      while (onCurve[i] & ONCURVE)
      {
    if (++vecCount > MAXVECTORS)
    { /*Ran out of local memory. Consume data and continue. */
      sc_mark (SCA x0p, y0p, x0p+1, y0p+1, yp-1) ;

      x0p = p->xPoints + 2;           /* save data in points 0 and 1 for final */
      y0p = p->yPoints + 2;
      *x0p++ = * (xp - 2);                       /* save last vector to be future previous vector */
      *x0p++ = * (xp - 1);
      *y0p++ = * (yp - 2);
      *y0p++ = * (yp - 1);
      xp = x0p;                                       /* start next processing with last vector */
      x0p = p->xPoints + 2;
      yp = y0p;
      y0p = p->yPoints + 2;
      vecCount = 5;
    }
    *xp++ = xx = x[i];
    *yp++ = yy = y[i];
    if (quit)
    {
      goto sc_exit;
    }
    else
    {
      i = i == endPt ? quit = 1, startPt : i + 1;
    }
      }

      do
      {
Offcurve:
    xx0 = xx;
    yy0 = yy;
/* nextPt = (j = i) + 1; */
    j = i;
    nextPt = i == endPt ? quit = 1, startPt : i + 1;
    if (onCurve[nextPt] & ONCURVE)
    {
      xx = x[nextPt];
      yy = y[nextPt];
      i = nextPt;
    }
    else
    {
          xx = (F26Dot6) (((long) x[i] + x[nextPt] + 1) >> 1);
          yy = (F26Dot6) (((long) y[i] + y[nextPt] + 1) >> 1);
    }
    if (sc_DrawParabola (xx0, yy0, x[j], y[j], xx, yy, &xp, &yp, &vecCount, -1))
    { /* not enough room to create parabola vectors  */
      sc_mark (SCA x0p, y0p, x0p+1, y0p+1, yp-1) ;

      x0p = p->xPoints + 2;
      y0p = p->yPoints + 2;
      *x0p++ = * (xp - 2);
      *x0p++ = * (xp - 1);
      *y0p++ = * (yp - 2);
      *y0p++ = * (yp - 1);
      xp = x0p;
      x0p = p->xPoints + 2;
      yp = y0p;
      y0p = p->yPoints + 2;
      vecCount = 5;
/* recaptured some memory, try again, if still wont work, MAXVEC is too small */
      if (sc_DrawParabola (xx0, yy0, x[j], y[j], xx, yy, &xp, &yp, &vecCount, -1))
        return SCAN_ERR;
    }
    if (quit)
    {
      goto sc_exit;
    }
    else
    {
      i = i == endPt ? quit = 1, startPt : i + 1;
    }
      } while (! (onCurve[i] & ONCURVE));

    }
sc_exit:

    sc_mark (SCA x0p, y0p, x0p+1, y0p+1, yp-1) ;
    sc_mark (SCA xp-2, yp-2, p->xPoints, p->yPoints, p->yPoints+1) ;

  }

  sortRows (bbox, LocalSC.lowRowP, LocalSC.highRowP);
  if (scanKind)
    sortCols (bbox);

/* Take care of problem of very small thin glyphs - always fill at least one pixel
   Should this only be turned on if dropout control ??
 */
  if (LocalSC.highRowP < LocalSC.lowRowP)
  {
    register int16 *p = *LocalSC.lowRowP;
    register int16 *s = p + bbox->nYchanges + 1;
    ++ * p;
    * (p + *p) = bbox->bounds.xMin;
    ++ * s;
    * (s - *s) = bbox->bounds.xMax == bbox->bounds.xMin ? bbox->bounds.xMin + 1 : bbox->bounds.xMax;
    highBand = lowBand + 1;
  }
  else if (bbox->bounds.xMin == bbox->bounds.xMax)
  {
    register int16 *p;
    register int16 inc = bbox->nYchanges;
    for (p = *LocalSC.lowRowP; p <= *LocalSC.highRowP; p += inc + 1)
    {
      *p = 1;
      * (p + inc) = bbox->bounds.xMin + 1;
      * (++p) = bbox->bounds.xMin;
      * (p + inc) = 1;
    }
  }

  sc_wnNrowFill (lowBand, highBand - lowBand , bbox);

  if (scanKind)
    sc_orSomeBits (bbox, scanKind);

  return NO_ERR;
}


/* rwb 11/29/90 - modify the old positive winding number fill to be
 * a non-zero winding number fill to be compatible with skia, postscript,
 * and our documentation.
 */

#define LARGENUM            0x7fff
#define NEGONE          ((uint32)0xFFFFFFFF)

#ifndef  FSCFG_BIG_ENDIAN
  static uint32 aulMask [32]
#ifdef PC_OS
  =
  {
    0xffffffff, 0xffffff7f, 0xffffff3f, 0xffffff1f,
    0xffffff0f, 0xffffff07, 0xffffff03, 0xffffff01,
    0xffffff00, 0xffff7f00, 0xffff3f00, 0xffff1f00,
    0xffff0f00, 0xffff0700, 0xffff0300, 0xffff0100,
    0xffff0000, 0xff7f0000, 0xff3f0000, 0xff1f0000,
    0xff0f0000, 0xff070000, 0xff030000, 0xff010000,
    0xff000000, 0x7f000000, 0x3f000000, 0x1f000000,
    0x0f000000, 0x07000000, 0x03000000, 0x01000000
  }
#endif
  ;
#define MASK_ON(x)  aulMask [x]
#define MASK_OFF(x) ~aulMask [32-(x)]

#else

#define MASK_ON(x)  (NEGONE >> (x))
#define MASK_OFF(x) (NEGONE << (x))

#endif

/*--------------------------------------------------------------------------------- */

/* x is pixel position, where 0 is leftmost pixel in scanline.
 * if x is not in the long pointed at by row, set row to the value of temp, clear
 * temp, and clear all longs up to the one containing x.  Then set the bits
 * from x mod 32 through 31 in temp.
 */
#define CLEARUpToAndSetLoOrder( x, lastBit, row, temp )                         \
{                                                                                                   \
        if (x >= lastBit)                                                               \
        {                                                                                   \
                *row++ = temp;                                                          \
                temp = 0;                                                               \
                lastBit += 32;                                                          \
        }                                                                                   \
        while (x >= lastBit)                                                            \
        {                                                                                   \
                *row++ = 0;                                                             \
                lastBit += 32;                                                          \
        }                                                                                   \
        temp |= MASK_ON (32 + x - lastBit);                                             \
}

/* x is pixel position, where 0 is leftmost pixel in scanline.
 * if x is not in the long pointed at by row, set row to the value of temp, set
 * all bits in temp, and set all bits in all longs up to the one containing x.
 * Then clear the bits from x mod 32 through 31 in temp.
 */
#define SETUpToAndClearLoOrder( x, lastBit, row, temp )                         \
{                                                                                                   \
  if (x >= lastBit)              /*<4>*/                                        \
  {                                                                                             \
    *row++ = temp;                                                                          \
    temp = NEGONE;                                                                          \
    lastBit += 32;                                                                          \
  }                                                                                             \
  while (x >= lastBit)   /*<4>*/                                                    \
  {                                                                                             \
    *row++ = NEGONE;                                                                        \
    lastBit += 32;                                                                          \
  }                                                                                             \
     /* JJJ Peter BEGIN 11/06/90 */                     \
     /* temp &= (NEGONE << (lastBit - x));  */          \
        if ((lastBit - x) == 32)                        \
           temp &= 0x0;                                 \
        else                                            \
           temp &= MASK_OFF (lastBit - x);              \
     /* JJJ Peter END   11/06/90 */                     \
}

#define FILLONEROW( row, longsWide, line, lineWide, xMin )                      \
/* do a winding number fill of one row of a bitmap from two sorted arrays   \
of onTransitions and offTransitions.                                                \
*/                                                                                              \
{                                                                                               \
  register int16 moreOns, moreOffs;                                                     \
  register int16 *onTp, *offTp;                                                         \
  register uint32 temp;                                                                     \
  uint32 *rowEnd = row + longsWide;                                                     \
  int  windNbr, lastBit, on, off, x, stop;                                          \
                                                                                                    \
  lastBit = 32 + xMin;                                                                      \
  windNbr  = 0;                                                                                 \
  temp = 0;                                                                                     \
  moreOns = *line;                                                                              \
  onTp = line+1;                                                                                \
  offTp = line + lineWide - 1;                                                          \
  moreOffs = *offTp;                                                                            \
  offTp -= moreOffs;                                                                            \
                                                                                                    \
  on = *onTp ;                                                                                  \
  off = *offTp ;                                                                                \
  while (moreOns || moreOffs)                                                           \
  {                                                                                         \
        stop = 0 ;                                                                              \
      if (on < off)                                                                         \
      {                                                                                        \
          x = on ;                                                                              \
          stop = 1 ;                                                                            \
        }                                                                                           \
      if (on > off)                                                                         \
        {                                                                                           \
          x = off ;                                                                             \
          stop = -1 ;                                                                           \
        }                                                                                           \
                                                                                                    \
        if (stop)                                                                               \
        {                                                                                           \
            windNbr += stop ;                                                                   \
        if (windNbr == stop)                                                            \
             CLEARUpToAndSetLoOrder (x, lastBit, row, temp)                    \
        else                                                                                   \
                if (windNbr == 0)                                                           \
                SETUpToAndClearLoOrder (x, lastBit, row, temp)                  \
        }                                                                                           \
                                                                                                    \
        if (stop >= 0)                                                                          \
        {                                                                                           \
        --moreOns;                                                                         \
            if (moreOns)                                                                        \
           on = *(++onTp) ;                                                             \
            else                                                                                    \
                on = LARGENUM ;                                                             \
        }                                                                                           \
        if (stop <= 0)                                                                          \
        {                                                                                           \
        --moreOffs;                                                                        \
            if (moreOffs)                                                                       \
            off = *(++offTp) ;                                                          \
            else                                                                                    \
                off = LARGENUM ;                                                                \
       }                                                                                            \
  }                                                                                           \
  *row = temp;                                                                                  \
  while (++row < rowEnd) *row = 0;                                                      \
}

#if 0
#define FILLONEROW( row, longsWide, line, lineWide, xMin )                      \
/* do a winding number fill of one row of a bitmap from two sorted arrays   \
of onTransitions and offTransitions.                                                \
*/                                                                                              \
{                                                                                               \
  register int16 moreOns, moreOffs;                                                     \
  register int16 *onTp, *offTp;                                                         \
  register uint32 temp;                                                                     \
  uint32 *rowEnd = row + longsWide;                                                     \
  int  windNbr, lastBit, on, off;                                                       \
                                                                                                    \
  lastBit = 32 + xMin;                                                                      \
  windNbr  = 0;                                                                                 \
  temp = 0;                                                                                     \
  moreOns = *line;                                                                              \
  onTp = line+1;                                                                                \
  offTp = line + lineWide - 1;                                                          \
  moreOffs = *offTp;                                                                            \
  offTp -= moreOffs;                                                                            \
                                                                                                    \
  while (moreOns || moreOffs)                                                           \
  {                                                                                         \
    if (moreOns)                                                                        \
    {                                                                                           \
      on = *onTp;                                                                       \
      if (moreOffs)                                                                         \
      {                                                                                         \
        off = *offTp;                                                                   \
        if (on < off)                                                                   \
        {                                                                                   \
          --moreOns;                                                                        \
          ++onTp;                                                                           \
          ++windNbr;                                                                        \
          if (windNbr == 1)                                                             \
              CLEARUpToAndSetLoOrder (on, lastBit, row, temp)                   \
          else                                                                              \
            if (windNbr == 0)                                                           \
              SETUpToAndClearLoOrder (on, lastBit, row, temp)                   \
        }                                                                                   \
        else if (on > off)                                                              \
        {                                                                                   \
          --moreOffs;                                                                       \
          ++offTp;                                                                          \
          --windNbr;                                                                        \
          if (windNbr == 0)                                                             \
            SETUpToAndClearLoOrder (off, lastBit, row, temp)                    \
          else                                                                              \
            if (windNbr == -1)                                                          \
              CLEARUpToAndSetLoOrder (off, lastBit, row, temp)                  \
        }                                                                                   \
        else                                                                            \
        {                                                                                   \
          --moreOns;                                                                        \
          ++onTp;                                                                           \
          --moreOffs;                                                                       \
          ++offTp;                                                                          \
        }                                                                                   \
      }                                                                                         \
      else                                 /* no more offs left */         \
      {                                                                                         \
        --moreOns;                                                                      \
        ++onTp;                                                                         \
        ++windNbr;                                                                      \
        if (windNbr == 1)                                                               \
          CLEARUpToAndSetLoOrder (on, lastBit, row, temp)                       \
        else                                                                                    \
          if (windNbr == 0)                                                             \
            SETUpToAndClearLoOrder (on, lastBit, row, temp)                 \
      }                                                                                         \
    }                                                                                           \
    else                                   /* no more ons left */          \
    {                                                                                           \
      off = *offTp;                                                                         \
      --moreOffs;                                                                       \
      ++offTp;                                                                                  \
      --windNbr;                                                                                \
      if (windNbr == 0)                                                                     \
        SETUpToAndClearLoOrder (off, lastBit, row, temp)                    \
      else                                                                                      \
        if (windNbr == -1)                                                              \
          CLEARUpToAndSetLoOrder (off, lastBit, row, temp)                  \
    }                                                                                           \
  }                                                                                         \
  *row = temp;                                                                                  \
  while (++row < rowEnd) *row = 0;                                                      \
}
#endif

/* Winding number fill of nRows of a glyph beginning at rowM, using two sorted
arrays of onTransitions and offTransitions.
*/

PRIVATE void sc_wnNrowFill (int rowM, int nRows, sc_BitMapData *bbox)
{
  uint32  longsWide = bbox->wide >> 5;
  uint32  lineWide = bbox->nYchanges + 2;
  uint32 * rowB = bbox->bitMap;
  int16  * lineB = * (bbox->yBase + rowM + nRows - 1);
  int     xMin = bbox->bounds.xMin;
  while (nRows-- > 0)
  {
    uint32 * row = rowB;
    int16 * line = lineB;
    FILLONEROW (row, longsWide, line, lineWide, xMin)
    rowB += longsWide;
    lineB -= lineWide;
  }
}


#undef NEGONE


/* Sort the values stored in locations pBeg to pBeg+nVal in ascending order
*/
#define ISORT( pBeg, pVal )                                                             \
{                                                                                               \
  register int16 *pj = pBeg;                                                            \
  register int16 nVal = *pVal - 2;                                                      \
  for (; nVal >= 0; --nVal)                                                             \
  {                                                                                                 \
    register int16 v;                                                                   \
    register int16 *pk, *pi;                                                        \
                                                                                                    \
    pk = pj;                                                                                \
    pi = ++pj;                                                                              \
    v = *pj;                                                                                \
    while (*pk > v && pk >= pBeg)                                                       \
      *pi-- = *pk--;                                                                        \
    *pi = v;                                                                                \
  }                                                                                                 \
}

/* rwb 4/5/90 Sort OnTransition and OffTransitions in Xlines arrays */
PRIVATE void sortCols (sc_BitMapData *bbox)
{
  register int16 nrows = bbox->bounds.xMax - bbox->bounds.xMin - 1;
  register int16 *p = bbox->xLines;
  register uint16 n = bbox->nXchanges + 1;                        /*<9>*/

  for (; nrows >= 0; --nrows)
  {
    ISORT (p + 1, p);
    p += n;                                                                         /*<9>*/
    ISORT (p - *p, p);
    ++p;
  }
}


/* rwb 4/5/90 Sort OnTransition and OffTransitions in Ylines arrays */
PRIVATE void sortRows (sc_BitMapData *bbox, int16**lowRowP, int16**highRowP)
{
  register uint16 n = bbox->nYchanges + 1;                        /*<9>*/
  int16 * p, *pend;

  if (highRowP < lowRowP)
    return;
  p = *lowRowP;
  pend = *highRowP;
  do
  {
    ISORT (p + 1, p);
    p += n;                                                                                 /*<9>*/
    ISORT (p - *p, p);
    ++p;
  } while (p <= pend);
}

#ifndef IN_ASM

/* 4/4/90 Version that distinguishes between On transitions and Off transitions.
*/
/* 3/23/90
*       A procedure to find and mark all of the scan lines (both row and column) that are
* crossed by a vector.  Many different cases must be considered according to the direction
* of the vector, whether it is vertical or slanted, etc.  In each case, the vector is first
* examined to see if it starts on a scan-line.  If so, special markings are made and the
* starting conditions are adjusted.  If the vector ends on a scan line, the ending
* conditions must be adjusted.  Then the body of the case is done.
*       Special adjustments must be made when a vector starts or ends on a scan line. Whenever
* one vector starts on a scan line, the previous vector must have ended on a scan line.
* Generally, this should result in the line being marked as crossed only once (conceptually
* by the vector that starts on the line.  But, if the two lines form a vertex that
* includes the vertex in a colored region, the line should be marked twice.  If the
* vertex is also on a perpendicular scan line, the marked scan line should be marked once
* on each side of the perpendicular line.  If the vertex defines a point that is jutting
* into a colored region, then the line should not be marked at all. In order to make
* these vertex crossing decisions, the previous vector must be examined.
*/

/*      Because many vectors are short with respect to the grid for small resolutions, the
* procedure first looks for simple cases in which no lines are crossed.
*
* xb, x0, and x1 are x coordinates of previous point, current point and next point
* similaryly yb, y0 and y1
*       ybase points to an array of pointers, each of which points to an array containing
* information about the glyph contour crossings of a horizontal scan-line.  The first
* entry in these arrays is the number of ON-transition crossings, followed by the y
* coordinates of each of those crossings.  The last entry in each array is the number of
* OFF-transtion crossings, preceded by the Y coordinates for each of these crossings.
*       LocalSC.xBase contains the same information for the column scan lines.
*/

#define DROUND(a) ((a + HALFM) & INTPART)
#define RSH(a) (int16)(a>>PIXSHIFT)
#define LSH(a) ((int32)a<<PIXSHIFT)
#define LINE(a)   ( !((a & FRACPART) ^ HALF))
#define SET(p,val) {register int16 *row = *p; ++*row; *(row+*row)=val;}
#define OFFX(val) {register int16 *s = *LocalSC.px+LocalSC.wideX; ++*s; *(s-*s) = val;}
#define OFFY(val) {register int16 *s = *LocalSC.py+LocalSC.wideY; ++*s; *(s-*s) = val;}
#define BETWEEN(a,b,c) (a < b && b < c )
#define EQUAL(a,b,c) (a == b && b == c)
#define EPSILON 0x1

/*---------------------LINE ORIENTATION MACROS-------------------------------- */
#define TOP_TO_BOT  BETWEEN (y1,y0,yb)
#define  BOT_TO_TOP BETWEEN (yb,y0,y1)
#define LFT_TO_RGHT BETWEEN (xb,x0,x1)
#define RGHT_TO_LFT BETWEEN (x1,x0,xb)
#define     INTERIOR        (SCMR_Flags & F_INTERIOR)
#define HORIZ           (SCMR_Flags & F_V_LINEAR)
#define  VERT           (SCMR_Flags & F_H_LINEAR)
#define QUAD_1OR2   (SCMR_Flags & (F_Q1 | F_Q2))
#define QUAD_3OR4   (SCMR_Flags & (F_Q3 | F_Q4))
#define QUAD_2OR3   (SCMR_Flags & (F_Q2 | F_Q3))
#define QUAD_1OR4   (SCMR_Flags & (F_Q1 | F_Q4))
#define  QUAD_1     (SCMR_Flags & F_Q1)
#define  QUAD_2     (SCMR_Flags & F_Q2)
#define  QUAD_3     (SCMR_Flags & F_Q3)
#define  QUAD_4     (SCMR_Flags & F_Q4)

/*----------------------------------------------------------------------------- */
/* define the DDA table. */
/*----------------------------------------------------------------------------- */

void (* DDAFunctionTable [])(SCP0) = { DDA_1_Y, DDA_2_Y, DDA_3_Y,
                                                        DDA_4_Y, DDA_4_Y,
                                                        DDA_1_XY, DDA_2_XY, DDA_3_XY,
                                                        DDA_4_XY, DDA_4_XY }    ;

/*----------------------------------------------------------------------------- */
PRIVATE void sc_mark (SCP F26Dot6 *pntbx, F26Dot6 *pntby, F26Dot6 *pntx, F26Dot6 *pnty, F26Dot6 *pnte)
{
  int16 onrow, oncol, Shift;
  int16 * *pend;
  F26Dot6  x0, y0, x1, y1, xb, yb, rx0, ry0, rx1, ry1, dy, dx ;
  int32 rhi, rlo;

/*-----------------SET UP A FLAG BYTE AND EQUATES FOR IT--------------------- */

register int SCMR_Flags ;

#define  F_Q1                               0x0001
#define  F_Q2                               0x0002
#define  F_Q3                               0x0004
#define  F_Q4                               0x0008
#define  F_INTERIOR                     0x0010
#define  F_V_LINEAR                     0x0020
#define  F_H_LINEAR                     0x0040
#define  QUADRANT_BITS              (F_Q1 | F_Q2 | F_Q3 | F_Q4)
/*------------------------------------------------------------------------------ */

/*---------------------------------------------------------------------------------
** Except on the PC, this code supports banding when stub and drop out
** controls are not required. For these cases, return if the band will
** not include any part of the glyph.
**-------------------------------------------------------------------------------*/

#ifndef FSCFG_NO_BANDING
 if (LocalSC.marktype != DO_STUBS && LocalSC.highRowP < LocalSC.lowRowP)
     return ;
#endif

/*------------------------------------------------------------------------------*/





/*
//---------------------------------------------------------------------------------
// loop through all the points in the contour.
//---------------------------------------------------------------------------------
 */

x0 = *pntbx ;
y0 = *pntby ;
x1 = *pntx++ ;
y1 = *pnty++ ;

while (pnty <= pnte)
{
    xb = x0 ;
    yb = y0 ;
    x0 = x1 ;
    y0 = y1 ;
    x1 = *pntx++ ;
    y1 = *pnty++ ;

    /*
    //-----------------------------------------------------------------------------
    // get the next set of points.
    //-----------------------------------------------------------------------------

    //-----------------------------------------------------------------------------
    // scan convert this line.
    //-----------------------------------------------------------------------------
     */

    SCMR_Flags = 0 ;
    dy = y1 - y0  ;
    dx = x1 - x0 ;
    if (!dy && !dx)
        continue ;

      rx0 = DROUND (x0);
      LocalSC.jx = RSH (rx0);
      ry0 = DROUND (y0);
      LocalSC.jy = RSH (ry0);
      rx1 = DROUND (x1);
      LocalSC.endx = RSH (rx1);
      ry1 = DROUND (y1);
      LocalSC.endy = RSH (ry1);
      LocalSC.py = LocalSC.yBase + LocalSC.jy;
      pend = LocalSC.yBase + LocalSC.endy ;
      LocalSC.px = LocalSC.xBase + LocalSC.jx;
      onrow = false;
      oncol = false;

    /*------------------SET UP THE QUADRANT THAT THE LINE IS IN--------------------- */

    if (dx > 0 && dy >=0) SCMR_Flags |= F_Q1;
    else
        if (dx <= 0 && dy > 0)  SCMR_Flags |= F_Q2;
        else
            if (dx < 0 && dy <= 0) SCMR_Flags |= F_Q3;
            else SCMR_Flags |= F_Q4;

    /*---------------------------------------------------------------------------- */
    LocalSC.py = LocalSC.yBase + LocalSC.jy ;
    LocalSC.px = LocalSC.xBase + LocalSC.jx ;

    /*-----------------------------------------------------------------------------
    ** for platforms where we do banding, we will set onrow and oncol only
    ** if the starting point is in the band.
    **---------------------------------------------------------------------------*/
#ifndef FSCFG_NO_BANDING
    if (LocalSC.marktype == DO_STUBS || ((QUAD_1OR2 && LocalSC.py >= LocalSC.lowRowP) ||
                                  (QUAD_3OR4 && LocalSC.py <= LocalSC.highRowP)))
#endif
    {
        if LINE (y0) onrow = true ;
        if LINE (x0) oncol = true ;
    }

    /*------------------------------------------------------------------------------
    ** for the platforms where we do banding, find out if the band totaly
    ** excludes the current line.
    **----------------------------------------------------------------------------*/
#ifndef FSCFG_NO_BANDING

    if (LocalSC.marktype != DO_STUBS)
        if (QUAD_1OR2 && (LocalSC.py > LocalSC.highRowP || pend < LocalSC.lowRowP))
            continue ;
        else if (QUAD_3OR4 && (LocalSC.py < LocalSC.lowRowP || pend > LocalSC.highRowP))
           continue ;

#endif

    /*------------------------------------------------------------------------------ */
    /* compute some other flags. */
    /*---------------------------------------------------------------------------- */

    if ((long)(x0-xb)*dy < (long)(y0-yb)*dx)
        SCMR_Flags |= F_INTERIOR ;
    if (EQUAL (yb, y0, y1))
        SCMR_Flags |= F_V_LINEAR ;
    if (EQUAL (xb, x0, x1))
        SCMR_Flags |= F_H_LINEAR ;


    /*------------------------------------------------------------------------------ */
    /* Now handle the cases where the starting point falls on a row scan line  */
    /* and maybe also on a coloumn scan line. */
    /* */
    /* first consider the intersections with row scan lines only. After this we  */
    /* will consider the intersections with coloumn scan lines. It is not  */
    /* worth while to set the coloumn intersections yet, because in any case we */
    /* will have to set the intersetions when a vertex does not lie on a row  */
    /* but does lie on a coloumn. */
    /*------------------------------------------------------------------------------ */

    Shift = 0;
    if (onrow)
    {
        if (oncol) Shift = 1 ;

        if ((INTERIOR || VERT) && (((yb > y0) && QUAD_1OR2) || ((yb < y0) && QUAD_3OR4)))
        {
            SET (LocalSC.py, LocalSC.jx)
            OFFY (LocalSC.jx+Shift)
        }
        else
            if ((INTERIOR && QUAD_1OR2) || BOT_TO_TOP || (HORIZ && (xb > x0) && QUAD_1))
                SET (LocalSC.py, LocalSC.jx)
            else
                if ((INTERIOR && QUAD_3OR4) || TOP_TO_BOT || (HORIZ && (x0 > xb) && QUAD_3))
                    OFFY (LocalSC.jx+Shift)
    }
    /*---------------------------------------------------------------------------- */
    /* now handle the coloumn intersections.                 */
    /*---------------------------------------------------------------------------- */

    Shift = 0 ;
    if (oncol && LocalSC.marktype == DO_STUBS)
    {
        if (onrow) Shift = 1 ;

        if ((INTERIOR || HORIZ) && (((xb > x0) && QUAD_1OR4) || ((xb < x0) && QUAD_2OR3)))
        {
            SET (LocalSC.px, LocalSC.jy)
            OFFX (LocalSC.jy+Shift)
        }
        else
            if ((INTERIOR && QUAD_2OR3) || RGHT_TO_LFT || (VERT && (yb > y0) && QUAD_2))
                SET (LocalSC.px, LocalSC.jy)
            else
                if ((INTERIOR && QUAD_1OR4) || LFT_TO_RGHT || (VERT && (y0 > yb) && QUAD_4))
                    OFFX (LocalSC.jy+Shift)
    }
    /*---------------------------------------------------------------------------- */
    /* Now handle horizontal and vertical lines.                                                */
    /*                                                                                                  */
    /*-----------------------horizontal line---------------------------------------*/

    if (LocalSC.endy == LocalSC.jy)
        if (LocalSC.marktype != DO_STUBS)
            continue ;
        else
        {
            if (QUAD_2OR3)
            {
                if LINE (x1)
                    ++LocalSC.endx;
                pend = LocalSC.xBase + LocalSC.endx;
            --LocalSC.px;
            while (LocalSC.px >= pend)
                {
                    SET (LocalSC.px, LocalSC.jy)
                    --LocalSC.px;
            }
                continue ;
            }
            else
            {
                if (onrow && QUAD_1)
                    ++LocalSC.jy;
            if (oncol)
                    ++LocalSC.px;
                pend = LocalSC.xBase + LocalSC.endx;
                while (LocalSC.px < pend)
                {
                    OFFX (LocalSC.jy)
                    ++LocalSC.px;
                }
                continue;
            }
       }
    /*-----------------------vertical line---------------------------------------- */

    if (LocalSC.endx == LocalSC.jx)
    {
        if (QUAD_1OR2)
        {
            pend = LocalSC.yBase + LocalSC.endy ;
            /*------------------------------------------------------------------------
            ** adjust the ending condition when banding is bieng done.
            **-----------------------------------------------------------------------*/
#ifndef FSCFG_NO_BANDING
            if (LocalSC.marktype != DO_STUBS && pend > LocalSC.highRowP)
                pend = LocalSC.highRowP + 1 ;
#endif
            /*-----------------------------------------------------------------------*/

          if (onrow)
                ++LocalSC.py;
          while (LocalSC.py < pend)                                      /* note oncol can't be true */
          {

                /*-------------------------------------------------------------------
                ** take care of banding when we support it
                **------------------------------------------------------------------*/

#ifndef FSCFG_NO_BANDING
                if (LocalSC.py >= LocalSC.lowRowP)
#endif
                    SET (LocalSC.py, LocalSC.jx)
                ++LocalSC.py;
          }
          continue ;
        }
        else
        {
            if (QUAD_4 && oncol) ++LocalSC.jx ;
          if LINE (y1)
                ++LocalSC.endy;
          pend = LocalSC.yBase + LocalSC.endy;

            /*------------------------------------------------------------------------
            ** adjust the ending condition when banding is bieng done.
            **-----------------------------------------------------------------------*/
#ifndef FSCFG_NO_BANDING
            if (LocalSC.marktype != DO_STUBS && pend < LocalSC.lowRowP)
                pend = LocalSC.lowRowP ;
#endif
            /*-----------------------------------------------------------------------*/

          --LocalSC.py;
          while (LocalSC.py >= pend)
          {

                /*-------------------------------------------------------------------
                ** take care of banding when we support it
                **------------------------------------------------------------------*/

#ifndef FSCFG_NO_BANDING
                if (LocalSC.py <= LocalSC.highRowP)
#endif
                    OFFY (LocalSC.jx)
                --LocalSC.py;
          }
          continue ;
        }
    }
    /*------------------SET UP INITIAL CONDITIONS FOR THE DDA--------------------- */

    if (QUAD_1OR2)
    {
        LocalSC.incY    = LSH (dy) ;

        if (!onrow)
            rhi = multlong ((ry0 - y0 + HALF), dx) ;
        else
        {
            rhi = LSH (dx) ;
            ++LocalSC.jy;
            ++LocalSC.py;
        }

        if (QUAD_1)
        {
            LocalSC.incX    = LSH (dx) ;
            if (!oncol)
                rlo = multlong ((rx0 - x0 + HALF), dy) ;
            else
            {
                rlo = LocalSC.incY ;
                ++LocalSC.jx ;
                ++LocalSC.px ;
            }

            LocalSC.r = rhi - rlo ;
        }
        else                                                    /* 2nd quadrant */
        {
            LocalSC.incX    = -LSH (dx) ;
            if (!oncol)
                rlo = multlong ((rx0 - x0 - HALF), dy) ;
            else
                rlo = -LocalSC.incY ;
            if LINE (x1)
                ++LocalSC.endx ;

            LocalSC.r = rlo - rhi + EPSILON ;
        }
    }
    else                                                        /* 3rd and 4th Quadrants */
    {
        LocalSC.incY = -LSH (dy) ;

        if (!onrow)
            rhi = multlong ((ry0 - y0 - HALF), dx) ;
        else
            rhi = -LSH (dx) ;

        if (QUAD_3)
        {
            LocalSC.incX = -LSH (dx) ;
            if (!oncol)
                rlo = multlong ((rx0 - x0 - HALF), dy) ;
            else
                rlo = LocalSC.incY ;

            if LINE (y1) ++LocalSC.endy ;
            if LINE (x1) ++LocalSC.endx ;

            LocalSC.r = rhi - rlo ;
        }
        else                                                    /* 4th quadrant */
        {
            LocalSC.incX = LSH (dx) ;
            if (!oncol)
                rlo = multlong ((rx0 - x0 + HALF), dy) ;
            else
            {
                rlo = -LocalSC.incY ;
                LocalSC.jx++ ;
                LocalSC.px++ ;
            }

            if LINE (y1) ++LocalSC.endy ;
            LocalSC.r = rlo - rhi + EPSILON ;
        }
    }
    /*---------------------------------------------------------------------------- */
    /* set up the address of the DDA function   and call it.                                */
    /*---------------------------------------------------------------------------- */

    (* DDAFunctionTable [((SCMR_Flags & QUADRANT_BITS) >> 1) +
                                              LocalSC.marktype])(SCA0) ;

/*
//--------------------------------------------------------------------------------
// go on to the next line.
//--------------------------------------------------------------------------------
 */
}
}
/*-------------------END OF SC_MARK-------------------------------------------- */

/*---------------------------------------------------------------------------- */
/* DDA for 1st quadrant with markings for x and y scan lines */
/*---------------------------------------------------------------------------- */

void DDA_1_XY (SCP0)
{

    do
    {
        if (LocalSC.r > 0)
        {
            if (LocalSC.jx == LocalSC.endx) break ;
            OFFX (LocalSC.jy)
            LocalSC.px++ ;
            LocalSC.jx++ ;
            LocalSC.r -= LocalSC.incY ;
        }
        else
        {
            if (LocalSC.jy == LocalSC.endy) break ;
            SET (LocalSC.py, LocalSC.jx)
            LocalSC.jy++ ;
            LocalSC.py++ ;
            LocalSC.r += LocalSC.incX ;
        }
    } while (true) ;
}
/*---------------------------------------------------------------------------- */
/* DDA for 2nd quadrant with markings for x and y scan lines */
/*---------------------------------------------------------------------------- */

void DDA_2_XY (SCP0)

{
    do
    {
        if (LocalSC.r > 0)
        {
            if (LocalSC.jx == LocalSC.endx) break ;
            --LocalSC.jx ;
            --LocalSC.px ;
            SET (LocalSC.px, LocalSC.jy)
            LocalSC.r -= LocalSC.incY ;
         }
         else
         {
            if (LocalSC.jy == LocalSC.endy) break ;
            SET (LocalSC.py, LocalSC.jx)
            LocalSC.jy++ ;
            LocalSC.py++ ;
            LocalSC.r += LocalSC.incX ;
         }
    } while (true) ;
}
/*---------------------------------------------------------------------------- */
/* DDA for 3rd quadrant with markings for x and y scan lines */
/*---------------------------------------------------------------------------- */

void DDA_3_XY (SCP0)

{
    do
    {
        if (LocalSC.r > 0)
        {
            if (LocalSC.jx == LocalSC.endx) break ;
            --LocalSC.jx ;
            --LocalSC.px ;
            SET (LocalSC.px, LocalSC.jy)
            LocalSC.r -= LocalSC.incY ;
         }
         else
         {
            if (LocalSC.jy == LocalSC.endy) break ;
            LocalSC.jy-- ;
            LocalSC.py-- ;
            OFFY (LocalSC.jx) ;
            LocalSC.r += LocalSC.incX ;
         }
    } while (true) ;
}
/*---------------------------------------------------------------------------- */
/* DDA for 4th quadrant with markings for x and y scan lines */
/*---------------------------------------------------------------------------- */

void DDA_4_XY (SCP0)

{
    do
    {
        if (LocalSC.r > 0)
        {
            if (LocalSC.jx == LocalSC.endx) break ;
            OFFX (LocalSC.jy)
            LocalSC.px++ ;
            LocalSC.jx++ ;
            LocalSC.r -= LocalSC.incY ;
         }
         else
         {
            if (LocalSC.jy == LocalSC.endy) break ;
            LocalSC.jy-- ;
            LocalSC.py-- ;
            OFFY (LocalSC.jx) ;
            LocalSC.r += LocalSC.incX ;
         }
    } while (true) ;
}
/*---------------------------------------------------------------------------- */
/* DDA for 1st quadrant with markings for y scan lines only */
/*---------------------------------------------------------------------------- */

void DDA_1_Y (SCP0)

{
    do
    {
        if (LocalSC.r > 0)
        {
            if (LocalSC.jx == LocalSC.endx) return ;
            LocalSC.jx += 1 ;
            LocalSC.r -= LocalSC.incY ;
         }
         else
         {
            if (LocalSC.jy == LocalSC.endy) return ;
            /*------------------------------------------------------------------------
            ** for platforms for which we support banding, include extra code
            **----------------------------------------------------------------------*/
#ifndef FSCFG_NO_BANDING
            if (LocalSC.py > LocalSC.highRowP)
                return ;
            if (LocalSC.py >= LocalSC.lowRowP)
#endif
            /*----------------------------------------------------------------------*/
                SET (LocalSC.py, LocalSC.jx)
            LocalSC.jy++ ;
            LocalSC.py++ ;
            LocalSC.r += LocalSC.incX ;
         }
    } while (true) ;
}

/*---------------------------------------------------------------------------- */
/* DDA for 2nd quadrant with markings for y scan lines only */
/*---------------------------------------------------------------------------- */

void DDA_2_Y (SCP0)

{
    do
    {
        if (LocalSC.r > 0)
        {
            if (LocalSC.jx == LocalSC.endx) return ;
            LocalSC.jx -= 1 ;
            LocalSC.r -= LocalSC.incY ;
         }
         else
         {
            if (LocalSC.jy == LocalSC.endy) return ;
            /*------------------------------------------------------------------------
            ** for platforms for which we support banding, include extra code
            **----------------------------------------------------------------------*/
#ifndef FSCFG_NO_BANDING
            if (LocalSC.py > LocalSC.highRowP)
                return ;
            if (LocalSC.py >= LocalSC.lowRowP)
#endif
            /*----------------------------------------------------------------------*/
                SET (LocalSC.py, LocalSC.jx)
            LocalSC.jy++ ;
            LocalSC.py++ ;
            LocalSC.r += LocalSC.incX ;

         }
    } while (true) ;
}
/*---------------------------------------------------------------------------- */
/* DDA for 3rd quadrant with markings for y scan lines only */
/*---------------------------------------------------------------------------- */

void DDA_3_Y (SCP0)

{
    do
    {
        if (LocalSC.r > 0)
        {
            if (LocalSC.jx == LocalSC.endx) return ;
            LocalSC.jx -= 1 ;
            LocalSC.r -= LocalSC.incY ;
         }
         else
         {
            if (LocalSC.jy == LocalSC.endy) return ;
            LocalSC.jy-- ;
            LocalSC.py-- ;
            /*------------------------------------------------------------------------
            ** for platforms for which we support banding, include extra code
            **----------------------------------------------------------------------*/
#ifndef FSCFG_NO_BANDING
            if (LocalSC.py < LocalSC.lowRowP)
                return ;
            if (LocalSC.py <= LocalSC.highRowP)
#endif
            /*----------------------------------------------------------------------*/
            OFFY (LocalSC.jx)
            LocalSC.r += LocalSC.incX ;
         }
    } while (true) ;
}
/*---------------------------------------------------------------------------- */
/* DDA for 4th quadrant with markings for y scan lines only */
/*---------------------------------------------------------------------------- */

void DDA_4_Y (SCP0)

{
    do
    {
        if (LocalSC.r > 0)
        {
            if (LocalSC.jx == LocalSC.endx) return ;
            LocalSC.jx += 1 ;
            LocalSC.r -= LocalSC.incY ;
         }
         else
         {
            if (LocalSC.jy == LocalSC.endy) return ;
            LocalSC.jy-- ;
            LocalSC.py-- ;
            /*------------------------------------------------------------------------
            ** for platforms for which we support banding, include extra code
            **----------------------------------------------------------------------*/
#ifndef FSCFG_NO_BANDING
            if (LocalSC.py < LocalSC.lowRowP)
                return ;
            if (LocalSC.py <= LocalSC.highRowP)
#endif
            /*----------------------------------------------------------------------*/
            OFFY (LocalSC.jx)
            LocalSC.r += LocalSC.incX ;
         }
    } while (true) ;
}
/*------------------------END  OF DDAS ----------------------------------------- */

#undef  DROUND
#undef  RSH
#undef  LSH
#undef  LINE
#undef  SET
#undef  OFFY
#undef  BETWEEN
#undef  INTERIOR
#undef  TOP_TO_BOT
#undef  BOT_TO_TOP
#undef  LFT_TO_RGHT
#undef  RGHT_TO_LFT

#endif


/* new version 4/4/90 - winding number version assumes that the On transitions are
int the first half of the array, and the Off transitions are in the second half.  Also
assumes that the number of on transitions is in array[0] and the number of off transitions
is in array[n].
*/

/* New version 3/10/90
Using the crossing information, look for segments that are crossed twice.  First
do Y lines, then do X lines.  For each found segment, look at the three lines in
the more positive adjoining segments.  If there are at least two crossings
of these lines, there is a dropout that needs to be fixed, so fix it.  If the bit on
either side of the segment is on, quit; else turn the leastmost of the two pixels on.
*/

PRIVATE void sc_orSomeBits (sc_BitMapData *bbox, int32 scanKind)
{
  int16 ymin, ymax, xmin, xmax;
  register int16 **yBase, **xBase;                                                                                        /*<9>*/
  register int16 scanline, coordOn, coordOff, nIntOn, nIntOff;                            /*<9>*/
  uint32 * bitmapP, *scanP;
  int16  * rowPt, longsWide, *pOn, *pOff, *pOff2;
  int16 index, incY, incX;
  int   upper, lower;

  scanKind &= STUBCONTROL;
  ymin = bbox->bounds.yMin;
  ymax = bbox->bounds.yMax - 1;
  xmin = bbox->bounds.xMin;
  xmax = bbox->bounds.xMax - 1;
  xBase = bbox->xBase;
  yBase = bbox->yBase;
  longsWide = bbox->wide >> 5;
  if (longsWide == 1)
    bitmapP = bbox->bitMap + bbox->high - 1;
  else
    bitmapP = bbox->bitMap + longsWide * (bbox->high - 1);

/* First do Y scanlines
*/
  scanP = bitmapP;
  incY = bbox->nYchanges + 2;
  incX = bbox->nXchanges + 2;
  rowPt = * (yBase + ymin);
  for (scanline = ymin; scanline <= ymax; ++scanline)
  {
    nIntOn = *rowPt;
    nIntOff = * (rowPt + incY - 1);
    pOn = rowPt + 1;
    pOff = rowPt + incY - 1 - nIntOff;
    while (nIntOn--)
    {
      coordOn = *pOn++;
      index = nIntOff;
      pOff2 = pOff;
      while (index-- && ((coordOff = *pOff2++) < coordOn))
            ;

      if (coordOn == coordOff)  /* This segment was crossed twice  */
      {
            if (scanKind)
            {
                upper = nUpperXings (yBase, xBase, scanline, coordOn, incY - 2, incX - 2,  xmin, xmax + 1, ymax);
                lower = nLowerXings (yBase, xBase, scanline, coordOn, incY - 2, incX - 2,  xmin, xmax + 1, ymin);
                if (upper < 2 || lower < 2)
                    continue;
            }
            if (coordOn > xmax)
                invpixOn ((int16)(xmax - xmin), longsWide, scanP);
            else if (coordOn == xmin)
                invpixOn ((int16)0, longsWide, scanP);
            else
                invpixSegY ((int16)(coordOn - xmin - 1), longsWide, scanP);
      }
    }
    rowPt += incY;
    scanP -= longsWide;
  }
/* Next do X scanlines */
  rowPt = * (xBase + xmin);
  for (scanline = xmin ; scanline <= xmax; ++scanline)
  {
    nIntOn = *rowPt;
    nIntOff = * (rowPt + incX - 1);
    pOn = rowPt + 1;
    pOff = rowPt + incX - 1 - nIntOff;
    while (nIntOn--)
    {
      coordOn = *pOn++;
      index = nIntOff;
      pOff2 = pOff;
      while (index-- && ((coordOff = *pOff2++) < coordOn))
            ;
      if (coordOn == coordOff)
      {
            if (scanKind)
            {
                upper = nUpperXings (xBase, yBase, scanline, coordOn, incX - 2, incY - 2, ymin, ymax + 1, xmax);
                lower = nLowerXings (xBase, yBase, scanline, coordOn, incX - 2, incY - 2,  ymin, ymax + 1, xmin);
                if (upper < 2 || lower < 2)
                    continue;
            }
            if (coordOn > ymax)
                invpixOn ((int16)(scanline - xmin), longsWide, bitmapP - longsWide * (ymax - ymin));
            else if (coordOn == ymin)
                invpixOn ((int16)(scanline - xmin), longsWide, bitmapP);
            else
                invpixSegX ((int16)(scanline - xmin), longsWide, bitmapP - longsWide * (coordOn - ymin - 1));
      }
    }
    rowPt += incX;
  }
}


/* Pixel oring to fix dropouts   *** inverted bitmap version ***
See if the bit on either side of the Y line segment is on, if so return,
else turn on the leftmost bit.

Bitmap array is always K longs wide by H rows high.

Bit locations are numbered 0 to H-1 from top to bottom
and from 0 to 32*K-1 from left to right; bitmap pointer points to 0,0, and
all of the columns for one row are stored adjacently.
*/

PRIVATE void invpixSegY (int16 llx, uint16 k, uint32*bitmapP)
{
  uint32 maskL, maskR;


  llx += 1 ;
  MASK_INVPIX (maskR, llx & 0x1f);
  bitmapP += (llx >> 5);

  if (*bitmapP & maskR)
    return;

  if (llx &= 0x1f)
    MASK_INVPIX (maskL, llx - 1) ;
  else
  {
    MASK_INVPIX (maskL, 31);
  --bitmapP ;
  }
  *bitmapP |= maskL;

}


/* Pixel oring to fix dropouts   *** inverted bitmap version ***
See if the bit on either side of the X line segment is on, if so return,
else turn on the bottommost bit.

Temporarily assume bitmap is set up as in Sampo Converter.
Bitmap array is always K longs wide by H rows high.

For now, assume bit locations are numbered 0 to H-1 from top to bottom
and from 0 to 32*K-1 from left to right; and that bitmap pointer points to 0,0, and
all of the columns for one row are stored adjacently.
*/

PRIVATE void invpixSegX (int16 llx, uint16 k, uint32*bitmapP)
{
  register uint32 maskL;

  bitmapP -= k;
  MASK_INVPIX (maskL, llx & 0x1f);
  bitmapP += (llx >> 5);
  if (*bitmapP & maskL)
    return;
  bitmapP += k;
  *bitmapP |= maskL;
}


/* Pixel oring to fix dropouts    ***inverted bitmap version ***
This code is used to orin dropouts when we are on the boundary of the bitmap.
The bit at llx, lly is colored.

Temporarily assume bitmap is set up as in Sampo Converter.
Bitmap array is always K longs wide by H rows high.

For now, assume bit locations are numbered 0 to H-1 from top to bottom
and from 0 to 32*K-1 from left to right; and that bitmap pointer points to 0,0, and
all of the columns for one row are stored adjacently.
*/
PRIVATE void invpixOn (int16 llx, uint16 k, uint32*bitmapP)
{
  uint32 maskL;

  MASK_INVPIX (maskL, llx & 0x1f);
  bitmapP += (llx >> 5);
  *bitmapP |= maskL;
}


/* Initialize a two dimensional array that will contain the coordinates of
line segments that are intersected by scan lines for a simple glyph.  Return
a biased pointer to the array containing the row pointers, so that they can
be accessed without subtracting a minimum value.
        Always reserve room for at least 1 scanline and 2 crossings
*/
PRIVATE int16**sc_lineInit (int16*arrayBase, int16**rowBase, int16 nScanlines, int16 maxCrossings,
int16 minScanline)
{
  int16 * *bias;
  register short    count = nScanlines;
  if (count)
    --count;
  bias = rowBase - minScanline;
  maxCrossings += 1;
  for (; count >= 0; --count)
  {
    *rowBase++ = arrayBase;
    *arrayBase = 0;
    arrayBase += maxCrossings;
    *arrayBase++ = 0;
  }
  return bias;
}


/* Check the kth scanline (indexed from base) and count the number of onTransition and
 * offTransition contour crossings at the line segment val.  Count only one of each
 * kind of transition, so maximum return value is two.
 */
PRIVATE int nOnOff (int16**base, int k, int16 val, int nChanges)
{
  register int16*rowP = * (base + k);
  register int16*endP = (rowP + *rowP + 1);
  register int count = 0;
  register int16 v;

  while (++rowP < endP)
  {
    if ((v = *rowP) == val)
    {
      ++count;
      break;
    }
    if (v > val)
      break;
  }
  rowP = * (base + k) + nChanges + 1;
  endP = (rowP - *rowP - 1);
  while (--rowP > endP)
  {
    if ((v = *rowP) == val)
      return ++count;
    if (v < val)
      break;
  }
  return count;
}


/* 8/22/90 - added valMin and valMax checks */
/* See if the 3 line segments on the edge of the more positive quadrant are cut by at
 * least 2 contour lines.
 */

PRIVATE int nUpperXings (int16**lineBase, int16**valBase, int line, int16 val, int lineChanges, int valChanges, int valMin, int valMax, int lineMax)
{
  register int32 count = 0;

  if (line < lineMax)
    count += nOnOff (lineBase, line + 1, val, lineChanges);     /*<14>*/
  if (count > 1)
    return (int)count;          //@WIN
  else if (val > valMin)
    count += nOnOff (valBase, val - 1, (int16)(line + 1), valChanges);
  if (count > 1)
    return (int)count;          //@WIN
  else if (val < valMax)
    count += nOnOff (valBase, val, (int16)(line + 1), valChanges);
  return (int)count;            //@WIN
}


/* See if the 3 line segments on the edge of the more negative quadrant are cut by at
 * least 2 contour lines.
 */

PRIVATE int nLowerXings (int16**lineBase, int16**valBase, int line, int16 val, int lineChanges, int valChanges, int valMin, int valMax, int lineMin)
{
  register int32 count = 0;

  if (line > lineMin)
    count += nOnOff (lineBase, line - 1, val, lineChanges);     /*<14>*/
  if (count > 1)
    return (int)count;          //@WIN
  if (val > valMin)
    count += nOnOff (valBase, val - 1, (int16)line, valChanges);
  if (count > 1)
    return (int)count;          //@WIN
  if (val < valMax)
    count += nOnOff (valBase, val, (int16)line, valChanges);
  return (int)count;            //@WIN
}


/*
 * Finds the extrema of a character.
 *
 * PARAMETERS:
 *
 * bbox is the output of this function and it contains the bounding box.

*/
/* revised for new scan converter 4/90 rwb */
int FAR sc_FindExtrema (sc_CharDataType *glyphPtr, sc_BitMapData *bbox)
{
  register F26Dot6 *x, *y;                                                                        /*<9>*/
  register F26Dot6 tx, ty, prevx, prevy;
  F26Dot6  xmin, xmax, ymin, ymax;
  ArrayIndex    point, endPoint, startPoint;
  LoopCount     ctr;
  uint16        nYchanges, nXchanges, nx;
  int   posY, posX, firstTime = true;

  nYchanges = nXchanges = 0;
  xmin = xmax = ymin = ymax = 0;

  for (ctr = 0; ctr < glyphPtr->nc; ctr++)
  {
    endPoint = glyphPtr->ep[ctr];
    startPoint = glyphPtr->sp[ctr];
    x = & (glyphPtr->x[startPoint]);                                                 /*<9>*/
    y = & (glyphPtr->y[startPoint]);                                                 /*<9>*/
    if (startPoint == endPoint)
      continue; /* We need to do this for anchor points for composites */
    if (firstTime)
    {
      xmin = xmax = *x;                                                                       /* <9>*/
      ymin = ymax = *y;                                                                       /* <9>*/
      firstTime = false;
    }
    posY = (int) (*y >= (ty = * (y + endPoint - startPoint)));    /* <9>*/
    posX = (int) (*x >= (tx = * (x + endPoint - startPoint)));    /* <9>*/

    for (point = startPoint; point <= endPoint; ++point)
    {
      prevx = tx;
      prevy = ty;
      tx = *x++;                                                                                      /* <9>*/
      ty = *y++;                                                                                      /* <9>*/
      if (tx > prevx)
      {
    if (!posX)
    {
      ++nXchanges;
      posX = true;
    }
      }
      else if (tx < prevx)
      {
    if (posX)
    {
      ++nXchanges;
      posX = false;
    }
      }
      else if (ty == prevy)
      {                                                                                                       /*faster <9>*/
    LoopCount j = point - 2 - startPoint;
    register F26Dot6 *newx = x-3;
    register F26Dot6 *oldx = newx++;
    register F26Dot6 *newy = y-3;
    register F26Dot6 *oldy = newy++;
        register uint8 *newC = & (glyphPtr->onCurve[point-2]);
    register uint8 *oldC = newC++;
    * (newC + 1) |= ONCURVE;
    for (; j >= 0; --j)
    {
      *newx-- = *oldx--;
      *newy-- = *oldy--;
      *newC-- = *oldC--;
    }
    ++startPoint;
      }

      if (ty > prevy)
      {
    if (!posY)
    {
      ++nYchanges;
      posY = true;
    }
      }
      else if (ty < prevy)
      {
    if (posY)
    {
      ++nYchanges;
      posY = false;
    }
      }
      if (tx > xmax)
    xmax = tx;
      else if (tx < xmin)
    xmin = tx;
      if (ty > ymax)
    ymax = ty;
      else if (ty < ymin)
    ymin = ty;
    }
    glyphPtr->sp[ctr] = (int16)(startPoint < endPoint ? startPoint : endPoint);//@WIN
    if (nXchanges & 1)
      ++nXchanges;
    if (nYchanges & 1)
      ++nYchanges; /* make even */
                x = &(glyphPtr->x[startPoint]);
      /*<9>*/
                y = &(glyphPtr->y[startPoint]);
      /*<9>*/
  }

  xmax += HALF;
  xmax >>= PIXSHIFT;
  ymax += HALF;
  ymax >>= PIXSHIFT;
  xmin += HALFM;
  xmin >>= PIXSHIFT;
  ymin += HALFM;
  ymin >>= PIXSHIFT;

  if ( (F26Dot6)(int16)xmin != xmin || (F26Dot6)(int16)ymin != ymin || (F26Dot6)(int16)xmax != xmax || (F26Dot6)(int16)ymax != ymax )  /*<10>*/
    return POINT_MIGRATION_ERR;

  bbox->bounds.xMax = (int16)xmax; /* quickdraw bitmap boundaries  */
  bbox->bounds.xMin = (int16)xmin;
  bbox->bounds.yMax = (int16)ymax;
  bbox->bounds.yMin = (int16)ymin;

  bbox->high = (int16)ymax - (int16)ymin;
  nx = (int16)xmax - (int16)xmin;         /*  width is rounded up to be a long multiple*/
  bbox->wide = (nx + 31) & ~31;          /* also add 1 when already an exact long multiple*/

    /*------------------------------------------------------------------------------
    ** make the width atleast 32 pels wide so that we do not allocate zero
    ** memory for the bitmap
    **----------------------------------------------------------------------------*/
    if (bbox->wide == 0)
        bbox->wide = 32 ;
    /*----------------------------------------------------------------------------*/

  if (nXchanges == 0)
    nXchanges = 2;
  if (nYchanges == 0)
    nYchanges = 2;
  bbox->nXchanges = nXchanges;
  bbox->nYchanges = nYchanges;

  return NO_ERR;
}


/*
 * This function break up a parabola defined by three points (A,B,C) and breaks it
 * up into straight line vectors given a maximium error. The maximum error is
 * 1/resolution * 1/ERRDIV. ERRDIV is defined in sc.h.
 *
 *
 *         B *-_
 *          /   `-_
 *         /       `-_
 *        /           `-_
 *       /               `-_
 *      /                   `* C
 *   A *
 *
 * PARAMETERS:
 *
 * Ax, Ay contains the x and y coordinates for point A.
 * Bx, By contains the x and y coordinates for point B.
 * Cx, Cy contains the x and y coordinates for point C.
 * hX, hY are handles to the areas where the straight line vectors are going to be put.
 * count is pointer to a count of how much data has been put into *hX, and *hY.
 *
 * F (t) = (1-t)^2 * A + 2 * t * (1-t) * B + t * t * C, t = 0... 1 =>
 * F (t) = t * t * (A - 2B + C) + t * (2B - 2A) + A  =>
 * F (t) = alfa * t * t + beta * t + A
 * Now say that s goes from 0...N, => t = s/N
 * set: G (s) = N * N * F (s/N)
 * G (s) = s * s * (A - 2B + C) + s * N * 2 * (B - A) + N * N * A
 * => G (0) = N * N * A
 * => G (1) = (A - 2B + C) + N * 2 * (B - A) + G (0)
 * => G (2) = 4 * (A - 2B + C) + N * 4 * (B - A) + G (0) =
 *           3 * (A - 2B + C) + 2 * N * (B - A) + G (1)
 *
 * D (G (0)) = G (1) - G (0) = (A - 2B + C) + 2 * N * (B - A)
 * D (G (1)) = G (2) - G (1) = 3 * (A - 2B + C) + 2 * N * (B - A)
 * DD (G)   = D (G (1)) - D (G (0)) = 2 * (A - 2B + C)
 * Also, error = DD (G) / 8 .
 * Also, a subdivided DD = old DD/4.
 */
PRIVATE int sc_DrawParabola (F26Dot6 Ax,
F26Dot6 Ay,
F26Dot6 Bx,
F26Dot6 By,
F26Dot6 Cx,
F26Dot6 Cy,
F26Dot6 **hX,
F26Dot6 **hY,
unsigned *count,
int32 inGY)
{
  int      nsqs;
  register int32 GX, GY, DX, DY, DDX, DDY;


  register F26Dot6 *xp, *yp;
  register int32 tmp;
  int   i;

/* Start calculating the first and 2nd order differences */
  GX  = Bx; /* GX = Bx */
  DDX = (DX = (Ax - GX)) - GX + Cx; /* = alfa-x = half of ddx, DX = Ax - Bx */
  GY  = By; /* GY = By */
  DDY = (DY = (Ay - GY)) - GY + Cy; /* = alfa-y = half of ddx, DY = Ay - By */
/* The calculation is not finished but these intermediate results are useful */

  if (inGY < 0)
  {
/* calculate amount of steps necessary = 1 << GY */
/* calculate the error, GX and GY used a temporaries */
    GX  = DDX < 0 ? -DDX : DDX;
    GY  = DDY < 0 ? -DDY : DDY;
/* approximate GX = sqrt (ddx * ddx + ddy * ddy) = Euclididan distance, DDX = ddx/2 here */
    GX += GX > GY ? GX + GY : GY + GY; /* GX = 2*distance = error = GX/8 */

/* error = GX/8, but since GY = 1 below, error = GX/8/4 = GX >> 5, => GX = error << 5 */
#ifdef ERRSHIFT
    for (GY = 1; GX > (PIXELSIZE << (5 - ERRSHIFT)); GX >>= 2)
    {
#else
      for (GY = 1; GX > (PIXELSIZE << 5) / ERRDIV; GX >>= 2)
      {
#endif
    GY++; /* GY used for temporary purposes */
      }
/* Now GY contains the amount of subdivisions necessary, number of vectors == (1 << GY)*/
      if (GY > MAXMAXGY)
    GY = MAXMAXGY; /* Out of range => Set to maximum possible. */
      i = 1 << GY;
      if ((*count = *count + i)  > MAXVECTORS)
      {
/* Overflow, not enough space => return */
    return (1);
      }
    }
else {
  GY = inGY;
  i = 1 << GY;
}

if (GY > MAXGY)
{
  F26Dot6 MIDX, MIDY;

  DDX = GY - 1; /* DDX used as a temporary */
/* Subdivide, this is nummerically stable. */

  MIDX = (F26Dot6) (((long) Ax + Bx + Bx + Cx + 2) >> 2);
  MIDY = (F26Dot6) (((long) Ay + By + By + Cy + 2) >> 2);
  DX   = (F26Dot6) (((long) Ax + Bx + 1) >> 1);
  DY   = (F26Dot6) (((long) Ay + By + 1) >> 1);
  sc_DrawParabola (Ax, Ay, DX, DY, MIDX, MIDY, hX, hY, count, DDX);
  DX   = (F26Dot6) (((long) Cx + Bx + 1) >> 1);
  DY   = (F26Dot6) (((long) Cy + By + 1) >> 1);
  sc_DrawParabola (MIDX, MIDY, DX, DY, Cx, Cy, hX, hY, count, DDX);
  return 0;
}

nsqs = (int) (GY + GY); /* GY = n shift, nsqs = n*n shift */    //@WIN

/* Finish calculations of 1st and 2nd order differences */
DX   = DDX - (DX << ++GY); /* alfa + beta * n */
DDX += DDX;
DY   = DDY - (DY <<   GY);
DDY += DDY;

xp = *hX;
yp = *hY;

GY = (long) Ay << nsqs; /*  Ay * (n*n) */
GX = (long) Ax << nsqs; /*  Ax * (n*n) */
/* GX and GY used for real now */

/* OK, now we have the 1st and 2nd order differences,
           so we go ahead and do the forward differencing loop. */
tmp = 1L << (nsqs-1);
do {
  GX += DX;  /* Add first order difference to x coordinate */
  *xp++ = (GX + tmp) >> nsqs;
  DX += DDX; /* Add 2nd order difference to first order difference. */
  GY += DY;  /* Do the same thing for y. */
  *yp++ = (GY + tmp) >> nsqs;
  DY += DDY;
} while (--i);
*hX = xp; /* Done, update pointers, so that caller will know how much data we put in. */
*hY = yp;
return 0;
  }


#ifndef PC_OS
#ifndef FSCFG_BIG_ENDIAN
/*      SetUpMasks() loads two arrays of 32-bit masks at runtime so
 *      that the byte layout of the masks need not be CPU-specific
 *
 *      It is conditionally compiled because the arrays are unused
 *      in a Big-endian (Motorola) configuration and initialized
 *      at compile time for Intel order in the PC_OS (Windows)
 *      configuration.
 *
 *      We load the arrays by converting the Big-Endian value of
 *      the mask to the "native" representation of that mask.  The
 *      "native" representation can be applied to a "native" byte
 *      array to manipulate more than 8 bits at a time of an output
 *      bitmap.
 */
        static void SetUpMasks (void)
        {
            register int i;
            uint32 ulMaskI = (unsigned long)(-1L);
            uint32 ulInvPixMaskI = (unsigned long)(0x80000000L);

            for (i=0;  i<32;  i++, ulMaskI>>=1, ulInvPixMaskI>>=1)
            {
                aulMask[i] = (uint32) SWAPL(ulMaskI);
                aulInvPixMask[i] = (uint32) SWAPL(ulInvPixMaskI);
            }
            fMasksSetUp = true;
        }
#endif
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\bass\sfnt_en.h ===
/*
    File:       sfnt_en.h

    Written by: Mike Reed

    Copyright:  c 1989-1990 by Apple Computer, Inc., all rights reserved.

    Change History (most recent first):

        <8+>     7/16/90    MR      Fixed INTEL version of tag_GlyphData
         <8>     7/16/90    MR      Conditionalize redefinition of script codes
         <7>     7/13/90    MR      Conditionalize enums to allow for byte-reversal on INTEL chips
         <6>     6/30/90    MR      Remove tag reference to 'mvt ' and 'cryp'
         <4>     6/26/90    MR      Add all script codes, with SM naming conventions
         <3>     6/20/90    MR      Change tag enums to #defines to be ansi-correct
         <2>      6/1/90    MR      Add postscript name to sfnt_NameIndex and 'post' to tags.
    To Do:
*/

#ifndef SFNT_ENUNS

typedef enum {
    plat_Unicode,
    plat_Macintosh,
    plat_ISO,
    plat_MS
} sfnt_PlatformEnum;

#ifndef smRoman
typedef enum {
    smRoman,
    smJapanese,
    smTradChinese,
    smChinese = smTradChinese,
    smKorean,
    smArabic,
    smHebrew,
    smGreek,
    smCyrillic,
    smRussian = smCyrillic,
    smRSymbol,
    smDevanagari,
    smGurmukhi,
    smGujarati,
    smOriya,
    smBengali,
    smTamil,
    smTelugu,
    smKannada,
    smMalayalam,
    smSinhalese,
    smBurmese,
    smKhmer,
    smThai,
    smLaotian,
    smGeorgian,
    smArmenian,
    smSimpChinese,
    smTibetan,
    smMongolian,
    smGeez,
    smEthiopic = smGeez,
    smAmharic = smGeez,
    smSlavic,
    smEastEurRoman = smSlavic,
    smVietnamese,
    smExtArabic,
    smSindhi = smExtArabic,
    smUninterp
} sfnt_ScriptEnum;
#endif

typedef enum {
    lang_English,
    lang_French,
    lang_German,
    lang_Italian,
    lang_Dutch,
    lang_Swedish,
    lang_Spanish,
    lang_Danish,
    lang_Portuguese,
    lang_Norwegian,
    lang_Hebrew,
    lang_Japanese,
    lang_Arabic,
    lang_Finnish,
    lang_Greek,
    lang_Icelandic,
    lang_Maltese,
    lang_Turkish,
    lang_Yugoslavian,
    lang_Chinese,
    lang_Urdu,
    lang_Hindi,
    lang_Thai
} sfnt_LanguageEnum;

typedef enum {
    name_Copyright,
    name_Family,
    name_Subfamily,
    name_UniqueName,
    name_FullName,
    name_Version,
    name_Postscript
} sfnt_NameIndex;

typedef long sfnt_TableTag;

#ifdef PC_OS                    /* Constants defined in Intel order */
#define SFNT_SWAPTAG(tag)       (tag)   
#define tag_CharToIndexMap      0x70616d63        /* 'cmap' */
#define tag_ControlValue        0x20747663        /* 'cvt ' */
#define tag_Editor0             0x30746465        /* 'edt0' */
#define tag_Editor1             0x31746465        /* 'edt1' */
#define tag_Encryption          0x70797263        /* 'cryp' */
#define tag_FontHeader          0x64616568        /* 'head' */
#define tag_FontProgram         0x6d677066        /* 'fpgm' */
#define tag_GlyphDirectory      0x72696467        /* 'gdir' */
#define tag_GlyphData           0x66796c67        /* 'glyf' */
#define tag_HoriDeviceMetrics   0x786d6468        /* 'hdmx' */
#define tag_HoriHeader          0x61656868        /* 'hhea' */
#define tag_HorizontalMetrics   0x78746d68        /* 'hmtx' */
#define tag_IndexToLoc          0x61636f6c        /* 'loca' */
#define tag_Kerning             0x6e72656b        /* 'kern' */
#define tag_LSTH                0x4853544c        /* 'LTSH' */
#define tag_LinearThreeshold    0x4853544c        /* 'LTSH' */
#define tag_MaxProfile          0x7078616d        /* 'maxp' */
#define tag_NamingTable         0x656d616e        /* 'name' */
#define tag_OS_2                0x322f534f        /* 'OS/2' */
#define tag_Postscript          0x74736f70        /* 'post' */
#define tag_PreProgram          0x70657270        /* 'prep' */
#else                           /* Constants defined in Motorola order */
#define SFNT_SWAPTAG(tag)       SWAPL(tag)
#define tag_CharToIndexMap      0x636d6170        /* 'cmap' */
#define tag_ControlValue        0x63767420        /* 'cvt ' */
#define tag_Editor0             0x65647430        /* 'edt0' */
#define tag_Editor1             0x65647431        /* 'edt1' */
#define tag_Encryption          0x63727970        /* 'cryp' */
#define tag_FontHeader          0x68656164        /* 'head' */
#define tag_FontProgram         0x6670676d        /* 'fpgm' */
#define tag_GlyphDirectory      0x67646972        /* 'gdir' */
#define tag_GlyphData           0x676c7966        /* 'glyf' */
#define tag_HoriDeviceMetrics   0x68646d78        /* 'hdmx' */
#define tag_HoriHeader          0x68686561        /* 'hhea' */
#define tag_HorizontalMetrics   0x686d7478        /* 'hmtx' */
#define tag_IndexToLoc          0x6c6f6361        /* 'loca' */
#define tag_Kerning             0x6b65726e        /* 'kern' */
#define tag_LSTH                0x4c545348        /* 'LTSH' */
#define tag_LinearThreeshold    0x4c545348        /* 'LTSH' */
#define tag_MaxProfile          0x6d617870        /* 'maxp' */
#define tag_NamingTable         0x6e616d65        /* 'name' */
#define tag_OS_2                0x4f532f32        /* 'OS/2' */
#define tag_Postscript          0x706f7374        /* 'post' */
#define tag_PreProgram          0x70726570        /* 'prep' */
#endif

#endif      /* not sfnt_enums */

#define SFNT_ENUMS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\bass\sfnt.h ===
/*
    File:       sfnt.h

    Contains:   xxx put contents here (or delete the whole line) xxx

    Written by: xxx put name of writer here (or delete the whole line) xxx

    Copyright:  c 1988-1990 by Apple Computer, Inc., all rights reserved.

    Change History (most recent first):

         <3>    10/31/90    MR      Add bit-field option for integer or fractional scaling [rb]
         <2>    10/20/90    MR      Remove unneeded tables from sfnt_tableIndex. [rb]
        <12>     7/18/90    MR      platform and specific should always be unsigned
        <11>     7/14/90    MR      removed duplicate definitions of int[8,16,32] etc.
        <10>     7/13/90    MR      Minor type changes, for Ansi-C
         <9>     6/29/90    RB      revise postscriptinfo struct
         <7>      6/4/90    MR      Remove MVT
         <6>      6/1/90    MR      pad postscriptinfo to long word aligned
         <5>     5/15/90    MR      Add definition of PostScript table
         <4>      5/3/90    RB      mrr     Added tag for font program 'fpgm'
         <3>     3/20/90    CL      chucked old change comments from EASE
         <2>     2/27/90    CL      getting bbs headers
       <3.1>    11/14/89    CEL     Instructions are legal in components.
       <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
       <2.2>     8/14/89    sjk     1 point contours now OK
       <2.1>      8/8/89    sjk     Improved encryption handling
       <2.0>      8/2/89    sjk     Just fixed EASE comment
       <1.7>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
       <1.6>     6/13/89    SJK     Comment
       <1.5>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
                                    bug, correct transformed integralized ppem behavior, pretty much
                                    so
       <1.4>     5/26/89    CEL     EASE messed up on "c" comments
      <,1.3>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts

    To Do:
        <3+>     3/20/90    mrr     Added tag for font program 'fpgm'
*/

#ifndef SFNT_ENUMS
#include "sfnt_en.h"
#endif

typedef struct {
    uint32 bc;
    uint32 ad;
} BigDate;

typedef struct {
    sfnt_TableTag   tag;
    uint32          checkSum;
    uint32          offset;
    uint32          length;
} sfnt_DirectoryEntry;

/*
 *  The search fields limits numOffsets to 4096.
 */
typedef struct {
    int32 version;                  /* 0x10000 (1.0) */
    uint16 numOffsets;              /* number of tables */
    uint16 searchRange;             /* (max2 <= numOffsets)*16 */
    uint16 entrySelector;           /* log2 (max2 <= numOffsets) */
    uint16 rangeShift;              /* numOffsets*16-searchRange*/
    sfnt_DirectoryEntry table[1];   /* table[numOffsets] */
} sfnt_OffsetTable;
#define OFFSETTABLESIZE     12  /* not including any entries */

/*
 *  for the flags field
 */
#define Y_POS_SPECS_BASELINE            0x0001
#define X_POS_SPECS_LSB                 0x0002
#define HINTS_USE_POINTSIZE             0x0004
#define USE_INTEGER_SCALING             0x0008

#define SFNT_MAGIC 0x5F0F3CF5

#define SHORT_INDEX_TO_LOC_FORMAT       0
#define LONG_INDEX_TO_LOC_FORMAT        1
#define GLYPH_DATA_FORMAT               0

typedef struct {
    Fixed       version;            /* for this table, set to 1.0 */
    Fixed       fontRevision;       /* For Font Manufacturer */
    uint32      checkSumAdjustment;
    uint32      magicNumber;        /* signature, should always be 0x5F0F3CF5  == MAGIC */
    uint16      flags;
    uint16      unitsPerEm;         /* Specifies how many in Font Units we have per EM */

    BigDate     created;
    BigDate     modified;

    /** This is the font wide bounding box in ideal space
 (baselines and metrics are NOT worked into these numbers) **/
    FUnit       xMin;
    FUnit       yMin;
    FUnit       xMax;
    FUnit       yMax;

    uint16      macStyle;               /* macintosh style word */
    uint16      lowestRecPPEM;          /* lowest recommended pixels per Em */

    /* 0: fully mixed directional glyphs, 1: only strongly L->R or T->B glyphs,
       -1: only strongly R->L or B->T glyphs, 2: like 1 but also contains neutrals,
       -2: like -1 but also contains neutrals */
    int16       fontDirectionHint;

    int16       indexToLocFormat;
    int16       glyphDataFormat;
} sfnt_FontHeader;

typedef struct {
    Fixed       version;                /* for this table, set to 1.0 */

    FUnit       yAscender;
    FUnit       yDescender;
    FUnit       yLineGap;       /* Recommended linespacing = ascender - descender + linegap */
    uFUnit      advanceWidthMax;
    FUnit       minLeftSideBearing;
    FUnit       minRightSideBearing;
    FUnit       xMaxExtent; /* Max of (LSBi + (XMAXi - XMINi)), i loops through all glyphs */

    int16       horizontalCaretSlopeNumerator;
    int16       horizontalCaretSlopeDenominator;

    uint16      reserved0;
    uint16      reserved1;
    uint16      reserved2;
    uint16      reserved3;
    uint16      reserved4;

    int16       metricDataFormat;           /* set to 0 for current format */
    uint16      numberOf_LongHorMetrics;    /* if format == 0 */
} sfnt_HorizontalHeader;

typedef struct {
    Fixed       version;                /* for this table, set to 1.0 */
    uint16      numGlyphs;
    uint16      maxPoints;              /* in an individual glyph */
    uint16      maxContours;            /* in an individual glyph */
    uint16      maxCompositePoints;     /* in an composite glyph */
    uint16      maxCompositeContours;   /* in an composite glyph */
    uint16      maxElements;            /* set to 2, or 1 if no twilightzone points */
    uint16      maxTwilightPoints;      /* max points in element zero */
    uint16      maxStorage;             /* max number of storage locations */
    uint16      maxFunctionDefs;        /* max number of FDEFs in any preprogram */
    uint16      maxInstructionDefs;     /* max number of IDEFs in any preprogram */
    uint16      maxStackElements;       /* max number of stack elements for any individual glyph */
    uint16      maxSizeOfInstructions;  /* max size in bytes for any individual glyph */
    uint16      maxComponentElements;   /* number of glyphs referenced at top level */
    uint16      maxComponentDepth;      /* levels of recursion, 1 for simple components */
} sfnt_maxProfileTable;


typedef struct {
    uint16      advanceWidth;
    int16       leftSideBearing;
} sfnt_HorizontalMetrics;

/*
 *  CVT is just a bunch of int16s
 */
typedef int16 sfnt_ControlValue;

/*
 *  Char2Index structures, including platform IDs
 */
typedef struct {
    uint16  format;
    uint16  length;
    uint16  version;
} sfnt_mappingTable;

typedef struct {
    uint16  platformID;
    uint16  specificID;
    uint32  offset;
} sfnt_platformEntry;

typedef struct {
    uint16  version;
    uint16  numTables;
    sfnt_platformEntry platform[1]; /* platform[numTables] */
} sfnt_char2IndexDirectory;
#define SIZEOFCHAR2INDEXDIR     4

typedef struct {
    uint16 platformID;
    uint16 specificID;
    uint16 languageID;
    uint16 nameID;
    uint16 length;
    uint16 offset;
} sfnt_NameRecord;

typedef struct {
    uint16 format;
    uint16 count;
    uint16 stringOffset;
/*  sfnt_NameRecord[count]  */
} sfnt_NamingTable;


#define DEVEXTRA    2   /* size + max */
/*
 *  Each record is n+2 bytes, padded to long word alignment.
 *  First byte is ppem, second is maxWidth, rest are widths for each glyph
 */
typedef struct {
    int16               version;
    int16               numRecords;
    int32               recordSize;
    /* Byte widths[numGlyphs+2] * numRecords */
} sfnt_DeviceMetrics;


typedef struct {
    Fixed   version;                /* 1.0 */
    Fixed   italicAngle;
    FUnit   underlinePosition;
    FUnit   underlineThickness;
/* Falco, for meets the document 11/21/91 *****
        int16   isFixedPitch;
        int16   pad;
        *******************************************/
        uint32  isFixedPitch;
/* Falco add    END */
    uint32  minMemType42;
    uint32  maxMemType42;
    uint32  minMemType1;
    uint32  maxMemType1;
/* mark by Falco, 11/21/91 */
#if 0
    uint16  numberGlyphs;
    union
    {
      uint16  glyphNameIndex[1];   /* version == 2.0 */
      int8    glyphNameIndex25[1]; /* version == 2.5 */
    };
#endif
} sfnt_PostScriptInfo;

typedef struct {
    uint16  Version;
    int16   xAvgCharWidth;
    uint16  usWeightClass;
    uint16  usWidthClass;
    int16   fsType;
    int16   ySubscriptXSize;
    int16   ySubscriptYSize;
    int16   ySubscriptXOffset;
    int16   ySubscriptYOffset;
    int16   ySuperScriptXSize;
    int16   ySuperScriptYSize;
    int16   ySuperScriptXOffset;
    int16   ySuperScriptYOffset;
    int16   yStrikeOutSize;
    int16   yStrikeOutPosition;
    int16   sFamilyClass;
    uint8   Panose [10];
    uint32  ulCharRange [4];
    char    achVendID [4];
    uint16  usSelection;
    uint16  usFirstChar;
    uint16  usLastChar;
} sfnt_OS2;
/* various typedef to access to the sfnt data */

typedef sfnt_OffsetTable          FAR *sfnt_OffsetTablePtr;
typedef sfnt_FontHeader           FAR *sfnt_FontHeaderPtr;
typedef sfnt_HorizontalHeader     FAR *sfnt_HorizontalHeaderPtr;
typedef sfnt_maxProfileTable      FAR *sfnt_maxProfileTablePtr;
typedef sfnt_ControlValue         FAR *sfnt_ControlValuePtr;
typedef sfnt_char2IndexDirectory  FAR *sfnt_char2IndexDirectoryPtr;
typedef sfnt_HorizontalMetrics    FAR *sfnt_HorizontalMetricsPtr;
typedef sfnt_platformEntry        FAR *sfnt_platformEntryPtr;
typedef sfnt_NamingTable          FAR *sfnt_NamingTablePtr;
typedef sfnt_OS2                  FAR *sfnt_OS2Ptr;
typedef sfnt_DirectoryEntry       FAR *sfnt_DirectoryEntryPtr;
typedef sfnt_PostScriptInfo       FAR *sfnt_PostScriptInfoPtr;




/*
 * UNPACKING Constants
*/
#define ONCURVE             0x01
#define XSHORT              0x02
#define YSHORT              0x04
#define REPEAT_FLAGS        0x08 /* repeat flag n times */
/* IF XSHORT */
#define SHORT_X_IS_POS      0x10 /* the short vector is positive */
/* ELSE */
#define NEXT_X_IS_ZERO      0x10 /* the relative x coordinate is zero */
/* ENDIF */
/* IF YSHORT */
#define SHORT_Y_IS_POS      0x20 /* the short vector is positive */
/* ELSE */
#define NEXT_Y_IS_ZERO      0x20 /* the relative y coordinate is zero */
/* ENDIF */
/* 0x40 & 0x80              RESERVED
** Set to Zero
**
*/

/*
 * Composite glyph constants
 */
#define COMPONENTCTRCOUNT           -1      /* ctrCount == -1 for composite */
#define ARG_1_AND_2_ARE_WORDS       0x0001  /* if set args are words otherwise they are bytes */
#define ARGS_ARE_XY_VALUES          0x0002  /* if set args are xy values, otherwise they are points */
#define ROUND_XY_TO_GRID            0x0004  /* for the xy values if above is true */
#define WE_HAVE_A_SCALE             0x0008  /* Sx = Sy, otherwise scale == 1.0 */
#define NON_OVERLAPPING             0x0010  /* set to same value for all components */
#define MORE_COMPONENTS             0x0020  /* indicates at least one more glyph after this one */
#define WE_HAVE_AN_X_AND_Y_SCALE    0x0040  /* Sx, Sy */
#define WE_HAVE_A_TWO_BY_TWO        0x0080  /* t00, t01, t10, t11 */
#define WE_HAVE_INSTRUCTIONS        0x0100  /* instructions follow */

/*
 *  Private enums for tables used by the scaler.  See sfnt_Classify
 */
typedef enum {
    sfnt_fontHeader,
    sfnt_horiHeader,
    sfnt_indexToLoc,
    sfnt_maxProfile,
    sfnt_controlValue,
    sfnt_preProgram,
    sfnt_glyphData,
    sfnt_horizontalMetrics,
    sfnt_charToIndexMap,
    sfnt_fontProgram,
/* replace by Falco, 11/12/91 */
/*#ifdef PC_OS */
    sfnt_Postscript,
    sfnt_HoriDeviceMetrics,
    sfnt_LinearThreeShold,
    sfnt_Names,
    sfnt_OS_2,
/*#endif*/
#ifdef FSCFG_USE_GLYPH_DIRECTORY
    sfnt_GlyphDirectory,
#endif
    sfnt_NUMTABLEINDEX
} sfnt_tableIndex;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\at1.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
#define MAXHINT 100
#define STACKMAX 24

typedef enum    { X, Y, XY } DIR;

typedef struct  {
        ubyte   FAR *name; /*@WIN*/
        ufix32  offset;
        }      TABLE;

typedef struct  {
        fix32   x;
        fix32   y;
        }      CScoord;

typedef struct  {
        real32  x;
        real32  y;
        }      DScoord;

typedef struct  {
        fix32   CSpos;
        fix16   DSgrid;
        real32  scaling;
}       Hint;

typedef struct {
        Hint    HintCB[MAXHINT];
        fix16   Count;
}       HintTable;



#ifdef  LINT_ARGS

/* For font data access */
bool    at1_get_CharStrings(ubyte FAR *, fix16 FAR *, ubyte FAR * FAR *); /*@WIN*/
bool    at1_get_FontBBox(fix32 FAR *); /*@WIN*/
bool    at1_get_Blues( fix16 FAR *, fix32 FAR [] ); /*@WIN*/
bool    at1_get_BlueScale( real32 FAR * ); /*@WIN*/
bool    at1_get_Subrs( fix16, ubyte FAR * FAR *, fix16 FAR * ); /*@WIN*/
bool    at1_get_lenIV( fix FAR * ); /*@WIN*/

/* The functions in at1intpr.c for PDL to call */
void    at1_newFont( void );
bool    at1_newChar( ubyte FAR *, fix16 ); /*@WIN*/
bool    at1_interpreter( ubyte FAR *, fix16 ); /*@WIN*/

/* The functions in at1fs.c for at1intpr.c to call */
void    at1fs_newFont( void );
void    at1fs_newChar( void );
void    at1fs_matrix_fastundo( real32 FAR * ); /*@WIN*/
void    at1fs_BuildBlues( void );
void    at1fs_BuildStem( fix32, fix32, DIR );
void    at1fs_BuildStem3( fix32, fix32, fix32, fix32, fix32, fix32, DIR );
void    at1fs_transform( CScoord, DScoord FAR * ); /*@WIN*/

#else

/* For font data access */
bool    at1_get_CharStrings();
bool    at1_get_FontBBox();
bool    at1_get_Blues();
bool    at1_get_BlueScale();
bool    at1_get_Subrs();
bool    at1_get_lenIV();

/* The functions in at1intpr.c for PDL to call */
void    at1_newFont();
bool    at1_newChar();
bool    at1_interpreter();

/* The functions in at1fs.c for at1intpr.c to call */
void    at1fs_newFont();
void    at1fs_newChar();
void    at1fs_matrix_fastundo();
void    at1fs_BuildBlues();
void    at1fs_BuildStem();
void    at1fs_BuildStem3();
void    at1fs_transform();

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\bass\sc.h ===
/*
        File:           sc.h

        Contains:       xxx put contents here (or delete the whole line) xxx

        Written by:     xxx put name of writer here (or delete the whole line) xxx

        Copyright:      c 1987-1990 by Apple Computer, Inc., all rights reserved.

        Change History (most recent first):

                 <2>    12/10/90        RB              Change findextrema to return error code.[cel]
                 <7>     7/18/90        MR              ScanChar returns error code as int
                 <6>     7/13/90        MR              Minor cleanup on some comments
                 <5>     6/21/90        RB              add NODOCONTROL define
                 <4>      6/3/90        RB              add def of STUBCONTROL
                 <3>      5/3/90        RB              Almost completely new scanconverter.  Winding number fill,
                                                                        dropout control.

                 <2>     2/27/90        CL              Dropoutcontrol scanconverter and SCANCTRL[] instruction
           <3.0>         8/28/89        sjk             Cleanup and one transformation bugfix
           <2.2>         8/14/89        sjk             1 point contours now OK
           <2.1>          8/8/89        sjk             Improved encryption handling
           <2.0>          8/2/89        sjk             Just fixed EASE comment
           <1.7>          8/1/89        sjk             Added composites and encryption. Plus some enhancements.
           <1.6>         6/13/89        SJK             Comment
           <1.5>          6/2/89        CEL             16.16 scaling of metrics, minimum recommended ppem, point size 0
                                                                        bug, correct transformed integralized ppem behavior, pretty much
                                                                        so
           <1.4>         5/26/89        CEL             EASE messed up on "c" comments
          <,1.3>  5/26/89        CEL             Integrated the new Font Scaler 1.0 into Spline Fonts

        To Do:
*/
/* rwb - 4/19/90 Almost completely new scanconverter - winding number fill, dropout control
** 3.2  CKL 02/20/1990 Added another public prototype sc_MovePoints()
** 3.1  CKL     02/08/1990      Added ANSI-C prototypes.
*/

/*EASE$$$ READ ONLY COPY of file "sc.h"
** 3.0  sjk 08/28/1989 Cleanup and one transformation bugfix
** 2.2  sjk 08/14/1989 1 point contours now OK
** 2.1  sjk 08/08/1989 Improved encryption handling
** 2.0  sjk 08/02/1989 Just fixed EASE comment
** 1.7  sjk 08/01/1989 Added composites and encryption. Plus some enhancements.
** 1.6  SJK 06/13/1989 Comment
** 1.5  CEL 06/02/1989 16.16 scaling of metrics, minimum recommended ppem,
**              point size 0 bug, correct transformed integralized ppem behavior,
**              pretty much so
** 1.4  CEL 05/26/1989 EASE messed up on "c" comments
**,1.3   CEL 05/26/1989 Integrated the new Font Scaler 1.0 into Spline Fonts
** END EASE MODIFICATION HISTORY */
/*
 * This module scanconverts a shape defined by quadratic bezier splines
 *
 *  c Apple Computer Inc. 1987, 1988, 1989.
 *
 *
 * Released for alpha on January 31, 1989.
 *
 * History:
 * Work on this module began in the fall of 1987.
 * Written June 14, 1988 by Sampo Kaasila.
 *
 */

/* DO NOT change these constants without understanding implications:
   overflow, out of range, out of memory, quality considerations, etc... */

#define PIXELSIZE 64 /* number of units per pixel. It has to be a power of two */
#define PIXSHIFT   6 /* should be 2log of PIXELSIZE */
#define ERRDIV     16 /* maximum error is  (pixel/ERRDIV) */
#define ERRSHIFT 4  /* = 2log(ERRDIV), define only if ERRDIV is a power of 2 */
#define ONE 0x40                        /* constants for 26.6 arithmetic */
#define HALF 0x20
#define HALFM 0x1F                      /* one-half - one-sixtyfourth */
#define FRACPART 0x3F
#define INTPART -64
#define STUBCONTROL 0x10000
#define NODOCONTROL 0x20000

/* The maximum number of vectors a spline segment is broken down into
 * is 2 ^ MAXGY
 * MAXGY can at most be:
 * (31 - (input range to sc_DrawParabola 15 + PIXSHIFT = 21)) / 2
 */
#define MAXGY 5
#define MAXMAXGY 8 /* related to MAXVECTORS */

/* RULE OF THUMB: xPoint and yPoints will run out of space when
 *                MAXVECTORS = 176 + ppem/4 ( ppem = pixels per EM )  */
#define MAXVECTORS 257  /* must be at least 257  = (2 ^ MAXMAXGY) + 1  */

#define sc_outOfMemory 0x01 /* For the error field */
#define sc_freeBitMap  0x01 /* For the info field */

typedef struct {
        uint32          FAR *bitMap; /*@WIN*/
        int16           FAR *xLines, FAR *yLines, FAR * FAR *xBase, FAR * FAR *yBase;/*@WIN*/
        BBOX            bounds;
        uint16          nXchanges, nYchanges;
        uint16          high, wide;
} sc_BitMapData;
/* rwb 4/2/90  New definition of sc_BitMapData.

bitMap is high bits tall, and wide bits wide, but wide is rounded up to
a long.  The actual bitmap width is xMax - xMin. xMin and yMin represent the
rounded integer value of the minimum 26.6 coordinate, but j.5 is rounded down
to j rather than up to j+1.  xMax and yMax represent the rounded up integer
value of the maximum 26.6 coordinat, and j.5 does round up to j+1.  The actual
pixel center scan lines that are represented in the bitmap are xMin ... xMax-1
and yMin...to ...yMax-1.

nYchanges is the total number of times that all of the contours in a glyph changed
y direction.  It is always an even number, and represents the maximum number
of times that a row scan line can intersect the glyph.  Similarly, nXchanges
is the total number of x direction changes.

yLines is an array of arrays.  Each array corresoponds to one row scan line.  Each
array is nYchanges+2 entries long. The 0th entry contains the number of times that row
intersects the glyph contours in an On Transition and then the pixel columns where
the intersections occur.  These intersections are sorted from left to right.  The last
entry contains the number of OFF transition intersections, and the immediately
preceding entries contain the pixel column numbers where the intersections occur.
These are also sorted from left to right.  yBase is an array of
pointers; each pointer pointing to one of the arrays in yLines.

Similarly, xLines and xBase describe the intersection of column scan lines with
the glyph conotours.  These arrays are only used to fix dropouts.
*/

typedef struct {
    F26Dot6 xPoints[ MAXVECTORS ];   /* vectors */
    F26Dot6 yPoints[ MAXVECTORS ];
} sc_GlobalData;

typedef fnt_ElementType sc_CharDataType;

#if 0
typedef struct {
        F26Dot6 FAR *x, FAR *y;/*@WIN*/
        int16   ctrs;
        int16   padWord;        /* <4> */
        int16   FAR *sp, FAR *ep;/*@WIN*/
        int8    FAR *onC;/*@WIN*/
} sc_CharDataType;
#endif


/* Internal flags for the onCurve array */
#define OVERLAP 0x02 /* can not be the same as ONCURVE in sfnt.h */
#define DROPOUTCONTROL 0x04 /* can not be the same as ONCURVE in sfnt.h */

#ifndef ONCURVE
#include "sfnt.h"
#endif


/* PUBLIC PROTOTYPES */

/*
 * Returns the bitmap
 * This is the top level call to the scan converter.
 *
 * Assumes that (*handle)->bbox.xmin,...xmax,...ymin,...ymax
 * are already set by sc_FindExtrema()
 *
 * PARAMETERS:
 *
 * lowBand   is lowest scan line to be included in the band.
 * highBand  is the highest scan line to be included in the band.
 * if highBand < lowBand then no banding will be done.
 * Always keep lowBand and highband within range: [ymin, (ymin+1) ....... ymax];
 * scPtr->bitMap always points at the actual memory.
 * the first row of pixels above the baseLine is numbered 0, and the next one up is 1.
 * => the y-axis definition is the normal one with the y-axis pointing straight up.
 *
 */
extern int FAR sc_ScanChar(sc_CharDataType FAR *glyphPtr, sc_GlobalData FAR *scPtr,/*@WIN*/
                                sc_BitMapData FAR *bbox, int16 lowBand, int16 highBand, int32 scanControl);/*@WIN*/

/*
 * Finds the extrema of a character.
 *
 * PARAMETERS:
 *
 * bbox is the output of this function and it contains the bounding box.
 */

extern int FAR sc_FindExtrema(sc_CharDataType FAR *glyphPtr, sc_BitMapData FAR *bbox);/*@WIN*/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\at1font.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */


// DJC added global include
#include "psglobal.h"

#define    LINT_ARGS            /* @WIN */
#define    NOT_ON_THE_MAC       /* @WIN */
#define    KANJI                /* @WIN */

// DJC eliminate and put in compiler definitions
// #define    UNIX                 /* @WIN */

#undef     DBG0
#undef     DBG1

#include   "global.ext"

#include   "graphics.h"
#include   "graphics.ext"

#include   "at1.h"


bool    at1_get_CharStrings(key, size, string)
ubyte   FAR key[];          /* i: key name       @WIN */
fix16   FAR *size;          /* o: string length  @WIN */
ubyte   FAR * FAR *string;       /* o: string address @WIN */
{
    struct object_def nameobj = {0, 0, 0}, FAR *obj_got, FAR *ch_obj; /*@WIN*/

    ATTRIBUTE_SET(&nameobj, LITERAL);
    LEVEL_SET(&nameobj, current_save_level);

    /* Get CharStrings dict */
    if( !get_name(&nameobj, "CharStrings", 11, FALSE) ||
        !get_dict(&GSptr->font, &nameobj, &ch_obj) ) {
#ifdef DBG1
            printf( "at1 CharStrings dict not found\n" );
#endif
            ERROR(UNDEFINEDRESULT);
            return(FALSE);
    }

    if( !get_name(&nameobj, (byte FAR *)key, lstrlen((byte FAR *)key), FALSE) ||
        !get_dict(ch_obj, &nameobj, &obj_got) ) { /* strlen=>lstrlen @WIN*/
#ifdef DBG1
            printf( "at1 CharStrings (%s) not found\n", key );
#endif
            ERROR(UNDEFINEDRESULT);
            return(FALSE);
    }
    if (TYPE(obj_got) != STRINGTYPE) {
#ifdef DBG1
            printf( "at1 CharStrings (%s) bad type\n", key );
#endif
            ERROR(TYPECHECK);
            return(FALSE);
    }
    *size = (fix) LENGTH(obj_got);
    *string = (ubyte FAR *) VALUE(obj_got);     /*@WIN*/
#ifdef  DBG1
    {
    fix         jj;
    ubyte       FAR *cc;        /*@WIN*/
    cc = (ubyte FAR *) *string; /*@WIN*/
    printf("at1_get_CharStrings ==> %s\n", key);
    for (jj = 0; jj < *size; jj++)        {
        if (jj % 16  == 0)
            printf("\n");
        printf(" %02x", (ufix) cc[jj]);
        }
    }
    printf("\n");
#endif  /* DBG1 */
    return(TRUE);
} /* end at1_get_CharStrings() */

bool    at1_get_FontBBox(BBox)
fix32   FAR BBox[];         /* o: FontBBox values @WIN*/
{
    struct object_def nameobj = {0, 0, 0}, FAR *obj_got, FAR *bb, obj; /*@WIN*/
    long32                  val;
    fix                     i;
    bool    cal_num(struct object_def FAR *, long32 FAR *); /* added prototype @WIN*/

    ATTRIBUTE_SET(&nameobj, LITERAL);
    LEVEL_SET(&nameobj, current_save_level);

    /* Get FontBBox Array */
    if( !get_name(&nameobj, "FontBBox", 8, FALSE) ||
        !get_dict(&GSptr->font, &nameobj, &obj_got) ) {
            ERROR(INVALIDFONT);
            return(FALSE);
    }

    bb = (struct object_def FAR *) VALUE(obj_got);      /*@WIN*/
    if (TYPE(obj_got) == ARRAYTYPE)     {
        for (i = 0; i < 4; i++)     {
            if (!cal_num(&bb[i], (long32 FAR *)&val))   {       /*@WIN*/
                ERROR(TYPECHECK);
                return(FALSE);
            }
            else
                BBox[i] = (fix32) L2F(val);
        }
    } else if (TYPE(obj_got) == PACKEDARRAYTYPE)   { /* Packed Array */
        for (i = 0; i < 4; i++) {
            get_pk_object( get_pk_array( (ubyte FAR *)bb, (ufix16)i ), /*@WIN*/
                           &obj, LEVEL(obj_got) );
            if (!cal_num(&obj, (long32 FAR *)&val))   { /*@WIN*/
                ERROR(TYPECHECK);
                return(FALSE);
            }
            else
                BBox[i] = (fix32) L2F(val);
        }
    } else  {
        ERROR(TYPECHECK);
        return(FALSE);
    }
#ifdef  DBG0
    printf("at1_get_FontBBox==> ");
    printf("%hd %hd %hd %hd\n", BBox[0], BBox[1], BBox[2], BBox[3]);
#endif
    return(TRUE);
} /* end at1_get_FontBBox() */


#define MAXBLUEVALUES   14      /* max elements in BlueValues */
#define MAXOTHERBLUES   10      /* max elements in OtherBlues */

bool
at1_get_Blues( n_pairs, allblues )
fix16   FAR *n_pairs;   /*@WIN*/
fix32   FAR allblues[]; /*@WIN*/
{
        struct object_def    nameobj, FAR *privdict_got, FAR *bluearry_got; /*@WIN*/
        struct object_def    FAR *arry_valp;    /*@WIN*/
        fix                  ii, i_allblues, n_arryitems;

        *n_pairs = i_allblues = 0;

        ATTRIBUTE_SET( &nameobj, LITERAL );
        LEVEL_SET( &nameobj, current_save_level );

        /* get Private */
#     ifdef DBG0
        printf( "get Private -- at1_get_blues\n" );
#     endif
        if( !get_name( &nameobj, "Private", 7, FALSE ) ||
            !get_dict( &GSptr->font, &nameobj, &privdict_got ) )
        {
#         ifdef DBG0
            printf( "cannot get Private -- at1_get_Blues\n" );
#         endif
            ERROR( UNDEFINEDRESULT );
            return( FALSE );
        }

        /* get OtherBlues from Private */
#     ifdef DBG0
        printf( "get OtherBlues -- at1_get_blues\n" );
#     endif
        if( !get_name( &nameobj, "OtherBlues", 10, FALSE ) ||
            !get_dict( privdict_got, &nameobj, &bluearry_got ) )
        {
            n_arryitems = 0;
        }
        else
        {
            arry_valp = (struct object_def FAR *)VALUE( bluearry_got ); /*@WIN*/
            if( TYPE(bluearry_got) != ARRAYTYPE )
                n_arryitems = 0;
            else
                n_arryitems = MIN( LENGTH(bluearry_got), MAXOTHERBLUES );
        }

        /* check if all are integers and load onto allblues[] */
#     ifdef DBG0
        printf( "load OtherBlues %d -- at1_get_OtherBlues\n", n_arryitems );
#     endif
        n_arryitems = (n_arryitems / 2) * 2;        /* make it even */
        for( ii=0; ii<n_arryitems; ii++ )
        {
//DJC UPD052 the old code is commented out!
#ifdef DJC_OLD_CODE
            if( TYPE(&arry_valp[ii]) != INTEGERTYPE )
            {
#             ifdef DBG0
                printf( "invalid OtherBlues -- at1_get_Blues\n" );
#             endif
                ERROR( UNDEFINEDRESULT );
                return( FALSE );
            }
            allblues[ i_allblues++ ] = (fix32)VALUE( &arry_valp[ii] );
#endif
            //
            // UPD052, allow floating Blue values
            //
            if (TYPE(&arry_valp[ii]) == INTEGERTYPE) {
               allblues[ i_allblues++ ] = (fix32) VALUE(&arry_valp[ii]);
            } else if (TYPE(&arry_valp[ii]) == REALTYPE ) {
               allblues[ i_allblues++ ] = (fix32) F2L(VALUE(&arry_valp[ii]));
            } else {
               ERROR( UNDEFINEDRESULT );
               return( FALSE );
            }



#         ifdef DBG0
            printf( " OtherBlues[%d]=%d\n", ii, (fix)VALUE(&arry_valp[ii]) );
#         endif
        }

        /* get BlueValues from Private */
#     ifdef DBG0
        printf( "get BlueValues -- at1_get_blues\n" );
#     endif
        if( !get_name( &nameobj, "BlueValues", 10, FALSE ) ||
            !get_dict( privdict_got, &nameobj, &bluearry_got ) )
        {
            n_arryitems = 0;
        }
        else
        {
            arry_valp = (struct object_def FAR *)VALUE( bluearry_got ); /*@WIN*/
            if( TYPE(bluearry_got) != ARRAYTYPE )
                n_arryitems = 0;
            else
                n_arryitems = MIN( LENGTH(bluearry_got), MAXBLUEVALUES );
        }
        /* check if all are integers and load onto allblues[] */
#     ifdef DBG0
        printf( "load BlueValues %d -- at1_get_blues\n", n_arryitems );
#     endif
        n_arryitems = (n_arryitems / 2) * 2;        /* make it even */
        for( ii=0; ii<n_arryitems; ii++ )
        {
//Old code new code fixes UPD052
#ifdef DJC_OLD_CODE
            if( TYPE(&arry_valp[ii]) != INTEGERTYPE )
            {
#             ifdef DBG0
                printf( "invalid BlueValues -- at1_get_Blues\n" );
#             endif
                ERROR( UNDEFINEDRESULT );
                return( FALSE );
            }
            allblues[ i_allblues++ ] = (fix32)VALUE( &arry_valp[ii] );
#endif

            //
            // UPD052, allow floating Blue values
            //
            if (TYPE(&arry_valp[ii]) == INTEGERTYPE) {
               allblues[ i_allblues++ ] = (fix32) VALUE(&arry_valp[ii]);
            } else if (TYPE(&arry_valp[ii]) == REALTYPE ) {
               allblues[ i_allblues++ ] = (fix32) F2L(VALUE(&arry_valp[ii]));
            } else {
               ERROR( UNDEFINEDRESULT );
               return( FALSE );
            }



#         ifdef DBG0
            printf( " BlueValues[%d]=%d\n", ii, (fix)VALUE(&arry_valp[ii]) );
#         endif
        }

        /* load OtherBlues and BlueValues onto output allblues[] */
        *n_pairs = (fix16)(i_allblues / 2);
#     ifdef DBG0
        printf( "# of blues pairs = %d\n", *n_pairs );
#     endif
        return( TRUE );
}

bool
at1_get_BlueScale( bluescale )
real32  FAR *bluescale;         /*@WIN*/
{
        struct object_def nameobj = {0, 0, 0}, FAR *privdict_got, FAR *obj_got; /*@WIN*/

        ATTRIBUTE_SET( &nameobj, LITERAL );
        LEVEL_SET( &nameobj, current_save_level );

        /* get Private */
        if( !get_name( &nameobj, "Private", 7, FALSE ) ||
            !get_dict( &GSptr->font, &nameobj, &privdict_got ) )
        {
#         ifdef DBG0
            printf( "cannot get Private -- at1_get_BlueScale\n" );
#         endif
            ERROR( UNDEFINEDRESULT );
            return( FALSE );
        }

        /* get BlueScale from Private */
        if( get_name( &nameobj, "BlueScale", 9, FALSE ) &&
            get_dict( privdict_got, &nameobj, &obj_got ) )
        {
            if( TYPE(obj_got) == REALTYPE )
            {
#             ifdef DBG0
                printf( " BlueScale = %f\n", L2F( VALUE(obj_got) ) );
#             endif
                *bluescale = L2F( VALUE(obj_got) );
                return( TRUE );
            }
            else if( TYPE(obj_got) == INTEGERTYPE )
            {
#             ifdef DBG0
                printf( " BlueScale = %d\n", (fix)VALUE(obj_got) );
#             endif
                *bluescale = (real32)VALUE(obj_got);
                return( TRUE );
            }
        }

#     ifdef DBG0
        printf( " No BlueScale\n" );
#     endif
        *bluescale = (real32)0.0;
        return( FALSE );
}

bool
at1_get_Subrs( subrnum, subrcontent, subrlen )
    fix16   subrnum;
    ubyte FAR *  FAR *subrcontent;      /*@WIN*/
    fix16   FAR *subrlen;               /*@WIN*/
{
        struct object_def    nameobj, FAR *privdict_got, FAR *obj_got; /*@WIN*/
        struct object_def    FAR *subr_valp;    /*@WIN*/

        *subrcontent = (ubyte FAR *)0;  /*@WIN*/
        *subrlen     = 0;

        ATTRIBUTE_SET( &nameobj, LITERAL );
        LEVEL_SET( &nameobj, current_save_level );

        /* get Private */
        if( !get_name( &nameobj, "Private", 7, FALSE ) ||
            !get_dict( &GSptr->font, &nameobj, &privdict_got ) )
        {
#         ifdef DBG0
            printf( "cannot get Private -- at1_get_Subrs\n" );
#         endif
            ERROR( UNDEFINEDRESULT );
            return( FALSE );
        }

        /* get Subrs from Private */
        if( !get_name( &nameobj, "Subrs", 5, FALSE ) ||
            !get_dict( privdict_got, &nameobj, &obj_got ) )
        {
#             ifdef DBG0
                printf( " no Subrs in Private\n" );
#             endif
                return( FALSE );
        }

        if( TYPE(obj_got) != ARRAYTYPE ||
            (fix16)LENGTH(obj_got) <= subrnum ||        //@WIN
            subrnum < 0 )
        {
#          ifdef DBG0
             printf( " bad Subrs type, or no such (%d) entry\n", subrnum );
#          endif
             return( FALSE );
        }

        subr_valp = (struct object_def FAR *)VALUE( obj_got ); /*@WIN*/
        subr_valp += subrnum;
        if( TYPE( subr_valp ) != STRINGTYPE )
        {
#         ifdef DBG0
             printf( " bad Subr[%d] type\n", subrnum );
#         endif
             return( FALSE );
        }

        *subrcontent = (ubyte FAR *)VALUE( subr_valp ); /*@WIN*/
        *subrlen     = (fix16)LENGTH( subr_valp );
#     ifdef DBG0
        printf( " Subrs[%d] = 0x%x of %d bytes\n",
                  subrnum, (ufix)*subrcontent, *subrlen );
#     endif
#     ifdef DBG1
        {
             fix         jj;
             for (jj = 0; jj < *subrlen; jj++)
             {
                 if (jj % 16  == 0)
                    printf("\n");
                 printf(" %02x", (ufix) subrcontent[jj]);
             }
             printf("\n");
        }
#     endif /* DBG1 */

        return( TRUE );
} /* end at1_get_Subrs() */

bool
at1_get_lenIV( lenIV )
fix     FAR *lenIV;     /*@WIN*/
{
        struct object_def nameobj = {0, 0, 0}, FAR *privdict_got, FAR *obj_got; /*@WIN*/

        ATTRIBUTE_SET( &nameobj, LITERAL );
        LEVEL_SET( &nameobj, current_save_level );

        *lenIV = 4;

        /* get Private */
        if( !get_name( &nameobj, "Private", 7, FALSE ) ||
            !get_dict( &GSptr->font, &nameobj, &privdict_got ) )
        {
#         ifdef DBG0
            printf( "cannot get Private -- at1_get_BlueScale\n" );
#         endif
            ERROR( UNDEFINEDRESULT );
            return( FALSE );
        }

        /* get lenIV from Private */
        if( get_name( &nameobj, "lenIV", 5, FALSE ) &&
            get_dict( privdict_got, &nameobj, &obj_got ) )
        {
            if( TYPE(obj_got) == INTEGERTYPE )
            {
#             ifdef DBG0
                printf( " lenIV = %d\n", (fix)VALUE(obj_got) );
#             endif
                *lenIV = (fix)VALUE(obj_got);
                return( TRUE );
            }
        }

#     ifdef DBG0
        printf( " No lenIV\n" );
#     endif
        *lenIV = 4;
        return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\bass\sfnt.c ===
/*
    File:       sfnt.c

    Contains:   xxx put contents here (or delete the whole line) xxx

    Written by: xxx put name of writer here (or delete the whole line) xxx

    Copyright:  c 1989-1990 by Apple Computer, Inc., all rights reserved.

    Change History (most recent first):

       <17+>     10/9/90    MR,rb   Remove classification of unused tables in sfnt_Classify
        <17>     8/10/90    MR      Pass nil for textLength parameter to MapString2, checked in
                                    other files to their precious little system will BUILD.  Talk
                                    about touchy!
        <16>     8/10/90    gbm     rolling out Mike's textLength change, because he hasn't checked
                                    in all the relevant files, and the build is BROKEN!
        <15>     8/10/90    MR      Add textLength arg to MapString2
        <14>     7/26/90    MR      don't include toolutil.h
        <13>     7/23/90    MR      Change computeindex routines to call functins in MapString.c
        <12>     7/18/90    MR      Add SWAPW macro for INTEL
        <11>     7/13/90    MR      Lots of Ansi-C stuff, change behavior of ComputeMapping to take
                                    platform and script
         <9>     6/27/90    MR      Changes for modified format 4: range is now times two, loose pad
                                    word between first two arrays.  Eric Mader
         <8>     6/21/90    MR      Add calls to ReleaseSfntFrag
         <7>      6/5/90    MR      remove vector mapping functions
         <6>      6/4/90    MR      Remove MVT
         <5>      5/3/90    RB      simplified decryption.
         <4>     4/10/90    CL      Fixed mapping table routines for double byte codes.
         <3>     3/20/90    CL      Joe found bug in mappingtable format 6 Added vector mapping
                                    functions use pointer-loops in sfnt_UnfoldCurve, changed z from
                                    int32 to int16
         <2>     2/27/90    CL      New error code for missing but needed table. (0x1409)  New
                                    CharToIndexMap Table format.
                                    Assume subtablenumber zero for old sfnt format.  Fixed
                                    transformed component bug.
       <3.2>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
                                    phantom points are in, even for components in a composite glyph.
                                    They should also work for transformations. Device metric are
                                    passed out in the output data structure. This should also work
                                    with transformations. Another leftsidebearing along the advance
                                    width vector is also passed out. whatever the metrics are for
                                    the component at it's level. Instructions are legal in
                                    components. Instructions are legal in components. Glyph-length 0
                                    bug in sfnt.c is fixed. Now it is legal to pass in zero as the
                                    address of memory when a piece of the sfnt is requested by the
                                    scaler. If this happens the scaler will simply exit with an
                                    error code ! Fixed bug with instructions in components.
       <3.1>     9/27/89    CEL     Removed phantom points.
       <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
       <2.2>     8/14/89    sjk     1 point contours now OK
       <2.1>      8/8/89    sjk     Improved encryption handling
       <2.0>      8/2/89    sjk     Just fixed EASE comment
       <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
       <1.4>     6/13/89    SJK     Comment
       <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
                                    bug, correct transformed integralized ppem behavior, pretty much
                                    so
       <1.2>     5/26/89    CEL     EASE messed up on "c" comments
      <y1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
       <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

    To Do:
        <3+>     3/20/90    mrr     Fixed mapping table routines for double byte codes.
                                    Added support for font program.
                                    Changed count from uint16 to int16 in vector char2index routines.
*/

// DJC DJC.. added global include
#include "psglobal.h"

// DJC added to resolve externals
#include <setjmp.h>
#define BYTEREAD

/** FontScaler's Includes **/
#include "fserror.h"
#include "fscdefs.h"
#include "fontmath.h"
#include "sfnt.h"
#include "fnt.h"
#include "sc.h"
#include "fsglue.h"
#include "privsfnt.h"
/*#include "MapString.h" */

/** SFNT Packed format **/
typedef struct {
  int         numberContours;
  int16       FAR * endPoints;             /** vector: indexes into x[], y[] **/
  uint8       FAR * flags;                 /** vector **/
  BBOX        bbox;
} sfnt_PackedSplineFormat;


/* #define GetUnsignedByte( p ) *(((uint8  *)p)++) */
#define GetUnsignedByte( p ) ((uint8)(*p++))

/** <4> **/
#define fsg_MxCopy(a, b)    (*(b) = *(a))

#define PRIVATE

/* PRIVATE PROTOTYES */
/* Falco skip the parameter, 11/12/91 */
/* Turn prototype on again; @WIN */
int sfnt_UnfoldCurve (fsg_SplineKey*key, sfnt_PackedSplineFormat*charData, unsigned length, unsigned *elementCount);

void sfnt_Classify (fsg_SplineKey *key, sfnt_DirectoryEntryPtr dir);
uint16 sfnt_ComputeUnkownIndex (uint8 FAR * mapping, uint16 charCode);
uint16 sfnt_ComputeIndex0 (uint8 FAR * mapping, uint16 charCode);
uint16 sfnt_ComputeIndex2 (uint8 FAR * mapping, uint16 charCode);
uint16 sfnt_ComputeIndex4 (uint8 FAR * mapping, uint16 charCode);
uint16 sfnt_ComputeIndex6 (uint8 FAR * mapping, uint16 charCode);
void sfnt_GetGlyphLocation (fsg_SplineKey* key, uint16 gIndex, uint32* offset, unsigned* length);
voidPtr sfnt_GetDataPtr (fsg_SplineKey *key, uint32 offset, unsigned length, sfnt_tableIndex n);


uint16 (*sfnt_Format2Proc [])(uint8 FAR * mapping, uint16 charCode) = { sfnt_ComputeIndex0, sfnt_ComputeUnkownIndex, sfnt_ComputeUnkownIndex, sfnt_ComputeUnkownIndex, sfnt_ComputeIndex4, sfnt_ComputeUnkownIndex, sfnt_ComputeIndex6 };
/*
int sfnt_UnfoldCurve ();
void sfnt_Classify ();
uint16 sfnt_ComputeUnkownIndex ();
uint16 sfnt_ComputeIndex0 ();
uint16 sfnt_ComputeIndex2 ();
uint16 sfnt_ComputeIndex4 ();
uint16 sfnt_ComputeIndex6 ();
void sfnt_GetGlyphLocation ();
voidPtr sfnt_GetDataPtr ();
uint16 (*sfnt_Format2Proc [])() = { sfnt_ComputeIndex0, sfnt_ComputeUnkownIndex, sfnt_ComputeUnkownIndex, sfnt_ComputeUnkownIndex, sfnt_ComputeIndex4, sfnt_ComputeUnkownIndex, sfnt_ComputeIndex6 };
*/
/* end */

#ifdef SEGMENT_LINK
#pragma segment SFNT_C
#endif


/*
 *
 *  sfnt_UnfoldCurve            <3>
 *
 *  ERROR:  return NON-ZERO
 *
 */

#ifndef IN_ASM

/* replace by Falco for imcompatibility, 11/12/91 */
/*PRIVATE int     sfnt_UnfoldCurve (fsg_SplineKey*key,
sfnt_PackedSplineFormat*charData,
unsigned length,
unsigned *elementCount)*/
PRIVATE int     sfnt_UnfoldCurve ( key, charData, length, elementCount )
fsg_SplineKey           *key;
sfnt_PackedSplineFormat *charData;
unsigned                length;
unsigned                *elementCount;
/* replace end */
{
  /* @INTEL960 BEGIN D.S. Tseng 10/04/91 */
  /* register int z; */
  register int16 z;
  /* @INTEL960 END   D.S. Tseng 10/04/91 */
  register uint8 flag, *byteP, *byteP2;
  register uint8  FAR *p;
  register F26Dot6 *cpPtr;
  fnt_ElementType * elementPtr;
  int numPoints;

  elementPtr  = & (key->elementInfoRec.interpreterElements[GLYPHELEMENT]);

  if (*elementCount == GLYPHELEMENT)
  {
    key->totalContours = 0;
    fsg_SetUpElement (key, GLYPHELEMENT);
  }
  else
  {
      /* # of points in previous component */
    fsg_IncrementElement (key, GLYPHELEMENT, key->numberOfRealPointsInComponent, elementPtr->nc);
  }
  key->totalComponents = (uint16)(*elementCount);

 (*elementCount)++;
  key->glyphLength = length;
  if (length <= 0)
  {
    elementPtr->nc = 1;
    key->totalContours += 1;

    elementPtr->sp[0] = 0;
    elementPtr->ep[0] = 0;

    elementPtr->onCurve[0] = ONCURVE;
    elementPtr->oox[0] = 0;
    elementPtr->ooy[0] = 0;
    return NO_ERR; /***************** exit here ! *****************/
  }

  elementPtr->nc = (int16)(charData->numberContours);
  z = (int) elementPtr->nc;
  key->totalContours += z;
  if (z < 0 || z > (int)key->maxProfile.maxContours)
    return CONTOUR_DATA_ERR;

  {   /* <4> */
    register int16*sp = elementPtr->sp;
    register int16*ep = elementPtr->ep;
    int16 FAR * charDataEP = charData->endPoints;
    register LoopCount i;
    *sp++ = 0;
    *ep = SWAPWINC (charDataEP);
    for (i = z - 2; i >= 0; --i)
    {
      *sp++ = *ep++ + 1;
      *ep = SWAPWINC (charDataEP);
    }
    numPoints = *ep + 1;
  }

/* Do flags */
  p = charData->flags;
  byteP = elementPtr->onCurve;
  byteP2 = byteP + numPoints;         /* only need to set this guy once */
  while (byteP < byteP2)
  {
    *byteP++ = flag = GetUnsignedByte (p);
    if (flag & REPEAT_FLAGS)
    {
      register LoopCount count = GetUnsignedByte (p);
      while (count--)
      {
        *byteP++ = flag;
      }
    }
  }

/* Do X first */
  z = 0;
  byteP = elementPtr->onCurve;
  cpPtr = elementPtr->oox;
  while (byteP < byteP2)
  {
    if ((flag = *byteP++) & XSHORT)
    {
      if (flag & SHORT_X_IS_POS)
        z += GetUnsignedByte (p);
      else
        z -= GetUnsignedByte (p);
    }
    else if (! (flag & NEXT_X_IS_ZERO))
    { /* This means we have a int32 (2 byte) vector */
#ifdef BYTEREAD
      z += (int) ((int8)(*p++) << 8);
      z += (uint8) * p++;
#else
      z += * ((int16 FAR *)p);
      p += sizeof (int16);
#endif
    }
    *cpPtr++ = (F26Dot6) z;
  }

/* Now Do Y */
  z = 0;
  byteP = elementPtr->onCurve;
  cpPtr = elementPtr->ooy;
  while (byteP < byteP2)
  {
    if ((flag = *byteP) & YSHORT)
    {
      if (flag & SHORT_Y_IS_POS)
        z += GetUnsignedByte (p);
      else
        z -= GetUnsignedByte (p);
    }
    else if (! (flag & NEXT_Y_IS_ZERO))
    { /* This means we have a int32 (2 byte) vector */
#ifdef BYTEREAD
      z += (int) ((int8)(*p++) << 8);
      z += (uint8) * p++;
#else
      z += * ((int16 FAR *)p);
      p += sizeof (int16);
#endif
    }
    *cpPtr++ = z;

    *byteP++ = flag & (uint8)ONCURVE; /* Filter out unwanted stuff */
  }

  key->numberOfRealPointsInComponent = numPoints;
  if (numPoints > (int) key->maxProfile.maxPoints)
    return POINTS_DATA_ERR;

  if (! (key->compFlags & NON_OVERLAPPING))
  {
    elementPtr->onCurve[0] |= OVERLAP;
  }

  return NO_ERR;
}


/*
 * Internal routine (make this an array and do a look up?)
 */
/* replace by Falco for imcompatibility, 11/12/91 */
/*PRIVATE void sfnt_Classify (register fsg_SplineKey *key,
register sfnt_DirectoryEntryPtr dir)*/
PRIVATE void sfnt_Classify ( key, dir )
register fsg_SplineKey *key;
register sfnt_DirectoryEntryPtr dir;
/* replace end */
{
  ArrayIndex  Index = -1;

  switch (SFNT_SWAPTAG(dir->tag))
  {
    case tag_FontHeader:
      Index = sfnt_fontHeader;
      break;
    case tag_HoriHeader:
      Index = sfnt_horiHeader;
      break;
    case tag_IndexToLoc:
      Index = sfnt_indexToLoc;
      break;
    case tag_MaxProfile:
      Index = sfnt_maxProfile;
      break;
    case tag_ControlValue:
      Index = sfnt_controlValue;
      break;
    case tag_PreProgram:
      Index = sfnt_preProgram;
      break;
    case tag_GlyphData:
      Index = sfnt_glyphData;
      break;
    case tag_HorizontalMetrics:
      Index = sfnt_horizontalMetrics;
      break;
    case tag_CharToIndexMap:
      Index = sfnt_charToIndexMap;
      break;
    case tag_FontProgram:
      Index = sfnt_fontProgram;      /* <4> */
      break;
/* replace by Falco, 11/14/91 */
/*#ifdef PC_OS*/
    case tag_Postscript:
      Index = sfnt_Postscript;
      break;
    case tag_HoriDeviceMetrics:
      Index = sfnt_HoriDeviceMetrics;
      break;
    case tag_LinearThreeshold:
      Index = sfnt_LinearThreeShold;
      break;
    case tag_NamingTable:
      Index = sfnt_Names;
      break;
    case tag_OS_2:
      Index = sfnt_OS_2;
      break;
/*#endif*/
#ifdef FSCFG_USE_GLYPH_DIRECTORY
    case tag_GlyphDirectory:
      Index = sfnt_GlyphDirectory;
      break;
#endif
  }
  if (Index >= 0)
  {
    key->offsetTableMap[Index].Offset = SWAPL (dir->offset);
    key->offsetTableMap[Index].Length = (unsigned) SWAPL (dir->length);
  }
}

#endif


/*
 * Creates mapping for finding offset table     <4>
 */
/* replace by Falco for imcompatibility, 11/12/91 */
/*void FAR sfnt_DoOffsetTableMap (register fsg_SplineKey *key)*/
void FAR sfnt_DoOffsetTableMap ( key )
register fsg_SplineKey *key;
/* replace end */
{
  register LoopCount i;
  sfnt_OffsetTablePtr sfntDirectory;
  uint32 sizeofDirectory;

  if (sfntDirectory = (sfnt_OffsetTablePtr) GETSFNTFRAG (key, key->clientID, 0, sizeof (sfnt_OffsetTable)))
  if (sfntDirectory)
  {
    sizeofDirectory = sizeof (sfnt_OffsetTable) + sizeof (sfnt_DirectoryEntry) * (SWAPW(sfntDirectory->numOffsets) - 1);
    RELEASESFNTFRAG(key, sfntDirectory);
    sfntDirectory = (sfnt_OffsetTablePtr) GETSFNTFRAG (key, key->clientID, 0, sizeofDirectory);
  }

  if (!sfntDirectory)
    fs_longjmp (key->env, NULL_SFNT_DIR_ERR); /* Do a gracefull recovery  */

    /* Initialize */
//MEMSET (key->offsetTableMap, 0, sizeof (key->offsetTableMap)); @WIN
  MEMSET ((LPSTR)key->offsetTableMap, 0, sizeof (key->offsetTableMap));
  {
    LoopCount last = (LoopCount) SWAPW (sfntDirectory->numOffsets) - 1;
    register sfnt_DirectoryEntryPtr dir = &sfntDirectory->table[last];
    for (i = last; i >= 0; --i, --dir)
      sfnt_Classify (key, dir);
  }

  RELEASESFNTFRAG(key, sfntDirectory);
}

/*
 * Use this function when only part of the table is needed.
 *
 * n is the table number.
 * offset is within table.
 * length is length of data needed.
 * To get an entire table, pass length = -1     <4>
 */

/* replace by Falco for imcompatibility, 11/12/91 */
/*voidPtr sfnt_GetTablePtr (register fsg_SplineKey *key, register sfnt_tableIndex n, register boolean mustHaveTable)*/
voidPtr sfnt_GetTablePtr ( key, n, mustHaveTable )
register fsg_SplineKey *key;
register sfnt_tableIndex n;
register boolean mustHaveTable;
/* replace end */
{
  unsigned      length = key->offsetTableMap[n].Length;
  register voidPtr fragment;
  int           Ret;

  if (length)
  {
    if (fragment = GETSFNTFRAG (key, key->clientID, key->offsetTableMap[n].Offset, length))
      return fragment;
    else
      Ret = CLIENT_RETURNED_NULL;
  }
  else
  {
    if (mustHaveTable)
      Ret = MISSING_SFNT_TABLE; /* Do a gracefull recovery  */
    else
      return (voidPtr) 0;
  }

  fs_longjmp (key->env, Ret); /* Do a gracefull recovery  */

  // having called longjmp, we should never reach this: this line to make compiler happy
  return((voidPtr) 0);
}

/* replace by Falco for imcompatibility, 11/12/91 */
/*PRIVATE voidPtr sfnt_GetDataPtr (register fsg_SplineKey *key,
register uint32 offset,
register unsigned length,
register sfnt_tableIndex n)*/
PRIVATE voidPtr sfnt_GetDataPtr ( key, offset, length, n )
register fsg_SplineKey *key;
register uint32 offset;
register unsigned length;
register sfnt_tableIndex n;
/* replace end */
{
  register voidPtr fragment;
  register int     Ret;

  if (key->offsetTableMap[n].Length)
  {
    if (fragment = GETSFNTFRAG (key, key->clientID, offset + key->offsetTableMap[n].Offset, length))
      return fragment;
    else
      Ret = CLIENT_RETURNED_NULL; /* Do a gracefull recovery  */
  }
  else
    Ret = MISSING_SFNT_TABLE;

  fs_longjmp (key->env, Ret); /* Do a gracefull recovery  */

  // having called longjmp, we should never reach this: this line to make compiler happy
  return((voidPtr) 0);
}


/*
 * This, is when we don't know what is going on
 */
/* replace by Falco for imcompatibility, 11/12/91 */
/*PRIVATE uint16 sfnt_ComputeUnkownIndex (uint8 FAR * mapping, uint16 gi)*/
PRIVATE uint16 sfnt_ComputeUnkownIndex ( mapping, gi )
uint8 FAR * mapping;
uint16 gi;
/* replace end */
{
  return 0;
}


/*
 * Byte Table Mapping 256->256          <4>
 */
#ifndef IN_ASM
/* replace by Falco for imcompatibility, 11/12/91 */
/*PRIVATE uint16 sfnt_ComputeIndex0 (uint8 FAR * mapping, register uint16 charCode)*/
PRIVATE uint16 sfnt_ComputeIndex0 ( mapping, charCode )
uint8 FAR * mapping;
register uint16 charCode;
/* replace end */
{
  return (charCode < 256 ? mapping[charCode] : 0);
}

/*
 * High byte mapping through table
 *
 * Useful for the national standards for Japanese, Chinese, and Korean characters.
 *
 * Dedicated in spirit and logic to Mark Davis and the International group.
 *
 *  Algorithm: (I think)
 *      First byte indexes into KeyOffset table.  If the offset is 0, keep going, else use second byte.
 *      That offset is from beginning of data into subHeader, which has 4 words per entry.
 *          entry, extent, delta, range
 *
 */

typedef struct {
  uint16  firstCode;
  uint16  entryCount;
  int16   idDelta;
  uint16  idRangeOffset;
} sfnt_subHeader;

typedef struct {
  uint16  subHeadersKeys [256];
  sfnt_subHeader  subHeaders [1];
} sfnt_mappingTable2;

/* replace by Falco for imcompatibility, 11/12/91 */
/*PRIVATE uint16 sfnt_ComputeIndex2 (uint8 FAR * mapping, uint16 charCode)*/
PRIVATE uint16 sfnt_ComputeIndex2 ( mapping, charCode )
uint8 FAR * mapping;
uint16 charCode;
/* replace end */
{
  register uint16 index, mapMe;
  uint16   highByte;
  sfnt_mappingTable2 FAR *Table2 = (sfnt_mappingTable2 FAR *) mapping;
  sfnt_subHeader FAR *subHeader;

/* mapping */
  index = 0;  /* Initially assume missing */
  highByte = charCode >> 8;

  if (Table2->subHeadersKeys [highByte])
    mapMe = charCode & 0xff; /* We also need the low byte. */
  else
    mapMe = highByte;

  subHeader = (sfnt_subHeader FAR *) ((char FAR *) &Table2->subHeaders + SWAPW (Table2->subHeadersKeys [highByte]));

  mapMe -= SWAPW (subHeader->firstCode);         /* Subtract first code. */
  if (mapMe < (uint16)SWAPW (subHeader->entryCount))    //@WIN
  {  /* See if within range. */
    uint16 glyph;

    if (glyph = * ((uint16 FAR *) ((char FAR *) &subHeader + SWAPW (subHeader->idRangeOffset)) + mapMe))
      index = glyph + (uint16) SWAPW (subHeader->idDelta);
  }
  return index;
}


#define maxLinearX2 16
#define BinaryIteration \
        newP = (uint16 FAR *) ((int8 FAR *)tableP + (range >>= 1)); \
        if (charCode > (uint16) SWAPW (*newP)) tableP = newP;

/*
 * Segment mapping to delta values, Yack.. !
 *
 * In memory of Peter Edberg. Initial code taken from code example supplied by Peter.
 */
/* replace by Falco for imcompatibility, 11/12/91 */
/*PRIVATE uint16 sfnt_ComputeIndex4 (uint8 FAR * mapping, register uint16 charCode) */
PRIVATE uint16 sfnt_ComputeIndex4 ( mapping, charCode )
uint8 FAR * mapping;
register uint16 charCode;
/* replace end */
{
  register uint16 FAR *tableP;
  register uint16 idDelta;
  register uint16 offset, segCountX2, index;

/* mapping */
  tableP = (uint16 FAR *)mapping;

  index = 0; /* assume missing initially */
  segCountX2 = SWAPWINC (tableP);

  if (segCountX2 < maxLinearX2)
  {
    tableP += 3; /* skip binary search parameters */
  }
  else
  {
/* start with unrolled binary search */
    register uint16 FAR *newP;
    register int16  range;      /* size of current search range */
    register uint16 selector;   /* where to jump into unrolled binary search */
    register uint16 shift;      /* for shifting of range */

    range       = SWAPWINC (tableP); /* == 2**floor (log2 (segCount)) == largest power of two <= segCount */
    selector    = SWAPWINC (tableP); /* == 2* log2 (range) */
    shift       = SWAPWINC (tableP); /* == 2* (segCount-range) */
/* tableP points at endCount[] */

    if (charCode >= (uint16) SWAPW (* ((uint16 FAR *) ((int8 FAR *)tableP + range))))
      tableP = (uint16 FAR *) ((int8 FAR *)tableP + shift); /* range to low shift it up */
    switch (selector >> 1)
    {
    case 15:
      BinaryIteration;
    case 14:
      BinaryIteration;
    case 13:
      BinaryIteration;
    case 12:
      BinaryIteration;
    case 11:
      BinaryIteration;
    case 10:
      BinaryIteration;
    case 9:
      BinaryIteration;
    case 8:
      BinaryIteration;
    case 7:
      BinaryIteration;
    case 6:
      BinaryIteration;
    case 5:
      BinaryIteration;
    case 4:
      BinaryIteration;
    case 3:
    case 2:  /* drop through */
    case 1:
    case 0:
      break;
    }
  }
/* Now do linear search */
  for (; charCode > (uint16) SWAPW (*tableP); tableP++)
    ;

tableP++;  /*??? Warning this is to fix a bug in the font */

/* End of search, now do mapping */

  tableP = (uint16 FAR *) ((int8 FAR *)tableP + segCountX2); /* point at startCount[] */
  if (charCode >= (uint16) SWAPW (*tableP))
  {
    offset = charCode - (uint16) SWAPW (*tableP);
    tableP = (uint16 FAR *) ((int8 FAR *)tableP + segCountX2); /* point to idDelta[] */
    idDelta = (uint16) SWAPW (*tableP);
    tableP = (uint16 FAR *) ((int8 FAR *)tableP + segCountX2); /* point to idRangeOffset[] */
    if ((uint16) SWAPW (*tableP) == 0)
    {
      index   = charCode + idDelta;
    }
    else
    {
      offset += offset; /* make word offset */
      tableP  = (uint16 FAR *) ((int8 FAR *)tableP + (uint16) SWAPW (*tableP) + offset); /* point to glyphIndexArray[] */
      index   = (uint16) SWAPW (*tableP) + idDelta;
    }
  }
  return index;
}


/*
 * Trimmed Table Mapping
 */

typedef struct {
  uint16  firstCode;
  uint16  entryCount;
  uint16  glyphIdArray [1];
} sfnt_mappingTable6;

/* replace by Falco for imcompatibility, 11/12/91 */
/*PRIVATE uint16 sfnt_ComputeIndex6 (uint8 FAR * mapping, uint16 charCode) */
PRIVATE uint16 sfnt_ComputeIndex6 ( mapping, charCode )
uint8 FAR * mapping;
uint16 charCode;
/* replace end */
{
  register sfnt_mappingTable6 FAR *Table6 = (sfnt_mappingTable6 FAR *) mapping;

/* mapping */
  charCode  -= SWAPW (Table6->firstCode);
  return (charCode < (uint16) SWAPW (Table6->entryCount) ? (uint16) SWAPW (Table6->glyphIdArray [charCode]) : 0);
}

#endif




/*
 * Sets up our mapping function pointer.
 */
#ifndef IN_ASM

// DJC
// modified this definition to use ANSI args
int     sfnt_ComputeMapping ( register fsg_SplineKey *key,
                              uint16  platformID,
                              uint16 specificID )
{
  voidPtr sfnt_GetTablePtr (fsg_SplineKey *, sfnt_tableIndex, boolean); /*add prototype: @WIN*/

  //DJC sfnt_char2IndexDirectoryPtr table = (sfnt_char2IndexDirectoryPtr)sfnt_GetTablePtr (key, sfnt_charToIndexMap, true);


  // DJC implement fix for Mac chooser bug, this is a copy of Scchen modifications
  // DJC done by us.

  sfnt_char2IndexDirectoryPtr table = (sfnt_char2IndexDirectoryPtr)sfnt_GetTablePtr (key, sfnt_charToIndexMap, false);

  uint8 FAR * mapping = (uint8 FAR *)table;
  uint16 format;
  boolean found = false;
  int   Ret = NO_ERR;

  //DJC add code to correct for Mac chooser bug that kept jobs from MAC from
  //DJC working, this is based on email from SCCHEN
  if (!table) {
     key->mappingF = sfnt_ComputeIndex0;
     return(Ret);  //DJC note return here!!
  }

  platformID = (uint16) SWAPW (platformID);
  specificID = (uint16) SWAPW (specificID);

/* mapping */
  {
    register sfnt_platformEntryPtr plat = (sfnt_platformEntryPtr) table->platform;    /* <4> */
    for (; plat < &table->platform [SWAPW (table->numTables)]; ++plat)
    {
      if (plat->platformID == platformID && plat->specificID == specificID)
      {
        found = true;
        key->mappOffset = (unsigned) SWAPL (plat->offset);  /* skip header */
        break;
      }
    }
  }

  if (!found)
  {
    Ret = OUT_OF_RANGE_SUBTABLE;
    format = (uint16) -1;
  }
  else
  {
    format = * (uint16 FAR *)(mapping + key->mappOffset);     /* back up for header */
    format = SWAPW (format);
    key->mappOffset += sizeof (sfnt_mappingTable);
  }

#ifndef NOT_ON_THE_MAC
//switch (SWAPW (format))       @WIN; fix bug by SCCHEN, already swapped
  switch (format)
  {
  case 0:
    key->mappingF = sfnt_ComputeIndex0;
    break;
/*#if 0 */
  case 2:
    key->mappingF = sfnt_ComputeIndex2;
    break;
/*#endif */
  case 4:
    key->mappingF = sfnt_ComputeIndex4;
    break;
  case 6:
    key->mappingF = sfnt_ComputeIndex6;
    break;
  default:
    key->mappingF = sfnt_ComputeUnkownIndex;
    break;
  }
#else
  key->mappingF = format <= 6 ? sfnt_Format2Proc [format]: sfnt_ComputeUnkownIndex;
#endif
  RELEASESFNTFRAG(key, table);
  return Ret;
}
#endif


/*
 *
 */

#ifndef IN_ASM

/* replace by Falco for imcompatibility, 11/12/91 */
/*void sfnt_ReadSFNTMetrics (fsg_SplineKey*key, register uint16 glyphIndex) */
void sfnt_ReadSFNTMetrics ( key, glyphIndex )
fsg_SplineKey*key;
register uint16 glyphIndex;
/* replace end */
{
  register sfnt_HorizontalMetricsPtr  horizMetricPtr;
  register uint16                     numberOf_LongHorMetrics = key->numberOf_LongHorMetrics;

  horizMetricPtr  = (sfnt_HorizontalMetricsPtr)sfnt_GetTablePtr (key, sfnt_horizontalMetrics, true);

  if (glyphIndex < numberOf_LongHorMetrics)
  {
    key->nonScaledAW    = SWAPW (horizMetricPtr[glyphIndex].advanceWidth);
    key->nonScaledLSB   = SWAPW (horizMetricPtr[glyphIndex].leftSideBearing);
  }
  else
  {
    int16 FAR * lsb = (int16 FAR *) & horizMetricPtr[numberOf_LongHorMetrics]; /* first entry after[AW,LSB] array */

    key->nonScaledAW    = SWAPW (horizMetricPtr[numberOf_LongHorMetrics-1].advanceWidth);
    key->nonScaledLSB   = SWAPW (lsb[glyphIndex - numberOf_LongHorMetrics]);
  }
  RELEASESFNTFRAG(key, horizMetricPtr);
}
#endif

/* replace by Falco for imcompatibility, 11/12/91 */
/*PRIVATE void sfnt_GetGlyphLocation (fsg_SplineKey*key, uint16 gIndex, uint32*offset, unsigned *length) */
PRIVATE void sfnt_GetGlyphLocation ( key, gIndex, offset, length )
fsg_SplineKey *key;
uint16 gIndex;
uint32*offset;
unsigned *length;
/* replace end */
{
#ifdef FSCFG_USE_GLYPH_DIRECTORY
  char FAR* gdirPtr = sfnt_GetTablePtr (key, sfnt_GlyphDirectory, true);
  uint32 FAR* offsetPtr;
  uint16 FAR* lengthPtr;

  offsetPtr = (uint32 FAR*)(gdirPtr+(gIndex*(sizeof(int32)+sizeof(uint16))));
  lengthPtr = (uint16 FAR*)(offsetPtr+1);

  *offset = SWAPL(*offsetPtr);
  *length = (*offset == 0L) ? 0 : (unsigned) SWAPW(*lengthPtr);

  RELEASESFNTFRAG(key, gdirPtr);
#else
  void FAR* indexPtr = sfnt_GetTablePtr (key, sfnt_indexToLoc, true);

  if (SWAPW (key->indexToLocFormat) == SHORT_INDEX_TO_LOC_FORMAT)
  {
    uint16 usTmp;   //NTFIX

    register uint16 FAR *shortIndexToLoc = (uint16 FAR *)indexPtr;
    shortIndexToLoc += gIndex;

    // NTFIX
    // For some reasonthe compiler was incorectly sign extending the next
    // piece of code. To fix we introduced a temp varialbe NTFIX
    //    *offset = (uint32) (unsigned) SWAPW (*shortIndexToLoc) << 1; shortIndexToLoc++;


    usTmp = (uint16) SWAPW(*shortIndexToLoc);
    *offset = ((uint32)usTmp) << 1; shortIndexToLoc++;

    usTmp = (uint16) SWAPW(*shortIndexToLoc);
    *length = (uint32) (((uint32)usTmp << 1) - *offset);



    //Was *length = (unsigned) (((uint32) (unsigned) SWAPW (*shortIndexToLoc) << 1) - *offset);
  }
  else
  {
    register uint32 FAR *longIndexToLoc = (uint32 FAR *)indexPtr;
    longIndexToLoc += gIndex;
    *offset = SWAPL (*longIndexToLoc); longIndexToLoc++;
    *length = (unsigned) (SWAPL (*longIndexToLoc) - *offset);
  }
  RELEASESFNTFRAG(key, indexPtr);
#endif
}


/*
 *  <4>
 */
/* replace by Falco for imcompatibility, 11/12/91 */
/*int     sfnt_ReadSFNT (register fsg_SplineKey *key,
unsigned   *elementCount,
register uint16 gIndex,
boolean useHints,
voidFunc traceFunc)*/
int     sfnt_ReadSFNT ( key, elementCount, gIndex, useHints, traceFunc )
register fsg_SplineKey *key;
unsigned   *elementCount;
register uint16 gIndex;
boolean useHints;
voidFunc traceFunc;
/* replace end */
{
  unsigned    sizeOfInstructions = 0;
  uint8 FAR * instructionPtr;
  unsigned    length;
  uint32      offset;
  int   result  = NO_ERR;
  int16 FAR *      shortP;
  void FAR *       glyphDataPtr = 0;       /* to signal ReleaseSfntFrag if we never asked for it */
  sfnt_PackedSplineFormat charData;
  Fixed  ignoreX, ignoreY;
  void sfnt_ReadSFNTMetrics (fsg_SplineKey*, uint16); /*add prototype; @WIN*/
  int sfnt_ReadSFNT (fsg_SplineKey *, unsigned *, uint16, boolean, voidFunc);/*add prototype; @WIN*/

  sfnt_ReadSFNTMetrics (key, gIndex);
  sfnt_GetGlyphLocation (key, gIndex, &offset, &length);
  if (length > 0)
  {
#ifdef FSCFG_USE_GLYPH_DIRECTORY
    glyphDataPtr = GETSFNTFRAG (key, key->clientID, offset, length);
    if  (!glyphDataPtr)
      fs_longjmp (key->env, CLIENT_RETURNED_NULL);
#else
    glyphDataPtr = sfnt_GetDataPtr (key, offset, length, sfnt_glyphData);
#endif

    shortP = (int16 FAR *)glyphDataPtr;

    charData.numberContours = SWAPWINC (shortP);
    charData.bbox.xMin = SWAPWINC (shortP);
    charData.bbox.yMin = SWAPWINC (shortP);
    charData.bbox.xMax = SWAPWINC (shortP);
    charData.bbox.yMax = SWAPWINC (shortP);
  }
  else
  {
    charData.numberContours = 1;
//  MEMSET (&charData.bbox, 0, sizeof (charData.bbox)); @WIN
    MEMSET ((LPSTR)&charData.bbox, 0, sizeof (charData.bbox));
  }

  if (charData.numberContours >= 0) /* Not a component glyph */
  {
    key->lastGlyph = ! (key->weGotComponents && (key->compFlags & MORE_COMPONENTS));

    if (length > 0)
    {
      charData.endPoints = shortP;
      shortP += charData.numberContours;
      sizeOfInstructions = SWAPWINC (shortP);
      instructionPtr = (uint8 FAR *)shortP;
      charData.flags = (uint8 FAR *)shortP + sizeOfInstructions;
    }

    if (!(result = sfnt_UnfoldCurve (key, &charData, length, elementCount)))
    {

#ifndef PC_OS
do_grid_fit:
      result = fsg_InnerGridFit (key, useHints, traceFunc, &charData.bbox, sizeOfInstructions, instructionPtr, charData.numberContours < 0);
#else
      extern char *FAR fs_malloc (int);
      extern void FAR fs_free (char *);
      char * p;

do_grid_fit:
      if (sizeOfInstructions)
      {
        p = fs_malloc (sizeOfInstructions);
        memcpy ((char FAR *) p, instructionPtr, sizeOfInstructions);
      }
      result = fsg_InnerGridFit (key, useHints, traceFunc, &charData.bbox, sizeOfInstructions, p, charData.numberContours < 0);
      if (sizeOfInstructions)
        fs_free (p);
#endif
    }
  }
  else
    if (key->weGotComponents = (charData.numberContours == -1))
    {
      uint16 flags;
      boolean transformTrashed = false;

      do
      {
        transMatrix ctmSaveT, localSaveT;
        uint16 glyphIndex;
        int16 arg1, arg2;

        flags       = (uint16)SWAPWINC (shortP);
        glyphIndex  = (uint16)SWAPWINC (shortP);

        if (flags & ARG_1_AND_2_ARE_WORDS)
        {
          arg1    = SWAPWINC (shortP);
          arg2    = SWAPWINC (shortP);
        }
        else
        {
          int8 FAR * byteP = (int8 FAR *)shortP;
          if (flags & ARGS_ARE_XY_VALUES)
          {
  /* offsets are signed */
            arg1 = *byteP++;
            arg2 = *byteP;
          }
          else
          {
  /* anchor points are unsigned */
            arg1 = (uint8) * byteP++;
            arg2 = (uint8) * byteP;
          }
          ++shortP;
        }

        if (flags & (WE_HAVE_A_SCALE | WE_HAVE_AN_X_AND_Y_SCALE | WE_HAVE_A_TWO_BY_TWO))
        {
          fsg_MxCopy (&key->currentTMatrix, &ctmSaveT);
          fsg_MxCopy (&key->localTMatrix, &localSaveT);
          transformTrashed = true;
          if (flags & WE_HAVE_A_TWO_BY_TWO)
          {
            register Fixed multiplier;
            transMatrix mulT;

            multiplier  = SWAPWINC (shortP); /* read 2.14 */
            mulT.transform[0][0] = (multiplier << 2); /* turn into 16.16 */

            multiplier  = SWAPWINC (shortP); /* read 2.14 */
            mulT.transform[0][1] = (multiplier << 2); /* turn into 16.16 */

            multiplier  = SWAPWINC (shortP); /* read 2.14 */
            mulT.transform[1][0] = (multiplier << 2); /* turn into 16.16 */

            multiplier  = SWAPWINC (shortP); /* read 2.14 */
            mulT.transform[1][1] = (multiplier << 2); /* turn into 16.16 */

            fsg_MxConcat2x2 (&mulT, &key->currentTMatrix);
            fsg_MxConcat2x2 (&mulT, &key->localTMatrix);
          }
          else
          {
            Fixed xScale, yScale;

            xScale  = (Fixed)SWAPWINC (shortP); /* read 2.14 */
            xScale <<= 2; /* turn into 16.16 */

            if (flags & WE_HAVE_AN_X_AND_Y_SCALE)
            {
              yScale  = (Fixed)SWAPWINC (shortP); /* read 2.14 */
              yScale <<= 2; /* turn into 16.16 */
            }
            else
              yScale = xScale;

            fsg_MxScaleAB (xScale, yScale, &key->currentTMatrix);
            fsg_MxScaleAB (xScale, yScale, &key->localTMatrix);
          }
          fsg_InitInterpreterTrans (key, &key->interpLocalScalarX, &key->interpLocalScalarY, &ignoreX, &ignoreY); /*** Compute global stretch etc. ***/
          key->localTIsIdentity = false;
        }
        key->compFlags = flags;
        key->arg1 = arg1;
        key->arg2 = arg2;

        result = sfnt_ReadSFNT (key, elementCount, glyphIndex, useHints, traceFunc);

        if (transformTrashed)
        {
          fsg_MxCopy (&ctmSaveT, &key->currentTMatrix);
          fsg_InitInterpreterTrans (key, &key->interpLocalScalarX, &key->interpLocalScalarY, &ignoreX, &ignoreY); /*** Compute global stretch etc. ***/

          fsg_MxCopy (&localSaveT, &key->localTMatrix);
          transformTrashed = false;
        }
      } while (flags & MORE_COMPONENTS && result == NO_ERR);

  /* Do Final Composite Pass */
      sfnt_ReadSFNTMetrics (key, gIndex); /* read metrics again */
      if (flags & WE_HAVE_INSTRUCTIONS)
      {
        sizeOfInstructions = (int) (uint16)SWAPWINC (shortP);
        instructionPtr = (uint8 FAR *)shortP;
      }
      goto do_grid_fit;
    }
    else
      result = UNKNOWN_COMPOSITE_VERSION;

  if (glyphDataPtr)
    RELEASESFNTFRAG(key, glyphDataPtr);

  return result;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\bass\fnt.c ===
/*
        File:           fnt.c

        Copyright:      c 1987-1990 by Apple Computer, Inc., all rights reserved.

    This file is used in these builds: BigBang

        Change History (most recent first):

                 <6>    11/27/90        MR              Fix bogus debugging in Check_ElementPtr. [rb]
                 <5>    11/16/90        MR              More debugging code [rb]
                 <4>     11/9/90        MR              Fix non-portable C (dup, depth, pushsomestuff) [rb]
                 <3>     11/5/90        MR              Use proper types in fnt_Normalize, change globalGS.ppemDot6 to
                                                                        globalGS.fpem. Make instrPtrs all uint8*. Removed conditional
                                                                        code for long vectors. [rb]
                 <2>    10/20/90        MR              Restore changes since project died. Converting to 2.14 vectors,
                                                                        smart math routines. [rb]
                <24>     8/16/90        RB              Fix IP to use oo domain
                <22>     8/11/90        MR              Add Print debugging function
                <21>     8/10/90        MR              Make SFVTL check like SPVTL does
                <20>      8/1/90        MR              remove call to fnt_NextPt1 macro in fnt_SHC
                <19>     7/26/90        MR              Fix bug in SHC
                <18>     7/19/90        dba             get rid of C warnings
                <17>     7/18/90        MR              What else, more Ansi-C fixes
                <16>     7/13/90        MR              Added runtime range checking, various ansi-fixes
                <15>      7/2/90        RB              combine variables into parameter block.
                <12>     6/26/90        RB              bugfix in divide instruction
                <11>     6/21/90        RB              bugfix in scantype
                <10>     6/12/90        RB              add scantype instruction, add selector variable to getinfo
                                                                        instruction
                 <9>     6/11/90        CL              Using the debug call.
                 <8>      6/4/90        MR              Remove MVT
                 <7>      6/3/90        RB              no change
                 <6>      5/8/90        RB              revert to version 4
                 <5>      5/4/90        RB              mrr-more optimization, errorchecking
                 <4>      5/3/90        RB              more optimization. decreased code size.
                 <4>      5/2/90        MR              mrr - added support for IDEF mrr - combined multiple small
                                                                        instructions into switchs e.g. BinaryOperands, UnaryOperand,
                                                                        etc. (to save space) mrr - added twilightzone support to fnt_WC,
                                                                        added fnt_ROTATE, fnt_MAX and fnt_MIN. Max and Min are in
                                                                        fnt_BinaryOperand. Optimized various functions for size.
                                                                        Optimized loops in push statements and alignrp for speed.
                                                                        gs->loop now is base-0. so gs->loop == 4 means do it 5 times.
                 <3>     3/20/90        MR              Added support for multiple preprograms. This touched function
                                                                        calls, definitions. Fractional ppem (called ppemDot6 in globalGS
                                                                        Add new instructions ELSE, JMPR Experimenting with RMVT, WMVT
                                                                        Removed lots of the MR_MAC #ifdefs, GOSLOW, Added MFPPEM, MFPS
                                                                        as experiments (fractional versions) Added high precision
                                                                        multiply and divide for MUL and DIV Changed fnt_MD to use oox
                                                                        instead of ox when it can (more precise) fnt_Init: Initialize
                                                                        instruction jump table with *p++ instead of p[index] Changed
                                                                        fnt_AngleInfo into fnt_FractPoint and int16 for speed and to
                                                                        maintain long alignment Switch to Loop in PUSHB and PUSHW for
                                                                        size reduction Speed up GetCVTScale to avoid FracMul (1.0,
                                                                        transScale) (sampo)
                 <2>     2/27/90        CL              Added DSPVTL[] instruction.  Dropout control scanconverter and
                                                                        SCANCTRL[] instruction.  BugFix in SFVTL[], and SFVTOPV[].
                                                                        Fixed bug in fnt_ODD[] and fnt_EVEN[]. Fixed bug in
                                                                        fnt_Normalize
           <3.4>        11/16/89        CEL             Added new functions fnt_FLIPPT, fnt_FLIPRGON and fnt_FLIPRGOFF.
           <3.3>        11/15/89        CEL             Put function array check in ifndef so printer folks could
                                                                        exclude the check.
           <3.2>        11/14/89        CEL             Fixed two small bugs/feature in RTHG, and RUTG. Added SROUND &
                                                                        S45ROUND.
           <3.1>         9/27/89        CEL             GetSingleWidth slow was set to incorrect value. Changed rounding
                                                                        routines, so that the sign flip check only apply if the input
                                                                        value is nonzero.
           <3.0>         8/28/89        sjk             Cleanup and one transformation bugfix
           <2.3>         8/14/89        sjk             1 point contours now OK
           <2.2>          8/8/89        sjk             Now allow the system to muck with high bytes of addresses
           <2.1>          8/8/89        sjk             Improved encryption handling
           <2.0>          8/2/89        sjk             Just fixed EASE comment
           <1.8>          8/1/89        sjk             Added in composites and encryption. Plus other enhancements.
           <1.7>         6/13/89        sjk             fixed broken delta instruction
           <1.6>         6/13/89        SJK             Comment
           <1.5>          6/2/89        CEL             16.16 scaling of metrics, minimum recommended ppem, point size 0
                                                                        bug, correct transformed integralized ppem behavior, pretty much
                                                                        so
           <1.4>         5/26/89        CEL             EASE messed up on "c" comments
          <y1.3>         5/26/89        CEL             Integrated the new Font Scaler 1.0 into Spline Fonts

        To Do:
/* rwb 4/24/90 - changed scanctrl instruction to take 16 bit argument
*/
/******* MIKE PLEASE FIX up these comments so they fit in the header above with the same
                 FORMAT!!!
*/
/*
 * File: fnt.c
 *
 * This module contains the interpreter that executes font instructions
 *
 * The BASS Project Interpreter and Font Instruction Set sub ERS contains
 * relevant information.
 *
 *  c Apple Computer Inc. 1987, 1988, 1989, 1990.
 *
 * History:
 * Work on this module began in the fall of 1987
 *
 * Written June 23, 1988 by Sampo Kaasila
 *
 * Rewritten October 18, 1988 by Sampo Kaasila. Added a jump table instead of the switch statement.
 *              Also added CALL (), LOOPCALL (), FDEF (), ENDF (), and replaced WX (),WY (), RX (), RY (), MD ()
 *              with new WC (), RC (), MD (). Reimplemented IUP (). Also optimized the code somewhat.
 *              Cast code into a more digestable form using a local and global graphics state.
 *
 * December 20, 1988. Added DELTA (), SDB (), SDS (), and deleted ONTON (), and ONTOFF (). ---Sampo.
 *
 * January 17, 1989 Added DEBUG (), RAW (), RLSB (), WLSB (), ALIGNPTS (), SANGW (), AA ().
 *                          Brought up this module to an alpha ready state. ---Sampo
 *
 * January 31, 1989 Added RDTG (), and RUTG ().
 *
 * Feb 16, 1989 Completed final bug fixes for the alpha release.
 *
 * March 21, 1989 Fixed a small Twilight Zone bug in MIAP (), MSIRP (), and MIRP ().
 *
 * March 28, 1989 Took away the need and reason for directional switches in the control value table.
 *                        However, this forced a modification of all the code that reads or writes to the control
 *                                value table and the single width. Also WCVT was replaced by WCVTFOL, WCVTFOD, and
 *                                WCVTFCVT. ---Sampo
 *
 * April 17, 1989 Modified RPV (), RFV (), WPV (), WFV () to work with an x & y pair instead of just x. --- Sampo
 *
 * April 25, 1989 Fixed bugs in CEILING (), RUTG (), FDEF (), and IF (). Made MPPEM () a function of
 *                the projection vector. ---Sampo
 *
 * June 7, 1989 Made ALIGNRP () dependent on the loop variable, and also made it blissfully
 *              ignorant of the twilight zone.
 *                              Also, added ROFF (), removed WCVTFCVT (), renamed WCVTFOL () to WCVT (), made MIRP () and
 *                              MDRP () compensate for the engine even when there is no rounding. --- Sampo
 *
 * June 8, 1989 Made DELTA () dependent on the Transformation. ---Sampo
 *
 * June 19, 1989 Added JROF () and JROT (). ---Sampo
 *
 * July 14, 1989 Forced a pretty tame behaviour when abs ((projection vector) * (freedoom vector)) < 1/16.
 *                      The old behaviour was to grossly blow up the outline. This situation may happen for low pointsizes
 *                      when the character is severly distorted due to the gridfitting ---Sampo
 *
 * July 17, 1989 Prevented the rounding routines from changing the sign of a quantity due to the engine compensation. ---Sampo
 *
 * July 19, 1989 Increased nummerical precision of fnt_MovePoint by 8 times. ---Sampo
 *
 * July 28, 1989 Introduced 5 more Delta instructions. (Now 3 are for points and 3 for the cvt.) ---Sampo
 *
 * Aug 24, 1989 fixed fnt_GetCVTEntrySlow and fnt_GetSingleWidthSlow bug ---Sampo
 *
 * Sep 26, 1989 changed rounding routines, so that the sign flip check only apply if the input value is nonzero. ---Sampo
 *
 * Oct 26, 1989 Fixed small bugs/features in fnt_RoundUpToGrid () and fnt_RoundToHalfGrid. Added SROUND () and S45ROUND (). ---Sampo
 *
 * Oct 31, 1989 Fixed transformation bug in fnt_MPPEM, fnt_DeltaEngine, fnt_GetCvtEntrySlow, fnt_GetSingleWidthSlow. ---Sampo
 *
 * Nov 3, 1989 Added FLIPPT (), FLIPRGON (), FLIPRGOFF (). ---Sampo
 *
 * Nov 16, 1989 Merged back in lost Nov 3 changes.---Sampo
 *
 * Dec 2, 1989 Added READMETRICS () aand WRITEMETRICS (). --- Sampo
 *
 * Jan 8, 1990 Added SDPVTL (). --- Sampo
 *
 * Jan 8, 1990 Eliminated bug in SFVTPV[] (old bug) and SFVTL[] (showed up because of SDPVTL[]). --- Sampo
 *
 * Jan 9, 1990 Added the SCANCTRL[] instruction. --- Sampo
 *
 * Jan 24, 1990 Fixed bug in fnt_ODD and fnt_EVEN. ---Sampo
 *
 * Jan 28, 1990 Fixed bug in fnt_Normalize. --- Sampo
 *
 *      2/9/90  mrr     ReFixed Normalize bug, added ELSE and JMPR.  Added pgmList[] to globalGS
                                in preparation for 3 preprograms.  affected CALL, LOOPCALL, FDEF
 * 2/21/90      mrr     Added RMVT, WMVT.
 * 3/7/90       mrr             put in high precision versions of MUL and DIV.
 */


// DJC DJC.. added global include
#include "psglobal.h"


//DJC added to resolve longjmp
#include <setjmp.h>

/****** Macros *******/
/** FontScaler's Includes **/
#include "fscdefs.h"
#include "fontmath.h"
#include "sfnt.h"
#include "fnt.h"
#include "sc.h"
#include "fserror.h"

#ifdef SEGMENT_LINK
#pragma segment FNT_C
#endif


#ifdef FSCFG_REENTRANT
#define GSP0    fnt_LocalGraphicStateType* pLocalGS
#define GSP     fnt_LocalGraphicStateType* pLocalGS,
#define GSA0    pLocalGS
#define GSA     pLocalGS,
#define LocalGS (*pLocalGS)
#else
#define GSP0    void
#define GSP
#define GSA0
#define GSA
fnt_LocalGraphicStateType LocalGS = {0};
#endif


#define PRIVATE
/* Private function prototypes */

F26Dot6 fnt_RoundToDoubleGrid(GSP F26Dot6 xin, F26Dot6 engine);
F26Dot6 fnt_RoundDownToGrid(GSP F26Dot6 xin, F26Dot6 engine);
F26Dot6 fnt_RoundUpToGrid(GSP F26Dot6 xin, F26Dot6 engine);
F26Dot6 fnt_RoundToGrid(GSP F26Dot6 xin, F26Dot6 engine);
F26Dot6 fnt_RoundToHalfGrid(GSP F26Dot6 xin, F26Dot6 engine);
F26Dot6 fnt_RoundOff(GSP F26Dot6 xin, F26Dot6 engine);
F26Dot6 fnt_SuperRound(GSP F26Dot6 xin, F26Dot6 engine);
F26Dot6 fnt_Super45Round(GSP F26Dot6 xin, F26Dot6 engine);

void fnt_Panic (GSP int error);
void fnt_IllegalInstruction (GSP0);
void fnt_Normalize (F26Dot6 x, F26Dot6 y, VECTOR* v);
void fnt_MovePoint  (GSP fnt_ElementType *element, ArrayIndex point, F26Dot6 delta);
void fnt_XMovePoint (GSP fnt_ElementType *element, ArrayIndex point, F26Dot6 delta);
void fnt_YMovePoint (GSP fnt_ElementType *element, ArrayIndex point, F26Dot6 delta);
F26Dot6 fnt_Project (GSP F26Dot6 x, F26Dot6 y);
F26Dot6 fnt_OldProject (GSP F26Dot6 x, F26Dot6 y);
F26Dot6 fnt_XProject (GSP F26Dot6 x, F26Dot6 y);
F26Dot6 fnt_YProject (GSP F26Dot6 x, F26Dot6 y);
Fixed fnt_GetCVTScale (GSP0);
F26Dot6 fnt_GetCVTEntryFast (GSP ArrayIndex n);
F26Dot6 fnt_GetCVTEntrySlow (GSP ArrayIndex n);
F26Dot6 fnt_GetSingleWidthFast (GSP0);
F26Dot6 fnt_GetSingleWidthSlow (GSP0);
void fnt_ChangeCvt (GSP fnt_ElementType *element, ArrayIndex number, F26Dot6 delta);
void fnt_InnerTraceExecute (GSP uint8 *ptr, uint8 *eptr);
void fnt_InnerExecute (GSP uint8 *ptr, uint8 *eptr);
void fnt_Check_PF_Proj (GSP0);
void fnt_ComputeAndCheck_PF_Proj (GSP0);
void fnt_SetRoundValues (GSP int arg1, int normalRound);
F26Dot6 fnt_CheckSingleWidth (GSP F26Dot6 value);
fnt_instrDef*fnt_FindIDef (GSP uint8 opCode);
void fnt_DeltaEngine (GSP FntMoveFunc doIt, int16 base, int16 shift);
void fnt_DefaultJumpTable (voidFunc*function);

/* Actual instructions for the jump table */
void fnt_SVTCA_0 (GSP0);
void fnt_SVTCA_1 (GSP0);
void fnt_SPVTCA (GSP0);
void fnt_SFVTCA (GSP0);
void fnt_SPVTL (GSP0);
void fnt_SDPVTL (GSP0);
void fnt_SFVTL (GSP0);
void fnt_WPV (GSP0);
void fnt_WFV (GSP0);
void fnt_RPV (GSP0);
void fnt_RFV (GSP0);
void fnt_SFVTPV (GSP0);
void fnt_ISECT (GSP0);
void fnt_SetLocalGraphicState (GSP0);
void fnt_SetElementPtr (GSP0);
void fnt_SetRoundState (GSP0);
void fnt_SROUND (GSP0);
void fnt_S45ROUND (GSP0);
void fnt_LMD (GSP0);
void fnt_RAW (GSP0);
void fnt_WLSB (GSP0);
void fnt_LWTCI (GSP0);
void fnt_LSWCI (GSP0);
void fnt_LSW (GSP0);
void fnt_DUP (GSP0);
void fnt_POP (GSP0);
void fnt_CLEAR (GSP0);
void fnt_SWAP (GSP0);
void fnt_DEPTH (GSP0);
void fnt_CINDEX (GSP0);
void fnt_MINDEX (GSP0);
void fnt_ROTATE (GSP0);
void fnt_MDAP (GSP0);
void fnt_MIAP (GSP0);
void fnt_IUP (GSP0);
void fnt_SHP (GSP0);
void fnt_SHC (GSP0);
void fnt_SHE (GSP0);
void fnt_SHPIX (GSP0);
void fnt_IP (GSP0);
void fnt_MSIRP (GSP0);
void fnt_ALIGNRP (GSP0);
void fnt_ALIGNPTS (GSP0);
void fnt_SANGW (GSP0);
void fnt_FLIPPT (GSP0);
void fnt_FLIPRGON (GSP0);
void fnt_FLIPRGOFF (GSP0);
void fnt_SCANCTRL (GSP0);
void fnt_SCANTYPE (GSP0);
void fnt_INSTCTRL (GSP0);
void fnt_AA (GSP0);
void fnt_NPUSHB (GSP0);
void fnt_NPUSHW (GSP0);
void fnt_WS (GSP0);
void fnt_RS (GSP0);
void fnt_WCVT (GSP0);
void fnt_WCVTFOD (GSP0);
void fnt_RCVT (GSP0);
void fnt_RC (GSP0);
void fnt_WC (GSP0);
void fnt_MD (GSP0);
void fnt_MPPEM (GSP0);
void fnt_MPS (GSP0);
void fnt_GETINFO (GSP0);
void fnt_FLIPON (GSP0);
void fnt_FLIPOFF (GSP0);
#ifndef NOT_ON_THE_MAC
#ifdef DEBUG
void fnt_DDT (int8 c, int32 n);
#endif
#endif
void fnt_DEBUG (GSP0);
void fnt_SkipPushCrap (GSP0);
void fnt_IF (GSP0);
void fnt_ELSE (GSP0);
void fnt_EIF (GSP0);
void fnt_JMPR (GSP0);
void fnt_JROT (GSP0);
void fnt_JROF (GSP0);
void fnt_BinaryOperand (GSP0);
void fnt_UnaryOperand (GSP0);
void fnt_ROUND (GSP0);
void fnt_NROUND (GSP0);
void fnt_PUSHB (GSP0);
void fnt_PUSHW (GSP0);
void fnt_MDRP (GSP0);
void fnt_MIRP (GSP0);
void fnt_CALL (GSP0);
void fnt_FDEF (GSP0);
void fnt_LOOPCALL (GSP0);
void fnt_IDefPatch (GSP0);
void fnt_IDEF (GSP0);
void fnt_UTP (GSP0);
void fnt_SDB (GSP0);
void fnt_SDS (GSP0);
void fnt_DELTAP1 (GSP0);
void fnt_DELTAP2 (GSP0);
void fnt_DELTAP3 (GSP0);
void fnt_DELTAC1 (GSP0);
void fnt_DELTAC2 (GSP0);
void fnt_DELTAC3 (GSP0);

void  fnt_PUSHB1 (GSP0);
void  fnt_PUSHB2 (GSP0);
void  fnt_PUSHB3 (GSP0);
void  fnt_PUSHB4 (GSP0);
void  fnt_PUSHB5 (GSP0);
void  fnt_PUSHB6 (GSP0);
void  fnt_PUSHB7 (GSP0);
void  fnt_PUSHB8 (GSP0);
void  fnt_PUSHW1 (GSP0);
void  fnt_PUSHW2 (GSP0);
void  fnt_PUSHW3 (GSP0);
void  fnt_PUSHW4 (GSP0);
void  fnt_PUSHW5 (GSP0);
void  fnt_PUSHW6 (GSP0);
void  fnt_PUSHW7 (GSP0);
void  fnt_PUSHW8 (GSP0);

void  fnt_LT  (GSP0);
void  fnt_LTEQ (GSP0);
void  fnt_GT  (GSP0);
void  fnt_GTEQ (GSP0);
void  fnt_EQ  (GSP0);
void  fnt_NEQ (GSP0);
void  fnt_AND (GSP0);
void  fnt_OR  (GSP0);
void  fnt_ADD (GSP0);
void  fnt_SUB (GSP0);
void  fnt_DIV (GSP0);
void  fnt_MUL (GSP0);
void  fnt_MAX (GSP0);
void  fnt_MIN (GSP0);

PRIVATE fnt_ElementType*fnt_SH_Common (GSP F26Dot6*dx, F26Dot6*dy, ArrayIndex*point);
PRIVATE void fnt_SHP_Common (GSP F26Dot6 dx, F26Dot6 dy);
PRIVATE void fnt_PushSomeStuff (GSP register LoopCount count, boolean pushBytes);

/*
*  function table as well as angle table
*/

#if 1  /*was "ifdef NOT_ON_THE_MAC", but "#else" is not really supported */

FntFunc function [MAXBYTE_INSTRUCTIONS] =
{
  fnt_SVTCA_0, fnt_SVTCA_1, fnt_SPVTCA, fnt_SPVTCA, fnt_SFVTCA, fnt_SFVTCA, fnt_SPVTL, fnt_SPVTL,
  fnt_SFVTL, fnt_SFVTL, fnt_WPV, fnt_WFV, fnt_RPV, fnt_RFV, fnt_SFVTPV, fnt_ISECT,
  fnt_SetLocalGraphicState, fnt_SetLocalGraphicState, fnt_SetLocalGraphicState, fnt_SetElementPtr, fnt_SetElementPtr, fnt_SetElementPtr, fnt_SetElementPtr, fnt_SetLocalGraphicState,
  fnt_SetRoundState, fnt_SetRoundState, fnt_LMD, fnt_ELSE, fnt_JMPR, fnt_LWTCI, fnt_LSWCI, fnt_LSW,
  fnt_DUP, fnt_SetLocalGraphicState, fnt_CLEAR, fnt_SWAP, fnt_DEPTH, fnt_CINDEX, fnt_MINDEX, fnt_ALIGNPTS,
  fnt_RAW, fnt_UTP, fnt_LOOPCALL, fnt_CALL, fnt_FDEF, fnt_IllegalInstruction, fnt_MDAP, fnt_MDAP,
  fnt_IUP, fnt_IUP, fnt_SHP, fnt_SHP, fnt_SHC, fnt_SHC, fnt_SHE, fnt_SHE,
  fnt_SHPIX, fnt_IP, fnt_MSIRP, fnt_MSIRP, fnt_ALIGNRP, fnt_SetRoundState, fnt_MIAP, fnt_MIAP,
  fnt_NPUSHB, fnt_NPUSHW, fnt_WS, fnt_RS, fnt_WCVT, fnt_RCVT, fnt_RC, fnt_RC,
  fnt_WC, fnt_MD, fnt_MD, fnt_MPPEM, fnt_MPS, fnt_FLIPON, fnt_FLIPOFF, fnt_DEBUG,
#ifdef  IN_ASM
  fnt_LT, fnt_LTEQ, fnt_GT, fnt_GTEQ, fnt_EQ, fnt_NEQ, fnt_UnaryOperand, fnt_UnaryOperand,
  fnt_IF, fnt_EIF, fnt_AND, fnt_OR, fnt_UnaryOperand, fnt_DELTAP1, fnt_SDB, fnt_SDS,
  fnt_ADD, fnt_SUB, fnt_DIV, fnt_MUL, fnt_UnaryOperand, fnt_UnaryOperand, fnt_UnaryOperand, fnt_UnaryOperand,
#else
fnt_BinaryOperand, fnt_BinaryOperand, fnt_BinaryOperand, fnt_BinaryOperand, fnt_BinaryOperand, fnt_BinaryOperand, fnt_UnaryOperand, fnt_UnaryOperand,
  fnt_IF, fnt_EIF, fnt_BinaryOperand, fnt_BinaryOperand, fnt_UnaryOperand, fnt_DELTAP1, fnt_SDB, fnt_SDS,
fnt_BinaryOperand, fnt_BinaryOperand, fnt_BinaryOperand, fnt_BinaryOperand, fnt_UnaryOperand, fnt_UnaryOperand, fnt_UnaryOperand, fnt_UnaryOperand,
#endif
  fnt_ROUND, fnt_ROUND, fnt_ROUND, fnt_ROUND, fnt_NROUND, fnt_NROUND, fnt_NROUND, fnt_NROUND,
  fnt_WCVTFOD, fnt_DELTAP2, fnt_DELTAP3, fnt_DELTAC1, fnt_DELTAC2, fnt_DELTAC3, fnt_SROUND, fnt_S45ROUND,
  fnt_JROT, fnt_JROF, fnt_SetRoundState, fnt_IllegalInstruction, fnt_SetRoundState, fnt_SetRoundState, fnt_SANGW, fnt_AA,

  fnt_FLIPPT, fnt_FLIPRGON, fnt_FLIPRGOFF, fnt_IDefPatch, fnt_IDefPatch, fnt_SCANCTRL, fnt_SDPVTL, fnt_SDPVTL,
#ifdef  IN_ASM
  fnt_GETINFO, fnt_IDEF, fnt_ROTATE, fnt_MAX, fnt_MIN, fnt_SCANTYPE, fnt_INSTCTRL, fnt_IDefPatch,
#else
  fnt_GETINFO, fnt_IDEF, fnt_ROTATE, fnt_BinaryOperand, fnt_BinaryOperand, fnt_SCANTYPE, fnt_INSTCTRL, fnt_IDefPatch,
#endif
  fnt_IDefPatch, fnt_IDefPatch, fnt_IDefPatch, fnt_IDefPatch, fnt_IDefPatch, fnt_IDefPatch, fnt_IDefPatch, fnt_IDefPatch,
  fnt_IDefPatch, fnt_IDefPatch, fnt_IDefPatch, fnt_IDefPatch, fnt_IDefPatch, fnt_IDefPatch, fnt_IDefPatch, fnt_IDefPatch,
  fnt_IDefPatch, fnt_IDefPatch, fnt_IDefPatch, fnt_IDefPatch, fnt_IDefPatch, fnt_IDefPatch, fnt_IDefPatch, fnt_IDefPatch,
  fnt_IDefPatch, fnt_IDefPatch, fnt_IDefPatch, fnt_IDefPatch, fnt_IDefPatch, fnt_IDefPatch, fnt_IDefPatch, fnt_IDefPatch,
#ifdef  IN_ASM
  fnt_PUSHB1, fnt_PUSHB2, fnt_PUSHB3, fnt_PUSHB4, fnt_PUSHB5, fnt_PUSHB6, fnt_PUSHB7, fnt_PUSHB8,
  fnt_PUSHW1, fnt_PUSHW2, fnt_PUSHW3, fnt_PUSHW4, fnt_PUSHW5, fnt_PUSHW6, fnt_PUSHW7, fnt_PUSHW8,
#else
  fnt_PUSHB, fnt_PUSHB, fnt_PUSHB, fnt_PUSHB, fnt_PUSHB, fnt_PUSHB, fnt_PUSHB, fnt_PUSHB,
  fnt_PUSHW, fnt_PUSHW, fnt_PUSHW, fnt_PUSHW, fnt_PUSHW, fnt_PUSHW, fnt_PUSHW, fnt_PUSHW,
#endif
  fnt_MDRP, fnt_MDRP, fnt_MDRP, fnt_MDRP, fnt_MDRP, fnt_MDRP, fnt_MDRP, fnt_MDRP,
  fnt_MDRP, fnt_MDRP, fnt_MDRP, fnt_MDRP, fnt_MDRP, fnt_MDRP, fnt_MDRP, fnt_MDRP,
  fnt_MDRP, fnt_MDRP, fnt_MDRP, fnt_MDRP, fnt_MDRP, fnt_MDRP, fnt_MDRP, fnt_MDRP,
  fnt_MDRP, fnt_MDRP, fnt_MDRP, fnt_MDRP, fnt_MDRP, fnt_MDRP, fnt_MDRP, fnt_MDRP,
  fnt_MIRP, fnt_MIRP, fnt_MIRP, fnt_MIRP, fnt_MIRP, fnt_MIRP, fnt_MIRP, fnt_MIRP,
  fnt_MIRP, fnt_MIRP, fnt_MIRP, fnt_MIRP, fnt_MIRP, fnt_MIRP, fnt_MIRP, fnt_MIRP,
  fnt_MIRP, fnt_MIRP, fnt_MIRP, fnt_MIRP, fnt_MIRP, fnt_MIRP, fnt_MIRP, fnt_MIRP,
  fnt_MIRP, fnt_MIRP, fnt_MIRP, fnt_MIRP, fnt_MIRP, fnt_MIRP, fnt_MIRP, fnt_MIRP
};
#else

/*
 *      Rebuild the jump table          <4>
 */
static void fnt_DefaultJumpTable( register voidFunc* function )
{
        register LoopCount i;

        /***** 0x00 - 0x0f *****/
    *function++ = fnt_SVTCA_0;
        *function++ = fnt_SVTCA_1;
        *function++ = fnt_SPVTCA;
        *function++ = fnt_SPVTCA;
        *function++ = fnt_SFVTCA;
        *function++ = fnt_SFVTCA;
        *function++ = fnt_SPVTL;
        *function++ = fnt_SPVTL;
        *function++ = fnt_SFVTL;
        *function++ = fnt_SFVTL;
        *function++ = fnt_WPV;
        *function++ = fnt_WFV;
        *function++ = fnt_RPV;
        *function++ = fnt_RFV;
        *function++ = fnt_SFVTPV;
        *function++ = fnt_ISECT;

        /***** 0x10 - 0x1f *****/
        *function++ = fnt_SetLocalGraphicState;         /* fnt_SRP0; */
        *function++ = fnt_SetLocalGraphicState;         /* fnt_SRP1; */
        *function++ = fnt_SetLocalGraphicState;         /* fnt_SRP2; */
        *function++ = fnt_SetElementPtr;                        /* fnt_SCE0; */
        *function++ = fnt_SetElementPtr;                        /* fnt_SCE1; */
        *function++ = fnt_SetElementPtr;                        /* fnt_SCE2; */
        *function++ = fnt_SetElementPtr;                        /* fnt_SCES; */
        *function++ = fnt_SetLocalGraphicState;         /* fnt_LLOOP; */
        *function++ = fnt_SetRoundState;                        /* fnt_RTG; */
        *function++ = fnt_SetRoundState;                        /* fnt_RTHG; */
        *function++ = fnt_LMD;                                          /* fnt_LMD; */
        *function++ = fnt_ELSE;                                         /* used to be fnt_RLSB */
        *function++ = fnt_JMPR;                                         /* used to be fnt_WLSB */
        *function++ = fnt_LWTCI;
        *function++ = fnt_LSWCI;
        *function++ = fnt_LSW;

        /***** 0x20 - 0x2f *****/
        *function++ = fnt_DUP;
        *function++ = fnt_SetLocalGraphicState;         /* fnt_POP; */
        *function++ = fnt_CLEAR;
        *function++ = fnt_SWAP;
        *function++ = fnt_DEPTH;
        *function++ = fnt_CINDEX;
        *function++ = fnt_MINDEX;
        *function++ = fnt_ALIGNPTS;
        *function++ = fnt_RAW;
        *function++ = fnt_UTP;
        *function++ = fnt_LOOPCALL;
        *function++ = fnt_CALL;
        *function++ = fnt_FDEF;
        *function++ = fnt_IllegalInstruction;           /* fnt_ENDF; used for FDEF and IDEF */
        *function++ = fnt_MDAP;
        *function++ = fnt_MDAP;


        /***** 0x30 - 0x3f *****/
        *function++ = fnt_IUP;
        *function++ = fnt_IUP;
        *function++ = fnt_SHP;
        *function++ = fnt_SHP;
        *function++ = fnt_SHC;
        *function++ = fnt_SHC;
        *function++ = fnt_SHE;
        *function++ = fnt_SHE;
        *function++ = fnt_SHPIX;
        *function++ = fnt_IP;
        *function++ = fnt_MSIRP;
        *function++ = fnt_MSIRP;
        *function++ = fnt_ALIGNRP;
        *function++ = fnt_SetRoundState;        /* fnt_RTDG; */
        *function++ = fnt_MIAP;
        *function++ = fnt_MIAP;

        /***** 0x40 - 0x4f *****/
        *function++ = fnt_NPUSHB;
        *function++ = fnt_NPUSHW;
        *function++ = fnt_WS;
        *function++ = fnt_RS;
        *function++ = fnt_WCVT;
        *function++ = fnt_RCVT;
        *function++ = fnt_RC;
        *function++ = fnt_RC;
        *function++ = fnt_WC;
        *function++ = fnt_MD;
        *function++ = fnt_MD;
        *function++ = fnt_MPPEM;
        *function++ = fnt_MPS;
        *function++ = fnt_FLIPON;
        *function++ = fnt_FLIPOFF;
        *function++ = fnt_DEBUG;

        /***** 0x50 - 0x5f *****/
        *function++ = fnt_BinaryOperand;        /* fnt_LT; */
        *function++ = fnt_BinaryOperand;        /* fnt_LTEQ; */
        *function++ = fnt_BinaryOperand;        /* fnt_GT; */
        *function++ = fnt_BinaryOperand;        /* fnt_GTEQ; */
        *function++ = fnt_BinaryOperand;        /* fnt_EQ; */
        *function++ = fnt_BinaryOperand;        /* fnt_NEQ; */
        *function++ = fnt_UnaryOperand;         /* fnt_ODD; */
        *function++ = fnt_UnaryOperand;         /* fnt_EVEN; */
        *function++ = fnt_IF;
        *function++ = fnt_EIF;          /* should this guy be an illegal instruction??? */
        *function++ = fnt_BinaryOperand;        /* fnt_AND; */
        *function++ = fnt_BinaryOperand;        /* fnt_OR; */
        *function++ = fnt_UnaryOperand;         /* fnt_NOT; */
        *function++ = fnt_DELTAP1;
        *function++ = fnt_SDB;
        *function++ = fnt_SDS;

        /***** 0x60 - 0x6f *****/
        *function++ = fnt_BinaryOperand;        /* fnt_ADD; */
        *function++ = fnt_BinaryOperand;        /* fnt_SUB; */
        *function++ = fnt_BinaryOperand;        /* fnt_DIV;  */
        *function++ = fnt_BinaryOperand;        /* fnt_MUL; */
        *function++ = fnt_UnaryOperand;         /* fnt_ABS; */
        *function++ = fnt_UnaryOperand;         /* fnt_NEG; */
        *function++ = fnt_UnaryOperand;         /* fnt_FLOOR; */
        *function++ = fnt_UnaryOperand;         /* fnt_CEILING */
        *function++ = fnt_ROUND;
        *function++ = fnt_ROUND;
        *function++ = fnt_ROUND;
        *function++ = fnt_ROUND;
        *function++ = fnt_NROUND;
        *function++ = fnt_NROUND;
        *function++ = fnt_NROUND;
        *function++ = fnt_NROUND;

        /***** 0x70 - 0x7f *****/
        *function++ = fnt_WCVTFOD;
        *function++ = fnt_DELTAP2;
        *function++ = fnt_DELTAP3;
        *function++ = fnt_DELTAC1;
        *function++ = fnt_DELTAC2;
        *function++ = fnt_DELTAC3;
        *function++ = fnt_SROUND;
        *function++ = fnt_S45ROUND;
        *function++ = fnt_JROT;
        *function++ = fnt_JROF;
        *function++ = fnt_SetRoundState;        /* fnt_ROFF; */
        *function++ = fnt_IllegalInstruction;/* 0x7b reserved for data compression */
        *function++ = fnt_SetRoundState;        /* fnt_RUTG; */
        *function++ = fnt_SetRoundState;        /* fnt_RDTG; */
        *function++ = fnt_SANGW;
        *function++ = fnt_AA;

        /***** 0x80 - 0x8d *****/
        *function++ = fnt_FLIPPT;
        *function++ = fnt_FLIPRGON;
        *function++ = fnt_FLIPRGOFF;
        *function++ = fnt_IDefPatch;            /* fnt_RMVT, this space for rent */
        *function++ = fnt_IDefPatch;            /* fnt_WMVT, this space for rent */
        *function++ = fnt_SCANCTRL;
        *function++ = fnt_SDPVTL;
        *function++ = fnt_SDPVTL;
        *function++ = fnt_GETINFO;                      /* <7> */
        *function++ = fnt_IDEF;
        *function++ = fnt_ROTATE;
        *function++ = fnt_BinaryOperand;        /* fnt_MAX; */
        *function++ = fnt_BinaryOperand;        /* fnt_MIN; */
        *function++ = fnt_SCANTYPE;                     /* <7> */
        *function++ = fnt_INSTCTRL;                     /* <13> */

        /***** 0x8f - 0xaf *****/
        for ( i = 32; i >= 0; --i )
            *function++ = fnt_IDefPatch;                /* potentially fnt_IllegalInstruction  <4> */

        /***** 0xb0 - 0xb7 *****/
        for ( i = 7; i >= 0; --i )
            *function++ = fnt_PUSHB;

        /***** 0xb8 - 0xbf *****/
        for ( i = 7; i >= 0; --i )
            *function++ = fnt_PUSHW;

        /***** 0xc0 - 0xdf *****/
        for ( i = 31; i >= 0; --i )
            *function++ = fnt_MDRP;

        /***** 0xe0 - 0xff *****/
        for ( i = 31; i >= 0; --i )
            *function++ = fnt_MIRP;
}

/*
 *      Init routine, to be called at boot time.
 *      globalGS->function has to be set up when this function is called.
 *      rewrite initialization from p[] to *p++                                                 <3>
 *      restructure fnt_AngleInfo into fnt_FractPoint and int16                 <3>
 *
 *      Only gs->function is valid at this time.
 */

void fnt_Init( fnt_GlobalGraphicStateType* globalGS )
{
        fnt_DefaultJumpTable( globalGS->function );

        /* These 20 x and y pairs are all stepping patterns that have a repetition period of less than 9 pixels.
           They are sorted in order according to increasing period (distance). The period is expressed in
                pixels * fnt_pixelSize, and is a simple Euclidian distance. The x and y values are Fracts and they are
                at a 90 degree angle to the stepping pattern. Only stepping patterns for the first octant are stored.
                This means that we can derrive (20-1) * 8 = 152 different angles from this data base */

        globalGS->anglePoint = (fnt_FractPoint *)((char*)globalGS->function + MAXBYTE_INSTRUCTIONS * sizeof(voidFunc));
        globalGS->angleDistance = (int16*)(globalGS->anglePoint + MAXANGLES);
        {
                register Fract* coord = (Fract*)globalGS->anglePoint;
                register int16* dist = globalGS->angleDistance;

                /**              x                                               y                                              d       **/

                *coord++ = 0L;                  *coord++ = 1073741824L; *dist++ = 64;
                *coord++ = -759250125L; *coord++ = 759250125L;  *dist++ = 91;
                *coord++ = -480191942L; *coord++ = 960383883L;  *dist++ = 143;
                *coord++ = -339546978L; *coord++ = 1018640935L; *dist++ = 202;
                *coord++ = -595604800L; *coord++ = 893407201L;  *dist++ = 231;
                *coord++ = -260420644L; *coord++ = 1041682578L; *dist++ = 264;
                *coord++ = -644245094L; *coord++ = 858993459L;  *dist++ = 320;
                *coord++ = -210578097L; *coord++ = 1052890483L; *dist++ = 326;
                *coord++ = -398777702L; *coord++ = 996944256L;  *dist++ = 345;
                *coord++ = -552435611L; *coord++ = 920726018L;  *dist++ = 373;
                *coord++ = -176522068L; *coord++ = 1059132411L; *dist++ = 389;
                *coord++ = -670761200L; *coord++ = 838451500L;  *dist++ = 410;
                *coord++ = -151850025L; *coord++ = 1062950175L; *dist++ = 453;
                *coord++ = -294979565L; *coord++ = 1032428477L; *dist++ = 466;
                *coord++ = -422967626L; *coord++ = 986924461L;  *dist++ = 487;
                *coord++ = -687392765L; *coord++ = 824871318L;  *dist++ = 500;
                *coord++ = -532725129L; *coord++ = 932268975L;  *dist++ = 516;
                *coord++ = -133181282L; *coord++ = 1065450257L; *dist++ = 516;
                *coord++ = -377015925L; *coord++ = 1005375799L; *dist++ = 547;
                *coord   = -624099758L; *coord   = 873739662L;  *dist   = 551;
        }
}
#endif

#ifdef  GET_STACKSPACE
  int  MaxStackSize = 0;

  #define PUSH(p, x) \
    { \
      if (p - LocalGS.globalGS->stackBase > MaxStackSize) \
        MaxStackSize = p - LocalGS.globalGS->stackBase; \
      (*(p)++ = (x)); \
    }

#else
  #define PUSH( p, x ) ( *(p)++ = (x) )
#endif
  #define POP( p )     ( *(--p) )

#define BADCOMPILER

#ifdef BADCOMPILER
#define BOOLEANPUSH( p, x ) PUSH( p, ((x) ? 1 : 0) ) /* MPW 3.0 */
#else
#define BOOLEANPUSH( p, x ) PUSH( p, x )
#endif

#define MAX(a,b)        ((a) > (b) ? (a) : (b))

#ifdef DEBUG
void CHECK_RANGE (int32 n, int32 min, int32 max);
void CHECK_RANGE (int32 n, int32 min, int32 max)
{
  if (n > max || n < min)
    Debugger ();
}


void CHECK_ASSERTION (int expression);
void CHECK_ASSERTION (int expression)
{
  if (!expression)
    Debugger ();
}


void CHECK_CVT (fnt_LocalGraphicStateType* pGS, ArrayIndex cvt);
void CHECK_CVT (fnt_LocalGraphicStateType* pGS, ArrayIndex cvt)
{
  CHECK_RANGE ((int32)cvt, 0L, pGS->globalGS->cvtCount - 1L);
}


void CHECK_FDEF (fnt_LocalGraphicStateType* pGS, ArrayIndex fdef);
void CHECK_FDEF (fnt_LocalGraphicStateType* pGS, ArrayIndex fdef)
{
  CHECK_RANGE ((int32)fdef, 0L, pGS->globalGS->maxp->maxFunctionDefs - 1L);
}


#define CHECK_PROGRAM(a)


void CHECK_ELEMENT (fnt_LocalGraphicStateType* pGS, ArrayIndex elem);
void CHECK_ELEMENT (fnt_LocalGraphicStateType* pGS, ArrayIndex elem)
{
  CHECK_RANGE ((int32)elem, 0L, pGS->globalGS->maxp->maxElements - 1L);
}


void CHECK_ELEMENTPTR (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem);
void CHECK_ELEMENTPTR (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem)
{
  if (elem == &pGS->elements[1])
  {
    int maxctrs, maxpts;

    maxctrs = MAX (pGS->globalGS->maxp->maxContours, pGS->globalGS->maxp->maxCompositeContours);
    maxpts  = MAX (pGS->globalGS->maxp->maxPoints, pGS->globalGS->maxp->maxCompositePoints);

    CHECK_RANGE ((int32)elem->nc, 1L, (int32)maxctrs);
    CHECK_RANGE ((int32)elem->ep[elem->nc-1], 0L, maxpts - 1L);
  }
  else if (elem != &pGS->elements[0])
  {
    Debugger ();
  }
}


void CHECK_STORAGE (fnt_LocalGraphicStateType* pGS, ArrayIndex index);
void CHECK_STORAGE (fnt_LocalGraphicStateType* pGS, ArrayIndex index)
{
  CHECK_RANGE ((int32)index, 0L, pGS->globalGS->maxp->maxStorage - 1L);
}


void CHECK_STACK (fnt_LocalGraphicStateType* pGS);
void CHECK_STACK (fnt_LocalGraphicStateType* pGS)
{
  CHECK_RANGE ((int32)(pGS->stackPointer - pGS->globalGS->stackBase), 0L, pGS->globalGS->maxp->maxStackElements - 1L);
}


void CHECK_POINT (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, ArrayIndex pt);
void CHECK_POINT (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, ArrayIndex pt)
{
  CHECK_ELEMENTPTR (pGS,elem);
  if (pGS->elements == elem)
    CHECK_RANGE ((int32)pt, 0L, pGS->globalGS->maxp->maxTwilightPoints - 1L);
  else
    CHECK_RANGE ((int32)pt, 0L, elem->ep[elem->nc-1] + 2L);     /* phantom points */
}


void CHECK_CONTOUR (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, ArrayIndex ctr);
void CHECK_CONTOUR (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, ArrayIndex ctr)
{
  CHECK_ELEMENTPTR (pGS,elem);
  CHECK_RANGE ((int32)ctr, 0L, elem->nc - 1L);
}

#define CHECK_POP(s)                POP(s)
#define CHECK_PUSH(s, v)    PUSH(s, v)
#else
#define CHECK_RANGE(a,b,c)
#define CHECK_ASSERTION(a)
#define CHECK_CVT(pgs,b)
#define CHECK_POINT(pgs,b,c)
#define CHECK_CONTOUR(pgs,b,c)
#define CHECK_FDEF(pgs,b)
#define CHECK_PROGRAM(a)
#define CHECK_ELEMENT(pgs,b)
#define CHECK_ELEMENTPTR(pgs,b)
#define CHECK_STORAGE(pgs,b)
#define CHECK_STACK(pgs)
#define CHECK_POP(s)                POP(s)
#define CHECK_PUSH(s, v)    PUSH(s, v)
#endif

/*@@*/

#define GETBYTE(ptr)    ( (uint8)*ptr++ )
#define MABS(x)                 ( (x) < 0 ? (-(x)) : (x) )

#define BIT0( t ) ( (t) & 0x01 )
#define BIT1( t ) ( (t) & 0x02 )
#define BIT2( t ) ( (t) & 0x04 )
#define BIT3( t ) ( (t) & 0x08 )
#define BIT4( t ) ( (t) & 0x10 )
#define BIT5( t ) ( (t) & 0x20 )
#define BIT6( t ) ( (t) & 0x40 )
#define BIT7( t ) ( (t) & 0x80 )

/******** 12 BinaryOperators **********/
#define LT_CODE         0x50
#define LTEQ_CODE       0x51
#define GT_CODE         0x52
#define GTEQ_CODE       0x53
#define EQ_CODE         0x54
#define NEQ_CODE        0x55
#define AND_CODE        0x5A
#define OR_CODE         0x5B
#define ADD_CODE        0x60
#define SUB_CODE        0x61
#define DIV_CODE        0x62
#define MUL_CODE        0x63
#define MAX_CODE        0x8b
#define MIN_CODE        0x8c

/******** 9 UnaryOperators **********/
#define ODD_CODE                0x56
#define EVEN_CODE               0x57
#define NOT_CODE                0x5C
#define ABS_CODE                0x64
#define NEG_CODE                0x65
#define FLOOR_CODE              0x66
#define CEILING_CODE    0x67

/******** 6 RoundState Codes **********/
#define RTG_CODE                0x18
#define RTHG_CODE               0x19
#define RTDG_CODE               0x3D
#define ROFF_CODE               0x7A
#define RUTG_CODE               0x7C
#define RDTG_CODE               0x7D

/****** LocalGS Codes *********/
#define POP_CODE        0x21
#define SRP0_CODE       0x10
#define SRP1_CODE       0x11
#define SRP2_CODE       0x12
#define LLOOP_CODE      0x17
#define LMD_CODE        0x1A

/****** Element Codes *********/
#define SCE0_CODE       0x13
#define SCE1_CODE       0x14
#define SCE2_CODE       0x15
#define SCES_CODE       0x16

/****** Control Codes *********/
#define IF_CODE         0x58
#define ELSE_CODE       0x1B
#define EIF_CODE        0x59
#define ENDF_CODE       0x2d
#define MD_CODE         0x49

/* flags for UTP, IUP, MovePoint */
#define XMOVED 0x01
#define YMOVED 0x02

/* Set default values for all variables in globalGraphicsState DefaultParameterBlock
 *      Eventually, we should provide for a Default preprogram that could optionally be
 *      run at this time to provide a different set of default values.
 */
int FAR fnt_SetDefaults (fnt_GlobalGraphicStateType *globalGS)
{
  register fnt_ParameterBlock *par = &globalGS->defaultParBlock;

  par->RoundValue  = fnt_RoundToGrid;
  par->minimumDistance = fnt_pixelSize;
  par->wTCI = fnt_pixelSize * 17 / 16;
  par->sWCI = 0;
  par->sW   = 0;
  par->autoFlip = true;
  par->deltaBase = 9;
  par->deltaShift = 3;
  par->angleWeight = 128;
  par->scanControl = 0;
  par->instructControl = 0;
  return 0;
}


/*
 * We exit through here, when we detect serious errors.
 */
void fnt_Panic (GSP  int error)
{
  fs_longjmp (LocalGS.env, error); /* Do a gracefull recovery  */
}


/***************************/



/*
 * Illegal instruction panic
 */
PRIVATE void fnt_IllegalInstruction (GSP0)
{
  fnt_Panic (GSA  UNDEFINED_INSTRUCTION_ERR);
}


#define bitcount(a,count)     \
  {                           \
    count = 0;                \
    while (a)                 \
    {                         \
      a >>= 1;                \
      count++;                \
    }                         \
  }

/*
*      Since x and y are 26.6, and currently that means they are really 16.6,
*      when treated as Fract, they are 0.[8]22, so shift up to 0.30 for accuracy
*/

PRIVATE void fnt_Normalize (F26Dot6 x, F26Dot6 y, VECTOR*v)
{
  Fract x1, y1;

  CHECK_RANGE (x, -32768L << 6, 32767L << 6);
  CHECK_RANGE (y, -32768L << 6, 32767L << 6);

  {
    int shift;
    int count;
    F26Dot6 xx = x;
    F26Dot6 yy = y;

    if (xx < 0)
      xx = -xx;
    if (yy < 0)
      yy = -yy;
    if (xx < yy)
      xx = yy;
/*
*      0.5 <= max (x,y) < 1
*/
    bitcount(xx, count);
    shift = 8 * sizeof (Fract) - 2 - count;
    x1 = (Fract) x << shift;
    y1 = (Fract) y << shift;
  }
  {
    Fract length;
    if (length = FracSqrt (FracMul (x1, x1) + FracMul (y1, y1)))
    {
      v->x = FIXROUND (FracDiv(x1, length));
      v->y = FIXROUND (FracDiv(y1, length));
    }
    else
    {
      v->x = ONEVECTOR;
      v->y = 0;
    }
  }
}


/******************** BEGIN Rounding Routines ***************************/

/*
 * Internal rounding routine
 */
F26Dot6 fnt_RoundToDoubleGrid (GSP register F26Dot6 xin, F26Dot6 engine)
{
  register F26Dot6 x = xin;

  if (x >= 0)
  {
    x += engine;
    x += fnt_pixelSize / 4;
    x &= ~ (fnt_pixelSize / 2 - 1);
  }
  else
  {
    x = -x;
    x += engine;
    x += fnt_pixelSize / 4;
    x &= ~ (fnt_pixelSize / 2 - 1);
    x = -x;
  }
  if (( (int32) (xin ^ x)) < 0 && xin)
  {
    x = 0; /* The sign flipped, make zero */
  }
  return x;
}


/*
 * Internal rounding routine
 */
F26Dot6 fnt_RoundDownToGrid (GSP register F26Dot6 xin, F26Dot6 engine)
{
  register F26Dot6 x = xin;

  if (x >= 0)
  {
    x += engine;
    x &= ~ (fnt_pixelSize - 1);
  }
  else
  {
    x = -x;
    x += engine;
    x &= ~ (fnt_pixelSize - 1);
    x = -x;
  }
  if (( (int32) (xin ^ x)) < 0 && xin)
  {
    x = 0; /* The sign flipped, make zero */
  }
  return x;
}


/*
 * Internal rounding routine
 */
F26Dot6 fnt_RoundUpToGrid (GSP register F26Dot6 xin, F26Dot6 engine)
{
  register F26Dot6 x = xin;

  if (x >= 0)
  {
    x += engine;
    x += fnt_pixelSize - 1;
    x &= ~ (fnt_pixelSize - 1);
  }
  else
  {
    x = -x;
    x += engine;
    x += fnt_pixelSize - 1;
    x &= ~ (fnt_pixelSize - 1);
    x = -x;
  }
  if (( (int32) (xin ^ x)) < 0 && xin)
  {
    x = 0; /* The sign flipped, make zero */
  }
  return x;
}


/*
 * Internal rounding routine
 */
F26Dot6 fnt_RoundToGrid (GSP register F26Dot6 xin, F26Dot6 engine)
{
  register F26Dot6 x = xin;

  if (x >= 0)
  {
    x += engine;
    x += fnt_pixelSize / 2;
    x &= ~ (fnt_pixelSize - 1);
  }
  else
  {
    x = -x;
    x += engine;
    x += fnt_pixelSize / 2;
    x &= ~ (fnt_pixelSize - 1);
    x = -x;
  }
  if (( (int32) (xin ^ x)) < 0 && xin)
  {
    x = 0; /* The sign flipped, make zero */
  }
  return x;
}


/*
 * Internal rounding routine
 */
F26Dot6 fnt_RoundToHalfGrid (GSP register F26Dot6 xin, F26Dot6 engine)
{
  register F26Dot6 x = xin;

  if (x >= 0)
  {
    x += engine;
    x &= ~ (fnt_pixelSize - 1);
    x += fnt_pixelSize / 2;
  }
  else
  {
    x = -x;
    x += engine;
    x &= ~ (fnt_pixelSize - 1);
    x += fnt_pixelSize / 2;
    x = -x;
  }
  if (((xin ^ x)) < 0 && xin)
  {
    x = xin > 0 ? fnt_pixelSize / 2 : -fnt_pixelSize / 2; /* The sign flipped, make equal to smallest valid value */
  }
  return x;
}


/*
 * Internal rounding routine
 */
F26Dot6 fnt_RoundOff (GSP register F26Dot6 xin, F26Dot6 engine)
{
  register F26Dot6 x = xin;

  if (x >= 0)
  {
    x += engine;
  }
  else
  {
    x -= engine;
  }
  if (( (int32) (xin ^ x)) < 0 && xin)
  {
    x = 0; /* The sign flipped, make zero */
  }
  return x;
}


/*
 * Internal rounding routine
 */
F26Dot6 fnt_SuperRound (GSP  register F26Dot6 xin, F26Dot6 engine)
{
  register F26Dot6 x = xin;
  register fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

  if (x >= 0)
  {
    x += engine;
    x += pb->threshold - pb->phase;
    x &= pb->periodMask;
    x += pb->phase;
  }
  else
  {
    x = -x;
    x += engine;
    x += pb->threshold - pb->phase;
    x &= pb->periodMask;
    x += pb->phase;
    x = -x;
  }
  if (( (int32) (xin ^ x)) < 0 && xin)
  {
    x = xin > 0 ? pb->phase : -pb->phase; /* The sign flipped, make equal to smallest phase */
  }
  return x;
}


/*
 * Internal rounding routine
 */
F26Dot6 fnt_Super45Round (GSP  register F26Dot6 xin, F26Dot6 engine)
{
  register F26Dot6 x = xin;
  register fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

  if (x >= 0)
  {
    x += engine;
    x += pb->threshold - pb->phase;
    x = (F26Dot6) VECTORDIV (x, pb->period45);
    x  &= ~ (fnt_pixelSize - 1);
    x = (F26Dot6) VECTORMUL (x, pb->period45);
    x += pb->phase;
  }
  else
  {
    x = -x;
    x += engine;
    x += pb->threshold - pb->phase;
    x = (F26Dot6) VECTORDIV (x, pb->period45);
    x  &= ~ (fnt_pixelSize - 1);
    x = (F26Dot6) VECTORMUL (x, pb->period45);
    x += pb->phase;
    x = -x;
  }
  if (((xin ^ x)) < 0 && xin)
  {
    x = xin > 0 ? pb->phase : -pb->phase; /* The sign flipped, make equal to smallest phase */
  }
  return x;
}


/******************** END Rounding Routines ***************************/


/* 3-versions ************************************************************************/

/*
 * Moves the point in element by delta (measured against the projection vector)
 * along the freedom vector.
 */
PRIVATE void fnt_MovePoint (GSP
register fnt_ElementType *element,
register ArrayIndex point,
register F26Dot6 delta)
{
  register VECTORTYPE pfProj = LocalGS.pfProj;
  register VECTORTYPE fx = LocalGS.free.x;
  register VECTORTYPE fy = LocalGS.free.y;

  CHECK_POINT (&LocalGS, element, point);

  if (pfProj != ONEVECTOR)
  {
    if (fx)
    {
      element->x[point] += VECTORMULDIV (delta, fx, pfProj);
      element->f[point] |= XMOVED;
    }
    if (fy)
    {
      element->y[point] += VECTORMULDIV (delta, fy, pfProj);
      element->f[point] |= YMOVED;
    }
  }
  else
  {
    if (fx)
    {
      element->x[point] += VECTORMUL (delta, fx);
      element->f[point] |= XMOVED;
    }
    if (fy)
    {
      element->y[point] += VECTORMUL (delta, fy);
      element->f[point] |= YMOVED;
    }
  }
}


/*
 * For use when the projection and freedom vectors coincide along the x-axis.
 */
#ifndef IN_ASM

PRIVATE void fnt_XMovePoint (GSP fnt_ElementType*element, ArrayIndex point, register F26Dot6 delta)
{
  CHECK_POINT (&LocalGS, element, point);
  element->x[point] += delta;
  element->f[point] |= XMOVED;
}


/*
 * For use when the projection and freedom vectors coincide along the y-axis.
 */
PRIVATE void fnt_YMovePoint (GSP register fnt_ElementType *element, ArrayIndex point, F26Dot6 delta)
{
  CHECK_POINT (&LocalGS, element, point);
  element->y[point] += delta;
  element->f[point] |= YMOVED;
}

#endif

/*
 * projects x and y into the projection vector.
 */
PRIVATE F26Dot6 fnt_Project (GSP F26Dot6 x, F26Dot6 y)
{
  return (F26Dot6) (VECTORMUL (x, LocalGS.proj.x) + VECTORMUL (y, LocalGS.proj.y));
}


/*
 * projects x and y into the old projection vector.
 */
PRIVATE F26Dot6 fnt_OldProject (GSP F26Dot6 x, F26Dot6 y)
{
  return (F26Dot6) (VECTORMUL (x, LocalGS.oldProj.x) + VECTORMUL (y, LocalGS.oldProj.y));
}


/*
 * Projects when the projection vector is along the x-axis
 */
F26Dot6 fnt_XProject (GSP F26Dot6 x, F26Dot6 y)
{
  return (x);
}


/*
 * Projects when the projection vector is along the y-axis
 */
F26Dot6 fnt_YProject (GSP F26Dot6 x, F26Dot6 y)
{
  return (y);
}


/*************************************************************************/

/*** Compensation for Transformations ***/

/*
* Internal support routine, keep this guy FAST!!!!!!!          <3>
*/
PRIVATE Fixed fnt_GetCVTScale (GSP0)
{
  register VECTORTYPE pvx, pvy;
  register fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
/* Do as few Math routines as possible to gain speed */

  pvx = LocalGS.proj.x;
  pvy = LocalGS.proj.y;
  if (pvy)
  {
    if (pvx)
    {
      pvy = VECTORDOT (pvy, pvy);
      pvx = VECTORDOT (pvx, pvx);
      return FixMul (globalGS->cvtStretchY, VECTOR2FIX (pvy)) + FixMul (globalGS->cvtStretchX, VECTOR2FIX (pvx));
    }
    else        /* pvy == +1 or -1 */
      return globalGS->cvtStretchY;
  }
  else  /* pvx == +1 or -1 */
    return globalGS->cvtStretchX;
}


/*      Functions for function pointer in local graphic state
*/
#ifndef IN_ASM
PRIVATE F26Dot6 fnt_GetCVTEntryFast (GSP ArrayIndex n)
{
  CHECK_CVT (&LocalGS, n);
  return LocalGS.globalGS->controlValueTable[ n ];
}
#endif

PRIVATE F26Dot6 fnt_GetCVTEntrySlow (GSP register ArrayIndex n)
{
  register Fixed scale;

  CHECK_CVT (&LocalGS, n);
  scale = fnt_GetCVTScale (GSA0);
  return (F26Dot6) (FixMul (LocalGS.globalGS->controlValueTable[ n ], scale));
}


PRIVATE F26Dot6 fnt_GetSingleWidthFast (GSP0)
{
  return LocalGS.globalGS->localParBlock.scaledSW;
}


/*
 *
 */
PRIVATE F26Dot6 fnt_GetSingleWidthSlow (GSP0)
{
  register Fixed scale;

  scale = fnt_GetCVTScale (GSA0);
  return (F26Dot6) (FixMul (LocalGS.globalGS->localParBlock.scaledSW, scale));
}



/*************************************************************************/

PRIVATE void fnt_ChangeCvt (GSP fnt_ElementType*elem, ArrayIndex number, F26Dot6 delta)
{
  CHECK_CVT (&LocalGS, number);
  LocalGS.globalGS->controlValueTable[ number ] += delta;
}


/*
 * This is the tracing interpreter.
 */
PRIVATE void fnt_InnerTraceExecute (GSP register uint8 *ptr, register uint8 *eptr)
{
  register uint8 *oldInsPtr;
  register fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

  oldInsPtr = LocalGS.insPtr;
  LocalGS.insPtr = ptr;

  if (LocalGS.insPtr < eptr) /* so we exit properly out of CALL () */
  {
      /* in case the editor wants to exit */
    while (LocalGS.insPtr < eptr && LocalGS.TraceFunc)
    {
      LocalGS.TraceFunc (&LocalGS, eptr);
      function[ LocalGS.opCode = *LocalGS.insPtr++ ] (GSA0);

    }

    if (LocalGS.TraceFunc)
      LocalGS.TraceFunc (&LocalGS, eptr);
  }
  LocalGS.insPtr = oldInsPtr;
}


#ifdef DEBUG
#define LIMIT           65536L*64L

void CHECK_STATE (GSP0)
{
  fnt_ElementType * elem;
  F26Dot6 * x;
  F26Dot6 * y;
  int16 count;
  F26Dot6 xmin, xmax, ymin, ymax;

/*  if (!LocalGS.globalGS->glyphProgram) */
/*    return; */

  elem = &LocalGS.elements[1];
  x = elem->x;
  y = elem->y;
  count = elem->ep[elem->nc - 1];
  xmin = xmax = *x;
  ymin = ymax = *y;

  for (; count >= 0; --count)
  {
    if (*x < xmin)
      xmin = *x;
    else if (*x > xmax)
      xmax = *x;
    if (*y < ymin)
      ymin = *y;
    else if (*y > ymax)
      ymax = *y;
    x++, y++;
  }
  if (xmin < -LIMIT || xmax > LIMIT || ymin < -LIMIT || ymax > LIMIT)
    Debugger ();
}


#else
#define CHECK_STATE()
#endif

/*
 * This is the fast non-tracing interpreter.
 */
#ifndef IN_ASM
PRIVATE void fnt_InnerExecute (GSP register uint8 *ptr, uint8 *eptr)
{
  uint8 * oldInsPtr;

  oldInsPtr = LocalGS.insPtr;
  LocalGS.insPtr = ptr;

  while (LocalGS.insPtr < eptr)
    function[ LocalGS.opCode = *LocalGS.insPtr++ ] (GSA0);
  LocalGS.insPtr = oldInsPtr;
}
#endif


#ifdef DEBUG
PRIVATE F26Dot6 fnt_GetSingleWidthNil (GSP0);
PRIVATE F26Dot6 fnt_GetCVTEntryNil (GSP ArrayIndex n);

PRIVATE F26Dot6 fnt_GetSingleWidthNil (GSP0)
{
  Debugger ();
  return 0;
}

PRIVATE F26Dot6 fnt_GetCVTEntryNil (GSP ArrayIndex n)
{
  Debugger();
  return 0;
}
#endif

/*
 * Executes the font instructions.
 * This is the external interface to the interpreter.
 *
 * Parameter Description
 *
 * elements points to the character elements. Element 0 is always
 * reserved and not used by the actual character.
 *
 * ptr points at the first instruction.
 * eptr points to right after the last instruction
 *
 * globalGS points at the global graphics state
 *
 * TraceFunc is pointer to a callback functioned called with a pointer to the
 *              local graphics state if TraceFunc is not null.
 *
 * Note: The stuff globalGS is pointing at must remain intact
 *       between calls to this function.
 */
int     FAR fnt_Execute (fnt_ElementType *elements, uint8 *ptr, register uint8 *eptr,
fnt_GlobalGraphicStateType *globalGS, voidFunc TraceFunc)
{
#ifdef FSCFG_REENTRANT
  fnt_LocalGraphicStateType thisLocalGS;
  fnt_LocalGraphicStateType* pLocalGS = &thisLocalGS;
#endif

  LocalGS.globalGS = globalGS;

  LocalGS.elements = elements;
  LocalGS.Pt0 = LocalGS.Pt1 = LocalGS.Pt2 = 0;
  LocalGS.CE0 = LocalGS.CE1 = LocalGS.CE2 = &elements[1];
  LocalGS.free.x = LocalGS.proj.x = LocalGS.oldProj.x = ONEVECTOR;
  LocalGS.free.y = LocalGS.proj.y = LocalGS.oldProj.y = 0;
  LocalGS.pfProj = ONEVECTOR;
  LocalGS.MovePoint = fnt_XMovePoint;
  LocalGS.Project   = fnt_XProject;
  LocalGS.OldProject = fnt_XProject;
  LocalGS.loop = 0;         /* 1 less than count for faster loops. mrr */

  if (globalGS->pgmIndex == FONTPROGRAM)
  {
#ifdef DEBUG
    LocalGS.GetCVTEntry = fnt_GetCVTEntryNil;
    LocalGS.GetSingleWidth = fnt_GetSingleWidthNil;
#endif
    goto ASSIGN_POINTERS;
  }

  if (globalGS->pixelsPerEm <= 1)
    return NO_ERR;
  if (globalGS->identityTransformation)
  {
    LocalGS.GetCVTEntry = fnt_GetCVTEntryFast;
    LocalGS.GetSingleWidth = fnt_GetSingleWidthFast;
  }
  else
  {
    LocalGS.GetCVTEntry = fnt_GetCVTEntrySlow;
    LocalGS.GetSingleWidth = fnt_GetSingleWidthSlow;
  }

    if (globalGS->localParBlock.sW)
    {
/* We need to scale the single width for this size  */
      globalGS->localParBlock.scaledSW = globalGS->ScaleFuncCVT (&globalGS->scaleCVT, (F26Dot6)(globalGS->localParBlock.sW));
    }

ASSIGN_POINTERS:
    LocalGS.stackPointer = globalGS->stackBase;

#ifdef DJC
   (LocalGS.Interpreter = (LocalGS.TraceFunc = TraceFunc) ?  fnt_InnerTraceExecute : fnt_InnerExecute) (GSA ptr, eptr);
#else

   LocalGS.TraceFunc = (FntTraceFunc)(TraceFunc);

   if (LocalGS.TraceFunc) {
      LocalGS.Interpreter = fnt_InnerTraceExecute;
   } else {
      LocalGS.Interpreter = fnt_InnerExecute;
   }

   LocalGS.Interpreter(GSA ptr, eptr);

#endif


    return NO_ERR;
  }


/*************************************************************************/

/*** 2 internal LocalGS.pfProj computation support routines ***/

/*
 * Only does the check of LocalGS.pfProj
 */
  PRIVATE void fnt_Check_PF_Proj (GSP0)
  {
    register VECTORTYPE pfProj = LocalGS.pfProj;

    if (pfProj > -ONESIXTEENTHVECTOR && pfProj < ONESIXTEENTHVECTOR)
    {
      LocalGS.pfProj = (VECTORTYPE)(pfProj < 0 ? -ONEVECTOR : ONEVECTOR); /* Prevent divide by small number */
    }
  }


/*
 * Computes LocalGS.pfProj and then does the check
 */
  PRIVATE void fnt_ComputeAndCheck_PF_Proj (GSP0)
  {
    register VECTORTYPE pfProj;

    pfProj = VECTORDOT (LocalGS.proj.x, LocalGS.free.x) + VECTORDOT (LocalGS.proj.y, LocalGS.free.y);
    if (pfProj > -ONESIXTEENTHVECTOR && pfProj < ONESIXTEENTHVECTOR)
    {
      pfProj = (VECTORTYPE)(pfProj < 0 ? -ONEVECTOR : ONEVECTOR); /* Prevent divide by small number */
    }
    LocalGS.pfProj = pfProj;
  }



/******************************************/
/******** The Actual Instructions *********/
/******************************************/

/*
 * Set Vectors To Coordinate Axis - Y
 */
  PRIVATE void fnt_SVTCA_0 (GSP0)
  {
    LocalGS.free.x = LocalGS.proj.x = 0;
    LocalGS.free.y = LocalGS.proj.y = ONEVECTOR;
    LocalGS.MovePoint = fnt_YMovePoint;
    LocalGS.Project = fnt_YProject;
    LocalGS.OldProject = fnt_YProject;
    LocalGS.pfProj = ONEVECTOR;
  }

/*
 * Set Vectors To Coordinate Axis - X
 */
  PRIVATE void fnt_SVTCA_1 (GSP0)
  {
    LocalGS.free.x = LocalGS.proj.x = ONEVECTOR;
    LocalGS.free.y = LocalGS.proj.y = 0;
    LocalGS.MovePoint = fnt_XMovePoint;
    LocalGS.Project = fnt_XProject;
    LocalGS.OldProject = fnt_XProject;
    LocalGS.pfProj = ONEVECTOR;
  }

/*
 * Set Projection Vector To Coordinate Axis
 */
  PRIVATE void fnt_SPVTCA (GSP0)
  {
    if (BIT0 (LocalGS.opCode))
    {
      LocalGS.proj.x = ONEVECTOR;
      LocalGS.proj.y = 0;
      LocalGS.Project = fnt_XProject;
      LocalGS.pfProj = LocalGS.free.x;
    }
    else
    {
      LocalGS.proj.x = 0;
      LocalGS.proj.y = ONEVECTOR;
      LocalGS.Project = fnt_YProject;
      LocalGS.pfProj = LocalGS.free.y;
    }
    fnt_Check_PF_Proj (GSA0);
    LocalGS.MovePoint = fnt_MovePoint;
    LocalGS.OldProject = LocalGS.Project;
  }

/*
 * Set Freedom Vector to Coordinate Axis
 */
  PRIVATE void fnt_SFVTCA (GSP0)
  {
    if (BIT0 (LocalGS.opCode))
    {
      LocalGS.free.x = ONEVECTOR;
      LocalGS.free.y = 0;
      LocalGS.pfProj = LocalGS.proj.x;
    }
    else
    {
      LocalGS.free.x = 0;
      LocalGS.free.y = ONEVECTOR;
      LocalGS.pfProj = LocalGS.proj.y;
    }
    fnt_Check_PF_Proj (GSA0);
    LocalGS.MovePoint = fnt_MovePoint;
  }

/*
 * Set Projection Vector To Line
 */
  PRIVATE void fnt_SPVTL (GSP0)
  {
    register ArrayIndex arg1, arg2;

    arg2 = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);
    arg1 = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);

    CHECK_POINT (&LocalGS, LocalGS.CE2, arg2);
    CHECK_POINT (&LocalGS, LocalGS.CE1, arg1);

    fnt_Normalize (LocalGS.CE1->x[arg1] - LocalGS.CE2->x[arg2], LocalGS.CE1->y[arg1] - LocalGS.CE2->y[arg2], &LocalGS.proj);
    if (BIT0 (LocalGS.opCode))
    {
/* rotate 90 degrees */
      VECTORTYPE tmp     = LocalGS.proj.y;
      LocalGS.proj.y                 = LocalGS.proj.x;
      LocalGS.proj.x                 = -tmp;
    }
    fnt_ComputeAndCheck_PF_Proj (GSA0);
    LocalGS.MovePoint = fnt_MovePoint;
    LocalGS.Project = fnt_Project;
    LocalGS.OldProject = LocalGS.Project;
  }


/*
 * Set Dual Projection Vector To Line
 */
  PRIVATE void fnt_SDPVTL (GSP0)
  {
    register ArrayIndex arg1, arg2;

    arg2 = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);
    arg1 = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);

    CHECK_POINT (&LocalGS, LocalGS.CE2, arg2);
    CHECK_POINT (&LocalGS, LocalGS.CE1, arg1);

/* Do the current domain */
    fnt_Normalize (LocalGS.CE1->x[arg1] - LocalGS.CE2->x[arg2], LocalGS.CE1->y[arg1] - LocalGS.CE2->y[arg2], &LocalGS.proj);

/* Do the old domain */
    fnt_Normalize (LocalGS.CE1->ox[arg1] - LocalGS.CE2->ox[arg2], LocalGS.CE1->oy[arg1] - LocalGS.CE2->oy[arg2], &LocalGS.oldProj);

    if (BIT0 (LocalGS.opCode))
    {
/* rotate 90 degrees */
      VECTORTYPE tmp     = LocalGS.proj.y;
      LocalGS.proj.y                 = LocalGS.proj.x;
      LocalGS.proj.x                 = -tmp;

      tmp                                = LocalGS.oldProj.y;
      LocalGS.oldProj.y      = LocalGS.oldProj.x;
      LocalGS.oldProj.x      = -tmp;
    }
    fnt_ComputeAndCheck_PF_Proj (GSA0);

    LocalGS.MovePoint = fnt_MovePoint;
    LocalGS.Project = fnt_Project;
    LocalGS.OldProject = fnt_OldProject;
  }

/*
 * Set Freedom Vector To Line
 */
  PRIVATE void fnt_SFVTL (GSP0)
  {
    register ArrayIndex arg1, arg2;

    arg2 = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);
    arg1 = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);

    CHECK_POINT (&LocalGS, LocalGS.CE2, arg2);
    CHECK_POINT (&LocalGS, LocalGS.CE1, arg1);

    fnt_Normalize (LocalGS.CE1->x[arg1] - LocalGS.CE2->x[arg2], LocalGS.CE1->y[arg1] - LocalGS.CE2->y[arg2], &LocalGS.free);
    if (BIT0 (LocalGS.opCode))
    {
/* rotate 90 degrees */
      VECTORTYPE tmp     = LocalGS.free.y;
      LocalGS.free.y     = LocalGS.free.x;
      LocalGS.free.x     = -tmp;
    }
    fnt_ComputeAndCheck_PF_Proj (GSA0);
    LocalGS.MovePoint = fnt_MovePoint;
  }


/*
 * Write Projection Vector
 */
  PRIVATE void fnt_WPV (GSP0)
  {
    LocalGS.proj.y = (VECTORTYPE) CHECK_POP (LocalGS.stackPointer);
    LocalGS.proj.x = (VECTORTYPE) CHECK_POP (LocalGS.stackPointer);

    fnt_ComputeAndCheck_PF_Proj (GSA0);

    LocalGS.MovePoint = fnt_MovePoint;
    LocalGS.Project = fnt_Project;
    LocalGS.OldProject = LocalGS.Project;
  }

/*
 * Write Freedom vector
 */
  PRIVATE void fnt_WFV (GSP0)
  {
    LocalGS.free.y = (VECTORTYPE) CHECK_POP (LocalGS.stackPointer);
    LocalGS.free.x = (VECTORTYPE) CHECK_POP (LocalGS.stackPointer);

    fnt_ComputeAndCheck_PF_Proj (GSA0);

    LocalGS.MovePoint = fnt_MovePoint;
  }

/*
 * Read Projection Vector
 */
  PRIVATE void fnt_RPV (GSP0)
  {
    CHECK_PUSH (LocalGS.stackPointer, LocalGS.proj.x);
    CHECK_PUSH (LocalGS.stackPointer, LocalGS.proj.y);
  }

/*
 * Read Freedom Vector
 */
  PRIVATE void fnt_RFV (GSP0)
  {

     CHECK_PUSH (LocalGS.stackPointer, LocalGS.free.x);
    CHECK_PUSH (LocalGS.stackPointer, LocalGS.free.y);
  }

/*
 * Set Freedom Vector To Projection Vector
 */
  PRIVATE void fnt_SFVTPV (GSP0)
  {
    LocalGS.free = LocalGS.proj;
    LocalGS.pfProj = ONEVECTOR;
    LocalGS.MovePoint = fnt_MovePoint;
  }

/*
 * fnt_ISECT ()
 *
 * Computes the intersection of two lines without using floating point!!
 *
 * (1) Bx + dBx * t0 = Ax + dAx * t1
 * (2) By + dBy * t0 = Ay + dAy * t1
 *
 *  1  => (t1 = Bx - Ax + dBx * t0) / dAx
 *  +2 =>   By + dBy * t0 = Ay + dAy/dAx * [ Bx - Ax + dBx * t0 ]
 *     => t0 * [dAy/dAx * dBx - dBy] = By - Ay - dAy/dAx* (Bx-Ax)
 *     => t0 (dAy*DBx - dBy*dAx) = dAx (By - Ay) + dAy (Ax-Bx)
 *     => t0 = [dAx (By-Ay) + dAy (Ax-Bx)] / [dAy*dBx - dBy*dAx]
 *     => t0 = [dAx (By-Ay) - dAy (Bx-Ax)] / [dBx*dAy - dBy*dAx]
 *     t0 = N/D
 *     =>
 *          N = (By - Ay) * dAx - (Bx - Ax) * dAy;
 *              D = dBx * dAy - dBy * dAx;
 *      A simple floating point implementation would only need this, and
 *      the check to see if D is zero.
 *              But to gain speed we do some tricks and avoid floating point.
 *
 */
  PRIVATE void fnt_ISECT (GSP0)
  {
    register F26Dot6 N, D;
    register ArrayIndex arg1, arg2;
    F26Dot6 Bx, By, Ax, Ay;
    F26Dot6 dBx, dBy, dAx, dAy;

    {
      register fnt_ElementType*element = LocalGS.CE0;
      register F26Dot6*stack = LocalGS.stackPointer;

      arg2 = (ArrayIndex)CHECK_POP (stack); /* get one line */
      arg1 = (ArrayIndex)CHECK_POP (stack);
      dAx = element->x[arg2] - (Ax = element->x[arg1]);
      dAy = element->y[arg2] - (Ay = element->y[arg1]);

      element = LocalGS.CE1;
      arg2 = (ArrayIndex)CHECK_POP (stack); /* get the other line */
      arg1 = (ArrayIndex)CHECK_POP (stack);
      dBx = element->x[arg2] - (Bx = element->x[arg1]);
      dBy = element->y[arg2] - (By = element->y[arg1]);

      arg1 = (ArrayIndex)CHECK_POP (stack); /* get the point number */
      LocalGS.stackPointer = stack;
    }
    LocalGS.CE2->f[arg1] |= XMOVED | YMOVED;
    {
      register F26Dot6*elementx = LocalGS.CE2->x;
      register F26Dot6*elementy = LocalGS.CE2->y;
      if (dAy == 0)
      {
        if (dBx == 0)
        {
          elementx[arg1] = Bx;
          elementy[arg1] = Ay;
          return;
        }
        N = By - Ay;
        D = -dBy;
      }
      else if (dAx == 0)
      {
        if (dBy == 0)
        {
          elementx[arg1] = Ax;
          elementy[arg1] = By;
          return;
        }
        N = Bx - Ax;
        D = -dBx;
      }
      else if (MABS (dAx) >= MABS (dAy))
      {
/* To prevent out of range problems divide both N and D with the max */
        N = (By - Ay) - MulDiv26Dot6 (Bx - Ax, dAy, dAx);
        D = MulDiv26Dot6 (dBx, dAy, dAx) - dBy;
      }
      else
      {
        N = MulDiv26Dot6 (By - Ay, dAx, dAy) - (Bx - Ax);
        D = dBx - MulDiv26Dot6 (dBy, dAx, dAy);
      }

      if (D)
      {
        elementx[arg1] = Bx + (F26Dot6) MulDiv26Dot6 (dBx, N, D);
        elementy[arg1] = By + (F26Dot6) MulDiv26Dot6 (dBy, N, D);
      }
      else
      {
/* degenerate case: parallell lines, put point in the middle */
        elementx[arg1] = (Bx + (dBx >> 1) + Ax + (dAx >> 1)) >> 1;
        elementy[arg1] = (By + (dBy >> 1) + Ay + (dAy >> 1)) >> 1;
      }
    }
  }

/*
 * Load Minimum Distanc
 */
  PRIVATE void fnt_LMD (GSP0)
  {
    LocalGS.globalGS->localParBlock.minimumDistance = CHECK_POP (LocalGS.stackPointer);
  }

/*
 * Load Control Value Table Cut In
 */
  PRIVATE void fnt_LWTCI (GSP0)
  {
    LocalGS.globalGS->localParBlock.wTCI = CHECK_POP (LocalGS.stackPointer);
  }

/*
 * Load Single Width Cut In
 */
  PRIVATE void fnt_LSWCI (GSP0)
  {
    LocalGS.globalGS->localParBlock.sWCI = CHECK_POP (LocalGS.stackPointer);
  }

/*
 * Load Single Width , assumes value comes from the original domain, not the cvt or outline
 */
  PRIVATE void fnt_LSW (GSP0)
  {
    register fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
    register fnt_ParameterBlock *pb = &globalGS->localParBlock;

    pb->sW = (int16)CHECK_POP (LocalGS.stackPointer);

    pb->scaledSW = globalGS->ScaleFuncCVT (&globalGS->scaleCVT, (F26Dot6)pb->sW); /* measurement should not come from the outline */
  }

  PRIVATE void fnt_SetLocalGraphicState (GSP0)
  {
    int arg = (int)CHECK_POP (LocalGS.stackPointer);

    switch (LocalGS.opCode)
    {
    case SRP0_CODE:
      LocalGS.Pt0 = (ArrayIndex)arg;
      break;
    case SRP1_CODE:
      LocalGS.Pt1 = (ArrayIndex)arg;
      break;
    case SRP2_CODE:
      LocalGS.Pt2 = (ArrayIndex)arg;
      break;

    case LLOOP_CODE:
      LocalGS.loop = (LoopCount)arg - 1;
      break;

    case POP_CODE:
      break;
#ifdef DEBUG
    default:
      Debugger ();
      break;
#endif
    }
  }

  PRIVATE void fnt_SetElementPtr (GSP0)
  {
    ArrayIndex arg = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);
    fnt_ElementType * element = &LocalGS.elements[ arg ];

    CHECK_ELEMENT (&LocalGS, arg);

    switch (LocalGS.opCode)
    {
    case SCES_CODE:
      LocalGS.CE2 = element;
      LocalGS.CE1 = element;
    case SCE0_CODE:
      LocalGS.CE0 = element;
      break;
    case SCE1_CODE:
      LocalGS.CE1 = element;
      break;
    case SCE2_CODE:
      LocalGS.CE2 = element;
      break;
#ifdef DEBUG
    default:
      Debugger ();
      break;
#endif
    }
  }

/*
 * Super Round
 */
  PRIVATE void fnt_SROUND (GSP0)
  {
    register int        arg1 = (int)CHECK_POP (LocalGS.stackPointer);
    register fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

    fnt_SetRoundValues (GSA arg1, true);
    pb->RoundValue = fnt_SuperRound;
  }

/*
 * Super Round
 */
  PRIVATE void fnt_S45ROUND (GSP0)
  {
    register int        arg1 = (int)CHECK_POP (LocalGS.stackPointer);
    register fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

    fnt_SetRoundValues (GSA arg1, false);
    pb->RoundValue = fnt_Super45Round;
  }

/*
 *      These functions just set a field of the graphics state
 *      They pop no arguments
 */
  PRIVATE void fnt_SetRoundState (GSP0)
  {
    register FntRoundFunc *rndFunc = &LocalGS.globalGS->localParBlock.RoundValue;

    switch (LocalGS.opCode)
    {
    case RTG_CODE:
      *rndFunc = fnt_RoundToGrid;
      break;
    case RTHG_CODE:
      *rndFunc = fnt_RoundToHalfGrid;
      break;
    case RTDG_CODE:
      *rndFunc = fnt_RoundToDoubleGrid;
      break;
    case ROFF_CODE:
      *rndFunc = fnt_RoundOff;
      break;
    case RDTG_CODE:
      *rndFunc = fnt_RoundDownToGrid;
      break;
    case RUTG_CODE:
      *rndFunc = fnt_RoundUpToGrid;
      break;
#ifdef DEBUG
    default:
      Debugger ();
      break;
#endif
    }
  }


#define FRACSQRT2DIV2   11591
/*
 * Internal support routine for the super rounding routines
 */
  PRIVATE void fnt_SetRoundValues (GSP register int arg1, register int normalRound)
  {
    register int        tmp;
    register fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

    tmp = arg1 & 0xC0;

    if (normalRound)
    {
      switch (tmp)
      {
      case 0x00:
        pb->period = fnt_pixelSize / 2;
        break;
      case 0x40:
        pb->period = fnt_pixelSize;
        break;
      case 0x80:
        pb->period = fnt_pixelSize * 2;
        break;
      default:
        pb->period = 999; /* Illegal */
      }
      pb->periodMask = ~ (pb->period - 1);
    }
    else
    {
      pb->period45 = FRACSQRT2DIV2;
      switch (tmp)
      {
      case 0x00:
        pb->period45 >>= 1;
        break;
      case 0x40:
        break;
      case 0x80:
        pb->period45 <<= 1;
        break;
      default:
        pb->period45 = 999; /* Illegal */
      }
      tmp = (sizeof (VECTOR) * 8 - 2 - fnt_pixelShift);
      pb->period = (int16) ((pb->period45 + (1L << (tmp - 1))) >> tmp); /*convert from 2.30 to 26.6 */
    }

    tmp = arg1 & 0x30;
    switch (tmp)
    {
    case 0x00:
      pb->phase = 0;
      break;
    case 0x10:
      pb->phase = (pb->period + 2) >> 2;
      break;
    case 0x20:
      pb->phase = (pb->period + 1) >> 1;
      break;
    case 0x30:
      pb->phase = (pb->period + pb->period + pb->period + 2) >> 2;
      break;
    }
    tmp = arg1 & 0x0f;
    if (tmp == 0)
    {
      pb->threshold = pb->period - 1;
    }
    else
    {
      pb->threshold = ((tmp - 4) * pb->period + 4) >> 3;
    }
  }

/*
 * Read Advance Width
 */
  PRIVATE void fnt_RAW (GSP0)
  {
    F26Dot6* ox = LocalGS.elements[1].ox;
    ArrayIndex index = LocalGS.elements[1].ep[LocalGS.elements[1].nc - 1] + 1;      /* lsb point */

    CHECK_PUSH( LocalGS.stackPointer, ox[index+1] - ox[index] );
  }

/*
 * DUPlicate
 */
  PRIVATE void fnt_DUP (GSP0)
  {
    F26Dot6 top = LocalGS.stackPointer[-1];
    CHECK_PUSH (LocalGS.stackPointer, top);
  }

/*
 * CLEAR stack
 */
  PRIVATE void fnt_CLEAR (GSP0)
  {
    LocalGS.stackPointer = LocalGS.globalGS->stackBase;
  }

/*
 * SWAP
 */
#ifndef IN_ASM
  PRIVATE void fnt_SWAP (GSP0)
  {
    register F26Dot6*stack = LocalGS.stackPointer;
    register F26Dot6 arg2 = CHECK_POP (stack);
    register F26Dot6 arg1 = CHECK_POP (stack);

    CHECK_PUSH (stack, arg2);
    CHECK_PUSH (stack, arg1);
  }
#endif

/*
 * DEPTH
 */
  PRIVATE void fnt_DEPTH (GSP0)
  {
    F26Dot6 depth = (F26Dot6)(LocalGS.stackPointer - LocalGS.globalGS->stackBase);
    CHECK_PUSH (LocalGS.stackPointer, depth);
  }

/*
 * Copy INDEXed value
 */
  PRIVATE void fnt_CINDEX (GSP0)
  {
    register ArrayIndex arg1;
    register F26Dot6 tmp;
    register F26Dot6*stack = LocalGS.stackPointer;

    arg1 = (ArrayIndex)CHECK_POP (stack);
    tmp = * (stack - arg1);
    CHECK_PUSH (stack , tmp);
  }

/*
 * Move INDEXed value
 */
  PRIVATE void fnt_MINDEX (GSP0)
  {
    register ArrayIndex arg1;
    register F26Dot6 tmp, *p;
    register F26Dot6*stack = LocalGS.stackPointer;

    arg1 = (ArrayIndex)CHECK_POP (stack);
    tmp = * (p = (stack - arg1));
    if (arg1)
    {
      do
      {
        *p = * (p + 1);
        p++;
      } while (--arg1);
      CHECK_POP (stack);
    }
    CHECK_PUSH (stack, tmp);
    LocalGS.stackPointer = stack;
  }

/*
 *      Rotate element 3 to the top of the stack                        <4>
 *      Thanks to Oliver for the obscure code.
 */
  PRIVATE void fnt_ROTATE (GSP0)
  {
    register F26Dot6 *stack = LocalGS.stackPointer;
    register F26Dot6 element1 = *--stack;
    register F26Dot6 element2 = *--stack;
    *stack = element1;
    element1 = *--stack;
    *stack = element2;
    * (stack + 2) = element1;
  }

/*
 * Move Direct Absolute Point
 */
  PRIVATE void fnt_MDAP (GSP0)
  {
    register F26Dot6 proj;
    register fnt_ElementType*ce0 = LocalGS.CE0;
    register fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;
    register ArrayIndex ptNum;

    ptNum = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);
    LocalGS.Pt0 = LocalGS.Pt1 = ptNum;

    if (BIT0 (LocalGS.opCode))
    {
      proj = (*LocalGS.Project) (GSA ce0->x[ptNum], ce0->y[ptNum]);
      proj = pb->RoundValue (GSA proj, LocalGS.globalGS->engine[0]) - proj;
    }
    else
      proj = 0;         /* mark the point as touched */

    (*LocalGS.MovePoint) (GSA ce0, ptNum, proj);
  }

/*
 * Move Indirect Absolute Point
 */
  PRIVATE void fnt_MIAP (GSP0)
  {
    register ArrayIndex ptNum;
    register F26Dot6 newProj, origProj;
    register fnt_ElementType*ce0 = LocalGS.CE0;
    register fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

    newProj = LocalGS.GetCVTEntry (GSA (ArrayIndex) CHECK_POP (LocalGS.stackPointer));
    ptNum = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);

    CHECK_POINT (&LocalGS, ce0, ptNum);
    LocalGS.Pt0 = LocalGS.Pt1 = ptNum;

    if (ce0 == LocalGS.elements)            /* twilightzone */
    {
      ce0->x[ptNum] = ce0->ox[ptNum] = (F26Dot6) VECTORMUL (newProj, LocalGS.proj.x);
      ce0->y[ptNum] = ce0->oy[ptNum] = (F26Dot6) VECTORMUL (newProj, LocalGS.proj.y);
    }

    origProj = (*LocalGS.Project) (GSA ce0->x[ptNum], ce0->y[ptNum]);

    if (BIT0 (LocalGS.opCode))
    {
      register F26Dot6 tmp = newProj -origProj;
      if (tmp < 0)
        tmp = -tmp;
      if (tmp > pb->wTCI)
        newProj = origProj;
      newProj = pb->RoundValue (GSA newProj, LocalGS.globalGS->engine[0]);
    }

    newProj -= origProj;
    (*LocalGS.MovePoint) (GSA ce0, ptNum, newProj);
  }

/*
 * Interpolate Untouched Points
 */
#ifndef IN_ASM

#define fnt_NextPt1(pt) ((pt) == ep_ctr ? sp_ctr : pt+1)

  PRIVATE void fnt_IUP (GSP0)
  {
    register ArrayIndex pt;
    register F26Dot6 *ooCoord;          /* Jean made me lie, these are really ints */
    LoopCount ctr;
    F26Dot6 * coord, *oCoord;
    int mask;
    ArrayIndex ptOrg, end;
    ArrayIndex ep_ctr, sp_ctr;
    fnt_ElementType *pCE2 = LocalGS.CE2;
    uint8  *pFlags = pCE2->f;

    if (LocalGS.opCode & 0x01)
    {
        /* do x */
      coord = pCE2->x;
      oCoord = pCE2->ox;
      ooCoord = pCE2->oox;
      mask = XMOVED;
    }
    else
    {
        /* do y */
      coord = pCE2->y;
      oCoord = pCE2->oy;
      ooCoord = pCE2->ooy;
      mask = YMOVED;
    }

      /* loop through contours */
    for (ctr = 0; ctr < pCE2->nc; ctr++)
    {
      sp_ctr = pt = pCE2->sp[ctr];
      ep_ctr = pCE2->ep[ctr];
      while (! (pFlags[pt] & mask) && pt <= ep_ctr)
        pt++;
      if (pt > ep_ctr)
        continue;
      ptOrg = pt;
      do
      {
        ArrayIndex start;
        ArrayIndex ptMin, ptMax;
        F26Dot6 _min, o_min, oo_min, dmin, oo_delta;

        do
        {
          start = pt;
          pt = fnt_NextPt1 (pt);
        }
        while (ptOrg != pt && (pFlags[pt] & mask));

        if (ptOrg == pt)
          break;

        end = pt;
        do
          end = fnt_NextPt1 (end);
        while (!(pFlags[end] & mask));

        if (ooCoord[start] < ooCoord[end])
        {
          ptMin = start;
          ptMax = end;
        }
        else
        {
          ptMin = end;
          ptMax = start;
        }

        _min  = coord[ptMin];
        o_min = oCoord[ptMin];
        dmin  = _min - o_min;
        oo_delta = ooCoord[ptMax] - (oo_min = ooCoord[ptMin]);

        if (oo_delta)
        {
          F26Dot6 dmax;
          F26Dot6 _delta, o_max, corr, oCoord_pt;
          register int32 tmp;

          o_max = oCoord[ptMax];
          dmax = _delta  = coord[ptMax];
          dmax -= o_max;
          _delta -= _min;

          if (oo_delta < 32768 && _delta < 32768)
          {
            corr = oo_delta >> 1;
            for (; pt != end; pt = fnt_NextPt1 (pt))
            {
              oCoord_pt = oCoord[pt];
              if (oCoord_pt > o_min && oCoord_pt < o_max)
              {
                tmp = SHORTMUL (ooCoord[pt] - oo_min, _delta);
                tmp += corr;
                tmp /= oo_delta;
                coord[pt] = (F26Dot6) tmp + _min;
              }
              else
              {
                if (oCoord_pt >= o_max)
                  oCoord_pt += dmax;
                else
                  oCoord_pt += dmin;
                coord[pt] = oCoord_pt;
              }
            }
          }
          else
          {
            Fixed ratio;
            int firstTime;

            firstTime = true;
            for (; pt != end; pt = fnt_NextPt1 (pt))
            {
              tmp = oCoord[pt];
              if (tmp <= o_min)
                tmp += dmin;
              else
                if (tmp >= o_max)
                  tmp += dmax;
                else
                {
                  if (firstTime)
                  {
                    ratio = FixDiv (_delta, oo_delta);
                    firstTime = 0;
                  }
                  tmp = ooCoord[pt];
                  tmp -= oo_min;
                  tmp = FixMul (tmp, ratio);
                  tmp += _min;
                }
              coord[pt] = (F26Dot6) tmp;
            }
          }
        }
        else
          while (pt != end)
          {
            coord[pt] += dmin;
            pt = fnt_NextPt1 (pt);
          }
      } while (pt != ptOrg);
    }
  }

#endif

  PRIVATE fnt_ElementType*fnt_SH_Common (GSP F26Dot6*dx, F26Dot6*dy, ArrayIndex*point)
  {
    F26Dot6 proj;
    ArrayIndex pt;
    fnt_ElementType * element;

    if (BIT0 (LocalGS.opCode))
    {
      pt = LocalGS.Pt1;
      element = LocalGS.CE0;
    }
    else
    {
      pt = LocalGS.Pt2;
      element = LocalGS.CE1;
    }
    proj = (*LocalGS.Project) (GSA element->x[pt] - element->ox[pt], element->y[pt] - element->oy[pt]);

    if (LocalGS.pfProj != ONEVECTOR)
    {
      if (LocalGS.free.x)
        *dx = (F26Dot6) VECTORMULDIV (proj, LocalGS.free.x, LocalGS.pfProj);
      if (LocalGS.free.y)
        *dy = (F26Dot6) VECTORMULDIV (proj, LocalGS.free.y, LocalGS.pfProj);
    }
    else
    {
      if (LocalGS.free.x)
        *dx = (F26Dot6) VECTORMUL (proj, LocalGS.free.x);
      if (LocalGS.free.y)
        *dy = (F26Dot6) VECTORMUL (proj, LocalGS.free.y);
    }
    *point = pt;
    return element;
  }

  PRIVATE void fnt_SHP_Common (GSP F26Dot6 dx, F26Dot6 dy)
  {
    register fnt_ElementType*CE2 = LocalGS.CE2;
    register LoopCount count = LocalGS.loop;
    for (; count >= 0; --count)
    {
      ArrayIndex point = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);
      if (LocalGS.free.x)
      {
        CE2->x[point] += dx;
        CE2->f[point] |= XMOVED;
      }
      if (LocalGS.free.y)
      {
        CE2->y[point] += dy;
        CE2->f[point] |= YMOVED;
      }
    }
    LocalGS.loop = 0;
  }

/*
 * SHift Point
 */
  PRIVATE void fnt_SHP (GSP0)
  {
    F26Dot6 dx, dy;
    ArrayIndex point;

    fnt_SH_Common (GSA &dx, &dy, &point);
    fnt_SHP_Common (GSA dx, dy);
  }

/*
 * SHift Contour
 */
  PRIVATE void fnt_SHC (GSP0)
  {
    register fnt_ElementType *element;
    register F26Dot6 dx, dy;
    register ArrayIndex contour, point;

    {
      F26Dot6 x=0, y=0;
      ArrayIndex pt;
      element = fnt_SH_Common (GSA &x, &y, &pt);
      point = pt;
      dx = x;
      dy = y;
    }
    contour = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);

    CHECK_CONTOUR (&LocalGS, LocalGS.CE2, contour);

    {
      VECTORTYPE fvx = LocalGS.free.x;
      VECTORTYPE fvy = LocalGS.free.y;
      register fnt_ElementType*CE2 = LocalGS.CE2;
      ArrayIndex currPt = CE2->sp[contour];
      LoopCount count = CE2->ep[contour] - currPt;
      CHECK_POINT (&LocalGS, CE2, currPt + count);
      for (; count >= 0; --count)
      {
        if (currPt != point || element != CE2)
        {
          if (fvx)
          {
            CE2->x[currPt] += dx;
            CE2->f[currPt] |= XMOVED;
          }
          if (fvy)
          {
            CE2->y[currPt] += dy;
            CE2->f[currPt] |= YMOVED;
          }
        }
        currPt++;
      }
    }
  }

/*
 * SHift Element                        <4>
 */
  PRIVATE void fnt_SHE (GSP0)
  {
    register fnt_ElementType *element;
    register F26Dot6 dx=0, dy=0;
    ArrayIndex firstPoint, origPoint, lastPoint, arg1;

    {
      F26Dot6 x=0, y;
      element = fnt_SH_Common (GSA &x, &y, &origPoint);
      dx = x;
      dy = y;
    }

    arg1 = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);
    CHECK_ELEMENT (&LocalGS, arg1);

    lastPoint = LocalGS.elements[arg1].ep[LocalGS.elements[arg1].nc - 1];
    CHECK_POINT (&LocalGS, &LocalGS.elements[arg1], lastPoint);
    firstPoint  = LocalGS.elements[arg1].sp[0];
    CHECK_POINT (&LocalGS, &LocalGS.elements[arg1], firstPoint);

/*** changed this                       <4>
        do {
                if (origPoint != firstPoint || element != &LocalGS.elements[arg1]) {
                        if (LocalGS.free.x) {
                                LocalGS.elements[ arg1 ].x[firstPoint] += dx;
                                LocalGS.elements[ arg1 ].f[firstPoint] |= XMOVED;
                        }
                        if (LocalGS.free.y) {
                                LocalGS.elements[ arg1 ].y[firstPoint] += dy;
                                LocalGS.elements[ arg1 ].f[firstPoint] |= YMOVED;
                        }
                }
                firstPoint++;
        } while (firstPoint <= lastPoint);
***** To this ? *********/

    if (element != &LocalGS.elements[arg1])         /* we're in different zones */
      origPoint = -1;                                           /* no need to skip orig point */
    {
      register int8 mask = 0;
      if (LocalGS.free.x)
      {
        register F26Dot6 deltaX = dx;
        register F26Dot6*x = &LocalGS.elements[ arg1 ].x[firstPoint];
        register LoopCount count = origPoint -firstPoint -1;
        for (; count >= 0; --count)
          *x++ += deltaX;
        if (origPoint == -1)
          count = lastPoint - firstPoint;
        else
        {
          count = lastPoint - origPoint - 1;
          x++;                                                  /* skip origPoint */
        }
        for (; count >= 0; --count)
          *x++ += deltaX;
        mask = XMOVED;
      }
      if (LocalGS.free.y)           /* fix me semore */
      {
        register F26Dot6 deltaY = dy;
        register F26Dot6*y = &LocalGS.elements[ arg1 ].y[firstPoint];
        register uint8*f = &LocalGS.elements[ arg1 ].f[firstPoint];
        register LoopCount count = origPoint -firstPoint -1;
        for (; count >= 0; --count)
        {
          *y++ += deltaY;
          *f++ |= mask;
        }
        if (origPoint == -1)
          count = lastPoint - firstPoint;
        else
        {
          count = lastPoint - origPoint - 1;
          y++, f++;                                             /* skip origPoint */
        }
        mask |= YMOVED;
        for (; count >= 0; --count)
        {
          *y++ += deltaY;
          *f++ |= mask;
        }
      }
    }
  }

/*
 * SHift point by PIXel amount
 */
  PRIVATE void fnt_SHPIX (GSP0)
  {
    register F26Dot6 proj, dx, dy;

    proj = CHECK_POP (LocalGS.stackPointer);
    if (LocalGS.free.x)
      dx = (F26Dot6) VECTORMUL (proj, LocalGS.free.x);
    if (LocalGS.free.y)
      dy = (F26Dot6) VECTORMUL (proj, LocalGS.free.y);

    fnt_SHP_Common (GSA dx, dy);
  }

/*
 * Interpolate Point
 */
#ifndef IN_ASM

void fnt_IP (GSP0)
{
  register ArrayIndex arg1;
  F26Dot6 oldRange;
  F26Dot6 proj;
  FntMoveFunc MovePoint = LocalGS.MovePoint;
  LoopCount cLoop = LocalGS.loop;
  fnt_ElementType * pCE0 = LocalGS.CE0;
  fnt_ElementType * pCE1 = LocalGS.CE1;
  fnt_ElementType * pCE2 = LocalGS.CE2;
  boolean twilight = pCE0 == LocalGS.elements || LocalGS.CE1 == LocalGS.elements || pCE2 == LocalGS.elements;
  int o_oo = twilight ? 0 : (int)(pCE2->oox - pCE2->ox);
  F26Dot6 x_RP1 = pCE0->x[LocalGS.Pt1];
  F26Dot6 * pCE2_x =  pCE2->x;
  F26Dot6 ox_RP1 = (pCE0->ox + o_oo)[LocalGS.Pt1];
  F26Dot6 * pCE2_ox = pCE2->ox + o_oo;
  ArrayIndex RP2 = LocalGS.Pt2;

  LocalGS.loop = 0;
  if (LocalGS.Project == fnt_XProject)
  {
      if (oldRange = (pCE1->ox + o_oo)[RP2] - ox_RP1)
        proj = pCE1->x[RP2] - x_RP1;

    for (; cLoop >= 0; cLoop--)
    {
        /* old ratio = old projection / oldRange , desired projection  = oldRatio * currentRange */
        /* Otherwise => desired projection = old projection */
      arg1 = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);
      MovePoint(GSA pCE2, arg1, (oldRange ? (F26Dot6) MulDiv26Dot6( proj, pCE2_ox[arg1] - ox_RP1, oldRange ) : pCE2_ox[arg1] - ox_RP1)
          -(pCE2_x[arg1] - x_RP1));
    }
  }
  else
  {
    F26Dot6 y_RP1 = pCE0->y[LocalGS.Pt1];
    F26Dot6 oy_RP1 = (pCE0->oy + o_oo)[LocalGS.Pt1];
    F26Dot6 * pCE2_y =  pCE2->y;
    F26Dot6 * pCE2_oy = pCE2->oy + o_oo;

    if (LocalGS.Project == fnt_YProject)
    {
      FntProject Project    = LocalGS.Project;
      FntProject OldProject = LocalGS.OldProject;

      if (oldRange = (pCE1->oy + o_oo)[RP2] - oy_RP1)
        proj = pCE1->y[RP2] - y_RP1;

      for (; cLoop >= 0; cLoop--)
      {
  /* old ratio = old projection / oldRange , desired projection  = oldRatio * currentRange */
  /* Otherwise => desired projection = old projection */
        arg1 = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);
        MovePoint (GSA pCE2, arg1, (oldRange ? (F26Dot6) MulDiv26Dot6(proj, pCE2_oy[arg1] - oy_RP1, oldRange) : pCE2_oy[arg1] - oy_RP1)
            -(pCE2_y[arg1] - y_RP1));
      }
    }
    else
    {
      FntProject Project    = LocalGS.Project;
      FntProject OldProject = LocalGS.OldProject;

      if (oldRange = OldProject (GSA (pCE1->ox + o_oo)[RP2] - ox_RP1, (pCE1->oy + o_oo)[RP2] - oy_RP1))
        proj = Project (GSA pCE1->x[RP2] - x_RP1, pCE1->y[RP2] - y_RP1);

      for (; cLoop >= 0; cLoop--)
      {
  /* old ratio = old projection / oldRange , desired projection  = oldRatio * currentRange */
  /* Otherwise => desired projection = old projection */
        arg1 = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);
        MovePoint (GSA pCE2, arg1, (oldRange ? (F26Dot6) MulDiv26Dot6(proj, Project (GSA pCE2_ox[arg1] - ox_RP1, pCE2_oy[arg1] -
            oy_RP1), oldRange) : Project (GSA pCE2_ox[arg1] - ox_RP1, pCE2_oy[arg1] - oy_RP1)) - Project (GSA pCE2_x[arg1] - x_RP1,
             pCE2_y[arg1] - y_RP1));
      }
    }
  }
}
#endif

/*
 * Move Stack Indirect Relative Point
 */
  void fnt_MSIRP (GSP0)
  {
    register fnt_ElementType*CE0 = LocalGS.CE0;
    register fnt_ElementType*CE1 = LocalGS.CE1;
    register ArrayIndex Pt0 = LocalGS.Pt0;
    register F26Dot6 dist = CHECK_POP (LocalGS.stackPointer); /* distance   */
    register ArrayIndex pt2 = (ArrayIndex)CHECK_POP (LocalGS.stackPointer); /* point #    */

    if (CE1 == LocalGS.elements)
    {
      CE1->ox[pt2] = CE0->ox[Pt0] + (F26Dot6) VECTORMUL (dist, LocalGS.proj.x);
      CE1->oy[pt2] = CE0->oy[Pt0] + (F26Dot6) VECTORMUL (dist, LocalGS.proj.y);
      CE1->x[pt2] = CE1->ox[pt2];
      CE1->y[pt2] = CE1->oy[pt2];
    }
    dist -= (*LocalGS.Project) (GSA CE1->x[pt2] - CE0->x[Pt0], CE1->y[pt2] - CE0->y[Pt0]);
    (*LocalGS.MovePoint) (GSA CE1, pt2, dist);
    LocalGS.Pt1 = Pt0;
    LocalGS.Pt2 = pt2;
    if (BIT0 (LocalGS.opCode))
    {
      LocalGS.Pt0 = pt2; /* move the reference point */
    }
  }

/*
 * Align Relative Point
 */
  PRIVATE void fnt_ALIGNRP (GSP0)
  {
    register fnt_ElementType*ce1 = LocalGS.CE1;
    register F26Dot6 pt0x = LocalGS.CE0->x[LocalGS.Pt0];
    register F26Dot6 pt0y = LocalGS.CE0->y[LocalGS.Pt0];

    for (; LocalGS.loop >= 0; --LocalGS.loop)
    {
      register ArrayIndex ptNum = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);
      register F26Dot6 proj = -(* LocalGS.Project) (GSA ce1->x[ptNum] - pt0x, ce1->y[ptNum] - pt0y);
      (*LocalGS.MovePoint) (GSA ce1, ptNum, proj);
    }
    LocalGS.loop = 0;
  }


/*
 * Align Two Points (by moving both of them)
 */
  PRIVATE void fnt_ALIGNPTS (GSP0)
  {
    register ArrayIndex pt1, pt2;
    register F26Dot6 move1, dist;

    pt2  = (ArrayIndex)CHECK_POP (LocalGS.stackPointer); /* point # 2   */
    pt1  = (ArrayIndex)CHECK_POP (LocalGS.stackPointer); /* point # 1   */
/* We do not have to check if we are in character element zero (the twilight zone)
           since both points already have to have defined values before we execute this instruction */
    dist = LocalGS.CE0->x[pt2] - LocalGS.CE1->x[pt1];
    move1 = LocalGS.CE0->y[pt2] - LocalGS.CE1->y[pt1];
    if (LocalGS.Project != fnt_XProject)
    {
      if (LocalGS.Project == fnt_YProject)
        dist = move1;
      else
        dist = (*LocalGS.Project) (GSA dist, move1);
    }

    move1 = dist >> 1;
    (*LocalGS.MovePoint) (GSA LocalGS.CE0, pt1, move1);
    (*LocalGS.MovePoint) (GSA LocalGS.CE1, pt2, move1 - dist); /* make sure the total movement equals tmp32 */
  }

/*
 * Set Angle Weight
 */
  PRIVATE void fnt_SANGW (GSP0)
  {
    LocalGS.globalGS->localParBlock.angleWeight = (int16)CHECK_POP (LocalGS.stackPointer);
  }

/*
 * Flip Point
 */
  PRIVATE void fnt_FLIPPT (GSP0)
  {
    register uint8 *onCurve = LocalGS.CE0->onCurve;
    register F26Dot6*stack = LocalGS.stackPointer;
    register LoopCount count = LocalGS.loop;

    for (; count >= 0; --count)
    {
      register ArrayIndex point = (ArrayIndex)CHECK_POP (stack);
      onCurve[ point ] ^= ONCURVE;
    }
    LocalGS.loop = 0;

    LocalGS.stackPointer = stack;
  }

/*
 * Flip On a Range
 */
  PRIVATE void fnt_FLIPRGON (GSP0)
  {
    register ArrayIndex lo, hi;
    register LoopCount count;
    register uint8 *onCurve = LocalGS.CE0->onCurve;
    register F26Dot6*stack = LocalGS.stackPointer;

    hi = (ArrayIndex)CHECK_POP (stack);
    CHECK_POINT (&LocalGS, LocalGS.CE0, hi);
    lo = (ArrayIndex)CHECK_POP (stack);
    CHECK_POINT (&LocalGS, LocalGS.CE0, lo);

    onCurve += lo;
    for (count = (LoopCount) (hi - lo); count >= 0; --count)
      *onCurve++ |= ONCURVE;
    LocalGS.stackPointer = stack;
  }

/*
 * Flip On a Range
 */
  PRIVATE void fnt_FLIPRGOFF (GSP0)
  {
    register ArrayIndex lo, hi;
    register LoopCount count;
    register uint8 *onCurve = LocalGS.CE0->onCurve;

    hi = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);
    CHECK_POINT (&LocalGS, LocalGS.CE0, hi);
    lo = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);
    CHECK_POINT (&LocalGS, LocalGS.CE0, lo);

    onCurve += lo;
    for (count = (LoopCount) (hi - lo); count >= 0; --count)
      *onCurve++ &= ~ONCURVE;
  }

/* 4/22/90 rwb - made more general
 * Sets lower 16 flag bits of ScanControl variable.  Sets scanContolIn if we are in one
 * of the preprograms; else sets scanControlOut.
 *
 * stack: value => -;
 *
 */
  PRIVATE void fnt_SCANCTRL (GSP0)
  {
    register fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
    register fnt_ParameterBlock *pb = &globalGS->localParBlock;

    pb->scanControl = (pb->scanControl & 0xFFFF0000) | CHECK_POP (LocalGS.stackPointer);
  }

/* 5/24/90 rwb
 * Sets upper 16 bits of ScanControl variable. Sets scanContolIn if we are in one
 * of the preprograms; else sets scanControlOut.
 */

  PRIVATE void fnt_SCANTYPE (GSP0)
  {
    register fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
    register fnt_ParameterBlock *pb = &globalGS->localParBlock;
    register int        value = (int)CHECK_POP (LocalGS.stackPointer);
    register int32 *scanPtr = & (pb->scanControl);
    if (value == 0)
      *scanPtr &= 0xFFFF;
    else if (value == 1)
      *scanPtr = (*scanPtr & 0xFFFF) | STUBCONTROL;
    else if (value == 2)
      *scanPtr = (*scanPtr & 0xFFFF) | NODOCONTROL;
  }

/* 6/28/90 rwb
 * Sets instructControl flags in global graphic state.  Only legal in pre program.
 * A selector is used to choose the flag to be set.
 * Bit0 - NOGRIDFITFLAG - if set, then truetype instructions are not executed.
 *              A font may want to use the preprogram to check if the glyph is rotated or
 *              transformed in such a way that it is better to not gridfit the glyphs.
 * Bit1 - DEFAULTFLAG - if set, then changes in localParameterBlock variables in the
 *              globalGraphics state made in the CVT preprogram are not copied back into
 *              the defaultParameterBlock.  So, the original default values are the starting
 *              values for each glyph.
 *
 * stack: value, selector => -;
 *
 */
  PRIVATE void fnt_INSTCTRL (GSP0)  /* <13> */
  {
    register fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
    register int32 *ic = &globalGS->localParBlock.instructControl;
    int selector         = (int)CHECK_POP (LocalGS.stackPointer);
    int32 value          = (int32)CHECK_POP (LocalGS.stackPointer);
    if (globalGS->init)
    {
      if (selector == 1)
        *ic &= ~NOGRIDFITFLAG;
      else if (selector == 2)
        *ic &= ~DEFAULTFLAG;

      *ic |= value;
    }
  }

/*
 * Does a cheap approximation of Euclidian distance.
 */
#if 0
  PRIVATE VECTOR fnt_QuickDist (register VECTOR dx, register VECTOR dy)
  {
    if (dx < 0)
      dx = -dx;
    if (dy < 0)
      dy = -dy;

    return (dx > dy ? dx + (dy >> 1) : dy + (dx >> 1));
  }
#endif

/*
 * AdjustAngle         <4>
 */
  PRIVATE void fnt_AA (GSP0)
  {
    return;
#if 0
    register fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
    ArrayIndex ptNum, bestAngle;
    F26Dot6 dx, dy, tmp32;
    VECTOR pvx, pvy; /* Projection Vector */
    VECTOR pfProj;
    VECTOR tpvx, tpvy;
    Fract * anglePoint;         /* x,y, x,y, x,y, ... */
    int16 distance, *angleDistance;
    int32 minPenalty;                   /* should this be the same as distance??? mrr-7/17/90 */
    LoopCount i;
    int yFlip, xFlip, xySwap;           /* boolean */


    ptNum = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);
/* save the projection vector */
    pvx = LocalGS.proj.x;
    pvy = LocalGS.proj.y;
    pfProj = LocalGS.pfProj;

    dx = LocalGS.CE1->x[ptNum] - LocalGS.CE0->x[LocalGS.Pt0];
    dy = LocalGS.CE1->y[ptNum] - LocalGS.CE0->y[LocalGS.Pt0];

/* map to the first and second quadrant */
    yFlip = dy < 0 ? dy = -dy, 1 : 0;

/* map to the first quadrant */
    xFlip = dx < 0 ? dx = -dx, 1 : 0;

/* map to the first octant */
    xySwap = dy > dx ? tmp32 = dy, dy = dx, dx = tmp32, 1 : 0;

/* Now tpvy, tpvx contains the line rotated by 90 degrees, so it is in the 3rd octant */
    {
      VECTOR v;
      fnt_Normalize (-dy, dx, &v);
      tpvx = v.x;
      tpvy = v.y;
    }

/* find the best angle */
    minPenalty = 10 * fnt_pixelSize;
    bestAngle = -1;
    anglePoint = &globalGS->anglePoint[0].x;            /* x,y, x,y, x,y, ... */
    angleDistance = globalGS->angleDistance;
    for (i = 0; i < MAXANGLES; i++)
    {
      if ((distance = *angleDistance++) >= minPenalty)
        break; /* No more improvement is possible */
      LocalGS.proj.x = *anglePoint++;
      LocalGS.proj.y = *anglePoint++;
/* Now find the distance between these vectors, this will help us gain speed */
      if (fnt_QuickDist (LocalGS.proj.x - tpvx, LocalGS.proj.y - tpvy) > (210831287)) /* 2PI / 32 */
        continue; /* Difference is to big, we will at most change the angle +- 360/32 = +- 11.25 degrees */

      tmp32 = fnt_Project (GSP dx, dy); /* Calculate the projection */
      if (tmp32 < 0)
        tmp32 = -tmp32;

      tmp32 = (globalGS->localParBlock.angleWeight * tmp32) >> fnt_pixelShift;
      tmp32 +=  distance;
      if (tmp32 < minPenalty)
      {
        minPenalty = tmp32;
        bestAngle = i;
      }
    }

    tmp32 = 0;
    if (bestAngle >= 0)
    {
/* OK, we found a good angle */
      LocalGS.proj.x = globalGS->anglePoint[bestAngle].x;
      LocalGS.proj.y = globalGS->anglePoint[bestAngle].y;
/* Fold the projection vector back into the full coordinate plane. */
      if (xySwap)
      {
        tmp32 = LocalGS.proj.y;
        LocalGS.proj.y = LocalGS.proj.x;
        LocalGS.proj.x = tmp32;
      }
      if (xFlip)
      {
        LocalGS.proj.x = -LocalGS.proj.x;
      }
      if (yFlip)
      {
        LocalGS.proj.y = -LocalGS.proj.y;
      }
      fnt_ComputeAndCheck_PF_Proj (GSA0);

      tmp32 = fnt_Project (GSP LocalGS.CE1->x[LocalGS.Pt0] - LocalGS.CE0->x[ptNum], LocalGS.CE1->y[LocalGS.Pt0] - LocalGS.CE0->y[ptNum]);
    }
    fnt_MovePoint (GSA LocalGS.CE1, ptNum, tmp32);

    LocalGS.proj.x = pvx; /* restore the projection vector */
    LocalGS.proj.y = pvy;
    LocalGS.pfProj = pfProj;
#endif
  }

/*
 *      Called by fnt_PUSHB and fnt_NPUSHB
 */
#ifndef IN_ASM
  PRIVATE void fnt_PushSomeStuff (GSP register LoopCount count, boolean pushBytes)
  {
    register F26Dot6*stack = LocalGS.stackPointer;
    register uint8*instr = LocalGS.insPtr;
    if (pushBytes)
      for (--count; count >= 0; --count)
      {
        CHECK_PUSH (stack, GETBYTE (instr));
      }
    else
    {
      for (--count; count >= 0; --count)
      {
        int16 word = *instr++;
        CHECK_PUSH (stack, (int16) ((word << 8) + *instr++));
      }
    }
    LocalGS.stackPointer = stack;
    LocalGS.insPtr = instr;
  }

/*
 * PUSH Bytes           <3>
 */
  PRIVATE void fnt_PUSHB (GSP0)
  {
    fnt_PushSomeStuff (GSA LocalGS.opCode - 0xb0 + 1, true);
  }

/*
 * N PUSH Bytes
 */
  PRIVATE void fnt_NPUSHB (GSP0)
  {
    fnt_PushSomeStuff (GSA GETBYTE (LocalGS.insPtr), true);
  }

/*
 * PUSH Words           <3>
 */
  PRIVATE void fnt_PUSHW (GSP0)
  {
    fnt_PushSomeStuff (GSA LocalGS.opCode - 0xb8 + 1, false);
  }

/*
 * N PUSH Words
 */
  PRIVATE void fnt_NPUSHW (GSP0)
  {
    fnt_PushSomeStuff (GSA GETBYTE (LocalGS.insPtr), false);
  }
#endif
/*
 * Write Store
 */
  PRIVATE void fnt_WS (GSP0)
  {
    register F26Dot6 storage;
    register ArrayIndex storeIndex;

    storage = CHECK_POP (LocalGS.stackPointer);
    storeIndex = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);

    CHECK_STORAGE (&LocalGS,storeIndex);

    LocalGS.globalGS->store[ storeIndex ] = storage;
  }

/*
 * Read Store
 */
  PRIVATE void fnt_RS (GSP0)
  {
    register ArrayIndex storeIndex;

    storeIndex = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);
    CHECK_STORAGE (&LocalGS, storeIndex);
    CHECK_PUSH (LocalGS.stackPointer, LocalGS.globalGS->store[storeIndex]);
  }

/*
 * Write Control Value Table from outLine, assumes the value comes form the outline domain
 */
  PRIVATE void fnt_WCVT (GSP0)
  {
    register ArrayIndex cvtIndex;
    register F26Dot6 cvtValue;

    cvtValue = CHECK_POP (LocalGS.stackPointer);
    cvtIndex = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);

    CHECK_CVT (&LocalGS, cvtIndex);

    LocalGS.globalGS->controlValueTable[ cvtIndex ] = cvtValue;

/* The BASS outline is in the transformed domain but the cvt is not so apply the inverse transform */
    if (cvtValue)
    {
      register F26Dot6 tmpCvt;
      if ((tmpCvt = LocalGS.GetCVTEntry (GSA cvtIndex)) && tmpCvt != cvtValue)
      {
        LocalGS.globalGS->controlValueTable[ cvtIndex ] = (F26Dot6) FixMul (cvtValue,  FixDiv (cvtValue, tmpCvt));
      }
    }
  }

/*
 * Write Control Value Table From Original Domain, assumes the value comes from the original domain, not the cvt or outline
 */
  PRIVATE void fnt_WCVTFOD (GSP0)
  {
    register ArrayIndex cvtIndex;
    register F26Dot6 cvtValue;
    register fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;

    cvtValue = CHECK_POP (LocalGS.stackPointer);
    cvtIndex = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);
    CHECK_CVT (&LocalGS, cvtIndex);
    globalGS->controlValueTable[ cvtIndex ] = globalGS->ScaleFuncCVT (&globalGS->scaleCVT, cvtValue);
  }



/*
 * Read Control Value Table
 */
  PRIVATE void fnt_RCVT (GSP0)
  {
    register ArrayIndex cvtIndex;

    cvtIndex = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);
    CHECK_PUSH (LocalGS.stackPointer, LocalGS.GetCVTEntry (GSA cvtIndex));
  }

/*
 * Read Coordinate
 */
  PRIVATE void fnt_RC (GSP0)
  {
    ArrayIndex pt;
    fnt_ElementType * element;
    register F26Dot6 proj;

    pt = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);
    element = LocalGS.CE2;

    if (BIT0 (LocalGS.opCode))
      proj = (*LocalGS.OldProject) (GSA element->ox[pt], element->oy[pt]);
    else
      proj = (*LocalGS.Project) (GSA element->x[pt], element->y[pt]);

    CHECK_PUSH (LocalGS.stackPointer, proj);
  }

/*
 * Write Coordinate
 */
  PRIVATE void fnt_WC (GSP0)
  {
    register F26Dot6 proj, coord;
    register ArrayIndex pt;
    register fnt_ElementType *element;

    coord = CHECK_POP (LocalGS.stackPointer);/* value */
    pt = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);/* point */
    element = LocalGS.CE2;

    proj = (*LocalGS.Project) (GSA element->x[pt],  element->y[pt]);
    proj = coord - proj;

    (*LocalGS.MovePoint) (GSA element, pt, proj);

    if (element == LocalGS.elements)                /* twilightzone */
    {
      element->ox[pt] = element->x[pt];
      element->oy[pt] = element->y[pt];
    }
  }


/*
 * Measure Distance
 */
  PRIVATE void fnt_MD (GSP0)
  {
    register ArrayIndex pt1, pt2;
    register F26Dot6 proj, *stack = LocalGS.stackPointer;
    register fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;

    pt2 = (ArrayIndex)CHECK_POP (stack);
    pt1 = (ArrayIndex)CHECK_POP (stack);
    if (BIT0 (LocalGS.opCode - MD_CODE))
      proj  = (*LocalGS.OldProject) (GSA LocalGS.CE0->ox[pt1] - LocalGS.CE1->ox[pt2], LocalGS.CE0->oy[pt1] - LocalGS.CE1->oy[pt2]);
    else
      proj  = (*LocalGS.Project) (GSA LocalGS.CE0->x[pt1] - LocalGS.CE1->x[pt2], LocalGS.CE0->y[pt1] - LocalGS.CE1->y[pt2]);
    CHECK_PUSH (stack, proj);
    LocalGS.stackPointer = stack;
  }

/*
 * Measure Pixels Per EM
 */
  PRIVATE void fnt_MPPEM (GSP0)
  {
    register uint16 ppem;
    register fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;

    ppem = globalGS->pixelsPerEm;

    if (!globalGS->identityTransformation)
      ppem = (uint16)FixMul (ppem, fnt_GetCVTScale (GSA0));

    CHECK_PUSH (LocalGS.stackPointer, ppem);
  }

/*
 * Measure Point Size
 */
  PRIVATE void fnt_MPS (GSP0)
  {
    CHECK_PUSH (LocalGS.stackPointer, LocalGS.globalGS->pointSize);
  }

/*
 * Get Miscellaneous info: version number, rotated, stretched   <6>
 * Version number is 8 bits.  This is version 0x01 : 5/1/90
 *
 */

  PRIVATE void fnt_GETINFO (GSP0)
  {
    register fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
    register int        selector = (int)CHECK_POP (LocalGS.stackPointer);
    register int        info = 0;

    if (selector & 1)                                                           /* version */
      info |= 3;
    if ((selector & 2) && (globalGS->non90DegreeTransformation & 0x1))
      info |= ROTATEDGLYPH;
    if ((selector & 4) && (globalGS->non90DegreeTransformation & 0x2))
      info |= STRETCHEDGLYPH;
    CHECK_PUSH (LocalGS.stackPointer, info);
  }

/*
 * FLIP ON
 */
  PRIVATE void fnt_FLIPON (GSP0)
  {
    LocalGS.globalGS->localParBlock.autoFlip = true;
  }

/*
 * FLIP OFF
 */
  PRIVATE void fnt_FLIPOFF (GSP0)
  {
    LocalGS.globalGS->localParBlock.autoFlip = false;
  }

#ifndef NOT_ON_THE_MAC
#ifdef DEBUG
/*
 * DEBUG
 */
  PRIVATE void fnt_DEBUG (GSP0)
  {
    register int32 arg;
    int8 buffer[24];

    arg = CHECK_POP (LocalGS.stackPointer);

    buffer[1] = 'D';
    buffer[2] = 'E';
    buffer[3] = 'B';
    buffer[4] = 'U';
    buffer[5] = 'G';
    buffer[6] = ' ';
    if (arg >= 0)
    {
      buffer[7] = '+';
    }
    else
    {
      arg = -arg;
      buffer[7] = '-';
    }

    buffer[13] = arg % 10 + '0';
    arg /= 10;
    buffer[12] = arg % 10 + '0';
    arg /= 10;
    buffer[11] = arg % 10 + '0';
    arg /= 10;
    buffer[10] = arg % 10 + '0';
    arg /= 10;
    buffer[ 9] = arg % 10 + '0';
    arg /= 10;
    buffer[ 8] = arg % 10 + '0';
    arg /= 10;

    buffer[14] = arg ? '*' : ' ';


    buffer[0] = 14; /* convert to pascal */
    DebugStr (buffer);
  }

#else           /* debug */

  PRIVATE void fnt_DEBUG (GSP0)
  {
    CHECK_POP (LocalGS.stackPointer);
  }

#endif          /* debug */
#else

  PRIVATE void fnt_DEBUG (GSP0)
  {
    CHECK_POP (LocalGS.stackPointer);
  }

#endif          /* ! not on the mac */

/*
 *      This guy is here to save space for simple insructions
 *      that pop two arguments and push one back on.
 */

#ifndef IN_ASM
  PRIVATE void fnt_BinaryOperand (GSP0)
  {
    F26Dot6 * stack = LocalGS.stackPointer;
    F26Dot6 arg2 = CHECK_POP (stack);
    F26Dot6 arg1 = CHECK_POP (stack);

    switch (LocalGS.opCode)
    {
    case LT_CODE:
      BOOLEANPUSH (stack, arg1 < arg2);
      break;
    case LTEQ_CODE:
      BOOLEANPUSH (stack, arg1 <= arg2);
      break;
    case GT_CODE:
      BOOLEANPUSH (stack, arg1 > arg2);
      break;
    case GTEQ_CODE:
      BOOLEANPUSH (stack, arg1 >= arg2);
      break;
    case EQ_CODE:
      BOOLEANPUSH (stack, arg1 == arg2);
      break;
    case NEQ_CODE:
      BOOLEANPUSH (stack, arg1 != arg2);
      break;

    case AND_CODE:
      BOOLEANPUSH (stack, arg1 && arg2);
      break;
    case OR_CODE:
      BOOLEANPUSH (stack, arg1 || arg2);
      break;

    case ADD_CODE:
      CHECK_PUSH (stack, arg1 + arg2);
      break;
    case SUB_CODE:
      CHECK_PUSH (stack, arg1 - arg2);
      break;
    case MUL_CODE:
      CHECK_PUSH (stack, Mul26Dot6 (arg1, arg2));
      break;
    case DIV_CODE:
      CHECK_PUSH (stack, (int)(((long) arg1 << 6) / arg2));
      break;
    case MAX_CODE:
      if (arg1 < arg2)
        arg1 = arg2;
      CHECK_PUSH (stack, arg1);
      break;
    case MIN_CODE:
      if (arg1 > arg2)
        arg1 = arg2;
      CHECK_PUSH (stack, arg1);
      break;
#ifdef DEBUG
    default:
      Debugger ();
#endif
    }
    LocalGS.stackPointer = stack;
    CHECK_STACK (&LocalGS);
  }
#endif

  PRIVATE void fnt_UnaryOperand (GSP0)
  {
    F26Dot6 * stack = LocalGS.stackPointer;
    F26Dot6 arg = CHECK_POP (stack);
    uint8 opCode = LocalGS.opCode;

    switch (opCode)
    {
    case ODD_CODE:
    case EVEN_CODE:
      arg = fnt_RoundToGrid (GSA arg, 0);
      arg >>= fnt_pixelShift;
      if (opCode == ODD_CODE)
        arg++;
      BOOLEANPUSH (stack, (arg & 1) == 0);
      break;
    case NOT_CODE:
      BOOLEANPUSH (stack, !arg);
      break;

    case ABS_CODE:
      CHECK_PUSH (stack, arg > 0 ? arg : -arg);
      break;
    case NEG_CODE:
      CHECK_PUSH (stack, -arg);
      break;

    case CEILING_CODE:
      arg += fnt_pixelSize - 1;
    case FLOOR_CODE:
      arg &= ~ (fnt_pixelSize - 1);
      CHECK_PUSH (stack, arg);
      break;
#ifdef DEBUG
    default:
      Debugger ();
#endif
    }
    LocalGS.stackPointer = stack;
    CHECK_STACK (&LocalGS);
  }

#define NPUSHB_CODE 0x40
#define NPUSHW_CODE 0x41

#define PUSHB_START 0xb0
#define PUSHB_END       0xb7
#define PUSHW_START 0xb8
#define PUSHW_END       0xbf

/*
 * Internal function for fnt_IF (), and fnt_FDEF ()
 */
  PRIVATE void fnt_SkipPushCrap (GSP0)
  {
    register uint8 opCode = LocalGS.opCode;
    register uint8*instr = LocalGS.insPtr;
    register ArrayIndex count;

    if (opCode == NPUSHB_CODE)
    {
      count = (ArrayIndex) * instr++;
      instr += count;
    }
    else if (opCode == NPUSHW_CODE)
    {
      count = (ArrayIndex) * instr++;
      instr += count + count;
    }
    else if (opCode >= PUSHB_START && opCode <= PUSHB_END)
    {
      count = (ArrayIndex) (opCode - PUSHB_START + 1);
      instr += count;
    }
    else if (opCode >= PUSHW_START && opCode <= PUSHW_END)
    {
      count = (ArrayIndex) (opCode - PUSHW_START + 1);
      instr += count + count;
    }
    LocalGS.insPtr = instr;
  }

/*
 * IF
 */
#ifndef IN_ASM
  PRIVATE void fnt_IF (GSP0)
  {
    register int        level;
    register uint8 opCode;

    if (!CHECK_POP (LocalGS.stackPointer))
    {
/* Now skip instructions */
      for (level = 1; level;)
      {
/* level = # of "ifs" minus # of "endifs" */
        if ((LocalGS.opCode = opCode = *LocalGS.insPtr++) == EIF_CODE)
        {
          level--;
        }
        else if (opCode == IF_CODE)
        {
          level++;
        }
        else if (opCode == ELSE_CODE)
        {
          if (level == 1)
            break;
        }
        else
          fnt_SkipPushCrap (GSA0);
      }
    }
  }
#endif

/*
 *      ELSE for the IF
 */
  PRIVATE void fnt_ELSE (GSP0)
  {
    register int        level;
    register uint8 opCode;

    for (level = 1; level;)
    {
/* level = # of "ifs" minus # of "endifs" */
      if ((LocalGS.opCode = opCode = *LocalGS.insPtr++) == EIF_CODE)
      { /* EIF */
        level--;
      }
      else if (opCode == IF_CODE)
      {
        level++;
      }
      else
        fnt_SkipPushCrap (GSA0);
    }
  }

/*
 * End IF
 */
  PRIVATE void fnt_EIF (GSP0)
  {
  }

/*
 * Jump Relative
 */
  PRIVATE void fnt_JMPR (GSP0)
  {
    register ArrayIndex offset;

    offset = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);
    offset--; /* since the interpreter post-increments the IP */
    LocalGS.insPtr += offset;
  }

/*
 * Jump Relative On True
 */
  PRIVATE void fnt_JROT (GSP0)
  {
    register ArrayIndex offset;
    register F26Dot6*stack = LocalGS.stackPointer;

    if (CHECK_POP (stack))
    {
      offset = (ArrayIndex)CHECK_POP (stack);
      --offset; /* since the interpreter post-increments the IP */
      LocalGS.insPtr += offset;
    }
    else
    {
      --stack;/* same as POP */
    }
    LocalGS.stackPointer = stack;
  }

/*
 * Jump Relative On False
 */
  PRIVATE void fnt_JROF (GSP0)
  {
    register ArrayIndex offset;
    register F26Dot6*stack = LocalGS.stackPointer;

    if (CHECK_POP (stack))
    {
      --stack;/* same as POP */
    }
    else
    {
      offset = (ArrayIndex)CHECK_POP (stack);
      offset--; /* since the interpreter post-increments the IP */
      LocalGS.insPtr += offset;
    }
    LocalGS.stackPointer = stack;
  }

/*
 * ROUND
 */
  PRIVATE void fnt_ROUND (GSP0)
  {
    register F26Dot6 arg1;
    register fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

    arg1 = CHECK_POP (LocalGS.stackPointer);

    CHECK_RANGE (LocalGS.opCode, 0x68, 0x6B);

    arg1 = pb->RoundValue (GSA arg1, LocalGS.globalGS->engine[LocalGS.opCode - 0x68]);
    CHECK_PUSH (LocalGS.stackPointer , arg1);
  }

/*
 * No ROUND
 */
  PRIVATE void fnt_NROUND (GSP0)
  {
    register F26Dot6 arg1;

    arg1 = CHECK_POP (LocalGS.stackPointer);

    CHECK_RANGE (LocalGS.opCode, 0x6C, 0x6F);

    arg1 = fnt_RoundOff (GSA arg1, LocalGS.globalGS->engine[LocalGS.opCode - 0x6c]);
    CHECK_PUSH (LocalGS.stackPointer , arg1);
  }

/*
 * An internal function used by MIRP an MDRP.
 */
  F26Dot6 fnt_CheckSingleWidth (GSP register F26Dot6 value)
  {
    register F26Dot6 delta, scaledSW;
    register fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

    scaledSW = LocalGS.GetSingleWidth (GSA0);

    if (value >= 0)
    {
      delta = value - scaledSW;
      if (delta < 0)
        delta = -delta;
      if (delta < pb->sWCI)
        value = scaledSW;
    }
    else
    {
      value = -value;
      delta = value - scaledSW;
      if (delta < 0)
        delta = -delta;
      if (delta < pb->sWCI)
        value = scaledSW;
      value = -value;
    }
    return value;
  }


/*
 * Move Direct Relative Point
 */
  PRIVATE void fnt_MDRP (GSP0)
  {
    register ArrayIndex pt1, pt0 = LocalGS.Pt0;
    register F26Dot6 tmp, tmpC;
    register fnt_ElementType *element = LocalGS.CE1;
    register fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
    register fnt_ParameterBlock *pb = &globalGS->localParBlock;

    pt1 = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);

    CHECK_POINT (&LocalGS, LocalGS.CE0, pt0);
    CHECK_POINT (&LocalGS, element, pt1);

    if ( LocalGS.CE0 == LocalGS.elements || element == LocalGS.elements || element->oox == element->ox)
      tmp  = (*LocalGS.OldProject) (GSA element->ox[pt1] - LocalGS.CE0->ox[pt0], element->oy[pt1] - LocalGS.CE0->oy[pt0]);
    else
      if (globalGS->squareScale)
      {
        tmp  = (*LocalGS.OldProject) (GSA element->oox[pt1] - LocalGS.CE0->oox[pt0], element->ooy[pt1] - LocalGS.CE0->ooy[pt0] );
        tmp = globalGS->ScaleFuncCVT( &globalGS->scaleCVT, tmp );
      }
      else
        tmp  = (*LocalGS.OldProject) (GSA globalGS->ScaleFuncX (&globalGS->scaleX, element->oox[pt1] - LocalGS.CE0->oox[pt0]), globalGS->ScaleFuncY (&globalGS->scaleY, element->ooy[pt1] - LocalGS.CE0->ooy[pt0]));

    if (pb->sWCI)
    {
      tmp = fnt_CheckSingleWidth (GSA tmp);
    }

    tmpC = tmp;
    if (BIT2 (LocalGS.opCode))
    {
      tmp = pb->RoundValue (GSA tmp, globalGS->engine[LocalGS.opCode & 0x03]);
    }
    else
    {
      tmp = fnt_RoundOff (GSA tmp, globalGS->engine[LocalGS.opCode & 0x03]);
    }


    if (BIT3 (LocalGS.opCode))
    {
      F26Dot6 tmpB = pb->minimumDistance;
      if (tmpC >= 0)
      {
        if (tmp < tmpB)
        {
          tmp = tmpB;
        }
      }
      else
      {
        tmpB = -tmpB;
        if (tmp > tmpB)
        {
          tmp = tmpB;
        }
      }
    }

    tmpC = (*LocalGS.Project) (GSA element->x[pt1] - LocalGS.CE0->x[pt0], element->y[pt1] - LocalGS.CE0->y[pt0]);
    tmp -= tmpC;
    (*LocalGS.MovePoint) (GSA element, pt1, tmp);
    LocalGS.Pt1 = pt0;
    LocalGS.Pt2 = pt1;
    if (BIT4 (LocalGS.opCode))
    {
      LocalGS.Pt0 = pt1; /* move the reference point */
    }
  }

/*
 * Move Indirect Relative Point
 */
#ifndef IN_ASM
  PRIVATE void fnt_MIRP (GSP0)
  {
    register ArrayIndex ptNum;
             ArrayIndex Pt0;
    register F26Dot6 tmp, tmpB, tmpC, tmpProj;
    register F26Dot6 *engine = LocalGS.globalGS->engine;
    register fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;
    fnt_ElementType *pCE0 = LocalGS.CE0;
    fnt_ElementType *pCE1 = LocalGS.CE1;
    unsigned opCode = (unsigned) LocalGS.opCode;

    tmp = LocalGS.GetCVTEntry (GSA (ArrayIndex)CHECK_POP (LocalGS.stackPointer));

    if (pb->sWCI)
      tmp = fnt_CheckSingleWidth (GSA tmp);

    ptNum = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);
    LocalGS.Pt1 = Pt0 = LocalGS.Pt0;
    LocalGS.Pt2 = ptNum;

    if (BIT4 (opCode))
      LocalGS.Pt0 = ptNum; /* move the reference point */

    if (pCE1 == LocalGS.elements)
    {
      pCE1->x [ptNum] = pCE1->ox[ptNum] = pCE0->ox [Pt0] + (F26Dot6) VECTORMUL (tmp, LocalGS.proj.x);
      pCE1->y [ptNum] = pCE1->oy[ptNum] = pCE0->oy [Pt0] + (F26Dot6) VECTORMUL (tmp, LocalGS.proj.y);
    }

    if (LocalGS.OldProject == fnt_XProject)
      tmpC = pCE1->ox[ptNum] - pCE0->ox[Pt0];
    else
      if (LocalGS.OldProject == fnt_YProject)
        tmpC = pCE1->oy[ptNum] - pCE0->oy[Pt0];
      else
        tmpC  = (*LocalGS.OldProject) (GSA pCE1->ox[ptNum] - pCE0->ox[Pt0], pCE1->oy[ptNum] - pCE0->oy[Pt0]);

    if (LocalGS.Project == fnt_XProject)
      tmpProj = pCE1->x[ptNum] - pCE0->x[Pt0];
    else
      if (LocalGS.Project == fnt_YProject)
        tmpProj = pCE1->y[ptNum] - pCE0->y[Pt0];
      else
    tmpProj  = (*LocalGS.Project) (GSA pCE1->x[ptNum] - pCE0->x[Pt0], pCE1->y[ptNum] - pCE0->y[Pt0]);


    if (pb->autoFlip)
      if (((tmpC ^ tmp)) < 0)
        tmp = -tmp; /* Do the auto flip */

    if (BIT2 (opCode))
    {
      tmpB = tmp - tmpC;
      if (tmpB < 0)
        tmpB = -tmpB;
      if (tmpB > pb->wTCI)
        tmp = tmpC;
      tmp = pb->RoundValue (GSA tmp, engine[opCode & 0x03]);
    }
    else
      tmp = fnt_RoundOff (GSA tmp, engine[opCode & 0x03]);


    if (BIT3 (opCode))
    {
      tmpB = pb->minimumDistance;
      if (tmpC >= 0)
      {
        if (tmp < tmpB)
          tmp = tmpB;
      }
      else
      {
        tmpB = -tmpB;
        if (tmp > tmpB)
          tmp = tmpB;
      }
    }

    (*LocalGS.MovePoint) (GSA pCE1, ptNum, tmp - tmpProj);
  }
#endif

/*
 * CALL a function
 */
  PRIVATE void fnt_CALL (GSP0)
  {
    register fnt_funcDef *funcDef;
    uint8 * ins;
    fnt_GlobalGraphicStateType * globalGS = LocalGS.globalGS;
    ArrayIndex arg = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);

    CHECK_PROGRAM (funcDef->pgmIndex);
    CHECK_FDEF (&LocalGS, arg);
    funcDef = &globalGS->funcDef[ arg ];
    ins     = globalGS->pgmList[ funcDef->pgmIndex ].Instruction;

    CHECK_ASSERTION (globalGS->funcDef != 0);
    CHECK_ASSERTION (ins != 0);

    ins += funcDef->start;
    LocalGS.Interpreter (GSA ins, ins + funcDef->length);
  }

/*
 * Function DEFinition
 */
  PRIVATE void fnt_FDEF (GSP0)
  {
    register fnt_funcDef *funcDef;
    uint8 * program, *funcStart;
    fnt_GlobalGraphicStateType * globalGS = LocalGS.globalGS;
    ArrayIndex arg = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);

    CHECK_FDEF (&LocalGS, arg);

    funcDef = &globalGS->funcDef[ arg ];
    program = globalGS->pgmList[ funcDef->pgmIndex = globalGS->pgmIndex ].Instruction;

    CHECK_PROGRAM (funcDef->pgmIndex);
    CHECK_ASSERTION (globalGS->funcDef != 0);
    CHECK_ASSERTION (globalGS->pgmList[funcDef->pgmIndex].Instruction != 0);

    funcDef->start = (int32)(LocalGS.insPtr - program);
    funcStart = LocalGS.insPtr;
    while ((LocalGS.opCode = *LocalGS.insPtr++) != ENDF_CODE)
      fnt_SkipPushCrap (GSA0);

    funcDef->length = (uint16)(LocalGS.insPtr - funcStart - 1); /* don't execute ENDF */
  }

/*
 * LOOP while CALLing a function
 */
  PRIVATE void fnt_LOOPCALL (GSP0)
  {
    register uint8 *start, *stop;
    register InterpreterFunc Interpreter;
    register fnt_funcDef *funcDef;
    ArrayIndex arg = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);
    register LoopCount loop;

    CHECK_FDEF (&LocalGS, arg);

    funcDef      = & (LocalGS.globalGS->funcDef[ arg ]);
    {
      uint8 * ins;

      CHECK_PROGRAM (funcDef->pgmIndex);
      ins = LocalGS.globalGS->pgmList[ funcDef->pgmIndex ].Instruction;

      start              = &ins[funcDef->start];
      stop               = &ins[funcDef->start + funcDef->length];      /* funcDef->end -> funcDef->length <4> */
    }
    Interpreter = LocalGS.Interpreter;
    loop = (LoopCount)CHECK_POP (LocalGS.stackPointer);
    for (--loop; loop >= 0; --loop)
      Interpreter (GSA start, stop);
  }

/*
 *      This guy returns the index of the given opCode, or 0 if not found <4>
 */
  PRIVATE fnt_instrDef*fnt_FindIDef (GSP register uint8 opCode)
  {
    register fnt_GlobalGraphicStateType*globalGS = LocalGS.globalGS;
    register LoopCount count = globalGS->instrDefCount;
    register fnt_instrDef*instrDef = globalGS->instrDef;
    for (--count; count >= 0; instrDef++, --count)
      if (instrDef->opCode == opCode)
        return instrDef;
    return 0;
  }

/*
 *      This guy gets called for opCodes that has been patch by the font's IDEF <4>
 *      or if they have never been defined.  If there is no corresponding IDEF,
 *      flag it as an illegal instruction.
 */
  PRIVATE void fnt_IDefPatch (GSP0)
  {
    register fnt_instrDef*instrDef = fnt_FindIDef (GSA LocalGS.opCode);
    if (instrDef == 0)
      fnt_IllegalInstruction (GSA0);
    else
    {
      register uint8*program;

      CHECK_PROGRAM (instrDef->pgmIndex);
      program = LocalGS.globalGS->pgmList[ instrDef->pgmIndex ].Instruction;

      program += instrDef->start;
      LocalGS.Interpreter (GSA program, program + instrDef->length);
    }
  }

/*
 * Instruction DEFinition       <4>
 */
  PRIVATE void fnt_IDEF (GSP0)
  {
    register uint8 opCode = (uint8)CHECK_POP (LocalGS.stackPointer);
    register fnt_instrDef*instrDef = fnt_FindIDef (GSA opCode);
    register ArrayIndex pgmIndex = (ArrayIndex)LocalGS.globalGS->pgmIndex;
    uint8 * program = LocalGS.globalGS->pgmList[ pgmIndex ].Instruction;
    uint8 * instrStart = LocalGS.insPtr;

    CHECK_PROGRAM (pgmIndex);

    if (!instrDef)
      instrDef = LocalGS.globalGS->instrDef + LocalGS.globalGS->instrDefCount++;

    instrDef->pgmIndex = (uint8) pgmIndex;
    instrDef->opCode = opCode;          /* this may or may not have been set */
    instrDef->start = (int32)(LocalGS.insPtr - program);

    while ((LocalGS.opCode = *LocalGS.insPtr++) != ENDF_CODE)
      fnt_SkipPushCrap (GSA0);

    instrDef->length = (uint16)(LocalGS.insPtr - instrStart - 1); /* don't execute ENDF */
  }

/*
 * UnTouch Point
 */
  PRIVATE void fnt_UTP (GSP0)
  {
    register ArrayIndex point = (ArrayIndex)CHECK_POP (LocalGS.stackPointer);
    register uint8*f = LocalGS.CE0->f;

    if (LocalGS.free.x)
    {
      f[point] &= ~XMOVED;
    }
    if (LocalGS.free.y)
    {
      f[point] &= ~YMOVED;
    }
  }

/*
 * Set Delta Base
 */
  PRIVATE void fnt_SDB (GSP0)
  {
    LocalGS.globalGS->localParBlock.deltaBase = (int16)CHECK_POP (LocalGS.stackPointer);
  }

/*
 * Set Delta Shift
 */
  PRIVATE void fnt_SDS (GSP0)
  {
    LocalGS.globalGS->localParBlock.deltaShift = (int16)CHECK_POP (LocalGS.stackPointer);
  }

/*
 * DeltaEngine, internal support routine
 */
  PRIVATE void fnt_DeltaEngine (GSP register FntMoveFunc doIt, int16 base, int16 shift)
  {
    register ArrayIndex tmp;
    register ArrayIndex aim, high;
    register int   fakePixelsPerEm, ppem;
    register F26Dot6 tmp32;

/* Find the beginning of data pairs for this particular size */
    high = CHECK_POP (LocalGS.stackPointer) << 1; /* -= number of pops required */
    LocalGS.stackPointer -= high;

/* same as fnt_MPPEM () */
    tmp = LocalGS.globalGS->pixelsPerEm;

    if (!LocalGS.globalGS->identityTransformation)
      tmp = (ArrayIndex) FixMul (tmp, fnt_GetCVTScale (GSA0));

    fakePixelsPerEm = (int) (tmp - base);       //@WIN



    if (fakePixelsPerEm >= 16 || fakePixelsPerEm < 0)
      return; /* Not within exception range */
    fakePixelsPerEm = fakePixelsPerEm << 4;

    aim = 0;
    tmp = high >> 1;
    tmp &= ~1;
    while (tmp > 2)
    {
      ppem  = (int)LocalGS.stackPointer[ aim + tmp ]; /* [ ppem << 4 | exception ] @WIN*/
      if ((ppem & ~0x0f) < fakePixelsPerEm)
      {
        aim += tmp;
      }
      tmp >>= 1;
      tmp &= ~1;
    }

    while (aim < high)
    {
      ppem  = (int)LocalGS.stackPointer[ aim ]; /* [ ppem << 4 | exception ] @WIN*/
      if ((tmp32 = (ppem & ~0x0f)) == fakePixelsPerEm)
      {
/* We found an exception, go ahead and apply it */
        tmp32  = ppem & 0xf; /* 0 ... 15 */
        tmp32 -= tmp32 >= 8 ? 7 : 8; /* -8 ... -1, 1 ... 8 */
        tmp32 <<= fnt_pixelShift; /* convert to pixels */
        tmp32 >>= shift; /* scale to right size */
        doIt (GSA LocalGS.CE0, (ArrayIndex)LocalGS.stackPointer[aim+1] /* point number */, (F26Dot6) tmp32 /* the delta */);
      }
      else if (tmp32 > fakePixelsPerEm)
      {
        break; /* we passed the data */
      }
      aim += 2;
    }
  }



/*
 * DELTAP1
 */
  PRIVATE void fnt_DELTAP1 (GSP0)
  {
    register fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;
    fnt_DeltaEngine (GSA LocalGS.MovePoint, pb->deltaBase, pb->deltaShift);
  }

/*
 * DELTAP2
 */
  PRIVATE void fnt_DELTAP2 (GSP0)
  {
    register fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;
    fnt_DeltaEngine (GSA LocalGS.MovePoint, (int16)(pb->deltaBase + 16), pb->deltaShift);
  }

/*
 * DELTAP3
 */
  PRIVATE void fnt_DELTAP3 (GSP0)
  {
    register fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;
    fnt_DeltaEngine (GSA LocalGS.MovePoint, (int16)(pb->deltaBase + 32), pb->deltaShift);
  }

/*
 * DELTAC1
 */
  PRIVATE void fnt_DELTAC1 (GSP0)
  {
    register fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;
    fnt_DeltaEngine (GSA fnt_ChangeCvt, pb->deltaBase, pb->deltaShift);
  }

/*
 * DELTAC2
 */
  PRIVATE void fnt_DELTAC2 (GSP0)
  {
    register fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;
    fnt_DeltaEngine (GSA fnt_ChangeCvt, (int16)(pb->deltaBase + 16), pb->deltaShift);
  }

/*
 * DELTAC3
 */
  PRIVATE void fnt_DELTAC3 (GSP0)
  {
    register fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;
    fnt_DeltaEngine (GSA fnt_ChangeCvt, (int16)(pb->deltaBase + 32), pb->deltaShift);
  }

/* END OF fnt.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\define.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/* Define option flags which are defined for Royal font module.
 * Date: Apr. 9, 1990
 *
 * Created by: Peter Chen
 */
#define SFNT     1
#define LVAL_FIX 1
#define register
#define NOT_ON_MOTOROLA

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\chk_vari.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */


// DJC added global include
#include "psglobal.h"

#define    LINT_ARGS            /* @WIN */
#define    NOT_ON_THE_MAC       /* @WIN */
#define    KANJI                /* @WIN */
// DJC use command line #define    UNIX                 /* @WIN */
/*
 * -------------------------------------------------------------------
 *  File:   CHK_VARI.C              08/23/88    created by Brian You
 *
 *  Descriptions:
 *      provide mechanism to check heavy variances between two font
 *          dictionaries (for font cache mechanism).
 *
 *  Heavy Items (in a font dictionary):
 *      those items which affect character's printout or metrics, such as
 *          FontMatrix, FontBBox, PaintType, StrokeWidth, etc.
 *      - for built-in fonts only; FontType dependent.
 *
 *  Revision History:
 *  1. 07/13/89  Danny- use VF for Virtual font & VFT for the change of
 *                      modules interface about composite object
 * -------------------------------------------------------------------
 */


#include    <stdio.h>
#include    <string.h>              /* for strlen() */

#include    "define.h"        /* Peter */
#include    "global.ext"
#include    "graphics.h"

#define     CHK_VARI_INC
#include    "font_sys.h"       /* for MAX_FONTTYPE */
#include    "warning.h"
#include    "fontqem.ext"      /* for heavy_items[] */
#include    "fntcache.ext"

/* --------------------- Program Convention -------------------------- */

#define FUNCTION
#define DECLARE         {
#define BEGIN
#define END             }

#define GLOBAL
#define PRIVATE         static
#define REG             register

/* ............................ chk_vari ............................. */

GLOBAL FUNCTION ufix8   chk_vari (ftype, varicode, chkdictobj, bsddictobj)
    ufix8               ftype;      /* i: FontType of fonts */
    ufix8               varicode;   /* i: to check which kind of variance */
    struct object_def  FAR *chkdictobj; /* i: font dict obj to be checked @WIN*/
    struct object_def  FAR *bsddictobj; /* i: base font obj. to check against @WIN*/

  DECLARE
    REG struct heavy_item_s    FAR *hvyp;       /*@WIN*/
    REG ubyte                 FAR * FAR *item_list;     /*@IN*/
        ufix8                   chk_bit, vari_result;
        bool                    chkobj_exist, bsdobj_exist;
        struct object_def       nameobj = {0, 0, 0};
        struct object_def       FAR *chkobj_got, FAR *bsdobj_got; /*@WIN*/
  BEGIN

#ifdef DBG
    printf ("  chk_vari: FontType=%d, VariCode=0x%X\n", ftype, varicode);
#endif

    /* initialize returned check result */
    vari_result = 0x00;

    /* get heavy item list for the specified FontType */
    for ( hvyp=heavy_items; (hvyp->ftype)<=MAX_FONTTYPE; hvyp++ )
        if (hvyp->ftype == ftype)   break;

#ifdef DBGwarn
    if ((hvyp->ftype) > MAX_FONTTYPE)
        {
        warning (CHK_VARI, 0x01, (byte FAR *)NULL);     /*@WIN*/
        return (vari_result);
        }
#endif

    ATTRIBUTE_SET (&nameobj, LITERAL);
    LEVEL_SET (&nameobj, current_save_level);

    /* check items of 1st priority: the corresponding bit been set */
    item_list = hvyp->items;
    for ( chk_bit=0x01; chk_bit!=0x80; chk_bit<<=1, item_list++ )
        {   /* from bit0 (LSB) to bit6 (MSB-1) */
        if ((*item_list) == (ubyte FAR *)NULL)      /* end of heavy items? @WIN*/
            {
#         ifdef DBG
            printf ("  end of items, result=0x%X\n", vari_result);
#         endif
            return (vari_result);
            }
#     ifdef DBG
        printf ("    current item (%s)\n", (*item_list));
#     endif
        if (varicode & chk_bit)     /* need to check? */
            {
#         ifdef DBG
            printf ("      check it, the same? ");
#         endif
            get_name (&nameobj, (byte FAR *)*item_list,         /*@WIN*/
                      lstrlen((byte FAR *)*item_list), TRUE);  /*strnlen=>lstrlen @WIN*/
            chkobj_exist = get_dict (chkdictobj, &nameobj, &chkobj_got);
            bsdobj_exist = get_dict (bsddictobj, &nameobj, &bsdobj_got);
            if (chkobj_exist == bsdobj_exist)
                {   /* both exist or both do not */
                if ( (chkobj_exist) &&              /* both exist? */
                     ( (TYPE(chkobj_got) != TYPE(bsdobj_got))
                       || (VALUE(chkobj_got) != VALUE(bsdobj_got)) ) )
                    {
                    vari_result |= chk_bit;
#                 ifdef DBG
                    printf ("No, different; result=0x%X\n", vari_result);
#                 endif
                    }
#             ifdef DBG
                else
                    printf ("Yes, or both not exist\n");
#             endif
                }
            else    /* one exists and the other does not */
                {
                vari_result |= chk_bit;
#             ifdef DBG
                printf ("No, one not exist; result=0x%X\n", vari_result);
#             endif
                }
            }
        }

    /* check items of 2nd priority */
    if (varicode & 0x80)    /* need to check? */
        {
#     ifdef DBG
        printf ("    check for others\n");
#     endif
        for (  ; (*item_list) != (ubyte FAR *)NULL; item_list++ )  /*@WIN*/
            {               /* till of end of items */
#         ifdef DBG
            printf ("    current item (%s), the same?", (*item_list));
#         endif
            get_name (&nameobj, (byte FAR *)*item_list, /*@WIN*/
                  lstrlen((byte FAR *)*item_list), TRUE); /* strlen=>lstrlen @WIN*/
            chkobj_exist = get_dict (chkdictobj, &nameobj, &chkobj_got);
            bsdobj_exist = get_dict (bsddictobj, &nameobj, &bsdobj_got);
            if (chkobj_exist == bsdobj_exist)
                {
                if ( (chkobj_exist) &&
                     ( (TYPE(chkobj_got) != TYPE(bsdobj_got))
                       || (VALUE(chkobj_got) != VALUE(bsdobj_got)) ) )
                    {
                    vari_result |= 0x80;        /* always set on MSB */
#                 ifdef DBG
                    printf ("No, different; result=0x%X\n", vari_result);
#                 endif
                    }
#             ifdef DBG
                else
                    printf ("Yes, or both not exist\n");
#             endif
                }
            else
                {
                vari_result |= 0x80;            /* always set on MSB */
#             ifdef DBG
                printf ("No, one not exist; result=0x%X\n", vari_result);
#             endif
                }
            if (vari_result & 0x80)     break;  /* some item differs */
            }
        }

#ifdef DBG
    printf ("  all checked, result=0x%X\n", vari_result);
#endif
    return (vari_result);
  END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\bsfill2.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */


// DJC added global include
#include "psglobal.h"

#define    LINT_ARGS            /* @WIN */
#define    NOT_ON_THE_MAC       /* @WIN */
#define    KANJI                /* @WIN */
// DJC use command line #define    UNIX                 /* @WIN */
/*
 * ---------------------------------------------------------------------
 *  File: BSFILL2.C
 *
 *  Algorithm Requirements:
 *      1. "interior" fill (rather than a standard PostScript fill).
 *      2. "non-zero winding number" fill (rather than a parity fill).
 *      3. keep adjacent black runs seperate from each other.
 *      4. characters have to fall within "sfix_t" representations and
 *              its size < "sfix_t" (such that distance of any 2 sfix_t
 *              nodes will still within fall sfix_t representations).
 *          (this requirement keeps all "sfix_t" computations valid and
 *              reduces floating pt. arithmetic).
 *
 *  Program Flows:
 *      1. shape approximation by constructing edges for shape outline.
 *      2. scan conversion for each scanline.
 *
 *  Revision History:
 *  1. for porting issues: word aligned for "ximin" when TO_PAGE
 *  2. for porting issues: data types, macros and LINT_ARGS
 *  3. 03/13/90  Ada    port to SUN for TYPE-I filler (flag TYPE1)
 *  4. 07/24/90  BYou   loosened the threshold condition for both X and Y
 *                          to resolve drop-outs in Type1.
 *  5. 07/24/90  BYou   fixed the conditional check to see if the actual
 *                          bitmap is or not nothing; have to look at both
 *                          dimensions, if extents in both dimensions are
 *                          nothing but 0, then the resultant bitmap is
 *                          exactly nothing. In old code, it checks if
 *                          extents in either dimension and NOT both.
 *      8/29/90; ccteng; change <stdio.h> to "stdio.h"
 *      11/22/91        upgrade for higher resolution @RESO_UPGR
 * ---------------------------------------------------------------------
 */
#include    "stdio.h"

#include    "global.ext"
#include    "graphics.h"
#include    "graphics.ext"

#include    "warning.h"

#include    "font.h"
#include    "font.ext"
#include    "fontqem.ext"

/* ---------------------- Program Convention -------------------------- */

#define FUNCTION
#define DECLARE         {
#define BEGIN
#define END             }

#define GLOBAL
#define PRIVATE         static
#define REG             register

/*
 * --------------------- DEBUG FACILITIES ----------------------------
 *  DEBUG1:     bs_fill_shape.
 *  DEBUG1_2D:      - when to scan convert in both dimensions?.
 *  DEBUG2:     edge constructions.
 *  DEBUG3:     do pairs (to stroke on which runs).
 *  DEBUG3A:        - threshold conditions handling.
 * -------------------------------------------------------------------
 */

/*
 * -------------------------------------------------------------------
 *      MODULE INTERFACES: Bitstream Fill
 * -------------------------------------------------------------------
 *  IMPORT DATA STRUCTURES:
 *      bmap_extnt (from QEM SUPPORT): created (indirectly).
 *  EXPORT DATA STRUCTURES:
 *      bs_et_first (from bs_vect2edge): initialized.   @13-
 * -------------------------------------------------------------------
 *  EXPORT ROUTINES:
 *  o  bs_fill_shape:   called by __fill_shape.
 *      - approximate shape with straight lines,
 *                      construct edges and set up 4 bitmap extents.
 *      - check bmap_extnt for some special cases.
 *      - initializse QEM SUPPORT bitmap render module.
 *      - do scan conversions.
 *      - determine whether to scan convert in both dimensions.
 *  IMPORT ROUTINES:
 *  o  qem_shape_approx():
 *      - do shape approximations with straight lines.
 *  o  bs_vect2edge():
 *      - construct edge for a given vector and set up 4 bitmap extents.
 *  o  chk_bmap_extnt():
 *      - check bmap_extnt and tell whether to go on scan conversions.
 *  o  qem_scan_conv():
 *      - do scan conversions.
 *  o  bs_dopairs():
 *      - stroke runs at a given scanline.
 *  o  free_edge():
 *      - free all the edges if ANY_ERROR().
 * -------------------------------------------------------------------
 *  Original Descriptions:      (before 10/06/88)
 *  --  called by Font Machinery to fill Bitstream's characters
 *  1. renders character bitmap in font cache or printout page.
 *  2. returns the 4 most intact bitmap extents for cache space efficiency.
 *          (the 4 extents will be extended for 1 pixel tolerance).
 *  3. determines whether to scan conversion in 1st dimension or both.
 *  4. checks whether need to apply clipping to the character object.
 *  5. aligns "bmap_extnt.ximin" and "bmap_raswid" on word boundary.
 *  6. counts "lines_per_band" to multi-band a huge object.
 * -------------------------------------------------------------------
 */
/*
 * -------------------------------------------------------------------
 *      MODULE INTERFACES: Edge Constructions
 * -------------------------------------------------------------------
 *  IMPORT DATA STRUCTURES:
 *      edge_table[]: modified.
 *      bs_et_first (from bs_fill_shape): modified.
 *      bmap_extnt (from QEMSUPP): modified.
 * ------------------------------------------------------------------
 *  EXPORT ROUTINES:
 *  o  bs_vect2edge():          called by qem_shape_approx().
 *      - reverse X, Y coord. if scan in X_DIMENSION.
 *      - update bitmap extents (bmap_extnt).
 *      - construct an edge with shifting .5 pixel at both ends of a vector.
 *                      (for "interior" fill).
 *      - insert the edge into edge table in ascending order.
 *  IMPORT ROUTINES:
 *  o  add_qem_edge():
 * -------------------------------------------------------------------
 */

#ifdef LINT_ARGS
    GLOBAL  void    bs_vect2edge (sfix_t, sfix_t, sfix_t, sfix_t,
                                fix, fix, fix, fix, ufix);
#else
    GLOBAL  void    bs_vect2edge ();
#endif

/*
 * -------------------------------------------------------------------
 *      MODULE INTERFACES: Do Pairs (Stroke Runs)
 * -------------------------------------------------------------------
 *  IMPORT DATA STRUCTURES:
 *      edge_table[]: accessed.
 *      bmap_extnt (from QEMSUPP): accessed.
 * -------------------------------------------------------------------
 *  EXPORT ROUTINES:
 *  o  bs_dopairs():
 *      - shrink 0.5 pixel at both ends for each black run.
 *      - stroke runs at a given scanline with a set of active edges.
 *  IMPORT ROUTINES:
 *  o  qem_setbits():
 *      - stroke a horizontal run.
 *  o  qem_set1bit():
 *      - stroke a discrete run.
 * -------------------------------------------------------------------
 */

#ifdef LINT_ARGS
    GLOBAL  bool        bs_dopairs (fix, ufix, fix, fix, fix);
#else
    GLOBAL  bool        bs_dopairs ();
#endif


/*
 * -------------------------------------------------------------------
 *      MODULE BODY: Bitstream Fill
 * -------------------------------------------------------------------
 *  PRIVATE DATA STRUCTURES:
 *      SMALL_in_Y: minimum threshold to scan convert in both dimensions.
 *      bsflat_lfx: bezier flatness of "lfix_t" (0.2).
 *  PRIVATE ROUTINES:
 *      none.
 * -------------------------------------------------------------------
 */

    /* threshold value to scan conversion in both dimensions */
#   define  SMALL_in_Y      28          /* for small/thin objects */

    /* flatness for flatterning bezier curves */
    PRIVATE lfix_t  near    bsflat_lfx = (lfix_t)(ONE_LFX/5);   /* 0.2 */

/* ........................ bs_fill_shape ............................ */

GLOBAL FUNCTION void        bs_fill_shape (filldest)
    ufix        filldest;   /* F_TO_CACHE or F_TO_PAGE */

/* called by Font Machinery to fill Bitstream's characters
 *  1. renders character bitmap in font cache or printout page.
 *  2. returns the 4 most intact bitmap extents for cache space efficiency.
 *          (the 4 extents will be extended for 1 pixel tolerance).
 *  3. determines whether to scan convert in 1st dimension or both.
 *  4. checks whether need to apply clipping to the character object.
 *  5. aligns "bmap_extnt.ximin" and "bmap_raswid" on word boundary.
 *  6. counts "lines_per_band" to multi-band a huge object.
 */
  DECLARE
        ufix    dimen;              /* Y_DIMENION or X_DIMENSION */
        fix     pixsz_in_y;         /* # of pixels in Y dimen < sfix_t */
        fix     pixsz_in_x;         /* # of pixels in X dimen < sfix_t */
        bool    scan_in_2D;         /* scan conv. in both dimension? */
  BEGIN

#ifdef DBG1
    printf ("BSFILL ...\n");
#endif

    dimen = Y_DIMENSION;

DO_IT_AGAIN:

    /* 1. shape approximation (edge constructions) */
#ifdef DBG1
    printf ("  shape approximation in %c\n", dimen==Y_DIMENSION? 'Y' : 'X');
#endif
    qem_shape_approx (F2L(bsflat_lfx), dimen, bs_vect2edge);
    if (ANY_ERROR())
        {   /* free all edges been built during traversal if any error */
#     ifdef DBG1
        printf ("Exit from BSFILL -- some error\n");
#     endif
        goto ABNORMAL_EXIT;         /* to free all edges */
        }

    if (dimen == Y_DIMENSION)
        {
        if ( ! chk_bmap_extnt (filldest) )
            goto ABNORMAL_EXIT;     /* no need to fill any more */

        pixsz_in_y = bmap_extnt.yimax - bmap_extnt.yimin + 1;
        pixsz_in_x = bmap_extnt.ximax - bmap_extnt.ximin + 1;

        scan_in_2D = pixsz_in_y < SMALL_in_Y;  /* small/thin objects? */
#    ifdef DBG1_2d
        printf("  pixel sz in Y (%d), 2-D scan? %d", pixsz_in_y, scan_in_2D);
#    endif
        if ((pixsz_in_y <= 0) && (pixsz_in_x <= 0))     /*  &&, NOT || */
            {
#         ifdef DBG1
            printf ("Exit from BSFILL -- no bitmap extents\n");
#         endif
            goto ABNORMAL_EXIT;
            }
        init_qem_bit (filldest);
        }

    /* 2. do scan conversion -- all edges are freed after qem_scan_conv(). */
#ifdef DBG1
    printf("  scan conversion in %c\n", dimen==Y_DIMENSION? 'Y' : 'X');
#endif
    if ( ! qem_scan_conv (dimen,
                    dimen==Y_DIMENSION? bmap_extnt.yimin : bmap_extnt.ximin,
                    dimen==Y_DIMENSION? bmap_extnt.yimax : bmap_extnt.ximax,
                    bs_dopairs) )
        {
        warning (BSFILL2, 0x11, (byte FAR *)NULL);  /* cannot format bitmap @WIN*/
        return;     /* all edges are freed even in case of fatal error */
        }

    /* check if need to scan convert in 2nd dimension? */
    if ((dimen == Y_DIMENSION) && (scan_in_2D))
        {
        dimen = X_DIMENSION;
        goto DO_IT_AGAIN;
        }

#ifdef DBG1
    printf("Exit from BSFILL\n");
#endif
    return;

  ABNORMAL_EXIT:
    return;
  END


/*
 * -------------------------------------------------------------------
 *      MODULE BODY: Edge Constructions
 * -------------------------------------------------------------------
 *  PRIVATE DATA STRUCTURES:
 *      none.
 *  PRIVATE ROUTINES:
 *      none.
 * -------------------------------------------------------------------
 */

/* ........................ bs_vect2edge ............................. */

GLOBAL FUNCTION void        bs_vect2edge (px1sfx, py1sfx, px2sfx, py2sfx,
                                         px1i, py1i, px2i, py2i, dimension)
    sfix_t      px1sfx, py1sfx, px2sfx, py2sfx; /* sfix_t pixel coord. */
    fix         px1i, py1i, px2i, py2i;         /* rounded pixel coord. */
    ufix        dimension;                      /* Y_DIMENSION, X_DIMENSION */

  DECLARE
        sfix_t   x1sfx, y1sfx, x2sfx, y2sfx; /* sfix_t pixel coord. */
    REG fix         x1i, x2i, y1i, y2i;         /* rounded pixel coord. */

        lfix_t      alpha_x_lfx;/* fix-point vrsn of alpha_x, 16 frac bits */
        fix         how_many_y; /* # of intercepts at y = n + 1/2  */
        fix         how_many_x; /* # of intercepts at x = n + 1/2  */
        lfix_t      xcept_lfx;  /* fix pt. x-intercept, 16 fract bits */
        fix         yi_start;   /* for each vector, lowest y-scan line */
        fix         xi_start;   /* for each vector, leftmost x-scan line */

  BEGIN

#ifdef DBG2
    printf("  Before edge construction,  1st (%f %f)  2nd (%f %f)\n");
            SFX2F(px1sfx), SFX2F(py1sfx), SFX2F(px2sfx), SFX2F(py2sfx));
#endif

    /* exchange x/y coord for scan conversion in the 2nd dimension */
    if (dimension == X_DIMENSION)
        {
        x1sfx = py1sfx;     y1sfx = px1sfx;
        x1i   = py1i;       y1i   = px1i;
        x2sfx = py2sfx;     y2sfx = px2sfx;
        x2i   = py2i;       y2i   = px2i;
        }
    else
        {
        x1sfx = px1sfx;     y1sfx = py1sfx;
        x1i   = px1i;       y1i   = py1i;
        x2sfx = px2sfx;     y2sfx = py2sfx;
        x2i   = px2i;       y2i   = py2i;
        }

    if (y1i <= y2i)
        {  how_many_y = y2i - y1i;   yi_start = y1i;  }
    else
        {  how_many_y = y1i - y2i;   yi_start = y2i;  }
    if (x1i <= x2i)
        {  how_many_x = x2i - x1i;   xi_start = x1i;  }
    else
        {  how_many_x = x1i - x2i;   xi_start = x2i;  }

    /* Update the character extents */
    if (dimension == Y_DIMENSION)
        {
        if (bmap_extnt.yimin > yi_start)
            bmap_extnt.yimin = (fix16)yi_start;
        if (bmap_extnt.yimax < yi_start + how_many_y - 1)
            bmap_extnt.yimax = yi_start + how_many_y - 1;
        if (bmap_extnt.ximin > xi_start)
            bmap_extnt.ximin = (fix16)xi_start;
        if (bmap_extnt.ximax < xi_start + how_many_x - 1)
            bmap_extnt.ximax = xi_start + how_many_x - 1;
        }

    /*
     * Line segment goes from (xf1, yf1) to (xf2, yf2)
     *   (xi1, yi1) and (xi2, yi2) are these endpoints rounded to integers
     * alpha_y is the slope of the line; alpha_x is the inverse slope
     * xcept and ycept are not really explainable in words, but are derived
     *   from the equations for a line:  x = (1/s)(y - y1) + x1  and
     *   y = s(x - x1) + y1,  (s is the slope, (x1, y1) is a point on the line)
     * alpha_xi, alpha_yi, xcept_int, ycept_int are fixed point numbers: the 16
     *   high-order bits are for the integer and the 16 low-order bits are
     *   for the fraction.
     */

    if (how_many_y)
        {
        struct edge_hdr     newedge;    /* template for new edge */

        /*
         * 1. starting intercept pt. = <xcept_lfx, yi_start+0.5>.
         * 2. keep (x2sfx-x1sfx) < representations(sfix_t) to avoid
         *          overflow in the following computations.
         */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                                                            /* "semi lfix_t" */
        alpha_x_lfx = SFX2LFX(x2sfx-x1sfx) / (y2sfx-y1sfx); /* 13-bit fract  */

        xcept_lfx = SFX2LFX(x1sfx) +
                        alpha_x_lfx *           /* exact lfix_t after "*" */
                        (lfix_t)(I2SFX(yi_start) + HALF_SFX - y1sfx);
#elif  FORMAT_16_16
        long dest1[2];
        long temp, quot;

        /* "alpha_x_lfx" needs to be in "LFX" format.
        */
        LongFixsMul((x2sfx - x1sfx), (1L << L_SHIFT), dest1);
        alpha_x_lfx = LongFixsDiv((y2sfx - y1sfx), dest1);

        temp = I2SFX(yi_start) + HALF_SFX - y1sfx;
        LongFixsMul((x2sfx - x1sfx), temp, dest1);
        quot = LongFixsDiv((y2sfx - y1sfx), dest1);
        xcept_lfx = SFX2LFX(x1sfx + quot);
#elif  FORMAT_28_4
        long dest1[2];
        long temp, quot;

        /* "alpha_x_lfx" needs to be in "LFX" format.
        */
        LongFixsMul((x2sfx - x1sfx), (1L << L_SHIFT), dest1);
        alpha_x_lfx = LongFixsDiv((y2sfx - y1sfx), dest1);

        temp = I2SFX(yi_start) + HALF_SFX - y1sfx;
        LongFixsMul((x2sfx - x1sfx), temp, dest1);
        quot = LongFixsDiv((y2sfx - y1sfx), dest1);
        xcept_lfx = SFX2LFX(x1sfx + quot);
#endif
        /* construct a new edge */
        newedge.QEM_YSTART = (fix16)yi_start;
        newedge.QEM_YLINES = (fix16)how_many_y;
        newedge.QEM_XINTC   = xcept_lfx;
#ifdef FORMAT_13_3 /* @RESO_UPGR */
        newedge.QEM_XCHANGE = I2SFX(alpha_x_lfx);/* semi to exact lfix_t */
#elif  FORMAT_16_16
        newedge.QEM_XCHANGE = alpha_x_lfx;
#elif  FORMAT_28_4
        newedge.QEM_XCHANGE = alpha_x_lfx;
#endif
        newedge.QEM_DIR = (y1i < y2i)? QEMDIR_DOWN : QEMDIR_UP;

#     ifdef DBG2
        printf("  construct an edge :\n");
        printf("    from (X,Y)=(%f,%d)\n", LFX2F(newedge.QEM_XINTC), yi_start);
        printf("    #(lines)=%d,  xchange=%f,  dir=%d\n",
                    how_many_y, LFX2F(newedge.QEM_XCHANGE),
                    newedge.QEM_DIR);
#     endif

        /* add it into edge_table */
        add_qem_edge (&newedge);
        }

    return;
  END


/*
 * -------------------------------------------------------------------
 *      MODULE BODY: Do Pairs (Stroke Runs)
 * -------------------------------------------------------------------
 *  PRIVATE DATA STRUCTURES:
 *      prev_stroke: the rightmost stroke at the scanline up to now.
 *                      (to keep black runs away from one another).
 *      thr_black_lfx: threshold to ignore a black run (0.05 pixel).
 *      thr_white_lfx: threshold to ignore a white run (0.05 pixel).
 * -------------------------------------------------------------------
 *  PRIVATE ROUTINES:
 *  o  bs_dothresh():
 *      - work for a run shorter than 1 pixel and wider than a threshold.
 * -------------------------------------------------------------------
 */

    /* the rightmost stroke to keep black runs away from one another */
    PRIVATE fix     near    prev_stroke;

    /* threshold to ignore a black run -- 0.05 pixel */
    PRIVATE lfix_t  near    thr_black_lfx = (ONE_LFX/20 + 1);   /* 3277 */

    /* threshold to ignore a white run -- 0.05 pixel */
    PRIVATE lfix_t  near    thr_white_lfx = (ONE_LFX/20 + 1);   /* 3277 */

#ifdef LINT_ARGS
    PRIVATE void near   bs_dothresh (lfix_t, lfix_t, fix, fix, fix, ufix);
#else
    PRIVATE void near   bs_dothresh ();
#endif

/* ........................ bs_dopairs ............................... */

GLOBAL FUNCTION bool        bs_dopairs (yline, dimension, filltype,
                                                        edge1st, edgelast)
    fix         yline;          /* current scanline */
    ufix        dimension;      /* X_DIMENSION or Y_DIMENSION */
    fix         filltype;       /* NON_ZERO or EVEN_ODD */
    fix         edge1st, edgelast;      /* range of active edges */

/* Descriptions:
 *  1. counts winding number of each run for a non-zero winding number fill.
 *  2. shrinks .5 pixel at both ends for a black run.
 *  3. strokes on runs at least 1 pixel wide for scan conversion in Y_DIMEN.
 *  4. handles the threshold condition:
 *          (a run shorted than 1 pixel and wider than a threshold value).
 *  4. determines whether to stroke a run for scan conversion in X_DIMENSION.
 *  6. records the rightmost dot been stroked.
 */
  DECLARE
    REG fix         lregi, rregi;
    REG fix         edgeii;
        lfix_t      z_lfx, lx_lfx, rx_lfx;
        fix         winding;        /* +1 for downword edge, -1 if upward */

  BEGIN

#ifdef DBG3
    printf ("bs_dopairs (at line=%d)\n", yline);
    printf ("  list of xintc ...\n");
    for ( edgeii=edge1st;
            !OUT_LAST_QEMEDGE(edgeii,edgelast); MAKE_NEXT_QEMEDGE(edgeii) )
        printf ("  %d: %f  dir=%d\n",
                edgeii,
                LFX2F(QEMEDGE_XINTC(edgeii)),
                QEMEDGE_DIR(edgeii));
#endif

    prev_stroke = (fix) MIN15;  /* far, far away from "bmap_extnt.ximin" */
    winding = 0;

    for ( edgeii=edge1st;  ;  )
        {

        /* get a pair of left and right edge */
        lregi = edgeii;
        rregi = NEXT_QEMEDGE(lregi);

        /* stop if no more pairs */
        if (OUT_LAST_QEMEDGE(rregi,edgelast)) break;

        /* get left and right x-intercept */
        lx_lfx = QEMEDGE_XINTC(lregi);      /* left  x-intercept */
        rx_lfx = QEMEDGE_XINTC(rregi);      /* right x-intercept */

        /* get starting edge of next pair (edgeii) to be ready for it */
        if (filltype==EVEN_ODD)
            edgeii = NEXT_QEMEDGE(rregi);   /* i.e. next edge of right */
        else
            {   /* NON_ZERO fill */
            edgeii = rregi;                 /* i.e. right of this pair */
            /* count winding number - looking upon direction of left edge */
            if ((winding += (QEMEDGE_DIR(lregi)==QEMDIR_DOWN? 1 : -1)) == 0)
                continue;                   /* skip for zero winding run */
            }

        /* shrink 0.5 at both ends of the run */
        lregi = LFX2I_T (lx_lfx + HALF_LFX);    /* rounded to right  */
        rregi = LFX2I_T (rx_lfx - HALF_LFX);    /* truncated to left */

#     ifdef DBG3
        printf("    xintc pair: (%f, %f)  ==>  (%d, %d)\n",
                        LFX2F(lx_lfx), LFX2F(rx_lfx), lregi, rregi);
#     endif

        /* decide to stroke or not? */
        if (dimension == Y_DIMENSION)
            {
            if (lregi <= rregi)     /* at least 1 pixel wide? */
                {
                if (lregi < bmap_extnt.ximin)   lregi = bmap_extnt.ximin;
                if (rregi > bmap_extnt.ximax)   rregi = bmap_extnt.ximax;
                if (lregi <= rregi) /* this test IS necessary */
                    {
#                 ifdef DBG3
                    printf("      stroke on the run\n");
#                 endif
                    prev_stroke = rregi; /* record the right end of the run */
                    qem_setbits (yline, lregi, rregi);
                    }
                }
            else
                {   /* < 1 pixel wide AND not too small? */
            /*  if ((rx_lfx - lx_lfx) > thr_black_lfx)   */
                    bs_dothresh (lx_lfx, rx_lfx, edgeii, edgelast,
                                                    yline, Y_DIMENSION);
                }
            }
        else    /* dimension == X_DIMENSION */
            {
            z_lfx = rx_lfx - lx_lfx;
            /* < 1 pixel AND not too small?  [[ (rregi != lregi)]] */
            if ((ONE_LFX > z_lfx))  /* && (z_lfx > thr_black_lfx)) */
                bs_dothresh (lx_lfx, rx_lfx, edgeii, edgelast,
                                                    yline, X_DIMENSION);
            }
        } /* for until no more pairs of x-intercept */

    return (TRUE);
  END

/* ........................ bs_dothresh .............................. */

PRIVATE FUNCTION void near  bs_dothresh (lx_lfx, rx_lfx, nextedge, lastedge,
                                                    yline, dimension)
    lfix_t      lx_lfx, rx_lfx;   /* left/right x-intercept of the run */
    fix         nextedge;         /* edge of next run */
    fix         lastedge;         /* last edge of the line */
    fix         yline;            /* current scan line */
    ufix        dimension;        /* X_DIMENSION or Y_DIMENSION */

/* Descriptions:        called by "bs_dopairs".
 *  -- only for a run shorter than 1 pixel and wider than a threshold.
 *  1. strokes on the dot if it is distinguishable from other runs,
 *          i.e. keeps it at least 1 pixel away from other runs.
 *  2. updates the rightmost stroke (prev_stroke) if a dot is stroked.
 */
  DECLARE
    REG fix     x1st;           /* best dot position: ctr of gravity */
    REG fix     x2nd;           /* next-best dot poisiton */
    REG fix     xset;           /* set this dot in bitmap if > 0  */
        lfix_t  next_xintc_lfx; /* "lfix_t" intercept pt. next to rx_lfx */
        fix     next_xintc;     /* "fix" version */
        lfix_t  z_lfx;          /* temps */
  BEGIN

    /* compute next_xintc */
    if (OUT_LAST_QEMEDGE(nextedge, lastedge))
        next_xintc = MAX15;     /* make it far far away if the last */
    else
        {
        next_xintc_lfx = QEMEDGE_XINTC(nextedge);
        next_xintc = ((next_xintc_lfx - rx_lfx) > thr_white_lfx)?
                LFX2I_T (next_xintc_lfx + HALF_LFX) : MAX15;
                /* make it far far away if next run is too close */
        }

    /* first choice : the middle point (fraction discarded) of this run */
    /* second choice: the left or right pixel around first choice */
    z_lfx = ((lx_lfx + rx_lfx) / 2);
    x1st = (fix) I_OF_LFX(z_lfx);
    x2nd = x1st + ((F_OF_LFX(z_lfx) < HALF_LFX)? -1 : 1);

#ifdef DBG3
    printf("    bs_dothresh: choice (1st:%d, 2nd:%d) at %d in %c\n",
        x1st, x2nd, yline, dimension==Y_DIMENSION?'Y':'X');
#endif

    /* which choice is standing alone? */
    if ((prev_stroke < x1st-1) && (next_xintc > x1st+1))
        xset = x1st;                    /* 1st choice chosen */
    else
        {   /* if stroke crosses over a pixel center and at < 4:1 ratio? */
        lfix_t  dist_ufx;   /* "unsigned" dist from rx_lfx to nearest pix */
        lfix_t  ratio_lfx;  /* ratio of dist_ufx over length of the run */

        dist_ufx = (lfix_t) ((ufix)F_OF_LFX(rx_lfx));
        if (dist_ufx > HALF_LFX)    dist_ufx = ONE_LFX - dist_ufx;
        ratio_lfx = I2LFX(dist_ufx) / z_lfx;
        if ( (ratio_lfx >= (ONE_LFX/5)) && (ratio_lfx <= (ONE_LFX*4/5)) )
            {                   /* 20%, 80% of one pixel long */
            if ((prev_stroke< x2nd-1) && (next_xintc> x2nd+1))
                xset = x2nd;            /* 2nd choice chosen */
            else
                return;     /* no stroke; both 1st and 2nd choices fail */
            }
        else
            return;         /* no stroke; both 1st and 2nd choices fail */
        }

#ifdef DBG3
    printf("      stroke on %d\n", xset);
#endif

    /* stroke on the chosen pixel */
    if (dimension == Y_DIMENSION)
        {
        if ((bmap_extnt.ximin <= xset) && (xset <= bmap_extnt.ximax))
            {
            qem_setbits (yline, xset, xset);    /* a single dot */
            }
        }
    else    /* X_DIMENSION */
        {   /* xset --> Y coord., yline --> X coord. */
        if ((bmap_extnt.yimin <= xset) && (xset <= bmap_extnt.yimax))
            {
            qem_set1bit (xset, yline);          /* Y and then X, in fact */
            }
        }
    prev_stroke = xset;     /* to keep runs seperate */
  END


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\at1intpr.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */


// DJC added global include
#include "psglobal.h"

#define    LINT_ARGS            /* @WIN */
#define    NOT_ON_THE_MAC       /* @WIN */
#define    KANJI                /* @WIN */
// DJC use command line #define    UNIX                 /* @WIN */
/***********************************************************************
 * ---------------------------------------------------------------------
 *  File   : at1intpr.c
 *
 *  Purpose: To show the Adobe Type I font.
 *
 *  Creating date
 *  Date   : Feb,  23, 1990
 *  By     : Falco Leu at Microsoft  Taiwan.
 *
 *  DBGmsg switches:
 *      DBGmsg0  - if defined, show the operator and its related operands,
 *                start and end with @@@.
 *      DBGmsg1  - if defined, show the shape description in char space.
 *                start and end with ###.
 *      DBGmsg2  - if defined, show the shape description in device space.
 *                start and end with ***.
 *      DBGmsg3  - if defined, show the stack operation.
 *                start and end with &&&.
 *      ERROR   - if defined, print the error message.
 *
 *  Revision History:
 *  02/22/90    Falco   Created.
 *  03/14/90    Falco   Comapcted and revised.
 *  03/15/90    Falco   Add at1_init(),and at1_restart().
 *                      change the current point from the device space to
 *                      character space.
 *  03/16/90    You     fix bugs: composechar(), code_to_key() and some
 *                      un-implemented operators.
 *  03/26/90    Falco   Change the composechar, add a get_real_content()
 *                      to skip the first unused data.
 *  03/26/90    Falco   Revise the at1_make_path, it only decrypt the data
 *                      and call dispatsher()(the original at1_make_path()).
 *  03/26/90    Falco   Implement the youtlinehint(), xoutlinehint(),
 *                      yevenoutlinehint(), xevenoutlinehint().
 *  04/09/90    Falco   Replace the apply_matrix() with at1fs_transform() to
 *                      add the hint.
 *  04/10/90    Falco   Change the hint from relative (0,0) to relative
 *                      to left side bearing.
 *  04/17/90    Falco   Change the outlinehint the hint pair in sort, so
 *                      add stem2_sort() and stem3_sort().
 *  04/20/90    Falco   Revise the at1_restart() to get FontBBox and
 *                      Blues.
 *  04/23/90    Falco   Rearrange the build_hint_table as 1,2 for the Blues
 *                      and FontBBox, and 3,4 for the hint pair.
 *  04/27/90    Falco   Tuning if the outlinehint/evenoutlinehint() the
 *                      direction is not use, then do nothing.
 *  05/24/90    Falco   Remove the at1_get... function in the at1_restart()
 *  05/31/90    Falco   add ystrokehint(), div(), newpath() three operator.
 *  05/31/90    Falco   add the implementation of callsubroutine().
 *  06/01/90    Falco   add if the first byte is 0xff, the below 4 byte is
 *                      2's complent data, and assume the first 2 byte is 0.
 *  06/04/90    Falco   add the NODECRYPT compile option.
 *  06/04/90    Falco   Add the flex implementation, reverse the flex to
 *                      2 Bezier curve.
 *  06/06/90    Falco   Fix the bug in grid_xstem3(), grid_ysttem(), x22_pos
 *                      ,x32_pos use x2_off instead of x1_off.
 *  06/11/90    BYou    introduce at1fs_newChar() to reset font scaler
 *                      internal data structures for each new character
 *                      (called before at1_makePath calls at1_interpreter).
 *  06/12/90    Falco   moved Blues_on to at1fs.c.
 *  06/13/90    Falco   The compose char , because skip data until 0x0d, but
 *                      if is 0xf70d, then got problem, so rewrite do_char()
 *                      to avoid this problem.
 *  07/01/90    Faclo   add 3 operator moveto(), lineto(), curveto() to solve
 *                      the case beyond the scope of black books.
 *  07/05/90    Falco   Delete the unused operators like ystrokehint(),
 *                      xstrokehint(), newpath().
 * ---------------------------------------------------------------------
 ***********************************************************************
 */
#include "global.ext"
//DJC
#include "graphics.h"
#include "fontqem.ext"
#include "at1.h"

static  fix32   FAR FontBBox[4];        /*@WIN*/

static  real32  FAR matrix[6];          /*@WIN*/

static  fix32   OPstack_count, FAR OPstack[512];         /*@WIN*/
static  fix32   SubrsStackCount, FAR SubrsStack[512];    /*@WIN*/

static  fix16   gsave_level;    /* the counter to count the gsave/grestore */
static  fix32   FAR PS[512];     /* store the operand for PDL to use @WIN*/
static  fix16   PScount;        /* the counter to count the operands above */

static  fix     lenIV;          /* the random number skipped after decryption */

static  CScoord CScurrent, CSorigin;

static  nested_call;            /* to record the times into at1_interpreter */

#ifdef  LINT_ARGS

static  void    type1_hstem(void);              /* 0x01 */
static  void    type1_vstem(void);              /* 0x03 */
static  void    type1_vmoveto(void);            /* 0x04 */
static  void    type1_rlineto(void);            /* 0x05 */
static  void    type1_hlineto(void);            /* 0x06 */
static  void    type1_vlineto(void);            /* 0x07 */
static  void    type1_rrcurveto(void);          /* 0x08 */
static  void    type1_closepath(void);          /* 0x09 */
static  void    type1_callsubr(void);           /* 0x0a */
static  void    type1_return(void);             /* 0x0b */
static  void    type1_dotsection(void);         /* 0x0c00 */
static  void    type1_vstem3(void);             /* 0x0c01 */
static  void    type1_hstem3(void);             /* 0x0c02 */
static  void    type1_seac(void);               /* 0x0c06 */
static  bool    type1_sbw(void);                /* 0x0c07 */
static  void    type1_div(void);                /* 0x0c0c */
static  void    type1_callothersubr(void);      /* 0x0c10 */
static  void    type1_pop(void);                /* 0x0c11 */
static  void    type1_setcurrentpoint(void);    /* 0x0c21 */
static  bool    type1_hsbw(void);               /* 0x0d */
static  void    type1_endchar(void);            /* 0x0e */
static  void    type1_moveto(void);             /* 0x10 */
static  void    type1_lineto(void);             /* 0x11 */
static  void    type1_curveto(void);            /* 0x12 */
static  void    type1_rmoveto(void);            /* 0x15 */
static  void    type1_hmoveto(void);            /* 0x16 */
static  void    type1_vhcurveto(void);          /* 0x1e */
static  void    type1_hvcurveto(void);          /* 0x1f */
static  void    push(fix32);
static  fix32   pop(void);
static  void    code_to_CharStrings(fix16, fix16 FAR *, ubyte FAR * FAR *); /*@WIN*/
static  ufix16  decrypt_init(ubyte FAR *, fix);         /*@WIN*/
static  ubyte   decrypt_byte(ubyte, ufix16 FAR *);      /*@WIN*/
static  bool    setmetrics(fix32, fix32, fix32,fix32);
static  void    internal_moveto(fix32, fix32);
static  void    internal_lineto(fix32, fix32);
static  void    internal_curveto(fix32, fix32, fix32, fix32, fix32, fix32);

#else

static  void    type1_hstem();                  /* 0x01 */
static  void    type1_vstem();                  /* 0x03 */
static  void    type1_vmoveto();                /* 0x04 */
static  void    type1_rlineto();                /* 0x05 */
static  void    type1_vlineto();                /* 0x06 */
static  void    type1_hlineto();                /* 0x07 */
static  void    type1_rrcurveto();              /* 0x08 */
static  void    type1_closepath();              /* 0x09 */
static  void    type1_callsubr();               /* 0x0a */
static  void    type1_return();                 /* 0x0b */
static  void    type1_dotsection();             /* 0x0c00 */
static  void    type1_vstem3();                 /* 0x0c01 */
static  void    type1_hstem3();                 /* 0x0c02 */
static  void    type1_seac();                   /* 0x0c06 */
static  bool    type1_sbw();                    /* 0x0c07 */
static  void    type1_div();                    /* 0x0c0c */
static  void    type1_callothersubr();          /* 0x0c10 */
static  void    type1_pop();                    /* 0x0c11 */
static  void    type1_setcurrentpoint();        /* 0x0c21 */
static  bool    type1_hsbw();                   /* 0x0d */
static  void    type1_endchar();                /* 0x0e */
static  void    type1_moveto();                 /* 0x10 */
static  void    type1_lineto();                 /* 0x11 */
static  void    type1_curveto();                /* 0x12 */
static  void    type1_rmoveto();                /* 0x15 */
static  void    type1_hmoveto();                /* 0x16 */
static  void    type1_vhcurveto();              /* 0x1e */
static  void    type1_hvcurveto();              /* 0x1f */
static  void    push();
static  fix32   pop();
static  void    code_to_CharStrings();
static  ufix16  decrypt_init();
static  ubyte   decrypt_byte();
static  bool    setmetrics();
static  void    internal_moveto();
static  void    internal_lineto();
static  void    internal_curveto();

#endif

// DJC changed to include void arg
void at1_init(void)
{
   ; // DJC /* nothing to do */
}

void
at1_newFont()
{
        if (at1_get_FontBBox(FontBBox) == FALSE){
#ifdef  DBGerror
                printf("at1_get_FontBBox FAIL\n");
#endif
                ERROR( UNDEFINEDRESULT );
        }

        lenIV = 4;
        at1_get_lenIV( &lenIV );

        at1fs_newFont();
}

bool
at1_newChar(encrypted_data, encrypted_len)
ubyte   FAR *encrypted_data;    /*@WIN*/
fix16   encrypted_len;
{
        bool    result;

        at1fs_newChar();
        OPstack_count = 0;
        nested_call = 0;
        gsave_level = 0;
        result = at1_interpreter(encrypted_data, encrypted_len);
        return(result);
}

/* This function according to the value, to verify is operand or operator, *
 * and then call the associated function                                   */
bool
at1_interpreter(text, length)
ubyte   FAR *text;      /*@WIN*/
fix16   length;
{
        fix32   operand;
        ufix16  decrypt_seed;
        ubyte   plain;
        fix16   i;

        decrypt_seed = decrypt_init(text, lenIV);
        text += lenIV;
        length -= (fix16)lenIV;

        while (length != 0 && !ANY_ERROR()){
                plain = decrypt_byte(*text, &decrypt_seed);
                text++;
                length--;
                if (plain < 0x20){
                        switch (plain){
                        case 0x01 : type1_hstem();
                                    break;
                        case 0x03 : type1_vstem();
                                    break;
                        case 0x04 : type1_vmoveto();
                                    break;
                        case 0x05 : type1_rlineto();
                                    break;
                        case 0x06 : type1_hlineto();
                                    break;
                        case 0x07 : type1_vlineto();
                                    break;
                        case 0x08 : type1_rrcurveto();
                                    break;
                        case 0x09 : type1_closepath();
                                    break;
                        case 0x0a : type1_callsubr();
                                    break;
                        case 0x0b : type1_return();
                                    break;
                        case 0x0c : plain = decrypt_byte(*text, &decrypt_seed);
                                    text++;
                                    length--;
                                    switch(plain){
                                        case 0x00 : type1_dotsection();
                                                    break;
                                        case 0x01 : type1_vstem3();
                                                    break;
                                        case 0x02 : type1_hstem3();
                                                    break;
                                        case 0x06 : type1_seac();
                                                    break;
                                        case 0x07 : if (type1_sbw() == FALSE)
                                                        return( FALSE);
                                                    break;
                                        case 0x0c : type1_div();
                                                    break;
                                        case 0x10 : type1_callothersubr();
                                                    break;
                                        case 0x11 : type1_pop();
                                                    break;
                                        case 0x21 : type1_setcurrentpoint();
                                                    break;
                                        default   : ERROR( UNDEFINEDRESULT );
                                                    return( FALSE );
                                    }
                                    break;
                        case 0x0d : if (type1_hsbw() == FALSE)
                                        return(FALSE);
                                    break;
                        case 0x0e : type1_endchar();
                                    break;
                        case 0x0f : type1_moveto();
                                    break;
                        case 0x10 : type1_lineto();
                                    break;
                        case 0x11 : type1_curveto();
                                    break;
                        case 0x15 : type1_rmoveto();
                                    break;
                        case 0x16 : type1_hmoveto();
                                    break;
                        case 0x1e : type1_vhcurveto();
                                    break;
                        case 0x1f : type1_hvcurveto();
                                    break;
                        default   : ERROR( UNDEFINEDRESULT );
                                    return( FALSE );
                        }
                }
                else if ((plain >= 0x20) && (plain <= 0xf6)){
                        push((fix32)(plain - 0x8b));
                }
                else if ((plain >= 0xf7) && (plain <= 0xfa)){
                        operand = (plain << 8) & 0xff00;
                        plain = decrypt_byte(*text, &decrypt_seed);
                        text++;
                        length--;
                        operand += plain;
                        push((fix32)(operand - 0xf694));
                }
                else if ((plain >= 0xfb) && (plain <= 0xfe)){
                        operand = (plain << 8) & 0xff00;
                        plain = decrypt_byte(*text, &decrypt_seed);
                        text++;
                        length--;
                        operand += plain;
                        push((fix32)(0xfa94 - operand));
                }
                else if (plain == 0xff){
                        operand = 0;
                        for (i=0 ; i<4 ; i++){
                                plain = decrypt_byte(*text, &decrypt_seed);
                                text++;
                                length--;
                                operand = operand << 8 | plain;
                        }
                        push((fix32)operand);
                }
        }

return( TRUE );
}


/****************************************************************
 *      The below function is the operator interpreter.
 *          Get the data from the internal stack and
 *          implement it.
 ****************************************************************/
/* code : 01 */
/* build the horizontal stem */
static  void
type1_hstem()
{
        fix32   CSy_pos, CSy_off;

        CSy_off = pop();
        CSy_pos = pop() + CSorigin.y;

#ifdef  DBGmsg0
        printf("\n@@@ %d %d hstem @@@\n", CSy_pos, CSy_off);
#endif

        at1fs_BuildStem(CSy_pos, CSy_off, Y);
}

/* code : 03 */
/* build vertical stem */
static  void
type1_vstem()
{
        fix32   CSx_pos, CSx_off;

        CSx_off = pop();
        CSx_pos = pop() + CSorigin.x;

#ifdef  DBGmsg0
        printf("\n@@@ %d %d vstem @@@\n", CSx_pos, CSx_off);
#endif

        at1fs_BuildStem(CSx_pos, CSx_off, X);
}

/* code : 04 */
static  void
type1_vmoveto()
{
        fix32   CSx_off, CSy_off;

        CSx_off = (fix32)0;
        CSy_off = pop();

#ifdef DBGmsg0
        printf("\n@@@ %d vmoveto @@@\n", (fix32)CSy_off);
#endif

        internal_moveto(CSx_off, CSy_off);

}

/* code : 05 */
static  void
type1_rlineto()
{
        fix32   CSx_off, CSy_off;

        CSy_off = pop();
        CSx_off = pop();

#ifdef DBGmsg0
        printf("\n@@@  %d %d rlineto @@@\n",(fix32)CSx_off, (fix32)CSy_off);
#endif

        internal_lineto(CSx_off, CSy_off);
}

/* code : 06 */
static  void
type1_hlineto()
{
        fix32   CSx_off, CSy_off;

        CSx_off = pop();
        CSy_off = (fix32)0;

#ifdef DBGmsg0
        printf("\n@@@  %d hlineto @@@\n", (fix32)CSx_off);
#endif

        internal_lineto(CSx_off, CSy_off);
}

/* code : 07 */
static  void
type1_vlineto()
{
        fix32   CSx_off, CSy_off;

        CSx_off = (fix32)0;
        CSy_off = pop();

#ifdef DBGmsg0
        printf("\n@@@ %d vlineto @@@\n",(fix32)CSy_off);
#endif

        internal_lineto(CSx_off, CSy_off);
}


/* code : 08 */
static  void
type1_rrcurveto()
{
        fix32   CSx1_off, CSy1_off, CSx2_off, CSy2_off, CSx3_off, CSy3_off;


        CSy3_off = pop();
        CSx3_off = pop();
        CSy2_off = pop();
        CSx2_off = pop();
        CSy1_off = pop();
        CSx1_off = pop();

#ifdef DBGmsg0
        printf("\n@@@ %d %d %d %d %d %d rrcurveto @@@\n",
                (fix32)CSx1_off, (fix32)CSy1_off, (fix32)CSx2_off,
                (fix32)CSy2_off, (fix32)CSx3_off, (fix32)CSy3_off);
#endif

        internal_curveto(CSx1_off,CSy1_off,CSx2_off,CSy2_off,CSx3_off,CSy3_off);
}

/* code : 09 */
static  void
type1_closepath()
{
#ifdef  DBGmsg0
        printf("\n@@@ closepath @@@\n");
#endif

#ifdef  DBGmsg1
        printf("\n### closepath ###\n");
#endif

#ifdef  DBGmsg2
        printf("\n*** closepath ***\n");
#endif

        __close_path();

}

/* code : 0A */
static  void
type1_callsubr()
{
        fix16   num;
        ubyte   FAR *encrypted_data;    /*@WIN*/
        fix16   encrypted_len;

        num = (fix16)pop();

#ifdef  DBGmsg0
        printf("\n@@@ %d callsubr @@@\n", num);
#endif

        if (at1_get_Subrs(num, &encrypted_data, &encrypted_len) == FALSE){ /*@WIN*/
#ifdef  DBGerror
                printf("at1_get_Subrs FAIL\n");
#endif
                ERROR( UNDEFINEDRESULT );
        }
        at1_interpreter(encrypted_data, encrypted_len);
}

/* code : 0B */
static  void
type1_return()
{
#ifdef  DBGmsg0
        printf("\n@@@ return @@@\n");
#endif
}

/* code : 0C00 */
/* Now is useless, it's for compatible the old interprerter */
static  void
type1_dotsection()
{
#ifdef  DBGmsg0
        printf("\n@@@ dotsection @@@\n");
#endif
}

/* code : 0c01 */
static  void
type1_vstem3()
{
        fix32   CSx1_pos, CSx1_off, CSx2_pos, CSx2_off, CSx3_pos, CSx3_off;

        CSx3_off = pop();
        CSx3_pos = pop() + CSorigin.x;
        CSx2_off = pop();
        CSx2_pos = pop() + CSorigin.x;
        CSx1_off = pop();
        CSx1_pos = pop() + CSorigin.x;

#ifdef  DBGmsg0
        printf("\n@@@ %d %d %d %d %d %d vstem3 @@@\n",
                CSx1_pos, CSx1_off, CSx2_pos, CSx2_off, CSx3_pos, CSx3_off);
#endif

        at1fs_BuildStem3(CSx1_pos, CSx1_off, CSx2_pos, CSx2_off,
                          CSx3_pos, CSx3_off, X);
}

/* code : 0c02 */
static  void
type1_hstem3()
{
        fix32   CSy1_pos, CSy1_off, CSy2_pos, CSy2_off, CSy3_pos, CSy3_off;

        CSy3_off = pop();
        CSy3_pos = pop() + CSorigin.y;
        CSy2_off = pop();
        CSy2_pos = pop() + CSorigin.y;
        CSy1_off = pop();
        CSy1_pos = pop() + CSorigin.y;

#ifdef  DBGmsg0
        printf("\n@@@ %d %d %d %d %d %d hstem3 @@@\n",
                CSy1_pos, CSy1_off, CSy2_pos, CSy2_off, CSy3_pos, CSy3_off);
#endif

        at1fs_BuildStem3(CSy1_pos, CSy1_off, CSy2_pos, CSy2_off,
                          CSy3_pos, CSy3_off, Y);
}

/* code : 0C06 */
/* Manipulate the composite char */
static  void
type1_seac()
{
        fix16   base, accent;
        fix32   lsb, CSx_off, CSy_off;
        fix16   encrypted_len;
        ubyte   FAR *encrypted_data;    /*@WIN*/

        accent   = (fix16)pop();        /* the accent char of composit */
        base     = (fix16)pop();        /* the base char of composit */
        CSy_off  = pop();
        CSx_off  = pop();               /* offset to put the 2nd char */
        lsb      = pop();                /* we do not use lsft side bearing */

#ifdef  DBGmsg0
        printf("\n@@@ %d %d %d %d %d composechar @@@\n", (fix32)lsb,
                (fix32)CSx_off, (fix32)CSy_off, (fix16)base, (fix16)accent);
#endif

/* show the first charcater in composite character */

        code_to_CharStrings(base, &encrypted_len, &encrypted_data);
                                /* transfer code to CharStrings data */
        nested_call ++;
        at1_interpreter(encrypted_data, encrypted_len);
        nested_call --;


/* show the second charcater in composite character */

        CScurrent = CSorigin;       /* return to the original address */
        CScurrent.x += CSx_off;     /* move the relative offset to    */
        CScurrent.y += CSy_off;

        code_to_CharStrings(accent, &encrypted_len, &encrypted_data);
        nested_call ++;
        at1_interpreter(encrypted_data, encrypted_len);
        nested_call --;

        USE_NONZEROFILL();               /* use non zero fill */
}

/* code : 0C07 */
/* set the leftside bearing and with of char */
static  bool
type1_sbw()
{
        fix32   lsbx, lsby;
        fix32   widthx, widthy;

        widthy = pop();                 /* get the char width */
        widthx = pop();
        lsby   = pop();                 /* get the left side bearing */
        lsbx   = pop();

#ifdef  DBGmsg0
        printf("\n@@@ %d %d %d %d sbw @@@\n", (fix32)lsbx, (fix32)lsby,
                                           (fix32)widthx, (fix32)widthy);
#endif

        return(setmetrics(lsbx, lsby, widthx, widthy));
}

/* code : 0C0C */
static  void
type1_div()
{
        fix32   num1, num2;

        num2 = pop();
        num1 = pop();
#ifdef  DBGmsg0
        printf("\n@@@ %d %d div @@@\n", num1, num2);
#endif

        push(num1/num2);
}

/* code : 0C10 */
/* This is for hint and flex, now we have not do this function */
static  void
type1_callothersubr()
{
        fix32   number;         /* the number of call othersubrs# */
//      CScoord CSref;          /* reference point in CS */     @WIN
        fix32   i;

#ifdef  DBGmsg0
        printf("\n@@@ callothersubr @@@\n");
#endif
        number = pop();         /* this is the othersubr# */
        SubrsStackCount = pop();/* the number of the parameters to othersubr */
        /* the under loop to push the relative value to subroutine stack */
        for ( i = 0 ; (i < SubrsStackCount) && (number != 3) ; i++ ){
                if ( (number == 0) && (i == 2) ){
                        pop();
                        SubrsStackCount--;
                        i--;
                }
                else
                        SubrsStack[ i ] = pop();
        }

        switch (number){
                case 0 : /* the final action to implement the flex, get the
                            value from the PostScript stack and simulate the
                            flex operation */
                         push( PS[2] );
                         push( PS[3] );
                         push( PS[4] );
                         push( PS[5] );
                         push( PS[6] );
                         push( PS[7] );
                         type1_curveto();
                         push( PS[8] );
                         push( PS[9] );
                         push( PS[10] );
                         push( PS[11] );
                         push( PS[12] );
                         push( PS[13] );
                         type1_curveto();
                         gsave_level--;
                         PScount = 0;
                         break;
                case 1 : /* initial the flex operation */
                         gsave_level++;
                         PScount = 0;
                         break;
                case 2 : /* the sequence of the flex operation */
                         PS[PScount++] = CScurrent.x;
                         PS[PScount++] = CScurrent.y;
                         if ( PScount > 14 ){
#ifdef  DBGerror
                                printf(" Out Of Flex\n");
#endif
                                ERROR( UNDEFINEDRESULT );
                         }
                         break;
                case 3 : /* Hint replacement */
                         for ( i=0 ; i < SubrsStackCount ; i++ )
                                pop();
                         SubrsStack[SubrsStackCount-1] = (fix32)3;
                         break;
                default: break;
        }
}

/* code : 0C11 */
/* We don't do the pop action really, we just skip it */
static  void
type1_pop()
{
#ifdef  DBGmsg0
        printf("\n@@@ pop @@@\n");
#endif
        push(SubrsStack[--SubrsStackCount]);
}

/* code : 0C21 */
static  void
type1_setcurrentpoint()
{
        fix32   CSx_off, CSy_off;

        CSy_off = pop();
        CSx_off = pop();

#ifdef  DBGmsg0
        printf("\n@@@ %d %d setcurrentpoint @@@\n", (fix32)CSx_off, (fix32)CSy_off);
#endif
        CScurrent.x = CSx_off;
        CScurrent.y = CSy_off;

#ifdef  DBGmsg1
        printf("\n### current point = %d %d ###\n", (fix32)CSx_off, (fix32)CSy_off);
#endif
}

/* code : 0D */
static  bool
type1_hsbw()
{
        fix32   lsbx, widthx;

        widthx = pop();                 /* get the char width in x */
        lsbx   = pop();                 /* get the left side bearing in x */

#ifdef  DBGmsg0
        printf("\n@@@ %d %d hsbw @@@\n", (fix32)lsbx, (fix32)widthx);
#endif

        return(setmetrics(lsbx, 0, widthx, 0));
}

/* code : 0E */
static  void
type1_endchar()
{
#ifdef  DBGmsg0
        printf("\n@@@ endoutlinechar @@@\n");
#endif

        // RAID 4492, Fixed Type1 fonts that were showing up from the chooser
        //            where the type1 fonts , were actually converted from
        //            TrueType. The fonts were missing a closepath at the
        //            end of the char description, which was causing the
        //            interpreter to blow up, because it could not fill a
        //            path that was truly not closed.


        type1_closepath();

}

/* code : 10 */
/* for absolute moveto */
static  void
type1_moveto()
{
        fix32   CSx_off, CSy_off;
        DScoord DScurrent;

        CSy_off = pop();
        CSx_off = pop();

#ifdef DBGmsg0
        printf("\n@@@  %d %d moveto @@@\n",(fix32)CSx_off, (fix32)CSy_off);
#endif

        CScurrent.x = CSx_off;
        CScurrent.y = CSy_off;

#ifdef DBGmsg1
        printf("\n### %d %d moveto ###\n",(fix32)CSx_off, (fix32)CSy_off);
#endif

        at1fs_transform(CScurrent, &DScurrent);

#ifdef DBGmsg2
        printf("\n*** %d %d moveto ***\n",DScurrent.x, DScurrent.y);
#endif

        __moveto(F2L(DScurrent.x), F2L(DScurrent.y));
}

/* code : 11 */
/* for absoluet lineto */
static  void
type1_lineto()
{
        fix32   CSx_off, CSy_off;
        DScoord DScurrent;

        CSy_off = pop();
        CSx_off = pop();

#ifdef DBGmsg0
        printf("\n@@@  %d %d lineto @@@\n",(fix32)CSx_off, (fix32)CSy_off);
#endif

        CScurrent.x = CSx_off;
        CScurrent.y = CSy_off;

#ifdef DBGmsg1
        printf("\n### %d %d lineto ###\n",(fix32)CSx_off, (fix32)CSy_off);
#endif

        at1fs_transform(CScurrent, &DScurrent);

#ifdef DBGmsg2
        printf("\n***  %f %f lineto ***\n",DScurrent.x, DScurrent.y);
#endif

        __lineto(F2L(DScurrent.x), F2L(DScurrent.y));
}

/* code : 12 */
/* for absoluet curveto */
static  void
type1_curveto()
{
        fix32   CSx1_off, CSy1_off, CSx2_off, CSy2_off, CSx3_off, CSy3_off;
        DScoord DScurrent1, DScurrent2, DScurrent3;


        CSy3_off = pop();
        CSx3_off = pop();
        CSy2_off = pop();
        CSx2_off = pop();
        CSy1_off = pop();
        CSx1_off = pop();

#ifdef DBGmsg0
        printf("\n@@@ %d %d %d %d %d %d curveto @@@\n",
               (fix32)CSx1_off, (fix32)CSy1_off, (fix32)CSx2_off,
               (fix32)CSy2_off, (fix32)CSx3_off, (fix32)CSy3_off);
#endif

#ifdef DBGmsg1
        printf("\n### %d %d %d %d %d %d curveto ###\n",
               (fix32)CSx1_off, (fix32)CSy1_off, (fix32)CSx2_off,
               (fix32)CSy2_off, (fix32)CSx3_off, (fix32)CSy3_off);
#endif

        CScurrent.x = CSx1_off;
        CScurrent.y = CSy1_off;
        at1fs_transform(CScurrent, &DScurrent1);

        CScurrent.x = CSx2_off;
        CScurrent.y = CSy2_off;
        at1fs_transform(CScurrent, &DScurrent2);

        CScurrent.x = CSx3_off;
        CScurrent.y = CSy3_off;
        at1fs_transform(CScurrent, &DScurrent3);

#ifdef DBGmsg2
        printf("\n*** %f %f %f %f %f %f curveto ***\n", DScurrent1.x,
          DScurrent1.y, DScurrent2.x, DScurrent2.y, DScurrent3.x, DScurrent3.y);
#endif

        __curveto(F2L(DScurrent1.x), F2L(DScurrent1.y), F2L(DScurrent2.x),
                  F2L(DScurrent2.y), F2L(DScurrent3.x), F2L(DScurrent3.y));
}

/* code : 15 */
static  void
type1_rmoveto()
{
        fix32   CSx_off, CSy_off;

        CSy_off = pop();
        CSx_off = pop();

#ifdef DBGmsg0
        printf("\n@@@  %d %d rmoveto @@@\n",(fix32)CSx_off, (fix32)CSy_off);
#endif

        internal_moveto(CSx_off, CSy_off);
}

/* code : 16 */
static  void
type1_hmoveto()
{
        fix32   CSx_off, CSy_off;


        CSx_off = pop();
        CSy_off = (fix32)0;

#ifdef DBGmsg0
        printf("\n@@@  %d hmoveto @@@\n", (fix32)CSy_off);
#endif

        internal_moveto(CSx_off, CSy_off);
}

/* code : 1E */
static  void
type1_vhcurveto()
{
        fix32   CSx1_off, CSy1_off, CSx2_off, CSy2_off, CSx3_off, CSy3_off;

        CSy3_off = (fix32)0;
        CSx3_off = pop();
        CSy2_off = pop();
        CSx2_off = pop();
        CSy1_off = pop();
        CSx1_off = (fix32)0;

#ifdef DBGmsg0
        printf("\n@@@ %d %d %d %d vhcurveto @@@\n", (fix32)CSy1_off,
               (fix32)CSx2_off, (fix32)CSy2_off, (fix32)CSx3_off);
#endif

        internal_curveto(CSx1_off, CSy1_off, CSx2_off,
                         CSy2_off, CSx3_off, CSy3_off);
}

/* code : 1F */
static  void
type1_hvcurveto()
{
        fix32    CSx1_off, CSy1_off, CSx2_off, CSy2_off, CSx3_off, CSy3_off;

        CSy3_off = pop();
        CSx3_off = (fix32)0;
        CSy2_off = pop();
        CSx2_off = pop();
        CSy1_off = (fix32)0;
        CSx1_off = pop();

#ifdef DBGmsg0
        printf("\n@@@ %d %d %d %d hvcurveto @@@\n", (fix32)CSx1_off,
               (fix32)CSx2_off, (fix32)CSy2_off, (fix32)CSy3_off);
#endif

        internal_curveto(CSx1_off, CSy1_off, CSx2_off,
                         CSy2_off, CSx3_off, CSy3_off);
}



/*************  Miscellaneous   ****************/


/************************************************************
 *      Function : code_to_CharStrings
 *              input the code in encoding table
 *      to get the data in CharStrings
 *      For composite char to call.
 ************************************************************/
struct{
fix16   code;
byte    FAR *text;      /*@WIN*/
} encode[]={
        0x20,"space", 0x21,"exclam", 0x22,"quotedbl", 0x23,"numbersign",
        0x24,"dollar", 0x25,"percent", 0x26,"ampersand", 0x27,"quoteright",
        0x28,"parenleft", 0x29,"parenright", 0x2a,"asterisk", 0x2b,"plus",
        0x2c,"comma", 0x2d,"hyphen", 0x2e,"period", 0x2f,"slash", 0x30,"zero",
        0x31,"one", 0x32,"two", 0x33,"three", 0x34,"four", 0x35,"five",
        0x36,"six", 0x37,"seven", 0x38,"eight", 0x39,"nine", 0x3a,"colon",
        0x3b,"semicolon", 0x3c,"less", 0x3d,"equal", 0x3e,"greater",
        0x3f,"question", 0x40,"at", 0x41,"A", 0x42,"B", 0x43,"C", 0x44,"D",
        0x45,"E", 0x46,"F", 0x47,"G", 0x48,"H", 0x49,"I", 0x4a,"J", 0x4b,"K",
        0x4c,"L", 0x4d,"M", 0x4e,"N", 0x4f,"O", 0x50,"P", 0x51,"Q", 0x52,"R",
        0x53,"S", 0x54,"T", 0x55,"U", 0x56,"V", 0x57,"W", 0x58,"X", 0x59,"Y",
        0x5a,"Z", 0x5b,"bracketleft", 0x5c,"backlash", 0x5d,"bracketright",
        0x5e,"asciicircum", 0x5f,"underscore", 0x60,"quoteleft", 0x61,"a",
        0x62,"b", 0x63,"c", 0x64,"d", 0x65,"e", 0x66,"f", 0x67,"g", 0x68,"h",
        0x69,"i", 0x6a,"j", 0x6b,"k", 0x6c,"l", 0x6d,"m", 0x6e,"n", 0x6f,"o",
        0x70,"p", 0x71,"q", 0x72,"r", 0x73,"s", 0x74,"t", 0x75,"u", 0x76,"v",
        0x77,"w", 0x78,"x", 0x79,"y", 0x7a,"z", 0x7b,"braceleft", 0x7c,"bar",
        0x7d,"braceright", 0x7e,"asciitilde", 0xa1,"exclamdown", 0xa2,"cent",
        0xa3,"sterling", 0xa4,"fraction", 0xa5,"yen", 0xa6,"florin",
        0xa7,"section", 0xa8,"currency", 0xa9,"quotesingle", 0xaa,"quotedblleft",
        0xab,"guillemotleft", 0xac,"guilsinglleft", 0xad,"guilsinglright",
        0xae,"fi", 0xaf,"fl", 0xb1,"endash", 0xb2,"dagger", 0xb3,"daggerdbl",
        0xb4,"periodcentered", 0xb6,"paragrapgh", 0xb7,"bullet",
        0xb8,"quotesinglebase", 0xb9,"quotedblbase", 0xba,"quotedblright",
        0xbb,"guillemotright", 0xbc,"ellipsis", 0xbd,"perhousand",
        0xbf,"questiondown", 0xc1,"grave", 0xc2,"acute", 0xc3,"circumflex",
        0xc4,"tilde", 0xc5,"macron", 0xc6,"breve", 0xc7,"dotaccent",
        0xc8,"dieresis", 0xca,"ring", 0xcb,"cedilla", 0xcd,"hungarumlaut",
        0xce,"ogonek", 0xcf,"caron", 0xd0,"emdash", 0xe1,"AE",
        0xe3,"ordfeminine", 0xe8,"Lslash", 0xe9,"Oslash", 0xea,"OE",
        0xeb,"ordmasculine", 0xf1,"ae", 0xf5,"dotlessi", 0xf8,"lslash",
        0xf9,"oslash", 0xfa,"oe", 0xfb,"germandbls"
};

static  void
code_to_CharStrings(code, encrypted_len, encrypted_data)
fix16   code;
fix16   FAR *encrypted_len;     /*@WIN*/
ubyte   FAR * FAR *encrypted_data;      /*@WIN*/
{
        ubyte   FAR *key;       /*@WIN*/
        fix16   i;

        i=0;
        while (encode[i].code != code) i++;
        key = (ubyte FAR *)encode[i].text;      /*@WIN*/
        if (at1_get_CharStrings(key, encrypted_len, encrypted_data) == FALSE){
#ifdef  DBGerror
                printf("at1_get_CharStrings FAIL\n");
#endif
                ERROR( UNDEFINEDRESULT );
        }
}

/***********************************************
 * The below 2 function is for stack operation
 * push() : add a data to stack.
 * pop() : get a data from stack.
 ***********************************************/
static  void
push(content)
        fix32   content;
{
        if (OPstack_count == 512)
                ERROR(STACKOVERFLOW);
        OPstack[OPstack_count++] = content;

#ifdef  DBGmsg3
        printf("\n&&& Push %d &&& \n", (fix32)content);
#endif
}

static  fix32
pop ()
{
        fix32   content;
         //DJC fix for UPD042
        //if (OPstack_count <= 0)
        //        ERROR(STACKUNDERFLOW);
        //
        //content = OPstack[--OPstack_count];
        if (OPstack_count > 0 ) {
           OPstack_count--;
        }
        content = OPstack[OPstack_count];

        //DJC end for fix UPD042


#ifdef  DBGmsg3
        printf("\n&&& Pop %d &&&\n", (fix32)content);
#endif

        return(content);
}

/* This function to set the initial value to decryption */
static  ufix16
decrypt_init(encrypted_data, random)
ubyte   FAR *encrypted_data;    /*@WIN*/
fix     random;                 /* the random number skipped after decryption */
{
        fix     i;
        ufix16  decryption_key;

        decryption_key = 4330;
        for (i=0; i< random; i++){
                decryption_key = (decryption_key + *encrypted_data) * 0xce6d
                                 + 0x58bf;
                encrypted_data++;
        }
        return(decryption_key);
}

/* To decrypt the data on the fly */
static  ubyte
decrypt_byte(cipher, decryption_key)
ubyte   cipher;         /* the data before decrypt */
ufix16  FAR *decryption_key;    /*@WIN*/
{
        ubyte   plain;  /* the data after decrypt */

        plain = (ubyte)((cipher ^ (*decryption_key >> 8)) & 0xff);
        *decryption_key = (*decryption_key + cipher) * 0xce6d + 0x58bf;
        return(plain);
}



/* This function use to for hsbw/sbw to setmetrics */
static  bool
setmetrics(lsbx, lsby, widthx, widthy)
fix32   lsbx, lsby;             /* the left side bearing */
fix32   widthx, widthy;         /* the width of this char */
{
        fix     __set_char_width (fix, fix);    /* added prototype @WIN*/

        if (nested_call != 0) return(TRUE);

        if (FontBBox[0] == 0 && FontBBox[1] == 0 &&
            FontBBox[2] == 0 && FontBBox[3] == 0){
            __set_char_width( (fix)widthx, (fix)widthy );
        } else {
            if (__set_cache_device((fix) widthx, (fix)widthy,
                           (fix) FontBBox[0], (fix) FontBBox[1],
                           (fix) FontBBox[2], (fix) FontBBox[3]) == STOP_PATHCONSTRUCT){
#ifdef DEBerror
                printf("out of cache\n");
#endif
                return(FALSE);
                }
        }

        __current_matrix(matrix);

        at1fs_matrix_fastundo(matrix);  /* to get the associated value relate
                                           to matrix */

        at1fs_BuildBlues();    /* To build the table of Balues related value */

/* Falco add for startpage Logo, 02/01/91 */
/*      USE_EOFILL();           /* use even-odd fill */
        USE_NONZEROFILL();
/* add end */

        __new_path();

        CScurrent.x = lsbx;       /* initialize the starting address from  */
        CScurrent.y = lsby;       /* left side bearing                     */

#ifdef DBGmsg1
        printf("\n### origin point = %d %d ###\n",
               (fix32)CScurrent.x, (fix32) CScurrent.y);
#endif

        CSorigin = CScurrent;       /* store the starting address for seac use */
        return (TRUE);
}

/* This is the intermediate function for type1_rmoveto(), type1_hmoveto(),
 * type1_vmoveto(), but exclude type1_moveto(), because it is in absolute
 * address */
static  void
internal_moveto(CSx_off, CSy_off)
fix32   CSx_off, CSy_off;
{
        DScoord DScurrent;

        CScurrent.x += CSx_off;
        CScurrent.y += CSy_off;

        if (gsave_level != 0)   /* if need to call the PostScript interpreter */
                return;

#ifdef DBGmsg1
        printf("\n### %d %d moveto ###\n", (fix32)CScurrent.x, (fix32)CScurrent.y);
#endif

        at1fs_transform(CScurrent, &DScurrent);

#ifdef DBGmsg2
        printf("\n*** %f %f moveto ***\n", DScurrent.x, DScurrent.y);
#endif

        __moveto(F2L(DScurrent.x), F2L(DScurrent.y));
}


/* This is the intermediate function for type1_rlineto(), type1_hlineto(),
 * type1_vlineto(), but exclude type1_lineto(), because it is in absolute
 *  address */
static  void
internal_lineto(CSx_off, CSy_off)
fix32   CSx_off, CSy_off;
{
        DScoord DScurrent;

        CScurrent.x += CSx_off;
        CScurrent.y += CSy_off;

#ifdef DBGmsg1
        printf("\n### %d %d lineto ###\n", (fix32)CScurrent.x, (fix32)CScurrent.y);
#endif

        at1fs_transform(CScurrent, &DScurrent);

#ifdef DBGmsg2
        printf("\n*** %f %f lineto ***\n", DScurrent.x, DScurrent.y);
#endif

        __lineto(F2L(DScurrent.x), F2L(DScurrent.y));
}


/* This is the intermediate function for type1_rrcurve(), type1_vhcurveto(),
 * type1_hvcurveto(), but exclude type1_curveto(), because it is in absolute
 *  address */
static  void
internal_curveto(CSx1_off, CSy1_off, CSx2_off, CSy2_off, CSx3_off, CSy3_off)
fix32   CSx1_off, CSy1_off, CSx2_off, CSy2_off, CSx3_off, CSy3_off;
{

        fix32   CSx1_pos, CSy1_pos, CSx2_pos, CSy2_pos, CSx3_pos, CSy3_pos;
        DScoord  DScurrent1, DScurrent2, DScurrent3;


        CSx1_pos = CScurrent.x + CSx1_off;
        CSy1_pos = CScurrent.y + CSy1_off;

        CSx2_pos = CSx1_pos + CSx2_off;
        CSy2_pos = CSy1_pos + CSy2_off;

        CSx3_pos = CSx2_pos + CSx3_off;
        CSy3_pos = CSy2_pos + CSy3_off;

#ifdef DBGmsg1
        printf("\n### %d %d %d %d %d %d curveto ###\n",
               (fix32)CSx1_pos, (fix32)CSy1_pos, (fix32)CSx2_pos,
               (fix32)CSy2_pos, (fix32)CSx3_pos, (fix32)CSy3_pos);
#endif

        CScurrent.x = CSx1_pos;
        CScurrent.y = CSy1_pos;
        at1fs_transform(CScurrent, &DScurrent1);

        CScurrent.x = CSx2_pos;
        CScurrent.y = CSy2_pos;
        at1fs_transform(CScurrent, &DScurrent2);

        CScurrent.x = CSx3_pos;
        CScurrent.y = CSy3_pos;
        at1fs_transform(CScurrent, &DScurrent3);

#ifdef DBGmsg2
        printf("\n*** %f %f %f %f %f %f curveto ***\n", DScurrent1.x,
          DScurrent1.y, DScurrent2.x, DScurrent2.y, DScurrent3.x, DScurrent3.y);
#endif

        __curveto(F2L(DScurrent1.x), F2L(DScurrent1.y), F2L(DScurrent2.x),
                  F2L(DScurrent2.y), F2L(DScurrent3.x), F2L(DScurrent3.y));
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\dictdata.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/* @WIN; take out the static def of dict data. The tables will be allocated
 * thru global alloc, and contents be loaded at run time, in "fontinit.c".
 */
#include "fontdefs.h"

struct    dict_head_def far *FontDir;    /* head pointer of FontDirectory */


#define   DICT_SIZE(no)     /* no: entry number in dict  */   \
          (sizeof(struct dict_head_def)+(no)*sizeof(struct dict_content_def) )
#define   ARRAY_SIZE(no)    /* no: entry number in array */   \
          ( (no)*sizeof(struct object_def) )

#define   CD_SIZE(no)      \
          (sizeof(struct dict_head_def)+ sizeof(struct cd_header) + \
           (no)*sizeof(fix16) )
#define   CD_KEY_SIZE(no)   \
          ( (no)*sizeof(fix16) )


ufix16    NO_FD =          250   ;  /* max FontDirectory entry          */
#ifdef    ADD2ID   /*DLF42*/
#define   NO_FDICT         13       /* + PlatformID & EncodingID        */
#else
#define   NO_FDICT         11       /* - PlatformID & EncodingID        */
#endif /*ADD2ID*/

#define   NO_FINFO          9       /* max FontInfo entry               */

#define   NO_EN             3       /* Standard,Symbol,ZapfDingbats     */

#define   STD_IDX           0       /* Standard     Encording index     */
#define   SYM_IDX           1       /* Symbol       Encording index     */
#define   ZAP_IDX           2       /* ZapfDingbats Encording index     */

//DJC#define   NO_CD           400       /* max CharStrings key number       */
#define   NO_CD           1400       /* max CharStrings key number       */
                                    /* 500->400, Kason 2/1/91           */
#define   SFNT_BLOCK_SIZE 65532L    /* sfnts object array string size   */
//struct    object_def    en_obj[NO_EN][256]; def move to "fontinit.c " @WIN
extern struct object_def  (FAR * en_obj)[256]; /* encoding object */
struct    dict_head_def far *cd_addr[NO_EN];    /* CD address      */

typedef   struct
              {
                 fix16      CDCode;
                 ufix16     CharCode;
                 byte       FAR *CharName; /*@WIN*/
              }  enco_data;

/* @WIN ---begin--- move def out; to be loaded at run time, in "fontinit.c" */
#define  SFNTGLYPHNUM  258   /* copy to "fontinit.c" @WIN */
extern enco_data FAR * Std_Enco;
extern enco_data FAR * Sym_Enco;
extern enco_data FAR * Zap_Enco;
extern byte FAR * FAR * sfntGlyphSet;
extern enco_data FAR * Enco_Ary[];
/* @WIN --- end --- */

/* Kason 2/1/91 */
struct new_str_dict {
    ufix16  k;
    fix16   v;
};

/*************************************************************************
**
**   Header for FontInfo directory.
**
**************************************************************************/
/* Local data of sfnt */
#define NO_STRING_IN_NAMING      5
#define NID_CopyrightNotice      0
#define NID_FamilyName           1
#define NID_Weight               2
#define NID_FullName             4
#define NID_FontName             6

#define Notice_idx               0
#define FamilyName_idx           1
#define Weight_idx               2
#define FullName_idx             3
#define FontName_idx             4

#define MAXFINFONAME 128  // DJC addes as per history UPD025

/* nameID in namingTable */
static struct  sfnt_FontInfo1 {
        fix   nameID;
        char  FAR *NameInFinfo; /*@WIN*/
//DJC        char  string[100]; /* 80, Kason 11/28/90 */
//DJC fix from history.log UPD025
        char  string[MAXFINFONAME];
}       Item4FontInfo1[NO_STRING_IN_NAMING] = {
        {NID_CopyrightNotice,   "Notice",},
        {NID_FamilyName,        "FamilyName",},
        {NID_Weight,            "Weight",},
        {NID_FullName,          "FullName"},
        {NID_FontName,          "FontName",},
};
#define NO_STRING_NOTIN_NAMING        1
#define IDEX_VERSION                  0
#define Version_idx                   0
static struct  sfnt_FontInfo2 {
        char  FAR *NameInFinfo; /*@WIN*/
        char  string[80];
}       Item4FontInfo2[NO_STRING_NOTIN_NAMING] = {
        {"version", },
};
typedef char   string_s[80];
/* replace by Falco, 11/18/91 */
/*static char    *SfntAddr;*/
char    FAR *SfntAddr; /*@WIN*/
/* replace end */
struct data_block {   /* Kason 12/04/90 */
       fix32   llx, lly, urx, ury;
       bool    is_fixed;
       ufix32  dload_uid;
       real32  italicAngle;
       real32  underlinePosition;
       real32  underlineThickness;
} ;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\fcachesr.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * -------------------------------------------------------------------
 *  File:   FCACHESR.H              11/28/90    created by Danny
 *
 *      Font Cache Save/Restore constants for precache fonts
 *
 *  References:
 *      FNTCACHE.C
 *
 *  Revision History:
 *  11/28/90  Danny   Precache Mech. Added, ref:PCH
 * -------------------------------------------------------------------
 */

/*  PCH: Begin, Danny, 11/28/90 */
#define   PRECACHE_BASE_S   0x40040000  /* for new seperate font YM */
#define   PRECACHE_BASE_R   0x80650000  /* ICE version */
/*#define   PRECACHE_BASE_R   0x40060000  |* ROM version */
/*  PCH: End, Danny, 11/28/90 */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\at1fs.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */


// DJC added global include
#include "psglobal.h"

#define    LINT_ARGS            /* @WIN */
#define    NOT_ON_THE_MAC       /* @WIN */
#define    KANJI                /* @WIN */
// DJC use command line #define    UNIX                 /* @WIN */
/***********************************************************************
 * ---------------------------------------------------------------------
 *  File   : at1fs.c
 *
 *  Purpose: The hint related procedure..
 *
 *  Creating date
 *  Date   : Apr, 09, 1990
 *  By     : Falco Leu at Microsoft  Taiwan.
 *
 *  DBGmsg switches:
 *      DBGnohint  - if defined, Only use ctm transfer to DS, do not apply hinting.
 *      DBGmsg0    - if defined, Show the data with Hinting and Without Hinting.
 *      DBGmsg1    - if defined, Show the Hint Table in CS and DS and its scaling.
 *      DBGerror   - if defined, print the error message.
 *
 *  Revision History:
 *  04/09/90    Falco   Created.
 *  04/10/90    Falco   Implement the 2nd hint algorithm. First grid fitting
 *                      the point near the grid, then use this point to
 *                      grid fitting the another point.
 *  04/17/90    Falco   Change the grid_stem2() and grid_stem3() parameter,
 *                      and revise these two procedure because the input
 *                      has been sorted.
 *  04/20/90    Falco   In build_hint_table() to add 3, 4 to manipulate the
 *                      main hint in for hint pair to apply.
 *  04/20/90    Falco   Calculate the scaling of hint pair previously, so
 *                      we can skip the calculation time in apply_hint().
 *  04/23/90    Falco   Rearrange the build_hint_table as 1,2 for the Blues
 *                      and FontBBox, and 3,4 for the hint pair.
 *  04/26/90    Falco   Add in grid_ystem2() to when the hint pair is within
 *                      the Blues, use Blues to grif the hint pair.
 *  04/27/90    Falco   1) revise build_Blues_table() to add if rotation or not
 *                      2) rewrite the apply_hint() to think of x-y, y->x;
 *  05/24/90    Falco   Skip the FontBBox as the hint, because it is useless,
 *                      if the control point is out the hint table, we wil
 *                      calculate the offset to to the grid of the hint.
 *  05/24/90    Falco   Recalculate the x coordinate hint pair valur from
 *                      leftmost, so to keep it balance.
 *  05/25/90    Falco   Try outside of hint table, using the grid data instead
 *                      of real address.
 *  06/08/90    Falco   Manipulate the rotation & oblique function.
 *  06/11/90    BYou    introduce at1fs_newChar() to reset xmain_count,
 *                      ymain_count, xhint_count, yhint_count and HINT_FLAG
 *                      for each new character.
 *  06/12/90    Falco   moved Blues_on in from at1intpr.c.
 *  06/25/90    Falco   revise the error in grid_xstem & grid_ystem, because
 *                      when check if the LFX is above 0.5, the value is 0x8000
 *                      instead 0x8fff, so we replace HALF_LFX, to avoid the con
 *                      fusion.
 *  07/01/90    Falco   Add a condition when there are no hint, just apply
 *                      matrix directly.
 *  07/10/90    Falco   Revise the program totally.
 * ---------------------------------------------------------------------
 ***********************************************************************
 */

#include <math.h>
#include "global.ext"
#include "graphics.h"
#include "at1.h"

static  bool8   BluesON, HintON;

static  fix16   Blues_count;
static  fix32   Blues[24];

static  HintTable BluesTable, X_StemTable, Y_StemTable;

static  real32  ctm[6]  = { (real32)0., (real32)0., (real32)0.,
                            (real32)0., (real32)0., (real32)0.};  //@WIN

static  fix     usingXorY[2] = { XY, XY };
                        /* to compute Xds/Yds using Xcs or Ycs */

static  fix     isvalid[2]   = { FALSE, FALSE };
                        /* vert. or hori. stems in CS are still vert. or hori. in DS */

static  real32  toplscale[2] = { (real32)0., (real32)0. };      //@WIN
                        /* top level scaling from Xcs or Ycs to its corresponding DS */



#ifdef  LINT_ARGS

static  bool8 ApplyBlues( fix32, fix32, fix32, fix16 FAR *, fix16 FAR *);/*@WIN*/
static  void  grid_stem( fix32, fix32, fix32, fix16 FAR *, fix16 FAR *, DIR );/*@WIN*/
static  void  grid_stem3( fix32,fix32,fix32,fix32,fix32,fix32,fix32,fix32,fix32,
                          fix16 FAR *, fix16 FAR *, fix16 FAR *, fix16 FAR *,
                          fix16 FAR *, fix16 FAR *, DIR );      /*@WIN*/
static  void  InitStemTable( void );
static  void  AddHintTable( Hint, HintTable FAR *);     /*@WIN*/
static  void  ScaleStemTable( HintTable FAR * );        /*@WIN*/
static  void  ApplyHint( fix32, real32 FAR *, HintTable, DIR ); /*@WIN*/

#else

static  bool8 ApplyBlues();
static  void  grid_stem();
static  void  grid_stem3();
static  void  InitStemTable();
static  void  AddHintTable();
static  void  ScaleStemTable();
static  void  ApplyHint();

#endif

void
at1fs_newFont()
{
        if (at1_get_Blues(&Blues_count, Blues) == FALSE){
#ifdef  DBGerror
                printf("at1_get_Blues FAIL\n");
#endif
                ERROR( UNDEFINEDRESULT );
        }
}

void
at1fs_newChar()
{
        BluesTable.Count = 0;
        X_StemTable.Count = Y_StemTable.Count = 0;
        BluesON = FALSE;
        HintON  = FALSE;

}

/********************************************************
 *      Function : at1fs_matrix_fastundo()
 *          This function calculate which direction is valid and
 *      its associated value for control point to apply.
 *
 *      i : matr[] : the matrix get from __current_matrix().
 *
 *      The influenced data.
 *          isvalid[2]   : to set X or Y coordinate is valid or not.
 *          usingXorY[2] : to set X or Y depends on X or Y.
 *          toplscale[2] : the scaling from CS to DS.
 *********************************************************/
void
at1fs_matrix_fastundo( matr )
    real32      FAR matr[];     /*@WIN*/
{
#   define MAX_QEM_CHARSIZE    (MAX15)

#ifdef MATRDBG
    printf( "matrix_undo :\n  %f %f %f\n  %f %f %f\n",
            matr[0], matr[2], matr[4], matr[1], matr[3], matr[5] );
#endif

    ctm[4] = matr[4];
    ctm[5] = matr[5];

    /* check if matrix cached already */
    if( ctm[0] == matr[0] && ctm[1] == matr[1] &&
        ctm[3] == matr[2] && ctm[3] == matr[3] )
    {
#ifdef MATRDBG
    printf( " ... matrix cached\n" );
#endif
        return;
    }

    /* update the matrix */
    ctm[0] = matr[0];
    ctm[1] = matr[1];
    ctm[2] = matr[2];
    ctm[3] = matr[3];

    /* upright and rotate 0 or 180 */
    if( ctm[1] == zero_f  && ctm[2] == zero_f )
    {
#ifdef MATRDBG
        printf( " ... upright, rotate 0 or 180\n" );
#endif
        usingXorY[ X ] = X;
        usingXorY[ Y ] = Y;
        /* Falco add */
        if(( ctm[0] > MAX_QEM_CHARSIZE ) ||
           ( ctm[1] > MAX_QEM_CHARSIZE ) ||
           ( ctm[2] > MAX_QEM_CHARSIZE ) ||
           ( ctm[3] > MAX_QEM_CHARSIZE ) ||
           ( ctm[4] > MAX_QEM_CHARSIZE ) ||
           ( ctm[5] > MAX_QEM_CHARSIZE )){
                isvalid[ X ] = TRUE;
                isvalid[ Y ] = TRUE;
        }
        else{
        isvalid[ X ] = TRUE;
        isvalid[ Y ] = TRUE;
        }
        toplscale[ X ] = ctm[0];
        toplscale[ Y ] = ctm[3];
        return;
    }

    /* upright but rotate 90 or -90 */
    if( ctm[0] == zero_f  && ctm[3] == zero_f )
    {
#ifdef MATRDBG
        printf( " ... upright, rotate 90 or -90\n" );
#endif
        usingXorY[ X ] = Y;
        usingXorY[ Y ] = X;
   /* Falco add */
        if(( ctm[0] > MAX_QEM_CHARSIZE ) ||
           ( ctm[1] > MAX_QEM_CHARSIZE ) ||
           ( ctm[2] > MAX_QEM_CHARSIZE ) ||
           ( ctm[3] > MAX_QEM_CHARSIZE ) ||
           ( ctm[4] > MAX_QEM_CHARSIZE ) ||
           ( ctm[5] > MAX_QEM_CHARSIZE )){
                isvalid[ X ] = TRUE;
                isvalid[ Y ] = TRUE;
        }
        else{

        isvalid[ X ] = TRUE;
        isvalid[ Y ] = TRUE;
        }
        toplscale[ X ] = ctm[1];
        toplscale[ Y ] = ctm[2];
        return;
    }

    /* rotate 0 or 180 and oblique */
    if( ctm[1] == zero_f )
    {
#ifdef MATRDBG
        printf( " ... rotate 0 or 180, obliqued\n" );
#endif
        usingXorY[ X ] = XY;
        usingXorY[ Y ] = Y;
   /* Falco add */
        if(( ctm[0] > MAX_QEM_CHARSIZE ) ||
           ( ctm[1] > MAX_QEM_CHARSIZE ) ||
           ( ctm[2] > MAX_QEM_CHARSIZE ) ||
           ( ctm[3] > MAX_QEM_CHARSIZE ) ||
           ( ctm[4] > MAX_QEM_CHARSIZE ) ||
           ( ctm[5] > MAX_QEM_CHARSIZE )){
                isvalid[ X ] = TRUE;
                isvalid[ Y ] = TRUE;
        }
        else{

        isvalid[ X ] = FALSE;
        isvalid[ Y ] = TRUE;
        }
        toplscale[ X ] = zero_f;
        toplscale[ Y ] = ctm[3];
        return;
    }

    /* rotate 90 or -90 and oblique */
    if( ctm[0] == zero_f )
    {
#ifdef MATRDBG
        printf( " ... rotate 90 or -90, obliqued\n" );
#endif
        usingXorY[ X ] = Y;
        usingXorY[ Y ] = XY;
   /* Falco add */
        if(( ctm[0] > MAX_QEM_CHARSIZE ) ||
           ( ctm[1] > MAX_QEM_CHARSIZE ) ||
           ( ctm[2] > MAX_QEM_CHARSIZE ) ||
           ( ctm[3] > MAX_QEM_CHARSIZE ) ||
           ( ctm[4] > MAX_QEM_CHARSIZE ) ||
           ( ctm[5] > MAX_QEM_CHARSIZE )){
                isvalid[ X ] = TRUE;
                isvalid[ Y ] = TRUE;
        }
        else{

        isvalid[ X ] = FALSE;
        isvalid[ Y ] = TRUE;
        }
        toplscale[ X ] = zero_f;
        toplscale[ Y ] = ctm[2];
        return;
    }

    /* vertical stems are still vertical, but horizontals slanted */
    if( ctm[2] == zero_f )
    {
#ifdef MATRDBG
        printf( " ... vertical remains, horizontals slanted\n" );
#endif
        usingXorY[ X ] = X;
        usingXorY[ Y ] = XY;
   /* Falco add */
        if(( ctm[0] > MAX_QEM_CHARSIZE ) ||
           ( ctm[1] > MAX_QEM_CHARSIZE ) ||
           ( ctm[2] > MAX_QEM_CHARSIZE ) ||
           ( ctm[3] > MAX_QEM_CHARSIZE ) ||
           ( ctm[4] > MAX_QEM_CHARSIZE ) ||
           ( ctm[5] > MAX_QEM_CHARSIZE )){
                isvalid[ X ] = TRUE;
                isvalid[ Y ] = TRUE;
        }
        else{

        isvalid[ X ] = TRUE;
        isvalid[ Y ] = FALSE;
        }
        toplscale[ X ] = ctm[0];
        toplscale[ Y ] = zero_f;
        return;
    }

    /* horizontal stems are vertical, but verticals slanted */
    if( ctm[3] == zero_f )
    {
#ifdef MATRDBG
        printf( " ... horizontal being vertical, verticals slanted\n" );
#endif
        usingXorY[ X ] = Y;
        usingXorY[ Y ] = XY;
   /* Falco add */
        if(( ctm[0] > MAX_QEM_CHARSIZE ) ||
           ( ctm[1] > MAX_QEM_CHARSIZE ) ||
           ( ctm[2] > MAX_QEM_CHARSIZE ) ||
           ( ctm[3] > MAX_QEM_CHARSIZE ) ||
           ( ctm[4] > MAX_QEM_CHARSIZE ) ||
           ( ctm[5] > MAX_QEM_CHARSIZE )){
                isvalid[ X ] = TRUE;
                isvalid[ Y ] = TRUE;
        }
        else{

        isvalid[ X ] = FALSE;
        isvalid[ Y ] = TRUE;
        }
        toplscale[ X ] = zero_f;
        toplscale[ Y ] = ctm[2];
        return;
    }

    /* all are slanted */
#ifdef MATRDBG
    printf( " ... all slanted\n" );
#endif
    usingXorY[ X ] = usingXorY[ Y ] = XY;
    isvalid[ X ]   = isvalid[ Y ]   = FALSE;
    toplscale[ X ] = toplscale[ Y ] = zero_f;
    return;
}

/* according the BluesValue, OtherBlues to build BluesTable */
void
at1fs_BuildBlues()
{

        fix16   i;
        Hint    Blues1, Blues2;
        fix32   CSpos1, CSpos2;
        fix16   DSgrid1, DSgrid2;


        /* if y direction is not upright, then do nothing */
        if ( !isvalid[Y] ) return;

        /* add Blues to main hint table */
        for ( i=0 ; i < Blues_count ; i++){
                if ( Blues[i*2] <= Blues[i*2+1] ){
                        CSpos1 = Blues[i*2];
                        CSpos2 = Blues[i*2+1];
                }
                else{
                        CSpos2 = Blues[i*2];
                        CSpos1 = Blues[i*2+1];
                }
                grid_stem(CSpos1,CSpos2,(CSpos2 - CSpos1),&DSgrid1,&DSgrid2,Y);
                Blues1.CSpos    = CSpos1;
                Blues1.DSgrid   = DSgrid1;
                /* if the two neighbor Blues is same, the scaling is zero, esle
                   use CSpos and DSpos to calculate its scaling */
                if ( (CSpos2 - CSpos1) == 0 )
                        Blues1.scaling = (real32)0.0;
                else
                        Blues1.scaling  = (real32)(DSgrid2-DSgrid1) /
                                          (CSpos2 - CSpos1);
                Blues2.CSpos    = CSpos2;
                Blues2.DSgrid   = DSgrid2;
                Blues2.scaling  = (real32)0.0;

                /* Add the Blues to BluesTable */
                AddHintTable(Blues1, &BluesTable);
                AddHintTable(Blues2, &BluesTable);
        }
        BluesON = TRUE;

#ifdef  DBGmsg1
        {
                fix16   i;

                printf("\n$$$$$ The Blues Table $$$$$\n");
                printf(" BluesTable.Count=%d\n", BluesTable.Count);
                for ( i = 0 ; i < BluesTable.Count ; i++ ){
                        printf(" CSpos = %d  DSgrid = %d  scaling = %f\n",
                                 BluesTable.HintCB[i].CSpos,
                                 BluesTable.HintCB[i].DSgrid,
                                 BluesTable.HintCB[i].scaling);
                }
        }
#endif

}

/* According the direction, build its associated StemTable */
void
at1fs_BuildStem(CSpos, CSoff, dir)
fix32   CSpos, CSoff;
DIR     dir;                    /* in which coordinate */
{
        fix32   CSpos1, CSpos2;
        fix16   DSgrid1, DSgrid2;
        Hint    StemSide1, StemSide2;

        if ( !isvalid[(ubyte)dir] ) return;

        /* If first time to build StemTable, Initialize the StemTable */
        if ( !HintON ){
                InitStemTable();
                HintON = TRUE;
        }

        /* Sort the stem, the large is after the small */
        if ( CSoff >= 0 ){
                CSpos1 = CSpos;
                CSpos2 = CSpos + CSoff;
        }
        else{
                CSpos2 = CSpos;
                CSpos1 = CSpos + CSoff;
        }

        grid_stem(CSpos1, CSpos2, ABS(CSoff), &DSgrid1, &DSgrid2, dir);
        StemSide1.CSpos  = CSpos1;
        StemSide1.DSgrid = DSgrid1;
        StemSide1.scaling = 0;
        StemSide2.CSpos  = CSpos2;
        StemSide2.DSgrid = DSgrid2;
        StemSide2.scaling = 0;

        if (dir == X){
                AddHintTable(StemSide1, &X_StemTable);
                AddHintTable(StemSide2, &X_StemTable);
        }
        else{
                AddHintTable(StemSide1, &Y_StemTable);
                AddHintTable(StemSide2, &Y_StemTable);
        }
}

/* Build the StemTable about the stem3, stem and stem3 all put to StemTable */
void
at1fs_BuildStem3(CSpos1, CSoff1, CSpos2, CSoff2, CSpos3, CSoff3, dir)
fix32   CSpos1, CSoff1, CSpos2, CSoff2, CSpos3, CSoff3;
DIR     dir;                    /* in which coordinate */
{
        fix32   CSminpos, CSmidpos, CSmaxpos, CSminoff, CSmidoff, CSmaxoff;
        fix32   CSpos11, CSpos12, CSpos21, CSpos22, CSpos31, CSpos32;
        fix16   DSgrid11, DSgrid12, DSgrid21, DSgrid22, DSgrid31, DSgrid32;
        Hint    StemSide11, StemSide12, StemSide21,
                StemSide22, StemSide31, StemSide32;

        if ( !isvalid[(ubyte)dir] ) return;

        if ( !HintON ){
                InitStemTable();
                HintON = TRUE;
        }

        /* Sort the stem3 */
        if ( CSpos1 < CSpos2 ){
                if ( CSpos3 < CSpos1 ){
                        CSminpos = CSpos3;
                        CSminoff = CSoff3;
                        CSmidpos = CSpos1;
                        CSmidoff = CSoff1;
                        CSmaxpos = CSpos2;
                        CSmaxoff = CSoff2;
                }
                else{
                        CSminpos = CSpos1;
                        CSminoff = CSoff1;
                        if ( CSpos2 < CSpos3 ){
                                CSmidpos = CSpos2;
                                CSmidoff = CSoff2;
                                CSmaxpos = CSpos3;
                                CSmaxoff = CSoff3;
                        }
                        else{
                                CSmidpos = CSpos3;
                                CSmidoff = CSoff3;
                                CSmaxpos = CSpos2;
                                CSmaxoff = CSoff2;
                        }
                }
        }
        else{
                if ( CSpos3 < CSpos2 ){
                        CSminpos = CSpos3;
                        CSminoff = CSoff3;
                        CSmidpos = CSpos2;
                        CSmidoff = CSoff2;
                        CSmaxpos = CSpos1;
                        CSmaxoff = CSoff1;
                }
                else{
                        CSminpos = CSpos2;
                        CSminoff = CSoff2;
                        if ( CSpos1 < CSpos3 ){
                                CSmidpos = CSpos1;
                                CSmidoff = CSoff1;
                                CSmaxpos = CSpos3;
                                CSmaxoff = CSoff3;
                        }
                        else{
                                CSmidpos = CSpos3;
                                CSmidoff = CSoff3;
                                CSmaxpos = CSpos1;
                                CSmaxoff = CSoff1;
                        }
                }
        }

        if ( CSminoff >= 0 ){
                CSpos11 = CSminpos;
                CSpos12 = CSminpos + CSminoff;
        }
        else{
                CSpos12 = CSminpos;
                CSpos11 = CSminpos + CSminoff;
        }
        if ( CSmidoff >= 0 ){
                CSpos21 = CSmidpos;
                CSpos22 = CSmidpos + CSmidoff;
        }
        else{
                CSpos22 = CSmidpos;
                CSpos21 = CSmidpos + CSmidoff;
        }
        if ( CSmaxoff >= 0 ){
                CSpos31 = CSmaxpos;
                CSpos32 = CSmaxpos + CSmaxoff;
        }
        else{
                CSpos32 = CSmaxpos;
                CSpos31 = CSmaxpos + CSmaxoff;
        }
        /* revise this error, forget to add this, 10/02/90 */
        CSoff1 = CSminoff;
        CSoff2 = CSmidoff;
        CSoff3 = CSmaxoff;
        /* @@@ */


        grid_stem3(CSpos11, CSpos12, ABS(CSoff1),
                   CSpos21, CSpos22, ABS(CSoff2),
                   CSpos31, CSpos32, ABS(CSoff3),
                   &DSgrid11, &DSgrid12, &DSgrid21, &DSgrid22,
                   &DSgrid31, &DSgrid32, dir);

        StemSide11.CSpos  = CSpos11;
        StemSide11.DSgrid = DSgrid11;
        StemSide11.scaling = 0;
        StemSide12.CSpos  = CSpos12;
        StemSide12.DSgrid = DSgrid12;
        StemSide12.scaling = 0;
        StemSide21.CSpos  = CSpos21;
        StemSide21.DSgrid = DSgrid21;
        StemSide21.scaling = 0;
        StemSide22.CSpos  = CSpos22;
        StemSide22.DSgrid = DSgrid22;
        StemSide22.scaling = 0;
        StemSide31.CSpos  = CSpos31;
        StemSide31.DSgrid = DSgrid31;
        StemSide31.scaling = 0;
        StemSide32.CSpos  = CSpos32;
        StemSide32.DSgrid = DSgrid32;
        StemSide32.scaling = 0;

        if (dir == X){
                AddHintTable(StemSide11, &X_StemTable);
                AddHintTable(StemSide12, &X_StemTable);
                AddHintTable(StemSide21, &X_StemTable);
                AddHintTable(StemSide22, &X_StemTable);
                AddHintTable(StemSide31, &X_StemTable);
                AddHintTable(StemSide32, &X_StemTable);
        }
        else{
                AddHintTable(StemSide11, &Y_StemTable);
                AddHintTable(StemSide12, &Y_StemTable);
                AddHintTable(StemSide21, &Y_StemTable);
                AddHintTable(StemSide22, &Y_StemTable);
                AddHintTable(StemSide31, &Y_StemTable);
                AddHintTable(StemSide32, &Y_StemTable);
        }
}

/* Calculate its Device space address from Char space address */
void
at1fs_transform(CSnode, DSnode)
CScoord CSnode;
DScoord FAR *DSnode;    /*@WIN*/
{
#ifdef  DBGnohint
        DSnode->x = CSnode.x * ctm[0] + CSnode.y * ctm[2] + ctm[4];
        DSnode->y = CSnode.x * ctm[1] + CSnode.y * ctm[3] + ctm[5];
        return;
#endif


        /* if BuildStemTable is over, calculate its scaling of Stem */
        if ( HintON ){
                ScaleStemTable(&X_StemTable);
                ScaleStemTable(&Y_StemTable);
                HintON = FALSE;

#ifdef  DBGmsg1
        {
                fix16   i;

                printf("\n$$$$$ The X direction Hint Table $$$$$\n");
                printf(" X_StemTable.Count=%d\n", X_StemTable.Count);
                for ( i = 0 ; i < X_StemTable.Count ; i++ ){
                        printf(" CSpos = %d  DSgrid = %d  scaling = %f\n",
                                 X_StemTable.HintCB[i].CSpos,
                                 X_StemTable.HintCB[i].DSgrid,
                                 X_StemTable.HintCB[i].scaling);
                }

                printf("\n$$$$$ The Y direction Hint Table $$$$$\n");
                printf(" Y_StemTable.Count=%d\n", Y_StemTable.Count);
                for ( i = 0 ; i < Y_StemTable.Count ; i++ ){
                        printf(" CSpos = %d  DSgrid = %d  scaling = %f\n",
                                 Y_StemTable.HintCB[i].CSpos,
                                 Y_StemTable.HintCB[i].DSgrid,
                                 Y_StemTable.HintCB[i].scaling);
                }
        }
#endif

        }

        /* if the direction is upright, apply hint */
        if ( usingXorY[X] == X )
                ApplyHint( CSnode.x, &(DSnode->x), X_StemTable, X );
        else if (usingXorY[X] == Y)
                ApplyHint( CSnode.y, &(DSnode->x), Y_StemTable, Y );
        else
                DSnode->x = CSnode.x * ctm[0] + CSnode.y * ctm[2];

        if ( usingXorY[Y] == X )
                ApplyHint( CSnode.x, &(DSnode->y), X_StemTable, X );
        else if (usingXorY[Y] == Y)
                ApplyHint( CSnode.y, &(DSnode->y), Y_StemTable, Y );
        else
                DSnode->y = CSnode.x * ctm[1] + CSnode.y * ctm[3];

#ifdef  DBGmsg0
        printf(" @@@@@ The difference With Hinting and No Hinting @@@@@\n");
        printf(" @@@ Without Hinting @@@\n");
        printf(" The node in X = %f  , in Y = %f\n",
               CSnode.x * ctm[0] + CSnode.y * ctm[2],
               CSnode.x * ctm[1] + CSnode.y * ctm[3]);
        printf(" @@@ With Hinting @@@\n");
        printf(" The node in X = %f  , in Y = %f\n\n", DSnode->x, DSnode->y);
#endif

        DSnode->x += ctm[4];
        DSnode->y += ctm[5];
}

/*************************************************************************
 *      Function : ApplyBlues()
 *      This function to ApplyBlues to constrain the Stem pair, if one side
 *      of stem is within the Blues pair, use this Blues pair to apply to
 *      this stem side, then use offset to the get the other side.
 *      else do nothing.
 *      i: CSpos1, CSpos2 : the hint 2 side address in char space.
 *         CSoff : the pair's width.
 *         dir   : in which coordinate, x or y.
 *      o: DSgrid1, DSgrid2 : the hint 2 side address in DS after grid fitting.
 *      return : TRUE , ApplyBlues succeed.
 *               FALSE, ApplyBlues fail.
 *********************************************************/
static  bool8
ApplyBlues(CSpos1, CSpos2, CSoff, DSgrid1, DSgrid2)
fix32   CSpos1, CSpos2, CSoff;
fix16   FAR *DSgrid1, FAR *DSgrid2;     /* the address in DS have been grid fitted @WIN*/
{
        fix16   DSoff;          /* the with of stem in DS after grid fitting */
        fix16   i;


        DSoff = ROUND( toplscale[Y] * CSoff );
        for (i=0 ; i<BluesTable.Count ; i+=2){
            if ((BluesTable.HintCB[i].CSpos <= CSpos1) &&
                (BluesTable.HintCB[i+1].CSpos >= CSpos1)){
                    if (BluesTable.HintCB[i].CSpos == CSpos1){
                        *DSgrid1 = BluesTable.HintCB[i].DSgrid;
                    }
                    else if (BluesTable.HintCB[i+1].CSpos == CSpos1){
                        *DSgrid1 = BluesTable.HintCB[i+1].DSgrid;
                    }
                    else{
                        *DSgrid1 = ROUND((real32)BluesTable.HintCB[i].DSgrid +
                                   (real32)(CSpos1-BluesTable.HintCB[i].CSpos) *
                                   (BluesTable.HintCB[i].scaling));
                    }
                    *DSgrid2 = *DSgrid1 + DSoff;
                    return(TRUE);
            }
            if ((BluesTable.HintCB[i].CSpos <= CSpos2) &&
                (BluesTable.HintCB[i+1].CSpos >= CSpos2)){
                    if (BluesTable.HintCB[i].CSpos == CSpos2){
                        *DSgrid2 = BluesTable.HintCB[i].DSgrid;
                    }
                    else if (BluesTable.HintCB[i+1].CSpos == CSpos2){
                        *DSgrid2 = BluesTable.HintCB[i+1].DSgrid;
                    }
                    else{
                        *DSgrid2 = ROUND((real32)BluesTable.HintCB[i].DSgrid +
                                   (real32)(CSpos2-BluesTable.HintCB[i].CSpos) *
                                   (BluesTable.HintCB[i].scaling));
                    }
                    *DSgrid1 = *DSgrid2 - DSoff;
                    return(TRUE);
            }

        }
        return(FALSE);
}

/*************************************************************************
 *      Function : grid_stem()
 *      This is to grid-fit the hint pair of hstem, vstem and Blues value.
 *      i: CSpos1, CSpos2 : the hint 2 side address in char space.
 *         CSoff : the pair's width.
 *         dir   : in which coordinate, x or y.
 *      o: DSgrid1, DSgrid2 : the hint 2 side address in DS after grid fitting.
 *********************************************************/
static  void
grid_stem(CSpos1, CSpos2, CSoff, DSgrid1, DSgrid2, dir)
fix32   CSpos1, CSpos2, CSoff;
fix16   FAR *DSgrid1, FAR *DSgrid2;     /* the address in DS have been grid fitted @WIN*/
DIR     dir;
{
        real32  DSpos1, DSpos2; /* the address in DS after transformation */
        fix16   DSoff;          /* the with of stem in DS after grid fitting */
        lfix_t  fraction1, fraction2;   /* the fraction of DSpos1 & DSpos2 */
        bool8   flag;

        /* Should consider this condition is this function or else */
        /* get the offset of the hint pair */   /* ?????? */

        DSoff = ROUND( toplscale[(ubyte)dir] * CSoff );
        /* check the stem pair is within the Blues */
        if ( BluesON && BluesTable.Count && (dir == Y)){
            flag = ApplyBlues(CSpos1, CSpos2, CSoff, DSgrid1, DSgrid2);
            if (flag == TRUE) return;
        }

        /* if the stem pair not within the Blues, use the below calculation */
        /* get the first point's long fix's fraction part */
             DSpos1 = toplscale[(ubyte)dir] * CSpos1;
             fraction1 = F_OF_LFX(F2LFX(DSpos1));
             if (fraction1 > HALF_LFX)  fraction1 = ONE_LFX - fraction1 + 1;

        /* get the second point's long fix's fraction part */
             DSpos2 = toplscale[(ubyte)dir] * CSpos2;
             fraction2 = F_OF_LFX(F2LFX(DSpos2));
             if (fraction2 > HALF_LFX)  fraction2 = ONE_LFX - fraction2 + 1;

        /* see which is near the grid, grid fitting this point, and then use
                this point to grid fitting the other point */
             if (fraction1 > fraction2){
                     *DSgrid2 = ROUND(DSpos2);
                     *DSgrid1 = *DSgrid2 - DSoff;
             } else{
                     *DSgrid1 = ROUND(DSpos1);
                     *DSgrid2 = *DSgrid1 + DSoff;
             }
}

/********************************************************
 *      Function : grid_stem3()
 *      This is to grid fitting the hint pair of hstem3()/vstem3().
 *      i : CSpos11, CSpos12 : the first hint pair 2 side in CS.
 *          CSoff1 : the width of first hint in CS.
 *          CSpos21, CSpos22 : the second hint pair 2 side in CS.
 *          CSoff2 : the width of first hint in CS.
 *          CSpos31, CSpos32 : the third hint pair 2 side in CS.
 *          CSoff3 : the width of first hint in CS.
 *          dir    : in which coordinate, x or y.
 *      o : DSgrid11, DSgrid12 : the grid fitted addrss of first hint in DS.
 *          DSgrid21, DSgrid22 : the grid fitted addrss of second hint in DS.
 *          DSgrid31, DSgrid32 : the grid fitted addrss of third hint in DS.
 *********************************************************/
static  void
grid_stem3(CSpos11,CSpos12,CSoff1,CSpos21,CSpos22,CSoff2,CSpos31,CSpos32,CSoff3,
           DSgrid11, DSgrid12, DSgrid21, DSgrid22, DSgrid31, DSgrid32, dir)
fix32   CSpos11, CSpos12, CSoff1;
fix32   CSpos21, CSpos22, CSoff2;
fix32   CSpos31, CSpos32, CSoff3;
fix16   FAR *DSgrid11, FAR *DSgrid12, FAR *DSgrid21, FAR *DSgrid22,
        FAR *DSgrid31, FAR *DSgrid32;           /*@WIN*/
DIR     dir;
{
        fix16   DSspace;
        fix16   DSdiff;         /* the difference between the grid the space
                                   and the distance of hint pair in DS */

        /* for every hint pair, get it's grid fitting result */

        grid_stem(CSpos11, CSpos12, CSoff1, DSgrid11, DSgrid12, dir);
        grid_stem(CSpos21, CSpos22, CSoff2, DSgrid21, DSgrid22, dir);
        grid_stem(CSpos31, CSpos32, CSoff3, DSgrid31, DSgrid32, dir);


        /* get the real offset between the hint pair */
        DSspace = ROUND( toplscale[(ubyte)dir] * (CSpos21 - CSpos12) );

        if ( (*DSgrid21 - *DSgrid12) != DSspace ){
                DSdiff = DSspace - (*DSgrid21 - *DSgrid12);
                *DSgrid11 -= DSdiff;
                *DSgrid12 -= DSdiff;
        }
        if ( (*DSgrid31 - *DSgrid22) != DSspace ){
                DSdiff = DSspace - (*DSgrid31 - *DSgrid22);
                *DSgrid31 += DSdiff;
                *DSgrid32 += DSdiff;
        }
}

/****************************************************************
 *      Function : InitStemTable()
 *              This fumction to initialize the StemTable, to clear
 *         the old Table's data and then first put the Blues Table.
 ****************************************************************/
static  void
InitStemTable()
{
        fix16   i;

        X_StemTable.Count = Y_StemTable.Count = 0;      /* reset the table */

        for (i=0 ; i < BluesTable.Count ; i++){
                Y_StemTable.HintCB[i] = BluesTable.HintCB[i];
                Y_StemTable.Count++;
        }
}

/***********************************************************************
 *      Function : AddHintTable()
 *      It used to add the calculated stem or Blues value to its associated
 *      table.
 *      i : Stemside : one of stem side address.
 *      io: Table : the table to add the stem side.
 *          Count : to count the specified table content.
 ************************************************************************/
static  void
AddHintTable(StemSide, Table)
Hint    StemSide;
HintTable       FAR *Table;     /*@WIN*/
{
        fix16   i, j;

        for (i = 0 ; i < Table->Count ; i++){
                if ( Table->HintCB[i].CSpos > StemSide.CSpos )
                        break;
        }

        for (j = Table->Count ; j > i ; j--){
                Table->HintCB[j] = Table->HintCB[j-1];
        }
        Table->HintCB[i] = StemSide;

        Table->Count++;
}

/****************************************************************
 *      Function : ScaleStemTable()
 *              This fumction to calculate the scaling between two
 *         Stem side previously, for apply hint to use.
 ****************************************************************/
static  void
ScaleStemTable(Table)
HintTable       FAR *Table;     /*@WIN*/
{
        fix16   i;
        fix32   CSdiff;
        fix16   DSdiff;

        for (i=0 ; i < (Table->Count - 1)  ; i++){
                CSdiff = Table->HintCB[i+1].CSpos - Table->HintCB[i].CSpos;
                DSdiff = Table->HintCB[i+1].DSgrid - Table->HintCB[i].DSgrid;
                if (CSdiff != 0)
                        Table->HintCB[i].scaling = (real32)DSdiff/CSdiff;
                else
                        Table->HintCB[i].scaling = (real32)0.0;
        }
        Table->HintCB[Table->Count-1].scaling = (real32)0.0;
}

/********************************************************
 *      Function : ApplyHint()
 *          This function use StemTable to calculate
 *      the control point address in DS, only consider one coordinate.
 *      i : CSpos : the control point in CS.
 *          Table : the associated Table to use.
 *          dir   : in which coordinat.
 *      o : DSpos : the control point in DS.
 *********************************************************/
static  void
ApplyHint(CSpos, DSpos, Table, dir)
fix32   CSpos;
real32  FAR *DSpos;     /*@WIN*/
HintTable     Table;
DIR     dir;
{
        fix16   i;

        /* If no hint, do nothing */
        if ( Table.Count == 0 ){
                *DSpos = (real32)CSpos * toplscale[(ubyte)dir];
                return;
        }

        /* If the control point is smaller than StemTable value */
        if ( Table.HintCB[0].CSpos > CSpos ){
                *DSpos = (real32)Table.HintCB[0].DSgrid -
                         (real32)(Table.HintCB[0].CSpos - CSpos)
                         * toplscale[(ubyte)dir];
                return;
        }

        /* If the control point is larger than StemTable value */
        if ( Table.HintCB[Table.Count - 1].CSpos < CSpos ){
               *DSpos = (real32)Table.HintCB[Table.Count - 1].DSgrid +
                        (real32)(CSpos - Table.HintCB[Table.Count - 1].CSpos)
                        * toplscale[(ubyte)dir];
               return;
        }

        for (i=0 ; i<Table.Count ; i++){
                if ( Table.HintCB[i].CSpos >= CSpos )
                        break;
        }


        if ( Table.HintCB[i].CSpos == CSpos ){
                *DSpos = (real32)Table.HintCB[i].DSgrid;
                return;
        }
        else{
                *DSpos = (real32)Table.HintCB[i - 1].DSgrid +
                         (real32)(CSpos - Table.HintCB[i - 1].CSpos)
                         * Table.HintCB[i - 1].scaling;
                return;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\font.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/**************************************************************/
/*                                                            */
/*      font.h                   10/9/87      Danny           */
/*                                                            */
/**************************************************************/

#ifdef UNIX
//extern char Data_Offset[];      /* address set in linker .cmd file */
extern char FAR *Data_Offset;      /* address set in linker .cmd file @WIN*/
#endif

/* Table of character
 * This table contains the character bitmap in cache and the related datas.
 */

struct Char_Tbl {
    real32  adv_x, adv_y;   /* advance vector */
    gmaddr  bitmap;         /* character bitmap */
    sfix_t  ref_x, ref_y;   /* reference point */
    fix16   box_w, box_h;   /* black box width and height */
#ifdef KANJI
    real32  adv1_x, adv1_y; /* advance vector for direction 1 */
    fix16   v01_x, v01_y;   /* difference vector between Org.0 and Org.1 */
#endif
};

struct box {
    real32  llx, lly, lrx, lry, ulx, uly, urx, ury;
};

#include "fontfunc.ext"


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\fontdefs.h ===
typedef struct
             {   fix32      font_type;
                 byte       FAR *data_addr; /*@WIN*/
                 byte       FAR *name;      /*@WIN*/
                 char       FAR *FileName;  /*@PROFILE; @WIN*/
                 real32     FAR *matrix;    /*@WIN*/
                 ufix32     uniqueid;
                 real32     italic_ang;
                 fix16      orig_font_idx;
             }   font_data;

typedef struct
             {   fix        num_entries;
                 font_data  FAR *fonts; /*@WIN*/
             }   font_tbl;

extern     font_tbl      built_in_font_tbl;
//DJC #define NO_BUILTINFONT 35

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\fontdict.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/**************************************************************
 *
 *      fontdict.h               10/9/87      Danny
 *
 *
 *  Revision History:
 **************************************************************/

struct table_hdr {
    ufix32  dict_addr;
    ufix32  dire_addr;
    ufix32  keys_addr;
    ufix32  nmcache_addr;
};

struct str_dict {
    ufix16  k;
    ufix16  length;
    gmaddr  v;          /* ??? reverse order */
};

struct pld_obj {
    ufix16        length;
    ufix16        v;
};

struct  cd_header       {
        gmaddr  base;           /* ??? reverse order */
        ufix16  FAR *key;           /* key's address        @WIN*/
        ufix16  max_bytes;      /* max  string's byte no. */
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\fntcache.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */


// DJC added global include
#include "psglobal.h"

#define    NOT_ON_THE_MAC       /* @WIN */
#define    KANJI                /* @WIN */
// DJC use command line #define    UNIX                 /* @WIN */
/*
 * -------------------------------------------------------------------
 *  File:   FNTCACHE.C              10/09/87    created by Danny
 *
 *      Font Cache Mechanism
 *
 *  References:
 *      FNTCACHE.DEF, FNTCACHE.EXT
 *
 *  Revision History:
 *  08/23/88  You   new cache policy and new program structures.
 *  09/06/88  Danny fix bug of free_cache_resources().
 *  09/08/88  You   revise approach of matrix[] comparison.
 *                      uniform warning message.
 *  09/09/88  You   rename free_cache_resources() to delete_cache_...().
 *  09/13/88  You   fix bug of get_pm(), incorrect formula for *size.
 *  10/11/88  You   discard un-used variables.
 *  10/19/88  You   invoke general purpose extract_dict() in init_name_cache,
 *                      to scan over CharStrings instead of direct use of
 *                      "struct str_dict" (in order to be independent of
 *                      internal representations of CharStrings, with some
 *                      loss of performance).
 *  10/26/88  You   add checks in init_fontcache() if empty precached bitmap
 *                      for SAVE_VM; add check in pack_cached_data(), also.
 *  11/16/88  Ada   zero_f updating.
 *  11/21/88  You   init N2CCmap[] at font preprocessing.
 *                  - init_name_cache() invokes get_name_cc_map() rather
 *                      than doing the task, leaving the argument of
 *                      fontdirectory for future extension.
 *                  - add get_name_cc_map() in "fontinit.c".
 *                  - include fntcache.ext; define FNTCACHE_INC before include.
 *  11/24/88  You   force bitmap cache address on word alignment, where "word"
 *                      depends on machine: use WORD_ALIGN() macro.
 *  11/24/88  You   use move_char_cache() instead of copy_char_cache()
 *                      in compact_bmapcache().
 *  03/17/89  You   fix bug of mis-initialization of cacheparams_lb
 *                      in init_fontcache().
 *  06/16/89  Danny Change NID flag to NOT_NID flag
 *  07/13/89  Danny use VF for Virtual font & VFT for the change of
 *                  modules interface about composite object
 *  02/28/90  You   created reinit_fontcache() to be called after init_1pp()
 *                      for 1pp in C. It does the following if ALL_VM defined:
 *                      1) making FID strong rom for all fonts in FontDir.,
 *                      2) rebuild ROMfont_info[],
 *                      3) making FID string rom for all precached data.
 *  05/02/90  Kason - add build_name_cc_table() for using when building
 *                    name_cache_map_table in op_setfont. Also, flag
 *                    NEW_NM_CC is added.
 *  10/04/90  Danny Add a flag of bitmap pool compacted or not, bmap_compacted,
 *                  to fix the bug of cache problem from save/restore.
 *                  (ref: SRB)
#ifdef SCSI
 *  06/29/90  Ada     add code for SCSI font cache
#endif
 *      8/29/90; ccteng; change <stdio.h> to "stdio.h"
 *  11/28/90  Danny   Precache Mech. Added, ref:PCH
 *  03/27/91  Kason   Always turn on NEW_NM_CC flag, del the "#ifndef" code
 *                    Always turn off NOT_NID  flag, del the "#ifdef" code
 *                    Change "#ifndef ADA" to  "#ifdef" SFNT"
 *                    del ZZZ flag
 *                    Change "DEBUG"    to "DBG"
 *                           "OVFLWDBG" to "DBGovflw"
 *                           "FIDDBG"   to "DBGfid"
 *                           "CACHEDBG" to "DBGcache"
 *                           "WARN"     to "DBG"
 * -------------------------------------------------------------------
 */


#define     FNTCACHE_INC
#include <stdio.h>
#include <string.h>

#include    "define.h"        /* Peter */
#include    "global.ext"
#include    "graphics.h"
#include    "graphics.ext"

#include    "font.h"
#include    "warning.h"
#include    "font_sys.h"
#include    "fontkey.h"

#include    "fntcache.ext"
#include    "fntcache.def"

#ifdef SFNT
#include    "fontqem.ext"
#endif

/*  PCH: Begin, Danny, 11/28/90 */
#include    "fcachesr.h"
/*  PCH: End, Danny, 11/28/90 */


/* IMPORTED from low-layer graphics primitives */

#ifdef  LINT_ARGS
// DJC this is declared in graphics.ext
//    void        move_char_cache (struct Char_Tbl far *, struct Char_Tbl far *);
#else
    void        move_char_cache ();
#endif /* LINT_ARGS */


#ifdef SCSI
#   ifdef LINT_ARGS
extern  void    file_fontcache(fix16);
extern  bool    is_char_filed(fix16, ufix16, struct Char_Tbl FAR * FAR *, bool); /*@WIN*/
extern  void    init_fontcache2(void);
#   else /* LINT_ARGS */
extern  void    file_fontcache();
extern  bool    is_char_filed();
extern  void    init_fontcache2();
#    endif /* LINT_ARGS */
#endif    /* SCSI */

#define FARALLOC(n,type)    /* to allocate far data ... */\
            (type far *) fardata((ufix32)n * sizeof(type))

/*
 * -------------------------------------------------------------------
 *                      Debug Facilities
 * -------------------------------------------------------------------
 *  DBG:        general behavior about cache mechanism.
 *  DBGfid:     behavior about FID generation.
 *  DBGovflw:   behavior about table overflows.
 *  DBGcache:   external debugging facilities (activated by op_cachestatus).
 * -------------------------------------------------------------------
 */


/*
 * -------------------------------------------------------------------
 *  [CODE]  FID Manager: Cache Policy Dependent
 * -------------------------------------------------------------------
 */

/* ........................ init_gen_fid ............................. */

PRIVATE FUNCTION void near  init_gen_fid (fontdirectory)
    struct object_def      FAR *fontdirectory;  /* i: fontdir of all ROM fonts @WIN*/

/* Descriptions:
 *  -- record critical items of all ROM fonts to make them recogizable.
 */
 DECLARE
    REG ufix        ii;
        struct dict_head_def    FAR *fontdir_dicthd;    /*@WIN*/
        struct dict_content_def FAR *fontdir_content;   /*@WIN*/
        struct object_def        nameobj;
        struct object_def       FAR *fdictobj_p, FAR *obj_got;  /*@WIN*/
        ufix32      uniqueid;
        ufix8       fonttype;
        bool        dict_ok;    /* get_dict() ok? */

#ifdef SFNT
    struct cache_id_items   FAR *idp;   /*@WIN*/
#endif

#ifdef DBGresetfid
#   ifdef LINT_ARGS
    PRIVATE void near   reset_fid(void);
#   else
    PRIVATE void near   reset_fid();
#   endif
#endif

 BEGIN

#ifdef DBGresetfid         /* See reset_fid() about DBGresetfid */
    reset_fid();
#endif

    /* initialization */
    fontdir_dicthd = (struct dict_head_def FAR *) VALUE(fontdirectory); /*@WIN*/
    fontdir_content = (struct dict_content_def FAR *) (fontdir_dicthd + 1); /*@WIN*/

    /* allocate ROMfont info table */
    n_ROMfont = fontdir_dicthd->actlength;
    ROMfont_info = FARALLOC (n_ROMfont, struct ROMfont_info_s);

    /* allocate fid stack */
    weakfid_stack   = FARALLOC ((MAXSAVESZ+1), ufix32);
    rom_varid_stack = FARALLOC ((MAXSAVESZ+1), ufix16);

    /* gather relevant info. for all ROM fonts */
    ATTRIBUTE_SET (&nameobj, LITERAL);
    LEVEL_SET (&nameobj, current_save_level);

    for ( ii=0;  ii<n_ROMfont;  ii++ )
        {
        /* get a ROM font dictionary */
        dict_ok = get_dict (fontdirectory, &(fontdir_content[ii].k_obj),
                        &fdictobj_p);
#     ifdef DBG
        if (!dict_ok)
            {
            warning (FNTCACHE, 0x01, "ROM dict.");
            ERROR (UNDEFINEDRESULT);
            return;
            }
#     endif

        /* get FontType */
        get_name (&nameobj, FontType, 8, TRUE);
        dict_ok = get_dict (fdictobj_p, &nameobj, &obj_got);
        fonttype = (ufix8) VALUE(obj_got);
#     ifdef DBG
        if (!dict_ok)
            {
            warning (FNTCACHE, 0x01, FontType);
            ERROR (UNDEFINEDRESULT);
            return;
            }
#     endif

        /* get UniqueID */
        get_name (&nameobj, UniqueID, 8, TRUE);
        dict_ok = get_dict (fdictobj_p, &nameobj, &obj_got);
        uniqueid = (ufix32)VALUE(obj_got);
#     ifdef DBG
        if (!dict_ok)
            {
            warning (FNTCACHE, 0x01, UniqueID);
            ERROR (UNDEFINEDRESULT);
            return;
            }
#     endif

        /* make "su_fid" and record it */
        PUT_ROMFI_SU_FID (ii, fonttype, uniqueid);
#     ifdef DBG
        if (fonttype > MAX_FONTTYPE)
            {
            warning (FNTCACHE, 0x01, "FontType too big");
            ERROR (UNDEFINEDRESULT);
            return;
            }
        if (uniqueid > MAX_UNIQUEID)
            {
            warning (FNTCACHE, 0x01, "UniqueID too big");
            ERROR (UNDEFINEDRESULT);
            return;
            }
#     endif

#ifdef SFNT
        /* get cache_id_items list for the specified FontType */
        for (idp = cache_id_items; idp->ftype <= MAX_FONTTYPE; idp++)
            if (idp->ftype == fonttype)
                break;
        /* get private item for the font */
        if (idp->itemname != NULL)  {
            get_name(&nameobj, idp->itemname, lstrlen(idp->itemname), TRUE); /*@WIN*/
            dict_ok = get_dict (fdictobj_p, &nameobj, &obj_got);
#     ifdef DBG
        if (!dict_ok)
            {
            warning (FNTCACHE, 0x01, Private);
            ERROR (UNDEFINEDRESULT);
            return;
            }
#     endif
            PUT_ROMFI_PRIV (ii, (ufix32) VALUE(obj_got) );
        } else {
            PUT_ROMFI_PRIV (ii, (ufix32) 0 );
        }
#else

        /* get and record Private */
        get_name (&nameobj, Private, 7, TRUE);
        dict_ok = get_dict (fdictobj_p, &nameobj, &obj_got);
        PUT_ROMFI_PRIV (ii, (struct dict_head_def FAR *) VALUE(obj_got) ); /*@WIN*/
#     ifdef DBG
        if (!dict_ok)
            {
            warning (FNTCACHE, 0x01, Private);
            ERROR (UNDEFINEDRESULT);
            return;
            }
#     endif
#endif

        /* get and record the object of the ROM font dict. */
        PUT_ROMFI_FDICT (ii, fdictobj_p);

#     ifdef DBG
        /* check FID validity */
        get_name (&nameobj, FID, 3, TRUE);
        dict_ok = get_dict (fdictobj_p, &nameobj, &obj_got);
        if (!dict_ok)
            {
            warning (FNTCACHE, 0x01, FID);
            ERROR (UNDEFINEDRESULT);
            return;
            }
        if ( ! IS_ROMFONT_FID(VALUE(obj_got)) )
            {
            warning (FNTCACHE, 0x01, "invalid FID");
            ERROR (UNDEFINEDRESULT);
            return;
            }
#     endif
        } /* for all ROM fonts */
  END

/* ........................ reset_fid ................................ */

#ifdef DBGresetfid
    /*
     *  DBGresetfid: is ONLY used when the cooked font data (generated by
     *      Font Preprocessor) are inproperly with INCOMPATIBLE FID
     *      REPRESENTATIONS, and those cooked font data are NOT REALLY ROMED.
     *  invoked by: init_gen_fid().
     */

PRIVATE FUNCTION void near  reset_fid ()

  DECLARE
        fix         ii, n_romfont;
        ufix8       ftype;
        ufix32      uid, newfid;
        struct dict_head_def    FAR *fontdir_dicthd;    /*@WIN*/
        struct dict_content_def FAR *fontdir_cont;      /*@WIN*/
        struct object_def        nameobj, newobj;
        struct object_def       FAR *fontdir;           /*@WIN*/
        struct object_def       FAR *fdobj_p, FAR *obj_got;     /*@WIN*/
  BEGIN

    /* initialization */
    get_dict_value (systemdict, FontDirectory, &fontdir);
    fontdir_dicthd = (struct dict_head_def FAR *) VALUE(fontdir);   /*@WIN*/
    fontdir_cont = (struct dict_content_def FAR *) (fontdir_dicthd + 1); /*@WIN*/
    n_romfont = fontdir_dicthd->actlength;

    /* gather relevant info. for all ROM fonts */
    ATTRIBUTE_SET (&nameobj, LITERAL);
    LEVEL_SET (&nameobj, current_save_level);

    for ( ii=0;  ii<n_romfont;  ii++ )
        {
        /* get a ROM font dictionary */
        if (!get_dict (fontdir, &(fontdir_cont[ii].k_obj), &fdobj_p))
            {
            printf ("\afatal error, cannot get a ROM font dict.!!\n");
            return;
            }

        /* get FontType */
        get_name (&nameobj, FontType, 8, TRUE);
        if (!get_dict (fdobj_p, &nameobj, &obj_got))
            {
            printf ("\afatal error, cannot get FontType from a ROM font!!\n");
            return;
            }
        ftype = (ufix8) VALUE(obj_got);
        if (ftype > MAX_FONTTYPE)
            {
            printf ("\afatal error, FontType too big in a ROM font!!\n");
            return;
            }

        /* get UniqueID */
        get_name (&nameobj, UniqueID, 8, TRUE);
        if (!get_dict (fdobj_p, &nameobj, &obj_got))
            {
            printf ("\afatal error, cannot get UniqueID from a ROM font!!\n");
            return;
            }
        uid = VALUE(obj_got);
        if (uid > MAX_UNIQUEID)
            {
            printf ("\afatal error, UniqueID too big in a ROM font!!\n");
            return;
            }

        /* make a "su_fid" and record it */
        newfid = FORM_SR_FID (ftype, uid);

        /* put new FID in its dictionary */
        get_name (&nameobj, FID, 3, TRUE);
        if (!get_dict (fdobj_p, &nameobj, &obj_got))
            {
            printf ("\afatal error, cannot get FID in a ROM font!!\n");
            return;
            }
        COPY_STRUCT (&newobj, obj_got, struct object_def);
        VALUE(&newobj) = newfid;
        if ( ! put_dict (fdobj_p, &nameobj, &newobj) )
            {
            printf ("\afatal error, cannot put FID back to ROM font!!\n");
            return;
            }
        } /* for all ROM fonts */

    return;
  END

#endif

/* ........................ reinit_fid ............................... */


GLOBAL FUNCTION bool        reinit_fid ()

/* Descriptions:
 *  -- reset FID in all PSGs' font dictionaries (generated in SAVE_VM)
 *              to Strong ROM Font FID class.
 * Notes:
 *  -- The action must be done right before VM is going to be saved.
 *  -- FID of precached matrices will be updated to Strong ROM Font FID
 *              during pack_cached_data().
 */
  DECLARE
        fix         ii, n_romfont;
        ufix32      oldfid, newfid;
        struct dict_head_def    FAR *fontdir_dicthd;    /*@WIN*/
        struct dict_content_def FAR *fontdir_cont;      /*@WIN*/
        struct object_def        nameobj, newobj;
        struct object_def       FAR *fontdir;           /*@WIN*/
        struct object_def       FAR *fdobj_p, FAR *obj_got;     /*@WIN*/
  BEGIN

    /* initialization */
    get_dict_value (systemdict, FontDirectory, &fontdir);
    fontdir_dicthd = (struct dict_head_def FAR *) VALUE(fontdir);  /*@WIN*/
    fontdir_cont = (struct dict_content_def FAR *) (fontdir_dicthd + 1); /*@WIN*/
    n_romfont = fontdir_dicthd->actlength;

    /* gather relevant info. for all ROM fonts */
    ATTRIBUTE_SET (&nameobj, LITERAL);
    LEVEL_SET (&nameobj, current_save_level);

    for ( ii=0;  ii<n_romfont;  ii++ )
        {
        /* get a ROM font dictionary */
        if (!get_dict (fontdir, &(fontdir_cont[ii].k_obj), &fdobj_p))
            {
            printf ("\afatal error, cannot get a ROM font dict.!!\n");
            ERROR (UNDEFINEDRESULT);
            return (FALSE);
            }

        /* get FID, check its FID class, and reset it if necessary */
        get_name (&nameobj, FID, 3, TRUE);
        if (!get_dict (fdobj_p, &nameobj, &obj_got))
            {
            printf ("\afatal error, cannot get FID from a ROM font!!\n");
            ERROR (UNDEFINEDRESULT);
            return (FALSE);
            }
        oldfid = (ufix32)VALUE(obj_got);
        if ( ! IS_ROMFONT_FID(oldfid) )
            {   /* have to reset */
            if (!IS_SU_FID(oldfid)||(FONTTYPE_SUFID(oldfid)==FONTTYPE_USRDEF))
                {
                printf ("\afatal error, invalid FID to be reset!!\n");
                ERROR (UNDEFINEDRESULT);
                return (FALSE);
                }
            /* reset to be a Strong ROM font FID */
            newfid = SU_2_SR_FID(oldfid);

            /* put new FID in its dictionary */
            COPY_STRUCT (&newobj, obj_got, struct object_def);
            VALUE(&newobj) = newfid;
            if ( ! put_dict (fdobj_p, &nameobj, &newobj) )
                {
                printf ("\afatal error, cannot put FID back!!\n");
                ERROR (UNDEFINEDRESULT);
                return (FALSE);
                }
            }
        } /* for all ROM fonts */

    return (TRUE);
  END


/* ............................ gen_fid .............................. */

#ifdef SFNT
GLOBAL FUNCTION ufix32      gen_fid (fdictobj, ftype, uid)
#else
GLOBAL FUNCTION ufix32      gen_fid (fdictobj, ftype, uid, privdict)
#endif
    struct object_def      FAR *fdictobj;   /* i: font dict obj @WIN*/
    ufix8                   ftype;      /* i: font type: 6-bit */
    ufix32                  uid;        /* i: > MAX_UNIQUEID, if undefined */

#ifndef SFNT
    struct dict_head_def   FAR *privdict;   /* i: Private (ignored, if ftype=USR) @WIN*/
#endif

/* Descriptions:
 *  -- generate an FID value for a definefont operation,
 *          depending upon FID representations and classifications.
 */
  DECLARE
    REG ufix        ii;
        ufix32      su_fid;
        ufix8       heavy_vari;
        ufix16      rom_varid;
#     ifdef DBGfid
        ufix32      fid_dbg;
#     endif

#ifdef SFNT
    struct object_def       nameobj = {0, 0, 0}, FAR *privobj_got;  /*@WIN*/
//  struct dict_head_def    FAR *h;     /*@WIN*/
    ufix32                  privdict;
    struct cache_id_items   FAR *idp;   /*@WIN*/
#endif
  BEGIN

#ifdef DBGfid
    printf ("GEN_FID, FontType=0x%X, Uid=0x%lX ...\n", ftype, uid);
#endif

#ifdef SFNT
    ATTRIBUTE_SET(&nameobj, LITERAL);
    LEVEL_SET(&nameobj, current_save_level);

    privdict = 0;         /* value if not assigned */
    if (uid <= MAX_UNIQUEID) {
        /* get cache_id_items list for the specified FontType */
        for (idp = cache_id_items; idp->ftype <= MAX_FONTTYPE; idp++)
            if (idp->ftype == ftype)
                break;
        /* get private item for the font */
        if (idp->itemname != NULL)  {
            get_name(&nameobj, idp->itemname, lstrlen(idp->itemname), FALSE); /*@WIN*/
            if (!get_dict(fdictobj, &nameobj, &privobj_got)) {
                POP(1);
                PUSH_OBJ(&nameobj);
                ERROR(UNDEFINED);
                return(0);
            }
// DJC            if (TYPE(privobj_got) != idp->itemtype) {
            if ((ufix16)(TYPE(privobj_got)) != idp->itemtype) {
                ERROR(INVALIDFONT);     /* LW+ V.38 may crash in such a case. */                return(0);
            }
            privdict = (ufix32) VALUE(privobj_got);
        }   /* end if != NULL */
    }   /* end if UniqueID defined */
#endif  /* SFNT */

#ifdef DBG
    if (ftype > MAX_FONTTYPE)
        {
        warning (FNTCACHE, 0x02, (byte FAR *)NULL);  /* invalid FontType @WIN*/
        ERROR (UNDEFINEDRESULT);
        return (INVALID_FID);
        }
#endif

    /*
     * 1. (UniqueID not exist)? --> Weak User FID.
     */
    if (uid > MAX_UNIQUEID)
#     ifndef DBGfid
        return ( FORM_WU_FID(new_weakfid()) );
#     else
        {
        fid_dbg = FORM_WU_FID(new_weakfid());
        printf ("  Weak User FID = 0x%lX\n", fid_dbg);
        return (fid_dbg);
        }
#     endif

    /*
     * 2. look for ROM font source and examine collision with any ROM font:
     *      (no collision)? --> Strong User FID.
     */
    su_fid = FORM_SU_FID (ftype, uid);

    /* a user-defined font with UniqueID? --> strong user fid */
    if (ftype == FONTTYPE_USRDEF)
#     ifndef DBGfid
        return (su_fid);
#     else
        {
        fid_dbg = su_fid;
        printf ("  Strong User FID = 0x%lX\n", fid_dbg);
        return (fid_dbg);
        }
#     endif

    /*
     * for Built-In fonts ...
     */

    /* examine any collision */
    for ( ii=0;  ii<n_ROMfont;  ii++ )
        if ( (privdict == ROMFI_PRIV(ii)) && (su_fid == (ufix32)ROMFI_SU_FID(ii)) ) //@WIN
            break;          /* a collision occurs */

    /* no collision? --> strong user fid */
    if (ii >= n_ROMfont)
#     ifndef DBGfid
        return (su_fid);
#     else
        {
        fid_dbg = su_fid;
        printf ("  Strong User FID = 0x%lX\n", fid_dbg);
        return (fid_dbg);
        }
#     endif

    /*
     * 3. collision with a ROM font:
     *      (no any heavy variances)? --> Strong ROM FID.
     *      Note that "ii" is ROM_src_id.
     */

    /* no any heavy variances? --> strong rom fid */        /* check all */
    if ( ! (heavy_vari = chk_vari ((ufix8)ftype, 0xFF,
                                    fdictobj, ROMFI_FDICT(ii))) )
#     ifndef DBGfid
        return ( FORM_SR_FID (ftype, uid) );
#     else
        {
        fid_dbg = FORM_SR_FID (ftype, uid);
        printf ("  Strong ROM FID = 0x%lX\n", fid_dbg);
        return (fid_dbg);
        }
#     endif

    /*
     * 4. collision and with heavy variances --> Weak ROM FID.
     *      look for cached dicts to use the dict of the same heavy variances.
     *      (cached dict cannot help)? --> generate a new ROM Variant ID.
     */
    if ( ! get_same_vari (fdictobj, (ufix8)ii, heavy_vari, &rom_varid) )
        {
        rom_varid = new_rom_varid();    /* new if cached dict cannot help. */
#     ifdef DBGfid
        printf ("   a new Variant ID = %d (0x%X)\n", rom_varid, rom_varid);
#     endif
        };

#ifndef DBGfid
    return ( FORM_WR_FID ((ufix8)ii, heavy_vari, rom_varid) );
#else
    fid_dbg = FORM_WR_FID ((ufix8)ii, heavy_vari, rom_varid);
    printf ("  Weak ROM FID = 0x%lX, srcid(0x%X), vari(0x%X), varid(0x%X)\n",
                            fid_dbg, ii, heavy_vari, rom_varid);
    return (fid_dbg);
#endif
  END

/* ............................ new_weakfid .......................... */

PRIVATE FUNCTION ufix32 near    new_weakfid ()

  DECLARE
    REG ufix32      ret_weakfid;
  BEGIN
    ret_weakfid = uniqval_weakfid;

    if (uniqval_weakfid == MAX_WEAKFID)
        ERROR (LIMITCHECK);
    else
        ++ uniqval_weakfid;

    return (ret_weakfid);
  END

/* ........................ new_rom_varid ............................ */

PRIVATE FUNCTION ufix16 near    new_rom_varid ()

  DECLARE
    REG ufix16      ret_rom_varid;
  BEGIN
    ret_rom_varid = uniqval_rom_varid;

    if (uniqval_rom_varid == MAX_ROM_VARID)
        ERROR (LIMITCHECK);
    else
        ++ uniqval_rom_varid;

    return (ret_rom_varid);
  END

/* ............................. save_fid ............................ */

PRIVATE FUNCTION void near      save_fid (save_level)
    ufix        save_level;     /* i: level to save */

  DECLARE
  BEGIN
    weakfid_stack[save_level]   = new_weakfid();
    rom_varid_stack[save_level] = new_rom_varid();
#ifdef DBGfid
    printf ("save_fid: wfid=0x%lX, rom_varid=0x%X -- saved\n",
            weakfid_stack[save_level], rom_varid_stack[save_level]);
#endif
  END

/* ............................ restore_fid .......................... */

PRIVATE FUNCTION void near      restore_fid (save_level)
    ufix        save_level;     /* i: level to restore */

  DECLARE
  BEGIN
    uniqval_weakfid   = weakfid_stack[save_level];
    uniqval_rom_varid = rom_varid_stack[save_level];
#ifdef DBGfid
    printf ("restore_fid: wfid=0x%lX, rom_varid=0x%X -- restored\n",
            weakfid_stack[save_level], rom_varid_stack[save_level]);
#endif
  END

/* ............................ is_weaker_fid ........................ */

PRIVATE FUNCTION bool near      is_weaker_fid (fid)
    ufix32      fid;            /* i: fid to be examined */

  DECLARE
  BEGIN
    return ( (IS_WU_FID(fid) && (fid >= uniqval_weakfid)) ||
// DJC             (IS_WR_FID(fid) && (VARID_WR_FID(fid) >= uniqval_rom_varid)) );
             (IS_WR_FID(fid) &&
                   ( (ufix16)(VARID_WR_FID(fid)) >= uniqval_rom_varid)) );
  END


/*
 * -------------------------------------------------------------------
 *  [CODE]  Font Cache Manager: Cache Policy Dependent
 * -------------------------------------------------------------------
 */

/* .................... is_dict_cached ............................... */

GLOBAL FUNCTION bool    is_dict_cached (fid, scalematr, origfont, dictfound)
    ufix32      fid;                    /* i: fid in dict */
    real32      FAR scalematr[];            /* i: ScaleMatrix[] @WIN*/
    struct dict_head_def   FAR *origfont;   /* i: OrigFont @WIN*/
    struct object_def     FAR * FAR *dictfound;  /* o: dict obj addr., if found. @WIN*/
                                        /*    undefined, otherwise.     */
  DECLARE
    REG fix         ii, dict_id;
    REG ufix32      dfid;           /* effective fid for dict cache */
        fix16       expon;
        long32      tolerance[6], tmpl;
        real32     FAR *matr;   /*@WIN*/
  BEGIN

    /*
     * determine floating pt. tolerance for matrix comparison,
     *      and force those near 0. to be exact 0.
     */
    for ( ii=0; ii<6; ii++ )
        {
        expon = DE_EXPONENT(scalematr[ii]);
        if (NEAR_ZERO(expon, N_BITS_ACCURACY))
            {
            F2L(scalematr[ii]) = F2L(zero_f);   /* SIDE EFFECT !!! */
            tolerance[ii] = GET_TOLERANCE_ZERO();
            }
        else
            tolerance[ii] = GET_TOLERANCE (expon, N_BITS_ACCURACY);
        }

    /* get effective FID for dict cache: depends on FID representation */
    dfid = TO_DFID (fid);


    /*
     * look for cached dict with the same fid, origfont and scalematr[].
     *  --> from the latest one to the oldest.
     */
    FOR_DICT_LATEST_2_OLDEST (ii)
        {
        dict_id = fcache_map[ii];
        if ( (dfid == TO_DFID (DICTCACHE_FID(dict_id)))     /* effective fid */
           && (origfont == DICTCACHE_ORIGFONT(dict_id)) )   /* OrigFont */
            {
            matr = &(DICTCACHE_MATR(dict_id)[0]);
            if (EQ_MATR (scalematr, matr, tolerance, tmpl)) /* ScaleMatrix */
                {
#         ifdef DBG
                printf ("FID=0x%lX, cached already, DictID=%d\n", fid,dict_id);
#         endif
                *dictfound = &DICTCACHE_DICT(dict_id);
                return (TRUE);
                }
            }
        }

    return (FALSE);     /* in such a case, dictfound is undefined */
  END

/* ........................ cache_dict ............................... */

GLOBAL
FUNCTION struct object_def FAR *cache_dict (fid, scalematr, origfont, dict_objp) /*@WIN*/
    ufix32      fid;                    /* i: fid in dict */
    real32      FAR scalematr[];            /* i: ScaleMatrix @WIN*/
    struct dict_head_def   FAR *origfont;   /* i: OrigFont WIN*/
    struct object_def      FAR *dict_objp;  /* i: dict obj to be cached @WIN*/

/* Return:
 *  -- addr of a "static" object in dict cache after caching the dict.
 */
  DECLARE
    REG fix         dict_id;
  BEGIN

#ifdef DBG
    printf ("Cache a new Dict, FID=0x%lX\n", fid);
#endif

#ifdef SCSI  /* SCSI_TTT */
    /* update primary cache */
    ++cache1_updated;
#endif

    /* create a new dict cache entry. */
    if (IS_FONTCACHE_TBL_FULL())    /* fontcache table full? */
        {
#     ifdef DBGovflw
        printf ("Font Dict/Matr Cache overflows ...\n");
#     endif
        delete_fontcache ();        /* delete some entry of fontcache table */
        }

    dict_id = fcache_map[NEW_A_DICTCACHE()];
#ifdef DBG
    printf ("  new DictID = %d\n", dict_id);
#endif

    /* cache the new entry. */
    CACHE_NEW_DICT (dict_id, fid, scalematr, origfont, dict_objp);
        /* note that those near 0. in scalematr[] had been forced to
         *      be exact 0. by is_dict_cached().
         */

    return (&DICTCACHE_DICT(dict_id));
  END

/* ........................ cache_matr ............................... */

GLOBAL FUNCTION ufix16      cache_matr (fid, scalectm)
    ufix32      fid;            /* i: fid in dict */
    real32      FAR scalectm[];     /* i: ScaleMatrix * CTM @WIN*/

  DECLARE
    REG fix         ii, matr_id;
    REG ufix32      mfid;       /* effective fid for matr cache */
        fix16       expon;
        long32      tolerance[6], tmpl;
        real32     FAR *matr;   /*@WIN*/
  BEGIN

#ifdef DBG
    printf ("Cache a Matr, FID=0x%lX\n", fid);
#endif

#ifdef SCSI /* SCSI_TTT */
    /* update primary cache */
    ++cache1_updated;
#endif

    /*
     * determine floating pt. tolerance for matrix comparison,
     *      and force those near 0. to be exact 0.
     */
    for ( ii=0; ii<6; ii++ )
        {
        expon = DE_EXPONENT(scalectm[ii]);
        if (NEAR_ZERO(expon, N_BITS_ACCURACY))
            {
            F2L(scalectm[ii]) = F2L(zero_f);    /* SIDE EFFECT !!! */
            tolerance[ii] = GET_TOLERANCE_ZERO();
            }
        else
            tolerance[ii] = GET_TOLERANCE (expon, N_BITS_ACCURACY);
        }


    /* get effetive fid for matr cache */
    mfid = TO_MFID (fid);

    /*
     * search cached matrix from the latest to the oldest.
     */
    FOR_MATR_LATEST_2_OLDEST (ii)
        {
        matr_id = fcache_map[ii];
        if (mfid == TO_MFID (MATRCACHE_FID(matr_id)))       /* effective fid */
            {
            matr = &(MATRCACHE_MATR(matr_id)[0]);
            if (EQ_MATR (scalectm, matr, tolerance, tmpl))  /* scalematr*ctm */
                {
                MAKE_MATR_LATEST (ii);
#         ifdef DBG
                printf ("  already cached, MatrID=%d\n", matr_id);
#         endif
                return ((ufix16)matr_id);   /* i.e. cache class id */
                }
            }
        }

    /* create a new matr cache entry. */
    if (IS_FONTCACHE_TBL_FULL())    /* fontcache table full? */
        {
#     ifdef DBGovflw
        printf ("Font Dict/Matr Cache overflows ...\n");
#     endif
        delete_fontcache ();        /* delete some entry of fontcache table */
        }

    matr_id = fcache_map[NEW_A_MATRCACHE()];
#ifdef DBG
    printf ("  new MatrID = %d\n", matr_id);
#endif

    /* cache the new entry. */
    CACHE_NEW_MATR (matr_id, mfid, scalectm);

    /* reset the new cache class. */
    reset_a_cacheclass (matr_id);

    return ((ufix16)matr_id);  /* i.e. cache class id */
  END

/* ........................ delete_fontcache ......................... */

PRIVATE FUNCTION void near  delete_fontcache()

  DECLARE
    REG fix     ii, matr_id;
  BEGIN
    /*
     * delete the oldest and non-precached matrix cache entry.
     */
    FOR_MATR_OLDEST_2_LATEST (ii)   /* execpt the latest (current) one */
        {
        matr_id = fcache_map[ii];
#ifdef SCSI
#ifdef DBGovflw
    /* debugging */
        printf("ii: % d, matr_id: %d, _ROMED: %d, _NONEMPTY: %d\n",
             ii, matr_id, IS_CLASS_ROMED(matr_id), IS_CLASS_NONEMPTY(matr_id) );
#endif
#endif
        if ( ! IS_CLASS_ROMED(matr_id) )
            {
            if (IS_CLASS_NONEMPTY(matr_id)) /* a non-empty class? */
                free_a_cacheclass (matr_id);
#         ifdef DBGovflw
            printf ("  to remove %d-th Matrix, MatrID=%d\n", ii, matr_id);
#         endif
            REMOVE_A_MATRCACHE (ii);        /* remove "ii" and make it free */
            return;
            }
        }

    /* only precached matrix left, so to remove the latest dict cache. */
#ifdef DBGovflw
    printf ("  to remove the latest dict, DictID=%d\n",
                            fcache_map[DICTCACHE_LATEST()]);
#endif
    REMOVE_A_DICTCACHE ();

  END

/* ........................ delete_cache_resources ....................... */

PRIVATE FUNCTION void near  delete_cache_resources ()

  DECLARE
    REG fix     ii, matr_id;
  BEGIN

#ifdef SCSI
    /* update primary cache */
    ++cache1_updated;
#endif

    /*
     * look for the oldest, non-empty and non-precached matrix cache entry.
     */
    FOR_MATR_OLDEST_2_LATEST (ii)   /* execpt the latest (current) one */
        {
        matr_id = fcache_map[ii];
#ifdef SCSI
#ifdef DBGovflw
    /* debugging */
        printf("ii: % d, matr_id: %d, _ROMED: %d, _NONEMPTY: %d\n",
             ii, matr_id, IS_CLASS_ROMED(matr_id), IS_CLASS_NONEMPTY(matr_id) );
#endif
#endif
        if ((!IS_CLASS_ROMED(matr_id)) && IS_CLASS_NONEMPTY(matr_id))
            break;
        }
    /* if nothing but itself, get its matrcache id. @+ 09/06/88 Danny */
    if (ii == MATRCACHE_LATEST())   matr_id = fcache_map[ii];

    /*
     * free the resources attached to it, and reset the class.
     */
#ifdef DBGovflw
    printf ("  to free %d-th Matrix, MatrID=%d\n", ii, matr_id);
#endif
    free_a_cacheclass (matr_id);
    reset_a_cacheclass (matr_id);
  END


/* ............................ font_save .............................. */

GLOBAL FUNCTION void            font_save ()

  DECLARE
  BEGIN
    save_fid (font_tos);
    if (ANY_ERROR())    return;         /* not to update font_tos */

    font_stack[font_tos].n_dict = n_dict;

    /* COUPLED with Char Cache Manager */
    font_stack[font_tos].cacheparams_ub = cacheparams_ub;
    font_stack[font_tos].cacheparams_lb = cacheparams_lb;

    font_tos ++;
  END

/* ............................ font_restore ........................... */

GLOBAL FUNCTION void            font_restore ()

  DECLARE
    REG fix     ii, jj, matr_id;
  BEGIN

#ifdef DBG
    printf ("font_restore ...\n");
#endif

    font_tos --;

    restore_fid (font_tos);     /* must be done before throw something out. */

    /* throw out all the classes of weaker fids */
    FOR_MATR_LATEST_2_OLDEST (ii)
        {
        matr_id = fcache_map[ii];
        if ( is_weaker_fid(MATRCACHE_FID(matr_id)) )
            {
            if (IS_CLASS_NONEMPTY(matr_id))
                free_a_cacheclass (matr_id);
#         ifdef DBG
            printf ("  to discard %d-th Matrix, MatrID=%d, FID=0x%lX\n",
                            ii, matr_id, MATRCACHE_FID(matr_id));
#         endif
            jj = ii;
            REMOVE_A_MATRCACHE (jj);
            }
        }

    /* throw out all the dict cached in this save level */
    if (n_dict > font_stack[font_tos].n_dict)   /* some dict in the upper    */
        n_dict = font_stack[font_tos].n_dict;   /*  save level may have been */
                                                /*  deleted in case overflow.*/
    /* COUPLED with Char Cache Manager */
    cacheparams_ub = font_stack[font_tos].cacheparams_ub;
    cacheparams_lb = font_stack[font_tos].cacheparams_lb;

#ifdef DBG
    printf ("  N_Matr=%d, N_Dict=%d\n", n_matr, n_dict);
#endif
  END

/* ........................ get_same_vari ............................ */

PRIVATE FUNCTION bool near  get_same_vari (newfobj, rom_srcid, vari, rom_varid)
    struct object_def      FAR *newfobj;    /* i: font dict object @WIN*/
    ufix8                   rom_srcid;  /* i: Src ID of Parent ROM font */
    ufix8                   vari;       /* i: variance code */
    ufix16                 FAR *rom_varid;  /* o: returned Variant ID with  @WIN*/
                                        /*      the ROM font source and */
  DECLARE                               /*      the same variances.     */
    REG fix         ii;
    REG ufix32      srcvari_wrfid;  /* WR FID of rom_srcid && vari code only */

  BEGIN

    srcvari_wrfid = MAKE_WR_SRCaVARI (rom_srcid, vari);
    FOR_DICT_LATEST_2_OLDEST (ii)
        {
        if (srcvari_wrfid == WR_SRCaVARI_OF_FID(DICTCACHE_FID(ii)))
            {   /* the same Parent ROM font, and the same Variant code */
            if ( ! chk_vari ( (ufix8)ROMFI_FONTTYPE(rom_srcid), vari, /*@WIN*/
                            newfobj, &(DICTCACHE_DICT(ii)) ) )

                {   /* all the variances have the same value */
#             ifdef DBGfid
                printf ("  Get Variant ID from %d-th Dict Cache\n", ii);
#             endif
                *rom_varid = VARID_WR_FID(DICTCACHE_FID(ii));
                return (TRUE);
                }
            }
        }
    return (FALSE);     /* no font in dict cache satisfies. */

  END


/*
 * -------------------------------------------------------------------
 *  [CODE]  Cache Class Manager
 * -------------------------------------------------------------------
 */

/* ........................ free_a_cacheclass ........................ */

PRIVATE FUNCTION void near  free_a_cacheclass (classid)
    fix         classid;        /* i: cache class id */

  DECLARE
    REG ufix        grp_ii, cg_seg, cg_off;
        fix16       charcc_id;
  BEGIN
#ifdef SCSI
    /* file cache or not ? */
    if ( IS_STRONGFID(MATRCACHE_FID(classid)) &&
                ( FONTTYPE_SUFID(MATRCACHE_FID(classid)) != FONTTYPE_USRDEF) )
        file_fontcache(classid);
#endif /* SCSI */

    for ( grp_ii=0; grp_ii<N_CGRP_CLASS; grp_ii++ )
        if ((cg_seg = CLASS_GRP2CGSEG(classid, grp_ii)) != NIL_CGSEG)
            {   /* free a group of char caches */
            for ( cg_off=0; cg_off<N_CG_CGSEG; cg_off++ )
                {
                if ((charcc_id = cg[cg_seg][cg_off]) != NIL_CHARCC_ID)
                    {
                    free_a_charcache (charcc_id);
                    cg[cg_seg][cg_off] = NIL_CHARCC_ID;
                    };
                 };
            MAKE_CGSEG_FREE((ufix8)cg_seg);
            };
  END

/* ........................ is_char_cached ........................... */

#ifdef SCSI
GLOBAL FUNCTION bool        is_char_cached (class, nmcc_id, charcache, wrf)
        fix16               class;      /* i: cache class id */
    REG ufix16              nmcc_id;    /* i: name cache id */
        struct Char_Tbl   FAR * FAR *charcache;  /* o: returned char cache info addr. @WIN*/
        bool                wrf;        /* i: only width required flag */
#else
GLOBAL FUNCTION bool        is_char_cached (class, nmcc_id, charcache)
        fix16               class;      /* i: cache class id */
    REG ufix16              nmcc_id;    /* i: name cache id */
        struct Char_Tbl   FAR * FAR *charcache;  /* o: returned char cache info addr. @WIN*/
#endif
  DECLARE
    REG ufix        cgseg;
    REG fix         charcc_id;
  BEGIN
#ifdef DBG
    printf ("Char: NameCacheID=0x%X, ClassID=%d ", nmcc_id, class);
#endif

    if (  ((cgseg = CLASS_GRP2CGSEG(class, NM2CGRP(nmcc_id))) == NIL_CGSEG)
       || ((charcc_id = cg[cgseg][NM2CGOFF(nmcc_id)]) == NIL_CHARCC_ID)
       )
        {
#     ifdef DBG
        printf (", not cached yet\n");
#     endif
#ifdef SCSI
        /* char filed or not ? */
        if ( IS_STRONGFID(MATRCACHE_FID(class)) &&
                ( FONTTYPE_SUFID(MATRCACHE_FID(class)) != FONTTYPE_USRDEF) )
            return (is_char_filed (class, nmcc_id, charcache, wrf));
        else
            return(FALSE);
#else
        return (FALSE);
#endif
        }
    else
        {
#     ifdef DBG
        printf (", already cached, CharCacheID=%d\n", charcc_id);
#     endif
        *charcache = &(Char_Tbl[charcc_id]);
        return (TRUE);
        }
  END

/* ........................ cache_char ............................... */

GLOBAL FUNCTION void        cache_char (classid, nmcc_id, charcache)
    fix16                   classid;    /* i: cache class id  */
    ufix16                  nmcc_id;    /* i: name cache id   */
    struct Char_Tbl        FAR *charcache;  /* i: addr of char cache to cache @WIN*/

   DECLARE
    REG ufix        chargrp, cg_seg;
        ufix8       newcgseg;
   BEGIN

#ifdef DBG
    printf ("Cache a new Char, NmCacheID=0x%X, ClassID=%d\n", nmcc_id,classid);
#endif

#ifdef SCSI
    /* update primary cache */
    ++cache1_updated;
#endif

    if (IS_CHARCACHE_FULL())
        {
#     ifdef DBGovflw
        printf ("Char Cache overflows ...\n");
#     endif
        delete_cache_resources ();
        }

    chargrp = NM2CGRP(nmcc_id);
    if ((cg_seg = CLASS_GRP2CGSEG(classid, chargrp)) == NIL_CGSEG)
        {
        if (IS_CG_FULL())
            {
#         ifdef DBGovflw
            printf ("CG Segment overflows ...\n");
#         endif
            delete_cache_resources ();
            }
        GET_FREE_CGSEG(&newcgseg);
        PUT_CLASS_GRP2CGSEG (classid, chargrp, newcgseg);
        cg_seg = (ufix)newcgseg;
#     ifdef DBG
        printf ("  new CG seg.(%d) for CharGrp (%d)\n", cg_seg, chargrp);
#     endif
        }

    /* add the new char into char cache */
    ADD_CLASS_A_CHAR(classid);
    CACHE_NEW_CHARCACHE (&(cg[cg_seg][NM2CGOFF(nmcc_id)]), charcache);
#ifdef DBG
    {   fix16   charcc_id;
    charcc_id = cg[cg_seg][NM2CGOFF(nmcc_id)];
    printf ("Cache a new CharCache ...\n");
    printf ("  n_char_cache=%d, n_char_compact=%d, CharCacheID=%d\n",
                    n_char_cache, n_char_compact, charcc_id);
    printf ("  box_w=%d, box_h=%d, gmaddr=0x%lX\n",
                    charcache->box_w, charcache->box_h, charcache->bitmap);
    printf ("  bmapcc actused=%ld(0x%lX), freeptr=0x%lX\n",
                    bmapcc_actused, bmapcc_actused, bmapcc_freeptr);
    }
#endif
  END


/*
 * -------------------------------------------------------------------
 *  [CODE]  Char Cache Manager
 * -------------------------------------------------------------------
 */

/* ........................ free_a_charcache ......................... */

PRIVATE FUNCTION void near  free_a_charcache (charcc_id)
    fix         charcc_id;      /* i: char cache id to be freed */
  DECLARE
    REG ufix    ii;
  BEGIN
    /* search for the one to be freed */
    for ( ii=n_char_precache; ii<n_char_cache; ii++ )
        if (free_charcc[ii] == charcc_id)
            {
            if (IS_TO_DIG_A_HOLE(ii))   UPDATE_COMPACT_AREA(ii);
            -- n_char_cache;
            for (  ; ii<n_char_cache; ii++ )    /* remove the freed entry */
                free_charcc[ii] = free_charcc[ii+1];
            free_charcc[ii] = (fix16)charcc_id;
            FREE_BMAPCACHE (&(Char_Tbl[charcc_id]));
/* SRB: 10/4/90, Danny */
            bmap_compacted = FALSE;
/* SRB: END */
            return;
            };
  END

/* ........................ compact_bmapcache ........................ */

PRIVATE FUNCTION void near  compact_bmapcache()

  DECLARE
    REG ufix                ii;
        struct Char_Tbl    FAR *charcc_p, old_cc;       /*@WIN*/
        ufix32              new_actused;
        gmaddr              new_freeptr;
        ufix32              charbmap_size;
  BEGIN
    /* calculate the bitmap cache size of compact area */
    new_actused = 0;
    FOR_COMPACT_AREA (ii)
        {
        charcc_p = &( Char_Tbl[ free_charcc[ii] ] );
        new_actused += (ufix32) SIZE_CHARBMAP (charcc_p);
        }

    /* compact bitmap cache by sweeping out the holes */
    new_freeptr = gp_cache_base + new_actused;
    for (  ; ii<n_char_cache; ii++ )
        {   /* for all cached char: move bitmap cache */
        charcc_p = &( Char_Tbl[ free_charcc[ii] ] );
        if (IS_EMPTY_BMAP(charcc_p))    continue;   /* skip over 'space' */

        COPY_STRUCT (&old_cc, charcc_p, struct Char_Tbl);
        charcc_p->bitmap = new_freeptr;             /* new gmaddr addr */
        move_char_cache (charcc_p, &old_cc);        /* @11/24/88= */
        new_actused += (charbmap_size = SIZE_CHARBMAP(charcc_p));
        new_freeptr += charbmap_size;
        }

    /* update end mark of the compact area */
    UPDATE_COMPACT_AREA (n_char_cache);

/* SRB: 10/4/90, Danny */
    bmap_compacted = TRUE;
/* SRB: END */

    /* reset bitmap cache state */
    bmapcc_actused = new_actused;
    bmapcc_freeptr = new_freeptr;
  END

/* ............................ ALLOCATE ............................. */

GLOBAL FUNCTION gmaddr          ALLOCATE(len)
    ufix        len;            /* i: number of bytes requested */

  DECLARE
    REG gmaddr  ret_gmptr;
  BEGIN

#ifdef DBG
    printf ("ALLOCATE (%d bytes) ...\n", len);
#endif

    len = WORD_ALIGN(len);      /* @11/24/88+ */

    /* make a contiguous free space at least "len" */
    while (IS_BMAP_INSUFF(len))
        {
#     ifdef DBGovflw
        printf ("Bitmap Cache insufficent -- ALLOCATE (%d bytes)\n", len);
#     endif
        delete_cache_resources ();
        }
    if (NEED_TO_COMPACT(len))  compact_bmapcache();

    ret_gmptr = bmapcc_freeptr;
    bmapcc_freeptr += len;
    bmapcc_actused += len;

#ifdef DBG
    printf ("  bitmap addr=0x%lX (next=0x%lX)\n", ret_gmptr, bmapcc_freeptr);
#endif
    return (ret_gmptr);
  END

/* ............................ get_pm ............................... */

GLOBAL FUNCTION gmaddr          get_pm (size)
    fix32      FAR *size;           /* o: allocated size to paint a huge char @WIN*/
/* Descriptions:
 *  -- the allocated cache buffer is only for temporary use to paint
 *          a huge character (when F_TO_PAGE).
 *  -- NOT TO UPDATE bitmap cache state.
 */
  DECLARE
  BEGIN

#ifdef DBG
    printf ("get_pm ...\n");
#endif

    /* make a contiguous free space at least "size" */
    while (IS_BMAP_INSUFF(MINBMAPSIZE_HUGECHAR))
        {
#     ifdef DBGovflw
        printf ("Bitmap Cache insufficent -- get_pm()\n");
#     endif
        delete_cache_resources ();
        }

    if (NEED_TO_COMPACT(MINBMAPSIZE_HUGECHAR))  compact_bmapcache();

    *size = (fix32)(gp_cache_end - bmapcc_freeptr);
#ifdef DBG
    printf ("  bitmap addr=0x%lX, size=0x%lX\n", bmapcc_freeptr, *size);
#endif
    return (bmapcc_freeptr);
  END

/* ............................ get_cm ............................... */

GLOBAL FUNCTION gmaddr          get_cm (size)
    ufix        size;           /* i: number of bytes requested */

/* Descriptions:
 *  -- leave a bitmap area and allocate another shadow bitmap cache
 *          to paint a character (the character image will be digged out
 *          from the shadow into the 1st bitmap area). The shadow is
 *          always at least big as the 1st bitmap area.
 *  -- NOT TO UPDATE bitmap cache state, since a final ALLOCATE will
 *          actually update the state.
 */
  DECLARE
    REG ufix32  len;
  BEGIN

#ifdef DBG
    printf ("get_cm (%d bytes) ...\n", size);
#endif

    size = WORD_ALIGN(size);    /* @11/24/88+ */

    /* make a contiguous free space at least "2*size" */
    len = size * 2;
    while (IS_BMAP_INSUFF(len))
        {
#     ifdef DBGovflw
        printf ("Bitmap Cache insufficent -- get_cm (2 * %d bytes)\n", size);
#     endif
        delete_cache_resources ();
        }
    if (NEED_TO_COMPACT(len))   compact_bmapcache();

#ifdef DBG
    printf ("  bitmap addr=0x%lX\n", bmapcc_freeptr+size);
#endif
    return (bmapcc_freeptr + size); /* leave a space, and returns shadow */
  END


/*
 ***********************************************************************
 * Build up NAME_CACHE_MAP_TABLE           @ 04/26/90  Kason
 *
 * ----------------- for setfont
 *
 ***********************************************************************
 */

void  build_name_cc_table (fdictobj_p,fonttype)
    struct object_def      FAR *fdictobj_p;  /* i: a fontdict  @WIN*/
    ufix8                  fonttype;     /* i: font type   */

 {
        struct object_def       someobj = {0, 0, 0}, chstr_k;
        struct object_def       FAR *obj_got, FAR *chstr_v;     /*@WIN*/
        ufix                    len;
        register ufix           ii, jj, kk;
//      ufix16                  cacheid;        @WIN
        struct dict_head_def    FAR *chstr_hd_ptr;      /*@WIN*/

    /* if use_define_font, it is not necessary to build name_cache_table */
     /*@ 05/16/90+ */
    if ((fonttype==FONTTYPE_USRDEF)||(fonttype==0))
       {
#ifdef DBG
        printf("Usr_def_font, system doesn't build up name_cache_table\n");
#endif

        return ;
       };

    /* assign name cache id for names in CharStrings of this fonts */
    ATTRIBUTE_SET (&someobj, LITERAL);
    LEVEL_SET (&someobj, current_save_level);

    n_N2CCmap = 0;  /* number of N2CCmap[], i.e. new cache id to be assigned */
                    /* In the begining, set to zero for entering setfont */

    /* get CharStrings */
    get_name (&someobj, CharStrings, 11, TRUE);
    get_dict (fdictobj_p, &someobj, &obj_got);


    /* Calculate how many keys in the Charstrings of this font */
    chstr_hd_ptr=(struct dict_head_def FAR *) VALUE(obj_got);   /*@WIN*/
    len = chstr_hd_ptr -> actlength;

    ii = 0;             /* ii: index to N2CCmap[] to be inserted at */
    kk = 0;             /* kk: index of current name to CharStrings[] */

    for (  ;  kk<len;  kk++ )
        {
          if (!extract_dict (obj_got, kk, &chstr_k, &chstr_v))
                warning (FNTCACHE, 0x03, "CharStrings's content");

          if( DROM(chstr_hd_ptr))          /* build-in */
            {                              /* CharStrings has been sorted */
            for (     ;  ii<n_N2CCmap;  ii++ )     /* where to insert at? */
                if (N2CCmap[ii].name_hid >= (fix16)VALUE(&chstr_k))
                    break;      /* stop to keep the new name in line */
            }
          else                             /* download */
            {                              /* CharStrings has not been sorted */
            for (ii=0 ;  ii<n_N2CCmap;  ii++ )     /* where to insert at? */
                if (N2CCmap[ii].name_hid >= (fix16)VALUE(&chstr_k))
                    break;      /* stop to keep the new name in line */
            }

          /* leave a space first */
          for ( jj=n_N2CCmap;  jj>ii;  jj-- )
                    COPY_STRUCT (&N2CCmap[jj], &N2CCmap[jj-1],
                                struct N2CCmap_s);

          /* and then insert it, perhaps at the last. */
          N2CCmap[ii].name_hid = (ufix16)VALUE(&chstr_k);
          N2CCmap[ii].cacheid = (ufix16)(n_N2CCmap);

          /* go for next cache id */
          ++ n_N2CCmap;
          if (n_N2CCmap==MAX_NAME_CACHE_MAP)
             ERROR(LIMITCHECK);

        } /* for (all names in CharStrings) */
       /*RCD-begin*/
       pre_cd_addr = chstr_hd_ptr ;
       pre_len = (ufix16)len ;
       pre_checksum = (ufix32)VALUE(&chstr_k);
       /*RCD-end*/
#ifdef DBG
       printf("\nWhen leaving build_name_cc_table(), there are : \n");
       printf("n_N2CCmap=%d\t N2CCmap=%lx\n",n_N2CCmap,N2CCmap);
       for(ii=0; ii<n_N2CCmap; ii++)
          {
             printf("N2CCmap[%d].name_hid =%d \t ", ii, N2CCmap[ii].name_hid );
             printf("N2CCmap[%d].cacheid=%d \n ", ii, N2CCmap[ii].cacheid);
          }

#endif
      return ;

 }  /*   build_name_cc_table ()  */

/* ........................ get_name_cacheid ......................... */

GLOBAL FUNCTION bool    get_name_cacheid (ftype, encoding, ascii, cacheid)
    ufix8               ftype;      /* i: FontType */
    struct object_def   FAR encoding[]; /* i: encoding array of the font @WIN*/
    ufix8               ascii;      /* i: ascii code of the char (0..255) */
    ufix16             FAR *cacheid;    /* o: returned name cache id @WIN*/

/* Descriptions:
 *  -- perform the mapping from char ascii code into name cache id.
 * Notes:
 *  -- N2CCmap[] is INEFFECTIVE for user-defined fonts, so the ASCII code of
 *          the character is its name cache id, too.
 * Return:
 *  -- TRUE if a name cache id is returned; FALSE, some error raises.
 */
  DECLARE
    fix16       name_hid;   /* hashed id of char name */
    ufix        N2CC_idx;   /* index to N2CCmap[] whose name = name_hid */

  BEGIN
    if (ftype == FONTTYPE_USRDEF)   /* not a builtin font? */
        {
        *cacheid = (ufix16)ascii;       /* use ASCII code as cache id   */
        return (TRUE);                  /*      for user-defined fonts. */
        }

    name_hid = (fix16) VALUE(&(encoding[ascii]));
    if (search_N2CCmap (name_hid, &N2CC_idx))
        {
        *cacheid = N2CCmap[N2CC_idx].cacheid;

#ifdef DBG             /* 05/08/90 Kason */
        printf("When searching the Name_cache_map_table, it finds : \n");
        printf("Encoding index:%d \t nameid=%d \t cacheid=%u\n",
                         ascii,      name_hid,    *cacheid     );
#endif

        return (TRUE);
        }
    else {  /* Kason 3/21/91 */
        extern ufix16  id_space ;

        if (search_N2CCmap (id_space, &N2CC_idx)) {
            *cacheid = (N2CCmap+N2CC_idx)->cacheid;
            return (TRUE);
        }/*if*/

    }/*if*/  /*K-end*/
#ifdef DBG
    printf("get_name_cacheid fails\n");
#endif
    return (FALSE); /* i.e. N2CCmap[] is invalid for some builtin font */
  END

/* ........................ search_N2CCmap ............................ */

PRIVATE FUNCTION bool near  search_N2CCmap (name_hid, N2CC_idx)
    fix16       name_hid;   /* i: hashed id of char name to searche for */
    ufix       FAR *N2CC_idx;   /* o: returned index to N2CCmap[], if found @WIN*/
/* Descriptions:
 *  -- search the private N2CCmap[] for a char name with Binary Search.
 * Return:
 *  -- TRUE, if char name found; FALSE, otherwise.
 */
  DECLARE
    REG fix     ii, jj, kk; /* middle, lower, upper for BINARY SEARCH */

  BEGIN
    jj = 0;
    kk = n_N2CCmap - 1;

    while (kk >= jj)        /* is there anything not searched yet? */
        {
        ii = (jj + kk) >> 1;    /* (jj+kk)/2 */

        if (name_hid == N2CCmap[ii].name_hid)   /* found? */
            {
            *N2CC_idx = ii;
            return (TRUE);
            }

        if (name_hid < N2CCmap[ii].name_hid)    /* in lower part? */
            kk = ii - 1;
        else
            jj = ii + 1;
        }

    return (FALSE);
  END


/*
 * -------------------------------------------------------------------
 *              Font Cache Initializer
 * -------------------------------------------------------------------
 *
 *  Sequences of Initialization or Packing Precache Data:
 *      1. init FID Manager.
 *      2. init Font Cache Manager.
 *      3. init Cache Class Manager.
 *      4. init Char Cache Manager.
 *      5. init Char Name Cache Manager.
 *
 * -------------------------------------------------------------------
 */

/* ........................ init_fontcache ........................... */

GLOBAL FUNCTION void        init_fontcache (fontdirectory)
    struct object_def      FAR *fontdirectory;  /* i: fontdir of all ROM fonts @WIN*/

  DECLARE
    REG ufix        ii, jj;
#ifdef PCH_R
        ubyte      FAR *deprecache_upto;    /* de-precache addr up to @WIN*/
#endif
  BEGIN

/* BEGIN 03/02/90 D.S. Tseng */
/*  PCH: Begin, Danny, 11/28/90 */
/********
    precache_hdr = (struct precache_hdr_s FAR *)(FONTBASE);     (*@WIN*)
********/
#ifdef PCH_R
    precache_hdr = (struct precache_hdr_s FAR *)(PRECACHE_BASE_R); /*@WIN*/
#else
#ifndef PCH_S
    precache_hdr = (struct precache_hdr_s FAR *)(FONTBASE); /*@WIN*/
#endif
#endif
/* PCH: end, Danny, 11/28/90 */
/* END   03/02/90 D.S. Tseng */


/*  PCH: replace flag RST_VM by PCH_R, Danny, 11/28/90 */
#ifdef PCH_R
    /* initialize de-precache addr for tables */
    if (precache_hdr->size == 0)
        {
        printf ("\afatal error, failed to de-precache!!\n");
        return;
        }
    deprecache_upto = (ubyte FAR *)precache_hdr + sizeof(struct precache_hdr_s); /*@WIN*/
#endif

    /*
     * 1. FID Manager: on her own way.
     */
    init_gen_fid (fontdirectory);

    /*
     * 2. Font Cache Manager: fcache_map[], FontCache_Tbl[], font_stack[].
     */

    /* fcache_map[] */
    fcache_map = FARALLOC (MAX_MATR_CACHE, fix16);
    for ( ii=0; ii<MAX_MATR_CACHE; ii++ )   fcache_map[ii] = (fix16)ii;

    /* FontCache_Tbl[] -- DictCache/MatrCache */
    FontCache_Tbl = FARALLOC (MAX_MATR_CACHE, struct fontcache_s);

    n_dict = 0;     /* None of dict is precached */

/*  PCH: replace flag RST_VM by PCH_R, Danny, 11/28/90 */
#ifdef PCH_R
    /* to De-precache Matrix Cache */
    n_matr = precache_hdr->n_matr;
    ii = (ufix) (n_matr * sizeof(struct fontcache_s));
    if (ii!=0)  lmemcpy ((ubyte FAR *)FontCache_Tbl, deprecache_upto, ii); /*@WIN*/
    deprecache_upto += ii;
#else
    n_matr = 0;
#endif

    /* font_stack[] */
    font_stack = FARALLOC ((MAXSAVESZ+1), struct font_stack_s);
    font_tos = 0;

    /*
     * 3. Cache Class Manager: free_cgseg[], cg[][].
     */
    free_cgseg = FARALLOC (MAX_CGSEG, ufix8);
    for ( ii=0; ii<MAX_CGSEG; ii++ )    free_cgseg[ii] = (ufix8)ii;

    cg = (fix16 (FAR *)[N_CG_CGSEG]) FARALLOC (MAX_CGSEG * N_CG_CGSEG, fix16);/*@WIN*/
    for ( ii=0; ii<MAX_CGSEG; ii++ )
        for ( jj=0; jj<N_CG_CGSEG; jj++ )   cg[ii][jj] = NIL_CHARCC_ID;

/*  PCH: replace flag RST_VM by PCH_R, Danny, 11/28/90 */
#ifdef PCH_R
    /* to De-precache CG Segments */
    n_cgseg_used = precache_hdr->n_cgseg_used;
    ii = n_cgseg_used * N_CG_CGSEG * sizeof(ufix16);
    if (ii!=0)  lmemcpy ((ubyte FAR *)cg, deprecache_upto, ii);  /*@WIN*/
    deprecache_upto += ii;
#else
    n_cgseg_used = 0;
#endif

    /*
     * 4. Char Cache Manager: Char_Tbl[], free_charcc[].
     */
    free_charcc = FARALLOC (MAX_CHAR_CACHE, fix16);
    for ( ii=0; ii<MAX_CHAR_CACHE; ii++ )    free_charcc[ii] = (fix16)ii;

    Char_Tbl = FARALLOC (MAX_CHAR_CACHE, struct Char_Tbl);

/*  PCH: replace flag RST_VM by PCH_R, Danny, 11/28/90 */
#ifdef PCH_R
    /* to De-precache Char Cache */
    n_char_cache = precache_hdr->n_char_cache;
    ii = n_char_cache * sizeof(struct Char_Tbl);
    if (ii!=0)  lmemcpy ((ubyte FAR *)Char_Tbl, deprecache_upto, ii); /*@WIN*/
    deprecache_upto += ii;

/*  PCH: Begin, Danny, 11/28/90 */
    /* Added for relocatable ROM area */
    for ( ii=0; ii<n_char_cache; ii++ )
        Char_Tbl[ii].bitmap += (ufix32)deprecache_upto;
/*  PCH: End, Danny, 11/28/90 */
#else
    n_char_cache = 0;
#endif

    n_char_compact = n_char_precache = n_char_cache;

    /* setup other char cache parameters. */
    ccb_space (&gp_cache_base, (fix32 far *)&gp_cache_size);

    /* @11/24/88+:
     *  round gp_cache_base up to word alignment.
     *  round gp_cache_end down to word alignment.
     *  available size = number of bytes within two rounded ends.
     */
    gp_cache_end  = gp_cache_base + gp_cache_size;  /* actual end */
//  gp_cache_base = WORD_ALIGN((ufix32)gp_cache_base); @WIN
//                  in Windows, global alloc always returns at word boundary
    gp_cache_size = (ufix32)((gp_cache_end - gp_cache_base) / sizeof(fix))
                        * sizeof(fix);      /* truncate to n_words first */

    gwb_space ((fix32 far *)&gp_workbufsize);
    cacheparams_ub = MIN (gp_workbufsize, CACHEPARAMS_UB);
    bmapcc_freeptr = gp_cache_base;
    bmapcc_actused = 0;
    cacheparams_lb = CACHEPARAMS_LB;    /* @03/17/89+ */
    gp_cache_end = gp_cache_base + gp_cache_size;   /* effective end */


    /*
     * 5. Name Cache Manager: on her own way.
     */

    /*  allocating fardata to N2CCmap[] for setfont ------ Kason 04/30/90 */
    /*  MAX_NAME_CACHE_MAP=400 defined in FNTCACHE.DEF                    */

    N2CCmap = FARALLOC(MAX_NAME_CACHE_MAP, struct N2CCmap_s);

    if ( N2CCmap== (struct N2CCmap_s far *)NULL )
       {
         printf(" Cann't get fardata in building name_cc table \n ");
         ERROR (UNDEFINEDRESULT);
       }

#ifdef SCSI

    /*
     * x. SCSI Font Cache
     */
    init_fontcache2();

#ifdef DBGovflw
{
/* debugging */

    fix         ii, matr_id;

    FOR_MATR_LATEST_2_OLDEST (ii)
        {
        matr_id = fcache_map[ii];
        printf("ii: % d, matr_id: %d, _ROMED: %d, _NONEMPTY: %d\n",
             ii, matr_id, IS_CLASS_ROMED(matr_id), IS_CLASS_NONEMPTY(matr_id) );        }
}
#endif

#endif    /* SCSI */

  END


/* ........................ pack_cached_data ......................... */

/*  PCH: replace flag SAVE_VM by PCH_S, Danny, 11/28/90 */
#ifdef PCH_S
/* collect pre cache data */

GLOBAL FUNCTION bool        pack_cached_data()

/* Descriptions:
 *  -- pack precached data of SAVE_VM version for later RST_VM.
 *  -- make FID of all the cached matrices be Strong ROM FID, and
 *          mark all the cache classed ROMed.
 * Notes:
 *  -- Any "printf" for debugging is INHIBITED here (in download version).
 *  -- BE CONSISENT with the de-precache steps in init_fontcache().
 */
  DECLARE
        fix         ii;
        ubyte      FAR *precache_upto;  /*@WIN*/
        ufix32      precache_size, table_size, oldfid;

  BEGIN

/* PCH: Begin, Danny, 11/28/90 */
    precache_hdr = (struct precache_hdr_s FAR *)(PRECACHE_BASE_S); /*@WIN*/
/* PCH: end, Danny, 11/28/90 */

    /* initialize addr. to precache tables */
    precache_upto = (ubyte FAR *)precache_hdr + sizeof(struct precache_hdr_s); /*@WIN*/

    precache_size = sizeof (struct precache_hdr_s);

    //DJC fix UPD051
    //                - sizeof (ufix16);  /* excluding the "size" entry */

    /* PreCache Matrix Cache */

        /* precondition check: fcache_map[] */
        for ( ii=0; ii<MAX_MATR_CACHE; ii++ )
            if (fcache_map[ii] != ii)  return (FALSE);

        /* size check */
        table_size = (ufix32)n_matr * sizeof(struct fontcache_s);
        if ((precache_size + table_size) > UMAX16)      return (FALSE);

        /* Mark all cached cache classes as ROMed and Make FID Strong ROMed */
        FOR_MATR_LATEST_2_OLDEST (ii)
            {
            /* need no "matr_id=fcache_map[ii]", since "ii=fcache_map[ii]" */
            oldfid = MATRCACHE_FID(ii);
            if (!IS_SR_FID(oldfid))
                {
                if ( !IS_SU_FID(oldfid) ||
                     (FONTTYPE_SUFID(oldfid) == FONTTYPE_USRDEF) )
                    return (FALSE);
                PUT_MATRCACHE_FID (ii, SU_2_SR_FID(oldfid));
                }
            SET_CLASS_ROMED (ii);
            };

    precache_hdr->n_matr = n_matr;
    if (table_size != 0)
        lmemcpy (precache_upto, (ubyte FAR *)FontCache_Tbl, (ufix)table_size); /*@WIN*/
    precache_upto += table_size;
    precache_size += table_size;

    /* PreCache CG Segments */

        /* precondition check: free_cgseg[] */
        for ( ii=0; ii<MAX_CGSEG; ii++ )
            if (free_cgseg[ii] != (ufix8)ii)    return (FALSE);

        /* size check */
        table_size = (ufix32)n_cgseg_used * N_CG_CGSEG * sizeof(ufix16);
        if ((precache_size + table_size) > UMAX16)      return (FALSE);

    precache_hdr->n_cgseg_used = n_cgseg_used;
    if (table_size != 0)
        lmemcpy (precache_upto, (ufix8 FAR *)cg, (ufix)table_size); /*@WIN*/
    precache_upto += table_size;
    precache_size += table_size;

    /* PreCache Char Cache */

        /* precondition check: free_charcc[] and ought to be compact */
        for ( ii=0; ii<MAX_CHAR_CACHE; ii++ )
            if (free_charcc[ii] != ii)  return (FALSE);
        if (n_char_compact != n_char_cache)     return (FALSE);

        /* size check */
        table_size = (ufix32)n_char_cache FAR * sizeof(struct Char_Tbl); /*@WIN*/
        if ((precache_size + table_size) > UMAX16)      return (FALSE);

/*  PCH: Begin, Danny, 11/28/90 */
    /* Added for relocatable ROM area */
    for ( ii=0; ii<n_char_cache; ii++ )
        Char_Tbl[ii].bitmap -= (ufix32)gp_cache_base;
/*  PCH: End, Danny, 11/28/90 */

    precache_hdr->n_char_cache = n_char_cache;
    if (table_size != 0)
        lmemcpy (precache_upto, (ufix8 FAR *)Char_Tbl, (ufix)table_size); /*@WIN*/
    precache_upto += table_size;
    precache_size += table_size;

    /* PreCache Cache Parameters */

        /* precondition check: bmapcc_actused, bmapcc_freeptr */
        if ((gp_cache_base + bmapcc_actused) != bmapcc_freeptr)
            return (FALSE);

    precache_hdr->gp_cache_base  = gp_cache_base;
    precache_hdr->gp_cache_size  = gp_cache_size;
    precache_hdr->gp_workbufsize = gp_workbufsize;
    precache_hdr->cacheparams_ub = cacheparams_ub;
    precache_hdr->bmapcc_freeptr = bmapcc_freeptr;
    precache_hdr->bmapcc_actused = bmapcc_actused;

    /* PreCache Bitmap Cache */

        /* size check */
        if ((precache_size + bmapcc_actused) > UMAX16)      return (FALSE);

/*  PCH: Begin, Danny, 11/28/90 */
/***********
    if (bmapcc_actused != 0)
        get_fontcache (gp_cache_base, precache_upto, (ufix)bmapcc_actused);
**********/
    if (bmapcc_actused != 0)
        lmemcpy (precache_upto, (ufix8 FAR *)gp_cache_base, (ufix)bmapcc_actused);
/*  PCH: End, Danny, 11/28/90 */

    precache_size += bmapcc_actused;

    /* FINALLY, write back the total size */
    precache_hdr->size = (ufix16)precache_size;

/*  PCH: Begin, Danny, 11/28/90 */
    printf("PreCache Action OK --\n");
    printf("  Begin Address:  %lx\n", precache_hdr);
    printf("  End   Address:  %lx\n", ((ufix32)precache_hdr - 1 +
                                       (ufix32)precache_hdr->size));
    printf("  Size (bytes) :  %x\n",  precache_hdr->size);
/*  PCH: End, Danny, 11/28/90 */


    return (TRUE);
  END

#endif

/* ........................ cachedbg ................................. */

#ifdef DBGcache

GLOBAL FUNCTION void        cachedbg()

/* Descriptions:
 *  -- to provide any useful information to debug cache mechanism.
 *  -- activated by op_cachestatus.
 */
  DECLARE
  BEGIN
    /* Anything you like to do can help debug */
  END

#endif

/* ....................... reinit_fontcache ......................... */

GLOBAL FUNCTION void       reinit_fontcache()

/* Descriptions:
 *  -- called right after init_1pp() in main() in start.c.
 */
  DECLARE
        fix         ii;
        ufix32      oldfid;
        struct object_def       FAR *fontdir; /*@WIN*/

  BEGIN


    /* have FID strong ROMed for all fonts in FontDir. */
    reinit_fid ();

    /* rebuild ROMfont_info[] */
    get_dict_value (systemdict, FontDirectory, &fontdir);
    init_gen_fid (fontdir);
    /* will cause some space useless allocated in 1st call to init_gen_fid() */

   /* have FID strong ROMed for all precached data */
   FOR_MATR_LATEST_2_OLDEST (ii)
        {
        /* need no "matr_id=fcache_map[ii]", since "ii=fcache_map[ii]" */
        oldfid = MATRCACHE_FID(ii);
        if (!IS_SR_FID(oldfid))
            {
            if ( !IS_SU_FID(oldfid) ||
                 (FONTTYPE_SUFID(oldfid) == FONTTYPE_USRDEF) )
                return;
            PUT_MATRCACHE_FID (ii, SU_2_SR_FID(oldfid));
            }
        SET_CLASS_ROMED (ii);
        };

  END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\fontgrap.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/**************************************************************/
/*							      */
/*	fontgrap.h		 10/9/87      Danny	      */
/*							      */
/**************************************************************/

#define    CTM		 (GSptr->ctm)
#define    LINEWIDTH	 (GSptr->line_width)

#define    NoCurPt()	 (F2L(GSptr->position.x) == NOCURPNT)
	     /* if currend point undefined */
#define    SetCurP_NA()  (path_table[GSptr->path].rf |= P_NACC)
	     /* Set current path NOACCESS */

	     /* current point */
#define    CURPOINT_X	 (GSptr->position.x)
#define    CURPOINT_Y	 (GSptr->position.y)

	     /* default translate */
#define    DEFAULT_TX	 (GSptr->device.default_ctm[4])
#define    DEFAULT_TY	 (GSptr->device.default_ctm[5])

	     /* current font dict object */
#define    current_font  (GSptr->font)

#define    CLIPPATH	 (GSptr->clip_path)

#ifdef KANJI
	     /* root font dict object */
#define    RootFont	 (GSptr->rootfont)
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\fontchar.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */

// DJC added global include
#include "psglobal.h"

#define    LINT_ARGS            /* @WIN */
#define    NOT_ON_THE_MAC       /* @WIN */
#define    KANJI                /* @WIN */
// DJC use command line #define    UNIX                 /* @WIN */
/*********************************************************************/
/*                                                                   */
/*      fontchar.c               10/9/87      Danny                  */
/*                                                                   */
/*********************************************************************/
/*
 * -------------------------------------------------------------------
 *  03/22/90 Danny  Add Type1, Type3, TypeSFNT constants
 *  03/26/90 You    allow FontBBox to be either ARRAYTYPE or PACKEDARRAYTYPE in
 *                     get_CF_info().
 *  05/14/90 BYou   set GSptr->currentfont to the actual current font before
 *                     calling __qem_restart() in get_CF_info(), and comment
 *                     out the actual setfont operation do_setfont().
#ifdef SCSI
 *  06/29/90  Ada   add code for SCSI font cache
#endif
 *      10/9/90, Danny   CFT: fix the bug for abnormal case of setfont
 *     11/17/90  DSTseng @BBOX To get large enough bbox for acche.
 *     12/11/90, Danny   calling op_grestore after calling get_cf() in error
 *                       to fix the bug for CTM error (ref. GCT:)
#ifdef WINF
 *  03/20/91 ccteng add code related to strblt
#endif
 *  04/12/91 Danny  FIX bug for showing within a showing    (ref: SOS:)
 *  04/15/91 Ada    Fix bug for kshow (ref:KSH )
 *  04/30/91 Phlin  Fix bug for missing char (ref: 2Pt)
 *  05/02/91 Kason  Fix bug for re-building CharStrings in typ1 download font
 *                  (ref : RCD)
 *  05/10/91 Phlin  Add do_transform flag used in make_path (ref: DTF)
 *  05/15/91 Kason  Add code for downloading "TrueType PostScript Font Format"
 *                  (ref : DLF42)
 *  07/28/91 YM     Fix bug for update Emunits when download fonts(ref Emunits)
 *  11/05/91 YM     Fix bug for charpath stroke within a show (ref YM@SCP)
 * -------------------------------------------------------------------
 */

#define    FONTCHAR_INC
#define    LINT_ARGS                    /* @WIN */

#include   <stdio.h>
#include   <math.h>
#include   <string.h>           /* for strlen(), memcpy() */

#include   "define.h"         /* Peter */
#include   "global.ext"
#include   "graphics.h"
#include   "graphics.ext"

#include   "font_sys.h"
#include   "fontgrap.h"
#include   "fontkey.h"
#include   "fontdict.h"
#include   "fontshow.h"

#include    "warning.h"

#include   "fontinfo.def"

#include   "fontqem.ext"
#include   "fontmain.ext"
#include   "fntcache.ext"

// DJC
// this is included in fontmain.ext ... not necessary
// #include   "fontfunc.ext"


/* erik chen, 1-9-1991 */
#include   "language.h"
#ifdef SETJMP_LIB
#include <setjmp.h>
#else
#include "setjmp.h"
#endif
//#include   "..\..\..\bass\work\source\FSCdefs.h"      @WIN
//#include   "..\..\..\bass\work\source\FontMath.h"
//#include   "..\..\..\bass\work\source\sfnt.h"
//#include   "..\..\..\bass\work\source\fnt.h"
//#include   "..\..\..\bass\work\source\sc.h"
//#include   "..\..\..\bass\work\source\FScaler.h"
//#include   "..\..\..\bass\work\source\FSglue.h"
#include   "..\bass\FSCdefs.h"
#include   "..\bass\FontMath.h"
#include   "..\bass\sfnt.h"
#include   "..\bass\fnt.h"
#include   "..\bass\sc.h"
#include   "..\bass\FScaler.h"
#include   "..\bass\FSglue.h"

#ifdef KANJI
#include   "mapping.h"
#endif

#include   "stdio.h"

/* external function for Dynamic Font Allocation; @DFA 7/9/92 */
#include   "wintt.h"

/* EXTERNAL routines */
#ifdef  LINT_ARGS
extern  void  get_fontdata(ufix32, ubyte huge *, ufix); /*@WIN 04-20-92 */
extern  void  imagemask_shape(ufix);
extern  void  build_name_cc_table (struct object_def FAR *, ufix8) ; /*@WIN*/
extern  void  SetupKey(fsg_SplineKey FAR *, ULONG_PTR); /* YM @WIN*/
extern  void  sfnt_DoOffsetTableMap(fsg_SplineKey FAR *);  /* YM @WIN*/
extern  void  FAR *sfnt_GetTablePtr(fsg_SplineKey FAR *, sfnt_tableIndex, boolean);      /* YM @WIN*/
#    ifdef  SFNT
extern  fix   rc_CharPath(void);
#    endif
#else
extern  void  get_fontdata();
extern  void  imagemask_shape();
extern  void  build_name_cc_table () ;
extern  void  SetupKey(); /* Jul-30,91 YM */
extern  void  sfnt_DoOffsetTableMap();  /* YM */
extern  void  *sfnt_GetTablePtr();      /* YM */
#    ifdef  SFNT
extern  fix   rc_CharPath();
#    endif
#endif


/* STATIC routines */
#ifdef  LINT_ARGS
static bool near chk_show(ufix, fix);
static bool near do_show(ufix, fix, struct object_def FAR *); /*@WIN*/
static bool near show_a_char(ubyte FAR *, ufix, fix, struct object_def FAR *); /*@WIN*/
static void near CTM_trans(real32 FAR *, real32 FAR *); /*@WIN*/
static bool near kshow_proc(ubyte FAR *, struct object_def FAR *,
                              struct object_def FAR *, ufix32 FAR *); /*@WIN*/
#ifdef KANJI
static bool near cshow_proc(ubyte FAR *, struct object_def FAR *,
                              struct object_def FAR *, ufix32 FAR *); /*@WIN*/
#endif
static bool near show_from_cache(ufix8);
static bool near width_from_cache(ufix8);
static bool near show_builtin(ufix8);
static bool near show_userdef(ufix8);
static fix  near font_soft(ufix);               /* return 0, 1, 2, 3 */
static void near get_metrics(long32, real32 FAR *, real32 FAR *); /*@WIN*/
#ifdef KANJI
static void near get_metrics2(real32 FAR *, real32 FAR *, real32 FAR *, real32 FAR *); /*@WIN*/
static fix31 near match_char(ubyte, ufix, ubyte);
#endif
#ifdef WINF /* 3/20/91 ccteng */
static fix  near get_win(struct object_def FAR *, struct f_info FAR *); /*@WIN*/
#endif

static fix  near get_ps(struct object_def FAR *, struct f_info FAR *); /*@WIN*/
static bool near get_cf(void);
static bool near is_rbuild_name_cc(void) ; /*RCD*/

#else
static bool near chk_show();
static bool near do_show();
static bool near show_a_char();
static void near CTM_trans();
static bool near kshow_proc();
#ifdef KANJI
static bool near cshow_proc();
#endif
static bool near show_from_cache();
static bool near width_from_cache();
static bool near show_builtin();
static bool near show_userdef();
static fix  near font_soft( );
static void near get_metrics( );
#ifdef KANJI
static void near get_metrics2( );
static fix31 near match_char();
#endif
#ifdef WINF /* 3/20/91 ccteng */
static fix  near get_win();
#endif

static fix  near get_ps( );
static bool near get_cf();
static bool near is_rbuild_name_cc() ; /*RCD*/
#endif

/* EXTERNAL variables */
extern struct char_extent   near bmap_extnt;
extern ufix16                    pre_len ;      /*RCD*/
extern ufix32                    pre_checksum ; /*RCD*/
extern struct dict_head_def     FAR *pre_cd_addr  ; /*RCD @WIN*/
extern int                       EMunits; /* GAW */
/* add by Falco, 11/20/91 */
extern char                     FAR *SfntAddr; /*@WIN*/
/* add end */


/* GLOBAL variables */
struct f_info near    FONTInfo; /* union of current font information */
struct object_def near BC_font; /* current BuildChar font, */
bool    near setc_flag = NO_ANY_SETC;/* setcachedevice or setcharwidth */
real32  near cxx, near cyy; /* current point */
fix     near buildchar = 0;      /* level of buildchar */
int     near do_transform;       /* flag of redoing NewTransformation, DTF */
#ifdef WINF
/* 3/21/91 ccteng, bring them out from do_show */
real32  ax, ay, cx, cy;

/* there are new for text justification */
static bool fBE = FALSE;        /* text justification flag */
static real32 dxBreak;          /* break extra */
static real32 tBreak;           /* total break extra */
static ubyte breakChar;         /* break character */
static bool esc;                /* escapement flag */
static real32 mxE[4];           /* rotation matrix */
bool   near f_wininfo;
#endif

/* STATIC variables */
static ufix32  near pre_font;      /* previous current font */
static fix     near pre_error;     /* error code for current font */
static bool    near pre_BC_UNDEF;  /* BuildChar Undefined flag for FontType 3 */

/* show operators, op_charpath, op_stringwidth */
static bool    near bool_charpath; /* boolean value for current charpath op */
static fix     near show_type;     /* call from SHOW, CHARPATH or STRINGWIDTH*/
static fix     near charpath_flag = 0;  /* level of charpath operation */
static ubyte   near CurWmode = 0;  /* current Wmode */
bool   near         MUL4_flag  ;   /* set in GrayMode and not run Charpath */
static bool    near do_name_cc ;   /* RCD */

static struct object_def FAR *  near CurKey;  /* current key object @WIN*/
static ufix16  near name_cacheid; /* Name Cache ID */

/* font_soft() */
static struct object_def  FAR * near c_metrics;  /* metrics for a char @WIN*/
#ifdef KANJI
static struct object_def  FAR * near c_metrics2;  /* metrics2 for a char @WIN*/
#endif

/* setcachedevice(), setcharwidth() */
fix   near cache_dest = F_TO_PAGE; /* cache destination -- NULL,
                                             FILL_TO_CACHE, FILL_TO_PAGE */
static bool  near cache_put;  /* put cache info into cache or not */
static bool  near clip_flag = FALSE;    /* clip or not */
static struct Char_Tbl  near Bitmap;    /* cache info */

/* get_cf() */
bool   near change_f_flag = TRUE;/* change font flag */

static fix16  near cacheclass_id;       /* Cache Class ID */
static real32 near ctm_fm[6];           /* current matrix for char */
static real32 near ctm_cm[6];           /* current matrix for cache */
static real32 near ctm_tm[6]= {(real32)0., (real32)0., (real32)0.,
                               (real32)0., (real32)0., (real32)0.};
                                        /* temp current matrix */

/* data set in get_f_info(), get_ps() */
/* private, charstrings are in file fontmain.def */
static struct object_def near   pre_obj;        /* pre_object for UNDEFINED */
static real32            near   scale_matrix[6];/* font matrix -- FontMatrix */
static fix   near  paint_flag;/* 0 -- normal
                             * 1 -- painttype = 1,2
                             */
real32       near   FONT_BBOX[4]; /* font bounding box */


/* 5.3.3.2 Show character module
 *
 * This module is used to show a character(SHOW) or get a character
 * path(CHARPATH) or get the character width(STRINGWIDTH). And it will
 * cache the character if necessary.
 *
 * 5.3.3.2.1 show_a_char
 */


/* show group operation -- show, ashow, widthshow, awidthshow, kshow */

void    __show(show_flag, no_opr, ob)
ufix    show_flag;
fix     no_opr;
struct object_def  FAR ob[]; /*@WIN*/
{
    fix     t_show_type;    /* call from SHOW or STRINGWIDTH */
#ifdef KANJI
    ubyte   t_CurWmode;
#endif

#ifdef DBG
    printf("Enter __show()\n");
#endif

/* Check error cases */

    if (!chk_show(show_flag, no_opr))
        return;
#ifdef KANJI
    t_CurWmode = CurWmode;
#endif

/* do the Show string action */

    if (buildchar)        t_show_type = show_type;
    show_type = SHOW;

    do_show(show_flag, no_opr, ob);

    if (buildchar)        show_type = t_show_type;
#ifdef KANJI
    CurWmode = t_CurWmode;
#endif

} /* __show() */


/* charpath operation */

void    __charpath()
{
    struct object_def  ob[2];
    struct sp_lst      t_path;
    bool    t_bool_charpath;/* boolean value for current charpath operation */
    real32  t_cxx, t_cyy;   /* added for save current point x & y YM@SCP */
    fix     t_show_type;    /* call from SHOW or STRINGWIDTH YM@SCP */
#ifdef KANJI
    ubyte                t_CurWmode;
#endif

/* Check error cases */

    if (!chk_show((ufix)CHARPATH_FLAG, 2))
        return;
#ifdef KANJI
    t_CurWmode = CurWmode;
#endif

/* do the charpath action */

    if (buildchar) {
        t_cxx = cxx;                    /* save current point x YM@SCP */
        t_cyy = cyy;                    /* save current point y YM@SCP */
        t_show_type = show_type;        /* save current show_type YM@SCP */
        t_path.head = path.head;
        t_path.tail = path.tail;
        t_bool_charpath = bool_charpath;
    }
    show_type = CHARPATH;               /* for charpath within show YM@SCP */
    ++charpath_flag;
    path.head = path.tail = NULLP;

    do_show((ufix)CHARPATH_FLAG, 2, ob);

    if (path.head != NULLP) {

        /* Append Character Path */
        append_path(&path);

        /* Put NOACCESS attribute into the header of the current path; */
        SetCurP_NA();
    }

    if (buildchar) {  /* move this condition before current point changed YM@SCP */
        cxx = t_cxx;                /* restore current point x YM@SCP */
        cyy = t_cyy;                /* restore current point y YM@SCP */
        show_type = t_show_type;    /* restore current show_type YM@SCP */
        path.head = t_path.head;
        path.tail = t_path.tail;
        bool_charpath = t_bool_charpath;
    }

    /*  change current point directly instead of moveto operation */
    CURPOINT_X = cxx;       /* 09/15/88: moved out of then-part of   */
    CURPOINT_Y = cyy;       /*  "if (path.head != NULLP)" predicate. */

    --charpath_flag;
#ifdef KANJI
    CurWmode = t_CurWmode;
#endif

} /* op_charpath() */

void    __stringwidth()
{
    struct object_def  ob[1];
    real32  t_cxx, t_cyy;
    fix     t_show_type;    /* call from SHOW or STRINGWIDTH */
    bool    j;
#ifdef KANJI
    ubyte   t_CurWmode;
#endif


/* Check error cases */

    if (!chk_show((ufix)STRINGWIDTH_FLAG, 1))
        return;
#ifdef KANJI
    t_CurWmode = CurWmode;
#endif


    if (buildchar) {
        t_cxx = cxx;
        t_cyy = cyy;

        t_show_type = show_type;
    }
    show_type = STRINGWIDTH;

/* do the stringwidth action */

    j = do_show((ufix)STRINGWIDTH_FLAG, 1, ob);

    if (j) {
        struct coord  FAR *ww; /*@WIN*/
        real32        tx, ty;

        tx = CTM[4];
        ty = CTM[5];
        CTM[4] = zero_f;
        CTM[5] = zero_f;
        ww = inverse_transform(F2L(cxx), F2L(cyy));
        CTM[4] = tx;
        CTM[5] = ty;
        if (ANY_ERROR()) {
            PUSH_OBJ(&ob[0]);
        }
        else {
/* Push x, y value of the string width vector onto the operand stack; */
            PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, F2L(ww->x));
            PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, F2L(ww->y));
        }
    }

    if (buildchar) {
        cxx = t_cxx;
        cyy = t_cyy;
        show_type = t_show_type;
    }
#ifdef KANJI
    CurWmode = t_CurWmode;
#endif

} /* op_stringwidth() */


#ifdef KANJI
/* cshow operation */

void    __cshow()
{
    struct object_def  ob[2];
    real32  t_cxx, t_cyy;
    fix     t_show_type;    /* call from SHOW or STRINGWIDTH */
    ubyte   t_CurWmode;

/* Check error cases */

    if (!chk_show((ufix)CSHOW_FLAG, 2))
        return;
    t_CurWmode = CurWmode;

    if (buildchar) {
        t_cxx = cxx;
        t_cyy = cyy;

        t_show_type = show_type;
    }
    show_type = STRINGWIDTH;

/* do the stringwidth action */

    do_show((ufix)CSHOW_FLAG, 2, ob);

    if (buildchar) {
        cxx = t_cxx;
        cyy = t_cyy;
        show_type = t_show_type;
    }
    CurWmode = t_CurWmode;

} /* __cshow() */
#endif


/* check error cases in show group operators */

static bool near    chk_show(show_flag, no_opr)
ufix    show_flag;
fix     no_opr;
{

/* Check current point */

    if ( !(show_flag & F_BIT)) {
        if ( NoCurPt() ) {   /* current point undefined */
            ERROR(NOCURRENTPOINT); /* Return with 'nocurrentpoint' error */
            return(FALSE);
        }
    }

/* Check current font dictionary */

#if 0 /* Kason 4/18/91 */
    if (TYPE(&current_font) !=DICTIONARYTYPE) { /* current font undefined */
        ERROR(INVALIDACCESS);
        return(FALSE);
    }
#endif
    {
       struct dict_head_def  FAR *h; /*@WIN*/
       h = (struct dict_head_def FAR *)VALUE(&current_font);    /*@WIN*/
       if (DFONT(h) == 0) {    /* current font undefined */
           ERROR(INVALIDFONT);
           //DJC return(-1);
           //DJC fix from history.log UPD036
           return(FALSE);
       }
    }

/* if error occurred while font set */

    if (pre_error && !pre_BC_UNDEF) {
        if (pre_error == UNDEFINED) {
            POP(no_opr);
            PUSH_OBJ(&pre_obj);
        }
        ERROR(((ufix16)(pre_error)));
        return(FALSE);
    }

/* Check operand stack */

    if (show_flag == STRINGWIDTH_FLAG) {
        if (FRCOUNT() < 1) {  /* free count of operand stack */
            ERROR(STACKOVERFLOW); /* Return with 'stackoverflow' error */
            return(FALSE);
        }
    }

    /* check string access, erik chen, 1-9-1991 */
    if (ACCESS_OP(0) == NOACCESS) {
        ERROR(INVALIDACCESS);
        return(FALSE);
    }

    return(TRUE);
} /* chk_show() */


/* do the show operation */

static bool near    do_show(show_flag, no_opr, ob)
ufix    show_flag;
fix     no_opr;
struct object_def  FAR ob[];    /*@WIN*/
{

    ubyte   FAR *s; /*@WIN*/
    fix     str_length;
    register    fix     i, k;

#ifndef WINF /* 3/21/91 ccteng, make them global */
    real32  ax=0, ay=0, cx=0, cy=0;
#endif
    fix31   ll=0;
    ufix8   ch;

    ufix32  k_pre_font;     /* previous current font for k show */
    struct object_def   FAR *proc; /*@WIN*/

#ifdef KANJI
    struct map_state     map_state;
    struct code_info     code_info;
#endif

#ifdef DBG
    printf("Enter do_show()\n");
#endif

/* Show string */

    if (show_flag & F_BIT) {   /* stringwidth or cshow */

        cxx = cyy = zero_f;
    }
    else {
        cxx = CURPOINT_X;
        cyy = CURPOINT_Y;
    }

    k = 0;

/* for charpath operator */

    if (show_flag == CHARPATH_FLAG) {
        bool_charpath = (bool)VALUE(GET_OPERAND(k));
        k++;
    }

/* get string from operand stack */

    if (!(str_length=LENGTH(GET_OPERAND(k))) ) { /* string is NULL */

        POP(no_opr); /* Pop 1 entries off the operand stack; */

        if (show_flag == STRINGWIDTH_FLAG) {
                 /* Push 0, 0 onto the operand stack; */
            PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, F2L(zero_f));
            PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, F2L(zero_f));
        }

        return(FALSE);
    }
    s = (ubyte FAR *)VALUE(GET_OPERAND(k)); /*@WIN*/
    k++;

/* calculate the (ax, ay)  or  (cx, cy) */

#ifdef WINF /* 3/21/91 ccteng */
    if ((show_flag & A_BIT) && !(show_flag & X_BIT)) {   /* ashow action bit */
#else
    if (show_flag & A_BIT) {   /* ashow action bit */
#endif
        cal_num((struct object_def FAR *)GET_OPERAND(k), (long32 FAR *)&ay); /*@WIN*/
        k++;
        cal_num((struct object_def FAR *)GET_OPERAND(k), (long32 FAR *)&ax); /*@WIN*/
        k++;
        CTM_trans(&ax, &ay);   /* multiply CTM */
    }
    if (show_flag & W_BIT) {   /* widthshow action bit */
#ifdef WINF /* 3/21/91 ccteng */
      if (show_flag & X_BIT) {   /* strblt action bit */
        ch = breakChar;
      } else {
#endif
        cal_integer((struct object_def FAR *)GET_OPERAND(k), &ll); /*@WIN*/
        ch = (ufix8)(ll % 256);
        k++;

        cal_num((struct object_def FAR *)GET_OPERAND(k), (long32 FAR *)&cy); /*@WIN*/
        k++;
        cal_num((struct object_def FAR *)GET_OPERAND(k), (long32 FAR *)&cx); /*@WIN*/
        k++;

        CTM_trans(&cx, &cy);   /* multiply CTM */
#ifdef WINF
      } /* if-else */
#endif
    }
    if (show_flag & K_BIT) {   /* kshow action bit */
#ifdef KANJI
        if (FONT_type(&FONTInfo) == 0) {  /* Composite Font */
            ERROR(INVALIDFONT);
            return(FALSE);
        }
#endif
        proc = &ob[k];

        k_pre_font = pre_font;
    }

#ifdef KANJI
    if (show_flag & C_BIT) {   /* cshow action bit */
        proc = &ob[k];
        k_pre_font = pre_font;
    }


/* init_mapping for composite font */

   /* KSH ; 4/15/91 */
    code_info.code_addr = &(code_info.code[0]);

    if (!init_mapping(&map_state, s, str_length))
        return(FALSE);

    CurWmode = map_state.wmode;
#endif

    op_gsave();  /* Call gsave operator; */

    for (i=0; i<no_opr; i++)
        COPY_OBJ(GET_OPERAND(i), &ob[i]);
    POP(no_opr);

#ifdef KANJI

#ifdef DBG2
    printf("Bef mapping: error = %d\n", ANY_ERROR());
#endif
    while (mapping(&map_state, &code_info))
    {
     /*RCD-begin*/
     {
     struct dict_head_def FAR *h ; /*@WIN*/
     h = (struct dict_head_def FAR *)(CHARstrings(&FONTInfo)) - 1; /*@WIN*/
#ifdef DJC // Fix from history.log UPD040
     if (do_name_cc) {
        if ( h!=pre_cd_addr )
           build_name_cc_table ( &current_font,(ufix8)FONT_type(&FONTInfo) );
        do_name_cc = FALSE ;
     } else {
          if ( (FONT_type(&FONTInfo)==1) && (!DROM(h)) ) { /* Type1 download font */
              if(is_rbuild_name_cc())
                 build_name_cc_table ( &current_font,(ufix8)FONT_type(&FONTInfo) );
          }/*if*/
     }/*if*/
#endif //Fix from history.log UPD040

     if (do_name_cc) {
        /* if ( h!=pre_cd_addr )
         *    In Type 1 download, the chars were incrementally downloaded. The
         *    condition of re-build character cache table should check if the
         *    number of chars was changed as well; can not just check if using
         *    the same font; @WIN
         */
        if ( h!=pre_cd_addr || h->actlength != pre_len)
           build_name_cc_table ( &current_font,(ufix8)FONT_type(&FONTInfo) );
        do_name_cc = FALSE ;
     } else {
          if ( (FONT_type(&FONTInfo)==1) && (!DROM(h)) ) { /* Type1 download font */
              if(is_rbuild_name_cc())
                 build_name_cc_table ( &current_font,(ufix8)FONT_type(&FONTInfo) );
          }/*if*/
     }/*if*/
     }
     /*RCD-end*/

#ifdef DBG1
    printf("Aft mapping: error = %d\n", ANY_ERROR());
#endif
    str_length = code_info.byte_no;

 /* KSH 4/15/91
  * s = &(code_info.code[0]);
  */
    s = code_info.code_addr ;

    if (map_state.idex)    /* for composite font only */
    {
        float mtx[6];

        mul_matrix(mtx, scale_matrix,
                map_state.finfo[map_state.idex-1].scalematrix);
        lmemcpy ((ubyte FAR *)scale_matrix, (ubyte FAR *)mtx, 6*sizeof(real32)); /*@WIN*/
        mul_matrix(mtx, FONT_matrix(&FONTInfo),
                map_state.finfo[map_state.idex-1].scalematrix);
        lmemcpy ((ubyte FAR *)FONT_matrix(&FONTInfo), (ubyte FAR *)mtx, 6*sizeof(real32)); /*@WIN*/
    }
#ifdef DBG2
    printf("\nscale_matrix....\n");
    printf("  %f  %f  %f  %f  %f  %f\n", scale_matrix[0], scale_matrix[1],
        scale_matrix[2], scale_matrix[3], scale_matrix[4], scale_matrix[5]);
    printf("\nFONT_matrix(&FONTInfo)....\n");
    printf("  %f  %f  %f  %f  %f  %f\n", FONT_matrix(&FONTInfo)[0],
        FONT_matrix(&FONTInfo)[1],
        FONT_matrix(&FONTInfo)[2], FONT_matrix(&FONTInfo)[3],
        FONT_matrix(&FONTInfo)[4], FONT_matrix(&FONTInfo)[5]);
#endif

#endif

/* Get current font information related to current matrix */

    if (!get_cf()) {
        if (!ANY_ERROR()) {
            if (show_flag == STRINGWIDTH_FLAG) {
                PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, (ufix32)INFINITY);
                PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, (ufix32)INFINITY);
            }
        }
        else {
            for (i=no_opr - 1; i>=0; i--)
                PUSH_OBJ(&ob[i]);
        }

        op_grestore();
        return(FALSE);
    }
#ifdef DBG2
    printf("\nctm_fm....\n");
    printf("  %f  %f  %f  %f  %f  %f\n", ctm_fm[0], ctm_fm[1],
        ctm_fm[2], ctm_fm[3], ctm_fm[4], ctm_fm[5]);
    printf("\nctm_cm....\n");
    printf("  %f  %f  %f  %f  %f  %f\n", ctm_cm[0], ctm_cm[1],
        ctm_cm[2], ctm_cm[3], ctm_cm[4], ctm_cm[5]);
#endif

    /* save patrial graphic state */
    lmemcpy ((ubyte FAR *)(CTM), (ubyte FAR *)ctm_fm, 6*sizeof(real32)); /*@WIN*/


    for (i=0; i<str_length; i++, s++) {

        if ((show_flag & K_BIT) && i) { /*KSH*/
                        /* kshow action bit */
            if (!kshow_proc(s, ob, proc, &k_pre_font))   /* execute proc */
                return(FALSE);
        }
        if (!show_a_char(s, show_flag, no_opr, ob))   /* show one character */
            return(FALSE);

/* Update Current point */
/* Current point <-- Current point + character advance vector
      + [ax ay] + [cx cy]; */

        if (show_flag & A_BIT) {
            cxx += ax;
            if (F2L(ay) != F2L(zero_f))     cyy += ay;
        }
#ifdef KANJI
        if (show_flag & C_BIT) {
            if (!cshow_proc(s, ob, proc, &k_pre_font))   /* execute proc */
                return(FALSE);
        }
#endif
        if (show_flag & W_BIT) {
#ifdef KANJI
            if (code_info.fmaptype) {
                if(ll == match_char(code_info.fmaptype,code_info.font_nbr,*s)){
                        cxx += cx;
                        if (F2L(cy) != F2L(zero_f))  cyy += cy;
                }
            }
            else {
                if (ch == *s) {
                        cxx += cx;
                        if (F2L(cy) != F2L(zero_f))  cyy += cy;
                }
            }
#else
            if (ch == *s) {
                cxx += cx;
                if (F2L(cy) != F2L(zero_f))  cyy += cy;
            }
#endif
        }
    } /* for */

#ifdef KANJI
    op_grestore();
    if (show_flag & M_BIT)        moveto(F2L(cxx), F2L(cyy));
    op_gsave();
    } /* while */
#endif

    op_grestore();
    if (show_flag & M_BIT)        moveto(F2L(cxx), F2L(cyy));

#ifdef KANJI
    if (ANY_ERROR())    return(FALSE);
    else
#endif

    return(TRUE);

} /* do_show() */


/* show a character */

static bool near    show_a_char(s, show_flag, no_opr, ob)
ubyte   FAR *s; /*@WIN*/
ufix    show_flag;
fix     no_opr;
struct object_def  FAR ob[];    /*@WIN*/
{
    register    fix     i;
    register    bool    j;


    /* @WINTT; */
    // DJC void TTLoadChar (int nChar);
    void TTLoadChar (fix nChar);

#ifdef DBG
    printf("show_a_char -- %d\n", (fix)*s);
#endif


    TTLoadChar ((fix)*s);

    j = (buildchar || !(show_flag & H_BIT) || pre_BC_UNDEF) ?
                                                 /* get from cache ? */
           FALSE : ( (show_flag & F_BIT) ?       /* what to get cache ? */
           width_from_cache((ufix8)(*s)) : show_from_cache((ufix8)(*s)) );

    if ( !j ) {

#ifdef KANJI
        /* get current key */
        CurKey = &(ENCoding(&FONTInfo)[*s]);
#endif

        /* @+ 10/08/88 ... */
        if (IS_BUILTIN_BASE(FONT_type(&FONTInfo)))
            j = show_builtin((ufix8)(*s));  /* builtin font */
        else if (FONT_type(&FONTInfo) == Type3)
            j = show_userdef((ufix8)(*s));  /* user-defined font */
        else
            j = 1;  /* error */

        if (j) { /* error occurred */
            op_grestore();
            moveto(F2L(cxx), F2L(cyy));
            if (ANY_ERROR() && !pre_BC_UNDEF) {
                for (i=no_opr - 1; i>=0; i--)
                    PUSH_OBJ(&ob[i]);
            }
            return(FALSE);
        } /* if (j) */
    } /* if (!j) */

    return(TRUE);
} /* show_a_char */


/* (x, y) * CTM */

static void near    CTM_trans(x, y)
real32  FAR *x, FAR *y; /*@WIN*/
{
    real32  tt;

    tt = (F2L(CTM[1]) == F2L(zero_f)) ?  zero_f : (*x * CTM[1]);
    *x *= CTM[0];
    if (F2L(*y) != F2L(zero_f)) {
        tt += *y * CTM[3];
        if (F2L(CTM[2]) != F2L(zero_f))
            *x += *y * CTM[2];
    }
    *y = (F2L(tt) == F2L(zero_f)) ?  zero_f : tt;
} /* CTM_trans() */

#ifdef KANJI
/* execute the procedure of cshow */

static bool near    cshow_proc(s, ob, proc, k_pre_font)
ubyte   FAR *s; /*@WIN*/
struct object_def  FAR ob[]; /*@WIN*/
struct object_def   FAR *proc; /*@WIN*/
ufix32  FAR *k_pre_font;     /* previous current font for k show @WIN*/
{
    struct coord  FAR *ww;      /*@WIN*/
    real32    tx, ty;

    tx = CTM[4];
    ty = CTM[5];
    CTM[4] = zero_f;
    CTM[5] = zero_f;
    ww = inverse_transform(F2L(cxx), F2L(cyy));
    CTM[4] = tx;
    CTM[5] = ty;
    if (ANY_ERROR())        return(FALSE);

    /* Push the char code & width vector onto the operand stack; */
    if (FRCOUNT() < 1) { ERROR(STACKOVERFLOW); return(FALSE);  }
    PUSH_VALUE(INTEGERTYPE, UNLIMITED, LITERAL, 0, (ufix32)(*s));
    if (FRCOUNT() < 1) { ERROR(STACKOVERFLOW); return(FALSE);  }
    PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, F2L(ww->x));
    if (FRCOUNT() < 1) { ERROR(STACKOVERFLOW); return(FALSE);  }
    PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, F2L(ww->y));

/* execute proc; */

    op_grestore();

    if (interpreter(proc)) {
        return(FALSE);
    }

    if (*k_pre_font != pre_font) {   /* font changed in the procedure */

/* Check current font dictionary */

        if (TYPE(&current_font) !=DICTIONARYTYPE) { /* current font undefined */            ERROR(INVALIDACCESS);
            return(FALSE);
        }

/* if error occurred while font set */

        if (pre_error && !pre_BC_UNDEF) {
            if (pre_error == UNDEFINED)
                PUSH_OBJ(&pre_obj);
            ERROR(((ufix16)(pre_error)));
            return(FALSE);
        }

        *k_pre_font = pre_font;
    }

    if (!get_cf()) {
        if (ANY_ERROR()) {
            PUSH_OBJ(&ob[1]);
            PUSH_OBJ(&ob[0]);
        }
        return(FALSE);
    }

    op_gsave();
    lmemcpy ((ubyte FAR *)(CTM), (ubyte FAR *)ctm_fm, 6*sizeof(real32)); /*@WIN*/

    cxx = cyy = zero_f;

    return(TRUE);
} /* cshow_proc() */
#endif



/* execute the procedure of kshow */

static bool near    kshow_proc(s, ob, proc, k_pre_font)
ubyte   FAR *s; /*@WIN*/
struct object_def  FAR ob[];    /*@WIN*/
struct object_def   FAR *proc;  /*@WIN*/
ufix32  FAR *k_pre_font;     /* previous current font for k show @WIN*/
{
    fix     t_show_type;

/* Push previous character code onto the operand stack; */
    if (FRCOUNT() < 1) { ERROR(STACKOVERFLOW); return(FALSE);  }
    PUSH_VALUE(INTEGERTYPE, UNLIMITED, LITERAL, 1, (ufix32)(*(s - 1)));

/* Push current character code onto the operand stack; */
    if (FRCOUNT() < 1) { ERROR(STACKOVERFLOW); return(FALSE);  }
    PUSH_VALUE(INTEGERTYPE, UNLIMITED, LITERAL, 1, (ufix32)(*s));

/* execute proc; */

    op_grestore();
    moveto(F2L(cxx), F2L(cyy));

    t_show_type = show_type;
    if (interpreter(proc)) {
        show_type = t_show_type;
        return(FALSE);
    }
    show_type = t_show_type;

/* Check current point */

    if ( NoCurPt() ) {   /* current point undefined */
        ERROR(NOCURRENTPOINT); /* Return with 'nocurrentpoint' error */
        return(FALSE);
    }

    if (*k_pre_font != pre_font) {   /* font changed in the procedure */

/* Check current font dictionary */

        if (TYPE(&current_font) !=DICTIONARYTYPE) { /* current font undefined */
            ERROR(INVALIDACCESS);
            return(FALSE);
        }

/* if error occurred while font set */

        if (pre_error && !pre_BC_UNDEF) {
            if (pre_error == UNDEFINED)
                PUSH_OBJ(&pre_obj);
            ERROR(((ufix16)(pre_error)));
            return(FALSE);
        }

        *k_pre_font = pre_font;
    }

    if (!get_cf()) {
        if (ANY_ERROR()) {
            PUSH_OBJ(&ob[1]);
            PUSH_OBJ(&ob[0]);
        }
        return(FALSE);
    }

/* save patrial graphic state */

    cxx = CURPOINT_X;
    cyy = CURPOINT_Y;

    op_gsave();
    lmemcpy ((ubyte FAR *)(CTM), (ubyte FAR *)ctm_fm, 6*sizeof(real32)); /*@WIN*/

    return(TRUE);
} /* kshow_proc() */


/* show char from cache -- this is not for CHARPATH/STRINGWIDTH */

static bool near    show_from_cache(code)
ufix8   code;         /* character code */
{

#ifdef DBG
    printf("show_from_cache: %c(%x)\n", code, code);
#endif

    /* get name cache id */
    if (!get_name_cacheid ((ufix8)FONT_type(&FONTInfo), ENCoding(&FONTInfo),
                            code, &name_cacheid))
        return(TRUE);   /* not found */

/* Is the character in cache already? */
#ifdef SCSI
    /* FALSE, not width required only */
    if (is_char_cached (cacheclass_id, name_cacheid, &cache_info,
                                                     (bool)FALSE)) {
#else
    if (is_char_cached (cacheclass_id, name_cacheid, &cache_info)) {
#endif

/* Show the character */
/* show_type is not CHARPATH AND char bitmap is in cache */
/* setup cache information for filling */

#ifdef DBG
    printf("\nshow_from_cache: buildchar=%d\n", buildchar);
    printf("cxx = %f, cyy = %f\n", cxx, cyy);
    printf("cache_info:\n");
    printf("ref_x = %d, ref_y = %d, box_w = %d, box_h = %d\n",
 cache_info->ref_x, cache_info->ref_y, cache_info->box_w, cache_info->box_h);
    printf("adv_x = %f, adv_y = %f, bitmap = %lx\n",
            cache_info->adv_x, cache_info->adv_y, cache_info->bitmap);
#endif

        if (cache_info->bitmap != 0) {  /* NULL      Peter */

/* Put this bitmap onto page buffer with halftone and clipping; */

            CURPOINT_X = cxx;
            CURPOINT_Y = cyy;

#ifdef KANJI
            if (CurWmode) {  /* writing mode 1 */
                cache_info->ref_x += cache_info->v01_x;
                cache_info->ref_y += cache_info->v01_y;
            }
#endif
            /* apply bitmap filling */
            fill_shape(EVEN_ODD, F_FROM_CACHE, F_TO_CLIP);
#ifdef KANJI
            if (CurWmode) {  /* writing mode 1 */
                cache_info->ref_x -= cache_info->v01_x;
                cache_info->ref_y -= cache_info->v01_y;
            }
#endif

        }

#ifdef KANJI
        if (CurWmode) {  /* writing mode 1 */
            if (F2L(cache_info->adv1_x) != F2L(zero_f))
                cxx += cache_info->adv1_x;
            cyy += cache_info->adv1_y;
        }
        else {           /* writing mode 0 */
            cxx += cache_info->adv_x;
            if (F2L(cache_info->adv_y) != F2L(zero_f))
                cyy += cache_info->adv_y;
        }
#else
        cxx += cache_info->adv_x;
        if (F2L(cache_info->adv_y) != F2L(zero_f))  /* @= 08/08/88 you */
            cyy += cache_info->adv_y;
#endif
        return(TRUE);
    } /* if */

    return(FALSE);

} /* show_from_cache() */


/* get char width from cache */

static bool near    width_from_cache(code)
ufix8   code;         /* character code */
{

#ifdef DBG
    printf("width_from_cache: %c(%x)\n", code, code);
#endif

    /* get name cache id */
    if (!get_name_cacheid ((ufix8)FONT_type(&FONTInfo), ENCoding(&FONTInfo),
                            code, &name_cacheid))
        return(TRUE);   /* not found */

/* Is the character in cache already? */
#ifdef SCSI
    /* TRUE, width required only */
    if (is_char_cached (cacheclass_id, name_cacheid, &cache_info,
                                                      (bool)TRUE)) {
#else
    if (is_char_cached (cacheclass_id, name_cacheid, &cache_info)) {
#endif

#ifdef KANJI
        if (CurWmode) {  /* writing mode 1 */
            if (F2L(cache_info->adv1_x) != F2L(zero_f))
                cxx += cache_info->adv1_x;
            cyy += cache_info->adv1_y;
        }
        else {           /* writing mode 0 */
            cxx += cache_info->adv_x;
            if (F2L(cache_info->adv_y) != F2L(zero_f))
                cyy += cache_info->adv_y;
        }
#else
        cxx += cache_info->adv_x;
        if (F2L(cache_info->adv_y) != F2L(zero_f))  /* @= 08/08/88 you */
            cyy += cache_info->adv_y;
#endif
        return(TRUE);

    } /* if */

    return(FALSE);

} /* width_from_cache() */

/* show a char of buildin font */

static bool near    show_builtin(code)
ufix8   code;
{
    real32  r;
    ufix    len;
    register    fix     k;
    ufix    t_cache_dest;       /* keep the old flags */
    bool    t_setc_flag;        /* keep the old flags */
    struct Char_Tbl   t_Bitmap; /* keep the old cache info */
    struct Char_Tbl   Bitmap2;  /* cache info */

#ifdef DBG
    printf("show_builtin: %c(%x),  buildchar=%d\n", code, code, buildchar);
#endif
#ifdef DBG
    printf("show_builtin: %c(%x), buildchar=%d\n", code, code, buildchar);
    printf("cxx = %f, cyy = %f\n", cxx, cyy);
    printf("charpath_flag = %d, bool_charpath = %d, setc_flag = %d\n",
            charpath_flag, bool_charpath, setc_flag);
#endif

/* Call Font SoftWare(Fontware or Intellifont) with FontMatrix and CTM
 * to generate charpath and bounding box;
 */
    t_cache_dest = cache_dest;
    if (buildchar) {
        lmemcpy ((ubyte FAR *)(&t_Bitmap), (ubyte FAR *)(&Bitmap), /*@WIN*/
                 sizeof(struct Char_Tbl));
    }

#ifdef DBG
    printf("before font_soft\n");
#endif

    save_setc_state(&t_setc_flag);  /* no matter BuiltIn or UserDef */
    clear_setc_state();
    k = font_soft((ufix)code);
    restore_setc_state(t_setc_flag);

    /* cache_info setup */
    cache_info = &Bitmap;

    if (k) {

#ifdef DBG
    printf("after font_soft\n");
    printf("k = %d\n", k);
#endif

        CTM[4] = ctm_fm[4];
        CTM[5] = ctm_fm[5];

        cache_dest = t_cache_dest;
        if (buildchar) {
            lmemcpy ((ubyte FAR *)(&Bitmap), (ubyte FAR *)(&t_Bitmap), /*@WIN*/
                     sizeof(struct Char_Tbl));
        }
#if     0
        else if (k == 3) {    /* put char cache for /.notdef */
            cache_char (cacheclass_id, name_cacheid, cache_info);
            return(0);
        }
#endif

        if (k == 1)       return(1);
        else              return(0);
    }

#ifdef DBG
    printf("after font_soft\n");
    printf("charpath_flag = %d, bool_charpath = %d, cache_dest = %d\n",
            charpath_flag, bool_charpath, cache_dest);
#endif

    if (charpath_flag) {

        FONTTYPE_QEM_CHARPATH(FONT_type(&FONTInfo));

/* Apply strokepath or not */

        if ( bool_charpath &&
             ((PAINT_type(&FONTInfo) == 1) || (PAINT_type(&FONTInfo) == 3)) ) {
                 /* bool is true AND
                    current font is a builtin font(FontType is 1) AND
                    PaintType of the currentfont is 1 or 3 */

             op_strokepath();  /* Apply strokepath operator */
        }

        get_path(&path);
        op_newpath();

/* restore patial graphic state */

        CTM[4] = ctm_fm[4];
        CTM[5] = ctm_fm[5];

#ifdef KANJI
        if (CurWmode) {  /* writing mode 1 */
            if (F2L(cache_info->adv1_x) != F2L(zero_f))
                cxx += cache_info->adv1_x;
            cyy += cache_info->adv1_y;
        }
        else {           /* writing mode 0 */
            cxx += cache_info->adv_x;
            if (F2L(cache_info->adv_y) != F2L(zero_f))
                cyy += cache_info->adv_y;
        }
#else
        cxx += cache_info->adv_x;
        if (F2L(cache_info->adv_y) != F2L(zero_f))  /* @= 08/08/88 you */
            cyy += cache_info->adv_y;
#endif

        cache_dest = t_cache_dest;
        if (buildchar) {
            lmemcpy ((ubyte FAR *)(&Bitmap), (ubyte FAR *)(&t_Bitmap), /*@WIN*/
                     sizeof(struct Char_Tbl));
        }

        if (ANY_ERROR())   return(1);
        return(0);
    }

    if (cache_dest) {
              /* the size of bounding box is under cache limit */

        switch ((fix)PAINT_type(&FONTInfo)) {    /* PaintType */
        case 0:

/* Call fill with this path to generate the bitmap in cache; */

#ifdef DBG
printf("Bef __fill_shape ---\n");
printf(" cache_dest: %d\n", cache_dest);
printf(" Font_type : %d\n", (ufix)FONT_type(&FONTInfo));
printf(" cache_info:\n");
printf(" adv_x = %f, adv_y = %f\n", cache_info->adv_x, cache_info->adv_y);
printf(" current point:\n");
printf("     x = %f,     y = %f\n", CURPOINT_X, CURPOINT_Y);
#endif

            __fill_shape ((ufix)FONT_type(&FONTInfo), cache_dest);/*@=10/08/88*/

            break;

        case 1: /* No example */

/* Call stroke with this path to generate the bitmap in cache; */

        case 2 :

/* current line width <-- StrokeWidth */
/* Call stroke with this path to generate the bitmap in cache; */

            FONTTYPE_QEM_CHARPATH(FONT_type(&FONTInfo));

            if ( ! NoCurPt() ) {
                r = LINEWIDTH;
                LINEWIDTH = STROKE_width(&FONTInfo);
                stroke_shape(cache_dest);
                LINEWIDTH = r;
            }

            break;

        case 3 : /* bitmap generated by Font Software */
                /* Not Used */
            break;

        } /* switch(PAINT_type) */
    } /* if (cache_dest) */

    if (!buildchar) {  /* buildchar == 0 */

        if (clip_flag) {
            restore_clip();
            restore_device();
            clip_flag = FALSE;
        } /* if (clip_flag) */

/* get the bitmap box in cache */

#ifdef KANJI
        if (IS_BUILTIN_BASE(FONT_type(&FONTInfo)) && (!paint_flag) &&
            (cache_dest == F_TO_CACHE)) {
#else
        if (IS_BUILTIN_BASE(FONT_type(&FONTInfo)) && (!paint_flag) &&
            (cache_dest == F_TO_CACHE)) {
#endif
            /* duplicate Bitmap into Bitmap2 */
            lmemcpy ((ubyte FAR *)(&Bitmap2), (ubyte FAR *)(&Bitmap), /*@WIN*/
                     sizeof(struct Char_Tbl));

/* 2Pt: Begin, Phlin, 4/29/91 */
            if(bmap_extnt.ximax == -1) {
                len = 0;           /* is a space char. */
            }
            else {
                Bitmap.ref_x -= bmap_extnt.ximin;
                Bitmap.ref_y -= bmap_extnt.yimin;

/* add by Falco for doubt, 12/06/91 */
                Bitmap.box_w = (bmap_extnt.ximax - bmap_extnt.ximin);
                if ((Bitmap.box_w%16) != 0)  Bitmap.box_w = ((Bitmap.box_w>>4)+1)<<4;
/*              Bitmap.box_w = (((bmap_extnt.ximax - bmap_extnt.ximin)
                                 >> 4) + 1) << 4;  */ /*  ... / 16 + 1) * 16 */
/* add end */

                Bitmap.box_h = bmap_extnt.yimax - bmap_extnt.yimin + 1;

                len = ((Bitmap.box_w >> 3) * Bitmap.box_h);  /* w / 8 * h */
            }
/* 2Pt: End, Phlin, 4/29/91 */

            if (len) {
                Bitmap.bitmap = ALLOCATE(len);

                init_char_cache(&Bitmap);
                copy_char_cache(&Bitmap, &Bitmap2,
                             bmap_extnt.ximin, bmap_extnt.yimin);
            }
            else
                Bitmap.bitmap = (gmaddr) 0;

        } /* if */

        if ((show_type == SHOW) && (cache_dest == F_TO_CACHE)) {

            CURPOINT_X = cxx;
            CURPOINT_Y = cyy;
#ifdef KANJI
            if (CurWmode) {  /* writing mode 1 */
                cache_info->ref_x += cache_info->v01_x;
                cache_info->ref_y += cache_info->v01_y;
            }
#endif

            /* apply bitmap filling */
            fill_shape(EVEN_ODD, F_FROM_CACHE, F_TO_CLIP);
                 /* Put this bitmap onto page buffer with halftone and
                    clipping; apply bitmap filling */
#ifdef KANJI
            if (CurWmode) {  /* writing mode 1 */
                cache_info->ref_x -= cache_info->v01_x;
                cache_info->ref_y -= cache_info->v01_y;
            }
#endif

        } /* if(cache_dest... */

        if (cache_put) {
            cache_char (cacheclass_id, name_cacheid, cache_info);
        }

    } /* if (!buildchar... */

/* restore patial graphic state */

    CTM[4] = ctm_fm[4];
    CTM[5] = ctm_fm[5];

#ifdef KANJI
    if (CurWmode) {  /* writing mode 1 */
        if (F2L(cache_info->adv1_x) != F2L(zero_f))
            cxx += cache_info->adv1_x;
        cyy += cache_info->adv1_y;
    }
    else {           /* writing mode 0 */
        cxx += cache_info->adv_x;
        if (F2L(cache_info->adv_y) != F2L(zero_f))
            cyy += cache_info->adv_y;
    }
#else
    cxx += cache_info->adv_x;
    if (F2L(cache_info->adv_y) != F2L(zero_f))  /* @= 08/08/88 you */
        cyy += cache_info->adv_y;
#endif

    cache_dest = t_cache_dest;
    if (buildchar) {
        lmemcpy ((ubyte FAR *)(&Bitmap), (ubyte FAR *)(&t_Bitmap), /*@WIN*/
                 sizeof(struct Char_Tbl));
    }

    if (ANY_ERROR())   return(1);
    return(0);

} /* show_builtin() */



/* show a char of user defined font */

static bool near    show_userdef(code)
ufix8   code;
{
    fix     k;

    ufix    t_cache_dest;       /* keep the old flags */
    bool    t_setc_flag;        /* keep the old flags */
    struct Char_Tbl   t_Bitmap; /* keep the old cache info */
    real32  t_cxx, t_cyy;       /* keep the old current point */
    real32   t_ctm_fm[6];       /* current matrix for char */
    real32   t_ctm_cm[6];       /* current matrix for cache */

#ifdef DBG
    printf("show_userdef: %c(%x), buildchar=%d\n", code, code, buildchar);
#endif

/* push font dictionary onto stack; */
/* push character code onto stack; */

    if (FRCOUNT() < 1) { ERROR(STACKOVERFLOW); return(1);  }
    PUSH_OBJ(&current_font);
    if (FRCOUNT() < 1) { ERROR(STACKOVERFLOW); return(1);  }
    PUSH_VALUE(INTEGERTYPE, UNLIMITED, LITERAL, 0, (ufix32)code);

    if (pre_BC_UNDEF) {
        if (FRCOUNT() < 1) {
            ERROR(STACKOVERFLOW);
        }
        else {
            PUSH_OBJ(&pre_obj);
            ERROR(UNDEFINED);
        }
        return(1);
    }

/* execute BuildChar -- pre_BuildChar */

    op_gsave();
    op_newpath();
    COPY_OBJ(&current_font, &BC_font);

    t_cache_dest = cache_dest;
    if (buildchar) {
        lmemcpy ((ubyte FAR *)(&t_Bitmap), (ubyte FAR *)(&Bitmap), /*@WIN*/
                 sizeof(struct Char_Tbl));
    }

    t_cxx = cxx;
    t_cyy = cyy;

    lmemcpy ((ubyte FAR *)t_ctm_fm, (ubyte FAR *)ctm_fm, 6*sizeof(real32)); /*@WIN*/
    lmemcpy ((ubyte FAR *)t_ctm_cm, (ubyte FAR *)ctm_cm, 6*sizeof(real32)); /*@WIN*/

    save_setc_state(&t_setc_flag);
    clear_setc_state();

    ++buildchar;
    k = interpreter(PRE_Buildchar(&FONTInfo));
    --buildchar;

    op_grestore();

    cxx = t_cxx;
    cyy = t_cyy;

    if (k) {    /* some error in BuildChar */
        restore_setc_state(t_setc_flag);
        return(1);
    } /* if (k) */

    lmemcpy ((ubyte FAR *)ctm_fm, (ubyte FAR *)t_ctm_fm, 6*sizeof(real32)); /*@WIN*/

    /* cache_info setup */
    cache_info = &Bitmap;

    if (!buildchar) {  /* buildchar == 0 */

        lmemcpy ((ubyte FAR *)ctm_cm, (ubyte FAR *)t_ctm_cm, 6*sizeof(real32)); /*@WIN*/
        cacheclass_id = cache_matr (PRE_fid(&FONTInfo), ctm_cm);

        if (clip_flag) {
            restore_clip();
            restore_device();
            clip_flag = FALSE;
        } /* if (clip_flag) */

        if ((show_type == SHOW) && (cache_dest == F_TO_CACHE)) {

            CURPOINT_X = cxx;
            CURPOINT_Y = cyy;

#ifdef KANJI
            if (CurWmode) {  /* writing mode 1 */
                cache_info->ref_x += cache_info->v01_x;
                cache_info->ref_y += cache_info->v01_y;
            }
#endif
            /* apply bitmap filling */
            fill_shape(EVEN_ODD, F_FROM_CACHE, F_TO_CLIP);
                 /* Put this bitmap onto page buffer with halftone and
                    clipping; apply bitmap filling */
#ifdef KANJI
            if (CurWmode) {  /* writing mode 1 */
                cache_info->ref_x -= cache_info->v01_x;
                cache_info->ref_y -= cache_info->v01_y;
            }
#endif
        }

        if (cache_put) {

            /* Name Cache Mechanism dependent: NOT HAVE TO get_name_cacheid()*/
            cache_char (cacheclass_id, name_cacheid, cache_info);

        }

    } /* if (!buildchar... */

/* restore patial graphic state */

    lmemcpy ((ubyte FAR *)(CTM), (ubyte FAR *)ctm_fm, 6*sizeof(real32)); /*@WIN*/

    if (is_after_any_setc()) {
#ifdef KANJI
        if (CurWmode) {  /* writing mode 1 */
            if (F2L(cache_info->adv1_x) != F2L(zero_f))
                cxx += cache_info->adv1_x;
            cyy += cache_info->adv1_y;
        }
        else {           /* writing mode 0 */
            cxx += cache_info->adv_x;
            if (F2L(cache_info->adv_y) != F2L(zero_f))
                cyy += cache_info->adv_y;
        }
#else
        cxx += cache_info->adv_x;
        if (F2L(cache_info->adv_y) != F2L(zero_f))  /* @= 08/08/88 you */
            cyy += cache_info->adv_y;
#endif
    } /* if */
    restore_setc_state(t_setc_flag);

    cache_dest = t_cache_dest;
    if (buildchar) {
        lmemcpy ((ubyte FAR *)(&Bitmap), (ubyte FAR *)(&t_Bitmap), /*@WIN*/
                 sizeof(struct Char_Tbl));
    }

    if (ANY_ERROR())    return(1);
    return(0);

} /* show_userdef() */



/* Call Font SoftWare(Fontware or Intellifont) with FontMatrix and CTM
 * to generate charpath and bounding box;
 */

static fix  near font_soft(num)
ufix    num;
{
    struct cd_header      FAR *cd_head; /*@WIN*/
    ufix16                FAR *char_defs;       /*@WIN*/
    struct dict_head_def  FAR *h;       /*@WIN*/
    struct object_def     ch_obj = {0, 0, 0}, FAR *enc;    /*@WIN*/

    ubyte  huge *p;     /* @WIN 04-20-92 */


    struct object_def     FAR *obj_got; /*@WIN*/

    ufix     id, n;
    register    fix      i, j, k;
    bool     rom_flag;
//  fix16   FAR *width; /*@WIN*/
    ufix32   cd_p;

#ifdef SFNT
    static union  char_desc_s  char_desc_ptr;
#endif

#ifdef DBG
    printf("font_soft: %c(%x)\n", num, num);
#endif

    enc = ENCoding(&FONTInfo);


    id = (ufix)(VALUE(&(enc[num])));

    h = (struct dict_head_def FAR *)(CHARstrings(&FONTInfo)) - 1; /*@WIN*/

#ifdef DBG
    printf("ENCoding[%d] = %ld, id = %d\n", num,
                 VALUE(&(enc[num])), id);
#endif

/* get CharStrings -- binary search, 12/30/87 */

    if (DPACK(h)) {

        j = 0;
        k = h->actlength -1;
        cd_head = (struct cd_header FAR *) (h + 1); /*@WIN*/
        char_defs = (ufix16 FAR *) (cd_head + 1); /*@WIN*/

        while (1) {
            i = (j + k) >> 1;    /* (j+k)/2 */
            if (id == (cd_head->key)[i])
                break;

            if (id < (cd_head->key)[i])
                k = i - 1;
            else
                j = i + 1;

            if (j > k) {   /* not found */
#ifdef DBG
    printf("Can't find key, pack:TRUE, id=%d\n", id);
                ERROR(UNDEFINEDRESULT);
#endif
                return(2);
            }
        }

#ifdef  SFNT
        char_desc_ptr.charcode = (ufix32)char_defs[i];
#else
        n = cd_head->max_bytes;
        cd_p = cd_head->base + char_defs[i];
#endif

/* Added for download font */

        rom_flag = TRUE;

    } /* if (h->pack... */
    else {

        ROM_RAM_SET(&ch_obj, RAM);
        ATTRIBUTE_SET(&ch_obj, LITERAL);
        TYPE_SET(&ch_obj, DICTIONARYTYPE);
        LENGTH(&ch_obj) = h->actlength;
        VALUE(&ch_obj) = (ULONG_PTR)h;

        if (!get_dict(&ch_obj, &(enc[num]), &obj_got)) {

#ifdef DBG
    printf("Can't get key from key, (pack:FALSE), id=%d\n", id);
            ERROR(UNDEFINEDRESULT);
#endif
            return(2);
        }

#ifdef SFNT
        if (FONT_type(&FONTInfo) != TypeSFNT)
#endif

        if (TYPE(obj_got) != STRINGTYPE) {
            ERROR(TYPECHECK);
            return(1);
        }

        n = LENGTH(obj_got);

        char_desc_ptr.char_info.len = (fix) LENGTH(obj_got);
        char_desc_ptr.char_info.chardesc = (ubyte FAR *) VALUE(obj_got); /*@WIN*/

        //DJC fix from history.log UPD034
        /* filter out PS procedure in type 42; @WIN */
        if (char_desc_ptr.char_info.len && FONT_type(&FONTInfo) == TypeSFNT) {
            printf("error: PS procedure in Type 42\n");
            char_desc_ptr.charcode = 0;
        }
        //DJC end fix UPD034

#ifdef DBG
    {
    fix         jj;
    ubyte       FAR *cc; /*@WIN*/
    cc = (ubyte FAR *) char_desc_ptr.char_info.chardesc; /*@WIN*/
    printf("get char info ==>");
    for (jj = 0; jj < char_desc_ptr.char_info.len; jj++)        {
        if (jj % 16  == 0)
            printf("\n");
        printf(" %02x", (unsigned) cc[jj]);
        }
    printf("\n");
    }
#endif /* DBG */


        if (ROM_RAM(obj_got) == ROM) {
            cd_p = (ufix32)VALUE(obj_got);
            rom_flag = TRUE;
        }
        else {
            p = (ubyte huge *)VALUE(obj_got); /*@WIN 04-20-92 */
            rom_flag = FALSE;
        }

    } /* else */

#ifdef  SFNT
    p = alloc_vm((ufix32)0); /*@WIN 04-20-92 */
#else
    if (rom_flag) {

        if ((p = (ubyte FAR *)alloc_vm((ufix32)n)) == NULL) { /*@WIN*/
            ERROR(VMERROR);
            return(1);
        } /* if ((p... */

/* Read from data/plaid file */
        get_fontdata(cd_p, p, n);

    } /* if (rom_flag... */
#endif


/* get metrics if any */

#ifdef KANJI
    if ( (F_metrics2(&FONTInfo) == NULL) ||
           (TYPE(F_metrics2(&FONTInfo)) != DICTIONARYTYPE) ||
           (!get_dict(F_metrics2(&FONTInfo), &(ENCoding(&FONTInfo)[num]),
                        &c_metrics2)) )
        c_metrics2 = NULL;
#endif

    if ( (F_metrics(&FONTInfo) == NULL) ||
             (TYPE(F_metrics(&FONTInfo)) != DICTIONARYTYPE) ||
             (!get_dict(F_metrics(&FONTInfo), &(ENCoding(&FONTInfo)[num]),
                        &c_metrics)) )
        c_metrics = NULL;


#ifdef DBG
printf("************ Bef __make_path ---\n");
printf(" Font_type : %d\n", (ufix)FONT_type(&FONTInfo));
printf(" current point:\n");
printf("     x = %f,     y = %f\n", CURPOINT_X, CURPOINT_Y);
printf("   cxx = %f,   cyy = %f\n", cxx, cyy);
printf(" current matrix:\n");
printf("CTM[0] = %f,  [1] = %f,  [2] = %f,  [3] = %f,  [4] = %f,  [5] = %f\n",
       CTM[0], CTM[1], CTM[2], CTM[3], CTM[4], CTM[5]);
printf(" clip:\n");
st_dumpclip();
printf(" path:\n");
st_dumppath();
#endif

#ifndef SFNT
    char_desc_ptr.chardesc = p;
#endif
//  i = __make_path((ufix)FONT_type(&FONTInfo), (ubyte *)&char_desc_ptr); /*@WIN*/
    i = __make_path((ufix)FONT_type(&FONTInfo), &char_desc_ptr); /*@WIN*/
                                    /* to be consistent with make_path() @WIN*/
                                                 /* @=10/08/88 */

#ifdef DBG
printf("**************** Aft __make_path ---\n");
printf(" Font_type : %d\n", (ufix)FONT_type(&FONTInfo));
printf(" current point:\n");
printf("     x = %f,     y = %f\n", CURPOINT_X, CURPOINT_Y);
printf(" current matrix:\n");
printf("CTM[0] = %f,  [1] = %f,  [2] = %f,  [3] = %f,  [4] = %f,  [5] = %f\n",
       CTM[0], CTM[1], CTM[2], CTM[3], CTM[4], CTM[5]);
printf(" clip:\n");
st_dumpclip();
printf(" path:\n");
st_dumppath();
#endif

#ifdef DBG
    printf("make_path: return %d, error = %d\n", i, ANY_ERROR());
#endif

#ifdef  SFNT
    free_vm((byte huge *)p); /*@WIN 04-20-92 */
#else
    if (rom_flag)        free_vm((byte FAR *)p); /*@WIN*/

    if (FONT_type(&FONTInfo) == 1) /* @+ 10/08/88 only for FontType 1 */
        {
        fre_rules();
        fre_chdefs();
        }
#endif

#ifdef DBG
    printf("End of font_soft ......\n");
#endif

    if (i)    return(0);
    if (ANY_ERROR())    return(1);

#ifdef KANJI
    if (CurWmode) {  /* writing mode 1 */
        if (F2L(Bitmap.adv1_x) != F2L(zero_f))
            cxx += Bitmap.adv1_x;
        cyy += Bitmap.adv1_y;
    }
    else {           /* writing mode 0 */
        cxx += Bitmap.adv_x;
        if (F2L(Bitmap.adv_y) != F2L(zero_f))
            cyy += Bitmap.adv_y;
    }
#else
    cxx += Bitmap.adv_x;
    if (F2L(Bitmap.adv_y) != F2L(zero_f))  /* @= 08/08/88 you */
        cyy += Bitmap.adv_y;
#endif

    return(2);

} /* font_soft() */


/* show for buildchar procedure */

void    show_buildchar(fs_type)
ufix    fs_type;
{

#ifdef DBG
    printf("show_buildchar: type=%d\n", fs_type);
#endif
#ifdef DBG
    printf("\nshow_buildchar: type=%d, buildchar=%d\n", fs_type, buildchar);
    printf("cxx = %f, cyy = %f\n", cxx, cyy);
    printf("cache_dest = %d, cache_put = %d\n", cache_dest, cache_put);
    printf("charpath_flag = %d, bool_charpath = %d, setc_flag = %d\n",
            charpath_flag, bool_charpath, setc_flag);
    printf("cache_info:\n");
    printf("ref_x = %d, ref_y = %d, box_w = %d, box_h = %d\n",
            Bitmap.ref_x, Bitmap.ref_y, Bitmap.box_w, Bitmap.box_h);
    printf("adv_x = %f, adv_y = %f, bitmap = %lx\n",
            Bitmap.adv_x, Bitmap.adv_y, Bitmap.bitmap);
#endif

    if (charpath_flag) {
        if ((fs_type == OP_FILL) || (fs_type == OP_EOFILL))
            op_closepath();

        if (bool_charpath && fs_type == OP_STROKE)
            op_strokepath();

        get_path(&path);
        op_newpath();
        return;
    }

    if (cache_dest) {

        cache_info = &Bitmap;

        switch(fs_type) {
        case OP_FILL:
            fill_shape(NON_ZERO, F_NORMAL, cache_dest);
            break;

        case OP_EOFILL:
            fill_shape(EVEN_ODD, F_NORMAL, cache_dest);
            break;

        case OP_STROKE:
            stroke_shape(cache_dest);
            break;

        case OP_IMAGEMASK:
            imagemask_shape(cache_dest);
            break;

        } /* switch */
    } /* if (cache_dest) */
} /* show_buildchar() */


#ifdef KANJI
/* set cache device 2 */
/* Set character width vector be [w0x w0y] for mode 0, [w1x, w1y] for mode 1
 * Set cache device margin be ([llx lly], [urx ury]), difference vector
 * from Orig0 to Orig1 be [vx, vy].
 */

fix     setcachedevice2(l_w0x, l_w0y, l_llx, l_lly, l_urx, l_ury,
                        l_w1x, l_w1y, l_vx,  l_vy)
long32  l_w0x, l_w0y, l_llx, l_lly, l_urx, l_ury, l_w1x, l_w1y, l_vx, l_vy;
{
    real32  w1x, w1y, vx, vy;
    register    fix     j;

    if (IS_BUILTIN_BASE(FONT_type(&FONTInfo)) &&             /*KANJI*/
                CDEVproc(&FONTInfo) != NULL ) {

        struct sp_lst      t_path;
        bool      t_bool_charpath;
        real32    t_cxx, t_cyy, dlx, dly, urx, ury;
        fix       t_show_type;
        long32    tl_llx, tl_lly;

        if (FRCOUNT() < 1) {ERROR(STACKOVERFLOW); return(STOP_PATHCONSTRUCT);}
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, l_w0x);
        if (FRCOUNT() < 1) {ERROR(STACKOVERFLOW); return(STOP_PATHCONSTRUCT);}
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, l_w0y);
        if (FRCOUNT() < 1) {ERROR(STACKOVERFLOW); return(STOP_PATHCONSTRUCT);}
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, l_llx);
        if (FRCOUNT() < 1) {ERROR(STACKOVERFLOW); return(STOP_PATHCONSTRUCT);}
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, l_lly);
        if (FRCOUNT() < 1) {ERROR(STACKOVERFLOW); return(STOP_PATHCONSTRUCT);}
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, l_urx);
        if (FRCOUNT() < 1) {ERROR(STACKOVERFLOW); return(STOP_PATHCONSTRUCT);}
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, l_ury);
        if (FRCOUNT() < 1) {ERROR(STACKOVERFLOW); return(STOP_PATHCONSTRUCT);}
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, l_w1x);
        if (FRCOUNT() < 1) {ERROR(STACKOVERFLOW); return(STOP_PATHCONSTRUCT);}
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, l_w1y);
        if (FRCOUNT() < 1) {ERROR(STACKOVERFLOW); return(STOP_PATHCONSTRUCT);}
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, l_vx);
        if (FRCOUNT() < 1) {ERROR(STACKOVERFLOW); return(STOP_PATHCONSTRUCT);}
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, l_vy);

        if (FRCOUNT() < 1) {ERROR(STACKOVERFLOW); return(STOP_PATHCONSTRUCT);}
        PUSH_OBJ(CurKey);

        /* update current point */
        t_cxx = cxx;
        t_cyy = cyy;

        t_show_type = show_type;
        if (charpath_flag) {
            t_path.head = path.head;
            t_path.tail = path.tail;
            t_bool_charpath = bool_charpath;
        }
        if (show_type != STRINGWIDTH)
            moveto(F2L(cxx), F2L(cyy));

        op_gsave();
        if (interpreter(CDEVproc(&FONTInfo))) {
            op_grestore();
            return(STOP_PATHCONSTRUCT);
        }
        op_grestore();

        if (COUNT() < 10) {    /* at least 10 arguments on stack */
            ERROR(STACKUNDERFLOW);
            return(STOP_PATHCONSTRUCT);
        }

        if (!cal_num((struct object_def FAR *)GET_OPERAND(9), &l_w0x) || /*@WIN*/
            !cal_num((struct object_def FAR *)GET_OPERAND(8), &l_w0y) || /*@WIN*/
            !cal_num((struct object_def FAR *)GET_OPERAND(7), &tl_llx) ||/*@WIN*/
            !cal_num((struct object_def FAR *)GET_OPERAND(6), &tl_lly) ||/*@WIN*/
            !cal_num((struct object_def FAR *)GET_OPERAND(5), &l_urx) || /*@WIN*/
            !cal_num((struct object_def FAR *)GET_OPERAND(4), &l_ury) || /*@WIN*/
            !cal_num((struct object_def FAR *)GET_OPERAND(3), &l_w1x) || /*@WIN*/
            !cal_num((struct object_def FAR *)GET_OPERAND(2), &l_w1y) || /*@WIN*/
            !cal_num((struct object_def FAR *)GET_OPERAND(1), &l_vx)  || /*@WIN*/
            !cal_num((struct object_def FAR *)GET_OPERAND(0), &l_vy) )   /*@WIN*/
            {
            ERROR(TYPECHECK);
            return(STOP_PATHCONSTRUCT);
            }

        POP(10);

        /* make no effect of c_metrics & c_metrics2 entry */
        c_metrics = NULL;
        c_metrics2 = NULL;

        /* update current point */
        cxx = t_cxx;
        cyy = t_cyy;
        show_type = t_show_type;
        if (charpath_flag) {
            path.head = t_path.head;
            path.tail = t_path.tail;
            bool_charpath = t_bool_charpath;
        }

        /* update bounding box */
        dlx = L2F(tl_llx) - L2F(l_llx);
        dly = L2F(tl_lly) - L2F(l_lly);

        urx = L2F(l_urx) - dlx;
        ury = L2F(l_ury) - dly;

        l_urx = F2L(urx);
        l_ury = F2L(ury);

        /* shift the character */
        CTM_trans(&dlx, &dly);
        CTM[4] += dlx;
        CTM[5] += dly;
    }

    w1x = L2F(l_w1x);
    w1y = L2F(l_w1y);
    vx  = L2F(l_vx);
    vy  = L2F(l_vy);

    if (c_metrics2)   /* builtin font */
        get_metrics2(&w1x, &w1y, &vx, &vy);

    CTM_trans(&w1x, &w1y);
    CTM_trans(&vx,  &vy);

    j = setcachedevice(l_w0x, l_w0y, l_llx, l_lly, l_urx, l_ury);

         if (MUL4_flag) {
             w1x /= (real32)4.0 ;
             vx  /= (real32)4.0 ;
         }

    /* advance vector */
    Bitmap.adv1_x = w1x;
    Bitmap.adv1_y = w1y;

    /* difference vector */
    Bitmap.v01_x = (fix16)ROUND(vx);
    Bitmap.v01_y = (fix16)ROUND(vy);

    if (CurWmode && (charpath_flag || (cache_dest == F_TO_PAGE)) ) {
        CTM[4] -= (real32)Bitmap.v01_x;
        CTM[5] -= (real32)Bitmap.v01_y;
    }

    return(j);

} /* setcachedevice2() */
#endif

/* set cache device */

fix     setcachedevice(l_wx, l_wy, l_llx, l_lly, l_urx, l_ury)
long32  l_wx, l_wy, l_llx, l_lly, l_urx, l_ury;
{
    // DJC static  real32      lx, ly, ux, uy;     /* @=static 09/12/88 you */
    // DJC NOTE:##### this used to be static but we dont know why
    //          it caused an assertion error in the compiler so we took
    //          it out!!!!!!
    //          it did not appear to need to be a static
    //
    real32      lx=0, ly=0, ux=0, uy=0;     /* @=static 09/12/88 you */
    real32  wx, wy, llx, lly, urx, ury, tt;
    real32  w, h, wb, ref_x, ref_y;
    ufix          len;
    struct box    box;

    record_setcachedevice_op();

    wx = L2F(l_wx);
    wy = L2F(l_wy);
    llx = L2F(l_llx);
    lly = L2F(l_lly);
    urx = L2F(l_urx);
    ury = L2F(l_ury);

    if (IS_BUILTIN_BASE(FONT_type(&FONTInfo)) &&
         (!buildchar) && (l_llx != l_urx)) {
        /* Enlarge box */
        llx -= (real32)BOX_LLX;
        lly -= (real32)BOX_LLY;
        urx += (real32)BOX_URX;
        ury += (real32)BOX_URY;
    } /* if */

    if (paint_flag) {
        tt = STROKE_width(&FONTInfo) / 2;

        llx -= tt;
        lly -= tt;
        urx += tt;
        ury += tt;
    }

#ifdef DBG
    printf("\nsetcachedevice --\n");
#endif
#ifdef DBG
    printf("CTM[0] = %f, CTM[1] = %f\n", CTM[0], CTM[1]);
    printf("CTM[2] = %f, CTM[3] = %f\n", CTM[2], CTM[3]);
    printf("CTM[4] = %f, CTM[5] = %f\n", CTM[4], CTM[5]);
    printf("CACHEDEVICE:\n");
    printf("wx=%f, wy=%f\n", wx, wy);
    printf("llx=%f, lly=%f, urx=%f, ury=%f\n", llx, lly, urx, ury);
#endif

    if (c_metrics)   /* builtin font for FontType 1 */
        get_metrics(l_llx, &wx, &wy);

/* Cache_box <-- Bounding box of ( cache device box * CTM) */

    box.ulx = box.llx = llx * CTM[0];
    box.lry = box.lly = lly * CTM[3];
    box.urx = box.lrx = urx * CTM[0];
    box.ury = box.uly = ury * CTM[3];

/* advance vector */
    Bitmap.adv_x = wx * CTM[0];
    if (F2L(wy) == F2L(zero_f))
        Bitmap.adv_y = zero_f;
    else
        Bitmap.adv_y = wy * CTM[3];

    if (F2L(CTM[1]) != F2L(zero_f)) {

        Bitmap.adv_y += wx * CTM[1];

        tt = llx * CTM[1];
        box.lly += tt;
        box.uly += tt;
        tt = urx * CTM[1];
        box.lry += tt;
        box.ury += tt;
    }

    if (F2L(CTM[2]) != F2L(zero_f)) {

        if (F2L(wy) != F2L(zero_f))
            Bitmap.adv_x += wy * CTM[2];

        tt = lly * CTM[2];
        box.llx += tt;
        box.lrx += tt;
        tt = ury * CTM[2];
        box.ulx += tt;
        box.urx += tt;
    }

    if ( (buildchar && FONT_type(&FONTInfo) != Type3) || (buildchar > 1) ) {

        if (charpath_flag) {
            cache_dest = 0;
        } /* if (charpath_... */
        else if (show_type == STRINGWIDTH) {
            cache_dest = 0;

/* stop path construction */
            return(STOP_PATHCONSTRUCT);
        } /* else if (show_type... */
#ifdef DJC
        CTM[4] += (real32)floor(cxx) + (real32)0.5;
        CTM[5] += (real32)floor(cyy) + (real32)0.5;
#endif
        //DJC fix from history.log UPD035
        CTM[4] += (real32)floor(cxx + (real32)0.5);     // @WIN
        CTM[5] += (real32)floor(cyy + (real32)0.5);     // @WIN

    } /* if (buildchar... */
    else {

/* Check cache or not */

#ifdef DBG
    printf("\ncheck_cache --\n");
#endif
        lx = MIN(MIN(box.llx, box.lrx), MIN(box.ulx, box.urx));
        ly = MIN(MIN(box.lly, box.lry), MIN(box.uly, box.ury));

        ref_x = - CTM[4] - (real32)((fix)lx);
        ref_y = - CTM[5] - (real32)((fix)ly);

        ux = MAX(MAX(box.llx, box.lrx), MAX(box.ulx, box.urx));
        uy = MAX(MAX(box.lly, box.lry), MAX(box.uly, box.ury));

        if ((ux - lx) <= (real32)ERR_VALUE) {
            wb = zero_f;
        }
        else {
            w = (real32)((fix)(ux - lx)) + 2;   /* !!! */
            wb = (real32)(((fix)(w + 0.5) + 15) / 16) * 2;
            /* @BBOX Get more accurate width for cache 10/02/90 D.S. Tseng */
            if ( !((fix)w % 16) && ((fix)lx % 16) ) wb += (real32)2.0;
        }

        if ((uy - ly) <= (real32)ERR_VALUE)
            h = zero_f;
        else
            /* @BBOX Enlarge bbox to tolerate computing error
                   10/30/90 D.S. Tseng */
            /* h = (real32)((fix)(uy - ly)) + 2; */
            h = (real32)((fix)(uy - ly)) + 4;

        if (charpath_flag || ((wb * h) > (real32)MIN(cacheparams_ub, MAX15)) ||
            (ref_x > (real32)MAX15) || (ref_x < (real32)MIN15) ||
            (ref_y > (real32)MAX15) || (ref_y < (real32)MIN15) ) {

            cache_put = FALSE;
            if ( !charpath_flag && (show_type == STRINGWIDTH)) {
                cache_dest = 0;

/* stop construction */
                return(STOP_PATHCONSTRUCT);
            } /* if (show_type... */
#ifdef DJC
            CTM[4] += (real32)floor(cxx) + (real32)0.5;
            CTM[5] += (real32)floor(cyy) + (real32)0.5;
#endif

            //DJC fix from history.log UPD035
            CTM[4] += (real32)floor(cxx + (real32)0.5);         // @WIN
            CTM[5] += (real32)floor(cyy + (real32)0.5);         // @WIN

            if (charpath_flag) {
                cache_dest = 0;

            goto decide_path_dest;      /* decide to do QEM or not */
            } /* if (charpath_... */

            cache_dest = F_TO_PAGE;     /* fill to page */

#ifdef DAN // DJC DJC
#ifdef DBG
    printf("CTM[4] = %f, CTM[5] = %f\n", CTM[4], CTM[5]);
    printf("BOX:\n");
    printf("ux=%f, lx=%f, uy=%f, ly=%f\n", ux, lx, uy, ly);
    printf("CLIP:\n");
    printf("bb_lx=%d, bb_ux=%d, bb_ly=%d, bb_uy=%d\n",
        CLIPPATH.bb_lx, CLIPPATH.bb_ux, CLIPPATH.bb_ly, CLIPPATH.bb_uy);
#endif
#endif

            if ((FONT_type(&FONTInfo) != Type3) &&
               ((CTM[4] + ux) < (real32)SFX2F(CLIPPATH.bb_lx) ||
                (CTM[5] + uy) < (real32)SFX2F(CLIPPATH.bb_ly) ||
                (CTM[4] + lx) > (real32)SFX2F(CLIPPATH.bb_ux + ONE_SFX - 1) ||
                (CTM[5] + ly) > (real32)SFX2F(CLIPPATH.bb_uy + ONE_SFX - 1)) )
/* stop construction */
                return(STOP_PATHCONSTRUCT);

#ifdef DBG
    printf("\nNo cache\n");
#endif

        }
        else {

/* Get_bitmap */

            Bitmap.ref_x = (fix16)ROUND(ref_x);
            Bitmap.ref_y = (fix16)ROUND(ref_y);
            Bitmap.box_w = (fix16)(wb + 0.5) * 8;
            Bitmap.box_h = (fix16)(h + 0.5);

/* current CTM <-- (Translate of cachedevice) * current CTM */
/* transform to cachedevice space */
/* The Translate is at lower left corner of Cache_box */

            CTM[4] = (real32)( - ((fix)lx - 1));
            CTM[5] = (real32)( - ((fix)ly - 1));

            cache_put = TRUE;    /* put cache info. into cache */
            len = ((Bitmap.box_w >> 3) * Bitmap.box_h);   /* w / 8 * h */
            if (len == 0) {
                Bitmap.bitmap = 0;      /* NULL   Peter */
                cache_dest = 0;
            }
            else {

#ifdef KANJI
                if (IS_BUILTIN_BASE(FONT_type(&FONTInfo)) && (!PAINT_type(&FONTInfo))) {
#else
                if (IS_BUILTIN_BASE(FONT_type(&FONTInfo)) && (!PAINT_type(&FONTInfo))) {
#endif
                             /* buildin font && painttype == 0 */
                    Bitmap.bitmap = get_cm(len);
                }
                else
                    Bitmap.bitmap = ALLOCATE(len);
                init_char_cache(&Bitmap);
                cache_dest = F_TO_CACHE;    /* fill to cache */

/* set cache device */

                    clip_flag = TRUE;

                    GSptr->device.default_ctm[0] = CTM[0];
                    GSptr->device.default_ctm[1] = CTM[1];
                    GSptr->device.default_ctm[2] = CTM[2];
                    GSptr->device.default_ctm[3] = CTM[3];
                    GSptr->device.default_ctm[4] = CTM[4];
                    GSptr->device.default_ctm[5] = CTM[5];

                    GSptr->device.default_clip.lx = 0;
                    GSptr->device.default_clip.ly = 0;
                    GSptr->device.default_clip.ux = F2SFX(w);
                    GSptr->device.default_clip.uy = I2SFX(Bitmap.box_h);

                    /* set current clip */
                    op_initclip();

#ifdef  SFNT
                    cache_info = &Bitmap;
#endif
            } /* else */

#ifdef DBG
    printf("\nCache it\n");
#endif

        } /* else */

    } /* else */


decide_path_dest:   /*  decide to construct GS or QEM path? */
                    /*  and to do QEM refinement logic?     */
    if (FONT_type(&FONTInfo) == Type3)
        {
            /*
             *  @+ 04/20/89 you:    to be compatible with Adobe's behavior ...
             */
            if ((cache_dest == F_TO_CACHE) && !NoCurPt())
                {                       /* update 'currentpoint' to */
                CURPOINT_X = CTM[4];    /*      lower left corner   */
                CURPOINT_Y = CTM[5];    /*      of the bitmap cache */
                }
        return (CONSTRUCT_GS_PATH);
        }
    else
    {   /* for built-in fonts only: out of QEM path rep? to do QEM? */
        if ( !is_within_qemrep((ufix)FONT_type(&FONTInfo), F2L(lx), F2L(ly),
                        F2L(ux), F2L(uy), F2L(CTM[4]), F2L(CTM[5])) )
            return (CONSTRUCT_GS_PATH);
        else if (charpath_flag || (PAINT_type(&FONTInfo) != 0))
            return (CONSTRUCT_GS_PATH);
        else
            return (CONSTRUCT_QEM_PATH);
    }

} /* setcachedevice() */


/* set char width */

void    setcharwidth(l_wx, l_wy)
long32  l_wx, l_wy;
{

    record_setcharwidth_op();

/* advance vector */

    Bitmap.adv_x = L2F(l_wx) * CTM[0] + L2F(l_wy) * CTM[2];
    Bitmap.adv_y = L2F(l_wx) * CTM[1] + L2F(l_wy) * CTM[3];
    if ((Bitmap.adv_y < (real32)1.0e-7) && (Bitmap.adv_y > (real32)-1.0e-7))
        Bitmap.adv_y = zero_f;

    if (show_type == STRINGWIDTH) {
        cache_dest = 0;
    }
    else {
#ifdef DJC
        CTM[4] += ((real32)floor(cxx) + (real32)0.5);
        CTM[5] += ((real32)floor(cyy) + (real32)0.5);
#endif
        //DJC fix from history.log UPD035
        CTM[4] += ((real32)floor(cxx + (real32)0.5));   // @WIN
        CTM[5] += ((real32)floor(cyy + (real32)0.5));   // @WIN

        if (charpath_flag)
            cache_dest = 0;
        else if (buildchar <= 1)
            cache_dest = F_TO_PAGE; /* fill to page */
    } /* else */

    if (buildchar <= 1)
        cache_put = FALSE;

} /* setcharwidth() */



/* Get Metrics in current font */

static void near get_metrics(l_llx, wx, wy)
long32  l_llx;
real32  FAR *wx, FAR *wy; /*@WIN*/
{
    real32  tt, bx, by, llx;
    struct object_def   FAR *b; /*@WIN*/

    llx = L2F(l_llx);

#ifdef DBG
    printf("Metrics defined\n");
#endif

    if (cal_num(c_metrics, (long32 FAR *)wx)) { /*@WIN*/
        *wy = zero_f;
        return;
    }

    if (TYPE(c_metrics) != ARRAYTYPE)
        return;

    b = (struct object_def FAR *)VALUE(c_metrics); /*@WIN*/

    switch (LENGTH(c_metrics)) {
    case 2:
        if (    cal_num(&b[0], (long32 FAR *)(&bx)) && /*@WIN*/
                cal_num(&b[1], (long32 FAR *)wx)   ) {  /*@WIN*/

            *wy = zero_f;
            CTM[4] = (bx - llx) * CTM[0] + CTM[4];
            CTM[5] = (bx - llx) * CTM[1] + CTM[5];
        }
        break;

    case 4:
        if (    cal_num(&b[0], (long32 FAR *)(&bx)) && /*@WIN*/
                cal_num(&b[1], (long32 FAR *)(&by)) && /*@WIN*/
                cal_num(&b[3], (long32 FAR *)(&tt)) && /*@WIN*/
                cal_num(&b[2], (long32 FAR *)wx)   ) { /*@WIN*/
            *wy = tt;
            CTM[4] = (bx - llx) * CTM[0] + by * CTM[2] + CTM[4];
            CTM[5] = (bx - llx) * CTM[1] + by * CTM[3] + CTM[5];
        }
        break;
    }
} /* get_metrics() */


#ifdef KANJI

static void near get_metrics2(w1x, w1y, vx, vy)
real32  FAR *w1x, FAR *w1y, FAR *vx, FAR *vy; /*@WIN*/
{
    real32  twx, twy, tvx;
    struct object_def   FAR *b; /*@WIN*/


    if ( (TYPE(c_metrics2) != ARRAYTYPE) || (LENGTH(c_metrics2) != 4) )
        return;

    b = (struct object_def FAR *)VALUE(c_metrics2); /*@WIN*/

    if (    cal_num(&b[0], (long32 FAR *)(&twx)) && /*@WIN*/
            cal_num(&b[1], (long32 FAR *)(&twy)) && /*@WIN*/
            cal_num(&b[2], (long32 FAR *)(&tvx)) && /*@WIN*/
            cal_num(&b[3], (long32 FAR *)vy)   ) {  /*@WIN*/
        *w1x = twx;
        *w1y = twy;
        *vx = tvx;
    }

} /* get_metrics2() */
#endif


/* Do setfont action
 *   . get font information
 *   . change current font in graphics state
 */

#define ROYALTYPE       42

static fsg_SplineKey  KData;
void                do_setfont(font_dict)
struct object_def  FAR *font_dict; /*@WIN*/
{
//      struct object_def          FAR *b1, my_obj, FAR *ary_obj; /*@WIN*/
        fsg_SplineKey              FAR *key = &KData; /*@WIN*/
//      sfnt_FontHeader            FAR *fontHead; /*@WIN*/
//      int                         x;          @WIN

#ifdef DBG2
    printf("Enter do_setfont: error = %d\n", ANY_ERROR());
#endif

    COPY_OBJ(font_dict, &current_font); /* SOS */

    if (pre_font == (ufix32)VALUE(font_dict)) {
     /* COPY_OBJ(font_dict, &current_font); SOS */
        return;
    }

    if (get_CF_info(font_dict, &FONTInfo) == -1) {
        pre_error = ANY_ERROR();
        CLEAR_ERROR();
     /* COPY_OBJ(font_dict, &current_font); SOS */
        pre_font = 0L;
    }
    else {

        do_name_cc = TRUE ; /*RCD*/
    /*  build_name_cc_table ( font_dict,(ufix8)FONT_type(&FONTInfo) ); RCD*/
        pre_error = 0;
        pre_font = (ufix32)VALUE(font_dict);
    }

/* move it to fontware_restart() --- Begin --- @DFA @WIN */
#if 0
    /* Added for update the EMunits  DLF42  Jul-28,91 YM BEGIN */

    if(get_f_type(font_dict) == ROYALTYPE) {
        ATTRIBUTE_SET(&my_obj, LITERAL);
        get_name(&my_obj, "sfnts", 5, TRUE);
        get_dict(font_dict, &my_obj, &b1);

        ary_obj = (struct object_def FAR *)VALUE(b1); /*@WIN*/

/* add by Falco to reference the right address, 11/20/91 */
        SfntAddr = (byte FAR *)VALUE(&ary_obj[0]); /*@WIN*/
/* add end */

        SetupKey(key, VALUE(&ary_obj[0]));

        sfnt_DoOffsetTableMap(key);

/* change by Falco to avoid the reference to key too much, 11/08/91 */

/*      x = key->offsetTableMap[sfnt_fontHeader] ;
        fontHead = (sfnt_FontHeader *) ((ufix32)VALUE(&ary_obj[0]) +
                                        key->sfntDirectory->table[x].offset);
*/
        fontHead = (sfnt_FontHeader FAR *)sfnt_GetTablePtr(key, sfnt_fontHeader, true ); /*@WIN*/
/* change end */

        EMunits = SWAPW(fontHead->unitsPerEm) ;
    }   /* ROYALTYPE */

    /* Added for update the EMunits  DLF42  Jul-28,91 YM END */
#endif
/* move it to fontware_restart() ---  End  --- @DFA @WIN */

} /* do_setfont() */


#ifdef KANJI

/* calculate match char
 *   m = 2,3,6   return  f * 256 + c
 *   m = 4,5     return  f * 128 + c
 */

static fix31 near match_char(m, f, c)
ubyte m;    /* FmapType */
ufix  f;    /* font number */
ubyte c;    /* code */
{
    return((fix31)( ((m == 4 || m == 5) ? 128 : 256) * f + c ) );
} /* match_char() */


/* Get FontType in the font_dict
 *   . return FontType
 */

fix32                get_f_type(font_dict)
struct object_def   FAR *font_dict; /*@WIN*/
{
    struct object_def     obj = {0, 0, 0}, FAR *b; /*@WIN*/

/* Get FontType from font_dict */

    ATTRIBUTE_SET(&obj, LITERAL);
    get_name(&obj, FontType, 8, TRUE);
    get_dict(font_dict, &obj, &b);

    return((fix32)VALUE(b));

} /* get_f_type() */

#endif     /* KANJI */


/* Get Current Font information in the font_dict */

// DJC
// changed to ANSI type args
fix get_CF_info(struct object_def FAR *font_dict, struct f_info FAR *font_info)
{
    struct object_def     FAR *obj_got, FAR *bb, obj; /*@WIN*/
    struct dict_head_def  FAR *h; /*@WIN*/
//  real32  tt;         @WIN

    pre_BC_UNDEF = FALSE;

/* Check validation of the font */

    h = (struct dict_head_def FAR *)VALUE(font_dict); /*@WIN*/

    if (DFONT(h) == 0) {
        ERROR(INVALIDFONT);
        return(-1);
    }

/* get font information */

    if (get_f_info(font_dict, font_info))    return(-1);
#ifdef DBG
    printf("Aft: get_f_info\n");
#endif

/* Get ScaleMatrix from current font */
#ifdef DBG
    printf("get ScaleMatrix\n");
#endif
    get_name(&pre_obj, ScaleMatrix, 11, TRUE);
    if (!get_dict(font_dict, &pre_obj, &obj_got)) {

      scale_matrix[0]=scale_matrix[3] = (real32)1.0;
      scale_matrix[1]=scale_matrix[2]=scale_matrix[4]=scale_matrix[5] = zero_f;

    }
    else if ( (TYPE(obj_got) != ARRAYTYPE) ||
            (ATTRIBUTE(obj_got) != LITERAL) || (LENGTH(obj_got) != 6) ) {
        ERROR(TYPECHECK);
        return(-1);
    }
    else {

        bb = (struct object_def FAR *)VALUE(obj_got); /*@WIN*/

        if ( !cal_num(&bb[0], (long32 FAR *)(&scale_matrix[0])) || /*@WIN*/
                !cal_num(&bb[1], (long32 FAR *)(&scale_matrix[1])) || /*@WIN*/
                !cal_num(&bb[2], (long32 FAR *)(&scale_matrix[2])) || /*@WIN*/
                !cal_num(&bb[3], (long32 FAR *)(&scale_matrix[3])) || /*@WIN*/
                !cal_num(&bb[4], (long32 FAR *)(&scale_matrix[4])) || /*@WIN*/
                !cal_num(&bb[5], (long32 FAR *)(&scale_matrix[5])) ) {/*@WIN*/

            ERROR(TYPECHECK);
            return(-1);
        }
    }

/* Check FontBBox from current font */

#ifdef DBG
    printf("get FontBBox\n");
#endif
    get_name(&pre_obj, FontBBox, 8, TRUE);
    get_dict(font_dict, &pre_obj, &obj_got);

    if ( ( (TYPE(obj_got) != ARRAYTYPE) && (TYPE(obj_got) != PACKEDARRAYTYPE) )
           || (LENGTH(obj_got) != 4) ) {
        ERROR(TYPECHECK);
        return(-1);
    }

#ifdef DBG
    printf("check if all numbers in FontBBox\n");
#endif
    bb = (struct object_def FAR *)VALUE(obj_got); /*@WIN*/

    if (TYPE(obj_got) == ARRAYTYPE)     {
        if ( !cal_num(&bb[0], (long32 FAR *)(&FONT_BBOX[0])) || /*@WIN*/
             !cal_num(&bb[1], (long32 FAR *)(&FONT_BBOX[1])) || /*@WIN*/
             !cal_num(&bb[2], (long32 FAR *)(&FONT_BBOX[2])) || /*@WIN*/
             !cal_num(&bb[3], (long32 FAR *)(&FONT_BBOX[3])) ) {/*@WIN*/

            ERROR(TYPECHECK);
            return(-1);
        }
    } else  {/* Packed Array */
        ufix16    ii;
        for (ii = 0; ii < 4; ii++) {
            get_pk_object(get_pk_array((ubyte FAR *) bb, (ufix16) ii), &obj, LEVEL(obj_got)); /*@WIN*/
          /* modified by CLEO
           *if (!cal_num(&obj, (long32 FAR *)(&tt))) {   @WIN
           */
            if (!cal_num(&obj, (long32 FAR *)(&FONT_BBOX[ii])) ) { /*@WIN*/
                ERROR(TYPECHECK);
                 return(-1);
            }
        }
    }

#ifdef DBG
    printf("QEM restart ...\n");
#endif

 /* COPY_OBJ(font_dict, &current_font); SOS */
#ifdef WINF /* 3/20/91 ccteng */
    /* get windows info */
    f_wininfo = TRUE;
#endif

    // for Truetype font, restart it only the font data is in memory; @DFA @WIN
    /* Restart the font software with some initial data */
    if ( FONT_type(&FONTInfo) != TypeSFNT ||
         (byte FAR *)VALUE(Sfnts(&FONTInfo)) != (char FAR *)NULL) {
        __qem_restart(FONT_type(font_info));
    }

    change_f_flag = TRUE;
    return(0);

} /* get_CF_info() */


/* Get font information in the font_dict */
/* the font_dict is defined by definefont operator already */


fix                  get_f_info(font_dict, font_info)
struct object_def   FAR *font_dict; /*@WIN*/
struct f_info       FAR *font_info; /*@WIN*/
{
    struct object_def     FAR *obj_got, FAR *bb; /*@WIN*/
    fix31   ft;
#ifdef KANJI
    fix31   wm;
#endif

#ifdef DBG2
    printf("get_f_info 0: error = %d\n", ANY_ERROR());
#endif

#ifdef DBG
    printf("get_f_info: %lx\n", font_dict);
#endif

#ifdef DBG
    printf("Get FID\n");
#endif
/* Get FID from font */

    ATTRIBUTE_SET(&pre_obj, LITERAL);
    LEVEL_SET(&pre_obj, current_save_level);

    get_name(&pre_obj, FID, 3, TRUE);
    //DJC fix from history.log UPD032
//  get_dict(font_dict, &pre_obj, &obj_got);
    if (!get_dict(font_dict, &pre_obj, &obj_got)) {
        printf("Warning, get_f_info error\n");
        return(-1);
    }

    PRE_fid(font_info) = (ufix32)VALUE(obj_got);

#ifdef DBG
    printf("Get Encoding\n");
#endif
/* Get Encoding from current font */

    get_name(&pre_obj, Encoding, 8, TRUE);
    get_dict(font_dict, &pre_obj, &obj_got);

    if (TYPE(obj_got) != ARRAYTYPE) {
        ERROR(TYPECHECK);
        return(-1);
    }
    ENCoding(font_info) = (struct object_def FAR *)VALUE(obj_got); /*@WIN*/

#ifdef DBG
    printf("Get FontMatrix\n");
#endif
/* Get FontMatrix from current font */

    get_name(&pre_obj, FontMatrix, 10, TRUE);
    get_dict(font_dict, &pre_obj, &obj_got);

    if ( (TYPE(obj_got) != ARRAYTYPE) ||
            (ATTRIBUTE(obj_got) != LITERAL) || (LENGTH(obj_got) != 6) ) {
        ERROR(TYPECHECK);
        return(-1);
    }
    bb = (struct object_def FAR *)VALUE(obj_got); /*@WIN*/

    if (!cal_num(&bb[0], (long32 FAR *)(&(FONT_matrix(font_info)[0]))) || /*@WIN*/
            !cal_num(&bb[1], (long32 FAR *)(&(FONT_matrix(font_info)[1]))) ||/*@WIN*/
            !cal_num(&bb[2], (long32 FAR *)(&(FONT_matrix(font_info)[2]))) ||/*@WIN*/
            !cal_num(&bb[3], (long32 FAR *)(&(FONT_matrix(font_info)[3]))) ||/*@WIN*/
            !cal_num(&bb[4], (long32 FAR *)(&(FONT_matrix(font_info)[4]))) ||/*@WIN*/
            !cal_num(&bb[5], (long32 FAR *)(&(FONT_matrix(font_info)[5]))) ) {/*@WIN*/

        ERROR(TYPECHECK);
        return(-1);
    }

#ifdef KANJI
#ifdef DBG
    printf("Get WMode\n");
#endif
/* Get WMode from current font */

    get_name(&pre_obj, WMode, 5, TRUE);
    if (!get_dict(font_dict, &pre_obj, &bb))
        WMODE(font_info) = 0;
    else if (!cal_integer(bb, &wm)) {
        ERROR(TYPECHECK);
        return(-1);
    }
    else if ((wm < 0) || (wm > 1)) {
        ERROR(INVALIDFONT);
        return(-1);
    }
    else
        WMODE(font_info) = (fix)wm;
#endif

#ifdef DBG
    printf("Get FontType\n");
#endif
/* Get FontType from current font */

    get_name(&pre_obj, FontType, 8, TRUE);
    get_dict(font_dict, &pre_obj, &obj_got);

    if (!cal_integer(obj_got, &ft)) {
        ERROR(TYPECHECK);
        return(-1);
    }
    if (INVALID_FONTTYPE(ft)) {
        ERROR(INVALIDFONT);
        return(-1);
    }
#ifdef KANJI
    if (!IS_BUILTIN_BASE(ft) && (ft!=0) && (ft!=3)) {
        ERROR(INVALIDFONT);
        return(-1);
    }
#else
    if (!IS_BUILTIN_BASE(ft) && (ft != Type3)) {
        ERROR(INVALIDFONT);
        return(-1);
    }
#endif
    FONT_type(font_info) = (fix)ft;

/* get font_type related informations */

    if (get_ps(font_dict, font_info))  return(-1);
#ifdef DBG2
    printf("get_f_info 1: error = %d\n", ANY_ERROR());
#endif
    return(0);

} /* get_f_info() */


/* get font_type related informations */

static fix  near get_ps(font_dict, font_info)
struct object_def   FAR *font_dict; /*@WIN*/
struct f_info       FAR *font_info; /*@WIN*/
{
    struct object_def      FAR *obj_got, FAR *b1; /*@WIN*/
    struct dict_head_def   FAR *h; /*@WIN*/
#ifdef KANJI
    fix31   esc;
#endif
#ifdef SFNT
    struct object_def      FAR *ary_obj; /*@WIN*/
    fix                     i, n;
#endif

#ifdef DBG
    printf("get_ps: %lx\n", font_dict);
#endif

    paint_flag = 0;
    c_metrics = NULL;
#ifdef KANJI
    c_metrics2 = NULL;

        switch (FONT_type(font_info)) {
        case Type1:
        case TypeSFNT:

#ifdef DBG
    printf("Get Metrics2 information\n");
#endif
        /* get Metrics2 */
            get_name(&pre_obj, Metrics2, 8, TRUE);
            if (!get_dict(font_dict, &pre_obj, &F_metrics2(font_info)))
                F_metrics2(font_info) = NULL;

#ifdef DBG
    printf("Get CDevProc information\n");
#endif
        /* get CDevProc */
            get_name(&pre_obj, CDevProc, 8, TRUE);
            if (!get_dict(font_dict, &pre_obj, &CDEVproc(font_info)))
                CDEVproc(font_info) = NULL;

            break;
        } /* inner switch */
#endif

    switch (FONT_type(font_info)) {
#ifdef KANJI
    case 0:    /* composite font */

#ifdef DBG
    printf("Get FontType 0 information\n");
#endif
    /* Get PrefEnc */
        get_name(&pre_obj, PrefEnc, 7, TRUE);
        get_dict(font_dict, &pre_obj, &PREFenc(font_info));

    /* Get MIDVector */
        get_name(&pre_obj, MIDVector, 9, TRUE);
        get_dict(font_dict, &pre_obj, &MIDVECtor(font_info));

    /* Get EscChar */
        get_name(&pre_obj, EscChar, 7, TRUE);
        if (!get_dict(font_dict, &pre_obj, &b1))
            ESCchar(font_info) = (ubyte)0xff;
        else if (!cal_integer(b1, &esc)) {
            ERROR(TYPECHECK);
            return(-1);
        }
        else
            ESCchar(font_info) = (ubyte)esc;

        break;
#endif

    case Type3:    /* userdefined font */
#ifdef DBG
    printf("Get FontType 3 information\n");
#endif
        get_name(&pre_obj, BuildChar, 9, TRUE);
        if (!get_dict(font_dict, &pre_obj, &PRE_Buildchar(font_info))) {
            pre_BC_UNDEF = TRUE;

            ERROR(UNDEFINED);
#ifdef DBGwarn
            warning (FONTCHAR, 0x01, "BuildChar");
#endif
            return(-1);
        }
        break;

#ifdef SFNT
    case TypeSFNT:
#ifdef DBG
    printf("Get FontType %d information\n", TypeSFNT);
#endif

    /* get PlatformID & EncodingID */

      { /*DLF42-begin*/
        bool has2id=TRUE;
        struct object_def FAR *obj_got1; /*@WIN*/
        get_name(&pre_obj, "PlatformID", 10, TRUE);
        if (!get_dict(font_dict, &pre_obj, &obj_got1)) {
            has2id=FALSE;
        }
        if (has2id) {
           if (TYPE(obj_got1) != INTEGERTYPE) {
               has2id=FALSE;
           }
           if (has2id) {
              get_name(&pre_obj, "EncodingID", 10, TRUE);
              if (!get_dict(font_dict, &pre_obj, &obj_got)) {
                  has2id=FALSE;
              }
              if (has2id) {
                 if (TYPE(obj_got) != INTEGERTYPE) {
                     has2id=FALSE;
                 }
              }
           }
        }
        if (has2id) {
           PlatID(font_info) = (ufix16)VALUE( obj_got1 );
           SpecID(font_info) = (ufix16)VALUE( obj_got );
        } else {
           PlatID(font_info) = (ufix16)1;  /*MAC encoding*/
           SpecID(font_info) = (ufix16)0;
        }
      } /*DLF42-end*/

    /* get CharStrings */
        get_name(&pre_obj, CharStrings, 11, TRUE);
        if (!get_dict(font_dict, &pre_obj, &obj_got)) {
            ERROR(UNDEFINED);
            return(-1);
        }
        if (TYPE(obj_got) != DICTIONARYTYPE) {
            ERROR(TYPECHECK);
            return(-1);
        }
        h = (struct dict_head_def FAR *)VALUE(obj_got); /*@WIN*/
        CHARstrings(font_info) = (struct str_dict FAR *)(h + 1); /*@WIN*/

    /* get sfnts */
        get_name(&pre_obj, "sfnts", 5, TRUE);
        if (!get_dict(font_dict, &pre_obj, &obj_got)) {
            ERROR(UNDEFINED);
            return(-1);
        }
        if (TYPE(obj_got) != ARRAYTYPE) {
            ERROR(TYPECHECK);
            return(-1);
        }
        n = LENGTH(obj_got);
        ary_obj = (struct object_def FAR *)VALUE(obj_got); /*@WIN*/
        for (i=0; i<n; i++) {
            if (TYPE(&ary_obj[i]) != STRINGTYPE) {
                ERROR(TYPECHECK);
                return(-1);
            }
        }
        Sfnts(font_info) = ary_obj;

        PRIvate(font_info) = NULL;

    /* get Metrics */
        get_name(&pre_obj, Metrics, 7, TRUE);
        if (!get_dict(font_dict, &pre_obj, &F_metrics(font_info)))
            F_metrics(font_info) = NULL;

    /* Get PaintType from current font */
        get_name(&pre_obj, PaintType, 9, TRUE);
        if (!get_dict(font_dict, &pre_obj, &obj_got)) {
            ERROR(UNDEFINED);
            return(-1);
        }
        if (!cal_integer(obj_got, &PAINT_type(font_info))) {
            ERROR(TYPECHECK);
            return(-1);
        }

    /* Get StrokeWidth from font */
        if ( (PAINT_type(font_info) == 2) ||
             (PAINT_type(font_info) == 1) ) {

            get_name(&pre_obj, StrokeWidth, 11, TRUE);
            if (get_dict(font_dict, &pre_obj, &obj_got)) {
                if (!cal_num(obj_got, (long32 FAR *)&STROKE_width(font_info))) { /*@WIN*/
                    ERROR(TYPECHECK);
                    return(-1);
                }
                if (STROKE_width(font_info) < (real32)0.0)
                    STROKE_width(font_info) = - STROKE_width(font_info);
            }
            else
                STROKE_width(font_info) = (real32)0.0;

            paint_flag = 1;
        } /* if (paint_type... */
        break;
#endif /* SFNT */

    default:   /* builtin font */

#ifdef DBG
    printf("Get FontType 1,5,6 information\n");
#endif
    /* get CharStrings */
#ifdef DBG
    printf("Get CharStrings\n");
#endif
        get_name(&pre_obj, CharStrings, 11, TRUE);
        if (!get_dict(font_dict, &pre_obj, &obj_got)) {
            ERROR(UNDEFINED);
#ifdef DBGwarn
            warning (FONTCHAR, 0x01, "CharStrings");
#endif
            return(-1);
        }
        if (TYPE(obj_got) != DICTIONARYTYPE) {
            ERROR(TYPECHECK);
            return(-1);
        }
        h = (struct dict_head_def FAR *)VALUE(obj_got); /*@WIN*/
        CHARstrings(font_info) = (struct str_dict FAR *)(h + 1); /*@WIN*/

    /* get Private */
#ifdef DBG
    printf("Get Private\n");
#endif
        get_name(&pre_obj, Private, 7, TRUE);
        if (!get_dict(font_dict, &pre_obj, &obj_got)) {
            ERROR(UNDEFINED);
#ifdef DBGwarn
            warning (FONTCHAR, 0x01, "Private");
#endif
            return(-1);
        }
        if (TYPE(obj_got) != DICTIONARYTYPE) {
            ERROR(TYPECHECK);
            return(-1);
        }

    /* @@ 1/11/88 Added for download font */
        if (ROM_RAM(obj_got) == ROM || FONT_type(font_info) == Type1) {
            h = (struct dict_head_def FAR *)VALUE(obj_got); /*@WIN*/
            PRIvate(font_info) = (struct pld_obj FAR *)(h + 1); /*@WIN*/
        }
        else {
            get_name(&pre_obj, FontwareRules, 13, TRUE);
            if ((!get_dict(obj_got, &pre_obj, &b1)) ||
                   (TYPE(b1) != ARRAYTYPE) || (LENGTH(b1) != 256)) {
                ERROR(INVALIDFONT);
                return(-1);
            }
            FONTRules(font_info) = (struct object_def FAR *)VALUE(b1); /*@WIN*/
            PRIvate(font_info) = NULL;
        }

    /* get Metrics */
#ifdef DBG
    printf("Get Metrics\n");
#endif
        get_name(&pre_obj, Metrics, 7, TRUE);
        if (!get_dict(font_dict, &pre_obj, &F_metrics(font_info)))
            F_metrics(font_info) = NULL;

    /* Get PaintType from current font */
#ifdef DBG
    printf("Get PaintType\n");
#endif
        get_name(&pre_obj, PaintType, 9, TRUE);
        if (!get_dict(font_dict, &pre_obj, &obj_got)) {
            ERROR(UNDEFINED);
#ifdef DBGwarn
            warning (FONTCHAR, 0x01, "PaintType");
#endif
            return(-1);
        }
        if (!cal_integer(obj_got, &PAINT_type(font_info))) {
            ERROR(TYPECHECK);
            return(-1);
        }

    /* Get StrokeWidth from font */
#ifdef DBG
    printf("Get StrokeWidth\n");
#endif
        if ( (PAINT_type(font_info) == 2) ||
             (PAINT_type(font_info) == 1) ) {

            get_name(&pre_obj, StrokeWidth, 11, TRUE);
            if (get_dict(font_dict, &pre_obj, &obj_got)) {
                if (!cal_num(obj_got, (long32 FAR *)&STROKE_width(font_info))) { /*@WIN*/
                    ERROR(TYPECHECK);
                    return(-1);
                }
                if (STROKE_width(font_info) < (real32)0.0)
                    STROKE_width(font_info) = - STROKE_width(font_info);
            }
            else
                STROKE_width(font_info) = (real32)0.0;

            paint_flag = 1;
        } /* if (paint_type... */


    } /* switch */
#ifdef DBG
    printf("Right before return get_ps\n");
#endif

    return(0);

} /* get_ps() */



/* get matrix index in cache */

static bool near    get_cf()
{
    real32  det;

#ifdef DBG
    printf("get_cf\n");
#endif

    if (pre_BC_UNDEF)
        return(TRUE);

/* check if font changed */

    if ( !change_f_flag &&
          (F2L(ctm_tm[0]) == F2L(CTM[0])) &&
          (F2L(ctm_tm[2]) == F2L(CTM[2])) &&
          (F2L(ctm_tm[1]) == F2L(CTM[1])) &&
          (F2L(ctm_tm[3]) == F2L(CTM[3])) ) {
        return(TRUE);
    } else {
          do_transform = TRUE;  /* DTF */
    }

    lmemcpy ((ubyte FAR *)(ctm_tm), (ubyte FAR *)(CTM), 4 * sizeof(real32)); /*@WIN*/

    _clear87();   /* clear status of 87 */

    mul_matrix(ctm_fm, FONT_matrix(&FONTInfo), ctm_tm);

    if (!buildchar)
        mul_matrix(ctm_cm, scale_matrix, ctm_tm);

    det = ctm_fm[0] * ctm_fm[3] - ctm_fm[1] * ctm_fm[2];

    if (_status87() & (PDL_CONDITION)) {
        _clear87();   /* clear status of 87 */
        return(FALSE);
    }
    _clear87();   /* clear status of 87 */

    if (det < (real32)0.)    det = - det;
    if (det < (real32)1e-12) {   /* det of matrix == 0 */
#ifdef DBG
    printf("get_cf: det = %f\n", det);
#endif
        ERROR(UNDEFINEDRESULT);
        return(FALSE);
    }

    if (!buildchar)
        cacheclass_id = cache_matr (PRE_fid(&FONTInfo), ctm_cm);

    change_f_flag = FALSE;
    return(TRUE);

} /* get_cf() */


/* copy font dict */

void    copy_fdic(b1, b2)
struct object_def  FAR *b1, FAR *b2; /*@WIN*/
{
    struct dict_content_def     FAR *p; /*@WIN*/
    register ufix               i, n;

    n = ((struct dict_head_def FAR *)VALUE(b1))->actlength; /*@WIN*/
    lmemcpy ((ubyte FAR *)VALUE(b2),    /* dest @WIN*/
            (ubyte FAR *)VALUE(b1),    /* src @WIN*/
        sizeof(struct dict_head_def) + n * sizeof(struct dict_content_def));

/* update current save level */

    p = (struct dict_content_def FAR *)(VALUE(b2) + sizeof(struct dict_head_def)); /*@WIN*/
    /* n = ((struct dict_head_def *)VALUE(b1))->actlength; */
    for (i=0; i<n; i++, p++) {
        LEVEL_SET(&(p->k_obj), current_save_level);
        LEVEL_SET(&(p->v_obj), current_save_level);
    }

} /* copy_fdic() */



/* gf_restore */

void  gf_restore()
{
    fix    t_ERROR;

#ifdef DBG
    printf("gf_restore\n");
#endif

/* reset the current font */

    if (TYPE(&current_font) == DICTIONARYTYPE) { /* current font */
        if ((pre_font != 0) &&
            (pre_font == (ufix32)VALUE(&current_font))) {
            pre_error = 0;
            return;
        }
        t_ERROR = ANY_ERROR();
        if (get_CF_info(&current_font, &FONTInfo) == -1) {
            pre_error = ANY_ERROR();
            pre_font = 0;
        }
        else {
            pre_error = 0;
            pre_font = (ufix32)VALUE(&current_font);

            build_name_cc_table (&current_font ,(ufix8)FONT_type(&FONTInfo) );
        }
        ERROR(((ufix16)(t_ERROR)));
    }
    else
        pre_font = 0;   /* force to be NULL */

    if ((buildchar) && (VALUE(&current_font) != VALUE(&BC_font)) )
        COPY_OBJ(&current_font, &BC_font);

} /* gf_restore() */


/* compute the value of number type on stack */

bool    cal_num(b, n)
struct object_def FAR *b; /*@WIN*/
long32  FAR *n; /*@WIN*/
{
    real32  f;
    union   four_byte num4;

    num4.ll = (fix32)VALUE(b);

    switch (TYPE(b)) {
    case INTEGERTYPE :
        f = (real32)num4.ll;
        *n = F2L(f);
        return(TRUE);
        break;
    case REALTYPE :
        *n = F2L(num4.ff);
        return(TRUE);
        break;
    default:
        return(FALSE);
        break;
    }
} /* cal_num() */

bool    cal_integer(b, n)
struct object_def FAR *b; /*@WIN*/
fix31   FAR *n; /*@WIN*/
{
    if (TYPE(b) == INTEGERTYPE) {
        *n = (fix31)VALUE(b);
        return(TRUE);
    }
    else
        return(FALSE);
} /* cal_integer() */

#ifdef WINF /* 3/20/91 ccteng */
/* get windows info */
static fix  near get_win(font_dict, font_info)
struct object_def   FAR *font_dict; /*@WIN*/
struct f_info       FAR *font_info; /*@WIN*/
{
    struct object_def name_obj, FAR *save_dict, FAR *info_dict, FAR *tmp_obj; /*@WIN*/
    bool save_flag = FALSE;
    real32 tmp_value;
    real32 theta;

#ifdef DBGWINF
    printf("get_win\n");
#endif

    /* set attribute and save_level */
    ATTRIBUTE_SET(&name_obj, LITERAL);
    LEVEL_SET(&name_obj, current_save_level);

    /* get FontInfo dict */
    get_name(&name_obj, "FontInfo", 8, TRUE);
    if (!get_dict(font_dict, &name_obj, &info_dict)) {
        /* does not have a FontInfo dict, use Courier's instead */
get_default:
        save_dict = font_dict;
        save_flag = TRUE;
        get_dict_value("FontDirectory", "Courier", &font_dict);
        get_dict(font_dict, &name_obj, &info_dict);
    } /* if */

    /* get underline position */
    get_name(&name_obj, "UnderlinePosition", 17, TRUE);
    if (!get_dict(info_dict, &name_obj, &tmp_obj)) {
        /* does not have UnderlinePosition */
        goto get_default;
    } /* if */
    cal_num(tmp_obj, (long32 FAR *)(&tmp_value)); /*@WIN*/
#ifdef DBGWINF
    printf("underline position=%f\n", tmp_value);
#endif
    tmp_value /= 1000.0;
    /* check scale_matrix[4] & [5] == zero before add to save a float
     * operation ???
     */
    font_info->fc.dxUL = scale_matrix[2] * tmp_value + scale_matrix[4];
    font_info->fc.dyUL = scale_matrix[3] * tmp_value + scale_matrix[5];

    /* get underline thickness */
    get_name(&name_obj, "UnderlineThickness", 18, TRUE);
    if (!get_dict(info_dict, &name_obj, &tmp_obj)) {
        /* does not have UnderlineThickness */
        goto get_default;
    } /* if */
    cal_num(tmp_obj, (long32 FAR *)(&tmp_value)); /*@WIN*/
#ifdef DBGWINF
    printf("underline thickness=%f\n", tmp_value);
#endif
    tmp_value /= 1000.0;
    /* check escapement */
    if ((scale_matrix[2] == zero_f) && (scale_matrix[0] > zero_f)) {
        /* scale_matrix[3] == Sy when it's not rotated */
        font_info->fc.cyUL = scale_matrix[3] * tmp_value;
        esc = FALSE;
    } else {
        real32 Sy;

        /* this is a pain to reverse the scale_matrix just to get Sy back
         * when it's rotated, we might not have to do this ???
         * this dose not handle shearing which current windows driver
         * does not use ???
         */
        Sy = sqrt((scale_matrix[3] * scale_matrix[3]) +
                        (scale_matrix[2] * scale_matrix[2]));
        font_info->fc.cyUL = Sy * tmp_value;
        theta = atan(scale_matrix[1] / scale_matrix[0]);
        mxE[0] = cos(theta);
        mxE[1] = sin(theta);
        mxE[2] = zero_f - mxE[1];
        mxE[3] = mxE[0];
#if 0 /* this is incorrect because Sy is actually ABS(Sy) */
        mxE[3] = zero_f - (scale_matrix[3] / Sy);
        mxE[1] = scale_matrix[2] / Sy;
        mxE[0] = mxE[3];
        mxE[2] = zero_f - mxE[1];
#endif
#ifdef DBGWINF
        printf("mxE=[%f, %f, %f, %f]\n", mxE[0], mxE[1], mxE[2], mxE[3]);
#endif
        esc = TRUE;
    } /* if-else */

    /* calculate strikeout values */
    tmp_value = 0.3;
    font_info->fc.dxSO = scale_matrix[2] * tmp_value + scale_matrix[4];
    font_info->fc.dySO = scale_matrix[3] * tmp_value + scale_matrix[5];

#ifdef DBGWINF
    printf("dxUL=%f, dyUL=%f, cyUL=%f\n", font_info->fc.dxUL, font_info->fc.dyUL, font_info->fc.cyUL);
    printf("dxSO=%f, dySO=%f\n", font_info->fc.dxSO, font_info->fc.dySO);
#endif

    /* restore original font dict if necessary */
    if (save_flag)
        font_dict = save_dict;

    return(0);
} /* get_win */

/*
 * op_strblt
 * 3/20/91 ccteng
 * Syntax: fUL fSO x y width string strblt -
 * Description:
 *      1. fUL and fSO are both bollean
 *      2. x y width are numbers in user unit
 * Functionality:
 *
 */
fix
op_strblt()
{
    struct coord FAR *pt0; /*@WIN*/
    real32 dxGdi, dyGdi, x0, y0;
    real32 tyBreak;
    real32 mxECTM[4], saveCTM[4], xUL, yUL, xSO, ySO;
    fix cbStr;
    ufix show_flag;
    struct object_def FAR *ob; /*@WIN*/
    bool        fUL, fSO;

#ifdef DBGWINF
    printf("op_strblt\n");
#endif

    /* check error */
    /* add X_BIT to distinguish from normal stringwidth operator */
    show_flag = STRINGWIDTH_FLAG | X_BIT;
    if (!chk_show(show_flag, 6))
        return(0);
#ifdef DBGWINF
    printf("chk_show OK\n");
#endif

    /* initialize parameters */
    cbStr = (fix)LENGTH(GET_OPERAND(0));
    if (!fBE)
        if (cbStr > 1)
            cbStr--;
    cal_num(GET_OPERAND(1), (long32 FAR *)(&dxGdi)); /*@WIN*/
    cal_num(GET_OPERAND(2), (long32 FAR *)(&y0)); /*@WIN*/
    cal_num(GET_OPERAND(3), (long32 FAR *)(&x0)); /*@WIN*/
    dyGdi = zero_f;

    /* get window information */
    if (f_wininfo) {
        get_win(&current_font, &FONTInfo);
        f_wininfo = FALSE;
    }

    /* make them into device space */
    if (fUL = (bool) VALUE(GET_OPERAND(5))) {
        xUL = FONTInfo.fc.dxUL;
        yUL = FONTInfo.fc.dyUL;
        CTM_trans(&xUL, &yUL);
    } /* if */
    if (fSO = (bool) VALUE(GET_OPERAND(4))) {
        xSO = FONTInfo.fc.dxSO;
        ySO = FONTInfo.fc.dySO;
        CTM_trans(&xSO, &ySO);
    } /* if */
    pt0 = transform(F2L(x0), F2L(y0));

    /* change CTM if esc != 0 */
    if (esc) {
        lmemcpy((ubyte FAR *)saveCTM, (ubyte FAR *)CTM, 4 * sizeof(real32)); /*@WIN*/
        mxECTM[0] = ((mxE[0] * CTM[0]) + (mxE[1] * CTM[2]));
        mxECTM[1] = ((mxE[0] * CTM[1]) + (mxE[1] * CTM[3]));
        mxECTM[2] = ((mxE[2] * CTM[0]) + (mxE[3] * CTM[2]));
        mxECTM[3] = ((mxE[2] * CTM[1]) + (mxE[3] * CTM[3]));
        lmemcpy((ubyte FAR *)CTM, (ubyte FAR *)mxECTM, 4 * sizeof(real32)); /*@WIN*/
    } /* if */
    CTM_trans(&dxGdi, &dyGdi);
#ifdef DBGWINF
    printf("dxGdi=%f, dyGdi=%f, x0=%f, y0=%f\n", dxGdi, dyGdi, x0, y0);
#endif

    /* we might need to add buildchar flag checking here ??? */

    /* get string width in device space */
    if (esc) lmemcpy((ubyte FAR *)CTM, (ubyte FAR *)saveCTM, 4 * sizeof(real32));/*@WIN*/
    show_type = STRINGWIDTH;
    do_show(show_flag, 0, ob);

    /* calculate character extra (dxExtra and dyExtra) in device space */
    /* cx and cy are global variables to be used in do_show */
    ax = (dxGdi - cxx) / (real32)cbStr;
    ay = (dyGdi - cyy) / (real32)cbStr;
#ifdef DBGWINF
    printf("cxx=%f, cyy=%f, ax=%f, ay=%f\n", cxx, cyy, ax, ay);
#endif

    /* show string here */
    moveto(F2L(pt0->x), F2L(pt0->y));
    if (fBE) {
        show_flag = AWIDTHSHOW_FLAG | X_BIT;
        cx = dxBreak;
        cy = zero_f;
        if (esc) lmemcpy((ubyte FAR *)CTM, (ubyte FAR *)mxECTM, 4 * sizeof(real32));/*@WIN*/
        CTM_trans(&cx, &cy);
        if (esc) lmemcpy((ubyte FAR *)CTM, (ubyte FAR *)saveCTM, 4 * sizeof(real32));/*@WIN*/
    } else {
        show_flag = ASHOW_FLAG | X_BIT;
    } /* if-else */
    show_type = SHOW;
    do_show(show_flag, 0, ob);
    if (esc) lmemcpy((ubyte FAR *)CTM, (ubyte FAR *)mxECTM, 4 * sizeof(real32)); /*@WIN*/

    /* draw underline if fUL is true */
    if (fUL) {
        xUL += pt0->x;
        yUL += pt0->y;
        moveto(F2L(xUL), F2L(yUL));
        if (fBE) {
            tyBreak = zero_f;
            CTM_trans(&tBreak, &tyBreak);
            dxGdi += tBreak;
            dyGdi += tyBreak;
        } /* if */
        xUL += dxGdi;
        yUL += dyGdi;
        lineto(F2L(xUL), F2L(yUL));

        /* set line width then stroke */
        FABS(GSptr->line_width, FONTInfo.fc.cyUL);
        op_stroke();
    } /* if */

    /* draw strikeout if fSO is true */
    if (fSO) {
        xSO += pt0->x;
        ySO += pt0->y;
        moveto(F2L(xSO), F2L(ySO));
        if (fBE && !VALUE(GET_OPERAND(5))) {
            tyBreak = zero_f;
            CTM_trans(&tBreak, &tyBreak);
            dxGdi += tBreak;
            dyGdi += tyBreak;
        } /* if */
        xSO += dxGdi;
        ySO += dyGdi;
        lineto(F2L(xSO), F2L(ySO));

        /* set line width then stroke */
        if (!VALUE(GET_OPERAND(5)))
            FABS(GSptr->line_width, FONTInfo.fc.cyUL);
        op_stroke();
    } /* if */

    /* restore CTM if necessary */
    if (esc) lmemcpy((ubyte FAR *)CTM, (ubyte FAR *)saveCTM, 4 * sizeof(real32)); /*@WIN*/

    /* need to turn off fBE here, fBE need to be trun on explicitly every time */
    fBE = FALSE;

    POP(6);

    return(0);
} /* op_strblt */

/*
 * op_setjustify
 * 3/20/91 ccteng
 * Syntax: breakChar tBreakExtra breakCount setjustify -
 * Description:
 *      1. tBreakExtra is a number in user unit
 *      2. breakCount is an integer that is greater then 0
 * Functionality:
 *
 */
fix
op_setjustify()
{
    fix breakCount;

#ifdef DBGWINF
    printf("op_setjustify\n");
#endif
    if ((breakCount = (fix)VALUE(GET_OPERAND(0))) <= 0) {
        ERROR(RANGECHECK);
        return(0);
    } /* if */

    cal_num(GET_OPERAND(1), (long32 FAR *)(&tBreak)); /*@WIN*/
    if (tBreak == zero_f) {
        fBE = FALSE;
    } else {
        dxBreak = tBreak / (real32)breakCount;
        breakChar = (ubyte)(VALUE(GET_OPERAND(2)) & 0x000000ff);
        fBE = TRUE;
#ifdef DBGWINF
        printf("tBreak=%f, dxBreak=%f, breakChar=%c\n", tBreak, dxBreak, breakChar);
#endif
    } /* if-else */

    POP(3);

    return(0);
} /* op_setjustify */
#endif /* WIN */

/* RCD
 * is_rbuild_name_cc()
 * for build CharStrings dict again if
 * (1) NUM chars in CharStrings is changed, or
 * (2) CheckSUM of the CharStrings is changed
 * Kason 4/30/01
 */

//static bool is_rbuild_name_cc()       @WIN
static bool near is_rbuild_name_cc()
{
    struct dict_head_def  FAR *h; /*@WIN*/
    ufix16                len;
    struct object_def     cd_obj, chstr_k, FAR *chstr_v ; /*@WIN*/
    ufix32                checksum ;

    h = (struct dict_head_def FAR *)(CHARstrings(&FONTInfo)) - 1; /*@WIN*/
    //DJC len = h->actlength -1;
    len = h->actlength;  // DJC fix from SC

    if (len == pre_len) {   /*The same length*/
       VALUE(&cd_obj) = (ULONG_PTR)h ;
       extract_dict (&cd_obj, len-1, &chstr_k, &chstr_v) ;
       checksum = (ufix32)VALUE(&chstr_k); /* calculate checksum of the CD keys */
       if ( checksum == pre_checksum )
          return FALSE ; /*same length and same checksum*/
       else
          return TRUE ;  /*checksum is changed*/
    } else { /*length is changed*/
         return TRUE ;
    }/*if*/
 }/* is_rbuild_name_cc()*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\fontenco.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/* @WIN; take out the static def of dict data. The tables will be allocated
 * thru global alloc, and contents be loaded at run time, in "fontinit.c".
 */
#ifdef KANJI
/* ********************************************************************** */
/* File: fontencod.h            Created by Jerry Jih    06-20-1990        */
/*                                                                        */
/*       Structure and table for encoding array of EncodingDirectory      */
/*                                                                        */
/* ********************************************************************** */

typedef struct {
    fix16      array_idx;
    char       FAR *char_name; /*@WIN*/
} encoding_data;

typedef struct {
    char       FAR *encoding_name; /*@WIN*/
    fix16      encod_type;
    fix16      encod_size;
} encoding_table_s;

static encoding_table_s Encoding_table[] = {
      {"JISEncoding",              NAMETYPE,    256},
      {"ShiftJISEncoding",         NAMETYPE,    256},
      {"ExtShiftJIS-A-CFEncoding", INTEGERTYPE,  31},
      {"KatakanaEncoding",         NAMETYPE,    256},
      {"NotDefEncoding",           NAMETYPE,    256},
      {(char FAR *)NULL,      (fix16)0,  (fix16)0} }; /*@WIN*/

/* @WIN ---begin--- move def out; to be loaded at run time, in "fontinit.c" */
extern encoding_data    FAR * JISEncoding_Enco;
extern encoding_data    FAR * ShiftJISEncoding_Enco;
extern encoding_data    FAR * ExtShiftJIS_A_CFEncoding_Enco;
extern encoding_data    FAR * KatakanaEncoding_Enco;
static encoding_data    FAR *Encoding_array[5];
/* @WIN --- end --- */

static encoding_data     NotDefEncoding_Enco[]={ {   0,(char FAR *)NULL } }; /*@WIN*/

#endif /*KANJI*/
/* -------------------- End of fontencod.h ------------------------------- */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\fontinit.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */


// DJC added global include
#include "psglobal.h"

#define    LINT_ARGS            /* @WIN */
#define    NOT_ON_THE_MAC       /* @WIN */
#define    KANJI                /* @WIN */
// DJC use command line #define    UNIX                 /* @WIN */
/**************************************************************/
/*                                                            */
/*      fontinit.c               10/9/87      Danny           */
/*                                                            */
/**************************************************************/

/*
 * -------------------------------------------------------------------
 *  Revision History:
 *
 * 1. 7/31/90  ccteng  1)change Data_Offset to char under UNIX flag
 *                     2)modify setup_fd for rtfpp, set length to NO_FD
 *                       in rtfpp.h, add include rtfpp.h
 *                     3)clean out junks
 *
 * 2. 08/07/90  Kason   - Open Data_Offset for fdata.bin produced in fpptool
 *                      - NO_FD has been changed the defined position
 *                        from rtfpp.h to dictdata.h . So, using
 *                        "extern NO_FD" in place of including "rtfpp.h"
 * 3. 08/29/90  ccteng  change <stdio.h> to "stdio.h"
 *
 * 4. 03/07/94  v-jimbr Changed the amt to allocate for SFNTGLYPHNUM to 259
 *                      changed the amt to allocate for EXTSJISENCONUM to 32
 *                      These numbers were always underallocated but the
 *                      heap manager must have allocated a little extra mem
 *                      because the problem did not show up until recent changes
 *                      to the heap manager.
 * -------------------------------------------------------------------
 */

#define     FONTINIT_INC

#include    <stdio.h>
#include    <string.h>      /* for strlen() and memcpy */

#include    "define.h"        /* Peter */
#include    "global.ext"
#include    "graphics.h"

#include    "fontdict.h"
#include    "fontkey.h"
#include    "fontmain.def"
#include    "fntcache.ext"
#include    "fontqem.ext"
/* Kason 4/18/91 */
#include    "graphics.ext"
#include    "fontgrap.h"

#include    "stdio.h"
#include "fcntl.h"              /*@WIN*/
#include "io.h"                 /*@WIN*/
#include "psres.h"              //DJC

#ifdef UNIX
// char Data_Offset[0x150000] ;  /* 05/03/91, 100000 */
char FAR *Data_Offset;       /* as a global allocate; @WIN */
char FAR *StringPool;          /*@WIN*/
char FAR *lpStringPool;        /*@WIN*/
#endif /* UNIX */

/* --starting address of FontDirectory */
extern struct dict_head_def  far *FontDir;
typedef   struct                                /* Got from "dictdata.h" @WIN*/
              {
                 fix16      CDCode;
                 ufix16     CharCode;
                 byte       FAR *CharName; /*@WIN*/
              }  enco_data;
enco_data FAR * Std_Enco;                /* Got from "dictdata.h" @WIN*/
enco_data FAR * Sym_Enco;                /* Got from "dictdata.h" @WIN*/
enco_data FAR * Zap_Enco;                /* Got from "dictdata.h" @WIN*/
byte FAR * FAR * sfntGlyphSet;           /* Got from "dictdata.h" @WIN*/
struct object_def  (FAR * en_obj)[256];  /* Got from "dictdata.h" @WIN*/
enco_data FAR *Enco_Ary[3];              /* Got from "dictdata.h" @WIN*/
/*extern     font_data     FONTDEFS_TBL[] ;        Got from "fontdefs.h" @WIN*/
#include "fontdefs.h"           /*@WIN*/

static char * sfnt_file[] = {   /*@WIN*/
//      "ariali.ttf",
//      "TICour.ttf",
        "cr.s",
        "hl.s",
        "hlb.s",
        "sm.s",
        "ag.s",
        "agb.s",
        "bmb.s",
        "bmbi.s",
        "bm.s",
        "bmi.s",
        "ncsr.s",
        "ncsb.s",
        "ncsi.s",
        "ncsbi.s",
        "plr.s",
        "plb.s",
        "pli.s",
        "plbi.s",
        "zfd.s",
        "zfcmi.s"
};














#ifdef KANJI
#include     "fontenco.h"
encoding_data    FAR * JISEncoding_Enco;        /* Got from "dictdata.h" @WIN*/
encoding_data    FAR * ShiftJISEncoding_Enco;   /* Got from "dictdata.h" @WIN*/
encoding_data    FAR * ExtShiftJIS_A_CFEncoding_Enco; /* Got from "dictdata.h" @WIN*/
encoding_data    FAR * KatakanaEncoding_Enco;   /* Got from "dictdata.h" @WIN*/

#define      EN_NO        16
#define      DICT_SIZE(no)\
             (sizeof(struct dict_head_def)+(no)*sizeof(struct dict_content_def))

/* struct object_def     encod_obj[EN_NO][256]; changed as global alloc;@WIN*/
struct object_def FAR * FAR * encod_obj;
                                        /* add prototype @WIN */
struct dict_head_def      FAR *init_encoding_directory(ufix32 FAR *); /*@WIN*/
static ufix16             hash_id(ubyte  FAR *);        /*@WIN*/
static void  near         encoding_setup(void);         /*@WIN*/
static void  near         setup_ed();
static encoding_table_s   FAR *encoding_table_ptr; /*@WIN*/
static int                power(int, int);      /*@WIN*/
static unsigned long int  ascii2long(char FAR *);       /*@WIN*/
#endif /* KANJI */

extern ufix16   NO_FD ;

#ifdef  LINT_ARGS
extern fix  init_build_fonts(void);
static void setup_nodef_dict(void);

static  void   setup_fd(ULONG_PTR);
#else

extern fix  init_build_fonts();
static void setup_nodef_dict();

static  void  near  setup_fd();
#endif /* LINT_ARGS */

int TTOpenFile(char FAR *szName);   /* from wintt.c */
static int ReadTables (void);                   /*@WIN*/
//DJC static int ReadEncoding (int hfd, enco_data FAR *EncodingTable); /*@WIN*/
static int ReadEncoding (PPS_RES_READ hfd, enco_data FAR *EncodingTable); /*@WIN*/

//DJC static int ReadGlyphSet (int hfd);         /*@WIN*/
static int ReadGlyphSet (PPS_RES_READ hfd);         /*@WIN*/
#ifdef KANJI
//DJC static int ReadJISEncoding (int hfd, encoding_data FAR *EncodingTable);
static int ReadJISEncoding (PPS_RES_READ hfd, encoding_data FAR *EncodingTable);
#endif
//DJC static int ReadString(int hfd, char * szCharName);
static int ReadString(PPS_RES_READ hfd, char * szCharName);
//DJCstatic int ReadInteger(int hfd, int * pInt);
static int ReadInteger(PPS_RES_READ hfd, int * pInt);

static int nCurrent = 0;
static int nLast = 0;
#define BUFSIZE 128
static  char szReadBuf[BUFSIZE];


/* This partial operation is to setup FontDirectory and to setup font
 * cache machinery. This operation will be included in the system
 * initialization module.
 */

void  init_font()
{
extern struct table_hdr    FAR *preproc_hdr;   /* header of font preprocessing data @WIN*/
    struct object_def   FAR *fontdir;       /* FontDirectory @WIN*/

#ifdef UNIX
/* read in font data; ------------------Begin-------------  @WIN*/
#ifdef XXX
    FILE *bfd ;
    long size ;

    /* Load sfnt font data from disk */
    if (!(bfd = fopen("fdata.bin","r"))) {
        printf("*** Error: locating fdata.bin ***\n") ;
        return;             /* exit(0)=>return @WIN*/
    }
    fseek(bfd,0L,2) ;
    size = ftell(bfd) ;
    rewind(bfd) ;
    fread(Data_Offset,sizeof(char),size,bfd) ;
    fclose (bfd) ;
#endif
    ReadTables(); /* read in font data, encoding tables, and SFNT glyph set */
/* read in font data; ------------------ End -------------  @WIN*/

#ifdef DBG
    printf("fontd.bin OK!\n") ;
#endif /* DBG */
#endif /* UNIX */

#ifdef DBG
    printf("\ninit_font, any error = %d ...\n", ANY_ERROR());
#endif

/* setup hash table with font */

#ifdef DBG
    printf("\nhash_fkey(), any error = %d ...\n", ANY_ERROR());
#endif


/*  TYPE(&current_font) = NULLTYPE; */
/*  current font <-- NULL ---  This will be done at graphic init time */

//  init_build_fonts() ;        @WIN
    if (!init_build_fonts()) {
        printf("init_build_fonts fail!\n");
        return;
    }

    setup_nodef_dict() ;

/* setup FontDirectory and StandardEncoding in "systemdict" */

      setup_fd((ULONG_PTR)FontDir);

/* get FontDirectory from systemdict, no matter SAVE_VM or RST_VM */

    get_dict_value(systemdict, FontDirectory, &fontdir);

#ifdef DBG
    printf("\nsetup_fd(), any error = %d ...\n", ANY_ERROR());
#endif

/* setup cache machinery */

    /* initialize font cache mechanism and its data structures */
        init_fontcache(fontdir);

#ifdef DBG
    printf("\ninit_fontcache, any error = %d ...\n", ANY_ERROR());
#endif

/* initialize font QEM */

    __qem_init();

#ifdef DBG
    printf("\n__qem_init, any error = %d ...\n", ANY_ERROR());
#endif

/* init other "far" tables */

    font_op4_init();

#ifdef DBG
    printf("\nfont_init OK, any error = %d ...\n", ANY_ERROR());
#endif

} /* init_font() */


/* setup FontDirectory */

static  void  near  setup_fd (dire_addr)
    ULONG_PTR          dire_addr;
{
    struct object_def      FAR *encoding; /*@WIN*/
    struct object_def       raw_fontdir_obj, someobj;
    struct dict_head_def    FAR *raw_fontdir_hd; /*@WIN*/
    struct dict_content_def FAR *raw_fontdir_content; /*@WIN*/
    ufix16                  no_raw_fontdict;



    /* get raw font directory info. from font preprocessing data */

    raw_fontdir_hd = (struct dict_head_def FAR *)dire_addr; /*@WIN*/
    no_raw_fontdict = raw_fontdir_hd->actlength;
#ifdef DBG
    printf("no_raw_fontdict =%d\n",no_raw_fontdict);
#endif
    raw_fontdir_content = (struct dict_content_def FAR *)(raw_fontdir_hd + 1); /*@WIN*/

    /* put raw FontDirectory into "systemdict" */

    TYPE_SET(&raw_fontdir_obj, DICTIONARYTYPE);
    ACCESS_SET(&raw_fontdir_obj, READONLY);
    ATTRIBUTE_SET(&raw_fontdir_obj, LITERAL);
    ROM_RAM_SET(&raw_fontdir_obj, ROM);
    LEVEL_SET(&raw_fontdir_obj, 0);
    LENGTH(&raw_fontdir_obj) = NO_FD;
    VALUE(&raw_fontdir_obj)  = (ULONG_PTR)raw_fontdir_hd;


    put_dict_value(systemdict, FontDirectory, &raw_fontdir_obj);


    /* put StandardEncoding to systemdict */

    ATTRIBUTE_SET(&someobj, LITERAL);
    get_name(&someobj, Encoding, 8, TRUE);
    get_dict(&(raw_fontdir_content[0].v_obj), &someobj, &encoding);

    put_dict_value(systemdict, StandardEncoding, encoding);

#ifdef DBG
    printf("**********leaving setup_fd()**********\n");
#endif


} /* setup_fd() */



/* Update for CharStrings in font dict */

static struct object_def    near unpack_key, near unpack_val;

bool    get_pack_dict(dict, key, val)
struct object_def    FAR *dict, FAR *key, FAR * FAR *val; /*@WIN*/
{
    struct cd_header      FAR *cd_head; /*@WIN*/
    ufix16                FAR *char_defs; /*@WIN*/
    struct dict_head_def  FAR *h; /*@WIN*/
    ufix16  id;
    register    fix     i, j, k;


    id = (ufix16)(VALUE(key));
    h = (struct dict_head_def FAR *)VALUE(dict); /*@WIN*/

    cd_head = (struct cd_header FAR *) (h + 1); /*@WIN*/
    char_defs = (ufix16 FAR *) (cd_head + 1); /*@WIN*/

/* get it -- binary search */

    j = 0;
    k = h->actlength -1;
#ifdef DBG
    printf("get_pack_key: h->actlength=%d \n ",h->actlength);
#endif
    while (1) {
        i = (j + k) >> 1;    /* (j+k)/2 */
        if (id == (cd_head->key)[i])
            break;

        if (id < (cd_head->key)[i])
            k = i - 1;
        else
            j = i + 1;

        if (j > k) {   /* not found */
            return(FALSE);
        }
    }

    TYPE_SET(&unpack_val, STRINGTYPE);
    ACCESS_SET(&unpack_val, NOACCESS);
    ATTRIBUTE_SET(&unpack_val, LITERAL);
    ROM_RAM_SET(&unpack_val, ROM);
    LENGTH(&unpack_val) = cd_head->max_bytes;
    VALUE(&unpack_val) = cd_head->base + char_defs[i];

    *val = &unpack_val;
#ifdef DBG
    printf(".....leaving get_pack_dict()...... \n ");
#endif
    return(TRUE);

} /* get_pack_dict() */


bool    extract_pack_dict(dict, index, key, val)
struct object_def   FAR *dict, FAR * FAR *key, FAR * FAR *val; /*@WIN*/
ufix    index;
{
    struct cd_header      FAR *cd_head; /*@WIN*/
    ufix16                FAR *char_defs; /*@WIN*/
    struct dict_head_def  FAR *h; /*@WIN*/

    h = (struct dict_head_def FAR *)VALUE(dict); /*@WIN*/

    if (index >= h->actlength)    return(FALSE);
    cd_head = (struct cd_header FAR *) (h + 1); /*@WIN*/
    char_defs = (ufix16 FAR *) (cd_head + 1); /*@WIN*/

    TYPE_SET(&unpack_key, NAMETYPE);
    ACCESS_SET(&unpack_key, UNLIMITED);
    ATTRIBUTE_SET(&unpack_key, LITERAL);
    ROM_RAM_SET(&unpack_key, RAM);
    LENGTH(&unpack_key) = 0; /* NULL;   Peter */
    VALUE(&unpack_key) = (ufix32) (cd_head->key)[index];

    TYPE_SET(&unpack_val, STRINGTYPE);
    ACCESS_SET(&unpack_val, NOACCESS);
    ATTRIBUTE_SET(&unpack_val, LITERAL);
    ROM_RAM_SET(&unpack_val, ROM);
    LENGTH(&unpack_val) = cd_head->max_bytes;
    VALUE(&unpack_val) = cd_head->base + char_defs[index];

    *key = &unpack_key;
    *val = &unpack_val;

    return(TRUE);
} /* extract_pack_dict() */


#ifdef KANJI
/* *********************************************************************** */
/* init_encoding_directory()                                               */
/*      Initialize EncodingDirectory                                       */
/* *********************************************************************** */
struct dict_head_def FAR *init_encoding_directory(dict_length) /*@WIN*/
ufix32    FAR *dict_length; /*@WIN*/
{
    ufix                     i, j, NO_Encoding;
    struct dict_content_def  far *encod_dict;
    struct dict_head_def     FAR *EncodDir; /*@WIN*/

#ifdef DBG
    printf(".. Enterinit_encoding_directory() \n");
#endif

    *dict_length = (ufix32)EN_NO;

    /* get no. of encoding from Encoding_table */
    for(encoding_table_ptr = Encoding_table, i = 0;
        encoding_table_ptr->encoding_name != (char FAR *)NULL; /*@WIN*/
        encoding_table_ptr++, i++);

    NO_Encoding = i;
#ifdef DBG
    printf(" NO_Encoding = %d\n", NO_Encoding);
#endif

    if (EN_NO < NO_Encoding)
       printf(" !!! Encoding definition too small !!!\n");
    /* get memory for ncodingDir */
    EncodDir=(struct dict_head_def far *)fardata((ufix32)DICT_SIZE(EN_NO));
    encod_dict=(struct dict_content_def  far *)(EncodDir+1);

    /* EncodingDirectory initial */
    for(i=0; i<NO_Encoding; i++) {
        TYPE_SET(&(encod_dict[i].k_obj), NAMETYPE);
        ATTRIBUTE_SET(&(encod_dict[i].k_obj), LITERAL);
        ROM_RAM_SET(&(encod_dict[i].k_obj), ROM);
        LEVEL_SET(&(encod_dict[i].k_obj), 0);
        ACCESS_SET(&(encod_dict[i].k_obj), READONLY);
        LENGTH(&(encod_dict[i].k_obj)) = 0;

        TYPE_SET(&(encod_dict[i].v_obj), DICTIONARYTYPE);
        ATTRIBUTE_SET(&(encod_dict[i].v_obj), LITERAL);
        ROM_RAM_SET(&(encod_dict[i].v_obj), ROM);
        LEVEL_SET(&(encod_dict[i].v_obj), 0);
        ACCESS_SET(&(encod_dict[i].v_obj), READONLY);
    }


    /* Encoding object initial */
    for(encoding_table_ptr = Encoding_table, j = 0;
        encoding_table_ptr->encoding_name != (char FAR *)NULL; /*@WIN*/
        encoding_table_ptr++, j++) {
        for(i=0; i<(ufix)encoding_table_ptr->encod_size; i++) { //@WIN
            TYPE_SET(&(encod_obj[j][i]),encoding_table_ptr->encod_type );
            ATTRIBUTE_SET(&(encod_obj[j][i]), LITERAL);
            ROM_RAM_SET(&(encod_obj[j][i]), ROM);
            LEVEL_SET(&(encod_obj[j][i]), 0);
            ACCESS_SET(&(encod_obj[j][i]), READONLY);
            LENGTH(&(encod_obj[j][i])) = 0;
        }
    }

    encoding_setup();

    /* process encoding */
    for(i=0;i< NO_Encoding;i++){
        encoding_table_ptr = &Encoding_table[i];
        VALUE(&(encod_dict[i].k_obj)) =
               (ufix32)hash_id((ubyte FAR *)encoding_table_ptr->encoding_name ); /*@WIN*/
        TYPE_SET(&(encod_dict[i].v_obj), ARRAYTYPE);
        LENGTH(&(encod_dict[i].v_obj)) = encoding_table_ptr->encod_size;
        VALUE(&(encod_dict[i].v_obj)) = (ULONG_PTR)(ubyte FAR *)encod_obj[i]; /*@WIN*/
    }

    /* EncodingDirectory head information */
    DACCESS_SET(EncodDir, UNLIMITED);
    DPACK_SET(  EncodDir, FALSE);
    DFONT_SET(  EncodDir, FALSE);
    DROM_SET(   EncodDir, TRUE);
    EncodDir->actlength = (fix16)NO_Encoding;

#ifdef DBG
    printf("..Exit init_encoding_directory() \n");
#endif
    return(EncodDir);
} /* init_encoding_directory()  /


/* *********************************************************************** */
/* hash_id()                                                               */
/*      Get the name hash id                                               */
/* *********************************************************************** */
static ufix16  hash_id(c)
ubyte  FAR *c; /*@WIN*/
{
    fix16   id;

    if (!name_to_id(c, (ufix16)lstrlen(c), &id, (bool8) TRUE) ) { /*strlen=>lstrlen @WIN*/
        printf(" !! Can't get hash id(%s) !!\n", c);
        return(1);                   /* exit=>return @WIN*/
    }
#ifdef DBG
    printf("name=%s   \t hash_id=%d\n", c, id);
#endif

    return((ufix16)id);
} /* hash_id() */


/* *********************************************************************** */
/* encoding_setup()                                                        */
/*      Setup encoding array                                               */
/* *********************************************************************** */
static void near encoding_setup()
{
    static encoding_data   FAR * FAR *en_ary=Encoding_array; /*@WIN*/
    static encoding_data   FAR *encod_ptr; /*@WIN*/
    ufix16                 id_notdef, i, j;

    id_notdef = hash_id((ubyte FAR *) NOTDEF); /*@WIN*/
    for(encoding_table_ptr = Encoding_table, i = 0;
        encoding_table_ptr->encoding_name != (char FAR *)NULL; /*@WIN*/
        encoding_table_ptr++, i++) {
         if( encoding_table_ptr->encod_type == NAMETYPE ) {
             /* put /.notdef into the Encoding array */
             for(j=0; j<(ufix16)encoding_table_ptr->encod_size; j++) { //@WIN
                 encod_obj[i][j].value = (ufix32)id_notdef;
             }
         }
         else if(encoding_table_ptr->encod_type == INTEGERTYPE ) {
             for(j=0; j<(ufix16)encoding_table_ptr->encod_size; j++) { //@WIN
                 encod_obj[i][j].value = (ufix32)0;
             }
         }

         encod_ptr = en_ary[i];
         if( encoding_table_ptr->encod_type == NAMETYPE ) {
             while( !( encod_ptr->char_name == (byte FAR *)NULL ) ) { /*@WIN*/
#ifdef DBG
    printf("array_idx=%d  char_name=%s\n",
            encod_ptr->array_idx, encod_ptr->char_name );
#endif
                 encod_obj[i][encod_ptr->array_idx].value =
                               hash_id((ubyte FAR *) encod_ptr->char_name); /*@WIN*/
                 ++encod_ptr;         /* next encoding data */
             } /* while */
         }
         else if(encoding_table_ptr->encod_type == INTEGERTYPE ) {
             while( !( encod_ptr->char_name == (byte FAR *)NULL ) ) { /*@WIN*/
                 encod_obj[i][encod_ptr->array_idx].value =
                                  ascii2long(encod_ptr->char_name);
#ifdef DBG
    printf("array_idx=%d  char_name=%ld\n",
            encod_ptr->array_idx, encod_obj[i][encod_ptr->array_idx].value);
#endif
                 ++encod_ptr;         /* next encoding data */
             } /* while */
         }

    } /* for i=..*/

    return;
}/* encoding_setup() */

/* ****************************************************************** */
/*   calculate exponentation                                          */
/* ****************************************************************** */
static int
power(x,n)                      /* exponentation */
int x, n;
{
   int i,p;

   p = 1;
   for (i =1; i <= n; ++i)
       p = p * x;
   return(p);
}

/* ****************************************************************** */
/*   ascii to long                                                    */
/* ****************************************************************** */
static unsigned long int
ascii2long(addr)
char FAR *addr; /*@WIN*/
{
    unsigned long int    hex_addr;
    unsigned int         num[80], i, length;

    hex_addr=0L ;
    length = lstrlen(addr);     /* strlen=>lstrlen @WIN*/
    for (i = 0; i < length ; i++) {

        if (addr[i]== 'a' || addr[i] == 'A')
            num[i] = 10;
        else if (addr[i] == 'b' || addr[i] == 'B')
                 num[i] = 11;
        else if (addr[i] == 'c' || addr[i] == 'C')
                 num[i] = 12;
        else if (addr[i] == 'd' || addr[i] == 'D')
                 num[i] = 13;
        else if (addr[i]== 'e' || addr[i] == 'E')
                 num[i] = 14;
        else if (addr[i] == 'f' || addr[i] == 'F')
                 num[i] = 15;
        else num[i] = addr[i] - '0';
        hex_addr += num[i] * (power(10,(length-i-1)));
    }
    return(hex_addr);
} /* ascii2long */
#endif /* KANJI */

/* for cpmpatible with NTX */
/* struct object_def    nodef_dict; */
static void setup_nodef_dict()
{
  struct object_def    key_obj,val_obj;

    ATTRIBUTE_SET(&key_obj, LITERAL);
    ATTRIBUTE_SET(&val_obj, LITERAL);
    get_name(&key_obj, FontName, 8, TRUE);
    get_name(&val_obj, NotDefFont,11, TRUE);

    /* Kason 4/18/91, nodef_dict->current_font */
    create_dict(&current_font, 1);
    DACCESS_SET( (struct dict_head_def FAR *)VALUE(&current_font) , READONLY ); /*@WIN*/
    put_dict(&current_font, &key_obj, &val_obj);
} /*setup_nodef_dict()*/



BOOL PsOpenRes( PPS_RES_READ ppsRes, LPSTR lpName, LPSTR lpType )
{
   extern HANDLE hInst;
   HRSRC hFindRes,hLoadRes;
   DWORD dwSize;
   BOOL bRetVal = TRUE; // Success

    //
    // FDB - MIPS build problem.  wLanguage must be a word value, not NULL
    //  Win32API reference says to use the following to use the language
    //  associated with the calling thread.
    //

   hFindRes = FindResourceEx( hInst, lpType,lpName,MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));

   if (hFindRes) {

     ppsRes->dwSize = SizeofResource( hInst, hFindRes);

     hLoadRes = LoadResource( hInst, hFindRes);


     ppsRes->lpPtrBeg = (LPSTR) LockResource( (HGLOBAL) hLoadRes);
     ppsRes->dwCurIdx = 0;


   } else {
      bRetVal = FALSE;
   }



   return(bRetVal);


}



int PsResRead(PPS_RES_READ ppsRes, LPSTR pBuf, WORD wMaxSize )
{
  int iAmtToRead;

  iAmtToRead = wMaxSize;
  if (( iAmtToRead + ppsRes->dwCurIdx) > ppsRes->dwSize) {
     iAmtToRead = ppsRes->dwSize - ppsRes->dwCurIdx;
  }

  memcpy( pBuf, ppsRes->lpPtrBeg + ppsRes->dwCurIdx, iAmtToRead);


  ppsRes->dwCurIdx += iAmtToRead;

  return(iAmtToRead);

}

/* read in Encoding tables, SFNT glyph set, and  font data *** Begin *** @WIN*/

#define  STD_ENCONUM  256
#define  SYM_ENCONUM  200
#define  ZAP_ENCONUM  200
#define  SFNTGLYPHNUM  259
#define  JISENCONUM      256
#define  SJISENCONUM     256
#define  EXTSJISENCONUM  32
#define  KATAENCONUM     256

#define STRINGPOOLSIZE  65536L    /* @WIN */
static  char buf[BUFSIZE];
static  fix nCDCode;
static  fix nCharCode;
static  int nItems;
static int ReadTables ()
{
    // DJC int hfd;
    PS_RES_READ ResData;                   //DJC for reading encod.dat from res
    PPS_RES_READ hfd=&ResData;             //DJC for reading encod.dat from res



    char szTemp[255];  //DJC

            // Global allocate for encod_obj & encoding data;
    encod_obj = (struct object_def far * far *)
                fardata((ufix32)(EN_NO * 256 * sizeof(struct object_def)));
    Std_Enco = (enco_data far *)
                fardata((ufix32)(STD_ENCONUM * sizeof(enco_data)));
    Sym_Enco = (enco_data far *)
                fardata((ufix32)(SYM_ENCONUM * sizeof(enco_data)));
    Zap_Enco = (enco_data far *)
                fardata((ufix32)(ZAP_ENCONUM * sizeof(enco_data)));
    sfntGlyphSet = (byte far * FAR *)
                fardata((ufix32)(SFNTGLYPHNUM * sizeof(byte far *)));
    StringPool = (char far *)
                fardata((ufix32)STRINGPOOLSIZE);

#ifdef KANJI
    JISEncoding_Enco = (encoding_data FAR *)
                fardata((ufix32)(JISENCONUM * sizeof(encoding_data)));
    ShiftJISEncoding_Enco = (encoding_data FAR *)
                fardata((ufix32)(SJISENCONUM * sizeof(encoding_data)));
    ExtShiftJIS_A_CFEncoding_Enco = (encoding_data FAR *)
                fardata((ufix32)(EXTSJISENCONUM * sizeof(encoding_data)));
    KatakanaEncoding_Enco = (encoding_data FAR *)
                fardata((ufix32)(KATAENCONUM * sizeof(encoding_data)));
#endif

    /* allocate for "rtfpp.c" @WIN */
    #define NO_EN 3     /* copied from "dictdata.h" @WIN */
    en_obj = (struct object_def (FAR *)[256])
                fardata((ufix32)(NO_EN * 256 * sizeof(struct object_def)));

            // Read in Std_Enco, Sym_Enco, Zap_Enco, and sfntGlyphSet;
    lpStringPool = StringPool;
    //DJC if ((hfd = TTOpenFile((char FAR *)"EncodTbl.dat"))<0) {
    //DJC PsFormFullPathToCfgDir( szTemp, "EncodTbl.dat");
#ifdef DJC
    if ((hfd = TTOpenFile(szTemp))<0) {
        printf("Fatal error: file %s not found\n",szTemp);
        return 0;
    }
    //DJC test

#else
    //DJC new code to read data from resource

    PsOpenRes( hfd, "encodtbl", "RAWDATA");

#endif


    /* skip out comments */
    while (strlen(buf)<50 || buf[0] != '#'
                                 || buf[50] != '#') {
        ReadString(hfd, buf);
    }

    if(ReadEncoding (hfd, Std_Enco)) printf("Std_Enco table fail");
    if(ReadEncoding (hfd, Sym_Enco)) printf("Sym_Enco table fail");
    if(ReadEncoding (hfd, Zap_Enco)) printf("Zap_Enco table fail");
    if(ReadGlyphSet (hfd)) printf("SfntGlyphSet table fail");

#ifdef KANJI
    if(ReadJISEncoding (hfd, JISEncoding_Enco)) printf("JIS_Enco fail");
    if(ReadJISEncoding (hfd, ShiftJISEncoding_Enco)) printf("SJIS_Enco fail");
    if(ReadJISEncoding (hfd, ExtShiftJIS_A_CFEncoding_Enco)) printf("ExtSJIS_Enco fail");
    if(ReadJISEncoding (hfd, KatakanaEncoding_Enco)) printf("Kata_Enco fail");
#endif

    //DJC _lclose(hfd);

    /* set up encoding array; got from "dictdata.h": @WIN
     * enco_data FAR *Enco_Ary[]= { Std_Enco, Sym_Enco, Zap_Enco };
     */
    Enco_Ary[0] = Std_Enco;
    Enco_Ary[1] = Sym_Enco;
    Enco_Ary[2] = Zap_Enco;

#ifdef KANJI
    /* set up JISencoding array; got from "fontenco.h": @WIN
     * encoding_data    FAR *Encoding_array[]= {
     *    JISEncoding_Enco,                ShiftJISEncoding_Enco,
     *    ExtShiftJIS_A_CFEncoding_Enco,   KatakanaEncoding_Enco,
     *    NotDefEncoding_Enco
     * };
     */

    Encoding_array[0] = JISEncoding_Enco;
    Encoding_array[0] = ShiftJISEncoding_Enco;
    Encoding_array[0] = ExtShiftJIS_A_CFEncoding_Enco;
    Encoding_array[0] = KatakanaEncoding_Enco;
    Encoding_array[0] = NotDefEncoding_Enco;
#endif
    return(1);  // DJC to get rid of warning
}


//DJCstatic int ReadEncoding (int hfd, enco_data FAR *EncodingTable)
static int ReadEncoding (PPS_RES_READ hfd, enco_data FAR *EncodingTable)
{
   int i;

   ReadInteger(hfd, &nItems);

   for (i=0; i<nItems; i++) {
       ReadInteger(hfd, &nCDCode);
       ReadInteger(hfd, &nCharCode);
       ReadString(hfd, buf);

       EncodingTable[i].CDCode = (fix16)nCDCode;
       EncodingTable[i].CharCode = (ufix16)nCharCode;
       lstrcpy(lpStringPool, (LPSTR)buf);
       EncodingTable[i].CharName = lpStringPool;
       lpStringPool += strlen(buf) + 1;
   }

   EncodingTable[i].CDCode = (fix16)NULL;
   EncodingTable[i].CharCode = (ufix16)NULL;
   EncodingTable[i].CharName = (char FAR *)NULL;
   return 0;
}

//DJC static int ReadGlyphSet (int hfd)
static int ReadGlyphSet (PPS_RES_READ hfd)
{
   int i;

   ReadInteger(hfd, &nItems);

   for (i=0; i<nItems; i++) {
       ReadString(hfd, buf);

       lstrcpy(lpStringPool, (LPSTR)buf);
       sfntGlyphSet[i] = lpStringPool;
       lpStringPool += strlen(buf) + 1;
   }

   sfntGlyphSet[i] = (char FAR *)NULL;
   return 0;
}

#ifdef KANJI
//DJC static int ReadJISEncoding (int hfd, encoding_data FAR *EncodingTable)
static int ReadJISEncoding (PPS_RES_READ hfd, encoding_data FAR *EncodingTable)
{
   static fix  array_idx;
   int i;

   ReadInteger(hfd, &nItems);

   for (i=0; i<nItems; i++) {
       ReadInteger(hfd, &array_idx);
       ReadString(hfd, buf);

       EncodingTable[i].array_idx = (fix16)array_idx;
       lstrcpy(lpStringPool, (LPSTR)buf);
       EncodingTable[i].char_name = lpStringPool;
       lpStringPool += strlen(buf) + 1;
   }

   EncodingTable[i].array_idx = (fix16)NULL;
   EncodingTable[i].char_name = (char FAR *)NULL;
   return 0;
}
#endif

//DJC static int ReadString(int hfd, char * szCharName)
static int ReadString(PPS_RES_READ hfd, char * szCharName)
{
   int bData = FALSE;
   while(1) {
       // skip \n \r space
       while ((szReadBuf[nCurrent] == '\n' ||
               szReadBuf[nCurrent] == '\r' ||
               szReadBuf[nCurrent] == ' ') &&
               nCurrent < nLast) nCurrent++;

       // get another block
       if (nCurrent >= nLast) {
//         if ((nLast = read (hfd, szReadBuf, BUFSIZE)) <=0) return 0;
//           if ((nLast = _lread(hfd, (LPSTR)szReadBuf, (WORD)BUFSIZE))<=0)return 0;
           if ((nLast = PsResRead(hfd, (LPSTR)szReadBuf, (WORD)BUFSIZE))<=0)return 0;
           nCurrent = 0;
       }

       if((szReadBuf[nCurrent] == ' '   ||
           szReadBuf[nCurrent] == '\n' ||
           szReadBuf[nCurrent] == '\r')  && bData){
           *szCharName = 0;
           return TRUE;
       }

       // skip \n \r space
       while ((szReadBuf[nCurrent] == '\n' ||
               szReadBuf[nCurrent] == '\r' ||
               szReadBuf[nCurrent] == ' ') &&
               nCurrent < nLast) nCurrent++;

       while ((szReadBuf[nCurrent] != '\n' &&
               szReadBuf[nCurrent] != '\r' &&
               szReadBuf[nCurrent] != ' ') &&
               nCurrent < nLast){
               bData = TRUE;
               *szCharName++ = szReadBuf[nCurrent++];
       }
       if (nCurrent < nLast) {
           *szCharName = 0;
           return TRUE;
       }
   }

}

//DJC static int ReadInteger(int hfd, int * pInt)
static int ReadInteger(PPS_RES_READ hfd, int * pInt)
{
   *pInt = 0;   // init
   while(1) {
       // skip \n \r space
       while ((szReadBuf[nCurrent] == '\n' ||
               szReadBuf[nCurrent] == '\r' ||
               szReadBuf[nCurrent] == ' ') &&
               nCurrent < nLast) nCurrent++;

       // get another block
       if (nCurrent >= nLast) {
//         if ((nLast = read (hfd, szReadBuf, BUFSIZE)) <=0) return 0;
//           if ((nLast = _lread(hfd, (LPSTR)szReadBuf, (WORD)BUFSIZE))<=0)return 0;

           if ((nLast = PsResRead(hfd, (LPSTR)szReadBuf, (WORD)BUFSIZE))<=0)return 0;


           nCurrent = 0;
       }

       if((szReadBuf[nCurrent] == ' '   ||
           szReadBuf[nCurrent] == '\n' ||
           szReadBuf[nCurrent] == '\r')  && *pInt !=0) return TRUE;

       // skip \n \r space
       while ((szReadBuf[nCurrent] == '\n' ||
               szReadBuf[nCurrent] == '\r' ||
               szReadBuf[nCurrent] == ' ') &&
               nCurrent < nLast) nCurrent++;

       while ((szReadBuf[nCurrent] != '\n' &&
               szReadBuf[nCurrent] != '\r' &&
               szReadBuf[nCurrent] != ' ') &&
               nCurrent < nLast) {
             *pInt= *pInt * 10 + szReadBuf[nCurrent++] - '0';
       }
       if (nCurrent < nLast) return TRUE;
   }

}
/* read in Encoding tables, SFNT glyph set, and  font data ***  End  *** @WIN*/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\font_op1.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */


// DJC added global include
#include "psglobal.h"

#define    LINT_ARGS            /* @WIN */
#define    NOT_ON_THE_MAC       /* @WIN */
#define    KANJI                /* @WIN */
// DJC use commandline #define    UNIX                 /* @WIN */
/**************************************************************/
/*                                                            */
/*      font_op1.c               10/9/87      Danny           */
/*                                                            */
/**************************************************************/

#define    FONT_OP1_INC
#define    EM      1000    /* EMsquare, DLF, 05/08/91 Kason */
/* #define DLF42    |* feature for TrueType PostScript Font Format */

//DJC uncoment to match SC code
#define DLF42    // feature for TrueType PostScript Font Format //DJC uncomented

#include   <stdio.h>
#include   <string.h>

#include   "define.h"        /* Peter */
#include   "global.ext"
#include   "graphics.h"
#include   "graphics.ext"

#include   "font_sys.h"    /* for MAX_UNIQUEID */
#include   "fontgrap.h"
#include   "fontkey.h"
#include   "fontdict.h"
#include   "fntcache.ext"
#ifdef SFNT
#include   "fontqem.ext"
#endif

#ifdef KANJI
#include   "mapping.h"
#endif

#include   "fontfunc.ext"

#include   "stdio.h"

#ifdef LINT_ARGS
    static void near    fetch_oprn_fdict (struct object_def FAR *, ufix32 FAR *, bool FAR *,
                                struct dict_head_def FAR * FAR *, real32 FAR [], real32 FAR []); /*@WIN*/
    static void near    create_new_fdict (struct object_def FAR *,
                                struct object_def FAR *, bool, real32 FAR [], real32 FAR []); /*@WIN*/
#else
    static void near    fetch_oprn_fdict ();
    static void near    create_new_fdict ();
#endif



/* 5.3.3.1 Font Operators Module
 * 5.3.3.1.1 op_definefont
 * This operator is used to register font as a font dictionary.
 */

fix     op_definefont()
{

#ifdef SFNT
    struct dict_head_def    FAR *h;     /*@WIN*/
#else
    struct dict_head_def    FAR *h, FAR *privdict_h; /*@WIN*/
    struct object_def       FAR *privobj_got; /*@WIN*/
#endif
    fix32                   f_type;
    ufix32                  fid, uid;
    struct object_def       nameobj = {0, 0, 0}, fid_valobj;
    struct object_def       FAR *obj_got; /*@WIN*/
    /*DLF42*/
    struct object_def       FAR *mtx_got, FAR *fbox_got; /*@WIN*/

#ifdef KANJI
    fix32                   fm_type;
    struct object_def       mid_obj, val_obj;
    struct comdict_items    items;
#endif


    static struct object_def FAR *fontdir_obj = NULL; /*@WIN*/

#ifdef DBG0
    printf("Definefont:\n");
#endif

    /*
     * Check Existence of Required Items:FontMatrix,FontBBox,Encoding,FontType.
     */

    ATTRIBUTE_SET(&nameobj, LITERAL);
    LEVEL_SET(&nameobj, current_save_level);

    /* check FontMatrix */
    get_name(&nameobj, FontMatrix, 10, TRUE);
    if (!get_dict(GET_OPERAND(0), &nameobj, &mtx_got)) {  /* obj_got->mtx_got , DLF42 */
        ERROR(INVALIDFONT);
        return(0);
    }

#ifndef KANJI
    /* check FontBBox */
    get_name(&nameobj, FontBBox, 8, TRUE);
    if (!get_dict(GET_OPERAND(0), &nameobj, &fbox_got)) {  /* obj_got->fbox_got , DLF42  */
        ERROR(INVALIDFONT);
        return(0);
    }
#endif

    /* check Encoding */
    get_name(&nameobj, Encoding, 8, TRUE);
    if (!get_dict(GET_OPERAND(0), &nameobj, &obj_got)) {  /* 11/24/87 */
        ERROR(INVALIDFONT);
        return(0);
    }

#ifdef KANJI
    items.encoding = obj_got;
#endif

    /* check and get FontType from font */
    get_name(&nameobj, FontType, 8, TRUE);
    if (!get_dict(GET_OPERAND(0), &nameobj, &obj_got)) {  /* 11/24/87 */
        ERROR(INVALIDFONT);
        return(0);
    }
    if (!cal_integer(obj_got, &f_type))   f_type = -1L;   /* for later use */

    /* Get FID from font */
    get_name(&nameobj, FID, 3, TRUE);
    if (get_dict(GET_OPERAND(0), &nameobj, &obj_got)) {
        ERROR(INVALIDFONT);     /* FID entry already in the font dictionary */
        return(0);
    }


#ifdef KANJI

/* generate MIDVector and CurMID entries for Composite Font */

    if (f_type == 0L) {

        /* Get PrefEnc from font */
        get_name(&nameobj, PrefEnc, 7, TRUE);
        if (!get_dict(GET_OPERAND(0), &nameobj, &obj_got)) {
            TYPE_SET(&val_obj, NULLTYPE);
            ACCESS_SET(&val_obj, READONLY);
            ATTRIBUTE_SET(&val_obj, LITERAL);
            ROM_RAM_SET(&val_obj, RAM);
            LEVEL_SET(&val_obj, current_save_level);
            LENGTH(&val_obj) = 0;
            VALUE(&val_obj) = 0L;

            if ( ! put_dict(GET_OPERAND(0), &nameobj, &val_obj) ) {
                ERROR(DICTFULL);    /* Return with 'dictfull' error; */
                return(0);
            }
        }
       /* Get MIDVector from font */
        get_name(&nameobj, MIDVector, 9, TRUE);
        if (get_dict(GET_OPERAND(0), &nameobj, &obj_got)) {
            ERROR(INVALIDFONT);
            /* MIDVector entry already in the font dictionary */
            return(0);
        }

        /* Get CurMID from font */
        get_name(&nameobj, CurMID, 6, TRUE);
        if (get_dict(GET_OPERAND(0), &nameobj, &obj_got)) {
            ERROR(INVALIDFONT);
            /* CurMID entry already in the font dictionary */
            return(0);
        }

        /* check FDepVector */
        get_name(&nameobj, FDepVector, 10, TRUE);
        if (!get_dict(GET_OPERAND(0), &nameobj, &obj_got)) {
            ERROR(INVALIDFONT);
            return(0);
        }
        items.fdepvector = obj_got;

        /* check FMapType */
        get_name(&nameobj, FMapType, 8, TRUE);
        if (!get_dict(GET_OPERAND(0), &nameobj, &obj_got)) {
            ERROR(INVALIDFONT);
            return(0);
        }
        if (!cal_integer(obj_got, &fm_type)) {
            ERROR(TYPECHECK);
            return(0);
        }
        items.fmaptype = obj_got;

        /* check SubsVector */
        if (fm_type == 6L) {
            get_name(&nameobj, SubsVector, 10, TRUE);
            if (!get_dict(GET_OPERAND(0), &nameobj, &obj_got)) {
                ERROR(INVALIDFONT);
                return(0);
            }
            items.subsvector = obj_got;
        }
        /* check EscChar */
        if (fm_type == 3) {
            get_name(&nameobj, EscChar, 7, TRUE);
            if (!get_dict(GET_OPERAND(0), &nameobj, &obj_got)) {
                TYPE_SET(&val_obj, INTEGERTYPE);
                ACCESS_SET(&val_obj, READONLY);
                ATTRIBUTE_SET(&val_obj, LITERAL);
                ROM_RAM_SET(&val_obj, RAM);
                LEVEL_SET(&val_obj, current_save_level);
                LENGTH(&val_obj) = 0;
                VALUE(&val_obj) = 0x000000ffL;

                if ( ! put_dict(GET_OPERAND(0), &nameobj, &val_obj) ) {
                    ERROR(DICTFULL);    /* Return with 'dictfull' error; */
                    return(0);
                }
            }
        }

        /* generate MIDVector */
        if (!define_MIDVector(&mid_obj, &items))
            return(0);

        get_name (&nameobj, MIDVector, 9, TRUE);
        if ( ! put_dict(GET_OPERAND(0), &nameobj, &mid_obj) ) {
            ERROR(DICTFULL);    /* Return with 'dictfull' error; */
            return(0);
        }
        get_name (&nameobj, CurMID, 6, TRUE);
        if ( ! put_dict(GET_OPERAND(0), &nameobj, &mid_obj) ) {
            ERROR(DICTFULL);    /* Return with 'dictfull' error; */
            return(0);
        }
    }
    else {
        /* check FontBBox */
        get_name(&nameobj, FontBBox, 8, TRUE);
        if (!get_dict(GET_OPERAND(0), &nameobj, &fbox_got)) {  /* obj_got->fbox_got, DLF42 */
            ERROR(INVALIDFONT);
            return(0);
        }
    }

/* KANJI */
#endif

 /*DLF42-begin*/
#ifdef DLF42
    h = (struct dict_head_def FAR *)VALUE(GET_OPERAND(0)); /*@WIN*/
    if ( (!DROM(h))&&(f_type==TypeSFNT) ) {  /* downloaded TrueType font */
        long32 n;
        fix16  i;
        real32 f = (real32)1.0 ;  /* [1*narrow 0 narrow*tan(theta) 1 0 0] */
        struct object_def FAR *ary_obj= (struct object_def FAR *)VALUE(mtx_got); /*@WIN*/
        if ( cal_num((ary_obj+3), &n ) ) {     /* real or integer */
             if ( n == F2L(f) ) {  /* FontMatrix = [ 1*narrow 0 narrow*tan(theta) 1 0 0 ] */

                 /* change FontMatrix to [ .001*narrow 0 .001*narrow*tan(theta) .001 0 0 ] */
                  for ( i=0 ; i<4 ; i++ ) {
                      if ( cal_num( (ary_obj+i), &n ) ) {
                           f = L2F(n)/EM;
                           TYPE_SET((ary_obj+i), REALTYPE);
                           VALUE ( (ary_obj+i) ) = F2L(f);
                      }/*if*/
                  }/*for*/

                  /* FontBBox bust be multiplied by EM */
                  ary_obj = (struct object_def FAR *)VALUE(fbox_got); /*@WIN*/
                  for ( i=0 ; i<4 ; i++ ) {
                      if ( cal_num( (ary_obj+i), &n ) ) {
                           f = L2F(n)*EM;
                           n = (long32)( (f>=0)? (f+0.5):(f-0.5) );
                           TYPE_SET((ary_obj+i), INTEGERTYPE);
                           VALUE ( (ary_obj+i) ) = n;
                      }/*if*/
                  }/*for*/
             }/*if*/
        }/*if*/
    }/*if*/
#endif
 /*DLF42-end*/

    /* get UniqueID */
    get_name(&nameobj, UniqueID, 8, TRUE);
    if ( get_dict(GET_OPERAND(0), &nameobj, &obj_got) &&
         cal_integer(obj_got, (fix31 FAR *)&uid)) { /*@WIN*/
        if (uid > MAX_UNIQUEID) {
            ERROR(INVALIDFONT);
            return(0);
        }
    } else          /* no UniqueID or non-integer ==> ignore UniqueID */
        uid = MAX_UNIQUEID + 1;

#ifdef DBG0
    printf ("  UniqueID=%ld (0x%lX)\n", uid, uid);
#endif

#ifdef SFNT
    /* generate an FID */
    fid = gen_fid (GET_OPERAND(0), (ufix8)f_type, uid);

#else
    /* get Private for Buit-In Fonts, if UniqueID given */
    if (f_type == 3L)
        privdict_h = (struct dict_head_def FAR *)NULL;  /*@WIN*/
    else if (uid <= MAX_UNIQUEID) {     /* for built-in fonts only */
        get_name(&nameobj, Private, 7, FALSE);
        if (!get_dict(GET_OPERAND(0), &nameobj, &privobj_got)) {
            POP(1);
            PUSH_OBJ(&nameobj);
            ERROR(UNDEFINED);
            return(0);
        }
        if (TYPE(privobj_got) != DICTIONARYTYPE) {
            ERROR(INVALIDFONT);     /* LW+ V.38 may crash in such a case. */
            return(0);
        }
        privdict_h = (struct dict_head_def FAR *)VALUE(privobj_got); /*@WIN*/
    }


    /* generate an FID */
    fid = gen_fid (GET_OPERAND(0), (ufix8)f_type, uid, privdict_h);
#endif

    if (ANY_ERROR())    return(0);

#ifdef DBG0
    printf("  FID=%ld (0x%lX)\n", fid, fid);
#endif

    /*
     * Put /FID into the font dictionary with NOACCESS.
     */
    TYPE_SET(&fid_valobj, FONTIDTYPE);
    ACCESS_SET(&fid_valobj, NOACCESS);
    ATTRIBUTE_SET(&fid_valobj, LITERAL);
    ROM_RAM_SET(&fid_valobj, RAM);
    LEVEL_SET(&fid_valobj, current_save_level);
    LENGTH(&fid_valobj) = 0;  /* NULL; Peter */
    VALUE(&fid_valobj) = fid;

    get_name (&nameobj, FID, 3, TRUE);
    if ( ! put_dict(GET_OPERAND(0), &nameobj, &fid_valobj) ) {
            /* Can't put /FID key into font dictionary */
        ERROR(DICTFULL);    /* Return with 'dictfull' error; */
        return(0);
    }

    /*
     * get FontDirectory if not got yet.
     */
    if (fontdir_obj == (struct object_def FAR *)NULL) /*@WIN*/
        get_dict_value (systemdict, FontDirectory, &fontdir_obj);

    /*
     * put the name obj and value obj of the font into FontDirectory
     *              with READONLY.
     */
    if ( ! put_dict(fontdir_obj, GET_OPERAND(1), GET_OPERAND(0)) ) {
        ERROR(DICTFULL);    /* Return with 'dictfull' error; */
        return(0);
    }

    h = (struct dict_head_def FAR *)VALUE(GET_OPERAND(0));  /* 11/25/87 @WIN*/
    DACCESS_SET(h, READONLY);
    DFONT_SET(h, TRUE); /* font dict registrated */

    /* push the font dictionary after definefont onto the operand stack */
    COPY_OBJ(GET_OPERAND(0), GET_OPERAND(1));
    POP(1);             /* pop 1 entries off the operand stack */


    return(0);

} /* op_definefont() */


/* fetch_oprn_fdict */

static  void near   fetch_oprn_fdict (fdict, fid,
                                origfont_exist, origfont, fontmatr, scalematr)
    struct object_def      FAR *fdict;          /* i: fontdict (operand(0)) @WIN*/
    ufix32                 FAR *fid;            /* o: fid in dict @WIN*/
    bool                   FAR *origfont_exist; /* o: origfont exist in dict? @WIN*/
    struct dict_head_def  FAR * FAR *origfont;       /* o: origfont dict head  @WIN*/
    real32                 FAR fontmatr[];     /* o: fontmatrix in dict  @WIN*/
    real32                 FAR scalematr[];    /* o: scalematrix in dict @WIN*/
{
    struct object_def      FAR *obj_got; /*@WIN*/
    struct object_def       nameobj = {0, 0, 0}, FAR *valobj_got;   /*@WIN*/
    fix                     ii;

    /* check font dictionary registration */
    if (DFONT((struct dict_head_def FAR *)VALUE(fdict)) == 0) { /*@WIN*/
#ifdef DBG1
    printf("\n--- get_font() error\n");
#endif
        ERROR(INVALIDFONT);
        return;
    }

    /* init name object to get_dict() */
    ATTRIBUTE_SET(&nameobj, LITERAL);
    LEVEL_SET(&nameobj, current_save_level);

    /* check, get FID and return it */
    get_name(&nameobj, FID, 3, TRUE);
    ii = get_dict(fdict, &nameobj, &obj_got);
    *fid = (ufix32)VALUE(obj_got);
#ifdef DBG1
    if ( (!ii) || (TYPE(obj_got) != FONTIDTYPE) ) {
        printf("\nERR: FID not in font_obj entry\n");
        return;
    }
#endif

    /* check, get FontMatrix and return it */
    get_name(&nameobj, FontMatrix, 10, TRUE);
    ii = get_dict(fdict, &nameobj, &obj_got);
#ifdef DBG1
    if (!ii) {
        printf("\nERR: FontMatrix not in dict\n");
        return;
    }
#endif
    if (TYPE(obj_got)!=ARRAYTYPE) {  /* 1/8/90*/
        ERROR(TYPECHECK);
        return;
    }
    if (LENGTH(obj_got)!=6) {  /* 1/8/90 */
        ERROR(RANGECHECK);
        return;
    }
    valobj_got = (struct object_def FAR *) VALUE(obj_got);  /* fontmatr array @WIN*/
    if (  !cal_num(&valobj_got[0], (long32 FAR *)&fontmatr[0]) || /*@WIN*/
          !cal_num(&valobj_got[1], (long32 FAR *)&fontmatr[1]) || /*@WIN*/
          !cal_num(&valobj_got[2], (long32 FAR *)&fontmatr[2]) || /*@WIN*/
          !cal_num(&valobj_got[3], (long32 FAR *)&fontmatr[3]) || /*@WIN*/
          !cal_num(&valobj_got[4], (long32 FAR *)&fontmatr[4]) || /*@WIN*/
          !cal_num(&valobj_got[5], (long32 FAR *)&fontmatr[5]) ) { /*@WIN*/
        ERROR(TYPECHECK);
        return;
    }

    /* get OrigFont if any, or define OrigFont (i.e. OPERAND(1)). */
    get_name(&nameobj, OrigFont, 8, TRUE);
    if (get_dict(fdict, &nameobj, &obj_got)) {
        *origfont_exist = TRUE;
        *origfont = (struct dict_head_def FAR *) VALUE(obj_got); /*@WIN*/
        if (TYPE(obj_got) != DICTIONARYTYPE) {
            ERROR (INVALIDACCESS);
            return;
        }
    } else {
        *origfont_exist = FALSE;
        *origfont = (struct dict_head_def FAR *) VALUE(fdict); /*@WIN*/
    }

    /* get ScaleMatrix if any, or define it (identity matrix). */
    get_name (&nameobj, ScaleMatrix, 11, TRUE);
    if (!get_dict(fdict, &nameobj, &obj_got)) {
        scalematr[0] = scalematr[3] = (real32)1.0;
        scalematr[1] = scalematr[2] = scalematr[4] = scalematr[5] = zero_f;
    } else {
        if (TYPE(obj_got)!=ARRAYTYPE) {  /* 1/8/90*/
            ERROR(TYPECHECK);
            return;
        }
        if (LENGTH(obj_got)!=6) {  /* 1/8/90 */
            ERROR(RANGECHECK);
            return;
        }
        valobj_got = (struct object_def FAR *) VALUE(obj_got); /*@WIN*/
        if (  !cal_num(&valobj_got[0], (long32 FAR *)&scalematr[0]) || /*@WIN*/
              !cal_num(&valobj_got[1], (long32 FAR *)&scalematr[1]) || /*@WIN*/
              !cal_num(&valobj_got[2], (long32 FAR *)&scalematr[2]) || /*@WIN*/
              !cal_num(&valobj_got[3], (long32 FAR *)&scalematr[3]) || /*@WIN*/
              !cal_num(&valobj_got[4], (long32 FAR *)&scalematr[4]) || /*@WIN*/
              !cal_num(&valobj_got[5], (long32 FAR *)&scalematr[5]) ) {/*@WIN*/
            ERROR(TYPECHECK);
            return;
        }
    };

    return;

} /* fetch_oprn_fdict */

/* create_new_fdict */

static  void near   create_new_fdict (newdict_obj, olddict_obj,
                                        origfont_exist, scalematr, fontmatr)
    struct object_def   FAR *newdict_obj;   /* o: returned new font dict object @WIN*/
    struct object_def   FAR *olddict_obj;   /* i: old font dict object @WIN*/
    bool            origfont_exist;     /* i: OrigFont exist? */
    real32          FAR scalematr[];        /* i: new ScaleMatrix @WIN*/
    real32          FAR fontmatr[];         /* i: new FontMatrix  @WIN*/
{
    struct object_def       nameobj = {0, 0, 0}, array_obj, FAR *aryval_got; /*@WIN*/
    struct dict_head_def    FAR *newdict_h, FAR *olddict_h; /*@WIN*/
    register    fix                     ii;

    olddict_h = (struct dict_head_def FAR *) VALUE(olddict_obj); /*@WIN*/
    ATTRIBUTE_SET(&nameobj, LITERAL);
    LEVEL_SET(&nameobj, current_save_level);

    /* create a new dictionary */
    if ( !create_dict (newdict_obj,
            (ufix16) (olddict_h->actlength + (origfont_exist? 0 : 2))) ) {
        ERROR(VMERROR);             /* if OrigFont exist, ScaleMatrix   */
        return;                     /*      is assumed there also.      */
    }
    ACCESS_SET(newdict_obj, READONLY);
    newdict_h = (struct dict_head_def FAR *) VALUE(newdict_obj); /*@WIN*/

    /* duplicate font into font'; */
    if (DROM(olddict_h)) {
        copy_fdic(olddict_obj, newdict_obj);
    } else {
        if (!copy_dict(olddict_obj, newdict_obj)) {
#ifdef DBG1
            printf("cannot copy_dict()\n");
#endif
            return;
        }
    }

    /* Put OrigFont in font' if not exist; */
    if (!origfont_exist) {
        get_name(&nameobj, OrigFont, 8, TRUE);

        ATTRIBUTE_SET(&nameobj, EXECUTABLE);
        put_dict(newdict_obj, &nameobj, olddict_obj);
        ATTRIBUTE_SET(&nameobj, LITERAL);
    }

    /* Put ScaleMatrix into font'; */
    if (!create_array(&array_obj, 6)) {
#ifdef DBG1
        printf("cannot create array for ScaleMatrix\n");
#endif
        ERROR(VMERROR);
        return;
    }
    ACCESS_SET(&array_obj, READONLY);
    aryval_got = (struct object_def FAR *)VALUE(&array_obj); /*@WIN*/
    for (ii=0; ii<6; ii++) {
        TYPE_SET(&aryval_got[ii], REALTYPE);
        ACCESS_SET(&aryval_got[ii], READONLY);
        ATTRIBUTE_SET(&aryval_got[ii], LITERAL);
        ROM_RAM_SET(&aryval_got[ii], RAM);
        LEVEL_SET(&aryval_got[ii], current_save_level);
        LENGTH(&aryval_got[ii]) = 0;    /* NULL   Peter */
        VALUE(&aryval_got[ii]) = *(ufix32 FAR *)(&scalematr[ii]); /*@WIN*/
    }
    ATTRIBUTE_SET(&nameobj, LITERAL);
    get_name(&nameobj, ScaleMatrix, 11, TRUE);
    ATTRIBUTE_SET(&nameobj, EXECUTABLE);
    if (!put_dict(newdict_obj, &nameobj, &array_obj)) {
#ifdef DBG1
        printf("cannot put_dict() for ScaleMatrix\n");
#endif
        ERROR(DICTFULL);
        return;
    }

    /* put FontMatrix in font' */
    if (!create_array(&array_obj, 6)) {
#ifdef DBG1
        printf("cannot create array for FontMatrix\n");
#endif
        ERROR(VMERROR);
        return;
    }
    ACCESS_SET(&array_obj, READONLY);
    aryval_got = (struct object_def FAR *)VALUE(&array_obj); /*@WIN*/
    for (ii=0; ii<6; ii++) {
        TYPE_SET(&aryval_got[ii], REALTYPE);
        ACCESS_SET(&aryval_got[ii], READONLY);
        ATTRIBUTE_SET(&aryval_got[ii], LITERAL);
        ROM_RAM_SET(&aryval_got[ii], RAM);
        LEVEL_SET(&aryval_got[ii], current_save_level);
        LENGTH(&aryval_got[ii]) = 0;   /* NULL;   Peter */
        VALUE(&aryval_got[ii]) = *(ufix32 FAR *)(&fontmatr[ii]); /*@WIN*/
    }
    ATTRIBUTE_SET(&nameobj, LITERAL);
    get_name(&nameobj, FontMatrix, 10, TRUE);
    ATTRIBUTE_SET(&nameobj, EXECUTABLE);
    if (!put_dict(newdict_obj, &nameobj, &array_obj)) {
#ifdef DBG1
        printf("cannot put_dict() for FontMatrix\n");
#endif
        ERROR(DICTFULL);
        return;
    }

    DACCESS_SET(newdict_h, READONLY);
    DFONT_SET(newdict_h, TRUE);
    DROM_SET(newdict_h, DROM(olddict_h));

    return;

} /* update_new_fdict */



/* 5.3.3.1.3 op_scalefont
 * This operator is used to scale font by scale to produce new font'.
 */

fix     op_scalefont()
{
    real32                  scale, scalematr[6], fontmatr[6];
    ufix32                  fid;
    struct dict_head_def   FAR *origfont; /*@WIN*/
    bool                    origfont_exist;
    struct object_def      FAR *cached_dictobj, newdict_obj; /*@WIN*/
    register    fix                     ii;

#ifdef DBG
    printf("Scalefont:\n");
#endif

    /* get "scale" operand */
    cal_num((struct object_def FAR *)GET_OPERAND(0), (long32 FAR *)(&scale)); /*@WIN*/

    /* fetch necessary info. for scalefont or makefont */
    fetch_oprn_fdict (GET_OPERAND(1), &fid,
                            &origfont_exist, &origfont, fontmatr, scalematr);
    if (ANY_ERROR())    return (0);

    /* calculate ScaleMatrix' <-- ScaleMatrix * "scale" */
    for (ii=0; ii<6; ii++)
        scalematr[ii] *= scale;

    /* if the dict is in cache already? */
    if (is_dict_cached (fid, scalematr, origfont, &cached_dictobj)) {
        POP (2);                        /* pop off "dict" "scale" */
        PUSH_OBJ (cached_dictobj);      /* push the cached dict */
        return (0);
    }

    /* calculate FontMatrix' <-- FontMatrix * "scale" */
    for (ii=0; ii<6; ii++)
        fontmatr[ii] *= scale;

    /*
     * create a new font dict. and update ScaleMatrix, FontMatrix as necessary.
     */
    create_new_fdict (&newdict_obj, GET_OPERAND(1),
                            origfont_exist, scalematr, fontmatr);
    if (ANY_ERROR())    return (0);

   /*
    * cache the new font dictionary.
    */
    cached_dictobj = cache_dict (fid, scalematr, origfont, &newdict_obj);

    POP(2);    /* Pop 2 entries off the operand stack; */

   /* push the new font dictionary onto the operand stack; */
    PUSH_OBJ (cached_dictobj);

    return(0);

} /* op_scalefont() */


/* 5.3.3.1.4 op_makefont
 *  This operator is used to transform font by matrix to produce new font'.
 */

fix     op_makefont()
{
    real32          makematr[6], scalematr[6], fontmatr[6], tmpmatr[6];
    ufix32                  fid;
    struct dict_head_def   FAR *origfont; /*@WIN*/
    bool                    origfont_exist;
    struct object_def      FAR *aryval_got, FAR *cached_dictobj, newdict_obj; /*@WIN*/

#ifdef DBG2
    printf("Makefont:\n");
#endif

    /* check MakeMatrix */
    if (LENGTH(GET_OPERAND(0)) != 6) {
        ERROR(TYPECHECK);
        return(0);
    }

    /* fetch necessary info. for scalefont or makefont */
    fetch_oprn_fdict (GET_OPERAND(1), &fid,
                            &origfont_exist, &origfont, fontmatr, scalematr);
    if (ANY_ERROR())    return (0);

    /* calculate MakeMatrix */
    aryval_got = (struct object_def FAR *)VALUE(GET_OPERAND(0)); /*@WIN*/
    if (    !cal_num(&aryval_got[0], (long32 FAR *)&makematr[0]) || /*@WIN*/
            !cal_num(&aryval_got[1], (long32 FAR *)&makematr[1]) || /*@WIN*/
            !cal_num(&aryval_got[2], (long32 FAR *)&makematr[2]) || /*@WIN*/
            !cal_num(&aryval_got[3], (long32 FAR *)&makematr[3]) || /*@WIN*/
            !cal_num(&aryval_got[4], (long32 FAR *)&makematr[4]) || /*@WIN*/
            !cal_num(&aryval_got[5], (long32 FAR *)&makematr[5]) ) {/*@WIN*/
        ERROR(TYPECHECK);
        return(0);
    }

   /* calculate new ScaleMatrix <-- ScaleMatrix * MakeMarix */
    mul_matrix(tmpmatr, scalematr, makematr);
    lmemcpy ((ubyte FAR *)scalematr, (ubyte FAR *)tmpmatr, 6*sizeof(real32)); /*@WIN*/

    /* if the dict is in cache already? */
    if (is_dict_cached (fid, scalematr, origfont, &cached_dictobj)) {
        POP (2);                        /* pop off "dict" "scale" */
        PUSH_OBJ (cached_dictobj);      /* push the cached dict */
        return (0);
    }

   /* calculate new FontMatrix <-- FontMatrix * MakeMarix */
    mul_matrix(tmpmatr, fontmatr, makematr);
    lmemcpy ((ubyte FAR *)fontmatr, (ubyte FAR *)tmpmatr, 6*sizeof(real32)); /*@WIN*/

    /*
     * create a new font dict. and update ScaleMatrix, FontMatrix as necessary.
     */
    create_new_fdict (&newdict_obj, GET_OPERAND(1),
                            origfont_exist, scalematr, fontmatr);
    if (ANY_ERROR())    return (0);

   /*
    * cache the new font dictionary.
    */
    cached_dictobj = cache_dict (fid, scalematr, origfont, &newdict_obj);

    POP(2);    /* Pop 2 entries off the operand stack; */

   /* push the new font dictionary onto the operand stack; */
    PUSH_OBJ (cached_dictobj);

    return(0);

} /* op_makefont() */


/* 5.3.3.1.5 op_setfont
 * This operator is used to set the current font dictionary.
 */

fix     op_setfont()
{

/* do setfont operation */

    do_setfont(GET_OPERAND(0));

#ifdef KANJI

/* Set root font */

    COPY_OBJ(GET_OPERAND(0), &RootFont);
          /* root font <-- font; */

#endif


    POP(1);    /* Pop 1 entry off the operand stack; */
    return(0);

} /* op_setfont() */


/* 5.3.3.1.6 op_currentfont
 * This operator is used to get the current font dictionary.
 */

/* extern struct object_def    nodef_dict; */
fix     op_currentfont()
{
/* Get Current font dictionary */

    if (FRCOUNT() < 1) {    /* free count of the operand stack */
        ERROR(STACKOVERFLOW); /* Return with 'stackoverflow' error */
        return(0);
    }

/* Push the current font dictionary onto the operand stack; */
/* the initial value of the current font is NULL */
#if 0 /* Kason 4/18/91 */
    if ( TYPE(&current_font)== NULLTYPE ) {
       PUSH_OBJ(&nodef_dict);
    } else {
       PUSH_OBJ(&current_font);
    }/*if*/
#endif
    PUSH_OBJ(&current_font);

    return(0);

} /* op_currentfont() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\fontshow.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/************* show flag ******************

  This is a one byte flag to indicate variate actions as following:

  +---+---+---+---+---+---+---+---+
  | a | w | h | f | k | c | m | X |
  +---+---+---+---+---+---+---+---+

  "a" bit -- ashow advance vector adjust bit flag
  "w" bit -- widthshow advance vector adjust bit flag
  "h" bit -- whether to get char information from cache or not
             0 : cache information not required
             1 : cache information required
  "f" bit -- 0 : get bitmap information from cache(show_from_cache)
             1 : get width information from cache (width_from_cache)
  "k" bit -- kshow operator indicator
  "c" bit -- cshow operator indicator
  "m" bit -- whether to call moveto() or not
             0 : don't call
             1 : call it
  "X" bit -- don't care

  FLAGS --
   . SHOW         --  0010 0010
   . ASHOW        --  1010 0010
   . WIDTHSHOW    --  0110 0010
   . AWIDTHSHOW   --  1110 0010
   . CHARPATH     --  0000 0000
   . STRINGWIDTH  --  0011 0000
   . KSHOW        --  0010 1010
   . CSHOW        --  0011 0100

******************************************************/

#define        A_BIT        0x0080
#define        W_BIT        0x0040
#define        H_BIT        0x0020
#define        F_BIT        0x0010
#define        K_BIT        0x0008
#define        C_BIT        0x0004
#define        M_BIT        0x0002
#ifdef WINF/* 3/21/91 ccteng */
#define         X_BIT           0x0001
#endif

#define        SHOW_FLAG           0x0022
#define        ASHOW_FLAG          0x00a2
#define        WIDTHSHOW_FLAG      0x0062
#define        AWIDTHSHOW_FLAG     0x00e2
#define        CHARPATH_FLAG       0x0000
#define        STRINGWIDTH_FLAG    0x0030
#define        KSHOW_FLAG          0x002a
#define        CSHOW_FLAG          0x0034


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\font_op2.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */


// DJC added global include
#include "psglobal.h"

#define    LINT_ARGS            /* @WIN */
#define    NOT_ON_THE_MAC       /* @WIN */
#define    KANJI                /* @WIN */
// DJC use command line #define    UNIX                 /* @WIN */
/**************************************************************/
/*                                                            */
/*      font_op2.c               10/9/87      Danny           */
/*                                                            */
/**************************************************************/

#include   "define.h"        /* Peter */
#include   "global.ext"
#include   "graphics.h"
#include   "graphics.ext"

#include   "fontshow.h"

#include   "fontfunc.ext"


/* 5.3.3.1.7 op_show
 *  This operator is used to print the characters identified by the
 * elements of string on the current page starting at the current point,
 * using the font face, size, and orientationspecified by the most
 * recent setfont.
 */

fix     op_show()
{
    struct object_def  ob[1];

    __show((ufix)SHOW_FLAG, 1, ob);
    return(0);

} /* op_show() */


/* 5.3.3.1.8 op_ashow
 * This operator is used to print the characters identified by the
 * elements of string on the current page starting at the current point,
 * using the font face, size, and orientationspecified by the most
 * recent setfont. Additionally, ashow adjusts the width of each character
 * by a vector which is in the operand stack.
 */

fix     op_ashow()
{
    struct object_def  ob[3];

    __show((ufix)ASHOW_FLAG, 3, ob);
    return(0);

} /* op_ashow() */


/* 5.3.3.1.9 op_widthshow
 * This operator is used to print the characters identified by the
 * elements of string on the current page starting at the current point,
 * using the font face, size, and orientation specified by the most
 * recent setfont. Additionally, widthshow adjusts the width of each
 * occurrence of the specified character by adding a vector to its
 * character width vector.
 */

fix     op_widthshow()
{
    struct object_def  ob[4];

    __show((ufix)WIDTHSHOW_FLAG, 4, ob);
    return(0);

} /* op_widthshow() */


/* 5.3.3.1.10 op_awidthshow
 * This operator is used to print the characters identified by the
 * elements of string on the current page starting at the current point,
 * using the font face, size, and orientationspecified by the most
 * recent setfont. Additionally, awidthshow combines the special effects
 * of ashow and widthshow.
 */

fix     op_awidthshow()
{
    struct object_def  ob[6];

    __show((ufix)AWIDTHSHOW_FLAG, 6, ob);
    return(0);

} /* op_awidthshow() */


/* 5.3.3.1.11 op_kshow
 * This operator is used to print the characters identified by the
 * elements of string on the current page starting at the current point,
 * using the font face, size, and orientationspecified by the most
 * recent setfont. Additionally, awidthshow combines the special effects
 * of ashow and widthshow.
 */

fix     op_kshow()
{
    struct object_def  ob[2];

    __show((ufix)KSHOW_FLAG, 2, ob);
    return(0);

} /* op_kshow() */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\font_op4.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */


// DJC added global include
#include "psglobal.h"

#define    LINT_ARGS            /* @WIN */
#define    NOT_ON_THE_MAC       /* @WIN */
#define    KANJI                /* @WIN */
// DJC ues command line #define    UNIX                 /* @WIN */
/**************************************************************/
/*                                                            */
/*      font_op4.c               11/18/87      Danny          */
/*                                                            */
/**************************************************************/

/*
 *  11/16/88   Ada   register adding
 *  02/07/90 ccteng  modify st_setidlefonts() for new 1pp modules; @1PP
 *  03/27/91 kason   always turn on GEI_PM flag
 */


#include   "define.h"        /* Peter */
#include   "global.ext"
#include   "graphics.h"
#include   "graphics.ext"
#include   "fontfunc.ext"
#include    "gescfg.h"       /* @WIN */
#include   "geipm.h"         /* Kason 11/22/90 */

#define    MAX_IF    150

/* operator in status dict */

static fix      near no_if = 0;

static byte   * near idlefonts;

/* allocate data for idlefonts array,   @@ 1/12/88,   Danny */

void    font_op4_init()
{
} /* font_op4_init() */


fix     st_setidlefonts()
{
    fix31   l;
    register    fix     i, j;
    byte    t_idlefonts[MAX_IF+1];
    fix us_readidlecachefont(void);             /* add prototype @WIN*/

    for (i=0 ; i<=MAX_IF ; i++)
         t_idlefonts[i]='\0';    /* initial */

/* 1/24/90 by Danny for compatibility */
    if (current_save_level) {
        ERROR(INVALIDACCESS);
        return(0);
    }
    op_counttomark();    /* Kason 12/06/90 , change order */
    if (ANY_ERROR())
        return(0);
    if (!cal_integer(GET_OPERAND(0), &l)){
        ERROR(TYPECHECK);
        return(0);
    }
    j = (fix)l;

    t_idlefonts[0]=(byte)j;

    for (i=1; i<=j; i++) {
        if (!cal_integer(GET_OPERAND(i), &l)){
            ERROR(TYPECHECK);
            return(0);
        }
        if (l < 0 || l > 255) {
            ERROR(RANGECHECK);
            return(0);
        }
        t_idlefonts[i] = (byte  )l;
    }

    GEIpm_write(PMIDofIDLETIMEFONT,t_idlefonts,(unsigned)(MAX_IF+1));

/*--@1PP begin---2/7/90 ccteng---------------------------------*/
/*  POP(j+2);
 */
    /*
     * 12/15/89 ccteng modify to call USER.C us_readidlecachefont
     * for new 1PP c-code
     * leave the integers on operand stack for us_readidlecachefont
     * which will be poped out there
     */
    us_readidlecachefont();
/*--@1PP end-----2/7/90 ccteng---------------------------------*/

    return(0);

} /* st_setidlefonts() */


fix     st_idlefonts()
{
    register    fix     i;
    byte    t_idlefonts[MAX_IF+1];
    fix     no_idlefont;

    if (FRCOUNT() < 1) { ERROR(STACKOVERFLOW); return(0);  }
    PUSH_VALUE(MARKTYPE, UNLIMITED, LITERAL, 0, 0L);
    GEIpm_read(PMIDofIDLETIMEFONT,t_idlefonts,(unsigned)(MAX_IF+1));
    no_idlefont=(fix)t_idlefonts[0];

    i = no_idlefont;
    while(i) {
        --i;
        if (FRCOUNT() < 1) { ERROR(STACKOVERFLOW); return(0);  }

        PUSH_VALUE(INTEGERTYPE, UNLIMITED, LITERAL, 0, (ufix32)t_idlefonts[i+1]);
    } /* while(i) */

    return(0);
} /* st_idlefonts() */



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\fontkey.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/**************************************************************/
/*                                                            */
/*      fontkey.def              10/9/87      Danny           */
/*                                                            */
/**************************************************************/

#define         UniqueID            "UniqueID"
#define         StrokeWidth         "StrokeWidth"
#define         Metrics             "Metrics"

#define         FontType            "FontType"
#define         PaintType           "PaintType"
#define         FontMatrix          "FontMatrix"
#define         FontBBox            "FontBBox"
#define         FontwareRules       "FontwareRules"
#define         Encoding            "Encoding"
#define         CharStrings         "CharStrings"
#define         Private             "Private"
#define         FID                 "FID"

#define         FontName            "FontName"
#define         FontInfo            "FontInfo"
#define         NOTDEF              ".notdef"


#define         FontDirectory       "FontDirectory"
#define         systemdict          "systemdict"
#define         StandardEncoding    "StandardEncoding"
#define         OrigFont            "OrigFont"
#define         ScaleMatrix         "ScaleMatrix"

#define         BuildChar           "BuildChar"
#define         NotDefFont          "InvalidFont"

#ifdef    KANJI
#define         WMode               "WMode"
#define         PrefEnc             "PrefEnc"
#define         MIDVector           "MIDVector"
#define         CurMID              "CurMID"
#define         FDepVector          "FDepVector"
#define         FMapType            "FMapType"
#define         SubsVector          "SubsVector"
#define         EscChar             "EscChar"

#define         Metrics2            "Metrics2"
#define         CDevProc            "CDevProc"

#define         userdict            "userdict"
#define         EncodingDirectory   "EncodingDirectory"
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\font_op3.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */


// DJC added global include
#include "psglobal.h"

#define    LINT_ARGS            /* @WIN */
#define    NOT_ON_THE_MAC       /* @WIN */
#define    KANJI                /* @WIN */
// DJC use command line #define    UNIX                 /* @WIN */
/**************************************************************/
/*                                                            */
/*      font_op3.c               10/9/87      Danny           */
/*                                                            */
/**************************************************************/

#define    FONT_OP3_INC

#include   <stdio.h>

#include   "define.h"        /* Peter */
#include   "global.ext"
#include   "graphics.h"
#include   "graphics.ext"

#include   "font_sys.h"    /* for fntcache.ext */
#include   "fontgrap.h"
#include   "fontkey.h"
#include   "fontfunc.ext"
#include   "fntcache.ext"

#include   "fontshow.h"
#ifdef KANJI
#include   "language.h"
#endif

#include   "stdio.h"


#include   "fontinfo.def"  /* Add this include for MCC4.0; 3/2/90 D.S. Tseng */


extern struct f_info near    FONTInfo; /* union of current font information */
extern fix    near buildchar;           /* level of buildchar */


extern struct object_def near  BC_font; /* current BuildChar font */

/* 5.3.2.z op_charpath
 * This operator is used to append character outline path to the current path.
 */

fix     op_charpath()
{
    __charpath();
    return(0);

} /* op_charpath() */


/* 5.3.3.1.12 op_stringwidth
 * This operator is used to calculate the width of the string in current font.
 */

fix     op_stringwidth()
{
    __stringwidth();
    return(0);

} /* op_stringwidth() */


#ifdef KANJI

/* cshow operator */
fix    op_cshow()
{
    __cshow();
    return(0);
}

/* rootfont operator */
fix    op_rootfont()
{
/* Get Root font dictionary */
/* Push the Root font dictionary onto the operand stack; */
/* the initial value of the Root font is NULL */

    if (FRCOUNT() < 1) { ERROR(STACKOVERFLOW); return(0);  }
    PUSH_OBJ(&RootFont);

    return(0);
}

/************************************
 *  op_findencoding
 *     findencoding operator
 ************************************/
fix
op_findencoding()
{
    struct  object_def  FAR *l_encodingdir, FAR *l_encodingdict; /*@WIN*/
    struct  object_def  FAR *key_ptr;  /*@WIN*/
#ifdef SCSI
    struct  object_def  str_obj;  /*@WIN*/
    char                huge *string, string1[80];   /*@WIN 04-20-92*/
    ufix32              key_idx;
#endif

    /* check stackunderfolw error */
    if( COUNT() < 1 ) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }

    /* push FontDirectory on the operand stack */
    get_dict_value(userdict, EncodingDirectory, &l_encodingdir);

    /* save operand stack pointer */
    key_ptr = GET_OPERAND(0);

#ifdef SCSI
    /* check if encoding key was known */
    if ( !get_dict(l_encodingdir, key_ptr, &l_encodingdict) ) {
        /* not known */

        /* AppendName */
        key_idx = VALUE(key_ptr);
        string = (byte huge *)alloc_vm((ufix32)80);      /*@WIN*/
        memcpy(string1, name_table[(fix)key_idx]->text,
                        name_table[(fix)key_idx]->name_len);
        string1[name_table[(fix)key_idx]->name_len] = '\0';
        strcpy(string, "encodings/");
        strcat(string, string1);

        /* put file name into operandstack */
        TYPE_SET(&str_obj, STRINGTYPE) ;
        ACCESS_SET(&str_obj, UNLIMITED) ;
        ATTRIBUTE_SET(&str_obj, LITERAL) ;
        ROM_RAM_SET(&str_obj, RAM) ;
        LEVEL_SET(&str_obj, current_save_level) ;
        LENGTH(&str_obj) = strlen(string);
        VALUE(&str_obj) = (ufix32)string;
        PUSH_OBJ(&str_obj) ;

        /* run disk file 'encodings/XXX' */
        op_run();

        if(ANY_ERROR())
            return(0);

        /* get the encoding array from EncodingDirectory */
        if( !get_dict(l_encodingdir, key_ptr, &l_encodingdict) ){
            ERROR(UNDEFINED);
            return(0);
        }
    } /* if */
#else

    /* check if encoding key was known */
    if ( !get_dict(l_encodingdir, key_ptr, &l_encodingdict) ) {
        /* not known */
         ERROR(UNDEFINED);
         return(0);
    } /* if */

#endif /* SEARCH_DISK */

    POP(1);

    /* push the encoding dictionary */
    PUSH_ORIGLEVEL_OBJ(l_encodingdict);

    return(0);
} /* op_findencoding() */


/* setcachedevice2 operator */

fix     op_setcachedevice2()
{
    struct object_def  obj = {0, 0, 0};
    real32  w0x, w0y, llx, lly, urx, ury, w1x, w1y, vx, vy;

/* Is it in executing BuildChar */

    if (!buildchar) {
        ATTRIBUTE_SET(&obj, LITERAL);
        LEVEL_SET(&obj, current_save_level);
        get_name(&obj, "setcachedevice2", 15, TRUE);

        if (FRCOUNT() < 1) { ERROR(STACKOVERFLOW); return(0);  }
        PUSH_OBJ(&obj);
        ERROR(UNDEFINED); /* Return with 'undefined' error */
        return(0);
    }

    cal_num((struct object_def FAR *)GET_OPERAND(9), (long32 FAR *)&w0x); /*@WIN*/
    cal_num((struct object_def FAR *)GET_OPERAND(8), (long32 FAR *)&w0y); /*@WIN*/
    cal_num((struct object_def FAR *)GET_OPERAND(7), (long32 FAR *)&llx); /*@WIN*/
    cal_num((struct object_def FAR *)GET_OPERAND(6), (long32 FAR *)&lly); /*@WIN*/
    cal_num((struct object_def FAR *)GET_OPERAND(5), (long32 FAR *)&urx); /*@WIN*/
    cal_num((struct object_def FAR *)GET_OPERAND(4), (long32 FAR *)&ury); /*@WIN*/
    cal_num((struct object_def FAR *)GET_OPERAND(3), (long32 FAR *)&w1x); /*@WIN*/
    cal_num((struct object_def FAR *)GET_OPERAND(2), (long32 FAR *)&w1y); /*@WIN*/
    cal_num((struct object_def FAR *)GET_OPERAND(1), (long32 FAR *)&vx);  /*@WIN*/
    cal_num((struct object_def FAR *)GET_OPERAND(0), (long32 FAR *)&vy);  /*@WIN*/

/* Set cache device 2 */
/* Set character width vector be [w0x w0y] for mode 0, [w1x, w1y] for mode 1
 * Set cache device margin be ([llx lly], [urx ury]), difference vector
 * from Orig0 to Orig1 be [vx, vy].
 */

    if (VALUE(&current_font) != VALUE(&BC_font))
        get_CF_info(&BC_font, &FONTInfo);

    setcachedevice2(F2L(w0x), F2L(w0y), F2L(llx), F2L(lly), F2L(urx), F2L(ury),
                    F2L(w1x), F2L(w1y), F2L(vx), F2L(vy));

    if (VALUE(&current_font) != VALUE(&BC_font))
        get_CF_info(&current_font, &FONTInfo);

    if (ANY_ERROR())    return(0);

    POP(10); /* Pop 10 entries off the operand stack; */
    return(0);

} /* op_setcachedevice() */
#endif



/* 5.3.3.1.14 op_setcachedevice
 * This operator is used to pass width and bounding box information to the
 * PostScript font machinery.
 */

fix     op_setcachedevice()
{
    struct object_def  obj = {0, 0, 0};
    real32  wx, wy, llx, lly, urx, ury;

/* Is it in executing BuildChar */

    if (!buildchar) {
        ATTRIBUTE_SET(&obj, LITERAL);
        LEVEL_SET(&obj, current_save_level);
        get_name(&obj, "setcachedevice", 14, TRUE);

        if (FRCOUNT() < 1) { ERROR(STACKOVERFLOW); return(0);  }
        PUSH_OBJ(&obj);
        ERROR(UNDEFINED); /* Return with 'undefined' error */
        return(0);
    }

    cal_num((struct object_def FAR *)GET_OPERAND(5), (long32 FAR *)&wx); /*@WIN*/
    cal_num((struct object_def FAR *)GET_OPERAND(4), (long32 FAR *)&wy); /*@WIN*/
    cal_num((struct object_def FAR *)GET_OPERAND(3), (long32 FAR *)&llx);/*@WIN*/
    cal_num((struct object_def FAR *)GET_OPERAND(2), (long32 FAR *)&lly);/*@WIN*/
    cal_num((struct object_def FAR *)GET_OPERAND(1), (long32 FAR *)&urx);/*@WIN*/
    cal_num((struct object_def FAR *)GET_OPERAND(0), (long32 FAR *)&ury);/*@WIN*/

/* Set cache device */
/* Set character width vector be [wx wy]; */
/* Set cache device margin be ([llx lly], [urx ury]); */

    if (VALUE(&current_font) != VALUE(&BC_font))
        get_CF_info(&BC_font, &FONTInfo);

    setcachedevice(F2L(wx), F2L(wy), F2L(llx), F2L(lly), F2L(urx), F2L(ury));

    if (VALUE(&current_font) != VALUE(&BC_font))
        get_CF_info(&current_font, &FONTInfo);

    if (ANY_ERROR())    return(0);

    POP(6); /* Pop 6 entries off the operand stack; */
    return(0);

} /* op_setcachedevice() */


/* 5.3.3.1.15 op_setcharwidth
 * This operator is used to pass width information to the PostScript font
 * machinery and to declare that the character being defined is not to be
 * placed in the font cache.
 */

fix     op_setcharwidth()
{
    struct object_def  obj = {0, 0, 0};
    real32  wx=0, wy=0;

/* Is it in executing BuildChar */

    if (!buildchar) {
        ATTRIBUTE_SET(&obj, LITERAL);
        LEVEL_SET(&obj, current_save_level);
        get_name(&obj, "setcharwidth", 12, TRUE);

        if (FRCOUNT() < 1) { ERROR(STACKOVERFLOW); return(0);  }
        PUSH_OBJ(&obj);
        ERROR(UNDEFINED); /* Return with 'undefined' error */
        return(0);
    }

    cal_num((struct object_def FAR *)GET_OPERAND(1), (long32 FAR *)&wx);/*@WIN*/
    cal_num((struct object_def FAR *)GET_OPERAND(0), (long32 FAR *)&wy);/*@WIN*/

/* Set char width */

    setcharwidth(F2L(wx), F2L(wy));

    POP(2); /* Pop 2 entries off the operand stack; */
    return(0);

} /* op_setcharwidth() */


/*
 * --------------------------------------------------------------------
 *                OPERATORS about CACHE STATUS and PARAMTERS
 * --------------------------------------------------------------------
 *      op_cachestatus          (5.3.3.1.13)
 *      op_setcachelimit        (5.3.3.1.16)
 *      op_setcacheparams       (new in LaserWriter Plus Ver.38)
 *      op_currentcacheparams   (new in LaserWriter Plus Ver.38)
 * --------------------------------------------------------------------
 */

#include    "fntcache.ext"

/* program convention */
#   define  FUNCTION
#   define  DECLARE         {
#   define  BEGIN
#   define  END             }

#   define  GLOBAL
#   define  REG             register

#ifdef V_38
/*
 *  Compatibility Issues (ADOBE PostScript v.38)
 *
 *  1. ADOBE PostScript v.38 adjusts "upper" of cache parameters to a
 *          multiple of 4, and does no adjustment to "lower".
 *  2. It raises RANGECHECK if "upper" falls outside [-100, 135960],
 *          raises LIMITCHECK if "upper" > 108736, and
 *          CRASHES if "upper" is set to a value around these values.
 */

    /* ADOBE compatible formula to align upper/lower of cache parameters */

#   define  CALC_CACHE_UB(ub)   ( (((ub) + 3) / 4) * 4 )
#else
/* version 47 compatible */
#   define  CALC_CACHE_UB(ub)   ( ub )
#endif /* V38 */

#   define  CALC_CACHE_LB(lb)   ( lb )


/*
 * --------------------------------------------------------------------
 *  op_cachestatus (5.3.3.1.13)
 *      --  ==>  bsize bmax msize mmax csize cmax blimit
 *
 *  This operator returns measurements of several ascepts of the font cache.
 *  It reports the current consumption and limit of font cache resources:
 *      bytes of bitmap storage, font/matrix combinations and total number of
 *      cached characters. It also reports the upper limit on the number of
 *      bytes that may be occupied by the pixel array of a single cached
 *      character.
 *
 *  External Ref: "fntcache.ext"
 * --------------------------------------------------------------------
 */

GLOBAL FUNCTION fix     op_cachestatus()

  DECLARE

  BEGIN

#ifdef DBG2
    void    mdump();

    mdump();
#endif

#ifdef DBGcache     /* for cache mechanism debugging -- fntcache.c */
    {   extern void     cachedbg();
    cachedbg();
    }
#endif

    /* get cache status from font cache mechanism */
    /* push bsize, bmaz, msize, mmax, csize, cmax, blimit to operand stack */

    if (FRCOUNT() < 1) { ERROR(STACKOVERFLOW); return(0);  }
    PUSH_VALUE(INTEGERTYPE, UNLIMITED, LITERAL, 0, OPRN_BSIZE);/*NULL Peter */
    if (FRCOUNT() < 1) { ERROR(STACKOVERFLOW); return(0);  }
    PUSH_VALUE(INTEGERTYPE, UNLIMITED, LITERAL, 0, OPRN_BMAX);/*NULL Peter */
    if (FRCOUNT() < 1) { ERROR(STACKOVERFLOW); return(0);  }
    PUSH_VALUE(INTEGERTYPE, UNLIMITED, LITERAL, 0, OPRN_MSIZE);/*NULL Peter */
    if (FRCOUNT() < 1) { ERROR(STACKOVERFLOW); return(0);  }
    PUSH_VALUE(INTEGERTYPE, UNLIMITED, LITERAL, 0, OPRN_MMAX);/*NULL Peter */
    if (FRCOUNT() < 1) { ERROR(STACKOVERFLOW); return(0);  }
    PUSH_VALUE(INTEGERTYPE, UNLIMITED, LITERAL, 0, OPRN_CSIZE);/*NULL Peter */
    if (FRCOUNT() < 1) { ERROR(STACKOVERFLOW); return(0);  }
    PUSH_VALUE(INTEGERTYPE, UNLIMITED, LITERAL, 0, OPRN_CMAX);/*NULL Peter */
    if (FRCOUNT() < 1) { ERROR(STACKOVERFLOW); return(0);  }
    PUSH_VALUE(INTEGERTYPE, UNLIMITED, LITERAL, 0, OPRN_BLIMIT);/*NULL Peter */
    return(0);
  END

/*
 * --------------------------------------------------------------------
 *  op_setcachelimit (5.3.3.1.16)
 *      num  ==>  --
 *
 *  This operator establishes the upper limit of bytes that may be occupied
 *      by the pixel array of a single cached character.
 *  It does not disturb any characters already in the cache, and only affects
 *      the decision whether to place new characters in the font cache.
 *
 *  External Ref: "fntcache.ext"
 * --------------------------------------------------------------------
 */


GLOBAL FUNCTION fix     op_setcachelimit()

  DECLARE
    REG fix31   cache_ub;

  BEGIN         /* precheck: TYPECHECK and STACKUNERFLOW */
    cache_ub = (fix31)VALUE(GET_OPERAND(0));


    if (CACHELIMIT_BADRANGE(cache_ub))
        {
        ERROR (RANGECHECK);
        return(0);
        }

    if (CACHELIMIT_TOOBIG((ufix32)cache_ub))    //@WIN
        {
        ERROR (LIMITCHECK);
        return(0);
        }

    SET_CACHELIMIT (CALC_CACHE_UB(cache_ub));

    POP(1);
    return(0);
  END

/*
 * --------------------------------------------------------------------
 *  op_setcacheparams()
 *      mark lower upper  ==>  --
 *
 *  This operator sets cache parameters as specified by the INTEGER objects
 *      above the top most mark on the stack, then removes all operands as
 *      cleartomark.
 *  The number of cache parameters is variable. if more operands are supplied
 *      than are needed, the topmost ones are used and the remainder ignored;
 *      if fewer are supplied than are needed, "setcacheparams" implicitly
 *      inserts the corresponding value of ORIGINAL setting (NOT DEFAULT).
 *  The "upper" operand specifies the same parameter as is set by "setcache-
 *      limit". If a character's pixel array requires fewer bytes than "upper"
 *      it will be cached. If a character's pixel array requires more bytes
 *      than "lower", it will be compressed in the cache.
 *  Setting "lower" to zero forces all characters to be compressed, and
 *      setting "lower" to a value greater than or equal to "upper" disables
 *      compression.
 *
 *  External Ref: "fntcache.ext"
 * --------------------------------------------------------------------
 */

GLOBAL FUNCTION fix     op_setcacheparams ()

  DECLARE
    REG ufix    cnt2mark;       /* # of entries counted to mark */

  BEGIN

    /* count to mark excluding that "mark" */
    for ( cnt2mark=0;  cnt2mark < COUNT();  cnt2mark++ )
        if (TYPE(GET_OPERAND(cnt2mark)) == MARKTYPE)  break;

    /* check if "mark" exists */
    if (cnt2mark == COUNT())
        {
        ERROR (UNMATCHEDMARK);
        return (0);
        }

    /* get and check type of "upper" of cache paramters */
    if (cnt2mark > 0)
        {
        if (TYPE(GET_OPERAND(0)) != INTEGERTYPE)
            {
            ERROR (TYPECHECK);
            return (0);
            }
        op_setcachelimit ();
        if (ANY_ERROR())  return (0);
        }

    cnt2mark --;    /* "upper" had been consumed by op_setcachelimit, */
                    /*      so "lower" becomes OPERAND(0).            */

    /* get and check "lower" of cache parameters */
    if (cnt2mark > 0)
        {
        if (TYPE(GET_OPERAND(0)) != INTEGERTYPE)
            {
            ERROR (TYPECHECK);
            return (0);
            }
        SET_CACHEPARAMS_LB (CALC_CACHE_LB (VALUE(GET_OPERAND(0)) ));
        }

    /* clear to mark, including "mark" */
    POP (cnt2mark+1);
    return (0);
  END


/*
 * --------------------------------------------------------------------
 *  op_currentcacheparams()
 *      --  ==>  mark lower upper
 *
 *  This operator pushes a mark object followed by the current cache
 *      parameters on the the operand stack. The number of cache parameters
 *      returned is variable. (see op_setcacheparams())
 *
 *  External Ref: "fntcache.ext"
 * --------------------------------------------------------------------
 */

GLOBAL FUNCTION fix     op_currentcacheparams ()

  DECLARE

  BEGIN

    /* push mark, lower and upper onto the operand stack */
    if (FRCOUNT() < 1) { ERROR(STACKOVERFLOW); return(0);  }
    PUSH_VALUE (MARKTYPE, UNLIMITED, LITERAL, 0, OPRN_MARK);/*NULL Peter */
    if (FRCOUNT() < 1) { ERROR(STACKOVERFLOW); return(0);  }
    PUSH_VALUE (INTEGERTYPE, UNLIMITED, LITERAL, 0, OPRN_LOWER);/*NULL Peter */
    if (FRCOUNT() < 1) { ERROR(STACKOVERFLOW); return(0);  }
    PUSH_VALUE (INTEGERTYPE, UNLIMITED, LITERAL, 0, OPRN_UPPER);/*NULL Peter */

    return (0);
  END

#ifdef DBG2

void mdump()
{
    ubyte  FAR *ptr; /*@WIN*/
    fix     len;
    int     i;

    ptr = (ubyte FAR *)VALUE(GET_OPERAND(1)); /*@WIN*/
    len = (fix)VALUE(GET_OPERAND(0));

    printf("\n");
    for (i=0; i<len; i++, ptr++) {
        if ( !(i % 16) )
            printf("\n%08lx --\n", ptr);
        printf("%02x ", *ptr);
    }
    printf("\n");

    POP(2);
} /* mdump */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\font_op5.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */


// DJC added global include
#include "psglobal.h"

#define    LINT_ARGS            /* @WIN */
#define    NOT_ON_THE_MAC       /* @WIN */
#define    KANJI                /* @WIN */
// DJC use command line #define    UNIX                 /* @WIN */
/**************************************************************/
/*                                                            */
/*      font_op5.c               06/13/90      Wendy          */
/*                                                            */
/*      Description:                                          */
/*      Add to the new operators for the font substitution    */
/*      method in PostScript, in which findfont returns a     */
/*      default font if the requested font cannot be found,   */
/*      is extended to perfomr substitution based on the style*/
/*      of the requested font.  Rather than replacing all     */
/*      unknown fonts with a single font, findfont now returns*/
/*      a font which approximates the requested style.        */
/*                                                            */
/**************************************************************/
#ifdef FIND_SUB
#include "global.ext"
#include "user.h"
#define N_subs 4

void dummy_fct();
fix Subs[N_subs] = {0, 1, 2, 3};

fix
st_setsubstitutefonts()
{
     fix i;
     struct object_def FAR *l_fontdir, FAR *l_fontdict, FAR *l_stdfontname; /*@WIN*/
     struct object_def obj, l_fontname;
     ufix p_index;
     fix temp[N_subs];

    if (current_save_level) {
        ERROR(INVALIDACCESS);
        return(0);
    }
     if ( COUNT() < 4 ) { ERROR(STACKUNDERFLOW);
          return(0);
     }

     if  (TYPE(GET_OPERAND(0)) != INTEGERTYPE ||
          TYPE(GET_OPERAND(1)) != INTEGERTYPE ||
          TYPE(GET_OPERAND(2)) != INTEGERTYPE ||
          TYPE(GET_OPERAND(3)) != INTEGERTYPE ){
          ERROR(TYPECHECK);
          return(0);
          }

/* get stdfontname from idletimedict and  get value  from stdfontname */
      get_dict_value(IDLETIMEDICT, "stdfontname", &l_stdfontname);
      get_dict_value(SYSTEMDICT, FONTDIRECTORY, &l_fontdir);

/* check 4 parameters among stdfontname length */
     for (i=0;i<N_subs;i++) {
          temp[i] = VALUE(GET_OPERAND((N_subs-1)-i));
          if (temp[i] < 0 || temp[i] >= l_stdfontname->length) {
               ERROR(RANGECHECK);
               return(0);
          }
     }
     for (i=0;i<N_subs;i++) {
          Subs[i] = temp[i];
     }
     POP(4);

 /* check if font name from stdfontname was found in the FontDirectory */
      for (i=0; i<N_subs; i++) {
           p_index = (ufix16)Subs[i];
           get_array(l_stdfontname, p_index, &l_fontname);
           if (! get_dict(l_fontdir, &l_fontname, &l_fontdict)){
                struct object_def t_obj;

                ATTRIBUTE_SET(&t_obj, LITERAL);
                LEVEL_SET(&t_obj, current_save_level);
                get_name(&t_obj, "setsubstitutefonts", 18, TRUE);
                PUSH_OBJ(&t_obj);
                ERROR(UNDEFINED);
                return(0);
           }
      }
      dummy_fct();
}


fix
st_substitutefonts()
{
     fix i;
     struct object_def obj;

     /* check if operand stack no free space */
     if (FRCOUNT() < 4) {
          ERROR(STACKOVERFLOW);
          return(0);
     }

    for (i = 0; i < N_subs; i++) {
        /* get Subs array element object */
        TYPE_SET(&obj, INTEGERTYPE);
        ATTRIBUTE_SET(&obj, LITERAL);
        ACCESS_SET(&obj, UNLIMITED);
        obj.length = 0;
        obj.value = (ufix32)Subs[i];
        ROM_RAM_SET(&obj, RAM);
        LEVEL_SET(&obj, current_save_level);

        PUSH_OBJ(&obj);
    }
      dummy_fct();
}


fix
st_selectsubstitutefont()
{
     fix i, flag,  style, length, j, n_i, loc;
     struct object_def FAR *l_fontdir, FAR *l_fontdict, FAR *l_stdfontname; /*@WIN*/
     struct object_def  l_fontname;
     ufix index;
     ufix32 n_key;
     static byte FAR *Bolds[4] = {"Bold", "Demi", "Black", "Heavy"}; /*@WIN*/
     static byte FAR *Italics[2] = {"Italic", "Oblique"}; /*@WIN*/
     byte key_text[80];

     style = 0;
     if ( COUNT() < 1 ) {
          ERROR(STACKUNDERFLOW);
          return(0);
     }
     n_key = VALUE(GET_OPERAND(0));
     memcpy(key_text, name_table[(fix)n_key]->text, name_table[(fix)n_key]->name_len);
     key_text[name_table[(fix)n_key]->name_len] = '\0';
     flag = 1;
     for (i=0; i<4; i++) {
          for (n_i=0; n_i<strlen(key_text); n_i++) {
               if (key_text[n_i] == '-')
                  {
                   loc = n_i;
                   break;
                  }
               else
                   loc = -1;
          }

        if (strlen(key_text+loc+1) <= 4) {
          if (strcmp((key_text+loc+1), Bolds[i]) == 0)
                   style |= flag ;
        }
        else {
          length = strlen(Bolds[i]);
          if (strncmp((key_text+loc+1), Bolds[i], length) == 0) {
                   style |= flag ;
                   for (j=0; j<2; j++) {
                        if (strcmp((key_text+loc+1+length),
                           Italics[j]) == 0) {
                              flag = 2;
                              style |= flag ;
                        }  /* if   */
                    }      /* for  */
            }              /* if   */
        }                  /* else */
     }                     /* for  */
     flag = 2;
     for (i=0; i<2; i++) {
          if (strcmp((key_text+loc+1), Italics[i]) == 0) {
              style |=  flag ;
              length = strlen(Italics[i]);
          }
     }
     POP(1);

     index = Subs[style];
     get_dict_value(IDLETIMEDICT, "stdfontname", &l_stdfontname);
     get_dict_value(SYSTEMDICT, FONTDIRECTORY, &l_fontdir);

     /* check if font name from stdfontname was found in the FontDirectory */
     get_array(l_stdfontname, index, &l_fontname);
     if (! get_dict(l_fontdir, &l_fontname, &l_fontdict)) {
         struct object_def obj;

         ATTRIBUTE_SET(&obj, LITERAL);
         LEVEL_SET(&obj, current_save_level);
         get_name(&obj, "selectsubstitutefont", 20, TRUE);
         PUSH_OBJ(&obj);
         ERROR(UNDEFINED);
         return(0);
     }
     if (FRCOUNT() < 1 ) {
         ERROR(STACKOVERFLOW);
         return(0);
     }
     PUSH_OBJ(&l_fontname);
     return(0);
}
void  dummy_fct()
{
     printf("");
}
#endif /* FIND_SUB */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\in_sfnt.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * -------------------------------------------------------------------
 * File: in_sfnt.h              11/11/89        created by danny
 *
 *      header definition to use the SFNT font
 *
 * References:
 * Revision History:
 * -------------------------------------------------------------------
 */

/* Font Scaler header files */
//#include        "..\..\..\bass\work\source\FSCdefs.h"         @WIN
//#include        "..\..\..\bass\work\source\sfnt.h"
//#include        "..\..\..\bass\work\source\Fscaler.h"
//#include        "..\..\..\bass\work\source\FSError.h"
#include        "..\bass\FSCdefs.h"
#include        "..\bass\sfnt.h"
#include        "..\bass\Fscaler.h"
#include        "..\bass\FSError.h"

struct  CharOut {
        float   awx;
        float   awy;
        float   lsx;
        float   lsy;
        uint32  byteWidth;
        uint16  bitWidth;
        int16   scan;
        int16   yMin;
        int16   yMax;
        /* info from rasterizer to calculate memoryBase 5, 6 and 7; @WIN 7/24/92 */
        FS_MEMORY_SIZE memorySize7;
        uint16 nYchanges;
        };

struct  BmIn {
        char    FAR *bitmap5; /*@WIN*/
        char    FAR *bitmap6; /*@WIN*/
        char    FAR *bitmap7; /*@WIN*/
        int      bottom;
        int      top;
        };

struct  Metrs {
        int     awx, awy;
        int     lox, loy;
        int     hix, hiy;
        };

/* ----------------------- End of IN_SFNT.H ---------------------------- */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\mapping.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
#ifdef KANJI

/* Mapping Nexting Level        */
#define         CFONT_LEVEL     5
#define         BUF_SIZE        10

/* Mapping Algorithm Constants  */
#define         MAP_MIN         2
#define         MAP_88          2
#define         MAP_ESC         3
#define         MAP_17          4
#define         MAP_97          5
#define         MAP_SUBS        6
#define         MAP_MAX         6

struct map_stack {
          struct object_def  FAR *fontdict;      /*@WIN*/
          struct object_def  FAR *midvector;          /* ?? @WIN*/
          real32             scalematrix[6];
          ufix               fonttype;
          ufix               maptype;
          struct object_def  FAR * FAR *de_fdict; /*@WIN*/
          fix                FAR *de_errcode;     /*@WIN*/
          ufix               de_size;
};

struct map_state {
          ubyte   FAR *str_addr; /*@WIN*/
          fix     str_len;
          ubyte   esc_char, wmode;
          bool    root_is_esc, unextracted;
          ufix16  unextr_code;
          ufix16  font_no;

          struct map_stack  FAR *cur_mapfont;     /* Current Mapping Font @WIN*/
          /* 5 level maintainence */
          struct map_stack  finfo[CFONT_LEVEL];
          bool            nouse_flag;
          ubyte           idex, esc_idex;
};

struct code_info {
          ufix    font_nbr;
          ufix    byte_no;
          ubyte   fmaptype;
          ubyte   code[BUF_SIZE];
          ubyte   FAR *code_addr; /*KSH 4/25/91@WIN*/
        };

struct  comdict_items   {       /* Composite fontdict item */
          struct object_def  FAR *fmaptype; /*@WIN*/
          struct object_def  FAR *encoding; /*@WIN*/
          struct object_def  FAR *fdepvector; /*@WIN*/
          struct object_def  FAR *subsvector; /*@WIN*/
};

struct  mid_header      {       /* MIDVector header */
        fix     de_size;
        fix     fmaptype;
};

#endif          /* KANJI */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\matrix.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */


// DJC added global include
#include "psglobal.h"

#define    LINT_ARGS            /* @WIN */
#define    NOT_ON_THE_MAC       /* @WIN */
#define    KANJI                /* @WIN */
// DJC use command line #define    UNIX                 /* @WIN */
/**************************************************************/
/*                                                            */
/*      matrix.c                 10/9/87      Danny           */
/*                                                            */
/**************************************************************/

/*
 *   11/16/88   zero_f updating
 */

#include   "define.h"        /* Peter */
#include   "global.ext"


/*
 * This is a file for matrix operations
 */

/* matrix multiplication
 *    matrix m <-- matrix m1 * matrix m2
 */

void  mul_matrix(m, m1, m2)
real32  FAR m[], FAR m1[], FAR m2[];    /*@WIN*/
{
    m[0] = m1[0] * m2[0];
    m[1] = zero_f;
    m[2] = zero_f;
    m[3] = m1[3] * m2[3];
    m[4] = m2[4];
    m[5] = m2[5];

    if (F2L(m1[1]) != F2L(zero_f)) {
        if (F2L(m2[2]) != F2L(zero_f))
            m[0] += m1[1] * m2[2];
        m[1] += m1[1] * m2[3];
    }
    if (F2L(m2[1]) != F2L(zero_f)) {
        m[1] += m1[0] * m2[1];
        if (F2L(m1[2]) != F2L(zero_f))
            m[3] += m1[2] * m2[1];
        if (F2L(m1[4]) != F2L(zero_f))
            m[5] += m1[4] * m2[1];
    }

    if (F2L(m1[2]) != F2L(zero_f))
        m[2] += m1[2] * m2[0];

    if (F2L(m2[2]) != F2L(zero_f)) {
        m[2] += m1[3] * m2[2];
        if (F2L(m1[5]) != F2L(zero_f))
            m[4] += m1[5] * m2[2];
    }

    if (F2L(m1[4]) != F2L(zero_f))
        m[4] += m1[4] * m2[0];
    if (F2L(m1[5]) != F2L(zero_f))
        m[5] += m1[5] * m2[3];

} /* mul_mat() */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\psres.h ===
//DJC new file for prototypes for new PsRes functions




//DJC new structure to enable reading encodtbl.dat from resource rather
//than file

typedef struct {
   DWORD dwSize;
   DWORD dwCurIdx;
   LPSTR lpPtrBeg;
} PS_RES_READ;
typedef PS_RES_READ *PPS_RES_READ;


BOOL PsOpenRes( PPS_RES_READ ppsRes, LPSTR lpName, LPSTR lpType );

int PsResRead(PPS_RES_READ ppsRes, LPSTR pBuf, WORD wMaxSize );


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\in_sfnt.c ===
// DJC added global include
#include "psglobal.h"

#define    LINT_ARGS            /* @WIN */
#define    NOT_ON_THE_MAC       /* @WIN */
#define    KANJI                /* @WIN */
// DJC use command line #define    UNIX                 /* @WIN */
/*
 * -----------------------------------------------------------------------------
 * File: in_sfnt.c                 11/03/89    created  by danny
 *                                 12/01/90    modified by Jerry
 *
 *      Interface to use the SFNT font
 *
 * References:
 * Revision History:
 * 05/10/91 Phlin  Take out rc_GetMetrics_Width() replaced by
 *                 rc_GetAdvanceWidth() for improving performance. (Ref. GAW)
 * -----------------------------------------------------------------------------
 */

#include <stdio.h>

#include "global.ext"           // @WIN; FAR, NEAR,... defs

/* sfnt interface header */
#ifdef EXTRA_DEF /* JJJ Peter */
#include        "define.h"
#endif
#include        "in_sfnt.h"

/* GAW, Begin, Phlin, 5/9/91, add for performance */
#include        "setjmp.h"
//#include        "..\..\..\bass\work\source\FontMath.h"        @WIN
//#include        "..\..\..\bass\work\source\fnt.h"
//#include        "..\..\..\bass\work\source\sc.h"
//#include        "..\..\..\bass\work\source\FSglue.h"
#include        "..\bass\FontMath.h"
#include        "..\bass\fnt.h"
#include        "..\bass\sc.h"
#include        "..\bass\FSglue.h"
/* add prototype; from bass ; @WIN */
//extern fsg_SplineKey FAR * fs_SetUpKey (fs_GlyphInputType FAR*, unsigned, int FAR*); @WIN
extern fsg_SplineKey FAR * fs_SetUpKey (fs_GlyphInputType FAR*, unsigned, int FAR*);
extern void sfnt_ReadSFNTMetrics (fsg_SplineKey FAR*, unsigned short);

/* GAW, END, Phlin, 5/9/91, add for performance */

/* constants */
#define PDLCharUnit     1000.0
#define PDL_ID          0
#define HalfPi          1.5707963
#define FIXED2FLOAT(x)  (((float)(x)/(float)(1L << 16)) + (float)0.0005)
#define FLOAT2FIXED(x)  ((Fixed)(x * (1L << 16)))
#define FixToInt( x )   (int16)(((x) + 0x00008000) >> 16)
#define SCL6            (float)0.015625        /* 1/64 */
#define KK              (float)(1.0/3.0)

/* Error code */
#define Err_NoMemory    901

 /* External Function Declaration --- client called by royal; add prototype @WIN */
 extern char  FAR *cr_FSMemory(long); /*@WIN_BASS*/
 extern char  FAR *cr_GetMemory(long); /*@WIN_BASS*/
 extern void    cr_translate(float FAR *, float FAR *);
 extern void    cr_newpath(void);
 extern void    cr_moveto(float, float);
 extern void    cr_lineto(float, float);
 extern void    cr_curveto(float, float, float, float, float, float);
 extern void    cr_closepath(void);

 extern int  EMunits;  /* GAW */

/* Lcoal Function Declatation; add prototype @WIN */
static  int     QBSpline2Bezier(F26Dot6 FAR *, F26Dot6 FAR *,
                short FAR *, short FAR *,unsigned char FAR *,long);
static  void    startPath(void);
static  void    startContour(float, float);
static  void    straightLine(float, float);
static  void    quadraticBezier(float, float, float, float, float, float);
static  char   FAR *GetSfntPiecePtr(long, long, long); /*@WIN*/
static  int     LargestCtm(float FAR *, float FAR *);   /*@WIN*/

static float  zero_f = (float)0.0;

/* static data structures */
static fs_GlyphInputType    input, FAR *in;   /*@WIN_BASS*/
static fs_GlyphInfoType     output, FAR *out; /*@WIN_BASS*/
static int32                ret;
Fixed                       Matrix[3][3];

static  struct  sfnt_data {
        char   FAR *sfnt; /*@WIN*/
        float   tx, ty;
        int     dpi;
        } sfdt;

extern int bWinTT;        /* if using Windows TT fonts; from ti.c;@WINTT */

/*
 * -----------------------------------------------------------------------------
 * Routine: rc_InitFonts
 *
 *      Initialize the SFNT module
 *
 * -----------------------------------------------------------------------------
 */
 int
 rc_InitFonts(dpi)
 int    dpi;      /* device resolution */
 {
#ifdef DBG
    printf("Enter rc_InitFonts\n");
#endif
        in  = &input;
        out = &output;

        /* open font scaler */
        ret = fs_OpenFonts(in, out);
        if(ret != NO_ERR)   return((int)ret);   //@WIN

        /* allocate memory for FS */
        if(!(in->memoryBases[0] = cr_FSMemory(out->memorySizes[0])))
            return(Err_NoMemory);
/* out->memorySize[1] is zero, it will produce a Err_NoMemory error. @WIN
        if(!(in->memoryBases[1] = cr_FSMemory(out->memorySizes[1])))
            return(Err_NoMemory);
*/
        if(!(in->memoryBases[2] = cr_FSMemory(out->memorySizes[2])))
            return(Err_NoMemory);
        in->memoryBases[1] = in->memoryBases[2];                    /*@WIN*/

#ifdef DBG
    printf(" memory[0]=%lx, %lx\n", in->memoryBases[0], out->memorySizes[0]);
    printf(" memory[1]=%lx, %lx\n", in->memoryBases[1], out->memorySizes[1]);
    printf(" memory[2]=%lx, %lx\n", in->memoryBases[2], out->memorySizes[2]);
#endif
        /* Initializes the Font Scaler */
        ret = fs_Initialize(in, out);
        if(ret != NO_ERR)   return((int)ret);   //@WIN

        sfdt.dpi = dpi;

#ifdef DBG
    printf("...Exit  rc_InitFonts()\n");
#endif
        return(0);
} /* rc_InitFonts() */

/*
 * -----------------------------------------------------------------------------
 *      Routine:        rc_LoadFont
 *
 *      Load an SFNT font data
 *
 * -----------------------------------------------------------------------------
 */
int
rc_LoadFont(sfnt, plat_id, spec_id)
char    FAR *sfnt; /*@WIN*/
uint16   plat_id, spec_id;
{
#ifdef DBG
    printf("Enter rc_LoadFont\n");
#endif
        sfdt.sfnt = sfnt;

        in->clientID                  = PDL_ID;
        in->GetSfntFragmentPtr        = (GetSFNTFunc)GetSfntPiecePtr;
        in->sfntDirectory             = (int32 FAR *)sfnt; /*@WIN*/
        in->ReleaseSfntFrag           = 0;    /*?????*/

        in->param.newsfnt.platformID  = plat_id;
        in->param.newsfnt.specificID  = spec_id;

        ret = fs_NewSfnt(in, out);
        if(ret != NO_ERR)   return((int)ret);   //@WIN

        /* get memory from client */
        if(!(in->memoryBases[3] = cr_GetMemory(out->memorySizes[3])))
                return(Err_NoMemory);
        if(!(in->memoryBases[4] = cr_GetMemory(out->memorySizes[4])))
                return(Err_NoMemory);
#ifdef DBG
    printf(" memory[3]=%lx, %lx\n", in->memoryBases[3], out->memorySizes[3]);
    printf(" memory[4]=%lx, %lx\n", in->memoryBases[4], out->memorySizes[4]);
    printf("...Exit  rc_LoadFont()\n");
#endif

        return(0);

} /* rc_LoadFont() */

/* GAW, Begin, Phlin, 5/9/91, add for performance */
/*
 * -----------------------------------------------------------------------------
 *
 * Routine: rc_GetAdvanceWidth
 *
 *      Setup Character Advance Width
 *
 * -----------------------------------------------------------------------------
 */
 int
 rc_GetAdvanceWidth(charid, Metrs)
 int    charid;
 struct Metrs  FAR *Metrs; /*@WIN*/
 {
        /* Kason 11/14/90 */
        extern int useglyphidx;
        int error;
        register fsg_SplineKey FAR * key=NULL; /*@WIN*/

#ifdef DBG
    printf("Enter rc_GetAdvanceWidth: %d\n", charid);
    printf("DPI: %d\n", sfdt.dpi);
#endif

        /* Kason 11/14/90 */
        if (!useglyphidx){
           in->param.newglyph.characterCode = (uint16)charid;
           /*JJ    in->param.newglyph.glyphIndex    = ???? */
        }
        else {
        in->param.newglyph.characterCode = 0xffff;
        in->param.newglyph.glyphIndex    = (uint16)charid;
        }

        ret = fs_NewGlyph(in, out);
        if(ret != NO_ERR)   return((int)ret);   //@WIN

//      key = fs_SetUpKey(in, (int32)(INITIALIZED | NEWSFNT | NEWTRANS), &error); @WIN
        key = fs_SetUpKey(in, (unsigned)(INITIALIZED | NEWSFNT | NEWTRANS), &error);

		if (key != NULL)
		{
	        sfnt_ReadSFNTMetrics( key, (unsigned short)charid );
		}

        Metrs->awx = (int)(key->nonScaledAW*PDLCharUnit/EMunits+0.5);
        Metrs->awy = 0;

#ifdef DBG
    printf("...Exit  rc_GetAdvanceWidth()\n");
#endif
        return(0);
} /* rc_GetAdvanceWidth() */
/* GAW, END, Phlin, 5/9/91, add for performance */


/*
 * --------------------------------------------------------------------
 *
 * Routine: rc_TransForm
 *
 * Setup matrix
 *
 * --------------------------------------------------------------------
 */
 int
 rc_TransForm(ctm)
 float  FAR *ctm; /*@WIN*/
 {
        Fixed   ma, mb, mc, md, pt_size;
        float   largest_ctm;
        float   pts;
#ifdef DBG
    printf("Enter rc_TransForm\n");
    printf("ctm: %f %f %f %f %f %f\n", ctm[0], ctm[1], ctm[2], ctm[3], ctm[4], ctm[5]);
#endif

        /* Find Largest of the ctm */
        LargestCtm(ctm, &largest_ctm);

        ma = FLOAT2FIXED(     ctm[0] / largest_ctm);
        mb = FLOAT2FIXED(-1.0*ctm[1] / largest_ctm); /* Element b & d must be mirrored */
        mc = FLOAT2FIXED(     ctm[2] / largest_ctm);
        md = FLOAT2FIXED(-1.0*ctm[3] / largest_ctm);

        pts = ((largest_ctm * (float)PDLCharUnit * (float)72.0) / (float)sfdt.dpi);
        pt_size  = FLOAT2FIXED(pts);

#ifdef DBG
        printf("largest_ctm = %f\n", largest_ctm);
        printf("Debug: Matrix (Noramlized): %x %x %x %x\n", ma, mb, mc,md);
        printf("Debug Point Size: s = %x\n", pt_size);
        printf("Debug:Resolution: %d dpi\n", sfdt.dpi);
#endif
        //DJC fix from history.log UPD015


        { /* filter out boundary conditions --- Begin --- @WIN */
          /* To void rasterizer generating a divide-by-zero error;
           *
           * Criteria:
           * Let the client tranformation matrix be
           *         (a00  a01)
           *         (a10  a11).
           *
           * Let     max0 = MAX(|a00|, |a01|)
           *         max1 = MAX(|a10|, |a11|).
           *
           * Let xpp be the pixels-per-em in the x-direction
           *     ((pntsize * xresolution) / 72. )
           * Let ypp be the pixels-per-em in the y-direction
           *     ((pntsize * yresolution) / 72. )
           * The condition to be fulfilled by the matrix is:
           *
           *         (xpp * max0 > 0.5) AND (ypp * max1 > 0.5)
           */
           #define LFX2F(lfx)   ((real32)(lfx) / 65536)
           long absma, absmb, absmc, absmd;
           float fMax0, fMax1, fPixelPerEm;
           absma = ma > 0 ? ma : -ma;
           absmb = mb > 0 ? mb : -mb;
           absmc = mc > 0 ? mc : -mc;
           absmd = md > 0 ? md : -md;
           fMax0 = absma > absmb ? LFX2F(absma) : LFX2F(absmb);
           fMax1 = absmc > absmd ? LFX2F(absmc) : LFX2F(absmd);
//         fPixelPerEm = pts * (float)sfdt.dpi / (float)72.0;
           fPixelPerEm = largest_ctm * (float)PDLCharUnit;

           if ((fPixelPerEm * fMax0) <= 0.5 ||
               (fPixelPerEm * fMax1) <= 0.5) {
               printf("matrix too small\n");
               return -1;
           }
        } /* filter out boundary conditions --- End --- @WIN */
        //DJC end fix UPD015

        in->param.newtrans.xResolution     = (short)sfdt.dpi;
        in->param.newtrans.yResolution     = (short)sfdt.dpi;
        in->param.newtrans.pointSize       = pt_size;
        in->param.newtrans.pixelDiameter   = (Fixed)FIXEDSQRT2;
        in->param.newtrans.traceFunc       = (voidFunc)0;
        Matrix[0][0] = ma;
        Matrix[0][1] = mb;
        Matrix[1][0] = mc;
        Matrix[1][1] = md;
        Matrix[2][2] = FLOAT2FIXED((real32)1.0);
        Matrix[0][2] = (Fixed)0L;
        Matrix[1][2] = (Fixed)0L;
        Matrix[2][0] = (Fixed)0L;    /* No tx translation */
        Matrix[2][1] = (Fixed)0L;    /* No ty translation */
        in->param.newtrans.transformMatrix = (transMatrix FAR *)Matrix; /*@WIN_BASS*/
        ret = fs_NewTransformation(in, out);
        if(ret != NO_ERR)   return((int)ret);   //@WIN

#ifdef DBG
    printf("...Exit  rc_Transform()\n");
#endif
        return(0);
} /* rc_Transform() */


/*
 * -----------------------------------------------------------------------------
 *
 * Routine: rc_BuildChar
 *
 *      Build the chatacter outline
 *
 * -----------------------------------------------------------------------------
 */
 int
 rc_BuildChar(GridFit, CharOut)
 int             GridFit;    /* Do Grid Fit or not ? */
 struct CharOut FAR *CharOut; /*@WIN*/
 {
#ifdef DBG
    printf("Enter rc_BuildChar\n");
#endif
        in->param.gridfit.styleFunc = 0;
        in->param.gridfit.traceFunc = (voidFunc)0;
        if (GridFit) {
            ret = fs_ContourGridFit(in, out);
            if(ret != NO_ERR)   return((int)ret);       //@WIN
        }
        else {
            ret = fs_ContourNoGridFit(in, out);
            if(ret != NO_ERR)   return((int)ret);       //@WIN
        }

        ret = fs_FindBitMapSize(in, out);
        if(ret != NO_ERR)   return((int)ret);           //@WIN

        CharOut->awx       = FIXED2FLOAT(out->metricInfo.advanceWidth.x);
        CharOut->awy       = FIXED2FLOAT(out->metricInfo.advanceWidth.y);
        CharOut->lsx       = FIXED2FLOAT(out->metricInfo.leftSideBearing.x);
        CharOut->lsy       = FIXED2FLOAT(out->metricInfo.leftSideBearing.y);
        CharOut->byteWidth = out->bitMapInfo.rowBytes;
/*PRF:Danny, 10/18/90 */
        CharOut->bitWidth  = out->bitMapInfo.bounds.right - out->bitMapInfo.bounds.left;
/*****PRF:
        CharOut->bitWidth  = out->bitMapInfo.bounds.right - out->bitMapInfo.bounds.left - 1;
********/
/*PRF: End */
        CharOut->yMin      = out->bitMapInfo.bounds.top;
        CharOut->yMax      = out->bitMapInfo.bounds.bottom;
        CharOut->scan      = CharOut->yMax - CharOut->yMin;

        /* save info from rasterizer to calculate memoryBase 5, 6 and 7; @WIN 7/24/92 */
        {
            register fsg_SplineKey FAR *key =
                    (fsg_SplineKey FAR *)in->memoryBases[KEY_PTR_BASE];
            CharOut->memorySize7 = out->memorySizes[BITMAP_PTR_3];
            CharOut->nYchanges = key->bitMapInfo.nYchanges;
        }

#ifdef DBG
    printf("...Exit  rc_BuildChar()\n");
#endif
        return(0);
} /* rc_BuildChar() */

/*
 * -----------------------------------------------------------------------------
 *
 * Routine: rc_FillChar
 *
 *      Generate abitmap or band bitmap of the current character
 *
 * -----------------------------------------------------------------------------
 */
 int
 rc_FillChar(BmIn, BmOut)
 struct BmIn    FAR *BmIn; /*@WIN*/
 BitMap        FAR * FAR *BmOut; /*@WIN*/
 {
#ifdef DBG
    printf("Enter rc_FillChar\n");
    printf(" memory[5]=%lx\n",(char FAR *)BmIn->bitmap5); /*@WIN_BASS*/
    printf(" memory[6]=%lx\n",(char FAR *)BmIn->bitmap6); /*@WIN_BASS*/
    printf(" memory[7]=%lx\n",(char FAR *)BmIn->bitmap7); /*@WIN_BASS*/
#endif
        in->memoryBases[5] = (char FAR *)BmIn->bitmap5; /*@WIN_BASS*/
        in->memoryBases[6] = (char FAR *)BmIn->bitmap6; /*@WIN_BASS*/
        in->memoryBases[7] = (char FAR *)BmIn->bitmap7; /*@WIN_BASS*/
        in->param.scan.bottomClip     = (int16)BmIn->bottom;
        in->param.scan.topClip        = (int16)BmIn->top;
        ret = fs_ContourScan(in, out);
        if(ret != NO_ERR)   return((int)ret);   //@WIN

        *BmOut = &out->bitMapInfo;

#ifdef DBG
    printf("...Exit  rc_FillChar()\n");
#endif
        return(0);
} /* rc_FillChar() */


/*
 * -----------------------------------------------------------------------------
 * routine: rc_CharPath
 *
 *      Generate the outline path of the current character
 *
 * -----------------------------------------------------------------------------
 */
int
rc_CharPath()
{
#ifdef DBG
    printf("Enter rc_CharPath\n");
#endif

#ifdef DJC // NOT used
        if (bWinTT) {   // for win31 TT font; @WINTT
            void TTCharPath(void);
            TTCharPath();
            return 0;
        }
#endif


        if(out->numberOfContours == 0)  /* A space has no path */
                return(0);

        cr_translate(&sfdt.tx, &sfdt.ty);

#ifdef DBG
    printf("tx = %f, ty = %f\n", sfdt.tx, sfdt.ty);
#endif
        QBSpline2Bezier(out->xPtr, out->yPtr, out->startPtr,
                     out->endPtr, out->onCurve, out->numberOfContours);
        return(0);
}

/*
 * -----------------------------------------------------------------------------
 * Routine:     rc_CharWidth
 *
 *      Get the width of the current character
 *
 * -----------------------------------------------------------------------------
 */
 int
 rc_CharWidth(charid, CharOut)
 int    charid;
 struct CharOut FAR *CharOut; /*@WIN*/
 {
        in->param.newglyph.characterCode = (uint16)charid;
        ret = fs_NewGlyph(in, out);
        if(ret != NO_ERR)   return((int)ret);   //@WIN

        ret = fs_GetAdvanceWidth(in, out);
        if(ret != NO_ERR)   return((int)ret);   //@WIN

        CharOut->awx = FIXED2FLOAT(out->metricInfo.advanceWidth.x);
        CharOut->awy = FIXED2FLOAT(out->metricInfo.advanceWidth.y);

        return(0);
 }



/*
 * -----------------------------------------------------------------------------
 *
 * QBSpline2Bezier() - Converts a Bass Quadradic B-Spline curve into
 *      a 3rd degree Bezier curve.
 *
 * -----------------------------------------------------------------------------
 */
static int QBSpline2Bezier( xPtr, yPtr, startPtr, endPtr, onCurve, numberOfContours )
F26Dot6       FAR *xPtr, FAR *yPtr ; /*@WIN*/
short         FAR *startPtr, FAR *endPtr ; /*@WIN*/
unsigned char FAR *onCurve ; /*@WIN*/
long          numberOfContours ;
{
    register int  i, points, offset, primed ;
    register F26Dot6  FAR *xp, FAR *yp ; /*@WIN*/
    register unsigned char  FAR *onp ; /*@WIN*/
    float  x0, y0, x1, y1, xTemp, yTemp, xStart, yStart ;
    float  xprime, yprime ;

#ifdef DBG
    printf("Enter QBSpline2Bezier\n");
#endif

    startPath() ;
    for ( i = 0; i < (int)numberOfContours; i++ ) {     //@WIN

        offset = ( *startPtr++ ) ;
        points = ( *endPtr++ - offset + 1 ) ;
        xp = xPtr + offset ;
        yp = yPtr + offset ;
        onp = onCurve + offset ;

        /*
         *    Check if the first point is on-curve.
         *    If not, use the last point of the curve as the on-curve
         *    point.  If the last curve is also off curve, synthesize
         *    an on-curve point.
         *
         *    ( xStart,yStart ) is coordinate for start of curve.
         */

        if ( *onp ) {
            onp++ ;
            points-- ;
            xStart = ( float )( *xp++ ) * SCL6 ;
            yStart = ( float )( *yp++ ) * SCL6 ;
        }
        else {
            if ( *( onp + ( points - 1 ) ) != 0 ) {
                points-- ;
                xStart = ( float )( *( xp + points ) ) * SCL6 ;
                yStart = ( float )( *( yp + points ) ) * SCL6 ;
            }
            else {
                xStart = (float)( *xp + *( xp + ( points - 1 ) ) ) * ( SCL6 * (float)0.5 ) ; //@WIN
                yStart = (float)( *yp + *( yp + ( points - 1 ) ) ) * ( SCL6 * (float)0.5 ) ; //@WIN
            }
        }

        x0 = xStart ;
        y0 = yStart ;
        startContour( x0, y0 ) ;

        primed = 0 ;

        /*
         *      Each time through the loop, most recent point (by definition,
         *      is an on-curve point) is ( x0,y0 ).
         */


        while ( points-- > 0 ) {

            if ( primed ) {
                x1 = xprime ;
                y1 = yprime ;
                primed = 0 ;
            }
            else {
                x1 = ( float )( *xp++ ) * SCL6 ;
                y1 = ( float )( *yp++ ) * SCL6 ;
            }

            /*
             *    Two on-curve points in a row.
             *    Connect with straight line, update current point and continue.
             */

            if ( *onp++ != 0 ) {
                straightLine( x0 = x1, y0 = y1 ) ;
                continue ;
            }

            /*
             *    Lastest point not on-curve.
             *
             *    If this is the last point in the set, generate a
             *    Bezier with P3 being the first point of the curve.
             *    After which, we are done.
             */

            if ( points <= 0 ) {
                quadraticBezier( x0, y0, x1, y1, xStart, yStart ) ;
                break ;
            }

            xTemp = x0 ;
            yTemp = y0 ;

            /*
             *    More points.  If the next point is on-curve, use the
             *    point as part of a Bezier (i.e., on,off,on).  This latest
             *    point is also updated as the current point.
             */

            if ( *onp != 0 ) {
                x0 = ( float )( *xp++ ) * SCL6 ;
                y0 = ( float )( *yp++ ) * SCL6 ;
                quadraticBezier( xTemp, yTemp, x1, y1, x0, y0 ) ;
                onp++ ;
                points-- ;
                continue ;
            }

            /*
             *    Next point not on-curve: i.e., two off-curve points in a row.
             *    Compute a synthetic on-curve point.
             */

            xprime = ( float )( *xp++ ) * SCL6 ;
            yprime = ( float )( *yp++ ) * SCL6 ;
            primed = 1 ;

            x0 = ( x1 + xprime ) * (float)0.5 ;
            y0 = ( y1 + yprime ) * (float)0.5 ;
            quadraticBezier( xTemp, yTemp, x1, y1, x0, y0 ) ;
        }
        cr_closepath() ;
    }
    return 0;   //@WIN
}

/*
 * -----------------------------------------------------------------------------
 *      Start a new path.
 * -----------------------------------------------------------------------------
 */
static void startPath()
{
    cr_newpath() ;
}

/*
 * -----------------------------------------------------------------------------
 *      Start a contour.
 * -----------------------------------------------------------------------------
 */
/*static void startContour( x, y ) to avoid C6.0 warning @WIN*/
/*register float x, y ;                                  @WIN*/
static void startContour( float x, float y )
{
    x += sfdt.tx;
    y = sfdt.ty - y;

    cr_moveto( x, y ) ;
}

/*
 * -----------------------------------------------------------------------------
 *      Generate straight line segment.
 * -----------------------------------------------------------------------------
 */
/*static void straightLine( x, y ) to avoid C6.0 warning @WIN*/
/*register float x, y ;                                  @WIN*/
static void straightLine( float x, float y )
{
    x += sfdt.tx;
    y = sfdt.ty - y;

    cr_lineto( x, y) ;
}

/*
 * -----------------------------------------------------------------------------
 *              Generate curve segment.
 * -----------------------------------------------------------------------------
 */
/*static void quadraticBezier( x0, y0, x1, y1, x2, y2 ) to avoid C6.0 warning @WIN*/
/*register float x0, y0, x1, y1, x2, y2 ;                             @WIN*/
static void quadraticBezier( float x0, float y0, float x1,
                             float y1, float x2, float y2)
{
    register    float   translate;

    translate = sfdt.tx;
    x0 += translate;;
    x1 = (translate + x1) * (float)2.0;
    x2 += translate;

    translate = sfdt.ty;
    y0 = translate - y0;
    y1 = (translate - y1) * (float)2.0;
    y2 = translate - y2;

    cr_curveto((x0+x1)*KK, (y0+y1)*KK, (x2+x1)*KK, (y2+y1)*KK, x2, y2);
}



/*
 * -----------------------------------------------------------------------------
 * Routine:     GetSfntPiecePtr
 *
 *      Get SFNT Fragement Pointer
 *
 * -----------------------------------------------------------------------------
 */
static char FAR *                /*@WIN*/
GetSfntPiecePtr(fp, offset, length)
long    fp;
long    offset;
long    length;
{
#ifdef DBG0
    printf("Enter GetSfntPiecePtr\n");
    printf("fp=%lx, offset=%lx, length=%lx, sfnt=%lx\n", fp, offset, length, sfdt.sfnt);
#endif
    return(sfdt.sfnt + offset);
} /* GetSfntPiecePtr() */

/*
 * -----------------------------------------------------------------------------
 * Routine: LargestCtm(ctm, lsize)
 *
 * Find Largest value of the given ctm to
 * find the largest element in the matrix.
 * This routine return the largest
 * of scale and yscale as well as the scale factors them selves.
 *
 * -----------------------------------------------------------------------------
 */
static int
LargestCtm(ctm, lsize)
float FAR *ctm, FAR *lsize; /*@WIN*/
{
    float    a, b, c, d;

#ifdef DBG
    printf("Enter LargestCtm\n");
    printf("ctm: %f %f %f %f %f %f\n", ctm[0], ctm[1], ctm[2], ctm[3], ctm[4], ctm[5]);
#endif

    a = (ctm[0] >= (float)0.0) ? ctm[0] : - ctm[0];     //@WIN
    b = (ctm[1] >= (float)0.0) ? ctm[1] : - ctm[1];     //@WIN
    c = (ctm[2] >= (float)0.0) ? ctm[2] : - ctm[2];     //@WIN
    d = (ctm[3] >= (float)0.0) ? ctm[3] : - ctm[3];     //@WIN

    if (b > a)    a = b;
    if (d > c)    c = d;

    if (c > a)    a = c;

    if (a == zero_f)    *lsize = (float)1.0;           /*@WIN*/
    else               *lsize = a;

    return(0);
} /* LargestCtm() */


/*
 * -----------------------------------------------------------------------------
 * debug routine
 * -----------------------------------------------------------------------------
 */
DebugStr(msg)
char FAR *msg ;  /*@WIN*/
{
        printf("*** BASS Error : %s ***\n",msg) ;
        return(0);                             /* exit=>return @WIN*/
}

/* --------------------- End of in_sfnt.c -------------------------- */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\font_sys.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/**************************************************************/
/*                                                            */
/*      font_sys.h               10/9/87      Danny           */
/*                                                            */
/**************************************************************/

/*
 *  08/24/88    You
 *      redefined system parameters about font cache.
 */


#define   ERR_VALUE  1e-5
           /* error tolerence for matrix compare */

#define   SHOW         1
#define   CHARPATH     2
#define   STRINGWIDTH  3

/* Extended Box of setcachedevice */

#define   BOX_LLX      60
#define   BOX_LLY      60
#define   BOX_URX      60
#define   BOX_URY      60


/* System Limit about cache paramters */

    /* UniqueID goes from 0 to this value */
#   define  MAX_UNIQUEID        0x00FFFFFF  /* LW+ v.38: 24-bit */

    /* range for cacheparams' upper: [0 .. this] */
#   define  CACHE_RANGE         135960L

    /* default value of cacheparams' upper: to cache or not */
#   define  CACHEPARAMS_UB      12500L

    /* default value of cacheparams' lower: to compress or not */
#   define  CACHEPARAMS_LB      1250L


/* Tunable System Limit about Font Cache */

    /* (internal) FontType goes from 0 to this value */
#   define  MAX_FONTTYPE        0x3F        /* 6-bit */

    /* Max Font/Matr Combinations */
#   define  MAX_MATR_CACHE      200     /* 136 for LW+ v.38 Jul-11,1991 YM */

    /* Max Characters Able to Be Cached */
#ifdef KANJI
#   define  MAX_CHAR_CACHE      1000    /* for KANJI project */
#else
#   define  MAX_CHAR_CACHE      1700    /* LW+ v.38 */
#endif

    /* (internal) Number of Character Groups per Cache Class */
#   define  N_CGRP_CLASS        80

    /* (internal) Max CG Segment to Be Allocated */
#   define  MAX_CGSEG           255
                                /* when this over 255, you have to rewrite
                                 *  codes of Cache Class Manager in font cache.
                                 */

    /* (internal) Number of CG entries per CG Segment */
#   define  N_CG_CGSEG          16
                                /* whenever you change it, you have to
                                 *  rewrite codes of Cache Class Manager
                                 *  in font cache.
                                 */

    /* (internal) min. size in byte of bitmap cache to paint a huge char */
#   define MINBMAPSIZE_HUGECHAR     10000L


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\mapping.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */


// DJC added global include
#include "psglobal.h"


#define    LINT_ARGS            /* @WIN */
#define    NOT_ON_THE_MAC       /* @WIN */
#define    KANJI                /* @WIN */
// DJC use command line #define    UNIX                 /* @WIN */

#ifdef  KANJI

/*
 *
 *  11/16/88    Ada    register adding & zero_f one_f updating
 *  08/29/90    ccteng change <stdio.h> to "stdio.h"
 *  03/27/91    kason  change "DEBUG" to "DBG", "G2" to "DBG"
 *  04/15/91    Ada    solving kshow bugs, reference KSH flag.
 */

#include        <string.h>

#include        "global.ext"
#include        "graphics.h"

#include        "mapping.h"

#include        "fontfunc.ext"

#include        "fontinfo.def"

#include        "stdio.h"


/* LOCAL FUNCTION */
#ifdef  LINT_ARGS
static bool near esc_mapping(struct map_state FAR *); /*@WIN*/
static bool near other_mapping(struct map_state FAR *); /*@WIN*/
static bool near one_mapping(struct map_state FAR *); /*@WIN*/
static bool near get_bytes(struct map_state FAR *, fix, ufix16 FAR *); /*@WIN*/
static void near get_escbytes(struct map_state FAR *, struct code_info FAR *); /*@WIN*/
static void near mul_unitmat(real32 FAR *, real32 FAR *, real32 FAR *); /*@WIN*/
#else
static bool near esc_mapping();
static bool near other_mapping();
static bool near one_mapping();
static bool near get_bytes();
static void near get_escbytes();
static void near mul_unitmat();
#endif

extern struct f_info near    FONTInfo; /* union of current font information */


#define         CUR_MFONT       (map_state->cur_mapfont)
#define         ROOTFONT        (map_state->finfo)
#define         UNEXTRACT(code) \
                {\
                    map_state->unextr_code = code;\
                    map_state->unextracted = TRUE;\
                }

/*      INIT_MAPPING()
 *      Setup rootfoot infomation in mapping state as the initial situation.
 *      It fails in case that rootfont errs.
 */
// DJC changed to new ANSI type
bool    init_mapping(struct map_state FAR *map_state,
                     ubyte FAR  str_address[],
                     fix  str_byteno)
{
        struct          mid_header      FAR *mid_head; /*@WIN*/
        register    fix             i, root_error;

        /* Set initial vaule for map_state */
        map_state->esc_idex = map_state->idex = 0;
        map_state->root_is_esc = map_state->unextracted = FALSE;
        map_state->str_addr = str_address;
        map_state->str_len = str_byteno;
        map_state->wmode = (ubyte)WMODE(&FONTInfo);

        /* Setup Level-1 value for root font */
        if (!(ROOTFONT->fonttype = FONT_type(&FONTInfo)))
        /* copy FontType whenever */
        {
            /* do it only if composite root font */
            root_error = LENGTH(MIDVECtor(&FONTInfo));
            if  ( root_error != NOERROR)
            {
                ERROR(((ufix16)(root_error)));
                return(FALSE);
            }

            ROOTFONT->midvector = MIDVECtor(&FONTInfo);
            mid_head = (struct mid_header FAR *) VALUE(ROOTFONT->midvector); /*@WIN*/
#ifdef  DBG
            printf("root font MidVector address = %lx\n", mid_head);
#endif
            ROOTFONT->maptype  = mid_head->fmaptype;
            ROOTFONT->de_size = mid_head->de_size;
            ROOTFONT->de_fdict = (struct object_def FAR * FAR *)  (mid_head + 1); /*@WIN*/
            ROOTFONT->de_errcode = (fix FAR *)            /*@WIN*/
                                    (ROOTFONT->de_fdict + ROOTFONT->de_size);

            for (i = 0; i < CFONT_LEVEL; i++)
                map_state->finfo[i].fontdict = NULL;
            /* scalematrix = FontMatrix;        */
            for (i = 0; i < 6; i++)
                    ROOTFONT->scalematrix[i] = FONT_matrix(&FONTInfo)[i];

            /* check if Root font is EscMap */
            if (mid_head->fmaptype == MAP_ESC)
            {
                map_state->root_is_esc = TRUE;
                map_state->esc_char = ESCchar(&FONTInfo);

                if      (*(map_state->str_addr) == map_state->esc_char)
                {
                        map_state->str_addr++;
                        map_state->str_len--;
                }
                else    /* unextract code 00 to string */
                        UNEXTRACT(0);
            }  /* end check EscMap */
        }   /* end check composite font */

        return(TRUE);
}


/*      MAPPING()
 *      Apply mapping algorithm sucessively to get a basefont and code(s).
 */
bool    mapping(map_state, code_info)
struct  map_state       FAR *map_state;          /*@WIN*/
struct  code_info       FAR *code_info;          /*@WIN*/
{
        ufix16  data;

        code_info->fmaptype = 0;   /*JJ for check in widthshow 07-10-90 */
        if (map_state->str_len == 0)
                /* end of data */
                return(FALSE);

        /* Make sure to check Root Font rather than Current Font!!! */
        if (ROOTFONT->fonttype != 0)
        /* Root font is a base font */
        {
                /* Prepare CODE_INFO to return */
                code_info->font_nbr = 0;
            /* KSH 4/21/91
             *  code_info->byte_no = MIN(BUF_SIZE, map_state->str_len);
             *  memcpy((ubyte *) code_info->code, (ubyte *)
             *                map_state->str_addr , code_info->byte_no);
             *  map_state->str_len -= code_info->byte_no;
             *  map_state->str_addr += code_info->byte_no;
             */
                code_info->byte_no = map_state->str_len;
                code_info->code_addr = map_state->str_addr;
                map_state->str_len = 0;
             /* KSH-end */

                return(TRUE);
        }

#ifdef  DBG
    printf("mapping 0: error = %d\n", ANY_ERROR());
#endif

        /* Current Mapping Font info ==> finfo[esc_idex].xxxxx */
        CUR_MFONT = &map_state->finfo[map_state->esc_idex];
        map_state->nouse_flag = FALSE;
        if (map_state->root_is_esc)     /* Apply ESC mapping */
            if (!esc_mapping(map_state))
                return(FALSE);

        map_state->idex = map_state->esc_idex;
        /* Current Mapping Font info ==> finfo[idex].xxxxx */
        if (!other_mapping(map_state))
                return(FALSE);
#ifdef  DBG
    printf("mapping 1: error = %d\n", ANY_ERROR());
#endif

        /* prepare CODE_INFO                   */
        code_info->font_nbr = map_state->font_no;
        code_info->fmaptype = (ubyte)((CUR_MFONT - 1)->maptype);
        code_info->byte_no = 1;
        if      (code_info->fmaptype == MAP_ESC)
                get_escbytes(map_state, code_info);
        else
        {
                if (!get_bytes(map_state, 1, &data))
                    return(FALSE);
                code_info->code[0] = (ubyte) data;
        }

        /* Update current font in graphics status */
        do_setfont(CUR_MFONT->fontdict);

        return(TRUE);
}


/*      ESC_MAPPING()
 *      Apply ESC mapping successively until non-ESC mapping font.
 */
static bool near   esc_mapping(map_state)
struct  map_state       FAR *map_state; /*@WIN*/
{
    struct  object_def      FAR *de_fontdict; /*@WIN*/
    struct  f_info          finfo;
    ufix16                  data;
    struct  mid_header      FAR *mid_head; /*@WIN*/

    /* Current Mapping Font info ==> finfo[esc_idex].xxxxx */
    while   (TRUE)
    {
        if (!get_bytes(map_state, 1, &data))
            return(FALSE);

        if (data == map_state->esc_char)
        {
                if (map_state->esc_idex == 0)
                {   /* no more level to pop */
                    ERROR(RANGECHECK);
                    return(FALSE);
                }

                map_state->esc_idex--;  /* POP one level */
                CUR_MFONT->fontdict = NULL;
                map_state->nouse_flag = TRUE;
                CUR_MFONT--;
        } /* end ESC char */
        else if ((CUR_MFONT->fonttype == 0) && (CUR_MFONT->maptype == MAP_ESC))
        {
                /* check if level > 5 */
                map_state->esc_idex++;
                if (map_state->esc_idex == CFONT_LEVEL)
                {   /* stack overflow */
                    ERROR(LIMITCHECK);
                    return(FALSE);
                }

                if  (data >= CUR_MFONT->de_size)
                {
                    ERROR(RANGECHECK);
                    return(FALSE);
                }

                if  (CUR_MFONT->de_errcode[data] != NOERROR)
                {       /* descendent font errs */
                    ERROR(((ufix16)(CUR_MFONT->de_errcode[data])));
                    return(FALSE);
                }

                de_fontdict = CUR_MFONT->de_fdict[data];
                map_state->font_no = data;
                CUR_MFONT++;
                CUR_MFONT->fontdict = de_fontdict;
                if (!(CUR_MFONT->fonttype = (ufix)get_f_type(de_fontdict)))
                {   /* composite font */
                    fix             error_code;

                    if (get_f_info(de_fontdict, &finfo))
                        return(FALSE);

                    error_code = LENGTH(MIDVECtor(&finfo));
                    if  (error_code != NOERROR)
                    {
                        ERROR(((ufix16)(error_code)));
                        return(FALSE);
                    }

                    CUR_MFONT->midvector = MIDVECtor(&finfo);
                    mid_head = (struct mid_header FAR *) /*@WIN*/
                                       VALUE(CUR_MFONT->midvector);
#ifdef  DBG
            printf("esc_mapping() MidVector address = %lx\n", mid_head);
#endif
                    CUR_MFONT->maptype = mid_head->fmaptype;
                    CUR_MFONT->de_size = mid_head->de_size;
                    CUR_MFONT->de_fdict = (struct object_def FAR * FAR *) /*@WIN*/
                                                             (mid_head + 1);
                    CUR_MFONT->de_errcode = (fix FAR *)          /*@WIN*/
                               (CUR_MFONT->de_fdict + CUR_MFONT->de_size);
                    /* smatrix = FontMatrix * smatrix[esc_idex - 1];   */
                    mul_unitmat(CUR_MFONT->scalematrix, FONT_matrix(&finfo),
                                (CUR_MFONT-1)->scalematrix);
                }
        }  /* end elseif */
        else
        {
                UNEXTRACT(data);
                break;
        }
    } /* end while */

    return(TRUE);
}


/*      OTHER_MAPPING()
 *      Apply 8/8, 1/7, 9/7 or SubsVector mapping successively until find a
 *               basefont.
 */
static bool near   other_mapping(map_state)
struct  map_state       FAR *map_state; /*@WIN*/
{
    struct  object_def      FAR *de_fontdict; /*@WIN*/
    struct  f_info          finfo;
    struct          mid_header      FAR *mid_head; /*@WIN*/

#ifdef  DBG
    printf("");
#endif

    while (CUR_MFONT->fonttype == 0)
    {
        if (!one_mapping(map_state))   /* Get next fno */
                return(FALSE);

#ifdef  DBG
    printf("1: %d\n", ANY_ERROR());
#endif
        /* check if level > 5 */
        map_state->idex++;
        if (map_state->idex == CFONT_LEVEL)
        {       /* stack overflow */
                ERROR(LIMITCHECK);
                return(FALSE);
        }

        if  (map_state->font_no >= CUR_MFONT->de_size)
        {
                ERROR(RANGECHECK);
                return(FALSE);
        }

        if  (CUR_MFONT->de_errcode[map_state->font_no] != NOERROR)
        {       /* descendent font errs. */
                ERROR(((ufix16)(CUR_MFONT->de_errcode[map_state->font_no])));
                return(FALSE);
        }


        de_fontdict = CUR_MFONT->de_fdict[map_state->font_no];
        CUR_MFONT++;
        if ((CUR_MFONT->fontdict != de_fontdict) || map_state->nouse_flag)
        {   /* This entry cannot be reused */
            CUR_MFONT->fontdict = de_fontdict;
            map_state->nouse_flag = TRUE;
            if (!(CUR_MFONT->fonttype = (ufix)get_f_type(de_fontdict)))
            {   /* composite font */
                fix     error_code;

                if (get_f_info(de_fontdict, &finfo))
                    return(FALSE);

                error_code = LENGTH(MIDVECtor(&finfo));
                if  (error_code != NOERROR)
                {
                    ERROR(((ufix16)(error_code)));
                    return(FALSE);
                }

                CUR_MFONT->midvector = MIDVECtor(&finfo);
                mid_head = (struct mid_header FAR *) /*@WIN*/
                            VALUE(CUR_MFONT->midvector);
#ifdef  DBG
            printf("other_mapping() MidVector address = %lx\n", mid_head);
#endif
                CUR_MFONT->maptype  = mid_head->fmaptype;
                CUR_MFONT->de_size = mid_head->de_size;
                CUR_MFONT->de_fdict = (struct object_def FAR * FAR *) /*@WIN*/
                                                     (mid_head + 1);
                CUR_MFONT->de_errcode = (fix FAR *)              /*@WIN*/
                            (CUR_MFONT->de_fdict + CUR_MFONT->de_size);
                /* smatrix = FontMatrix * smatrix[idex - 1];       */
                mul_unitmat(CUR_MFONT->scalematrix, FONT_matrix(&finfo),
                                (CUR_MFONT-1)->scalematrix);
            } /* end if composite font */
        } /* end if entry cannot be reused */
    } /* end while */


    return(TRUE);
}

/*      ONE_MAPPING()
 *      Apply 8/8, 1/7, 9/7 or SubsVector mapping once to get font number.
 *      If meets any other mapping type, it generates error code.
 */
static bool near   one_mapping(map_state)
struct map_state        FAR *map_state; /*@WIN*/
{
        /* Current Mapping Font info ==> finfo[idex].xxxxx */
        switch (CUR_MFONT->maptype)
        {
            case  MAP_88:
                        if (!get_bytes(map_state, 1, &map_state->font_no))
                                return(FALSE);
                        break;
            case  MAP_17:
                        if (!get_bytes(map_state, 1, &map_state->font_no))
                                return(FALSE);
                        UNEXTRACT(map_state->font_no & 0x7f);
                        map_state->font_no >>= 7;
                        break;
            case  MAP_97:
                        if (!get_bytes(map_state, 2, &map_state->font_no))
                                return(FALSE);
                        UNEXTRACT(map_state->font_no & 0x7f);
                        map_state->font_no >>= 7;
                        break;
            case  MAP_SUBS:
            {
                register    ubyte   subs_len, i;
                ubyte   FAR *subsvector; /*@WIN*/
                ufix16  value, range;

                subsvector = (ubyte FAR *) (CUR_MFONT->de_errcode /*@WIN*/
                                       + CUR_MFONT->de_size);
                subs_len = *subsvector++;
                if (!get_bytes(map_state, (ufix) (subsvector[0] + 1), &value))
                        return(FALSE);
                for (i = 1; i < subs_len; value -= range, i++)
                {
                    if (!(range = subsvector[i])) /* copy, not equal */
                                /* zero means 256 */
                                range = 256;
                    if (value < range)
                                break;
                }

                UNEXTRACT(value);
                map_state->font_no = i - 1;
                break;
            }
            default:
                        ERROR(INVALIDFONT);
                        return(FALSE);
        } /* end switch */
        return(TRUE);
} /* end one_mapping() */

/*      GET_ESCBYTES()
 *      Extract several codes for the base font to show.
 *      It will get all codes unless it meets ESCchar.
 */
static void near   get_escbytes(state, codeinfo)
struct map_state        FAR *state; /*@WIN*/
struct code_info        FAR *codeinfo; /*@WIN*/
{
        ubyte   FAR *dest; /*@WIN*/

        dest = codeinfo->code;
        codeinfo->byte_no = 0;

        if (state->unextracted)
        {
            codeinfo->byte_no = 1;
            *dest++ = (ubyte) state->unextr_code;
            state->unextracted = FALSE;
        }

        while (state->str_len > 0 && (*state->str_addr) != state->esc_char &&
                (codeinfo->byte_no < BUF_SIZE)  )
        {
                *dest++ = *state->str_addr++;
                state->str_len--;
                codeinfo->byte_no++;
        }
} /* end get_escbytes() */

/*      GET_BYTES()
 *      Extract one or two bytes value from show string.
 *      If there is a unextracted code, it will consume it at first.
 *      If insufficient code, it generates a error code.
 */
static bool near   get_bytes(state, no, value)
struct map_state        FAR *state; /*@WIN*/
fix                     no;
ufix16                  FAR *value; /*@WIN*/
{
        if (state->unextracted)
        {
                *value = state->unextr_code;
                state->unextracted = FALSE;
        }
        else
        {
                if (state->str_len == 0)
                {       /* insufficient data */
                        ERROR(RANGECHECK);
                        return(FALSE);
                }
                *value = *state->str_addr++;
                state->str_len--;
        }

        if (no > 1)
        {
                if (state->str_len == 0)
                {       /* insufficient data */
                        ERROR(RANGECHECK);
                        return(FALSE);
                }
                *value = ((ufix16) (*value) << 8) +
                          (ufix16) *state->str_addr++;
                state->str_len--;
        }

        return(TRUE);
} /* end get_bytes() */


/*      MUL_UNITMAT()
 *      Matrix concatenation. (i.e. m = m1 * m2)
 *      It's probable that m1 is a unit matrix.  If so, the multiplicaion could
 *      be optimized.
 */
static void near   mul_unitmat(m, m1, m2)
real32  FAR m[], FAR m1[], FAR m2[];    /*@WIN*/
{
        /*               | 1    0 |
           Check if m1 = | 0    1 |
                         | *    * |             */
        if ((F2L(m1[0]) == F2L(one_f))   &&   (F2L(m1[1]) == F2L(zero_f))  &&
            (F2L(m1[2]) == F2L(zero_f))  &&   (F2L(m1[3]) == F2L(one_f))   )
        {
                m[0] = m2[0];
                m[1] = m2[1];
                m[2] = m2[2];
                m[3] = m2[3];
                m[4] = m2[4];
                m[5] = m2[5];
                if (F2L(m1[4]) != F2L(zero_f))
                {
                        m[4] += m1[4] * m2[0];
                        m[5] += m1[4] * m2[1];
                }
                if (F2L(m1[5]) != F2L(zero_f))
                {
                        m[4] += m1[5] * m2[2];
                        m[5] += m1[5] * m2[3];
                }
        }
        else
                mul_matrix(m, m1, m2);
}


/*      DEFINE_MIDVECTOR()
 *      Create MIDVcetor value object for the definefonted dict.
 *      This object is designed for internal mapping usage.
 *              LENGTH(obj) will record rootfont error code.
 *              VALUE(obj) will pointer to ---
 *                      descendent no + FMapType +
 *                      dict address[] + error code[] +
 *                      length(SubsVector) + SubsVector[]
 */
bool    define_MIDVector(mid_obj, items)
struct  object_def      FAR *mid_obj; /*@WIN*/
struct  comdict_items   FAR *items; /*@WIN*/
{
        fix     VM_bytes, size, maptype, i, idex;
        struct  mid_header  huge *head; /*@WIN 04-20-92*/
        struct  object_def  huge * huge *dict_dest, FAR
                            *encoding, FAR *fdepvector;   /*@WIN 04-20-92*/
        fix     huge *err_dest; /*@WIN 04-20-92*/
        ubyte   subs_len, FAR *subsvector, FAR *dest; /*@WIN*/

        /* Setup MIDVector value object */
        TYPE_SET(mid_obj, STRINGTYPE);
        ATTRIBUTE_SET(mid_obj, LITERAL);
        ACCESS_SET(mid_obj, NOACCESS);
        LEVEL_SET(mid_obj, current_save_level);
        ROM_RAM_SET(mid_obj, RAM);

        /* typecheck for Encoding & FDepVector */
        if (TYPE(items->encoding) != ARRAYTYPE)
        {
                /* root_error = TYPECHECK;      */
                LENGTH(mid_obj) = TYPECHECK;
                return(TRUE);
        }

        if (TYPE(items->fdepvector) != ARRAYTYPE)
        {
                /* root_error = TYPECHECK;      */
                LENGTH(mid_obj) = TYPECHECK;
                return(TRUE);
        }


        /* VM byte number initial value */
        VM_bytes = sizeof(struct mid_header);

        maptype = (fix) VALUE(items->fmaptype);

    /* decide descendent no. */
        switch  (maptype)
        {
            case MAP_17:
                        size = 2;
                        break;
            case MAP_88:
                        size = 256;
                        break;
            case MAP_97:
                        size = 512;
                        break;
            case MAP_ESC:
                        size = 256;
                        break;
            case MAP_SUBS:
                        /* typecheck for Encoding & FDepVector */
                        if (TYPE(items->subsvector) != STRINGTYPE)
                        {
                                /* root_error = TYPECHECK;      */
                                LENGTH(mid_obj) = TYPECHECK;
                                return(TRUE);
                        }

                        subs_len = (ubyte) LENGTH(items->subsvector);
                        subsvector = (ubyte FAR *) VALUE(items->subsvector); /*@WIN*/
                        if      (subs_len < 2)
                        {
                                /* root_error = INVALIDFONT; */
                                LENGTH(mid_obj) = INVALIDFONT;
                                return(TRUE);
                        }
                        if      (subsvector[0] > 1)
                        {
                                /* root_error = RANGECHECK;     */
                                LENGTH(mid_obj) = RANGECHECK;
                                return(TRUE);
                        }

                        size = subs_len;
                        break;
            default:    /* incorrect FMapType */
                        /* root_error = RANGECHECK;     */
                        LENGTH(mid_obj) = RANGECHECK;
                        return(TRUE);
        } /* end switch */
        if      ((fix)LENGTH(items->encoding) < size)   //@WIN
                size = LENGTH(items->encoding);

        /*   Decide actual VM size */
        VM_bytes += size * sizeof(struct object_def FAR *); /*@WIN*/
        VM_bytes += size * sizeof(fix);
        if      (maptype == MAP_SUBS)
        {
                VM_bytes += subs_len;
                VM_bytes++;            /* for string length */
        }

        /* Allocate VM  */
#ifdef  DBG
    printf("Allocate %d bytes for MIDVector\n", VM_bytes);
#endif
        head = (struct mid_header huge *) alloc_vm((ufix32) VM_bytes); /*@WIN*/
        if      (!head)
        {
                ERROR(VMERROR);
                return(FALSE);
        }

        /* Setup MIDVector header */
        head->de_size = size;
        head->fmaptype = maptype;

        /* Setup MIDVector object */
        VALUE(mid_obj) = (ULONG_PTR) head;
        LENGTH(mid_obj) = NOERROR;

        /* Setup dict address & error code for each descendent */
        dict_dest = (struct object_def huge * huge *) (head + 1); /*@WIN*/
        err_dest = (fix huge *) (dict_dest + size); /*@WIN 04-20-92*/
        encoding = (struct object_def FAR *) VALUE(items->encoding); /*@WIN*/
        fdepvector = (struct object_def FAR *) VALUE(items->fdepvector); /*@WIN*/
        for     (i = 0; i < size; i++, dict_dest++)
        {
            if      ((TYPE(&encoding[i]) != INTEGERTYPE) ||
                    ((idex = (fix) VALUE(&encoding[i])) >=
                                  (fix)LENGTH(items->fdepvector))     ) //@WIN
            {
                    /* RECORD  descendent error code as RangeCheck */
                    *err_dest++ = RANGECHECK;
            }
            else if ((TYPE(&fdepvector[idex]) != DICTIONARYTYPE)   ||
               (!DFONT((struct dict_head_def FAR *) VALUE(&fdepvector[idex])))) /*@WIN*/
            {
                    /* RECORD  descendent error code as InvalidFont */
                    *err_dest++ = INVALIDFONT;
            }
            else    /* this descendent no error */
            {
                    *err_dest++ = NOERROR;
                    *dict_dest = &fdepvector[idex];
            }
        } /* end for */

        /* If SubsVector, record range information */
        if      (maptype == MAP_SUBS)
        {
                dest = (ubyte FAR *) err_dest; /*@WIN*/
                /* RECORD  strlen(SubsVector) */
                *dest++ = subs_len;

                for     (i = 0; i < (fix)subs_len; i++)         //@WIN
                        /* RECORD SubsVector[i] */
                        *dest++ = subsvector[i];
        }


#ifdef  DBG
        printf("MID address = %lx, FMapType = %d, \n", head, head->fmaptype);
        printf("    array size = %d", size);
        printf("    ==> [dict_address, error code]\n");

        dict_dest = (struct object_def FAR * FAR *) (head + 1); /*@WIN*/
        err_dest = (fix FAR *) (dict_dest + size); /*@WIN*/
        for (i = 0; i < size; i++)
                printf("[%lx, %4x]   ", dict_dest[i], err_dest[i]);
        printf("\n");
#endif

        return(TRUE);
}


#endif          /* KANJI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\qemsupp.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */


#include "psglobal.h"

#define    LINT_ARGS            /* @WIN */
#define    NOT_ON_THE_MAC       /* @WIN */
#define    KANJI                /* @WIN */
// DJC eliminate and use command line arg
// #define    UNIX                 /* @WIN */

/*
 * --------------------------------------------------------------------
 *  File: QEMSUPP.C                     09/05/88 created by Brian You
 *
 *  Descriptions:
 *      This file includes modules to support various font QEMs and
 *          its filler, i.e. FontType-Independent supporting for various
 *          built-in base fonts, including:
 *      QEM PATH SUPPORT:
 *          . qem initialization.               (newly defined  - 10/08/88)
 *          . make path interfaces.             (newly defined  - 09/05/88)
 *          . qem path contructions.            (by S.C.Chen    - 09/05/88)
 *          . qem path traversal.               (from BSFILL2.C - 10/06/88)
 *          . curve approximations of qem path. (by S.C.Chen    - 09/05/88)
 *      QEM FILL SUPPORT:
 *          . fill dispather.                   (from BSFILL2.C - 10/06/88)
 *          . shape approx & edge constructions.(newly defined  - @16+)
 *          . scan conversions.                 (from BSFILL2.C - 10/06/88)
 *      QEM GP SUPPORT:
 *          . qem bitmap render.                (from BSFILL2.C - 09/05/88)
 *
 *  Revision History:
 *  1.09/08/88  you     uniform warning message.
 *  2.09/09/88  you     add debugging facilities.
 *  3.09/12/88  you     add run-time flag to switch between even-odd fill and
 *                          non-zero winding number fill for QEM fill.
 *  4.09/29/88  you     move LFX2SFX_T() to "graphics.ext".
 *  5.09/29/88  you     add subpath_open_count to fix bug of abnormal path.
 *                          (e.g. "space" consists of a closepath only).
 *  6.10/07/88  you     fix bug of subpath_open_count handling in __moveto().
 *  7.10/08/88  you     re-organize to renew module structures and interfaces.
 *                      . add __make_path, USE_EOFIIL, USE_NONZEROFILL.
#ifdef  KANJI
 *                              and __set_cache_device2 for KANJI.
#endif
 *                      . include __current_matrix.
 *                      . add FONTTYPE_MAKE_PATH, CHK_DO_QEM, and
 *                              FONTTYPE_FILL_SHAPE macros.
 *                      . remove traverse_qem_path.
 *                      . add __fill_shape, chk_bmap_extnt and "bmap_extnt".
 *                      . add qem_shape_approx --> QEM Fill's (*vect2edge)().
 *                      . add qem_scan_conv --> QEM Fill's (*do_pairs)().
 *                      . rewrite init_qem_bit.
 *                      . add __qem_init and __qem_restart.
 *  8.10/11/88  you     discard un-used variables.
 *  9.10/12/88  you     an extra lineto required in case of CLOSEPATH in
 *                          qem_shape_approx() to close the open path.
#ifdef KANJI
 * 10.10/19/88  you     invoke get_CD2_extra() to transfer control from
 *                          __set_cache_device() to __set_cache_device2(),
 *                          since __set_cache_device() serves for FontType 1
 *                          and __set_cache_device2() for FontType 5 and 6.
 *                          In the current implementations, FontType 5 is
 *                          faked upon FontType 1, so it needs a transfer.
 * 11.10/21/88  you     save all the private/export data of Make Path Interfaces *                          BEFORE invoking QEM internal make path and restore
 *                          all AFTER invocation, since setcachedevice2 may
 *                          execute a user-defined PostScript procedure and
 *                          hence it may lead to recursive show operations.
 *            WARN: all the internal static data of qem MUST be generated
 *                          right AFTER invoking __set_cache_device() or
 *                          __set_cache_device2().
#endif
 * 12.10/21/88  you     modify interfaces of __make_path.
 *                          (eleminate argument of "size_of_charstrings").
 * 13.11/21/88  you     include fntcache.ext to clarify interfaces for get_pm()
 *                          and define QEMFILL_INC before include.
#ifdef KANJI
 * 14.11/22/88  you     fix bug of improper position to save/restore all the
 *                          private/export data of Make Path Support.
 *                          (to do it in __set_cache_device2() rather than
 *                          in __make_path()).
#endif
 * 15.11/24/88  you     allocate scanline_table[] in restart_qem_bit() by
 *                          alloc_scanline() rather than share the same
 *                          global space, and always have to flush_qem_bit()
 *                          no matter success or not in scan conversion.
 *                      . use pixel_table instead of scanline_table in
 *                          qem_set1bit() and qem_pixelout().
 * 16.12/13/88  you     modify for edge_table restructured from singly linked
 *                          list to indexed linked list.
 *                      . add restart_qem_edge(), add_qem_edge().
 *                      . qem_shape_approx() invoke restart_qem_edge() first.
 *                      . rename qem_update_et() --> qem_update_actv().
 *                      . modify interfaces and algorithms of qem_scan_conv(),
 *                              qem_sort_actv(), and qem_update_actv()
 *                              to fit new data structures.
 * 17.12/19/88  you     fix bug of incorrect calculation of "bmap_rasght" in
 *                          init_qem_bit() in case of F_TO_PAGE and need2clip:
 *                          have bmap_rasght NOT ONLY bounded by max scanlines
 *                          allowed by low-layer graphics primitives, BUT ALSO
 *                          as small as possible.
 * 18.12/20/88  you     share nodes of sfix_t representations with graphics
 *                          . qem_bezier_to_line() --> bezier_to_line_sfx(),
 *                                  (and move it to PATH.C).
 *                          . QEMVX_X  -->  VXSFX_X.
 *                          . QEMVX_Y  -->  VXSFX_Y.
 *                          . QEMVX_TYPE  -->  VXSFX_TYPE.
 * 19.01/09/89  you     __current_matrix(): (real64[] --> real32[]).
 * 20. 1/13/89  Ada     make path_dest public
 *                      qem_lineto(), qem_moveto() & qem_curveto() public
 * 21. 1/19/89  Ada     make qem_closepath & qem_newpath public
 * 22.03/17/89  You     correct mis-spelling of qem_sort_actv & qem_update_actv
 *                          for !LINT_ARGS.
 * 24.11/15/89  SCC     re-structure node table; combine subpath
 *                      and first vertex to one node. @NODE
 * 25.04/10/90  you     modified is_within_qemrep() due to changes to
 *                          CHK_DO_QEM().
 * 26.07/24/90  BYou    fixed a bug in chk_bmap_extnt():
 *                          return FALSE to indicate not to scan convert
 *                          NOT only when no edges constructed but also
 *                          the resultant extents should be nothing in
 *                          both dimensions. In old code, it cause a
 *                          character of single or multiple horizontal
 *                          thin stems scan converted with NULL bitmap.
 *      8/29/90; ccteng; change <stdio.h> to "stdio.h"
 *      3/27/91  kason   change "DEBUG" to "DBG", "CLIPDBG" to "DBGclip"
 *                       change "WARN"  to "DBG"
 * --------------------------------------------------------------------
 */

#define     QEMFILL_INC

#include    <stdio.h>
#include    <string.h>
#include    <math.h>

#include    "define.h"
#include    "global.ext"
#include    "graphics.h"
#include    "graphics.ext"

#include    "font.h"
#include    "warning.h"
#include    "font.ext"
#include    "fontqem.ext"
#include    "fntcache.ext"

#include    "stdio.h"

/* ---------------------- Program Convention -------------------------- */

#define FUNCTION
#define DECLARE         {
#define BEGIN
#define END             }

#define GLOBAL
#define PRIVATE         static
#define REG             register

        /* copy structured object */
#define COPY_STRUCT(dst,src, type)      ( *(dst) = *(src) )
            /* OR memcpy ((ubyte*)dst, (ubyte*)src, sizeof(type)) */

extern int bWinTT;        /* if using Windows TT fonts; from ti.c;@WINTT */
extern fix cache_dest;    /* @WIN check if out of cache */
extern fix buildchar;     /* @WIN */

/*
 * ----------------------- DEBUG FACILITIES --------------------------
 *  DBG1:     Make Path Interfaces.
 *  DBG4:     Fill Dispather.
 *  DBG5:     Shape Approximations.
 *  DBG6:     Scan Conversions.
 *  DBG6a:        - more details of edge table management.
 *  DBG6x:        - consistency check about edge table management.
 *  DBG7:     Set Bits.
 *  DBG8:     Set 1 Bit.
 *  DBGclip:    Character Clipping.
 * --------------------------------------------------------------------
 */


/*
 * --------------------------------------------------------------------
 *      MODULE INTERFACES: QEM Make Path Interfaces
 * --------------------------------------------------------------------
 *  EXPORT DATA STRUCTURES:
 *      qemfill_type: to QEM Fill Dispather and QEM Scan Conversions.
 *      path_dest: to QEM Fill Dispather.
 *  IMPORT DATA STRUCTURES:
 *      GSptr->ctm[]: accessed.
 * --------------------------------------------------------------------
 *  EXPORT ROUTINES:
 *  o  __make_path():           called by Font show_a_char().
 *      - construct character path for different type of built-in fonts.
 *      - free all the nodes constructed if ANY_ERROR().
 *  o  USE_EOFILL():            called by QEM make_path().
 *      - guide QEM Fill to employ even-odd fill.
 *  o  USE_NONZEROFILL():       called by QEM make_path().
 *      - guide QEM Fill to employ non-zero winding number fill.
 *  o  is_within_qemrep():      called by setcachedevice().
 *      - check if the character too big (given 4 coord. of charbbox)?
 *      - decide to do quality enhancement or not.
 *  o  __set_cache_device():    called by QEM make_path().
 *      - invoke setcachedevice() to decide
 *              STOP_PATHCONSTRUCT, CONSTRUCT_GS_PATH or CONSTRUCT_QEM_PATH.
 *      - return (STOP_PATHCONSTRUCT, DO_QEM_AS_USUAL or NOT_TO_DO_QEM).
#ifdef KANJI
 *  o  __set_cache_device2():   for KANJI only.
 *      - invoke setcachedevice2() instead of setcachedevice().
 *      - same functional as __set_cache_device().
#endif
 *  o  __current_matrix():      MUST BE invoked after __set_cache_device().
 *      - load current transformation matrix to QEM.
 *  o  __new_path():            called by make_path().
 *      - invoke op_newpath() or qem_newpath() according to path_dest.
 *  o  __moveto():              called by make_path().
 *      - invoke moveto() or qem_moveto() according to path_dest.
 *  o  __lineto():              called by make_path().
 *      - invoke lineto() or qem_lineto() according to path_dest.
 *  o  __curveto():             called by make_path().
 *      - invoke curveto() or qem_curveto() according to path_dest.
 *  o  __close_path():          called by make_path().
 *      - invoke op_closepath() or qem_closepath() according to path_dest.
 *  IMPORT ROUTINES:
 *  o  FONTTYPE_MAKE_PATH():    (macro defined in FONTQEM.EXT)
 *      - invoke different make_path() for different type of built-in fonts.
 *  o  CHK_DO_QEM():            (macro defined in FONTQEM.EXT)
 *      - check QEM limitations for each kind of built-in fonts.
 *  o  setcachedevice() or setcachedevice2():
 *      - in Font show_a_char(), return as described above.
 *  o  qem_newpath, qem_moveto, qem_lineto, qem_curveto, qem_closepath:
 *      - construct QEM path (QEM path construction support).
 *  o  op_newpath, moveto, lineto, curveto, op_closepath:
 *      - construct GS path.
#ifdef KANJI
 *  o  get_CD2_extra():     (@10+)
 *      - get extra items of setcachedevice2 than setcachedevice.
#endif
 * --------------------------------------------------------------------
 *  Notes:
 *  1. Destination of Path Construction (GS or QEM path)
 *      - conditions to construct GS path:
 *          o  op_charpath().
 *          o  QEM Fill cannot support the desired PaintType (e.g. stroke).
 *          o  Character size is so big that QEM path cannot fit to
 *                          represent all the nodes on the character shape.
 *  2. To Do Quality Enhancement? (to do qem or not)
 *      - character is so big to go out of QEM internal representations,
 *          e.g. pixels allocated of 64K for a zone for Bitstream Fontware.
 * --------------------------------------------------------------------
 */

    /* QEM fill to use EVEN_ODD or NON_ZERO winding number, @3+ */
    PRIVATE fix     near    qemfill_type;   /* EVEN_ODD or NON_ZERO */

    /* destination of path construction (GS or QEM path) */
            fix     near    path_dest;          /* @20 */

#ifdef LINT_ARGS
    GLOBAL
//      bool    __make_path      (ufix, ubyte FAR []);   /* @12= @WIN*/
        bool    __make_path      (ufix, union char_desc_s FAR *);   /* @12= @WIN*/
                                    /* to be consistent with make_path() @WIN*/
        void    USE_EOFILL       (void);
        void    USE_NONZEROFILL  (void);
        bool    is_within_qemrep (ufix, long32, long32, long32, long32,
                                                            long32, long32);
        fix     __set_cache_device (fix, fix, fix, fix, fix, fix);
    /* add by Falco for if FontBBox = 0, 05/02/91 */
        fix     __set_char_width (fix, fix);
#ifdef KANJI
        fix     __set_cache_device2(fix, fix, fix, fix, fix, fix,
                                                    fix, fix, fix, fix);
#endif
        void    __current_matrix (real32 FAR []);        /* @19= @WIN*/
        void    __new_path  (void);
        void    __close_path(void);
        void    __moveto    (long32, long32);
        void    __lineto    (long32, long32);
        void    __curveto   (long32, long32, long32, long32, long32, long32);
#else
    GLOBAL
        bool    __make_path      ();
        void    USE_EOFILL       ();
        void    USE_NONZEROFILL  ();
        bool    is_within_qemrep   ();
        fix     __set_cache_device ();
/* add by Falco for FontBBox = 0, 05/02/91 */
        fix     __set_char_width ();
#ifdef KANJI
        fix     __set_cache_device2();
#endif
        void    __current_matrix   ();
        void    __new_path  ();
        void    __close_path();
        void    __moveto    ();
        void    __lineto    ();
        void    __curveto   ();
#endif

/*
 * --------------------------------------------------------------------
 *      MODULE INTERFACES: QEM Path Constructions
 *                                      09/02/88 created by S.C.Chen
 * --------------------------------------------------------------------
 *  EXPORT DATA STRUCTURES:
 *      qem_path[], curr_qem_subpath: to QEM Shape Approximations.
 *  IMPORT DATA STRUCTURES:
 *      node_table[]: modified.
 * --------------------------------------------------------------------
 *  EXPORT ROUTINES:
 *  o  qem_newpath():
 *      - initialize or free all qem paths.
 *  o  qem_moveto():
 *  o  qem_lineto():
 *  o  qem_curveto():
 *      - create a MOVETO or a LINETO, 3 CURVETO node(s).
 *  o  qem_closepath():
 *      - create a CLOSEPATH node.
 *  IMPORT ROUTINES:
 *  o  free_node():
 *      - free all the nodes on a subpath list.
 *  o  get_node():
 *      - allocate a free node.
 * --------------------------------------------------------------------
 *  This module supports Font Machinery to construct path of characters
 *      in its internal format (sfix_t) in order to achieve better
 *      performance, by incorperation with a proprietary filler.
 *
 *  NOTE:
 *      1. All the coordinates used are of device coord. system.
 *      2. qem_moveto is the only way to generate a new subpath (not
 *              qem_closepath); if qem_moveto does not follow a qem_closepath
 *              it will cause a wrong path constructed.
 * --------------------------------------------------------------------
 */

    /* qem_path table */
//DJC #   define  MAXQEMPATH      30
#define MAXQEMPATH 60   //DJC fix from SC for type 1 download with too many
                        //    subpaths UPD037


    /* PRIVATE struct vx_lst   near qem_path[MAXQEMPATH]; @NODE */
    PRIVATE struct list_hdr   near qem_path[MAXQEMPATH];

    /* index of current subpath */
    PRIVATE fix             near curr_qem_subpath = -1;

#ifdef LINT_ARGS
    GLOBAL  void    qem_newpath  (void);                /* @21 */
    GLOBAL  void    qem_moveto   (sfix_t, sfix_t);      /* @20 */
    GLOBAL  void    qem_lineto   (sfix_t, sfix_t);      /* @20 */
    GLOBAL  void    qem_curveto  (sfix_t, sfix_t, sfix_t, sfix_t,   /* @20 */
                                                        sfix_t, sfix_t);
    GLOBAL  void    qem_closepath(void);                /* @21 */
#else
    GLOBAL  void    qem_newpath  ();
    GLOBAL  void    qem_moveto   ();
    GLOBAL  void    qem_lineto   ();
    GLOBAL  void    qem_curveto  ();
    GLOBAL  void    qem_closepath();
#endif

/*
 * --------------------------------------------------------------------
 *      MODULE INTERFACES: QEM Curve Approximations
 *                                          09/02/88 created by S.C.Chen
 * --------------------------------------------------------------------
 *  IMPORT DATA STRUCTURES:
 *      node_table[]: modified.
 * --------------------------------------------------------------------
 *  EXPORT ROUTINES:
 *  o  qem_bezier_to_line:      called by qem_shape_approx().   @18-
 *      - converts a bezier curve to a list of nodes that contains the
 *              approximated straight lines.
 * --------------------------------------------------------------------
 *  This module supports Font Machinery to get approximated lines for
 *      a given bezier curve, again in its internal format (sfix_t) to
 *      achieve better performance.
 * --------------------------------------------------------------------
 */

/*
 * --------------------------------------------------------------------
 *      MODULE INTERFACES: QEM Fill Dispatcher
 * --------------------------------------------------------------------
 *  EXPORT DATA STRUCTURES:
 *      bmap_extnt: set by QEM Fill's vect2edge and to QEM Bitmap Render.
 *  IMPORT DATA STRUCTURES:
 *      path_dest, qemfill_type: from QEM Make Path Interfaces.
 *      cache_info, GSptr->clip_path: accessed.
 * --------------------------------------------------------------------
 *  EXPORT ROUTINES:
 *  o  __fill_shape():      called by Font show_a_char().
 *      - do painting to cache or page for all kinds of built-in base fonts.
 *      - release all the nodes after painting.
 *  o  chk_bmap_extnt():    called by QEM Fill.
 *      - renew bmap_extnt.
 *      - check if no need to fill (no edges, no extents or outside of clip).
 *  IMPORT ROUTINES:
 *  o  fill_shape():
 *      - paint if not qem path constructued.
 *  o  FONTTYPE_FILL_SHAPE():   (macro defined in FONTQEM.EXT)
 *      - invoke different fill_shape() for different type of built-in fonts.
 *  o  __new_path():
 *      - release all the nodes constructed.
 * --------------------------------------------------------------------
 */

    /* bitmap extents */
    GLOBAL struct char_extent near  bmap_extnt;

#ifdef LINT_ARGS
    GLOBAL  void        __fill_shape   (ufix, ufix);
    GLOBAL  bool        chk_bmap_extnt (ufix);  /* @16= */
#else
    GLOBAL  void        __fill_shape   ();
    GLOBAL  bool        chk_bmap_extnt ();
#endif

/*
 * --------------------------------------------------------------------
 *      MODULE INTERFACES: QEM Shape Approximations
 * --------------------------------------------------------------------
 *  IMPORT DATA STRUCTURES:
 *      qem_path[], curr_qem_subpath (by QEM Path Constructions): accessed.
 *      node_table[]: accessed.
 * --------------------------------------------------------------------
 *  EXPORT ROUTINES:
 *  o  qem_shape_approx():
 *      - traverse all the nodes, flattern all the curves, and invoke
 *              (*vect2edge)() to construct edges for approximated vectors.
 *      - NOTE: (@9+)
 *          Each subpath must be led by a MOVETO node, or it crashes.
 *              (especially, in case of a path nothing but CLOSEPATH).
 *  IMPORT ROUTINES:
 *  o  restart_qem_edge():      @16+
 *      - restart qem support of edge constructions.
 *  o  bezier_to_line_sfx():    @18=
 *      - straight line approximation for bezier curves.
 *  o  (*vect2edge)():  passed by QEM Fill.
 *      - construct edges and set up "bmap_extnt".
 * --------------------------------------------------------------------
 */

#ifdef LINT_ARGS
 // DJC eliminate because this is defined in fontqem.ext
 //   GLOBAL  void    qem_shape_approx ( lfix_t, ufix,
 //                                      void (*)(sfix_t, sfix_t, sfix_t, sfix_t,
 //                                             fix, fix, fix, fix, ufix) );
#else
 //   GLOBAL  void    qem_shape_approx ();
#endif

/*
 * -------------------------------------------------------------------
 *      MODULE INTERFACES: QEM Scan Conversions
 * -------------------------------------------------------------------
 *  IMPORT DATA STRUCTURES:
 *      edge_table[] (setup by QEM Fill's vect2edge): modified.
 *      qemfill_type (by QEM Make Path Interfaces): accessed.
 * --------------------------------------------------------------------
 *  EXPORT ROUTINES:
 *  o  qem_scan_conv():     called by QEM Fill.
 *      - for each scanline do:
 *         . update 'actvlast' if no more active edges (for a new set).
 *         . advance 'actvlast' if any new edge comes in.
 *         . sort active edges if 'actvlast' updated or active edges cross.
 *         . invoke (*do_pairs)() to stroke runs of intercept pairs.
 *         . update active edges for next scanline.
 *        enddo.
 *  IMPORT ROUTINES:
 *  o  (*do_pairs)():       passed by QEM Fill.
 *      - stroke runs at a scanline with a set of active edges.
 *  o  restart_qem_bit():
 *      - initialize QEM bitmap render module each time to scan convert.
 *      - allocate scanline_table/pixel_table (@15+).
 *  o  flush_qem_bit():
 *      - flush buffered scanlines/pixels at the end of scan conversions.
 *  o  free_edge():
 *      - free all the edges which are no more effective.
 * --------------------------------------------------------------------
 */

#ifdef LINT_ARGS
    GLOBAL  bool    qem_scan_conv (ufix, fix, fix,
                                  bool (*) (fix, ufix, fix, fix, fix));
#else
    GLOBAL  bool    qem_scan_conv ();
#endif

/*
 * --------------------------------------------------------------------
 *      MODULE INTERFACES: QEM Bitmap Render
 * --------------------------------------------------------------------
 *  IMPORT DATA STRUCTURES:
 *      scanline_table[] (shared exclusively with pixel_table[]): modified.
 *          (@15=: dynamically allocate scanline_table[]).
 *      GSptr->clip_path, bmap_extnt, cache_info, and <cxx,cyy>: accessed.
 *  EXPORT ROUTINES:
 *  o  init_qem_bit():      called by QEM Fill.
 *      - initialize bitmap render module.
 *  o  restart_qem_bit():   called by qem_scan_conv().
 *      - reset count or index about scanline/pixel table.
 *  o  flush_qem_bit():     called by qem_scan_conv().
 *      - flush buffered scanlines/pixels to graphics primitives.
 *  o  qem_setbits():       called by QEM Fill.
 *      - render a horizontal black run.
 *  o  qem_set1bit():       called by QEM Fill.
 *      - render a discrete pixel.
 *  IMPORT ROUTINES:
 *  o  fill_shape():
 *      - apply clipping.
 *  o  low-layer graphics primitives:
 *      - fill_scan_cache, fill_scan_page (and init_char_cache).
 *      - fill_pixel_cache, fill_pixel_page.
 * --------------------------------------------------------------------
 */

    /* IMPORTED from FONTCHAR.C */
    extern real32       near cxx,   /* floating coord. of current point */
                        near cyy;   /*      required if need to clip.   */

#ifdef LINT_ARGS
    GLOBAL  void        init_qem_bit    (ufix);
    PRIVATE void        restart_qem_bit (void);
    PRIVATE void        flush_qem_bit   (ufix);
    GLOBAL  void        qem_setbits     (fix, fix, fix);
    GLOBAL  void        qem_set1bit     (fix, fix);
#else
    GLOBAL  void        init_qem_bit    ();
    PRIVATE void        restart_qem_bit ();
    PRIVATE void        flush_qem_bit   ();
    GLOBAL  void        qem_setbits     ();
    GLOBAL  void        qem_set1bit     ();
#endif

/*
 * --------------------------------------------------------------------
 *      MODULE INTERFACES: QEM Initialization
 * --------------------------------------------------------------------
 *  IMPORT/EXPORT DATA STRUCTURES:
 *      none.
 *  EXPORT ROUTINES:
 *  o  __qem_init():        called by FONT INIT.
 *      - initialize all QEMs.
 *  o  __qem_restart():     called by FONT show_a_char.
 *      - reset QEM for each character.
 *  IMPORT ROUTINES:
 *  o  FONTTYPE_QEM_INIT():     (macro defined in FONTQEM.EXT)
 *      - invoke all QEM init routines.
 *  o  FONTTYPE_QEM_RESTART():  (macro defined in FONTQEM.EXT)
 *      - invoke different QEM restart routines for different built-in fonts.
 * --------------------------------------------------------------------
 */


/*
 * --------------------------------------------------------------------
 *      MODULE BODY: QEM Make Path Interfaces
 * --------------------------------------------------------------------
 *  PRIVATE DATA STRUCTURES:
 *      do_qem_b: to do quality enhancement or not?.
 *      subpath_open_count: count of subpaths not closed yet.
 *      makepath_ftype: font type of current make_path (@10+).
 *  PRIVATE ROUTINES:
 *      none.
 * --------------------------------------------------------------------
 */

    /* to do quality enhancement or not? */
    PRIVATE fix     near    do_qem_b;

    /* count of subpath not closed yet (@5+) */
    PRIVATE fix     near    subpath_open_count;

    /* FontType of the built-in font to make path (@10+) */
    PRIVATE ufix    near    makepath_ftype;


/* ........................ __make_path .............................. */

GLOBAL FUNCTION bool        __make_path (ftype, chardesc)
    ufix        ftype;          /* font type */
//  ubyte       FAR chardesc[];     /* character shape descriptions @WIN*/
    union char_desc_s FAR *chardesc; /* to be consistent with make_path() @WIN*/

  DECLARE
        bool    ret_code;       /* TRUE: succeed, FALSE: fail */
  BEGIN

#ifdef DBG1
    printf ("$$__make_path\n");
#endif

    /* initialize all the private/export data of this module */
    USE_EOFILL();
    path_dest = CONSTRUCT_QEM_PATH;
    do_qem_b  = FALSE;
    subpath_open_count = 0;
    makepath_ftype = ftype;     /* @10+ */

    /* @14-: not to save/restore all the private/export data here */

    /* invoke different make path for different type of built-in fonts */
    FONTTYPE_MAKE_PATH (makepath_ftype, chardesc, &ret_code);   /* @12= */

    /* free all the nodes constructed if ANY_ERROR() */
    if (ANY_ERROR())
        {
#     ifdef DBG1
        printf ("$$__make_path: error = %d\n", ANY_ERROR());
#     endif
        __new_path ();
        ret_code = FALSE;   /* have to restore all data if error */
        }

#ifdef DBG1
    printf ("$$__make_path ok? %s\n", ret_code? "yes" : "no");
#endif
    return (ret_code);
  END

/* ........................ USE_EOFILL ............................... */

GLOBAL FUNCTION void        USE_EOFILL ()

  DECLARE
  BEGIN
    qemfill_type = EVEN_ODD;
  END

/* ........................ USE_NONZEROFILL .......................... */

GLOBAL FUNCTION void        USE_NONZEROFILL ()

  DECLARE
  BEGIN
    qemfill_type = NON_ZERO;
  END

/* ........................ is_within_qemrep ......................... */

GLOBAL FUNCTION bool        is_within_qemrep (ftype, lox, loy, hix, hiy,
                                                x_origin, y_origin)
    ufix            ftype;
    long32          lox, loy, hix, hiy;     /* relative to char origin */
    long32          x_origin, y_origin;

  DECLARE
        real32          x_size, y_size;
        real32          lox_r, loy_r, hix_r, hiy_r;
  BEGIN

/*POFF: Danny, 10/18/90 **
    if (ftype == TypeSFNT)    return(TRUE);
**POFF: End */

    x_size = L2F(hix) - L2F(lox);
    y_size = L2F(hiy) - L2F(loy);

    lox_r = L2F(lox) + L2F(x_origin);
    loy_r = L2F(loy) + L2F(y_origin);
    hix_r = L2F(hix) + L2F(x_origin);
    hiy_r = L2F(hiy) + L2F(y_origin);

#ifdef DBG1
    printf ("$$is_within_qemrep: ftype(%d)\n", ftype);
    printf ("$$  size (%f, %f)  lo (%f, %f), hi (%f %f)",
                      x_size, y_size, lox_r, loy_r, hix_r, hiy_r);
#endif

    /* check to do qem or not? */
    CHK_DO_QEM (ftype, x_size, y_size, lox_r, loy_r, hix_r, hiy_r, &do_qem_b);
#ifdef DBG1
    printf ("  - %s do QEM\n", do_qem_b? "to" : "NOT to");
#endif

    if (bWinTT) {
        /* @WIN divide by 4 for GDI no function call to
           get parcial font charecter */
        if (cache_dest == F_TO_PAGE || ((cache_dest == F_TO_CACHE) &&
        (buildchar))) return (FALSE);
    }
    else
    /* check for qem fill */
    //DJC
    //DJC printf("\nMAX QEM = %d", MAX_QEMFILL_SIZE); // DJC take out

    if (x_size>=(real32)MAX_QEMFILL_SIZE || y_size>=(real32)MAX_QEMFILL_SIZE)
        return (FALSE);     /* out of qem fill acceptable range */

    /* check for qem path */
    if (  (lox_r <= (real32)MIN_QEMPATH_REP) ||
          (loy_r <= (real32)MIN_QEMPATH_REP) ||
          (hix_r >= (real32)MAX_QEMPATH_REP) ||
          (hiy_r >= (real32)MAX_QEMPATH_REP)  )
        return (FALSE);

#ifdef DBG1
    printf ("$$  Yes, within qem path rep\n");
#endif
    return (TRUE);      /* all conditions are satisfied */
  END

/* ........................ __set_cache_device ....................... */

GLOBAL FUNCTION fix         __set_cache_device (sw, sh, lox, loy, hix, hiy)
    fix             sw, sh, lox, loy, hix, hiy;

  DECLARE
    real32          sw_f, sh_f, lox_f, loy_f, hix_f, hiy_f;
  BEGIN

#ifdef KANJI    /* transfer to __set_cache_device2 if FontType!=1, @10+ */
    if (makepath_ftype != 3)
        {
        fix     w1x, w1y, v01x, v01y;

        get_CD2_extra (makepath_ftype, sw, sh, lox, loy, hix, hiy, &w1x, &w1y,
                       &v01x, &v01y);
        return (__set_cache_device2 (sw, sh, lox, loy, hix, hiy,
                                                w1x, w1y, v01x, v01y));
        }
#else
#ifdef DBG
    if (makepath_ftype != 3)
        {
        warning (QEMSUPP, 0x10, "FontType in setcachedevice");
        return (STOP_PATHCONSTRUCT);
        }
#endif
#endif

    sw_f  = (real32)sw;
    sh_f  = (real32)sh;
    lox_f = (real32)lox;
    loy_f = (real32)loy;
    hix_f = (real32)hix;
    hiy_f = (real32)hiy;

    switch ( setcachedevice (F2L(sw_f), F2L(sh_f),
                            F2L(lox_f), F2L(loy_f), F2L(hix_f), F2L(hiy_f)) )
        {
        case CONSTRUCT_QEM_PATH:    /* op_show and qem rep. ok */
#         ifdef DBG1
            printf ("$$__setcachedevice: construct QEM path\n");
#         endif
            path_dest = CONSTRUCT_QEM_PATH;
            return (do_qem_b);
        case CONSTRUCT_GS_PATH:     /* op_charpath or to call strok_shape */
#         ifdef DBG1
            printf ("$$__setcachedevice: construct GS path\n");
#         endif
            path_dest = CONSTRUCT_GS_PATH;
            return (do_qem_b);
        default:    /* i.e. case STOP_PATHCONSTRUCT: */
#         ifdef DBG1
            printf ("$$__setcachedevice: stop path construction\n");
#         endif
            return (STOP_PATHCONSTRUCT);
        }
  END

#ifdef KANJI

/* add by Falco for FontBBox = 0. 05/02/91 */
/* ........................ __set_char_width ......................... */

GLOBAL FUNCTION fix         __set_char_width (sw, sh)
    fix             sw, sh;

  DECLARE
    real32          sw_f, sh_f;
  BEGIN

    sw_f  = (real32)sw;
    sh_f  = (real32)sh;

    setcharwidth (F2L(sw_f), F2L(sh_f) );
    return 0;   //@WIN
  END
/* add end */

/* ........................ __set_cache_device2 ...................... */

GLOBAL FUNCTION fix         __set_cache_device2 (w0x, w0y,
                                                    lox, loy, hix, hiy,
                                                    w1x, w1y, v01x, v01y)
    fix             w0x, w0y, lox, loy, hix, hiy;
    fix             w1x, w1y, v01x, v01y;

  DECLARE
        real32      w0x_f, w0y_f, lox_f, loy_f, hix_f, hiy_f;
        real32      w1x_f, w1y_f, v01x_f, v01y_f;
        fix         t_qemfill_type;
        fix         t_subpath_open_count;
        ufix        t_makepath_ftype;
        fix         retval;
  BEGIN

#ifdef DBG     /* @10+, @14= */
    if ((makepath_ftype == 3) || !IS_BUILTIN_BASE(makepath_ftype))
        {
        warning (QEMSUPP, 0x11, "FontType in setcachedevice2");
        return (STOP_PATHCONSTRUCT);
        }
#endif

    w0x_f = (real32)w0x;
    w0y_f = (real32)w0y;
    lox_f = (real32)lox;
    loy_f = (real32)loy;
    hix_f = (real32)hix;
    hiy_f = (real32)hiy;
    w1x_f = (real32)w1x;
    w1y_f = (real32)w1y;
    v01x_f = (real32)v01x;
    v01y_f = (real32)v01y;

    /* save all the private/export data @14+ */
    t_qemfill_type       = qemfill_type;
    t_subpath_open_count = subpath_open_count;
    t_makepath_ftype     = makepath_ftype;

        /* NOTE: not to save/restore "do_qem_b" and "path_dest" @14+ */

    retval = setcachedevice2 (F2L(w0x_f), F2L(w0y_f),
                        F2L(lox_f), F2L(loy_f), F2L(hix_f), F2L(hiy_f),
                        F2L(w1x_f), F2L(w1y_f), F2L(v01x_f), F2L(v01y_f));

    /* restore all the private/export data @14+ */
    qemfill_type       = t_qemfill_type;
    subpath_open_count = t_subpath_open_count;
    makepath_ftype     = t_makepath_ftype;

#ifdef DBG1
    printf ("$$__setcachedevice2: ");
#endif

    switch (retval)
        {
        case CONSTRUCT_QEM_PATH:    /* op_show and qem rep. ok */
#         ifdef DBG1
            printf ("construct QEM path\n");
#         endif
            path_dest = CONSTRUCT_QEM_PATH;
            return (do_qem_b);

        case CONSTRUCT_GS_PATH:     /* op_charpath or to call strok_shape */
#         ifdef DBG1
            printf ("construct GS path\n");
#         endif
            path_dest = CONSTRUCT_GS_PATH;
            return (do_qem_b);

        default:    /* i.e. case STOP_PATHCONSTRUCT: */
#         ifdef DBG1
            printf ("stop path construction\n");
#         endif
            return (STOP_PATHCONSTRUCT);
        }
  END

#endif  /* KANJI */

/* ........................ __current_matrix ......................... */

GLOBAL FUNCTION void        __current_matrix (matrix)
    real32      FAR matrix[];   /* @19= @WIN*/

  DECLARE
  BEGIN
#ifdef DBG1
    printf ("$$__current_matrix\n");
#endif
    lmemcpy ((byte FAR *)matrix, (byte FAR *)GSptr->ctm, 6*sizeof(real32));    /* @19= @WIN*/
  END

/* ........................ __new_path ............................... */

GLOBAL FUNCTION void        __new_path ()

  DECLARE
  BEGIN
#ifdef DBG1
    printf ("__new_path $$ open subpath = %d\n", subpath_open_count);
#endif
    if (path_dest == CONSTRUCT_QEM_PATH)
        qem_newpath();
    else
        op_newpath();
    subpath_open_count = 0;
  END

/* ........................ __close_path ............................. */

GLOBAL FUNCTION void        __close_path ()

  DECLARE
  BEGIN
#ifdef DBG1
    printf ("__close_path $$ open subpath = %d\n", subpath_open_count);
#endif
    if (subpath_open_count == 0)  return;   /* ignore the useless close_path */
    subpath_open_count -- ;

    if (path_dest == CONSTRUCT_QEM_PATH)
        qem_closepath();
    else
        op_closepath();
  END

/* ........................ __moveto ................................. */

GLOBAL FUNCTION void        __moveto (x, y)
    long32                  x, y;

  DECLARE
  BEGIN
#ifdef DBG1
    printf ("  %f %f __moveto\n", L2F(x), L2F(y));
#endif
    if (subpath_open_count != 0)    /* previous subpath not closed? */
        {
        __close_path();             /* close the previous subpath */
        /* @6=: subpath_open_count --; ==> done by __close_path() */
        }
    subpath_open_count = 1;         /* always at most 1 open subpath */

    if (path_dest == CONSTRUCT_QEM_PATH)
        qem_moveto (F2SFX(L2F(x)), F2SFX(L2F(y)));
    else
        moveto (x, y);
  END

/* ........................ __lineto ................................. */

GLOBAL FUNCTION void        __lineto (x, y)
    long32                  x, y;

  DECLARE
  BEGIN
#ifdef DBG
    if (subpath_open_count == 0)
        {
        warning (QEMSUPP, 0x12, (byte FAR *)NULL);   /* no prefixed moveto @WIN*/
        return;
        }
#endif
#ifdef DBG1
    printf ("  %f %f __lineto\n", L2F(x), L2F(y));
#endif
    if (path_dest == CONSTRUCT_QEM_PATH)
        qem_lineto (F2SFX(L2F(x)), F2SFX(L2F(y)));
    else
        lineto (x, y);
  END

/* ........................ __curveto ................................ */

GLOBAL FUNCTION void        __curveto (x0, y0, x1, y1, x2, y2)
    long32                  x0, y0, x1, y1, x2, y2;

  DECLARE
  BEGIN
#ifdef DBG
    if (subpath_open_count == 0)
        {
        warning (QEMSUPP, 0x13, (byte FAR *)NULL);   /* no prefixed moveto @WIN*/
        return;
        }
#endif
#ifdef DBG1
    printf ("  %f %f %f %f %f %f __curveto\n",
                    L2F(x0), L2F(y0), L2F(x1), L2F(y1), L2F(x2), L2F(y2));
#endif
    if (path_dest == CONSTRUCT_QEM_PATH)
        qem_curveto (F2SFX(L2F(x0)), F2SFX(L2F(y0)),
                     F2SFX(L2F(x1)), F2SFX(L2F(y1)),
                     F2SFX(L2F(x2)), F2SFX(L2F(y2)));
    else
        curveto (x0, y0, x1, y1, x2, y2);
  END

/*
 * --------------------------------------------------------------------
 *      MODULE BODY: QEM Path Constructions
 *                                          09/02/88 created by S.C.Chen
 * --------------------------------------------------------------------
 *  PRIVATE DATA STRUCTURES:
 *      none.
 *  PRIVATE ROUTINES:
 *      none.
 * --------------------------------------------------------------------
 */

/* ........................ qem_newpath ............................... */

GLOBAL  FUNCTION void       qem_newpath()

  DECLARE
    REG fix     isp;
  BEGIN
        for (isp=0; isp<=curr_qem_subpath; isp++)
            free_node (qem_path[isp].head);

        /* initialize qem_path table */
        curr_qem_subpath = -1;
  END

/* ........................ qem_moveto ................................ */

GLOBAL  FUNCTION void       qem_moveto (x, y)
    sfix_t                  x, y;

  DECLARE
    REG struct nd_hdr       FAR *vtx;   /*@WIN*/
        VX_IDX              ivtx; /* index to node_table for vertex */
  BEGIN
    /* create a new subpath */
    curr_qem_subpath++;
#ifdef DBG
    if (curr_qem_subpath >= MAXQEMPATH)
        warning (QEMSUPP, 0x20, "QEM Path Table too small");
#endif

    //DJC fix from history.log UPD037
    if (curr_qem_subpath >= MAXQEMPATH)         /* @WIN */
        {
        ERROR(LIMITCHECK);
        return;
        }
    /*
     * Create a MOVETO node
     */
    /* Allocate a node */
    if ((ivtx = get_node()) == NULLP)
        {
        ERROR(LIMITCHECK);
        return;
        }
    vtx = &node_table[ivtx];

    /* Set up a MOVETO node */
    vtx->VXSFX_TYPE = MOVETO;
    vtx->VXSFX_X    = x;
    vtx->VXSFX_Y    = y;
    vtx->next       = NULLP;

    /* Append this node to current_subpath */
    qem_path[curr_qem_subpath].head = qem_path[curr_qem_subpath].tail = ivtx;
  END

/* ........................ qem_lineto ................................ */

GLOBAL  FUNCTION void       qem_lineto (x, y)
    sfix_t                  x, y;

  DECLARE
    REG struct nd_hdr       FAR *vtx; /*@WIN*/
    REG VX_IDX              ivtx; /* index to node_table for vertex */
  BEGIN
    /*
     * Create a LINETO node
     */
    /* Allocate a node */
    if ((ivtx = get_node()) == NULLP)
        {
        ERROR(LIMITCHECK);
        return;
        }
    vtx = &node_table[ivtx];

    /* Set up a LINETO node */
    vtx->VXSFX_TYPE = LINETO;
    vtx->VXSFX_X    = x;
    vtx->VXSFX_Y    = y;
    vtx->next       = NULLP;

    /* Append this node to current_subpath */
    node_table[ qem_path[curr_qem_subpath].tail ].next = ivtx;
    qem_path[curr_qem_subpath].tail = ivtx;
  END

/* ........................ qem_curveto ............................... */

GLOBAL  FUNCTION void       qem_curveto (x0, y0, x1, y1, x2, y2)
    sfix_t                  x0, y0, x1, y1, x2, y2;

  DECLARE
    REG struct nd_hdr       FAR *vtx; /*@WIN*/
    REG VX_IDX              ivtx; /* index to node_table for vertex */
        struct coord_i      cp[3];
        fix                 ii;
  BEGIN
    cp[0].x = x0;
    cp[0].y = y0;
    cp[1].x = x1;
    cp[1].y = y1;
    cp[2].x = x2;
    cp[2].y = y2;

    /*
     * Create 3 CURVETO nodes
     */
    for (ii=0; ii<3; ii++)
        {
        /* Allocate a node */
        if ((ivtx = get_node()) == NULLP)
            {
            ERROR(LIMITCHECK);
            return;
            }
        vtx = &node_table[ivtx];

        /* Set up a CURVETO node */
        vtx->VXSFX_TYPE = CURVETO;
        vtx->VXSFX_X    = cp[ii].x;
        vtx->VXSFX_Y    = cp[ii].y;
        vtx->next       = NULLP;

        /* Append this node to current_subpath */
        node_table[ qem_path[curr_qem_subpath].tail ].next = ivtx;
        qem_path[curr_qem_subpath].tail = ivtx;
        }
  END

/* ........................ qem_closepath ............................. */

GLOBAL  FUNCTION void       qem_closepath ()

  DECLARE
    REG struct nd_hdr       FAR *vtx; /*@WIN*/
    REG VX_IDX              ivtx; /* index to node_table for vertex */
  BEGIN
    /* check if only of closepath and of no any moveto */
    if (curr_qem_subpath == -1)  return;

    /*
     * Create a CLOSEPATH node
     */
    /* Allocate a node */
    if ((ivtx = get_node()) == NULLP)
        {
        ERROR(LIMITCHECK);
        return;
        }
    vtx = &node_table[ivtx];

    /* Set up a CLOSEPATH node */
    vtx->VXSFX_TYPE = CLOSEPATH;
    vtx->next       = NULLP;

    /* Append this node to current_subpath */
    node_table[ qem_path[curr_qem_subpath].tail ].next = ivtx;
    qem_path[curr_qem_subpath].tail = ivtx;
  END


/*
 * --------------------------------------------------------------------
 *      MODULE BODY: QEM Curve Approximations       @18-
 *                                          09/02/88 created by S.C.Chen
 * --------------------------------------------------------------------
 *  PRIVATE DATA STRUCTURES:
 *      qem_bezier_depth, qem_bezier_flatness.
 *  PRIVATE ROUTINES:
 *  o  qem_bezier_split:
 *      - recursive routine to split one bezier hull into 2.
 * --------------------------------------------------------------------
 */


/* @16+
 * --------------------------------------------------------------------
 *      MODULE BODY: edge constructions
 * --------------------------------------------------------------------
 */

PRIVATE fix         first_alledge, last_alledge;

PRIVATE FUNCTION void       restart_qem_edge()
  DECLARE
  BEGIN
    first_alledge = 0;
    last_alledge  = PREV_QEMEDGE(first_alledge);
  END

GLOBAL FUNCTION void        add_qem_edge (edge2add_p)
    struct edge_hdr         FAR *edge2add_p;    /* i: edge to be added @WIN*/

  DECLARE
    REG fix                 new_ystart, ii;
        struct edge_hdr     FAR *new_ep;        /* point to available edge @WIN*/
  BEGIN

#ifdef DBG5
    printf ("add_qem_edge\n");
#endif

#ifdef DBG
    if (edge2add_p->QEM_YLINES <= 0)
        {
        warning (QEMSUPP, 0x55, "ineffective edge to be added");
        return;
        }
#endif

    /* get an available edge and copy the edge into it */
    MAKE_NEXT_QEMEDGE(last_alledge);        /* get available one */
    if (OUT_LAST_QEMEDGE(last_alledge, MAXEDGE-1))
        {
        ERROR (LIMITCHECK);
        return;
        }
    LINK_QEMEDGE_PTR(last_alledge);         /* link to avaiable edge */
    new_ep = QEMEDGE_PTR(last_alledge);     /* keep track of it */
    COPY_STRUCT (new_ep, edge2add_p, struct edge_hdr);  /* copy content */

    /*
     * find an appropriate place for 'newedge' in ascending order of YSTART.
     *      (by insertion sort with downward movement of edge_table) ...
     */
    new_ystart = new_ep->QEM_YSTART;
    ii = PREV_QEMEDGE(last_alledge);
    if (!OUT_1ST_QEMEDGE(ii, first_alledge))    /* some been added before? */
        {   /* find the first one who has the smaller 'ystart' */
        for (  ; !OUT_1ST_QEMEDGE(ii, first_alledge); MAKE_PREV_QEMEDGE(ii) )
            {
            if (QEMEDGE_PTR(ii)->QEM_YSTART <= new_ystart) break;
            QEMEDGE_PTR(NEXT_QEMEDGE(ii)) = QEMEDGE_PTR(ii);
            };
        }
    MAKE_NEXT_QEMEDGE(ii);  /* have it next to one with the smaller 'ystart',
                             *      exactly the place to be put into.
                             */

    /* put 'newedge' into the place, indexed by 'ii' */
    QEMEDGE_PTR(ii) = new_ep;

#ifdef DBG5
    printf ("  insert ystart=%d between [%d,%d] (at %d)\n",
        new_ystart,
        (ii==first_alledge)? -1 : QEMEDGE_PTR(PREV_QEMEDGE(ii))->QEM_YSTART,
        (ii==last_alledge)?  -1 : QEMEDGE_PTR(NEXT_QEMEDGE(ii))->QEM_YSTART,
        ii);
#endif
    return;
  END


/*
 * --------------------------------------------------------------------
 *      MODULE BODY: QEM Fill Dispather
 * --------------------------------------------------------------------
 *  PRIVATE DATA STRUCTURES:
 *      none.
 *  PRIVATE ROUTINES:
 *      none.
 * --------------------------------------------------------------------
 */

/* ........................ __fill_shape .............................. */

GLOBAL FUNCTION void        __fill_shape (fonttype, filldest)
    ufix        fonttype;   /* type of built-in fonts */
    ufix        filldest;   /* F_TO_CACHE or F_TO_PAGE */

  DECLARE
  BEGIN

#ifdef DBG4
    printf ("\n__fill_shape, F_TO_%s, %s -- (path: %s)\n",
                filldest==F_TO_PAGE? "PAGE" : "CACHE",
                qemfill_type==EVEN_ODD? "EVEN_ODD" : "NON_ZERO",
                path_dest==CONSTRUCT_GS_PATH? "GS" : "QEM");
    op_countnode ();
    op_countedge ();
#endif

    if (path_dest == CONSTRUCT_GS_PATH)     /* not qem path format? */
        {
#     ifdef DBG4
        printf ("direct transfer to fill_shape() ...\n");
#     endif
        /*  Note:
         *  1. GSptr->device (default_ctm[], default_clip) should be
         *      set up by setcachedevice() and restored after painting.
         *  2. fill_shape() will free all the nodes after painting.
         */
/*POFF: Danny, 10/18/90 */
        { extern fix  rc_CharPath(void);        /* add prototype @WIN*/
            if (fonttype == TypeSFNT)  { op_newpath(); rc_CharPath(); }
        }
/*POFF: End */
        fill_shape (qemfill_type, F_NORMAL, filldest);
        if (filldest == F_TO_CACHE)
            {
            bmap_extnt.ximin = 0;
            bmap_extnt.ximax = cache_info->box_w - 1;
            bmap_extnt.yimin = 0;
            bmap_extnt.yimax = cache_info->box_h - 1;
            }
#     ifdef DBG4
        printf ("after fill_shape ...\n");
        op_countnode ();
        op_countedge ();
#     endif
        return;
        }

    /* initialize 4 extents of bitmap to be rendered */
    bmap_extnt.ximin = bmap_extnt.yimin = (fix16) MAX15;
    bmap_extnt.ximax = bmap_extnt.yimax = (fix16) MIN15;

    /* invoke FontType-Dependent Fill */
    FONTTYPE_FILL_SHAPE (fonttype, filldest);

    /* free all the nodes constructed after filling */
    __new_path ();

#ifdef DBG4
    printf ("__fill_shape returns ...\n");
    op_countnode ();
    op_countedge ();
#endif
  END

/* ........................ chk_bmap_extnt ............................ */

GLOBAL FUNCTION bool        chk_bmap_extnt (filldest)
    ufix    filldest;       /* F_TO_CACHE or F_TO_PAGE */
/*  bool    is_no_edge;     (* no edges constructed at all? @16- */

/* Return:
 *  - FALSE, if not to scan convert (some particular cases).
 *  - TRUE, if ok to scan convert (normal cases).
 */
  DECLARE

  BEGIN
    /* if no edges contructed at all? */
    if (last_alledge == NULLP  &&     /* @26, @16= (is_no_edge) */
        bmap_extnt.yimin >= bmap_extnt.yimax  &&    /* @26+ */
        bmap_extnt.ximin >= bmap_extnt.ximax  )     /* @26+ */
        {        /* to reset bitmap extents to nothing */
        bmap_extnt.yimin = bmap_extnt.yimax = (fix16)0;
        bmap_extnt.ximin = bmap_extnt.ximax = (fix16)0;
#     ifdef DBG4
        printf ("  no edge constructed: bitmap extent reset to 0\n");
#     endif
        return (FALSE);
        }

    /* extend the bitmap extents for 1 pixel tolerance */
    --bmap_extnt.ximin;         ++bmap_extnt.ximax;
    --bmap_extnt.yimin;         ++bmap_extnt.yimax;
#ifdef DBG4
    printf("  bitmap extents:  min=(%d, %d), max=(%d, %d)\n",
                bmap_extnt.ximin, bmap_extnt.yimin,
                bmap_extnt.ximax, bmap_extnt.yimax );
#endif

    if (filldest == F_TO_CACHE)
        {
        /* NO lower than lower bound of cache when fill to cache */
        if (bmap_extnt.ximin < 0)  bmap_extnt.ximin = 0;
        if (bmap_extnt.yimin < 0)  bmap_extnt.yimin = 0;

        /* NO higher than upper bound of cache when fill to cache */
        if (bmap_extnt.ximax >= cache_info->box_w)
            bmap_extnt.ximax = cache_info->box_w - 1;
        if (bmap_extnt.yimax >= cache_info->box_h)
            bmap_extnt.yimax = cache_info->box_h - 1;
        }

    if ( (bmap_extnt.ximax <= bmap_extnt.ximin) ||
         (bmap_extnt.yimax <= bmap_extnt.yimin) )
        return (FALSE);     /* no character extents */

    /* check if totally outside ot clip bbox? (for F_TO_PAGE only) */
    if (filldest == F_TO_PAGE)
        {
#     ifdef DBGclip
        printf("  bitmap extents:  min=(%d, %d), max=(%d, %d)\n",
                    bmap_extnt.ximin, bmap_extnt.yimin,
                    bmap_extnt.ximax, bmap_extnt.yimax );
        printf("  clip path: SingleRectangle? %s\n",
                    (GSptr->clip_path.single_rect)? "yes" : "no");
        printf("    _lx/_ly=(%.2f, %.2f), _ux/_uy=(%.2f, %.2f)\n",
                    SFX2F(GSptr->clip_path.bb_lx),
                    SFX2F(GSptr->clip_path.bb_ly),
                    SFX2F(GSptr->clip_path.bb_ux),
                    SFX2F(GSptr->clip_path.bb_uy));
#     endif
        /* bitmap totally outside of clip path? */
        if ( (bmap_extnt.ximax < SFX2I(GSptr->clip_path.bb_lx)) ||
             (bmap_extnt.ximin > SFX2I(GSptr->clip_path.bb_ux)) ||
             (bmap_extnt.yimax < SFX2I(GSptr->clip_path.bb_ly)) ||
             (bmap_extnt.yimin > SFX2I(GSptr->clip_path.bb_uy)) )
            return (FALSE);    /* totally outside of clip path */
        }

    return (TRUE);
  END


/*
 * --------------------------------------------------------------------
 *      MODULE BODY: QEM Shape Approximations
 * --------------------------------------------------------------------
 *  PRIVATE DATA STRUCTURES:
 *      none.
 *  PRIVATE ROUTINES:
 *      none.
 *  NOTE:   (@9+)
 *  - Each subpath must be led by a MOVETO node, or it crashes.
 *      (especially, in case of a path nothing but CLOSEPATH).
 * --------------------------------------------------------------------
 */

/* .................... qem_shape_approx .............................. */

GLOBAL FUNCTION void    qem_shape_approx (flatness_lfx, dimension, vect2edge)
    lfix_t  flatness_lfx;
    ufix    dimension;      /* Y_DIMENSION or X_DIMENSION */
#  ifdef  LINT_ARGS
// DJC replace declaration
//    void    (*vect2edge)(sfix_t,sfix_t,sfix_t,sfix_t,fix,fix,fix,fix,ufix);
   QEM_SHAPE_ARG2 vect2edge;

#  else
    void    (*vect2edge)(); /* (x0sfx,y0sfx,x1sfx,y1sfx,x0i,y0i,x1i,y1i,dmn) */
#  endif

  DECLARE
    REG fix         subpathii;              /* subpath index of qem path */
    REG VX_IDX      vx_ii, vx_jj;
        sfix_t      tx_sfx,  ty_sfx;        /* coord of 1st moveto, @9+ */
        fix         tx_i,    ty_i;
        sfix_t      x1p_sfx=0, y1p_sfx=0,       /* coord.: sfx_t in pixel */
                    x2p_sfx=0, y2p_sfx=0;
        fix         x1p_i,   y1p_i,         /* coord.: rounded integer */
                    x2p_i,   y2p_i;
        sfix_t      x2sfx, y2sfx, x3sfx, y3sfx;     /* for bezier_to_line() */
        /* struct vx_lst   far *vx_listp;           (* vertex list *) @NODE */
        SP_IDX head;                                           /* @NODE */
        struct nd_hdr   far *nd_iip, far *nd_jjp;   /* index to node table */

  BEGIN

#ifdef DBG5
    printf ("qem_shape_approx ...\n");
#endif

    restart_qem_edge ();    /* @16+ */

    /* traverse all the subpaths */
    for ( subpathii=0; subpathii<=curr_qem_subpath; subpathii++ )
        {
#     ifdef DBG5
        printf ("  %d-th path ...\n", ii);
#     endif
        /* traverse each node of the subpath, and flattern curves */
        for (  vx_ii=qem_path[subpathii].head;   vx_ii!=NULLP;
                                                        vx_ii=nd_iip->next )
            {
            nd_iip = &node_table[vx_ii];
            switch (nd_iip->VXSFX_TYPE)
                {
                case PSMOVE:
                case MOVETO:
                    x2p_sfx = nd_iip->VXSFX_X;      x2p_i = SFX2I(x2p_sfx);
                    y2p_sfx = nd_iip->VXSFX_Y;      y2p_i = SFX2I(y2p_sfx);
                    tx_sfx = x2p_sfx;   tx_i = x2p_i;   /* @9+ */
                    ty_sfx = y2p_sfx;   ty_i = y2p_i;
#                 ifdef DBG5
                    if (dimension == Y_DIMENSION)
                        printf("  Move  to   (%.2f, %.2f)\n",
                                    SFX2F(x2p_sfx), SFX2F(y2p_sfx));
#                 endif
                    break;

                case LINETO:
                    x1p_sfx = x2p_sfx;              x1p_i = x2p_i;
                    y1p_sfx = y2p_sfx;              y1p_i = y2p_i;
                    x2p_sfx = nd_iip->VXSFX_X;      x2p_i = SFX2I(x2p_sfx);
                    y2p_sfx = nd_iip->VXSFX_Y;      y2p_i = SFX2I(y2p_sfx);
#                 ifdef DBG5
                    if (dimension == Y_DIMENSION)
                        printf("  Vector to  (%.2f, %.2f)\n",
                                    SFX2F(x2p_sfx), SFX2F(y2p_sfx));
#                 endif
                    /* construct an edge */
                    (*vect2edge) (x1p_sfx, y1p_sfx, x2p_sfx, y2p_sfx,
                                x1p_i, y1p_i, x2p_i, y2p_i, dimension);
                    break;

                case CURVETO :
                    /* previous node */
                    x1p_sfx = x2p_sfx;          y1p_sfx = y2p_sfx;
                    /* current node */
                    x2sfx = nd_iip->VXSFX_X;    y2sfx = nd_iip->VXSFX_Y;
                    /* next node */
                    nd_iip = &node_table[nd_iip->next];
                    x3sfx = nd_iip->VXSFX_X;    y3sfx = nd_iip->VXSFX_Y;
                    /* next of next */
                    nd_iip = &node_table[nd_iip->next];
#                 ifdef DBG5
                    if (dimension == Y_DIMENSION)
                        {
                        printf("  Curve to   (%.2f, %.2f)\n",
                                        SFX2F(x2sfx), SFX2F(y2sfx));
                        printf("             (%.2f, %.2f)\n",
                                        SFX2F(x3sfx), SFX2F(y3sfx));
                        printf("             (%.2f, %.2f)\n",
                            SFX2F(nd_iip->VXSFX_X), SFX2F(nd_iip->VXSFX_Y));
                        }
#                 endif

                    /* vx_listp = bezier_to_line_sfx (flatness_lfx, @18= @NODE*/
                    head = bezier_to_line_sfx (flatness_lfx, /*@18=*/
                                x1p_sfx, y1p_sfx, x2sfx, y2sfx, x3sfx, y3sfx,
                                nd_iip->VXSFX_X, nd_iip->VXSFX_Y);
                    if (ANY_ERROR())    return;

                    /* traverse the flatterned curve */
                    /* for ( vx_jj=vx_listp->head;  vx_jj!=NULLP; @NODE */
                    for ( vx_jj=head;  vx_jj!=NULLP;
                                                        vx_jj=nd_jjp->next )
                        {
                        x1p_sfx = x2p_sfx;              x1p_i = x2p_i;
                        y1p_sfx = y2p_sfx;              y1p_i = y2p_i;
                        nd_jjp  = &node_table[vx_jj];
                        x2p_sfx = nd_jjp->VXSFX_X;      x2p_i = SFX2I(x2p_sfx);
                        y2p_sfx = nd_jjp->VXSFX_Y;      y2p_i = SFX2I(y2p_sfx);
#                     ifdef DBG5
                        printf("    ..Vector to (%.2f, %.2f)\n",
                                        SFX2F(x2p_sfx), SFX2F(y2p_sfx));
#                     endif
                        /* construct an edge */
                        (*vect2edge) (x1p_sfx, y1p_sfx, x2p_sfx, y2p_sfx,
                                    x1p_i, y1p_i, x2p_i, y2p_i, dimension);
                        }
                    /* free_node (vx_listp->head); @NODE */
                    free_node (head);
                    break;

                case CLOSEPATH :
                    /* add a lineto if not back to 1st MOVETO, @9+ */
                    if ((tx_sfx != x2p_sfx) || (ty_sfx != y2p_sfx))
                        (*vect2edge) (x2p_sfx, y2p_sfx, tx_sfx, ty_sfx,
                                        x2p_i, y2p_i, tx_i, ty_i, dimension);

                    break;

                default:    /* unknown node type */
                    warning (QEMSUPP, 0x50, (byte FAR *)NULL); /*@WIN*/
                    break;

                }  /* switch */
            }  /* for all the nodes on a subpath */

        } /* for all the subpaths */
  END

/*
 * -------------------------------------------------------------------
 *      MODULE BODY: QEM Scan Conversions
 * -------------------------------------------------------------------
 *  PRIVATE DATA STRUCTURES:
 *      none.
 *  PRIVATE ROUTINES:
 *  o  qem_sortactv():
 *      - (insertion) sort active edges in ascending order of intercept coord.
 *  o  qem_update_actv():       @16= (qem_update_et())
 *      - decrease DeltaY of all active edges by 1 and free ineffective edges.
 * -------------------------------------------------------------------
 */

#ifdef LINT_ARGS
    PRIVATE void near   qem_sort_actv  (fix, fix);      /* @16= */
    PRIVATE void near   qem_update_actv(fix FAR *, fix FAR *);    /* @16= @WIN*/
#else
    PRIVATE void near   qem_sort_actv  ();      /* @22= */
    PRIVATE void near   qem_update_actv();      /* @22= */
#endif

/* ........................ qem_scan_conv ............................ */

GLOBAL FUNCTION bool        qem_scan_conv (dimen, line1st, linelast, do_pairs)
    ufix    dimen;          /* Y_DIMENSION or X_DIMENSION */
    fix     line1st;        /* first scanline */
    fix     linelast;       /* last  scanline */
#  ifdef LINT_ARGS
    bool    (*do_pairs)(fix, ufix, fix, fix, fix);
#  else
    bool    (*do_pairs)();  /* (scanline,dimn,filltype,actv1st,actvlast) */
#  endif

  DECLARE
    REG fix         yline, ii;
        fix         actv1st, actvlast;  /* first/last active edge */
        bool        new_edge_come;          /* new edge coming? */
        bool        scan_succeed;
        struct edge_hdr    FAR *ii_ep; /*@WIN*/
#     ifdef DBG
        fix         actv_cnt;       /* # of non-horizontal active edges */
#     endif
  BEGIN

#ifdef DBG6
    printf ("qem_scan_conv ...\n");
#endif

    /* check if edge table empty? */
    if (last_alledge == NULLP)   return (TRUE);

    /* restart bitmap render module */
    restart_qem_bit ();

#ifdef DBG
    if (QEMEDGE_PTR(first_alledge)->QEM_YSTART < line1st)
        warning (QEMSUPP, 0x60, "1st scanline inconsistent");
#endif

    /* prologue */
    scan_succeed = TRUE;
    actv1st  = first_alledge;
    actvlast = PREV_QEMEDGE(first_alledge);

    /* for each scanline */
    for (yline=QEMEDGE_PTR(actv1st)->QEM_YSTART; yline<=linelast; yline++)
        {
        /* all edges done? */
        if (OUT_LAST_QEMEDGE(actv1st, last_alledge))  break;

        /* assume no new edges come for this scan line */
        new_edge_come = FALSE;

        /* region of scanlines with no runs at all? */
        if (OUT_LAST_QEMEDGE(actv1st, actvlast))
            {
            /* synchronize 'actvlast' with 'actv1st' for a new start */
            actvlast = actv1st;
            /* skip over scanlines of no runs */
            yline = QEMEDGE_PTR(actv1st)->QEM_YSTART;

#         ifdef DBG
            actv_cnt = 1;
          /*@HORIZ
           *actv_cnt = (QEMEDGE_PTR(actv1st)->QEM_DIR != QEMDIR_HORIZ)?
           *                1 : 0;
           */
#         endif
            }

#     ifdef DBG6
        printf ("  scanline=%d\n", yline);
#     endif

        /*
         * see if any new edge comes for this scanline,
         *      and try to advance 'actvlast' if so.
         */
        for ( ii=NEXT_QEMEDGE(actvlast);
                !OUT_LAST_QEMEDGE(ii,last_alledge);  MAKE_NEXT_QEMEDGE(ii) )
            {
            ii_ep = QEMEDGE_PTR(ii);
            if (ii_ep->QEM_YSTART > yline)  break;  /* out of this scanline? */
            new_edge_come = TRUE;   /* a new edge comes in */
            actvlast = ii;

#         ifdef DBG
            if (ii_ep->QEM_YLINES <= 0)
                warning (QEMSUPP, 0x60, "deltaY of new edge <= 0 ");
            else
                actv_cnt++;
              /*@HORIZ
               *if (ii_ep->QEM_DIR != QEMDIR_HORIZ)   actv_cnt++;
               */
#         endif
            }

        /*
         *  - NOT ONLY in case a new edge comes,
         *    BUT ALSO every time of a non-zero winding number fill.
         *
         *  for two overlapped subjects, there is always a possibility
         *      for an edge of a subobject crossing with another edge
         *      of the other subobject.
         */
        if ((new_edge_come) || (qemfill_type==NON_ZERO))
            qem_sort_actv (actv1st, actvlast);

#     if (defined(DBG6) && defined(DBG))
        printf("    # of intercepts = %d\n", actv_cnt);
#     endif

#     ifdef DBG
        if ((actv_cnt & 0x0001) || (actv_cnt <= 0))
            {
            warning (QEMSUPP, 0x61, "odd num of intercepts");
            scan_succeed = FALSE;
            goto SCANCONV_EXIT;
            }
#     endif

        /* get pairs of runs and render bitmap */
        if ( ! (*do_pairs)(yline, dimen, qemfill_type, actv1st, actvlast))
            {
            scan_succeed = FALSE;
            goto SCANCONV_EXIT;
            }

        /*
         * update all active edges, to be ready for next scan line.
         */
        qem_update_actv (&actv1st, &actvlast);

#     ifdef DBG
        actv_cnt = actvlast - actv1st + 1;
      /*@HORIZ
       *actv_cnt = 0;
       *for (ii=actv1st; !OUT_LAST_QEMEDGE(ii,actvlast); MAKE_NEXT_QEMEDGE(ii))
       *    if (QEMEDGE_PTR(ii)->QEM_DIR != QEMDIR_HORIZ)  actv_cnt++;
       */
#     endif

        } /* for each scanline */

    /* epilogue */
    scan_succeed = TRUE;        /* succeed if for-loop terminates normally */

  SCANCONV_EXIT:

    /* @15m: always to flush_qem_bit rather than only for success */
    flush_qem_bit (dimen);      /* flush buffered scanlines or pixels */

#ifdef  DBG
    /* all edges should have been consumed after conversion */
    if (!OUT_LAST_QEMEDGE(actv1st, last_alledge))
        warning (QEMSUPP, 0x62, "more edges");
#endif

    return (scan_succeed);
  END

/* ........................ qem_sort_actv ............................ */

PRIVATE FUNCTION void near  qem_sort_actv (actv1st, actvlast)
    fix         actv1st, actvlast;  /* i: first/last active edge */
  DECLARE
    REG fix     ii;
        bool    sort_done;
        struct edge_hdr     FAR *next_ep; /*@WIN*/
  BEGIN

#ifdef DBG6a
    printf("  sort active edges ...\n");
#endif

    /* bubble sort to keep in ascending order of x-intercept ... */
    for (  sort_done=FALSE;  !sort_done;   )
        {
        sort_done = TRUE;
        next_ep = QEMEDGE_PTR(actvlast);
        for ( ii=actvlast; !OUT_1ST_QEMEDGE(MAKE_PREV_QEMEDGE(ii), actv1st); )
            {
            /* bubble up the lighter one */
            if (next_ep->QEM_XINTC < QEMEDGE_PTR(ii)->QEM_XINTC)
                {   /* pull the heavier down and lift the lighter up */
                sort_done = FALSE;
                QEMEDGE_PTR(NEXT_QEMEDGE(ii)) = QEMEDGE_PTR(ii);
                QEMEDGE_PTR(ii) = next_ep;      /* still is next_ep */
                }
            else
                next_ep = QEMEDGE_PTR(ii);      /* ready for next cycle */
            } /* for one pass of sorting */
        } /* for till sorting is done */

#ifdef DBG6a
    printf ("     after sorting ...\n");
    for (ii=actv1st; !OUT_LAST_QEMEDGE(ii,actvlast); MAKE_NEXT_QEMEDGE(ii))
        printf ("    %d:  ystart=%d, ylines=%d, xintc=%f, xchange=%f\n",
            ii, QEMEDGE_PTR(ii)->QEM_YSTART, QEMEDGE_PTR(ii)->QEM_YLINES,
            LFX2F(QEMEDGE_PTR(ii)->QEM_XINTC),
            LFX2F(QEMEDGE_PTR(ii)->QEM_XCHANGE) );
#endif

  END

/* ........................ qem_update_actv .......................... */

PRIVATE FUNCTION void near  qem_update_actv (actv1st, actvlast)
    fix         FAR *actv1st, FAR *actvlast;    /* io: first/last active edge @WIN*/

/* Descriptions:
 *  1. update all active edges to be ready for next scanline.
 *  2. discard all ineffective edges after updating.
 *  3. update range mark of active edges.
 */
  DECLARE
        struct edge_hdr FAR *curr_scan_ep; /*@WIN*/
    REG fix     last_updated,   /* which effective edge had been updated */
                curr_scan;      /* which edge is being currently scanned */
        bool    any_ineffective;/* any edge ineffective after updating?  */
  BEGIN

#ifdef DBG6a
    printf ("  qem_update_actv: from %d to %d\n", *actv1st, *actvlast);
#endif

    any_ineffective = FALSE;        /* assume no edges to be ineffective */
    last_updated = *actvlast + 1;   /* for PREV_QEMEDGE() when need to move */

    for ( curr_scan=(*actvlast);
          !OUT_1ST_QEMEDGE(curr_scan,*actv1st);  MAKE_PREV_QEMEDGE(curr_scan) )
        {
        curr_scan_ep = QEMEDGE_PTR(curr_scan);

        /* calculate x-intercept for next scanline */
        curr_scan_ep->QEM_YLINES --;
        curr_scan_ep->QEM_XINTC += curr_scan_ep->QEM_XCHANGE;

        if (curr_scan_ep->QEM_YLINES <= 0)
            {
            /*
             * this edge becomes ineffective after updating, and leaves
             *      it as a free hole for later effective edges.
             */
            any_ineffective = TRUE;
            }
        else
            {
            /*
             * this edge is still effective after updating; thus
             *      calculate x-intercept with next scanline, and then
             *      move it downward if any free hole exists.
             */
            MAKE_PREV_QEMEDGE(last_updated);    /* new place to move to  */
            if (any_ineffective)
                {   /* move it downward if any free hole there */
                QEMEDGE_PTR(last_updated) = QEMEDGE_PTR(curr_scan);
                }
#         ifdef DBG    /* consistency check if no edge ineffective */
            else if (last_updated != curr_scan)
                    warning (QEMSUPP, 0x63, "inconsistent in update_actv");
#         endif
            }
        } /* for all active edges */

    /*
     * update range mark of active edges:
     *      actv1st  = 1st effective active edge.
     *      actvlast = remains the old mark.
     *
     *      note that last_updated == next(actvlast)
     *              if all are ineffective after updating, so
     *          actvlast < actv1st, if all are ineffective
     *          actvlast >= actv1st, otherwise.
     */
    *actv1st = last_updated;

#ifdef DBG6a
    {   REG fix     ii;
    printf ("   after updating: from %d to %d\n", *actv1st, *actvlast);
    for (ii=(*actv1st); !OUT_LAST_QEMEDGE(ii,*actvlast); MAKE_NEXT_QEMEDGE(ii))
        printf ("    %d:  ystart=%d, ylines=%d, xintc=%f, xchange=%f\n",
            ii, QEMEDGE_PTR(ii)->QEM_YSTART, QEMEDGE_PTR(ii)->QEM_YLINES,
            LFX2F(QEMEDGE_PTR(ii)->QEM_XINTC),
            LFX2F(QEMEDGE_PTR(ii)->QEM_XCHANGE) );
    }
#endif

    return;
  END


/*
 * --------------------------------------------------------------------
 *      MODULE BODY: QEM Bitmap Render
 * --------------------------------------------------------------------
 *  PRIVATE DATA STRUCTURES:
 *      qemfill_dest: (F_TO_CACHE or F_TO_PAGE).
 *      bmap_cache, bmap_raswid, bmap_rashgt, lines_per_band.
 *      need2clip, cp_xi, cp_yi, cacheinfo_save, charcache_clip.
 *      curr_scanline, no_lines, scanline_ii, pixel_ii.
 *      scanline_table, pixel_table: @15+.
 *  PRIVATE ROUTINES:
 *  o  qem_lineout:
 *      - flush buffered scanlines (and apply clipping if need to).
 *  o  qem_pixelout:
 *      - flush buffered pixels (and apply clipping if need to).
 * --------------------------------------------------------------------
 */

    PRIVATE ufix    near qemfill_dest;      /* F_TO_CACHE or F_TO_PAGE */
    PRIVATE gmaddr  near bmap_cache;        /* bitmap cache address */
    PRIVATE fix     near bmap_raswid,       /* bitmap raster width  */
                    near bmap_rashgt;       /* bitmap raster height */

    PRIVATE fix     near lines_per_band;    /* for huge bitmap */

    /* for clipping */
    PRIVATE bool        need2clip;      /* need to clip? */
    PRIVATE fix16       cp_xi, cp_yi;   /* integer pixel coord. */
    PRIVATE struct Char_Tbl    FAR *cacheinfo_save; /* used when need to clip @WIN*/
    PRIVATE struct Char_Tbl     charcache_clip; /* used when need to clip */

    /* for qem_setbits() */
    PRIVATE fix     near curr_scanline,     /* current scanline */
                    near no_lines,          /* # of scanlines */
                    near scanline_ii;       /* index to scanline table */

    /* for qem_set1bit() */
#   define N_PIXEL  (MAXSCANLINES)          /* size of pixel table */
    PRIVATE fix     near pixel_ii;          /* index to pixel table */

    /* @15+ */
    PRIVATE SCANLINE    FAR *   scanline_table; /* near=>FAR @WIN */
    PRIVATE SCANLINE    FAR *   pixel_table;    /* near=>FAR @WIN */

#ifdef LINT_ARGS
    PRIVATE void    near qem_lineout (void);
    PRIVATE void    near qem_pixelout(void);
#else
    PRIVATE void    near qem_lineout ();
    PRIVATE void    near qem_pixelout();
#endif


        /* apply clipping to cache */
#define APPLY_CLIP_TO_CACHE()           \
                fill_shape (EVEN_ODD, F_FROM_CACHE, F_TO_CLIP)

/* ........................ init_qem_bit .............................. */

GLOBAL FUNCTION void        init_qem_bit (filldest)
    ufix    filldest;       /* F_TO_CACHE or F_TO_PAGE */

  DECLARE
        fix32   bmap_size, clipbmap_sz;     /* bitmap size in byte */
  BEGIN
    /* record fill destination */
    qemfill_dest = filldest;

    /* init need2clip, bmap_cache, bmap_raswid, bmap_rashgt, lines_per_band */
    if (qemfill_dest == F_TO_CACHE)
        {
        need2clip = FALSE;
        bmap_cache = cache_info->bitmap;
        bmap_raswid    = cache_info->box_w;
        lines_per_band = cache_info->box_h; /* single band for to cache */
        bmap_rashgt    = cache_info->box_h;
        }
    else        /* F_TO_PAGE */
        {
        /* object clipped? */
        need2clip = (GSptr->clip_path.single_rect) &&
                    ( (bmap_extnt.ximin >= SFX2I(GSptr->clip_path.bb_lx)) &&
                      (bmap_extnt.yimin >= SFX2I(GSptr->clip_path.bb_ly)) &&
                      (bmap_extnt.ximax <= SFX2I(GSptr->clip_path.bb_ux)) &&
                      (bmap_extnt.yimax <= SFX2I(GSptr->clip_path.bb_uy))
                    ) ?         FALSE   :   TRUE;
                /* inside clip path */    /* intersecting clip path */

        /* align "ximin" left to word boundary (@17m) */
        bmap_extnt.ximin = ALIGN_L(bmap_extnt.ximin);

        /* calculate width and height of raster bitmap */
        bmap_raswid = ALIGN_R(bmap_extnt.ximax) - bmap_extnt.ximin + 1;
        bmap_rashgt = bmap_extnt.yimax - bmap_extnt.yimin + 1;

        /* get upper limit of low-layer graphics primitives (ClipMaskBuf) */
        cmb_space (&bmap_size);     /* @=gwb_space, 07/28/88 Y.C.Chen */
        if (need2clip)
            {       /* working bitmap for clip; allocated from font cache */
            bmap_cache = get_pm (&clipbmap_sz);
            bmap_size = MIN (bmap_size, clipbmap_sz);
            }       /* no working bitmap needed if not to clip */

        /* calculate max scanlines allowed under that upper limit */
        lines_per_band = (fix) ((bmap_size * 8) / bmap_raswid);

        /* have raster bitmap height bounded by max scanlines allowed.
         *      AND as small as possible (@17+).
         */
        bmap_rashgt = MIN (lines_per_band, bmap_rashgt);
        }

#if (defined(DBG7) || defined(DBG8))
    printf ("init_qem_bit: wid=%d, hgt=%d, lines/band=%d, clip?%s\n",
                bmap_raswid, bmap_rashgt, lines_per_band,
                need2clip? "yes" : "no");
#endif

    if (need2clip)
        {
        /* make GSptr->cx/cy consistent with "cxx"/"cyy" */
        moveto (F2L(cxx), F2L(cyy));

        /* get integer pixel coord. of current point */
        cp_xi = (fix16) cxx;    cp_yi = (fix16) cyy;
        }

#ifdef DBGclip
    printf ("  clip? %s, CP <%d,%d>\n", need2clip?"yes":"no", cp_xi, cp_yi);
#endif
  END

/* ........................ restart_qem_bit ........................... */

PRIVATE FUNCTION void       restart_qem_bit ()

  DECLARE
  BEGIN

#if (defined(DBG7) || defined(DBG8))
    printf ("restart_qem_bit\n");
#endif
    /* @15+: allocate scanline_table and pixel_table */
    scanline_table = pixel_table = alloc_scanline(MAXSCANLINES);

    /* initialize variables about scanline table/pixel table */
    curr_scanline = no_lines = scanline_ii = pixel_ii = 0;

    /* save "cache_info" and setup new one when need to apply clipping */
    if (need2clip)
        {
        /* save old cache_info (restored by flush_qem_setbit) */
        cacheinfo_save = cache_info;

        /* setup new cache_info */
        charcache_clip.ref_x  = (cp_xi) - bmap_extnt.ximin;
        charcache_clip.ref_y  = 0;
        charcache_clip.box_w  = (fix16)bmap_raswid;
        charcache_clip.box_h  = (fix16)bmap_rashgt;
        charcache_clip.bitmap = bmap_cache;
        cache_info = &charcache_clip;   /* new place for cache clipping */
        }
  END

/* ........................ flush_qem_bit ............................. */

PRIVATE FUNCTION void       flush_qem_bit (dimension)
    ufix    dimension;      /* Y_DIMENSION:scanlines,  X_DIMENSION:pixels */

  DECLARE
  BEGIN

#if (defined(DBG7) || defined(DBG8))
    printf ("flush_qem_bit\n");
#endif

    /* flush scanlines/pixels to low-layer graphics primitives */
    if (dimension == Y_DIMENSION)
        qem_lineout();
    else
        qem_pixelout();

    /* reset variables about scanline table/pixel table */
    curr_scanline = no_lines = scanline_ii = pixel_ii = 0;

    /* restore "cache_info" when clipping applied */
    if (need2clip)
        cache_info = cacheinfo_save;
  END

/* ........................ qem_setbits ............................... */

GLOBAL FUNCTION void        qem_setbits (scanline_given, xbit1, xbit2)
    fix     scanline_given;     /* which scanline */
    fix     xbit1, xbit2;       /* from, to */

/* Descriptions:
 *  1. adds a run (from xbit1 to xbit2 at a scanline) into scanline_table.
 *  2. inserts END_OF_SCANLINE for blank lines.
 *  3. dumps out scanline_table when table or band full.
 */
  DECLARE
    REG fix     ii;     /* # of blank scanlines to be skipped */
  BEGIN

    if ((ii = scanline_given - curr_scanline) < 0)  return;

#ifdef DBG7
    printf ("  pre-setbits(): n_ln=%d, curr=%d, given=%d, idx=%d\n",
                no_lines, curr_scanline, scanline_given, scanline_ii);
#endif

    if (no_lines &&
          ( ((scanline_ii+3+ii) >= (MAXSCANLINES-1)) ||     /* table full? */
            ((no_lines+ii) >= lines_per_band) ))            /* over a band? */
        {
        qem_lineout ();             /* dump out when scanline_table full */
        no_lines = scanline_ii = 0; /* reset scanline_table */
        }

    if (no_lines == 0)
        {       /* this is the 1st scanline */
        no_lines = 1;
        scanline_ii = 0;
        }
    else
        {       /* scanline_table was ended with END_OF_SCANLINE */
        if (ii >= 1)
            {   /* add END_OF_SCANLINE's for blank scanlines */
            no_lines += ii;     /* including the new scanline */
            while (--ii)
                scanline_table[scanline_ii++] = END_OF_SCANLINE;
            }
        else    /* the run is on the same line as curr_scanline, ... */
            --scanline_ii;  /* the last DELIMITER is NOT needed any more */
        }

    /* have to relative to base of bmap_cache when character clipped */
    if (need2clip)
        {
        xbit1 -= bmap_extnt.ximin;
        xbit2 -= bmap_extnt.ximin;
        }

    /* put the run into scanline_table */
    scanline_table[scanline_ii++] = (ufix16)xbit1;
    scanline_table[scanline_ii++] = (ufix16)xbit2;
    scanline_table[scanline_ii++] = END_OF_SCANLINE;
    curr_scanline = scanline_given;

#ifdef DBG7
    printf("  post -- n_ln=%d, idx=%d, curr=%d, run=(%d,%d)\n",
                    no_lines, scanline_ii, curr_scanline, xbit1, xbit2);
#endif
  END

/* ............................ qem_lineout ........................... */

PRIVATE FUNCTION void near      qem_lineout ()

/* Descriptions:    called by qem_setbits(), flush_qem_bit().
 *  1. strokes out black runs accumulated on scanline_tbale.
 *  2. applies clipping to a bitmap band of a huge object if necessary.
 */
  DECLARE
    REG fix     ii;     /* the starting scanline of the output band */
  BEGIN
    if (no_lines)
        {
        ii = curr_scanline - no_lines + 1;  /* the starting scanline */
        scanline_table[scanline_ii] = END_OF_SCANLINE;

#     ifdef DBG7
        printf("  lineout(): n_ln=%d, idx=%d, start at %d\n",
                            no_lines, scanline_ii, ii);
#     endif

        if (qemfill_dest == F_TO_CACHE)
            fill_scan_cache (bmap_cache, bmap_raswid, bmap_rashgt, ii,
                            no_lines, scanline_table);
        else        /* F_TO_PAGE */
            {
            if (need2clip)
                {   /* for clipping */
                cache_info->ref_y = cp_yi - ii; /* adjust ref_y for the band */
#             ifdef DBGclip
                printf ("lineout - clipping\n");
                printf ("  cache_info->ref_x/_y=(%d,%d), _w/_h=(%d,%d)\n",
                                cache_info->ref_x,  cache_info->ref_y,
                                cache_info->box_w,  cache_info->box_h);
#             endif
                init_char_cache (cache_info);               /* clear bitmap */
                fill_scan_cache (bmap_cache, bmap_raswid, bmap_rashgt,
                            0, no_lines, scanline_table);   /* render bitmap */
                APPLY_CLIP_TO_CACHE ();                     /* apply clip */
                }
            else    /* totally inside of clip path */
                fill_scan_page (bmap_extnt.ximin, ii, bmap_raswid, no_lines,
                                scanline_table);            /* @= 08/31/88 */
            }
        }
  END

/* ........................ qem_set1bit ............................... */

GLOBAL FUNCTION void        qem_set1bit (sline, bit)
    REG fix     sline, bit;

/* Descriptions:
 *  1. adds a discrete pixel into pixel_table.
 *  2. dumps out pixel_table when table or band full.
 */
  DECLARE
  BEGIN

#ifdef DBG8
    printf ("  set1bit: line=%d, bit=%d, n_pix=%d\n", sline, bit, pixel_ii/2);
#endif

    /* dump out when pixel_table full */
    if (pixel_ii >= (N_PIXEL-2))
        {
        qem_pixelout();
        pixel_ii = 0;       /* reset pixel_table */
        }

    /* have to relative to base of bmap_cache when character clipped */
    if (need2clip)
        {
        bit   -= bmap_extnt.ximin;
        sline -= bmap_extnt.yimin;
        }

    /* put the pixel into pixel_table */
    pixel_table[pixel_ii++] = (ufix16)bit;
    pixel_table[pixel_ii++] = (ufix16)sline;
  END

/* ............................ qem_pixelout .......................... */

PRIVATE FUNCTION void near      qem_pixelout ()

/* Descriptions:    called by qem_set1bit(), flush_qem_bit().
 *  1. strokes out discrete pixels accumulated on pixel_table.
 *  2. applies clipping to a bitmap band of a huge object if necessary.
 */
  DECLARE
    REG fix     num_pixel;
  BEGIN
    if (pixel_ii)
        {
        num_pixel = pixel_ii / 2;   /* actual # of pixel pairs */
#     ifdef DBG8
        printf ("  pixelout (n_pixel=%d)\n", num_pixel);
#     endif
        if (qemfill_dest == F_TO_CACHE)
            fill_pixel_cache (bmap_cache, bmap_raswid, bmap_rashgt,
                                num_pixel, pixel_table);
        else        /* F_TO_PAGE */
            {
            if (need2clip)
                {   /* for clipping small/thin objects */
                cache_info->ref_y = cp_yi - bmap_extnt.yimin;
#             ifdef DBGclip
                printf ("pixelout - clipping\n");
                printf ("  cache_info->ref_x/_y=(%d,%d), box_w/_h=(%d,%d)\n",
                                cache_info->ref_x,  cache_info->ref_y,
                                cache_info->box_w,  cache_info->box_h);
#             endif
                init_char_cache (cache_info);           /* clear bitmap */
                fill_pixel_cache (bmap_cache, bmap_raswid, bmap_rashgt,
                            num_pixel, pixel_table);    /* render bitmap */
                APPLY_CLIP_TO_CACHE ();                 /* apply clip */
                }
            else    /* totally inside of clip path */
                fill_pixel_page (/* bmap_extnt.ximin, bmap_extnt.yimin,
                                  * bmap_raswid, bmap_rashgt,
                                  * @- unused parameters, 07/28/88 Y.C.Chen
                                  */
                                 num_pixel, pixel_table);
            }
        }
  END


/*
 * --------------------------------------------------------------------
 *      MODULE BODY: QEM Initialization
 * --------------------------------------------------------------------
 *  PRIVATE DATA STRUCTURES:
 *      none.
 *  PRIVATE ROUTINES:
 *      none.
 * --------------------------------------------------------------------
 */

/* ........................ __qem_init ................................ */

GLOBAL FUNCTION void        __qem_init ()

  DECLARE
  BEGIN
    FONTTYPE_QEM_INIT();
  END

/* ........................ __qem_restart ............................. */

GLOBAL FUNCTION void        __qem_restart (fonttype)
    ufix        fonttype;

  DECLARE
  BEGIN
    FONTTYPE_QEM_RESTART(fonttype);
  END

#ifdef KANJI

/* get cachedevice2 extra information */

void    get_CD2_extra(ftype, wx, wy, llx, lly, urx, ury, w1x, w1y, vx, vy)
ufix    ftype;
fix     wx, wy, llx, lly, urx, ury;
fix     FAR *w1x, FAR *w1y, FAR *vx, FAR *vy; /*@WIN*/
{
    *w1x = wx;
    *w1y = wy;
    *vx  = 0;
    *vy  = 0;

} /* get_CD2_extra() */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\warning.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * --------------------------------------------------------------------
 *  File: WARNING.H                     09/08/88 created by You
 *
 *  Purpose:
 *      This file defines major error code for warning message.
 *
 *  Revision History:
 *  09/29/88  you   - add for Ricoh fonts.
 *  10/19/88  you   - use file name instead of major error code.
 *                  . all major error codes are re-assigned.
 *                  . add major2name[] (have to be consistent with major code).
 * --------------------------------------------------------------------
 *  Warning Format:
 *      major error code :   a number of a source file (defined as below).
 *          --> file name of source program. (10/19/88)
 *      minor error code :   a number given in source programs.
 *      tailing message  :   a short string (normally NULL).
 *
 *  Notes:
 *      better not to reassign major codes to avoid confusions of
 *          different versions (unless you keep a good record).
 * --------------------------------------------------------------------
 */

/* major error code, in alphabetic order for all source programs */
           /* Font Machinery */
#define     CHK_VARI    0
#define     FNTCACHE    1
#define     FONTCHAR    2
#define     FONTINIT    3
#define     FONT_OP1    4
#define     FONT_OP2    5
#define     FONT_OP3    6
#define     FONT_OP4    7
#define     MATRIX      8
#define     QEMSUPP     9

            /* Bitstream font QEM */
#define     BSFILL2     10
#define     BS_FONT     11
#define     MAKEPATH    12
#define     PSGETREC    13
#define     PS_CACHE    14
#define     PS_DOFUN    15
#define     PS_RULES    16


/* 10/19/88: mapping table of major code to file name, for warning.c only */

#ifdef WARNING_INC

    PRIVATE byte    FAR *major2name[] = { /*@WIN*/
        "CHK_VARI",     /*  0 */
        "FNTCACHE",     /*  1 */
        "FONTCHAR",     /*  2 */
        "FONTINIT",     /*  3 */
        "FONT_OP1",     /*  4 */
        "FONT_OP2",     /*  5 */
        "FONT_OP3",     /*  6 */
        "FONT_OP4",     /*  7 */
        "MATRIX",       /*  8 */
        "QEMSUPP",      /*  9 */
        "BSFILL2",      /* 10 */
        "BS_FONT",      /* 11 */
        "MAKEPATH",     /* 12 */
        "PSGETREC",     /* 13 */
        "PS_CACHE",     /* 14 */
        "PS_DOFUN",     /* 15 */
        "PS_RULES",     /* 16 */
        (byte FAR *)NULL     /* ending delimiter @WIN*/
        };

#endif /* WARNING_INC */

/* .......................  Module Interfaces ......................... */

#ifdef  LINT_ARGS
    void    warning (ufix16, ufix16, byte FAR []);      /*@WIN*/
#else
    void    warning ();
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\ry_font.c ===
// DJC added global include
#include "psglobal.h"

#define    LINT_ARGS            /* @WIN */
#define    NOT_ON_THE_MAC       /* @WIN */
#define    KANJI                /* @WIN */
// DJC use command line #define    UNIX                 /* @WIN */
/*
 * -----------------------------------------------------------------------------
 *  File:   ry_font.c              11/08/89    created by Danny
 *                                 12/01/90    modified by Jerry
 *
 *      Client interface module
 *      Client called by Royal font Module
 *
 *  References:
 *  Revision History:
 *   12/5/90  Danny  Fix the bugs for show char in show (ref. CIRL:)
 *                   fill_cache_cache() calling added (it is in fill_gs.c)
 *   01/30/91 DS     @TT moidfy swap_bitmap() to avoid to copy non-used memory.
 *   03/27/91 Jerry  Modify ry_fill_shape() and cr_FSMemory()
 *   03/27/91 DS     change flag INTEL to LITTLE_ENDIAN
 *   03/29/91 Danny  Fix the bugs for showing the space char (ref: SPC:)
 *   04/23/91 Phlin  Fix the bugs for extra underline of 2 points char and
 *   04/30/91 Phlin  missing char '_' in small point size (ref: 2Pt).
 *   05/10/91 Phlin  Replace rc_GetMetrics_Width by rc_GetAdvanceWidth (ref: GAW)
 *   05/10/91 Phlin  Add do_transform flag used in make_path (ref: DTF)
 * -----------------------------------------------------------------------------
 */


#include <stdio.h>  /* 05/03/91 for SUN */
#include <string.h>

#include        "define.h"
#include        "global.ext"
#include        "graphics.h"
#include        "graphics.ext"

#include        "font.h"
#include        "font.ext"

#include        "warning.h"
#include        "fontqem.ext"

#include        "fontgrap.h"
#include        "fontdict.h"
#include        "fontkey.h"
#include        "fontinfo.def"

/* external function for Dynamic Font Allocation; @DFA 7/9/92 */
#include   "wintt.h"

/* sfnt interface header */
#include        "in_sfnt.h"

/* added for update EMunits;  @DFA @WIN */
#include   "..\bass\FontMath.h"
#include   "..\bass\fnt.h"
#include   "..\bass\sc.h"
#include   "..\bass\FSglue.h"
extern void SetupKey(fsg_SplineKey FAR *, ULONG_PTR);
extern void sfnt_DoOffsetTableMap(fsg_SplineKey FAR *);
extern void FAR *sfnt_GetTablePtr(fsg_SplineKey FAR *, sfnt_tableIndex, boolean);
extern int  EMunits; /* GAW */
extern char FAR *SfntAddr; /*@WIN*/

extern int bWinTT;        /* if using Windows TT fonts; from ti.c;@WINTT */
// extern from wintt.h; @WINTT
void CheckFontData (void);
unsigned long ShowGlyph (unsigned int fuFormat,
     char FAR *lpBitmap);
void ShowOTM (void);
void ShowKerning(void);
void TTLoadFont (int nFont);
void TTLoadChar (int nChar);
int TTAveCharWidth (void);
float TTTransform (float FAR *ctm);

// DJC not used for pstodib
// void TTBitmapSize (struct CharOut FAR *CharOut);

#define  N_BITS_ACCURACY     13  /* 2e-13 == 0.0001 */
#define  EXCESS127(expon)    ((expon) + 127)
#define  N_MANTISSA_BITS     23
#define  NEAR_ZERO(expon, nbit)  ( (expon) <= EXCESS127(-(nbit)) )
#define  DE_EXPONENT(ff)                                    \
                ( (fix16) (  (F2L(ff) & 0x7FFFFFFF)         \
                             >> N_MANTISSA_BITS             \
                          )                                 \
                )
#define FARALLOC(n,type)     /* to allocate far data ... */\
                             (type far *) fardata((ufix32)n * sizeof(type))
#define     PDLDPI           300
#define     CB_MEMSIZE       ((unsigned)64 * 1024)       /* 64 buffer */

/* add prototype; @WIN */
extern void far fill_cache_cache(struct Char_Tbl FAR *,struct Char_Tbl FAR *);
extern fix  rc_InitFonts(int);
extern fix  rc_LoadFont(char FAR *, uint16, uint16);
extern fix  rc_GetAdvanceWidth(int, struct Metrs FAR *);  /* GAW */
extern fix  rc_TransForm(float FAR *);
extern fix  rc_BuildChar(int, struct CharOut FAR *);
extern fix  rc_FillChar(struct BmIn FAR *, BitMap FAR * FAR *);
extern fix  rc_CharPath(void);
extern fix  rc_CharWidth(int, struct CharOut FAR *);
#ifdef  DBG
static void to_bitmap();
#endif

#ifdef LITTLE_ENDIAN
static void swap_bitmap();
#endif

extern struct f_info near FONTInfo;     /* union of current font information */
extern real32  near cxx,  near cyy;     /* current point */
extern real32   near      FONT_BBOX[4]; /* added by CLEO -- font bounding box */
extern int      near      do_transform; /* flag of redoing NewTransformation, DTF */

static ufix32             cb_size;
static byte              FAR *cb_base, FAR *cb_pos; /*@WIN*/
static float              ctm_tx, ctm_ty;
static fix16              ctm_dx, ctm_dy;
static struct CharOut     CharInfo;


/*
 * -----------------------------------------------------------------------------
 * Routine: fontware_init
 *
 * -----------------------------------------------------------------------------
 */
void
fontware_init()
{
    fix     ret_code;

    ret_code = rc_InitFonts(PDLDPI);
    if (ret_code) return;       /* exit(1)=>return; @WIN */

    cb_size = (ufix32)CB_MEMSIZE;

    //DJC cb_base = FARALLOC(cb_size, byte);

    // DJC change to alloc a little extra memory for data we use later...
    // DJC when we split the cache thats left in half. This is required
    // DJC to guarantee DWORD alignment when we split the cache
    cb_base = FARALLOC(cb_size + 10 , byte);

    cb_pos = cb_base;

    return;
} /* fontware_init() */


/*
 * -----------------------------------------------------------------------------
 * Routine: fontware_restart
 *
 * -----------------------------------------------------------------------------
 */
void
fontware_restart()
{
#ifndef SFNT
    struct pld_obj      FAR *private; /*@WIN*/
    gmaddr              FAR *p_base; /*@WIN*/
#endif
    byte                FAR *sfnt; /*@WIN*/
    fix                  ret_code;
    ufix16               platform_id;
    ufix16               specific_id;
    int                 nFontID;        //@WINTT


#ifdef DBG
    printf("Enter fontware_restart\n");
#endif
    cb_pos = cb_base;

#ifdef SFNT
{
        struct object_def  FAR *obj_p ; /*@WIN*/
        obj_p=(struct object_def FAR *)Sfnts(&FONTInfo) ; /*@WIN*/
        sfnt = (byte FAR *)VALUE(obj_p) ; /*@WIN*/
}
#else  /* SFNT */

    p_base = (gmaddr FAR *) PRIvate(&FONTInfo); /*@WIN*/
    private = (struct pld_obj FAR *) (p_base + 1); /*@WIN*/

#ifndef RE_DICT
    sfnt = (byte FAR *)(*((ufix32 FAR *)(&private[0]))); /*@WIN*/
#else    /* RE_DICT */
    sfnt = (byte FAR *)(*((ufix32 FAR *)(*p_base))); /*@WIN*/
#endif   /* RE_DICT */
#endif  /* SFNT */

#ifdef DBG
    printf("sfnt: %lx\n", (ufix32)sfnt);
#endif

    platform_id = (ufix16)PlatID(&FONTInfo) ;
    specific_id = (ufix16)SpecID(&FONTInfo) ;
    ret_code = rc_LoadFont(sfnt, platform_id, specific_id);

//if (bWinTT) {                      // for Win31 truetype; @WINTT
  nFontID = (int)(PRE_fid(&FONTInfo)) - 1024;   // use as font ID
  bWinTT = FALSE;
#ifdef DJC // comment out for fix of MAC chooser problems
  if (nFontID >= 0) {     // for Win31 truetype; @WINTT
    bWinTT = TRUE;
    TTLoadFont(nFontID);
  }
#endif

#ifdef DBGCFONT
    if (ret_code)
        printf("rc_LoadFont error!! PlatformID=%d, SpecificID=%d, sfnt: %lx\n",
                platform_id, specific_id, (ufix32)sfnt);
#endif

    if (ret_code) { ERROR(INVALIDFONT); return; }

    /* update EMunits; moved in from do_setfont();  --- Begin --- @DFA @WIN */
    {
        fsg_SplineKey  KData;
        fsg_SplineKey FAR *key = &KData;
        sfnt_FontHeader FAR *fontHead;

        SfntAddr = (byte FAR *)sfnt;
        SetupKey(key, (ULONG_PTR)sfnt);
        sfnt_DoOffsetTableMap(key);
        fontHead = (sfnt_FontHeader FAR *)sfnt_GetTablePtr(key, sfnt_fontHeader, true );
        EMunits = SWAPW(fontHead->unitsPerEm) ;
    }
    /* update EMunits; moved in from do_setfont();  ---  End  --- @DFA @WIN */

    return;
} /* fontware_restart() */


/*
 * -----------------------------------------------------------------------------
 * Routine: make_path
 *
 * -----------------------------------------------------------------------------
 */
bool
make_path(char_desc)
union char_desc_s FAR *char_desc; /*@WIN*/
{
    ufix          CharCode;
    struct Metrs  Metrs;
    int           GridFit;
    float         largest_ctm;

    /* If font data is not in memory, load and init it; @DFA --- Begin ---*/
    {
        struct object_def          my_obj = {0, 0, 0}, FAR *ary_obj;

        ary_obj = (struct object_def FAR *)Sfnts(&FONTInfo); /*@WIN*/
        if ((byte FAR *)VALUE(ary_obj) == (char FAR *)NULL) {
            struct object_def FAR *obj_uid;
            ufix32      uniqueid;
            char FAR * lpFontData;
            int nSlot;

            /* get uniqueID to locate index of FontDefs[] */
            ATTRIBUTE_SET (&my_obj, LITERAL);
            LEVEL_SET (&my_obj, current_save_level);
            get_name (&my_obj, UniqueID, 8, TRUE);
            get_dict (&current_font, &my_obj, &obj_uid);
            uniqueid = (ufix32)VALUE(obj_uid);
            lpFontData = ReadFontData ((int)uniqueid -TIFONT_UID,
                                       (int FAR*)&nSlot);
            VALUE(&ary_obj[0]) = (ULONG_PTR)lpFontData;
            // if no_block > 1, needs to set other pointers ??? TBD

            /* put font_dict in ActiveFont[] */
            SetFontDataAttr(nSlot, &ary_obj[0]);

            // re-initialize the fontware
            fontware_restart();
        } /* if */
    }
    /* If font data is not in memory, load and init it; @DFA ---  End  ---*/

    CharCode = (ufix)char_desc->charcode;
#ifdef DBG
    printf("Enter make_path: %d\n", CharCode);
#endif

  if (bWinTT) {                      // for Win31 truetype; @WINTT
#ifdef DJC
    // TTLoadChar (CharCode);      move to show_a_char() for temp solution
    //                             since CharCode here is a Glyph index
    largest_ctm = TTTransform(CTM);  // set matrix before getting real advance width
//  Metrs.awx = (int)((float)TTAveCharWidth() / CTM[0]);
    Metrs.awx = (int)((float)TTAveCharWidth() / largest_ctm);
    Metrs.awy = 0;
#endif
      ; // DJC
  } else {
    /* get advancewidth information */
    rc_GetAdvanceWidth(CharCode, &Metrs); /* GAW */
  }

    ctm_dx = (fix16)(ROUND(CTM[4]));
    ctm_dy = (fix16)(ROUND(CTM[5]));

    /* set cachedevice */
    switch (__set_cache_device ((fix)Metrs.awx, (fix)Metrs.awy,
                        (fix)FONT_BBOX[0], (fix)FONT_BBOX[1],
                        (fix)FONT_BBOX[2], (fix)FONT_BBOX[3]))
    {
    case STOP_PATHCONSTRUCT:
        return (FALSE);
    case DO_QEM_AS_USUAL:
        GridFit = TRUE;
        break;
    default:    /* case NOT_TO_DO_QEM : */
        GridFit = FALSE;
        break;
    }

#ifdef DBG
    printf("CTM: %f %f %f %f %f %f\n", CTM[0], CTM[1], CTM[2], CTM[3], CTM[4], CTM[5]);
#endif
    ctm_tx = CTM[4];
    ctm_ty = CTM[5];
    /* DTF */
    if(do_transform) {
       //if (bWinTT) {                      // for Win31 truetype; @WINTT
       // DJC  largest_ctm = TTTransform(CTM);
       // DJC
       // } else {
           //DJC fix from history.log UPD015
           //rc_TransForm(CTM);

           if( rc_TransForm(CTM)) {
              return(FALSE);  //DJC, note return here
           }
           //DJC end fix UPD015
       // }
       do_transform = FALSE;
    }

    /* Not Apply hinting for rotated char */
    if (GridFit &&
        !(( NEAR_ZERO(DE_EXPONENT(CTM[0]), N_BITS_ACCURACY) &&
            NEAR_ZERO(DE_EXPONENT(CTM[3]), N_BITS_ACCURACY) ) ||
          ( NEAR_ZERO(DE_EXPONENT(CTM[1]), N_BITS_ACCURACY) &&
            NEAR_ZERO(DE_EXPONENT(CTM[2]), N_BITS_ACCURACY) ) ) )
        GridFit = FALSE;

    /* build internal char path */
  if (bWinTT) {                      // for Win31 truetype; @WINTT
// DJC    TTBitmapSize (&CharInfo);
   ; // DJC
  } else {
    rc_BuildChar(GridFit, &CharInfo);
  }
    return(TRUE);

} /* make_path() */





// DJC, 2/1/93, complete replace of ry_fill_shape from tumbo UPD009
//
// NOTE:        One thing to watch out for is cb_size getting modified
//              in which case you may up with a situation where its NOT
//              DWORD aligned, this could cause problems to fault on
//              MIPS.... this was fixed once in the original ry_fill_shape
//              but too much stuff changed and we migrated to the new one
//              defined below.
//
/*
 * -----------------------------------------------------------------------------
 * Routine: ry_fill_shape
 *
 * -----------------------------------------------------------------------------
 */
void
ry_fill_shape(filldest)
ufix  filldest;   /* F_TO_CACHE or F_TO_PAGE */
{
    ufix32           cb_size;
    byte            FAR *cb_pos2, FAR *cb_pos3, FAR *sptr, FAR *dptr; /*@WIN*/
    fix              iscan, one_band, n_bands, band_size, ret_code;
    register fix     i, j;
    struct Char_Tbl FAR *save_cache_info, Cache1; /*@WIN*/
    struct BmIn      BmIn;
    struct BitMap   FAR *BmOut; /*@WIN*/

#ifdef DBG
    printf("Enter ry_fill_shape: %d\n", filldest);
    printf("CharInfo.scan = %ld\n", CharInfo.scan);
#endif
/* SPC: Begin, Danny Lu, 3/29/91, Added */
/* 2Pt: Phlin, 4/29/91, Update */
/*  if ((CharInfo.bitWidth == 0) || (CharInfo.scan == 0)) {  */
    if ( CharInfo.bitWidth == 0 ) {
        if (!buildchar) {
              cache_info->bitmap = (gmaddr) 0;
              cache_info->ref_x = 0;
              cache_info->ref_y = 0;
              cache_info->box_w = 0;
              cache_info->box_h = 0;
              bmap_extnt.ximin = -1;
              bmap_extnt.ximax = -1;
              bmap_extnt.yimin = -1;
              bmap_extnt.yimax = -1;
        }
        return;
    }
/* SPC: End, Danny Lu, 3/29/91 */

    save_cache_info = cache_info;
    cb_size = (ufix32)(((ULONG_PTR)cb_base + CB_MEMSIZE) - (ULONG_PTR)(cb_pos));

    if (filldest == F_TO_CACHE) {

          if (buildchar) { /* CIRL */
              Cache1.ref_x = - (int)CharInfo.lsx - 1 - ctm_dx; /* add int; @WIN */
              Cache1.ref_y = CharInfo.yMax - 1 - ctm_dy;
          }
          else {
              bmap_extnt.ximin = 0;
              bmap_extnt.ximax =  CharInfo.bitWidth;
              bmap_extnt.yimin = 0;
/* 2Pt: Begin, Phlin, 4/23/91
 *            bmap_extnt.yimax = CharInfo.scan + 1; */
              bmap_extnt.yimax = CharInfo.scan;
              if (bmap_extnt.yimax)
                  bmap_extnt.yimax--;    /*?????*/
/* 2Pt: End, Phlin, 4/23/91 */

              cache_info->ref_x = - (int)CharInfo.lsx - 1 - ctm_dx; /* add int; @WIN */
              cache_info->ref_y = CharInfo.yMax - 1 - ctm_dy;
          }
    }
    else { /* filldest == F_TO_PAGE */

        lmemcpy ((ubyte FAR *)(&Cache1), (ubyte FAR *)(cache_info), sizeof(struct Char_Tbl)); /*@WIN*/
        cache_info = &Cache1;

        moveto(F2L(ctm_tx), F2L(ctm_ty));

        cache_info->ref_x = (- (int)CharInfo.lsx - 1);  /* add int; @WIN */

        cache_info->ref_y = CharInfo.yMax - 1;
    }

    if ((filldest == F_TO_CACHE) && (!buildchar) ) {

        if (bWinTT) {                      // for Win31 truetype; @WINTT
#ifdef DJC
              /* GetGlyphOutline constants; from "windows.h" */
              #define GGO_METRICS        0
              #define GGO_BITMAP         1
              #define GGO_NATIVE         2
              static nCharCode = 65;
              unsigned long dwWidthHeight;

              dwWidthHeight = TTShowBitmap ((char FAR *)cache_info->bitmap);
              cache_info->box_w = (fix16) (dwWidthHeight >> 16);
              cache_info->box_h = (fix16) (dwWidthHeight & 0x0ffffL);
#endif
        } else {
/* calculate memoryBase 5, 6 and 7 correctly; ----- Begin --- @WIN 7/24/92 */
#if 0
          cb_size = cb_size / 2;
          cb_pos2 = cb_pos;
          cb_pos3 = cb_pos2 + cb_size;

          BmIn.bitmap5 = (byte FAR *)cache_info->bitmap; /*@WIN*/
          BmIn.bitmap6 = cb_pos2;   /* suppose it is enough */
          BmIn.bitmap7 = cb_pos3;

          BmIn.bottom  = CharInfo.yMin;
          BmIn.top     = CharInfo.yMax;
          ret_code     = rc_FillChar(&BmIn, &BmOut);
          if (ret_code) {  ERROR(INVALIDFONT); return;  }
          cache_info->box_w = BmOut->rowBytes * 8;
          cache_info->box_h = BmOut->bounds.bottom - BmOut->bounds.top;
#endif
          /* refer to bass\fscaler.c */
          int scans, top;
          char FAR * bitmap;
          /* cb_size = memorySize6 + memorySize7
             where,
             memorySize6 = scan * ((nYchanges + 2) * sizeof(int16) + sizeof(int16 FAR *));
             memorySize7 is fixed, since we band it in y-direction; x-dir is same
             so,
              scan = (cb_size - memorySize7) /
                     ((nYchanges+2) * sizeof(int16) + sizeof(int16 *));
          */
          /* turn off drop out control when memory is not enough */
          if (CharInfo.memorySize7 > (fix32)(cb_size -4096)) CharInfo.memorySize7 = 0;

          scans = (int)((cb_size - CharInfo.memorySize7) /
                      ((CharInfo.nYchanges+2) * sizeof(int16) + sizeof(int16 FAR *)));
          top = CharInfo.yMax;
          bitmap = (byte FAR *)cache_info->bitmap;

          BmIn.bitmap6 = cb_pos;
          BmIn.bitmap7 = CharInfo.memorySize7 ?
                         cb_pos + (cb_size - CharInfo.memorySize7) : 0L;
          do {
              BmIn.bitmap5 = bitmap;
              BmIn.top     = top;
              top -= scans;
              BmIn.bottom  = CharInfo.yMin > top ? CharInfo.yMin : top;
              ret_code     = rc_FillChar(&BmIn, &BmOut);

              if (ret_code != 0) {
                 // NTFIX this still needs to get looked at but
                 //       for nowlets just set an error. This is NOT
                 //       critical as only one char in DINGBATS causes this
                 //       (MTSSORTS.TTF
                 //
                 printf("\nWarning... rc_FillChar returns ERROR"); //DJC
                 ERROR(INVALIDFONT);
                 return;
              }
              bitmap += BmOut->rowBytes * scans;
          } while (BmIn.bottom > CharInfo.yMin);

          cache_info->box_w = BmOut->rowBytes * 8;
          cache_info->box_h = CharInfo.yMax - CharInfo.yMin;
/* calculate memoryBase 5, 6 and 7 correctly; ----- End --- @WIN 7/24/92 */

        }

#ifdef LITTLE_ENDIAN
          sptr=BmOut->baseAddr;
          /* @TT BEGIN move part of buffer which accurately be used
           *     in BASS to cache buffer rather than whole buffer
           *     D.S Tseng 01/30/91
           */
          swap_bitmap((ufix16 FAR *)sptr, BmOut->rowBytes, cache_info->box_h); /*@WIN*/
#endif
#ifdef  DBG
          for (i=0, sptr=BmOut->baseAddr; i<cache_info->box_h;
               i++, sptr+=BmOut->rowBytes, dptr+=(cache_info->box_w/8))
          {
              to_bitmap(sptr, BmOut->rowBytes);
          }
#endif
    }
    else { /* filldest == F_TO_PAGE || ((filldest == F_TO_CACHE) && (buildchar))*/

/* calculate memoryBase 5, 6 and 7 correctly; ----- Begin --- @WIN 7/24/92 */
#if 0
        cb_size = cb_size / 3;
        cb_size &= 0xfffffffe;       /* 2 bytes alignment */
        cb_pos2 = cb_pos  + cb_size;
        cb_pos3 = cb_pos2 + cb_size;
#endif
    {
        /* defined in bass\fscaler.c */
        #ifdef  DEBUGSTAMP
        #define STAMPEXTRA              4
        #else
        #define STAMPEXTRA              0
        #endif
        int scan, width6;
        ufix32 cmb_size;

        /* cb_size = memorySize5 + memorySize6 + memorySize7
           where,
           memorySize5 = (scan * byteWidth) + STAMPEXTRA;
           memorySize6 = scan * ((nYchanges + 2) * sizeof(int16) + sizeof(int16 FAR *));
           memorySize7 is fixed, since we band it in y-direction; x-dir is same
           so,
            scan = (cb_size - memorySize7 - STAMPEXTRA) /
                    (byteWidth + ( (nYchanges+2) * sizeof(int16) + sizeof(int16 *)));
        */
        /* turn off drop out control when memory is not enough */
        if (CharInfo.memorySize7 > (fix32)(cb_size -4096)) CharInfo.memorySize7 = 0;
        width6 = (CharInfo.nYchanges+2) * sizeof(int16) + sizeof(int16 FAR *);
        scan = (int)((cb_size - CharInfo.memorySize7 - STAMPEXTRA) /
               (CharInfo.byteWidth + width6));
        if(scan ==0) {
                printf("Fatal error, scan==0\n");
                scan++;
        }

        cb_size = (scan * CharInfo.byteWidth) + STAMPEXTRA;
        cmb_space(&cmb_size);
        if(cb_size > cmb_size) cb_size = cmb_size;
        cb_pos2 = cb_pos  + cb_size;
        cb_pos3 = cb_pos2 + (scan * width6);

        BmIn.bitmap5 = cb_pos;
        BmIn.bitmap6 = cb_pos2;
        BmIn.bitmap7 = CharInfo.memorySize7 ? cb_pos3 : 0L;
    }
/* calculate memoryBase 5, 6 and 7 correctly; ----- End --- @WIN */

        band_size = (fix) (cb_size / CharInfo.byteWidth);       //@WIN
        n_bands   = CharInfo.scan / band_size;
        one_band  = CharInfo.scan % band_size;

        dptr = (byte FAR *)cache_info->bitmap; /*@WIN*/
        if (n_bands) {   /* Char too large; must band into pagemap/bitmap */
            for (iscan=CharInfo.yMax;n_bands>0; iscan -= band_size, n_bands--) {
                BmIn.bottom  = iscan - band_size;
                BmIn.top     = iscan;
                ret_code     = rc_FillChar(&BmIn, &BmOut);
                if (ret_code) {  ERROR(INVALIDFONT); return;  }
#ifdef LITTLE_ENDIAN
                    sptr=BmOut->baseAddr;
                    /* @TT BEGIN move part of buffer which accurately be used
                     *     in BASS to cache buffer rather than whole buffer
                     *     D.S Tseng 01/30/91
                     */
                    swap_bitmap((ufix16 FAR *)sptr, BmOut->rowBytes, band_size); /*@WIN*/
#endif
                if (filldest == F_TO_CACHE) { /* buildchar CIRL */

                    Cache1.bitmap = (gmaddr)((char FAR *)BmOut->baseAddr);/*@WIN*/
                    Cache1.box_w = (fix16)BmOut->rowBytes * 8;
                    Cache1.box_h = (fix16)band_size;

                    fill_cache_cache(cache_info, &Cache1);
                    Cache1.ref_y -= (fix16)band_size;
                }
                else {  /* F_TO_PAGE  (fill to page frame) */

                    if (BmOut->rowBytes % 2) {
                        /* padding bitmap */
                        for (i=0, sptr=BmOut->baseAddr, dptr=cb_pos;i<band_size;
                             i++, sptr+=BmOut->rowBytes, dptr+=(BmOut->rowBytes + 1))
                        {
                            for (j=0; j<BmOut->rowBytes; j++)
                                dptr[j] = sptr[j];
                            dptr[j] = 0;
#ifdef  DBG
                            to_bitmap(sptr, BmOut->rowBytes);
#endif
                        } /* for (i... */
                        cache_info->box_w = BmOut->rowBytes * 8 + 8;
                        cache_info->bitmap = (gmaddr)cb_pos;
                    }
                    else {
                        cache_info->box_w = BmOut->rowBytes * 8;
                        cache_info->bitmap = (gmaddr)((char FAR *)BmOut->baseAddr);/*@WIN*/
                    }
                    cache_info->box_h = (fix16)band_size;
                    /* apply bitmap filling */
                    fill_shape(EVEN_ODD, F_FROM_CACHE, F_TO_CLIP);
                    cache_info->ref_y -= (fix16)band_size;
                }
            } /* for (iscan... */
        }
        if (one_band) {
            BmIn.bottom  = CharInfo.yMin;
            BmIn.top     = CharInfo.yMin + one_band;
            ret_code     = rc_FillChar(&BmIn, &BmOut);
            if (ret_code) {  ERROR(INVALIDFONT); return;  }
#ifdef LITTLE_ENDIAN
                sptr=BmOut->baseAddr;
                /* @TT BEGIN move part of buffer which accurately be used
                 *     in BASS to cache buffer rather than whole buffer
                 *     D.S Tseng 01/30/91
                 */
                swap_bitmap((ufix16 FAR *)sptr, BmOut->rowBytes, one_band); /*@WIN*/
#endif
            if (filldest == F_TO_CACHE) { /* buildchar CIRL */

                Cache1.bitmap = (gmaddr)((char FAR *)BmOut->baseAddr);/*@WIN*/
                Cache1.box_w = (fix16)BmOut->rowBytes * 8;
                Cache1.box_h = (fix16)one_band;

                fill_cache_cache(cache_info, &Cache1);
            }
            else {  /* F_TO_PAGE  (fill to page frame) */

                if (BmOut->rowBytes % 2) {
                    /* padding bitmap */
                    for (i=0, sptr=BmOut->baseAddr, dptr=cb_pos;
                         i<one_band;
                         i++, sptr+=BmOut->rowBytes, dptr+=(BmOut->rowBytes + 1))
                    {
                        for (j=0; j<BmOut->rowBytes; j++)
                            dptr[j] = sptr[j];
                        dptr[j] = 0;
#ifdef  DBG
                        to_bitmap(sptr, BmOut->rowBytes);
#endif
                    } /* for (i... */
                    cache_info->box_w = BmOut->rowBytes * 8 + 8;
                    cache_info->bitmap = (gmaddr)cb_pos;
                }
                else {
                    cache_info->box_w = BmOut->rowBytes * 8;
                    cache_info->bitmap = (gmaddr)((char FAR *)BmOut->baseAddr);/*@WIN*/
                }
                cache_info->box_h = (fix16)one_band;
                /* apply bitmap filling */
                fill_shape(EVEN_ODD, F_FROM_CACHE, F_TO_CLIP);
            }
        }
    }
    if (buildchar && (filldest == F_TO_CACHE) ) { /* CIRL */
        CURPOINT_X += cache_info->adv_x;
        CURPOINT_Y += cache_info->adv_y;
    }
    cache_info = save_cache_info;
#ifdef  DBG
    printf("Exit ry_fill_shape()....\n");
#endif
    return;
} /* ry_fill_shape() */



/*
 * -----------------------------------------------------------------------------
 * Routine: cr_FSMemory
 *
 * -----------------------------------------------------------------------------
 */
char FAR * /*@WIN_BASS*/
cr_FSMemory(size)
long    size;
{
    return((char FAR *)(((ULONG_PTR)FARALLOC(size, char) + 3) / 4 * 4));
} /* cr_FSMemory() */


/*
 * -----------------------------------------------------------------------------
 * Routine: cr_GetMemory
 *
 * -----------------------------------------------------------------------------
 */
char FAR * /*@WIN_BASS*/
cr_GetMemory(size)
long    size;
{
    char FAR *p; /*@WIN*/
#ifdef DBG
    printf("Enter cr_GetMemory: %ld size\n", size);
#endif

    p = cb_pos;
    cb_pos += (size + 3) / 4 * 4;

    return(p);
} /* cr_GetMemory() */


/*
 * -----------------------------------------------------------------------------
 * Routine: cr_translate
 *
 * -----------------------------------------------------------------------------
 */
void
cr_translate(tx, ty)
float    FAR *tx, FAR *ty; /*@WIN*/
{
    *tx = ctm_tx;
    *ty = ctm_ty;

    return;
} /* cr_translate() */


/*
 * -----------------------------------------------------------------------------
 * Routine: cr_newpath
 *
 * -----------------------------------------------------------------------------
 */
void
cr_newpath()
{
#ifdef DBG
    printf("newpath\n");
#endif
    op_newpath();

    return;
} /* cr_newpath() */


/*
 * -----------------------------------------------------------------------------
 * Routine: cr_moveto
 *
 * -----------------------------------------------------------------------------
 */
void
cr_moveto(float x, float y)     /*@WIN*/
{
    real32  xx, yy;
#ifdef DBG
    printf("%f %f moveto\n", x, y);
#endif

    xx = x;
    yy = y;
    moveto(F2L(xx), F2L(yy));

    return;
} /* cr_moveto() */


/*
 * -----------------------------------------------------------------------------
 * Routine: cr_lineto
 *
 * -----------------------------------------------------------------------------
 */
void
cr_lineto(float x, float y)     /*@WIN*/
{
    real32  xx, yy;
#ifdef DBG
    printf("%f %f lineto\n", x, y);
#endif

    xx = x;
    yy = y;
    lineto(F2L(xx), F2L(yy));

    return;
} /* cr_lineto() */


/*
 * -----------------------------------------------------------------------------
 * Routine: cr_curveto
 *
 * -----------------------------------------------------------------------------
 */
void
cr_curveto(float x1, float y1, float x2, float y2, float x3, float y3) /*@WIN*/
{
    real32  xx1, yy1, xx2, yy2, xx3, yy3;
#ifdef DBG
    printf("%f %f %f %f %f %f curveto\n", x1, y1, x2, y2, x3, y3);
#endif

    xx1 = x1;
    yy1 = y1;
    xx2 = x2;
    yy2 = y2;
    xx3 = x3;
    yy3 = y3;
    curveto(F2L(xx1), F2L(yy1), F2L(xx2), F2L(yy2), F2L(xx3), F2L(yy3));

    return;
} /* cr_curveto() */


/*
 * -----------------------------------------------------------------------------
 * Routine: cr_closepath
 *
 * -----------------------------------------------------------------------------
 */
void
cr_closepath()
{
#ifdef DBG
    printf("closepath\n");
#endif
    op_closepath();

    return;
} /* cr_closepath() */


#ifdef  DBG
/*
 * -----------------------------------------------------------------------------
 * Routine: to_bitmap
 *
 * -----------------------------------------------------------------------------
 */
static void
to_bitmap(p_row, p_len)
byte    FAR p_row[]; /*@WIN*/
fix     p_len;
{
    fix         l_i, l_k;
    ufix16      FAR *l_value; /*@WIN*/
    byte        FAR *l_ptr; /*@WIN*/

    for(l_k=0; l_k < p_len; l_k += 2) {
        l_value = (ufix16 FAR *)(&p_row[l_k]); /*@WIN*/
        for(l_i=0; l_i < 16; l_i++) {
            /* high bit order first */
            if( (*l_value >> (15-l_i)) & 0x01 )
                printf("#");
            else
                printf(".");
        }
    }
    printf("    ");

    l_ptr = p_row;
    for(l_i=0; l_i < p_len; l_ptr++, l_i++)
        printf(" %2x", (ufix16)*l_ptr);
    printf("\n");

    return;
}   /* to_bitmap */
#endif  /* DBG */

#ifdef LITTLE_ENDIAN
/* @TT BEGIN move part of buffer which accurately be used
 *     in BASS to cache buffer rather than whole buffer
 *     D.S Tseng 01/30/91 */
#ifndef LBODR /* #ifdef HB32 */
void swap_bitmap(mapbase, rowbytes,band_size)
ufix16 FAR *mapbase; /*@WIN*/
fix    rowbytes;
fix    band_size;
{
fix    i, row;
ufix16 tmp1;
ufix16 tmp2;
    for (i=0; i<band_size; i++) {
        row = rowbytes;
        for (;row > 3; row -=4) {
            tmp1 = *mapbase;
            tmp2 = *(mapbase+1);
            *mapbase++ = tmp2;
            *mapbase++ = tmp1;
        }
    }
    return;
}
/* @TT END 01/31/91 D.S.Tseng */
#else /* #ifdef LBODR */
void swap_bitmap(mapbase, rowbytes,band_size)
ubyte FAR *mapbase; /*@WIN*/
fix    rowbytes;
fix    band_size;
{
fix    i, j, row;
ufix32 h_val, l_val;
ufix32 tmp1, is_one, is_one_h, is_one_l;
    for (i=0; i<band_size; i++) {
        row = rowbytes;
        for (;row > 3; row -=4) {
            tmp1 = *(ufix32 FAR *)mapbase; /*@WIN*/
            h_val = (1<<31);
            l_val = 1;
            for (j = 15; j >= 0; j--) {
                is_one_h = tmp1 & h_val ? 1 : 0;
                is_one_l = tmp1 & l_val ? 1 : 0;
                if (is_one_h != is_one_l) {
                /* if ((is_one = (tmp1 & h_val)) != (tmp1 & l_val)) { */
                    if (is_one_h) {  /* j+16th bit == 1 */
                    /* if (is_one) { */  /* j+16th bit == 1 */
                        tmp1 -= h_val;
                        tmp1 += l_val;
                    } else {               /* 15-jth bit == 1 */
                        tmp1 -= l_val;
                        tmp1 += h_val;
                    }
                }
                h_val = h_val >> 1;
                l_val = l_val << 1;
            }
            *(ufix32 FAR *)mapbase = tmp1; /*@WIN*/
            mapbase += 4;
        }
    }
    return;
}
#endif
#endif


#ifdef DJC  //Complete replace of ry_fill_shape from current code
/*
 * -----------------------------------------------------------------------------
 * Routine: ry_fill_shape
 *
 * -----------------------------------------------------------------------------
 */
void
ry_fill_shape(filldest)
ufix  filldest;   /* F_TO_CACHE or F_TO_PAGE */
{
    ufix32           cb_size;
    byte            FAR *cb_pos2, FAR *cb_pos3, FAR *sptr, FAR *dptr; /*@WIN*/
    fix              iscan, one_band, n_bands, band_size, ret_code;
    register fix     i, j;
    struct Char_Tbl FAR *save_cache_info, Cache1; /*@WIN*/
    struct BmIn      BmIn;
    struct BitMap   FAR *BmOut; /*@WIN*/

#ifdef DBG
    printf("Enter ry_fill_shape: %d\n", filldest);
    printf("CharInfo.scan = %ld\n", CharInfo.scan);
#endif
/* SPC: Begin, Danny Lu, 3/29/91, Added */
/* 2Pt: Phlin, 4/29/91, Update */
/*  if ((CharInfo.bitWidth == 0) || (CharInfo.scan == 0)) {  */
    if ( CharInfo.bitWidth == 0 ) {
        if (!buildchar) {
              cache_info->bitmap = (gmaddr)NULL;
              cache_info->ref_x = 0;
              cache_info->ref_y = 0;
              cache_info->box_w = 0;
              cache_info->box_h = 0;
              bmap_extnt.ximin = -1;
              bmap_extnt.ximax = -1;
              bmap_extnt.yimin = -1;
              bmap_extnt.yimax = -1;
        }
        return;
    }
/* SPC: End, Danny Lu, 3/29/91 */

    save_cache_info = cache_info;
    cb_size = (ufix32)(cb_base + CB_MEMSIZE) - (ufix32)(cb_pos);

    if (filldest == F_TO_CACHE) {

          if (buildchar) { /* CIRL */
              Cache1.ref_x = - (int)CharInfo.lsx - 1 - ctm_dx; /* add int; @WIN */
              Cache1.ref_y = CharInfo.yMax - 1 - ctm_dy;
          }
          else {
              bmap_extnt.ximin = 0;
              bmap_extnt.ximax =  CharInfo.bitWidth;
              bmap_extnt.yimin = 0;
/* 2Pt: Begin, Phlin, 4/23/91
 *            bmap_extnt.yimax = CharInfo.scan + 1; */
              bmap_extnt.yimax = CharInfo.scan;
              if (bmap_extnt.yimax)
                  bmap_extnt.yimax--;    /*?????*/
/* 2Pt: End, Phlin, 4/23/91 */

              cache_info->ref_x = - (int)CharInfo.lsx - 1 - ctm_dx; /* add int; @WIN */
              cache_info->ref_y = CharInfo.yMax - 1 - ctm_dy;
          }
    }
    else { /* filldest == F_TO_PAGE */

        lmemcpy ((ubyte FAR *)(&Cache1), (ubyte FAR *)(cache_info), sizeof(struct Char_Tbl)); /*@WIN*/
        cache_info = &Cache1;

        moveto(F2L(ctm_tx), F2L(ctm_ty));

        cache_info->ref_x = (- (int)CharInfo.lsx - 1);  /* add int; @WIN */

        cache_info->ref_y = CharInfo.yMax - 1;
    }

    if ((filldest == F_TO_CACHE) && (!buildchar) ) {
#ifdef DJC //correction from history.log
          cb_size = cb_size / 2;

          //DJC add the alignment here so the middle is DWORD aligned as well
          //DJC
          cb_size = WORD_ALIGN(cb_size);


          cb_pos2 = cb_pos;
          cb_pos3 = cb_pos2 + cb_size;

        if (bWinTT) {                      // for Win31 truetype; @WINTT
#ifdef DJC
              /* GetGlyphOutline constants; from "windows.h" */
              #define GGO_METRICS        0
              #define GGO_BITMAP         1
              #define GGO_NATIVE         2
              static nCharCode = 65;
              unsigned long dwWidthHeight;

              dwWidthHeight = ShowGlyph (GGO_BITMAP,
                                         (char FAR *)cache_info->bitmap);
              cache_info->box_w = (fix16) (dwWidthHeight >> 16);
              cache_info->box_h = (fix16) (dwWidthHeight & 0x0ffffL);
#endif
              ; // DJC
        } else {
          BmIn.bitmap5 = (byte FAR *)cache_info->bitmap; /*@WIN*/
          BmIn.bitmap6 = cb_pos2;   /* suppose it is enough */
          BmIn.bitmap7 = cb_pos3;

          BmIn.bottom  = CharInfo.yMin;
          BmIn.top     = CharInfo.yMax;
          ret_code     = rc_FillChar(&BmIn, &BmOut);
          if (ret_code) {  ERROR(INVALIDFONT); return;  }

          cache_info->box_w = BmOut->rowBytes * 8;
          cache_info->box_h = BmOut->bounds.bottom - BmOut->bounds.top;
        }
#endif

//DJC from history.log, UPD009

          /* refer to bass\fscaler.c */
          int scans, top;
          char FAR * bitmap;
          /* cb_size = memorySize6 + memorySize7
             where,
             memorySize6 = scan * ((nYchanges + 2) * sizeof(int16) + sizeof(int16 FAR *));
             memorySize7 is fixed, since we band it in y-direction; x-dir is same
             so,
              scan = (cb_size - memorySize7) /
                     ((nYchanges+2) * sizeof(int16) + sizeof(int16 *));
          */
          /* turn off drop out control when memory is not enough */
          if (CharInfo.memorySize7 > (fix32)(cb_size -4096)) CharInfo.memorySize7 = 0;

          scans = (int)((cb_size - CharInfo.memorySize7) /
                      ((CharInfo.nYchanges+2) * sizeof(int16) + sizeof(int16 FAR *)));
          top = CharInfo.yMax;
          bitmap = (byte FAR *)cache_info->bitmap;

          BmIn.bitmap6 = cb_pos;
          BmIn.bitmap7 = CharInfo.memorySize7 ?
                         cb_pos + (cb_size - CharInfo.memorySize7) : 0L;
          do {
              BmIn.bitmap5 = bitmap;
              BmIn.top     = top;
              top -= scans;
              BmIn.bottom  = CharInfo.yMin > top ? CharInfo.yMin : top;
              ret_code     = rc_FillChar(&BmIn, &BmOut);
              if (ret_code != 0) {
#ifdef WRN_PSTODIB
                 printf("\nrc_FillChar returns error!!");
#endif
                 ERROR(INVALIDFONT);
                 return;
              }
              bitmap += BmOut->rowBytes * scans;
          } while (BmIn.bottom > CharInfo.yMin);

          cache_info->box_w = BmOut->rowBytes * 8;
          cache_info->box_h = CharInfo.yMax - CharInfo.yMin;
/* calculate memoryBase 5, 6 and 7 correctly; ----- End --- @WIN 7/24/92 */

        }


//DJC, end UPD009


#ifdef LITTLE_ENDIAN
          sptr=BmOut->baseAddr;
          /* @TT BEGIN move part of buffer which accurately be used
           *     in BASS to cache buffer rather than whole buffer
           *     D.S Tseng 01/30/91
           */
          swap_bitmap((ufix16 FAR *)sptr, BmOut->rowBytes, cache_info->box_h); /*@WIN*/
#endif
#ifdef  DBG
          for (i=0, sptr=BmOut->baseAddr; i<cache_info->box_h;
               i++, sptr+=BmOut->rowBytes, dptr+=(cache_info->box_w/8))
          {
              to_bitmap(sptr, BmOut->rowBytes);
          }
#endif
    }
    else { /* filldest == F_TO_PAGE || ((filldest == F_TO_CACHE) && (buildchar))*/

/* calculate memoryBase 5, 6 and 7 correctly; ----- Begin --- @WIN 7/24/92 */
#if 0
        cb_size = cb_size / 3;
        cb_size &= 0xfffffffe;       /* 2 bytes alignment */
        cb_pos2 = cb_pos  + cb_size;
        cb_pos3 = cb_pos2 + cb_size;
#endif
    {
        /* defined in bass\fscaler.c */
        #ifdef  DEBUGSTAMP
        #define STAMPEXTRA              4
        #else
        #define STAMPEXTRA              0
        #endif
        int scan, width6;
        ufix32 cmb_size;

        /* cb_size = memorySize5 + memorySize6 + memorySize7
           where,
           memorySize5 = (scan * byteWidth) + STAMPEXTRA;
           memorySize6 = scan * ((nYchanges + 2) * sizeof(int16) + sizeof(int16 *));
           memorySize7 is fixed;
           so,
            scan = (cb_size - memorySize7 - STAMPEXTRA) /
                    (byteWidth + ( (nYchanges+2) * sizeof(int16) + sizeof(int16 *)));
        */
        width6 = (CharInfo.nYchanges+2) * sizeof(int16) + sizeof(int16 FAR *);
        scan = (int)((cb_size - CharInfo.memorySize7 - STAMPEXTRA) /
               (CharInfo.byteWidth + width6));
        if(scan ==0) {
                printf("Fatal error, scan==0\n");
                scan++;
        }

        cb_size = (scan * CharInfo.byteWidth) + STAMPEXTRA;
        cmb_space(&cmb_size);
        if(cb_size > cmb_size) cb_size = cmb_size;
        cb_pos2 = cb_pos  + cb_size;
        cb_pos3 = cb_pos2 + (scan * width6);

        BmIn.bitmap5 = cb_pos;
        BmIn.bitmap6 = cb_pos2;
        BmIn.bitmap7 = cb_pos3;
    }
/* calculate memoryBase 5, 6 and 7 correctly; ----- End --- @WIN */

        band_size = (fix) (cb_size / CharInfo.byteWidth);       //@WIN
        n_bands   = CharInfo.scan / band_size;
        one_band  = CharInfo.scan % band_size;

        dptr = (byte FAR *)cache_info->bitmap; /*@WIN*/
        if (n_bands) {   /* Char too large; must band into pagemap/bitmap */
            for (iscan=CharInfo.yMax;n_bands>0; iscan -= band_size, n_bands--) {
                BmIn.bottom  = iscan - band_size;
                BmIn.top     = iscan;
                ret_code     = rc_FillChar(&BmIn, &BmOut);
                if (ret_code) {  ERROR(INVALIDFONT); return;  }
#ifdef LITTLE_ENDIAN
                    sptr=BmOut->baseAddr;
                    /* @TT BEGIN move part of buffer which accurately be used
                     *     in BASS to cache buffer rather than whole buffer
                     *     D.S Tseng 01/30/91
                     */
                    swap_bitmap((ufix16 FAR *)sptr, BmOut->rowBytes, band_size); /*@WIN*/
#endif
                if (filldest == F_TO_CACHE) { /* buildchar CIRL */

                    Cache1.bitmap = (gmaddr)((char FAR *)BmOut->baseAddr);/*@WIN*/
                    Cache1.box_w = (fix16)BmOut->rowBytes * 8;
                    Cache1.box_h = band_size;

                    fill_cache_cache(cache_info, &Cache1);
                    Cache1.ref_y -= band_size;
                }
                else {  /* F_TO_PAGE  (fill to page frame) */

                    if (BmOut->rowBytes % 2) {
                        /* padding bitmap */
                        for (i=0, sptr=BmOut->baseAddr, dptr=cb_pos;i<band_size;
                             i++, sptr+=BmOut->rowBytes, dptr+=(BmOut->rowBytes + 1))
                        {
                            for (j=0; j<BmOut->rowBytes; j++)
                                dptr[j] = sptr[j];
                            dptr[j] = 0;
#ifdef  DBG
                            to_bitmap(sptr, BmOut->rowBytes);
#endif
                        } /* for (i... */
                        cache_info->box_w = BmOut->rowBytes * 8 + 8;
                        cache_info->bitmap = (gmaddr)cb_pos;
                    }
                    else {
                        cache_info->box_w = BmOut->rowBytes * 8;
                        cache_info->bitmap = (gmaddr)((char FAR *)BmOut->baseAddr);/*@WIN*/
                    }
                    cache_info->box_h = band_size;
                    /* apply bitmap filling */
                    fill_shape(EVEN_ODD, F_FROM_CACHE, F_TO_CLIP);
                    cache_info->ref_y -= band_size;
                }
            } /* for (iscan... */
        }
        if (one_band) {
            BmIn.bottom  = CharInfo.yMin;
            BmIn.top     = CharInfo.yMin + one_band;
            ret_code     = rc_FillChar(&BmIn, &BmOut);
            if (ret_code) {  ERROR(INVALIDFONT); return;  }
#ifdef LITTLE_ENDIAN
                sptr=BmOut->baseAddr;
                /* @TT BEGIN move part of buffer which accurately be used
                 *     in BASS to cache buffer rather than whole buffer
                 *     D.S Tseng 01/30/91
                 */
                swap_bitmap((ufix16 FAR *)sptr, BmOut->rowBytes, one_band); /*@WIN*/
#endif
            if (filldest == F_TO_CACHE) { /* buildchar CIRL */

                Cache1.bitmap = (gmaddr)((char FAR *)BmOut->baseAddr);/*@WIN*/
                Cache1.box_w = (fix16)BmOut->rowBytes * 8;
                Cache1.box_h = one_band;

                fill_cache_cache(cache_info, &Cache1);
            }
            else {  /* F_TO_PAGE  (fill to page frame) */

                if (BmOut->rowBytes % 2) {
                    /* padding bitmap */
                    for (i=0, sptr=BmOut->baseAddr, dptr=cb_pos;
                         i<one_band;
                         i++, sptr+=BmOut->rowBytes, dptr+=(BmOut->rowBytes + 1))
                    {
                        for (j=0; j<BmOut->rowBytes; j++)
                            dptr[j] = sptr[j];
                        dptr[j] = 0;
#ifdef  DBG
                        to_bitmap(sptr, BmOut->rowBytes);
#endif
                    } /* for (i... */
                    cache_info->box_w = BmOut->rowBytes * 8 + 8;
                    cache_info->bitmap = (gmaddr)cb_pos;
                }
                else {
                    cache_info->box_w = BmOut->rowBytes * 8;
                    cache_info->bitmap = (gmaddr)((char FAR *)BmOut->baseAddr);/*@WIN*/
                }
                cache_info->box_h = one_band;
                /* apply bitmap filling */
                fill_shape(EVEN_ODD, F_FROM_CACHE, F_TO_CLIP);
            }
        }
    }
    if (buildchar && (filldest == F_TO_CACHE) ) { /* CIRL */
        CURPOINT_X += cache_info->adv_x;
        CURPOINT_Y += cache_info->adv_y;
    }
    cache_info = save_cache_info;
#ifdef  DBG
    printf("Exit ry_fill_shape()....\n");
#endif
    return;
} /* ry_fill_shape() */
#endif //DJC end complete replace



/* --------------------- End of ry_font.c ---------------------- */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\warning.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */

// DJC added global include
#include "psglobal.h"

#define    LINT_ARGS            /* @WIN */
#define    NOT_ON_THE_MAC       /* @WIN */
#define    KANJI                /* @WIN */
// DJC use command line #define    UNIX                 /* @WIN */
/*
 * --------------------------------------------------------------------
 *  File: WARNING.C                     09/08/88 created by You
 *
 *  Purpose:
 *      This file uniforms warning message format.
 *
 *  Revision History:
 *  1.10/12/88  You   - fix bug if the tailing message is NULL.
 *  2.10/19/88  You   - change warning format (see warning.h).
 *  3.11/21/88  You   - not to bell in warning().
 *    8/29/90; ccteng; change <stdio.h> to "stdio.h"
 * --------------------------------------------------------------------
 *  See WARNING.H about warning message format.
 * --------------------------------------------------------------------
 */

#define FUNCTION
#define DECLARE         {
#define BEGIN
#define END             }

#define GLOBAL
#define PRIVATE         static
#define REG             register


#include    "global.ext"

#include    "stdio.h"

#define     WARNING_INC
#include    "warning.h"


/* ............................ warning .............................. */

GLOBAL FUNCTION void            warning (major, minor, msg)
        ufix16                  major, minor;
        byte                    FAR msg[]; /*@WIN*/

  DECLARE
  BEGIN
    printf ("\nfatal error, %s (%X) -- %s !!\n",
                   major2name[major],
                   minor,
                   (msg==(byte FAR *)NULL)? "???" : msg); /*@WIN*/
  END


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\rtfpp.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */


// DJC added global include
#include "psglobal.h"



#define    LINT_ARGS            /* @WIN */
#define    NOT_ON_THE_MAC       /* @WIN */
#define    KANJI                /* @WIN */
// DJC use command line #define    UNIX                 /* @WIN */
/*
 ************************************************************************
 *
 *      File name:              RTFPP.C
 *      Function:               Building font dicts in run-time situation.
 *      Author:                 Kason Chang
 *      Date:                   18-Jun-1990
 *      Owner:                  Microsoft Inc.
 *      Function:    Building font dicts in run-time situation.
 *
 * revision history:
 * Date      Name     Comment
 *---------  -------  --------------------------------------------------
 * 7/10/90   ccteng   change FontBBox to be executable array
 *08/07/90   Kason    get rid of put_addr_to_tbl(), using fdata.bin and
 *                    fontdefs.h produced by fpptool. In SUN environment,
 *                    Data_Offset[] is preserved for reading in fdata.bin.
 * 9/19/90   ccteng   add op_readhexsfnt
 * 9/20/90   phlin    enable fe_data() module.
 *                    add judgement conditions of FontInfo in build_finfo().
 *11/02/90   dstseng  apply macro SWAPW, SWAPL while accessing SFNT data to
 *                    suit different byte order.
 *11/02/90   dstseng  @@SWAP add INTEL flag for byte swap issue.
 *12/05/90   kason    build CharStrings from 'post' table
 *                    clean out gabages , get rid of 'exit(1)'
 *01/10/91   kason    RE-write cd_sort() for removing duplicate keys
 *02/01/91   kason    Modify   op_readsfnt(),enco_cd_setup()
 *                    change str_dict type to new_str_dict ( the new_str_dict
 *                    struct definition is added in dictdata.h
 *03/08/91   kason    reduce VM usage, SVM flag
 *                    when call hash_id(), change "ubyte" to "byte"
 *03/15/91   dstseng  @@SWAP1 apply SWAPW, SWAPL for sfnts POST table.
 *03/27/91   kason    take away SIADD, ADD2ID ,CHECK_SFNT,
 *                    CPR_CD, CPR_DR,
 *03/27/91   dstseng  change flag INTEL to LITTLE_ENDIAN.
 *05/10/91   Phlin    add global variable EMunits. (Ref. GAW)
 *05/15/91   Kason    delete PlatformID and EncodingID in the font dict (DLF42)
 ************************************************************************
 */
/* JJJ Peter BEGIN 11/06/90 , Phlin add 3/08/91 */
#ifdef SETJMP_LIB
#include <setjmp.h>
#else
#include "setjmp.h"
#endif
/* JJJ Peter END 11/06/90 , Phlin add 3/08/91 */

#define FONTPREP_INC     /* for GEN_ROMFID in fntcache.ext */
#include <math.h>
#include <string.h>
#include "global.ext"
#include "graphics.h"
#include "stdio.h"
#include "fontdict.h"
//#include "..\..\..\bass\work\source\FSCdefs.h"        @WIN
//#include "..\..\..\bass\work\source\FontMath.h"     /* Phlin add 2/27/91 */
//#include "..\..\..\bass\work\source\sfnt.h"
//#include "..\..\..\bass\work\source\fnt.h"
//#include "..\..\..\bass\work\source\sc.h"
//#include "font.h"         /* for extern Data_Offset */
//#include "..\..\..\bass\work\source\FScaler.h"   /* Kason 11/07/90 */
//#include "..\..\..\bass\work\source\FSglue.h"
#include "..\bass\FSCdefs.h"
#include "..\bass\FontMath.h"     /* Phlin add 2/27/91 */
#include "..\bass\sfnt.h"
#include "..\bass\fnt.h"
#include "..\bass\sc.h"
#include "font.h"         /* for extern Data_Offset */
#include "..\bass\FScaler.h"   /* Kason 11/07/90 */
#include "..\bass\FSglue.h"
#include "rtfpp.h"
#include "dictdata.h"
#include "fntcache.ext"

/* external function for Dynamic Font Allocation; @DFA 7/9/92 */
#include   "wintt.h"

/* Kason 10/14/90 -- BASS procedure */
// extern int    sfnt_ComputeMapping() ; @WIN
int sfnt_ComputeMapping (fsg_SplineKey FAR *, uint16, uint16); /*add prototype; @WIN_BASS*/
//DJC extern uint16 sfnt_ComputeIndex0();
//DJC extern uint16 sfnt_ComputeIndex2();
//DJC extern uint16 sfnt_ComputeIndex4();
//DJC extern uint16 sfnt_ComputeIndex6();
//DJC extern uint16 sfnt_ComputeUnkownIndex();


uint16 sfnt_ComputeUnkownIndex (uint8 FAR * mapping, uint16 charCode);
uint16 sfnt_ComputeIndex0 (uint8 FAR * mapping, uint16 charCode);
uint16 sfnt_ComputeIndex2 (uint8 FAR * mapping, uint16 charCode);
uint16 sfnt_ComputeIndex4 (uint8 FAR * mapping, uint16 charCode);
uint16 sfnt_ComputeIndex6 (uint8 FAR * mapping, uint16 charCode);


// extern void   sfnt_DoOffsetTableMap(); @WIN
void FAR sfnt_DoOffsetTableMap (fsg_SplineKey FAR *); /*add prototype; @WIN_BASS*/
extern void   sfnt_Classify();
extern void   dummyReleaseSfntFrag(voidPtr); /*add prototype; @WIN_BASS*/
//extern void   *sfnt_GetTablePtr(); @WIN
voidPtr sfnt_GetTablePtr (fsg_SplineKey FAR *, sfnt_tableIndex, boolean); /*add prototype: @WIN_BASS*/

/* @@SWAP BEGIN 11/02/90 D.S. Tseng */
#ifdef LITTLE_ENDIAN
void copy_maxProfile();
#endif
/* @@SWAP END   11/02/90 D.S. Tseng */

#ifdef LINT_ARGS
fix                         init_build_fonts(void);
//static struct object_def    FAR *do_readsfnt(byte FAR *,byte FAR *,real32 FAR *,ufix32,real32); /*@WIN*/
static struct object_def    FAR *do_readsfnt(byte huge *,byte huge *,real32 FAR *,ufix32, float); /*@WIN*/
static ufix16               hash_id(byte FAR *); /*@WIN*/
static void                 cd_sorting(struct new_str_dict FAR *,ufix16 FAR *);
/* Kason @WIN*/
static bool                 enco_cd_setup(void); /* void, Kason 11/30/90 */
static ULONG_PTR            build_finfo(fix16,byte huge *,real32); /*@WIN*/
static void                 fe_data(byte FAR *); /*@WIN*/
static void                 sfntdata(ULONG_PTR, struct data_block FAR *); /*@WIN*/
/* static void                 SetupKey(fsg_SplineKey*, ufix32); */
void                        SetupKey(fsg_SplineKey FAR *, ULONG_PTR); /*@WIN_BASS*/
//static char                 FAR *GetSfntPiecePtr(long, long, long); /*@WIN*/
char                        FAR *GetSfntPiecePtr(long, long, long); /*@WIN*/
static int                  readsfnt(int);
static ufix32               scansfnt(ubyte huge *);  /* Kason 04-20-92 @WIN*/
static bool                 valid_sfnt(byte huge *);  /* Kason 04-20-92 @WIN*/
static ufix32               CalcTableChecksum( ufix32 FAR *, ufix32 ); /*@WIN*/
/*SVM
static byte                 *glyphidx2name(*sfnt_PostScriptInfo, ufix16 );
*/
static ufix16               glyphidx2name(sfnt_PostScriptInfo FAR *, ufix16 );
static fix16                computeFirstMapping(fsg_SplineKey FAR *); /*@WIN_BASS*/
static struct object_def    FAR *cmap2encoding(byte FAR *,fix,fix); /*@WIN*/
static byte                 FAR *chk_sfnt(struct object_def FAR *); /*@WIN*/
static struct object_def    FAR *setup_CharString(byte FAR *); /*@WIN*/
/*SVM, Kason 3/6/91*/
static void                 proc_hashid(void);

#else   /* LINT_ARGS */
fix                         init_build_fonts();
static struct object_def    *do_readsfnt();
static ufix16               hash_id();
static void                 cd_sorting();
static bool                 enco_cd_setup();  /* void, Kason 11/30/90 */
static ULONG_PTR            build_finfo();
static void                 fe_data();
static void                 sfntdata();
/* static void                 SetupKey(); */
void                        SetupKey();
//static char                 *GetSfntPiecePtr(); @WIN
char                 *GetSfntPiecePtr();
static int                  readsfnt();
static ufix32               scansfnt();   /* Kason 11/29/90 */
static bool                 valid_sfnt(); /* Kason 12/04/90 */
static ufix32               CalcTableChecksum(); /* Kason 12/04/90 */
/*SVM
static byte                 *glyphidx2name();
*/
static ufix16               glyphidx2name();
static fix16                computeFirstMapping();
static struct object_def    *cmap2encoding();
static byte                 *chk_sfnt();
static struct object_def    *setup_CharString();
/*SVM, Kason 3/6/91*/
static void                 proc_hashid();

#endif  /* LINT_ARGS */

/* Kason 11/14/90 , global variable area*/
int                         useglyphidx;
int                         EMunits; /* GAW */
bool                        builtin_state=TRUE;
ufix16                      id_space ; /*SVM*/

/* @PROFILE @WIN */
void SetupFontDefs(void);
float SFNT_MATRIX[] =  {(float)0.001,   (float)0.0,  (float)0.0,
                        (float)0.001,   (float)0.0,  (float)0.0};

/***********************************************************************
** TITLE:      init_build_fonts()                Date:   06/18/90
**
** FUNCTION:   building up FontDiretctoy in font_init()
**
***********************************************************************/

static struct object_def       a_font_dict;
static byte    FAR *ftname ;       /* Kason 11/30/90 , add 'static'@WIN*/
/*SVM, Kason 3/6/91 */
static ufix16   id_notdef, id_apple ;
static ufix16   chset_hashid[SFNTGLYPHNUM];
//DJC static ufix32   cd_addr_ary[NO_BUILTINFONT];

//DJC use new global defined in ONE spot
static ufix32   cd_addr_ary[MAX_INTERNAL_FONTS];

static ufix16   fontidx=0 ;

fix    init_build_fonts()
{
  font_data                FAR *each_font; /*@WIN*/

  struct object_def        FAR *font_dict, l_obj;   /* l_obj added Jun-24,91 PJ @WIN*/
  ufix                     i, n_fd=0;
  struct dict_content_def  far *fd_obj;

printf("\n");           /* ??? */
#ifdef DBGfpp
   printf("entering init_build_fonts()......\n");
//DJC   printf("NO_BUILTINFONT=%d\n",NO_BUILTINFONT);
   printf("NO_BUILTINFONT=%d\n", MAX_INTERNAL_FONTS);

#endif

/* get memory for FtDir */
#ifdef DBGfpp
   printf("get memory for FtDir!\n");
#endif

   /* Begin: Jun-07,91 PJ */
   /*
   FontDir=(struct dict_head_def far *) alloc_vm((ufix32)DICT_SIZE(NO_FD));
    if ( FontDir== (struct dict_head_def far *)NULL )
       {
         return  0 ;
       }
   fd_obj=(struct dict_content_def  far *)(FontDir+1);

|* FontDirectory initial *|

    for(i=0; i<NO_FD; i++) {
        TYPE_SET(&(fd_obj[i].k_obj), NAMETYPE);
        ATTRIBUTE_SET(&(fd_obj[i].k_obj), LITERAL);
        ROM_RAM_SET(&(fd_obj[i].k_obj), ROM);
        LEVEL_SET(&(fd_obj[i].k_obj), current_save_level);
        ACCESS_SET(&(fd_obj[i].k_obj), READONLY);
        LENGTH(&(fd_obj[i].k_obj)) = 0;

        TYPE_SET(&(fd_obj[i].v_obj), DICTIONARYTYPE);
        ATTRIBUTE_SET(&(fd_obj[i].v_obj), LITERAL);
        ROM_RAM_SET(&(fd_obj[i].v_obj), ROM);
        LEVEL_SET(&(fd_obj[i].v_obj), current_save_level);
        ACCESS_SET(&(fd_obj[i].v_obj), READONLY);
    }
    */

    if(! create_dict(&l_obj, (ufix16)NO_FD) ) {
        return 0;
    }
    FontDir=(struct dict_head_def huge *) VALUE(&l_obj); /*@WIN 04-20-92*/
    fd_obj=(struct dict_content_def huge *)(FontDir+1); /*@WIN 04-20-92*/
   /* End: Jun-07,91 PJ */

/*SVM, Kason 3/6/91 */
/*get hashid of the standard char set */
  proc_hashid();

/* setup Encoding & CharStrings objects */

  if ( !enco_cd_setup() )
     {
       free_vm( (byte huge *)FontDir ) ; /*@WIN 04-20-92*/
       return  0 ;
     }

  /* setup fontdefs table according to profile "tumbo.ini" @PROFILE; @WIN */
  SetupFontDefs();

  for(i=0; (fix)i<built_in_font_tbl.num_entries; i++)   //@WIN
     {
      int nSlot;                                                //@DFA

      /*SVM, Kason 3/8/91*/
      fontidx = (ufix16)i;

      each_font=&built_in_font_tbl.fonts[i];

      /* read in font data before do_readsfnt; @DFA @WIN */
      each_font->data_addr = ReadFontData(i, (int FAR*)&nSlot);

      if( !(each_font->data_addr==(byte FAR *)NULL) ) /*@WIN*/
       {

        switch ((fix)each_font->font_type)
           {
             case ROYALTYPE:
                      font_dict= do_readsfnt((byte huge *)      /*04-20-92*/
                                  each_font->data_addr, (byte huge *)
                                  each_font->name ,
                                  each_font->matrix,
                                  each_font->uniqueid ,
                                  each_font->italic_ang ) ;

                      if ( font_dict!=(struct object_def FAR *)NULL ) { /*@WIN*/
                         /* register this font into FontDirectory */
                         VALUE(&(fd_obj[n_fd].k_obj))=(ufix32)hash_id((byte FAR *) /*@WIN*/
                                                              ftname);

                         LENGTH(&(fd_obj[n_fd].v_obj)) = (fix16)NO_FDICT;
                         VALUE(&(fd_obj[n_fd].v_obj)) =VALUE(font_dict);
                         DFONT_SET( (struct dict_head_def FAR *)VALUE(font_dict),TRUE ); /*@WIN*/

                         /* Begin: Jun-07,91 PJ */
                         TYPE_SET(&(fd_obj[n_fd].k_obj), NAMETYPE);
                         ATTRIBUTE_SET(&(fd_obj[n_fd].k_obj), LITERAL);
                         ROM_RAM_SET(&(fd_obj[n_fd].k_obj), ROM);
                         LEVEL_SET(&(fd_obj[n_fd].k_obj), current_save_level);
                         ACCESS_SET(&(fd_obj[n_fd].k_obj), READONLY);
                         LENGTH(&(fd_obj[n_fd].k_obj)) = 0;

                         TYPE_SET(&(fd_obj[n_fd].v_obj), DICTIONARYTYPE);
                         ATTRIBUTE_SET(&(fd_obj[n_fd].v_obj), LITERAL);
                         ROM_RAM_SET(&(fd_obj[n_fd].v_obj), ROM);
                         LEVEL_SET(&(fd_obj[n_fd].v_obj), current_save_level);
                         ACCESS_SET(&(fd_obj[n_fd].v_obj), READONLY);
                         /* End: Jun-07,91 PJ */

                         /* register font_dict in ActiveFont[] @DFA --Begin --*/
                         if (each_font->uniqueid < WINFONT_UID)
                         {
                             struct object_def FAR *b1, my_obj;
                             ATTRIBUTE_SET(&my_obj, LITERAL);
                             get_name(&my_obj, "sfnts", 5, TRUE);
                             get_dict(&(fd_obj[n_fd].v_obj), &my_obj, &b1);
                             SetFontDataAttr(nSlot, (struct object_def FAR *)
                                                    VALUE(b1));
                         }
                         /* register font_dict in ActiveFont[] @DFA ---End--- */

                         n_fd++;

                      }/* if */

                      break;

             default:
                      break;
           }  /* switch */

         }   /* if */

     }   /* for */

  if( n_fd==0) {
       printf("NO font dictionary is created !!! \n");
       free_vm( (byte huge *)FontDir ) ; /*@WIN 04-20-92*/
       return  0 ;
  } /* if */

  /* FontDirectory head information */
  DACCESS_SET(FontDir, READONLY);
  DPACK_SET(FontDir, FALSE);
  DFONT_SET(FontDir, FALSE);
  DROM_SET(FontDir, TRUE);
  FontDir->actlength = (fix16)n_fd;

  /* Kason 11/29/90 ,it will be download state afterwards */
  builtin_state=FALSE;

#ifdef DBGfpp
printf("n_fd=%d\n",n_fd);
printf("leaving init_build_fonts() \n");
#endif

  return((fix)1);

}    /* init_build_fonts */


static struct data_block sfnt_items; /* Kason 12/01/90 */

/***********************************************************************
** TITLE:      do_readsfnt()                Date:   06/18/90
**
** FUNCTION:   building up a font dictionary
**
***********************************************************************/
// ???@WIN; void the waring message from C6.0
// static struct object_def FAR *do_readsfnt(dataaddr,fname ,fmatrix,uid,angle) /*@WIN*/
// byte    FAR *dataaddr;   /*@WIN*/
// byte    FAR *fname ;     /*@WIN*/
// real32  FAR *fmatrix;    /*@WIN*/
// ufix32  uid;
// real32  angle ;
static struct object_def FAR *do_readsfnt(
byte    huge *dataaddr,  /*@WIN 04-20-92*/
byte    huge *fname,     /*@WIN 04-20-92*/
real32  FAR *fmatrix,    /*@WIN*/
ufix32  uid,
real32  angle)
{
   struct object_def huge   *ar_obj, huge *sfnt_obj; /*@WIN 04-20-92*/
   struct dict_head_def huge *a_font;           /*@WIN 04-20-92*/
   struct dict_content_def huge *ft_obj;        /*@WIN 04-20-92*/
   ufix16                  n_ft, i,len,no_block;
   sfnt_OffsetTable FAR *table = (sfnt_OffsetTable FAR *)dataaddr; /*@WIN*/
   sfnt_DirectoryEntry FAR *offset_len=table->table; /*@WIN*/
   ufix32                  datasize, maxOffset ;
   ufix16                  maxOffInd, no_table;
   byte                    huge *str ; /*@WIN 04-20-92*/


#ifdef DBGfpp
 if ( fname == (byte FAR *) NULL ) /*@WIN*/
    printf(" FONTNAME==NULL \n");
 else
    printf("--------------FONTNAME=%s---------------\n",fname);
#endif

/* Kason 11/08/90 , Check the validness of sfnt data */

   if (!valid_sfnt(dataaddr) ) {
      ERROR(INVALIDFONT);
      return ((struct object_def FAR *)NULL); /*@WIN*/
   }/*if*/

/* Kason 11/30/90  */
   fe_data((byte FAR *)dataaddr);       /*@WIN 04-20-92*/

/* get memory for fontdict */
#ifdef DBGfpp
   printf("get memory for fontdict!\n");
#endif
   a_font=(struct dict_head_def huge *)alloc_vm( (ufix32)DICT_SIZE(NO_FDICT) );
    if ( a_font== (struct dict_head_def huge *)NULL )   /*@WIN 04-20-92*/
       {
         return ( (struct object_def FAR *)NULL ) ; /*@WIN*/
       }
   ft_obj=(struct dict_content_def huge *)(a_font+1);   /*@WIN 04-20-92*/

/* font dictionary initial */
#ifdef DBGfpp
   printf("font dictionary initial!\n");
#endif
    for(i=0; i<NO_FDICT; i++) {
        TYPE_SET(&(ft_obj[i].k_obj), NAMETYPE);
        ATTRIBUTE_SET(&(ft_obj[i].k_obj), LITERAL);
        ROM_RAM_SET(&(ft_obj[i].k_obj), ROM);
        LEVEL_SET(&(ft_obj[i].k_obj), current_save_level);
        ACCESS_SET(&(ft_obj[i].k_obj), READONLY);
        LENGTH(&(ft_obj[i].k_obj)) = 0;

        ATTRIBUTE_SET(&(ft_obj[i].v_obj), LITERAL);
        ROM_RAM_SET(&(ft_obj[i].v_obj), ROM);
        LEVEL_SET(&(ft_obj[i].v_obj), current_save_level);
        ACCESS_SET(&(ft_obj[i].v_obj), READONLY);
    }

    n_ft=0;

/* FontType */
#ifdef DBGfpp
   printf("Process FontType!! \n");
#endif
    VALUE(&(ft_obj[n_ft].k_obj)) = (ufix32)hash_id((byte FAR *)FontType); /*@WIN*/

    TYPE_SET(&(ft_obj[n_ft].v_obj), INTEGERTYPE);
    LENGTH(&(ft_obj[n_ft].v_obj)) = 0;
    VALUE(&(ft_obj[n_ft].v_obj)) = (ufix32)ROYALTYPE;
    n_ft++;

/* PaintType */
#ifdef DBGfpp
   printf("Process PaintType!! \n");
#endif
    VALUE(&(ft_obj[n_ft].k_obj)) = (ufix32)hash_id((byte FAR *) PaintType); /*@WIN*/

    TYPE_SET(&(ft_obj[n_ft].v_obj), INTEGERTYPE);
    LENGTH(&(ft_obj[n_ft].v_obj)) = 0;
    VALUE(&(ft_obj[n_ft].v_obj)) = (ufix32)PAINTTYPE;
    n_ft++;

/* UniqueID */
#ifdef DBGfpp
   printf("Process UniqueID!! \n");
#endif
   if ( uid != (ufix32) 0 )
    {
    VALUE(&(ft_obj[n_ft].k_obj)) = (ufix32)hash_id((byte FAR *)UniqueID); /*@WIN*/

    TYPE_SET(&(ft_obj[n_ft].v_obj), INTEGERTYPE);
    LENGTH(&(ft_obj[n_ft].v_obj)) = 0;
    VALUE(&(ft_obj[n_ft].v_obj)) = (ufix32)uid;
    n_ft++;
    }
/* Kason 10/21/90 */
   else {
    VALUE(&(ft_obj[n_ft].k_obj)) = (ufix32)hash_id((byte FAR *)UniqueID); /*@WIN*/

    TYPE_SET(&(ft_obj[n_ft].v_obj), INTEGERTYPE);
    LENGTH(&(ft_obj[n_ft].v_obj)) = 0;
    VALUE(&(ft_obj[n_ft].v_obj)) = (ufix32)(sfnt_items.dload_uid & 0x00ffffff);
    n_ft++;
   }


/* FontMatrix */
#ifdef DBGfpp
   printf("Process FontMatrix!! \n");
#endif
    ar_obj=(struct object_def huge *)alloc_vm((ufix32)ARRAY_SIZE(6));
    if ( ar_obj== (struct object_def huge *)NULL )      /*@WIN 04-20-92*/
       {
         free_vm( (byte huge *)a_font ) ; /*@WIN 04-20-92*/
         return ( (struct object_def FAR *)NULL ) ; /*@WIN*/
       }
    for(i=0; i<6; i++) {
        TYPE_SET(&(ar_obj[i]), REALTYPE);
        ATTRIBUTE_SET(&(ar_obj[i]), LITERAL);
        ROM_RAM_SET(&(ar_obj[i]), ROM);
        LEVEL_SET(&(ar_obj[i]), current_save_level);
        ACCESS_SET(&(ar_obj[i]), READONLY);
        LENGTH(&(ar_obj[i])) = 0;
    }

    if ( fmatrix==(real32 FAR *)NULL ) /*@WIN*/
         fmatrix = SFNT_MATRIX ;
    for (i=0; i < 6; i++) {
        VALUE(&ar_obj[i]) = F2L(fmatrix[i]);
    }

    VALUE(&(ft_obj[n_ft].k_obj)) = (ufix32)hash_id((byte FAR *) FontMatrix); /*@WIN*/

    TYPE_SET(&(ft_obj[n_ft].v_obj), ARRAYTYPE);
    LENGTH(&(ft_obj[n_ft].v_obj)) = 6;
    VALUE(&(ft_obj[n_ft].v_obj)) = (ULONG_PTR) ar_obj ;
    n_ft++;

/* FontName */
#ifdef DBGfpp
   printf("Process FontName!! \n");
#endif

    VALUE(&(ft_obj[n_ft].k_obj)) = (ufix32)hash_id((byte FAR *) FontName); /*@WIN*/

    TYPE_SET(&(ft_obj[n_ft].v_obj), NAMETYPE);
    LENGTH(&(ft_obj[n_ft].v_obj)) = 0;
    if ( fname == ( byte huge *) NULL ) /*@WIN 04-20-92*/
       {
         /* Kason 11/29/90 */
         if (Item4FontInfo1[FontName_idx].string[0]=='\0' ) {
             str= (byte huge *) alloc_vm ( (ufix32) (11)  ) ; /*@WIN 04-20-92*/
             /**** Kason 11/21/90 ****/
               if ( str==(byte huge *)NULL ) { /*@WIN 04-20-92*/
                    free_vm ( (byte huge *)a_font ) ; /*@WIN 04-20-92*/
                    return ( (struct object_def FAR *)NULL ) ; /*@WIN*/
               }
             lstrcpy(str,(char FAR *)"NOfontName");     /*@WIN*/
         }
         else {
             len= (fix16)strlen(Item4FontInfo1[FontName_idx].string);
             str= (byte huge *) alloc_vm ( (ufix32) (len+1)  ) ; /*@WIN 04-20-92*/
             /**** Kason 11/21/90 ****/
               if ( str==(byte huge *)NULL ) { /*@WIN 04-20-92*/
                    free_vm ( (byte huge *)a_font ) ; /*@WIN 04-20-92*/
                    return ( (struct object_def FAR *)NULL ) ; /*@WIN*/
               }
             lstrcpy(str, Item4FontInfo1[FontName_idx].string); /*@WIN*/
         }/* if */
         fname = str ;
       }/* if */
    ftname=fname    ;   /* for FontDirectory font name */
#ifdef DBGfpp
    printf("FontName=%s\n",fname );
#endif
    VALUE(&(ft_obj[n_ft].v_obj)) = (ufix32)hash_id(fname) ; /*@WIN 04-20-92*/

    n_ft++;

/* FID  */
#ifdef DBGfpp
   printf("Process FID!! \n");
#endif
   if (uid != (ufix32) 0 )
    {
    VALUE(&(ft_obj[n_ft].k_obj)) = (ufix32)hash_id((byte FAR *) FID); /*@WIN*/

    TYPE_SET(&(ft_obj[n_ft].v_obj), FONTIDTYPE);
    ACCESS_SET(&(ft_obj[n_ft].v_obj), NOACCESS);
    LENGTH(&(ft_obj[n_ft].v_obj)) = 0;
    VALUE(&(ft_obj[n_ft].v_obj)) = (ufix32) GEN_ROMFID( ROYALTYPE, uid );
    n_ft++;
    }

/* sfnts  */
#ifdef DBGfpp
   printf("Process sfnts!! \n");
#endif

        /* @@SWAP BEGIN 11/02/90 D.S. Tseng */
        no_table=(ufix16)SWAPW(table->numOffsets);
        /* @@SWAP END   11/02/90 D.S. Tseng */
#ifdef DBGfpp
        printf("no_table=%u\n",no_table);
#endif
        for (i = 0, maxOffInd = 0, maxOffset = 0; i < no_table; i++)
                if ((ufix32)SWAPL(offset_len[i].offset) > maxOffset)
                     {
                        maxOffset = (ufix32)SWAPL(offset_len[i].offset);
                        maxOffInd = i;
                     }
        datasize = maxOffset + (ufix32)SWAPL(offset_len[maxOffInd].length);
       no_block=(ufix16)ceil ( (double)((double)datasize / (double)SFNT_BLOCK_SIZE) )  ;
#ifdef DBGfpp /* ccteng; get datasize */
       printf("sfnt data name=%s size= %lu\n",fname,datasize);
       printf(" no_block=%u\n",no_block );
#endif

    sfnt_obj=(struct object_def huge *)alloc_vm((ufix32)ARRAY_SIZE(no_block));
    if ( sfnt_obj== (struct object_def huge *)NULL )    /* 04-02-92 */
       {
         free_vm ( (byte huge *)a_font ) ; /*@WIN 04-20-92*/
         return ( (struct object_def FAR *)NULL ) ; /*@WIN*/
       }
      for (i = 0; i < no_block; i++)
       {
        TYPE_SET(&sfnt_obj[i], STRINGTYPE);
        ATTRIBUTE_SET(&sfnt_obj[i], LITERAL);
        ROM_RAM_SET(&sfnt_obj[i], ROM);
        ACCESS_SET(&sfnt_obj[i], NOACCESS);
        LEVEL_SET(&sfnt_obj[i], current_save_level);

// DJC == unsigned/signed warning???        if ( (i+1)==no_block )
        if ( (ufix16)(i+1) == no_block )
           {
              LENGTH(&sfnt_obj[i]) = (ufix16) (datasize- i*SFNT_BLOCK_SIZE );
           }
        else
           {
              LENGTH(&sfnt_obj[i]) = (ufix16) (SFNT_BLOCK_SIZE );
           }
        VALUE(&sfnt_obj[i])  = (ULONG_PTR) (dataaddr+i*SFNT_BLOCK_SIZE );
       }

      VALUE(&(ft_obj[n_ft].k_obj)) = (ufix32)hash_id((byte FAR *) sfnts); /*@WIN*/

      TYPE_SET(&(ft_obj[n_ft].v_obj), ARRAYTYPE);
      LENGTH(&(ft_obj[n_ft].v_obj)) = (fix16)no_block;
      VALUE(&(ft_obj[n_ft].v_obj)) = (ULONG_PTR) sfnt_obj ;
      n_ft++;

/* FontBBox */
#ifdef DBGfpp
   printf("Process FontBBox!! \n");
#endif
    ar_obj=(struct object_def huge *)alloc_vm((ufix32)ARRAY_SIZE(4)); /*@WIN*/
    if ( ar_obj== (struct object_def huge *)NULL )      /* 04-02-92 */
       {
         free_vm ( (byte huge *)a_font ) ; /*@WIN 04-20-92*/
         return ( (struct object_def FAR *)NULL ) ; /*@WIN*/
       }
    for(i=0; i<4; i++) {
        TYPE_SET(&(ar_obj[i]), INTEGERTYPE);
        ATTRIBUTE_SET(&(ar_obj[i]), LITERAL);
        ROM_RAM_SET(&(ar_obj[i]), ROM);
        LEVEL_SET(&(ar_obj[i]), current_save_level);
        ACCESS_SET(&(ar_obj[i]), READONLY);
        LENGTH(&(ar_obj[i])) = 0;
    }

/* Kason 12/01/90, get FontBBox from sfnt_item */
    VALUE(&ar_obj[0]) = (ufix32)sfnt_items.llx ;
    VALUE(&ar_obj[1]) = (ufix32)sfnt_items.lly ;
    VALUE(&ar_obj[2]) = (ufix32)sfnt_items.urx ;
    VALUE(&ar_obj[3]) = (ufix32)sfnt_items.ury ;


    VALUE(&(ft_obj[n_ft].k_obj)) = (ufix32)hash_id((byte FAR *) FontBBox); /*@WIN*/

    TYPE_SET(&(ft_obj[n_ft].v_obj), ARRAYTYPE);
    ATTRIBUTE_SET(&(ft_obj[n_ft].v_obj), EXECUTABLE);
    LENGTH(&(ft_obj[n_ft].v_obj)) = (fix16)4;
    VALUE(&(ft_obj[n_ft].v_obj)) = (ULONG_PTR) ar_obj ;
    n_ft++;

/* Encoding */
#ifdef DBGfpp
   printf("Process Encoding!! \n");
#endif
    VALUE(&(ft_obj[n_ft].k_obj)) = (ufix32)hash_id((byte FAR *) Encoding); /*@WIN*/

    TYPE_SET(&(ft_obj[n_ft].v_obj), ARRAYTYPE);
    LENGTH(&(ft_obj[n_ft].v_obj)) = 256;

/* take out non-UGL mapping, since it may arouse further problems */
#if 0
    /* select encoding:  MS non-UGL code, then PS encoding; @WIN; @UGL */
    {
      ufix32 ce;
      struct object_def FAR *ce_p;      /*@WIN*/
      ce_p = cmap2encoding((byte FAR *)dataaddr, 3, 0);
      if ( ce_p != (struct object_def FAR *)NULL ) {
          ce = (ufix32)VALUE(ce_p);
          VALUE(&(ft_obj[n_ft].v_obj)) = ce ;
      } else {  /* otherwise, use PS encoding */
          if(uid<WINFONT_UID && !lstrcmp(fname,(char FAR *)"Symbol") ) /*@WIN*/
                VALUE(&(ft_obj[n_ft].v_obj)) = (ufix32) ((char FAR *)en_obj[SYM_IDX]);
          else if (uid<WINFONT_UID && !lstrcmp(fname,(char FAR *)"ZapfDingbats") ) /*@WIN*/
                VALUE(&(ft_obj[n_ft].v_obj)) = (ufix32)((char FAR *)en_obj[ZAP_IDX]);
          else
                VALUE(&(ft_obj[n_ft].v_obj)) = (ufix32)((char FAR *)en_obj[STD_IDX]);
      }
    }
#endif
#ifdef DJC //this is the original code
    if(builtin_state)
          if(uid<WINFONT_UID && !lstrcmp(fname,(char FAR *)"Symbol") ) /*@WIN*/
                VALUE(&(ft_obj[n_ft].v_obj)) = (ufix32) ((char FAR *)en_obj[SYM_IDX]);
          else if (uid<WINFONT_UID && !lstrcmp(fname,(char FAR *)"ZapfDingbats") ) /*@WIN*/
                VALUE(&(ft_obj[n_ft].v_obj)) = (ufix32)((char FAR *)en_obj[ZAP_IDX]);
          else
                VALUE(&(ft_obj[n_ft].v_obj)) = (ufix32)((char FAR *)en_obj[STD_IDX]);
    else /* download state , use the first CMAP encoding */
       { /*SVM*/
         ufix32 ce;
         struct object_def FAR *ce_p;
         ce_p = cmap2encoding((byte FAR *)dataaddr,-1,-1) ;     /*04-20-92*/
         if ( ce_p == (struct object_def FAR *)NULL )
             return ( (struct object_def FAR *)NULL );
         ce = (ufix32)VALUE(ce_p);
         VALUE(&(ft_obj[n_ft].v_obj)) = ce ;
       }
#endif
#ifdef DJC // this was fixed again in UPD030
    //DJC fix from history.log UPD006
    {
      ufix32 ce;
      struct object_def FAR *ce_p;      /*@WIN*/
      ce_p = cmap2encoding((byte FAR *)dataaddr, 3, 0);
      if ( ce_p != (struct object_def FAR *)NULL ) {
          ce = (ufix32)VALUE(ce_p);
          VALUE(&(ft_obj[n_ft].v_obj)) = ce ;
      } else {  /* otherwise, use PS encoding */
          if( !lstrcmp(fname,(char FAR *)"Symbol") )       /*@WIN*/
                VALUE(&(ft_obj[n_ft].v_obj)) = (ufix32) ((char FAR *)en_obj[SYM_IDX]);
          else if (!lstrcmp(fname,(char FAR *)"ZapfDingbats") ) /*@WIN*/
                VALUE(&(ft_obj[n_ft].v_obj)) = (ufix32)((char FAR *)en_obj[ZAP_IDX]);
          else
                VALUE(&(ft_obj[n_ft].v_obj)) = (ufix32)((char FAR *)en_obj[STD_IDX]);
      }
    }
    //DJC end fix UPD006
#endif
//DJC fix from history.log UPD030
    if(builtin_state)
          if(uid<WINFONT_UID && !lstrcmp(fname,(char FAR *)"Symbol") ) /*@WIN*/
                VALUE(&(ft_obj[n_ft].v_obj)) = (ULONG_PTR) ((char FAR *)en_obj[SYM_IDX]);
          else if (uid<WINFONT_UID && !lstrcmp(fname,(char FAR *)"ZapfDingbats") ) /*@WIN*/
                VALUE(&(ft_obj[n_ft].v_obj)) = (ULONG_PTR)((char FAR *)en_obj[ZAP_IDX]);
          else
                VALUE(&(ft_obj[n_ft].v_obj)) = (ULONG_PTR)((char FAR *)en_obj[STD_IDX]);
    else /* download state , use the first CMAP encoding */
       { /*SVM*/
         ufix32 ce;
         struct object_def FAR *ce_p;
         ce_p = cmap2encoding((byte FAR *)dataaddr,-1,-1) ;     /*04-20-92*/
         if ( ce_p == (struct object_def FAR *)NULL )
             return ( (struct object_def FAR *)NULL );
         ce = (ufix32)VALUE(ce_p);
         VALUE(&(ft_obj[n_ft].v_obj)) = ce ;
       }

// DJC, end fix for UPD030

    n_ft++;

#ifdef ADD2ID /*DLF42*/
#ifdef DBGfpp
   printf("Process PlatformID & EncodingID!! \n");
#endif
    VALUE(&(ft_obj[n_ft].k_obj)) = (ufix32)hash_id((byte FAR *) "PlatformID"); /*@WIN*/

    TYPE_SET(&(ft_obj[n_ft].v_obj), INTEGERTYPE);
    LENGTH(&(ft_obj[n_ft].v_obj)) = 0;
    VALUE(&(ft_obj[n_ft].v_obj)) = (ufix32)1; /*MAC*/
    n_ft++;

    VALUE(&(ft_obj[n_ft].k_obj)) = (ufix32)hash_id((byte FAR *) "EncodingID"); /*@WIN*/

    TYPE_SET(&(ft_obj[n_ft].v_obj), INTEGERTYPE);
    LENGTH(&(ft_obj[n_ft].v_obj)) = 0;
    VALUE(&(ft_obj[n_ft].v_obj)) = (ufix32)0; /*MAC*/
    n_ft++;
#endif /*ADD2ID,DLF42*/


/* CharStrings */
#ifdef DBGfpp
   printf("Process CharStrings!! \n");
#endif
    VALUE(&(ft_obj[n_ft].k_obj)) = (ufix32)hash_id((byte FAR *) CharStrings); /*@WIN*/

    TYPE_SET(&(ft_obj[n_ft].v_obj), DICTIONARYTYPE);
    ACCESS_SET(&(ft_obj[n_ft].v_obj), NOACCESS);
    LENGTH(&(ft_obj[n_ft].v_obj)) = (fix16)NO_CD;

  { /*SVM, Kason 3/8/91*/
    ufix32  cd;
    struct  object_def FAR * cd_p; /*@WIN*/
    font_data FAR *each_font; /*@WIN*/

    each_font=&built_in_font_tbl.fonts[fontidx];
    if ( (each_font->orig_font_idx == -1)||(!builtin_state) ){ /*PSF font*/
       cd_p = setup_CharString((byte FAR *)dataaddr) ;     /* or download font */
       if ( cd_p == (struct object_def FAR *)NULL ) /*@WIN*/
            return ( (struct object_def FAR *)NULL ); /*@WIN*/
       cd = (ufix32)VALUE(cd_p) ;
       VALUE(&(ft_obj[n_ft].v_obj)) = cd ;
       if (builtin_state)
          cd_addr_ary[fontidx] = cd ;
    } else {  /*PSG font*/
       cd = cd_addr_ary[each_font->orig_font_idx] ;
       if ( cd == (ufix32)0 ){
            printf("WARNING!! Wrong PSG assign(%d,%d) !!!\n",fontidx,each_font->orig_font_idx);
            return ( (struct object_def FAR *)NULL ); /*@WIN*/
       }/*if*/
       VALUE(&(ft_obj[n_ft].v_obj)) = cd_addr_ary[each_font->orig_font_idx] ;
    }/*if*/
    useglyphidx = TRUE ;

  }/*SVM*/

    n_ft++;

/* FontInfo */
#ifdef DBGfpp
   printf("Process FontInfo!! \n");
#endif
    VALUE(&(ft_obj[n_ft].k_obj)) = (ufix32)hash_id((byte FAR *) FontInfo); /*@WIN*/

    TYPE_SET(&(ft_obj[n_ft].v_obj), DICTIONARYTYPE);
    LENGTH(&(ft_obj[n_ft].v_obj)) = (fix16)NO_FINFO;
    if ( ! ( VALUE(&(ft_obj[n_ft].v_obj)) = build_finfo( (fix16)ROYALTYPE,
                                                  fname, angle ) )  )
       {
         free_vm( (byte huge *)a_font ) ;         /*@WIN 04-20-92*/
         return ( (struct object_def FAR *)NULL ) ; /*@WIN*/
       }

    ++n_ft;

/* dict head data */
    DACCESS_SET(a_font, READONLY);
    DPACK_SET(a_font, FALSE);
    DFONT_SET(a_font, FALSE); /* Kason 11/30/90, TRUE->FALSE */
    DROM_SET(a_font, TRUE);
    a_font->actlength = (fix16)n_ft;

/* returned object */
    TYPE_SET(&(a_font_dict), DICTIONARYTYPE);
    ATTRIBUTE_SET(&(a_font_dict), LITERAL);
    ROM_RAM_SET(&(a_font_dict), ROM);
    LEVEL_SET(&(a_font_dict), current_save_level);
    ACCESS_SET(&(a_font_dict), READONLY);

    LENGTH(&(a_font_dict)) = (fix16)NO_FDICT;
    VALUE(&(a_font_dict)) = (ULONG_PTR) a_font;

#ifdef DBGfpp
   printf("leaving do_readsfnt()..... \n");
#endif

    return (&(a_font_dict));


}    /*  do_readsfnt() */



/***********************************************************************
** TITLE:      hash_id()                Date:   06/18/90
**
** FUNCTION:   Get the name hash id
**
***********************************************************************/
static ufix16     hash_id(c)
byte   FAR *c; /*@WIN*/
{
    fix16   id;

 /*SVM
  * name_to_id(c, (ufix16)strlen(c), &id, (bool8) TRUE);
  */
    name_to_id(c, (ufix16)lstrlen(c), &id, (bool8)FALSE); /*@WIN*/

    return((ufix16)id);

} /* hash_id() */



/***********************************************************************
** TITLE:      enco_cd_setup()                Date:   06/18/90
**
** FUNCTION:   Set up Encoding and CharStrings objects
**
***********************************************************************/
static bool enco_cd_setup()  /* Kason 11/30/90 void->bool */
{
    static enco_data       FAR * FAR *en_ary=Enco_Ary; /*@WIN*/
    static enco_data       FAR *enco_ptr; /*@WIN*/
/*SVM, Kason 3/6/91
 *  ufix16                 id_space, id_notdef, i, j, idex, *keyptr;
 */
    ufix16                 i, j, idex, huge *keyptr; /*@WIN 04-20-92*/
    ufix16                 no_cd ;
    struct new_str_dict        cd_obj[NO_CD];
    struct cd_header far   *cd_head_ptr;
    fix16  far             *cd_code_ptr;


#ifdef DBGfpp
   printf("entering enco_cd_setup()...... \n");
#endif
/* Encoding object initial */
    for (j=0; j<NO_EN; j++) {
        for(i=0; i<256; i++) {
            TYPE_SET(&(en_obj[j][i]), NAMETYPE);
            ATTRIBUTE_SET(&(en_obj[j][i]), LITERAL);
            ROM_RAM_SET(&(en_obj[j][i]), ROM);
            LEVEL_SET(&(en_obj[j][i]), current_save_level);
            ACCESS_SET(&(en_obj[j][i]), READONLY);
            LENGTH(&(en_obj[j][i])) = 0;
        }
    }

    id_notdef = hash_id((byte FAR *) NOTDEF); /*@WIN*/

    for( i=0;  i<NO_EN;   i++)
       {
         /* put /.notdef into the Encoding array */
         id_notdef = hash_id((byte FAR *) NOTDEF); /*@WIN*/
         for(idex = 0; idex < 256; idex++)
            {
             en_obj[i][idex].value = (ufix32)id_notdef;
            }
         no_cd=0;
         enco_ptr=en_ary[i];
         while( ! ( enco_ptr->CharName==(byte FAR *)NULL ) ) /*@WIN*/
              {
                /* put data into char descript dict object */
           /*SVM, Kason 3/6/91*/
              if (i==STD_IDX){
                  cd_obj[no_cd].k=chset_hashid[enco_ptr->CDCode];
              }
              else {
                cd_obj[no_cd].k = hash_id((byte FAR *) enco_ptr->CharName); /*@WIN*/
              }/*if*/

                cd_obj[no_cd].v = enco_ptr->CDCode;


                j = enco_ptr->CharCode;
                if ( j < 256 )
                    en_obj[i][j].value = (ufix32)cd_obj[no_cd].k;

                ++(no_cd);               /* by sequence */
                /* check if CD_OBJ overflow */
                if (no_cd == NO_CD)
                    printf("Cd_obj[] is full.  Err if more CD.\n");

                ++enco_ptr;         /* next encoding data */
              } /* while */


              /* Put /.notdef into char description dict object, vaule
               *          the same as /space                      */
           /*SVM, Kason 3/6/91
            * id_space = hash_id((byte *) SPACE);
            */
              for (idex = 0; idex < no_cd; idex++)
                  if (cd_obj[idex].k == id_space)
                          break;
              if (idex == no_cd)
              {
                  printf("This Encoding  doesn't contain /space information.\n");
              }
              else
              {
                  cd_obj[no_cd].v = cd_obj[idex].v;
                  cd_obj[no_cd].k = id_notdef;

                  ++(no_cd);
              }

         /* Sorting the char descrip data object by hid & find Max length */
         if ( i==STD_IDX ) {
              cd_sorting(cd_obj, &no_cd); /* Kason 12/04/90, +& */

         /* get memory for charstrings */
              cd_addr[i]= (struct dict_head_def huge *)         /* 04-20-92 */
                  alloc_vm((ufix32)CD_SIZE(no_cd) );

              if ( cd_addr[i]== (struct dict_head_def far *)NULL )
                 {
                   return FALSE ;
                 }
              cd_head_ptr=(struct cd_header huge *) (cd_addr[i]+1);  /*04-20*/
                             /* @WIN 04-20-92 */
              keyptr=(ufix16 huge *) alloc_vm( (ufix32)CD_KEY_SIZE(no_cd) );
              if ( keyptr== (ufix16 huge *)NULL )       /*@WIN 04-20-92*/
                 {
                   return FALSE ;
                 }
              cd_head_ptr->key=keyptr;
              cd_head_ptr->base=(gmaddr)0;
              cd_head_ptr->max_bytes=(ufix16)0;
              cd_code_ptr=(fix16 far *) (cd_head_ptr+1);

              DACCESS_SET(cd_addr[i], READONLY);
              DPACK_SET(cd_addr[i], TRUE);
              DFONT_SET(cd_addr[i], FALSE);
              DROM_SET(cd_addr[i], TRUE);
              cd_addr[i]->actlength = (fix16)no_cd;

         /* feed data into charstrings */
              for( j=0 ; j< no_cd; j++)
                 {
                   keyptr[j]=cd_obj[j].k;
                   cd_code_ptr[j]=(fix16)cd_obj[j].v;
                 }
         } /* i==STD_IDX */

       } /* for i=..*/

#ifdef DBGfpp
   printf("leaving enco_cd_setup()...... \n");
#endif

   /**** Kason 11/21/90 ****/
   return (TRUE) ;

}    /* enco_cd_setup() */



/* Kason 12/11/90 , Re-write for removing dup names */
/***********************************************************************
** TITLE:      cd_sorting()                Date:   06/18/90
**
** FUNCTION:   Sorting CharStrings key by hash_id
**
***********************************************************************/
static void    cd_sorting(cd_obj, no)
struct new_str_dict  FAR *cd_obj; /*@WIN*/
ufix16               FAR *no;    /*@WIN*/
{
    fix16     i, j;
    struct  new_str_dict  t_obj;
    fix16     no_char=1 , eq_key=FALSE , k; /* Kason 12/11/90 */
    fix16     dup_num=0;

#ifdef DBGfpp
   printf("entering cd_sorting()...... \n");
#endif
    for (i = 1; (ufix16)i < *no; i++) {         //@WIN
        t_obj.k = cd_obj[i].k;
        t_obj.v = cd_obj[i].v;

        for (j = no_char - 1; j >= 0; j--) {
            if (t_obj.k == cd_obj[j].k)  /* Kason 12/11/90 */
               { eq_key = TRUE ; break ;}
            else
            if (t_obj.k > cd_obj[j].k)
                break;
        } /* for (j...  */
        if (eq_key ) {
            eq_key = FALSE ;
            dup_num++;
            continue ;
        } else {
            for (k=no_char; k>j+1 ; k--) {
                cd_obj[k].k = cd_obj[k-1].k;
                cd_obj[k].v = cd_obj[k-1].v;
            }/*for*/
            cd_obj[j+1].k = t_obj.k;
            cd_obj[j+1].v = t_obj.v;
            no_char++;
        } /*if*/

    } /* for (i.... */

   *no = no_char ; /* real char number */

#ifdef DBGfpp
   printf("leaving cd_sorting()...... \n");
#endif
} /* end cd_sorting() */



/***********************************************************************
** TITLE:      build_finfo()                Date:   06/18/90
**
** FUNCTION:   Building FontInfo dictionary for do_readsfnt()
**
***********************************************************************/
// ???@WIN; void the waring message from C6.0
// static ufix32  build_finfo( ftype, fname , angle )
// fix16   ftype;
// byte    FAR *fname ;     /*@WIN*/
// real32  angle ;
static ULONG_PTR  build_finfo(
fix16   ftype,
byte    huge *fname,     /*@WIN 04-20-92*/
real32  angle)
{

   struct dict_head_def     huge *f_info; /*@WIN 04-20-92*/
   struct dict_content_def  huge *fi_obj; /*@WIN 04-20-92*/
   fix16                    n_fi,i,len;
/*SVM
 * real32  pos,thick ,italic_ang;
 */
   real32  italic_ang;
   byte    huge *str ;    /*@WIN 04-20-92*/

#ifdef DBGfpp
    printf("entering build_finfo() ..... \n");
#endif

   n_fi=0;
/* get memory for FontInfo */
#ifdef DBGfpp
   printf("get memory for FontInfo!!\n");
#endif                          /*@WIN 04-20-92 huge*/
   f_info=(struct dict_head_def huge *)alloc_vm( (ufix32)DICT_SIZE(NO_FINFO) );
    if ( f_info== (struct dict_head_def huge *)NULL )
       {
        return  ( (ULONG_PTR)0 ) ;
       }
   fi_obj=(struct dict_content_def huge *)(f_info+1);

/* FontInfo dict initial */
    for(i=0; i<NO_FINFO; i++) {
        TYPE_SET(&(fi_obj[i].k_obj), NAMETYPE);
        ATTRIBUTE_SET(&(fi_obj[i].k_obj), LITERAL);
        ROM_RAM_SET(&(fi_obj[i].k_obj), ROM);
        LEVEL_SET(&(fi_obj[i].k_obj), current_save_level);
        ACCESS_SET(&(fi_obj[i].k_obj), READONLY);
        LENGTH(&(fi_obj[i].k_obj)) = 0;

        ATTRIBUTE_SET(&(fi_obj[i].v_obj), LITERAL);
        ROM_RAM_SET(&(fi_obj[i].v_obj), ROM);
        LEVEL_SET(&(fi_obj[i].v_obj), current_save_level);
        ACCESS_SET(&(fi_obj[i].v_obj), READONLY);
    }

/* 09/20/90 modified by PHLIN */
/* FontInfo -- Version */
#ifdef DBGfpp
   printf("Process FontInfo -- Version!\n");
#endif
    if(Item4FontInfo2[Version_idx].string[0] != '\0')  {
         VALUE(&(fi_obj[n_fi].k_obj)) = (ufix32)hash_id((byte FAR *) /*@WIN*/
                              Item4FontInfo2[Version_idx].NameInFinfo);

         TYPE_SET(&(fi_obj[n_fi].v_obj), STRINGTYPE);
         LEVEL_SET(&(fi_obj[n_fi].v_obj), current_save_level);
         len= (fix16)strlen(Item4FontInfo2[Version_idx].string);
         LENGTH(&(fi_obj[n_fi].v_obj))=len;
         str= (byte huge *) alloc_vm ( (ufix32) (len+1)  ) ; /*@WIN 04-20-92*/
         /**** Kason 11/21/90 ****/
         if ( str==(byte huge *)NULL ) /*@WIN 04-20-92*/
            {
              return ( (ULONG_PTR)0 ) ;
            }
         lstrcpy(str, Item4FontInfo2[Version_idx].string); /*WIN*/
         VALUE(&(fi_obj[n_fi].v_obj))=(ULONG_PTR)(str);
         ++(n_fi);
    }

/* FontInfo -- Notice */
#ifdef DBGfpp
   printf("Process FontInfo -- Notice!\n");
#endif
    if(Item4FontInfo1[Notice_idx].string[0] != '\0')  {
         VALUE(&(fi_obj[n_fi].k_obj)) = (ufix32)hash_id((byte FAR *) /*@WIN*/
                              Item4FontInfo1[Notice_idx].NameInFinfo);

         TYPE_SET(&(fi_obj[n_fi].v_obj), STRINGTYPE);
         LEVEL_SET(&(fi_obj[n_fi].v_obj), current_save_level);
         len= (fix16)strlen(Item4FontInfo1[Notice_idx].string);
         LENGTH(&(fi_obj[n_fi].v_obj))=(fix16)len;
         str= (byte huge *) alloc_vm ( (ufix32) (len+1)  ) ; /*@WIN 04-20-92*/
         /**** Kason 11/21/90 ****/
         if ( str==(byte huge *)NULL ) /*@WIN 04-20-92*/
            {
              return ( (ULONG_PTR)0 ) ;
            }
         lstrcpy(str, Item4FontInfo1[Notice_idx].string); /*@WIN*/
         VALUE(&(fi_obj[n_fi].v_obj))=(ULONG_PTR)(str);

         ++(n_fi);
    }

/* FontInfo -- FullName */
#ifdef DBGfpp
   printf("Process FontInfo -- FullName!\n");
#endif
    if(Item4FontInfo1[FullName_idx].string[0] != '\0')  {
    VALUE(&(fi_obj[n_fi].k_obj)) = (ufix32)hash_id((byte FAR *) /*@WIN*/
                              Item4FontInfo1[FullName_idx].NameInFinfo);

         TYPE_SET(&(fi_obj[n_fi].v_obj), STRINGTYPE);
         LEVEL_SET(&(fi_obj[n_fi].v_obj), current_save_level);
         len= (fix16)strlen(Item4FontInfo1[FullName_idx].string);
         LENGTH(&(fi_obj[n_fi].v_obj))=(fix16)len;
         str= (byte huge *) alloc_vm ( (ufix32) (len+1)  ) ; /*@WIN 04-20-92*/
         /**** Kason 11/21/90 ****/
         if ( str==(byte huge *)NULL ) /*@WIN 04-20-92*/
            {
              return ( (ULONG_PTR)0 ) ;
            }
         lstrcpy(str, Item4FontInfo1[FullName_idx].string); /*@WIN*/
         VALUE(&(fi_obj[n_fi].v_obj))=(ULONG_PTR)(str);

         ++(n_fi);
    }

/* FontInfo -- Weight */
#ifdef DBGfpp
   printf("Process FontInfo -- Weight!\n");
#endif
    if(Item4FontInfo1[Weight_idx].string[0] != '\0')  {
         VALUE(&(fi_obj[n_fi].k_obj)) = (ufix32)hash_id((byte FAR *) /*@WIN*/
                              Item4FontInfo1[Weight_idx].NameInFinfo);

         TYPE_SET(&(fi_obj[n_fi].v_obj), STRINGTYPE);
         LEVEL_SET(&(fi_obj[n_fi].v_obj), current_save_level);
         len= (fix16)strlen(Item4FontInfo1[Weight_idx].string);
         LENGTH(&(fi_obj[n_fi].v_obj))=(fix16)len;
         str= (byte huge *) alloc_vm ( (ufix32) (len+1)  ) ; /*@WIN 04-20-92*/
         /**** Kason 11/21/90 ****/
         if ( str==(byte huge *)NULL ) /*@WIN 04-20-92*/
            {
              return ( (ULONG_PTR)0 ) ;
            }
         lstrcpy(str, Item4FontInfo1[Weight_idx].string); /*@WIN*/
         VALUE(&(fi_obj[n_fi].v_obj))=(ULONG_PTR)(str);

         ++(n_fi);
    }

/* FontInfo -- FamilyName */
#ifdef DBGfpp
   printf("Process FontInfo -- FamilyName!\n");
#endif
    if(Item4FontInfo1[FamilyName_idx].string[0] != '\0')  {
         VALUE(&(fi_obj[n_fi].k_obj)) = (ufix32)hash_id((byte FAR *) /*@WIN*/
                              Item4FontInfo1[FamilyName_idx].NameInFinfo);

         TYPE_SET(&(fi_obj[n_fi].v_obj), STRINGTYPE);
         LEVEL_SET(&(fi_obj[n_fi].v_obj), current_save_level);
         len= (fix16)strlen(Item4FontInfo1[FamilyName_idx].string);
         LENGTH(&(fi_obj[n_fi].v_obj))=(fix16)len;
         str= (byte huge *) alloc_vm ( (ufix32) (len+1)  ) ; /*@WIN 04-20-92*/
         /**** Kason 11/21/90 ****/
         if ( str==(byte huge *)NULL ) /*@WIN 04-20-92*/
            {
              return ( (ULONG_PTR)0 ) ;
            }
         lstrcpy(str, Item4FontInfo1[FamilyName_idx].string);   /*@WIN*/
         VALUE(&(fi_obj[n_fi].v_obj))=(ULONG_PTR)(str);

         ++(n_fi);
    }

/* FontInfo -- ItalicAngle  */
#ifdef DBGfpp
   printf("Process FontInfo -- ItalicAngle !\n");
#endif
   VALUE(&(fi_obj[n_fi].k_obj)) = (ufix32)hash_id((byte FAR *) ItalicAngle ); /*@WIN*/

   TYPE_SET(&(fi_obj[n_fi].v_obj), REALTYPE  );
   LEVEL_SET(&(fi_obj[n_fi].v_obj), current_save_level);
   LENGTH(&(fi_obj[n_fi].v_obj))=(fix16)0;

   if ( angle!=(real32)0.0 ) {
      italic_ang = angle;
    } else {    /* Kason 12/01/90 */
      italic_ang = sfnt_items.italicAngle;
    }/*if*/

    VALUE(&(fi_obj[n_fi].v_obj))= F2L(italic_ang) ;
    ++(n_fi);

/* FontInfo -- isFixedPitch */
#ifdef DBGfpp
   printf("Process FontInfo -- isFixedPitch!\n");
#endif
    VALUE(&(fi_obj[n_fi].k_obj)) = (ufix32)hash_id((byte FAR *) "isFixedPitch"); /*@WIN*/

    TYPE_SET(&(fi_obj[n_fi].v_obj), BOOLEANTYPE);
    LEVEL_SET(&(fi_obj[n_fi].v_obj), current_save_level);
    LENGTH(&(fi_obj[n_fi].v_obj))=(fix16)0;
    VALUE(&(fi_obj[n_fi].v_obj))=(ufix32)(sfnt_items.is_fixed);

    ++(n_fi);

/* FontInfo -- UnderlinePosition */
#ifdef DBGfpp
   printf("Process FontInfo -- UnderlinePosition!\n");
#endif
      VALUE(&(fi_obj[n_fi].k_obj)) =
                       (ufix32) hash_id((byte FAR *) UnderlinePosition); /*@WIN*/

      TYPE_SET(&(fi_obj[n_fi].v_obj), REALTYPE);
      LENGTH(&(fi_obj[n_fi].v_obj)) = 0;
      VALUE(&(fi_obj[n_fi].v_obj)) = F2L(sfnt_items.underlinePosition);
      ++(n_fi);

/* FontInfo -- UnderlineThickness */
#ifdef DBGfpp
   printf("Process FontInfo -- UnderlineThickness!\n");
#endif
      VALUE(&(fi_obj[n_fi].k_obj)) =
                       (ufix32) hash_id((byte FAR *) UnderlineThickness); /*@WIN*/

      TYPE_SET(&(fi_obj[n_fi].v_obj), REALTYPE);
      LENGTH(&(fi_obj[n_fi].v_obj)) = 0;
      VALUE(&(fi_obj[n_fi].v_obj)) = F2L(sfnt_items.underlineThickness);
      ++(n_fi);

/* FontInfo head information */
    DACCESS_SET(f_info, READONLY);
    DPACK_SET(f_info, FALSE);
    DFONT_SET(f_info, FALSE);
    DROM_SET(f_info, TRUE);
    f_info->actlength = (fix16)(n_fi);

#ifdef DBGfpp
    printf("leaving build_finfo() ..... \n");
#endif
    return ( (ULONG_PTR)f_info );

}   /* build_finfo */



/***  Extract key from sfnt file ***/
static void fe_data(sfnt)
byte        FAR *sfnt; /*@WIN*/
{
    /* get sfnt data */
    SfntAddr = sfnt;
    sfntdata((ULONG_PTR)sfnt, &sfnt_items);

} /* fe_data() */

//#define FIXED2FLOAT(val)    (((float) val) / (float) (1 << 16)) @WIN
#define FIXED2FLOAT(val)    (((float) val) / (float) 65536.0)

/*Kason 11/08/90 */
static ufix16 FAR name_offset[NO_CD]; /*@WIN*/

static fsg_SplineKey  KeyData;
static void sfntdata(SFNTPtr, sfnt_items)
ULONG_PTR             SFNTPtr;
struct data_block  FAR *sfnt_items; /*@WIN*/
{
        register fsg_SplineKey FAR *key = &KeyData; /*@WIN_BASS*/
        sfnt_FontHeader        FAR *fontHead; /*@WIN*/
        sfnt_HorizontalHeader  FAR *horiHead; /*@WIN*/
        sfnt_NamingTable       FAR *nameHead; /*@WIN*/
        sfnt_NameRecord        FAR *nameRecord; /*@WIN*/
     /* Kason 10/09/90+ */
        sfnt_PostScriptInfo    FAR *postScript; /*@WIN*/
        real32                 fmt_no;

        struct sfnt_FontInfo1  FAR *finfoPtr; /*@WIN*/
        char FAR *                  nameBuffer; /*@WIN*/
        fix                    ii, jj, kk;
        double                 box;

#ifdef DBGfpp
    printf("entering sfntdata()...... \n");
#endif

        fontHead = (sfnt_FontHeader FAR *)sfnt_GetTablePtr(key, sfnt_fontHeader, true ); /*@WIN*/
        horiHead = (sfnt_HorizontalHeader FAR *)sfnt_GetTablePtr( key, sfnt_horiHeader, true ); /*@WIN*/
      /* JJ Jerry modified 09-26-90
       *nameHead = (sfnt_NamingTable*)sfnt_GetTablePtr( key, sfnt_namingTable, true );
       */
/* replace by Falco for imcompatibility, 11/12/91 */
/*      nameHead = (sfnt_NamingTable*)sfnt_GetTablePtr( key, sfnt_namingTable, false);
        postScript = (sfnt_PostScriptInfo*)sfnt_GetTablePtr( key, sfnt_PostScript, false);
*/
        nameHead = (sfnt_NamingTable FAR *)sfnt_GetTablePtr( key, sfnt_Names, false); /*@WIN*/
        postScript = (sfnt_PostScriptInfo FAR *)sfnt_GetTablePtr( key, sfnt_Postscript, false); /*@WIN*/
/* replace end */
/* @@SWAP1 BEGIN 03/15/91 D.S. Tseng */
        sfnt_items->italicAngle = FIXED2FLOAT(SWAPL(postScript->italicAngle));
        sfnt_items->is_fixed = ((bool)(SWAPL(postScript->isFixedPitch)))? TRUE : FALSE;
        /* Kason 2/25/91 */
        EMunits = SWAPW(fontHead->unitsPerEm) ;  /*GAW*/
        sfnt_items->underlinePosition =(real32)( floor(
          (real32)(1000*SWAPW(postScript->underlinePosition))/SWAPW(fontHead->unitsPerEm)+0.5));
        sfnt_items->underlineThickness =(real32)(floor(
          (real32)(1000*SWAPW(postScript->underlineThickness))/SWAPW(fontHead->unitsPerEm)+0.5));
        fmt_no = FIXED2FLOAT(SWAPL(postScript->version));
        /* @@SWAP1 END   03/15/91 D.S. Tseng */
        if (fmt_no==(float)2.0){        //@WIN
                    ufix16 num_glyph, delta ;
                    ufix16 FAR *nmidx_p, private_name_no=0 ; /*@WIN*/
                    byte   FAR *name_string_base, FAR *name_pos ; /*@WIN*/

#ifdef DBGfpp
                    printf("post table 2.0 !!\n");
#endif

                    /* @@SWAP1 BEGIN 03/13/91 D.S. Tseng */
                    num_glyph = SWAPW(*( ufix16 FAR * )( postScript+1 )); /*@WIN*/
                    /* @@SWAP1 END   03/13/91 D.S. Tseng */
                    nmidx_p = (ufix16 FAR *)( (byte FAR *)(postScript+1)+2 ) ; /*@WIN*/
                    name_string_base = (byte FAR *) ( (byte FAR *)nmidx_p+2*num_glyph ) ; /*@WIN*/
#ifdef DJC    // Fix from history.log
                    for(ii=0;(ufix16)ii<num_glyph;ii++) //@WIN
                       if ( nmidx_p[ii]>=258)
                          private_name_no++;
#else

                    for(ii=0;(ufix16)ii<num_glyph;ii++) { //@WIN
                       if ( SWAPW(nmidx_p[ii]) >=258) {
                          private_name_no++;
                       }
                    }
#endif
                    /* convert INDEX to OFFSET */
#ifdef DBGfpp
                    printf("private_name_no=%u\n",private_name_no);
#endif

                    name_offset[0]=0; name_pos=name_string_base;
                    for(ii=1;(ufix16)ii<private_name_no;ii++) { //@WIN
                       delta=(ufix16)(*name_pos)+1;
                       name_offset[ii]=name_offset[ii-1]+delta;
                       name_pos+=delta;
                    }/*for*/
        }/* if */

        if (SWAPL(fontHead->magicNumber) != SFNT_MAGIC )
             return /* BAD_MAGIC_ERR */;
        key->emResolution = SWAPW(fontHead->unitsPerEm);
        key->numberOf_LongHorMetrics = SWAPW(horiHead->numberOf_LongHorMetrics);
        /* @@SWAP BEGIN 10/05/90 D.S. Tseng */
#ifndef LITTLE_ENDIAN
        key->maxProfile = *((sfnt_maxProfileTable FAR *)sfnt_GetTablePtr( key, sfnt_maxProfile, true )); /*@WIN*/
#else
        copy_maxProfile(key);
#endif
        /* @@SWAP END   10/05/90 D.S. Tseng */

/* @@SWAP1 BEGIN 03/13/91 D.S. Tseng */
/*Kason 10/21/90 */
#ifdef DBGfpp
        printf("CheckSUMadjust=%lx\n",SWAPL(fontHead->checkSumAdjustment));
#endif
        sfnt_items->dload_uid = SWAPL(fontHead->checkSumAdjustment);
/* @@SWAP1 END   03/13/91 D.S. Tseng */

/* get version */
/* DLL can not use sprintf lib; always set as "1.00"; tmp solution; ???@WINTT
        sprintf(Item4FontInfo2[IDEX_VERSION].string, "%.2f",
                FIXED2FLOAT(SWAPL(fontHead->version)));
 */


        //DJC put this back per scchen request
        wsprintf(Item4FontInfo2[IDEX_VERSION].string, "%.2f",
                 FIXED2FLOAT(SWAPL(fontHead->version)));

#ifdef DJC
        Item4FontInfo2[IDEX_VERSION].string[0] = '1';
        Item4FontInfo2[IDEX_VERSION].string[1] = '.';
        Item4FontInfo2[IDEX_VERSION].string[2] = '0';
        Item4FontInfo2[IDEX_VERSION].string[3] = '0';
        Item4FontInfo2[IDEX_VERSION].string[4] = 0;
#endif

/* get FontBBox */
        box = 1000 * (float) (fix16)SWAPW(horiHead->minLeftSideBearing) / (fix16)SWAPW(fontHead->unitsPerEm);
        if (box >= 0)
            sfnt_items->llx = (fix32) ceil(box); /* Kason 12/01/90 */
        else
            sfnt_items->llx = (fix32) floor(box); /* Kason 12/01/90 */
#ifdef DBGfpp
        printf("    FontBBox = %f(%d) ", box, sfnt_items->llx);
#endif
        box = 1000 * (float) (fix16)SWAPW(fontHead->yMin) / (fix16)SWAPW(fontHead->unitsPerEm);
        if (box >= 0)
            sfnt_items->lly = (fix32) ceil(box);/* Kason 12/01/90 */
        else
            sfnt_items->lly = (fix32) floor(box);/* Kason 12/01/90 */
#ifdef DBGfpp
        printf(" %f(%d) ", box, sfnt_items->lly);
#endif
        box = 1000 * (float) (fix16)SWAPW(horiHead->xMaxExtent) / (fix16)SWAPW(fontHead->unitsPerEm);
        if (box >= 0)
            sfnt_items->urx = (fix32) ceil(box);/* Kason 12/01/90 */
        else
            sfnt_items->urx = (fix32) floor(box);/* Kason 12/01/90 */
#ifdef DBGfpp
        printf(" %f(%d) ", box, sfnt_items->urx);
#endif
        box = 1000 * (float) (fix16)SWAPW(fontHead->yMax) / (fix16)SWAPW(fontHead->unitsPerEm);
        if (box >= 0)
            sfnt_items->ury = (fix32) ceil(box);/* Kason 12/01/90 */
        else
            sfnt_items->ury = (fix32) floor(box);/* Kason 12/01/90 */
#ifdef DBGfpp
        printf(" %f(%d)\n", box, sfnt_items->ury);
#endif


/* get NamingTable */
      if( nameHead ) {     /* JJ Jerry add 09-26-90 */
        nameBuffer = (char FAR *) nameHead + SWAPW(nameHead->stringOffset); /*@WIN*/
        nameRecord = (sfnt_NameRecord FAR *) (nameHead + 1); /*@WIN*/
        for (finfoPtr = Item4FontInfo1, jj = 0; jj < NO_STRING_IN_NAMING;
             finfoPtr++, jj++) {

            /* search the item within namingTable */
            for (ii = 0; ii < SWAPW(nameHead->count); ii++)
                /* @@SWAP1 BEGIN 03/13/91 D.S. Tseng */
                if (SWAPW(nameRecord[ii].nameID) == finfoPtr->nameID)
                /* @@SWAP1 BEGIN 03/13/91 D.S. Tseng */
                   {
                    break;
                   }
            if (ii >= SWAPW(nameHead->count)) { /* not exist */
                finfoPtr->string[0] = '\0';
                continue;
            }
            //DJC fix history ,  for (kk = 0; kk < SWAPW(nameRecord[ii].length); kk++) {
            for (kk = 0; kk < MIN(MAXFINFONAME-1, SWAPW(nameRecord[ii].length)); kk++) {
                finfoPtr->string[kk] = nameBuffer[SWAPW(nameRecord[ii].offset) + kk];
            }
            finfoPtr->string[kk] = '\0';

        } /* end for   */

       }/*if*/
       else {
        for (finfoPtr = Item4FontInfo1, jj = 0; jj < NO_STRING_IN_NAMING;
             finfoPtr++, jj++) {
                finfoPtr->string[0] = '\0';
        } /* end for   */
       } /* if  JJ Jerry add 09-26-90 */

#ifdef DBGfpp
    printf("leaving sfntdata()...... \n");
#endif

}

#define FPP_ID     10
/* SetupKey:    reference FontScaler.c fs_SetUpKey() */
/* static void    SetupKey(key, sfntAddr) */
void    SetupKey(key, sfntAddr)
fsg_SplineKey  FAR *key; /*@WIN_BASS*/
ULONG_PTR         sfntAddr;
{
/* mark by Falco, as this field no longer existed, 11/08/91 */
/*      key->sfntDirectory = (sfnt_OffsetTable*) sfntAddr; */
/* mark end */
        key->GetSfntFragmentPtr = (GetSFNTFunc) GetSfntPiecePtr;
        key->clientID = FPP_ID;
        key->ReleaseSfntFrag = dummyReleaseSfntFrag;
}

//static char FAR * GetSfntPiecePtr(ClientID, offset, length) /*@WIN*/
char FAR * GetSfntPiecePtr(ClientID, offset, length) /*@WIN*/
long    ClientID;
long    offset;
long    length;
{

//  return(SfntAddr + offset);  @WIN

    char FAR * p;
    p = SfntAddr + offset;
    return(p);
} /* GetSfntPiecePtr() */


#define BUF (1024)
/***********************************************************************
** TITLE:      op_readsfnt()              Date:   07/16/90
**
** FUNCTION:   Operator readsfnt .
**
**
***********************************************************************/
int
op_readsfnt()
{
    readsfnt(BIN);
    return(0);
}

int
op_readhexsfnt()
{
    readsfnt(HEX);
    return(0);
}


static int
readsfnt(mode)
int mode;
{
  struct object_def   FAR *font ; /*@WIN*/
  struct object_def   fobj, strobj = {0, 0, 0};
  ufix16              str_size ;
  fix16               obj_type ;
  ubyte               huge *font_addr=(ubyte huge *)NULL, huge *tmp_addr ; /*@WIN*/
  ubyte               str_buf[BUF] ;
  bool                fst_time ;
/*SVM
 *struct object_def   l_fontname, *l_name;
 */
  /* Kason 11/29/90 */
  ufix32              fontsize=0, sizecount, sizediff;  /*SVM*/
  struct dict_head_def FAR *font_head; /* 9/24/90; ccteng; add this line @WIN*/

#ifdef DBGfpp
  printf("Entering op_readsfnt()......\n");
#endif

  obj_type=(fix16)TYPE( GET_OPERAND(0) ) ;
  switch(obj_type)
        {
          case STRINGTYPE :

               font=do_readsfnt( (byte huge *)VALUE( GET_OPERAND(0) ), /*@WIN*/
                                 (byte huge *)NULL , /*@WIN 04-20-92*/
                                 (real32 FAR *)NULL , /*@WIN*/
                                 (ufix32)0 ,
                                 (real32)0.0 ) ;
            /* 9/24/90; ccteng
             * if ( font != (struct object_def *)NULL )
             *      PUSH_OBJ(font) ;
             */
               if ( font != (struct object_def FAR *)NULL ) { /*@WIN*/
                    /* 9/25/90; ccteng; change access to unlimited */
                    POP(1); /* Kason 1/15/91 , shift from outside-if */
                    font_head = (struct dict_head_def FAR *)VALUE(font); /*@WIN*/
                    DACCESS_SET(font_head, UNLIMITED);
                    ACCESS_SET(font, UNLIMITED);
                    PUSH_OBJ(font) ;
               } /* if */
               break ;

          case FILETYPE  :
               /* create string buffer */
               ATTRIBUTE_SET(&strobj, LITERAL);
               ROM_RAM_SET(&strobj, RAM);
               LEVEL_SET(&strobj, current_save_level);
               ACCESS_SET(&strobj, UNLIMITED);
               TYPE_SET(&strobj, STRINGTYPE);
//             VALUE(&strobj)  = (ULONG_PTR) (str_buf); @WIN
               VALUE(&strobj)  = (ULONG_PTR) ((char FAR *)str_buf);
               LENGTH(&strobj) = (fix16)BUF;

               COPY_OBJ ( GET_OPERAND(0), &fobj ) ;
               POP(1) ;
               fst_time=TRUE ;
               sizecount = 0;
               while(1) {
                   PUSH_OBJ ( &fobj ) ;
                   PUSH_OBJ ( &strobj ) ;
                   if (mode == BIN)
                       op_readstring() ;
                   else
                       op_readhexstring() ;
                   if (ANY_ERROR()) {   /* Kason 1/15/91 */
                       if ( !fst_time )
                            free_vm((byte huge *)font_addr); /*@WIN 04-20-92*/
                       POP(1) ; /* Kason 1/15/91, 2->1 */
                       return 0 ;
                   }
                   str_size = (ufix16) LENGTH ( GET_OPERAND(1) ) ;

                   if ( str_size ) {
                       if (!(tmp_addr=(ubyte huge *)alloc_vm((ufix32)str_size)))
                       { /*@WIN 04-20-92*/
                               if ( !fst_time )
                                 free_vm((byte huge *)font_addr); /*@WIN 04-20-92*/
                              POP(2) ;
                              PUSH_OBJ ( &fobj ) ; /* Kason 1/15/91 */
                              return 0 ;
                         } /* if */

                         lmemcpy ( tmp_addr ,(ubyte FAR *)VALUE(GET_OPERAND(1)), /*@WIN*/
                                  str_size*sizeof(ubyte) ) ;

                         if (fst_time ) {
                            font_addr = tmp_addr ;
                            /* 9/20/90; ccteng; add to scan fontsize */
                            fontsize = scansfnt(tmp_addr);

                            fst_time = FALSE ;
                         }
                         sizecount += str_size;
                         sizediff = fontsize - sizecount;
                         if (!sizediff) {
#ifdef DBGfpp
                             printf("end reading data\n");
#endif
                             POP(2);
                             break;
                         } else if (sizediff < 1024)
                             LENGTH(&strobj) = (fix16)sizediff;
                   } /* if */

                   if ( ! (bool)VALUE( GET_OPERAND(0) ) ) {
                         POP(2) ;
                         break ;
                   } /* if */

                   POP(2) ;
               } /* while */
               if ((byte huge *)font_addr == (byte huge *)NULL) { /*04-20-92*/
                    PUSH_OBJ( &fobj );
                    ERROR(INVALIDFONT);
                    return 0;
               }/*if*/
               font=do_readsfnt( (byte huge *)font_addr, /*@WIN*/
                                 (byte huge *)NULL ,     /*@WIN 04-20-92*/
                                 (real32 FAR *)NULL ,    /*@WIN*/
                                 (ufix32)0 ,
                                 (real32)0.0 ) ;
               if ( font != (struct object_def FAR *)NULL ) { /*@WIN*/
                    PUSH_OBJ(font) ;
               }
               else {    /* Kason 1/15/91 */
                    free_vm( (byte huge *)font_addr ); /*@WIN*/
                    PUSH_OBJ( &fobj );
               }/* if */

               break ;

          default :
                ERROR(TYPECHECK) ;
                return(0);
        }

#ifdef DBGfpp
  printf("Leaving op_readsfnt()......\n");
#endif
/* Kason 11/30/90 */
  return(0) ;

}   /* op_readsfnt() */


static ufix32         /* Kason 11/29/90 */
scansfnt(str)
ubyte huge *str;  /*@WIN 04-20-92*/
{
    ufix32  pad, offset, length=0;  /* Kason 11/29/90 */ /*SVM*/
    ufix16  i;
    sfnt_OffsetTable    FAR *dir; /*@WIN*/
    sfnt_DirectoryEntry  FAR *tbl; /*@WIN*/

#ifdef DBGfpp
    printf("entering scansfnt().....\n");
#endif
    dir = (sfnt_OffsetTable FAR *)str; /*@WIN*/
    tbl = dir->table;
    for (i = 0, offset = 0; i < (ufix16)SWAPW(dir->numOffsets); i++, tbl++) {//@WIN
        if (offset < (ufix32)SWAPL(tbl->offset)) {      //@WIN
            offset = SWAPL(tbl->offset);
            length = SWAPL(tbl->length);
        }
        if (SWAPL(tbl->offset) == 0)
            break;      /* data below is invalid */
    }
    if (pad = length % 4)
            pad = 4 - pad;
    length += offset + pad;

#ifdef DBGfpp
    printf("download fontsize: %d\n", length);
#endif
#ifdef DBGfpp
    printf("leaving scansfnt().....\n");
#endif
    return(length);
}

/* @@SWAP BEGIN 11/02/90 D.S. Tseng */
#ifdef LITTLE_ENDIAN
void copy_maxProfile(key)
fsg_SplineKey FAR *key; /*@WIN_BASS*/
{
sfnt_maxProfileTable FAR *ds; /*@WIN*/
        ds = (sfnt_maxProfileTable FAR *)sfnt_GetTablePtr( key, sfnt_maxProfile, true ); /*@WIN*/
        key->maxProfile.version = SWAPL(ds->version);
        key->maxProfile.numGlyphs = SWAPW(ds->numGlyphs);
        key->maxProfile.maxPoints = SWAPW(ds->maxPoints);
        key->maxProfile.maxContours = SWAPW(ds->maxContours);
        key->maxProfile.maxCompositePoints = SWAPW(ds->maxCompositePoints);
        key->maxProfile.maxCompositeContours = SWAPW(ds->maxCompositeContours);
        key->maxProfile.maxElements = SWAPW(ds->maxElements);
        key->maxProfile.maxTwilightPoints = SWAPW(ds->maxTwilightPoints);
        key->maxProfile.maxStorage = SWAPW(ds->maxStorage);
        key->maxProfile.maxFunctionDefs = SWAPW(ds->maxFunctionDefs);
        key->maxProfile.maxInstructionDefs = SWAPW(ds->maxInstructionDefs);
        key->maxProfile.maxStackElements = SWAPW(ds->maxStackElements);
        key->maxProfile.maxSizeOfInstructions = SWAPW(ds->maxSizeOfInstructions);
        key->maxProfile.maxComponentElements = SWAPW(ds->maxComponentElements);
        key->maxProfile.maxComponentDepth = SWAPW(ds->maxComponentDepth);
        return;
}
#endif
/* @@SWAP END   11/02/90 D.S. Tseng */

/***********************************************************************
** TITLE:      glyphidx2name()              Date:   10/12/90
**
** FUNCTION:   Getting glyphname from post table through glyphindex
***********************************************************************/
byte  glyphname[80];
/* SVM , Kason 3/6/91
static byte  *glyphidx2name( postScript, glyphidx )
*/
static ufix16 glyphidx2name( postScript, glyphidx )
sfnt_PostScriptInfo   FAR *postScript; /*@WIN*/
ufix16                glyphidx;
{
   real32  fmt_no;
   extern ufix16 FAR name_offset[];     /*@WIN*/
   extern bool   nm_mpa;

   /* @@SWAP1 BEGIN 03/13/91 D.S. Tseng */
   fmt_no = FIXED2FLOAT(SWAPL(postScript->version));
   /* @@SWAP1 END   03/13/91 D.S. Tseng */
   switch ( (fix16)(fmt_no+fmt_no) ) {
     case 2: /* format 1.0 */
          {
           /*SVM, Kason 3/6/91
             return ( sfntGlyphSet[glyphidx] );
            */
             return ( chset_hashid[glyphidx] );
          }
     case 6: /* format 3.0 */
          {
           /*SVM
             return ( (byte*)(".notdef") ) ; |* ??? */
             return ( id_notdef );
          }
     case 5: /* format 2.5 */
          {
            byte   FAR *offset_ptr=(byte FAR *)( postScript+1 ); /*@WIN*/
            fix16  offset_value ;

            offset_value = (fix16)offset_ptr[glyphidx];
            /*SVM
            return( sfntGlyphSet[ (fix16)glyphidx + offset_value ] );
             */
            return( chset_hashid[ (fix16)glyphidx + offset_value ] );
          }
     case 4: /* format 2.0 */
          {
            ufix16 nameidx,name_len, num_glyph;   /*SVM*/
            ufix16 FAR *nmidx_p; /*@WIN*/
            byte   FAR *name_string_base, FAR *a_name_string; /*@WIN*/

            /* @@SWAP1 BEGIN 03/13/91 D.S. Tseng */
            num_glyph = SWAPW(*( ufix16 FAR * )( postScript+1 )); /*@WIN*/
            /* @@SWAP1 END   03/13/91 D.S. Tseng */
            nmidx_p = ( ufix16 FAR * )( (byte FAR *)(postScript+1)+2 ); /*@WIN*/
            name_string_base = (byte FAR *) ( (byte FAR *)nmidx_p+2*num_glyph ) ; /*@WIN*/

            /* @@SWAP1 BEGIN 03/13/91 D.S. Tseng */
            nameidx = SWAPW(nmidx_p[glyphidx]);
            /* @@SWAP1 END   03/13/91 D.S. Tseng */
            if ( nameidx<SFNTGLYPHNUM ) {  /* builtin name */
              /*SVM
               return ( sfntGlyphSet[nameidx] );
               */
               return ( chset_hashid[nameidx] );
            }
            else {  /* private name */
                  fix16  id ; /*SVM*/
                  a_name_string = name_string_base + name_offset[nameidx - SFNTGLYPHNUM];

               name_len = (ufix16)(*a_name_string);
               a_name_string++; /*SVM*/
               name_to_id((byte FAR *)a_name_string,name_len,&id,(bool8)FALSE); /*@WIN*/
               return ( (ufix16)id );
            }  /* if */
          }
     default  : /* error format  */
           /*SVM
            return ( (byte*)".notdef" );
            */
            return ( id_notdef );
   } /* switch */

}  /* glyphidx2name() */


/***********************************************************************
** TITLE:      computeFirstMapping()              Date:   10/17/90
**
** FUNCTION:   Set the first cmap table as default encoding.
***********************************************************************/
static fix16 computeFirstMapping(key)
register fsg_SplineKey FAR *key; /*@WIN_BASS*/
{
        sfnt_char2IndexDirectory FAR *table= (sfnt_char2IndexDirectory FAR *) /*@WIN*/
                            sfnt_GetTablePtr( key, sfnt_charToIndexMap, true );
        uint8 FAR *mapping = (uint8 FAR *)table; /*@WIN*/
        register uint16 format;
        bool            found=FALSE;

/* delete by Falco for not existing in new key structure, 11/12/91 */
/*      key->numberOfBytesTaken = 2;*/ /* Initialize */
/* delete end */

        /* mapping */
        /* @@SWAP1 BEGIN 03/15/91 D.S. Tseng */
        if ( SWAPW(table->version) == 0 ) {     /*@WIN*/
                register sfnt_platformEntry FAR * plat = table->platform; /*@WIN*/
                key->mappOffset = (unsigned)SWAPL(plat->offset) + 6;  /* skip header @WIN*/
                found=TRUE;
        }
        /* @@SWAP1 END   03/15/91 D.S. Tseng */

        if ( !found )
        {
                key->mappingF = sfnt_ComputeUnkownIndex;
                return 1;
        }
        mapping += key->mappOffset - 6;         /* back up for header */
        /* @@SWAP1 BEGIN 03/15/91 D.S. Tseng */
        format = SWAPW(*(uint16 FAR *)mapping); /*@WIN*/
        /* @@SWAP1 END   03/15/91 D.S. Tseng */

        switch ( format ) {
        case 0:
                key->mappingF = sfnt_ComputeIndex0;
                break;
        case 2:
                key->mappingF = sfnt_ComputeIndex2;
                break;
        case 4:
                key->mappingF = sfnt_ComputeIndex4;
                break;
        case 6:
                key->mappingF = sfnt_ComputeIndex6;
                break;
        default:
                key->mappingF = sfnt_ComputeUnkownIndex;
                break;
        }
        return 0;
} /* computeFirstMapping() */



/***********************************************************************
** TITLE:      cmap2encoding()              Date:   10/17/90
**
** FUNCTION:   Get Encoding array from sfnt data.
**             platformID==-1 and specificID==-1 --->using First encoding
***********************************************************************/
static struct object_def  encoding_obj;
static struct object_def  FAR *cmap2encoding(sfnt,platformID,specificID) /*@WIN*/
byte    FAR *sfnt; /*@WIN*/
fix     platformID, specificID;
{
    fsg_SplineKey            keystru, FAR *key=&keystru; /*@WIN_BASS*/
    sfnt_PostScriptInfo      FAR *postScript; /*@WIN*/
    struct object_def        huge *ar_obj; /*@WIN 04-20-92*/
    ufix16                   glyphidx,charcode,startcode,i;
 /*SVM
  * byte                     *glyphname;
  */
    real32                   fmt_no;

       startcode=0x0;
       SfntAddr=sfnt;
       SetupKey(key, (ULONG_PTR)sfnt);
       sfnt_DoOffsetTableMap( key );      /* Map offset and length table */

       /* the default first encoding in cmap */
       if ( (platformID==-1) && (specificID==-1) ) {
            computeFirstMapping(key);
       }
       else {
       /* choose the corresponding encoding table */
          if( sfnt_ComputeMapping(key,(uint16)platformID,(uint16)specificID) ) {
             return ((struct object_def FAR *)NULL);  /* not found @WIN*/
          }/* if */
       }/* if */
       /* post table */

/* replace by Falco. 11/12/91 */
/*     postScript=(sfnt_PostScriptInfo*)
                         sfnt_GetTablePtr( key, sfnt_PostScript, true); */
       postScript=(sfnt_PostScriptInfo FAR *) /*@WIN*/
                         sfnt_GetTablePtr( key, sfnt_Postscript, true);
/* replace end */

        /* @@SWAP1 BEGIN 03/13/91 D.S. Tseng */
        fmt_no = FIXED2FLOAT(SWAPL(postScript->version));
        /* @@SWAP1 END   03/13/91 D.S. Tseng */
        if (fmt_no==(float)2.0){        //@WIN
                    ufix16 i, num_glyph, delta ;
                    ufix16 FAR *nmidx_p, private_name_no=0 ; /*@WIN*/
                    byte   FAR *name_string_base, FAR *name_pos; /*@WIN*/

                    /* @@SWAP1 BEGIN 03/13/91 D.S. Tseng */
                    num_glyph = SWAPW(*( ufix16 FAR * )(postScript+1)); /*@WIN*/
                    /* @@SWAP1 BEGIN 03/13/91 D.S. Tseng */
                    nmidx_p = (ufix16 FAR *)( (byte FAR *)(postScript+1)+2 ) ; /*@WIN*/
                    name_string_base = (byte FAR *) ( (byte FAR *)nmidx_p+2*num_glyph ) ; /*@WIN*/

                    for(i=0;i<num_glyph;i++)
                        /* @@SWAP1 BEGIN 03/13/91 D.S. Tseng */
                       if ( SWAPW(nmidx_p[i])>=258)
                        /* @@SWAP1 END   03/13/91 D.S. Tseng */
                          private_name_no++;
                    name_offset[0]=0; name_pos=name_string_base;
                    for(i=1;i<private_name_no;i++) {
                        /* @@SWAP1 BEGIN 03/13/91 D.S. Tseng */
//                     delta=(ufix16)SWAPW((*name_pos))+1; fix bug by SCCHEN; byte not need to swap
                       delta=(ufix16)(*name_pos)+1;
                        /* @@SWAP1 END   03/13/91 D.S. Tseng */
                       name_offset[i]=name_offset[i-1]+delta;
                       name_pos+=delta;
                    }/*for*/
        }/* if */

       ar_obj=(struct object_def huge *)alloc_vm((ufix32)ARRAY_SIZE(256));
       if ( ar_obj== (struct object_def huge *)NULL ){ /*@WIN 04-20-92*/
          return ((struct object_def FAR *)NULL);  /* memory allocation error @WIN*/
       }

/* take out non-UGL mapping, since it may arouse further problems */
#if 0
       /* set starting code range of MS non-UGL code; @WIN;@UGL */
       if (platformID==3 && specificID==0)
            startcode=0xf000;
#endif
#ifdef DJC  // After further discussions with scchen, i was instructed to
            // take this out
       //DJC, fix from history.log UPD006
       /* set starting code range of MS non-UGL code */
       if (platformID==3 && specificID==0)
         startcode=0xf000;
#endif


       //DJC, end fix UPD006

       /* Encoding object setting */
        for(charcode=startcode, i=0; i<256; i++, charcode++) {
            TYPE_SET((ar_obj+i), NAMETYPE);
            ATTRIBUTE_SET((ar_obj+i), LITERAL);
            ROM_RAM_SET((ar_obj+i), ROM);
            LEVEL_SET((ar_obj+i), current_save_level);
            ACCESS_SET((ar_obj+i), UNLIMITED);
            LENGTH(ar_obj+i) = 0;

            /* charcode to glyphname mapping */
/* change By Falco for parameter change, 11/20/91 */
/*          glyphidx=(*key->mappingF)(key,charcode); */
{
            uint8 FAR * mappingPtr = (uint8 FAR *)sfnt_GetTablePtr (key, sfnt_charToIndexMap, true);
            glyphidx = key->mappingF (mappingPtr + key->mappOffset, charcode);
}
/* change end */
            /*SVM*/
            ar_obj[i].value=(ufix32)glyphidx2name(postScript,glyphidx);
        }
        /* returned object */
            TYPE_SET(&(encoding_obj), ARRAYTYPE);
            ATTRIBUTE_SET(&(encoding_obj), LITERAL);
            ROM_RAM_SET(&(encoding_obj), ROM);
            LEVEL_SET(&(encoding_obj), current_save_level);
            ACCESS_SET(&(encoding_obj), UNLIMITED);

            LENGTH(&(encoding_obj)) = (fix16)256;
            VALUE(&(encoding_obj)) = (ULONG_PTR) ar_obj;

            return(&encoding_obj);
}  /* cmap2encoding() */


/***********************************************************************
** TITLE:      op_setsfntencoding()           Date:   10/12/90
**
** FUNCTION:   Operator setsfntencoding.
***********************************************************************/
fix   op_setsfntencoding()
{
    fix  platformid, encodingid;
    struct object_def   FAR *font_dict, FAR *encoding_obj; /*@WIN*/
    byte                FAR *sfnt; /*@WIN*/

#ifdef DBGfpp
    printf("entering op_setsfntencoding()....\n");
#endif
    encodingid = (fix)VALUE(GET_OPERAND(0));
    platformid = (fix)VALUE(GET_OPERAND(1));
    font_dict  = (struct object_def FAR *)(GET_OPERAND(2)); /*@WIN*/
    if ((sfnt=chk_sfnt(font_dict)) == NULL)   return(0);

    if ((encoding_obj=cmap2encoding(sfnt, platformid, encodingid)) == NULL) {
        if (ANY_ERROR())   return(0);
        POP(2);
        PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, FALSE);
    }
    else {
        struct object_def       nameobj, valobj;

        ATTRIBUTE_SET(&valobj, LITERAL);
        LEVEL_SET(&valobj, current_save_level);
        TYPE_SET(&valobj, INTEGERTYPE);
        LENGTH(&valobj) = 0;

        ATTRIBUTE_SET(&nameobj, LITERAL);
        get_name (&nameobj, "PlatformID", 10, TRUE);
        VALUE(&valobj) = (ufix32)platformid;
        if ( ! put_dict(GET_OPERAND(2), &nameobj, &valobj) ) {
            ERROR(DICTFULL);    /* Return with 'dictfull' error; */
            return(0);
        }
        get_name (&nameobj, "EncodingID", 10, TRUE);
        VALUE(&valobj) = (ufix32)encodingid;
        if ( ! put_dict(GET_OPERAND(2), &nameobj, &valobj) ) {
            ERROR(DICTFULL);    /* Return with 'dictfull' error; */
            return(0);
        }

        get_name (&nameobj, Encoding, 8, TRUE);
        if ( ! put_dict(GET_OPERAND(2), &nameobj, encoding_obj) ) {
            ERROR(DICTFULL);    /* Return with 'dictfull' error; */
            return(0);
        }

        POP(2);
        PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, TRUE);
    }
    return(0);
}

/***********************************************************************
** TITLE:      chk_sfnt()              Date:   10/12/90
**
** FUNCTION:   Check font dict within op_setsfntencoding .
***********************************************************************/
static byte   FAR *chk_sfnt(font_dict) /*@WIN*/
struct object_def   FAR *font_dict; /*@WIN*/
{
    struct object_def       obj = {0, 0, 0};
    struct object_def      FAR *obj_got; /*@WIN*/
    struct object_def      FAR *ary_obj; /*@WIN*/
    fix                     n, i;
    byte                   FAR *sfnt;    /*@WIN*/

#ifdef DBGfpp
    printf("entering chk_sfnt()....\n");
#endif

    /* check font dictionary registration */
//  if (DFONT((struct dict_head_def FAR *)VALUE(font_dict)) ) { fixed by @SC
    if (DFONT((struct dict_head_def FAR *)VALUE(font_dict)) == 0) { /*@WIN*/
        ERROR(INVALIDFONT);
        return(NULL);
    }

    /* get sfnts */
    ATTRIBUTE_SET(&obj, LITERAL);
    get_name(&obj, "sfnts", 5, TRUE);
    if (!get_dict(font_dict, &obj, &obj_got)) {
        ERROR(INVALIDFONT);
        return(NULL);
    }
    if (TYPE(obj_got) != ARRAYTYPE) {
        ERROR(INVALIDFONT);
        return(NULL);
    }
    n = LENGTH(obj_got);
    ary_obj = (struct object_def FAR *)VALUE(obj_got); /*@WIN*/
    for (i=0; i<n; i++) {
        if (TYPE(&ary_obj[i]) != STRINGTYPE) {
            ERROR(INVALIDFONT);
            return(NULL);
        }
    }
    sfnt= (byte FAR *)VALUE(ary_obj); /*@WIN*/
#ifdef DBGfpp
    printf("leaving chk_sfnt()....\n");
#endif
    return(sfnt);
} /* chk_sfnt() */


/***********************************************************************
** TITLE:      setup_CharString()              Date:   10/12/90
**
** FUNCTION:   Set up CharStrings from 'post' table
***********************************************************************/
static struct object_def  FAR *setup_CharString(sfnt) /*@WIN*/
byte   FAR *sfnt; /*@WIN*/
{
    register fsg_SplineKey  FAR *key = &KeyData; /*SVM @WIN_BASS*/
    sfnt_PostScriptInfo      FAR *postScript; /*@WIN*/
    sfnt_maxProfileTable     FAR *profile;    /*@WIN*/
/*SVM, Kason 3/8/91
 *  ufix16                   glyphidx, id_apple, apple_pos ;
 *  ufix16                   id_space, id_notdef, space_pos, notdef_pos;
 *  byte                     *glyphname;
 */
    real32                   fmt_no;
    ufix16                   num_glyph, glyphidx; /*SVM*/
    struct dict_head_def     huge *cd_ptr; /*@WIN 04-20-92*/
    struct new_str_dict      cd_obj[NO_CD];
    ufix16                   huge *keyptr; /*@WIN 04-20-92*/
    struct cd_header         huge *cd_head_ptr; /*@WIN 04-20-92*/
    fix16                    huge *cd_code_ptr; /*@WIN 04-20-92*/
    struct object_def        huge *rtn_obj;     /*@WIN 04-20-92*/

#ifdef DBGfpp
       printf("entering setup_CharString()..... \n");
#endif

      /* get memory for returned object */
      rtn_obj= (struct object_def huge *)alloc_vm((ufix32)sizeof(struct
object_def)); /*@WIN*/
      if ( rtn_obj== (struct object_def huge *)NULL ) { /*@WIN 04-20-92*/
           return ( (struct object_def FAR *)NULL ); /*@WIN*/
      } /* if */
      /* returned object setting */
      TYPE_SET(rtn_obj, DICTIONARYTYPE);
      ATTRIBUTE_SET(rtn_obj, LITERAL);
      ROM_RAM_SET(rtn_obj, ROM);
      LEVEL_SET(rtn_obj, current_save_level);
      ACCESS_SET(rtn_obj, READONLY);
      LENGTH(rtn_obj) = (fix16)NO_CD;

#if 0 /*SVM*/
      SfntAddr=sfnt;
      SetupKey(key, (ULONG_PTR)sfnt);
      sfnt_DoOffsetTableMap( key );      /* Map offset and length table */
#endif /*0*/
      /* post table */

/* repalce by Falco. 11/12/91 */
/*    postScript=(sfnt_PostScriptInfo*)
                        sfnt_GetTablePtr( key, sfnt_PostScript, false);*/
      postScript=(sfnt_PostScriptInfo FAR *)     /*@WIN*/
                        sfnt_GetTablePtr( key, sfnt_Postscript, false);
/* replace end */
      if ( postScript==(sfnt_PostScriptInfo FAR *)NULL ) { /*@WIN*/
         ERROR(INVALIDFONT);
         return ( (struct object_def FAR *)NULL ); /*@WIN*/
      }
      profile = (sfnt_maxProfileTable FAR *) /*@WIN*/
                        sfnt_GetTablePtr( key, sfnt_maxProfile, false );
      if ( profile==(sfnt_maxProfileTable FAR *)NULL ) { /*@WIN*/
         ERROR(INVALIDFONT);
         return ( (struct object_def FAR *)NULL ); /*@WIN*/
      }

      /* @@SWAP1 BEGIN 03/15/91 D.S. Tseng */
  { long dbg;                                           /*@WIN*/
    dbg = SWAPL(postScript->version);                   /*@WIN*/
    fmt_no = FIXED2FLOAT(dbg);                          /*@WIN*/
//    fmt_no = FIXED2FLOAT(SWAPL(postScript->version));
  }
      /* @@SWAP1 END   03/15/91 D.S. Tseng */
      if(fmt_no==(float)1.0) {          //@WIN
         num_glyph=SFNTGLYPHNUM;
         /* returned object */
         VALUE(rtn_obj)  = (ULONG_PTR)cd_addr[STD_IDX] ;
#ifdef DBGfpp
         printf("format 1.0 , CD return !!\n");
#endif
         return( rtn_obj );
      }
      else if (fmt_no==(float)2.0)      //@WIN
        {
        /* @@SWAP1 BEGIN 03/15/91 D.S. Tseng */
         num_glyph = SWAPW(*( ufix16 FAR * )( postScript+1 )); /*@WIN*/
        /* @@SWAP1 END   03/15/91 D.S. Tseng */
#ifdef DBGfpp
         printf("postScript num=%u\n",num_glyph);
#endif
        }
      else if (fmt_no==(float)2.5)      //@WIN
        /* @@SWAP1 BEGIN 03/15/91 D.S. Tseng */
         num_glyph = SWAPW(profile->numGlyphs);
        /* @@SWAP1 END   03/15/91 D.S. Tseng */
      else { /*???*/
         return ( (struct object_def FAR *)NULL ); /*@WIN*/
      }


      /* put data into char descript dict object */
      for(glyphidx=0; glyphidx<num_glyph; glyphidx++) {
          /*SVM*/
          cd_obj[glyphidx].k = glyphidx2name( postScript, glyphidx );

          cd_obj[glyphidx].v = glyphidx; /* value */
      }/* for */

      /* make the value of ".notdef" and "apple" as the one of "space" */
   /*SVM
    * id_space=hash_id((byte *) SPACE);
    * id_notdef = hash_id((byte *) NOTDEF);
    * id_apple = hash_id((byte *) APPLE);
    */
    {/*SVM*/
      ufix16  notdef_pos=0, space_pos=0, apple_pos=0 ;
      bool    has_space=FALSE, has_notdef=FALSE ,has_apple=FALSE ;

      for(glyphidx=0; glyphidx<num_glyph; glyphidx++) {
          if (cd_obj[glyphidx].k == id_space)
             { space_pos=glyphidx; has_space=TRUE; break; } /*SVM*/
      }
      for(glyphidx=0; glyphidx<num_glyph; glyphidx++) {
          if (cd_obj[glyphidx].k == id_notdef)
             { notdef_pos=glyphidx; has_notdef=TRUE; break; } /*SVM*/
      }
      if (has_notdef){ /*SVM,glyphidx<num_glyph*/
         if (has_space)
            cd_obj[notdef_pos].v = cd_obj[space_pos].v;
         else
            cd_obj[notdef_pos].k = hash_id( (byte FAR *)"nodef" ); /*@WIN*/
      }
      for(glyphidx=0; glyphidx<num_glyph; glyphidx++) {
          if (cd_obj[glyphidx].k == id_apple)
             { apple_pos=glyphidx; has_apple=TRUE; break; }
      }
      if (has_apple){ /*SVM,glyphidx<num_glyph*/
          cd_obj[apple_pos].k = cd_obj[notdef_pos].k;
          cd_obj[apple_pos].v = cd_obj[notdef_pos].v;
      }
    }/*SVM*/

      /* Sorting the char descrip data object by hashid */
      cd_sorting(cd_obj, &num_glyph);

      /* get memory for charstrings */
      cd_ptr= (struct dict_head_def huge *)alloc_vm((ufix32)CD_SIZE(num_glyph));
      if ( cd_ptr== (struct dict_head_def huge *)NULL ) { /*@WIN 04-20-92*/
           return ( (struct object_def FAR *)NULL ); /*@WIN*/
      } /* if */
      cd_head_ptr=(struct cd_header huge *) ( cd_ptr+1 ); /*@WIN 04-20-92*/
      keyptr=(ufix16 huge *) alloc_vm( (ufix32)CD_KEY_SIZE(num_glyph) );
      if ( keyptr== (ufix16 huge *)NULL ){ /*@WIN 04-20-92*/
           return ( (struct object_def FAR *)NULL ); /*@WIN*/
      }/* if */
      cd_head_ptr->key = keyptr;
      cd_head_ptr->base = (gmaddr)0;
      cd_head_ptr->max_bytes = (ufix16)0;
      cd_code_ptr = (fix16 huge *)( cd_head_ptr+1 ); /*@WIN*/

      /* feed data into charstrings */
      for( glyphidx=0 ; glyphidx< num_glyph; glyphidx++) {
         keyptr[glyphidx] = cd_obj[glyphidx].k;
         cd_code_ptr[glyphidx] = (fix16)cd_obj[glyphidx].v;
      }/* for */

      /* CharString dict header set up */
      DACCESS_SET(cd_ptr, READONLY);
      DPACK_SET(cd_ptr, TRUE);
      DFONT_SET(cd_ptr, FALSE);
      DROM_SET(cd_ptr, TRUE);
      cd_ptr->actlength = (fix16)num_glyph;

      /* returned object */
      VALUE(rtn_obj)  = (ULONG_PTR)cd_ptr;

#ifdef DBGfpp
      printf("leaving setup_CharString()...... \n");
#endif
      return( rtn_obj );

}/* setup_CharString() */

/*SVM, Kason 3/6/91 */
static void proc_hashid()
{
   register fix16 i;
   id_space = hash_id( (byte FAR *)SPACE ); /*@WIN*/
   id_notdef = hash_id( (byte FAR *)NOTDEF ); /*@WIN*/
   id_apple = hash_id( (byte FAR *)APPLE ); /*@WIN*/
   for(i=0; i< SFNTGLYPHNUM ; i++)
      *(chset_hashid+i)= hash_id((byte FAR *) *(sfntGlyphSet+i) ) ; /*@WIN*/
   /*init cd_addr_ary[]*/
   //DJC for(i=0; i< NO_BUILTINFONT ; i++)
   for(i=0; i< MAX_INTERNAL_FONTS ; i++)
      *(cd_addr_ary+i) = 0 ;
}/*proc_hashid*/

/***********************************************************************
** TITLE:      valid_sfnt()              Date:   10/12/90
**
** FUNCTION:   Check the validness of sfnt data
***********************************************************************/
static bool  valid_sfnt(sfnt)
byte   huge *sfnt;      /*@WIN 04-20-92*/
{
   sfnt_OffsetTable             FAR *table = (sfnt_OffsetTable FAR *)sfnt; /*@WIN*/
   sfnt_DirectoryEntry          FAR *offset_len=table->table; /*@WIN*/
   register fsg_SplineKey       FAR *key = &KeyData; /*SVM @WIN_BASS*/
   sfnt_FontHeader              FAR *fontHead; /*@WIN*/
   fix16                        no_table,i;

#ifdef DBGfpp
   printf("entering valid_sfnt()......\n");
#endif

   SfntAddr=sfnt;
   SetupKey(key, (ULONG_PTR)sfnt);    /* &sfnt_keystru->key, SVM */
   sfnt_DoOffsetTableMap( key );   /* Map offset and length table */

   /* essential table check */
/* mark by Falco for incompatible key, 11/08/91 */
/* if ( (key->offsetTableMap[sfnt_fontHeader]==-1)        ||
        (key->offsetTableMap[sfnt_charToIndexMap]==-1)    ||
        (key->offsetTableMap[sfnt_glyphData]==-1)         ||
        (key->offsetTableMap[sfnt_horiHeader]==-1)        ||
        (key->offsetTableMap[sfnt_horizontalMetrics]==-1) ||
        (key->offsetTableMap[sfnt_indexToLoc]==-1)        ||
        (key->offsetTableMap[sfnt_maxProfile]==-1)        ||
        (key->offsetTableMap[sfnt_Names]==-1)             ||
        (key->offsetTableMap[sfnt_Postscript]==-1)         ) {
#ifdef DBGfpp
      printf("Essential table checks ERROR!!\n");
#endif
      return FALSE ;
   }
*/
/* mark end */

#ifdef DBGfpp
   printf("Essential table checks O.K!!\n");
#endif

   /* Magic number check */
   fontHead = (sfnt_FontHeader FAR *)sfnt_GetTablePtr(key, sfnt_fontHeader, true ); /*@WIN*/
   /* @@SWAP1 BEGIN 03/13/91 D.S. Tseng */
   if (SWAPL(fontHead->magicNumber) != SFNT_MAGIC ) {
   /* @@SWAP1 END   03/13/91 D.S. Tseng */
#ifdef DBGfpp
        printf("Magic number checks ERROR!!\n");
#endif
        return FALSE /* BAD_MAGIC_ERR */;
   }

#ifdef DBGfpp
   printf("Magic number checks O.K!!\n");
#endif
   /* table check sum check */
   /* @@SWAP1 BEGIN 03/13/91 D.S. Tseng */
   no_table=(ufix16)SWAPW(table->numOffsets);
   /* @@SWAP1 END   03/13/91 D.S. Tseng */

   for (i = 0 ; i < no_table; i++) {
     /* @@SWAP1 BEGIN 03/13/91 D.S. Tseng */
     if ( SWAPL((offset_len+i)->tag) != tag_FontHeader ) {  /* Kason 12/13/90 */
       if( (ufix32)SWAPL((offset_len+i)->checkSum) !=   //@WIN
          CalcTableChecksum( (ufix32 FAR *)( sfnt+SWAPL((offset_len+i)->offset)) , /*@WIN*/
                             SWAPL((offset_len+i)->length))  ) {
     /* @@SWAP1 END   03/13/91 D.S. Tseng */

#ifdef DBGfpp
          printf("CheckSum  checks ERROR!!\n");
#endif
          return FALSE ;
       }/* if */
     }

   }/* for */

#ifdef DBGfpp
   printf("CheckSum  checks O.K!!\n");
#endif
   return  TRUE ;

} /* valid_sfnt() */


static ufix32   CalcTableChecksum( table, length )
ufix32  FAR *table; /*@WIN*/
ufix32  length;
{
   ufix32  sum=0L;
   ufix32  FAR *endptr = table +( ( (length+3) & ~3 ) / sizeof(ufix32)); /*@WIN*/

#ifdef DBGfpp
/*   printf("entering CalcTableChecksum()......\n"); */
#endif
   while ( table < endptr ) {
         /* @@SWAP1 BEGIN 03/13/91 D.S. Tseng */
         sum += SWAPL(*table); /* @@@ Kason 12/06/90 */
         /* @@SWAP1 END   03/13/91 D.S. Tseng */
         table++;
   } /*while*/
#ifdef DBGfpp
/*   printf("leaving CalcTableChecksum()......\n"); */
#endif
   return sum;

}/* CalcTableChecksum() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\gei\geicfg.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GEIcfg.h
 *
 *  HISTORY:
 *  09/20/90    byou    merge all configuration header files into this one.
 *                      - IO and Engine configuration parameters.
 *                      - Timeouts parameters (job, manualfeed and wait)
 * ---------------------------------------------------------------------
 */

#ifndef _GEICFG_H_
#define _GEICFG_H_

#include    "geiioctl.h"

/*
 * ---------------------------------------------------------------------
 *  IO Configuration
 * ---------------------------------------------------------------------
 */

    /*
     * ---
     *  IO Device (Serial, Parallel and Appletalk) Configuration Parameters
     * ---
     */
    typedef
        struct serialcfg
        {
            unsigned long       timeout;
            unsigned char       baudrate;
            unsigned char       flowcontrol;
            unsigned char       parity;
            unsigned char       stopbits;
            unsigned char       databits;
        }
    serialcfg_t;

    typedef
        struct parallelcfg
        {
            unsigned long       timeout;
        }
    parallelcfg_t;

    typedef
        struct atalkcfg
        {
            unsigned long       timeout;    /* wait timeout */
            unsigned char       prname[ _MAXPRNAMESIZE ];   /* in pascal */
        }
    atalkcfg_t;

/*
 * ---------------------------------------------------------------------
 *  Engine Configuration
 * ---------------------------------------------------------------------
 */

    /*
     * ---
     *  Engine Configuration Parameters
     * ---
     */
    typedef
        struct engcfg
        {
            unsigned long       timeout;    /* manualfeed timeout */
            unsigned long       leftmargin;
            unsigned long       topmargin;
            unsigned char       pagetype;
        }
    engcfg_t;

/*
 * ---------------------------------------------------------------------
 *  Timeouts Configuration
 * ---------------------------------------------------------------------
 */

    /*
     * ---
     *  Timeouts Configuration Parameters
     * ---
     */
    typedef
        struct toutcfg
        {
            unsigned long       jobtout;
            unsigned long       manualtout;
            unsigned long       waittout;
        }   /* all in millisecond */
    toutcfg_t;

#endif /* !_GEICFG_H_ */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\font\rtfpp.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
#define    FontType	       "FontType"
#define    PaintType	       "PaintType"
#define    FontMatrix	       "FontMatrix"
#define    FontBBox	       "FontBBox"
#define    FontwareRules       "FontwareRules"
#define    Encoding	       "Encoding"
#define    CharStrings	       "CharStrings"
#define    Private	       "Private"
#define    FID		       "FID"
#define    FontName	       "FontName"
#define    CDevProc	       "CDevProc"
#define    sfnts	       "sfnts"

#define    UniqueID	       "UniqueID"
#define    StrokeWidth	       "StrokeWidth"

#define    FontInfo	       "FontInfo"
#define    Version	       "Version"
#define    OutlineResolution   "OutlineResolution"
#define    Notice	       "Notice"
#define    Date 	       "Date"
#define    FullName	       "FullName"
/*
#define    isFixedPitch        "isFixedPitch"
*/
#define    UnderlineThickness  "UnderlineThickness"
#define    Weight	       "Weight"
#define    UnderlinePosition   "UnderlinePosition"
#define    ItalicAngle	       "ItalicAngle"
#define    FamilyName	       "FamilyName"

#define    Metrics	       "Metrics"
#define    BuildChar	       "BuildChar"

#define    NOTDEF	       ".notdef"
#define    SPACE	       "space"
#define    APPLE	       "apple"  /* Kason 12/05/90 */

#define    FONT_TYPE	       1
#define    ROYALTYPE	      42
#define    PAINTTYPE	       0
#define    OUTLINERESOLUTION   1000

/* 9/19/90; ccteng; add for readsfnt */
#define    BIN			0
#define    HEX			1


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\gei\geieng.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GEIeng.h
 *
 *  HISTORY:
 *  09/20/90    byou    created.
 * ---------------------------------------------------------------------
 */

#ifndef _GEIENG_H_
#define _GEIENG_H_

/*
 * ---
 *  Engine Error Code Definitions
 * ---
 */
#define         EngNormal               0
#define         EngErrPaperOut          1
#define         EngErrPaperJam          2
#define         EngErrWarmUp            3
#define         EngErrCoverOpen         4
#define         EngErrTonerLow          5
#define         EngErrHardwareErr       6

/*
 * ---
 *  Page Tray Code Definitions
 * ---
 */
#define         PaperTray_LETTER        0
#define         PaperTray_LEGAL         1
#define         PaperTray_A4            2
#define         PaperTray_B5            3
/* #define         PaperTray_NOTE          4 Jimmy */

/*
 * ---
 *  Cassette/Manual feed Modes
 * ---
 */
#define         CASSETTE                0
#define         MANUALFEED              1
/*
 * ---
 *  Page Print Parameters
 * ---
 */
typedef
    struct GEIpage
    {
        unsigned char  FAR *pagePtr;    /* starting addr of page bitmap */
        int             pageNX;     /* # of pixels per scanline     */
        int             pageNY;     /* # of scanline per page       */
        int             pageLM;     /* left margin position on page */
        int             pageTM;     /* top margin position on page  */
        short           feed_mode;  /* cassette/manual feed mode    */
    }
GEIpage_t;

/*
 * ---
 *  Interface Routines
 * ---
 */
/* @WIN; add prototype */
void            GEIeng_setpage( /* GEIpage_t* */ );
int /* bool */  GEIeng_printpage( /* nCopies, eraseornot */ );
int             GEIeng_checkcomplete(void); /* return # of scanlines printed */
unsigned long   GEIeng_status();            /* return engine status */
unsigned int    GEIeng_paper();             /* get paper type */
#endif /* _GEIENG_H_ */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\gei\geierr.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GEIerr.h
 *
 *  HISTORY:
 *  09/13/90    byou        created.
 *  01/07/91    billlwo     rename GEIseterror to GESseterror
 * ---------------------------------------------------------------------
 */

#ifndef _GEIERR_H_
#define _GEIERR_H_

#ifdef  UNIX
#define volatile
#endif  /* UNIX */
/*
 * ---
 *  Error Code List
 * ---
 */
#define     EZERO            0
#define     EPERM            1
#define     ENOENT           2
#define     ESRCH            3
#define     EINTR            4
#define     EIO              5
#define     ENXIO            6
#define     E2BIG            7
#define     ENOEXEC          8
#define     EBADF            9
#define     ECHILD          10
#define     EAGAIN          11
#define     ENOMEM          12
#define     EACCES          13
#define     EFAULT          14
#define     ENOTBLK         15
#define     EBUSY           16
#define     EEXIST          17
#define     EXDEV           18
#define     ENODEV          19
#define     ENOTDIR         20
#define     EISDIR          21
#define     EINVAL          22
#define     ENFILE          23
#define     EMFILE          24
#define     ENOTTY          25
#define     ETXTBSY         26
#define     EFBIG           27
#define     ENOSPC          28
#define     ESPIPE          29
#define     EROFS           30
#define     EMLINK          31
#define     EPIPE           32
#define     EDOM            33
#define     ERANGE          34
#define     EUCLEAN         35
#define     EDEADLOCK       36
#define     ENAMETOOLONG    63
#define     ETIME           73
#define     ENOSR           74
#define     ENOSYS          90

/*
 * ---
 *  Interface Routines
 * ---
 */
volatile    extern int      GEIerrno;

#define     GEIerror()      ( GEIerrno )
#define     GESseterror(e)  ( GEIerrno = (e) )
#define     GEIclearerr()   (void)( GEIerrno = EZERO )

#endif /* !_GEIERR_H_ */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\gei\geiio.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GEIio.h
 *
 *  HISTORY:
 *  04-07-92   SCC   Add prototypes and re-order the sequence of typedef
 * ---------------------------------------------------------------------
 */

#ifndef _GEIIO_H_
#define _GEIIO_H_

#ifndef TRUE
#define TRUE    ( 1 )
#define FALSE   ( 0 )
#endif

#ifndef NULL
#define NULL    ( 0 )
#endif

#ifndef EOF
#define EOF     ( -1 )
#endif


/*
 * ---
 *  File Buffer Structure
 * ---
 */
typedef
    struct GEIfbuf
    {
        int                 f_refcnt;
        int                 f_size;
        int                 f_cnt;
        unsigned char FAR * f_ptr;
        unsigned char FAR * f_base;

        /* the following are used by old version EDIT: PJ */
        short               rw_buffer;
        short               rw_offset;
        short               incount;
        unsigned int        size;
        char                inchar[2];
    }
GEIfbuf_t;

/* @WIN; move typedef of GEIfmodq_t to here before using it */
typedef
    struct GEIfmodq
    {
        struct GEIfmodq FAR *    next;
//      GEIfmod_t FAR *          fmod;     @WIN: avoid define recursively
        struct GEIfmod FAR *     fmod;
        char FAR *               private;
    }
GEIfmodq_t;

/*
 * ---
 *  File Stream Structure
 * ---
 */
/* @WIN; move typedef of GEIFILE to here before using it */
typedef
    struct  GEIiofile
    {
        unsigned short      f_type;
        unsigned short      f_flag;
        short               f_handle;
        GEIfbuf_t FAR *     f_fbuf;
        GEIfmodq_t FAR *    f_modq;
        int                 f_opentag;
        int                 f_savelevel;

        /* the following are used by old version EDIT: PJ */
        unsigned short      f_oldtype;
    }
GEIFILE;

/*
 * ---
 *  File Module Structure
 * ---
 */
/* @WIN; add prototype */
typedef
    struct GEIfmod
    {
        char FAR * fmod_name;
        int (FAR *fmod_open) (GEIFILE FAR *, GEIfmodq_t FAR *);
                              /* file, *this_fmodq */
        int (FAR *fmod_close)(GEIFILE FAR *, GEIfmodq_t FAR *);
                              /* file, *this_fmodq */
        int (FAR *fmod_ioctl)(GEIFILE FAR *, GEIfmodq_t FAR *, int, int FAR*);
                              /* file, *this_fmodq, req, arg */
        int (FAR *fmod_read) (GEIFILE FAR *, GEIfmodq_t FAR *, char FAR *, int);
                              /* file, *this_fmodq, buf, size */
        int (FAR *fmod_write)(GEIFILE FAR *, GEIfmodq_t FAR *, char FAR *, int);
                              /* file, *this_fmodq, buf, size */
        int (FAR *fmod_flush)(GEIFILE FAR *, GEIfmodq_t FAR *);
                              /* file, *this_fmodq */
        int (FAR *fmod_ungetc)(int, GEIFILE FAR *, GEIfmodq_t FAR *);
                              /* char2pushback, file, *this_fmodq */
        int (FAR *fmod_getc) (GEIFILE FAR *, GEIfmodq_t FAR *);
                              /* file, *this_fmodq */
        int (FAR *fmod_putc) (GEIFILE FAR *, GEIfmodq_t FAR *, int);
                              /* file, *this_fmodq, char2put */
    }
GEIfmod_t;



/*  the following macros should never be used by anyone except GEIio */
#   define  FMODQ_OPEN(f,mq)            \
                ( *((mq)->fmod->fmod_open)  )( f, mq )
#   define  FMODQ_CLOSE(f,mq)           \
                ( *((mq)->fmod->fmod_close) )( f, mq )
#   define  FMODQ_IOCTL(f,mq,req,arg)   \
                ( *((mq)->fmod->fmod_ioctl) )( f, mq, req, arg )

void        GESio_closeall(void);

/* interface routines for file modules to call, but through macros only */
/* @WIN; add prototype */
int         GESio_read(GEIFILE FAR *, char FAR *, int);
int         GESio_write(GEIFILE FAR *, unsigned char FAR *, int );
int         GESio_flush(GEIFILE FAR *);
int         GESio_ungetc(int, GEIFILE FAR *);
int         GESfbuf_fill(GEIFILE FAR *);
int         GESfbuf_flush(GEIFILE FAR *, int);

/* macros for file modules to use directly */

#   define  FMODQ_NEXT(mq)          ( (mq)->next )

#   define  FMODQ_NAME(mq)          \
                (                                                           \
                    (mq) != (GEIfmodq_t FAR *)NULL?                         \
                        ( (mq)->fmod->fmod_name )  :  (char FAR *)NULL      \
                )

/* Bill 04/30/'91 add it according to performance issue */

#ifdef FMODQ
#   define  FMODQ_READ(f,mq,buf,s)  \
                (                                                           \
                    (mq) != (GEIfmodq_t FAR *)NULL?                         \
                        ( *((mq)->fmod->fmod_read) )( f, mq, buf, s )  :    \
                        GESio_read( f, buf, s )                             \
                )
#   define  FMODQ_WRITE(f,mq,buf,s) \
                (                                                           \
                    (mq) != (GEIfmodq_t FAR *)NULL?                         \
                        ( *((mq)->fmod->fmod_write) )( f, mq, buf, s )  :   \
                        GESio_write( f, buf, s )                            \
                )
#   define  FMODQ_FLUSH(f,mq)       \
                (                                                           \
                    (mq) != (GEIfmodq_t FAR *)NULL?                         \
                        ( *((mq)->fmod->fmod_flush) )( f, mq )  :           \
                        GESio_flush( f )                                    \
                )
#   define  FMODQ_UNGETC(c,f,mq)    \
                (                                                           \
                    (mq) != (GEIfmodq_t FAR *)NULL?                         \
                        ( *((mq)->fmod->fmod_ungetc) )( c, f, mq )  :       \
                        GESio_ungetc( c, f )                                \
                )
#   define  FMODQ_PUTC(f,mq,c)      \
                (                                                           \
                    (mq) != (GEIfmodq_t FAR *)NULL?                         \
                        ( *((mq)->fmod->fmod_putc) )( f, mq, c )  :         \
                    --((f)->f_fbuf->f_cnt) >= 0 ?                           \
                        *( (f)->f_fbuf->f_ptr++ ) = (unsigned char)( c )  : \
                        GESfbuf_flush( f, c )                               \
                )
#   define  FMODQ_GETC(f,mq)        \
                (                                                           \
                    (mq) != (GEIfmodq_t FAR *)NULL?                         \
                        ( *((mq)->fmod->fmod_getc) )( f, mq )   :           \
                    --((f)->f_fbuf->f_cnt) >= 0 ?                           \
                        *( (f)->f_fbuf->f_ptr++ )  :                        \
                        GESfbuf_fill( f )                                   \
                )
#else
#   define  FMODQ_READ(f,mq,buf,s)  \
                (                                                           \
                        GESio_read( f, buf, s )                             \
                )
#   define  FMODQ_WRITE(f,mq,buf,s) \
                (                                                           \
                        GESio_write( f, buf, s )                            \
                )
#   define  FMODQ_FLUSH(f,mq)       \
                (                                                           \
                        GESio_flush( f )                                    \
                )
#   define  FMODQ_UNGETC(c,f,mq)    \
                (                                                           \
                        GESio_ungetc( c, f )                                \
                )
#   define  FMODQ_PUTC(f,mq,c)      \
                (                                                           \
                    --((f)->f_fbuf->f_cnt) >= 0 ?                           \
                        *( (f)->f_fbuf->f_ptr++ ) = (unsigned char)( c )  : \
                        (unsigned char)GESfbuf_flush( f, c ) /*@WIN*/       \
                )

#ifdef DJC
// change cast of (unsigned char) to nothing
#   define  FMODQ_GETC(f,mq)        \
                (                                                           \
                    --((f)->f_fbuf->f_cnt) >= 0 ?                           \
                        *( (f)->f_fbuf->f_ptr++ )  :                        \
                        (unsigned char)GESfbuf_fill( f )     /*@WIN*/       \
                )
#else
#   define  FMODQ_GETC(f,mq)        \
                (                                                           \
                    --((f)->f_fbuf->f_cnt) >= 0 ?                           \
                        *( (f)->f_fbuf->f_ptr++ )  :                        \
                        GESfbuf_fill( f )     /*@WIN*/       \
                )
#endif // DJC


#endif

/* file check macros */
#   define  GEIio_isopen( f )       \
                ( (f) != (GEIFILE FAR *)NULL  &&  (f)->f_handle != EOF )
#   define  GEIio_isok( f )         \
                ( GEIio_isopen(f)  &&  !((f)->f_flag & _F_ERR) )
#   define  GEIio_isreadable( f )   \
                ( GEIio_isok(f)  &&  (f)->f_flag & _O_RDONLY )
#   define  GEIio_iswriteable( f )  \
                ( GEIio_isok(f)  &&  (f)->f_flag & _O_WRONLY )
#   define  GEIio_eof( f )          \
                ( !GEIio_isopen(f)  ||  (f)->f_flag & _F_EOF )
#   define  GEIio_err( f )          \
                ( !GEIio_isopen(f)  ||  (f)->f_flag & _F_ERR )
#   define  GEIio_clearerr( f )     \
                {                                               \
                    if( GEIio_isopen(f) )                       \
                        ( (f)->f_flag &= ~(_F_EOF |_F_ERR) );   \
                }

/* file type definition     */
#   define     _S_IFNON     ( 0 )
#   define     _S_IFCHR     ( 1 )
#   define     _S_IFREG     ( 3 )
#   define     _S_IFSTR     ( 6 )
#   define  GEIio_ischr( f )        ( (f)->f_type == _S_IFCHR )
#   define  GEIio_isreg( f )        ( (f)->f_type == _S_IFREG )
#   define  GEIio_isstr( f )        ( (f)->f_type == _S_IFSTR )

/***
# * define     _S_IFBLK     ( 2 )
# * define     _S_IFDIR     ( 4 )
# * define     _S_IFLNK     ( 5 )
# * define  GEIio_isblk( f )        ( (f)->f_type == _S_IFBLK )
# * define  GEIio_isdir( f )        ( (f)->f_type == _S_IFDIR )
# * define  GEIio_islnk( f )        ( (f)->f_type == _S_IFLNK )
 ***/

#   define     _S_IFEDIT    ( 7 )   /* to be removed someday */
#   define  GEIio_isedit( f )       ( (f)->f_type == _S_IFEDIT )
#   define  GEIio_setedit( f )      { (f)->f_oldtype = (f)->f_type;     \
                                      (f)->f_type = _S_IFEDIT; }

/* file flag definition */
#   define     _F_RWMASK    ( 00007 )   /* read/write mask */
#   define         _O_RDONLY    ( 00001 )
#   define         _O_WRONLY    ( 00002 )
#   define         _O_RDWR      ( _O_RDONLY | _O_WRONLY )   /* not support */
#   define     _F_MDMASK    ( 00070 )   /* operation mode mask */
#   define         _O_APPEND    ( 00010 )
#   define         _O_NDELAY    ( 00020 )
#   define         _O_SYNC      ( 00040 )
#   define     _F_ONLY4OPEN ( 00700 )   /* never put onto f_flag */
#   define         _O_TRUNC     ( 00100 )       /* for file sys only */
#   define         _O_CREAT     ( 00200 )       /* for file sys only */
#   define         _O_EXCL      ( 00400 )       /* for file sys only */
#   define     _F_EOF       ( 00100 )
#   define     _F_ERR       ( 00200 )
#   define     _F_MYBUF     ( 00400 )

/* only for TrueImage usage */
#   define  GEIio_opentag( f )      ( (f)->f_opentag )
#   define  GEIio_savelevel( f )    ( (f)->f_savelevel )
#   define  GEIio_setsavelevel(f,s) (void)( (f)->f_savelevel = (s) )

/*
 * ---
 *  Standard File Streams
 * ---
 */
extern GEIFILE   FAR *GEIio_stdin,  FAR *GEIio_stdout,  FAR *GEIio_stderr;

/*
 * ---
 *  Interface Routines
 * ---
 */
#   define  GEIio_source( )         \
            ctty->devname
/*  Bill 05/02/'91 refine it according to performance issue

#   define  GEIio_getc( f )         \
                ( GEIio_isreadable(f)? FMODQ_GETC( f, (f)->f_modq ) : EOF )
#   define  GEIio_ungetc( c, f )    \
                (                                                   \
                        c!=EOF?              \
                        FMODQ_UNGETC( c, f, (f)->f_modq ) : EOF \
                )
#   define  GEIio_putc( f, c )      \
                ( GEIio_iswriteable(f)? FMODQ_PUTC( f, (f)->f_modq, c ) : EOF )
*/

#   define  GEIio_getc( f )         \
                ( FMODQ_GETC( f, (f)->f_modq ) )
#   define  GEIio_ungetc( c, f )    \
                (                                                   \
                    GEIio_isreadable( f )  &&  c!=EOF?              \
                        FMODQ_UNGETC( c, f, (f)->f_modq ) : EOF     \
                )
#   define  GEIio_putc( f, c )      \
                ( FMODQ_PUTC( f, (f)->f_modq, c ) )

/* @WIN; add prototype */
int         GEIio_forceopenstdios(unsigned /* usingCTTY, seebelow */ );
#               define      _FORCESTDIN     ( 00001 )
#               define      _FORCESTDOUT    ( 00002 )
#               define      _FORCESTDERR    ( 00004 )
#               define      _FORCESTDALL    ( 00007 )
int         GEIio_setstdios(GEIFILE FAR *, GEIFILE FAR *, GEIFILE FAR *);

GEIFILE FAR *    GEIio_firstopen(void);
GEIFILE FAR *    GEIio_nextopen(void);

/* @WIN; add prototype */
GEIFILE FAR *    GEIio_open(char FAR *, int, int );
GEIFILE FAR *    GEIio_sopen(char FAR *, int, int );
GEIFILE FAR *    GEIio_dup(GEIFILE FAR *);
int         GEIio_close(GEIFILE FAR *);
int         GEIio_flush(GEIFILE FAR *);
int         GEIio_read(GEIFILE FAR *, char FAR *, int);         /* @WIN */
int         GEIio_write(GEIFILE FAR *, unsigned char FAR *, int);/* @WIN */
int         GEIio_ioctl(GEIFILE FAR *, int, int FAR *);        /* @WIN */
#ifdef DBGDEV
#ifdef __I960__
int         printf(const char  FAR *, ...);
#else
int         printf( /* format, ... */ );
#endif
#endif
int         GEIio_printf();   // GEIFILE FAR *, char FAR *, ...);
                         /* file, format, ... */

/* status update */
void        GESio_obtainstatus(char FAR * FAR *statusaddr, int FAR *len);

/* set wait timeout */
void        GEIio_setwaittimeout(unsigned long /* wait-timeout-in-msec */ );

/* channel name (in gesiocfg.c) */
char FAR *       GEIio_channelname(int /* 25 or 9 */ );  /* for scc stuff */
char FAR *       GEIio_channelnameforall(int /* index */ );

/* select stdios (in gesiocfg.c) */
int         GEIio_selectstdios(void);   /* @WIN */

#endif /* !_GEIIO_H_ */

/* @WIN; add prototype */
void        GEIio_init(void);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\gei\geiio.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GEIio.c
 *
 *  COMPILATION SWITCHES:
 *      FILESYS     - to invoke file system, if defined.
 *
 *  HISTORY:
 *  09/15/90    Erik Chen   created.
 *  10/18/90    byou        removed all about block devices.
 *  10/22/90    byou        revised a lot.
 *                          added code for GESevent.
 *                          removed 'selectstdios' into 'gesiocfg.c'.
 *  01/07/91    billlwo     rename GEIseterror to GESseterror
 *                          update GESio_closeall() to close from
 *                          FileTableBeg.
 * 01/24/91     billlwo     fixed selectstdios() bug in auto polling
 *                          update GESio_closeall() to close from
 *                          FileTable. because GEIio_stderr not close by TI
 * 02/23/91     billlwo     Fixed bug in EOF processing in GES-GEI interface
 * 09/10/91     Falco       revise the status string in the GEIio_init to
 *                          make sure to get the correct string.
 * 09/10/91     Falco       To verify the ic_startup is already or not, only
 *                          initialization is ready, then can get the actual
 *                          status.
 * ---------------------------------------------------------------------
 */

// DJC added global include file
#include "psglobal.h"

#ifdef MTK
extern void    pdl_process(),pdl_no_process();
#endif  /* MTK */

#include        <string.h>

#include        "global.ext"
#include        "gescfg.h"
#include        "geiio.h"
#include        "geierr.h"
#include        "geiioctl.h"
#include        "geisig.h"
#include        "geitmr.h"
#include        "gesmem.h"
#include        "gesdev.h"
#ifndef UNIX
#include        "gesevent.h"
#endif  /* UNIX */
#include        "gesfs.h"               /* @WIN */

// DJC DJC int             GEIerrno = EZERO;
volatile int             GEIerrno = EZERO;

#define         MAXSTDIOS       ( 3 )
GEIFILE FAR *            GEIio_stdin;
GEIFILE FAR *            GEIio_stdout;
GEIFILE FAR *            GEIio_stderr;

#define         NULLFILE        ( (GEIFILE FAR *)NULL )

static GEIFILE FAR *     FileTable    = NULLFILE;
static GEIFILE FAR *     FileTableBeg = NULLFILE;    /* excluding stdios */
static GEIFILE FAR *     FileTableEnd = NULLFILE;

static GEIFILE      FileInitVals =
                    {
                       _S_IFNON,            /* f_type */
                       _F_ERR,              /* f_flag */
                       EOF,                 /* f_handle */
                       (GEIfbuf_t FAR *)NULL,    /* f_fbuf */
                       (GEIfmodq_t FAR *)NULL,   /* f_modq */
                       0,                   /* f_opentag */
                       0                    /* f_savelevel */
                    };
/* make fin a global data  --  01/24/91 bill*/
GEIFILE FAR *            fin  = NULLFILE;
/***/
extern  char    job_name[], job_state[], job_source[];
/* erik chen, 3-1-1991 */
int             local_flag=TRUE;
extern char     TI_state_flag;
extern short int startup_flag;
extern void     change_status(void);
extern void     GEP_restart(void);
/* erik chen, 3-1-1991 */

/* @WIN; add prototype */
static int io_dup(GEIFILE FAR *, GEIFILE FAR *);
static int fbuf_init(GEIfbuf_t FAR * FAR *, unsigned char FAR *, int);
static int outsync(unsigned short, short, unsigned char FAR *, int);

/*
 * ---------------------------------------------------------------------
 *      GEI Status Update and Query
 * ---------------------------------------------------------------------
 */

char                statusbuf[ MAXSTATUSLEN ];
int                 statuslen = 0;

/* ...................................... */

/*void        GEIio_updatestatus( name, state, source, flag )
    char      *name, *state, *source, flag;
    char      flag;
{
   job_name=name;
   job_state=state;
   job_source=source;
   TI_state_flag=flag;
} */

/* ...................................... */

void        GESio_obtainstatus( statusaddr, len )
    char FAR *        FAR *statusaddr;
    int          FAR *len;
{
    unsigned short int l_len;
    struct object_def    FAR *l_tmpobj;

/* add by Falco to initial value, 09/06/91 */
    statusbuf[0]='%';
    statusbuf[1]='%';
    statusbuf[2]='[';
    statusbuf[3]=' ';
    statusbuf[4]='\0';

    if (startup_flag){
        if (job_name[0] != '\0') {
            lstrcat(statusbuf, "name: ");       /*@WIN*/
            lstrcat(statusbuf, job_name);       /*@WIN*/
        }

        get_dict_value("statusdict", "jobstate", &l_tmpobj);
        l_len = LENGTH(l_tmpobj);
        if (lstrcmp(job_state, (char  FAR *)VALUE(l_tmpobj))) {  /*@WIN*/
            lstrcpy(job_state, (char  FAR *)VALUE(l_tmpobj)) ;   /*@WIN*/
            job_state[l_len] = ';' ;
            job_state[l_len + 1] = ' ' ;
            job_state[l_len + 2] = '\0' ;
            change_status();
        }

        lstrcat(statusbuf, "status: ");         /*@WIN*/
        lstrcat(statusbuf, job_state);          /*@WIN*/

        if (lstrcmp(job_state, "idle\0") && strcmp(job_state, "start page\0")) {
            lstrcat(statusbuf, "source: ");     /*@WIN*/
            lstrcat(statusbuf, job_source);     /*@WIN*/
        }
    }

    statuslen = lstrlen(statusbuf)-4;   /*@WIN*/
    lstrcat(statusbuf," ]%%\n\r");      /*@WIN*/

    *statusaddr = statusbuf+4;
    *len = statuslen;
}

/* ...................................... */


/*
 * ---------------------------------------------------------------------
 *      GEIio find first and next open
 * ---------------------------------------------------------------------
 */

static      GEIFILE FAR *        currf = NULLFILE;

/* ...................................... */

GEIFILE FAR *     GEIio_firstopen()
{

    for( currf=FileTable; currf<FileTableEnd; currf++ )
        if( currf->f_handle != EOF )
            return( currf );

    return( NULLFILE );
}

/* ...................................... */

GEIFILE FAR *    GEIio_nextopen()
{
    while( ++currf < FileTableEnd )
        if( currf->f_handle != EOF )
            return( currf );

    return( NULLFILE );
}

/* ...................................... */

/*
 * ---------------------------------------------------------------------
 *      GESio Internal Functions
 * ---------------------------------------------------------------------
 */

static
int         io_dup( newf, oldf )
    register GEIFILE FAR *   newf;
    register GEIFILE FAR *   oldf;
{
    int                 oldopentag;
    GEIfmodq_t FAR *         mq;
#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( EOF );
    }
#endif

    /* copy all of old into new (exclude fmodq and opentag) */
    oldopentag = newf->f_opentag;
    *newf      = *oldf;
    newf->f_modq    = (GEIfmodq_t FAR *)NULL;
    newf->f_opentag = oldopentag;

    /* open the device driver again */
    switch( newf->f_type )
    {
    case _S_IFEDIT:     /* to be removed in the future!!! */
        break;
    case _S_IFCHR:
        if( CDEV_OPEN( newf->f_handle ) == EOF )
            return( EOF );
        break;
#ifdef FILESYS
    case _S_IFREG:
        break;
#endif
    default:
        GESseterror( EBADF );
        return( EOF );
    }

    newf->f_fbuf->f_refcnt ++;
    newf->f_opentag ++;

    if( oldf->f_modq != (GEIfmodq_t FAR *)NULL )
    {
        GEIfmod_t FAR *              fmods[ MAXFMODQS ];
        int                     nfmods;

        nfmods = 0;
        for( mq=oldf->f_modq; mq!=(GEIfmodq_t FAR *)NULL; mq=FMODQ_NEXT(mq) )
            fmods[ nfmods++ ] = mq->fmod;

        while( --nfmods >= 0 )      /* push from bottom to top */
        {
//          if( GEIio_ioctl( newf, _I_PUSH, (char FAR *)fmods[ nfmods ] ) == EOF )
            if( GEIio_ioctl( newf, _I_PUSH, (int FAR *)fmods[ nfmods ] ) == EOF ) /*@WIN*/
                goto dup_err;

#         ifdef PANEL
            if( GESevent_isset( EVIDofKILL ) )
            {
                GESseterror( EINTR );
                goto dup_err;
            }
#         endif
        }
    }
    return( 0 );

  dup_err:
    for( mq=newf->f_modq; mq!=(GEIfmodq_t FAR *)NULL; mq=FMODQ_NEXT(mq) )
        FMODQ_CLOSE( newf, mq );
    newf->f_fbuf->f_refcnt --;
    if( newf->f_type == _S_IFCHR )
        CDEV_CLOSE( newf->f_handle );

    *newf = FileInitVals;
    newf->f_opentag = oldopentag;
    return( EOF );

}   /* io_dup */

/* ...................................... */

static
int         outsync( ftype, handle, buf, len )
    unsigned short  ftype;
    short           handle;
    unsigned char FAR *  buf;
    int             len;
{
    switch( ftype )
    {
    case _S_IFCHR:
        return( CDEV_WRITE( handle, buf, len, _O_SYNC ) );
#ifdef FILESYS
    case _S_IFREG:
        {
            int     oldflag, tmpflag;

            if( GESfs_ioctl( handle, _F_GETFL, &oldflag ) == EOF )
                return( EOF );

            tmpflag = oldflag;
            if( !(oldflag & _O_SYNC) )
            {
                tmpflag |= _O_SYNC;
                if( GESfs_ioctl( handle, _F_SETFL, &tmpflag ) == EOF )
                    return( EOF );
            }

            if( GESfs_write( handle, buf, len ) == EOF )
                return( EOF );

            if( !(oldflag & _O_SYNC) )
                return( GESfs_ioctl( handle, _F_SETFL, &oldflag ) );

            return( 0 );
        }
#endif /* FILESYS */
    }

    return( 0 );
}

/* ...................................... */

static
int         fbuf_init( fbufap, buf, len )
    register GEIfbuf_t FAR *  FAR *fbufap;
    unsigned char FAR *      buf;
    int                 len;
{
    register GEIfbuf_t FAR * fbufp;

    if( buf != (unsigned char FAR *)NULL )
    {
        if( (fbufp = (GEIfbuf_t FAR *)GESmalloc( sizeof(GEIfbuf_t) ))
                == (GEIfbuf_t FAR *)NULL )
            return( EOF );

        fbufp->f_base = buf;
    }
    else
    {
        if( (fbufp = (GEIfbuf_t FAR *)GESmalloc( sizeof(GEIfbuf_t) + len ))
                == (GEIfbuf_t FAR *)NULL )
            return( EOF );

        fbufp->f_base = (unsigned char FAR *)fbufp + sizeof(GEIfbuf_t);

    }

    fbufp->f_refcnt = 1;
    fbufp->f_size   = len;

    *fbufap = fbufp;

    return( 0 );
}

/* ...................................... */

/*
 * ---------------------------------------------------------------------
 *      open, sopen, dup, close, read, write, ungetc, flush, ioctl
 * ---------------------------------------------------------------------
 */

GEIFILE FAR *    GEIio_open( filename, namelen, flags )
    char FAR *       filename;
    int         namelen;
    int         flags;
{
    register GEIFILE FAR *       f;
    register GESiocfg_t FAR *    iocfg;

#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( NULLFILE );
    }
#endif

#ifdef DBG
    printf( "\nenter io_open: name = %s, flags = %o\n", filename, flags );
#endif

    flags &= (_F_RWMASK |_F_MDMASK |_F_ONLY4OPEN );


    if(  namelen <= 0
      || !(flags & _F_RWMASK)
      || (flags & _O_RDWR) == _O_RDWR  )
    /* inhibited for read and write */
    {
#ifdef  DBG
        printf( "invalid namelen or flags\n" );
#endif
        GESseterror( EINVAL );
        return( NULLFILE );
    }

    if( (iocfg = GESiocfg_namefind( filename, namelen )) != (GESiocfg_t FAR *)NULL )
    {   /* if special, look for the file stream with the same requirements */

        flags &= (_F_RWMASK |_F_MDMASK );    /* ignore others for device */

        for( f=FileTableBeg; f<FileTableEnd; f++ )
        {
            if(   f->f_type == _S_IFCHR
              &&  f->f_handle == iocfg->devnum
              &&  flags == (int)(f->f_flag & (_F_RWMASK | _F_MDMASK ))  )//@WIN
                return( f );        /* return if the same thing found */
        }
    }

    /* allocate a file stream entry */
    for( f=FileTableBeg; f<FileTableEnd; f++ )
        if( f->f_handle == EOF )
            break;
    if( f>=FileTableEnd )
    {
#     ifdef DBG
        printf( "too many open files\n" );
#     endif
        GESseterror( EMFILE );
        return( NULLFILE );
    }

#ifdef DBG
    printf( "file alloc address = %lx\n", (long)f );
#endif

    /* determine file type and handle (open device driver or file system) */
    if( iocfg != (GESiocfg_t FAR *)NULL )
    {
        if( CDEV_OPEN( iocfg->devnum ) == EOF )
            return( NULLFILE );

        f->f_handle = iocfg->devnum;
        f->f_type   = _S_IFCHR;
    }
    else    /* not a special file (not a device) */
    {
#ifdef FILESYS
        if( (f->f_handle = (short)GESfs_open( filename, namelen, flags )) == EOF )
            return( NULLFILE );

        f->f_type = _S_IFREG;
#else
#     ifdef DBG
        printf( "no such dev\n" );
#     endif
        GESseterror( ENODEV );
        return( NULLFILE );
#endif
    }

#ifdef DBG
    printf( "file type = %d, handle = 0x%X\n", f->f_type, f->f_handle );
#endif

    /* initialize file fbuf, flag, modq, and then increment opentag */
    if(fbuf_init(&(f->f_fbuf),(unsigned char FAR *)NULL, MAXUNGETCSIZE+MAXFBUFSIZE )
        == EOF )
    {
        f->f_type = FileInitVals.f_type;
        f->f_handle = EOF;
        return( NULLFILE );
    }
    f->f_fbuf->f_ptr =  f->f_fbuf->f_base  +  (flags & _O_RDONLY?
                                                    MAXUNGETCSIZE : 0);
    f->f_fbuf->f_cnt =  flags & _O_RDONLY? 0 : (MAXUNGETCSIZE+MAXFBUFSIZE);

    f->f_flag = _F_MYBUF | ( flags & (_F_RWMASK |_F_MDMASK) );
    f->f_modq = FileInitVals.f_modq;
    f->f_opentag++;

    return( f );

}   /* GEIio_open */

/* ...................................... */

GEIFILE FAR *    GEIio_sopen( string, length, flags )
    char FAR *      string;             /* @WIN */
    int                 length;
    int                 flags;
{
    register GEIFILE FAR *   f;

#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( NULLFILE );
    }
#endif

#ifdef  DBG
    printf( "\nenter io_sopen: len = %d, flags = %o\n", length, flags );
#endif

    flags &= _F_RWMASK;

    if(  length < 0  ||  flags == 0  ||  flags == _O_RDWR  )
    {
#ifdef  DBG
        printf( "invalid stringlen or flags\n" );
#endif
        GESseterror( EINVAL );
        return( NULLFILE );
    }

    /* allocate a file stream entry */
    for( f=FileTableBeg; f<FileTableEnd; f++ )
        if( f->f_handle == EOF )
            break;
    if( f>=FileTableEnd )
    {
#     ifdef DBG
        printf( "too many open files\n" );
#     endif
        GESseterror( EMFILE );
        return( NULLFILE );
    }

#ifdef DBG
    printf( "file alloc address = %lx\n", (long)f );
#endif

    /* initialize file fbuf, type, handle, flag, and then increment opentag */
    if( fbuf_init( &(f->f_fbuf), string, length ) == EOF )
        return( NULLFILE );
    f->f_fbuf->f_ptr = string;
    //DJC fix from history.log UPD039
    /*
     * f->f_fbuf->f_cnt = flags & _O_RDONLY?  0  :  length;
     *  For string file, the f_cnt should be always set as length, since
     *  it will not issue any GESfbuf_fill at _O_RDONLY mode to read
     *  another data block.   @WIN
     */
    f->f_fbuf->f_cnt = length;
    //DJC end fix UPD039

    f->f_type = _S_IFSTR;
    f->f_handle = 0;
    f->f_flag = (unsigned short)flags;
    f->f_opentag++;

    return( f );

}   /* GEIio_sopen */

/* ...................................... */

GEIFILE FAR *    GEIio_dup( file )
    register GEIFILE FAR *   file;
{
    register GEIFILE FAR *   newf;

#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( NULLFILE );
    }
#endif

#ifdef DBG
    printf( "\nenter io_dup: file = %lx, type = %d, handle = %o\n",
            (long)file, file->f_type, file->f_handle );
#endif

/*  if( f == NULLFILE  ||  f->f_flag & _F_ERR ) */
    if( file == NULLFILE  ||  file->f_flag & _F_ERR )
    {
#ifdef DBG
        printf( "bad file to dup\n" );
#endif
        GESseterror( EBADF );
        return( NULLFILE );
    }

    /* allocate a file stream entry */
    for( newf=FileTableBeg; newf<FileTableEnd; newf++ )
        if( newf->f_handle == EOF )
            break;
    if( newf>=FileTableEnd )
    {
#     ifdef DBG
        printf( "too many open files\n" );
#     endif
        GESseterror( EMFILE );
        return( NULLFILE );
    }

#ifdef  DBG
    printf( "file alloc addr = %lx\t", (long)newf );
#endif

    return( io_dup( newf, file ) == EOF?  NULLFILE  :  newf );

}   /* GEIio_dup */

/* ...................................... */

int         GEIio_close( f )
    GEIFILE FAR *    f;
{
    GEIFILE         oldf;
    GEIfmodq_t FAR *     mq;

    /* you should NEVER to detect GESevents for close */

#ifdef  DBG
    printf( "\nenter io_close: file = %lx, type = %d, handle = %o\n",
            (long)f, f->f_type, f->f_handle );
#endif

    if( f == NULLFILE  ||  f->f_handle == EOF )
        return( 0 );

    if( f->f_type == _S_IFEDIT )    /* to be removed in the future !!! */
        f->f_type = f->f_oldtype;

    for( mq=f->f_modq;  mq!=(GEIfmodq_t FAR *)NULL;  mq=FMODQ_NEXT(mq)  )
        FMODQ_CLOSE( f, mq );
    f->f_modq = (GEIfmodq_t FAR *)NULL;
    GEIclearerr();

    oldf = *f;
    *f = FileInitVals;
    f->f_opentag = oldf.f_opentag;

    if( --oldf.f_fbuf->f_refcnt <= 0 )
    {
        /* to write all buffered output */
        if(   oldf.f_flag & _O_WRONLY
          &&  oldf.f_fbuf->f_ptr > oldf.f_fbuf->f_base  )
            GESio_flush( &oldf );
        GEIclearerr();

        /* for string type, free fbuf only; fbuf and f_base o/w */
        if( oldf.f_type == _S_IFSTR  ||  oldf.f_flag & _F_MYBUF )
            GESfree( (char FAR *)(oldf.f_fbuf) );
    }

    /* invoke device driver or file system to close */
    switch( oldf.f_type )
    {
    case _S_IFCHR:
        CDEV_CLOSE( oldf.f_handle );
        break;
#ifdef FILESYS
    case _S_IFREG:
        GESfs_close( oldf.f_handle );
        break;
#endif
    default:
        break;
    }

    return( 0 );

}   /* GEIio_close */

/* ...................................... */

int         GEIio_read( f, buf, nbytes )
    register GEIFILE FAR *   f;
    char FAR *               buf;
    int                 nbytes;
{
#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( EOF );
    }
#endif

    if( f == NULLFILE  ||  f->f_flag & _F_ERR  ||  !(f->f_flag & _O_RDONLY) )
    {
        GESseterror( EBADF );
        return( EOF );
    }

    if( nbytes < 0 )
    {
        GESseterror( EINVAL );
        return( EOF );
    }

    if( nbytes == 0 )
        return( 0 );

    return( FMODQ_READ( f, f->f_modq, buf, nbytes ) );

}   /* GEIio_read */

/* ...................................... */

int         GESio_read( f, buf, nbytes )
    register GEIFILE FAR *   f;
    char FAR *               buf;
    int                 nbytes;
{
    register GEIfbuf_t FAR * fbufp = f->f_fbuf;
    int                 nleft = nbytes;
    int                 retval,remainder;

#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( EOF );
    }
#endif

    if( f->f_flag & _F_ERR )
        return( EOF );
    if( nbytes <= fbufp->f_cnt )    /* only have to read out buffered data */
    {
        remainder=nbytes;
more:
        lmemcpy( buf, fbufp->f_ptr, remainder );        /*@WIN*/
        fbufp->f_ptr += remainder;
        fbufp->f_cnt -= remainder;
        return( nbytes );
    }

    if( fbufp->f_cnt > 0 )          /* buffered bytes are not big enough */
    {                               /* however, deliver buffered bytes first */
        lmemcpy( buf, fbufp->f_ptr, fbufp->f_cnt );     /*@WIN*/
        buf   += fbufp->f_cnt;
        nleft -= fbufp->f_cnt;

        fbufp->f_ptr -= fbufp->f_cnt;
        fbufp->f_cnt = 0;

        if( f->f_type == _S_IFSTR  ||  f->f_flag & _O_NDELAY )
            return( nbytes - nleft );
    }

    /* read into user's buffer through GESfbuf_fill */
    while( nleft > 0 )
    {
        if( (retval = GESfbuf_fill( f )) == EOF )
            break;

        *buf++ = (char)retval;
        nleft--;
        if( nleft > 0  &&  fbufp->f_cnt > 0 )
        {
            if (nleft < fbufp->f_cnt)   /* too much, Jimmy */
                {
                remainder=nleft;
                goto more;
                }
            lmemcpy( buf, fbufp->f_ptr, fbufp->f_cnt );         /*@WIN*/
            buf   += fbufp->f_cnt;
            nleft -= fbufp->f_cnt;

            fbufp->f_ptr -= fbufp->f_cnt;
            fbufp->f_cnt = 0;
        }

        if( f->f_flag & _O_NDELAY )
            break;
    }

    return( nleft == nbytes?  EOF  :  nbytes - nleft );

}   /* GESio_read */

/* ...................................... */
/* #ifdef JIMMY
unsigned long   IOwaittimeout = _NOWAITTIMEOUT;

void        GEIio_setwaittimeout( timeout )
    unsigned long   timeout;
{
    IOwaittimeout = timeout;
}

int         waittimeout_handler( timerp )
    GEItmr_t*       timerp;
{
    GESseterror( ETIME );               (* raise timed out error *)
    timerp->interval = _NOWAITTIMEOUT;  (* indicate the timer stopped on exit *)
    return( FALSE );                    (* stop the timer *)
}

#endif (* JIMMY */
/* ...................................... */

int         GESfbuf_fill( f )       /* called when buffer empty */
    register GEIFILE FAR *   f;
{
    /* (f) has been checked against 'isreadable' in getc() */

    register GEIfbuf_t FAR * fbufp;
    int                 retval;

/* Bill move it from behind 05/07/'91 */
    fbufp = f->f_fbuf;
    fbufp->f_cnt = 0;           /* force fbuf consistent */
    fbufp->f_ptr = fbufp->f_base + MAXUNGETCSIZE;

#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( EOF );
    }
#endif

#ifdef FILESYS
    if( f->f_type != _S_IFCHR  &&  f->f_type != _S_IFREG )
        f->f_flag |= _F_EOF;
#else
    if( f->f_type != _S_IFCHR )
        f->f_flag |= _F_EOF;
#endif

    if( f->f_flag & (_F_ERR | _F_EOF) ) {
       // DJC added
       retval = EOF;
       return(retval);
    }

/* Bill move it forward 05/07/'91
 *   fbufp = f->f_fbuf;
 *   fbufp->f_cnt = 0;
 *   fbufp->f_ptr = fbufp->f_base + MAXUNGETCSIZE;
 */

#ifdef FILESYS
    if( f->f_type == _S_IFREG )
    {
        while( (retval = GESfs_read( f->f_handle, fbufp->f_ptr,
                                     fbufp->f_size - MAXUNGETCSIZE ))
                == 0 )
        {

#         ifdef PANEL
            if( GESevent_isset( EVIDofKILL ) )
            {
                GESseterror( EINTR );
                break;
            }
#         endif

            if( GEIerror() != EZERO )
                break;
        }
    }
    else    /* for character device below */
#endif /* FILESYS */
    {       /* character devices */
/* #ifdef JIMMY
        GEItmr_t        waittimer;
        waittimer.interval =
            MAJdev(f->f_handle)==_SERIAL || MAJdev(f->f_handle)==_PARALLEL?
                IOwaittimeout : _NOWAITTIMEOUT;

        if( waittimer.interval != _NOWAITTIMEOUT )
        {
            waittimer.handler  = waittimeout_handler;
            waittimer.private  = (char*)NULL;
            if( !GEItmr_start( &waittimer ) )
                waittimer.interval = _NOWAITTIMEOUT;
        }
        GEIclearerr();
#endif  (* JIMMY */


        do  /* no-delay read until something got, eof or error */
        {
            retval = CDEV_READ( f->f_handle, fbufp->f_ptr,
                                             fbufp->f_size - MAXUNGETCSIZE,
                                             _O_NDELAY );

            if (retval == 0) {     // @WIN; break as EOF; @LANG
                f->f_flag |= _F_EOF;    // Temp. solution by scchen
                break;
            }

/* erik chen, 3-1-1991 */
            if ((retval == 0) && local_flag) {
                if (startup_flag) {
                    lstrncpy(job_state, "waiting; \0", 11) ;    /*@WIN*/
                    TI_state_flag = 0 ;
                    change_status() ;
                }
                local_flag = FALSE;
            }
/* erik chen, 3-1-1991 */

#         ifdef PANEL
#ifdef MTK
            pdl_no_process();
#endif
            if( GESevent_isset( EVIDofKILL ) )
                GESseterror( EINTR );
#         endif

            if( GEIerror() != EZERO )
                break;

        }while( retval == 0 );
/* #ifdef JIMMY
        if( waittimer.interval != _NOWAITTIMEOUT )
            GEItmr_stop( waittimer.timer_id );
   #endif
*/
    }

/* erik chen, 3-1-1991 */
        if ( !local_flag) {
            lstrncpy(job_state, "busy; \0", 8) ;        /* @WIN */
            TI_state_flag = 1 ;
            local_flag = TRUE;
            change_status() ;
        }
/* erik chen, 3-1-1991 */

    if( GEIerror() != EZERO )
    {
        f->f_flag |= _F_ERR;
        return( EOF );
    }

    if( retval == EOF )
    {
        f->f_flag |= _F_EOF;
        return( EOF );
    }

    fbufp->f_cnt = retval - 1;

    retval=*fbufp->f_ptr; /* Jimmy */
    fbufp->f_ptr++;
#ifdef MTK
    pdl_process();
#endif

    return(retval);

}   /* GESfbuf_fill */

/* ...................................... */

int         GEIio_write( f, buf, nbytes )
    register GEIFILE FAR *   f;
    unsigned char FAR *      buf;
    int                 nbytes;
{
   int retvalue;
#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( EOF );
    }
#endif

    if( f == NULLFILE  ||  f->f_flag & _F_ERR  ||  !(f->f_flag & _O_WRONLY) )
    {
        GESseterror( EBADF );
        return( EOF );
    }

    if( nbytes < 0 )
    {
        GESseterror( EINVAL );
        return( EOF );
    }

    if( nbytes == 0 )
        return( 0 );

AGAIN:

/*    return( FMODQ_WRITE( f, f->f_modq, buf, nbytes ) ); */
    retvalue = FMODQ_WRITE( f, f->f_modq, buf, nbytes );
#ifdef DBG_W
    printf(" retvalue = %lx nbytes= %lx\n", retvalue, nbytes);
#endif
    switch (retvalue) {
    case EOF:
       return(EOF);
    case 0:
       goto AGAIN;
    default:
       if (retvalue==nbytes) {
          return(retvalue);
       } else {
#ifdef DBG_W
          printf(" buf = %lx, retvalue= %lx\n", buf, retvalue);
#endif
          buf=buf+retvalue;
          nbytes=nbytes-retvalue;
          goto AGAIN;
       } /* endif */
    } /* endswitch */

}   /* GEIio_write */

/* ...................................... */

int         GESio_write( f, buf, nbytes )
    register GEIFILE FAR *   f;
    unsigned char FAR *      buf;
    int                 nbytes;     /* always be positive and non-zero */
{
    register GEIfbuf_t FAR *     fbufp = f->f_fbuf;
    int                     written, nb2write;
    int                     retval;

#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( EOF );
    }
#endif

    if( f->f_flag & _F_ERR )
        return( EOF );

    /* copy as many user's data onto buffer as possible */
    if( (written = (fbufp->f_cnt >= nbytes? nbytes : fbufp->f_cnt)) > 0 )
    {
        lmemcpy( fbufp->f_ptr, buf, written );          /*@WIN*/
        buf += written;
        fbufp->f_ptr += written;
        fbufp->f_cnt -= written;
    }

    /* deal with string file */
    if( f->f_type == _S_IFSTR )
    {
        if( written == 0 )
        {
            f->f_flag |= _F_EOF;
            return( EOF );
        }
        return( written );
    }

    /* here should be only of _S_IFCHR and _S_IFREG */
    switch( f->f_type )
    {
    case _S_IFCHR:
    case _S_IFREG:
        break;
    default:
        GESseterror( EBADF );
        return( EOF );
    }

    /* flush all buffered output and user's output if sync requested */
    if( f->f_flag & _O_SYNC )
    {
        nb2write = fbufp->f_size - fbufp->f_cnt;/* size of buffered output */

        fbufp->f_ptr = fbufp->f_base;           /* reset fbuf */
        fbufp->f_cnt = fbufp->f_size;

        /* flush all buffered output first and user's then */
        if(  outsync( f->f_type, f->f_handle, fbufp->f_base, nb2write ) == EOF
          || outsync( f->f_type, f->f_handle, buf, nbytes-written ) == EOF   )
        {
            f->f_flag |= _F_ERR;
            return( EOF );
        }

        return( nbytes );       /* all been physically written */
    }

    if( written >= nbytes )
        return( nbytes );       /* all been buffered */

#ifdef DBG_W
    if (written>0) printf(" before flush written = %d\n",written);
#endif
    if( (written>0)  &&  (f->f_flag & _O_NDELAY) )
        return( written );      /* return if some been buffered for no-delay */

    /* write buffered output to device driver or file system */
    if( (nb2write = fbufp->f_size - fbufp->f_cnt) > 0 )
    {
#ifdef DBG_W
       printf(" nb2write = %d\n", nb2write);
#endif
        /* make a write to device or file system */
        retval =
#         ifdef FILESYS
            f->f_type == _S_IFREG?
                GESfs_write( f->f_handle, fbufp->f_base, nb2write )  :
#         endif
                CDEV_WRITE(  f->f_handle, fbufp->f_base, nb2write,
                                                f->f_flag & _F_MDMASK );
/*                                              _O_SYNC ); */

        if( retval == EOF )
        {
            f->f_flag |= _F_ERR;
            return( EOF );
        }

      /* 04/11/91 Bill make sure all are flushed */
      if (retval != nb2write) {
        CDEV_WRITE(f->f_handle, fbufp->f_base+retval, nb2write-retval, _O_SYNC);
      } else {
      } /* endif */

#     ifdef PANEL
        if( GESevent_isset( EVIDofKILL ) )
            retval = EOF;
#     endif
#ifdef DBG_W
       printf(" retval = %d\n", retval);
#endif

        /* reset fbufp */
        fbufp->f_cnt = fbufp->f_size;
        fbufp->f_ptr = fbufp->f_base;

#ifdef DBG_W
        printf(" f_cnt = %lx, f_ptr = %lx\n", fbufp->f_cnt, fbufp->f_ptr);
#endif
/* not all written?
 *
 *      if( retval < nb2write )
 *      {
 *          unsigned char*  ptr  = fbufp->f_base;
 *          int             left = nb2write - retval;
 *
 *          for( ; left--> 0; ptr++ )   *ptr = *( ptr + retval );
 *
 *          return( written );
 *      }
 *  }
 */
        /* all buffered output has been written out */

    }
    return( 0 );

}   /* GESio_write */

/* ...................................... */

int         GESfbuf_flush( f, c )   /* called by putc when buffer full */
    GEIFILE FAR *    f;
    int         c;
{
    /* (f) has been checked against iswriteable in putc() */

#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( EOF );
    }
#endif

    if( f->f_type == _S_IFSTR )
        f->f_flag |= _F_EOF;

    if( f->f_flag & (_F_ERR | _F_EOF) )
        return( EOF );

    if( GESio_flush( f ) == EOF  ||  f->f_flag & (_F_ERR | _F_EOF) )
        return( EOF );

    --( f->f_fbuf->f_cnt );
    return( *( f->f_fbuf->f_ptr++ ) = (char)c );

}   /* GESfbuf_flush */

/* ...................................... */

int         GESio_ungetc( c, f )
    int                 c;
    register GEIFILE FAR *   f;
{
    register GEIfbuf_t FAR * fbufp = f->f_fbuf;

#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( EOF );
    }
#endif

    if( f->f_flag & _F_ERR  ||  fbufp->f_ptr <= fbufp->f_base )
        return( EOF );

    *( -- fbufp->f_ptr )= (char)c;
    ++ fbufp->f_cnt;

    return( c );

}   /* GESio_ungetc */

/* ...................................... */

int         GEIio_flush( f )
    register GEIFILE FAR *   f;
{
#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( EOF );
    }
#endif

    if( f == NULLFILE  ||  f->f_flag & _F_ERR )
    {
        GESseterror( EBADF );
        return( EOF );
    }

    return( FMODQ_FLUSH( f, f->f_modq ) );

}   /* GEIio_flush */

/* ...................................... */

int         GESio_flush( f )
    register GEIFILE FAR *   f;
{
    register GEIfbuf_t FAR * fbufp = f->f_fbuf;

#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( EOF );
    }
#endif

    if( f->f_flag & _F_ERR )
        return( EOF );

    if( f->f_flag & _O_RDONLY )
    {
        switch( f->f_type )
        {
        case _S_IFCHR:
            while(  CDEV_READ( f->f_handle, fbufp->f_base, fbufp->f_size, 0 )
                    != EOF );
            break;
#     ifdef FILESYS
        case _S_IFREG:
            while( GESfs_read( f->f_handle, fbufp->f_base, fbufp->f_size )
                    != EOF );
            break;
#     endif
        default:
            break;
        }

        fbufp->f_ptr = fbufp->f_base + fbufp->f_size;
        fbufp->f_cnt = 0;

        f->f_flag |= _F_EOF;
    }   /* end of flush on input stream */
    else
    {   /* flush on output stream */

        outsync( f->f_type, f->f_handle, fbufp->f_base,
                                         fbufp->f_size - fbufp->f_cnt );
        fbufp->f_ptr = fbufp->f_base;
        fbufp->f_cnt = fbufp->f_size;

    }   /* end of flush on output stream */

    if( GEIerror() != EZERO )
    {
        f->f_flag |= _F_ERR;
        return( EOF );
    }

    return( 0 );

}   /* GESio_flush */

/* ...................................... */

int         GEIio_ioctl( f, req, arg )
    register GEIFILE FAR *   f;
    int                 req;
    int                  FAR *arg;
{
    int                 tmpval;
    GEIfmodq_t           FAR *mq,  FAR *mqtop;

    /* you should NEVER to detect GESevents for ioctl */

    if( f == NULLFILE  ||  f->f_flag & _F_ERR )
    {
        GESseterror( EBADF );
        return( EOF );
    }

    switch( req )
    {
    case _I_PUSH:
        tmpval = 0;
        for( mq=f->f_modq; mq!=(GEIfmodq_t FAR *)NULL; mq=FMODQ_NEXT(mq) )
            tmpval ++;

        if(  tmpval == MAXFMODQS  ||
             (mq = (GEIfmodq_t FAR *)GESmalloc( sizeof(GEIfmodq_t) ))
                    == (GEIfmodq_t FAR *)NULL  )
        {
            GESseterror( ENOSR );
            return( EOF );
        }

        mqtop = f->f_modq;

        mq->next = mqtop;
        mq->fmod = (GEIfmod_t FAR *)arg;
        mq->private = (char FAR *)NULL;
        f->f_modq = mq;

        if( FMODQ_OPEN( f, mq ) != EOF )
            return( 0 );    /* successful open */

        f->f_modq = mqtop;
        GESfree( (char FAR *)mq );
        return( EOF );

    case _I_POP:
        if( (mqtop = f->f_modq) == (GEIfmodq_t FAR *)NULL )
        {
            *(GEIfmod_t FAR * FAR *)arg = (GEIfmod_t FAR *)NULL;
            return( 0 );    /* no operation */
        }

        *(GEIfmod_t FAR * FAR *)arg = mqtop->fmod;
        f->f_modq = FMODQ_NEXT( mqtop );
        FMODQ_CLOSE( f, mqtop );
        GESfree( (char FAR *)mqtop );
        return( 0 );

    case _I_LOOK:
        *(char FAR * FAR *)arg = FMODQ_NAME( f->f_modq );
        return( 0 );

    case _F_GETFL:
        *arg = f->f_flag & _F_MDMASK;
        return( 0 );

    case _F_SETFL:
        f->f_flag &= ~_F_MDMASK;
        f->f_flag |= (*arg & _F_MDMASK);
#     ifdef FILESYS
        if( f->f_type == _S_IFREG )
            GESfs_ioctl( f->f_handle, req, arg );
#     endif
        return( 0 );

    case _ECHOEOF:
    case _GETIOCOOK:
    case _SETIOCOOK:
    case _GETIOPARAMS:
    case _SETIOPARAMS:
        if( f->f_type == _S_IFCHR )
            return( CDEV_IOCTL( f->f_handle, req, arg ) );
        break;
    case _FIONREAD:
        if( !(f->f_flag & _O_RDONLY) )
            return( EOF );

        *arg = 0;
        for( mq=f->f_modq;  mq!=(GEIfmodq_t FAR *)NULL;  mq=FMODQ_NEXT(mq)  )
        {
            if( FMODQ_IOCTL( f, mq, _FIONREAD, &tmpval ) == EOF )
                return( EOF );
            *arg += tmpval;
        }
        *arg += f->f_fbuf->f_cnt;

        switch( f->f_type )
        {
        case _S_IFCHR:
            if( CDEV_IOCTL( f->f_handle, _FIONREAD, &tmpval ) == EOF )
                return( EOF );
            break;
#     ifdef FILESYS
        case _S_IFREG:
            if( GESfs_ioctl( f->f_handle, _FIONREAD, &tmpval ) == EOF )
                return( EOF );
            break;
#     endif
        default:    /* no operation */
            tmpval = 0;
            break;
        }

        *arg += tmpval;
        return( 0 );

    case _FIONRESET:
        for( mq=f->f_modq;  mq!=(GEIfmodq_t FAR *)NULL;  mq=FMODQ_NEXT(mq)  )
            if( FMODQ_IOCTL( f, mq, _FIONRESET, &tmpval ) == EOF )
                return( EOF );

        if( f->f_flag & _O_RDONLY )
        {
            f->f_fbuf->f_ptr = f->f_fbuf->f_base +
                               ( f->f_flag & _F_MYBUF? MAXUNGETCSIZE : 0 );
            f->f_fbuf->f_cnt = 0;
        }
        else
        {
            f->f_fbuf->f_ptr = f->f_fbuf->f_base;
            f->f_fbuf->f_cnt = f->f_fbuf->f_size;
        }

        f->f_flag &= ~(_F_EOF | _F_ERR);

        if( f->f_type == _S_IFCHR )
            CDEV_IOCTL( f->f_handle, _FIONRESET, arg );

        return( 0 );

    default:
        break;
    }

    GESseterror( ENOTTY );
    return( EOF );

}   /* GEIio_ioctl */

/* ...................................... */

/*
 * ---------------------------------------------------------------------
 *      GEIio stdios management
 * ---------------------------------------------------------------------
 */

/* ...................................... */

/* close all file table entries except at position 0,1,2 for ctty */
/* this routine is being called at the time of device switch - Bill lwo */

void        GESio_closeall()
{
    register GEIFILE FAR *   f;

    for( f=FileTable; f<FileTableEnd; f++ )
    {
        if( f->f_handle != EOF )
        {
            GEIclearerr();
            GEIio_close( f );
        }
    }
    GEIclearerr();
    return;
}

/* ...................................... */

GESiocfg_t FAR *     ctty = (GESiocfg_t FAR *)NULL;

/* ...................................... */

void        GESio_interrupt( devnum )   /* called by device driver    */
    int         devnum;                 /* when received an interrupt */
{
    if( ctty != (GESiocfg_t FAR *)NULL  &&  devnum == ctty->devnum )
        GEIsig_raise( GEISIGINT, 0x03 );    /* signal if a ctty */

    return;
}

/* ...................................... */

int         GEIio_forceopenstdios( which )
    unsigned    which;
{
    GEIFILE FAR *                fout = NULLFILE;
    GEIFILE FAR *                ferr = NULLFILE;

#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( FALSE );
    }
#endif

    if( (ctty = GESiocfg_defaultdev()) == (GESiocfg_t FAR *)NULL )
        return( FALSE );

    if( which & _FORCESTDIN )
        fin = GEIio_open( ctty->devname, lstrlen(ctty->devname), _O_RDONLY );/*@WIN*/

    if( which & _FORCESTDOUT )

    /* Bill 04/11/91 BUG in GESio_write */
        fout = GEIio_open( ctty->devname, lstrlen(ctty->devname),  /*@WIN*/
                           _O_WRONLY +_O_NDELAY );
/*        fout = GEIio_open( ctty->devname, strlen(ctty->devname), _O_WRONLY ); */


    if( which & _FORCESTDERR )
        ferr = GEIio_open( ctty->devname, lstrlen(ctty->devname), _O_WRONLY );/*@WIN*/

    return(  GEIio_setstdios( fin, fout, ferr )  );

}   /* GEIio_forceopenstdios */

/* ...................................... */

int         GEIio_setstdios( fin, fout, ferr )
    GEIFILE FAR *        fin;
    GEIFILE FAR *        fout;
    GEIFILE FAR *        ferr;
{
    register GEIFILE FAR *   f;

#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( EOF );
    }
#endif

    if(  (fin != NULLFILE && !GEIio_isreadable(fin))   ||
         (fout!= NULLFILE && !GEIio_iswriteable(fout)) ||
         (ferr!= NULLFILE && !GEIio_iswriteable(ferr))  )
    {
        GESseterror( EBADF );
        return( FALSE );
    }

    if(  (f = fin) != GEIio_stdin  &&  f != NULLFILE  )
    {
        if( GEIio_isopen( GEIio_stdin ) )
            GEIio_close( GEIio_stdin );

        if( io_dup( GEIio_stdin, f ) == EOF )
            return( FALSE );
    }

    if(  (f = fout) != GEIio_stdout  &&  f != NULLFILE  )
    {
        if( GEIio_isopen( GEIio_stdout ) )
            GEIio_close( GEIio_stdout );

        if( io_dup( GEIio_stdout, f ) == EOF )
            return( FALSE );
    }

    if(  (f = ferr) != GEIio_stderr  &&  f != NULLFILE  )
    {
        if( GEIio_isopen( GEIio_stderr ) )
            GEIio_close( GEIio_stderr );

        if( io_dup( GEIio_stderr, f ) == EOF )
            return( FALSE );
    }

    return( TRUE );

}   /* GEIio_setstdios */

/* ...................................... */

/*
 * ---------------------------------------------------------------------
 *      GEIio_init
 * ---------------------------------------------------------------------
 */

void        GEIio_init()
{
    register GEIFILE FAR *       f;

    if( (FileTable =
            (GEIFILE FAR *)GESpalloc( (MAXSTDIOS+MAXFILES) * sizeof(GEIFILE) ))
        == NULLFILE )
    {
        GESseterror( ENOMEM );
        return;
    }
    /* Initialize statusbuf  03/22/91 Bill*/
    statusbuf[0]='%';
    statusbuf[1]='%';
    statusbuf[2]='[';
    statusbuf[3]=' ';
    statusbuf[4]='\0';

    GEIio_stdin  = FileTable + 0;
    GEIio_stdout = FileTable + 1;
    GEIio_stderr = FileTable + 2;

    FileTableBeg = FileTable + MAXSTDIOS;
    FileTableEnd = FileTable + MAXSTDIOS + MAXFILES;

    for( f=FileTable; f<FileTableEnd; f++ )
        *f = FileInitVals;

#ifdef FILESYS
    GESfs_init();
#endif

    return;
}

/* Restarting printer */
extern GESiosyscfg_t FAR *  activedev;
void        GEIio_restart()
{
    if ( activedev->iocfg.devnum == MAKEdev(MAJatalk, MINatalk) ) {
       GEIio_getc(GEIio_stdin);
       GEIio_ioctl(GEIio_stdout, _FIONRESET, (int FAR *)0) ;
    }
    GEP_restart();
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\gei\geipm.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GEIpm.c
 *
 *  COMPILATION SWITCHES:
 *      REALEEPROM  - enables to physical read/write from real eeprom.
 *
 *  HISTORY:
 *  09/16/90    byou    created.
 *                      - not to interact with real eeprom.
 *                      - always read from ROM copy at boot.
 *                      - always write to RAM copy only instead of eeprom.
 *  09/17/90    byou    added REALEEPROM options.
 *  09/22/90    echen   added APPLE corresponding eeprom
 *  10/30/90    byou    included "gescfg.h" and added ioparams stuff
 *                      for temporary testing.
 *  11/16/90    phchen  reorganized GESpm_init() for real eeprom.
 * ---------------------------------------------------------------------
 */



// DJC added global include file
#include "psglobal.h"

// DJC DJC #include    "windowsx.h"                /* @WIN */
#include "windows.h"

#include    "winenv.h"                  /* @WIN */

#include    <string.h>

#include    "gescfg.h"

#include    "geipm.h"
#include    "geiio.h"
#include    "geiioctl.h"
#include    "geisig.h"
#include    "geierr.h"

#include    "geicfg.h"

#ifndef TRUE
#define TRUE    ( 1 )
#define FALSE   ( 0 )
#endif

#define     _MAXPAGECOUNT       128
#define     _MAXEESCRATCHARRY    64
#define     _MAXIDLETIMEFONT    151
#define     _MAXSCCBATCH         10
#define     _MAXSCCINTER         10
#define     EEPROM_CHECKSUM   84480

#ifdef REALEEPROM
#include    "eeprom.h"
static      int         EEPromOnLine = FALSE;
#endif /* REALEEPROM */

/* @WIN; add prototype */
static void FlushOrUpdateRAMandMarkDiff(unsigned, char FAR *, unsigned, int);
typedef void (*pmop_t)(int, char FAR *);
static pmop_t findpmop( unsigned, unsigned);

/*
 * ---
 *  Physical Persistent Memory Allocation And Initialized Values
 * ---
 */
#ifdef  UNIX
#define ByteAlign( addr )       ( addr )
#define WordAlign( addr )       ( ((addr) + 1) / 2 ) * 2
#define LongAlign( addr )       ( ((addr) + 3) / 4 ) * 4
#endif

/*
    +-------+--------------+----+
    |start  |type          |size|
    |postion|              |    |
    +-------+--------------+----+
    |    0  |magicnum      |  4 |
    |    4  |password      |  4 |
    |    8  |pagecount     |128 |
    |  136  |leftmargin    |  4 |
    |  140  |topmargin     |  4 |
    |  144  |pagetype      |  1 |
    +-------+--------------+----+
    |  145  |baud          |  1 |
    |  146  |flowpari      |  1 | --- serial25
    |  147  |stopdata      |  1 |
    +-------+--------------+----+
    |  148  |baud          |  1 |
    |  149  |flowpari      |  1 | --- serial9
    |  150  |stopdata      |  1 |
    +-------+--------------+----+
    |  151  |prname        | 33 |
    +-------+--------------+----+
    |  184  |jobtout       |  4 |
    |  188  |manualtout    |  4 | --- timeouts
    |  192  |waittout      |  4 |
    +-------+--------------+----+
    |  196  |eescratcharry | 64 |
    |  260  |idletimefont  |151 |
    |  411  |stsstart      |  1 |
    |  412  |sccbatch      | 10 |
    |  422  |sccinter      | 10 |
    |  432  |dplylistsize  |  4 |
    |  436  |fontcachesze  |  4 |
    |  440  |atalksize     |  4 |
    |  444  |dostartpage   |  1 |
    |  445  |hwiomode      |  1 |
    |  446  |swiomode      |  1 |
    |  447  |pagestckorder |  1 |
    |  448  |reserve       | 64 |
    +-------+--------------+----+
*/
#ifdef  UNIX
#define OFFSmagicnum            LongAlign( 0 )
#define SIZEmagicnum            sizeof( unsigned long )

#define OFFSpassword            LongAlign( OFFSmagicnum + SIZEmagicnum )
#define SIZEpassword            sizeof( unsigned long )

#define OFFSpagecount           ByteAlign( OFFSpassword + SIZEpassword )
#define SIZEpagecount           ( _MAXPAGECOUNT )

#define OFFSengparams           LongAlign( OFFSpagecount + SIZEpagecount )
#define     OFFSleftmargin      LongAlign( 0 )
#define     SIZEleftmargin      sizeof( unsigned long )
#define     OFFStopmargin       LongAlign( OFFSleftmargin + SIZEleftmargin )
#define     SIZEtopmargin       sizeof( unsigned long )
#define     OFFSpagetype        ByteAlign( OFFStopmargin + SIZEtopmargin )
#define     SIZEpagetype        sizeof( unsigned char )
#define SIZEengparams           ( OFFSpagetype + SIZEpagetype )

#define OFFSserial25            ByteAlign( OFFSengparams + SIZEengparams )
#define     OFFSbaud            ByteAlign( 0 )
#define     SIZEbaud            sizeof( unsigned char )
#define     OFFSflowpari        ByteAlign( OFFSbaud + SIZEbaud )
#define     SIZEflowpari        sizeof( unsigned char )
#define     OFFSstopdata        ByteAlign( OFFSflowpari + SIZEflowpari )
#define     SIZEstopdata        sizeof( unsigned char )
#define SIZEserial              ( OFFSstopdata + SIZEstopdata )
#define OFFSserial9             ByteAlign( OFFSserial25 + SIZEserial )

#define OFFSprname              ByteAlign( OFFSserial9 + SIZEserial )
#define SIZEprname              ( _MAXPRNAMESIZE )

#define OFFStimeouts            LongAlign( OFFSprname + SIZEprname )
#define     OFFSjobtout         LongAlign( 0 )
#define     SIZEjobtout         sizeof( unsigned long )
#define     OFFSmanualtout      LongAlign( OFFSjobtout + SIZEjobtout )
#define     SIZEmanualtout      sizeof( unsigned long )
#define     OFFSwaittout        LongAlign( OFFSmanualtout + SIZEmanualtout )
#define     SIZEwaittout        sizeof( unsigned long )
#define SIZEtimeouts            ( OFFSwaittout + SIZEwaittout )

#define OFFSeescratcharry       ByteAlign( OFFStimeouts + SIZEtimeouts )
#define SIZEeescratcharry       ( _MAXEESCRATCHARRY )

#define OFFSidletimefont        ByteAlign(OFFSeescratcharry + SIZEeescratcharry)
#define SIZEidletimefont        ( _MAXIDLETIMEFONT )

#define OFFSstsstart            ByteAlign( OFFSidletimefont + SIZEidletimefont)
#define SIZEstsstart            sizeof( unsigned char )

#define OFFSsccbatch            ByteAlign( OFFSstsstart + SIZEstsstart)
#define SIZEsccbatch            ( _MAXSCCBATCH )

#define OFFSsccinter            ByteAlign( OFFSsccbatch + SIZEsccbatch )
#define SIZEsccinter            ( _MAXSCCINTER )

#define OFFSdplylistsize        LongAlign( OFFSsccinter + SIZEsccinter )
#define SIZEdplylistsize        sizeof( unsigned long )

#define OFFSfontcachesze        LongAlign(OFFSdplylistsize + SIZEdplylistsize)
#define SIZEfontcachesze        sizeof( unsigned long )

#define OFFSatalksize           LongAlign(OFFSfontcachesze + SIZEfontcachesze)
#define SIZEatalksize           sizeof( unsigned long )

#define OFFSdostartpage         ByteAlign( OFFSatalksize + SIZEatalksize )
#define SIZEdostartpage         sizeof( unsigned char )

#define OFFShwiomode            ByteAlign( OFFSdostartpage + SIZEdostartpage )
#define SIZEhwiomode            sizeof( unsigned char )

#define OFFSswiomode            ByteAlign( OFFShwiomode + SIZEhwiomode )
#define SIZEswiomode            sizeof( unsigned char )

#define OFFSpagestckorder       ByteAlign( OFFSswiomode + SIZEswiomode )
#define SIZEpagestckorder       sizeof( unsigned char )

#define OFFSreserve             ByteAlign( OFFSpagestckorder+SIZEpagestckorder)
#define SIZEreserve             ( MAXEEPROMSIZE - OFFSreserve )

#else

#define OFFSmagicnum            ( 0 )
#define SIZEmagicnum            sizeof( unsigned long )

#define OFFSpassword            ( OFFSmagicnum + SIZEmagicnum )
#define SIZEpassword            sizeof( unsigned long )

#define OFFSpagecount           ( OFFSpassword + SIZEpassword )
#define SIZEpagecount           ( _MAXPAGECOUNT )

#define OFFSengparams           ( OFFSpagecount + SIZEpagecount )
#define     OFFSleftmargin      ( 0 )
#define     SIZEleftmargin      sizeof( unsigned long )
#define     OFFStopmargin       ( OFFSleftmargin + SIZEleftmargin )
#define     SIZEtopmargin       sizeof( unsigned long )
#define     OFFSpagetype        ( OFFStopmargin + SIZEtopmargin )
#define     SIZEpagetype        sizeof( unsigned char )
#define SIZEengparams           ( OFFSpagetype + SIZEpagetype )

#define OFFSserial25            ( OFFSengparams + SIZEengparams )
#define     OFFSbaud            ( 0 )
#define     SIZEbaud            sizeof( unsigned char )
#define     OFFSflowpari        ( OFFSbaud + SIZEbaud )
#define     SIZEflowpari        sizeof( unsigned char )
#define     OFFSstopdata        ( OFFSflowpari + SIZEflowpari )
#define     SIZEstopdata        sizeof( unsigned char )
#define SIZEserial              ( OFFSstopdata + SIZEstopdata )
#define OFFSserial9             ( OFFSserial25 + SIZEserial )

#define OFFSprname              ( OFFSserial9 + SIZEserial )
#define SIZEprname              ( _MAXPRNAMESIZE )

#define OFFStimeouts            ( OFFSprname + SIZEprname )
#define     OFFSjobtout         ( 0 )
#define     SIZEjobtout         sizeof( unsigned long )
#define     OFFSmanualtout      ( OFFSjobtout + SIZEjobtout )
#define     SIZEmanualtout      sizeof( unsigned long )
#define     OFFSwaittout        ( OFFSmanualtout + SIZEmanualtout )
#define     SIZEwaittout        sizeof( unsigned long )
#define SIZEtimeouts            ( OFFSwaittout + SIZEwaittout )

#define OFFSeescratcharry       ( OFFStimeouts + SIZEtimeouts )
#define SIZEeescratcharry       ( _MAXEESCRATCHARRY )

#define OFFSidletimefont        (OFFSeescratcharry + SIZEeescratcharry)
#define SIZEidletimefont        ( _MAXIDLETIMEFONT )

#define OFFSstsstart            ( OFFSidletimefont + SIZEidletimefont)
#define SIZEstsstart            sizeof( unsigned char )

#define OFFSsccbatch            ( OFFSstsstart + SIZEstsstart)
#define SIZEsccbatch            ( _MAXSCCBATCH )

#define OFFSsccinter            ( OFFSsccbatch + SIZEsccbatch )
#define SIZEsccinter            ( _MAXSCCINTER )

#define OFFSdplylistsize        ( OFFSsccinter + SIZEsccinter )
#define SIZEdplylistsize        sizeof( unsigned long )

#define OFFSfontcachesze        (OFFSdplylistsize + SIZEdplylistsize)
#define SIZEfontcachesze        sizeof( unsigned long )

#define OFFSatalksize           (OFFSfontcachesze + SIZEfontcachesze)
#define SIZEatalksize           sizeof( unsigned long )

#define OFFSdostartpage         ( OFFSatalksize + SIZEatalksize )
#define SIZEdostartpage         sizeof( unsigned char )

#define OFFShwiomode            ( OFFSdostartpage + SIZEdostartpage )
#define SIZEhwiomode            sizeof( unsigned char )

#define OFFSswiomode            ( OFFShwiomode + SIZEhwiomode )
#define SIZEswiomode            sizeof( unsigned char )

#define OFFSpagestckorder       ( OFFSswiomode + SIZEswiomode )
#define SIZEpagestckorder       sizeof( unsigned char )

#define OFFSreserve             ( OFFSpagestckorder+SIZEpagestckorder)
#define SIZEreserve             ( MAXEEPROMSIZE - OFFSreserve )
#endif

/*
 * ---
 *  Physical Persistent Memory Initialization Values
 * ---
 */
#define ROMVAL  static
ROMVAL  unsigned long   INITmagicnum    = 0L;
ROMVAL  unsigned long   INITpassword    = 0L;
/* pagecount */
ROMVAL  unsigned long   INITleftmargin  = 0L;
ROMVAL  unsigned long   INITtopmargin   = 0L;
ROMVAL  unsigned char   INITpagetype    = 0;
ROMVAL  unsigned char   INITbaud25      = _B9600;
ROMVAL  unsigned char   INITflowpari25  = (_FXONXOFF << 4) | _PNONE;
ROMVAL  unsigned char   INITstopdata25  = (1 << 4) | 8;
ROMVAL  unsigned char   INITbaud9       = _B9600;
ROMVAL  unsigned char   INITflowpari9   = (_FXONXOFF << 4) | _PNONE;
ROMVAL  unsigned char   INITstopdata9   = (1 << 4) | 8;
ROMVAL  unsigned char   INITprname[]    = "\023MicroSoft TrueImage0.234567890.23";
ROMVAL  unsigned long   INITjobtout     = 0L;
ROMVAL  unsigned long   INITmanualtout  = 60L;
ROMVAL  unsigned long   INITwaittout    = 30L;
/* eescratcharray */
/* idletimefont */
ROMVAL  unsigned char   INITstsstart    = 0;
ROMVAL  unsigned char   INITsccbatch[]  = "\031\045\200\000\000\011\045\200\000\000";
ROMVAL  unsigned char   INITsccinter[]  = "\031\045\200\000\000\011\045\200\000\000";
ROMVAL  unsigned long   INITdplylssize  = 0L;
ROMVAL  unsigned long   INITfontcasze   = 0L;
ROMVAL  unsigned long   INITatalksize   = 0L;   /* ???? 0xff, 0, 0, 0 */
ROMVAL  unsigned char   INITdostartpage = 0x00;
ROMVAL  unsigned char   INIThwiomode    = 0;
ROMVAL  unsigned char   INITswiomode    = 0;
ROMVAL  unsigned char   INITpstckorder  = 0;

/*
 * ---
 *  RAM Copy of Physical Persistent Memory
 * ---
 */
static  unsigned char   pm_ramcopy[ MAXEEPROMSIZE ];

/* ..................................................................... */

static
void    ReloadFromROM()
{
    int     i;

    *(unsigned long FAR *)( &pm_ramcopy[ OFFSmagicnum ] )
        = INITmagicnum;
    *(unsigned long FAR *)( &pm_ramcopy[ OFFSpassword ] )
        = INITpassword;
    for (i = 0; i < _MAXPAGECOUNT; i++)
        pm_ramcopy[ OFFSpagecount + i ] = 0;
    *(unsigned long FAR *)( &pm_ramcopy[ OFFSengparams + OFFSleftmargin ] )
        = INITleftmargin;
    *(unsigned long FAR *)( &pm_ramcopy[ OFFSengparams + OFFStopmargin ] )
        = INITtopmargin;
    *(unsigned char FAR *)( &pm_ramcopy[ OFFSengparams + OFFSpagetype ] )
        = INITpagetype;
    *(unsigned char FAR *)( &pm_ramcopy[ OFFSserial25 + OFFSbaud ] )
        = INITbaud25;
    *(unsigned char FAR *)( &pm_ramcopy[ OFFSserial25 + OFFSflowpari ] )
        = INITflowpari25;
    *(unsigned char FAR *)( &pm_ramcopy[ OFFSserial25 + OFFSstopdata ] )
        = INITstopdata25;
    *(unsigned char FAR *)( &pm_ramcopy[ OFFSserial9 + OFFSbaud ] )
        = INITbaud9;
    *(unsigned char FAR *)( &pm_ramcopy[ OFFSserial9 + OFFSflowpari ] )
        = INITflowpari9;
    *(unsigned char FAR *)( &pm_ramcopy[ OFFSserial9 + OFFSstopdata ] )
        = INITstopdata9;
    lmemcpy( &pm_ramcopy[ OFFSprname ], INITprname, sizeof(INITprname) );/*@WIN*/
    *(unsigned long FAR *)( &pm_ramcopy[ OFFStimeouts + OFFSjobtout ] )
        = INITjobtout;
    *(unsigned long FAR *)( &pm_ramcopy[ OFFStimeouts + OFFSmanualtout ] )
        = INITmanualtout;
    *(unsigned long FAR *)( &pm_ramcopy[ OFFStimeouts + OFFSwaittout ] )
        = INITwaittout;
    for (i = 0; i < _MAXEESCRATCHARRY; i++)
        pm_ramcopy[ OFFSeescratcharry + i ] = 0;
    /* APPLE setting value */
    pm_ramcopy[ OFFSeescratcharry ] = 1;
    pm_ramcopy[ OFFSeescratcharry + 3 ] = 0x64;
    pm_ramcopy[ OFFSeescratcharry + 5 ] = 0x07;
    pm_ramcopy[ OFFSeescratcharry + 6 ] = 0xd0;
    for (i = 0; i < _MAXIDLETIMEFONT; i++)
        pm_ramcopy[ OFFSidletimefont + i ] = 0;
    *(unsigned char  FAR *)( &pm_ramcopy[ OFFSstsstart ] )
        = INITstsstart;
    lmemcpy( &pm_ramcopy[ OFFSsccbatch ], INITsccbatch, sizeof(INITsccbatch) );/*@WIN*/
    lmemcpy( &pm_ramcopy[ OFFSsccinter ], INITsccinter, sizeof(INITsccinter) );/*@WIN*/
    *(unsigned long FAR *)( &pm_ramcopy[ OFFSdplylistsize ] )
        = INITdplylssize;
    *(unsigned long FAR *)( &pm_ramcopy[ OFFSfontcachesze ] )
        = INITfontcasze;
    *(unsigned long FAR *)( &pm_ramcopy[ OFFSatalksize ] )
        = INITatalksize;
    /* APPLE setting value */
    *(unsigned long FAR *)( &pm_ramcopy[ OFFSatalksize ] ) = 0xff;
    *(unsigned char FAR *)( &pm_ramcopy[ OFFSdostartpage ] )
        = INITdostartpage;
    *(unsigned char FAR *)( &pm_ramcopy[ OFFShwiomode ] )
        = INIThwiomode;
    *(unsigned char FAR *)( &pm_ramcopy[ OFFSswiomode ] )
        = INITswiomode;
    *(unsigned char FAR *)( &pm_ramcopy[ OFFSpagestckorder ] )
        = INITpstckorder;
    for (i = 0; i < MAXEEPROMSIZE - OFFSreserve; i++)
        pm_ramcopy[ OFFSreserve + i ] = 0;
}

/* ..................................................................... */

/*
 * ---
 *  Byte Diff Bitmap (RAM Copy against Physical)
 * ---
 */

static unsigned char        PMDiffBitmap[ (MAXEEPROMSIZE + 7) / 8 ];
                            /* one bit per byte */

#define     ChkDiff( offset )           \
            (  PMDiffBitmap[ offset / 8 ]  &  ( 1 << ( offset % 8 ) )  )

#define     SetDiff( offset )           \
            (  PMDiffBitmap[ offset / 8 ]  |=  1 << ( offset % 8 )  )

#define     ClrDiff( offset )           \
            (  PMDiffBitmap[ offset / 8 ]  &=  ~( 1 << ( offset % 8 ) )  )

#define     SetAllDiff( setval )                    \
            (  memset( PMDiffBitmap,                \
                       setval? 0xFF : 0x00,         \
                       (MAXEEPROMSIZE + 7) / 8 )  )

/* ..................................................................... */

static
void    FlushOrUpdateRAMandMarkDiff( ramcopy_offs, checkvals, size, toflush )
    register unsigned   ramcopy_offs;
    char FAR *               checkvals;
    unsigned            size;
    int                 toflush;
{
    register unsigned char FAR *     ramcopy_ptr;
    unsigned        offset2;

    ramcopy_ptr = &pm_ramcopy[ ramcopy_offs ];
    for( offset2=0; offset2<size; offset2++, ramcopy_offs++ )
    {
        if( *ramcopy_ptr != (unsigned char)*checkvals )         //@WIN
        {
            *ramcopy_ptr = *checkvals;
            SetDiff( ramcopy_offs );
            if( toflush )
            {
                ClrDiff( ramcopy_offs );
#             ifdef REALEEPROM
                if(  EEPromOnLine
                  && EEPromWrite( ramcopy_offs, pm_ramcopy[ ramcopy_offs ] )
                        != NO_ERR )
                {
                    GEIsig_raise( GEISIGEEPROM, ramcopy_offs );
                }
#             endif /* !REALEEPROM */
            }
        }
        ramcopy_ptr++;
        checkvals++;
    }

    return;
}

/* ..................................................................... */

/*
 * ---
 *  Persistent Logical Segment Handler
 * ---
 */
#define     PMOP_READ       ( 0 )
#define     PMOP_WRITE      ( 1 )
#define     PMOP_FLUSH      ( 2 )

/* ..................................................................... */

static
void        pmop_password( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        *(unsigned long FAR *)pmvals =
                    *(unsigned long FAR *)( &pm_ramcopy[ OFFSpassword ] );
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSpassword, pmvals, SIZEpassword, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_pagecount( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        lmemcpy( pmvals, &pm_ramcopy[OFFSpagecount], SIZEpagecount); /*@WIN*/
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSpagecount, pmvals, SIZEpagecount, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_engparams( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        ( (engcfg_t FAR *)pmvals )->timeout    =
            *(unsigned long FAR *)( &pm_ramcopy[ OFFStimeouts+OFFSmanualtout ] );

        ( (engcfg_t FAR *)pmvals )->leftmargin =
            *(unsigned long FAR *)( &pm_ramcopy[ OFFSengparams+OFFSleftmargin ] );
        ( (engcfg_t FAR *)pmvals )->topmargin  =
            *(unsigned long FAR *)( &pm_ramcopy[ OFFSengparams+OFFStopmargin ] );
        ( (engcfg_t FAR *)pmvals )->pagetype   =
            *(unsigned char FAR *)( &pm_ramcopy[ OFFSengparams+OFFSpagetype ] );
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFStimeouts + OFFSwaittout,
        (char FAR *)&(( (engcfg_t FAR *)pmvals )->timeout ),
        SIZEwaittout,
        pmop == PMOP_FLUSH );

    FlushOrUpdateRAMandMarkDiff(
        OFFSengparams + OFFSleftmargin,
        (char FAR *)&(( (engcfg_t FAR *)pmvals )->leftmargin ),
        SIZEleftmargin,
        pmop == PMOP_FLUSH );

    FlushOrUpdateRAMandMarkDiff(
        OFFSengparams + OFFStopmargin,
        (char FAR *)&(( (engcfg_t FAR *)pmvals )->topmargin ),
        SIZEtopmargin,
        pmop == PMOP_FLUSH );

    FlushOrUpdateRAMandMarkDiff(
        OFFSengparams + OFFSpagetype,
        (char FAR *)&(( (engcfg_t FAR *)pmvals )->pagetype ),
        SIZEpagetype,
        pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_dostartpage( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        *( (unsigned char FAR *)pmvals ) = pm_ramcopy[ OFFSdostartpage ];
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSdostartpage, pmvals, SIZEdostartpage, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_serial( pmop, pmvals, pmid )
    int             pmop;
    char FAR *           pmvals;
    unsigned        pmid;
{
    unsigned        offset;
    unsigned char   serialpack[ SIZEserial ];

    offset = pmid == PMIDofSERIAL25? OFFSserial25 : OFFSserial9;

    if( pmop == PMOP_READ )
    {
        ( (serialcfg_t FAR *)pmvals )->timeout =
            *(unsigned long FAR *)( &pm_ramcopy[ OFFStimeouts + OFFSwaittout ] );

        ( (serialcfg_t FAR *)pmvals )->baudrate    =
                                    pm_ramcopy[ offset + OFFSbaud ];
        ( (serialcfg_t FAR *)pmvals )->flowcontrol =            //@WIN
                    (unsigned char)(pm_ramcopy[ offset + OFFSflowpari ] >> 4);
        ( (serialcfg_t FAR *)pmvals )->parity      =            //@WIN
                    (unsigned char)(pm_ramcopy[ offset + OFFSflowpari ] & 0x0F);
        ( (serialcfg_t FAR *)pmvals )->stopbits    =            //@WIN
                    (unsigned char)(pm_ramcopy[ offset + OFFSstopdata ] >> 4);
        ( (serialcfg_t FAR *)pmvals )->databits    =            //@WIN
                    (unsigned char)(pm_ramcopy[ offset + OFFSstopdata ] & 0x0F);
        return;
    }

    /* deal with waittimeout */
    FlushOrUpdateRAMandMarkDiff(
        OFFStimeouts + OFFSwaittout,
        (char FAR *)&(( (serialcfg_t FAR *)pmvals )->timeout),
        SIZEwaittout, pmop == PMOP_FLUSH );

    /* deal with baud, flow/parity, stop/data */
    serialpack[ OFFSbaud ]     = ( (serialcfg_t FAR *)pmvals )->baudrate;
    serialpack[ OFFSflowpari ] = (unsigned char)( ( (serialcfg_t FAR *)pmvals )->flowcontrol << 4 )
                                 | ( (serialcfg_t FAR *)pmvals )->parity; //@WIN
    serialpack[ OFFSstopdata ] = (unsigned char)( ( (serialcfg_t FAR *)pmvals )->stopbits << 4 )
                                 | ( (serialcfg_t FAR *)pmvals )->databits;//@WIN
    FlushOrUpdateRAMandMarkDiff(
        offset, serialpack, SIZEserial, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_prname( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        lmemcpy( pmvals,  &pm_ramcopy[ OFFSprname ],            /* @WIN */
                (unsigned)pm_ramcopy[ OFFSprname ] + 1 );
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSprname, pmvals, (unsigned)pmvals[0] + 1, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_timeouts( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        ( (toutcfg_t FAR *)pmvals )->jobtout    =
            *(unsigned long FAR *)( &pm_ramcopy[ OFFStimeouts + OFFSjobtout ] );
        ( (toutcfg_t FAR *)pmvals )->manualtout =
            *(unsigned long FAR *)( &pm_ramcopy[ OFFStimeouts + OFFSmanualtout ] );
        ( (toutcfg_t FAR *)pmvals )->waittout   =
            *(unsigned long FAR *)( &pm_ramcopy[ OFFStimeouts + OFFSwaittout ] );
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFStimeouts+OFFSjobtout,
        (char FAR *)&( ( (toutcfg_t FAR *)pmvals )->jobtout ),
        SIZEjobtout, pmop==PMOP_FLUSH );

    FlushOrUpdateRAMandMarkDiff(
        OFFStimeouts+OFFSmanualtout,
        (char FAR *)&( ( (toutcfg_t FAR *)pmvals )->manualtout ),
        SIZEjobtout, pmop==PMOP_FLUSH );

    FlushOrUpdateRAMandMarkDiff(
        OFFStimeouts+OFFSwaittout,
        (char FAR *)&( ( (toutcfg_t FAR *)pmvals )->waittout ),
        SIZEwaittout, pmop==PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_parallel( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        ( (parallelcfg_t FAR *)pmvals )->timeout    =
            *(unsigned long FAR *)( &pm_ramcopy[ OFFStimeouts + OFFSwaittout ] );
        return;
    }

    /* deal with waittimeout */
    FlushOrUpdateRAMandMarkDiff(
        OFFStimeouts+OFFSwaittout,
        (char FAR *)&(( (parallelcfg_t FAR *)pmvals )->timeout ),
        SIZEwaittout, pmop==PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_eescratcharry( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        lmemcpy( pmvals,  &pm_ramcopy[ OFFSeescratcharry ], SIZEeescratcharry); /*@WIN*/
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSeescratcharry, pmvals, SIZEeescratcharry, pmop == PMOP_FLUSH
);

    return;
}

/* ..................................................................... */

static
void        pmop_idletimefont( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        lmemcpy( pmvals, &pm_ramcopy[ OFFSidletimefont ], SIZEidletimefont );/*@WIN*/
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSidletimefont, pmvals, SIZEidletimefont, pmop == PMOP_FLUSH
);

    return;
}

/* ..................................................................... */

static
void        pmop_sccbatch( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        lmemcpy( pmvals, &pm_ramcopy[ OFFSsccbatch ], SIZEsccbatch ); /*@WIN*/
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSsccbatch, pmvals, SIZEsccbatch, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_sccinter( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        lmemcpy( pmvals,  &pm_ramcopy[ OFFSsccinter ], SIZEsccinter ); /*@WIN*/
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSsccinter, pmvals, SIZEsccinter, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_hwiomode( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        *( (unsigned char FAR *)pmvals ) = pm_ramcopy[ OFFShwiomode ];
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFShwiomode, pmvals, SIZEhwiomode, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_swiomode( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        *( (unsigned char FAR *)pmvals ) = pm_ramcopy[ OFFSswiomode ];
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSswiomode, pmvals, SIZEswiomode, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_dplylistsize( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        *( (unsigned long FAR *)pmvals ) =
                        *(unsigned long FAR *)( &pm_ramcopy[ OFFSdplylistsize ] );
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSdplylistsize, pmvals, SIZEdplylistsize, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_fontcachesze( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        *( (unsigned long FAR *)pmvals ) =
                        *(unsigned long FAR *)( &pm_ramcopy[ OFFSfontcachesze ] );
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSfontcachesze, pmvals, SIZEfontcachesze, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_atalksize( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        *( (unsigned long FAR *)pmvals ) =
                        *(unsigned long FAR *)( &pm_ramcopy[ OFFSatalksize ] );
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSatalksize, pmvals, SIZEatalksize, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_stsstart( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        *( (unsigned char FAR *)pmvals ) = pm_ramcopy[ OFFSstsstart ];
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSstsstart, pmvals, SIZEstsstart, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_pagestckorder( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        *( (unsigned char FAR *)pmvals ) = pm_ramcopy[ OFFSpagestckorder ];
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSpagestckorder, pmvals, SIZEpagestckorder, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_atalk( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        ( (atalkcfg_t FAR *)pmvals )->timeout    =
            *(unsigned long FAR *)( &pm_ramcopy[ OFFStimeouts+OFFSwaittout ] );

        lmemcpy( ( (atalkcfg_t FAR *)pmvals )->prname,          /*@WIN*/
                &pm_ramcopy[ OFFSprname ],
                (unsigned)pm_ramcopy[ OFFSprname ] + 1 );
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSwaittout,
        (char FAR *)&(( (atalkcfg_t FAR *)pmvals )->timeout),
        SIZEwaittout, pmop == PMOP_FLUSH );

    FlushOrUpdateRAMandMarkDiff(
        OFFSprname,
        ( (atalkcfg_t FAR *)pmvals )->prname,
        (unsigned)( (atalkcfg_t FAR *)pmvals )->prname[0] + 1, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

/*
 * ---
 *  PMID and Its Operator Mapping
 * ---
 */
/* @WIN; move to top of the file */
//typedef
//    void    (*pmop_t)(int, char FAR *, unsigned /* pmop, vals, [pmid] */ );

typedef
    struct
    {
        unsigned        pmid;
        unsigned        pmsize;
        pmop_t          pmop;
    }
PMid2op_t;

static  PMid2op_t  PMid2opTbl[] =
    {
       { PMIDofPASSWORD,     SIZEpassword,         (pmop_t)pmop_password     },
       { PMIDofPAGECOUNT,    SIZEpagecount,        (pmop_t)pmop_pagecount    },
       { PMIDofPAGEPARAMS,   sizeof(engcfg_t),     (pmop_t)pmop_engparams    },
       { PMIDofSERIAL25,     sizeof(serialcfg_t),  (pmop_t)pmop_serial       },
       { PMIDofSERIAL9,      sizeof(serialcfg_t),  (pmop_t)pmop_serial       },
       { PMIDofPARALLEL,     sizeof(parallelcfg_t),(pmop_t)pmop_parallel     },
       { PMIDofPRNAME,       SIZEprname,           (pmop_t)pmop_prname       },
       { PMIDofTIMEOUTS,     SIZEtimeouts,         (pmop_t)pmop_timeouts     },
       { PMIDofEESCRATCHARRY,SIZEeescratcharry,    (pmop_t)pmop_eescratcharry},
       { PMIDofIDLETIMEFONT, SIZEidletimefont,     (pmop_t)pmop_idletimefont },
       { PMIDofSTSSTART,     SIZEstsstart,         (pmop_t)pmop_stsstart     },
       { PMIDofSCCBATCH,     SIZEsccbatch,         (pmop_t)pmop_sccbatch     },
       { PMIDofSCCINTER,     SIZEsccinter,         (pmop_t)pmop_sccinter     },
       { PMIDofDPLYLISTSIZE, SIZEdplylistsize,     (pmop_t)pmop_dplylistsize },
       { PMIDofFONTCACHESZE, SIZEfontcachesze,     (pmop_t)pmop_fontcachesze },
       { PMIDofATALKSIZE,    SIZEatalksize,        (pmop_t)pmop_atalksize    },
       { PMIDofDOSTARTPAGE,  SIZEdostartpage,      (pmop_t)pmop_dostartpage  },
       { PMIDofHWIOMODE,     SIZEhwiomode,         (pmop_t)pmop_hwiomode     },
       { PMIDofSWIOMODE,     SIZEswiomode,         (pmop_t)pmop_swiomode     },
       { PMIDofPAGESTCKORDER,SIZEpagestckorder,    (pmop_t)pmop_pagestckorder},
       { PMIDofATALK,        sizeof(atalkcfg_t),   (pmop_t)pmop_atalk        },
       { PMIDofRESERVE,      0,                    (pmop_t)NULL              }
    };

/* ..................................................................... */

static
pmop_t      findpmop( pmid, pmsize )
    unsigned        pmid;
    unsigned        pmsize;
{
    PMid2op_t FAR *      id2op;

    for( id2op=PMid2opTbl; id2op->pmid!=0; id2op++ )
        if( id2op->pmid == pmid )
            return( id2op->pmsize == pmsize? id2op->pmop : (pmop_t)NULL );

    return( (pmop_t)NULL );
}

/* ..................................................................... */

/*
 * ---
 *  Interface Routines
 * ---
 */

/* ..................................................................... */
#ifndef WIN
int         GEIpm_read( pmid, pmvals, pmsize )
    unsigned        pmid;
    char FAR *           pmvals;
    unsigned        pmsize;
{
    pmop_t          pmop;

    if( (pmop = findpmop( pmid, pmsize )) == (pmop_t)NULL )
    {
        GESseterror( EINVAL );
        return( FALSE );
    }

    (*pmop)( PMOP_READ, pmvals);
    return( TRUE );
}

/* ..................................................................... */

int         GEIpm_write( pmid, pmvals, pmsize )
    unsigned        pmid;
    char FAR *           pmvals;
    unsigned        pmsize;
{
    pmop_t          pmop;

    if( (pmop = findpmop( pmid, pmsize )) == (pmop_t)NULL )
    {
        GESseterror( EINVAL );
        return( FALSE );
    }

    (*pmop)( PMOP_WRITE, pmvals);
    return( TRUE );
}

/* ..................................................................... */

int         GEIpm_flush( pmid, pmvals, pmsize )
    unsigned        pmid;
    char FAR *           pmvals;
    unsigned        pmsize;
{
    pmop_t          pmop;

    if( (pmop = findpmop( pmid, pmsize )) == (pmop_t)NULL )
    {
        GESseterror( EINVAL );
        return( FALSE );
    }

    (*pmop)( PMOP_FLUSH, pmvals);
    return( TRUE );
}

/* ..................................................................... */

void        GEIpm_flushall()
{

#ifdef REALEEPROM
    {
        register unsigned char FAR * diffbmp_p;
        register unsigned       ramcopy_offs, ii;

        if( !EEPromOnLine )
        {
            SetDiff( 0 );
            return;
        }

        diffbmp_p    = PMDiffBitmap;
        ramcopy_offs = 0;
        while( ramcopy_offs < MAXEERPOMSIZE )
        {
            if( *diffbmp_p == 0 )
            {
                ramcopy_offs += 8;
                diffbmp_p++;
                continue;
            }

            for( ii=0; ii<7; ii++ )
            {
                if( *diffbmp_p & ( 1 << ii ) )
                {
                    if( EEPromWrite( ramcopy_offs, pm_ramcopy[ ramcopy_offs ] )
                            != NO_ERR )
                        GEIsig_raise( GEISIGEEPROM, ramcopy_offs );
                    else
                        ClrDiff( ramcopy_offs );
                }

                if( ramcopy_offs++ >= MAXEEPROMSIZE )
                    break;
            }
            diffbmp_p++;
        }
    }
#endif

    return;
}
#endif

/* ..................................................................... */

void        GEIpm_reload()
{
    ReloadFromROM();

#ifdef REALEEPROM
    SetAllDiff( 1 );
    GEIpm_flushall();
#else
    SetAllDiff( 0 );
#endif
}

/* ..................................................................... */

/*
 * ---
 *  Initialization Code
 * ---
 */

/* ..................................................................... */

static
void        GESpm_sighandler( sigid, sigcode )
    int         sigid;
    int         sigcode;
{
    GESseterror( EIO );
}

/* ..................................................................... */

#ifndef WIN
void            GESpm_init()
{
#ifdef REALEEPROM
    {
        register int                ramcopy_offs;
        register unsigned char FAR *     ramcopy_ptr;
        int                         checksum = 0;

        if( ( EEPromOnLine = ( EEPromTInit() == NO_ERR ) ) )
        {
            for( ramcopy_offs = 0, ramcopy_ptr = pm_ramcopy;
                 ramcopy_offs < MAXEEPROMSIZE;
                 ramcopy_offs++, ramcopy_ptr++ )
            {
                if( EEPromRead( ramcopy_offs, ramcopy_ptr ) != NO_ERR )
                {
                    GEIpm_reload();
                    return;
                }
                checksum = checksum + ( *ramcopy_ptr );
            }

            if ( checksum == EEPROM_CHECKSUM )
            {
                ReloadFromROM();
                SetAllDiff( 0 );
                return;
            }
        }
        GEIsig_signal( GEISIGEEPROM, GESpm_sighandler );
        SetAllDiff( 0 );
    }
#else /* REALEEPROM */
    {
        ReloadFromROM();
        SetAllDiff( 0 );
    }
#endif /* REALEEPROM */

    return;
}
#endif

/* ..................................................................... */

/* BYou (for temporary testing ???) */

#include        <string.h>
#include        "geiioctl.h"

typedef
    struct IOParams
    {
        char FAR *           devname;
        GEIioparams_t   ioparams;
    }
IOParams_t;

#ifdef  UNIX
IOParams_t      IOParamsTable[ 2 ] =
                {
                  {
                    "%SERIAL25%",
                    {
                        _SERIAL,
                        { _B9600, _PNONE, 1, 8, _FXONXOFF }
                    }
                  }
                 ,{
                    "%SERIAL9%",
                    {
                        _SERIAL,
                        { _B9600, _PNONE, 1, 8, _FXONXOFF }
                    }
                  }
#else
IOParams_t      IOParamsTable[ 3 ] =/* BE CONSISTENT WITH gesiocfg.def */
                {
                  {
                    "%SERIAL25%",
                    {
                        _SERIAL,
                        { _B9600, _PNONE, 1, 8, _FXONXOFF }
                    }
                  }
                 ,{
                    "%SERIAL9%",
                    {
                        _SERIAL,
                        { _B9600, _PNONE, 1, 8, _FXONXOFF }
                    }
                  }
                 ,{
                    "%PARALLEL%",
                    {
                        _PARALLEL,
                        { 0 }
                    }
                  }
              /* ,{
               *    "%APPLETALK%",
               *    {
               *        _APPLETALK,
               *        { ' ..... ' }
               *    }
               *  } */
#endif  /* UNIX */
                };

#ifndef WIN
int     GEIpm_ioparams_read( channelname, ioparams, isBatch )
    char FAR *           channelname;
    GEIioparams_t FAR *  ioparams;
    int             isBatch;
{
    register IOParams_t FAR *    iop;

    for( iop=IOParamsTable; iop<&IOParamsTable[3]; iop++ )
        if( lstrcmp( iop->devname, channelname ) == 0 )         /*@WIN*/
        {
            *ioparams = iop->ioparams;
            return( TRUE );
        }

    return( FALSE );
}

int     GEIpm_ioparams_write( channelname, ioparams, isBatch )
    char FAR *           channelname;
    GEIioparams_t FAR *  ioparams;
    int             isBatch;
{
    return( TRUE );
}

int     GEIpm_ioparams_flush( channelname, ioparams, isBatch )
    char FAR *           channelname;
    GEIioparams_t FAR *  ioparams;
    int             isBatch;
{
    return( TRUE );
}
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\gei\geipm.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GEIpm.h
 *
 *  HISTORY:
 *  09/16/90    byou    created.
 * ---------------------------------------------------------------------
 */

#ifndef _GEIPM_H_
#define _GEIPM_H_

/*
 * ---
 *  Global Logical PMid Assignments (ALWAYS FROM 1)
 * ---
 */
#define     PMIDofPASSWORD      ( 1 )
#define     PMIDofPAGECOUNT     ( 2 )
#define     PMIDofPAGEPARAMS    ( 3 )
#define     PMIDofSERIAL25      ( 4 )
#define     PMIDofSERIAL9       ( 5 )
#define     PMIDofPARALLEL      ( 6 )
#define     PMIDofPRNAME        ( 7 )
#define     PMIDofTIMEOUTS      ( 8 )
#define     PMIDofEESCRATCHARRY ( 9 )
#define     PMIDofIDLETIMEFONT  ( 10 )
#define     PMIDofSTSSTART      ( 11 )
#define     PMIDofSCCBATCH      ( 12 )
#define     PMIDofSCCINTER      ( 13 )
#define     PMIDofDPLYLISTSIZE  ( 14 )
#define     PMIDofFONTCACHESZE  ( 15 )
#define     PMIDofATALKSIZE     ( 16 )
#define     PMIDofDOSTARTPAGE   ( 17 )
#define     PMIDofHWIOMODE      ( 18 )
#define     PMIDofSWIOMODE      ( 19 )
#define     PMIDofPAGESTCKORDER ( 20 )
#define     PMIDofATALK         ( 21 )
#define     PMIDofMULTICOPY     ( 22 )
#define     PMIDofPAGETYPE      ( 23 )

#define     PMIDofRESERVE       ( 24 )

/*
 * ---
 *  Interface Routines
 * ---
 */
int /* bool */  GEIpm_read(unsigned, char FAR *, unsigned);
int /* bool */  GEIpm_write(unsigned, char FAR *, unsigned);
int /* bool */  GEIpm_flush(unsigned, char FAR *, unsigned);
void            GEIpm_flushall(void);
void            GEIpm_reload(void);

/* to be implemented ??? */
int /* bool */  GEIpm_ioparams_read(char FAR *, GEIioparams_t FAR *, int);
int /* bool */  GEIpm_ioparams_write(char FAR *, GEIioparams_t FAR *, int);
int /* bool */  GEIpm_ioparams_flush(char FAR *, GEIioparams_t FAR *, int);

#endif /* !_GEIPM_H_ */
#define     _MAXPAGECOUNT      128

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\gei\geisig.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GEIsig.h
 *
 *  HISTORY:
 *  09/18/90    byou      created.
 *  01/07/91    billlwo   rename GEIseterror to GESseterror
 *                        hook ^C isr at the time of GESsig_init()
 * ---------------------------------------------------------------------
 */



// DJC added global include file
#include "psglobal.h"

// DJC DJC #include    "windowsx.h"                /* @WIN */
#include "windows.h"


#include    "winenv.h"                  /* @WIN */

#include    "geisig.h"
#include    "geierr.h"

#include    "gesmem.h"
#include    "gescfg.h"

#ifndef NULL
#define NULL    ( 0 )
#endif

typedef
    struct sigent
    {
        int             sig_state;      /* nonzero means busy */
        sighandler_t    sig_handler;
    }
sigent_t;

/* @WIN; add prototype */
void hook_interrupt(void);

static  sigent_t FAR *       SigTable;       /* allocated at init */
/*
 * ---
 *  Interface Routines
 * ---
 */

/* ..................................................................... */

sighandler_t    GEIsig_signal( sigid, newsighandler )
    int             sigid;
    sighandler_t    newsighandler;
{
    register sigent_t FAR *  sigentp;
    sighandler_t        oldsighandler;

    if( sigid < 0 || sigid >= MAXSIGS )
        return( GEISIG_IGN );

    oldsighandler = (sigentp = (SigTable + sigid))->sig_handler;
    sigentp->sig_handler = newsighandler;

    return( oldsighandler );
}

/* ..................................................................... */

void            GEIsig_raise( sigid, sigcode )
    int         sigid;
    int         sigcode;
{
    register sigent_t FAR *  sigentp;

    if( sigid < 0 || sigid >= MAXSIGS )
        return;

    if( (sigentp = (SigTable + sigid))->sig_state == 0 )
    {
        sigentp->sig_state = 1;
        if( sigentp->sig_handler != GEISIG_IGN )
            (*( sigentp->sig_handler ))( sigid, sigcode );
        sigentp->sig_state = 0;
    }
    return;
}

/* ..................................................................... */

/*
 * ---
 *  Initialization Code
 * ---
 */

/* ..................................................................... */

void        GESsig_init()
{
    register sigent_t FAR *  sigentp;

    SigTable = (sigent_t FAR *)GESpalloc( MAXSIGS * sizeof(sigent_t) );
    if( SigTable == (sigent_t FAR *)NULL )
    {
        GESseterror( ENOMEM );
        return;
    }

    for( sigentp=SigTable; sigentp<( SigTable + MAXSIGS ); sigentp++ )
    {
        sigentp->sig_state   = 0;
        sigentp->sig_handler = GEISIG_IGN;
    }
    /* hook ^C isr - Bill */
    hook_interrupt();                   /* @WIN */
    GEIsig_signal(GEISIGINT, (sighandler_t)hook_interrupt);
}

/* ^C hook routine */
void hook_interrupt()
{
   extern short int_flag;
   int_flag=1;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\gei\geisig.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GEIsig.h
 *
 *  HISTORY:
 *  09/18/90    byou    created.
 *  01/14/91    bill    update SIGID starting sequence
 * ---------------------------------------------------------------------
 */

#ifndef _GEISIG_H_
#define _GEISIG_H_

#define     GEISIGINT       0  /* ID */
#define     GEISIGEEPROM    1
#define     GEISIGENG       2
#define     GEISIGFPE       3
#define     GEISIGSCC       4  /* when scc cmd received */
#define     GEISIGSTART     5  /* when dostartpage cmd received */
#define     GEISIGKILL      6  /* emulation switch */

typedef     void (*sighandler_t)(int, int /* sigid, sigcode */ );

#define     GEISIG_IGN      (sighandler_t)NULL
#define     GEISIG_DFL      ( GEISIG_IGN )


sighandler_t    GEIsig_signal(int, sighandler_t /* sigid, sighandler */ );
void            GEIsig_raise( int, int /* sigid, sigcode */ ); /* @WIN */

#endif /* !_GEISIG_H_ */

/* @WIN; add prototype */
void        GESsig_init(void);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\gei\geiioctl.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GEIioctl.h
 *
 *  HISTORY:
 *  09/13/90    byou    created.
 *  10/18/90    byou    completed all the possible definitions.
 *  10/22/90    byou    made GEIioparams a union structure.
 *  01/03/90    billlwo GEIiopararms subfield for AppleTalk was added
 * ---------------------------------------------------------------------
 */

#ifndef _GEIIOCTL_H_
#define _GEIIOCTL_H_

/*
 * ---
 * IO Device Parameters
 * ---
 */
#   define  _MAXPRNAMESIZE      ( 32 )  /* including a prefixed length byte */
#   define  ATTYPE_MAX_SIZE     ( 32 )  /* including a prefixed length byte */
#   define  ATZONE_MAX_SIZE      ( 2 )  /* including a prefixed length byte */
struct sioparams
{
    unsigned char       baudrate;   /* see below */
    unsigned char       parity;     /* see below */
    unsigned char       stopbits;   /* 1 or 2 */
    unsigned char       databits; /* 6(0), 7(1) or 8(2), 11/30/90 Jimmy */
    unsigned char       flowcontrol;/* see below */
};

typedef
    struct GEIioparams
    {
        unsigned char       protocol;   /* see below */
#ifdef  UNIX
        struct sioparams s;
#else
        union
        {
            struct sioparams s;
            struct pioparams
            {
                unsigned            reserved;
            }       p;
            struct aioparams
            {
                unsigned char       prname[ _MAXPRNAMESIZE ];  /* in pascal */
                unsigned char       atalktype[ ATTYPE_MAX_SIZE ];
                unsigned char       atalkzone[ ATZONE_MAX_SIZE ];

            }       a;
        }   u;
#endif  /* UNIX */
    }
GEIioparams_t;

struct dn_para_str {
        int dn;
        GEIioparams_t   para;
};

/* protocol definition */
#   define _SERIAL              ( 0 )
#   define _PARALLEL            ( 1 )
#   define _APPLETALK           ( 2 )
#   define _ETHERTALK           ( 3 )

/* baudrate_definition */
#   define _B110                ( 0 )
#   define _B300                ( 1 )
#   define _B600                ( 2 )
#   define _B1200               ( 3 )
#   define _B2400               ( 4 )
#   define _B4800               ( 5 )
#   define _B9600               ( 6 )
#   define _B19200              ( 7 )
#   define _B38400              ( 8 )
#   define _B57600              ( 9 )

/* parity definition */
#   define _PNONE               ( 0 )
#   define _PODD                ( 1 )
#   define _PEVEN               ( 2 )
#   define _PMARK               ( 3 )
#   define _PSPACE              ( 4 )

/* flowcontrol definition */
#   define _FXONXOFF            ( 0 )
#   define _FDTR                ( 1 )
#   define _FETXACK             ( 2 )

/* value for no wait-timeout event */
#   define _NOWAITTIMEOUT       ( 0L )

/*
 * ---
 * IOCTL Codes
 * ---
 */

#   define _FIONREAD            ( 1 )
#   define _FIONRESET           ( 2 )

#   define _GETIOPARAMS         ( 3 )
#   define _SETIOPARAMS         ( 4 )

#   define _GETIOCOOK           ( 5 )
#   define _SETIOCOOK           ( 6 )

#   define _ECHOEOF             ( 7 )

#   define _F_GETFL             ( 8 )
#   define _F_SETFL             ( 9 )

#   define _I_PUSH              ( 10 )
#   define _I_POP               ( 11 )
#   define _I_LOOK              ( 12 )

#endif /* !_GEIIOCTL_H_ */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\gei\geiiolib.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GEIiolib.c
 *
 *  COMPILATION SWITCHES:
 *
 *  HISTORY:
 *  09/15/90    Erik Chen   created.
 * ---------------------------------------------------------------------
 */


// DJC added global include file
#include "psglobal.h"


// DJC DJC #include    "windowsx.h"                /* @WIN */
#include "windows.h"

#include    "winenv.h"                  /* @WIN */

#include        "geiio.h"
#include        "gescfg.h"

typedef double              real64;
typedef float               real32;
typedef unsigned long       ufix32;
typedef long                fix32;
typedef unsigned int        ufix;
typedef int                 fix;
typedef unsigned short      ufix16;
typedef short               fix16;
typedef unsigned char       ubyte;
typedef char                byte;

#ifndef DOS
#define near
#define far
#endif

#ifndef TRUE
#define TRUE    ( 1 )
#define FALSE   ( 0 )
#endif

/* @WIN; add prototype */
static byte * near printfield(byte *cursor, ufix32 number, ufix32 divide,
                              ufix32 radix);

/*
 * ---------------------------------------------------------------------
 *  printf( file, ... ) and GEIio_printf(...)
 * ---------------------------------------------------------------------
 */

static char     digit[] =
{
    '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F',
    'G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V',
    'W','X','Y','Z'
};

/* ...................................... */

static byte * near
printfield(cursor, number, divide, radix)
byte    *cursor;
ufix32  number;
ufix32  divide;
ufix32  radix;
{
    byte        c;
    fix         notzero = 0;

    for (; divide >= 1L;) {
        c = digit[(fix)(number / divide)];
        if (c != '0' || notzero) {
           notzero = 1;
           *cursor++ = c;
        }
        number = number % divide;
        divide = divide / radix;
    }
    if (!notzero)
       *cursor++ = '0';
    return(cursor);
}   /* printfield() */

/* ...................................... */

#ifdef DBGDEV
/*
 *     printf()
 */
fix
printf(va_alist)
char    *va_alist;
{
    char*       argv;
    byte        *cursor;
    byte        *format;
    byte        buffer[256];

    argv = (byte *)&va_alist;
    format = ((char **)(argv += sizeof(char *)))[-1];

    for (cursor = buffer; *format != '\0';) {
        if (*format == '%') {
           fix  flag;

           for (flag = 0, format++; *format != '\0';) {
               switch (*format++) {
               case 'l':
                    flag = 1;
                    break;
               case 'd':
               case 'i':
                    if (flag == 0) {
                       fix  number;

                       number = ((fix *)(argv += sizeof(fix)))[-1];
                       if (number < 0) {
                          number = -number;
                          *cursor++= '-';
                       } else
                          *cursor++= ' ';
                       cursor = printfield(cursor, (ufix32)number, 10000L, 10L);
                    } else {
                       fix32  number;

                       number = ((fix32 *)(argv += sizeof(fix32)))[-1];
                       if (number < 0) {
                          number = -number;
                          *cursor++= '-';
                       } else
                          *cursor++= ' ';
                       cursor = printfield(cursor, (ufix32)number, 1000000000L, 10L);
                    }
                    flag = 2;
                    break;
               case 'u':
                    if (flag == 0) {
                       ufix  number;

                       number = ((ufix *)(argv += sizeof(ufix)))[-1];
                       cursor = printfield(cursor, (ufix32)number, 10000L, 10L);
                      } else {
                       ufix32   number;

                       number = ((ufix32 *)(argv += sizeof(ufix32)))[-1];
                       cursor = printfield(cursor, number, 1000000000L, 10L);
                    }
                    flag = 2;
                    break;
               case 'o':
                    if (flag == 0) {
                       ufix  number;

                       number = ((ufix *)(argv += sizeof(ufix)))[-1];
                       cursor = printfield(cursor, (ufix32)number, 0x8000L, 8L);
                     } else {
                       ufix32   number;

                       number = ((ufix32 *)(argv += sizeof(ufix32)))[-1];
                       cursor = printfield(cursor, number, 0x40000000L, 8L);
                    }
                    flag = 2;
                    break;
               case 'x':
               case 'X':
                    if (flag == 0) {
                       ufix  number;

                       number = ((ufix *)(argv += sizeof(ufix)))[-1];
                       cursor = printfield(cursor, (ufix32)number, 0x1000L, 16L);
                     } else {
                       ufix32  number;

                       number = ((ufix32 *)(argv += sizeof(ufix32)))[-1];
                       cursor = printfield(cursor, number, 0x10000000L, 16L);
                    }
                    flag = 2;
                    break;
               case 'f':
               case 'e':
               case 'E':
               case 'g':
               case 'G':
                    {
                       fix      length;
                       fix      expont;
                       real64   number;
                       number = ((real64 *)(argv += sizeof(real64)))[-1];
                       if (number < (real64)0) {
                          if (number <= (real64)-1.0e39) {
                             *cursor++= '-';
                             *cursor++= 'I';
                             *cursor++= 'N';
                             *cursor++= 'F';
                             *cursor++= ' ';
                             flag = 2;
                             break;
                          } else if (number > (real64)-1.0e-39) {
                             *cursor++= '-';
                             *cursor++= '0';
                             *cursor++= '.';
                             *cursor++= '0';
                             *cursor++= ' ';
                             flag = 2;
                             break;
                          }
                          number = -number;
                          *cursor++= '-';
                       } else {
                          if (number >= (real64)1.0e39) {
                             *cursor++= '+';
                             *cursor++= 'I';
                             *cursor++= 'N';
                             *cursor++= 'F';
                             *cursor++= ' ';
                             flag = 2;
                             break;
                          } else if (number < (real64)1.0e-39) {
                             *cursor++= '+';
                             *cursor++= '0';
                             *cursor++= '.';
                             *cursor++= '0';
                             *cursor++= ' ';
                             flag = 2;
                             break;
                          }

                          *cursor++= ' ';
                       }
                       if (number >= (real64)1.0) {
                          for (expont = 0; (real32)number >= (real32)10.0; expont++)
                               number = number / 10.0;
                       } else {
                          for (expont = 0; (real32)number < (real32)1.0; expont--)
                              number = number * 10.0;
                       }
                       *cursor++= digit[((fix)number)];
                       number = (number - ((fix)number)) * 10.0;
                       *cursor++= '.';
                       for (length = 0; length < 5; length++) {
                           *cursor++= digit[((fix)number)];
                           number = (number - ((fix)number)) * 10.0;
                       }
                       *cursor++= 'E';
                       if (expont < 0) {
                          expont = -expont;
                          *cursor++= '-';
                       } else
                          *cursor++= '+';
                       cursor = printfield(cursor, (ufix32)expont, 10L, 10L);
                    }
                    flag = 2;
                    break;
               case 'c':
                    {
                       ufix  charac;

                       charac = ((ufix *)(argv += sizeof(ufix)))[-1];
                       *cursor++ = (byte)charac;
                    }
                    flag = 2;
                    break;
               case 's':
                    {
                       byte  *string;

                       string = ((byte **)(argv += sizeof(byte *)))[-1];
                       for (; *string != '\0';)
                           *cursor++= *string++;
                    }
                    flag = 2;
                    break;
               } /* switch */

               if (flag == 2)
                  break;
            } /* for */
        } else {
            *cursor++= *format++;
        }
    } /* for */

    CDEV_WRITE( MINdev(DBGDEV), buffer, cursor-buffer, _O_SYNC );

    return( 0 );
}   /* GEIio_printf() */

#endif /* DBGDEV */

/* ...................................... */

fix
GEIio_printf(file, va_alist)
GEIFILE *file;
char    *va_alist;
{
    char*       argv;
    byte        *cursor;
    byte        *format;
    byte        buffer[256];

    argv = (byte *)&va_alist;
    format = ((char **)(argv += sizeof(char *)))[-1];

    for (cursor = buffer; *format != '\0';) {
        if (*format == '%') {
           fix  flag;

           for (flag = 0, format++; *format != '\0';) {
               switch (*format++) {
               case 'l':
                    flag = 1;
                    break;
               case 'd':
               case 'i':
                    if (flag == 0) {
                       fix  number;

                       number = ((fix *)(argv += sizeof(fix)))[-1];
                       if (number < 0) {
                          number = -number;
                          *cursor++= '-';
                       } else
                          *cursor++= ' ';
                       cursor = printfield(cursor, (ufix32)number, 10000L, 10L);
                    } else {
                       fix32  number;

                       number = ((fix32 *)(argv += sizeof(fix32)))[-1];
                       if (number < 0) {
                          number = -number;
                          *cursor++= '-';
                       } else
                          *cursor++= ' ';
                       cursor = printfield(cursor, (ufix32)number, 1000000000L, 10L);
                    }
                    flag = 2;
                    break;
               case 'u':
                    if (flag == 0) {
                       ufix  number;

                       number = ((ufix *)(argv += sizeof(ufix)))[-1];
                       cursor = printfield(cursor, (ufix32)number, 10000L, 10L);
                      } else {
                       ufix32   number;

                       number = ((ufix32 *)(argv += sizeof(ufix32)))[-1];
                       cursor = printfield(cursor, number, 1000000000L, 10L);
                    }
                    flag = 2;
                    break;
               case 'o':
                    if (flag == 0) {
                       ufix  number;

                       number = ((ufix *)(argv += sizeof(ufix)))[-1];
                       cursor = printfield(cursor, (ufix32)number, 0x8000L, 8L);
                     } else {
                       ufix32   number;

                       number = ((ufix32 *)(argv += sizeof(ufix32)))[-1];
                       cursor = printfield(cursor, number, 0x40000000L, 8L);
                    }
                    flag = 2;
                    break;
               case 'x':
               case 'X':
                    if (flag == 0) {
                       ufix  number;

                       number = ((ufix *)(argv += sizeof(ufix)))[-1];
                       cursor = printfield(cursor, (ufix32)number, 0x1000L, 16L);
                     } else {
                       ufix32  number;

                       number = ((ufix32 *)(argv += sizeof(ufix32)))[-1];
                       cursor = printfield(cursor, number, 0x10000000L, 16L);
                    }
                    flag = 2;
                    break;
               case 'f':
               case 'e':
               case 'E':
               case 'g':
               case 'G':
                    {
                       fix      length;
                       fix      expont;
                       real64   number;
                       number = ((real64 *)(argv += sizeof(real64)))[-1];
                       if (number < (real64)0.0) {
                          if (number <= (real64)-1.0e39) {
                             *cursor++= '-';
                             *cursor++= 'I';
                             *cursor++= 'N';
                             *cursor++= 'F';
                             *cursor++= ' ';
                             flag = 2;
                             break;
                          } else if (number > (real64)-1.0e-39) {
                             *cursor++= '-';
                             *cursor++= '0';
                             *cursor++= '.';
                             *cursor++= '0';
                             *cursor++= ' ';
                             flag = 2;
                             break;
                          }
                          number = -number;
                          *cursor++= '-';
                       } else {
                          if (number >= (real64)1.0e39) {
                             *cursor++= '+';
                             *cursor++= 'I';
                             *cursor++= 'N';
                             *cursor++= 'F';
                             *cursor++= ' ';
                             flag = 2;
                             break;
                          } else if (number < (real64)1.0e-39) {
                             *cursor++= '+';
                             *cursor++= '0';
                             *cursor++= '.';
                             *cursor++= '0';
                             *cursor++= ' ';
                             flag = 2;
                             break;
                          }

                          *cursor++= ' ';
                       }
                       if (number >= (real64)1.0) {
                          for (expont = 0; (real32)number >= (real32)10.0; expont++)
                               number = number / 10.0;
                       } else {
                          for (expont = 0; (real32)number < (real32)1.0; expont--)
                              number = number * 10.0;
                       }
                       *cursor++= digit[((fix)number)];
                       number = (number - ((fix)number)) * 10.0;
                       *cursor++= '.';
                       for (length = 0; length < 5; length++) {
                           *cursor++= digit[((fix)number)];
                           number = (number - ((fix)number)) * 10.0;
                       }
                       *cursor++= 'E';
                       if (expont < 0) {
                          expont = -expont;
                          *cursor++= '-';
                       } else
                          *cursor++= '+';
                       cursor = printfield(cursor, (ufix32)expont, 10L, 10L);
                    }
                    flag = 2;
                    break;
               case 'c':
                    {
                       ufix  charac;

                       charac = ((ufix *)(argv += sizeof(ufix)))[-1];
                       *cursor++ = (byte)charac;
                    }
                    flag = 2;
                    break;
               case 's':
                    {
                       byte  *string;

                       string = ((byte **)(argv += sizeof(byte *)))[-1];
                       for (; *string != '\0';)
                           *cursor++= *string++;
                    }
                    flag = 2;
                    break;
               } /* switch */

               if (flag == 2)
                  break;
            } /* for */
        } else {
            *cursor++= *format++;
        }
    } /* for */

    GEIio_write( file, buffer, (int)(cursor-buffer) );
    GEIio_flush( file );
    return( 0 );
}   /* GEIio_printf */

/* ...................................... */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\gei\gesdev.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GESdev.h
 *
 *  HISTORY:
 *  09/13/90    byou    created.
 *  10/17/90    byou    removed all about block devices.
 *  10/18/90    byou    revised CDEV_ macros.
 *  11/19/90    jimmy   move GEStty_t from gesdev.c
 *  01/07/91    billlwo rename c_XXXX to x_XXXX in GESDEV[] definition
 *                      for generic reason.
 * ---------------------------------------------------------------------
 */

#ifndef _GESDEV_H_
#define _GESDEV_H_

#ifdef  UNIX
#define volatile
#endif  /* UNIX */

/*
 * ----------------------------------------------------------------
 * Status Obtaining And Interrupt Signaling
 * ----------------------------------------------------------------
 */
// void        GESio_obtainstatus();
// @WIN; already defined in geiio.h

void        GESio_interrupt(int /* devnum */ );       /*@WIN; add prototype*/

/*
 * ----------------------------------------------------------------
 *  Device Number
 * ----------------------------------------------------------------
 */
#   define  MAJdev( dev )           ( ( 0xFF00 & (dev) ) >> 8 )
#   define  MINdev( dev )           ( 0x00FF & (dev) )
#   define  MAKEdev( major, minor ) ( (0xFF & (major))<<8 | (0xFF & (minor)) )

/*
 * ----------------------------------------------------------------
 *  NullDev and NoDev
 * ----------------------------------------------------------------
 */
int         nulldev();
int         nodev();

/*
 * ----------------------------------------------------------------
 *  Character Device Switch Table
 * ----------------------------------------------------------------
 */
/* @WIN; add prototype */
typedef
    struct GEScdev
    {
        unsigned x_flag;     /* reserved for future use */
        int     (*x_open)  (int /* dev.minor */ );
        int     (*x_close) (int /* dev.minor */ );
        int     (*x_read)  (int, char FAR *, int, int/* dev.minor, buf, size, mode */ );
        int     (*x_write) (int, char FAR *, int, int/* dev.minor, buf, size, mode */ );
        int     (*x_ioctl) (int, int, int FAR * /* dev.minor, request, *arg */ );
} GEScdev_t;
extern          GEScdev_t       GEScdevsw[];

#define         CDEV_OPEN(d)        \
                    ( *GEScdevsw[ MAJdev(d) ].x_open  )( MINdev(d) )
#define         CDEV_CLOSE(d)       \
                    ( *GEScdevsw[ MAJdev(d) ].x_close )( MINdev(d) )
#define         CDEV_READ(d,b,s,m)  \
                    ( *GEScdevsw[ MAJdev(d) ].x_read  )( MINdev(d), b, s, m )
#define         CDEV_WRITE(d,b,s,m) \
                    ( *GEScdevsw[ MAJdev(d) ].x_write )( MINdev(d), b, s, m )
#define         CDEV_IOCTL(d,r,a) \
                    ( *GEScdevsw[ MAJdev(d) ].x_ioctl )( MINdev(d), r, a )

typedef
    struct GEStty
    {
        /* device open count */
        int             tt_count;
        /* input buffer */
        char FAR *      tt_ibuf;
        int             tt_isiz;
        int             tt_iget;
        int             tt_iput;
/* Bill 04/03/91 remove it*/
/* volatile int            tt_icnt; */
        int             tt_himark;
        int             tt_lomark;
        /* output buffer */
        char FAR *      tt_obuf;
        int             tt_osiz;
        int             tt_oget;
        int             tt_oput;
/* Bill 04/08/91 remove it*/
/* volatile int            tt_ocnt; */
        /* control flags */
volatile unsigned char  tt_iflag;
volatile unsigned char  tt_oflag;
volatile unsigned char  tt_cflag;
        /* characters for cooking */
        char            tt_interrupt;   /* ^C */
        char            tt_status;      /* ^T */
        char            tt_eof;         /* ^D */
        /* device parameters */
        GEIioparams_t   tt_params;      /* the structure depends on tty type */
    }
GEStty_t;

#   define _TT_I_BLOCK      ( 00001 )   /* input exceeding high water mark */
#   define _TT_I_EOF        ( 00002 )   /* input EOF received */
#   define _TT_I_ERR        ( 00004 )   /* input buffer overflows */
#   define _TT_O_BLOCK      ( 00001 )   /* output blocked by a peer XOFF */
#   define _TT_O_XMTING     ( 00002 )   /* being transmitting */
#   define _TT_O_CTRL_T     ( 00004 )   /* ^T pressed flag */
#   define _TT_C_PROTOMASK  ( 00007 )   /* protocol mask */
#   define _TT_C_XONXOFF    ( 00001 )   /* Xon/Xoff? */
#   define _TT_C_ETXACK     ( 00002 )   /* ETX/ACK? (not implemented) */
#   define _TT_C_DTR        ( 00004 )   /* DTR? */
#   define _TT_C_COOK       ( 00010 )   /* cook mode? */
#endif /* !_GESDEV_H_ */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\gei\geitmr.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GEItmr.h
 *
 *  HISTORY:
 *  09/18/89    you     created (modified from AppleTalk/TIO).
 * ---------------------------------------------------------------------
 */

#ifndef _GEITMR_H_
#define _GEITMR_H_

typedef
    struct GEItmr
    {
        unsigned int    timer_id;
        int             ( *handler )( struct GEItmr FAR * );
        long            interval;   /* in millisecond */
        long            remains;    /* in millisecond */
        char FAR *           private;
    }
GEItmr_t;

int /* bool */  GEItmr_start( GEItmr_t FAR * );
int /* bool */  GEItmr_reset( int /* timer_id */  );
int /* bool */  GEItmr_stop(  int /* timer_id */  );

void            GEItmr_reset_msclock(void);     /* @WIN */
unsigned long   GEItmr_read_msclock(void);      /* @WIN */

#endif /* _GEITMR_H_ */

/* @WIN; add prototype */
void GEStmr_init(void);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\gei\gesevent.h ===
/*
 * ---------------------------------------------------------------------
 *  FILE:   GESevent.h
 *
 *  HISTORY:
 *  09/13/90    byou    created.
 * ---------------------------------------------------------------------
 */

#ifndef _GESEVENT_H_
#define _GESEVENT_H_

/*
 * ---
 *  Event ID Assignment
 * ---
 */
#define     EVIDofKILL              ( 00001 )

/*
 * ---
 *  Event Manipulation Macros
 * ---
 */

volatile    extern  unsigned long       GESeventword;
volatile    extern  unsigned long       GESeventmask;

#define     GESevent_set(eid)           ( GESeventword |=  (eid) )
#define     GESevent_clear(eid)         ( GESeventword &= ~(eid) )
#define     GESevent_isset(eid)         ( GESeventword & (eid) )

#define     GESevent_anypending()    ( GESeventword & GESeventmask )
#define     GESevent_clearall()         ( GESeventword = GESeventmask = 0L )

#define     GESevent_setdoing(eid)      ( GESeventmask |=  (eid) )
#define     GESevent_setdone(eid)       ( GESeventmask &= ~(eid) )
#define     GESevent_isdoing(eid)       ( GESeventmask & (eid) )

typedef     void    (*evhandler_t)();

evhandler_t         GESevent_sethandler( /* eventid, eventhandler */ );
void                GESevent_processing();

#endif /* _GESEVENT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\gei\gesfs.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
#ifdef  FILESYS
extern  int     copen();
extern  int     cclose();
extern  int     cread();
extern  int     cwrite();
extern  int     cioctl();
extern  int     nodev();
#endif

/* @WIN; add prototype */
int     GESfs_open(char FAR *,int,int);
int     GESfs_close(int);
int     GESfs_read(int, char FAR *, int);
int     GESfs_write(int, char FAR *, int);
int     GESfs_ioctl(int, int, int FAR *);
int     GESfs_init(void);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\gei\gesfs.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/* @WIN */
#define INTEL



// DJC added global include file
#include "psglobal.h"

// DJC DJC #include    "windowsx.h"                /* @WIN */
#include "windows.h"

#include    "winenv.h"                  /* @WIN */

char FAR * WinBuffer=0L;                   /* @WIN */
// DJC removed PSTR (FAR *lpWinRead)(void);

#ifdef  DBG
#define DEBUG(format, data)        (printf(format, data)) ;
#else
#define DEBUG(format, data)
#endif

#ifdef  INTEL
#include        <stdio.h>
#endif
#include        "geiio.h"
#include        "geierr.h"
#include        "geiioctl.h"
#include        "gesmem.h"
#include        "gescfg.h"
#include        "gesdev.h"
#include        "gesfs.h"

#ifndef TRUE
#define TRUE    ( 1 )
#define FALSE   ( 0 )
#endif

/* @WIN; add prototype */
int c_write( int min, char FAR * buf, int size, int mod);

extern          int     errno;

int     GESfs_open( filename, namelen, flags )
    char FAR *   filename;
    int     namelen;
    int     flags;
{
    int     fd;

    if (namelen <= 0) {
        GESseterror(ENOENT);
        printf("error length\n");
        return EOF;
    }

    if (!(flags &= (_O_RDONLY | _O_WRONLY))) {
        GESseterror(ENOENT);
        printf("error flags\n");
        return EOF;
    }

    flags &= (_O_RDONLY | _O_WRONLY);   /* ignore others for SUN test */

    /* erik chen, 10-10-1990 */
    filename[namelen] = '\0';

    switch(flags) {
        case _O_RDONLY:
                errno = 0;
                //fd = open(filename, 0); /* O_RDONLY + O_BINARY 0x80000 */
                DEBUG("open %s\n", filename)
                fd = 1;
                break;
        case _O_WRONLY:
                errno = 0;
                //fd = creat(filename, 0644);
                DEBUG("creat %s\n", filename)
                fd = 1;
                /* O_WRONLY | O_CREATE | O_TRUNC */
                break;
        case _O_RDWR:                           /* ignore currently */
        case _O_APPEND:
        case _O_NDELAY:
        case _O_SYNC:
        case _O_TRUNC:
        case _O_CREAT:
        case _O_EXCL:
        default:
                fd = -1;
    }
    return (fd == -1 ? EOF : fd);
}

int     GESfs_close( handle )
    int         handle;
{
    if (handle == -1) {
        GESseterror(ENOENT);
#ifdef  DEBUG
        printf("file stream is not opened\n");
#endif
        return EOF;
    }

    errno = 0;
    //close(handle);
    DEBUG("close handle %d\n", handle)
    return 0;
}


int     GESfs_read( handle, buf, nleft )
    int                 handle;
    char FAR *               buf;
    int                 nleft;
{
    int         ret_val;

    if (nleft < 0) {
        GESseterror(ENOSR);
#ifdef  DEBUG
        printf("size of file > 16 K.. ignore\n");
#endif
        return EOF;
    }

    errno = 0;
    //ret_val = fread(buf, nleft, 1, 0);
    DEBUG("read %d bytes\n", nleft)
    for (ret_val = 0; (ret_val<nleft) && (*WinBuffer); ret_val ++) {
        buf[ret_val] = *WinBuffer++;
    }

    if (ret_val)
        return( ret_val );
    else
        return EOF;
}

int     GESfs_write( handle, buf, nleft )
    int                 handle;
    char FAR *               buf;
    int                 nleft;
{
    int i;      // @WIN

#ifdef  DEBUG
        printf("enter GESfs_write\n");
#endif

    if (nleft < 0) {
        GESseterror(ENOSR);
#ifdef  DEBUG
        printf("size of file > 16 K.. ignore\n");
#endif
        return EOF;
    }

    errno = 0;
    //return write(handle, buf, nleft);
    DEBUG("write %d bytes\n", nleft)
    for (i=0; i<nleft; i++) {
        printf("%c", buf[i]);
    }

    return(nleft);
}

int     GESfs_ioctl( handle, req, arg /*, mode*/ )
    int                 handle;
    int                 req;
    int                  FAR *arg;
//  unsigned            mode;                           @WIN
{
//  int                 retval;         @WIN

    GESseterror( ENOTTY );
    return( EOF );
}

int     GESfs_init()
{
        return 0;
}

/* --------------------------------------------------------------------- */

#ifdef UNIX
#ifndef INTEL
#include        <fcntl.h>
#endif
#endif

static          int     fd = EOF;

int         nulldev()
{
    return 0;
}
#ifdef DJC
int   nodev()
{
    GESseterror( ENODEV );
    return EOF;
}
#endif


//DJC begin add new prototypes to get rid of warnings
int nd_open( int min)
{
   GESseterror(ENODEV );
   return(EOF);
}


int     nd_read(min, buf, size, mod)
int     min;
char FAR *   buf;
int     size;
int     mod;
{
    fd = EOF;
    *buf = '\0';
    return(0);
}



int     nd_write(min, buf, size, mod)
int     min;
char FAR *   buf;
int     size;
int     mod;
{

   return(size);
}


int     nd_ioctl(min, req, arg)
int     min;
int     req;
int FAR *   arg;
{

   GESseterror( ENOTTY );
   return( EOF );
}
//DJC end









int         GEPserial_diagnostic()
{
    return TRUE;
}
int         GEPparallel_diagnostic()
{
    return TRUE;
}


//DJC int     c_open(min, mod)
int     c_open(min)
int     min;
//DJC int     mod;
{
        return 0;
}
int     c_close(min)
int     min;
{
        return 0;
}

int     c_read(min, buf, size, mod)
int     min;
char FAR *   buf;
int     size;
int     mod;
{
	extern int PsStdinGetC(unsigned char *);
   unsigned char uc;
   int iRet;

   //
   // PsStdinGet()
   // returns -1 if EOF encountered... if -1 is returned
   // the character will be '\0';
   // otherwise returns 0
	
	// DJC complete rewrite to support pstodib() stuff
   iRet = PsStdinGetC(&uc);


   if (iRet == -1) {
      fd = EOF;
      *buf = '\0';
      return(0);
   }


   *buf = uc;


   // DJC test TEST add for frank so we actually read cntrl d's
   if ( (*buf == 0x04) &&
       !(dwGlobalPsToDibFlags & PSTODIBFLAGS_INTERPRET_BINARY)) {
      fd = EOF;
      return(0);
   }


   return(1);
}    	

int     c_write(min, buf, size, mod)
int     min;
char FAR *   buf;
int     size;
int     mod;
{

   extern void PsStdoutPutC(unsigned char);

   // DJC complete re-write for PStoDib stuff
   int   x;

   for (x = 0; x < size ; x++ ) {
      PsStdoutPutC(*buf++);
   }
   return(size);
}



//DJC int     c_ioctl(min, req, arg, mod)
int     c_ioctl(min, req, arg)
int     min;
int     req;
int FAR *   arg;
//DJC int     mod;
{
static  char    control_d[] = { '^', 'D' };

    switch( req )
    {
    case _I_PUSH:
    case _I_POP:
    case _I_LOOK:
    case _F_GETFL:
    case _F_SETFL:
        GESseterror( ENOTTY );
        return( EOF );

    case _ECHOEOF:
        return( c_write( 0, control_d, sizeof(control_d), _O_SYNC ) );
    case _GETIOCOOK:
    case _SETIOCOOK:
    case _GETIOPARAMS:
    case _SETIOPARAMS:
        return( 0 );

    case _FIONREAD:
        *arg = 1;
        return( 0 );
    case _FIONRESET:
        return( 0 );
    }

    if( GEIerror() != EZERO )
        GESseterror( ENOTTY );
    return( EOF );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\gei\gescfg.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GEScfg.h
 *
 *  HISTORY:
 *  09/13/90    byou    created.
 *  10/17/90    byou    removed 'devtype' from GESiocfg_t.
 *                      removed 'devtype' parameter from GESiocfg_devnumfind.
 *  10/22/90    byou    removed 'GESiocfg_nextalt()'.
 *                      removed 'devpmid' from GESiocfg_t.
 *  01/14/91    bill    update MAXSIGS
 * ---------------------------------------------------------------------
 */

#ifndef _GESCFG_H_
#define _GESCFG_H_

#include    "geiioctl.h"
#include    "gesdev.h"

/*
 * ---------------------------------------------------------------------
 *  System Capability Parameters
 * ---------------------------------------------------------------------
 */

#ifdef  UNIX
#undef          PANEL
#undef          DIPSWITCH
/* #undef          REALEEPROM */
#define         FILESYS
#else
#define         PANEL
#undef          DIPSWITCH
#undef          REALEEPROM
#undef          FILESYS
#endif  /* UNIX */

/*
 * ---------------------------------------------------------------------
 *  System Limitation Parameters
 * ---------------------------------------------------------------------
 */
#define     MAXSIGS         ( 10)       /* 5, jimmy , be consistent with GEIsig.h */

#define     MAXTIMERS       ( 15 )      /* subject to change */

#define     MAXEEPROMSIZE   ( 512 )     /* size of physical eeprom */

#define     MAXFILES        ( 20 )      /* subject to change */
#define     MAXFMODQS       ( 10 )      /* max number of fmodq per file */

#define     MAXFBUFSIZE     ( 128 )     /* typical size of f_buffer */
#define     MAXUNGETCSIZE   ( 2 )       /* typical extra size of ungetc */

#define     MAXIBUFSIZE     ( 4 * 1024 )/* typical size of io buffer */
#define     MAXOBUFSIZE     ( 512 )

#define     MAXSTATUSLEN    ( 128 )     /* typical max length of status */

/*
 * ---------------------------------------------------------------------
 * Major/Minor Device Number Assignment
 * ---------------------------------------------------------------------
 */
#define     MAJserial           ( _SERIAL )
#define       NMINserial        ( 2 )       /* two serial ports */
#define         MINserial25         ( 0 )
#define         MINserial9          ( 1 )

#ifdef  UNIX
#define     MAJparallel         ( _PARALLEL )
#define       NMINparallel      ( 0 )       /* one parallel port */
#define         MINparallel         ( -1 )
#else
#define     MAJparallel         ( _PARALLEL )
#define       NMINparallel      ( 1 )       /* one parallel port */
#define         MINparallel         ( 0 )
#endif  /* UNIX */

#ifdef  UNIX
#define     MAJatalk            ( _APPLETALK )
#define       NMINatalk         ( 0 )
#define         MINatalk            ( -1 )
#else
/* add by Falco for enable/disable AppleTalk, 04/16/91 */
#define     MAJatalk            ( _APPLETALK )
#ifdef  NO_ATK
#define       NMINatalk         ( 0 )
#define         MINatalk            ( -1 )
#else
#define       NMINatalk         ( 1 )
#define         MINatalk            ( 0 )
#endif
/* add end */
#endif
#define     MAJetalk            ( _ETHERTALK )
#define       NMINetalk         ( 0 )       /* not supported now */
#define         MINetalk            ( -1 )

#define     MAXIODEVICES        ( NMINserial+NMINparallel+NMINatalk+NMINetalk )

/* debug channel for printf (to 'undef' on SUN or others having 'printf' */
#ifdef  UNIX
#undef  DBGDEV
#else
#define     DBGDEV              MAKEdev( MAJserial, MINserial25 )
#endif  /* UNIX */

/* to write thru DBGDEV for parallel output if defined */
/* #define     DBG_DEV */

/*
 * ---------------------------------------------------------------------
 * IO Configuration Parameters
 * ---------------------------------------------------------------------
 */

typedef
    struct GESiocfg
    {
        char FAR *           devname;
        short           devnum;         /* major | minor */
    }
GESiocfg_t;

typedef
    struct GESiosyscfg
    {
        GESiocfg_t      iocfg;
        int             nextalt;
        int             sccchannel;     /* for scc stuff */
        int             state;
#                           define  BADDEV      -1
#                           define  GOODDEV     0
#                           define  OPENED      1
        int             (*diag)( void/* minordev */ );
    }
GESiosyscfg_t;

/*
 * ---------------------------------------------------------------------
 *  Interface Routines
 * ---------------------------------------------------------------------
 */
/* @WIN; add prototype */
GESiocfg_t FAR *     GESiocfg_defaultdev(void);
GESiocfg_t FAR *     GESiocfg_namefind(char FAR *, unsigned);
GESiocfg_t FAR *     GESiocfg_devnumfind(int /* devnum */ );
GESiocfg_t FAR *     GESiocfg_getiocfg(int /* iocfg_index */ );


#endif /* !_GESCFG_H_ */

/* requested by MTK */
/* @WIN; add prototype */
extern void  GEPserial_sleep(void);
extern void  GEPparallel_sleep(void);
extern void  GEPatalk_sleep(void);
extern void  GEPserial_wakeup(void);
extern void  GEPparallel_wakeup(void);
extern void  GEPatalk_wakeup(void);
extern void  GESiocfg_init(void);


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\gei\geitmr.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GEItmr.c
 *
 *  HISTORY:
 *  09/18/89    you     created (modified from AppleTalk/TIO).
 * ---------------------------------------------------------------------
 */



// DJC added global include file
#include "psglobal.h"

// DJC DJC #include    "windowsx.h"                /* @WIN */
#include "windows.h"

#include    "winenv.h"                  /* @WIN */

#include    <stdio.h>
#include    "geitmr.h"
#include    "geierr.h"

#include    "gescfg.h"
#include    "gesmem.h"


extern      unsigned    GEPtickisr_init();  /* returns millisec per tick */

#ifndef NULL
#define NULL        ( 0 )
#endif

#define TRUE        1
#define FALSE       0

/*
 * ---
 *  Timer Table
 * ---
 */
typedef
    struct tment
    {
        GEItmr_t FAR *       tmr_p;
        unsigned        state;
#define                 TMENT_LOCK      ( 00001 )
#define                 TMENT_TOUT      ( 00002 )
#define                 TMENT_BUSY      ( 00004 )
#define                 TMENT_FREE      ( 00010 )
    }
tment_t;


static  tment_t FAR *        TimerTable = (tment_t FAR *)NULL;

static  tment_t FAR *        HighestMark = (tment_t FAR *)NULL;
                        /* highest entry of those running timers */

static  unsigned long   CountMSec = 0L;

static  unsigned        MSecPerTick = 0;

/* ..................................................................... */

/*
 * ---
 *  Initialization Code
 * ---
 */
#ifdef  PCL
unsigned char PCL_TT[ MAXTIMERS * sizeof(tment_t) ];
#endif
/* ..................................................................... */

void            GEStmr_init()
{
    register tment_t FAR *   tmentp;
#ifndef PCL
    TimerTable = (tment_t FAR *)GESpalloc( MAXTIMERS * sizeof(tment_t) );
#else
    TimerTable = (tment_t FAR *) &PCL_TT[0];
#endif
    if( TimerTable == (tment_t FAR *)NULL )
    {
        GEIerrno = ENOMEM;
        return;
    }

    for( tmentp=TimerTable; tmentp<( TimerTable + MAXTIMERS ); tmentp++ )
    {
        tmentp->tmr_p = (GEItmr_t FAR *)NULL;
        tmentp->state = TMENT_FREE;
    }

    HighestMark = TimerTable - 1;

    CountMSec = 0L;

#ifdef  UNIX
    MSecPerTick = 0;
#else
    MSecPerTick = GEPtickisr_init();
#endif  /* UNIX */
}

/* ..................................................................... */

/*
 * ---
 *  Interface Routines
 * ---
 */

/* ..................................................................... */

int         GEItmr_start( tmr )
    GEItmr_t FAR *       tmr;
{
    register tment_t FAR *   tmentp;
             int        tmrid;

    for( tmentp=TimerTable, tmrid=0; tmrid<MAXTIMERS; tmentp++, tmrid++ )
    {
        if( tmentp->state == TMENT_FREE )
        {
            tmr->timer_id = tmrid;
            tmr->remains  = tmr->interval;

            tmentp->state = TMENT_LOCK;
            tmentp->tmr_p = tmr;

            if( tmentp > HighestMark )
                HighestMark = tmentp;

            return( TRUE );
        }
    }

    return( FALSE );
}

/* ..................................................................... */

int         GEItmr_reset( tmrid )
    int     tmrid;
{
    register tment_t FAR *   tmentp;
    unsigned            oldstate;

    if( tmrid < 0  ||  tmrid >= MAXTIMERS )
        return( FALSE );

    tmentp = TimerTable + tmrid;

    if( (oldstate = tmentp->state) & TMENT_FREE )
        return( FALSE );

/*  tmentp->state = TMENT_LOCK;  */
    tmentp->tmr_p->remains = tmentp->tmr_p->interval;
    tmentp->state = oldstate & ~TMENT_TOUT;

    return( TRUE );
}

/* ..................................................................... */

int         GEItmr_stop( tmrid )
    int     tmrid;
{
    register tment_t FAR *   tmentp;

    if( tmrid < 0  ||  tmrid >= MAXTIMERS )
        return( FALSE );

    tmentp = TimerTable + tmrid;

/*  tmentp->state = TMENT_FREE | TMENT_LOCK; */
    tmentp->tmr_p = (GEItmr_t FAR *)NULL;
    tmentp->state = TMENT_FREE;

    if( tmentp == HighestMark )
    {
        while( (--tmentp) >= TimerTable )
            if( !(tmentp->state & TMENT_FREE) )
                break;
        HighestMark = tmentp;
    }

    return( TRUE );
}

/* ..................................................................... */

void        GEItmr_reset_msclock()
{
    CountMSec = 0L;
}

/* ..................................................................... */
//extern  unsigned    CyclesPerMs;          /* Jun-19,91 YM */  @WIN
//extern  unsigned    GetTimerInterval();   /* Jun-19,91 YM */  @WIN

unsigned long   GEItmr_read_msclock()
{
/*  return( CountMSec )         YM Jun-19,91 */
//    return( CountMSec + 10 - GetTimerInterval()/CyclesPerMs ); @WIN
    return( CountMSec );                /* @WIN */
}

/* ..................................................................... */

/*
 * ---
 *  Tick Interrupt Driven Routines
 * ---
 */
/* ..................................................................... */

int         GEStmr_counttick()
{
    register tment_t FAR *   tmentp;
    int         anytimeout;

    CountMSec += MSecPerTick;
    anytimeout = FALSE;
    for( tmentp=TimerTable; tmentp<=HighestMark; tmentp++ )
    {
        if( !(tmentp->state & TMENT_FREE) )
        {
            if( (tmentp->tmr_p->remains -= MSecPerTick) < 0 )
            {
                anytimeout = TRUE;
                tmentp->state |= TMENT_TOUT;
            }
        }
    }

    return( anytimeout );
}

/* ..................................................................... */

void        GEStmr_timeout()
{
    static  unsigned    SemaCount = 0;  /* for critical region */
    register tment_t FAR *   tmentp;

    if( SemaCount )
        return;

    for( tmentp=TimerTable; tmentp<=HighestMark; tmentp++ )
    {
        ++SemaCount;

        if( !(tmentp->state & TMENT_TOUT ))
        {
            --SemaCount;
        }
        else    /* timed out */
        {
            tmentp->state |= TMENT_BUSY;

            --SemaCount;

            if( (*( tmentp->tmr_p->handler ))( tmentp->tmr_p ) && ++SemaCount )
            {   /* to continue this timer */

                tmentp->tmr_p->remains = tmentp->tmr_p->interval;
                tmentp->state &= (unsigned)~(TMENT_TOUT | TMENT_BUSY);
                --SemaCount;
            }
            else
            {   /* to stop this timer */

                tmentp->state = TMENT_FREE;
/*              tmentp->tmr_p = (GEItmr_t FAR *)NULL;     */

                --SemaCount;

                if( tmentp == HighestMark )
                {
                    while( (--tmentp) >= TimerTable )
                        if( (!tmentp->state & TMENT_FREE) )
                            break;
                    HighestMark = tmentp;
                }
            }
        }
    }

    return;
}

/* ..................................................................... */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\gei\gesiocfg.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GESiocfg.c
 *
 *      1. IO device name, type, number, its persistent data and alternate.
 *      2. Interface Routines to the "iocfg" subcomponent.
 *      3. Refer to GEIpm.c for initialization parameters for each device.
 *
 *  HISTORY:
 *  09/16/90    byou    created.
 *  10/18/90    byou    removed all about 'devtype' and block devices.
 *  01/07/91    billlwo correct selectstdio() bug, add GESio_closeall()
 *  01/24/91    billlwo fixed selectstdios() bug in auto polling
 *  02/06/91    billlwo delete GESpanel_activeparams()
 * ---------------------------------------------------------------------
 */


// DJC added global include file
#include "psglobal.h"

// DJC DJC #include    "windowsx.h"                /* @WIN */
#include "windows.h"

#include    "winenv.h"                  /* @WIN */

#include    <string.h>

#include    "gescfg.h"

#include    "geiio.h"
#include    "geiioctl.h"
#include    "geipm.h"
#include    "geicfg.h"
#include    "geisig.h"
#include    "geierr.h"
//#include    "gep_pan.h"       @WIN
#ifndef UNIX
#include    "gesevent.h"
#endif  /* UNIX */

#include    "gesiocfg.def"

/* add for auto polling - 01/24/91 bill */
extern GEIFILE FAR * fin;
/* Bill */
void GEIio_sleep_others(short);
void GEIio_wakeup_others(short);
int sleep_flag=0;
/* Bill */

#ifdef MTK
void        pdl_no_process();
#endif
/* ..................................................................... */

/*
 * ---
 * Interface Routines
 * ---
 */

/* ..................................................................... */

char FAR *           GEIio_channelname( sccchannel )
    int             sccchannel;
{
    register GESiosyscfg_t FAR *     iosyscfgp;

    for( iosyscfgp=GESiosyscfgs; iosyscfgp<GESiosyscfgs_end; iosyscfgp++ )
        if( iosyscfgp->sccchannel == sccchannel )
            return( iosyscfgp->state != BADDEV?
                    iosyscfgp->iocfg.devname : (char FAR *)NULL );

    return( (char FAR *)NULL );
}

/* ..................................................................... */

char FAR *           GEIio_channelnameforall( iodevidx )
    int             iodevidx;
{
    register GESiosyscfg_t FAR *     iosyscfgp;

    if( iodevidx >= 0 )
        for( iosyscfgp=GESiosyscfgs; iosyscfgp<GESiosyscfgs_end; iosyscfgp++ )
            if( iosyscfgp->state != BADDEV )
                if( --iodevidx < 0 )
                    return( iosyscfgp->iocfg.devname );

    return( (char FAR *)NULL );
}

/* ..................................................................... */

GESiocfg_t FAR *     GESiocfg_namefind( devname, namelen )
    char FAR *           devname;
    unsigned        namelen;
{
    register GESiosyscfg_t FAR *     iosyscfgp;

    for( iosyscfgp=GESiosyscfgs; iosyscfgp<GESiosyscfgs_end; iosyscfgp++ )
        if(  namelen == (unsigned)lstrlen( iosyscfgp->iocfg.devname )  && /*@WIN*/
             lmemcmp( devname, iosyscfgp->iocfg.devname, namelen ) == 0  )/*@WIN*/
            return( iosyscfgp->state != BADDEV?
                    &( iosyscfgp->iocfg ) : (GESiocfg_t FAR *)NULL );

    return( (GESiocfg_t FAR *)NULL );
}

/* ..................................................................... */

GESiocfg_t FAR *     GESiocfg_devnumfind( devnum )
    int             devnum;
{
    register GESiosyscfg_t FAR *     iosyscfgp;

    for( iosyscfgp=GESiosyscfgs; iosyscfgp<GESiosyscfgs_end; iosyscfgp++ )
        if(  iosyscfgp->iocfg.devnum == devnum  )
            return( iosyscfgp->state != BADDEV?
                    &( iosyscfgp->iocfg ) : (GESiocfg_t FAR *)NULL );

    return( (GESiocfg_t FAR *)NULL );
}

/* ..................................................................... */

GESiocfg_t FAR *     GESiocfg_getiocfg( iocfgidx )
    int             iocfgidx;
{
    register GESiosyscfg_t FAR *     iosyscfgp;

    if( iocfgidx >= 0 )
        for( iosyscfgp=GESiosyscfgs; iosyscfgp<GESiosyscfgs_end; iosyscfgp++ )
            if( iosyscfgp->state != BADDEV )
                if( --iocfgidx < 0 )
                    return( &( iosyscfgp->iocfg ) );

    return( (GESiocfg_t FAR *)NULL );
}

/* ..................................................................... */

/*
 * ---
 *  active device selection
 * ---
 */

/* ..................................................................... */

GESiosyscfg_t FAR *      defaultdev = (GESiosyscfg_t FAR *)NULL;
GESiosyscfg_t FAR *      activedev  = (GESiosyscfg_t FAR *)NULL;

struct dn_para_str dn_para[MAXIODEVICES];
int GESpanel_defaultdev()
{
   return(MAKEdev(MAJserial, MINserial25));
}

void GESpanel_activeparams(dn,pp)
int  dn;
GEIioparams_t    FAR *pp;
{
int  i;
        i=0;
        while (TRUE) {
                if (dn==dn_para[i].dn) {
                        *pp=dn_para[i].para;
                        break;
                }
                else ++i;
        }
}
/* ..................................................................... */

GESiocfg_t FAR *   GESiocfg_defaultdev()
{
    if( defaultdev == (GESiosyscfg_t FAR *)NULL )
        GEIio_selectstdios();

    return( &( activedev->iocfg ) );
}

/* ..................................................................... */

/* SHOULD BE REMOVED SOME DAY !!! */

int         GEIio_selectstdios()
{
    register GESiosyscfg_t FAR * adev;
    GESiosyscfg_t FAR *          newdev;
    int                     defaultdevnum;
    GEIioparams_t           ioparams;

    int                     bytesavail;


/* Bill */
    if (sleep_flag==1) {
       GEIio_wakeup_others(activedev->iocfg.devnum);
       sleep_flag=0;
       }
/* Bill */
#ifndef UNIX
    /* process all pending events if any */
    if( GESevent_anypending() )
        GESevent_processing();
#endif  /* UNIX */

    /* locate the new default dev */
#ifdef  UNIX
    defaultdevnum = MAKEdev(MAJserial, MINserial25);
#else
#    ifdef PANEL
        defaultdevnum = GESpanel_defaultdev();
#ifdef MTK
        pdl_no_process();
#endif
        GEPpanel_change();    /* any parameters changed ? */
#    else /* i.e. DIPSWITCH */
        defaultdevnum = GESdipsw_defaultdev();
#    endif  /* PANEL */
#endif  /* UNIX */
    for( adev=GESiosyscfgs; adev<GESiosyscfgs_end; adev++ )
        if( adev->iocfg.devnum == defaultdevnum )
            break;
    newdev = adev;

    if( newdev != defaultdev )  /* default device changed? */
    {
        int     isDeviceChainChanged = TRUE;

        /* check if device chain changed */
        if( defaultdev != (GESiosyscfg_t FAR *)NULL )
        {
            adev = defaultdev;
            do
            {
                if( adev == newdev )
                {
                    isDeviceChainChanged = FALSE;
                    break;
                }
                adev = &GESiosyscfgs[ adev->nextalt ];

            }while( adev != defaultdev );
        }

        if( isDeviceChainChanged )
        {
            /* close the prior default driver and its chained alternates */
            if( (adev = defaultdev) != (GESiosyscfg_t FAR *)NULL )
            {
                do
                {
                    GEIclearerr();
                    if( adev->state == OPENED )
                    {
                        CDEV_CLOSE( adev->iocfg.devnum );
                        adev->state = GOODDEV;
                    }
                    adev = &GESiosyscfgs[ adev->nextalt ];

                }while( adev != defaultdev );
                GEIclearerr();
                fin= (GEIFILE FAR *)NULL;  /* 01/24/91 bill */
                GESio_closeall(); /* clear FileTable entries - Bill */
            }

            /* open the newly selected driver and its chained alternates */
            adev = newdev;
            do
            {
                if( adev->state == GOODDEV )
                {
                    GEIclearerr();
                    adev->state = OPENED;
                    CDEV_OPEN( adev->iocfg.devnum );
                }
                adev = &GESiosyscfgs[ adev->nextalt ];

            }while( adev != newdev );
            GEIclearerr();

            /* make the newly selected device become the default */
            defaultdev = newdev;
            activedev = newdev; /* initial active device  -- 01/24/91 bill */
        }
    }

    /* reload io params for all chained and opened devices */
    adev = defaultdev;
    do
    {
        if( adev->state == OPENED )
        {
            GEIclearerr();

/* 02/06/91 bill fixed bug about printername
 * #ifdef PANEL
 *             GESpanel_activeparams( adev->iocfg.devnum, &ioparams );
 * #else
 *             GEIpm_ioparams_read( adev->iocfg.devname, &ioparams, TRUE );
 * #endif
 */
            GEIpm_ioparams_read( adev->iocfg.devname, &ioparams, TRUE );

            CDEV_IOCTL(adev->iocfg.devnum, _SETIOPARAMS, (int FAR *)&ioparams); /*@WIN*/
        }
        adev = &GESiosyscfgs[ adev->nextalt ];

    }while( adev != defaultdev );
    GEIclearerr();

    /* see if any byte available on some candidate device */
    /* 01/24/91 billlwo for bug in auto polling*/
    /* last active channel take higher precedence */
    adev = activedev;  /* 02/28/91 temporary sol'n */
    if ((fin !=(GEIFILE FAR *)NULL) && (fin->f_fbuf->f_cnt > 0 )) {
       return( GEIio_forceopenstdios( _FORCESTDALL ) );
    } else {
    } /* endif */

    do
    {
        if( adev->state == OPENED )
        {

            if( CDEV_IOCTL( adev->iocfg.devnum, _FIONREAD, &bytesavail ) == EOF )
                bytesavail = 0;

            if( bytesavail > 0 )
            {
                activedev = adev;       /* set active device */
                /* Bill */
                GEIio_sleep_others(adev->iocfg.devnum);
                sleep_flag=1;
                /* Bill */
                return( GEIio_forceopenstdios( _FORCESTDALL ) );
            }
        }
        adev = &GESiosyscfgs[ adev->nextalt ];

    }while( adev != activedev ); /* 01/28/91 bill temporary sol'n*/

/*  activedev = defaultdev;     (* set default device as active device */
    return( FALSE );

}   /* GEIio_selectstdios */

/* ..................................................................... */

/*
 * ---
 * Initialization
 * ---
 */

/* ..................................................................... */

void        GESiocfg_init()
{
    register GESiosyscfg_t FAR *     iosyscfgp;

    /* diagnose on all devices */
    for( iosyscfgp=GESiosyscfgs; iosyscfgp<GESiosyscfgs_end; iosyscfgp++ )
    {
        if(  ( *(iosyscfgp->diag) )( /*MINdev( iosyscfgp->iocfg.devnum )*/ )  )
            iosyscfgp->state = GOODDEV;
        else
            iosyscfgp->state = BADDEV;
    }

    return;
}

void GEIio_sleep_others(devno)
short devno;
{
#ifdef  _AM29K
   if (devno != MAKEdev( MAJserial, MINserial25 ))
      GEPserial_sleep(MINserial25);
   if (devno != MAKEdev( MAJparallel, MINparallel ))
      GEPparallel_sleep(MINparallel);
   if (devno != MAKEdev( MAJatalk, MINatalk ))
      GEPatalk_sleep(MINatalk);
/* to be added someday */
/* GEPserial_sleep(MINserial9); */
#endif

}
void GEIio_wakeup_others(devno)
short devno;
{
#ifdef  _AM29K
   if (devno != MAKEdev( MAJserial, MINserial25 ))
      GEPserial_wakeup(MINserial25);
   if (devno != MAKEdev( MAJparallel, MINparallel ))
      GEPparallel_wakeup(MINparallel);
   if (devno != MAKEdev( MAJatalk, MINatalk ))
      GEPatalk_wakeup(MINatalk);
/* to be added someday */
/* GEPserial_wakeup(MINserial9); */
#endif
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\gei\gesmem.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GESmem.h
 *
 *  HISTORY:
 *  09/13/90    byou    created.
 * ---------------------------------------------------------------------
 */

#ifndef _GESMEM_H_
#define _GESMEM_H_

unsigned GESmemavail(void);  /* return # of bytes in the biggest free blk */

char FAR * GESpalloc(unsigned); /* permanent allocation */
char FAR * GESmalloc(unsigned);
void       GESfree(char FAR * /* address_of_space_to_be_freed */ );

#endif /* !_GESMEM_H_ */

/* @WIN; add prototype */
void GESmem_init(char FAR *, unsigned);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\gei\gesmem.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GESmem.c
 *
 *  COMPILATION SWITCHES:
 *
 *  HISTORY:
 *  09/19/90    byou    extracted from ANSI C.
 * ---------------------------------------------------------------------
 */


// DJC added global include file
#include "psglobal.h"

// DJC DJC #include    "windowsx.h"                /* @WIN */
#include "windows.h"

#include    "winenv.h"                  /* @WIN */

#include    "gesmem.h"

#ifndef NULL
#define NULL        ( 0 )
#endif

/*
 * ---
 *  Memory Block Header And Associated Static Vars
 * ---
 */
typedef
    union mblk
    {
        struct
        {
            union mblk FAR *     next;
            unsigned        size;   /* # of mblk_t */
        }       m;
        long    align;          /* force alignment on long boundary */
    }
mblk_t;

static  char FAR *       PoolBase = (char FAR *)NULL;
static  unsigned    PoolSize = 0;
static  mblk_t FAR *     HeadOfFree = (mblk_t FAR *)NULL;

#define     MBLK_RDUP(n)    (  ((n) + sizeof(mblk_t) - 1) / sizeof(mblk_t)  )
#define     MBLK_RDDN(n)    (  (n) / sizeof(mblk_t)  )
#define     NUMOFMBLK(n)    (  (n) / sizeof(mblk_t)  )

/* ..................................................................... */

/*
 * ---
 *  Initialization Code
 * ---
 */

/* ..................................................................... */
#define         MAXGESMEMSIZE   ( (unsigned)52 * 1024 )
unsigned        ext_mem=0;

void    GESmem_init( base, size )
    char FAR *       base;
    unsigned    size;
{
/*  char*       end = base + size;  Jimmy */

    if( size <= sizeof(mblk_t) )
        return;
    if (size > MAXGESMEMSIZE)
        ext_mem = size - MAXGESMEMSIZE;
    PoolBase = (char FAR *)( (mblk_t FAR *)base );
    PoolSize = NUMOFMBLK( size ) * sizeof(mblk_t);

    HeadOfFree = (mblk_t FAR *)PoolBase;

    HeadOfFree->m.next = (mblk_t FAR *)NULL;
    HeadOfFree->m.size = NUMOFMBLK( PoolSize );
}

/* ..................................................................... */

/*
 * ---
 *  Interface Routines
 * ---
 */

/* ..................................................................... */

unsigned        GESmemavail()
{
    register mblk_t      FAR *curr;
    unsigned            nbiggestmblk = 0;

    for( curr=HeadOfFree; curr!=(mblk_t FAR *)NULL; curr=curr->m.next )
        if( curr->m.size > nbiggestmblk )
            nbiggestmblk = curr->m.size;

    return(  nbiggestmblk==0?  0  :  (nbiggestmblk-1) * sizeof(mblk_t)  );
}

/* ..................................................................... */

char FAR *           GESpalloc( nbytes )
    unsigned    nbytes;
{
    unsigned    nmblks;

    if( PoolBase == (char FAR *)NULL  ||  HeadOfFree != (mblk_t FAR *)PoolBase )
        return( (char FAR *)NULL );

    nmblks = MBLK_RDUP( nbytes ) + 1;     /* yang */
    nbytes = nmblks * sizeof(mblk_t);

    if( nbytes > PoolSize )
        return( (char FAR *)NULL );

    PoolBase += nbytes;
    PoolSize -= nbytes;

    nmblks = HeadOfFree->m.size - nmblks;       /* # of free blks */
    HeadOfFree = (mblk_t FAR *)PoolBase;

    HeadOfFree->m.next = (mblk_t FAR *)NULL;
    HeadOfFree->m.size = nmblks;

    return( PoolBase - nbytes );
}

/* ..................................................................... */

char FAR *           GESmalloc( nbytes )
    unsigned    nbytes;
{
    register mblk_t      FAR *prev,  FAR *curr;
    unsigned            nmblks;

    nmblks = MBLK_RDUP( nbytes ) + 1;   /* extra one for mblk_t */

    for(  prev = (mblk_t FAR *)NULL, curr = HeadOfFree;
          curr != (mblk_t FAR *)NULL;
          prev = curr, curr = curr->m.next  )
    {
        if( curr->m.size == nmblks )
        {
            if( prev == (mblk_t FAR *)NULL )
                HeadOfFree = curr->m.next;
            else
                prev->m.next = curr->m.next;

            curr->m.next = (mblk_t FAR *)NULL;

            return( (char FAR *)( curr + 1 ) );
        }
        else if( curr->m.size > nmblks )
        {
            curr->m.size -= nmblks;

            curr += curr->m.size;
            curr->m.next = (mblk_t FAR *)NULL;
            curr->m.size = nmblks;
            return( (char FAR *)( curr + 1 ) );
        }
    }
    return( (char FAR *)NULL );
}

/* ..................................................................... */

void            GESfree( addr )
    char FAR *       addr;
{
    register mblk_t      FAR *tofree,  FAR *prev,  FAR *curr;
    unsigned            nmblks;

    tofree = (mblk_t FAR *)addr -  1;
    nmblks = tofree->m.size;

    /* have 'curr' stopped right after 'tofree', and 'prev' in front */
    for(  prev = (mblk_t FAR *)NULL, curr = HeadOfFree;
          curr != (mblk_t FAR *)NULL  &&  curr < tofree;
          prev = curr, curr = curr->m.next  )
    {};

    /* join to 'prev' if adjacent */
    if( prev != (mblk_t FAR *)NULL )
    {
        if( prev + prev->m.size == tofree )
        {
            prev->m.size += nmblks;
            tofree = prev;
        }
        else
        {
            tofree->m.next = prev->m.next;
            prev->m.next   = tofree;
        }
    }
    else
    {
        HeadOfFree = tofree;
    }

    /* join to 'curr' if adjacent */
    if( curr != (mblk_t FAR *)NULL )
    {
        if( tofree + nmblks == curr )
        {
            tofree->m.size += curr->m.size;
            tofree->m.next =  curr->m.next;
        }
        else
        {
            tofree->m.next = curr;
        }
    }

    return;
}

/* ..................................................................... */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\gei\start.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/* %W%, AMD */
/*************************************************************************
** start.h      STARTUP AND FUNDAMENTAL CONTROLS                v1.0d1  **
**                                                                      **
** Copyright 1989, Advanced Micro Devices, Inc.                         **
** Written by Gibbons and Associates, Inc.                              **
**                                                                      **
**                                                                      **
** This module contains the delarations of the startup routines and     **
** fundamental control routines.                                        **
**                                                                      **
** History: (after version 1.0)                                         **
**                                                                      **
** v1.0d1 JG    add SetTimerNext, add returns to EnbInt, DsbInt and     **
** v1.0d1 JG            IntLevel                                        **
**                                                                      **
*************************************************************************/

#ifndef START_H
#define START_H 1

/*
** LEDs - these don't really merit a separate file, so they are just
** included here.
*/

#define LED_ROM         (1 << 0)        /* ROM Instruction and Checksum */
#define LED_RAM         (1 << 1)        /* RAM Address and Data         */
#define LED_PANEL       (1 << 2)        /* Front panel interface        */
#define LED_EEPROM      (1 << 3)        /* EEPROM interface             */
#define LED_SERIAL      (1 << 4)        /* Serial port                  */
#define LED_COPROC      (1 << 5)        /* Coprocessor interface        */
#define LED_LPEC        (1 << 6)        /* Laser printer engine intf    */
#define LED_PARALLEL    (1 << 7)        /* Parallel port                */

#define LEDS_ON         0x00            /* all LEDs on                  */
#define LEDS_OFF        0xff            /* all LEDs off                 */

/*
** Port external declarations (see also ???port.h)
*/

extern volatile unsigned        LEDs;           /* may use RAM loc      */

/*
** Static data exported to C functions
*/

extern unsigned         CyclesPerSec;   /* CPU cycles per second        */
extern unsigned         CyclesPerMs;    /* CPU cycles per millisecond   */
extern unsigned         LEDCrnt;        /* LEDs image                   */
extern unsigned         LEDCmltv;       /* LEDs cumulative image        */

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

extern void     SerDelay
/*
** This routine provides the delay required by the SCC between register
** accesses.
*/
(
void
);

/*
** The macro below is defined for use of the SerDelay routine above.
** In hardware environments where it the delay is not required, the
** macro can be defined to be a blank.
*/

#define SER_DELAY       SerDelay ();

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

extern unsigned EnbInt
/*
** This routine enables interrupts by clearing DI.
**
** The prior cps value is returned.
*/
(
void
);

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

extern unsigned DsbInt
/*
** This routine disables interrupts by setting DI.
**
** The prior cps value is returned.
*/
(
void
);


#endif                                  /* ifdef START_H                */

/* end of start.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\gei\main.c ===
/*
 *****************************************************************************
 *
 *      Copyright (c) 1989, 1990 Microsoft Corporation
 *
 ******************************************************************************
 *
 *       main Source Code File
 *
 ******************************************************************************
 *
 *      Filename........:       main.c
 *      Description.....:       This module sets up the default communication
 *                              configuration initializes the Interpreter and
 *                              launches it.
 *      Author..........:
 *      Created.........:
 *      Routines........:
 *              configErr()     - Displays configuration errors.
 *
 ******************************************************************************
 *      History.........: <   date  version  author >
 *                              < description >
 *
 *      03-12-90        V1.00
 *              Cleaned up for source code control & added UNIX flag for SUN
 *              compatability.
 *      04-18-90        V2.00
 *              Created from pdl.c of nike2 startup for SUN build.
 *      06-19-90        V2.10
 *              Cleaned up and changed stdio.h to wrap_io.h.
 *      06-23-90        V2.10
 *              Changed wrap_config.h to ic_config.h and removed wrap_io.h.
 *              Increased memory from 2 Megs to 3 megs.
 *
 ******************************************************************************
 */



// DJC added global include file
#include "psglobal.h"

// DJC DJC #include    "windowsx.h"                /* @WIN */
#include "windows.h"

#include    "winenv.h"                  /* @WIN */
#define INTEL

#ifdef  INTEL
#include <stdio.h>
#endif
#include "ic_cfg.h"
#include "geiio.h"
#include "geierr.h"
#include "geitmr.h"
#include "geisig.h"
#include "gesmem.h"
#include "gescfg.h"

#ifndef TRUE
#define TRUE    ( 1 )
#define FALSE   ( 0 )
#endif

/* @WINl add prototype */
static void configErr(int, char FAR *);
int ps_main(struct ps_config FAR *);

#define ONE_MEG         1024 * 1024
#define PDL_MEM_SIZE    5 * ONE_MEG

#ifdef  INTEL
#define RAM_START       0x10100000L     /* INTEL */
#define RAMSize         0x00a00000L     /* INTEL */
#define FDPTR           0x10600000L     /* Font data area */
#endif
//#define MAXGESBUFSIZE   (60 * 1024)           @WIN
#define MAXGESBUFSIZE   (4 * 1024)
char GESbuffer[ (unsigned)MAXGESBUFSIZE ];

struct ps_config    pscf ;

int TrueImageMain();

/*
 *  return 0: OK
 *      else: fail
 */
int TrueImageMain()
{
        int err=0;      /* @WIN; init to zero */
//      struct ps_config    pscf ;              // move out as global; @WIN
#ifdef  INTEL
//      char    FAR *fdptr;     @WIN
//      char    c_in;           @WIN
//      int     i, j, size;     @WIN
#endif

        GESmem_init( (char FAR *)GESbuffer, (unsigned)MAXGESBUFSIZE );
        GEStmr_init();
#ifndef INTEL
        GESpm_init();
#endif
        GESsig_init();
        GESiocfg_init();
        GEIio_init();

        GEIio_forceopenstdios( _FORCESTDALL );

        if( GEIerror() != EZERO )
        {
            printf( "GEI init failed, code = %d\n", GEIerror() );
            //exit( -1 );
            return(-1);      // return fail; @WIN */
        }

#ifdef  INTEL
/* YM
        fdptr = (char FAR *)FDPTR;
        printf("Please send your font data through RS232.......\n");
        printf("This font data will download to %lx\n", fdptr);
        printf("Please enter your font data size in decimal\n");
        c_in = getchar();
        size = 0;
        for(i=0; (c_in != 0x0D) || (c_in != 0x0A); i++) {
            if(c_in < 0x30 || c_in > 0x39) {
                printf("\007Error...\n");
                printf("Please enter decimal value\n");
                c_in = getchar();
            } else {
                size = size * 10 + (c_in - 0x30);
            }
        }
        printf("Your font data size is %d\n", size);
        printf("Is this size correct ? Y/N (Y)");
        if c_in = getchar() != "n"


        getchar();
*/
        pscf.PsMemoryPtr = (unsigned int FAR *)RAM_START;
        pscf.PsMemorySize = RAMSize;    /* INTEL */
#else
        if (!(pscf.PsMemoryPtr = (unsigned int FAR *) malloc(PDL_MEM_SIZE))) {
                printf("*** Error: allocating %d bytes ***\n",PDL_MEM_SIZE) ;
                //exit(1) ;
                return(-1);      // return fail; @WIN */
        }
        pscf.PsMemorySize = PDL_MEM_SIZE ;
#endif  /* INTEL */
#ifdef DDEBUG
        dprintf("Postscript memory @ %lx, with %lx bytes...\n",
                pscf.PsMemoryPtr, pscf.PsMemorySize) ;
#endif /* DDEBUG */
        if(err = ps_main(&pscf)) {
                switch (err) {
                case PS_CONFIG_MALLOC:
                        configErr(err,"memory size allocation") ;
                        break ;
                case PS_CONFIG_MPLANES:
                        configErr(err,"memory planes") ;
                        break ;
                case PS_CONFIG_MWPP:
                        configErr(err,"memory size per plane") ;
                        break ;
                case PS_CONFIG_DPI:
                        configErr(err,"drawing resolution") ;
                        break ;
                case PS_FATAL_UNKNOWN:
                        configErr(err,"fatal error") ;
                        break ;
                default:
                        configErr(err,"unknown error") ;
                        break ;
                }
        }
        return(err);      // return error code; @WIN */
}

static void configErr(num,msg)
int num ;
char FAR *msg ;
{
        printf("*** Error(%d): ps_main() - %s ***\n",num,msg) ;
        //exit(1) ;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\graph\fillgb.c ===
/**********************************************************************
 *
 *      Name:       fillgb.c
 *
 *      Purpose:    This file contains routines for performing bitmap related
 *                  operations.
 *
 *      Developer:  S.C.Chen
 *
 *      History:
 *      Version     Date        Comments
 *      3.0         10/18/88    source file reorganization for saving trapezoids
 *                              in command buffer instead of scanlines, i.e.
 *                              defer scan conversion at lower level graphics
 *                              split scanconv.c => savetpzd.c & fillgb.c
 *                              savetpzd -- save trapezoid in command buffer
 *                              fillgb   -- perform scan conversion, scanline
 *                                          bitblt function.
 *                              primitives:
 *                              gp_scanconv() -- perform scan conversion.
 *                              gp_scanline16() -- 16 bit scanline filling
 *                              gp_scanline32() -- 32 bit scanline filling
 *                              gp_bitblt16() -- 16 bits bitblt moving
 *                              gp_bitblt32() -- 32 bits bitblt moving
 *                              gp_charblt16() -- 16 bits CC --> FB
 *                              gp_charblt32() -- 32 bits CC --> FB
 *                              gp_charblt16_cc() -- 16 bits CC --> CC
 *                              gp_charblt16_clip() -- 16 bits CC --> CMB
 *                              gp_charblt32_clip() -- 32 bits CC --> CMB
 *
 *                  11/03/88    LFX2I => LFX2I_T, SFX2I => SFX2I_T
 *                  11/24/88    add new parameter (seed index) to
 *                              fill_seed_patt()
 *                  1/12/89     modify gp_scanconv():
 *                              end points of trapezoid in 1/8 pixel(instead
 *                              of in pixel), should process start & end line
 *                              segemnt that less than 1 scanline
 *                  01/16/89    @IMAGE: fill_a_band(): add new dest type
 *                              F_TO_MASK to generate clipping mask (CMB)
 *                              for clipped image/imagemask
 *                  01/24/89    gp_scanconv(): truncate y-coord for fill a
 *                              degernated trapezoid
 *                  01/31/89    gp_scanconv(): fix a bug of count of scanline
 *                              loop
 *
 *      4.0         02-03-1989  add primitive routines:
 *                              gp_scanconv_i:
 *                                 filling image seed pattern; it applies
 *                                 interior filling.
 *                              gp_patblt:
 *                                 move image seed pattern to frame buffer
 *
 *                              gp_patblt_m:
 *                                 move image seed pattern to frame buffer with
 *                                 clipping mask
 *                              gp_patblt_c:
 *                                 move image seed pattern to character cache
 *
 *                  03/23/89    gp_scanconv(): round start_y and end_y of the
 *                              trapezoid instead of truncation for quality
 *                              enhancement @RND
 *                  04/19/89    fill_a_band(): use fixed bounding box for
 *                              cahce
 *                  05/18/89    gp_scanconv():should not modify bounding box
 *                              for calling lower level primitives with
 *                              F_TO_CACHE
 *                  05/18/89    fill_a_band(): fix the bug aroused on 4/19/89;
 *                              keep bounding box info in local variable instead
 *                              of in global variable
 *                  05/23/89    gp_scanline32() check negative ys_line
 *                  03/07/91    gp_scanconv_i(): add end of scanline mark
#ifdef WIN
 *  Ada             03/15/91    gp_scanline32_pfOR() to fill pattern OR to page
 *  Ada             03/20/91    gp_scanline32_pfREP() to fill pattern to page
 *  Ada             03/21/91    elimulate WHITE in REP case to call normal fill
#endif
 *                  11/20/91    upgrade for higher resolution @RESO_UPGR
 *                  1/20/92     add checking of negative scan points due to
 *                              arith error in gp_scanconv()
 * SCCHEN           10/07/92    Bitblt functions were moved to fillgbx.c:
 *                              gp_bitblt16 gp_bitblt32
 *                              gp_pixels16 gp_pixels32
 *                              gp_cacheblt16
 *                              gp_bitblt16_32
 *                              gp_charblt16 gp_charblt32 gp_charblt16_cc
 *                              gp_charblt16_clip gp_charblt32_clip
 *                              gp_patblt gp_patblt_m gp_patblt_c
 **********************************************************************/




// DJC added global include
#include "psglobal.h"


#include        <math.h>
#include        <stdio.h>
#include        "global.ext"
#include        "graphics.h"
#include        "graphics.ext"
#include        "font.h"
#include        "font.ext"
#include        "fillproc.h"
#include        "fillproc.ext"

/* @WIN; add prototype */
void      expand_halftone(void);
lfix_t FixMul(lfix_t, lfix_t);
lfix_t FixDiv(lfix_t, lfix_t);


// DJC not necessary
// typedef unsigned long       DWORD;      /* for huge memory */

struct edgese {         /* data structure of a edge */
        fix     s, e;           /*   left and right edge of a scanline */
};
/* scanline structure */
//static SCANLINE near gpscan_table[MAXSCANLINES];      @WIN
SCANLINE FAR  gpscan_table[MAXSCANLINES];
#define scanline_table gpscan_table

/* -------------------------------------------------
 * Local Variables used by gp_scanconv, fill_a_band
 * -------------------------------------------------
 */
//static SCANLINE near *scanline;       @WIN
static SCANLINE FAR *scanline;
static ufix tpzd_destination;                   /* fill destination */
static struct tpzd_info FAR *tpzd_info;             /* bounding box information */

/*
 *      left and right edges for scan conversion
 *
 *              +-----------+             <---  scan_y0
 *             /             \
 *            /                \
 *           /                   \
 *          +---------------------+       <---  scan_y1
 *      scan_lxc: x_change of left edge;
 *      scan_lxint: x_coord. of intersection point of left edge;
 *      scan_rxc: x_change of right edge;
 *      scan_rxint: x_coord. of intersection point of right edge;
 */
static sfix_t   scan_y0,        /* start y_coord */
                scan_y1;        /* end y_coord */
static lfix_t   scan_lxc,       /* x_change of left edge */
                scan_rxc,       /*      ...    right edge */
                scan_lxint,     /* intersect point of left edge */
                scan_rxint;     /*      ...           right edge */


/* ********** static function declartion ********** */

#ifdef LINT_ARGS
/* for type checks of the parameters in function declarations */
static void fill_a_band (fix, fix);

#else
/* for no type checks of the parameters in function declarations */
static void fill_a_band ();
#endif

// Short & long word swapping @WINFLOW
#ifdef  bSwap
#define WORDSWAP(lw) \
        (lw =  (lw << 16) | (lw >> 16))
#define SWORDSWAP(sw) \
        (sw =  (sw << 8) | (sw >> 8))
#define LWORDSWAP(lw) \
        (lw =  (lw << 24) | (lw >> 24) | \
                 ((lw >> 8) & 0x0000ff00) | ((lw << 8) & 0x00ff0000))
#define S2WORDSWAP(lw) \
        (lw = ((lw >> 8) & 0x00ff00ff) | ((lw << 8) & 0xff00ff00))
#define SWAPWORD(lw) (lw = (lw << 16) | (lw >> 16))
#else
#define WORDSWAP(lw)    (lw)
#define SWORDSWAP(sw)   (sw)
#define LWORDSWAP(lw)   (lw)
#define S2WORDSWAP(lw)  (lw)
#define SWAPWORD(lw) (lw)
#endif

/***********************************************************************
 * Performs scan conversion on a trapezoid. The trapezoid has been converted
 * to a left and right edge. This routine gets a pair of endpoints, and updates for each
 * left and right edge for each scan line. Scan lines are put in the scanline
 * table. It will call fill_a_band to render the scan lines when the scanline
 * table is full.
 *
 * TITLE:       gp_scanconv
 *
 * CALL:        gp_scanconv(dest, info, tpzd)
 *
 * PARAMETERS:
 *              1. dest: fill_destination
 *                      F_TO_CACHE -- fill to cache memory
 *                      F_TO_PAGE  -- fill to page
 *                      F_TO_CLIP  -- fill to clip mask
 *                      F_TO_IMAGE -- fill for image(build seed pattern)
 *              2. info: bounding box information
 *              3. tpzd: a trapezoid
 *
 * INTERFACE:   Save_tpzd
 *
 * CALLS:       Fill_a_band
 *
 * RETURN:      None
 **********************************************************************/
void far gp_scanconv(dest, info, tpzd)
ufix dest;
struct tpzd_info FAR *info;
struct tpzd FAR *tpzd;
{
        sfix_t dy;

//      fix scan_y;     @WIN
        fix     bb_y, start_y, lines;
        fix32   bmap_size;
        ufix    lines_per_band;
        fix     xs, xe;
        fix     scans;
        bool    first_band, last_band;
#ifdef FORMAT_13_3      /* @RESO_UPGR */
#elif FORMAT_16_16
        long    dest1[2];
        long    temp;
#elif FORMAT_28_4
        long    dest1[2];
        long    temp;
#endif

        tpzd_destination = dest;
        tpzd_info = info;

        /* build left and right edges for scan conversion */
        scan_y0 = tpzd->topy;
        scan_y1 = tpzd->btmy;

        dy = tpzd->btmy - tpzd->topy;
        if (dy == 0) {  /* degernated trapezoid, just a horiz. line */
                scan_lxc = scan_rxc = 0;
        } else {
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                scan_lxc = (((fix32)(tpzd->btmxl - tpzd->topxl)) << L_SHIFT) / dy;
                scan_rxc = (((fix32)(tpzd->btmxr - tpzd->topxr)) << L_SHIFT) / dy;
#elif  FORMAT_16_16
                /* "scan_lxc" needs to be in "LFX" format.
                */
                LongFixsMul((tpzd->btmxl - tpzd->topxl), (1L << L_SHIFT), dest1);
                scan_lxc = LongFixsDiv(dy, dest1);
                LongFixsMul((tpzd->btmxr - tpzd->topxr), (1L << L_SHIFT), dest1);
                scan_rxc = LongFixsDiv(dy, dest1);
#elif  FORMAT_28_4
                /* "scan_lxc" needs to be in "LFX" format.
                */
                LongFixsMul((tpzd->btmxl - tpzd->topxl), (1L << L_SHIFT), dest1);
                scan_lxc = LongFixsDiv(dy, dest1);
                LongFixsMul((tpzd->btmxr - tpzd->topxr), (1L << L_SHIFT), dest1);
                scan_rxc = LongFixsDiv(dy, dest1);
#endif
        }

        scan_lxint = SFX2LFX(tpzd->topxl);
        scan_rxint = SFX2LFX(tpzd->topxr);

#ifdef DBG1
        printf("gp_scanconv: destination=%d,", tpzd_destination);
        printf(" box_x=%d, box_y=%d, box_w=%d, box_h=%d\n", tpzd_info->BOX_X,
                 tpzd_info->BOX_Y, tpzd_info->box_w, tpzd_info->box_h);
        printf("tpzd: scan_y0=%f, scan_y1=%f\n", SFX2F(scan_y0),
               SFX2F(scan_y1));
        printf("      left edge  -- xc=%f, xint=%f\n", LFX2F(scan_lxc),
               LFX2F(scan_lxint));
        printf("      right edge -- xc=%f, xint=%f\n", LFX2F(scan_rxc),
               LFX2F(scan_rxint));
#endif

        /* initilize lines_per_band */
        if (tpzd_destination == F_TO_PAGE) {
                /* a graph to page may exceed a band buffer */
                gwb_space (&bmap_size);
                lines_per_band = (fix)(bmap_size * 8 / tpzd_info->box_w);

                /* lines limit due to scanline table */
                if (lines_per_band > ((MAXSCANLINES - 1) / 3))
                        lines_per_band = (MAXSCANLINES - 1) / 3;
        } else {
                lines_per_band = (MAXSCANLINES - 1) / 3;
        }

        /* initialization */
        scanline = scanline_table;

        /* round y-coord instead of truncation @RND 3/23/89 */
        /*  start_y = SFX2I_T(scan_y0 + 7);
         *  scans = SFX2I_T(scan_y1) - start_y + 1;
         */

         start_y = SFX2I(scan_y0);
         scans = SFX2I(scan_y1) - start_y + 1;

        /* special case: just a horizontal line, to fill it directly */

        if (scans <= 1) {          /* if (scans <= 0)  {  @RND 3/23/89   */
#ifdef DBG1
                printf("scans=%d less than zero\n", scans);
#endif
                /* horiz. line adjustment; expand to max endpoints */
                if (tpzd->topxl > tpzd->btmxl)  /* get min_x */
                     xs = SFX2I_T(tpzd->btmxl);
                else
                     xs = SFX2I_T(tpzd->topxl);

                if (tpzd->topxr < tpzd->btmxr) /* get max_x */
                     xe = SFX2I_T(tpzd->btmxr);
                else
                     xe = SFX2I_T(tpzd->topxr);

                /* put scan line in scanline structure */
                *scanline++ = (SCANLINE)xs;
                *scanline++ = (SCANLINE)xe;
                /* put end_mark in scanline structure */
                *scanline++ = END_OF_SCANLINE;

                /* y-coord truncate to pixel 1/24/89 */
                /* start_y = SFX2I_T(scan_y0);  @RND */
                /* should not modify bounding box for F_TO_CACHE 5/18/89 */
                if (tpzd_destination == F_TO_PAGE) {
                        tpzd_info->BOX_Y = start_y;  /* @RND */
                        tpzd_info->box_h = 1;        /* @RND */
                }

                fill_a_band (start_y, 1);
                return;
        }

        /* modify x_coord as y_coord advances to pixel position */
        dy = I2SFX(start_y) - scan_y0;  /* @RESO_UPGR */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
        scan_lxint += (scan_lxc >> S_SHIFT) * dy;
        scan_rxint += (scan_rxc >> S_SHIFT) * dy;
#elif FORMAT_16_16
        LongFixsMul(scan_lxc, dy, dest1);
        scan_lxint += LongFixsDiv((1L << S_SHIFT), dest1);

        LongFixsMul(scan_rxc, dy, dest1);
        scan_rxint += LongFixsDiv((1L << S_SHIFT), dest1);
#elif FORMAT_28_4
        /*
        */
        scan_lxint += ((scan_lxc >> S_SHIFT) * dy);
        scan_rxint += ((scan_rxc >> S_SHIFT) * dy);
#endif

        /*
         * adjustment of left and right edges to prevent broken lines
         */

        /* shift left edge to left side for 1/2 * x_change units */
        if (scan_lxc > 0) {
                scan_lxint -= (scan_lxc >> 1);
                xs = SFX2I_T(tpzd->topxl);
                     /* get real endpoint as 1st scanline; should not shift */
        } else {
                scan_lxint += (scan_lxc >> 1);
                xs = LFX2I_T(scan_lxint);
                if (xs < 0) xs = 0;       /* fix arith error 1/20/91 */
        }

        /* shift right edge to right side for 1/2 * x_change units */
        if (scan_rxc < 0) {
                scan_rxint -= (scan_rxc >> 1);
                xe = SFX2I_T(tpzd->topxr);
                     /* get real endpoint as 1st scanline; should not shift */
        } else {
                scan_rxint += (scan_rxc >> 1);
                xe = LFX2I_T(scan_rxint);
        }

#ifdef DBG1
        printf("1st:  (xs,xe)= (%d, %d)\n", xs, xe);
#endif

/* shortcut for rectangle - begin, 1-16-91, Jack */
        if ((tpzd->btmxl == tpzd->topxl) && (tpzd->btmxr == tpzd->topxr)) {
            for ( ;scans > 0; scans -= lines_per_band,
                start_y += lines_per_band) {
/*              fix dy; */

                if ((ufix)scans <= lines_per_band) {    //@WIN
                    lines = scans;
                } else
                    lines = lines_per_band;
                bb_y = lines;

                /* Loop for each scan line in edge_table */
                while(bb_y--) {
                    *scanline++ = (SCANLINE)xs;
                    *scanline++ = (SCANLINE)xe;
                    *scanline++ = END_OF_SCANLINE;
                } /* scan line loop */
                /* fill the band */
                if (tpzd_destination == F_TO_PAGE) {
                    /* the bounding box infomation should be modified */
                    tpzd_info->BOX_Y = start_y;
                    tpzd_info->box_h = lines;
                }
                fill_a_band (start_y, lines);

                /* initialize scanline structure */
                scanline = scanline_table;
            }
            return;
        }
/* shortcut for rectangle -   end, 1-16-91, Jack */

        /* put 1st scan line in scanline structure */
        *scanline++ = (SCANLINE)xs;
        *scanline++ = (SCANLINE)xe;
        /* put end_mark in scanline structure */
        *scanline++ = END_OF_SCANLINE;

        /* init */
        first_band = TRUE;
        last_band = FALSE;

        /* Loop for filling a band */
        for ( ;scans > 0; scans -= lines_per_band, start_y += lines_per_band) {
            fix dy;                             /* scans >= 0    1/31/89 */

            if ((ufix)scans <= lines_per_band) {        //@WIN
                last_band = TRUE;
                lines = scans;
            } else
                lines = lines_per_band;

            dy = lines;
            if (first_band) {   /* 1st scan line has been generated */
                dy--;
                first_band = FALSE;
            }

#ifdef DBG1
            printf("start_y=%d, scans=%d, lines=%d, lines_per_band=%d, dy=%d\n",
                 start_y, scans, lines, lines_per_band, dy);
#endif

            /* Loop for each scan line in edge_table */
            while(dy--) {

                    /* update edge table */
                    scan_lxint += scan_lxc;
                    scan_rxint += scan_rxc;

                    /* get scan pairs */
                    xs = LFX2I_T(scan_lxint);
                    xe = LFX2I_T(scan_rxint);

#ifdef DBG1
                    printf("      (xs,xe)= (%d, %d)\n", xs, xe);
#endif
                    *scanline++ = (SCANLINE)xs;
                    *scanline++ = (SCANLINE)xe;
                    /* put end_mark in scanline structure */
                    *scanline++ = END_OF_SCANLINE;
            } /* scan line loop */

            /* get real endpoint as the last scanline; should not shift */
            if (last_band) {
                if (scan_lxc < 0) {
                        *(scanline -3) = SFX2I_T(tpzd->btmxl);
#ifdef DBG1
                        printf("revise last xs = %d\n", *(scanline -3));
#endif
                }

                if (scan_rxc > 0) {
                        *(scanline -2) = SFX2I_T(tpzd->btmxr);
#ifdef DBG1
                        printf("revise last xe = %d\n", *(scanline -2));
#endif
                }
            }

            /* fill the band */
            if (tpzd_destination == F_TO_PAGE) {
                    /* the bounding box infomation should be
                     * modified
                     */
                    tpzd_info->BOX_Y = start_y; /* (bb_y >= 1) ? bb_y - 1 : 0; */
                    tpzd_info->box_h = lines;   /* lines + 1; */
                                    /* expand box one more line to
                                     * include top horizontal line
                                     */
            }
#ifdef DBG2
            printf(" Fill a band: box_x=%d,", tpzd_info->BOX_X);
            printf(" bb_y=%d, box_w=%d, lines=%d start_y=%d\n",
                     bb_y, tpzd_info->box_w, lines, start_y);
#endif

#ifdef DBG3
            /* Start of DEBUG: to check if scanlines inside box of trapezoid */
            {
                fix min_x, max_x;
                fix     i, error;
                SCANLINE FAR *scan;

                if (tpzd->topxl > tpzd->btmxl)  /* get min_x */
                     min_x = SFX2I_T(tpzd->btmxl);
                else
                     min_x = SFX2I_T(tpzd->topxl);

                if (tpzd->topxr < tpzd->btmxr) /* get max_x */
                     max_x = SFX2I_T(tpzd->btmxr);
                else
                     max_x = SFX2I_T(tpzd->topxr);

                error = FALSE;
                for (i=0, scan=scanline_table; i<lines; i++) {
                    fix tmp1, tmp2;
                    while( *scan != END_OF_SCANLINE) {
                        if (((tmp1 = *scan++) < min_x) ||
                            ((tmp2 = *scan++) > max_x) ||
                            (tmp1 > tmp2)) {
                            error = TRUE;
                        }
                    }
                    scan++;
                }
                if (error) {
                    printf("Warning, outside tpzd_box!! gp_scanconv():\n");
                    printf("topy=%f, topxl=%f, topxr=%f\n", SFX2F(tpzd->topy),
                            SFX2F(tpzd->topxl), SFX2F(tpzd->topxr));
                    printf("btmy=%f, btmxl=%f, btmxr=%f\n", SFX2F(tpzd->btmy),
                            SFX2F(tpzd->btmxl), SFX2F(tpzd->btmxr));
                    printf(" box_x=%d, box_y=%d, box_w=%d, box_h=%d\n",
                            tpzd_info->BOX_X, tpzd_info->BOX_Y,
                            tpzd_info->box_w, tpzd_info->box_h);
                    printf("tpzd: scan_y0=%f, scan_y1=%f\n", SFX2F(scan_y0),
                           SFX2F(scan_y1));
                    printf("      left edge  -- xc=%f, xint=%f\n",
                           LFX2F(scan_lxc), LFX2F(scan_lxint));
                    printf("      right edge -- xc=%f, xint=%f\n",
                           LFX2F(scan_rxc), LFX2F(scan_rxint));

                    for (i=0, scan=scanline_table; i<lines; i++) {
                        while( *scan != END_OF_SCANLINE) {
                                printf("     <%d ",*scan);
                                scan++;
                                printf("-> %d> ",*scan);
                                scan++;
                        }
                        printf("\n");
                        scan++;
                    }
                } /* if error */
            }
            /* End of DEBUG */
#endif

            fill_a_band (start_y, lines);

            /* initialize scanline structure */
            scanline = scanline_table;

        } /* band loop */
}


/***********************************************************************
 * Performs scan conversion on a quadrangle in a interior fill manner.
 * All verteice of the quadrangle are in integer format.
 *
 * TITLE:       gp_scanconv_i
 *
 * CALL:        gp_scanconv(x_maxs, y_maxs, sample)
 *
 * PARAMETERS:
 *              1. x_maxs: maximum value of x ccordinate
 *              2. y_maxs: maximum value of y ccordinate
 *              3. sample: a quadrangle
 *
 * INTERFACE:   fill_seed
 *
 * CALLS:       fill_seed_patt
 *
 * RETURN:      None
 **********************************************************************/
void far
gp_scanconv_i(image_type, x_maxs, y_maxs, quadrangle)
ufix           image_type;                                      /* 05-25-89 */
fix            x_maxs, y_maxs;
struct sample FAR *quadrangle;
{
    fix                 index;
    struct vertex      FAR *point;
    struct vertex       vertex[5];
    struct edgese       edgese[256];
    SCANLINE      FAR *scanline_table;
    SCANLINE      FAR *scanline;

    scanline_table = alloc_scanline(y_maxs * 3);

    /* reset content of edge table */
    for (index = 0; index < y_maxs; index++)
        edgese[index].s = edgese[index].e = -1;

    /* create circular vertex list */
    vertex[0].x = quadrangle->p[0].x /* - x_mins */;
    vertex[0].y = quadrangle->p[0].y /* - y_mins */;
    vertex[1].x = quadrangle->p[1].x /* - x_mins */;
    vertex[1].y = quadrangle->p[1].y /* - y_mins */;
    vertex[2].x = quadrangle->p[2].x /* - x_mins */;
    vertex[2].y = quadrangle->p[2].y /* - y_mins */;
    vertex[3].x = quadrangle->p[3].x /* - x_mins */;
    vertex[3].y = quadrangle->p[3].y /* - y_mins */;
    vertex[4].x = quadrangle->p[0].x /* - x_mins */;
    vertex[4].y = quadrangle->p[0].y /* - y_mins */;

    for (index = 0, point = vertex; index <  4; point++, index++)
    {
        fix                 x0, y0;
        fix                 x1, y1;
        fix                 dx, dy;
        fix                 x, y, px;

        /* no need to process horizontal edge */
        if (point[0].y == point[1].y)
            continue;

        /* setup points of a edge; be sure that y0 <= y1 */
        if (point[0].y <= point[1].y) {
            x0 = point[0].x; y0 = point[0].y;
            x1 = point[1].x; y1 = point[1].y;
        } else {
            x0 = point[1].x; y0 = point[1].y;
            x1 = point[0].x; y1 = point[0].y;
        }

        /* calculate length of x and y component */
        dx = (x1 - x0) * 2;
        dy = (y1 - y0) * 2;

#ifdef  DBG2
        printf("[%2d, %2d]    [%2d, %2d]    dx: %3d    dy: %3d\n",
               x0, y0, x1, y1, dx, dy);
#endif

        /* could be modified into DDA */
        px = x0 * dy + x1 - x0;
        for (y = y0; y < y1; y++) {
            x = px / dy;
            /* put x into proper field (s or e) */
            if (edgese[y].s == -1)
                edgese[y].s = x;
            else
            if (edgese[y].s <=  x)
                edgese[y].e = x;
            else {
                edgese[y].e = edgese[y].s;
                edgese[y].s = x;
            }
            px+= dx;
        }
    }

    scanline = scanline_table;
    for (index = 0; index < y_maxs; index++) {
        if (edgese[index].s < edgese[index].e) {
            *scanline = (SCANLINE)(edgese[index].s);
            scanline++;
            *scanline = (SCANLINE)(edgese[index].e - 1);
            scanline++;
        }
        *scanline = (SCANLINE) 0x8000;
        scanline++;
    }
    *scanline = (SCANLINE) 0x8000;      /* 3-7-91, Jack */

    fill_seed_patt(image_type, image_info.seed_index,   /* @IMAGE 01-04-89 */
                   x_maxs, y_maxs, y_maxs, scanline_table);     /* 05-25-89 */
}


/***********************************************************************
 * According to the type(tpzd_destination), this routine calls the
 * corresponding lower level graphics primitives to render it to
 * appropriate destination(cache, page, mask, or seed pattern).
 *
 * TITLE:       fill_a_band
 *
 * CALL:        fill_a_band(ys_lines, no_lines)
 *
 * PARAMETERS:
 *              ys_lines: y-coord of the starting sacn line
 *              no_lines: number of scan lines
 *
 *              global variable: tpzd_destination
 *                      F_TO_CACHE -- fill to cache memory
 *                      F_TO_PAGE  -- fill to page
 *                      F_TO_CLIP  -- fill to clip mask
 *                      F_TO_IMAGE -- fill for image(build seed pattern)
 *
 * INTERFACE:   gp_scanconv
 *
 * CALLS:       fill_scan_cache
 *              fill_scan_page
 *              clip_cache_page
 *              fill_seed_patt
 *
 * RETURN:      None
 **********************************************************************/
static void fill_a_band (ys_lines, no_lines)
fix     ys_lines, no_lines;
{

#ifdef DBG2
        fix     i;
        SCANLINE FAR *scan;

        printf("Fill_band(): destination=%d,", tpzd_destination);
        printf(" box_x=%d, box_y=%d, box_w=%d, box_h=%d\n", tpzd_info->BOX_X,
                 tpzd_info->BOX_Y, tpzd_info->box_w, tpzd_info->box_h);
        printf("       ys_lines=%d, no_lines=%d\n", ys_lines, no_lines);

        for (i=0, scan=scanline_table; i<no_lines; i++) {
            while( *scan != END_OF_SCANLINE) {
                    printf("     <%d ",*scan);
                    scan++;
                    printf("-> %d> ",*scan);
                    scan++;
            }
            printf("\n");
            scan++;
        }
#endif

        *scanline = END_OF_SCANLINE;            /* will be deleted ??? */

        switch (tpzd_destination) {

        case F_TO_CACHE :
/*          fill_scan_cache (cache_info->bitmap,
 *              cache_info->box_w, cache_info->box_h,
 *              ys_lines, no_lines, scanline_table);
 */

            /* keep bounding box info in local variable(cache_info) instead of
             * in global variable(cahce_info) for correctly saving commands
             * in command buffer 5/18/89
             */
            fill_scan_cache (tpzd_info->BMAP,           /* 4/19/89 */
                tpzd_info->box_w, tpzd_info->box_h,
                ys_lines, no_lines, scanline_table);
            break;

        case F_TO_PAGE :
/*          fill_scan_page (fill_info.box_x, fill_info.box_y,
 *                          fill_info.box_w, fill_info.box_h,
 *                          scanline_table);
 */
            fill_scan_page (tpzd_info->BOX_X, tpzd_info->BOX_Y,
                            tpzd_info->box_w, tpzd_info->box_h,
                            scanline_table);
            break;

        case F_TO_CLIP :
            clip_cache_page (ys_lines, no_lines, scanline_table);
            break;

/*      CAN BE REMOVED                                  01-16-89
        case F_TO_IMAGE :                       |* @IMAGE *|
#ifdef DBG2
            printf("fill_band(): F_TO_IMAGE");
            printf(" box_x=%d, box_y=%d, box_w=%d, box_h=%d\n", tpzd_info->BOX_X,
                     tpzd_info->BOX_Y, tpzd_info->box_w, tpzd_info->box_h);
            printf("       ys_lines=%d, no_lines=%d\n", ys_lines, no_lines);
#endif

|*          fill_seed_patt(fill_info->box_w, fill_info->box_h,
 *                         no_lines, scanline_table);
 *|
            fill_seed_patt(image_info.seed_index,               |* 11-24-88 *|
                           tpzd_info->box_w, tpzd_info->box_h,
                           no_lines, scanline_table);
            break;
*/

    /* ++++++++++++ @Y.C. BEGIN +++++++++++++++++++++++++++++++++++++++++++ */
        case F_TO_MASK :                        /* @IMAGE  01-16-89  Y.C. */
            clip_image_page (ys_lines, no_lines, scanline_table);
            break;
    /* ++++++++++++ @Y.C. END +++++++++++++++++++++++++++++++++++++++++++++ */

        default :
            printf(" fatal error, tpzd_destination\n");

        } /* swith */
}


/* -----------------------------------------------------------------------
 * THIN LINE SIMULATION: gp_vector() and gp_vector_c()
 *                       gp_vector() -- fill line to frame buffer
 *                       gp_vector_c -- fill line to character cache buffer
 *
 * Function Description:
 *           Draw a thin line (single pixel) into Frame Buffer.
 *           vector with following logical operations:
 *           FC_SOLID: 1 --> destination (cache only)
 *           FC_MERGE: source .OR.  destination --> destination
 *           FC_CLEAR: (.NOT. source)  .AND. (destination) --> destination
 *           FC_MERGE | HT_APPLY:
 *               Step 1. Clear destination for value 1 on source object.
 *               Step 2. (source AND halftone) --> source.
 *               Step 3. (source OR destination) --> destination.
 *           , where source are always "1"
 *
 * Calling sequence:
 *       void gp_vector(DST, FC, X0, Y0, X1, Y1)
 *       void gp_vector_c(DST, FC, X0, Y0, X1, Y1)
 *       struct bitmap *DST;    (* address of destination bitmap *)
 *       ufix16         FC;     (* Paint type *)
 *       fix            X0, Y0; (* position of starting point *)
 *       fix            X1, Y1; (* position of ending point *)
 *
 *
 * Diagram Description:
 *
 *                   destination bitmap
 *          DST +---------------------------+
 *              |                           |
 *              | (X0, Y0)                  |
 *              |       \                   |
 *              |        \                  |
 *              |         \                 |
 *              |          \                |
 *              |           \               |
 *              |            \              |
 *              |             \             |
 *              |              \            |
 *              |               \           |
 *              |                \ (X1,Y1)  |
 *              |                           |
 *              |                           |
 *              +---------------------------+
 *
 * ----------------------------------------------------------------------- */
/* -----------------------------------------------------------------------
 * gp_vector(): fill line to frame buffer
 *
 * ----------------------------------------------------------------------- */

void
gp_vector(dst, fc, x0, y0, x1, y1)
struct bitmap FAR     *dst;
ufix16                  fc;
/* fix                  x0, y0, x1, y1; */
sfix_t                  x0, y0, x1, y1; /* @RESO_UPGR */
{
    fix                 dw;
    BM_DATYP           huge *db, huge *dp;      /* far => huge @WIN */
    fix                 hw;
    BM_DATYP           huge *ht, huge *hp;      /* far => huge @WIN */
    BM_DATYP            pm;

    /* fix              x, y, sx, sy, dx, dy; */
    sfix_t              x, y, sx, sy, dx, dy; /* @RESO_UPGR */
    fix                scans;
    lfix_t             slope, nextp;
#ifdef FORMAT_13_3      /* @RESO_UPGR */
#elif FORMAT_16_16
        long    dest1[2];
        long    temp;
#elif FORMAT_28_4
        long    dest1[2];
        long    temp;
#endif
    ufix32              tmp;                    /* for swap; @WIN */

    dx = (x1 >= x0) ? (x1 - x0) : (x0 - x1);
    dy = (y1 >= y0) ? (y1 - y0) : (y0 - y1);
    dw = dst->bm_cols / BM_PIXEL_WORD;

    /* due to slope evaluate line pixels in x-coord or y-coord major */
    if (dx >= dy) {        /*  |degree| <= 45; x-coord major */
        fix     last_y, delta_y, start_x;

/*      printf("X-coord major\n");      */

        /*  swap for x0 <= x1  */
        if (x1 < x0) {
            sx = x1;
            x1 = x0;
            x0 = sx;
            sy = y1;
            y1 = y0;
            y0 = sy;
        }

//      db = &((BM_DATYP huge *) dst->bm_addr)[SFX2I(y0) * dw]; /* far => huge @WIN */
        db = (BM_DATYP huge *) dst->bm_addr +
             ((DWORD)SFX2I(y0) * (DWORD)dw);

        switch (fc)
        {
        case FC_CLEAR:                  /*  0010  D <- D .AND. .NOT. S  */

           start_x = SFX2I_T(x0);
           /* fill first pixel */
//         dp = &db[start_x / BM_PIXEL_WORD];   @WIN
           dp = db + start_x / BM_PIXEL_WORD;
//         dp[0] = AND(dp[0], ~BM_P_MASK(start_x));   /*@WIN*/
           tmp = BM_P_MASK(start_x);   /*@WIN*/
           LWORDSWAP(tmp);
           dp[0] = AND(dp[0], ~tmp);

           /* degernated case, just one pixel */
           if (dx == 0) {
/*                 printf(" <%d, %d>", SFX2I_T(x0), SFX2I(y0)); */
                   return;
           }

#ifdef FORMAT_13_3 /* @RESO_UPGR */
           slope = (((fix32)(y1 - y0)) << L_SHIFT) / (x1 - x0);
#elif  FORMAT_16_16
           /* "slope" needs to be in "LFX" format.
           */
           LongFixsMul((y1 - y0), (1L << L_SHIFT), dest1);
           slope = LongFixsDiv((x1 - x0), dest1);
#elif  FORMAT_28_4
           /* "slope" needs to be in "LFX" format.
           */
           LongFixsMul((y1 - y0), (1L << L_SHIFT), dest1);
           slope = LongFixsDiv((x1 - x0), dest1);
#endif
           nextp = SFX2LFX(y0);

           scans = SFX2I_T(x1) - start_x + 1;

           /* modify y_coord as x_coord truncates to pixel position */
           dx = I2SFX(start_x) - x0;

#ifdef FORMAT_13_3 /* @RESO_UPGR */
           nextp += (slope >> S_SHIFT) * dx;
#elif  FORMAT_16_16
           LongFixsMul(slope, dx, dest1);
           nextp += LongFixsDiv((1L << S_SHIFT), dest1);
#elif  FORMAT_28_4
           nextp += (slope >> S_SHIFT) * dx;
#endif

           /* special processing for the first pixel, use endpoint y0 */
/*         printf(" <%d, %d>", start_x, SFX2I(y0));     */
           last_y = SFX2I(y0);
           if (--scans == 0) return;

           /* Loop for each scan line in edge_table */
           x = (sfix_t)start_x;
           while(scans--) {
                   /* get next position */
                   nextp += slope;
                   x++;

                   y = LFX2I(nextp);

                   delta_y = y - last_y;
                   if(delta_y > 0) {
                        db += dw;
                   }
                   else if (delta_y < 0) {
                        db -= dw;
                   }
//                 dp = &db[x / BM_PIXEL_WORD]; @WIN
                   dp = db + x / BM_PIXEL_WORD;
//                 dp[0] = AND(dp[0], ~BM_P_MASK(x));      /*@WIN*/
                   tmp = BM_P_MASK(x);   /*@WIN*/
                   LWORDSWAP(tmp);
                   dp[0] = AND(dp[0], ~tmp);

/*                 printf(" <%d, %d> (%d)", x, y, delta_y);     */
                   last_y = y;
           }
           break;

        case FC_MERGE:                  /*  0111  D <- D .OR. S         */

        case FC_SOLID:                  /*  1111  D <- 1                */

           start_x = SFX2I_T(x0);
           /* fill first pixel */
//         dp = &db[start_x / BM_PIXEL_WORD];   @WIN
           dp = db + start_x / BM_PIXEL_WORD;
//         dp[0] = OR(dp[0], BM_P_MASK(start_x));  /*@WIN*/
           tmp = BM_P_MASK(start_x);   /*@WIN*/
           LWORDSWAP(tmp);
           dp[0] = OR(dp[0], tmp);

           /* degernated case, just one pixel */
           if (dx == 0) {
/*                 printf(" <%d, %d>", SFX2I_T(x0), SFX2I(y0)); */
                   return;
           }

#ifdef FORMAT_13_3 /* @RESO_UPGR */
           slope = (((fix32)(y1 - y0)) << L_SHIFT) / (x1 - x0);
#elif FORMAT_16_16
           /* "slope" needs to be in "LFX" format.
           */
           LongFixsMul((y1 - y0), (1L << L_SHIFT), dest1);
           slope = LongFixsDiv((x1 - x0), dest1);
#elif FORMAT_28_4
           LongFixsMul((y1 - y0), (1L << L_SHIFT), dest1);
           slope = LongFixsDiv((x1 - x0), dest1);
#endif
           nextp = SFX2LFX(y0);

           scans = SFX2I_T(x1) - start_x + 1;

           /* modify y_coord as x_coord truncates to pixel position */
           dx = I2SFX(start_x) - x0;

#ifdef FORMAT_13_3 /* @RESO_UPGR */
           nextp += (slope >> S_SHIFT) * dx;
#elif  FORMAT_16_16
           LongFixsMul(slope, dx, dest1);
           nextp += LongFixsDiv((1L << S_SHIFT), dest1);
#elif  FORMAT_28_4
           nextp += (slope >> S_SHIFT) * dx;
#endif

           /* special processing for the first pixel, use endpoint y0 */
/*         printf(" <%d, %d>", start_x, SFX2I(y0));     */
           last_y = SFX2I(y0);
           if (--scans == 0) return;

           /* Loop for each scan line in edge_table */
           x = (sfix_t)start_x;
           while(scans--) {
                   /* get next position */
                   nextp += slope;
                   x++;

                   y = LFX2I(nextp);

                   delta_y = y - last_y;
                   if(delta_y > 0) {
                        db += dw;
                   }
                   else if (delta_y < 0) {
                        db -= dw;
                   }
//                 dp = &db[x / BM_PIXEL_WORD]; @WIN
                   dp = db + x / BM_PIXEL_WORD;
//                 dp[0] = OR(dp[0], BM_P_MASK(x));  /*@WIN*/
                   tmp = BM_P_MASK(x);   /*@WIN*/
                   LWORDSWAP(tmp);
                   dp[0] = OR(dp[0], tmp);
/*                 printf(" <%d, %d> (%d)", x, y, delta_y); */
                   last_y = y;
           }
           break;

        case FC_MERGE | HT_APPLY:       /*  D <- (D .AND. .NOT. S) .OR.
                                                 (S .AND. HT)           */
           start_x = SFX2I_T(x0);

           hw = HTB_Bmap.bm_cols / BM_PIXEL_WORD;
           ht = (BM_DATYP huge *) HTB_Bmap.bm_addr;   /* far => huge @WIN */

           /* fill first pixel */
//         dp = &db[start_x / BM_PIXEL_WORD];   @WIN
           dp = db + start_x / BM_PIXEL_WORD;
           hp = &ht[(SFX2I(y0) % HTB_Bmap.bm_rows) * hw +
                     start_x / BM_PIXEL_WORD];
//         dp[0] = OR(AND(dp[0], ~BM_P_MASK(start_x)),     /*@WIN*/
//                         AND(hp[0],  BM_P_MASK(start_x)));  /*@WIN*/
           tmp = BM_P_MASK(start_x);   /*@WIN*/
           LWORDSWAP(tmp);
           dp[0] = OR(AND(dp[0], ~tmp),     /*@WIN*/
                           AND(hp[0],  tmp));  /*@WIN*/

           /* degernated case, just one pixel */
           if (dx == 0) {
/*                 printf(" <%d, %d>", SFX2I_T(x0), SFX2I(y0)); */
                   return;
           }

#ifdef FORMAT_13_3 /* @RESO_UPGR */
           slope = (((fix32)(y1 - y0)) << L_SHIFT) / (x1 - x0);
#elif FORMAT_16_16
           /* "slope" needs to be in "LFX" format.
           */
           LongFixsMul((y1 - y0), (1L << L_SHIFT), dest1);
           slope = LongFixsDiv((x1 - x0), dest1);
#elif FORMAT_28_4
           LongFixsMul((y1 - y0), (1L << L_SHIFT), dest1);
           slope = LongFixsDiv((x1 - x0), dest1);
#endif
           nextp = SFX2LFX(y0);

           scans = SFX2I_T(x1) - start_x + 1;

           /* modify y_coord as x_coord truncates to pixel position */
           dx = I2SFX(start_x) - x0;

#ifdef FORMAT_13_3 /* @RESO_UPGR */
           nextp += (slope >> S_SHIFT) * dx;
#elif  FORMAT_16_16
           LongFixsMul(slope, dx, dest1);
           nextp += LongFixsDiv((1L << S_SHIFT), dest1);
#elif  FORMAT_28_4
           nextp += (slope >> S_SHIFT) * dx;
#endif

           /* special processing for the first pixel, use endpoint y0 */
/*         printf(" <%d, %d>", start_x, SFX2I(y0));     */
           last_y = SFX2I(y0);
           if (--scans == 0) return;

           /* Loop for each scan line in edge_table */
           x = (sfix_t)start_x;
           while(scans--) {
                   /* get next position */
                   nextp += slope;
                   x++;

                   y = LFX2I(nextp);
                   delta_y = y - last_y;

                   if(delta_y > 0) {
                        db += dw;
                   }
                   else if (delta_y < 0) {
                        db -= dw;
                   }
//                 dp = &db[x / BM_PIXEL_WORD]; @WIN
                   dp = db + x / BM_PIXEL_WORD;
                   hp = &ht[(y % HTB_Bmap.bm_rows) * hw +
                             x / BM_PIXEL_WORD];
//                 dp[0] = OR(AND(dp[0], ~BM_P_MASK(x)),   /*@WIN*/
//                            AND(hp[0],  BM_P_MASK(x)));  /*@WIN*/
                   tmp = BM_P_MASK(x);   /*@WIN*/
                   LWORDSWAP(tmp);
                   dp[0] = OR(AND(dp[0], ~tmp),     /*@WIN*/
                                   AND(hp[0],  tmp));  /*@WIN*/

/*                 printf(" <%d, %d> (%d)", x, y, delta_y);     */
                   last_y = y;
           }
           break;
        }

    } else {        /*  |degree| > 45; y-coord major */
        fix     start_y;

/*      printf("Y-coord major\n");      */

        /*  swap for y0 <= y1  */
        if (y1 < y0) {
            sx = x1;
            x1 = x0;
            x0 = sx;
            sy = y1;
            y1 = y0;
            y0 = sy;
        }
#ifdef FORMAT_13_3 /* @RESO_UPGR */
        slope = (((fix32)(x1 - x0)) << L_SHIFT) / (y1 - y0);
#elif FORMAT_16_16
        /* "slope" needs to be in "LFX" format.
        */
        LongFixsMul((x1 - x0), (1L << L_SHIFT), dest1);
        slope = LongFixsDiv((y1 - y0), dest1);
#elif FORMAT_28_4
        LongFixsMul((x1 - x0), (1L << L_SHIFT), dest1);
        slope = LongFixsDiv((y1 - y0), dest1);
#endif
        nextp = SFX2LFX(x0);

        start_y = SFX2I(y0);
        scans = SFX2I(y1) - start_y + 1;

        /* modify x_coord as y_coord rounds to pixel position */
        dy = I2SFX(start_y) - y0;

#ifdef FORMAT_13_3 /* @RESO_UPGR */
        nextp += (slope >> S_SHIFT) * dy;
#elif  FORMAT_16_16
        LongFixsMul(slope, dy, dest1);
        nextp += LongFixsDiv((1L << S_SHIFT), dest1);
#elif  FORMAT_28_4
        nextp += (slope >> S_SHIFT) * dy;
#endif

//      db = &((BM_DATYP huge *) dst->bm_addr)[start_y * dw]; /* far => huge @WIN */
        db = (BM_DATYP huge *)dst->bm_addr + ((DWORD)start_y * (DWORD)dw);
        pm = BM_P_MASK(SFX2I_T(x0));
        LWORDSWAP(pm);                  /*@WIN*/

        switch (fc)
        {
        case FC_CLEAR:                  /*  0010  D <- D .AND. .NOT. S  */

           /* special processing for the first pixel, use endpoint x0 */
/*         printf(" <%d, %d>", SFX2I_T(x0), start_y);   */
//         dp = &db[SFX2I_T(x0) / BM_PIXEL_WORD];       @WIN
           dp = db + SFX2I_T(x0) / BM_PIXEL_WORD;
           dp[0] = AND(dp[0], ~pm);
           if (--scans == 0) return;

           /* Loop for each scan line in edge_table */
           y = (sfix_t)start_y;
           while(scans--) {
                   /* get next position */
                   nextp += slope;
                   db += dw;

                   x = LFX2I_T(nextp);
//                 dp = &db[x / BM_PIXEL_WORD]; @WIN
                   dp = db + x / BM_PIXEL_WORD;
//                 dp[0] = AND(dp[0], ~BM_P_MASK(x));      /*@WIN*/
                   tmp = BM_P_MASK(x);   /*@WIN*/
                   LWORDSWAP(tmp);
                   dp[0] = AND(dp[0], ~tmp);
/*                 printf(" <%d, %d> (%d)", x, y, delta_x);     */
           }
           break;

        case FC_MERGE:                  /*  0111  D <- D .OR. S         */

        case FC_SOLID:                  /*  1111  D <- 1                */

           /* special processing for the first pixel, use endpoint x0 */
/*         printf(" <%d, %d>", SFX2I_T(x0), start_y);   */
//         dp = &db[SFX2I_T(x0) / BM_PIXEL_WORD]; @WIN
           dp = db + SFX2I_T(x0) / BM_PIXEL_WORD;
           dp[0] = OR(dp[0], pm);
           if (--scans == 0) return;

           /* Loop for each scan line in edge_table */
           y = (sfix_t)start_y;
           while(scans--) {
                   /* get next position */
                   nextp += slope;
                   db += dw;

                   x = LFX2I_T(nextp);
//                 dp = &db[x / BM_PIXEL_WORD]; @WIN
                   dp = db + x / BM_PIXEL_WORD;
//                 dp[0] = OR(dp[0], BM_P_MASK(x));    /*@WIN*/
                   tmp = BM_P_MASK(x);   /*@WIN*/
                   LWORDSWAP(tmp);
                   dp[0] = OR(dp[0], tmp);
/*                 printf(" <%d, %d> (%d)", x, y, delta_x);     */
           }
           break;

        case FC_MERGE | HT_APPLY:       /*  D <- (D .AND. .NOT. S) .OR.
                                                 (S .AND. HT)           */

            hw = HTB_Bmap.bm_cols / BM_PIXEL_WORD;
            ht = (BM_DATYP huge *) HTB_Bmap.bm_addr;    /* far => huge @WIN */

           /* special processing for the first pixel, use endpoint x0 */
/*         printf(" <%d, %d>", SFX2I_T(x0), start_y);   */
//         dp = &db[SFX2I_T(x0) / BM_PIXEL_WORD]; @WIN
           dp = db + SFX2I_T(x0) / BM_PIXEL_WORD;
           hp = &ht[(start_y % HTB_Bmap.bm_rows) * hw +
                    SFX2I_T(x0) / BM_PIXEL_WORD];
           dp[0] = OR(AND(dp[0], ~pm),
                      AND(hp[0],  pm));
           if (--scans == 0) return;

           /* Loop for each scan line in edge_table */
           y = (sfix_t)start_y;
           while(scans--) {
                   /* get next position */
                   nextp += slope;
                   db += dw;
                   y++;

                   x = LFX2I_T(nextp);
//                 dp = &db[x / BM_PIXEL_WORD]; @WIN
                   dp = db + x / BM_PIXEL_WORD;
                   hp = &ht[(y % HTB_Bmap.bm_rows) * hw +
                             x / BM_PIXEL_WORD];
                   dp[0] = OR(AND(dp[0], ~pm),
                              AND(hp[0],  pm));
/*                 printf(" <%d, %d> (%d)", x, y, delta_x);     */
           }
           break;
        }

    } /* if 45 degrees */

} /* gp_vector */


/* ----------------------------------------------------------------------
 * gp_vector_c(): used for fill line to character cache
 *
 * ---------------------------------------------------------------------- */
void
gp_vector_c(dst, fc, x0, y0, x1, y1)
struct bitmap FAR     *dst;
ufix16                  fc;
/* fix                  x0, y0, x1, y1; */
sfix_t                  x0, y0, x1, y1; /* @RESO_UPGR */
{
    fix                 dw;
    CC_DATYP           FAR *db, FAR *dp;
    CC_DATYP            pm;

    /* fix              x, y, sx, sy, dx, dy; */
    sfix_t              x, y, sx, sy, dx, dy; /* @RESO_UPGR */
    fix                scans;
    lfix_t             slope, nextp;
#ifdef FORMAT_13_3      /* @RESO_UPGR */
#elif FORMAT_16_16
        long    dest1[2];
        long    temp;
#elif FORMAT_28_4
        long    dest1[2];
        long    temp;
#endif

#ifdef  DBG
    printf("vector_c: %6.6lx %4.4x [%4x,%4x] [%4x,%4x]\n",
           dst->bm_addr, fc, x0, y0, x1, y1);
#endif

    dx = (x1 >= x0) ? (x1 - x0) : (x0 - x1);
    dy = (y1 >= y0) ? (y1 - y0) : (y0 - y1);
    dw = dst->bm_cols / CC_PIXEL_WORD;

    /* due to slope evaluate line pixels in x-coord or y-coord major */
    if (dx >= dy) {        /*  |degree| <= 45; x-coord major */
        fix     last_y, delta_y, start_x;

/*      printf("X-coord major\n");      */

        /*  swap for x0 <= x1  */
        if (x1 < x0) {
            sx = x1;
            x1 = x0;
            x0 = sx;
            sy = y1;
            y1 = y0;
            y0 = sy;
        }
        //NTFIX
        db = (CC_DATYP FAR *) dst->bm_addr + ((DWORD) SFX2I(y0) * (DWORD) dw);

        start_x = SFX2I_T(x0);

        //NTFIX
        dp = db + start_x / CC_PIXEL_WORD;

        //NTFIX, added the cast to get rid of a warning

        {
            ufix32 tmp;
            tmp = CC_P_MASK( start_x );
            LWORDSWAP(tmp);
            dp[0] = OR(dp[0], (CC_DATYP) tmp );
        }

        /* degernated case, just one pixel */
        if (dx == 0) {
/*              printf(" <%d, %d>", SFX2I_T(x0), SFX2I(y0));    */
                return;
        }

#ifdef FORMAT_13_3 /* @RESO_UPGR */
        slope = (((fix32)(y1 - y0)) << L_SHIFT) / (x1 - x0);
#elif FORMAT_16_16
        /* "slope" needs to be in "LFX" format.
        */
        LongFixsMul((y1 - y0), (1L << L_SHIFT), dest1);
        slope = LongFixsDiv((x1 - x0), dest1);
#elif FORMAT_28_4
        LongFixsMul((y1 - y0), (1L << L_SHIFT), dest1);
        slope = LongFixsDiv((x1 - x0), dest1);
#endif
        nextp = SFX2LFX(y0);

        scans = SFX2I_T(x1) - start_x + 1;

        /* modify y_coord as x_coord truncates to pixel position */
        dx = I2SFX(start_x) - x0;
#ifdef FORMAT_13_3 /* @RESO_UPGR */
        nextp += (slope >> S_SHIFT) * dx;
#elif  FORMAT_16_16
        LongFixsMul(slope, dx, dest1);
        nextp += LongFixsDiv((1L << S_SHIFT), dest1);
#elif  FORMAT_28_4
        nextp += (slope >> S_SHIFT) * dx;
#endif

        /* special processing for the first pixel, use endpoint y0 */
/*      printf(" <%d, %d>", start_x, SFX2I(y0));        */
        last_y = SFX2I(y0);
        if (--scans == 0) return;

        /* Loop for each scan line in edge_table */
        x = (sfix_t)start_x;
        while(scans--) {
                /* get next position */
                nextp += slope;
                x++;

                y = LFX2I(nextp);
                delta_y = y - last_y;
                if(delta_y > 0) {
                     db += dw;
                }
                else if (delta_y < 0) {
                     db -= dw;
                }
                //NTFIX
                dp = db + x / CC_PIXEL_WORD;

                //NTFIX
                {
                   ufix16 tmp;
                   tmp = CC_P_MASK(x);
                   SWORDSWAP(tmp);
                   dp[0] = OR( dp[0], tmp );

                }

/*              printf(" <%d, %d> (%d)", x, y, delta_y); */
                last_y = y;
        }

    } else {        /*  |degree| > 45; y-coord major */
        fix     start_y;

/*      printf("Y-coord major\n");      */

        /*  swap for y0 <= y1  */
        if (y1 < y0) {
            sx = x1;
            x1 = x0;
            x0 = sx;
            sy = y1;
            y1 = y0;
            y0 = sy;
        }
#ifdef FORMAT_13_3 /* @RESO_UPGR */
        slope = (((fix32)(x1 - x0)) << L_SHIFT) / (y1 -y0);
#elif FORMAT_16_16
        /* "slope" needs to be in "LFX" format.
        */
        LongFixsMul((x1 - x0), (1L << L_SHIFT), dest1);
        slope = LongFixsDiv((y1 - y0), dest1);
#elif FORMAT_28_4
        LongFixsMul((x1 - x0), (1L << L_SHIFT), dest1);
        slope = LongFixsDiv((y1 - y0), dest1);
#endif
        nextp = SFX2LFX(x0);

        start_y = SFX2I(y0);
        scans = SFX2I(y1) - start_y + 1;

        /* modify x_coord as y_coord rounds to pixel position */
        dy = I2SFX(start_y) - y0;

#ifdef FORMAT_13_3 /* @RESO_UPGR */
        nextp += (slope >> S_SHIFT) * dy;
#elif  FORMAT_16_16
        LongFixsMul(slope, dy, dest1);
        nextp += LongFixsDiv((1L << S_SHIFT), dest1);
#elif  FORMAT_28_4
        nextp += (slope >> S_SHIFT) * dy;
#endif

        db = &((CC_DATYP FAR *) dst->bm_addr)[start_y * dw];
        pm = CC_P_MASK(SFX2I_T(x0));


        /* special processing for the first pixel, use endpoint x0 */
/*      printf(" <%d, %d>", SFX2I_T(x0), start_y);   */
        dp = &db[SFX2I_T(x0) / CC_PIXEL_WORD];

        //NTFIX
        {
           ufix16 tmp;
           tmp = CC_P_MASK(SFX2I_T(x0));
           SWORDSWAP(tmp);
           dp[0] = OR(dp[0],tmp);
        }

        if (--scans == 0) return;

        /* Loop for each scan line in edge_table */
        y = (sfix_t)start_y;
        while(scans--) {
                /* get next position */
                nextp += slope;
                db += dw;

                x = LFX2I_T(nextp);
                dp = &db[x / CC_PIXEL_WORD];

                //NTFIX
                {
                   ufix16 tmp;
                   tmp = CC_P_MASK(x);
                   SWORDSWAP( tmp );
                   dp[0] = OR(dp[0], tmp);

                }
/*              printf(" <%d, %d> (%d)", x, y, delta_x);     */
        }

    } /* if 45 degrees */

} /* gp_vector_c */


/* -----------------------------------------------------------------------
 * SCANLINE SIMULATION
 *
 * Programmed by : M.S Lin
 * Date : 5/24/1988
 *
 * Purpose
 *    Given scanline arrary, fill scanline into page buffer.
 *
 *       bb_addr
 *         +------- bb_width -----------+
 *         |                            |
 *         |                            |
 *         |    xs1   xe1  xs2  xe2     |
 *      1  |    =======    ======       | <--- ys_line
 *      2  |       =========            |
 *      .  |            .               |
 *      .  |            .           bb_heigh
 *      .  |            .               |
 * no_lines|      =====   ===   ===     |
 *         |                            |
 *         +----------------------------+
 *
 *
 *
 *    scanlist[]: horizontal lines may be followed scanlines.
 *       <xs1 xe1><xs2 xe2> ... 0x8000
 *       <xs1 xe1><xs2 xe2> ... 0x8000
 *              .
 *              .
 *              .
 *       <xs1 xe1><xs2 xe2> ... 0x8000
 *      [<yc xs xe>
 *       <yc xs xe>
 *              .
 *              .
 *              .
 *       <yc xs xe>]
 *       0x8000
 *
 *    History :
 *              1. 6-17-88  fix bug when loffset = 0, width > 16
 *                 change if(loffset && nwords) --> if(lmask && nwords).
 *              2. 8-12-88 change interface to consistant with Y.C Chen.
 *              3. 8-24-88 added code for horizontal lines process.
 *                 8-24-88 check bitmap boundary
 *
 * void            gp_scanline16(struct bitmap near *,
 *                               ufix16,
 *                               fix, fix, SCANLINE near *);
 * void            gp_scanline32(struct bitmap near *,
 *                               ufix16,
 *                               fix, fix, SCANLINE near *);
 *
 * -----------------------------------------------------------------------
 */

/* ************************************************************************
 *      gp_scanline16(): Filling into cache, solid filling only.
 *
 * ************************************************************************ */
void    gp_scanline16(dst_bmap, halftone, ys_line, no_lines, scanlist)
struct    bitmap        FAR *dst_bmap;
ufix16                  halftone;
fix                     ys_line, no_lines;
SCANLINE                FAR *scanlist;
{
register  fix       nwords;                     /* ufix -> fix  11-08-88 */
register  ufix16    huge *ptr;                  // FAR -> huge
register  SCANLINE  xs, xe;
register  fix       bb_width;
          ufix16    huge *scan_addr;            // FRA -> huge
register  ufix16    lmask, rmask;
          ufix16    sw;

#ifdef  DBG
    printf("scanline16: %6.6lx %4x %4x %4x\n",
           dst_bmap->bm_addr, halftone, ys_line, no_lines);
#endif

   /*
    * caculate 1st scanline starting address
    */
   bb_width = dst_bmap->bm_cols >> SHORTPOWER;
// scan_addr = (ufix16 FAR *)dst_bmap->bm_addr + (ys_line * bb_width); @WIN
   scan_addr = (ufix16 huge *)dst_bmap->bm_addr +
               ((DWORD)ys_line * (DWORD)bb_width);

   /*
    * Filling solid
    */

     while(no_lines-- >0) {
        /*
         * process segment by segment
         */
        while( (xs = *scanlist++) != (SCANLINE)END_OF_SCANLINE ) {
                /*
                 * process one segment in a scanline
                 * fill left partial word
                 * fill nwords full word
                 * fill right partial word
                 */
                xe = *scanlist++ + 1;
                sw = xs >> SHORTPOWER;
                ptr = scan_addr + sw;

                lmask = (ufix16) (ONE16 LSHIFT (xs & SHORTMASK)); //@WIN
                rmask = BRSHIFT((ufix16)ONE16,(BITSPERSHORT -(xe & SHORTMASK)),16); //@WIN
                nwords = (xe >> SHORTPOWER) - sw;

                // swapping for @WINFLOW
                SWORDSWAP(lmask);
                SWORDSWAP(rmask);

                if(nwords == 0) {
                   *ptr = *ptr | (lmask & rmask);
                   continue;
                }
                *ptr++ = *ptr | lmask;
                while(--nwords > 0)
                   *ptr++ = ONE16;
                *ptr = *ptr | rmask;

        }  /* while */

        /*
         * move scanline address to next line.
         */
        scan_addr += bb_width;

     } /* while */
} /* gp_scanline16 */

#ifdef WIN
/* ************************************************************************
 *      gp_scanline32_pfOR(): .OR. Pattern into FRame Buffer
 *
 *              Divide into 3 cases: SOLID(BLACK), WHITE, SOLID+HALFTONE.
 * ************************************************************************ */
void    gp_scanline32_pfOR(dst_bmap, halftone, ys_line, no_lines, scanlist)
struct    bitmap   FAR *dst_bmap;
ufix16    halftone;
fix       ys_line, no_lines;
SCANLINE  FAR *scanlist;
{

register  fix          nwords;                 /* ufix -> fix  11-08-88 */
register  ufix32       huge *ptr;               // FAR -> huge
register  ufix32       FAR *htb_ptr;
register  SCANLINE     xs, xe;
register  ufix32       bb_width;
          ufix32       huge *scan_addr;         // FAR -> huge
          ufix32       lmask, rmask;
          ufix32       FAR *htb_addr;
          ufix32       ht_lineoff;
          ufix32       hw, sw;
          fix          pf_lineoff;
          ufix32       FAR *pf_addr;
           extern       ufix32  PF_BASE[];

#ifdef  DBG
    printf("scanline32: %6.6lx %4x %4x %4x\n",
           dst_bmap->bm_addr, halftone, ys_line, no_lines);
#endif

   /*
    * caculate 1st scanline starting address
    */
   bb_width = dst_bmap->bm_cols >> WORDPOWER;
// scan_addr = (ufix32 FAR *)dst_bmap->bm_addr + (ys_line * bb_width); @WIN
   scan_addr = (ufix32 huge *)dst_bmap->bm_addr + ((DWORD)ys_line * bb_width);

   /* The pfill pattern is designed as a 32 * 16 bitamp.
    * If the size is changed, check the code again.
    */
   pf_lineoff = ys_line % PF_HEIGHT;
   pf_addr = (ufix32 FAR *)(PF_BASE + pf_lineoff *
                (PF_WIDTH >> WORDPOWER) );
#ifdef DBG
   printf("scanline32_pfOR(), bb_addr = %lx, no_lines = %x\n", bb_addr, no_lines);
#endif
   /*
    * divide into 3 cases (Apply halftone, Black, White),
    * process line by line.
    */
  if(halftone & HT_APPLY) {

     /*
      * case 1: apply halftone      F = (H & P) | (F & ~P)
      */
     ht_lineoff = ys_line % HT_HEIGH;
     hw = HT_WIDTH >> WORDPOWER;
     htb_addr = (ufix32 FAR *)HTB_BASE + (ht_lineoff * hw);

     while(no_lines-- >0) {
        ufix32  pf = *pf_addr;



        /*
         * process segment by segment
         */
        while( (xs = *scanlist++) != (SCANLINE)END_OF_SCANLINE ) {
                /*
                 * process one segment in a scanline
                 * fill left partial word
                 * fill nwords full word
                 * fill right partial word
                 */
                if(xs >= dst_bmap->bm_cols) {/* check bitmap boundary @WINFLOW*/
                   scanlist++;
                   continue;
                }
                xe = *scanlist++ + 1;

                if(xe > dst_bmap->bm_cols)   /* check bitmap boundary @WINFLOW*/
                   xe = (SCANLINE)dst_bmap->bm_cols;

                sw = xs >> WORDPOWER;
                ptr = scan_addr + sw;

                lmask = ONE32 LSHIFT (xs & WORDMASK);
                rmask = BRSHIFT(ONE32,(BITSPERWORD -(xe & WORDMASK)),32);

                // swapping for @WINFLOW
                LWORDSWAP(lmask);
                LWORDSWAP(rmask);

                nwords = (fix)((xe >> WORDPOWER) - sw);         //@WIN
              /*
               * apply halftone
               */
                htb_ptr = htb_addr + (xs >> WORDPOWER);

                if(nwords == 0) {
                   *ptr = (lmask & rmask &
                              ((*htb_ptr & pf) | (*ptr & ~pf)))
                          | (*ptr & ~(lmask & rmask));
                    continue;
                }
                *ptr++ = (lmask &
                             ((*htb_ptr++ & pf) | (*ptr & ~pf)))
                         | (*ptr & ~lmask);
                while(--nwords > 0)
                    *ptr++ = ((*htb_ptr++ & pf) | (*ptr & ~pf));
                *ptr = (rmask & ((*htb_ptr & pf) | (*ptr & ~pf)))
                       | (*ptr & ~rmask);
        }  /* while */
        /*
         * move halftone & scanline address to next line.
         */
        scan_addr += bb_width;
        if(++ht_lineoff == (ufix32)HT_HEIGH){   //@WIN
           htb_addr = (ufix32 FAR *)HTB_BASE;
           ht_lineoff = 0;
        }
        else
           htb_addr += hw;

        /*
         * move pfill pattern to next line.
         */
        if(++pf_lineoff == PF_HEIGHT){
           pf_addr = (ufix32 FAR *)PF_BASE;
           pf_lineoff = 0;
        }
        else
           pf_addr += PF_WIDTH >> WORDPOWER;
     } /* while */
  }
  else if(halftone == FC_BLACK || halftone == FC_SOLID)
  {
     /*
      * case 2: halftone pattern black      F = P | (F & ~P) = (P | F)
      */
     while(no_lines-- >0) {
        ufix32  pf = *pf_addr;
        /*
         * process segment by segment
         */
        while( (xs = *scanlist++) != (SCANLINE)END_OF_SCANLINE ) {
                /*
                 * process one segment in a scanline
                 * fill left partial word
                 * fill nwords full word
                 * fill right partial word
                 */
                if(xs >= dst_bmap->bm_cols) {    /* check bitmap boundary */
                   scanlist++;
                   continue;
                }
                xe = *scanlist++ + 1;

                if(xe > dst_bmap->bm_cols)       /* check bitmap boundary */
                   xe = (SCANLINE)dst_bmap->bm_cols;

                sw = xs >> WORDPOWER;
                ptr = scan_addr + sw;

                lmask = ONE32 LSHIFT (xs & WORDMASK);
                rmask = BRSHIFT(ONE32,(BITSPERWORD -(xe & WORDMASK)),32);

                // swapping for @WINFLOW
                LWORDSWAP(lmask);
                LWORDSWAP(rmask);

                nwords = (fix) ((xe >> WORDPOWER) - sw);        //@WIN
                if(nwords == 0) {
                   /* reduce this formula
                    * *ptr = ((lmask & rmask) & (*pf_addr | *ptr))
                    *        | (*ptr & ~(lmask & rmask));
                    */
                   *ptr = ((lmask & rmask) & pf) | *ptr;
                   continue;
                }
                /* reduce this formula
                 * *ptr = (lmask & (pf | *ptr)) | (*ptr & ~lmask);
                 */
                *ptr++  = (lmask & pf) | *ptr;
                while(--nwords > 0)
                  *ptr++ = (pf | *ptr);
                /* reduce this formula
                 * *ptr = (rmask & (*pf_addr | *ptr)) | (*ptr & ~rmask);
                 */
                *ptr = (rmask & pf) | *ptr;
        }  /* while */

        /*
         * move scanline address to next line.
         */
        scan_addr += bb_width;

        /*
         * move pfill pattern to next line.
         */
        if(++pf_lineoff == PF_HEIGHT){
           pf_addr = (ufix32 FAR *)PF_BASE;
           pf_lineoff = 0;
        }
        else
           pf_addr += PF_WIDTH >> WORDPOWER;
     } /* while */

  } /* if else */
  else
  {
     /*
      * case 3: halftone pattern white      F = (F & ~P)
      */
     while(no_lines-- >0) {
        ufix32  pf = ~*pf_addr;
        /*
         * process segment by segment
         */
        while( (xs = *scanlist++) != (SCANLINE)END_OF_SCANLINE ) {
                /*
                 * process one segment in a scanline
                 * fill left partial word
                 * fill nwords full word
                 * fill right partial word
                 */
                if(xs >= dst_bmap->bm_cols) {
                   scanlist++;
                   continue;
                }
                xe = *scanlist++ + 1;
                if(xe > dst_bmap->bm_cols)
                   xe = (SCANLINE)dst_bmap->bm_cols;

                sw = xs >> WORDPOWER;
                ptr = scan_addr + sw;

                lmask = ONE32 LSHIFT (xs & WORDMASK);
                rmask = BRSHIFT(ONE32,(BITSPERWORD -(xe & WORDMASK)),32);

                // swapping for @WINFLOW
                LWORDSWAP(lmask);
                LWORDSWAP(rmask);

                nwords = (fix) ((xe >> WORDPOWER) - sw);        //@WIN
                if(nwords == 0) {
                   *ptr = (*ptr & pf) | (*ptr & ~(lmask & rmask));
                   continue;
                }
                *ptr++ = (*ptr & pf) | (*ptr & ~lmask);
                while(--nwords > 0)
                  *ptr++ = *ptr & pf;
                *ptr = (*ptr & pf) | (*ptr & ~rmask);
        }  /* while */

        /*
         * move scanline address to next line.
         */
        scan_addr += bb_width;

        /*
         * move pfill pattern to next line.
         */
        if(++pf_lineoff == PF_HEIGHT){
           pf_addr = (ufix32 FAR *)PF_BASE;
           pf_lineoff = 0;
        }
        else
           pf_addr += PF_WIDTH >> WORDPOWER;
     } /* while */

  } /* else */
} /* gp_scanline32_pfOR */
/* ************************************************************************
 *      gp_scanline32_pfREP(): Filling Pattern into FRame Buffer
 *
 *              Divide into 3 cases: SOLID(BLACK), WHITE, SOLID+HALFTONE.
 * ************************************************************************ */
void    gp_scanline32_pfREP(dst_bmap, halftone, ys_line, no_lines, scanlist)
struct    bitmap   FAR *dst_bmap;
ufix16    halftone;
fix       ys_line, no_lines;
SCANLINE  FAR *scanlist;
{

register  fix          nwords;                 /* ufix -> fix  11-08-88 */
register  ufix32       huge *ptr;               // FAR -> huge
register  ufix32       FAR *htb_ptr;
register  SCANLINE     xs, xe;
register  ufix32       bb_width;
          ufix32       huge *scan_addr;         // FAR -> huge
          ufix32       lmask, rmask;
          ufix32       FAR *htb_addr;
          ufix32       ht_lineoff;
          ufix32       hw, sw;
          fix          pf_lineoff;
          ufix32       FAR *pf_addr;
           extern       ufix32  PF_BASE[];

#ifdef  DBG
    printf("scanline32: %6.6lx %4x %4x %4x\n",
           dst_bmap->bm_addr, halftone, ys_line, no_lines);
#endif

   /*
    * caculate 1st scanline starting address
    */
   bb_width = dst_bmap->bm_cols >> WORDPOWER;
// scan_addr = (ufix32 FAR *)dst_bmap->bm_addr + (ys_line * bb_width); @WIN
   scan_addr = (ufix32 huge *)dst_bmap->bm_addr + ((DWORD)ys_line * bb_width);

   /* The pfill pattern is designed as a 32 * 16 bitamp.
    * If the size is changed, check the code again.
    */
   pf_lineoff = ys_line % PF_HEIGHT;
   pf_addr = (ufix32 FAR *)(PF_BASE + pf_lineoff *
                (PF_WIDTH >> WORDPOWER) );
#ifdef DBG
   printf("scanline32_pfREP(), bb_addr = %lx, no_lines = %x\n", bb_addr, no_lines);
#endif
   /*
    * divide into 3 cases (Apply halftone, Black, White),
    * process line by line.
    */
  if(halftone & HT_APPLY) {

     /*
      * case 1: apply halftone      F = H & P
      */
     ht_lineoff = ys_line % HT_HEIGH;
     hw = HT_WIDTH >> WORDPOWER;
     htb_addr = (ufix32 FAR *)HTB_BASE + (ht_lineoff * hw);

     while(no_lines-- >0) {
        ufix32  pf = *pf_addr;
        /*
         * process segment by segment
         */
        while( (xs = *scanlist++) != (SCANLINE)END_OF_SCANLINE ) {
                /*
                 * process one segment in a scanline
                 * fill left partial word
                 * fill nwords full word
                 * fill right partial word
                 */
                if(xs >= dst_bmap->bm_cols) {/* check bitmap boundary @WINFLOW*/
                   scanlist++;
                   continue;
                }
                xe = *scanlist++ + 1;

                if(xe > dst_bmap->bm_cols)   /* check bitmap boundary @WINFLOW*/
                   xe = (SCANLINE)dst_bmap->bm_cols;

                sw = xs >> WORDPOWER;
                ptr = scan_addr + sw;

                lmask = ONE32 LSHIFT (xs & WORDMASK);
                rmask = BRSHIFT(ONE32,(BITSPERWORD -(xe & WORDMASK)),32);

                // swapping for @WINFLOW
                LWORDSWAP(lmask);
                LWORDSWAP(rmask);

                nwords = (fix)((xe >> WORDPOWER) - sw);         //@WIN
              /*
               * apply halftone
               */
                htb_ptr = htb_addr + (xs >> WORDPOWER);

                if(nwords == 0) {
                   *ptr = (lmask & rmask & *htb_ptr & pf)
                          | (*ptr & ~(lmask & rmask));
                    continue;
                }
                *ptr++ = (lmask & *htb_ptr++ & pf) | (*ptr & ~lmask);
                while(--nwords > 0)
                    *ptr++ = *htb_ptr++ & pf;
                *ptr = (rmask & *htb_ptr & pf) | (*ptr & ~rmask);
        }  /* while */
        /*
         * move halftone & scanline address to next line.
         */
        scan_addr += bb_width;
        if(++ht_lineoff == (ufix32)HT_HEIGH){   //@WIN
           htb_addr = (ufix32 FAR *)HTB_BASE;
           ht_lineoff = 0;
        }
        else
           htb_addr += hw;

        /*
         * move pfill pattern to next line.
         */
        if(++pf_lineoff == PF_HEIGHT){
           pf_addr = (ufix32 FAR *)PF_BASE;
           pf_lineoff = 0;
        }
        else
           pf_addr += PF_WIDTH >> WORDPOWER;
     } /* while */
  }
  else if(halftone == FC_BLACK || halftone == FC_SOLID)
  {
     /*
      * case 2: halftone pattern black      F = P
      */
     while(no_lines-- >0) {
        ufix32  pf = *pf_addr;
        /*
         * process segment by segment
         */
        while( (xs = *scanlist++) != (SCANLINE)END_OF_SCANLINE ) {
                /*
                 * process one segment in a scanline
                 * fill left partial word
                 * fill nwords full word
                 * fill right partial word
                 */
                if(xs >= dst_bmap->bm_cols) {    /* check bitmap boundary */
                   scanlist++;
                   continue;
                }
                xe = *scanlist++ + 1;

                if(xe > dst_bmap->bm_cols)       /* check bitmap boundary */
                   xe = (SCANLINE)dst_bmap->bm_cols;

                sw = xs >> WORDPOWER;
                ptr = scan_addr + sw;

                lmask = ONE32 LSHIFT (xs & WORDMASK);
                rmask = BRSHIFT(ONE32,(BITSPERWORD -(xe & WORDMASK)),32);

                // swapping for @WINFLOW
                LWORDSWAP(lmask);
                LWORDSWAP(rmask);

                nwords = (fix) ((xe >> WORDPOWER) - sw);        //@WIN
                if(nwords == 0) {
                   *ptr = (lmask & rmask & pf) | (*ptr & ~(lmask & rmask));
                   continue;
                }
                *ptr++ = (lmask & pf) | (*ptr & ~lmask);
                while(--nwords > 0)
                  *ptr++ = pf;
                *ptr = (rmask & pf) | (*ptr & ~rmask);
        }  /* while */

        /*
         * move scanline address to next line.
         */
        scan_addr += bb_width;

        /*
         * move pfill pattern to next line.
         */
        if(++pf_lineoff == PF_HEIGHT){
           pf_addr = (ufix32 FAR *)PF_BASE;
           pf_lineoff = 0;
        }
        else
           pf_addr += PF_WIDTH >> WORDPOWER;
     } /* while */

  } /* if else */
/* in order to reduce code size, call normal eofill/fill to achieve it
 *else {
 *   (*
 *    * case 3: halftone pattern white      F = 0
 *    *)
 *              :
 *              :
 *}
 */
} /* gp_scanline32_pfREP */

#endif

/* ************************************************************************
 *      gp_scanline32(): Filling into FRame Buffer, CMB or Seed
 *
 *              Divide into 3 cases: SOLID(BLACK), WHITE, SOLID+HALFTONE.
 * ************************************************************************ */
void    gp_scanline32(dst_bmap, halftone, ys_line, no_lines, scanlist)
struct    bitmap   FAR *dst_bmap;
ufix16    halftone;
fix       ys_line, no_lines;
SCANLINE  FAR *scanlist;
{

register  fix          nwords;                 /* ufix -> fix  11-08-88 */
register  ufix32       huge *ptr;               // FAR -> huge
register  ufix32       FAR *htb_ptr;
register  SCANLINE     xs, xe;
register  ufix32       bb_width;
          ufix32       huge *scan_addr;         // FAR -> huge
          ufix32       lmask, rmask;
          ufix32       FAR *htb_addr;
          ufix32       ht_lineoff;
          ufix32       hw, sw;

#ifdef  DBG
    printf("scanline32: %6.6lx %4x %4x %4x\n",
           dst_bmap->bm_addr, halftone, ys_line, no_lines);
#endif

   /*
    * caculate 1st scanline starting address
    */
   bb_width = dst_bmap->bm_cols >> WORDPOWER; //Note: bm_cols should be in long
                                              //      word boundary @WINFLOW
// scan_addr = (ufix32 *)dst_bmap->bm_addr + (ys_line * bb_width);
   scan_addr = (ufix32 huge *)dst_bmap->bm_addr + ((DWORD)ys_line * bb_width);

#ifdef DBG
   printf("scanline32(), bb_addr = %lx, no_lines = %x\n", bb_addr, no_lines);
#endif
   /*
    * divide into 3 cases (Apply halftone, Black, White),
    * process line by line.
    */
  if(halftone & HT_APPLY) {

     /*
      * case 1: apply halftone
      */
     ht_lineoff = ys_line % HT_HEIGH;
     hw = HT_WIDTH >> WORDPOWER;
     htb_addr = (ufix32 FAR *)HTB_BASE + (ht_lineoff * hw);


     while(no_lines-- >0) {

        /*
         * process segment by segment
         */
        while( (xs = *scanlist++) != (SCANLINE)END_OF_SCANLINE ) {
                /*
                 * process one segment in a scanline
                 * fill left partial word
                 * fill nwords full word
                 * fill right partial word
                 */
                if(xs >= dst_bmap->bm_cols) {/* check bitmap boundary @WINFLOW*/
                   scanlist++;
                   continue;
                }
                xe = *scanlist++ + 1;

                if(xe > dst_bmap->bm_cols)   /* check bitmap boundary @WINFLOW*/
                   xe = (SCANLINE)dst_bmap->bm_cols;

                sw = xs >> WORDPOWER;
                ptr = scan_addr + sw;

                lmask = ONE32 LSHIFT (xs & WORDMASK);
                rmask = BRSHIFT(ONE32,(BITSPERWORD -(xe & WORDMASK)),32);

                // swapping for @WINFLOW
                LWORDSWAP(lmask);
                LWORDSWAP(rmask);

                nwords = (fix)((xe >> WORDPOWER) - sw);         //@WIN
              /*
               * apply halftone
               */
                htb_ptr = htb_addr + (xs >> WORDPOWER);

                if(nwords == 0) {
                   *ptr = (*ptr & ~(lmask&rmask)) | (lmask & rmask & *htb_ptr);
                    continue;
                }
                *ptr++ = (*ptr & ~lmask) | (lmask & *htb_ptr++);
                while(--nwords > 0)
                    *ptr++ = *htb_ptr++;
                *ptr = (*ptr & ~rmask) | (rmask & *htb_ptr);
        }  /* while */
        /*
         * move halftone & scanline address to next line.
         */
        scan_addr += bb_width;
        if(++ht_lineoff == (ufix32)HT_HEIGH){   //@WIN
           htb_addr = (ufix32 FAR *)HTB_BASE;
           ht_lineoff = 0;
        }
        else
           htb_addr += hw;

     } /* while */
  }
  else if(halftone == FC_BLACK || halftone == FC_SOLID)
  {
     /*
      * case 2: halftone pattern black
      */
     while(no_lines-- >0) {
        /*
         * process segment by segment
         */
        while( (xs = *scanlist++) != (SCANLINE)END_OF_SCANLINE ) {
                /*
                 * process one segment in a scanline
                 * fill left partial word
                 * fill nwords full word
                 * fill right partial word
                 */
                if(xs >= dst_bmap->bm_cols) {    /* check bitmap boundary */
                   scanlist++;
                   continue;
                }
                xe = *scanlist++ + 1;

                if(xe > dst_bmap->bm_cols)       /* check bitmap boundary */
                   xe = (SCANLINE)dst_bmap->bm_cols;

                sw = xs >> WORDPOWER;
                ptr = scan_addr + sw;

                lmask = ONE32 LSHIFT (xs & WORDMASK);
                rmask = BRSHIFT(ONE32,(BITSPERWORD -(xe & WORDMASK)),32);

                // swapping for @WINFLOW
                LWORDSWAP(lmask);
                LWORDSWAP(rmask);

                nwords = (fix) ((xe >> WORDPOWER) - sw);        //@WIN
                if(nwords == 0) {
                   *ptr = *ptr | (lmask & rmask);
                   continue;
                }
                *ptr++ = *ptr | lmask;
                while(--nwords > 0)
                  *ptr++ = ONE32;
                *ptr = *ptr | rmask;
        }  /* while */

        /*
         * move scanline address to next line.
         */
        scan_addr += bb_width;
     } /* while */

  } /* if else */
  else
  {
     /*
      * case 3: halftone pattern white
      */
     while(no_lines-- >0) {

        /*
         * process segment by segment
         */
        while( (xs = *scanlist++) != (SCANLINE)END_OF_SCANLINE ) {
                /*
                 * process one segment in a scanline
                 * fill left partial word
                 * fill nwords full word
                 * fill right partial word
                 */
                if(xs >= dst_bmap->bm_cols) {
                   scanlist++;
                   continue;
                }
                xe = *scanlist++ + 1;
                if(xe > dst_bmap->bm_cols)
                   xe = (SCANLINE)dst_bmap->bm_cols;

                sw = xs >> WORDPOWER;
                ptr = scan_addr + sw;

                lmask = ONE32 LSHIFT (xs & WORDMASK);
                rmask = BRSHIFT(ONE32,(BITSPERWORD -(xe & WORDMASK)),32);

                // swapping for @WINFLOW
                LWORDSWAP(lmask);
                LWORDSWAP(rmask);

                nwords = (fix) ((xe >> WORDPOWER) - sw);        //@WIN
                if(nwords == 0) {
                   *ptr = *ptr & ~(lmask & rmask);
                   continue;
                }
                *ptr++ = *ptr & ~lmask;
                while(--nwords > 0)
                  *ptr++ = ZERO;
                *ptr = *ptr & ~rmask;
        }  /* while */

        /*
         * move scanline address to next line.
         */
        scan_addr += bb_width;

     } /* while */

  } /* else */
} /* gp_scanline32 */

void
ImageClear(type)
ufix32     type;                        /* fix => ufix32 @WIN */
{
#ifdef  DUMBO
        ufix32  huge *ptr;
#else
        ufix32  FAR *ptr;       // @DLL
#endif
        fix32   size, size8;

#ifdef DBG1
   printf("ImageClear() : %lx, %lx\n", FB_ADDR, FB_WIDTH);
#endif
#ifndef  DUMBO
//DJC need this for multi page support so frame buffer will clear        return;               /* @WINFLOW; force to do nothing */

        ptr = (ufix32 FAR *)FB_ADDR;
        size = FB_HEIGH * (FB_WIDTH >> 5);
#else
        ptr = (ufix32 huge *)FB_ADDR;                           // @DLL
        size = (DWORD)FB_HEIGH * (DWORD)(FB_WIDTH >> 5);        // @DLL
#endif

        size8 = size >> 3;
        if (type == BM_WHITE) {
           while(size8--) {
              *ptr++ = 0L;
              *ptr++ = 0L;
              *ptr++ = 0L;
              *ptr++ = 0L;
              *ptr++ = 0L;
              *ptr++ = 0L;
              *ptr++ = 0L;
              *ptr++ = 0L;
           }
           size8 = size & 0x7;
           while(size8--)
              *ptr++ = 0L;
        } else {
           while(size8--) {
              *ptr++ = 0xffffffffL;
              *ptr++ = 0xffffffffL;
              *ptr++ = 0xffffffffL;
              *ptr++ = 0xffffffffL;
              *ptr++ = 0xffffffffL;
              *ptr++ = 0xffffffffL;
              *ptr++ = 0xffffffffL;
              *ptr++ = 0xffffffffL;
           }
           size8 = size & 0x7;
           while(size8--)
              *ptr++ = 0xffffffffL;
        }
}

/* Following code added for stroke enhancement  -jwm, 3/18/91, -begin- */

static ufix32 l_mask32[32] = {
        0xFFFFFFFF, 0x7FFFFFFF, 0x3FFFFFFF, 0x1FFFFFFF,
        0x0FFFFFFF, 0x07FFFFFF, 0x03FFFFFF, 0x01FFFFFF,
        0x00FFFFFF, 0x007FFFFF, 0x003FFFFF, 0x001FFFFF,
        0x000FFFFF, 0x0007FFFF, 0x0003FFFF, 0x0001FFFF,
        0x0000FFFF, 0x00007FFF, 0x00003FFF, 0x00001FFF,
        0x00000FFF, 0x000007FF, 0x000003FF, 0x000001FF,
        0x000000FF, 0x0000007F, 0x0000003F, 0x0000001F,
        0x0000000F, 0x00000007, 0x00000003, 0x00000001
        };

static ufix32 r_mask32[32] = {
        0x00000000, 0x80000000, 0xC0000000, 0xE0000000,
        0xF0000000, 0xF8000000, 0xFC000000, 0xFE000000,
        0xFF000000, 0xFF800000, 0xFFC00000, 0xFFE00000,
        0xFFF00000, 0xFFF80000, 0xFFFC0000, 0xFFFE0000,
        0xFFFF0000, 0xFFFF8000, 0xFFFFC000, 0xFFFFE000,
        0xFFFFF000, 0xFFFFF800, 0xFFFFFC00, 0xFFFFFE00,
        0xFFFFFF00, 0xFFFFFF80, 0xFFFFFFC0, 0xFFFFFFE0,
        0xFFFFFFF0, 0xFFFFFFF8, 0xFFFFFFFC, 0xFFFFFFFE
        };



void do_fill_box (ul_coord, lr_coord)
struct coord_i FAR *ul_coord, FAR *lr_coord;
{
    ufix32      FAR *fb_ptr, FAR *fb_addr, FAR *htb_ptr, FAR *htb_addr;
    ufix32      left_mask, right_mask;
    fix16       current_y, bottom_y, nwords, word_ctr;
    fix16       left_x, right_x, left_word, fb_words, ht_words, ht_lineoff;

    if (HTP_Flag == HT_CHANGED) {                    /* jwm, 1/30/91 */
        HTP_Flag =  HT_UPDATED;
        expand_halftone();
        }

    current_y = SFX2I(ul_coord->y);
/*    current_y = SFX2I_T(ul_coord->y); */

/*    bottom_y = SFX2I(lr_coord->y);    */
    bottom_y = SFX2I_T(lr_coord->y);

    left_x = SFX2I(ul_coord->x);
/*    left_x = SFX2I_T(ul_coord->x);    */
    left_word = left_x >> WORDPOWER;
    right_x = SFX2I(lr_coord->x);

    fb_addr = (ufix32 FAR *) (FB_ADDR + current_y * (FB_WIDTH >> 3)) + left_word;
    fb_words = FB_WIDTH >> WORDPOWER;

    left_mask = l_mask32[left_x & WORDMASK];

    right_mask = r_mask32[right_x & WORDMASK];

    nwords = (right_x >> WORDPOWER) - left_word;
/*  fb_marked = TRUE;    * 5-7-91, Jack */

    if (HTP_Type == HT_MIXED) {
        ht_lineoff = current_y % HT_HEIGH;
        htb_addr = (ufix32 FAR *)(HTB_BASE + ht_lineoff * (HT_WIDTH >> 3)) + left_word;
        ht_words = HT_WIDTH >> WORDPOWER;

        for ( ; current_y <= bottom_y; current_y++) {
            fb_ptr = fb_addr;
            htb_ptr = htb_addr;
            word_ctr = nwords;
            if (!word_ctr) {
                left_mask = left_mask & right_mask;
                *fb_ptr = (*htb_ptr & left_mask) | (*fb_ptr & ~left_mask);
                }
            else {
                *fb_ptr = (*htb_ptr & left_mask) | (*fb_ptr & ~left_mask);
                ++fb_ptr;
                ++htb_ptr;
                while (--word_ctr > 0)
                    *fb_ptr++ = *htb_ptr++;
                *fb_ptr = (*htb_ptr & right_mask) | (*fb_ptr & ~right_mask);
                }

            fb_addr += fb_words;
            if (++ht_lineoff == HT_HEIGH) {
                htb_addr = (ufix32 FAR *)HTB_BASE + left_word;
                ht_lineoff = 0;
                }
            else
                htb_addr += ht_words;
            }
        }

    else if ((FC_Paint == FC_BLACK) || (FC_Paint == FC_SOLID)) {
        for ( ; current_y <= bottom_y; current_y++) {
            fb_ptr = fb_addr;

            word_ctr = nwords;
            if (!word_ctr) {
                left_mask = left_mask & right_mask;
                *fb_ptr = (left_mask) | (*fb_ptr & ~left_mask);
                }
            else {
                *fb_ptr = left_mask | (*fb_ptr & ~left_mask);
                ++fb_ptr;
                while (--word_ctr > 0)
                    *fb_ptr++ = ONE32;
                *fb_ptr = right_mask | (*fb_ptr & ~right_mask);
                }

            fb_addr += fb_words;
            }
        }

    else {
        for ( ; current_y <= bottom_y; current_y++) {
            fb_ptr = fb_addr;
            word_ctr = nwords;
            if (!word_ctr) {
                *fb_ptr = *fb_ptr & ~(left_mask & right_mask);
                }
            else {
                *fb_ptr = *fb_ptr & ~left_mask;
                ++fb_ptr;
                while (--word_ctr > 0)
                    *fb_ptr++ = 0;
                *fb_ptr = *fb_ptr & ~right_mask;
                }

            fb_addr += fb_words;
            }
        }
}

void do_fill_rect (rect1)
struct line_seg_i FAR *rect1;
{
#ifdef  _AM29K
    volatile
#endif
    lfix_t  lx_incr, rx_incr;
    register    ufix32  FAR *fb_ptr;
    register    fix     current_y;
    register    fix16   current_lx, current_rx;
    fix         critical_y0, critical_y1, critical_y2, bottom_y;
    fix16       adj_lx0, adj_lx1, adj_rx0, adj_rx1;
    lfix_t      lx_intercept, rx_intercept, left_x, left_y, right_x, right_y, frac_y;
    lfix_t      lx_step0, lx_step1, lx_step2, rx_step0, rx_step1, rx_step2;
    lfix_t      critical_lx0, critical_lx1, critical_lx2;
    lfix_t      critical_rx0, critical_rx1, critical_rx2;
    lfix_t      abs_dx, abs_dy, slope1, slope2, tmp_l1, tmp_l2, tmp_l3, tmp_l4, tmp_l5;
    ufix32      FAR *fb_addr, FAR *htb_addr, FAR *htb_ptr;
    ufix32      left_mask, right_mask;
    fix16       left_word, fb_words, ht_words, ht_lineoff, nwords;
    byte        adjust_right, adjust_left;

    if (rect1->p0.x <= rect1->p1.x) {
        left_x = SFX2LFX(rect1->p0.x);
        left_y = SFX2LFX(rect1->p0.y);
        right_x = SFX2LFX(rect1->p1.x);
        right_y = SFX2LFX(rect1->p1.y);
        }
    else {
        left_x = SFX2LFX(rect1->p1.x);
        left_y = SFX2LFX(rect1->p1.y);
        right_x = SFX2LFX(rect1->p0.x);
        right_y = SFX2LFX(rect1->p0.y);
        }

    if ((abs_dx = SFX2LFX(rect1->vct_d.x)) < 0)
        abs_dx = -abs_dx;
    if ((abs_dy = SFX2LFX(rect1->vct_d.y)) < 0)
        abs_dy = -abs_dy;

    tmp_l1 = abs_dy << 1;
    tmp_l4 = right_x - left_x;

    if ((tmp_l3 = left_y - right_y) < 0) {
        tmp_l3 = -tmp_l3;
        slope1 = FixDiv(tmp_l3, tmp_l4);
        slope2 = FixDiv(tmp_l4, tmp_l3);

/*      lx_step[0] = -slope1;
 *      rx_step[0] = slope2;
 */

        lx_intercept = rx_intercept = left_x + abs_dx;
        tmp_l2 = left_y - abs_dy;
        current_y = LFX2I(tmp_l2);

        tmp_l4 = right_y + abs_dy;
        critical_y2 = LFX2I(tmp_l4) + 1;
        critical_lx2 = critical_rx2 = right_x - abs_dx;
        if (tmp_l1 <= tmp_l3) {

            critical_y0 = LFX2I(left_y + abs_dy);
            critical_y1 = LFX2I(right_y - abs_dy);
            critical_lx0 = left_x - abs_dx;
            critical_rx0 = left_x + abs_dx + FixMul(slope2,tmp_l1);
            adj_lx0 = *((fix16 FAR *)(&critical_lx0));

            tmp_l3 -= tmp_l1;
            critical_lx1 = left_x - abs_dx + FixMul(slope2,tmp_l3);
            critical_rx1 = right_x + abs_dx;
            adj_lx1 = *((fix16 FAR *)(&critical_lx1));
            adj_rx1 = *((fix16 FAR *)(&critical_rx1));

/*          lx_step[1] = slope2;
 *          rx_step[1] = slope2;
 *          lx_step[2] = slope2;
 *          rx_step[2] = -slope1;
 */
/*  Recalculation of lx_steps & rx_steps for pixel-by-pixel compatibility w/gp_scanconv */
            tmp_l5 = tmp_l1 >> 13;
            if (!tmp_l5) {
                lx_step0 = rx_step0 = 0;
                }
            else {
                lx_step0 = ((critical_lx0 - lx_intercept) << 3) / tmp_l5;
                rx_step0 = ((critical_rx0 - rx_intercept) << 3) / tmp_l5;
                }

            tmp_l5 = (right_y - left_y - tmp_l1) >> 13;
            if (!tmp_l5) {
                lx_step1 = rx_step1 = 0;
                }
            else {
                lx_step1 = ((critical_lx1 - critical_lx0) << 3) / tmp_l5;
                rx_step1 = ((critical_rx1 - critical_rx0) << 3) / tmp_l5;
                }

            tmp_l5 = tmp_l1 >> 13;
            if (!tmp_l5) {
                lx_step2 = rx_step2 = 0;
                }
            else {
                lx_step2 = ((critical_lx2 - critical_lx1) << 3) / tmp_l5;
                rx_step2 = ((critical_rx2 - critical_rx1) << 3) / tmp_l5;
                }

            if (critical_y0 == critical_y1) {
                adj_rx0 = *((fix16 FAR *)(&critical_rx0));
                }
            else {
                frac_y = I2LFX(critical_y0) - left_y - abs_dy;
                critical_lx0 += FixMul(lx_step1,frac_y);
                critical_rx0 += FixMul(rx_step1,frac_y);
                critical_lx0 -= (lx_step1 >> 1);
                critical_rx0 += (rx_step1 >> 1);
                adj_rx0 = *((fix16 FAR *)(&critical_rx0));
                }

            if (critical_y2 - critical_y1 > 2) {
                frac_y = I2LFX(critical_y1) - right_y + abs_dy;
                critical_lx1 += FixMul(lx_step2,frac_y);
                critical_rx1 += FixMul(rx_step2,frac_y);
                critical_lx1 -= (lx_step2 >> 1);
                critical_rx1 -= (rx_step2 >> 1);
                }

            adjust_left = 1;
            adjust_right = 0;

            }
        else {

            critical_y0 = LFX2I(right_y - abs_dy);
            critical_y1 = LFX2I(left_y + abs_dy);
            critical_lx0 = left_x + abs_dx - FixMul(slope1,tmp_l3);
            critical_rx0 = right_x + abs_dx;
            adj_rx0 = *((fix16 FAR *)(&critical_rx0));

            tmp_l3 = tmp_l1 - tmp_l3;
            critical_lx1 = left_x - abs_dx;
            critical_rx1 = right_x + abs_dx - FixMul(slope1,tmp_l3);
            adj_lx1 = *((fix16 FAR *)(&critical_lx1));
            adj_rx1 = *((fix16 FAR *)(&critical_rx1));

/*          lx_step[1] = -slope1;
 *          rx_step[1] = -slope1;
 *          lx_step[2] = slope2;
 *          rx_step[2] = -slope1;
 */
/*  Recalculation of lx_steps & rx_steps for pixel-by-pixel compatibility w/gp_scanconv */
            tmp_l5 = (right_y - left_y) >> 13;
            if (!tmp_l5) {
                lx_step0 = rx_step0 = 0;
                }
            else {
                lx_step0 = ((critical_lx0 - lx_intercept) << 3) / tmp_l5;
                rx_step0 = ((critical_rx0 - rx_intercept) << 3) / tmp_l5;
                }

            tmp_l5 = (left_y - right_y + tmp_l1) >> 13;
            if (!tmp_l5) {
                lx_step1 = rx_step1 = 0;
                }
            else {
                lx_step1 = ((critical_lx1 - critical_lx0) << 3) / tmp_l5;
                rx_step1 = ((critical_rx1 - critical_rx0) << 3) / tmp_l5;
                }

            tmp_l5 = (right_y - left_y) >> 13;
            if (!tmp_l5) {
                lx_step2 = rx_step2 = 0;
                }
            else {
                lx_step2 = ((critical_lx2 - critical_lx1) << 3) / tmp_l5;
                rx_step2 = ((critical_rx2 - critical_rx1) << 3) / tmp_l5;
                }

            if (critical_y0 == critical_y1) {
                adj_lx0 = *((fix16 FAR *)(&critical_lx0));
                }
            else {
                frac_y = I2LFX(critical_y0) - right_y + abs_dy;
                critical_lx0 += FixMul(lx_step1,frac_y);
                critical_rx0 += FixMul(rx_step1,frac_y);
                critical_lx0 += (lx_step1 >> 1);
                critical_rx0 -= (rx_step1 >> 1);
                adj_lx0 = *((fix16 FAR *)(&critical_lx0));
                }

            if (critical_y2 - critical_y1 > 2) {
                frac_y = I2LFX(critical_y1) - left_y - abs_dy;
                critical_lx1 += FixMul(lx_step2,frac_y);
                critical_rx1 += FixMul(rx_step2,frac_y);
                critical_lx1 -= (lx_step2 >> 1);
                critical_rx1 -= (rx_step2 >> 1);
                }

            adjust_left = 0;
            adjust_right = 1;

            }
        }
    else {

        slope1 = FixDiv(tmp_l3, tmp_l4);
        slope2 = FixDiv(tmp_l4, tmp_l3);

/*      lx_step[0] = -slope2;
 *      rx_step[0] = slope1;
 */

        lx_intercept = rx_intercept = right_x - abs_dx;
        tmp_l2 = right_y - abs_dy;
        current_y = LFX2I(tmp_l2);

        tmp_l4 = left_y + abs_dy;
        critical_y2 = LFX2I(tmp_l4) + 1;
        critical_lx2 = critical_rx2 = left_x + abs_dx;
        if (tmp_l1 <= tmp_l3) {

            critical_y0 = LFX2I(right_y + abs_dy);
            critical_y1 = LFX2I(left_y - abs_dy);
            critical_lx0 = right_x - abs_dx - FixMul(slope2,tmp_l1);
            critical_rx0 = right_x + abs_dx;
            adj_rx0 = *((fix16 FAR *)(&critical_rx0));

            tmp_l3 -= tmp_l1;
            critical_lx1 = left_x - abs_dx;
            critical_rx1 = right_x + abs_dx - FixMul(slope2,tmp_l3);
            adj_lx1 = *((fix16 FAR *)(&critical_lx1));
            adj_rx1 = *((fix16 FAR *)(&critical_rx1));

/*          lx_step[1] = -slope2;
 *          rx_step[1] = -slope2;
 *          lx_step[2] = slope1;
 *          rx_step[2] = -slope2;
 */
/*  Recalculation of lx_steps & rx_steps for pixel-by-pixel compatibility w/gp_scanconv */
            tmp_l5 = tmp_l1 >> 13;
            if (!tmp_l5) {
                lx_step0 = rx_step0 = 0;
                }
            else {
                lx_step0 = ((critical_lx0 - lx_intercept) << 3) / tmp_l5;
                rx_step0 = ((critical_rx0 - rx_intercept) << 3) / tmp_l5;
                }

            tmp_l5 = (left_y - right_y - tmp_l1) >> 13;
            if (!tmp_l5) {
                lx_step1 = rx_step1 = 0;
                }
            else {

                lx_step1 = ((critical_lx1 - critical_lx0) << 3) / tmp_l5;
                rx_step1 = ((critical_rx1 - critical_rx0) << 3) / tmp_l5;
                }

            tmp_l5 = tmp_l1 >> 13;
            if (!tmp_l5) {
                lx_step2 = rx_step2 = 0;
                }
            else {

                lx_step2 = ((critical_lx2 - critical_lx1) << 3) / tmp_l5;
                rx_step2 = ((critical_rx2 - critical_rx1) << 3) / tmp_l5;
                }

            if (critical_y0 == critical_y1) {
                adj_lx0 = *((fix16 FAR *)(&critical_lx0));
                }
            else {
                frac_y = I2LFX(critical_y0) - right_y - abs_dy;
                critical_lx0 += FixMul(lx_step1,frac_y);
                critical_rx0 += FixMul(rx_step1,frac_y);
                critical_lx0 += (lx_step1 >> 1);
                critical_rx0 -= (rx_step1 >> 1);
                adj_lx0 = *((fix16 FAR *)(&critical_lx0));
                }

            if (critical_y2 - critical_y1 > 2) {
                frac_y = I2LFX(critical_y1) - left_y + abs_dy;
                critical_lx1 += FixMul(lx_step2,frac_y);
                critical_rx1 += FixMul(rx_step2,frac_y);
                critical_lx1 -= (lx_step2 >> 1);
                critical_rx1 -= (rx_step2 >> 1);
                }

            adjust_left = 0;
            adjust_right = 1;

            }
        else {

            critical_y0 = LFX2I(left_y - abs_dy);
            critical_y1 = LFX2I(right_y + abs_dy);
            critical_lx0 = left_x - abs_dx;
            critical_rx0 = right_x - abs_dx + FixMul(slope1,tmp_l3);
            adj_lx0 = *((fix16 FAR *)(&critical_lx0));

            tmp_l3 = tmp_l1 - tmp_l3;
            critical_lx1 = left_x - abs_dx + FixMul(slope1,tmp_l3);
            critical_rx1 = right_x + abs_dx;
            adj_lx1 = *((fix16 FAR *)(&critical_lx1));
            adj_rx1 = *((fix16 FAR *)(&critical_rx1));

/*          lx_step[1] = slope1;
 *          rx_step[1] = slope1;
 *          lx_step[2] = slope1;
 *          rx_step[2] = -slope2;
 */
/*  Recalculation of lx_steps & rx_steps for pixel-by-pixel compatibility w/gp_scanconv */
            tmp_l5 = (left_y - right_y) >> 13;
            if (!tmp_l5) {
                lx_step0 = rx_step0 = 0;
                }
            else {
                lx_step0 = ((critical_lx0 - lx_intercept) << 3) / tmp_l5;
                rx_step0 = ((critical_rx0 - rx_intercept) << 3) / tmp_l5;
                }

            tmp_l5 = (right_y - left_y + tmp_l1) >> 13;
            if (!tmp_l5) {
                lx_step1 = rx_step1 = 0;
                }
            else {
                lx_step1 = ((critical_lx1 - critical_lx0) << 3) / tmp_l5;
                rx_step1 = ((critical_rx1 - critical_rx0) << 3) / tmp_l5;
                }

            tmp_l5 = (left_y - right_y) >> 13;
            if (!tmp_l5) {
                lx_step2 = rx_step2 = 0;
                }
            else {
                lx_step2 = ((critical_lx2 - critical_lx1) << 3) / tmp_l5;
                rx_step2 = ((critical_rx2 - critical_rx1) << 3) / tmp_l5;
                }


            if (critical_y0 == critical_y1) {
                adj_rx0 = *((fix16 FAR *)(&critical_rx0));
                }
            else {
                frac_y = I2LFX(critical_y0) - left_y + abs_dy;
                critical_lx0 += FixMul(lx_step1,frac_y);
                critical_rx0 += FixMul(rx_step1,frac_y);
                critical_lx0 -= (lx_step1 >> 1);
                critical_rx0 += (rx_step1 >> 1);
                adj_rx0 = *((fix16 FAR *)(&critical_rx0));
                }

            if (critical_y2 - critical_y1 > 2) {
                frac_y = I2LFX(critical_y1) - right_y - abs_dy;
                critical_lx1 += FixMul(lx_step2,frac_y);
                critical_rx1 += FixMul(rx_step2,frac_y);
                critical_lx1 -= (lx_step2 >> 1);
                critical_rx1 -= (rx_step2 >> 1);
                }

            adjust_left = 1;
            adjust_right = 0;

            }
        }

    if ((critical_y0 - current_y) > 0) {  /* 1st band not degenerate -modified 4/1/91 */
        /* modify x_coord as y_coord advances to pixel position, a la gp_scanconv() */
        frac_y = I2LFX(current_y) - tmp_l2;
        lx_intercept += FixMul(frac_y,lx_step0);
        rx_intercept += FixMul(frac_y,rx_step0);
        lx_intercept += lx_step0 >> 1;
        rx_intercept += rx_step0 >> 1;
        }

    if (HTP_Flag == HT_CHANGED) {
        HTP_Flag =  HT_UPDATED;
        expand_halftone();
        }

    fb_addr = (ufix32 FAR *) (FB_ADDR + current_y * (FB_WIDTH >> 3));
    fb_words = FB_WIDTH >> WORDPOWER;
/*  fb_marked = TRUE;    * 5-7-91, Jack */

    if ((FC_Paint == FC_BLACK) || (FC_Paint == FC_SOLID)) {

        current_lx = *((fix16 FAR *)(&lx_intercept));
        current_rx = *((fix16 FAR *)(&rx_intercept)) + 1;
        bottom_y = critical_y0;
        lx_incr = lx_step0;
        rx_incr = rx_step0;

        while (current_y < bottom_y) {
            if (current_lx > current_rx)
                goto neg_rect10;
            left_mask = l_mask32[current_lx & WORDMASK];
            right_mask = r_mask32[current_rx & WORDMASK];
            left_word = current_lx >> WORDPOWER;
            fb_ptr = fb_addr + left_word;
            nwords = (current_rx >> WORDPOWER) - left_word;
            if (!nwords) {
                left_mask = left_mask & right_mask;
                *fb_ptr = (left_mask) | (*fb_ptr & ~left_mask);
                }
            else {
                *fb_ptr = (left_mask) | (*fb_ptr & ~left_mask);
                ++fb_ptr;
                while (--nwords > 0)
                    *fb_ptr++ = ONE32;
                *fb_ptr = (right_mask) | (*fb_ptr & ~right_mask);
                }
neg_rect10:
            fb_addr += fb_words;
            lx_intercept += lx_incr;
            current_lx = *((fix16 FAR *)(&lx_intercept));
            rx_intercept += rx_incr;
            current_rx = *((fix16 FAR *)(&rx_intercept)) + 1;
            ++current_y;
            }

        lx_intercept = critical_lx0;
        current_lx = adj_lx0;
        rx_intercept = critical_rx0;
        current_rx = adj_rx0 + 1;
        lx_incr = lx_step1;
        rx_incr = rx_step1;
        bottom_y = critical_y1;

        while (current_y < bottom_y) {
            if (current_lx > current_rx)
                goto neg_rect11;
            left_mask = l_mask32[current_lx & WORDMASK];
            right_mask = r_mask32[current_rx & WORDMASK];
            left_word = current_lx >> WORDPOWER;
            fb_ptr = fb_addr + left_word;
            nwords = (current_rx >> WORDPOWER) - left_word;
            if (!nwords) {
                left_mask = left_mask & right_mask;
                *fb_ptr = (left_mask) | (*fb_ptr & ~left_mask);
                }
            else {
                *fb_ptr = (left_mask) | (*fb_ptr & ~left_mask);
                ++fb_ptr;
                while (--nwords > 0)
                    *fb_ptr++ = ONE32;
                *fb_ptr = (right_mask) | (*fb_ptr & ~right_mask);
                }
neg_rect11:
            fb_addr += fb_words;
            lx_intercept += lx_incr;
            current_lx = *((fix16 FAR *)(&lx_intercept));
            rx_intercept += rx_incr;
            current_rx = *((fix16 FAR *)(&rx_intercept)) + 1;
            ++current_y;
            }

        lx_intercept = critical_lx1;
        if (adjust_left) {
            current_lx = MIN(current_lx,adj_lx1);
            }
        else
            current_lx = adj_lx1;
        rx_intercept = critical_rx1;
        if (adjust_right) {
            current_rx = MAX(current_rx,(adj_rx1 + 1));
            }
        else
            current_rx = adj_rx1 + 1;
        lx_incr = lx_step2;
        rx_incr = rx_step2;
        bottom_y = critical_y2;

        while (current_y < bottom_y) {
            if (current_lx > current_rx)
                goto neg_rect12;
            left_mask = l_mask32[current_lx & WORDMASK];
            right_mask = r_mask32[current_rx & WORDMASK];
            left_word = current_lx >> WORDPOWER;
            fb_ptr = fb_addr + left_word;
            nwords = (current_rx >> WORDPOWER) - left_word;
            if (!nwords) {
                left_mask = left_mask & right_mask;
                *fb_ptr = (left_mask) | (*fb_ptr & ~left_mask);
                }
            else {
                *fb_ptr = (left_mask) | (*fb_ptr & ~left_mask);
                ++fb_ptr;
                while (--nwords > 0)
                    *fb_ptr++ = ONE32;
                *fb_ptr = (right_mask) | (*fb_ptr & ~right_mask);
                }
neg_rect12:
            fb_addr += fb_words;
            lx_intercept += lx_incr;
            current_lx = *((fix16 FAR *)(&lx_intercept));
            rx_intercept += rx_incr;
            current_rx = *((fix16 FAR *)(&rx_intercept)) + 1;
            ++current_y;
            }
        }

    else if (HTP_Type == HT_MIXED) {
        ht_lineoff = current_y % HT_HEIGH;
        htb_addr = (ufix32 FAR *)(HTB_BASE + ht_lineoff * (HT_WIDTH >> 3));
        ht_words = HT_WIDTH >> WORDPOWER;
        current_lx = *((fix16 FAR *)(&lx_intercept));
        current_rx = *((fix16 FAR *)(&rx_intercept)) + 1;
        bottom_y = critical_y0;
        lx_incr = lx_step0;
        rx_incr = rx_step0;

        while (current_y < bottom_y) {
            if (current_lx > current_rx)
                goto neg_rect20;
            left_mask = l_mask32[current_lx & WORDMASK];
            right_mask = r_mask32[current_rx & WORDMASK];
            left_word = current_lx >> WORDPOWER;
            fb_ptr = fb_addr + left_word;
            htb_ptr = htb_addr + left_word;
            nwords = (current_rx >> WORDPOWER) - left_word;
            if (!nwords) {
                left_mask = left_mask & right_mask;
                *fb_ptr = (*htb_ptr & left_mask) | (*fb_ptr & ~left_mask);
                }
            else {
                *fb_ptr = (*htb_ptr & left_mask) | (*fb_ptr & ~left_mask);
                ++fb_ptr;
                ++htb_ptr;
                while (--nwords > 0)
                    *fb_ptr++ = *htb_ptr++;
                *fb_ptr = (*htb_ptr & right_mask) | (*fb_ptr & ~right_mask);
                }
neg_rect20:
            fb_addr += fb_words;
            if(++ht_lineoff == HT_HEIGH){
                htb_addr = (ufix32 FAR *)HTB_BASE;
                ht_lineoff = 0;
                }
            else
                htb_addr += ht_words;
            lx_intercept += lx_incr;
            current_lx = *((fix16 FAR *)(&lx_intercept));
            rx_intercept += rx_incr;
            current_rx = *((fix16 FAR *)(&rx_intercept)) + 1;
            ++current_y;
            }

        lx_intercept = critical_lx0;
        current_lx = adj_lx0;
        rx_intercept = critical_rx0;
        current_rx = adj_rx0 + 1;
        lx_incr = lx_step1;
        rx_incr = rx_step1;
        bottom_y = critical_y1;

        while (current_y < bottom_y) {
            if (current_lx > current_rx)
                goto neg_rect21;
            left_mask = l_mask32[current_lx & WORDMASK];
            right_mask = r_mask32[current_rx & WORDMASK];
            left_word = current_lx >> WORDPOWER;
            fb_ptr = fb_addr + left_word;
            htb_ptr = htb_addr + left_word;
            nwords = (current_rx >> WORDPOWER) - left_word;
            if (!nwords) {
                left_mask = left_mask & right_mask;
                *fb_ptr = (*htb_ptr & left_mask) | (*fb_ptr & ~left_mask);
                }
            else {
                *fb_ptr = (*htb_ptr & left_mask) | (*fb_ptr & ~left_mask);
                ++fb_ptr;
                ++htb_ptr;
                while (--nwords > 0)
                    *fb_ptr++ = *htb_ptr++;
                *fb_ptr = (*htb_ptr & right_mask) | (*fb_ptr & ~right_mask);
                }
neg_rect21:
            fb_addr += fb_words;
            if(++ht_lineoff == HT_HEIGH){
                htb_addr = (ufix32 FAR *)HTB_BASE;
                ht_lineoff = 0;
                }
            else
                htb_addr += ht_words;
            lx_intercept += lx_incr;
            current_lx = *((fix16 FAR *)(&lx_intercept));
            rx_intercept += rx_incr;
            current_rx = *((fix16 FAR *)(&rx_intercept)) + 1;
            ++current_y;
            }

        lx_intercept = critical_lx1;
        if (adjust_left) {
            current_lx = MIN(current_lx,adj_lx1);
            }
        else
            current_lx = adj_lx1;
        rx_intercept = critical_rx1;
        if (adjust_right) {
            current_rx = MAX(current_rx,(adj_rx1 + 1));
            }
        else
            current_rx = adj_rx1 + 1;
        lx_incr = lx_step2;
        rx_incr = rx_step2;
        bottom_y = critical_y2;

        while (current_y < bottom_y) {
            if (current_lx > current_rx)
                goto neg_rect22;
            left_mask = l_mask32[current_lx & WORDMASK];
            right_mask = r_mask32[current_rx & WORDMASK];
            left_word = current_lx >> WORDPOWER;
            fb_ptr = fb_addr + left_word;
            htb_ptr = htb_addr + left_word;
            nwords = (current_rx >> WORDPOWER) - left_word;
            if (!nwords) {
                left_mask = left_mask & right_mask;
                *fb_ptr = (*htb_ptr & left_mask) | (*fb_ptr & ~left_mask);
                }
            else {
                *fb_ptr = (*htb_ptr & left_mask) | (*fb_ptr & ~left_mask);
                ++fb_ptr;
                ++htb_ptr;
                while (--nwords > 0)
                    *fb_ptr++ = *htb_ptr++;
                *fb_ptr = (*htb_ptr & right_mask) | (*fb_ptr & ~right_mask);
                }
neg_rect22:
            fb_addr += fb_words;
            if(++ht_lineoff == HT_HEIGH){
                htb_addr = (ufix32 FAR *)HTB_BASE;
                ht_lineoff = 0;
                }
            else
                htb_addr += ht_words;
            lx_intercept += lx_incr;
            current_lx = *((fix16 FAR *)(&lx_intercept));
            rx_intercept += rx_incr;
            current_rx = *((fix16 FAR *)(&rx_intercept)) + 1;
            ++current_y;
            }
        }

    else {

        current_lx = *((fix16 FAR *)(&lx_intercept));
        current_rx = *((fix16 FAR *)(&rx_intercept)) + 1;
        bottom_y = critical_y0;
        lx_incr = lx_step0;
        rx_incr = rx_step0;

        while (current_y < bottom_y) {
            if (current_lx > current_rx)
                goto neg_rect30;
            left_mask = l_mask32[current_lx & WORDMASK];
            right_mask = r_mask32[current_rx & WORDMASK];
            left_word = current_lx >> WORDPOWER;
            fb_ptr = fb_addr + left_word;
            nwords = (current_rx >> WORDPOWER) - left_word;
            if (!nwords) {
                *fb_ptr = *fb_ptr & ~(left_mask & right_mask);
                }
            else {
                *fb_ptr = (*fb_ptr & ~left_mask);
                ++fb_ptr;
                while (--nwords > 0)
                    *fb_ptr++ = 0;
                *fb_ptr = (*fb_ptr & ~right_mask);
                }
neg_rect30:
            fb_addr += fb_words;
            lx_intercept += lx_incr;
            current_lx = *((fix16 FAR *)(&lx_intercept));
            rx_intercept += rx_incr;
            current_rx = *((fix16 FAR *)(&rx_intercept)) + 1;
            ++current_y;
            }

        lx_intercept = critical_lx0;
        current_lx = adj_lx0;
        rx_intercept = critical_rx0;
        current_rx = adj_rx0 + 1;
        lx_incr = lx_step1;
        rx_incr = rx_step1;
        bottom_y = critical_y1;

        while (current_y < bottom_y) {
            if (current_lx > current_rx)
                goto neg_rect31;
            left_mask = l_mask32[current_lx & WORDMASK];
            right_mask = r_mask32[current_rx & WORDMASK];
            left_word = current_lx >> WORDPOWER;
            fb_ptr = fb_addr + left_word;
            nwords = (current_rx >> WORDPOWER) - left_word;
            if (!nwords) {
                *fb_ptr = *fb_ptr & ~(left_mask & right_mask);
                }
            else {
                *fb_ptr = (*fb_ptr & ~left_mask);
                ++fb_ptr;
                while (--nwords > 0)
                    *fb_ptr++ = 0;
                *fb_ptr = (*fb_ptr & ~right_mask);
                }
neg_rect31:
            fb_addr += fb_words;
            lx_intercept += lx_incr;
            current_lx = *((fix16 FAR *)(&lx_intercept));
            rx_intercept += rx_incr;
            current_rx = *((fix16 FAR *)(&rx_intercept)) + 1;
            ++current_y;
            }

        lx_intercept = critical_lx1;
        if (adjust_left) {
            current_lx = MIN(current_lx,adj_lx1);
            }
        else
            current_lx = adj_lx1;
        rx_intercept = critical_rx1;
        if (adjust_right) {
            current_rx = MAX(current_rx,(adj_rx1 + 1));
            }
        else
            current_rx = adj_rx1 + 1;
        lx_incr = lx_step2;
        rx_incr = rx_step2;
        bottom_y = critical_y2;

        while (current_y < bottom_y) {
            if (current_lx > current_rx)
                goto neg_rect32;
            left_mask = l_mask32[current_lx & WORDMASK];
            right_mask = r_mask32[current_rx & WORDMASK];
            left_word = current_lx >> WORDPOWER;
            fb_ptr = fb_addr + left_word;
            nwords = (current_rx >> WORDPOWER) - left_word;
            if (!nwords) {
                *fb_ptr = *fb_ptr & ~(left_mask & right_mask);
                }
            else {
                *fb_ptr = (*fb_ptr & ~left_mask);
                ++fb_ptr;
                while (--nwords > 0)
                    *fb_ptr++ = 0;
                *fb_ptr = (*fb_ptr & ~right_mask);
                }
neg_rect32:
            fb_addr += fb_words;
            lx_intercept += lx_incr;
            current_lx = *((fix16 FAR *)(&lx_intercept));
            rx_intercept += rx_incr;
            current_rx = *((fix16 FAR *)(&rx_intercept)) + 1;
            ++current_y;
            }
        }
    return;
}
/* -jwm, 3/18/91, -end- */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\graph\fillgr.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/* --------------------------------------------------------------------
 * File : fillgr.c
 *
 * Programmed by: M.S Lin
 * Date: 10-19-1988
 *
 * Purpose: Provided routines for Graphics Command Buffer(GCB)
 *
 * Modification History:
 *          check_print() defined in fillgp.c
 * 07/29/89 cg - Unix port changes
 * Peter 09/12/90 change check_print() to GEIeng_checkcomplete() for ICI.
#ifdef WIN
 *  Ada             03/15/91    op_setpattern() and op_patfill()
 *                  execute_gcb() to process PFILL_PTZD and CHANGE_PF_PATTERN
 *  Ada             03/20/91    change op_patfill() to include backgroup drawing
 *  Ada             03/21/91    make WHITE REP to call normal fill
 *                            if Foregroup = Backgroup, do the normal fill only
 *  Ada             04/18/91    update pattern in LANSACOPE and adopted
 *                              for new driver files billmcc sent
 *  Ada             05/02/91  update the repeat pattern in LANDSCAPE
 *  Ada             05/15/91  solve pattern fill in contious printing
 *                            execute_gcb()  case CHANGE_PF_PATTERN:
 #endif
 *                  11/23/91  upgrade for higher resolution @RESO_UPGR
 * ---------------------------------------------------------------------
 */


// DJC added global include
#include "psglobal.h"


#include               "global.ext"
#include               "graphics.h"
#include               "graphics.ext"
#include               "font.h"
#include               "fillproc.h"
#include               "fillproc.ext"
#include               "stdio.h"      /* to define printf() @WIN */

/* @WIN; add prototype */
fix GEIeng_checkcomplete(void);
fix fb_busy(void);

#ifdef WIN
#include               <string.h>
#include               "pfill.h"

/*************************************************************************
 * SYNTAX:      pattern setpattern -
 *
 * TITLE:       op_setpattern
 *
 * CALL:        op_setpattern()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_setpattern)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 *************************************************************************/
fix
op_setpattern()
{
    ubyte FAR *pattern;
    fix    ii;
    ufix32 FAR *pf_addr = (ufix32 FAR *) PF_BASE;
    ufix32  pat;
    ULONG_PTR *old_ptr;
    fix     jj, mask, rot_byte;

    if (LENGTH_OPERAND(0) != 8) {
        ERROR(RANGECHECK);
        return(0);
    }
#ifdef DBG_PFILL
    printf("CTM = %f %f %f %f]\n", GSptr->ctm[0], GSptr->ctm[1],
            GSptr->ctm[2], GSptr->ctm[3]);
#endif
    pattern = (ubyte FAR *) (VALUE_OPERAND(0));

    /* to check if LANDSCOPE or PORTRAIT */
    if (GSptr->ctm[0] >= TOLERANCE) {
        /*  Generate the fill pattern:
         *  if pattern[0] = 01011100 then bitmap 32*16 will be
         * HSB            LSB
         *  +----------------+----------------+
         *  |1100110000001111|    the same    |
         *  |1100110000001111|    the same    |
         *  +----------------+----------------+
         *  |  pattern[1]    |                |
         *  |     :          |                |
         *  |     :          |                |
         *  |  pattern[7]    |                |
         *  +----------------+----------------+
         */
        for (ii = 0; ii < 8; ii++) {
#ifdef DBG_PFILL
            printf(" %x ==> %x\n", (fix) pattern[ii], (fix)
                   pf_cell[pattern[ii]]);
#endif
#ifdef DJC  // take this code out UDP027
            pat = (((ufix32) pf_cell[pattern[ii]]) << 16) |
                            pf_cell[pattern[ii]];
            *pf_addr++ = pat;
            *pf_addr++ = pat;
#endif
            //DJC fix from history.log UPD027
            pat =  ((ufix32) pattern[ii]) << 24 |
                   ((ufix32) pattern[ii]) << 16 |
                   ((ufix32) pattern[ii]) <<  8 |
                   ((ufix32) pattern[ii]);
            pat = ~pat;
            *pf_addr = pat;
            *(pf_addr+8) = pat;
            pf_addr++;

            //DJC end fix for UPD027




        } /* end for */
    } else {
        /* if in case of LANDSCAPE */
        /*  Generate the fill pattern:
         *  if pattern[0] = 01011100 then bitmap 32*16 will be
         *                                       Ywin  <---+
         *      +--+--+--+--+--+--+--+--+----------------+ |
         * HSB  |p |  |  |  |  |  |  |11|  the same      | v
         *      |a |  |  |  |  |  |  |11|                | Xwin
         *      |t |  |  |  |  |  |  |00|                |
         *      |t |  |  |  |  |  |  |00|                |
         *      |e |  |  |  |  |  |  |11|                |
         *      |r |  |  |  |  |  |  |11|                |
         *      |n |  |  |  |  |  |  |00|                |
         *      |^ |  |  |  |  |  |  |00|                |
         *      |7 |  |  |  |  |  |  |00|                |
         *      |v |  |  |  |  |  |  |00|                |
         *      |  |  |  |  |  |  |  |00|                |
         *      |  |  |  |  |  |  |  |00|                |
         *      |  |  |  |  |  |  |  |11|                |
         *      |  |  |  |  |  |  |  |11|                |
         *      |  |  |  |  |  |  |  |11|                |
         * LSB  |  |  |  |  |  |  |  |11|                |
         *      +--+--+--+--+--+--+--+--+----------------+
         */
        for (ii = 0, mask = 0x80; ii < 8; ii++, mask >>= 1) {
            for (jj = 7, rot_byte = 0; jj >= 0; jj--) {
                rot_byte <<= 1;
                rot_byte |= pattern[jj] & mask;
            }
            rot_byte >>= (7 - ii);
#ifdef DBG_PFILL
            printf("rot_byte = %x\n", rot_byte);
#endif
//DJC fix from history.log UPD027
/*          Take out the mapping from 1 bit to 2*2 bits; @WIN
 *          pat = (((ufix32) pf_cell[rot_byte]) << 16) |
 *                          pf_cell[rot_byte];
 *          *pf_addr++ = pat;
 *          *pf_addr++ = pat;
 */
            pat =  ((ufix32) rot_byte) << 24 |
                   ((ufix32) rot_byte) << 16 |
                   ((ufix32) rot_byte) <<  8 |
                   ((ufix32) rot_byte);
            pat = ~pat;
            *pf_addr = pat;
            *(pf_addr+8) = pat;
            pf_addr++;

//DJC end fix UPD027


        }
    } /* end else */

#ifdef DBG_PFILL
    printf("pfill pattern = ");
    for (ii = 0; ii < 16; ii++)
        printf("%8lx ", PF_BASE[ii]);
    printf("\n");
#endif

    if (FB_busy) {
        if (alloc_gcb(GCB_SIZE1) != NIL) {
            old_ptr = gcb_ptr++;
            *gcb_ptr++ = CHANGE_PF_PATTERN;
            /* put pattern into gcb */
            lmemcpy((ufix8 FAR *)gcb_ptr, (ufix8 FAR *)PF_BASE, PF_BSIZE << 2);/*@WIN*/
            gcb_ptr += PF_BSIZE;
            *old_ptr = (ULONG_PTR)gcb_ptr;
        }
    }

    POP(1);
    return(0);
}

/*************************************************************************
 * SYNTAX:      Bred Bgreen Bblue  Fred Fgreen Fblue ftype patfill -
 *
 * TITLE:       op_patfill
 *
 * CALL:        op_patfill()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_patfill)
 *
 * CALLS:       setrgbcolor, fill_shape
 *
 * RETURN:      none
 *
 *************************************************************************/
fix     pfill_flag = PF_NON;
fix
op_patfill()
{
    fix     pfill_flag_save;
    fix     ftype;
    real32      fred, fgreen, fblue, bred, bgreen, bblue;

    /* Ignore it if no currentpoints */
    if (F2L(GSptr->position.x) == NOCURPNT) return(0);

    ftype = (fix) VALUE_OPERAND(0);
    GET_OBJ_VALUE(fblue, GET_OPERAND(1));
    GET_OBJ_VALUE(fgreen, GET_OPERAND(2));
    GET_OBJ_VALUE(fred, GET_OPERAND(3));
    GET_OBJ_VALUE(bblue, GET_OPERAND(4));
    GET_OBJ_VALUE(bgreen, GET_OPERAND(5));
    GET_OBJ_VALUE(bred, GET_OPERAND(6));

    if (ftype != 0 && ftype != 1) {
        ERROR(RANGECHECK);
        return(0);
    }

#ifdef DBGpfill
    {
        fix ii;
        printf("pfill pattern = ");
        for (ii = 0; ii < 16; ii++)
            printf("%8lx ", PF_BASE[ii]);
        printf("\n");
    }
#endif

    pfill_flag_save = pfill_flag;
    setrgbcolor(F2L(bred), F2L(bgreen), F2L(bblue)); /* set backgroup color */
    if (HTP_Type == HT_WHITE) {
#ifdef DBGpfill
        printf("PFILL with WHITE backgroup -- PFILL(REP)\n");
#endif
        setrgbcolor(F2L(fred), F2L(fgreen), F2L(fblue)); /* set foregroup color */
        if (HTP_Type == HT_WHITE)
            /* Ada 3/21/91 to call normal fill */
            pfill_flag = PF_NON;
        else
            /* pfill the area REPLACE the framebuffer */
            pfill_flag = PF_REP;
        fill_shape(ftype == 0 ? NON_ZERO : EVEN_ODD, F_NORMAL, F_TO_PAGE);
    }
    else /* HT_MIXED or HT_BLOCK */ {
        real32  gray;
#ifdef DBGpfill
        printf("PFILL with nonBLACK backgroup");
#endif
        gray = GSptr->color.gray;
        /* fill/eofill the area  */
        op_gsave();     /* save the currentpath */
        pfill_flag = PF_NON;
        fill_shape(ftype == 0 ? NON_ZERO : EVEN_ODD, F_NORMAL, F_TO_PAGE);
        op_grestore();
#ifdef DBGpfill
        printf(" -- PFILL(OR)\n");
        /* op_copypage(); */
#endif
        setrgbcolor(F2L(fred), F2L(fgreen), F2L(fblue)); /* set foregroup color */
        if (gray == GSptr->color.gray)
            op_newpath();
        else {
            /* pfill the area OR the framebuffer */
            pfill_flag = PF_OR;
            fill_shape(ftype == 0 ? NON_ZERO : EVEN_ODD, F_NORMAL, F_TO_PAGE);
        }
    }
    pfill_flag = pfill_flag_save;

    POP(7);
    return(0);
}
#endif

/* ******** GCB (Graphics Command Buffer) **************************** */

/* --------------------------------------------------------------------
 * execute_gcb(): execute all of the graphics low level commands on
 *                GCB
 *
 * Called by: flush_gcb
 * --------------------------------------------------------------------*/
void    execute_gcb()
{
  ufix32   FAR *ptr, FAR *next_ptr;                     /* @WIN */
  ULONG_PTR   par1, par2, par3, par4, par5;          /* @WIN */
  struct Char_Tbl       FAR *cptr1, FAR *cptr2;
  struct tpzd_info      FAR *tpzdinfo_ptr;
  struct tpzd           FAR *tpzd_ptr;
  struct coord_i        FAR *coord_ptr;             /* jwm, 3/18 */
#ifdef WIN
  extern ufix32         PF_BASE[];
  extern fix            pfill_flag;
#endif

#ifdef FORMAT_13_3 /* @RESO_UPGR */
#elif FORMAT_16_16
           sfix_t par3_sf, par4_sf, par5_sf, par6_sf;
           sfix_t temp;
#elif  FORMAT_28_4
           sfix_t par3_sf, par4_sf, par5_sf, par6_sf;
           sfix_t temp;
#endif

#ifdef DBGgcb
  printf("execute_gcb(): %ld, %lx\n", GCB_count, gcb_ptr);
#endif

  ptr = (ufix32 FAR *)GCB_BASE;                 /* @WIN */
  while(GCB_count--) {
#ifdef DBGgcb
  printf("       %lx", ptr);
#endif
#ifndef _WIN64
    next_ptr = (ufix32 FAR *)*ptr++;            /* @WIN */
#else
    next_ptr = NULL;
#endif
#ifdef DBGgcb
  printf(" ,%lx\n", *ptr);
#endif
    switch(*ptr++) {

        case RESET_PAGE:
           par1 = *ptr++;
           par2 = *ptr++;
           reset_page((fix)par1, (fix)par2, (fix)*ptr);
           break;

        case ERASE_PAGE:
           /* Integrate the changes made by YM at 6-21-91 @HSIC */
           par1 = HTP_Type;
           HTP_Type = (fix)*ptr++;      //@WIN
           /* End of Integration */

           erase_page();

           /* Integrate the changes made by YM at 6-21-91 @HSIC */
           HTP_Type = (fix)par1;        //@WIN
           /* End of Integration */
           break;

#ifdef WIN
        case CHANGE_PF_PATTERN:
            lmemcpy((ufix8 FAR *)PF_BASE, (ufix8 FAR *)ptr, PF_BSIZE << 2);/*@WIN*/
            break;

        case PFILL_TPZD:
        {
            fix     pfill_flag_save;
            pfill_flag_save = pfill_flag;

            pfill_flag = (fix) *ptr++;
            image_info.seed_index = (fix16 )*ptr++;         /*MS 10-20-88 */
            par1 = *ptr++;
            tpzdinfo_ptr = (struct tpzd_info FAR *)ptr;
            tpzd_ptr = (struct tpzd FAR *)(tpzdinfo_ptr + 1);
            fill_tpzd((ufix)par1, tpzdinfo_ptr, tpzd_ptr);

            pfill_flag = pfill_flag_save;
            break;
        }
#endif

        case FILL_TPZD:
           image_info.seed_index = (fix16 )*ptr++;         /*MS 10-20-88 */
           par1 = *ptr++;
           tpzdinfo_ptr = (struct tpzd_info FAR *)ptr;
           tpzd_ptr = (struct tpzd FAR *)(tpzdinfo_ptr + 1);
           fill_tpzd((ufix)par1, tpzdinfo_ptr, tpzd_ptr);
           break;

        case FILL_LINE:   /* 1-18-89 */
           par1 = *ptr++;
           tpzdinfo_ptr = (struct tpzd_info FAR *)ptr;
           ptr = (ufix32 FAR *)(tpzdinfo_ptr + 1);
#ifdef FORMAT_13_3 /* @RESO_UPGR */
           par3 = *ptr++;
           par4 = *ptr++;
           par5 = *ptr++;
//         fill_line((ufix )par1, tpzdinfo_ptr, par3, par4, par5, *ptr); @WIN
           fill_line((ufix )par1, tpzdinfo_ptr, (sfix_t)par3, (sfix_t)par4, (sfix_t)par5, (sfix_t)*ptr);
#elif FORMAT_16_16
           temp = *ptr++;
           par3_sf = (temp << 16) | *ptr++;
           temp = *ptr++;
           par4_sf = (temp << 16) | *ptr++;
           temp = *ptr++;
           par5_sf = (temp << 16) | *ptr++;
           temp = *ptr++;
           par6_sf = (temp << 16) | *ptr;
           fill_line((ufix )par1, tpzdinfo_ptr, par3_sf, par4_sf, par5_sf, par6_sf);
#elif  FORMAT_28_4
           temp = *ptr++;
           par3_sf = (temp << 16) | *ptr++;
           temp = *ptr++;
           par4_sf = (temp << 16) | *ptr++;
           temp = *ptr++;
           par5_sf = (temp << 16) | *ptr++;
           temp = *ptr++;
           par6_sf = (temp << 16) | *ptr;
           fill_line((ufix )par1, tpzdinfo_ptr, par3_sf, par4_sf, par5_sf, par6_sf);
#endif
           break;

        case FILL_SCAN_PAGE:    /* 10-07-88 */
           par1 = *ptr++;
           par2 = *ptr++;
           par3 = *ptr++;
           par4 = *ptr++;
           fill_scan_page((fix)par1, (fix)par2, (fix)par3, (fix)par4,
                            (SCANLINE FAR *)ptr);
           break;

        case FILL_PIXEL_PAGE:
           par1 = *ptr++;
           fill_pixel_page((fix)par1, (PIXELIST FAR *)ptr);
           break;

        case INIT_CHAR_CACHE:
           init_char_cache((struct Char_Tbl FAR *)ptr);
           break;

        case COPY_CHAR_CACHE:
           cptr1 = (struct Char_Tbl FAR *)ptr;
           cptr2 = cptr1 + 1;
           ptr = (ufix32 FAR *)(cptr2 + 1);
           par3 = *ptr++;
           copy_char_cache((struct Char_Tbl FAR *)cptr1,
                           (struct Char_Tbl FAR *)cptr2, (fix)par3, (fix)*ptr);
           break;

        case FILL_SCAN_CACHE:
           par1 = *ptr++;
           par2 = *ptr++;
           par3 = *ptr++;
           par4 = *ptr++;
           par5 = *ptr++;
           fill_scan_cache((gmaddr)par1, (fix)par2, (fix)par3, (fix)par4, (fix)par5,
                           (SCANLINE FAR *)ptr);
           break;

        case FILL_PIXEL_CACHE:
           par1 = *ptr++;
           par2 = *ptr++;
           par3 = *ptr++;
           par4 = *ptr++;
           fill_pixel_cache((gmaddr)par1, (fix)par2, (fix)par3, (fix)par4,
                            (PIXELIST FAR *)ptr);
           break;

        case INIT_CACHE_PAGE:
           par1 = *ptr++;
           par2 = *ptr++;
           par3 = *ptr++;
           par4 = *ptr++;
           init_cache_page((fix)par1, (fix)par2, (fix)par3, (fix)par4, (gmaddr)*ptr);
           break;

        case CLIP_CACHE_PAGE:
           par1 = *ptr++;
           par2 = *ptr++;
           clip_cache_page((fix)par1, (fix)par2, (SCANLINE FAR *)ptr);
           break;

        case FILL_CACHE_PAGE:
           fill_cache_page();
           break;

        case DRAW_CACHE_PAGE:
           par1 = *ptr++;
           par2 = *ptr++;
           par3 = *ptr++;
           par4 = *ptr++;
           draw_cache_page((fix32)par1, (fix32)par2, (ufix32)par3,
                        (ufix32)par4, (gmaddr)*ptr);    /*@WIN 04-15-92*/
           break;

        case FILL_SEED_PATT:
           par1 = *ptr++;
           par2 = *ptr++;
           par3 = *ptr++;
           par4 = *ptr++;
           par5 = *ptr++;
           fill_seed_patt((fix)par1, (fix)par2, (fix)par3, (fix)par4, (fix)par5, (SCANLINE FAR *)ptr);
           break;

        case CHANGE_HALFTONE:
           par1 = *ptr++;
           par2 = *ptr++;
           par3 = *ptr++;
           par4 = *ptr++;
           change_halftone((ufix32 FAR *)par1, (gmaddr)par2, (fix)par3, (fix)par4, (fix)*ptr);
                                                      /* ufix => ufix32 @WIN */
           break;

        case MOVE_CHAR_CACHE:
           cptr1 = (struct Char_Tbl FAR *)ptr;
           cptr2 = cptr1 + 1;
           move_char_cache(cptr1,cptr2);
           break;

        case INIT_IMAGE_PAGE:
           par1 = *ptr++;
           par2 = *ptr++;
           par3 = *ptr++;
           init_image_page((fix)par1, (fix)par2, (fix)par3, (fix)*ptr);
           break;

        case CLIP_IMAGE_PAGE:
           par1 = *ptr++;
           par2 = *ptr++;
           clip_image_page((fix)par1, (fix)par2, (SCANLINE FAR *)(ptr));
           break;

        /* jwm, 3/18/91, -begin- */
        case FILL_BOX:
            par1 = (ULONG_PTR) ptr;        /* @WIN */
            coord_ptr = (struct coord_i FAR *) ptr;
            par2 = (ULONG_PTR) (++coord_ptr);      /* @WIN */
            do_fill_box((struct coord_i FAR *)par1, (struct coord_i FAR *)par2);
            break;

        case FILL_RECT:
            par1 = (ULONG_PTR) ptr;        /* @WIN */
            do_fill_rect((struct line_seg_i FAR *)par1);
            break;
        /* jwm, 3/18/91, -end- */

        default:
           printf("\07GCB error !\n");
           break;

    } /* switch */
    ptr = next_ptr;

  } /* while */
  return;
} /* execute_gcb */

/* --------------------------------------------------------------------
 * flush_gcb: flush GCB commands
 *
 * Called by: alloc_gcb on GCB full or *GCB_flush == TRUE
 * --------------------------------------------------------------------*/
void flush_gcb(check_flag)
fix     check_flag;
{
#ifdef DBGgcb
   printf("flush_gcb(): %ld, %lx\n", GCB_count, gcb_ptr);
#endif

  if(check_flag){
     /* wait until Frame Buffer availabel */
/*   while(check_print())       @GEI */
     while(GEIeng_checkcomplete())
        ;
  }
  if(GCB_count > 0) {

    GCB_flush = TRUE;
    execute_gcb();
  }
  GCB_flush = FALSE;
  GCB_count = 0;
  gcb_ptr = (ULONG_PTR *)GCB_BASE;                     /* @WIN */

  return;
} /* flush_gcb */

/* --------------------------------------------------------------------
 * alloc_gcb(): check GCB available size
 *
 * Parameter: alloc_size -- expected size.
 *
 * Return(NIL)     -- when GCB full
 *       (gcb_ptr) -- when size availabe
 * --------------------------------------------------------------------*/
fix     FAR *alloc_gcb(alloc_size)
fix     alloc_size;
{
#ifdef DBGgcb
   printf("alloc_gcb(): %lx\n", gcb_ptr);
#endif

   if(!fb_busy())
        return(NIL);

   if( (GCB_BASE + GCB_SIZE - (ULONG_PTR)gcb_ptr) < (ULONG_PTR)alloc_size){   /* @WIN */
#ifdef DBGgcb
           printf("GCB full: %lx\n", gcb_ptr);
#endif

           flush_gcb(TRUE);
           return(NIL);
   }
   GCB_count++;
   return((fix FAR *)gcb_ptr);          /* @WIN */

} /* alloc_gcb */


/* --------------------------------------------------------------------
 * put_scanline(): put scanline list into GCB
 *
 * Parameter
 *    no_lines -- no. of scanline
 *    scanline -- scanline list
 *
 * --------------------------------------------------------------------*/
void  put_scanline(no_lines, scanline)
fix             no_lines;
SCANLINE        FAR *scanline;
{
   SCANLINE     FAR *ptr, FAR *scan;

#ifdef DBGgcb
   printf("put_scanline(): %lx\n", gcb_ptr);
/*   get_scanlist(0L, no_lines, scanline);*/
#endif

   scan = scanline;
   ptr = (SCANLINE FAR *)gcb_ptr;
   while(no_lines--) {
      while((*ptr++ = *scan++) != (SCANLINE )END_OF_SCANLINE)
        *ptr++ = *scan++;
   }
#ifdef DBGgcb
   printf("\thoriz. line\n");
#endif

   /* horizontal lines */
   while((*ptr++ = *scan++) != (SCANLINE )END_OF_SCANLINE){
        *ptr++ = *scan++;
        *ptr++ = *scan++;
   }

  gcb_ptr = (ULONG_PTR *)( ((ULONG_PTR)ptr + 3) & 0xFFFFFFFCL ); /* 4 byte allignment @WIN*/
   return;
} /* put_scanline */


/* --------------------------------------------------------------------
 * put_pixelist(): put pixelist into GCB
 *
 * Parameter
 *    no_pixel -- no. of pixel
 *    pixelist -- pixelist
 *
 * --------------------------------------------------------------------*/
void    put_pixelist(no_pixel, pixelist)
fix             no_pixel;
PIXELIST        FAR *pixelist;
{
   PIXELIST     FAR *ptr, FAR *pixel;

#ifdef DBGgcb
   printf("put_pixelist(): %lx\n", gcb_ptr);
#endif

   pixel = pixelist;
   ptr = (PIXELIST FAR *)gcb_ptr;
   while(no_pixel--) {
      *ptr++ = *pixel++;
      *ptr++ = *pixel++;
   }
   gcb_ptr = (ULONG_PTR *)( ((ULONG_PTR)ptr + 3) & 0xFFFFFFFCL); /* 4 byte allignment @WIN*/
   return;
}

/* --------------------------------------------------------------------
 * put_Char_Tbl(): put Char_tbl structure into GCB
 *
 * Parameter
 *   dcc_info: pointer to Char_Tbl structure
 * --------------------------------------------------------------------*/

void        put_Char_Tbl(dcc_info)
struct      Char_Tbl    FAR *dcc_info;
{
   struct Char_Tbl      FAR *cptr;

#ifdef DBGgcb
   printf("put_Char_Tbl: %lx\n", gcb_ptr);
#endif
   cptr = (struct Char_Tbl FAR *)gcb_ptr;
   *cptr++ = *dcc_info;
   gcb_ptr = (ULONG_PTR *)( ((ULONG_PTR)cptr + 3) & 0xFFFFFFFCL); /* 4 byte allignment @WIN*/
#ifdef DBGgcb
   printf("%lx..>\n", gcb_ptr);
#endif

   return;
}


/* -------------------------------------------------------------------------
 *      put_tpzd_info(p1, p2): put tpzd_info structure to GCB
 *
 * ------------------------------------------------------------------------- */
void    put_tpzd_info(ptr)
struct  tpzd_info       FAR *ptr;
{
        struct  tpzd_info       FAR *cptr;


#ifdef DBGgcb
   printf("put_tpzd_info: %lx\n", gcb_ptr);
#endif
   cptr = (struct tpzd_info FAR *)gcb_ptr;
   *cptr++ = *ptr;
   gcb_ptr = (ULONG_PTR *)( ((ULONG_PTR)cptr + 3) & 0xFFFFFFFCL); /* 4 byte allignment @WIN*/
#ifdef DBGgcb
   printf("%lx..>\n", gcb_ptr);
#endif

   return;
}


/* -------------------------------------------------------------------------
 *      put_tpzd(p1, p2): put tpzd structure to GCB
 *
 * ------------------------------------------------------------------------- */
void    put_tpzd(ptr)
struct  tpzd       FAR *ptr;
{
        struct  tpzd       FAR *cptr;


#ifdef DBGgcb
   printf("put_tpzd: %lx\n", gcb_ptr);
#endif
   cptr = (struct tpzd FAR *)gcb_ptr;
   *cptr++ = *ptr;
   gcb_ptr = (ULONG_PTR *)( ((ULONG_PTR)cptr + 3) & 0xFFFFFFFCL); /* 4 byte allignment @WIN*/
#ifdef DBGgcb
   printf("%lx..>\n", gcb_ptr);
#endif

   return;
}
//DJC we will always return false
fix fb_busy()
{
   return(FALSE);
}
#ifdef XXX
/* @WIN ??? */
/* -------------------------------------------------------------------------
 *      FB_busy(): return TRUE if Frame buffer busy.
 *                 return FALSE if Frame buffer ready.
 * -------------------------------------------------------------------------*/
fix     fb_busy()
{
/*      if(check_print())               @GEI */
        if(GEIeng_checkcomplete())
           return(TRUE);
        if(GCB_count && !GCB_flush)
           flush_gcb(FALSE);
        FB_busy = FALSE;
        return(FALSE);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\graph\fillgbx.c ===
/**********************************************************************
 *
 *  Name:       fillgbx.c
 *
 *  Purpose:    This file contains routines for performing bitblt related
 *              operations.
 *
 *  History:
 *  SCChen      10/07/92    Move in bitblt related functions from fillgb.c:
 *                          gp_bitblt16 gp_bitblt32
 *                          gp_pixels16 gp_pixels32
 *                          gp_cacheblt16
 *                          gp_bitblt16_32
 *                          gp_charblt16 gp_charblt32 gp_charblt16_cc
 *                          gp_charblt16_clip gp_charblt32_clip
 *                          gp_patblt gp_patblt_m gp_patblt_c
 **********************************************************************/



// DJC added global include
#include "psglobal.h"


#include        <math.h>
#include        <stdio.h>
#include        "global.ext"
#include        "graphics.h"
#include        "graphics.ext"
#include        "font.h"
#include        "font.ext"
#include        "fillproc.h"
#include        "fillproc.ext"
// Short & long word swapping @WINFLOW
#ifdef  bSwap
#define WORDSWAP(lw) \
        (lw =  (lw << 16) | (lw >> 16))
#define SWORDSWAP(sw) \
        (sw =  (sw << 8) | (sw >> 8))
#define LWORDSWAP(lw) \
        (lw =  (lw << 24) | (lw >> 24) | \
                 ((lw >> 8) & 0x0000ff00) | ((lw << 8) & 0x00ff0000))
#define S2WORDSWAP(lw) \
        (lw = ((lw >> 8) & 0x00ff00ff) | ((lw << 8) & 0xff00ff00))
#define SWAPWORD(lw) (lw = (lw << 16) | (lw >> 16))
#else
#define WORDSWAP(lw)    (lw)
#define SWORDSWAP(sw)   (sw)
#define LWORDSWAP(lw)   (lw)
#define S2WORDSWAP(lw)  (lw)
#define SWAPWORD(lw) (lw)
#endif

/* -----------------------------------------------------------------------
 * BITBLT SIMULATION
 *
 * Function Description:
 *           Move bitmap from source to destination with logical
 *           operation in a graphics buffer or between graphics
 *           buffer and character cache buffer.
 *           source bitmap width must equal destination bitmap
 *           width.
 *           simulate graphics bitblt with following logical operations:
 *           FC_MOVES: source                   --> destination
 *           FC_CLIPS: source .AND. destination --> destination
 *           FC_MERGE: source .OR.  destination --> destination
 *           FC_CLEAR: (.NOT. source)  .AND. (destination) --> destination
 *           FC_MERGE | HT_APPLY:
 *               Step 1. Clear destination for value 1 on source.
 *               Step 2. (source AND halftone) --> source.
 *               Step 3. (source OR destination) --> destination.
 *
 *
 * By : M.S Lin
 * Date : May 18, 1988
 *
 * History :
 *        5/24/88  check if nwords == 0 in rowcopy().
 *        8-12-88  Update interface to consistant with Y.C Chen.
 *        11-12-88 Code reduction for portable to single CPU environment.
 *
 * Calling sequence:
 *   gp_bitblt16(DST, DX, DY, W, H, HT_FC, SRC, SX, SY): For bitmap width 16X
 *   gp_bitblt32(DST, DX, DY, W, H, HT_FC, SRC, SX, SY): For bitmap width 32X
 *
 *   struct bitmap *DST;      address of destination bitmap
 *   fix            DX;       X origin of destination rectangle
 *   fix            DY;       Y origin of destination rectangle
 *   fix            W;        width  of rectangle to be bitblted
 *   fix            H;        height of rectangle to be bitblted
 *   ufix16         HT_FC;    operation flag: halftoning flag and
 *                                            logical function
 *   struct bitmap *SRC;      address of source bitmap
 *   fix            SX;       X origin of source rectangle
 *   fix            SY;       Y origin of source rectangle
 *
 * Diagram Description:
 *
 *   DST +---------------------------+   SRC +-----------------------+
 *       |                           |       |       |<-- W -->|     |
 *       |       |<-- W -->|         |       |(SX,SY)*---------+ --- |
 *       |(DX,DY)*---------+ ---     |       |       |         |  |  |
 *       |       |         |  |      |       |       |         |  |  |
 *       |       |         |  |      |       |       |         |  H  |
 *       |       |         |  H      |       |       |         |  |  |
 *       |       |         |  |      |       |       |         |  |  |
 *       |       |         |  |      |       |       +---------+ --- |
 *       |       +---------+ ---     |       |                       |
 *       |                           |       |                       |
 *       |                           |       +-----------------------+
 *       |                           |
 *       |                           |
 *       |                           |
 *       +---------------------------+
 * ----------------------------------------------------------------------- */


/* *************************************************************************
 *      gp_bitblt16(): Bitblt with 16 bit operations.
 *
 * ************************************************************************* */
void
gp_bitblt16(dst, dx, dy, w, h, fc, src, sx, sy)
struct bitmap FAR     *dst;
fix                     dx, dy;
fix                     w, h;
ufix16                  fc;
struct bitmap FAR     *src;
fix                     sx, sy;
{
    fix                 dw;
   ufix16              huge *db;        /* FAR => huge @WIN */
    fix                 sw;
   ufix16              FAR *sb;
    fix                 hw;
    fix                 hy;
   ufix16              FAR *hb;
    fix                 ls, rs;
    fix                 xs, xe;
    fix                 now, cow;
   ufix16              FAR *hs;

#ifdef  DBGbb
    printf("bitblt16: %6.6lx %4x %4x %4x %4x %4.4x %6.6lx %4x %4x\n",
           dst->bm_addr, dx, dy, w, h, fc, src->bm_addr, sx, sy);
#endif

        /*  calculate starting address and width in words
         */
        dw = dst->bm_cols >> SHORTPOWER;                         /* @DST */
//      db = &((ufix16 FAR *) dst->bm_addr)[dy * dw + (dx >> SHORTPOWER)];
        db = (ufix16 huge *) dst->bm_addr +             /*@WIN*/
             ((ufix32)dy * dw + ((ufix32)dx >> SHORTPOWER));
        sw = src->bm_cols >> SHORTPOWER;                         /* @SRC */
        sb =  ((ufix16 FAR *) src->bm_addr);

        /*  calculate starting and ending coordinate of x
         */
        xs = dx;
        xe = dx + w - 1;
        now = ((fix)(xe & CC_ALIGN_MASK) - (fix)(xs & CC_ALIGN_MASK)) >> CC_WORD_POWER;
                                                 /* cast fix 10/16/92 @WIN */

        /*  calculate shifts and masks based on from SRC to DST
         */
        rs = dx & SHORTMASK;                            /* right shift */
        ls = BITSPERSHORT - rs;                         /* left  shift */

        /*  calculate starting address/y and width in words
         */
        hw = HTB_Bmap.bm_cols >> SHORTPOWER;
        hy = dy % HTB_Bmap.bm_rows;
        hs = (ufix16 FAR *)HTB_Bmap.bm_addr + (dx >> SHORTPOWER);
        hb = hs + (hy * hw);

        if (rs  == 0x00)                /* no left/right shift? */
        {
            for (dw-= now + 1, sw-= now + 1, hw-= now + 1; h > 0;
                 db+= dw, sb+= sw, h--)
            {
                for (cow = now; cow >= 0x00; db++, sb++, hb++, cow--)
                    db[0] = (db[0] & ~(sb[0])) | (hb[0] & sb[0]);
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }
        else if (now == 0x00)           /* totally within one word? */
        {
            for (; h > 0; db+= dw, sb+= sw, h--)
            {
                db[0] = (db[0] & ~(CC_RIGH_SHIFT(sb[0], rs))) |
                        (hb[0] &  (CC_RIGH_SHIFT(sb[0], rs)));
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }
        else  if (now == 0x01)          /* just crossing two words? */
        {
            if (w <= CC_PIXEL_WORD)     /* one word crossing two words? */
            {
                for (; h > 0; db+= dw, sb+= sw, h--)
                {
                    db[0] = (db[0] & ~(CC_RIGH_SHIFT(sb[0], rs))) |
                            (hb[0] & CC_RIGH_SHIFT(sb[0], rs));
                    db[1] = (db[1] & ~(CC_LEFT_SHIFT(sb[0], ls))) |
                            (hb[1] & CC_LEFT_SHIFT(sb[0], ls));
                    hy++;
                    if (hy == HTB_Bmap.bm_rows)
                    {
                        hy =  0;
                        hb = hs;
                    } else
                        hb += hw;
                }
            }
            else                        /* two words crossing two words! */
            {
                for (; h > 0; db+= dw, sb+= sw, h--)
                {
                    db[0] = (db[0] & ~(CC_RIGH_SHIFT(sb[0], rs))) |
                            (hb[0] & CC_RIGH_SHIFT(sb[0], rs));
                    db[1] = (db[1] & ~(CC_LEFT_SHIFT(sb[0], ls)
                                   |   CC_RIGH_SHIFT(sb[1], rs))) |
                            (hb[1] & (CC_LEFT_SHIFT(sb[0], ls)
                                   |  CC_RIGH_SHIFT(sb[1], rs)));
                    hy++;
                    if (hy == HTB_Bmap.bm_rows)
                    {
                        hy =  0;
                        hb = hs;
                    } else
                        hb += hw;
                }
            }
        }
        else                            /* crossing more than two words! */
        {
            for (dw-= now, sw-= (now - 1),
                 hw-= now; h > 0; db+= dw, sb+= sw, h--)
            {
                db[0] = (db[0] & ~(CC_RIGH_SHIFT(sb[0], rs))) |
                        (hb[0] & (CC_RIGH_SHIFT(sb[0], rs)));
                for (db++, hb++, cow = now; cow >= 0x02;
                     db++, sb++, hb++, cow--)
                {
                    db[0] = (db[0] & ~(CC_LEFT_SHIFT(sb[0], ls)
                                   |   CC_RIGH_SHIFT(sb[1], rs))) |
                            (hb[0] & (CC_LEFT_SHIFT(sb[0], ls)
                                   |  CC_RIGH_SHIFT(sb[1], rs)));
                }
                db[0] = (db[0] & ~(CC_LEFT_SHIFT(sb[0], ls))) |
                        (hb[0] & (CC_LEFT_SHIFT(sb[0], ls)));
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }

} /* gp_bitblt16 */

/* ***********************************************************************
 *      gp_bitblt32(): Bitblt with 32 bits operation.
 *
 * *********************************************************************** */
void
gp_bitblt32(dst, dx, dy, w, h, fc, src, sx, sy)
struct bitmap FAR     *dst;
fix                     dx, dy;
fix                     w, h;
ufix16                  fc;
struct bitmap FAR     *src;
fix                     sx, sy;
{
    fix                 dw;
    BM_DATYP           huge *db;        /* FAR => huge @WIN */
    fix                 sw;
    BM_DATYP           FAR *sb;
    fix                 hw;
    fix                 hy;
    BM_DATYP           FAR *hb;
    fix                 ls, rs;
    BM_DATYP            fm, sm, mm;
    fix                 xs, xe;
    fix                 now, cow;
    BM_DATYP           FAR *hs;
    ufix32              tmprs0;             /*@WIN 05-12-92*/
    ufix32              tmp0, tmp1;             /*@WIN 05-12-92*/


#ifdef  DBG
    printf("bitblt32: %6.6lx %4x %4x %4x %4x %4.4x %6.6lx %4x %4x\n",
           dst->bm_addr, dx, dy, w, h, fc, src->bm_addr, sx, sy);
#endif

    /*  calculate starting address and width in words
     */
    dw = dst->bm_cols >> BM_WORD_POWER;                         /* @DST */
//  db = &((BM_DATYP FAR *) dst->bm_addr)[dy * dw + (dx >> BM_WORD_POWER)];
    db = (BM_DATYP huge *) dst->bm_addr +               /*@WIN*/
         ((ufix32)dy * dw + ((ufix32)dx >> BM_WORD_POWER));
    sw = src->bm_cols >> BM_WORD_POWER;                         /* @SRC */
    sb =  ((BM_DATYP FAR *) src->bm_addr);

    /*  calculate starting and ending coordinate of x
     */
    xs = dx;
    xe = dx + w - 1;
    now = ((fix)(xe & BM_ALIGN_MASK) - (fix)(xs & BM_ALIGN_MASK)) >> BM_WORD_POWER;
                                                 /* cast fix 10/16/92 @WIN */

    /*  calculate shifts and masks based on from SRC to DST
     */
    rs = dx & BM_PIXEL_MASK;                            /* right shift */
    ls = BM_PIXEL_WORD - rs;                            /* left  shift */

    switch (fc)
    {
    case FC_MOVES:            /*  0001  D <-  S          */

        fm =  BM_L_MASK(xs);                                /* first  mask */
        sm =  BM_R_MASK(xe);                                /* second mask */
        LWORDSWAP(fm);                  /*@WIN 05-12-92*/
        LWORDSWAP(sm);                  /*@WIN 05-12-92*/
        if (rs  == 0x00)                /* no left/right shift? */
        {
            for (dw-= now + 1, sw-= now + 1; h > 0; db+= dw, sb+= sw, h--)
            {
                for (cow = now; cow >= 0x00; db++, sb++, cow--)
                    db[0] = sb[0];
            }
        }
        else  if (now == 0x00)          /* totally within one word? */
        {
            mm = fm & sm;
            for (; h > 0; db+= dw, sb+= sw, h--) {      /*@WIN 05-12-92*/
                tmp0 = sb[0];
                LWORDSWAP(tmp0);
                tmp0 = BM_RIGH_SHIFT(tmp0, rs);
                db[0] = (db[0] & ~mm) + (LWORDSWAP(tmp0) & mm);
            }
            /*  @WIN 05-12-92
            for (; h > 0; db+= dw, sb+= sw, h--)
                db[0] = (db[0] & ~mm) + (BM_RIGH_SHIFT(sb[0], rs) & mm);
            */
        }
        else  if (now == 0x01)          /* just crossing two words? */
        {
            for (; h > 0; db+= dw, sb+= sw, h--)
            {
                tmp0 = sb[0];            /*@WIN 05-12-92 begin*/
                LWORDSWAP(tmp0);
                tmp1 = tmp0;
                tmp0 = BM_RIGH_SHIFT(tmp0, rs);
                db[0] = (db[0] & ~fm) + (LWORDSWAP(tmp0) & fm);
                tmp0 = BM_LEFT_SHIFT(tmp1, ls);
                tmp1 = sb[1];
                LWORDSWAP(tmp1);
                tmp1 = tmp0 | BM_RIGH_SHIFT(tmp1, rs);
                db[1] = (db[1] & ~sm) + (LWORDSWAP(tmp1) & sm); /*@WIN end*/
                /*      @WIN
                db[0] = (db[0] & ~fm) + (BM_RIGH_SHIFT(sb[0], rs) & fm);
                db[1] = (db[1] & ~sm) + ((BM_LEFT_SHIFT(sb[0], ls) |
                                          BM_RIGH_SHIFT(sb[1], rs)) & sm);
                */
            }
        }
        else                            /* crossing more than two words! */
        {
            for (dw-= now, sw-= (now - 1); h > 0; db+= dw, sb+= sw, h--)
            {
                tmp0 = sb[0];                   /*@WIN 05-12-92 begin*/
                LWORDSWAP(tmp0);
                tmp0 = BM_RIGH_SHIFT(tmp0, rs);
                db[0] = (db[0] & ~fm) + (LWORDSWAP(tmp0) & fm);
                for (db++, cow = now; cow >= 0x02; db++, sb++, cow--) {
                    tmp0 = sb[0];
                    LWORDSWAP(tmp0);
                    tmp1 = sb[1];
                    LWORDSWAP(tmp1);
                    tmp1 = (BM_LEFT_SHIFT(tmp0, ls) |
                            BM_RIGH_SHIFT(tmp1, rs));
                    db[0] = LWORDSWAP(tmp1);
                }
                tmp0 = sb[0];
                LWORDSWAP(tmp0);
                tmp0 = BM_LEFT_SHIFT(tmp0, ls);
                tmp1 = sb[1];
                LWORDSWAP(tmp1);
                tmp1 = BM_RIGH_SHIFT(tmp1, rs);
                tmp1 = LWORDSWAP(tmp0) | LWORDSWAP(tmp1); /* compiler ???*/
                db[0] = (db[0] & ~sm) + (tmp1 & sm); /*@WIN end*/
                /*      @WIN
                db[0] = (db[0] & ~fm) + (BM_RIGH_SHIFT(sb[0], rs) & fm);
                for (db++, cow = now; cow >= 0x02; db++, sb++, cow--)
                    db[0] = (BM_LEFT_SHIFT(sb[0], ls) |
                             BM_RIGH_SHIFT(sb[1], rs));
                db[0] = (db[0] & ~sm) + ((BM_LEFT_SHIFT(sb[0], ls) |
                                          BM_RIGH_SHIFT(sb[1], rs)) & sm);
                */
            }
        }
        break;

    case HT_APPLY:              /*  D <- (D .AND. .NOT. S) .OR.
                                         (S .AND. HT)                   */
        /*  calculate starting address/y and width in words
         */
        hw = HTB_Bmap.bm_cols >> BM_WORD_POWER;
        hy = dy % HTB_Bmap.bm_rows;
        hs = (BM_DATYP FAR *)HTB_Bmap.bm_addr + (dx >> BM_WORD_POWER);
        hb = hs + (hy * hw);

        if (rs  == 0x00)                /* no left/right shift? */
        {
            for (dw-= now + 1, sw-= now + 1, hw-= now + 1; h > 0;
                 db+= dw, sb+= sw, h--)
            {
                for (cow = now; cow >= 0x00; db++, sb++, hb++, cow--)
                    db[0] = (db[0] & ~(sb[0])) | (hb[0] & sb[0]);
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }

        else if (now == 0x00)           /* totally within one word? */
        {
            for (; h > 0; db+= dw, sb+= sw, h--)
            {
                tmprs0 = sb[0];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                LWORDSWAP(tmprs0);
                db[0] = (db[0] & ~(tmprs0)) |
                        (hb[0] &  (tmprs0));
                /*  @WIN
                db[0] = (db[0] & ~(BM_RIGH_SHIFT(sb[0], rs))) |
                        (hb[0] &  (BM_RIGH_SHIFT(sb[0], rs)));
                */
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }
        else  if (now == 0x01)          /* just crossing two words? */
        {
            if (w <= BM_PIXEL_WORD)     /* one word crossing two words? */
            {
                for (; h > 0; db+= dw, sb+= sw, h--)
                {
                    db[0] = (db[0] & ~(BM_RIGH_SHIFT(sb[0], rs))) |
                            (hb[0] & BM_RIGH_SHIFT(sb[0], rs));
                    db[1] = (db[1] & ~(BM_LEFT_SHIFT(sb[0], ls))) |
                            (hb[1] & BM_LEFT_SHIFT(sb[0], ls));
                    hy++;
                    if (hy == HTB_Bmap.bm_rows)
                    {
                        hy =  0;
                        hb = hs;
                    } else
                        hb += hw;
                }
            }
            else                        /* two words crossing two words! */
            {
                for (; h > 0; db+= dw, sb+= sw, h--)
                {
                    db[0] = (db[0] & ~(BM_RIGH_SHIFT(sb[0], rs))) |
                            (hb[0] & BM_RIGH_SHIFT(sb[0], rs));
                    db[1] = (db[1] & ~(BM_LEFT_SHIFT(sb[0], ls)
                                   |   BM_RIGH_SHIFT(sb[1], rs))) |
                            (hb[1] & (BM_LEFT_SHIFT(sb[0], ls)
                                   |  BM_RIGH_SHIFT(sb[1], rs)));
                    hy++;
                    if (hy == HTB_Bmap.bm_rows)
                    {
                        hy =  0;
                        hb = hs;
                    } else
                        hb += hw;
                }
            }
        }
        else                            /* crossing more than two words! */
        {
            for (dw-= now, sw-= (now - 1),
                 hw-= now; h > 0; db+= dw, sb+= sw, h--)
            {
                db[0] = (db[0] & ~(BM_RIGH_SHIFT(sb[0], rs))) |
                        (hb[0] & (BM_RIGH_SHIFT(sb[0], rs)));
                for (db++, hb++, cow = now; cow >= 0x02;
                     db++, sb++, hb++, cow--)
                {
                    db[0] = (db[0] & ~(BM_LEFT_SHIFT(sb[0], ls)
                                   |   BM_RIGH_SHIFT(sb[1], rs))) |
                            (hb[0] & (BM_LEFT_SHIFT(sb[0], ls)
                                   |  BM_RIGH_SHIFT(sb[1], rs)));
                }
                db[0] = (db[0] & ~(BM_LEFT_SHIFT(sb[0], ls))) |
                        (hb[0] & (BM_LEFT_SHIFT(sb[0], ls)));
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }
        break;

#ifdef DBGwarn
    default:
        printf("gp_bitblt32: Illegal FC_code = %x\n", fc);
        break;
#endif
    }
} /* gp_bitblt32 */


/* ---------------------------------------------------------------------
 *      gp_pixels16(): fill pixels onto character cache
 * --------------------------------------------------------------------- */
void    gp_pixels16(bufferptr, logical, no_pixel, pixelist)
struct  bitmap    FAR *bufferptr;
fix               logical;
fix               no_pixel;
PIXELIST     FAR *pixelist;
{
    fix16    FAR *ptr;
    PIXELIST xc, yc;

    while(no_pixel--) {
       xc = *pixelist++;
       yc = *pixelist++;
       ptr = (fix16 FAR *)( bufferptr->bm_addr +
             (xc >> 4 << 1) + (yc * (bufferptr->bm_cols >> 3)) );

       *ptr = (ONE1_16 LSHIFT (xc & SHORTMASK)) | *ptr;
    }

    return;
} /* gp_pixels16 */

/* ---------------------------------------------------------------------
 *      gp_pixels32(): fill pixels onto page buffer
 * --------------------------------------------------------------------- */
void    gp_pixels32(bufferptr, logical, no_pixel, pixelist)
struct  bitmap    FAR *bufferptr;
ufix               logical;             /* @WIN */
fix               no_pixel;
PIXELIST     FAR *pixelist;
{
   ufix      FAR *ptr, FAR *ht_ptr;
   PIXELIST  xc, yc;

   switch(logical){

     case FC_BLACK:
        while(no_pixel--) {
           xc = *pixelist++;
           yc = *pixelist++;
           ptr = (ufix FAR *)( (ufix FAR *)bufferptr->bm_addr +
                 (xc >> WORDPOWER) + yc * (bufferptr->bm_cols >> WORDPOWER) );

           *ptr = (ufix)(ONE1_32 LSHIFT (xc & WORDMASK)) | *ptr;        //@WIN
        }
        break;

     case FC_WHITE:
        while(no_pixel--) {
           xc = *pixelist++;
           yc = *pixelist++;
           ptr = (ufix FAR *)( (ufix FAR *)bufferptr->bm_addr+
                 (xc >> WORDPOWER) + yc * (bufferptr->bm_cols >> WORDPOWER) );

           *ptr = (ufix)(~(ONE1_32 LSHIFT (xc & WORDMASK))) & *ptr; //@WIN
        }
        break;

     case HT_APPLY:
        /* apply halftone */
        while(no_pixel--) {
           xc = *pixelist++;
           yc = *pixelist++;
           ptr = (ufix FAR *)( (ufix FAR *)bufferptr->bm_addr +
                 (xc >> WORDPOWER) + yc * (bufferptr->bm_cols >> WORDPOWER) );
           ht_ptr = (ufix FAR *)
                ((ufix FAR *)HTB_BASE  + (yc % HT_HEIGH) * (HT_WIDTH >>
                 WORDPOWER) + (xc >> WORDPOWER) );
          /*
           * filling also apply halftone
           */
           *ptr = (ufix)((ONE1_32 LSHIFT (xc & WORDMASK)) & *ht_ptr) | *ptr;//@WIN
        }
        break;

      default:
        break;
   }

   return;
} /* gp_pixels32 */

void   gp_cacheblt16(dbuf_ptr, dx, dy, swidth, sheight, sbuf_ptr, sx, sy)
struct bitmap FAR *sbuf_ptr, FAR *dbuf_ptr;
fix           dx, dy, swidth, sheight, sx, sy;
{
register  ufix16        FAR *sbase, FAR *dbase;
register  fix           sword, dword, nwords, offD;
ufix16        FAR *src_addr, FAR *dst_addr;
fix           soffset, doffset;
fix           lmask, rmask, i, j;

#ifdef DBG
  printf("Enter gp_cacheblt16()\n");
  printf("   src addr = %lx, dest addr = %lx, sx = %lx, sy = %lx\n",
          sbuf_ptr->bm_addr, dbuf_ptr->bm_addr, sx, sy);
  printf("w = %ld, h = %ld\n", swidth, sheight);
#endif

        /*
         * caculate source & destination bitmap starting address and offset in
         * a word.
         */
        src_addr = (ufix16 FAR *)((ufix16 FAR *)sbuf_ptr->bm_addr +
                   (sy * (sbuf_ptr->bm_cols >> SHORTPOWER) )+
                   ( sx >> SHORTPOWER) );
        soffset = (BITSPERSHORT - (sx & SHORTMASK));
        dst_addr = (ufix16 FAR *)((ufix16 FAR *)dbuf_ptr->bm_addr +
                   (dy * (dbuf_ptr->bm_cols >> SHORTPOWER)) +
                   ( dx >> SHORTPOWER) );
        doffset = (BITSPERSHORT - (dx & SHORTMASK));


        /*
         * setup constant for row copy
         */
        lmask = (ufix16)(ONE16 LSHIFT (BITSPERSHORT-doffset));  //@WIN
        nwords = (swidth - doffset) >> SHORTPOWER;
        rmask = BRSHIFT((ufix16)ONE16,(BITSPERSHORT - ((swidth - doffset) %
                               BITSPERSHORT)),16);      //@WIN
        offD = (doffset > soffset)
               ? (doffset - soffset)
               : (BITSPERSHORT - (soffset - doffset));

#ifdef DBG
   printf("soff=%d, doff=%d, offD=%d, nwords=%d, lmask=%x, rmask=%x\n",
           soffset, doffset, offD, nwords, lmask, rmask);
#endif

    if(swidth < doffset) {
      lmask &= ONE16  RSHIFT (doffset - swidth);

      for(i=0; i<sheight; i++) {

        sbase = src_addr;
        dbase = dst_addr;
        sword = (doffset > soffset)
                ? *sbase++
                : 0;

        dword = (sword RSHIFT offD) + (*sbase LSHIFT (BITSPERSHORT - offD));
        *dbase = (dword & lmask) + (*dbase & ~lmask);

        src_addr += (sbuf_ptr->bm_cols >> SHORTPOWER);
        dst_addr += (dbuf_ptr->bm_cols >> SHORTPOWER);
      } /* for */

      return;
    } /* if (swidth < doffset) */
    else {

      for(i=0; i<sheight; i++) {
        sbase = src_addr;
        dbase = dst_addr;
        j = nwords;
        sword = (doffset > soffset)
                ? *sbase++
                : 0;

           /* move left uncomplete word */
/*
        dword = (sword RSHIFT offD) + (*sbase LSHIFT (BITSPERSHORT - offD));
 */
        dword = BRSHIFT(sword,offD,16) +
                BLSHIFT(*sbase,(BITSPERSHORT - offD),16);
        *dbase = ((*dbase | dword) & lmask) + (*dbase & ~lmask);
        dbase++;

              /* move # of complete word */
        while(j-- > 0) {
             sword = *sbase++;
/*
             dword = (sword RSHIFT offD) +
                     (*sbase LSHIFT (BITSPERSHORT - offD));
 */
             dword = BRSHIFT(sword,offD,16) +
                     BLSHIFT(*sbase,(BITSPERSHORT - offD),16);
             *dbase = *dbase | dword;
             dbase++;
        }

              /* move right uncomplete word */
        sword = *sbase++;
/*
        dword = (sword RSHIFT offD) + (*sbase LSHIFT (BITSPERSHORT - offD));
 */
        dword = BRSHIFT(sword,offD,16) +
                BLSHIFT(*sbase,(BITSPERSHORT - offD),16);
        *dbase = ((*dbase | dword) & rmask) + (*dbase & ~rmask);

        src_addr += (sbuf_ptr->bm_cols >> SHORTPOWER);
        dst_addr += (dbuf_ptr->bm_cols >> SHORTPOWER);

      } /*for*/
    } /* else */

    return;

} /* gp_cacheblt16 */

#ifndef LBODR
/* ***********************************************************************
 *      gp_bitblt16_32(): Bitblt with 16 bits to 32 bits operation.
 *
 * fill from cache to page, used in high bit ording 32 bits enviroment
 * *********************************************************************** */
void
gp_bitblt16_32(dst, dx, dy, w, h, fc, src, sx, sy)
struct bitmap FAR     *dst;
fix                     dx, dy;
fix                     w, h;
ufix16                  fc;
struct bitmap FAR     *src;
fix                     sx, sy;
{
    fix                 dw;
    BM_DATYP       huge *db;        /*@WIN 04-15-92*/
    fix                 sw;
    ufix16             FAR *sb;
    fix                 hw;
    fix                 hy;
    BM_DATYP           FAR *hb;
    fix                 ls, rs;
    fix                 xs, xe;
    fix                 now, cow;
    BM_DATYP           FAR *hs;
    ufix32              dword, tword, tmp0;       /*@WIN*/

#ifdef  DBG
    printf("bitblt16_32: %6.6lx %4x %4x %4x %4x %4.4x %6.6lx %4x %4x\n",
           dst->bm_addr, dx, dy, w, h, fc, src->bm_addr, sx, sy);
#endif

    /*  calculate starting address and width in words
     */
    dw = dst->bm_cols >> BM_WORD_POWER;                         /* @DST */
    db = (BM_DATYP huge *) dst->bm_addr +                       /*@WIN*/
         ((ufix32)dy * dw + ((ufix32)dx >> BM_WORD_POWER));     /*@WIN*/
    sw = src->bm_cols >> SHORTPOWER;                            /* @SRC */
    sb =  ((ufix16 FAR *) src->bm_addr);


    //NTFIX this is only an issue with platforms that dont allow access
    //      to memory posotiong 0
    //
    if (sb == NULL || w == 0 || h == 0 ) {
       return;
    }
    /*  calculate starting and ending coordinate of x
     */
    xs = dx;
    xe = dx + w - 1;
    now = ((fix)(xe & BM_ALIGN_MASK) - (fix)(xs & BM_ALIGN_MASK)) >> BM_WORD_POWER;
                                                 /* cast fix 10/16/92 @WIN */

    /*  calculate shifts and masks based on from SRC to DST
     */
    rs = dx & BM_PIXEL_MASK;                            /* right shift */
    ls = BM_PIXEL_WORD - rs;                            /* left  shift */

                            /*  D <- (D .AND. .NOT. S) .OR.
                                     (S .AND. HT)                   */
    /*  calculate starting address/y and width in words
     */
    hw = HTB_Bmap.bm_cols >> BM_WORD_POWER;
    hy = dy % HTB_Bmap.bm_rows;
    hs = (BM_DATYP FAR *)HTB_Bmap.bm_addr + (dx >> BM_WORD_POWER);
    hb = hs + (hy * hw);

    if (w & BM_PIXEL_MASK) {            /* 2 byte boundry */
        if (rs  == 0x00)                /* no left/right shift? */
        {
            for (dw-= now, sw-= (now + now), hw-= now; h > 0;
                 db+= dw, sb+= sw, h--)
            {
                for (cow = now; cow > 0x00; db++, hb++, cow--) {
                     dword = *sb++;
                     dword = (dword << 16) | *sb++;
                     SWAPWORD(dword);                  /*@WIN*/
                     db[0] = (db[0] & ~(dword)) | (hb[0] & dword);
                }
                dword = *sb;
                dword = (dword << 16);
                SWAPWORD(dword);                  /*@WIN*/
                db[0] = (db[0] & ~(dword)) | (hb[0] & dword);
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }
        else if (now == 0x00)           /* totally within one word? */
        {
            for (; h > 0; db+= dw, sb+= sw, h--)
            {
                dword = *sb;
                dword = (dword << 16);
                S2WORDSWAP(dword);                      /*@WIN begin*/
                tmp0 = BM_RIGH_SHIFT(dword, rs);
                LWORDSWAP(tmp0);
                db[0] = (db[0] & ~tmp0) | (hb[0] & tmp0);       /*@WIN end*/
                /*      @WIN
                db[0] = (db[0] & ~(BM_RIGH_SHIFT(dword, rs))) |
                        (hb[0] &  (BM_RIGH_SHIFT(dword, rs)));
                */
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }
        else  if (now == 0x01)          /* just crossing two words? */
        {
            if (w <= BM_PIXEL_WORD)     /* one word crossing two words? */
            {
                for (; h > 0; db+= dw, sb+= sw, h--)
                {
                    dword = *sb;
                    dword = (dword << 16);
                    S2WORDSWAP(dword);                          /*@WIN begin*/
                    tmp0 = BM_RIGH_SHIFT(dword, rs);
                    LWORDSWAP(tmp0);
                    db[0] = (db[0] & ~tmp0) | (hb[0] & tmp0);
                    /*  @WIN
                    db[0] = (db[0] & ~(BM_RIGH_SHIFT(dword, rs))) |
                            (hb[0] &   BM_RIGH_SHIFT(dword, rs));
                    */
                    tmp0 = BM_LEFT_SHIFT(dword, ls);
                    LWORDSWAP(tmp0);
                    db[1] = (db[1] & ~tmp0) | (hb[1] & tmp0);    /*@WIN end*/
                    /*  @WIN
                    db[1] = (db[1] & ~(BM_LEFT_SHIFT(dword, ls))) |
                            (hb[1] &   BM_LEFT_SHIFT(dword, ls));
                    */
                    hy++;
                    if (hy == HTB_Bmap.bm_rows)
                    {
                        hy =  0;
                        hb = hs;
                    } else
                        hb += hw;
                }
            }
            else                        /* two words crossing two words! */
            {
                for (sw-= 2; h > 0; db+= dw, sb+= sw, h--)
                {
                    dword = *sb++;
                    dword = (dword << 16) | *sb++;
                    S2WORDSWAP(dword);                  /*@WIN*/
                    tword = *sb;
                    tword = (tword << 16);
                    S2WORDSWAP(tword);                          /*@WIN begin*/
                    tmp0 = BM_RIGH_SHIFT(dword, rs);
                    LWORDSWAP(tmp0);
                    db[0] = (db[0] & ~tmp0) | (hb[0] & tmp0);
                    /*  @WIN
                    db[0] = (db[0] & ~(BM_RIGH_SHIFT(dword, rs))) |
                            (hb[0] &   BM_RIGH_SHIFT(dword, rs));
                    */
                    tmp0 = BM_LEFT_SHIFT(dword, ls) | BM_RIGH_SHIFT(tword, rs);
                    LWORDSWAP(tmp0);
                    db[1] = (db[1] & ~tmp0) | (hb[1] & tmp0);   /*@WIN end*/
                    /*  @WIN
                    db[1] = (db[1] & ~(BM_LEFT_SHIFT(dword, ls)
                                   |   BM_RIGH_SHIFT(tword, rs))) |
                            (hb[1] &  (BM_LEFT_SHIFT(dword, ls)
                                   |   BM_RIGH_SHIFT(tword, rs)));
                    */
                    hy++;
                    if (hy == HTB_Bmap.bm_rows)
                    {
                        hy =  0;
                        hb = hs;
                    } else
                        hb += hw;
                }
            }
        }
        else                            /* crossing more than two words! */
        {
            cow = w >> BM_WORD_POWER;
            if (now == cow)
            {
                for (dw-= now, sw-= (now + now),
                     hw-= now; h > 0; db+= dw, sb+= sw, h--)
                {
                    dword = *sb++;
                    dword = (dword << 16) | *sb++;
                    S2WORDSWAP(dword);                          /*@WIN begin*/
                    tmp0 = BM_RIGH_SHIFT(dword, rs);
                    LWORDSWAP(tmp0);
                    db[0] = (db[0] & ~tmp0) | (hb[0] & tmp0);   /*@WIN end*/
                    /*  @WIN
                    db[0] = (db[0] & ~(BM_RIGH_SHIFT(dword, rs))) |
                            (hb[0] &  (BM_RIGH_SHIFT(dword, rs)));
                    */
                    for (db++, hb++, cow = now; cow >= 0x02;
                         db++, hb++, cow--)
                    {
                        tword = dword;
                        dword = *sb++;
                        dword = (dword << 16) | *sb++;
                        S2WORDSWAP(dword);                      /*@WIN begin*/
                        tmp0 = BM_LEFT_SHIFT(tword, ls) |
                               BM_RIGH_SHIFT(dword, rs);
                        LWORDSWAP(tmp0);
                        db[0] = (db[0] & ~tmp0) | (hb[0] & tmp0); /*@WIN end*/
                        /*      @WIN
                        db[0] = (db[0] & ~(BM_LEFT_SHIFT(tword, ls)
                                       |   BM_RIGH_SHIFT(dword, rs))) |
                                (hb[0] &  (BM_LEFT_SHIFT(tword, ls)
                                       |   BM_RIGH_SHIFT(dword, rs)));
                        */
                    }
                    tword = dword;
                    dword = *sb;
                    dword = (dword << 16);
                    S2WORDSWAP(dword);                      /*@WIN begin*/
                    tmp0 = BM_LEFT_SHIFT(tword, ls) |
                           BM_RIGH_SHIFT(dword, rs);
                    LWORDSWAP(tmp0);
                    db[0] = (db[0] & ~tmp0) | (hb[0] & tmp0); /*@WIN end*/
                    /*  @WIN
                    db[0] = (db[0] & ~(BM_LEFT_SHIFT(tword, ls)
                                   |   BM_RIGH_SHIFT(dword, rs))) |
                            (hb[0] &  (BM_LEFT_SHIFT(tword, ls)
                                   |   BM_RIGH_SHIFT(dword, rs)));
                    */
                    hy++;
                    if (hy == HTB_Bmap.bm_rows)
                    {
                        hy =  0;
                        hb = hs;
                    } else
                        hb += hw;
                }
            }
            else
            {
                for (dw-= now, sw-= (now + now - 2),
                     hw-= now; h > 0; db+= dw, sb+= sw, h--)
                {
                    dword = *sb++;
                    dword = (dword << 16) | *sb++;
                    S2WORDSWAP(dword);                      /*@WIN begin*/
                    tmp0 = BM_RIGH_SHIFT(dword, rs);
                    LWORDSWAP(tmp0);
                    db[0] = (db[0] & ~tmp0) | (hb[0] & tmp0); /*@WIN end*/
                    /*  @WIN
                    db[0] = (db[0] & ~(BM_RIGH_SHIFT(dword, rs))) |
                            (hb[0] &  (BM_RIGH_SHIFT(dword, rs)));
                    */
                    for (db++, hb++, cow = now; cow > 0x02;
                         db++, hb++, cow--)
                    {
                        tword = dword;
                        dword = *sb++;
                        dword = (dword << 16) | *sb++;
                        S2WORDSWAP(dword);                      /*@WIN begin*/
                        tmp0 = BM_LEFT_SHIFT(tword, ls) |
                               BM_RIGH_SHIFT(dword, rs);
                        LWORDSWAP(tmp0);
                        db[0] = (db[0] & ~tmp0) | (hb[0] & tmp0); /*@WIN end*/
                        /*      @WIN
                        db[0] = (db[0] & ~(BM_LEFT_SHIFT(tword, ls)
                                       |   BM_RIGH_SHIFT(dword, rs))) |
                                (hb[0] &  (BM_LEFT_SHIFT(tword, ls)
                                       |   BM_RIGH_SHIFT(dword, rs)));
                        */
                    }
                    tword = dword;
                    dword = *sb;
                    dword = (dword << 16);
                    S2WORDSWAP(dword);                      /*@WIN begin*/
                    tmp0 = BM_LEFT_SHIFT(tword, ls) |
                           BM_RIGH_SHIFT(dword, rs);
                    LWORDSWAP(tmp0);
                    db[0] = (db[0] & ~tmp0) | (hb[0] & tmp0);
                    ++db; ++hb;
                    /*  @WIN
                    *db++ = (*db   & ~(BM_LEFT_SHIFT(tword, ls)
                                   |   BM_RIGH_SHIFT(dword, rs))) |
                            (*hb++ &  (BM_LEFT_SHIFT(tword, ls)
                                   |   BM_RIGH_SHIFT(dword, rs)));
                    */
                    tmp0 = BM_LEFT_SHIFT(dword, ls);
                    LWORDSWAP(tmp0);
                    db[0] = (db[0] & ~tmp0) | (hb[0] & tmp0);    /*@WIN end*/
                    /*  @WIN
                    db[0] = (db[0] & ~(BM_LEFT_SHIFT(dword, ls))) |
                            (hb[0] &  (BM_LEFT_SHIFT(dword, ls)));
                    */
                    hy++;
                    if (hy == HTB_Bmap.bm_rows)
                    {
                        hy =  0;
                        hb = hs;
                    } else
                        hb += hw;
                }
            }
        }

    } else {                            /* 4 byte boundry */
        if (rs  == 0x00)                /* no left/right shift? */
        {
            for (dw-= now + 1, sw-= ((now + 1) << 1), hw-= now + 1; h > 0;
                 db+= dw, sb+= sw, h--)
            {
                for (cow = now; cow >= 0x00; db++, hb++, cow--) {
                    dword = *sb++;
                    dword = (dword << 16) | *sb++;
                    SWAPWORD(dword);                   /*@WIN*/
                    db[0] = (db[0] & ~(dword)) | (hb[0] & dword);
                }
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }
        else if (now == 0x00)           /* totally within one word? */
        {
            for (sw-= 1; h > 0; db+= dw, sb+= sw, h--)
            {
                dword = *sb++;
                dword = (dword << 16) | *sb;
                S2WORDSWAP(dword);              /*@WIN begin*/
                tmp0 = BM_RIGH_SHIFT(dword, rs);
                LWORDSWAP(tmp0);
                db[0] = (db[0] & ~tmp0) | (hb[0] & tmp0);       /*@WIN end*/
                /*      @WIN
                db[0] = (db[0] & ~(BM_RIGH_SHIFT(dword, rs))) |
                        (hb[0] &  (BM_RIGH_SHIFT(dword, rs)));
                */
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }
        else  if (now == 0x01)          /* just crossing two words? */
        {
            if (w <= BM_PIXEL_WORD)     /* one word crossing two words? */
            {
                for (sw-= 1; h > 0; db+= dw, sb+= sw, h--)
                {
                    dword = *sb++;
                    dword = (dword << 16) | *sb;
                    S2WORDSWAP(dword);              /*@WIN begin*/
                    tmp0 = BM_RIGH_SHIFT(dword, rs);
                    LWORDSWAP(tmp0);
                    db[0] = (db[0] & ~tmp0) | (hb[0] & tmp0);
                    /*  @WIN
                    db[0] = (db[0] & ~(BM_RIGH_SHIFT(dword, rs))) |
                            (hb[0] &   BM_RIGH_SHIFT(dword, rs));
                    */
                    tmp0 = BM_LEFT_SHIFT(dword, ls);
                    LWORDSWAP(tmp0);
                    db[1] = (db[1] & ~tmp0) | (hb[1] & tmp0);   /*@WIN end*/
                    /*  @WIN
                    db[1] = (db[1] & ~(BM_LEFT_SHIFT(dword, ls))) |
                            (hb[1] &   BM_LEFT_SHIFT(dword, ls));
                    */
                    hy++;
                    if (hy == HTB_Bmap.bm_rows)
                    {
                        hy =  0;
                        hb = hs;
                    } else
                        hb += hw;
                }
            }
            else                        /* two words crossing two words! */
            {
                for (sw-= 3; h > 0; db+= dw, sb+= sw, h--)
                {
                    dword = *sb++;
                    dword = (dword << 16) | *sb++;
                    S2WORDSWAP(dword);              /*@WIN*/
                    tword = *sb++;
                    tword = (tword << 16) | *sb;
                    S2WORDSWAP(tword);              /*@WIN begin*/
                    tmp0 = BM_RIGH_SHIFT(dword, rs);
                    LWORDSWAP(tmp0);
                    db[0] = (db[0] & ~tmp0) | (hb[0] & tmp0);
                    /*  @WIN
                    db[0] = (db[0] & ~(BM_RIGH_SHIFT(dword, rs))) |
                            (hb[0] &   BM_RIGH_SHIFT(dword, rs));
                    */
                    tmp0 = BM_LEFT_SHIFT(dword, ls) | BM_RIGH_SHIFT(tword, rs);
                    LWORDSWAP(tmp0);
                    db[1] = (db[1] & ~tmp0) | (hb[1] & tmp0);   /*@WIN end*/
                    /*  @WIN
                    db[1] = (db[1] & ~((BM_LEFT_SHIFT(dword, ls)
                                   |   BM_RIGH_SHIFT(tword, rs)))) |
                            (hb[1] &  ((BM_LEFT_SHIFT(dword, ls)
                                   |   BM_RIGH_SHIFT(tword, rs))));
                    */
                    hy++;
                    if (hy == HTB_Bmap.bm_rows)
                    {
                        hy =  0;
                        hb = hs;
                    } else
                        hb += hw;
                }
            }
        }
        else                            /* crossing more than two words! */
        {
            for (dw-= now, sw-= (now + now),
                 hw-= now; h > 0; db+= dw, sb+= sw, h--)
            {
                dword = *sb++;
                dword = (dword << 16) | *sb++;
                S2WORDSWAP(dword);              /*@WIN*/
                tmp0 = BM_RIGH_SHIFT(dword, rs);     /*@WIN*/
                LWORDSWAP(tmp0);
                db[0] = (db[0] & ~tmp0) | /*@WIN*/
                        (hb[0] & tmp0);  /*@WIN*/
                /*      @WIN
                db[0] = (db[0] & ~(BM_RIGH_SHIFT(dword, rs))) |
                        (hb[0] &   BM_RIGH_SHIFT(dword, rs));
                */
                for (db++, hb++, cow = now; cow >= 0x02;
                     db++, hb++, cow--)
                {
                    tword = dword;
                    dword = *sb++;
                    dword = (dword << 16) | *sb++;
                    S2WORDSWAP(dword);          /*@WIN begin*/
                    tmp0 = BM_LEFT_SHIFT(tword, ls) | BM_RIGH_SHIFT(dword, rs);
                    LWORDSWAP(tmp0);
                    db[0] = (db[0] & ~tmp0) |
                            (hb[0] & tmp0);     /*@WIN end*/
                /*      @WIN
                    db[0] = (db[0] & ~(BM_LEFT_SHIFT(tword, ls)
                                   |   BM_RIGH_SHIFT(dword, rs))) |
                            (hb[0] &  (BM_LEFT_SHIFT(tword, ls)
                                   |   BM_RIGH_SHIFT(dword, rs)));
                */
                }
                tmp0 = BM_LEFT_SHIFT(dword, ls);        /*@WIN begin*/
                LWORDSWAP(tmp0);
                db[0] = (db[0] & ~tmp0) |
                        (hb[0] & tmp0);     /*@WIN end*/
                /*      @WIN
                db[0] = (db[0] & ~(BM_LEFT_SHIFT(dword, ls))) |
                        (hb[0] &  (BM_LEFT_SHIFT(dword, ls)));
                */
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }
   }
} /* gp_bitblt16_32 */

#endif

/* ---------------------------------------------------------------------
 *      gp_charblt: a group of bitblt functions for char cache bitblt
 *                  with following logical operations:
 *                  FC_BLACK: source  --> destination.
 *                  FC_WHITE: (^source) AND (destination) --> destination
 *
 *      gp_charblt16(): for cache bitmap width = 16 * X
 *      gp_charblt32(): for cache bitmap width = 32 * X
 * --------------------------------------------------------------------- */

#ifdef  LBODR

/* **********************************************************************
 *      gp_charblt16: move character bitmap from cache to frame buffer
 *                    with cache bitmap width multiple of 16
 *      width_height: width<<16 | height
 *      shift_code:   shift<<16 | code
 * ********************************************************************** */
void gp_charblt16(charimage, charbitmap, width_height, shift_code)
ufix16 FAR *charimage, FAR *charbitmap;
fix width_height, shift_code;
{
        register fix    savewidth;
        register ufix   wordsline, leftsh;
        register ufix16 bitmapline;
        register ufix16 FAR *chimagep;

#ifdef DBGchar
   printf("gp_charblt16() : %lx, %lx, %lx, %lx\n", charimage, charbitmap,
           width_height, shift_code);
#endif
        leftsh = shift_code >> 16;
        savewidth = width_height >> 16;
        width_height &= 0xffff;
        wordsline = FB_WIDTH >> SHORTPOWER;

#ifdef DBG
   printf("width_height = %lx, shift_code = %lx\n", width_height, shift_code);
#endif

    switch(shift_code & 0xffff) {

      case FC_MERGE:
           while (width_height--) {
              chimagep = charimage;
              shift_code = savewidth;
              do  {
                      bitmapline = *charbitmap++;
                      *chimagep++ |= (bitmapline LSHIFT leftsh);
/*
                      *chimagep |= (bitmapline RSHIFT (16 - leftsh));
 */
                      *chimagep |= BRSHIFT(bitmapline,(16 - leftsh),16);
              } while ((shift_code -= 16) > 0);
              charimage += wordsline;
           }
        break;

      case FC_CLEAR:
           while (width_height--) {
              chimagep = charimage;
              shift_code = savewidth;
              do  {
                      bitmapline = *charbitmap++;
                      *chimagep++ &= ~(bitmapline LSHIFT leftsh);
/*
                      *chimagep &= ~(bitmapline RSHIFT (16 - leftsh));
 */
                      *chimagep &= ~(BRSHIFT(bitmapline,(16 - leftsh),16));
              } while ((shift_code -= 16) > 0);
              charimage += wordsline;
           }

    } /* switch */

} /* gp_charblt16 */


/* **********************************************************************
 *      gp_charblt32: move character bitmap from cache to frmae buffer
 *                    with cache bitmap width multiple of 32
 *      width_height: width<<16 | height
 *      shift_code:   shift<<16 | code
 * ********************************************************************** */
void gp_charblt32(charimage, charbitmap, width_height, shift_code)
ufix   FAR *charimage, FAR *charbitmap;
fix    width_height, shift_code;
{
        register fix    savewidth;
        register ufix   wordsline, leftsh;
        register ufix   bitmapline;
        register ufix   FAR *chimagep;
#ifdef DBGchar
   printf("gp_charblt32() : %lx, %lx, %lx, %lx\n", charimage, charbitmap,
           width, height);
#endif

        leftsh = shift_code >> 16;
        savewidth = width_height >> 16;
        width_height &= 0xffff;
        wordsline = FB_WIDTH >> WORDPOWER;

#ifdef DBG
   printf("width_height = %lx, shift_code = %lx\n", width_height, shift_code);
#endif

    switch(shift_code & 0xffff) {

      case FC_MERGE:
           while (width_height--) {
              chimagep = charimage;
              shift_code = savewidth;
              do  {
                      bitmapline = *charbitmap++;
                      *chimagep++ |= (bitmapline LSHIFT leftsh);
/*
                      *chimagep |= (bitmapline RSHIFT (32 - leftsh));
 */
                      *chimagep |= BRSHIFT(bitmapline,(32 - leftsh),32);
              } while ((shift_code -= 32) > 0);
              charimage += wordsline;
           }
        break;

      case FC_CLEAR:
           while (width_height--) {
              chimagep = charimage;
              shift_code = savewidth;
              do  {
                      bitmapline = *charbitmap++;
                      *chimagep++ &= ~(bitmapline LSHIFT leftsh);
/*
                      *chimagep &= ~(bitmapline RSHIFT (32 - leftsh));
 */
                      *chimagep &= ~(BRSHIFT(bitmapline,(32 - leftsh),32));
              } while ((shift_code -= 32) > 0);
              charimage += wordsline;
           }
        break;

    } /* switch */

} /* gp_charblt32 */

#else

/* **********************************************************************
 *      gp_charblt16: move character bitmap from cache to frmae buffer
 *                    with cache bitmap width multiple of 16
 *      width_height: width<<16 | height
 *      shift_code:   shift<<16 | code
 * ********************************************************************** */
void gp_charblt16(charimage, charbitmap, width_height, shift_code)
ufix32  huge *charimage;        /*@WIN*/
ufix16  FAR *charbitmap;
ufix32  width_height, shift_code;       /*@WIN*/
{
        register fix32    savewidth;            /*@WIN*/
        register ufix32   wordsline, leftsh;    /*@WIN*/
        register ufix32   bitmapline, width;    /*@WIN*/
        register ufix32   dw, righsh, tmp;      /*@WIN*/

#ifdef DBGchar
   printf("gp_charblt16() : %lx, %lx, %lx, %lx\n", charimage,
                 charbitmap, width_height, shift_code);
#endif
        leftsh = shift_code >> 16;
        savewidth = width_height >> 16;
        width_height &= 0xffff;
        wordsline = savewidth >> WORDPOWER;
        dw = FBX_Bmap.bm_cols >> WORDPOWER;

#ifdef DBG
   printf("width_height = %lx, shift_code = %lx\n", width_height, shift_code);
#endif

    switch(shift_code & 0xffff) {

      case FC_MERGE:

        if (leftsh)
        {
           righsh = BITSPERWORD - leftsh;
           dw -= (wordsline + 1);
           while (width_height--) {
              width = wordsline;
              while (width--) {
                   bitmapline = *charbitmap++;
                   bitmapline = (bitmapline << 16) | *charbitmap++;

                   S2WORDSWAP(bitmapline);              /*@WIN*/

                   tmp = (bitmapline >> leftsh);        /*@WIN*/
                   *charimage++ |= LWORDSWAP(tmp);      /*@WIN*/
                   tmp = (bitmapline << righsh);        /*@WIN*/
                   *charimage   |= LWORDSWAP(tmp);      /*@WIN*/
              }
              bitmapline = *charbitmap++;
              bitmapline = bitmapline << 16;

              S2WORDSWAP(bitmapline);                   /*@WIN*/

              tmp = (bitmapline >> leftsh);             /*@WIN*/
              *charimage++ |= LWORDSWAP(tmp);           /*@WIN*/
              tmp = (bitmapline << righsh);             /*@WIN*/
              *charimage   |= LWORDSWAP(tmp);           /*@WIN*/
              charimage += dw;
           }
        }
        else
        {
           dw -= wordsline;
           while (width_height--) {
              width = wordsline;
              while (width--) {
                   bitmapline = *charbitmap++;
                   bitmapline = (bitmapline << 16) | *charbitmap++;
                   *charimage++ |= WORDSWAP(bitmapline);        /*@WIN*/
              }
              bitmapline = *charbitmap++;
              bitmapline = bitmapline << 16;
              *charimage |= WORDSWAP(bitmapline);               /*@WIN*/
              charimage += dw;
           }
        }
        break;

      case FC_CLEAR:

        if (leftsh)
        {
           righsh = BITSPERWORD - leftsh;
           dw -= (wordsline + 1);
           while (width_height--) {
              width = wordsline;
              while (width--) {
                   bitmapline = *charbitmap++;
                   bitmapline = (bitmapline << 16) | *charbitmap++;
                   S2WORDSWAP(bitmapline);              /*@WIN*/
                   tmp = ~(bitmapline >> leftsh);       /*@WIN*/
                   *charimage++ &= LWORDSWAP(tmp);      /*@WIN*/
                   tmp = ~(bitmapline << righsh);       /*@WIN*/
                   *charimage   &= LWORDSWAP(tmp);      /*@WIN*/
              }
              bitmapline = *charbitmap++;
              bitmapline = bitmapline << 16;
              S2WORDSWAP(bitmapline);                   /*@WIN*/
              tmp = ~(bitmapline >> leftsh);            /*@WIN*/
              *charimage++ &= LWORDSWAP(tmp);           /*@WIN*/
              tmp = ~(bitmapline << righsh);            /*@WIN*/
              *charimage   &= LWORDSWAP(tmp);           /*@WIN*/
              charimage += dw;
           }
        }
        else
        {
           dw -= wordsline;
           while (width_height--) {
              width = wordsline;
              while (width--) {
                   bitmapline = *charbitmap++;
                   bitmapline = (bitmapline << 16) | *charbitmap++;
                   WORDSWAP(bitmapline);                /*@WIN*/
                   *charimage++ &= ~bitmapline;
              }
              bitmapline = *charbitmap++;
              bitmapline = bitmapline << 16;
              WORDSWAP(bitmapline);                     /*@WIN*/
              *charimage &= ~bitmapline;
              charimage += dw;
           }
        }
        break;

    } /* switch */

} /* gp_charblt16 */


/* **********************************************************************
 *      gp_charblt32: move character bitmap from cache to frmae buffer
 *                    with cache bitmap width multiple of 32
 *      width_height: width<<16 | height
 *      shift_code:   shift<<16 | code
 * ********************************************************************** */
void gp_charblt32(charimage, charbitmap, width_height, shift_code)
ufix32  huge *charimage, FAR *charbitmap;       /*@WIN*/
ufix32  width_height, shift_code;               /*@WIN*/
{
        register fix32    savewidth;            /*@WIN*/
        register ufix32   wordsline, leftsh;    /*@WIN*/
        register ufix32   bitmapline, width;    /*@WIN*/
        register ufix32   dw, righsh, tmp;      /*@WIN*/
#ifdef DBGchar
   printf("gp_charblt32() : %lx, %lx, %lx, %lx\n", charimage,
                 charbitmap, width_height, shift_code);
#endif
        leftsh = shift_code >> 16;
        savewidth = width_height >> 16;
        width_height &= 0xffff;
        wordsline = savewidth >> WORDPOWER;
        dw = FBX_Bmap.bm_cols >> WORDPOWER;

#ifdef DBG
   printf("width_height = %lx, shift_code = %lx\n", width_height, shift_code);
#endif

    switch(shift_code & 0xffff) {

      case FC_MERGE:

        if (leftsh)
        {
           righsh = BITSPERWORD - leftsh;
           dw -= wordsline;
           while (width_height--) {
                width = wordsline;
                while (width--) {
                   bitmapline = *charbitmap++;
#ifdef LITTLE_ENDIAN /* 03/27/91 */
                   bitmapline = (bitmapline << 16) | (bitmapline >> 16);
#endif
                   LWORDSWAP(bitmapline);                       /*@WIN*/
                   tmp = (bitmapline >> leftsh);                /*@WIN*/
                   *charimage++ |= LWORDSWAP(tmp);              /*@WIN*/
                   tmp = (bitmapline << righsh);                /*@WIN*/
                   *charimage   |= LWORDSWAP(tmp);              /*@WIN*/
                }
                charimage += dw;
            }
        }
        else
        {
           dw -= wordsline;
           while (width_height--) {
                width = wordsline;
                while (width--) {
                   bitmapline = *charbitmap++;
#ifdef LITTLE_ENDIAN /* 03/27/91 */
                   bitmapline = (bitmapline << 16) | (bitmapline >> 16);
#endif
                   *charimage++ |= bitmapline;       /*@WIN*/
                }
                charimage += dw;
            }
        }
        break;

      case FC_CLEAR:

        if (leftsh)
        {
           righsh = BITSPERWORD - leftsh;
           dw -= wordsline;
           while (width_height--) {
                width = wordsline;
                while (width--) {
                   bitmapline = *charbitmap++;
#ifdef LITTLE_ENDIAN /* 03/27/91 */
                   bitmapline = (bitmapline << 16) | (bitmapline >> 16);
#endif
                   LWORDSWAP(bitmapline);                       /*@WIN*/
                   tmp = ~(bitmapline >> leftsh);               /*@WIN*/
                   *charimage++ &= LWORDSWAP(tmp);              /*@WIN*/
                   tmp = ~(bitmapline << righsh);               /*@WIN*/
                   *charimage   &= LWORDSWAP(tmp);              /*@WIN*/
                }
                charimage += dw;
            }
        }
        else
        {
           dw -= wordsline;
           while (width_height--) {
                width = wordsline;
                while (width--) {
                   bitmapline = *charbitmap++;
#ifdef LITTLE_ENDIAN /* 03/27/91 */
                   bitmapline = (bitmapline << 16) | (bitmapline >> 16);
#endif
                   *charimage++ &= ~bitmapline ;
                }
                charimage += dw;
            }
        }
        break;

    } /* switch */

} /* gp_charblt32 */

#endif

/* ------------------------------------------------------------------- */
void
gp_charblt16_cc(dst, w, h, src, sx, sy)
ufix16          FAR     *dst;
fix                     w;
fix                     h;
struct Char_Tbl FAR     *src;
fix                     sx;
fix                     sy;
{
    fix                 sw;
   ufix16              FAR *sb;
    fix                 ls, rs;
    fix                 now, cow;
   ufix16               tmp0, tmp1;     /*@WIN 04-20-92*/

#ifdef  DBG
    printf("charblt16_cc: %6.6lx %4x %4x %4x %4.4x %6.6lx\n",
           dst, sx, sy, w, h, src->bitmap);
#endif

        /*  calculate starting address and width in words
         */
        sw = src->box_w >> SHORTPOWER;                         /* @DST */
        sb = &((ufix16 FAR *) src->bitmap)[sy * sw + (sx >> SHORTPOWER)];

        /*  calculate starting and ending coordinate of x
         */
        now = (w + SHORTMASK) >> SHORTPOWER;
        rs = sx & SHORTMASK;                    /* right shift */
        ls = BITSPERSHORT - rs;                 /* left  shift */

        for (sw-= now; h > 0; sb+= sw, h--)
        {
           cow = now;
           do  {
                   tmp0 = sb[0];        /*@WIN 04-20-92 begin*/
                   tmp1 = sb[1];
                   tmp0 = (ufix16)(BM_LEFT_SHIFT(SWORDSWAP(tmp0), rs) |
                            BM_RIGH_SHIFT(SWORDSWAP(tmp1), ls));//@WIN
                   *dst++ = *dst | SWORDSWAP(tmp0);     /*@WIN 04-20-92 end*/
                /*      @WIN 04-20-92
                   *dst++ = *dst | ((BM_LEFT_SHIFT(sb[0], rs) |
                                     BM_RIGH_SHIFT(sb[1], ls)));
                */
                   sb++;
                } while ((--cow) > 0);
        }
} /* gp_charblt16_cc */


/* ------------------------------------------------------------------- */
void
gp_charblt16_clip(dst, w, h, src, sx, sy)
struct bitmap FAR     *dst;
fix                     w, h;
struct bitmap FAR     *src;
fix                     sx, sy;
{
    fix                 dw;
   ufix16              FAR *db;
    fix                 sw;
   ufix16              FAR *sb;
    fix                 ls, rs;
    fix                 now, cow;
   ufix16               tmp0, tmp1;     /*@WIN 04-20-92*/

#ifdef  DBG
    printf("charblt16_clip: %6.6lx %4x %4x %4x %4.4x %6.6lx\n",
           dst->bm_addr, sx, sy, w, h, src->bm_addr);
#endif

        /*  calculate starting address and width in words
         */
        dw = dst->bm_cols >> SHORTPOWER;                         /* @DST */
        db = (ufix16 FAR *) dst->bm_addr;
        sw = src->bm_cols >> SHORTPOWER;                         /* @SRC */
        sb = &((ufix16 FAR *) src->bm_addr)[sy * sw + (sx >> SHORTPOWER)];

        /*  calculate starting and ending coordinate of x
         */
        now = (w + SHORTMASK) >> SHORTPOWER;
        rs = sx & SHORTMASK;                    /* right shift */

        if (rs == 0x00)                /* no left/right shift? */
        {
            for (dw-= now, sw-= now; h > 0; db+= dw, sb+= sw, h--)
            {
                 cow = now;
                 do {
                     *db++ = *db & *sb++;
                 } while ((--cow) > 0);
            }
        }
        else                            /* crossing more than two words! */
        {
            ls = BITSPERSHORT - rs;                    /* left  shift */
            for (dw-= now, sw-= now; h > 0; db+= dw, sb+= sw, h--)
            {
                 cow = now;
                 do {
                     tmp0 = sb[0];        /*@WIN 04-20-92 begin*/
                     tmp1 = sb[1];
                     tmp0 = (ufix16)(BM_LEFT_SHIFT(SWORDSWAP(tmp0), rs) |
                              BM_RIGH_SHIFT(SWORDSWAP(tmp1), ls)); //@WIN
                     *db++ = *db & (SWORDSWAP(tmp0)); /*@WIN 04-20-92 end*/
                /* @WIN         04-20-92
                     *db++ = *db & ((BM_LEFT_SHIFT(sb[0], rs) |
                                     BM_RIGH_SHIFT(sb[1], ls)));
                */
                      sb++;
                 } while ((--cow) > 0);
            }
        }
} /* gp_charblt16_clip */

/* ------------------------------------------------------------------- */
void
gp_charblt32_clip(dst, w, h, src, sx, sy)
struct bitmap FAR     *dst;
fix                     w, h;
struct bitmap FAR     *src;
fix                     sx, sy;
{
    fix                 dw;
    BM_DATYP           FAR *db;
    fix                 sw;
    BM_DATYP           FAR *sb;
    fix                 ls, rs;
    fix                 now, cow;
   ufix32               tmp0, tmp1;     /*@WIN 04-20-92*/

#ifdef  DBG
    printf("charblt32_clip: %6.6lx %4x %4x %4x %4.4x %6.6lx\n",
           dst->bm_addr, sx, sy, w, h, src->bm_addr);
#endif

        /*  calculate starting address and width in words
         */
        dw = dst->bm_cols >> BM_WORD_POWER;                         /* @DST */
        db = (BM_DATYP FAR *) dst->bm_addr;
        sw = src->bm_cols >> BM_WORD_POWER;                         /* @SRC */
        sb = &((BM_DATYP FAR *) src->bm_addr)[sy * sw + (sx >> BM_WORD_POWER)];

        /*  calculate starting and ending coordinate of x
         */
        now = (w + BM_PIXEL_MASK) >> BM_WORD_POWER;
        rs = sx & BM_PIXEL_MASK;                        /* right shift */


        if (rs == 0x00)                /* no left/right shift? */
        {
            for (dw-= now, sw-= now; h > 0; db+= dw, sb+= sw, h--)
            {
                 cow = now;
                 do {
                     *db++ = *db & *sb++;
                 } while ((--cow) > 0);
            }
        }
        else                            /* crossing more than two words! */
        {
            ls = BM_PIXEL_WORD - rs;                    /* left  shift */
            for (dw-= now, sw-= now; h > 0; db+= dw, sb+= sw, h--)
            {
                 cow = now;
                 do {
                     tmp0 = sb[0];        /*@WIN 04-20-92 begin*/
                     tmp1 = sb[1];
                     tmp0 = (BM_LEFT_SHIFT(LWORDSWAP(tmp0), rs) |
                              BM_RIGH_SHIFT(LWORDSWAP(tmp1), ls));
                     *db++ = *db & LWORDSWAP(tmp0);     /*@WIN 04-20-92 end*/
                /* @WIN 04-20-92
                     *db++ = *db & ((BM_LEFT_SHIFT(sb[0], rs) |
                                     BM_RIGH_SHIFT(sb[1], ls)));
                */
                      sb++;
                 } while ((--cow) > 0);
            }
        }
} /* gp_charblt32_clip */

/* ********************************************************************** *
 *      gp_patblt:      move image seed pattern to frame buffer           *
 *                                                                        *
 *      gp_patblt_m:    move image seed pattern to frame buffer with      *
 *                      clipping mask                                     *
 *                                                                        *
 *      gp_patblt_c:    move image seed pattern to character cache        *
 *                                                                        *
 *                                                                        *
 *      1)  All image seed patterns are in multiple of 32; i.e. ufix      *
 *          aligned.  Unused area of bitmap of any image seed pattern     *
 *          is cleared with zero; i.e. white.                             *
 *                                                                        *
 *      2)  The calling sequence of all patblt functions are same as:     *
 *                                                                        *
 *              struct bitmap near *dst;        (* destination bitmap *)  *
 *              fix                 dx, dy;     (* destination x & y *)   *
 *              fix                 w, h;       (* width and height *)    *
 *              ufix16              fc;         (* function code *)       *
 *              struct bitmap near *src;        (* source bitmap *)       *
 *                                                                        *
 *          Parameter w is not in mutiple of 32, it is the actual width   *
 *          of the image seed pattern instead of width of bitmap of image *
 *          seed pattern.                                                 *
 *                                                                        *
 *      3)  The functions code aceepted by gp_bitblt() and gp_bitblt_m()  *
 *          are FC_CLEAR, FC_MERGE and HT_APPLY.  gp_bitblt_c() can       *
 *          accept FC_MERGE only.                                         *
 *                                                                        *
 *      4)  Both gp_patblt() and gp_patblt_m() refer global variables:    *
 *          HTB_Bmap and HTB_Modula.  gp_patblt_m() also refers global    *
 *          variables: CMB_Xorig and CMB_Yorig.                           *
 *                                                                        *
 *      5)  The following code are expanded to its maximum to gain        *
 *          speed instead of space.  Such rule may be not applicable to   *
 *          RISC graphics environment.  It should be optimized based on   *
 *          the architecture of graphics environment ported.              *
 *                                                                        *
 * ********************************************************************** */
void
gp_patblt(dst, dx, dy, w, h, fc, src)
struct bitmap FAR *dst;
fix                     dx, dy;
fix                     w, h;
ufix16                  fc;
struct bitmap FAR *src;
{
    fix                 dw;
    BM_DATYP           huge *db;        /* FAR => huge @WIN */
    fix                 sw;
    BM_DATYP           FAR *sb;
    fix                 hw;
    fix                 hy;
    BM_DATYP           FAR *hb;
    fix                 ls, rs;
    BM_DATYP            sm;
    fix                 xs, xe;
    fix                 now, cow;
    BM_DATYP           FAR *hs;
    ufix32 tmprs0, tmpls0, tmprs1;   /*@WIN 10-05-92*/

#ifdef  DBGp
    printf("patblt: %6.6lx %4x %4x %4x %4x %4.4x %6.6lx\n",
           dst->bm_addr, dx, dy, w, h, fc, src->bm_addr);
#endif

    /*  calculate starting address and width in words
     */
    dw = dst->bm_cols >> BM_WORD_POWER;                         /* @DST */
//  db = &((BM_DATYP FAR *) dst->bm_addr)[dy * dw + (dx >> BM_WORD_POWER)];
    db = (BM_DATYP huge *) dst->bm_addr +               /*@WIN*/
         ((ufix32)dy * dw + ((ufix32)dx >> BM_WORD_POWER));
    sw = src->bm_cols >> BM_WORD_POWER;                         /* @SRC */
    sb =  ((BM_DATYP FAR *) src->bm_addr);

    /*  calculate starting and ending coordinate of x
     */
    xs = dx;
    xe = dx + w - 1;
    now = ((fix)(xe & BM_ALIGN_MASK) - (fix)(xs & BM_ALIGN_MASK)) >> BM_WORD_POWER;
                                                 /* cast fix 10/16/92 @WIN */

    /*  calculate shifts and masks based on from SRC to DST
     */
    rs = dx & BM_PIXEL_MASK;                            /* right shift */
    ls = BM_PIXEL_WORD - rs;                            /* left  shift */

    if (fc == HT_APPLY) {
/*
    switch (fc)
    {
    case HT_APPLY:  */             /*  D <- (D .AND. .NOT. S) .OR.
                                         (S .AND. HT)                   */
        /*  calculate starting address/y and width in words
         */
        hw = HTB_Bmap.bm_cols >> BM_WORD_POWER;
        hy = dy % HTB_Bmap.bm_rows;
        hs = ((BM_DATYP FAR *) HTB_Bmap.bm_addr +
                           ((dx % HTB_Modula) >> BM_WORD_POWER));
        hb = hs + (hy * hw);

        if (rs == 0x00)                /* no left/right shift? */
        {
            for (dw-= now + 1, hw-= now + 1; h > 0; db+= dw, h--)
            {
                for (cow = now; cow >= 0x00; db++, sb++, hb++, cow--)
                    db[0] = (db[0] & ~(sb[0])) | (hb[0] & (sb[0]));
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }

        else if (now == 0x00)           /* totally within one word? */
        {
            for (; h > 0; db+= dw, sb+= sw, h--)
            {
                                     /*@WIN 10-05-92 begin*/
                tmprs0 = sb[0];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                LWORDSWAP(tmprs0);
                db[0] = (db[0] & ~tmprs0) | (hb[0] & tmprs0);
                                     /*@WIN 04-20-92 end*/
                /*
                db[0] = (db[0] & ~(BM_RIGH_SHIFT(sb[0], rs))) |  //@WIN
                        (hb[0] &  (BM_RIGH_SHIFT(sb[0], rs)));   //@WIN
                */
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }
        else  if (now == 0x01)          /* just crossing two words? */
        {
            if (w <= BM_PIXEL_WORD)     /* one word crossing two words? */
            {
                for (; h > 0; db+= dw, sb+= sw, h--)
                {
                                     /*@WIN 10-05-92 begin*/
                    tmprs0 = sb[0];
                    tmpls0 = sb[0];
                    tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                    tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                    LWORDSWAP(tmprs0);
                    LWORDSWAP(tmpls0);
                    db[0] = (db[0] & ~tmprs0) | (hb[0] & tmprs0);
                    db[1] = (db[1] & ~tmpls0) | (hb[1] & tmpls0);
                                     /*@WIN 04-20-92 end*/
                    /*
                    db[0] = (db[0] & ~(BM_RIGH_SHIFT(sb[0], rs))) | //@WIN
                            (hb[0] &  (BM_RIGH_SHIFT(sb[0], rs)));  //@WIN
                    db[1] = (db[1] & ~(BM_LEFT_SHIFT(sb[0], ls))) | //@WIN
                            (hb[1] &  (BM_LEFT_SHIFT(sb[0], ls)));  //@WIN
                    */
                    hy++;
                    if (hy == HTB_Bmap.bm_rows)
                    {
                        hy =  0;
                        hb = hs;
                    } else
                        hb += hw;
                }
            }
            else                        /* two words crossing two words! */
            {
                sm =  BM_R_MASK(xe);        /* second mask */
                LWORDSWAP(sm);                  /*@WIN 10-06-92*/
                for (; h > 0; db+= dw, sb+= sw, h--)
                {
                                     /*@WIN 10-05-92 begin*/
                    tmprs0 = sb[0];
                    tmpls0 = sb[0];
                    tmprs1 = sb[1];
                    tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                    tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                    tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                    LWORDSWAP(tmprs0);
                    LWORDSWAP(tmpls0);
                    LWORDSWAP(tmprs1);
                    db[0] = (db[0] & ~tmprs0) | (hb[0] & tmprs0);
                    db[1] = (db[1] & ~((tmpls0 | tmprs1) & sm)) |
                            (hb[1] &  ((tmpls0 | tmprs1) & sm));
                                     /*@WIN 04-20-92 end*/
                    /*
                    db[0] = (db[0] & ~(BM_RIGH_SHIFT(sb[0], rs))) | //@WIN
                            (hb[0] &  (BM_RIGH_SHIFT(sb[0], rs)));  //@WIN
                    db[1] = (db[1] & ~((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                        BM_RIGH_SHIFT(sb[1], rs)) & sm)) | //@WIN
                            (hb[1] & ((BM_LEFT_SHIFT(sb[0], ls) |  //@WIN
                                       BM_RIGH_SHIFT(sb[1], rs)) & sm)); //@WIN
                    */
                    hy++;
                    if (hy == HTB_Bmap.bm_rows)
                    {
                        hy =  0;
                        hb = hs;
                    } else
                        hb += hw;
                }
            }
        }
        else                            /* crossing more than two words! */
        {
            sm =  BM_R_MASK(xe);        /* second mask */
            LWORDSWAP(sm);                  /*@WIN 10-06-92*/
            for (dw-= now, sw-= (now - 1),
                 hw-= now; h > 0; db+= dw, sb+= sw, h--)
            {
                                     /*@WIN 10-05-92 begin*/
                tmprs0 = sb[0];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                LWORDSWAP(tmprs0);
                db[0] = (db[0] & ~(tmprs0)) | (hb[0] &  (tmprs0));
                                     /*@WIN 04-20-92 end*/
                /*
                db[0] = (db[0] & ~(BM_RIGH_SHIFT(sb[0], rs))) | //@WIN
                        (hb[0] &  (BM_RIGH_SHIFT(sb[0], rs))); //@WIN
                */
                for (db++, hb++, cow = now; cow >= 0x02;
                     db++, sb++, hb++, cow--)
                {
                    tmpls0 = sb[0];
                    tmprs1 = sb[1];
                    tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                    tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                    LWORDSWAP(tmpls0);
                    LWORDSWAP(tmprs1);
                    db[0] = (db[0] & ~(tmpls0 | tmprs1)) |
                            (hb[0] &  (tmpls0 | tmprs1)); //@WIN
                    /*
                    db[0] = (db[0] & ~(BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                       BM_RIGH_SHIFT(sb[1], rs))) | //@WIN
                            (hb[0] & (BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                      BM_RIGH_SHIFT(sb[1], rs))); //@WIN
                    */
                }
                tmpls0 = sb[0];
                tmprs1 = sb[1];
                tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                LWORDSWAP(tmpls0);
                LWORDSWAP(tmprs1);
                db[0] = (db[0] & ~((tmpls0 | tmprs1) & sm)) |
                        (hb[0] &  ((tmpls0 | tmprs1) & sm)); //@WIN
                /*
                db[0] = (db[0] & ~((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                    BM_RIGH_SHIFT(sb[1], rs)) & sm)) | //@WIN
                        (hb[0] & ((BM_LEFT_SHIFT(sb[0], ls) |        //@WIN
                                   BM_RIGH_SHIFT(sb[1], rs)) & sm)); //@WIN
                */
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }
/*        break; */
    }
    else if (fc == FC_CLEAR) {

/*    case FC_CLEAR:  */          /*  0001  D <- D .AND. .NOT. S          */

        if (rs == 0x00)                /* no left/right shift? */
        {
            for (dw-= now + 1; h > 0; db+= dw, h--)
            {
                for (cow = now; cow >= 0x00; db++, sb++, cow--)
                    db[0] = (db[0] & ~(sb[0]));
            }
        }
        else  if (now == 0x00)          /* totally within one word? */
        {
            for (; h > 0; db+= dw, sb+= sw, h--) {
                             /*@WIN 10-05-92 begin*/
                tmprs0 = sb[0];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                LWORDSWAP(tmprs0);
                db[0] = db[0] & ~((tmprs0));
                             /*@WIN 10-05-92 end*/
                //db[0] = db[0] & ~((BM_RIGH_SHIFT(sb[0], rs))); //@WIN
            }
        }
        else  if (now == 0x01)          /* just crossing two words? */
        {
            sm =  BM_R_MASK(xe);        /* second mask */
            LWORDSWAP(sm);                  /*@WIN 10-06-92*/
            for (; h > 0; db+= dw, sb+= sw, h--)
            {
                             /*@WIN 10-05-92 begin*/
                tmprs0 = sb[0];
                tmpls0 = sb[0];
                tmprs1 = sb[1];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                LWORDSWAP(tmprs0);
                LWORDSWAP(tmpls0);
                LWORDSWAP(tmprs1);
                db[0] = db[0] & ~((tmprs0)); //@WIN
                db[1] = db[1] & ~((tmpls0 | tmprs1) & sm);
                             /*@WIN 10-05-92 end*/
                /*
                db[0] = db[0] & ~((BM_RIGH_SHIFT(sb[0], rs))); //@WIN
                db[1] = db[1] & ~((BM_LEFT_SHIFT(sb[0], ls) |        //@WIN
                                   BM_RIGH_SHIFT(sb[1], rs)) & sm); //@WIN
                */
            }
        }
        else                            /* crossing more than two words! */
        {
            sm =  BM_R_MASK(xe);        /* second mask */
            LWORDSWAP(sm);                  /*@WIN 10-06-92*/
            for (dw-= now, sw-= (now - 1); h > 0; db+= dw, sb+= sw, h--)
            {
                tmprs0 = sb[0];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                LWORDSWAP(tmprs0);
                db[0] = db[0] & ~((tmprs0)); //@WIN
                for (db++, cow = now; cow >= 0x02; db++, sb++, cow--) {
                    tmpls0 = sb[0];
                    tmprs1 = sb[1];
                    tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                    tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                    LWORDSWAP(tmpls0);
                    LWORDSWAP(tmprs1);
                    db[0] = db[0] & ~((tmpls0 | tmprs1));
                }
                tmpls0 = sb[0];
                tmprs1 = sb[1];
                tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                LWORDSWAP(tmpls0);
                LWORDSWAP(tmprs1);
                db[0] = db[0] & ~((tmpls0 | tmprs1) & sm); //@WIN
                /*
                db[0] = db[0] & ~((BM_RIGH_SHIFT(sb[0], rs))); //@WIN
                for (db++, cow = now; cow >= 0x02; db++, sb++, cow--)
                    db[0] = db[0] & ~((BM_LEFT_SHIFT(sb[0], ls) |    //@WIN
                                       BM_RIGH_SHIFT(sb[1], rs))); //@WIN
                db[0] = db[0] & ~((BM_LEFT_SHIFT(sb[0], ls) |        //@WIN
                                   BM_RIGH_SHIFT(sb[1], rs)) & sm); //@WIN
                */
            }
        }
/*        break; */
    }
    else if (fc == FC_MERGE) {
/*    case FC_MERGE: */             /*  0001  D <- D .OR. S                 */

        if (rs == 0x00)                /* no left/right shift? */
        {
            for (dw-= now + 1; h > 0; db+= dw, h--)
            {
                for (cow = now; cow >= 0x00; db++, sb++, cow--)
                    db[0] = (db[0] | (sb[0]));
            }
        }
        else  if (now == 0x00)          /* totally within one word? */
        {
            for (; h > 0; db+= dw, sb+= sw, h--) {
                tmprs0 = sb[0];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                LWORDSWAP(tmprs0);
                db[0] = db[0] | ((tmprs0));
                //db[0] = db[0] | ((BM_RIGH_SHIFT(sb[0], rs))); //@WIN
            }
        }
        else  if (now == 0x01)          /* just crossing two words? */
        {
            sm =  BM_R_MASK(xe);        /* second mask */
            LWORDSWAP(sm);                  /*@WIN 10-06-92*/
            for (; h > 0; db+= dw, sb+= sw, h--)
            {
                tmprs0 = sb[0];
                tmpls0 = sb[0];
                tmprs1 = sb[1];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                LWORDSWAP(tmprs0);
                LWORDSWAP(tmpls0);
                LWORDSWAP(tmprs1);
                db[0] = db[0] | ((tmprs0));
                db[1] = db[1] | ((tmpls0 | tmprs1) & sm);
                /*
                db[0] = db[0] | ((BM_RIGH_SHIFT(sb[0], rs))); //@WIN
                db[1] = db[1] | ((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                  BM_RIGH_SHIFT(sb[1], rs)) & sm); //@WIN
                */
            }
        }
        else                            /* crossing more than two words! */
        {
            sm =  BM_R_MASK(xe);        /* second mask */
            LWORDSWAP(sm);                  /*@WIN 10-06-92*/
            for (dw-= now, sw-= (now - 1); h > 0; db+= dw, sb+= sw, h--)
            {
                tmprs0 = sb[0];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                LWORDSWAP(tmprs0);
                db[0] = db[0] | ((tmprs0)); //@WIN
                for (db++, cow = now; cow >= 0x02; db++, sb++, cow--) {
                    tmpls0 = sb[0];
                    tmprs1 = sb[1];
                    tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                    tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                    LWORDSWAP(tmpls0);
                    LWORDSWAP(tmprs1);
                    db[0] = db[0] | ((tmpls0 | tmprs1));
                }
                tmpls0 = sb[0];
                tmprs1 = sb[1];
                tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                LWORDSWAP(tmpls0);
                LWORDSWAP(tmprs1);
                db[0] = db[0] | ((tmpls0 | tmprs1) & sm);
                /*
                db[0] = db[0] | ((BM_RIGH_SHIFT(sb[0], rs))); //@WIN
                for (db++, cow = now; cow >= 0x02; db++, sb++, cow--)
                    db[0] = db[0] | ((BM_LEFT_SHIFT(sb[0], ls) |     //@WIN
                                      BM_RIGH_SHIFT(sb[1], rs))); //@WIN
                db[0] = db[0] | ((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                  BM_RIGH_SHIFT(sb[1], rs)) & sm); //@WIN
                */
            }
        }
/*        break; */
#ifdef  DBGwarn
    default:
        printf("gp_patblt: Illegal FC_code = %x\n", fc);
        break;
#endif
    }
} /* gp_patblt */

void
gp_patblt_m(dst, dx, dy, w, h, fc, src)
struct bitmap FAR     *dst;
fix                     dx, dy;
fix                     w, h;
ufix16                  fc;
struct bitmap FAR     *src;
{
    fix                 dw;
    BM_DATYP           huge *db;        /* FAR => huge @WIN */
    fix                 sw;
    BM_DATYP           FAR *sb;
    fix                 mw;
    BM_DATYP           FAR *mb;
    fix                 hw;
    fix                 hy;
    BM_DATYP           FAR *hb, FAR *hs;
    fix                 ls, rs;
    BM_DATYP            sm;
    fix                 xs, xe;
    fix                 now, cow;
    ufix32 tmprs0, tmpls0, tmprs1;   /*@WIN 10-05-92*/

#ifdef  DBGp
    printf("patblt_m: %6.6lx %4x %4x %4x %4x %4.4x %6.6lx\n",
           dst->bm_addr, dx, dy, w, h, fc, src->bm_addr);
#endif



    // NTFIX   A negative destination should get remapped to 0. This is
    //         from the printer group.
    //
    if (dx < 0 ) {
       dx = 0;
    }

    if (dy <0 ) {
       dy = 0;
    }

    /*  calculate starting address and width in words
     */
    dw = dst->bm_cols >> BM_WORD_POWER;                         /* @DST */
//  db = &((BM_DATYP FAR *) dst->bm_addr)[dy * dw + (dx >> BM_WORD_POWER)]; @WINFLOW
    db = (ufix32 huge *)dst->bm_addr +
               ((fix32)dy * (fix32)dw + ((fix32)dx >> BM_WORD_POWER));
    sw = src->bm_cols >> BM_WORD_POWER;
    sb =  ((BM_DATYP FAR *) src->bm_addr);

    mw = CMB_Bmap.bm_cols >> BM_WORD_POWER;                     /* @CMB */
//  mb = &((BM_DATYP FAR *) CMB_Bmap.bm_addr)[(dy - CMB_Yorig) * mw +  @WINFLOW
//                                       ((dx - CMB_Xorig) >> BM_WORD_POWER)];

    /* adjust starting address of CMB; --- begin --- 11/9/92 @WIN */
//  mb = (BM_DATYP FAR *) CMB_Bmap.bm_addr +
//                       ((DWORD)(dy - CMB_Yorig) * mw +
//                       ((DWORD)(dx - CMB_Xorig) >> BM_WORD_POWER));
    {
    int nX = (dx > CMB_Xorig) ? (dx - CMB_Xorig) : 0;
    int nY = (dy > CMB_Yorig) ? (dy - CMB_Yorig) : 0;
    mb = (BM_DATYP FAR *) CMB_Bmap.bm_addr +
                         ((DWORD)(nY) * mw +
                         ((DWORD)(nX) >> BM_WORD_POWER));
    }
    /* adjust starting address of CMB; --- end --- 11/9/92 @WIN */

    /* adjust starting addresses when they are out of page;  10-6-92 @WIN */
    /* it also needs to consider dx; To Be Fixed??? */
    if (dy < 0) {       // too small
        h += dy;
        db = (ufix32 huge *)dst->bm_addr + ((fix32)dx >> BM_WORD_POWER);
        sb += (-dy) * sw;
        mb += (-dy) * mw;
        dy = 0;
    }
    if ((dy+h) > SFX2I(GSptr->device.default_clip.uy)) { // tooo large
        h = SFX2I(GSptr->device.default_clip.uy) - dy;
    }
    /* adjust starting addresses when they are out of page;  --end-- */

    /*  calculate starting and ending coordinate of x
     */
    xs = dx;
    xe = dx + w - 1;
    now = ((fix)(xe & BM_ALIGN_MASK) - (fix)(xs & BM_ALIGN_MASK)) >> BM_WORD_POWER;
                                                 /* cast fix 10/16/92 @WIN */

    /*  calculate shifts and masks based on from SRC to DST
     */
    rs = dx & BM_PIXEL_MASK;                            /* right shift */
    ls = BM_PIXEL_WORD - rs;                            /* left  shift */

/*
    switch (fc)
    {
    case HT_APPLY:  */          /*  D <- (D .AND. .NOT.(S .AND. M)) .OR.
                                         ((S .AND. M) .AND. HT)         */
    if (fc == HT_APPLY) {
        /*  calculate starting address/y and width in words
         */
        hw = HTB_Bmap.bm_cols >> BM_WORD_POWER;
        hy = dy % HTB_Bmap.bm_rows;
        hs = ((BM_DATYP FAR *) HTB_Bmap.bm_addr +
                           ((dx % HTB_Modula) >> BM_WORD_POWER));
        hb = hs + (hy * hw);

        if (rs == 0x00)                /* no left/right shift? */
        {
            for (dw-= now + 1, mw-= now + 1,
                 hw-= now + 1; h > 0; db+= dw, mb+= mw, h--)
            {
                for (cow = now; cow >= 0x00; db++, sb++, mb++, hb++, cow--)
                    db[0] = (db[0] & ~(sb[0] & mb[0])) |
                            (hb[0] &  (sb[0] & mb[0]));
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }
        else  if (now == 0x00)          /* totally within one word? */
        {
            for (; h > 0; db+= dw, sb+= sw, mb+= mw, h--)
            {
                tmprs0 = sb[0];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                LWORDSWAP(tmprs0);
                db[0] = (db[0] & ~(tmprs0 & mb[0])) |
                        (hb[0] &  (tmprs0 & mb[0]));
                /*
                db[0] = (db[0] & ~(BM_RIGH_SHIFT(sb[0], rs) & mb[0])) | //@WIN
                        (hb[0] &  (BM_RIGH_SHIFT(sb[0], rs) & mb[0])); //@WIN
                */
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }
        else  if (now == 0x01)          /* just crossing two words? */
        {
            if (w <= BM_PIXEL_WORD)     /* one word crossing two words? */
            {
                for (; h > 0; db+= dw, sb+= sw, mb+= mw, h--)
                {
                    tmprs0 = sb[0];
                    tmpls0 = sb[0];
                    tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                    tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                    LWORDSWAP(tmprs0);
                    LWORDSWAP(tmpls0);
                    db[0] = (db[0] & ~(tmprs0 & mb[0])) |
                            (hb[0] &  (tmprs0 & mb[0]));
                    db[1] = (db[1] & ~(tmpls0 & mb[1])) |
                            (hb[1] &  (tmpls0 & mb[1]));
                    /*
                    db[0] = (db[0] & ~(BM_RIGH_SHIFT(sb[0], rs) & mb[0])) | //@WIN
                            (hb[0] &  (BM_RIGH_SHIFT(sb[0], rs) & mb[0])); //@WIN
                    db[1] = (db[1] & ~(BM_LEFT_SHIFT(sb[0], ls) & mb[1])) | //@WIN
                            (hb[1] &  (BM_LEFT_SHIFT(sb[0], ls) & mb[1])); //@WIN
                    */
                    hy++;
                    if (hy == HTB_Bmap.bm_rows)
                    {
                        hy =  0;
                        hb = hs;
                    } else
                        hb += hw;
                }
            }
            else                        /* one word crossing two words? */
            {
                sm =  BM_R_MASK(xe);    /* second mask */
                LWORDSWAP(sm);                  /*@WIN 10-06-92*/
                for (; h > 0; db+= dw, sb+= sw, mb+= mw, h--)
                {
                    tmprs0 = sb[0];
                    tmpls0 = sb[0];
                    tmprs1 = sb[1];
                    tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                    tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                    tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                    LWORDSWAP(tmprs0);
                    LWORDSWAP(tmpls0);
                    LWORDSWAP(tmprs1);
                    db[0] = (db[0] & ~(tmprs0 & mb[0])) | //@WIN
                            (hb[0] &  (tmprs0 & mb[0])); //@WIN
                    db[1] = (db[1] & ~((tmpls0 | tmprs1) & mb[1] & sm)) |
                            (hb[1] &  ((tmpls0 | tmprs1) & mb[1] & sm));
                    /*
                    db[0] = (db[0] & ~(BM_RIGH_SHIFT(sb[0], rs) & mb[0])) | //@WIN
                            (hb[0] &  (BM_RIGH_SHIFT(sb[0], rs) & mb[0])); //@WIN
                    db[1] = (db[1] & ~((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                     BM_RIGH_SHIFT(sb[1], rs)) & mb[1] & sm)) | //@WIN
                            (hb[1] &  ((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                     BM_RIGH_SHIFT(sb[1], rs)) & mb[1] & sm)); //@WIN
                    */
                    hy++;
                    if (hy == HTB_Bmap.bm_rows)
                    {
                        hy =  0;
                        hb = hs;
                    } else
                        hb += hw;
                }
            }
        }
        else                            /* crossing more than two words! */
        {
            sm =  BM_R_MASK(xe);        /* second mask */
            LWORDSWAP(sm);                  /*@WIN 10-06-92*/
            for (dw-= now, sw-= (now - 1), mw-= now,
                 hw-= now; h > 0; db+= dw, sb+= sw, mb+= mw, h--)
            {
                tmprs0 = sb[0];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                LWORDSWAP(tmprs0);
                db[0] = (db[0] & ~(tmprs0 & mb[0])) |
                        (hb[0] &  (tmprs0 & mb[0]));
                /*
                db[0] = (db[0] & ~(BM_RIGH_SHIFT(sb[0], rs) & mb[0])) | //@WIN
                        (hb[0] &  (BM_RIGH_SHIFT(sb[0], rs) & mb[0])); //@WIN
                */
                for (db++, hb++, mb++, cow = now; cow >= 0x02;
                     db++, sb++, hb++, mb++, cow--)
                {
                    tmpls0 = sb[0];
                    tmprs1 = sb[1];
                    tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                    tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                    LWORDSWAP(tmpls0);
                    LWORDSWAP(tmprs1);
                    db[0] = (db[0] & ~((tmpls0 | tmprs1) & mb[0])) |
                            (hb[0] &  ((tmpls0 | tmprs1) & mb[0]));
                    /*
                    db[0] = (db[0] & ~((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                        BM_RIGH_SHIFT(sb[1], rs)) & mb[0])) | //@WIN
                            (hb[0] &  ((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                        BM_RIGH_SHIFT(sb[1], rs)) & mb[0])); //@WIN
                    */
                }
                tmpls0 = sb[0];
                tmprs1 = sb[1];
                tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                LWORDSWAP(tmpls0);
                LWORDSWAP(tmprs1);
                db[0] = (db[0] & ~((tmpls0 | tmprs1) & mb[0] & sm)) |
                        (hb[0] &  ((tmpls0 | tmprs1) & mb[0] & sm));
                /*
                db[0] = (db[0] & ~((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                    BM_RIGH_SHIFT(sb[1], rs)) & mb[0] & sm)) | //@WIN
                        (hb[0] &  ((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                    BM_RIGH_SHIFT(sb[1], rs)) & mb[0] & sm)); //@WIN
                */
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }
/*      break; */
    }
    else if (fc == FC_CLEAR) {
/*  case FC_CLEAR:  */          /*  0001  D <- D .AND. .NOT.(S .AND. M) */

        if (rs == 0x00)                /* no left/right shift? */
        {
            for (dw-= now + 1, mw-= now + 1; h > 0; db+= dw, mb+= mw, h--)
            {
                for (cow = now; cow >= 0x00; db++, sb++, mb++, cow--)
                    db[0] = (db[0] & ~(sb[0] & mb[0]));
            }
        }
        else  if (now == 0x00)          /* totally within one word? */
        {
            for (; h > 0; db+= dw, sb+= sw, mb+= mw, h--)
            {
                tmprs0 = sb[0];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                LWORDSWAP(tmprs0);
                db[0] = db[0] & ~(((tmprs0) & mb[0])); //@WIN
                /*
                db[0] = db[0] & ~(((BM_RIGH_SHIFT(sb[0], rs)) & mb[0])); //@WIN
                */
            }
        }
        else  if (now == 0x01)          /* just crossing two words? */
        {
            sm =  BM_R_MASK(xe);        /* second mask */
            LWORDSWAP(sm);                  /*@WIN 10-06-92*/
            for (; h > 0; db+= dw, sb+= sw, mb+= mw, h--)
            {
                tmprs0 = sb[0];
                tmpls0 = sb[0];
                tmprs1 = sb[1];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                LWORDSWAP(tmprs0);
                LWORDSWAP(tmpls0);
                LWORDSWAP(tmprs1);
                db[0] = db[0] & ~(((tmprs0) & mb[0]));
                db[1] = db[1] & ~(((tmpls0 | tmprs1) & mb[1]) & sm);
                /*
                db[0] = db[0] & ~(((BM_RIGH_SHIFT(sb[0], rs)) & mb[0])); //@WIN
                db[1] = db[1] & ~(((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                    BM_RIGH_SHIFT(sb[1], rs)) & mb[1]) & sm); //@WIN
                */
            }
        }
        else                            /* crossing more than two words! */
        {
            sm =  BM_R_MASK(xe);        /* second mask */
            LWORDSWAP(sm);                  /*@WIN 10-06-92*/
            for (dw-= now, sw-= (now - 1),
                 mw-= now; h > 0; db+= dw, sb+= sw, mb+= mw, h--)
            {
                tmprs0 = sb[0];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                LWORDSWAP(tmprs0);
                db[0] = db[0] & ~((tmprs0 & mb[0])); //@WIN
                /*
                db[0] = db[0] & ~(((BM_RIGH_SHIFT(sb[0], rs)) & mb[0])); //@WIN
                */
                for (db++, mb++, cow = now; cow >= 0x02;
                     db++, sb++, mb++, cow--)
                {
                    tmpls0 = sb[0];
                    tmprs1 = sb[1];
                    tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                    tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                    LWORDSWAP(tmpls0);
                    LWORDSWAP(tmprs1);
                    db[0] = db[0] & ~(((tmpls0 | tmprs1) & mb[0]));
                    /*
                    db[0] = db[0] & ~(((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                        BM_RIGH_SHIFT(sb[1], rs)) & mb[0])); //@WIN
                    */
                }
                tmpls0 = sb[0];
                tmprs1 = sb[1];
                tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                LWORDSWAP(tmpls0);
                LWORDSWAP(tmprs1);
                db[0] = db[0] & ~(((tmpls0 | tmprs1) & mb[0]) & sm);
                /*
                db[0] = db[0] & ~(((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                    BM_RIGH_SHIFT(sb[1], rs)) & mb[0]) & sm); //@WIN
                */
            }
        }
/*      break; */
    }
    else if (fc == FC_MERGE) {
/*  case FC_MERGE:  */          /*  0001  D <- D .OR. (S .AND. M)       */

        if (rs == 0x00)                /* no left/right shift? */
        {
            for (dw-= now + 1, mw-= now + 1; h > 0; db+= dw, mb+= mw, h--)
            {
                for (cow = now; cow >= 0x00; db++, sb++, mb++, cow--)
                    db[0] = (db[0] | (sb[0] & mb[0]));
            }
        }
        else  if (now == 0x00)          /* totally within one word? */
        {
            for (; h > 0; db+= dw, sb+= sw, mb+= mw, h--)
            {
                             /*@WIN 10-05-92 begin*/
                tmprs0 = sb[0];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                LWORDSWAP(tmprs0);
                db[0] = db[0] | (((tmprs0) & mb[0]));
                             /*@WIN 10-05-92 end*/
                /*
                db[0] = db[0] | (((BM_RIGH_SHIFT(sb[0], rs)) & mb[0])); //@WIN
                */
            }
        }
        else  if (now == 0x01)          /* just crossing two words? */
        {
            sm =  BM_R_MASK(xe);        /* second mask */
            LWORDSWAP(sm);                  /*@WIN 10-06-92*/
            for (; h > 0; db+= dw, sb+= sw, mb+= mw, h--)
            {
                             /*@WIN 10-05-92 begin*/
                tmprs0 = sb[0];
                tmpls0 = sb[0];
                tmprs1 = sb[1];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                LWORDSWAP(tmprs0);
                LWORDSWAP(tmpls0);
                LWORDSWAP(tmprs1);
                db[0] = db[0] | (((tmprs0) & mb[0]));
                db[1] = db[1] | (((tmpls0 | tmprs1) & mb[1]) & sm);
                             /*@WIN 10-05-92 end*/
                /*
                db[0] = db[0] | (((BM_RIGH_SHIFT(sb[0], rs)) & mb[0])); //@WIN
                db[1] = db[1] | (((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                   BM_RIGH_SHIFT(sb[1], rs)) & mb[1]) & sm); //@WIN
                */
            }
        }
        else                            /* crossing more than two words! */
        {
            sm =  BM_R_MASK(xe);        /* second mask */
            LWORDSWAP(sm);                  /*@WIN 10-06-92*/
            for (dw-= now, sw-= (now - 1), mw-= now;
                 h > 0; db+= dw, sb+= sw, mb+= mw, h--)
            {
                             /*@WIN 10-05-92 begin*/
                tmprs0 = sb[0];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                LWORDSWAP(tmprs0);
                db[0] = db[0] | (((tmprs0) & mb[0]));
                for (db++, mb++, cow = now; cow >= 0x02;
                     db++, sb++, mb++, cow--)
                {
                    tmpls0 = sb[0];
                    tmprs1 = sb[1];
                    tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                    tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                    LWORDSWAP(tmpls0);
                    LWORDSWAP(tmprs1);
                    db[0] = db[0] | (((tmpls0 | tmprs1) & mb[0]));
                }
                tmpls0 = sb[0];
                tmprs1 = sb[1];
                tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                LWORDSWAP(tmpls0);
                LWORDSWAP(tmprs1);
                db[0] = db[0] | (((tmpls0 | tmprs1) & mb[0]) & sm);
                             /*@WIN 10-05-92 end*/
                /*
                db[0] = db[0] | (((BM_RIGH_SHIFT(sb[0], rs)) & mb[0])); //@WIN
                for (db++, mb++, cow = now; cow >= 0x02;
                     db++, sb++, mb++, cow--)
                {
                    db[0] = db[0] | (((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                       BM_RIGH_SHIFT(sb[1], rs)) & mb[0])); //@WIN
                }
                db[0] = db[0] | (((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                   BM_RIGH_SHIFT(sb[1], rs)) & mb[0]) & sm); //@WIN
                */
            }
        }
/*      break; */

#ifdef  DBGwarn
    default:
        printf("gp_patblt_m: Illegal FC_code = %x\n", fc);
        break;
#endif
    }
} /* gp_patblt_m */

//NTFIX , total replacement of gp_patblt_c the code below does swapping to
//        correct memory orientation issues. Since were replicating a patter
//        that has already been corrected this should not be done here.
//        when the cache is moved to the final surface the swapping will
//        be correct.

#if 0
void
gp_patblt_c(dst, dx, dy, w, h, fc, src)
struct bitmap FAR     *dst;
fix                     dx, dy;
fix                     w, h;
ufix16                  fc;
struct bitmap FAR     *src;
{
    fix                 dw;
    CC_DATYP           huge *db;        /* FAR => huge @WIN */
    fix                 sw;
    CC_DATYP           FAR *sb;
    fix                 ls, rs;
    CC_DATYP            sm;
    fix                 xs, xe;
    fix                 now, cow;

#ifdef  DBGp
    printf("patblt_c: %6.6lx %4x %4x %4x %4x %4.4x %6.6lx\n",
           dst->bm_addr, dx, dy, w, h, fc, src->bm_addr);
#endif
    /* for clipped cached font, 5-30-91, -begin- */
    fix                 dh;



    //UPD056
    dh = h;
    if ( dx > dst->bm_cols || dy > dst->bm_rows)
        return;         /* out of clipped region */
    if (dx < 0 ) {
       dx = 0;
    }




    if ((dx + w - 1) > dst->bm_cols)
        xe = dst->bm_cols;
    else
        xe = dx + w - 1;
    if ((dy + dh - 1) > dst->bm_rows)
        h = dy + dh - 1 - dst->bm_rows;
    sw = src->bm_cols >> CC_WORD_POWER;
    sb =  ((CC_DATYP FAR *) src->bm_addr);
    dw = dst->bm_cols >> CC_WORD_POWER;
//  db = &((CC_DATYP FAR *) dst->bm_addr)[dy * dw + (dx >> CC_WORD_POWER)];
    db = (CC_DATYP huge *) dst->bm_addr +               /*@WIN*/
         ((ufix32)dy * dw + ((ufix32)dx >> CC_WORD_POWER));
    if (dy < 0) {
        if ((dy + dh - 1) < 0)
            return;    /* out of clipped region */
        else {
            h = dy + dh;
            sb = &((CC_DATYP FAR *) src->bm_addr)[-dy * sw];
//          db = &((CC_DATYP FAR *) dst->bm_addr)[dx >> CC_WORD_POWER];
            db = (CC_DATYP huge *) dst->bm_addr + ((ufix32)dx >> CC_WORD_POWER); //@WIN
        }
    }
    /* for clipped cached font, 5-30-91, -end- */

    /*  calculate starting address and width in words
     */
/*  dw = dst->bm_cols >> CC_WORD_POWER;
//  db = &((CC_DATYP FAR *) dst->bm_addr)[dy * dw + (dx >> CC_WORD_POWER)];
    db = (CC_DATYP FAR *) dst->bm_addr + ((ufix32)dy * dw + ((ufix32)dx >> CC_WORD_POWER)); //@WIN
    sw = src->bm_cols >> CC_WORD_POWER;
    sb =  ((CC_DATYP FAR *) src->bm_addr); * 5-30-91, Jack */

    /*  calculate starting and ending coordinate of x
     */
    xs = dx;
/*  xe = dx + w - 1; * 5-30-91, Jack */
    now = ((fix)(xe & CC_ALIGN_MASK) - (fix)(xs & CC_ALIGN_MASK)) >> CC_WORD_POWER;
                                                 /* cast fix 10/16/92 @WIN */

    /*  calculate shifts and masks based on from SRC to DST
     */
    rs = dx & CC_PIXEL_MASK;                            /* right shift */
    ls = CC_PIXEL_WORD - rs;                            /* left  shift */

/*  case FC_MERGE:   */         /*  0001  D <- D .OR. S      */

        if (rs == 0x00)                /* no left/right shift? */
        {
            for (dw-= now + 1, sw-= now + 1 ; h > 0; db+= dw, sb+= sw, h--)
            {
                for (cow = now; cow >= 0x00; db++, sb++, cow--)
                    db[0] = (db[0] | (sb[0]));
            }
        }
        else  if (now == 0x00)          /* totally within one word? */
        {
            for (; h > 0; db+= dw, sb+= sw, h--)
            {
                db[0] = db[0] | ((CC_RIGH_SHIFT(sb[0], rs)));  /*@WIN*/
            }
        }
        else  if (now == 0x01)          /* just crossing two words? */
        {

            sm =  CC_R_MASK(xe);        /* second mask */
            SWORDSWAP(sm);                  /*@WIN 10-06-92*/
            for (; h > 0; db+= dw, sb+= sw, h--)
            {
                db[0] = db[0] | ((CC_RIGH_SHIFT(sb[0], rs)));
                db[1] = db[1] | ((CC_LEFT_SHIFT(sb[0], ls) |
                                  CC_RIGH_SHIFT(sb[1], rs)) & sm);
            }
        }
        else                            /* crossing more than two words! */
        {

            sm =  CC_R_MASK(xe);        /* second mask */
            SWORDSWAP(sm);                  /*@WIN 10-06-92*/
            for (dw-= now, sw-= (now - 1); h > 0; db+= dw, sb+= sw, h--)
            {
                db[0] = db[0] | ((CC_RIGH_SHIFT(sb[0], rs)));
                for (db++, cow = now; cow >= 0x02; db++, sb++, cow--)
                {
                    db[0] = db[0] | ((CC_LEFT_SHIFT(sb[0], ls) |
                                      CC_RIGH_SHIFT(sb[1], rs)));
                }
                db[0] = db[0] | ((CC_LEFT_SHIFT(sb[0], ls) |
                                  CC_RIGH_SHIFT(sb[1], rs)) & sm);
            }
        }
} /* gp_patplt_c */

#endif

//
//NTFIX, this is the corrected patblt function that works in nt.
//
void
gp_patblt_c(dst, dx, dy, w, h, fc, src)
struct bitmap FAR     *dst;
fix                     dx, dy;
fix                     w, h;
ufix16                  fc;
struct bitmap FAR     *src;
{
    fix                 dw;
    CC_DATYP           huge *db;        /* FAR => huge @WIN */
    fix                 sw;
    CC_DATYP           FAR *sb;
    fix                 ls, rs;
    CC_DATYP            sm;
    fix                 xs, xe;
    fix                 now, cow;

#ifdef  DBGp
    printf("patblt_c: %6.6lx %4x %4x %4x %4x %4.4x %6.6lx\n",
           dst->bm_addr, dx, dy, w, h, fc, src->bm_addr);
#endif
    /* for clipped cached font, 5-30-91, -begin- */
    fix                 dh;

    //UPD056
    dh = h;
    if ( dx > dst->bm_cols || dy > dst->bm_rows)
        return;         /* out of clipped region */
    if (dx < 0 ) {
       dx = 0;
    }

    //
    //NTFIX  There are situations where this code gets called with a 0 width
    //       or height. This should be a NOP
    //
    if (w == 0 || h == 0) {
       return;
    }



    if ((dx + w - 1) > dst->bm_cols)
        xe = dst->bm_cols;
    else
        xe = dx + w - 1;
    if ((dy + dh - 1) > dst->bm_rows)
        h = dy + dh - 1 - dst->bm_rows;
    sw = src->bm_cols >> CC_WORD_POWER;
    sb =  ((CC_DATYP FAR *) src->bm_addr);
    dw = dst->bm_cols >> CC_WORD_POWER;
//  db = &((CC_DATYP FAR *) dst->bm_addr)[dy * dw + (dx >> CC_WORD_POWER)];
    db = (CC_DATYP huge *) dst->bm_addr +               /*@WIN*/
         ((ufix32)dy * dw + ((ufix32)dx >> CC_WORD_POWER));
    if (dy < 0) {
        if ((dy + dh - 1) < 0)
            return;    /* out of clipped region */
        else {
            h = dy + dh;
            sb = &((CC_DATYP FAR *) src->bm_addr)[-dy * sw];
//          db = &((CC_DATYP FAR *) dst->bm_addr)[dx >> CC_WORD_POWER];
            db = (CC_DATYP huge *) dst->bm_addr + ((ufix32)dx >> CC_WORD_POWER); //@WIN
        }
    }
    /* for clipped cached font, 5-30-91, -end- */

    /*  calculate starting address and width in words
     */
/*  dw = dst->bm_cols >> CC_WORD_POWER;
//  db = &((CC_DATYP FAR *) dst->bm_addr)[dy * dw + (dx >> CC_WORD_POWER)];
    db = (CC_DATYP FAR *) dst->bm_addr + ((ufix32)dy * dw + ((ufix32)dx >> CC_WORD_POWER)); //@WIN
    sw = src->bm_cols >> CC_WORD_POWER;
    sb =  ((CC_DATYP FAR *) src->bm_addr); * 5-30-91, Jack */

    /*  calculate starting and ending coordinate of x
     */
    xs = dx;
/*  xe = dx + w - 1; * 5-30-91, Jack */
    now = ((fix)(xe & CC_ALIGN_MASK) - (fix)(xs & CC_ALIGN_MASK)) >> CC_WORD_POWER;
                                                 /* cast fix 10/16/92 @WIN */

    /*  calculate shifts and masks based on from SRC to DST
     */
    rs = dx & CC_PIXEL_MASK;                            /* right shift */
    ls = CC_PIXEL_WORD - rs;                            /* left  shift */

/*  case FC_MERGE:   */         /*  0001  D <- D .OR. S      */

        if (rs == 0x00)                /* no left/right shift? */
        {
            for (dw-= now + 1, sw-= now + 1 ; h > 0; db+= dw, sb+= sw, h--)
            {
                for (cow = now; cow >= 0x00; db++, sb++, cow--)
                    db[0] = (db[0] | (sb[0]));
            }
        }
        else  if (now == 0x00)          /* totally within one word? */
        {
            for (; h > 0; db+= dw, sb+= sw, h--)
            {
                db[0] = db[0] | ((CC_RIGH_SHIFT(sb[0], rs)));  /*@WIN*/
            }
        }
        else  if (now == 0x01)          /* just crossing two words? */
        {
            sm =  CC_R_MASK(xe);        /* second mask */

            //NTFIX, no swaping memory is already swaped..
            //
            //SWORDSWAP(sm);                  /*@WIN 10-06-92*/

            for (; h > 0; db+= dw, sb+= sw, h--)
            {
                db[0] = db[0] | ((CC_RIGH_SHIFT(sb[0], rs)));
                db[1] = db[1] | ((CC_LEFT_SHIFT(sb[0], ls) |
                                  CC_RIGH_SHIFT(sb[1], rs)) & sm);
            }
        }
        else                            /* crossing more than two words! */
        {
            sm =  CC_R_MASK(xe);        /* second mask */

            //NTFIX memory is already swapped.
            //
            //SWORDSWAP(sm);                  /*@WIN 10-06-92*/

            for (dw-= now, sw-= (now - 1); h > 0; db+= dw, sb+= sw, h--)
            {
                db[0] = db[0] | ((CC_RIGH_SHIFT(sb[0], rs)));
                for (db++, cow = now; cow >= 0x02; db++, sb++, cow--)
                {
                    db[0] = db[0] | ((CC_LEFT_SHIFT(sb[0], ls) |
                                      CC_RIGH_SHIFT(sb[1], rs)));
                }
                db[0] = db[0] | ((CC_LEFT_SHIFT(sb[0], ls) |
                                  CC_RIGH_SHIFT(sb[1], rs)) & sm);
            }
        }
} /* gp_patplt_c */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\graph\coord.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/**********************************************************************
 *
 *  Name:      coord.c
 *
 *  Purpose:   Manipulate coordinate systems.
 *
 *  Developer: J. Jih
 *
 *  History:
 *  Version    Date      Comments
 *             1/17/89   op_rotate(): fix bug of transformation from
 *                       any degree to range of 0 to 360
 *             1/25/89   op_invertmatrix(): for compatabitily --
 *                       ignore invalid access check on 1st matrix
 *             1/7/91    change < (real32)UNDRTOLANCE to <= (real32)UNDRTOLANCE
 *             3/20/91   refine the tolance check: UNDRTOLANCE --> IS_ZERO
 **********************************************************************/


// DJC added global include
#include "psglobal.h"


#include        <math.h>
#include        "global.ext"
#include        "graphics.h"
#include        "graphics.ext"

#define         ERR             3

/* ********** static function declartion ********** */
#ifdef LINT_ARGS
/* for type checks of the parameters in function declarations */
static bool near preprocess_op(ufix, struct object_def FAR * FAR *);
static void near get_g_array(struct object_def FAR *, ufix, struct object_def FAR *);
static void near create_object(long32, struct  object_def FAR *);

#else
/* for no type checks of the parameters in function declarations */
static bool near preprocess_op();
static void near get_g_array();
static void near create_object();
#endif

/* @WIN; add prototype */
bool type_chk(struct  object_def FAR *);


/***********************************************************************
 * Given a floating value and an object, to put the value to the object
 * and set it as a real type object.
 *
 * CALL:        create_object()
 *
 * PARAMETER:   l_value     : object value (input)
 *              obj         : will be created object (input/output)
 *
 * INTERFACE:   op_matrix
 **********************************************************************/
static void near
create_object(l_value, obj)
long32    l_value;
struct  object_def FAR *obj;
{
        real32   value;
        union   four_byte  value4;

        value = L2F(l_value);

        /* create object of array element */
        TYPE_SET(obj, REALTYPE);
        ATTRIBUTE_SET(obj, UNLIMITED);
        ACCESS_SET(obj, LITERAL);
        obj->length = 0;
        value4.ff = value;
        obj->value = value4.ll;
        ROM_RAM_SET(obj, RAM);
        LEVEL_SET(obj, current_save_level);

}

/***********************************************************************
 *
 * This module is to check type of array element object
 *
 * TITLE:       type_chk
 *
 * CALL:        type_chk()
 *
 * PARAMETER:   obj_array_element
 *
 * INTERFACE:   * many *
 *
 * CALLS:       none
 *
 * RETURN:      TRUE  : sucess
 *              FALSE : failure
 *
 **********************************************************************/
bool
type_chk(obj_array_element)
struct  object_def      FAR *obj_array_element;
{
        if(!IS_REAL(obj_array_element) &&
           !IS_INTEGER(obj_array_element)){
                ERROR(TYPECHECK);
                return(FALSE);
        }
        else{
                return(TRUE);
        }
}


/***********************************************************************
 *
 * This module is to get value of array element
 *
 * TITLE:       get_array_elmt
 *
 * CALL:        get_array_elmt(obj_array, array_length, elmt, flag)
 *
 * PARAMETER:   obj_array    : array  object
 *              array_length : array length
 *              elmt         : array element
 *              flag         : (PACKEDARRAY || ARRAY) || (ARRAY)
 *
 * INTERFACE:   * many *
 *
 * CALLS:       get_array, get_g_array
 *
 * RETURN:      TRUE  : normal (return elmt)
 *              FALSE : TYPECHECK error
 *
 * Modified by J. Lin, 8-19-1988
 **********************************************************************/
bool16
get_array_elmt(obj_array, array_length, elmt, flag)
 struct  object_def FAR *obj_array;
 fix     array_length;
 real32  FAR elmt[];
 ufix    flag;
{
 fix  i;
 struct  object_def obj_cont, FAR *obj_elmt;
 union   four_byte num4;

    obj_elmt = &obj_cont;
    for (i = 0; i < array_length; i++){
        /* get matrix element object */
        if (flag == G_ARRAY) /* PACKEDARRAY || ARRAY */
           get_g_array(obj_array, i, obj_elmt);
        else /* flag == ARRAY_ONLY */
           get_array(obj_array, i, obj_elmt);

        /* check array element type */
        if (!type_chk(obj_elmt)) {
           ERROR(TYPECHECK);
           return(FALSE);
        } else {
           num4.ll = (fix32)VALUE(obj_elmt);
           if (IS_REAL(obj_elmt))
              elmt[i] = num4.ff;
           else
              elmt[i] = (real32)num4.ll;
        }
    }
    return(TRUE);
}



/***********************************************************************
 *
 * This module is to get array, but no access limit
 *
 * TITLE:       get_g_array
 *
 * CALL:        get_g_array(obj_array, array_length, elmt)
 *
 * PARAMETER:   obj_array    : array  object
 *              array_index  : array index
 *              elmt         : array element
 *
 * INTERFACE:   * many *
 *
 * CALLS:       get_pk_object, get_pk_array
 *
 **********************************************************************/
static void near
get_g_array(obj_array, array_index, elmt)
struct  object_def  FAR *obj_array, FAR *elmt ;
ufix    array_index ;
{
    struct  object_def   FAR *l_temp ;

    l_temp = (struct object_def FAR *)VALUE(obj_array) ;

    if(TYPE(obj_array) == ARRAYTYPE) {
        l_temp += array_index ;
        COPY_OBJ( l_temp, elmt ) ;
    } else
        get_pk_object(get_pk_array((ubyte FAR *)l_temp, array_index), elmt,
                      LEVEL(obj_array)) ;

}   /* end get_g_array */


/***********************************************************************
 *
 * This module is to return a 6_element array object with the value of
 * identity matrix
 *
 * SYNTAX:      -       matrix  matrix
 *
 * TITLE:       op_matrix
 *
 * CALL:        op_matrix()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_matrix)
 *
 * CALLS:       create_object, put_array
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_matrix()
{
        struct object_def obj_array;

        /* check if operand stack no free space */
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }

        /* create a new array object */
        create_array(&obj_array, MATRIX_LEN);

        /* create array element object */
        create_object(F2L(one_f) ,GET_OBJ(&obj_array,0));
        create_object(F2L(zero_f),GET_OBJ(&obj_array,1));
        create_object(F2L(zero_f),GET_OBJ(&obj_array,2));
        create_object(F2L(one_f) ,GET_OBJ(&obj_array,3));
        create_object(F2L(zero_f),GET_OBJ(&obj_array,4));
        create_object(F2L(zero_f),GET_OBJ(&obj_array,5));

        /* push array object on the operand stack */
        PUSH_OBJ(&obj_array);

        return(0);
}


/***********************************************************************
 *
 * This module is to set the current CTM in the current graphics state
 * to device default matrix
 *
 * SYNTAX:      -       initmatrix      -
 *
 * TITLE:       op_initmatrix
 *
 * CALL:        op_initmatrix()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_initmatrix)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_initmatrix()
{
        ufix16  i;

        /* set the current CTM to default matrix */
        for(i = 0; i < MATRIX_LEN; i++){
                GSptr->ctm[i] = GSptr->device.default_ctm[i];
        }
        /* the default CTM is initially established by the framedevice
         * or banddevice operator, i.e. default CTM =
         * [4.166666, 0.0, 0.0, -4.166666, -75.0, 3268.0]
         */

        return(0);
}


/***********************************************************************
 *
 * This module is to replace the value of matrix with the value of
 * identity matrix
 *
 * SYNTAX:      matrix  identmatrix     matrix
 *
 * TITLE:       op_identmatrix
 *
 * CALL:        op_identmatrix()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_identmatrix)
 *
 * CALLS:       PUT_VALUE
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_identmatrix()
{
        struct  object_def FAR *obj_matrix;

        /* get operand */
        obj_matrix = GET_OPERAND(0);

        /* check access right */
        if( !access_chk(obj_matrix, ARRAY_ONLY) ) return(0);

        /* check rangecheck error */
        if(LENGTH(obj_matrix) != MATRIX_LEN){
                ERROR(RANGECHECK);
                return(0);
        }


        /* create matrix element object */
        PUT_VALUE(F2L(one_f), 0, obj_matrix);
        PUT_VALUE(F2L(zero_f), 1, obj_matrix);
        PUT_VALUE(F2L(zero_f), 2, obj_matrix);
        PUT_VALUE(F2L(one_f), 3, obj_matrix);
        PUT_VALUE(F2L(zero_f), 4, obj_matrix);
        PUT_VALUE(F2L(zero_f), 5, obj_matrix);
        return(0);
}


/***********************************************************************
 *
 * This module is to replace the value of matrix with the value of the
 * device default matrix
 *
 * SYNTAX:      matrix  defaultmatrix   matrix
 *
 * TITLE:       op_defaultmatrix
 *
 * CALL:        op_defaultmatrix()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_defaultmatrix)
 *
 * CALLS:       PUT_VALUE
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_defaultmatrix()
{
        ufix16  i;
        struct  object_def FAR *obj_matrix;

        /* get operand  */
        obj_matrix = GET_OPERAND(0);

        /* check access right */
        if( !access_chk(obj_matrix, ARRAY_ONLY) ) return(0);

        /* check rangecheck error */
        if(LENGTH(obj_matrix) != MATRIX_LEN){
                ERROR(RANGECHECK);
                return(0);
        }

        for(i = 0; i < MATRIX_LEN; i++){
            /* create matrix element object */
            PUT_VALUE(F2L(GSptr->device.default_ctm[i]), i, obj_matrix);
        }

        return(0);
}


/***********************************************************************
 *
 * This module is to replace the value of matrix with the value of the
 * current CTM
 *
 * SYNTAX:      matrix  currentmatrix   matrix
 *
 * TITLE:       op_currentmatrix
 *
 * CALL:        op_currentmatrix()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_currentmatrix)
 *
 * CALLS:       PUT_VALUE
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_currentmatrix()
{
        ufix16  i;
        struct  object_def FAR *obj_matrix;

        /* get operand */
        obj_matrix = GET_OPERAND(0);

        /* check access right */
        if( !access_chk(obj_matrix, ARRAY_ONLY) ) return(0);

        /* check rangecheck error */
        if(LENGTH(obj_matrix) != MATRIX_LEN){
                ERROR(RANGECHECK);
                return(0);
        }

        for(i = 0; i < MATRIX_LEN; i++){
            /* create matrix element object */
            PUT_VALUE(F2L(GSptr->ctm[i]), i, obj_matrix);
        }

        return(0);
}


/***********************************************************************
 *
 * This module is to set the current CTM in the current graphics state
 * to the specific matrix
 *
 * SYNTAX:      matrix  setmatrix       -
 *
 * TITLE:       op_setmatrix
 *
 * CALL:        op_setmatrix()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_setmatrix)
 *
 * CALLS:       get_array_elmt
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_setmatrix()
{
        struct  object_def FAR *obj_matrix;

        /* get operand */
        obj_matrix = GET_OPERAND(0);

        /* check rangecheck error */
        if (LENGTH(obj_matrix) != MATRIX_LEN) {
           ERROR(RANGECHECK);
           return(0);
        }

        if (!get_array_elmt(obj_matrix, MATRIX_LEN, GSptr->ctm ,G_ARRAY))
           return(0);

        /* pop operand stack */
        POP(1);
        return(0);
} /* op_setmatrix() */


/***********************************************************************
 *
 * This module is used as preprocessor of procedure that process two
 * operator types, its function includes check STACKUNDERFLOW,
 * TYPECHECK, and decide if matrix operand is exist, if matrix operand
 * is exist then check RANGECHECK also
 *
 * TITLE:       preprocess_op
 *
 * CALL:        preprocess_op()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   op_translate, op_scale, op_itransform, op_idtransform
 *
 * CALLS:       none
 *
 * RETURN:      matrix_exist : matrix exist flag
 *
 **********************************************************************/
static bool near
preprocess_op(opns, obj_opd)
ufix    opns;
struct  object_def FAR * FAR obj_opd[];
{
        bool    matrix_exist;

        /* get operand */
        obj_opd[0] = GET_OPERAND(0);

        if(opns == 3){
                matrix_exist = TRUE;           /* matrix exist flag */

                /* check rangecheck error */
                if(LENGTH(obj_opd[0]) != MATRIX_LEN){
                        ERROR(RANGECHECK);
                        return(ERR);
                }

                obj_opd[1] = GET_OPERAND(1);
                obj_opd[2] = GET_OPERAND(2);

        }
        else{
                matrix_exist = FALSE;          /* matrix exist flag */

                obj_opd[1] = GET_OPERAND(1);

        }
        return(matrix_exist);
}


/***********************************************************************
 *
 * This module is to move the origin of the user coordinate system by
 * (tx, ty) units, or to define translating the value of matrix by
 * (tx, ty) units
 *
 * SYNTAX:               tx  ty  translate       -
 *        or     tx  ty  matrix  translate       matrix
 *
 * TITLE:       op_translate
 *
 * CALL:        op_translate()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_translate)
 *
 * CALLS:       preprocess_op, PUT_VALUE
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_translate(opns)
fix     opns;
{
        real32   tx, ty;
        bool    matrix_exist;
        struct  object_def FAR *obj_operand[3];

        /* preprocess operands : check error and dcide operator type */
        matrix_exist = preprocess_op(opns, obj_operand);

        if(matrix_exist == ERR){
             return(0);
        }
        else if(matrix_exist == TRUE){

             /* check access right */
             if( !access_chk(obj_operand[0], ARRAY_ONLY)) return(0);

             GET_OBJ_VALUE(tx, obj_operand[2]);
             GET_OBJ_VALUE(ty, obj_operand[1]);

             PUT_VALUE(F2L(one_f), 0, obj_operand[0]);
             PUT_VALUE(F2L(zero_f), 1, obj_operand[0]);
             PUT_VALUE(F2L(zero_f), 2, obj_operand[0]);
             PUT_VALUE(F2L(one_f), 3, obj_operand[0]);
             PUT_VALUE(F2L(tx), 4, obj_operand[0]);
             PUT_VALUE(F2L(ty), 5, obj_operand[0]);

             /* pop operand stack */
             POP(3);

             /* push modified matrix on the operand stack */
             PUSH_OBJ(obj_operand[0]);
        }
        else{   /* matrix_exist == FALSE */

                /* replace the CTM by [1.0, 0.0, 0.0, 1.0, tx, ty] * CTM,
                 * i.e., GSptr->ctm[ep, fp] = GSptr->ctm[a*tx + c*ty + e,
                 * b*tx + d*ty + f] */

                GET_OBJ_VALUE(tx, obj_operand[1]);
                GET_OBJ_VALUE(ty, obj_operand[0]);

                _clear87() ;
                GSptr->ctm[4] = GSptr->ctm[0] * tx + GSptr->ctm[2] * ty +
                                GSptr->ctm[4];
                CHECK_INFINITY(GSptr->ctm[4]);

                GSptr->ctm[5] = GSptr->ctm[1] * tx + GSptr->ctm[3] * ty +
                                GSptr->ctm[5];
                CHECK_INFINITY(GSptr->ctm[5]);
                /* pop operand stack */
                POP(2);
        }

        return(0);
}

/***********************************************************************
 *
 * This module is to scale the user coordinate system by (sx, sy) units,
 * or to define scaling the value of matrix by (sx, sy) units
 *
 * SYNTAX:              sx  sy  scale   -
 *        or    sx  sy  matrix  scale   matrix
 *
 * TITLE:       op_scale
 *
 * CALL:        op_scale()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_scale)
 *
 * CALLS:       preprocess_op, PUT_VALUE
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_scale(opns)
fix     opns;
{
        real32   sx, sy;
        bool    matrix_exist;
        struct  object_def FAR *obj_operand[3];

        /* preprocess operands : check error and dcide operator type */
        matrix_exist = preprocess_op(opns, obj_operand);

        if(matrix_exist == ERR){
             return(0);
        }
        else if(matrix_exist == TRUE){

            /* check access right */
            if( !access_chk(obj_operand[0], ARRAY_ONLY) ) return(0);

            GET_OBJ_VALUE(sx, obj_operand[2]);
            GET_OBJ_VALUE(sy, obj_operand[1]);

            PUT_VALUE(F2L(sx), 0, obj_operand[0]);
            PUT_VALUE(F2L(zero_f), 1, obj_operand[0]);
            PUT_VALUE(F2L(zero_f), 2, obj_operand[0]);
            PUT_VALUE(F2L(sy), 3, obj_operand[0]);
            PUT_VALUE(F2L(zero_f), 4, obj_operand[0]);
            PUT_VALUE(F2L(zero_f), 5, obj_operand[0]);

            /* pop operand stack */
            POP(3);

            /* push modified matrix on the operand stack */
            PUSH_OBJ(obj_operand[0]);

        }
        else{   /* matrix_exist == FALSE */

                /* replace the CTM by [sx, 0.0, 0.0, sy, 0.0, 0.0]*CTM,
                 * i.e., GSptr->ctm[ap, bp, cp, dp] =
                 *       GSptr->ctm[a*sx, b*sx, c*sy, d*sy] */

#ifdef DBG
                printf("op_scale: before\n");
                printf("ctm[0]=%f, ctm[1]=%f\n", GSptr->ctm[0], GSptr->ctm[1]);
                printf("ctm[2]=%f, ctm[3]=%f\n", GSptr->ctm[2], GSptr->ctm[3]);
                printf("ctm[4]=%f, ctm[5]=%f\n", GSptr->ctm[4], GSptr->ctm[5]);
#endif
                GET_OBJ_VALUE(sx, obj_operand[1]);
                GET_OBJ_VALUE(sy, obj_operand[0]);

                _clear87() ;
                GSptr->ctm[0] = GSptr->ctm[0] * sx;
                CHECK_INFINITY(GSptr->ctm[0]);

                GSptr->ctm[1] = GSptr->ctm[1] * sx;
                CHECK_INFINITY(GSptr->ctm[1]);

                GSptr->ctm[2] = GSptr->ctm[2] * sy;
                CHECK_INFINITY(GSptr->ctm[2]);

                GSptr->ctm[3] = GSptr->ctm[3] * sy;
                CHECK_INFINITY(GSptr->ctm[3]);

                /* pop operand stack */
                POP(2);
#ifdef DBG
                printf("op_scale: after\n");
                printf("ctm[0]=%f, ctm[1]=%f\n", GSptr->ctm[0], GSptr->ctm[1]);
                printf("ctm[2]=%f, ctm[3]=%f\n", GSptr->ctm[2], GSptr->ctm[3]);
                printf("ctm[4]=%f, ctm[5]=%f\n", GSptr->ctm[4], GSptr->ctm[5]);
#endif
        }

        return(0);
}


/***********************************************************************
 *
 * This module is to rotate the user coordinate system by angle degrees,
 * or to rotating the value of matrix by angle degrees
 *
 * SYNTAX:              angle  rotate   -
 *         or   angle  matrix  rotate   matrix
 *
 * TITLE:       op_rotate
 *
 * CALL:        op_rotate()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_rotate)
 *
 * CALLS:       PUT_VALUE
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_rotate(opns)
fix     opns;
{
        real64  theta;
        bool    matrix_exist;
        real32   a, b, c, d;
        real32   angle, cos_theta, sin_theta, neg_sin_theta;
        struct  object_def FAR *obj_opd0, FAR *obj_opd1;

        /* get operand */
        obj_opd0 = GET_OPERAND(0);

        if(opns == 2){
                matrix_exist = TRUE;           /* matrix exist flag */

                /* check rangecheck error */
                if(LENGTH(obj_opd0) != MATRIX_LEN){
                        ERROR(RANGECHECK);
                        return(0);
                }

                /* get operand */
                obj_opd1 = GET_OPERAND(1);

        }
        else{
             matrix_exist = FALSE;          /* matrix exist flag */
        }

        if(matrix_exist == TRUE){

            GET_OBJ_VALUE(angle, obj_opd1);
            if( F2L(angle) == F2L(infinity_f)){
                  cos_theta = infinity_f;
                  sin_theta = infinity_f;
            }
            else{
                  /* angle -= (real32)floor(angle/360.)*360.; 1/17/89 */
                  theta = angle * PI / 180;
                  cos_theta = (real32)cos(theta);
                  sin_theta = (real32)sin(theta);
            }

            /* check access right */
            if( !access_chk(obj_opd0, ARRAY_ONLY) ) return(0);

            PUT_VALUE(F2L(cos_theta), 0, obj_opd0);
            PUT_VALUE(F2L(sin_theta), 1, obj_opd0);

            if(F2L(sin_theta) == F2L(infinity_f)){
                 PUT_VALUE(F2L(infinity_f), 2, obj_opd0);
            }
            else{
                 neg_sin_theta = -sin_theta;
                 PUT_VALUE(F2L(neg_sin_theta), 2, obj_opd0);
            }

            PUT_VALUE(F2L(cos_theta), 3, obj_opd0);
            PUT_VALUE(F2L(zero_f), 4, obj_opd0);
            PUT_VALUE(F2L(zero_f), 5, obj_opd0);
            /* pop operand stack */
            POP(2);

            /* push modified matrix on the operand stack */
            PUSH_OBJ(obj_opd0);
        }
        else{   /* matrix_exist == FALSE */

                GET_OBJ_VALUE(angle, obj_opd0);
                if( F2L(angle) == F2L(infinity_f)){
                  GSptr->ctm[0] = infinity_f;
                  GSptr->ctm[1] = infinity_f;
                  GSptr->ctm[2] = infinity_f;
                  GSptr->ctm[3] = infinity_f;
                  POP(1);
                  return(0);
                }
                else{
                      /* angle -= (real32)floor(angle/360.)*360.; 1/17/89 */
                      theta = angle * PI / 180;
                      cos_theta = (real32)cos(theta);
                      sin_theta = (real32)sin(theta);
                }

                /* replace the CTM by  R * CTM,
                 * i.e., GSptr->ctm = [cos, sin, -sin, cos, 0.0, 0.0]*CTM */
                a = GSptr->ctm[0];
                b = GSptr->ctm[1];
                c = GSptr->ctm[2];
                d = GSptr->ctm[3];
                _clear87() ;
                GSptr->ctm[0] =  a * cos_theta + c * sin_theta;
                CHECK_INFINITY(GSptr->ctm[0]);

                GSptr->ctm[1] =  b * cos_theta + d * sin_theta;
                CHECK_INFINITY(GSptr->ctm[1]);

                GSptr->ctm[2] = -a * sin_theta + c * cos_theta;
                CHECK_INFINITY(GSptr->ctm[2]);

                GSptr->ctm[3] = -b * sin_theta + d * cos_theta;
                CHECK_INFINITY(GSptr->ctm[3]);
                /* pop operand stack */
                POP(1);
        }

        return(0);
}


/***********************************************************************
 *
 * state by concatenating the matrix with the current CTM
 *
 * SYNTAX:      matrix  concat  -
 *
 * TITLE:       op_concat
 *
 * CALL:        op_concat()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_concate)
 *
 * CALLS:       get_array_elmt
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_concat()
{
        struct  object_def FAR *obj_matrix;
        real32   l, m, n, o, p, q, elmt[MATRIX_LEN];

        /* get operand */
        obj_matrix = GET_OPERAND(0);

        /* check rangecheck error */
        if(LENGTH(obj_matrix) != MATRIX_LEN){
                ERROR(RANGECHECK);
                return(0);
        }

        /* check access right */
        if( !access_chk(obj_matrix, G_ARRAY) ) return(0);

        /* get matrix element */
        if( !get_array_elmt(obj_matrix,MATRIX_LEN,(real32 FAR*) elmt,G_ARRAY))
                return(0);

        /* value of CTM elements */
        l = GSptr->ctm[0];
        m = GSptr->ctm[1];
        n = GSptr->ctm[2];
        o = GSptr->ctm[3];
        p = GSptr->ctm[4];
        q = GSptr->ctm[5];

        _clear87() ;
        GSptr->ctm[0] = elmt[0] * l + elmt[1] * n;
        CHECK_INFINITY(GSptr->ctm[0]);

        GSptr->ctm[1] = elmt[0] * m + elmt[1] * o;
        CHECK_INFINITY(GSptr->ctm[1]);

        GSptr->ctm[2] = elmt[2] * l + elmt[3] * n;
        CHECK_INFINITY(GSptr->ctm[2]);

        GSptr->ctm[3] = elmt[2] * m + elmt[3] * o;
        CHECK_INFINITY(GSptr->ctm[3]);

        GSptr->ctm[4] = elmt[4] * l + elmt[5] * n + p;
        CHECK_INFINITY(GSptr->ctm[4]);

        GSptr->ctm[5] = elmt[4] * m + elmt[5] * o + q;
        CHECK_INFINITY(GSptr->ctm[5]);

        /* pop operand stack */
        POP(1);
        return(0);
}


/***********************************************************************
 *
 * This module is to replace the value of matrix3 by the result of
 * concatenating matrix1 with the matrix2
 *
 * SYNTAX:      matrix1  matrix2  matrix3 concatmatrix  matrix3
 *
 * TITLE:       op_concatmatrix
 *
 * CALL:        op_concatmatrix()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_concatmatrix)
 *
 * CALLS:       get_array_elmt
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_concatmatrix()
{
        real32   ap, bp, cp, dp, ep, fp;
        real32   elmt1[MATRIX_LEN], elmt2[MATRIX_LEN];
        struct  object_def FAR *obj_opd0, FAR *obj_opd1, FAR *obj_opd2;

        obj_opd0 = GET_OPERAND(0);
        obj_opd1 = GET_OPERAND(1);
        obj_opd2 = GET_OPERAND(2);

        /* check rangecheck error */
        if((LENGTH(obj_opd0) != MATRIX_LEN) ||
           (LENGTH(obj_opd1) != MATRIX_LEN) ||
           (LENGTH(obj_opd2) != MATRIX_LEN)){
                ERROR(RANGECHECK);
                return(0);
        }

        /* check access right */
        if( !access_chk(obj_opd0, ARRAY_ONLY) ) return(0);
        if( !access_chk(obj_opd1, G_ARRAY) ) return(0);
        if( !access_chk(obj_opd2, G_ARRAY) ) return(0);

        /* get matrix element */
        if( !get_array_elmt(obj_opd2,MATRIX_LEN,(real32 FAR*)elmt2,G_ARRAY))
                return(0);

        /* get matrix element */
        if( !get_array_elmt(obj_opd1,MATRIX_LEN,(real32 FAR*)elmt1,G_ARRAY))
                return(0);

        /* create modified matrix3 element objects */
        _clear87() ;
        ap = elmt2[0] * elmt1[0] + elmt2[1] * elmt1[2];
        CHECK_INFINITY(ap);

        bp = elmt2[0] * elmt1[1] + elmt2[1] * elmt1[3];
        CHECK_INFINITY(bp);

        cp = elmt2[2] * elmt1[0] + elmt2[3] * elmt1[2];
        CHECK_INFINITY(cp);

        dp = elmt2[2] * elmt1[1] + elmt2[3] * elmt1[3];
        CHECK_INFINITY(dp);

        ep = elmt2[4] * elmt1[0] + elmt2[5] * elmt1[2] + elmt1[4];
        CHECK_INFINITY(ep);

        fp = elmt2[4] * elmt1[1] + elmt2[5] * elmt1[3] + elmt1[5];
        CHECK_INFINITY(fp);

        PUT_VALUE(F2L(ap), 0, obj_opd0);
        PUT_VALUE(F2L(bp), 1, obj_opd0);
        PUT_VALUE(F2L(cp), 2, obj_opd0);
        PUT_VALUE(F2L(dp), 3, obj_opd0);
        PUT_VALUE(F2L(ep), 4, obj_opd0);
        PUT_VALUE(F2L(fp), 5, obj_opd0);

        /* pop operand stack */
        POP(3);

        /* push modified matrix3 on the operand stack */
        /* PUSH_OBJ(obj_opd0);  this cause one more save level Nov-11-91 YM */
        PUSH_ORIGLEVEL_OBJ(obj_opd0); /* Nov-11-91 YM */

        return(0);
}


/***********************************************************************
 *
 * This module is to transform the user coordinate (x, y) by the current
 * CTM to produce the corresponding device coordinate (x', y'), or to
 * transform (x, y) by the matrix to produce the corresponding (x', y')
 *
 * SYNTAX:              x  y  transform  x'  y'
 *         or   x  y  matrix  transform  x'  y'
 *
 * TITLE:       op_transform
 *
 * CALL:        op_transform()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_transform)
 *
 * CALLS:       get_array_elmt
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_transform(opns)
fix     opns;
{
        bool    matrix_exist;
        union   four_byte   xp4, yp4;
        real32   x, y, xp, yp, elmt[MATRIX_LEN];
        struct  object_def  FAR *obj_operand[3];

        /* preprocess operands : check error and dcide operator type */
        matrix_exist = preprocess_op(opns, obj_operand);

        if(matrix_exist == ERR){
                return(0);
        }
        else if(matrix_exist == TRUE){

                GET_OBJ_VALUE(x, obj_operand[2]);
                GET_OBJ_VALUE(y, obj_operand[1]);

                /* get matrix element */
                if(!get_array_elmt(obj_operand[0],MATRIX_LEN,
                    (real32 FAR*)elmt,G_ARRAY))
                        return(0);

                _clear87() ;
                xp = elmt[0] * x + elmt[2] * y + elmt[4];
                CHECK_INFINITY(xp);

                yp = elmt[1] * x + elmt[3] * y + elmt[5];
                CHECK_INFINITY(yp);

                /* pop operand stack */
                POP(3);
        }
        else{   /*matrix_exist == FALSE */

                GET_OBJ_VALUE(x, obj_operand[1]);
                GET_OBJ_VALUE(y, obj_operand[0]);

                _clear87() ;
                xp = GSptr->ctm[0]*x + GSptr->ctm[2]*y + GSptr->ctm[4];
                CHECK_INFINITY(xp);

                yp = GSptr->ctm[1]*x + GSptr->ctm[3]*y + GSptr->ctm[5];
                CHECK_INFINITY(yp);

                /* pop operand stack */
                POP(2);
        }

        /* push (xp, yp) on the operand stack */
        xp4.ff = xp;
        yp4.ff = yp;
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, xp4.ll);
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, yp4.ll);

        return(0);
}


/***********************************************************************
 *
 * This module is to transform the distance vector (dx, dy) by the
 * current CTM to produce the corresponding distance vector (dx', dy')
 * in device coordinate, or to transform (dx, dy) by the matrix to
 * produce the corresponding (dx', dy')
 *
 * SYNTAX:              dx  dy  dtransform  dx'  dy'
 *         or   dx  dy  matrix  dtransform  dx'  dy'
 *
 * TITLE:       op_dtransform
 *
 * CALL:        op_dtransform()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_dtransform)
 *
 * CALLS:       get_array_elmt
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_dtransform(opns)
fix     opns;
{
        bool    matrix_exist;
        union   four_byte   dxp4, dyp4;
        real32   dx, dy, dxp, dyp, elmt[MATRIX_LEN];
        struct  object_def  FAR *obj_operand[3];

        /* preprocess operands : check error and dcide operator type */
        matrix_exist = preprocess_op(opns, obj_operand);

        if(matrix_exist == ERR){
                return(0);
        }
        else if(matrix_exist == TRUE){

                GET_OBJ_VALUE(dx, obj_operand[2]);
                GET_OBJ_VALUE(dy, obj_operand[1]);

                /* get matrix element */
                if(!get_array_elmt(obj_operand[0],MATRIX_LEN,
                        (real32 FAR*)elmt,G_ARRAY) )
                        return(0);

                _clear87() ;
                dxp = elmt[0] * dx + elmt[2] * dy;
                CHECK_INFINITY(dxp);

                dyp = elmt[1] * dx + elmt[3] * dy;
                CHECK_INFINITY(dyp);

                /* pop operand stack */
                POP(3);
        }
        else{   /*matrix_exist == FALSE */

                GET_OBJ_VALUE(dx, obj_operand[1]);
                GET_OBJ_VALUE(dy, obj_operand[0]);

                _clear87() ;
                dxp = GSptr->ctm[0]*dx + GSptr->ctm[2]*dy;
                CHECK_INFINITY(dxp);

                dyp = GSptr->ctm[1]*dx + GSptr->ctm[3]*dy;
                CHECK_INFINITY(dyp);

                /* pop operand stack */
                POP(2);
        }

        /* push (dxp, xyp) on the operand stack */
        dxp4.ff = dxp;
        dyp4.ff = dyp;
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, dxp4.ll);
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, dyp4.ll);

        return(0);
}


/***********************************************************************
 *
 * This module is to transform the user coordinate (x', 'y) by the
 * inverse of current CTM to produce the corresponding device coordinate
 * (x, y), or to transform (x', y') by the inverse matrix to produce the
 * corresponding (x, y)
 *
 * SYNTAX:              x'  y'  itransform  x  y
 *         or   x'  y'  matrix  itransform  x  y
 *
 * TITLE:       op_itransform
 *
 * CALL:        op_itransform()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_itransform)
 *
 * CALLS:       preprocess_op, get_array_elmt
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_itransform(opns)
fix     opns;
{
        bool    matrix_exist;
        real32   det_matrix;
        real32   x, y, xp, yp, elmt[MATRIX_LEN];
        union   four_byte   x4, y4;
        struct  object_def  FAR *obj_operand[3];
        /*real32  tmp;*/

        /* preprocess operands : check error and dcide operator type */
        matrix_exist = preprocess_op(opns, obj_operand);

        if(matrix_exist == ERR){
                return(0);
        }
        else if(matrix_exist == TRUE){

                GET_OBJ_VALUE(xp, obj_operand[2]);
                GET_OBJ_VALUE(yp, obj_operand[1]);

                /* get matrix element */
                if( !get_array_elmt(obj_operand[0],MATRIX_LEN,
                        (real32 FAR*)elmt,G_ARRAY))
                        return(0);

                _clear87() ;
                det_matrix = elmt[0] * elmt[3] - elmt[1] * elmt[2];
                CHECK_INFINITY(det_matrix);


                /* check undefinedresult error */
                /*FABS(tmp, det_matrix);
                if(tmp <= (real32)UNDRTOLANCE){   3/20/91; scchen*/
                if(IS_ZERO(det_matrix)) {
                        ERROR(UNDEFINEDRESULT);
                        return(0);
                }

                x = (elmt[3]*xp - elmt[2]*yp - elmt[4]*elmt[3] +
                     elmt[2]*elmt[5]) / det_matrix;
                CHECK_INFINITY(x);

                y = (elmt[0]*yp - elmt[1]*xp - elmt[0]*elmt[5] +
                     elmt[4]*elmt[1]) / det_matrix;
                CHECK_INFINITY(y);

                /* pop operand stack */
                POP(3);
        }
        else{   /*matrix_exist == FALSE */

                GET_OBJ_VALUE(xp, obj_operand[1]);
                GET_OBJ_VALUE(yp, obj_operand[0]);

                _clear87() ;
                det_matrix = GSptr->ctm[0] * GSptr->ctm[3] -
                             GSptr->ctm[1] * GSptr->ctm[2];
                CHECK_INFINITY(det_matrix);

                /* check undefinedresult error */
                /*FABS(tmp, det_matrix);
                if(tmp <= (real32)UNDRTOLANCE){   3/20/91; scchen*/
                if(IS_ZERO(det_matrix)) {
                        ERROR(UNDEFINEDRESULT);
                        return(0);
                }

                x = (GSptr->ctm[3]*xp - GSptr->ctm[2]*yp -
                     GSptr->ctm[4]*GSptr->ctm[3] +
                     GSptr->ctm[2]*GSptr->ctm[5]) / det_matrix;
                CHECK_INFINITY(x);

                y = (GSptr->ctm[0]*yp - GSptr->ctm[1]*xp -
                     GSptr->ctm[0]*GSptr->ctm[5] +
                     GSptr->ctm[4]*GSptr->ctm[1]) / det_matrix;
                CHECK_INFINITY(y);

                /* pop operand stack */
                POP(2);
        }

        /* push (x, y) on the operand stack */
        x4.ff = x;
        y4.ff = y;
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, x4.ll);
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, y4.ll);

        return(0);
}


/***********************************************************************
 *
 * This module is to transform the distance vector (dx', dy') by the
 * inverse of current CTM to produce the corresponding distance vector
 * (dx, dy) in user coordinate, or to transform (dx', dy') by the
 * inverse of matrix to produce the corresponding (dx, dy)
 *
 * SYNTAX:              dx'  dy'  idtransform  dx  dy
 *         or   dx'  dy'  matrix  idtransform  dx  dy
 *
 * TITLE:       op_idtransform
 *
 * CALL:        op_idtransform()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_idtransform)
 *
 * CALLS:       preprocess_op, get_array_elmt
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_idtransform(opns)
fix     opns;
{
        bool    matrix_exist;
        real32   det_matrix;
        real32   dx, dy, dxp, dyp, elmt[MATRIX_LEN];
        union   four_byte   dx4, dy4;
        struct  object_def  FAR *obj_operand[3];
        /*real32  tmp;*/

        /* preprocess operands : check error and dcide operator type */
        matrix_exist = preprocess_op(opns, obj_operand);

        if(matrix_exist == ERR){
                return(0);
        }
        else if(matrix_exist == TRUE){

                GET_OBJ_VALUE(dxp, obj_operand[2]);
                GET_OBJ_VALUE(dyp, obj_operand[1]);

                /* get matrix element */
                if( !get_array_elmt(obj_operand[0],MATRIX_LEN,
                        (real32 FAR*)elmt,G_ARRAY))
                        return(0);

                /* calculate the det(matrix) */
                _clear87() ;
                det_matrix = elmt[0] * elmt[3] - elmt[1] * elmt[2];
                CHECK_INFINITY(det_matrix);

                /* check undefinedresult error */
                /*FABS(tmp, det_matrix);
                if(tmp <= (real32)UNDRTOLANCE){   3/20/91; scchen*/
                if(IS_ZERO(det_matrix)) {
                        ERROR(UNDEFINEDRESULT);
                        return(0);
                }

                /* calculate (dx, dy), (dx, dy) -concat- INV(matrix) */
                dx = ( elmt[3] / det_matrix) * dxp +
                     (-elmt[2] / det_matrix) * dyp;
                CHECK_INFINITY(dx);

                dy = (-elmt[1] / det_matrix) * dxp +
                     ( elmt[0] / det_matrix) * dyp;
                CHECK_INFINITY(dy);

                /* pop operand stack */
                POP(3);
        }
        else{   /*matrix_exist == FALSE */

                GET_OBJ_VALUE(dxp, obj_operand[1]);
                GET_OBJ_VALUE(dyp, obj_operand[0]);

                /* calculate the det(CTM) */
                _clear87() ;
                det_matrix = GSptr->ctm[0] * GSptr->ctm[3] -
                             GSptr->ctm[1] * GSptr->ctm[2];
                CHECK_INFINITY(det_matrix);

                /* check undefinedresult error */
                /*FABS(tmp, det_matrix);
                if(tmp <= (real32)UNDRTOLANCE){   3/20/91; scchen*/
                if(IS_ZERO(det_matrix)) {
                        ERROR(UNDEFINEDRESULT);
                        return(0);
                }

                /* calculate (dx, dy), (dx, dy) -concat- INV(CTM) */
                dx = ( GSptr->ctm[3] / det_matrix) * dxp +
                     (-GSptr->ctm[2] / det_matrix) * dyp;
                CHECK_INFINITY(dx);

                dy = (-GSptr->ctm[1] / det_matrix) * dxp +
                     ( GSptr->ctm[0] / det_matrix) * dyp;
                CHECK_INFINITY(dy);

                /* pop operand stack */
                POP(2);
        }

        /* push (dx, dy) on the operand stack */
        dx4.ff = dx;
        dy4.ff = dy;
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, dx4.ll);
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, dy4.ll);

        return(0);
}


/***********************************************************************
 *
 * This module is to replace the value of matrix2 by the result of
 * inverting matrix1
 *
 * SYNTAX:      matrix1  matrix2  invertmatrix  matrix2
 *
 * TITLE:       op_invertmatrix
 *
 * CALL:        op_invertmatrix()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_invertmatrix)
 *
 * CALLS:       get_array_elmt, PUT_VALUE
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_invertmatrix()
{
        real32   det_matrix1;
        real32   ap, bp, cp, dp, ep, fp, elmt[MATRIX_LEN];
        struct  object_def FAR *obj_opd0, FAR *obj_opd1;
        /*real32  tmp;*/

        obj_opd0 = GET_OPERAND(0);
        obj_opd1 = GET_OPERAND(1);

        /* check rangecheck error */
        if((LENGTH(obj_opd0) != MATRIX_LEN) ||
           (LENGTH(obj_opd1) != MATRIX_LEN)){
                ERROR(RANGECHECK);
                return(0);
        }

        /* check access right */
        if( !access_chk(obj_opd0, ARRAY_ONLY) ) return(0);

        /* get matrix element */
        if( !get_array_elmt(obj_opd1,MATRIX_LEN,
                (real32 FAR*)elmt,G_ARRAY) ) return(0);

        /* calculate the det(matrix1) */
        _clear87() ;
        det_matrix1 = elmt[0] * elmt[3] - elmt[1] * elmt[2];
        CHECK_INFINITY(det_matrix1);

        /* check undefinedresult error */
        /*FABS(tmp, det_matrix1);
        if(tmp <= (real32)UNDRTOLANCE){   3/20/91; scchen*/
        if(IS_ZERO(det_matrix1)) {
                ERROR(UNDEFINEDRESULT);
                return(0);
        }

        ap =  elmt[3] / det_matrix1;
        CHECK_INFINITY(ap);

        bp = -elmt[1] / det_matrix1;
        CHECK_INFINITY(bp);

        cp = -elmt[2] / det_matrix1;
        CHECK_INFINITY(cp);

        dp =  elmt[0] / det_matrix1;
        CHECK_INFINITY(dp);

        ep = (elmt[2] * elmt[5] - elmt[3] * elmt[4]) / det_matrix1;
        CHECK_INFINITY(ep);

        fp = (elmt[1] * elmt[4] - elmt[0] * elmt[5]) / det_matrix1;
        CHECK_INFINITY(fp);

        PUT_VALUE(F2L(ap), 0, obj_opd0);
        PUT_VALUE(F2L(bp), 1, obj_opd0);
        PUT_VALUE(F2L(cp), 2, obj_opd0);
        PUT_VALUE(F2L(dp), 3, obj_opd0);
        PUT_VALUE(F2L(ep), 4, obj_opd0);
        PUT_VALUE(F2L(fp), 5, obj_opd0);
        /* pop operand stack */
        POP(2);

        /* push modified matrix2 on the operand stack */
        PUSH_OBJ(obj_opd0);

        return(0);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\graph\gopr.c ===
/*
 * Copyrigqht (c) 1989,90 Microsoft Corporation

 */
/**********************************************************************
 *
 *      Name:       gopr.c
 *
 *      Purpose:    This file contains routines to process the graphics
 *                  operators.
 *
 *      Developer:  S.C.Chen
 *
 *      History:
 *      Version     Date        Comments
 *      1.0         12/24/87    Performance enhancement:
 *                              1.@PRE_CLIP
 *                                pre-clipping for fixed-point
 *                                arithmatics
 *                  1/7/88      @RECT_I:
 *                              integer polygon structure
 *                  4/7/88      @INV_CTM: pre-set inverse CTM
 *                  4/15/88     @PAGE_TYPE: page type selection
 *                  4/18/88     @CLIP_TBL: move clip_path from
 *                              edge_table to node_table
 *                  5/19/88     update initial value for calculating
 *                              path bounding box
 *                  5/20/88     limit check for op_framedevice
 *                  5/23/88     @DEVICE: update framedevice & nulldevice
 *                              for correct operation under gsave/grestore.
 *                              append 4 fields in dev_hdr: width, hight,
 *                              chg_flg, and nuldev_flg.
 *                  5/23/88     @PFALL: copy current path to a working path
 *                              for dumpping all nodes
 *                  6/02/88     @DFL_CLP: default clip in SFX format
 *                  7/19/88     update data types:
 *                              1) float ==> real32
 *                              2) int   ==> sfix_t, for short fixed real
 *                                           fix, for integer
 *                                 short ==> fix
 *                              3) long  ==> long32, for parameter
 *                              4) iwidth8 * 8 ==> I2SFX(iwidth8)
 *                                 iheight * 8 ==> I2SFX(iheight)
 *                                 ux - 8 ==> ux - ONE_SFX
 *                                 uy - 8 ==> uy - ONE_SFX
 *                              5) add compiling option: LINT_ARGS
 *                              6) introduce ATTRIBUTE_SET
 *                  7/20/88     @ARC_POP: pop operand stack for degernated
 *                              arc in arc_process
 *                  7/20/88     @PAGE_CNT: update page count for each print
 *                  7/22/88     @PRT_FLAG: set SHOWPAGE/COPYPAGE flag for
 *                              lower level graphics primitives
 *                  8/11/88     remove continuation mark "\" in routines:
 *                              op_arcto
 *      3.0         8/13/88     @SCAN_EHS: scan_conversion enhancement
 *                  8/18/88     @OUT_PAGE: enhancement of out_page checking
 *                  8/30/88     move in erasepage() from "shape.c"
 *                  9/06/88     @STK_INFO: collect parameters used by stroke to
 *                              a structure stk_info, and set its value only at
 *                              necessary time instead of each op_stroke command
 *                  10/27/88    change routine check_infinity() to
 *                              macro CHECK_INFINITY()
 *                  11/24/88    @FABS: update fabs ==> macro FABS
 *                  11/25/88    @STK_CHK: check if operand stack no free space
 *                  11/30/88    clip_process(): call init_edgetable before
 *                              shape_approximation
 *                  12/02/88    arc_process(), op_arcto(): modify OUTPAGE check
 *                  12/14/88    clip_process(): init. values of clip box
 *                  12/15/88    revise inverse_transform(): directly solve
 *                              equations instead of inverse_ctm[]
 *                  1/25/89     op_framedevice(): for compatability --
 *                              1. add rangecheck on matrix
 *                              2. modify values of limit check
 *                              3. ignore invalid access check on matrix
 *                  1/28/89     @REM_STK: not change contains of operand stack
 *                              when error occurs
 *                  1/30/89     op_strokepath(): update currentpoint
 *                  1/31/89     op_arcto(): delete dirty code
 *                                          change arc to arc_to_bezier
 *                                          check small cross angle condition
 *                  1/31/89     @STK_OVR: push values to operand stack as many
 *                              as possible until overflow
 *                  5/26/89     st_frameto_printer(): add one more parameter
 *                              "manfeed" for manualfeed feature
 *                  11/15/89    @NODE: re-structure node table; combine subpath
 *                              and first vertex to one node.
 *                  11/27/89    @DFR_GS: defer copying nodes of gsave operator
 *                  1/15/90     st_frametoprinter(): modify input interface for
 *                              LW-V47 compatability; left margins changed from
 *                              bytes to bits. Note: 1pp also needs to be
 *                              modified.
 *                  2/20/90     fix @NODE bug in op_reversepath()
 *                  7/26/90     Jack Liaw, update for grayscale
 *                  8/31/90     ccteng; include stdio.h, remove dprintf
 *                  11/29/90    check undefine error, Jack
 *                  12/4/90     @CPPH: fix limitcheck error of clippath
 *                              op_clippath(): save clipping trapezoids in
 *                                 cp_path, defined in path_table[], instead
 *                                 of transforming it to path directly.
 *                              fill_clippath(): new created for op_fill/eofill
 *                              op_initclip(): free old clipping path only it
 *                                 does not used by current path(cp_path).
 *                              op_fill & op_eofill(): try to fill clipping
 *                                 trapezoids (call fill_clippath) directly
 *                                 instead of normal filling procedure.
 *                              op_pathbbox(): set current point as init value
 *                                 of bbox, since path->head may be NULLP.
 *                  1/7/91      change < (real32)UNDRTOLANCE to <= (real32)UNDRTOLANCE
 *                  1/11/91     op_pathbbox(): for charpath, current point is
 *                              not a real node, pathbbox can not use it as
 *                              init value.
 *                  2/22/91     op_flattenpath(): fix the bug of an
 *                              un-initialized variable vlist.
 *                  2/28/91     op_stroke(): fix the bug of ignoring stroke
 *                              when 0 scaling in both x and y which occurs on
 *                              12-12-90 update.
 *                  3/20/91     refine the tolerance check:
 *                              f <= UNDRTOLANCE --> IS_ZERO(f)
 *                              f == 0 --> IS_ZERO(f)
 *                              f <  0 --> SIGN_F(f)
 *                  3/26/91     op_reversepath(): fix the bug of an
 *                              uninitialized variable vlist.
 *                  4/17/91     clip_process(): limit check for edge table
 **********************************************************************/


// DJC added global include
#include "psglobal.h"



#include <math.h>
#include "global.ext"
#include "graphics.h"
#include "graphics.ext"
#include "fillproc.h"                   /* 8-1-90 Jack Liaw */
#include "fillproc.ext"                 /* 8-1-90 Jack Liaw */
#include "font.h"
#include "font.ext"
#include "stdio.h"

/* grayscale 8-1-90 Jack Liaw */
extern ufix32 highmem;
extern gmaddr FBX_BASE; //DJC @WIN  put back , now used...

/* #define GV_flag 1    @GEI */
/* papertype changed 10-11-90, JS */
//DJC ufix32  last_frame = 0;

/* ********** static variables ********** */
/* type of print_page, for lower level graphics primitives @PRT_FLAG */
static bool near print_page_flag;
static byte cur_gray_mode = MONODEV;    /* @GRAY */

/* ********** static function declartion ********** */

#ifdef LINT_ARGS
/* for type checks of the parameters in function declarations */
static void near moveto_process(fix);
static void near lineto_process(fix);
static void near arc_process(fix);
static struct coord * near endpoint (long32, long32, long32, long32, long32,
                               long32, long32, ufix);
static void near curveto_process(fix);
static void near free_newpath(void);
static void near clip_process(fix);
static void near erasepage(void);
static fix near fill_clippath(void);                   /* @CPPH */

#else
/* for no type checks of the parameters in function declarations */
static void near moveto_process();
static void near lineto_process();
static void near arc_process();
static struct coord * near endpoint ();
static void near curveto_process();
static void near free_newpath();
static void near clip_process();
static void near erasepage();
static fix near fill_clippath();                   /* @CPPH */
#endif

/************************************************************************
 * This module is to implement newpath operator.
 * Syntax :        -   newpath   -
 *
 * TITLE:       op_newpath
 *
 * CALL:        op_newpath()
 *
 * INTERFACE:   interpreter(op_newpath)
 *
 * CALLS:       none
 ************************************************************************/
fix
op_newpath()
{
        /* free current path */
        free_path();

        /* set no current point */
        F2L(GSptr->position.x) = F2L(GSptr->position.y) = NOCURPNT;

        return(0);
}


/************************************************************************
 * This module is to implement currentpoint operator.
 * Syntax :        -   currentpoint   x y
 *
 * TITLE:       op_currentpoint
 *
 * CALL:        op_currentpoint()
 *
 * INTERFACE:   interpreter(op_currentpoint)
 *
 * CALLS:       inverse_transform
 ************************************************************************/
fix
op_currentpoint()
{
        struct coord FAR *p;
        union  four_byte x4, y4;

        /* check nocurrentpoint error */
        if(F2L(GSptr->position.x) == NOCURPNT){
                ERROR(NOCURRENTPOINT);
                return(0);
        }

        /* Get current position, transform to user's space,
         * and push to operand stack
         */
        /* check infinity 10/29/88 */
        if ((F2L(GSptr->position.x) == F2L(infinity_f)) ||
            (F2L(GSptr->position.y) == F2L(infinity_f))) {
                x4.ff = infinity_f;
                y4.ff = infinity_f;
        } else {
                p = inverse_transform(F2L(GSptr->position.x),
                                      F2L(GSptr->position.y));

                if(ANY_ERROR()) return(0);      /* @REM_STK */

                x4.ff = p->x;
                y4.ff = p->y;
        }

        if(FRCOUNT() < 1){                      /* @STK_OVR */
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, x4.ll);
        if(FRCOUNT() < 1){                      /* @STK_OVR */
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, y4.ll);

        return(0);
}


/************************************************************************
 * This module is to process 