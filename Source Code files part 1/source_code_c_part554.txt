h methods
//

template< typename EOS >
backref_tag< typename EOS::const_iterator > _match_helper( 
    const basic_rpattern_base<typename EOS::const_iterator> & pat,
    match_param<typename EOS::const_iterator> & param,
    EOS eos )
{
    typedef typename EOS::const_iterator CI;

    if( GLOBAL & pat.flags() ) // do a global find
    {
        // The NOBACKREFS flag is ignored in the match method.
        const bool fAll   = ( ALLBACKREFS   == ( ALLBACKREFS   & pat.flags() ) );
        const bool fFirst = ( FIRSTBACKREFS == ( FIRSTBACKREFS & pat.flags() ) );

        backref_tag<CI>  br;
        vector<backref_tag<CI> > rgtempbackrefs;
        
        while( br = _do_match( pat, param ) )
        {
            // Handle specially the backref flags
            if( fFirst )
                rgtempbackrefs.push_back( br );
            else if( fAll )
                rgtempbackrefs.insert( rgtempbackrefs.end(),
                                       param.prgbackrefs->begin(),
                                       param.prgbackrefs->end() );
            else
                rgtempbackrefs.swap( *param.prgbackrefs );

            if( br.first == ( param.istart = br.second ) )
            {
                if( eos( param, param.istart ) )
                    break;
                ++param.istart;
            }
        }

        // restore the backref vectors
        if( !br || fFirst || fAll )
            param.prgbackrefs->swap( rgtempbackrefs );
        else if( ! (*param.prgbackrefs)[0] )
            param.prgbackrefs->clear();

        return param.prgbackrefs->empty() ? backref_tag<CI>() : (*param.prgbackrefs)[0];
    }
    else 
        return _do_match( pat, param );
}

template< typename CH, typename TR, typename AL >
basic_regexpr<CH,TR,AL>::backref_type basic_regexpr<CH,TR,AL>::match( 
    const basic_rpattern_base<const_iterator> & pat,
    size_type pos, size_type len ) const throw()
{
    if( pat.flags() & CSTRINGS )
    {
        assert( ! "A pattern optimized for CSTRINGS can only be used with the static regexpr::match method" );
        return backref_type();
    }

    m_pbackref_str = this;
    m_backref_str.erase(); // free up unused memory

    const_iterator istart = begin();
    advance( istart, pos );

    const_iterator istop;
    if( len == npos || pos + len >= size() )
        istop = end();
    else
        advance( istop = begin(), pos + len );

    match_param<const_iterator> param( istart, istop, & m_rgbackrefs );
    return _match_helper<eos_t<const_iterator> >( pat, param, eos_t<const_iterator>() );
}

template< typename CH >
backref_tag<const CH *> _static_match_helper( 
    const CH * szstr, 
    const basic_rpattern_base<const CH *> & pat,
    vector< backref_tag< const CH * > > * prgbackrefs ) throw()
{
    vector< backref_tag< const CH * > > rgdummyvector;
    if( NULL == prgbackrefs )
        prgbackrefs = &rgdummyvector;

    match_param<const CH *> param( szstr, NULL, prgbackrefs );
    return _match_helper<eocs_t<const CH *> >( pat, param, eocs_t<const CH *>() );
}

//
// Helper function called from both basic_regexpr::count methods
//
template< typename EOS >
size_t _count_helper( 
    const basic_rpattern_base<typename EOS::const_iterator> & pat,
    match_param<typename EOS::const_iterator> & param,
    EOS eos )
{
    typedef typename EOS::const_iterator CI;

    size_t cmatches = 0;
    vector<backref_tag<CI> > rgbackrefs; // dummy backref vector
    backref_tag<CI>          br;
    param.prgbackrefs = &rgbackrefs;

    while( br = _do_match( pat, param ) )
    {
        ++cmatches;

        if( br.first == ( param.istart = br.second ) )
        {
            if( eos( param, param.istart ) )
                break;
            ++param.istart;
        }
    }
    return cmatches;
}

template< typename CH, typename TR, typename AL >
size_t basic_regexpr<CH,TR,AL>::count( 
    const basic_rpattern_base<basic_regexpr<CH,TR,AL>::const_iterator> & pat,
    size_type pos, 
    size_type len ) const throw()
{
    if( pat.flags() & CSTRINGS )
    {
        assert( ! "A pattern optimized for CSTRINGS can only be used with the static regexpr::count method" );
        return backref_type();
    }

    m_pbackref_str = this;

    const_iterator istart = begin();
    advance( istart, pos );

    const_iterator istop;
    if( len == npos || pos + len >= size() )
        istop = end();
    else
        advance( istop = begin(), pos + len );

    match_param<const_iterator> param( istart, istop, NULL );
    return _count_helper<eos_t<const_iterator> >( pat, param, eos_t<const_iterator>() );
}

template< typename CH >
size_t _static_count_helper( 
    const CH * szstr, 
    const basic_rpattern_base<const CH *> & pat ) throw()
{
    match_param<const CH *> param( szstr, NULL, NULL );
    return _count_helper<eocs_t<const CH *> >( pat, param, eocs_t<const CH *>() );
}

// Base class for sub-expressions which are zero-width 
// (i.e., assertions eat no characters during matching)
// Assertions cannot be quantified.
template< typename CI >
class assertion : public sub_expr<CI>
{
public:
    virtual ~assertion() {}
    virtual bool is_assertion() const throw() { return true; }
protected:
    virtual width_type _width_this() throw() { return width_type(0,0); }
};

template< typename OP >
class assert_op : public assertion<typename OP::const_iterator>
{
public:
    typedef OP op_type;
    typedef typename OP::const_iterator CI;
    virtual ~assert_op() {}
protected:
    virtual bool _match_this( match_param<CI> & param, CI & icur ) const throw()
    {
        return m_op( param, icur );
    }
    op_type m_op;
};

template< typename CI >
assertion<CI> * create_bos( unsigned /*flags*/ )
{
    return new assert_op<bos_t<CI> >();
}

template< typename CI >
assertion<CI> * create_eos( unsigned flags )
{
    switch( CSTRINGS & flags )
    {
    case 0:
        return new assert_op<peos_t<CI> >();
    case CSTRINGS:
        return new assert_op<peocs_t<CI> >();
    default:
        __assume(0); // tells the compiler that this is unreachable
    }
}

template< typename CI >
assertion<CI> * create_eoz( unsigned flags )
{
    switch( CSTRINGS & flags )
    {
    case 0:
        return new assert_op<eos_t<CI> >();
    case CSTRINGS:
        return new assert_op<eocs_t<CI> >();
    default:
        __assume(0); // tells the compiler that this is unreachable
    }
}

template< typename CI >
assertion<CI> * create_bol( unsigned flags )
{
    switch( MULTILINE & flags )
    {
    case 0:
        return new assert_op<bos_t<CI> >();
    case MULTILINE:
        return new assert_op<bol_t<CI> >();
    default:
        __assume(0); // tells the compiler that this is unreachable
    }
}

template< typename CI >
assertion<CI> * create_eol( unsigned flags )
{
    switch( ( MULTILINE | CSTRINGS ) & flags )
    {
    case 0:
        return new assert_op<peos_t<CI> >();
    case MULTILINE:
        return new assert_op<eol_t<CI> >();
    case CSTRINGS:
        return new assert_op<peocs_t<CI> >();
    case MULTILINE | CSTRINGS:
        return new assert_op<eocl_t<CI> >();
    default:
        __assume(0); // tells the compiler that this is unreachable
    }
}

template< typename CI >
class match_atom : public sub_expr<CI>
{
public:
    match_atom( const basic_string<sub_expr<CI>::char_type>::iterator istart, 
                basic_string<sub_expr<CI>::char_type>::const_iterator istop ) 
        : m_istart( istart ), m_istop( istop ) {}
    virtual ~match_atom() {}

    const basic_string<sub_expr<CI>::char_type>::iterator m_istart;
    basic_string<sub_expr<CI>::char_type>::const_iterator m_istop;
protected:
    virtual width_type _width_this() throw() 
    { 
        size_t width = distance( (basic_string<sub_expr<CI>::char_type>::const_iterator)m_istart, m_istop ); 
        return width_type( width, width );
    }
};

template< typename EOS >
class match_atom_t : public match_atom<typename EOS::const_iterator>
{
public:
    typedef EOS eos_type;
    typedef typename EOS::const_iterator CI;
    match_atom_t( const basic_string<sub_expr<CI>::char_type>::iterator istart,
                  basic_string<sub_expr<CI>::char_type>::const_iterator istop ) 
        : match_atom<CI>( istart, istop ) {}
    virtual ~match_atom_t() {}
protected:
    virtual bool _match_this( match_param<CI> & param, CI & icur ) const throw()
    {
        CI icur_tmp = icur;
        basic_string<sub_expr<CI>::char_type>::const_iterator ithis = m_istart;
        for( ; ithis != m_istop; ++icur_tmp, ++ithis )
        {
            if( m_eos( param, icur_tmp ) || *ithis != *icur_tmp )
                return false;
        }
        icur = icur_tmp;
        return true;
    }
    eos_type  m_eos;
};

template< typename EOS >
class match_atom_nocase_t : public match_atom<typename EOS::const_iterator>
{
public:
    typedef EOS eos_type;
    typedef typename EOS::const_iterator CI;
    match_atom_nocase_t( const basic_string<sub_expr<CI>::char_type>::iterator istart, 
                         basic_string<sub_expr<CI>::char_type>::const_iterator istop ) 
        : match_atom<CI>( istart, istop ), m_strlower( (basic_string<sub_expr<CI>::char_type>::const_iterator)istart, istop ) 
    {
        // Store the uppercase version of the atom in [m_istart,m_istop).
        to_upper( m_istart, m_istop );
        // Store the lowercase version of the atom in m_strlower.
        to_lower( m_strlower.begin(), m_strlower.end() );
    }
    virtual ~match_atom_nocase_t() {}

protected:
    virtual bool _match_this( match_param<CI> & param, CI & icur ) const throw()
    {
        CI icur_tmp = icur;
        basic_string<sub_expr<CI>::char_type>::const_iterator ithisu   = m_istart;           // uppercase
        basic_string<sub_expr<CI>::char_type>::const_iterator ithisl   = m_strlower.begin(); // lowercase
        for( ; ithisu != m_istop; ++icur_tmp, ++ithisu, ++ithisl )
        {
            if( m_eos( param, icur_tmp ) || ( *ithisu != *icur_tmp && *ithisl != *icur_tmp ) )
                return false;
        }
        icur = icur_tmp;
        return true;
    }
    eos_type                 m_eos;
    basic_string<sub_expr<CI>::char_type>  m_strlower;
};

template< typename CI >
match_atom<CI> * create_atom(
    const basic_string<iterator_traits<CI>::value_type>::iterator istart,
    basic_string<iterator_traits<CI>::value_type>::const_iterator istop, 
    unsigned flags )
{
    switch( ( NOCASE | CSTRINGS ) & flags )
    {
    case 0:
        return new match_atom_t<eos_t<CI> >( istart, istop );
    case NOCASE:
        return new match_atom_nocase_t<eos_t<CI> >( istart, istop );
    case CSTRINGS:
        return new match_atom_t<eocs_t<CI> >( istart, istop );
    case NOCASE | CSTRINGS:
        return new match_atom_nocase_t<eocs_t<CI> >( istart, istop );
    default:
        __assume(0); // tells the compiler that this is unreachable
    }
}

template< typename CI >
match_atom<CI> * create_atom( 
    const basic_string<iterator_traits<CI>::value_type>::iterator istart, 
    unsigned flags )
{
    basic_string<iterator_traits<CI>::value_type>::const_iterator istop = istart;
    return create_atom<CI>( istart, ++istop, flags );
}

template< typename CI >
class match_any : public sub_expr<CI>
{
public:
    virtual ~match_any() {}
protected:
    virtual width_type _width_this() throw() { return width_type(1,1); }
};

template< typename EOS >
class match_any_t : public match_any<typename EOS::const_iterator>
{
public:
    typedef EOS eos_type;
    typedef typename EOS::const_iterator CI;
    virtual ~match_any_t() {}
protected:
    virtual bool _match_this( match_param<CI> & param, CI & icur ) const throw()
    {
        if( m_eos( param, icur ) )
            return false;
        ++icur;
        return true;
    }
    eos_type m_eos;
};

template< typename CI >
match_any<CI> * create_any( unsigned flags ) 
{
    switch( ( SINGLELINE | CSTRINGS ) & flags )
    {
    case 0:
        return new match_any_t<eol_t<CI> >();
    case SINGLELINE:
        return new match_any_t<eos_t<CI> >();
    case CSTRINGS:
        return new match_any_t<eocl_t<CI> >();
    case SINGLELINE | CSTRINGS:
        return new match_any_t<eocs_t<CI> >();
    default:
        __assume(0); // tells the compiler that this is unreachable
    }
}

typedef pair<wchar_t,wchar_t> range_type;
const vector<range_type> g_rgranges; // empty

template< typename CI >
class match_charset : public sub_expr<CI>
{
public:
    match_charset( bool fcomplement,
                   const ascii_bitvector & bvect )
        : m_fcomplement( fcomplement ),
          m_rgascii( bvect ),
          m_rgranges( g_rgranges ),
          m_ncharflags(0) {}

    // Note that only the references are copied here -- they are not ref counted.
    // Beware of variable lifetime issues.
    match_charset( const match_charset<CI> & that )
        : m_fcomplement( that.m_fcomplement ),
          m_rgascii( that.m_rgascii ),
          m_rgranges( that.m_rgranges ),
          m_ncharflags( that.m_ncharflags ) {}

    virtual ~match_charset() {}

    const bool                 m_fcomplement;
    const ascii_bitvector    & m_rgascii;  // bitmap for chars in range 0-255
    const vector<range_type> & m_rgranges; // vector of included character ranges 256-65535
    wctype_t                   m_ncharflags; // Parameter to iswctype()

    // The case-sensitivity of a character set is "compiled" into the ascii_bitvector
    // but not into the range vector because it is too computationally expensive. Instead,
    // when doing a unicode case-insensitive match on the ranges vector, two lookups
    // must be performed -- one lowercase and one uppercase. By contrast, only one lookup
    // is needed for the ascii_bitvector.

protected:

    match_charset( bool fcomplement, 
                   const ascii_bitvector & bvect,
                   const vector<range_type> & rgranges )
        : m_fcomplement( fcomplement ),
          m_rgascii( bvect ),
          m_rgranges( rgranges ),
          m_ncharflags(0) {}

    // this method should never be called. match_charset is only a base class
    // for match_charset_t
    virtual bool _match_this( match_param<CI> &, CI & ) const throw()
    {
        assert(false);
        return true;
    }

    template< typename SY >
    match_charset<CI> * get_altern_charset( char_type ch, unsigned flags, SY /*sy*/ ) const throw()
    {
        return basic_rpattern<CI,SY>::s_charset_map.get( ch, flags );
    }
    virtual width_type _width_this() throw() { return width_type(1,1); }
};

// Used as a template parameter to find a unicode character in an array of ranges.
class match_range : public unary_function<wchar_t,bool>
{
protected:
    const vector<range_type> & m_rgranges;

    // determines if one range is less then another.
    // used in binary search of range vector
    inline static bool _range_less( const range_type & rg1,
                                    const range_type & rg2 ) throw()
    {
        return rg1.second < rg2.first;
    }

    match_range( const vector<range_type> & rgranges )
        : m_rgranges( rgranges ) {}
};

class match_range_with_case : public match_range
{
public:
    match_range_with_case( const vector<range_type> & rgranges )
        : match_range( rgranges ) {}
    inline bool operator()( wchar_t ch ) const throw()
    {
        return binary_search( m_rgranges.begin(), m_rgranges.end(), 
                              range_type(ch,ch), _range_less );
    }
};

class match_range_no_case : public match_range
{
public:
    match_range_no_case( const vector<range_type> & rgranges )
        : match_range( rgranges ) {}
    inline bool operator()( wchar_t ch ) const throw()
    {
        const wchar_t chup = towupper( ch );
        if( binary_search( m_rgranges.begin(), m_rgranges.end(), 
                           range_type(chup,chup), _range_less ) )
            return true;

        const wchar_t chlo = towlower( ch );
        if( chup != chlo &&
            binary_search( m_rgranges.begin(), m_rgranges.end(), 
                           range_type(chlo,chlo), _range_less ) )
            return true;

        return false;    
    }
};

template< typename EOS, typename RGM >
class match_charset_t : public match_charset<typename EOS::const_iterator>
{
public:
    typedef EOS eos_type;
    typedef RGM range_match_type;
    typedef typename EOS::const_iterator CI;

    match_charset_t( const match_charset<CI> & that )
        : match_charset<CI>( that ), m_rgm( m_rgranges ) {}
    virtual ~match_charset_t() {}

    inline bool is_in_charset( char_type ch ) const throw()
    {
        return m_fcomplement != _is_in_charset( ch );
    }

protected:
    match_charset_t( bool fcomplement,
                     const ascii_bitvector & bvect,
                     const vector<range_type> & rgranges )
        : match_charset<CI>( fcomplement, bvect, rgranges ), m_rgm( m_rgranges ) {}

    // Note overloading based on parameter
    inline bool _is_in_charset( char ch ) const throw()
    {
        return ( m_rgascii[ (unsigned char)(ch) ] ) || 
               ( m_ncharflags && ( _pctype[(unsigned char)(ch)] & m_ncharflags ) );
    }

    // Note overloading based on parameter
    inline bool _is_in_charset( wchar_t ch ) const throw()
    {
        if( UCHAR_MAX >= ch )
            return _is_in_charset( char(ch) );

        // use range_match_type to see if this character is within one of the
        // ranges stored in m_rgranges.
        return ( ! m_rgranges.empty() && m_rgm( ch ) ) || 
               ( m_ncharflags && iswctype( ch, m_ncharflags ) );
    }

    virtual bool _match_this( match_param<CI> & param, CI & icur ) const throw()
    {
        if( m_eos( param, icur ) || ! is_in_charset( *icur ) )
            return false;
        ++icur;
        return true;
    }

    // range_match_type encapsulates the case-sensitivity
    // issues with doing a unicode lookup on the ranges vector.
    range_match_type m_rgm;
    eos_type         m_eos;
};

template< typename EOS, typename RGM >
class match_custom_charset_t : public match_charset_t<EOS,RGM>
{
public:
    template< typename SY >
    match_custom_charset_t( bool fcomplement,
                            basic_string<char_type>::iterator & icur,
                            basic_string<char_type>::const_iterator istop,
                            unsigned flags, SY /*sy*/ ) throw(bad_regexpr,bad_alloc)
        : match_charset_t<EOS,RGM>( fcomplement, m_rgasciicustom, m_rgrangescustom )
    {
        _parse_charset( icur, istop, flags, SY() );
        _optimize();
    }

    virtual ~match_custom_charset_t() {}
    
    // for including one character set in another
    match_custom_charset_t<EOS,RGM> & operator|=( const match_charset<CI> & that )
    {
        assert( 0 == that.m_ncharflags );
        if( that.m_fcomplement )
        {
            m_rgasciicustom |= ~ that.m_rgascii;
            
            // append the inverse of that.m_rgranges to this->m_rgrangescustom
            wchar_t chlow = UCHAR_MAX;
            typedef vector<range_type>::const_iterator VCI;
            for( VCI prg = that.m_rgranges.begin(); prg != that.m_rgranges.end(); ++prg )
            {
                if( UCHAR_MAX + 1 != prg->first )
                    m_rgrangescustom.push_back( range_type( wchar_t(chlow+1), wchar_t(prg->first-1) ) );
                chlow = prg->second;
            }
            if( WCHAR_MAX != chlow )
                m_rgrangescustom.push_back( range_type( wchar_t(chlow+1), WCHAR_MAX ) );
        }
        else
        {
            m_rgasciicustom |= that.m_rgascii;
            m_rgrangescustom.insert( m_rgrangescustom.end(),
                                     that.m_rgranges.begin(), 
                                     that.m_rgranges.end() );
        }
        return *this;
    }

protected:

    // If we reached the end of the string before finding the end of the
    // character set, then this is an ill-formed regex
    void _check_iter( basic_string<char_type>::const_iterator icur,
                      basic_string<char_type>::const_iterator istop ) throw(bad_regexpr)
    {
        if( icur == istop )
            throw bad_regexpr("expecting end of character set");
    }

    template< typename SY >
    void _parse_charset( basic_string<char_type>::iterator & icur,
                         basic_string<char_type>::const_iterator istop,
                         unsigned flags, SY /*sy*/ ) throw(bad_regexpr,bad_alloc)
    {
        TOKEN tok;
        char_type ch_prev = 0;
        match_charset<CI> * pcharset;
        basic_string<char_type>::iterator iprev = icur;
        const bool fnocase = ( NOCASE == ( NOCASE & flags ) );

        _check_iter( icur, istop );

        // remember the current position and grab the next token
        tok = SY::charset_token( icur, istop );
        do
        {
            _check_iter( icur, istop );

            if( CHARSET_RANGE == tok && ch_prev )
            {
                // remember the current position
                basic_string<char_type>::iterator iprev2 = icur;
                char_type old_ch = ch_prev;
                ch_prev = 0;

                // old_ch is lower bound of a range
                switch( SY::charset_token( icur, istop ) )
                {
                case CHARSET_RANGE:
                case CHARSET_NEGATE:
                    icur = iprev2; // un-get these tokens and fall through
                case NO_TOKEN:
                case CHARSET_ESCAPE: // BUGBUG user-defined charset?
                    _set_bit_range( old_ch, *icur++, fnocase );
                    continue;
                case CHARSET_BACKSPACE:
                    _set_bit_range( old_ch, char_type(8), fnocase ); // backspace
                    continue;
                case CHARSET_END: // fall through
                default:          // not a range.
                    icur = iprev; // backup to range token
                    _set_bit( old_ch, fnocase );
                    _set_bit( *icur++, fnocase );
                    continue;
                }
            }

            if( ch_prev )
                _set_bit( ch_prev, fnocase );
            ch_prev = 0;

            switch( tok )
            {
            // None of the intrinsic charsets are case-sensitive,
            // so no special handling must be done when the NOCASE 
            // flag is set.
            case CHARSET_RANGE:
            case CHARSET_NEGATE:
            case CHARSET_END:
                icur = iprev; // un-get these tokens
                ch_prev = *icur++;
                continue;
            case CHARSET_BACKSPACE:
                ch_prev = char_type(8); // backspace
                continue;
            case ESC_DIGIT:
                *this |= match_charset<CI>( false, get_digit_vector() );
                continue;
            case ESC_NOT_DIGIT:
                *this |= match_charset<CI>( true,  get_digit_vector() );
                continue;
            case ESC_SPACE:
                *this |= match_charset<CI>( false, get_space_vector() );
                continue;
            case ESC_NOT_SPACE:
                *this |= match_charset<CI>( true,  get_space_vector() );
                continue;
            case ESC_WORD:
                *this |= match_charset<CI>( false, get_word_vector() );
                continue;
            case ESC_NOT_WORD:
                *this |= match_charset<CI>( true,  get_word_vector() );
                continue;
            case CHARSET_ALNUM:
                m_ncharflags |= (_ALPHA|_DIGIT);
                continue;
            case CHARSET_ALPHA:
                m_ncharflags |= (_ALPHA);
                continue;
            case CHARSET_BLANK:
                m_ncharflags |= (_BLANK);
                continue;
            case CHARSET_CNTRL:
                m_ncharflags |= (_CONTROL);
                continue;
            case CHARSET_DIGIT:
                m_ncharflags |= (_DIGIT);
                continue;
            case CHARSET_GRAPH:
                m_ncharflags |= (_PUNCT|_ALPHA|_DIGIT);
                continue;
            case CHARSET_LOWER:
                m_ncharflags |= (_LOWER);
                if( NOCASE == ( NOCASE & flags ) )
                    m_ncharflags |= (_UPPER);
                continue;
            case CHARSET_PRINT:
                m_ncharflags |= (_BLANK|_PUNCT|_ALPHA|_DIGIT);
                continue;
            case CHARSET_PUNCT:
                m_ncharflags |= (_PUNCT);
                continue;
            case CHARSET_SPACE:
                m_ncharflags |= (_SPACE);
                continue;
            case CHARSET_UPPER:
                m_ncharflags |= (_UPPER);
                if( NOCASE == ( NOCASE & flags ) )
                    m_ncharflags |= (_LOWER);
                continue;
            case CHARSET_XDIGIT:
                m_ncharflags |= (_HEX);
                continue;
            case CHARSET_ESCAPE:
                // Maybe this is a user-defined intrinsic charset
                pcharset = get_altern_charset( *icur, flags, SY() );
                if( NULL != pcharset )
                {
                    *this |= *pcharset;
                    ++icur;
                    continue;
                }
                // else fall through
            default:
                ch_prev = *icur++;
                continue;
            }
        }
        while( _check_iter( iprev = icur, istop ), CHARSET_END != ( tok = SY::charset_token( icur, istop ) ) );

        if( ch_prev )
            _set_bit( ch_prev, fnocase );
    }

    void _optimize()
    {
        // this sorts on range_type.first (uses operator<() for pair templates)
        sort( m_rgrangescustom.begin(), m_rgrangescustom.end() ); 
        
        // This merges ranges that overlap
        for( size_t index = 1; index < m_rgrangescustom.size(); )
        {
            if( m_rgrangescustom[index].first <= m_rgrangescustom[index-1].second + 1 )
            {
                m_rgrangescustom[index-1].second = max( 
                    m_rgrangescustom[index-1].second, m_rgrangescustom[index].second );
                m_rgrangescustom.erase( m_rgrangescustom.begin() + index );
            }
            else
                ++index;
        }
    }

    // Note overloading based on second parameter
    void _set_bit( char ch, const bool fnocase ) throw()
    { 
        if( fnocase )
        {
            m_rgasciicustom.set( (unsigned char)(tolower(ch)) );
            m_rgasciicustom.set( (unsigned char)(toupper(ch)) );
        }
        else
        {
            m_rgasciicustom.set( (unsigned char)(ch) ); 
        }
    }

    // Note overloading based on second parameter
    void _set_bit( wchar_t ch, const bool fnocase ) throw(bad_alloc)
    { 
        if( UCHAR_MAX >= ch )
            _set_bit( char(ch), fnocase );
        else
            m_rgrangescustom.push_back( range_type( ch, ch ) ); 
    }

    // Note overloading based on second parameter
    void _set_bit_range( char ch1, char ch2, const bool fnocase ) throw(bad_regexpr)
    {
        if( (unsigned char)(ch1) > (unsigned char)(ch2) )
            throw bad_regexpr("invalid range specified in character set");

        if( fnocase )
        {
            // i is unsigned int to prevent overflow if ch2 is UCHAR_MAX
            for( unsigned int i = (unsigned char)(ch1); i <= (unsigned char)(ch2); ++i )
            {
                m_rgasciicustom.set( (unsigned char)( toupper(i) ) );
                m_rgasciicustom.set( (unsigned char)( tolower(i) ) );
            }
        }
        else
        {
            // i is unsigned int to prevent overflow if ch2 is UCHAR_MAX
            for( unsigned int i = (unsigned char)(ch1); i <= (unsigned char)(ch2); ++i )
                m_rgasciicustom.set( (unsigned char)(i) );
        }
    }

    // Note overloading based on second parameter
    void _set_bit_range( wchar_t ch1, wchar_t ch2, const bool fnocase ) throw(bad_regexpr,bad_alloc)
    {
        if( ch1 > ch2 )
            throw bad_regexpr("invalid range specified in character set");

        if( UCHAR_MAX >= ch1 )
            _set_bit_range( char(ch1), char( min(wchar_t(UCHAR_MAX),ch2) ), fnocase );

        if( UCHAR_MAX < ch2 )
            m_rgrangescustom.push_back( range_type( max(wchar_t(UCHAR_MAX+1),ch1), ch2 ) );
    }

    ascii_bitvector    m_rgasciicustom;
    vector<range_type> m_rgrangescustom;
};


template< typename CI >
match_charset<CI> * create_charset( 
    const match_charset<CI> & that,
    unsigned flags )
{
    switch( ( NOCASE | CSTRINGS ) & flags )
    {
    case 0:
        return new match_charset_t<eos_t<CI>,match_range_with_case>( that );
    case NOCASE:
        return new match_charset_t<eos_t<CI>,match_range_no_case>( that );
    case CSTRINGS:
        return new match_charset_t<eocs_t<CI>,match_range_with_case>( that );
    case NOCASE | CSTRINGS:
        return new match_charset_t<eocs_t<CI>,match_range_no_case>( that );
    default:
        __assume(0); // tells the compiler that this is unreachable
    }
}

template< typename EOS >
class word_assertion_t : public assertion<typename EOS::const_iterator>
{
public:
    typedef EOS eos_type;
    typedef typename EOS::const_iterator CI;
    word_assertion_t() 
        : m_isword( match_charset<CI>( false, get_word_vector() ) ) {}
    virtual ~word_assertion_t() {}
protected:
    bos_t<CI>  m_bos;
    eos_type   m_eos;
    match_charset_t<eos_type,match_range_with_case> m_isword;
};

template< typename EOS >
class word_boundary_t : public word_assertion_t<EOS>
{
public:
    word_boundary_t( const bool fisboundary ) 
        : m_fisboundary( fisboundary ) {}
    virtual ~word_boundary_t() {}
protected:
    virtual bool _match_this( match_param<CI> & param, CI & icur ) const throw()
    {
        CI iprev = icur;
        --iprev;

        const bool fprevword = ! m_bos( param, icur ) && m_isword.is_in_charset( *iprev );
        const bool fthisword = ! m_eos( param, icur ) && m_isword.is_in_charset( *icur  );

        return ( m_fisboundary == ( fprevword != fthisword ) );
    }
    const bool m_fisboundary;
};

template< typename EOS >
class word_start_t : public word_assertion_t<EOS>
{
public:
    word_start_t() {}
    virtual ~word_start_t() {}
protected:
    virtual bool _match_this( match_param<CI> & param, CI & icur ) const throw()
    {
        CI iprev = icur;
        --iprev;

        const bool fprevword = ! m_bos( param, icur ) && m_isword.is_in_charset( *iprev );
        const bool fthisword = ! m_eos( param, icur ) && m_isword.is_in_charset( *icur  );

        return ! fprevword && fthisword;
    }
};

template< typename EOS >
class word_stop_t : public word_assertion_t<EOS>
{
public:
    word_stop_t() {}
    virtual ~word_stop_t() {}
protected:
    virtual bool _match_this( match_param<CI> & param, CI & icur ) const throw()
    {
        CI iprev = icur;
        --iprev;

        const bool fprevword = ! m_bos( param, icur ) && m_isword.is_in_charset( *iprev );
        const bool fthisword = ! m_eos( param, icur ) && m_isword.is_in_charset( *icur  );

        return fprevword && ! fthisword;
    }
};

template< typename CI >
assertion<CI> * create_word_boundary( const bool fisboundary, unsigned flags )
{
    switch( CSTRINGS & flags )
    {
    case 0:
        return new word_boundary_t<eos_t<CI> >( fisboundary );
    case CSTRINGS:
        return new word_boundary_t<eocs_t<CI> >( fisboundary );
    default:
        __assume(0); // tells the compiler that this is unreachable
    }
}

template< typename CI >
assertion<CI> * create_word_start( unsigned flags )
{
    switch( CSTRINGS & flags )
    {
    case 0:
        return new word_start_t<eos_t<CI> >();
    case CSTRINGS:
        return new word_start_t<eocs_t<CI> >();
    default:
        __assume(0); // tells the compiler that this is unreachable
    }
}

template< typename CI >
assertion<CI> * create_word_stop( unsigned flags )
{
    switch( CSTRINGS & flags )
    {
    case 0:
        return new word_stop_t<eos_t<CI> >();
    case CSTRINGS:
        return new word_stop_t<eocs_t<CI> >();
    default:
        __assume(0); // tells the compiler that this is unreachable
    }
}

template< typename CI > class group_quantifier;

template< typename CI >
class match_group : public sub_expr<CI>
{
public:
    friend class group_quantifier<CI>;

    match_group( size_t cgroup )
        : m_rgalternates(), m_pptail(NULL), m_cgroup( cgroup ),
          m_end_group( this ), m_nwidth(uninit_width) {}

    virtual ~match_group() {}

    virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
    {
        CI old_istart = CI();
        
        if( size_t(-1) != m_cgroup ) // could be -1 if this is a lookahead_assertion
        {
            old_istart = (*param.prgbackrefs)[ m_cgroup ].first;
            (*param.prgbackrefs)[ m_cgroup ].first = icur;
        }

        typedef vector<sub_expr<CI>*>::const_iterator VCI;
        for( VCI ialt = m_rgalternates.begin(); ialt != m_rgalternates.end(); ++ialt )
        {
            if( (*ialt)->domatch( param, icur ) )
                return true;
        }

        if( size_t(-1) != m_cgroup )
            (*param.prgbackrefs)[ m_cgroup ].first = old_istart;

        return false;
    }
    
    virtual void _delete()
    {
        typedef vector<sub_expr<CI>*>::iterator VI;
        for( VI ialt = m_rgalternates.begin(); ialt != m_rgalternates.end(); ++ialt )
            delete_sub_expr( *ialt );
        sub_expr<CI>::_delete();
    }

    size_t group_number() const 
    { 
        return m_cgroup; 
    }

    void group_number( size_t cgroup ) 
    { 
        m_cgroup = cgroup; 
    }

    void add_item( sub_expr<CI> * pitem )
    {
        *m_pptail = pitem;
        m_pptail = & pitem->next();
    }

    void add_alternate()
    {
        m_rgalternates.push_back( NULL );
        m_pptail = & m_rgalternates.back();
    }

    void end_alternate()
    {
        *m_pptail = & m_end_group;
    }

    size_t calternates() const 
    {
        return m_rgalternates.size();
    }

    width_type group_width()
    {
        (void) match_group<CI>::_width_this();
        return m_nwidth;
    }

protected:

    virtual bool _call_back( match_param<CI> & param, CI icur ) const throw()
    {
        CI old_iend = CI();

        if( size_t(-1) != m_cgroup )
        {
            old_iend = (*param.prgbackrefs)[ m_cgroup ].second;
            (*param.prgbackrefs)[ m_cgroup ].second = icur;
        }

        if( match_next( param, icur ) )
            return true;

        if( size_t(-1) != m_cgroup )
            (*param.prgbackrefs)[ m_cgroup ].second = old_iend;

        return false;
    }

    virtual width_type _width_this() throw()
    {
        typedef vector<sub_expr<CI>*>::const_iterator VCI;
        if( uninit_width == m_nwidth )
        {
            m_nwidth = width_type(size_t(-1),0);
            for( VCI ialt = m_rgalternates.begin(); worst_width != m_nwidth && ialt != m_rgalternates.end(); ++ialt )
            {
                width_type temp_width = (*ialt)->get_width();
                m_nwidth.m_min = min( m_nwidth.m_min, temp_width.m_min );
                m_nwidth.m_max = max( m_nwidth.m_max, temp_width.m_max );
            }
        }
        return m_nwidth;
    }

    class end_group;
    friend class end_group;
    class end_group : public sub_expr<CI>
    {
        void * operator new( size_t );
    public:
        end_group( match_group * pgroup ) 
            : m_pgroup( pgroup ) {}
        virtual ~end_group() {}
        virtual void _delete() {} // don't delete this, because it was never alloc'ed

        virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
        {
            return m_pgroup->_call_back( param, icur );
        }
    protected:
        // since m_pnext is always NULL for end_groups, get_width() stops recursing here
        virtual width_type _width_this() throw() 
        {
            return width_type(0,0); 
        }
        match_group<CI> * m_pgroup;
    };

    vector<sub_expr<CI>*> m_rgalternates;
    sub_expr<CI>       ** m_pptail; // only used when adding elements
    size_t                m_cgroup;
    end_group             m_end_group;
    width_type            m_nwidth;
};

// Behaves like a lookahead assertion if m_cgroup is -1, or like
// an independent group otherwise.
template< typename CI >
class independent_group : public match_group<CI>
{
public:
    independent_group() 
        : match_group<CI>( size_t(-1) ), m_fexpected(true) {}
    virtual ~independent_group() {}

    virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
    {
        // Copy the entire backref vector onto the stack
        backref_tag<CI> * prgbr =  (backref_tag<CI>*)_alloca( param.prgbackrefs->size() * sizeof backref_tag<CI> );
        copy( param.prgbackrefs->begin(), param.prgbackrefs->end(), 
              raw_storage_iterator<backref_tag<CI>*,backref_tag<CI> >(prgbr) );

        // Match until the end of this group and then return
        const bool fdomatch = match_group<CI>::domatch( param, icur );

        if( m_fexpected == fdomatch )
        {
            // If m_cgroup != 1, then this is not a zero-width assertion.
            if( size_t(-1) != m_cgroup )
                icur = (*param.prgbackrefs)[ m_cgroup ].second;

            if( match_next( param, icur ) )
                return true;
        }

        // if match_group::domatch returned true, the backrefs must be restored
        if( fdomatch )
            copy( prgbr, prgbr + param.prgbackrefs->size(), param.prgbackrefs->begin() );

        return false;
    }

protected:

    independent_group( const bool fexpected ) 
        : match_group<CI>( size_t(-1) ), m_fexpected(fexpected) {}

    virtual bool _call_back( match_param<CI> & param, CI icur ) const throw()
    {
        if( size_t(-1) != m_cgroup )
            (*param.prgbackrefs)[ m_cgroup ].second = icur;
        return true;
    }

    const bool m_fexpected;
};

template< typename CI >
class lookahead_assertion : public independent_group<CI>
{
public:
    lookahead_assertion( const bool fexpected )
        : independent_group<CI>( fexpected ) {}
    virtual ~lookahead_assertion() {}
    virtual bool is_assertion() const throw() { return true; }
protected:
    virtual width_type _width_this() throw() { return width_type(0,0); }
};

template< typename CI >
class lookbehind_assertion : public independent_group<CI>
{
public:
    lookbehind_assertion( const bool fexpected )
        : independent_group<CI>( fexpected ) {}
    virtual ~lookbehind_assertion() {}

    virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
    {
        // This is the room in the string from the start to the current position
        size_t room = distance( param.ibegin, icur );

        // If we don't have enough room to match the lookbehind, the match fails.
        // If we wanted the match to fail, try to match the rest of the pattern.
        if( m_nwidth.m_min > room )
            return m_fexpected ? false : match_next( param, icur );

        // Copy the entire backref vector onto the stack
        backref_tag<CI> * prgbr = (backref_tag<CI>*)_alloca( param.prgbackrefs->size() * sizeof backref_tag<CI> );
        copy( param.prgbackrefs->begin(), param.prgbackrefs->end(), 
              raw_storage_iterator<backref_tag<CI>*,backref_tag<CI> >(prgbr) );

        CI local_istart  = icur;
        advance( local_istart, -int( min( m_nwidth.m_max, room ) ) );

        CI local_istop = icur;
        advance( local_istop, -int( m_nwidth.m_min ) );

        // Create a local param struct that has icur as param.iend
        match_param<CI> local_param(param.ibegin,param.istart,icur,param.prgbackrefs);

        // Find the rightmost match that ends at icur.
        for( CI local_icur = local_istart; local_icur <= local_istop; ++local_icur )
        {
            // Match until the end of this group and then return
            const bool fmatched = match_group<CI>::domatch( local_param, local_icur );

            // If the match results were what we were expecting, try to match the
            // rest of the pattern. If that succeeds, return true.
            if( m_fexpected == fmatched && match_next( param, icur ) )
                return true;

            // if match_group::domatch returned true, the backrefs must be restored
            if( fmatched )
            {
                copy( prgbr, prgbr + param.prgbackrefs->size(), param.prgbackrefs->begin() );

                // Match succeeded. If this is a negative lookbehind, we didn't want it
                // to succeed, so return false.
                if( ! m_fexpected )
                    return false;
            }
        }

        // No variation of the lookbehind was satisfied in a way that permited
        // the rest of the pattern to match successfully, so return false.
        return false;
    }
    virtual bool is_assertion() const throw() { return true; }
protected:
    virtual bool _call_back( match_param<CI> & param, CI icur ) const throw()
    {
        return param.istop == icur;
    }
    virtual width_type _width_this() throw() { return width_type(0,0); }
};

// Corresponds to the (?:foo) extension, which has grouping semantics, but 
// does not store any backref information.
template< typename CI >
class group_nobackref : public match_group<CI>
{
public:
    group_nobackref( ) 
        : match_group( size_t(-1) ) {} // will be assigned a group number in basic_rpattern::basic_rpattern()
    virtual ~group_nobackref() {}
};

template< typename CI >
class match_wrapper : public sub_expr<CI>
{
public:
    match_wrapper( sub_expr<CI> * psub ) 
        : m_psub(psub) {}
    virtual ~match_wrapper() {}

    virtual void _delete()
    {
        delete_sub_expr( m_psub );
        sub_expr<CI>::_delete();
    }

protected:

    bool _wrapped_match_this( match_param<CI> & param, CI & icur ) const throw()
    {
        return m_psub->_match_this( param, icur );
    }
    
    virtual width_type _width_this() throw()
    {
        return m_psub->_width_this();
    }

    sub_expr<CI> * m_psub;
};

template< typename CI >
class match_quantifier : public match_wrapper<CI>
{
public:    
    match_quantifier( sub_expr<CI> * psub, size_t lbound, size_t ubound ) 
        : match_wrapper<CI>( psub ), m_lbound(lbound), m_ubound(ubound) {}

    virtual ~match_quantifier() {}

protected:

    virtual width_type _width_this() throw()
    {
        width_type this_width = match_wrapper<CI>::_width_this();

        return this_width * width_type( m_lbound, m_ubound );
    }

    const size_t m_lbound;
    const size_t m_ubound;
};

template< typename CI >
class max_atom_quantifier : public match_quantifier<CI>
{
public:
    max_atom_quantifier( sub_expr<CI> * psub, size_t lbound, size_t ubound ) 
        : match_quantifier<CI>( psub, lbound, ubound ) {}

    virtual ~max_atom_quantifier() {}

    virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
    {
        size_t cmatches = 0;
        int    cdiff    = 0; // must be a signed quantity for advance() below

        if( cmatches < m_ubound )
        {
            CI istart = icur;
            if( _wrapped_match_this( param, icur ) )
            {
                ++cmatches;
                cdiff = distance( istart, icur );
            
                if( 0 == cdiff )
                    return ( match_next( param, icur ) );

                while( cmatches < m_ubound && 
                       _wrapped_match_this( param, icur ) )
                {
                    ++cmatches;
                }
            }
        }

        if( cmatches >= m_lbound )
        {
            if( ! next() )
                return true;
    
            for(;;)
            {
                if( next()->domatch( param, icur ) )
                    return true;
                
                if( cmatches-- <= m_lbound )
                    break;
                
                advance( icur, -cdiff );
            }
        }

        return false;
    }
};

template< typename CI >
class min_atom_quantifier : public match_quantifier<CI>
{
public:    
    min_atom_quantifier( sub_expr<CI> * psub, size_t lbound, size_t ubound ) 
        : match_quantifier<CI>( psub, lbound, ubound ) {}

    virtual ~min_atom_quantifier() {}

    virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
    {
        size_t cmatches = 0;
        bool   fsuccess = true;
        CI icur_tmp = icur;

        if( _wrapped_match_this( param, icur_tmp ) )
        {
            if( icur_tmp == icur )
                return ( match_next( param, icur ) );

            if( m_lbound )
            {
                icur = icur_tmp;
                ++cmatches;
            }
            
            while( ( cmatches < m_lbound ) &&
                   ( fsuccess = _wrapped_match_this( param, icur ) ) )
            {
                ++cmatches;
            }
        }
        else
        {
            fsuccess = ! m_lbound;
        }

        if( fsuccess && next() )
        {
            do
            {
                if( next()->domatch( param, icur ) )
                    break;
            } while( fsuccess = ( cmatches++ < m_ubound && 
                                  _wrapped_match_this( param, icur ) ) );
        }

        return fsuccess;
    }
};

template< typename CI >
class group_quantifier : public match_quantifier<CI>
{
public:
    
    group_quantifier( match_group<CI> * psub, size_t lbound, size_t ubound ) 
        : match_quantifier<CI>( psub, lbound, ubound ),
          m_group( *psub ), m_end_quantifier( this )
    {
        psub->next() = & m_end_quantifier;
    }

    virtual ~group_quantifier() {}

    virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
    {
        // group_number is only -1 for assertions, which can't be quantified
        assert( size_t(-1) != group_number() );

        backref_tag<CI> & br = (*param.prgbackrefs)[ group_number() ];
        backref_tag<CI> old_backref = br;
        br = backref_tag<CI>( icur, icur ); // sets cmatches (reserved) to 0

        if( _recurse( param, icur ) )
            return true;

        br = old_backref;
        return false;
    }

protected:

    class end_quantifier;
    friend class end_quantifier;
    class end_quantifier : public sub_expr<CI>
    {
        void * operator new( size_t );
    public:
        end_quantifier( group_quantifier<CI> * pquant ) 
            : m_pquant( pquant ) {}

        virtual ~end_quantifier() {}
        virtual void _delete() {} // don't delete this, since it wasn't alloc'ed
        
        virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
        {
            // group_number is only -1 for assertions, which can't be quantified
            assert( size_t(-1) != m_pquant->group_number() );

            // handle special the case where a group matches 0 characters
            backref_tag<CI> & br = (*param.prgbackrefs)[ m_pquant->group_number() ];
            if( icur == br.first )
            {
                size_t old_cmatches = br.reserved;
                br.reserved = m_pquant->m_ubound;
                if( m_pquant->_recurse( param, icur ) )
                    return true;
                br.reserved = old_cmatches;
                return false;
            }
            return m_pquant->_recurse( param, icur );
        }

    protected:
        virtual width_type _width_this() throw() { return width_type(0,0); }
        group_quantifier<CI>             * m_pquant;
    };

    size_t group_number() const 
    { 
        return m_group.group_number(); 
    }

    size_t & cmatches( match_param<CI> & param ) const 
    { 
        return (*param.prgbackrefs)[ group_number() ].reserved; 
    }

    virtual bool _recurse( match_param<CI> & param, CI icur )  const throw() = 0;

    match_group<CI> & m_group;
    end_quantifier    m_end_quantifier;
};

template< typename CI >
class max_group_quantifier : public group_quantifier<CI>
{
public:
    max_group_quantifier( match_group<CI> * psub, size_t lbound, size_t ubound ) 
        : group_quantifier<CI>( psub, lbound, ubound ) {}

    virtual ~max_group_quantifier() {}

protected:

    virtual bool _recurse( match_param<CI> & param, CI icur ) const throw()
    {
        if( m_ubound == cmatches( param ) )
            return match_next( param, icur );

        ++cmatches( param );
        if( m_psub->domatch( param, icur ) )
            return true;

        if( --cmatches( param ) < m_lbound )
            return false;

        return match_next( param, icur );
    }
};

template< typename CI >
class min_group_quantifier : public group_quantifier<CI>
{
public:
    min_group_quantifier( match_group<CI> * psub, size_t lbound, size_t ubound ) 
        : group_quantifier<CI>( psub, lbound, ubound ) {}

    virtual ~min_group_quantifier() {}

protected:

    virtual bool _recurse( match_param<CI> & param, CI icur ) const throw()
    {
        if( m_lbound > cmatches( param ) )
        {
            ++cmatches( param );
            return m_psub->domatch( param, icur );
        }

        if( match_next( param, icur ) )
            return true;

        if( cmatches( param )++ == m_ubound )
            return false;
            
        return m_psub->domatch( param, icur );
    }
};

template< typename CI >
class match_backref : public sub_expr<CI>
{
public:
    match_backref( size_t cbackref, const width_type & group_width ) 
        : m_cbackref( cbackref ), m_nwidth(group_width) {}
    virtual ~match_backref() {}
protected:
    // Return the width specifications of the group to which this backref refers
    virtual width_type _width_this() throw() { return m_nwidth; }
    const size_t m_cbackref;
    const width_type m_nwidth;
};

template< typename CMP, typename EOS >
class match_backref_t : public match_backref<typename EOS::const_iterator>
{
public:
    typedef CMP cmp_type;
    typedef EOS eos_type;
    typedef typename EOS::const_iterator CI;
    match_backref_t( size_t cbackref, const width_type & group_width ) 
        : match_backref<CI>( cbackref, group_width ) {}
    virtual ~match_backref_t() {}
protected:
    virtual bool _match_this( match_param<CI> & param, CI & icur ) const throw()
    {
        CI ithis     = (*param.prgbackrefs)[ m_cbackref ].first;
        CI istop     = (*param.prgbackrefs)[ m_cbackref ].second;
        CI icur_tmp  = icur;

        // Don't match a backref that hasn't match anything
        if( ! (*param.prgbackrefs)[ m_cbackref ] )
            return false;

        for( ; ithis != istop; ++icur_tmp, ++ithis )
        {
            if( m_eos( param, icur_tmp ) || m_cmp( *icur_tmp, *ithis ) )
                return false;
        }
        icur = icur_tmp;
        return true;
    }
    cmp_type m_cmp;
    eos_type m_eos;
};

template< typename CI >
match_backref<CI> * create_backref( 
    size_t cbackref, 
    const width_type & group_width, 
    unsigned flags ) 
{
    typedef typename iterator_traits<CI>::value_type char_type;

    switch( ( NOCASE | CSTRINGS ) & flags )
    {
    case 0:
        return new match_backref_t<ch_neq_t<char_type>,eos_t<CI> >( cbackref, group_width );
    case NOCASE:
        return new match_backref_t<ch_neq_nocase_t<char_type>,eos_t<CI> >( cbackref, group_width );
    case CSTRINGS:
        return new match_backref_t<ch_neq_t<char_type>,eocs_t<CI> >( cbackref, group_width );
    case NOCASE | CSTRINGS:
        return new match_backref_t<ch_neq_nocase_t<char_type>,eocs_t<CI> >( cbackref, group_width );
    default:
        __assume(0); // tells the compiler that this is unreachable
    }
}

// Replace some escape sequences with the actual characters
// they represent
template< typename CI >
void basic_rpattern_base<CI>::_normalize_string( basic_string<basic_rpattern_base<CI>::char_type> & str )
{
    // Don't do pattern normalization if the user didn't ask for it.
    if( NORMALIZE != ( NORMALIZE & m_flags ) )
        return;

    process_escapes( str );
}

//
// Implementation of basic_rpattern:
//
template< typename CI, typename SY >
basic_rpattern<CI,SY>::basic_rpattern() throw()
    : basic_rpattern_base<CI>( 0 )
{
}

template< typename CI, typename SY >
basic_rpattern<CI,SY>::basic_rpattern( 
    const basic_string<basic_rpattern<CI,SY>::char_type> & pat, 
    unsigned flags ) throw(bad_regexpr,bad_alloc)
    : basic_rpattern_base<CI>( flags, pat )
{
    push_new_handler pnh( &my_new_handler );
    _normalize_string( m_pat );
    _common_init( flags );
}

template< typename CI, typename SY >
basic_rpattern<CI,SY>::basic_rpattern( 
    const basic_string<basic_rpattern<CI,SY>::char_type> & pat, 
    const basic_string<basic_rpattern<CI,SY>::char_type> & subst, 
    unsigned flags ) throw(bad_regexpr,bad_alloc)
    : basic_rpattern_base<CI>( flags, pat, subst )
{
    push_new_handler pnh( &my_new_handler );
    _normalize_string( m_pat );
    _common_init( flags );
    _normalize_string( m_subst );    
    _parse_subst(); // must come after _common_init
}

template< typename CI, typename SY >
void basic_rpattern<CI,SY>::init( 
    const basic_string<basic_rpattern<CI,SY>::char_type> & pat, 
    unsigned flags ) throw(bad_regexpr,bad_alloc)
{
    push_new_handler pnh( &my_new_handler );
    _reset();
    m_flags = flags;
    m_pat   = pat;
    _normalize_string( m_pat );
    _common_init( m_flags );
}

template< typename CI, typename SY >
void basic_rpattern<CI,SY>::init(
    const basic_string<basic_rpattern<CI,SY>::char_type> & pat, 
    const basic_string<basic_rpattern<CI,SY>::char_type> & subst, 
    unsigned flags ) throw(bad_regexpr,bad_alloc)
{
    push_new_handler pnh( &my_new_handler );
    _reset();
    m_flags = flags;
    m_pat   = pat;
    m_subst = subst;
    _normalize_string( m_pat );
    _common_init( m_flags );
    _normalize_string( m_subst );    
    _parse_subst(); // must come after _common_init
}

template< typename CI, typename SY >
void basic_rpattern<CI,SY>::_common_init( unsigned flags )
{
    m_cgroups = 0;
    vector<match_group<CI>*> rggroups;
    basic_string<char_type>::iterator ipat = m_pat.begin();
    match_group<CI> * pgroup = _find_next_group( ipat, flags, rggroups );

    m_pfirst = pgroup;
    m_nwidth = pgroup->group_width();

    // Number the invisible groups
    m_cgroups_visible = m_cgroups;
    while( ! m_invisible_groups.empty() )
    {
        m_invisible_groups.front()->group_number( _get_next_group_nbr() );
        m_invisible_groups.pop_front();
    }

    //
    // determine if we can get away with only calling m_pfirst->domatch only once
    //

    m_floop = true;

    // Optimization: if first character of pattern string is '^'
    // and we are not doing a multiline match, then we only 
    // need to try domatch once
    basic_string<char_type>::iterator icur = m_pat.begin();
    if( MULTILINE != ( MULTILINE & m_flags ) &&
        1 == pgroup->calternates() && 
        icur != m_pat.end() && 
        BEGIN_LINE == SY::reg_token( icur, m_pat.end() ) )
    {
        m_flags &= ~RIGHTMOST;
        m_floop = false;
    }

    // Optimization: if first 2 characters of pattern string are ".*" or ".+",
    // then we only need to try domatch once
    icur = m_pat.begin();
    if( RIGHTMOST != ( RIGHTMOST & m_flags ) &&
        SINGLELINE == ( SINGLELINE & m_flags ) &&
        1 == pgroup->calternates() &&
        icur != m_pat.end() && 
        MATCH_ANY == SY::reg_token( icur, m_pat.end() ) &&
        icur != m_pat.end() )
    {
        switch( SY::quant_token( icur, m_pat.end() ) )
        {
            case ONE_OR_MORE:
            case ZERO_OR_MORE:
            case ONE_OR_MORE_MIN:
            case ZERO_OR_MORE_MIN:
                m_floop = false;
        }
    }
}

template< typename CI, typename SY >
void basic_rpattern<CI,SY>::_reset() throw()
{
    basic_rpattern_base<CI>::_reset();

    m_cgroups = m_cgroups_visible = 0;
    m_floop   = true;

    m_subst.erase();
    m_pat.erase();

    m_pfirst.free_ptr();
    m_nwidth = uninit_width;
    m_subst_list.clear();
    m_invisible_groups.clear();
}

template< typename CI, typename SY >
void basic_rpattern<CI,SY>::set_flags( unsigned flags ) throw(bad_regexpr,bad_alloc)
{
    push_new_handler pnh( &my_new_handler );
    m_pfirst.free_ptr();
    m_flags = flags;
    _common_init( m_flags );
}

template< typename CI, typename SY >
void basic_rpattern<CI,SY>::set_substitution( const basic_string<basic_rpattern<CI,SY>::char_type> & subst ) throw(bad_regexpr,bad_alloc)
{
    push_new_handler pnh( &my_new_handler );
    m_subst_list.clear();
    m_subst = subst;
    _normalize_string( m_subst );
    _parse_subst();
}

template< typename CI, typename SY >
match_group<CI> * basic_rpattern<CI,SY>::_find_next_group( 
    basic_string<basic_rpattern<CI,SY>::char_type>::iterator & ipat, 
    unsigned & flags,
    vector<match_group<CI>*> & rggroups )
{
    auto_sub_ptr<match_group<CI> > pgroup;
    basic_string<char_type>::iterator itemp = ipat;
    unsigned old_flags = flags;
    TOKEN tok;

    // Look for group extensions. (This could change the value of the flags variable.)
    if( ipat != m_pat.end() && NO_TOKEN != ( tok = SY::ext_token( ipat, m_pat.end(), flags ) ) )
    {
        if( itemp == m_pat.begin() || ipat == m_pat.end() )
            throw bad_regexpr("ill-formed regular expression");

        // Don't process empty groups
        if( END_GROUP != SY::reg_token( itemp = ipat, m_pat.end() ) )
        {
            switch( tok )
            {
            case EXT_NOBACKREF:
                // invisible groups are numbered only after all
                // visible groups have been numbererd
                pgroup = new match_group<CI>( size_t(-1) );
                m_invisible_groups.push_back( pgroup.get() );
                break;

            case EXT_INDEPENDENT:
                pgroup = new independent_group<CI>();
                m_invisible_groups.push_back( pgroup.get() );
                break;

            case EXT_POS_LOOKAHEAD:
                pgroup = new lookahead_assertion<CI>( true );
                break;
            
            case EXT_NEG_LOOKAHEAD:
                pgroup = new lookahead_assertion<CI>( false );
                break;
            
            case EXT_POS_LOOKBEHIND:
                // For look-behind assertions, turn off the CSTRINGs optimization
                flags &= ~CSTRINGS;
                pgroup = new lookbehind_assertion<CI>( true );
                break;
            
            case EXT_NEG_LOOKBEHIND:
                // For look-behind assertions, turn off the CSTRINGs optimization
                flags &= ~CSTRINGS;
                pgroup = new lookbehind_assertion<CI>( false );
                break;
            
            default:
                throw bad_regexpr("bad extension sequence");
            }
        }
        else
        {
            // Skip over the END_GROUP token
            ipat = itemp;
        }
    }
    else
    {
        pgroup = new match_group<CI>( _get_next_group_nbr() );
    }

    if( NULL != pgroup.get() )
    {
        pgroup->add_alternate();
        while( _find_next( ipat, pgroup.get(), flags, rggroups ) );
        pgroup->end_alternate();

        // Add this group to the rggroups array
        if( size_t(-1) != pgroup->group_number() )
        {
            if( pgroup->group_number() >= rggroups.size() )
                rggroups.resize( pgroup->group_number() + 1, NULL );
            rggroups[ pgroup->group_number() ] = pgroup.get();
        }

        // The group should calculate its own width now and 
        // save the result for later.
        pgroup->group_width();

        // If this is not a pattern modifier, restore the 
        // flags to their previous settings.  This causes 
        // pattern modifiers to have the scope of their 
        // enclosing group.
        flags = old_flags;
    }

    return pgroup.release();
}

//
// Read ahead through the pattern and treat sequential atoms
// as a single atom, making sure to handle quantification
// correctly. Warning: dense code ahead.
//
template< typename CI, typename SY >
void basic_rpattern<CI,SY>::_find_atom( 
    basic_string<basic_rpattern<CI,SY>::char_type>::iterator & ipat,
    match_group<CI> * pgroup, 
    unsigned flags )
{
    basic_string<char_type>::iterator itemp = ipat, istart = ipat;

    do
    {
        switch( SY::quant_token( itemp, m_pat.end() ) )
        {
        // if {,} can't be interpreted as quantifiers, treat them as regular chars
        case BEGIN_RANGE:
            if( istart != ipat ) // treat as a quantifier
                goto quantify;
        case NO_TOKEN:
        case END_RANGE:
        case END_RANGE_MIN:
        case RANGE_SEPARATOR:
            break;

        default: 
            if( istart == ipat ) // must be able to quantify something.
                throw bad_regexpr("quantifier not expected");
quantify:   if( istart != --ipat )
                pgroup->add_item( create_atom<CI>( istart, ipat, flags ) );
            auto_sub_ptr<sub_expr<CI> > pnew( create_atom<CI>( ipat++, flags ) );
            _quantify( pnew, NULL, ipat );
            pgroup->add_item( pnew.release() );
            return;
        }
    } while( m_pat.end() != ++ipat && ! SY::reg_token( itemp = ipat, m_pat.end() ) );

    assert( ipat != istart );
    pgroup->add_item( create_atom<CI>( istart, ipat, flags ) );
}

template< typename CI, typename SY >
bool basic_rpattern<CI,SY>::_find_next( 
    basic_string<basic_rpattern<CI,SY>::char_type>::iterator & ipat,
    match_group<CI> * pgroup, 
    unsigned & flags,
    vector<match_group<CI>*> & rggroups )
{
    match_group<CI> * pnew_group = NULL;
    auto_sub_ptr<sub_expr<CI> > pnew;
    basic_string<char_type>::iterator istart, itemp;
    bool fdone;

    if( ipat == m_pat.end() )
    {
        if( 0 != pgroup->group_number() )
            throw bad_regexpr( "mismatched parenthesis" );
        return false;
    }

    switch( SY::reg_token( ipat, m_pat.end() ) )
    {
    case NO_TOKEN: // not a token. Must be an atom
        _find_atom( ipat, pgroup, flags );
        return true;
    
    case END_GROUP:
        if( 0 == pgroup->group_number() )
            throw bad_regexpr( "mismatched parenthesis" );
        return false;

    case ALTERNATION:
        pgroup->end_alternate();
        pgroup->add_alternate();
        return true;
    
    case BEGIN_GROUP:
        // Find next group could return NULL if the group is really
        // a pattern modifier, like: (?s-i)
        pnew = pnew_group = _find_next_group( ipat, flags, rggroups );
        break;

    case BEGIN_LINE:
        pnew = create_bol<CI>( flags );
        break;

    case END_LINE:
        pnew = create_eol<CI>( flags );
        break;

    case BEGIN_CHARSET:
        pnew = create_charset_helper<CI,SY>::create_charset_aux( m_pat, ipat, flags );
        break;

    case MATCH_ANY:
        pnew = create_any<CI>( flags );
        break;

    case ESC_WORD_BOUNDARY:
        pnew = create_word_boundary<CI>( true, flags );
        break;
    
    case ESC_NOT_WORD_BOUNDARY:
        pnew = create_word_boundary<CI>( false, flags );
        break;
    
    case ESC_WORD_START:
        pnew = create_word_start<CI>( flags );
        break;
    
    case ESC_WORD_STOP:
        pnew = create_word_stop<CI>( flags );
        break;
    
    case ESC_DIGIT:
        pnew = create_charset<CI>( match_charset<CI>( false,
                                                    get_digit_vector() ),
                                                    flags );
        break;

    case ESC_NOT_DIGIT:
        pnew = create_charset<CI>( match_charset<CI>( true,
                                                    get_digit_vector() ),
                                                    flags );
        break;

    case ESC_WORD:
        pnew = create_charset<CI>( match_charset<CI>( false,
                                                    get_word_vector() ),
                                                    flags );
        break;

    case ESC_NOT_WORD:
        pnew = create_charset<CI>( match_charset<CI>( true,
                                                    get_word_vector() ),
                                                    flags );
        break;

    case ESC_SPACE:
        pnew = create_charset<CI>( match_charset<CI>( false,
                                                    get_space_vector() ),
                                                    flags );
        break;

    case ESC_NOT_SPACE:
        pnew = create_charset<CI>( match_charset<CI>( true,
                                                    get_space_vector() ),
                                                    flags );
        break;

    case ESC_BEGIN_STRING:
        pnew = create_bos<CI>( flags );
        break;

    case ESC_END_STRING:
        pnew = create_eos<CI>( flags );
        break;

    case ESC_END_STRING_z:
        pnew = create_eoz<CI>( flags );
        break;

    case ESCAPE:

        if( char_type('0') <= *ipat && char_type('9') >= *ipat )
        {
            // use _cgroups_total here since the invisible groups have not been numbered yet.
            unsigned nbackref = parse_int( ipat, m_pat.end(), _cgroups_total() - 1 );// always at least 1 group
            if( 0 == nbackref || rggroups.size() <= nbackref || NULL == rggroups[ nbackref ] )
                throw bad_regexpr( "invalid backreference" );
            pnew = create_backref<CI>( nbackref, rggroups[nbackref]->group_width(), flags );
        }
        else
        {
            // Is this a user-defined intrinsic character set?
            match_charset<CI> * pcharset = s_charset_map.get( *ipat, flags );
            if( NULL != pcharset )
                pnew = create_charset<CI>( *pcharset, flags );
            else
                pnew = create_atom<CI>( ipat, flags );
            ++ipat;
        }
        break;

    // If quotemeta, loop until we find quotemeta off or end of string
    case ESC_QUOTE_META_ON:
        for( istart = itemp = ipat, fdone = false; !fdone && ipat != m_pat.end(); )
        {
            switch( SY::reg_token( ipat, m_pat.end() ) )
            {
            case ESC_QUOTE_META_OFF:
                fdone = true;
                break;
            case NO_TOKEN:
                ++ipat; // fallthrough
            default:
                itemp = ipat;
                break;
            }
        }
        if( itemp != istart )
            pgroup->add_item( create_atom<CI>( istart, itemp, flags ) );

        // skip the quantification code below
        return true;

    // Should never get here for valid patterns
    case ESC_QUOTE_META_OFF:
        throw bad_regexpr("quotemeta turned off, but was never turned on");

    default:
        assert( ! "Unhandled token type" );
        break;
    }
    
    // If pnew is null, then the current subexpression is a no-op.
    if( pnew.get() )
    {
        // Look for quantifiers
        _quantify( pnew, pnew_group, ipat );

        // Add the item to the group
        pgroup->add_item( pnew.release() );
    }
    return true;
}

template< typename CI, typename SY >
void basic_rpattern<CI,SY>::_quantify( 
    auto_sub_ptr<sub_expr<CI> > & pnew,
    match_group<CI> * pnew_group,
    basic_string<basic_rpattern<CI,SY>::char_type>::iterator & ipat )
{
    if( ipat != m_pat.end() && ! pnew->is_assertion() )
    {
        basic_string<char_type>::iterator itemp = ipat;
        bool fmin = false;
        
        // Since size_t is unsigned, -1 is really the largest size_t
        size_t lbound = (size_t)-1;
        size_t ubound = (size_t)-1;
        size_t ubound_tmp;

        switch( SY::quant_token( itemp, m_pat.end() ) )
        {
        case ZERO_OR_MORE_MIN:
            fmin = true;
        case ZERO_OR_MORE:
            lbound = 0;
            break;

        case ONE_OR_MORE_MIN:
            fmin = true;
        case ONE_OR_MORE:
            lbound = 1;
            break;

        case ZERO_OR_ONE_MIN:
            fmin = true;
        case ZERO_OR_ONE:
            lbound = 0;
            ubound = 1; 
            break;

        case BEGIN_RANGE:
            lbound = parse_int( itemp, m_pat.end() );
            if( itemp == m_pat.end() )
                throw bad_regexpr( "expecting end of range" );

            switch( SY::quant_token( itemp, m_pat.end() ) )
            {
            case END_RANGE_MIN:
                fmin = true;
            case END_RANGE:
                ubound = lbound;
                break;

            case RANGE_SEPARATOR:
                ipat = itemp;
                ubound_tmp = parse_int( itemp, m_pat.end() );
                if( itemp != ipat )
                    ubound = ubound_tmp;
                if( itemp == m_pat.end() )
                    throw bad_regexpr( "expecting end of range" );
                switch( SY::quant_token( itemp, m_pat.end() ) )
                {
                case END_RANGE_MIN:
                    fmin = true;
                case END_RANGE:
                    break;
                default:
                    throw bad_regexpr( "expecting end of range" );
                }
                break;

            default:
                throw bad_regexpr( "ill-formed quantifier" );
            }

            if( ubound < lbound  )
                throw bad_regexpr( "ill-formed quantifier" );

            break;
        }

        if( (size_t)-1 != lbound )
        {
            auto_sub_ptr<match_quantifier<CI> > pquant;

            // a group quantifier is less efficient than an atom quantifier
            if( fmin )
            {
                if( pnew_group )
                    pquant = new min_group_quantifier<CI>( pnew_group, 
                                                                 lbound, ubound );
                else
                    pquant = new min_atom_quantifier<CI>( pnew.get(), 
                                                                lbound, ubound );
            }
            else
            {
                if( pnew_group )
                    pquant = new max_group_quantifier<CI>( pnew_group, 
                                                                 lbound, ubound );
                else
                    pquant = new max_atom_quantifier<CI>( pnew.get(),
                                                                lbound, ubound );
            }

            pnew.release();
            pnew = pquant.release();
            ipat = itemp;
        }
    }
}

template< typename CI, typename SY >
void basic_rpattern<CI,SY>::_add_subst_backref( subst_node & snode, size_t nbackref, size_t rstart )
{
    m_fuses_backrefs = true;
    assert( subst_node::SUBST_STRING == snode.stype );
    if( snode.subst_string.rlength )
        m_subst_list.push_back( snode );

    snode.stype = subst_node::SUBST_BACKREF;
    snode.subst_backref = nbackref;
    m_subst_list.push_back( snode );

    // re-initialize the subst_node
    snode.stype = subst_node::SUBST_STRING;
    snode.subst_string.rstart = rstart;
    snode.subst_string.rlength = 0;
}

template< typename CI, typename SY >
void basic_rpattern<CI,SY>::_parse_subst()
{
    TOKEN tok;
    subst_node snode;
    basic_string<char_type>::iterator icur = m_subst.begin();
    size_t nbackref;
    basic_string<char_type>::iterator itemp;
    bool fdone;

    m_fuses_backrefs = false;

    // Initialize the subst_node
    snode.stype = subst_node::SUBST_STRING;
    snode.subst_string.rstart = 0;
    snode.subst_string.rlength = 0;

    while( icur != m_subst.end() )
    {
        switch( tok = SY::subst_token( icur, m_subst.end() ) )
        {
        case SUBST_MATCH:
            _add_subst_backref( snode, 0, distance( m_subst.begin(), icur ) );
            break;

        case SUBST_PREMATCH:
            _add_subst_backref( snode, (size_t)subst_node::PREMATCH, distance( m_subst.begin(), icur ) );
            break;

        case SUBST_POSTMATCH:
            _add_subst_backref( snode, (size_t)subst_node::POSTMATCH, distance( m_subst.begin(), icur ) );
            break;

        case SUBST_BACKREF:
            nbackref = parse_int( icur, m_subst.end(), cgroups() - 1 ); // always at least 1 group
            if( 0 == nbackref )
                throw bad_regexpr( "invalid backreference in substitution" );

            _add_subst_backref( snode, nbackref, distance( m_subst.begin(), icur ) );
            break;

        case SUBST_QUOTE_META_ON:
            assert( subst_node::SUBST_STRING == snode.stype );
            if( snode.subst_string.rlength )
                m_subst_list.push_back( snode );

            snode.subst_string.rstart = distance( m_subst.begin(), icur );
            for( itemp = icur, fdone = false; !fdone && icur != m_subst.end(); )
            {
                switch( tok = SY::subst_token( icur, m_subst.end() ) )
                {
                case SUBST_ALL_OFF:
                    fdone = true;
                    break;
                case NO_TOKEN:
                    ++icur; // fall-through
                default:
                    itemp = icur;
                    break;
                }
            }
            snode.subst_string.rlength = distance( m_subst.begin(), itemp ) - snode.subst_string.rstart;
            if( snode.subst_string.rlength )
                m_subst_list.push_back( snode );

            if( tok == SUBST_ALL_OFF )
            {
                snode.stype = subst_node::SUBST_OP;
                snode.op    = subst_node::ALL_OFF;
                m_subst_list.push_back( snode );
            }

            // re-initialize the subst_node
            snode.stype = subst_node::SUBST_STRING;
            snode.subst_string.rstart = distance( m_subst.begin(), icur );
            snode.subst_string.rlength = 0;
            break;

        case SUBST_UPPER_ON:
        case SUBST_UPPER_NEXT:
        case SUBST_LOWER_ON:
        case SUBST_LOWER_NEXT:
        case SUBST_ALL_OFF:
            assert( subst_node::SUBST_STRING == snode.stype );
            if( snode.subst_string.rlength )
                m_subst_list.push_back( snode );

            snode.stype = subst_node::SUBST_OP;
            snode.op    = (subst_node::op_type) tok;
            m_subst_list.push_back( snode );

            // re-initialize the subst_node
            snode.stype = subst_node::SUBST_STRING;
            snode.subst_string.rstart = distance( m_subst.begin(), icur );
            snode.subst_string.rlength = 0;
            break;
        
        case SUBST_ESCAPE:
            if( icur == m_subst.end() )
                throw bad_regexpr("expecting escape sequence in substitution string");
            assert( subst_node::SUBST_STRING == snode.stype );
            if( snode.subst_string.rlength )
                m_subst_list.push_back( snode );
            snode.subst_string.rstart = distance( m_subst.begin(), icur++ );
            snode.subst_string.rlength = 1;
            break;

        case NO_TOKEN:
        default:
            ++snode.subst_string.rlength;
            ++icur;
            break;
        }
    }
    assert( subst_node::SUBST_STRING == snode.stype );
    if( snode.subst_string.rlength )
        m_subst_list.push_back( snode );
}

template< typename CI, typename SY >
basic_rpattern<CI,SY>::charset_map basic_rpattern<CI,SY>::s_charset_map;

// Pass in an interator to one after the opening bracket of the character set.
// On return, icur points to one character after the closing bracket
template< typename CI, typename SY >
sub_expr<CI> * create_charset_helper<CI,SY>::create_charset_aux(
    basic_string<iterator_traits<CI>::value_type> & str,
    basic_string<iterator_traits<CI>::value_type>::iterator & icur,
    unsigned flags )
{
    bool fcomplement = false;
    match_charset<CI> * pnew = NULL;
    basic_string<iterator_traits<CI>::value_type>::iterator itemp = icur;

    if( itemp != str.end() && CHARSET_NEGATE == SY::charset_token( itemp, str.end() ) )
    {
        fcomplement = true;
        icur = itemp;
    }

    switch( ( NOCASE | CSTRINGS ) & flags )
    {
    case 0:
        pnew = new match_custom_charset_t<eos_t<CI>,match_range_with_case>( fcomplement, icur, str.end(), flags, SY() );
        break;
    case NOCASE:
        pnew = new match_custom_charset_t<eos_t<CI>,match_range_no_case>( fcomplement, icur, str.end(), flags, SY() );
        break;
    case CSTRINGS:
        pnew = new match_custom_charset_t<eocs_t<CI>,match_range_with_case>( fcomplement, icur, str.end(), flags, SY() );
        break;
    case NOCASE | CSTRINGS:
        pnew = new match_custom_charset_t<eocs_t<CI>,match_range_no_case>( fcomplement, icur, str.end(), flags, SY() );
        break;
    default:
        __assume(0); // tells the compiler that this is unreachable
    }

    return pnew;
}

#pragma warning( disable : 4660 )

// Explicit instantiation
#ifdef REGEX_FORCE_INSTANTIATION
 template class basic_regexpr<char>;
 template class basic_regexpr<wchar_t>;
#else
 template class basic_regexpr<TCHAR>;
#endif

#ifndef NO_PERL_RE
 #ifdef REGEX_FORCE_INSTANTIATION
  template class basic_rpattern<const char *>;
  template class basic_rpattern<const wchar_t *>;
  template class basic_rpattern<string::const_iterator>;
  template class basic_rpattern<wstring::const_iterator>;
 #else
  template class basic_rpattern<const TCHAR *>;
  template class basic_rpattern<tstring::const_iterator>;
 #endif
#endif

#ifdef POSIX_RE
 #ifdef REGEX_FORCE_INSTANTIATION
  template class basic_rpattern<const char *,posix_syntax<char> >;
  template class basic_rpattern<const wchar_t *,posix_syntax<wchar_t> >;
  template class basic_rpattern<string::const_iterator,posix_syntax<char> >;
  template class basic_rpattern<wstring::const_iterator,posix_syntax<wchar_t> >;
 #else
  template class basic_rpattern<const TCHAR *,posix_syntax<TCHAR> >;
  template class basic_rpattern<tstring::const_iterator,posix_syntax<TCHAR> >;
 #endif
#endif

} // namespace regex
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\genflt\syntax.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       syntax.cpp
//
//  Contents:   data definitions for the syntax modules
//
//  Classes:    
//
//  Functions:  
//
//  Coupling:   
//
//  Notes:      
//
//  History:    3-29-00   ericne   Created
//
//----------------------------------------------------------------------------

#include <memory.h>
#include "syntax.h"

namespace regex
{

// Initialize the perl syntax look-up tables
perl_syntax_base::init_perl_syntax::init_perl_syntax()
{
    memset( perl_syntax_base::s_rgreg, 0, sizeof( perl_syntax_base::s_rgreg ) );
    memset( perl_syntax_base::s_rgescape, 0, sizeof( perl_syntax_base::s_rgescape ) );

    // REGULAR TOKENS
    perl_syntax_base::s_rgreg[ (unsigned char)'(' ] = BEGIN_GROUP;
    perl_syntax_base::s_rgreg[ (unsigned char)')' ] = END_GROUP;
    perl_syntax_base::s_rgreg[ (unsigned char)'|' ] = ALTERNATION;
    perl_syntax_base::s_rgreg[ (unsigned char)'^' ] = BEGIN_LINE;
    perl_syntax_base::s_rgreg[ (unsigned char)'$' ] = END_LINE;
    perl_syntax_base::s_rgreg[ (unsigned char)'[' ] = BEGIN_CHARSET;
    perl_syntax_base::s_rgreg[ (unsigned char)'.' ] = MATCH_ANY;
    perl_syntax_base::s_rgreg[ (unsigned char)'\\' ] = ESCAPE;

    // ESCAPE TOKENS
    perl_syntax_base::s_rgescape[ (unsigned char)'d' ] = ESC_DIGIT;
    perl_syntax_base::s_rgescape[ (unsigned char)'D' ] = ESC_NOT_DIGIT;
    perl_syntax_base::s_rgescape[ (unsigned char)'s' ] = ESC_SPACE;
    perl_syntax_base::s_rgescape[ (unsigned char)'S' ] = ESC_NOT_SPACE;
    perl_syntax_base::s_rgescape[ (unsigned char)'w' ] = ESC_WORD;
    perl_syntax_base::s_rgescape[ (unsigned char)'W' ] = ESC_NOT_WORD;

    perl_syntax_base::s_rgescape[ (unsigned char)'A' ] = ESC_BEGIN_STRING;
    perl_syntax_base::s_rgescape[ (unsigned char)'Z' ] = ESC_END_STRING;
    perl_syntax_base::s_rgescape[ (unsigned char)'z' ] = ESC_END_STRING_z;
    perl_syntax_base::s_rgescape[ (unsigned char)'b' ] = ESC_WORD_BOUNDARY;
    perl_syntax_base::s_rgescape[ (unsigned char)'B' ] = ESC_NOT_WORD_BOUNDARY;
    perl_syntax_base::s_rgescape[ (unsigned char)'Q' ] = ESC_QUOTE_META_ON;
    perl_syntax_base::s_rgescape[ (unsigned char)'E' ] = ESC_QUOTE_META_OFF;
}
TOKEN perl_syntax_base::s_rgreg[ UCHAR_MAX + 1 ];
TOKEN perl_syntax_base::s_rgescape[ UCHAR_MAX + 1 ];
perl_syntax_base::init_perl_syntax perl_syntax_base::s_init_perl_syntax;

extern const posix_charset_type g_rgposix_charsets[] = 
{
    posix_charset_type("[:alnum:]",9),
    posix_charset_type("[:alpha:]",9),
    posix_charset_type("[:blank:]",9),
    posix_charset_type("[:cntrl:]",9),
    posix_charset_type("[:digit:]",9),
    posix_charset_type("[:graph:]",9),
    posix_charset_type("[:lower:]",9),
    posix_charset_type("[:print:]",9),
    posix_charset_type("[:punct:]",9),
    posix_charset_type("[:space:]",9),
    posix_charset_type("[:upper:]",9),
    posix_charset_type("[:xdigit:]",10)
};

extern const size_t g_cposix_charsets = ARRAYSIZE(g_rgposix_charsets);

} // namespace regex
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\genflt\rxlib.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       rxlib.cpp
//
//  Contents:   Regular expression library
//
//  History:    1-May-2001   kumarp  created
//
//  Notes:      all regex code taken from http://toolbox (owner ericne)
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop


#pragma warning( disable : 4018 )
#define assert(a)

#include "syntax.h"
#include "regexpr.h"



#include <syntax.cpp>
#include <regexpr.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\genflt\rxutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       rxutil.h
//
//  Contents:   Regular expression based helper functions
//
//  History:    1-May-2001   kumarp  created
//
//--------------------------------------------------------------------------


#ifndef _RXUTIL_H_
#define _RXUTIL_H_

 

EXTERN_C
BOOL
ParseLine(
    IN  PCWSTR szLine,
    OUT PUINT pMatchStart,
    OUT PUINT pMatchLength
    );

EXTERN_C
DWORD RxInit();

#endif // _RXUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\genflt\tsource.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1994.
//
//  File:       TSource.cxx
//
//  Contents:   TEXT_SOURCE implementation
//
//  Classes:    CTextSource
//
//  History:    14-Apr-94   KyleP       Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//+-------------------------------------------------------------------------
//
//  Member:     CTextSource::CTextSource, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [pFilter] -- IFilter (source of data)
//              [Stat]    -- Chunk statistics
//
//  History:    01-Aug-93 AmyA      Created
//              14-Apr-94 KyleP     Sync with wordbreaker spec
//
//--------------------------------------------------------------------------

CTextSource::CTextSource( IFilter * pFilter, STAT_CHUNK & Stat, CSourceMapper* pMapper )
        : _pMapper (pMapper),
          _pFilter(pFilter),
          _Stat( Stat ),
          _sc( S_OK )
{
#if 0

    CFullPropSpec & ps = *((CFullPropSpec *)&Stat.attribute);

    ciDebugOut(( DEB_WORDS,
                 "TEXT SOURCE: Initial chunk of "
                 "%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X\\",
                 ps.GetPropSet().Data1,
                 ps.GetPropSet().Data2,
                 ps.GetPropSet().Data3,
                 ps.GetPropSet().Data4[0], ps.GetPropSet().Data4[1],
                 ps.GetPropSet().Data4[2], ps.GetPropSet().Data4[3],
                 ps.GetPropSet().Data4[4], ps.GetPropSet().Data4[5],
                 ps.GetPropSet().Data4[6], ps.GetPropSet().Data4[7] ));

    if ( ps.IsPropertyName() )
        ciDebugOut(( DEB_WORDS | DEB_NOCOMPNAME,
                     "%ws\n", ps.GetPropertyName() ));
    else
        ciDebugOut(( DEB_WORDS | DEB_NOCOMPNAME,
                     "0x%x\n", ps.GetPropertyPropid() ));
#endif

    iEnd = 0;
    iCur = 0;
    awcBuffer = _awcFilterBuffer;
    pfnFillTextBuffer = CTextSource::FillBuf;

    if (_pMapper)
    {
        if (_Stat.idChunk == _Stat.idChunkSource)
        {
            _pMapper->NewChunk ( _Stat.idChunk, 0 );
        }
        else
        {
            _pMapper->NewDerivedChunk (
                _Stat.idChunkSource,
                _Stat.cwcStartSource,
                _Stat.cwcLenSource);
        }
    }

    FillBuf( this );
}



//+-------------------------------------------------------------------------
//
//  Member:     CTextSource::FillBuf, public
//
//  Synopsis:   Fills buffer with IFilter::GetText and IFilter::GetChunk
//
//  History:    01-Aug-93 AmyA      Created
//              20-Apr-94 KyleP     Sync with spec
//
//  Notes:      NOTE! In several places, this function casts const away
//              from awcBuffer.  This is an acceptable cast from const to
//              non-const. The buffer is const to the client but non-const
//              to the server.
//
//--------------------------------------------------------------------------

SCODE CTextSource::FillBuf( TEXT_SOURCE * pTextSource )
{
    CTextSource * pthis = (CTextSource *)pTextSource;

    //
    // Never continue past an error condition other than FILTER_E_NO_MORE_TEXT
    //

    if ( FAILED( pthis->_sc ) && pthis->_sc != FILTER_E_NO_MORE_TEXT )
        return( pthis->_sc );

    //
    // Move any existing text to beginning of buffer.
    //

    Win4Assert ( pthis->iEnd >= pthis->iCur );

    ULONG ccLeftOver = pthis->iEnd - pthis->iCur;

    if ( ccLeftOver > 0 )
    {
        RtlMoveMemory( (WCHAR *)pthis->awcBuffer,
                       &pthis->awcBuffer[pthis->iCur],
                       ccLeftOver * sizeof (WCHAR) );
    }

    if (pthis->_pMapper)
    {
        // this much has been processed from the current chunk
        pthis->_pMapper->Advance ( pthis->iCur );
    }

    pthis->iCur = 0;
    pthis->iEnd = ccLeftOver;
    ULONG ccRead = PAGE_SIZE / sizeof(WCHAR) - ccLeftOver;
    const BUFFER_SLOP = 10;  // Buffer is attempted to be filled until BUFFER_SLOP remains

    //
    // Get some more text.  If *previous* call to GetText returned
    // FILTER_S_LAST_TEXT, or FILTER_E_NO_MORE_TEXT then don't even
    // bother trying.
    //

    if ( pthis->_sc == FILTER_S_LAST_TEXT || pthis->_sc == FILTER_E_NO_MORE_TEXT )
        pthis->_sc = FILTER_E_NO_MORE_TEXT;
    else
    {
        pthis->_sc = pthis->_pFilter->GetText( &ccRead,
                                               (WCHAR *) &pthis->awcBuffer[ccLeftOver] );

        if ( SUCCEEDED( pthis->_sc ) )
        {
            pthis->iEnd += ccRead;
            ccLeftOver += ccRead;
            ccRead = PAGE_SIZE / sizeof(WCHAR) - ccLeftOver;

            while ( pthis->_sc == S_OK && ccRead > BUFFER_SLOP )
            {
               //
               // Attempt to fill in as much of buffer as possible before returning
               //
               pthis->_sc = pthis->_pFilter->GetText( &ccRead,
                                                     (WCHAR *) &pthis->awcBuffer[ccLeftOver] );
               if ( SUCCEEDED( pthis->_sc ) )
               {
                  pthis->iEnd += ccRead;
                  ccLeftOver += ccRead;
                  ccRead = PAGE_SIZE / sizeof(WCHAR) - ccLeftOver;
               }
            }

#if 0
            DebugPrintBuffer( pthis );
#endif
            //
            // Either return FILTER_S_LAST_TEXT or return S_OK because we have succeeded in
            // adding text to the buffer
            //
            if ( pthis->_sc == FILTER_S_LAST_TEXT )
                 return FILTER_S_LAST_TEXT;
            else
                 return S_OK;
        }

        if ( pthis->_sc != FILTER_E_NO_MORE_TEXT )
        {
            //
            // Weird failure, hence return, else goto next chunk
            //
            return pthis->_sc;
        }
    }

    //
    // Go to next chunk, if necessary.
    //

    while ( pthis->_sc == FILTER_E_NO_MORE_TEXT )
    {
        pthis->_sc = pthis->_pFilter->GetChunk( &pthis->_Stat );

        if ( pthis->_sc == FILTER_E_END_OF_CHUNKS )
            return WBREAK_E_END_OF_TEXT;

        if ( FAILED( pthis->_sc ) )
            return( pthis->_sc );

        if ( pthis->_Stat.flags & CHUNK_VALUE )
        {
            pthis->_sc = FILTER_E_NO_TEXT;
            return WBREAK_E_END_OF_TEXT;
        }

        if ( pthis->_Stat.breakType != CHUNK_NO_BREAK )
        {
            pthis->_sc = WBREAK_E_END_OF_TEXT;
            return WBREAK_E_END_OF_TEXT;
        }

#if 0
        ciDebugOut(( DEB_WORDS, "TEXT SOURCE: NoBreak chunk\n" ));
#endif

        if (pthis->_pMapper)
        {
            ULONG idChunk = pthis->_Stat.idChunk;
            if (idChunk == pthis->_Stat.idChunkSource)
            {
                pthis->_pMapper->NewChunk ( idChunk, ccLeftOver );
            }
            else
            {
                pthis->_sc = WBREAK_E_END_OF_TEXT;
                return WBREAK_E_END_OF_TEXT;
            }
        }

        ccRead = PAGE_SIZE / sizeof(WCHAR) - ccLeftOver;
        pthis->_sc = pthis->_pFilter->GetText( &ccRead,
                                               (WCHAR *) &pthis->awcBuffer[ccLeftOver] );

        if ( SUCCEEDED( pthis->_sc ) )
        {
            pthis->iEnd += ccRead;
            ccLeftOver += ccRead;
            ccRead = PAGE_SIZE / sizeof(WCHAR) - ccLeftOver;

            while ( pthis->_sc == S_OK && ccRead > BUFFER_SLOP )
            {
               //
               // Attempt to fill in as much of buffer as possible before returning
               //
               pthis->_sc = pthis->_pFilter->GetText( &ccRead,
                                                     (WCHAR *) &pthis->awcBuffer[ccLeftOver] );
               if ( SUCCEEDED( pthis->_sc ) )
               {
                  pthis->iEnd += ccRead;
                  ccLeftOver += ccRead;
                  ccRead = PAGE_SIZE / sizeof(WCHAR) - ccLeftOver;
               }
            }

#if 0
            DebugPrintBuffer( pthis );
#endif
            //
            // Either return FILTER_S_LAST_TEXT or return S_OK because we have succeeded in
            // adding text to the buffer
            //
            if ( pthis->_sc == FILTER_S_LAST_TEXT )
                 return FILTER_S_LAST_TEXT;
            else
                 return S_OK;
        }
    }

    if ( FAILED( pthis->_sc ) )
        return( pthis->_sc );

    if ( ccRead == 0 )
        return WBREAK_E_END_OF_TEXT;

    Win4Assert( pthis->iCur == 0 );
    Win4Assert( pthis->iEnd == ccLeftOver );

#if 0
    ciDebugOut(( DEB_WORDS, "TEXT SOURCE: Fill buffer with %d characters. %d left over\n",
                 pthis->iEnd, ccLeftOver ));
#endif

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CTextSource::DebugPrintBuffer
//
//  Synopsis:   Debug print the text buffer
//
//  Arguments:  [pThis] -- Pointer to text source
//
//  History:    08-Apr-97   SitaramR      Created
//
//--------------------------------------------------------------------------

void CTextSource::DebugPrintBuffer( CTextSource *pthis )
{
#if 0
   if ( ciInfoLevel & DEB_WORDS )
      {
          ciDebugOut(( DEB_WORDS, "CTextSource::FillBuf -- iCur = %u, iEnd = %u\n",
                       pthis->iCur, pthis->iEnd ));

          BOOL fOk = TRUE;
          for ( unsigned i = pthis->iCur; i < pthis->iEnd; i++ )
          {
              if ( pthis->awcBuffer[i] > 0xFF )
              {
                  fOk = FALSE;
                  break;
              }
          }

          if ( fOk )
          {
              unsigned j = 0;
              WCHAR awcTemp[71];

              for ( unsigned i = pthis->iCur; i < pthis->iEnd; i++ )
              {
                  awcTemp[j] = pthis->awcBuffer[i];
                  j++;

                  if ( j == sizeof(awcTemp)/sizeof(awcTemp[0]) - 1 )
                  {
                      awcTemp[j] = 0;
                      ciDebugOut(( DEB_WORDS, "%ws\n", awcTemp ));
                      j = 0;
                  }
              }

              awcTemp[j] = 0;
              ciDebugOut(( DEB_WORDS, "%ws\n", awcTemp ));
          }
          else
          {
              unsigned j = 0;

              for ( unsigned i = pthis->iCur; i < pthis->iEnd; i++ )
              {
                  if ( 0 == j )
                      ciDebugOut(( DEB_WORDS, "%04X", pthis->awcBuffer[i] ));
                  else if ( 14 == j )
                  {
                      ciDebugOut(( DEB_WORDS | DEB_NOCOMPNAME, " %04X\n", pthis->awcBuffer[i] ));
                  }
                  else
                      ciDebugOut(( DEB_WORDS | DEB_NOCOMPNAME, " %04X", pthis->awcBuffer[i] ));

                  j++;

                  if ( j > 14 )
                      j = 0;
              }

              ciDebugOut(( DEB_WORDS | DEB_NOCOMPNAME, "\n" ));
          }

      }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\idtopath\idtopath.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       idtopath.cxx
//
//  Contents:   Convert file ID to path name
//
//  History:    16 Jul 1997     DLee    Created
//
//--------------------------------------------------------------------------

extern "C"
{
    #include <nt.h>
    #include <ntioapi.h>
    #include <ntrtl.h>
    #include <nturtl.h>
}

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <process.h>
#include <fcntl.h>
#include <string.h>

void die( char * pc, NTSTATUS s )
{
    printf( "fail: 0x%x, '%s'\n", s, pc );
    exit( 1 );
} //die

void OpenById( HANDLE hVol, LONGLONG ll, WCHAR wcVol )
{
    UNICODE_STRING uScope;
    uScope.Buffer = (WCHAR *) &ll;
    uScope.Length = sizeof ll;
    uScope.MaximumLength = sizeof ll;

    OBJECT_ATTRIBUTES ObjectAttr;
    InitializeObjectAttributes( &ObjectAttr,          // Structure
                                &uScope,              // Name
                                OBJ_CASE_INSENSITIVE, // Attributes
                                hVol,                 // Root
                                0 );                  // Security

    IO_STATUS_BLOCK IoStatus;
    HANDLE h = INVALID_HANDLE_VALUE;
    NTSTATUS Status = NtOpenFile( &h,                
                                  FILE_READ_ATTRIBUTES,
                                  &ObjectAttr,       
                                  &IoStatus,         
                                  FILE_SHARE_READ |
                                      FILE_SHARE_WRITE |
                                      FILE_SHARE_DELETE,
                                  FILE_OPEN_BY_FILE_ID );

    if ( NT_ERROR( Status ) )
    {
        if ( STATUS_INVALID_PARAMETER == Status )
        {
            printf( "no file exists with fileid %#I64x on volume %wc\n", ll, wcVol );
            exit( 1 );
        }
        else
            die( "can't open file", Status );
    }

    unsigned cbMax = 32768 * sizeof WCHAR + sizeof FILE_NAME_INFORMATION;

    BYTE * pBuf = new BYTE[cbMax];
    if ( 0 == pBuf )
        return;

    PFILE_NAME_INFORMATION FileName = (PFILE_NAME_INFORMATION) pBuf;
    FileName->FileNameLength = cbMax - sizeof FILE_NAME_INFORMATION;

    Status = NtQueryInformationFile( h,
                                     &IoStatus,
                                     FileName, 
                                     cbMax,
                                     FileNameInformation );
                                            
    if ( NT_ERROR( Status ) )
       die( "can't get filename", Status );

    // This is actually the full path, not the filename

    FileName->FileName[ FileName->FileNameLength / sizeof WCHAR ] = 0;

    printf( "fileid %#I64x: '%wc:%ws'\n", ll, wcVol, FileName->FileName );

    delete [] pBuf;

    NtClose( h );
} //OpenById

void Usage()
{
    printf( "usage: idtopath /v:volume /i:fileid\n" );
    printf( "  e.g.: idtopath /v:c /i:2000000001a99\n" );
    exit( 1 );
} //Usage

extern "C" int __cdecl wmain( int argc, WCHAR * argv[] )
{
    WCHAR const *pwcId = 0;
    WCHAR wcVol = 0;

    for ( int i = 1; i < argc; i++ )
    {
        if ( L'-' == argv[i][0] || L'/' == argv[i][0] )
        {
            WCHAR wc = (WCHAR) toupper( argv[i][1] );

            if ( ':' != argv[i][2] )
                Usage();

            if ( 'V' == wc )
                wcVol = argv[i][3];
            else if ( 'I' == wc )
                pwcId = argv[i] + 3;
            else
                Usage();
        }
        else
            Usage();
    }

    if ( 0 == wcVol || 0 == pwcId )
        Usage();

    LONGLONG ll = 0;
    swscanf( pwcId, L"%I64x", &ll );

    WCHAR awcVol[20];
    wcscpy( awcVol, L"\\\\.\\k:" );
    awcVol[4] = wcVol;

    HANDLE h = CreateFileW( awcVol,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            0,
                            OPEN_EXISTING,
                            0, 0 );
                                  
    if ( INVALID_HANDLE_VALUE == h )
        die( "can't open volume", GetLastError() );

    OpenById( h, ll, wcVol );

    CloseHandle( h );
    return 0;
} //main
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\genflt\rxutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       rxutil.cpp
//
//  Contents:   Regular expression based helper functions
//
//  History:    1-May-2001   kumarp  created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#pragma warning( disable : 4018 )
#define assert(a)

#include "syntax.h"
#include "regexpr.h"


using namespace regex;

typedef std::vector< rpattern_c* > rpattern_c_ptr_vector;
typedef std::vector< UINT > uint_vector;

#define MAX_LINE_SIZE 512

rpattern_c_ptr_vector* g_pRegexPatterns = NULL;
uint_vector* g_uiGroupNumbers = NULL;

DWORD
InitRegexPatterns(
    IN  PCWSTR pszFileName,
    OUT rpattern_c_ptr_vector **ppRegexPatterns,
    OUT uint_vector **ppGroupNumbers
    )
{
    FILE *fp;
    WCHAR szLine[MAX_LINE_SIZE+1];
    UINT GroupNumber;
    UINT NumItemsScanned, NumCharsToSkip;
    UINT cPattern = 0;
    DWORD dwError = NO_ERROR;
    rpattern_c* pPattern;
    PCWSTR pszPattern;
    UINT uiLen;

    *ppRegexPatterns = new rpattern_c_ptr_vector;
    if ( !*ppRegexPatterns )
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    *ppGroupNumbers  = new uint_vector;
    if ( !*ppGroupNumbers )
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    
    fp = _wfopen( pszFileName, L"r" );

    if ( fp )
    {
        while( fgetws( szLine, MAX_LINE_SIZE, fp ) )
        {
            if ( szLine[0] == L';' )
            {
                // ignore comments
                continue;
            }

            uiLen = wcslen(szLine);

            //
            // get rid of the trailing \n in the line
            //
            szLine[uiLen-1] = 0;
            
            NumItemsScanned = swscanf( szLine, L"%d", &GroupNumber );
            if ( NumItemsScanned == 1 )
            {
                //
                // skip the leading number so that we know where the
                // pattern starts
                //
                NumCharsToSkip = wcsspn( szLine, L"0123456789 \t" );

                pszPattern = szLine + NumCharsToSkip;
                pPattern = new rpattern_c( pszPattern );
                //wprintf( L"%02d: %s\n", cPattern++, pszPattern );
                g_pRegexPatterns->push_back(pPattern);
                g_uiGroupNumbers->push_back( GroupNumber );
            }
            else
            {
                dwError = ERROR_INVALID_DATA;
                break;
            }
        }
    }
    else
    {
        dwError = ERROR_FILE_NOT_FOUND;
    }

 Cleanup:
    
    return dwError;
}

EXTERN_C
BOOL
ParseLine(
    IN  PCWSTR szLine,
    OUT PUINT pMatchStart,
    OUT PUINT pMatchLength
    )
{
    BOOL fResult = FALSE;
    regexpr::backref_vector_c backrefs;
    UINT g;
    regexpr::backref_type br;
    
    for (int i=0; i < g_pRegexPatterns->size(); i++)
    {
        //wprintf(L"trying %02d for '%s'\n", i, szLine);

        //wprintf(L"rp[%02d]: %s\n", i, sz);
        
        br = regexpr::match( szLine, *(*g_pRegexPatterns)[i], &backrefs );
        
        g = (*g_uiGroupNumbers)[i];
        
        if( br && backrefs[g] )
        {
            *pMatchStart  = backrefs[g].first - szLine;
            *pMatchLength = backrefs[g].second - backrefs[g].first;
            fResult = TRUE;
            break;
        }
    }
    
    return fResult;
}

#ifndef GENFLT_FILE_INIT
PCWSTR g_szPatterns[] =
{
    //  L"2 ^[ \t]*\\([ \t]*def(un|macro|subst|advice)[ \t]+([*+a-zA-Z0-9_-]+)[ \t]*\\(",
  L"2 ^[ \t]*\\([ \t]*def(un|macro|subst|advice)[ \t]+([^ \t\n;]+)[ \t]*\\(",
  //  L"2 ^[ \t]*\\([ \t]*def(var|custom|group|face|const|ine-skeleton|alias)[ \t]+([*+a-zA-Z0-9_-]+)",
  L"2 ^[ \t]*\\([ \t]*def(var|custom|group|face|const|ine-skeleton|alias)[ \t]+([^ \t\n;]+)",
  L"1 ^[ \t]*\\([ \t]*defalias[ \t]+'([^ \t\n;]+)",
#ifdef GENFLT_PERL_SUPPORT
    L"1 ^[ \t]*sub[ \t]+([a-zA-Z0-9_]+)[ \t]*",
    L"1 ^[ \t]*package[ \t]+([a-zA-Z0-9_]+)[ \t]*;",
#endif
//    L"2 ^[ \\t]*\\([ \\t]*def(un|macro|subst|advice)[ \\t]+([+a-zA-Z0-9_-]+)[ \\t]*\\(",
//    L"2 ^[ \\t]*\\([ \\t]*def(var|custom|group|face|const|ine-skeleton|alias)[ \\t]+([+a-zA-Z0-9_-]+)",
//  #ifdef GENFLT_PERL_SUPPORT
//      L"1 ^[ \\t]*sub[ \\t]+([a-zA-Z0-9_]+)[ \\t]*",
//      L"1 ^[ \\t]*package[ \\t]+([a-zA-Z0-9_]+)[ \\t]*;",
//  #endif
};

int c_cPatterns = sizeof(g_szPatterns) / sizeof(PCWSTR);

DWORD
InitRegexPatternsList(
    OUT rpattern_c_ptr_vector **ppRegexPatterns,
    OUT uint_vector **ppGroupNumbers
    )
{
    UINT GroupNumber;
    UINT NumItemsScanned, NumCharsToSkip;
    UINT cPattern = 0;
    DWORD dwError = NO_ERROR;
    rpattern_c* pPattern;
    PCWSTR pszPattern;
    UINT uiLen;
    PCWSTR pszPatternSpec = NULL;
    
    *ppRegexPatterns = new rpattern_c_ptr_vector;
    if ( !*ppRegexPatterns )
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    *ppGroupNumbers  = new uint_vector;
    if ( !*ppGroupNumbers )
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    for (int i=0; i < c_cPatterns; i++)
    {
        pszPatternSpec = g_szPatterns[i];
        
        uiLen = wcslen(pszPatternSpec);

        NumItemsScanned = swscanf( pszPatternSpec, L"%d", &GroupNumber );
        if ( NumItemsScanned == 1 )
        {
            //
            // skip the leading number so that we know where the
            // pattern starts
            //
            NumCharsToSkip = wcsspn( pszPatternSpec, L"0123456789 \t" );

            pszPattern = pszPatternSpec + NumCharsToSkip;
            pPattern = new rpattern_c( pszPattern );
#if DBG
            //DbgPrint( "InitRegexPatternsList: %02d: %ws\n", cPattern++, pszPattern );
#endif
            g_pRegexPatterns->push_back(pPattern);
            g_uiGroupNumbers->push_back( GroupNumber );
        }
        else
        {
            dwError = ERROR_INVALID_DATA;
            break;
        }
    }

 Cleanup:
    
    return dwError;
}
#endif // GENFLT_FILE_INIT

EXTERN_C
DWORD RxInit()
{
    static BOOL fRxInitialized = FALSE;
    DWORD dwError = NO_ERROR;

    if ( fRxInitialized )
    {
        return NO_ERROR;
    }

#ifdef GENFLT_FILE_INIT
    dwError = InitRegexPatterns(
                  L"c:\\rx.ini",
                  &g_pRegexPatterns,
                  &g_uiGroupNumbers );
#else
    dwError = InitRegexPatternsList(
                  &g_pRegexPatterns,
                  &g_uiGroupNumbers );
#endif
    
    if ( dwError == NO_ERROR )
    {
        fRxInitialized = TRUE;
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\genflt\syntax.h ===
//+---------------------------------------------------------------------------
//
//  File:       syntax.h
//
//  Contents:   syntax modules for regexpr
//
//  Classes:    perl_syntax, posix_syntax
//
//  History:    3-29-00   ericne   Created
//
//----------------------------------------------------------------------------

#pragma once
#pragma warning(push)
// warning C4511: copy constructor could not be generated
// warning C4512: assignment operator could not be generated
#pragma warning( disable : 4511 4512 )

#include <string>
#include <cwchar>
#include <iterator>

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof(*(x)))
#endif

#ifndef UCHAR_MAX
#define UCHAR_MAX 0xff
#endif

#ifndef WCHAR_MAX
#define WCHAR_MAX ((wchar_t)-1)
#endif

template<>
struct std::iterator_traits< const char * >
{	// get traits from iterator _Iter
	typedef random_access_iterator_tag iterator_category;
	typedef char value_type;
	typedef ptrdiff_t difference_type;
	typedef difference_type distance_type;	// retained
	typedef char * pointer;
	typedef char & reference;
};

template<>
struct std::iterator_traits< const wchar_t * >
{	// get traits from iterator _Iter
	typedef random_access_iterator_tag iterator_category;
	typedef wchar_t value_type;
	typedef ptrdiff_t difference_type;
	typedef difference_type distance_type;	// retained
	typedef wchar_t * pointer;
	typedef wchar_t & reference;
};

namespace regex
{

//
// The following are the tokens that can be emitted by the syntax module.
// Don't reorder this list!!!
//
enum TOKEN
{ 
    NO_TOKEN = 0,

    // REGULAR TOKENS
    BEGIN_GROUP,
    END_GROUP,
    ALTERNATION,
    BEGIN_LINE,
    END_LINE,
    BEGIN_CHARSET,
    MATCH_ANY,
    ESCAPE,

    // QUANTIFICATION TOKENS
    ONE_OR_MORE,
    ZERO_OR_MORE,
    ZERO_OR_ONE,
    ONE_OR_MORE_MIN,
    ZERO_OR_MORE_MIN,
    ZERO_OR_ONE_MIN,
    BEGIN_RANGE,
    RANGE_SEPARATOR,
    END_RANGE,
    END_RANGE_MIN,

    // ESCAPE SEQUENCES
    ESC_DIGIT,
    ESC_NOT_DIGIT,
    ESC_SPACE,
    ESC_NOT_SPACE,
    ESC_WORD,
    ESC_NOT_WORD,
    ESC_BEGIN_STRING,
    ESC_END_STRING,
    ESC_END_STRING_z,
    ESC_WORD_BOUNDARY,
    ESC_NOT_WORD_BOUNDARY,
    ESC_WORD_START,
    ESC_WORD_STOP,
    ESC_QUOTE_META_ON,
    ESC_QUOTE_META_OFF,

    // SUBSTITUTION TOKENS
    SUBST_BACKREF,
    SUBST_PREMATCH,
    SUBST_POSTMATCH,
    SUBST_MATCH,
    SUBST_ESCAPE,
    SUBST_QUOTE_META_ON,
    SUBST_UPPER_ON,
    SUBST_UPPER_NEXT,
    SUBST_LOWER_ON,
    SUBST_LOWER_NEXT,
    SUBST_ALL_OFF,

    // CHARSET TOKENS
    CHARSET_NEGATE,
    CHARSET_ESCAPE,
    CHARSET_RANGE,
    CHARSET_BACKSPACE,
    CHARSET_END,
    CHARSET_ALNUM,
    CHARSET_ALPHA,
    CHARSET_BLANK,
    CHARSET_CNTRL,
    CHARSET_DIGIT,
    CHARSET_GRAPH,
    CHARSET_LOWER,
    CHARSET_PRINT,
    CHARSET_PUNCT,
    CHARSET_SPACE,
    CHARSET_UPPER,
    CHARSET_XDIGIT,

    // EXTENSION TOKENS
    EXT_NOBACKREF,
    EXT_POS_LOOKAHEAD,
    EXT_NEG_LOOKAHEAD,
    EXT_POS_LOOKBEHIND,
    EXT_NEG_LOOKBEHIND,
    EXT_INDEPENDENT,
    EXT_UNKNOWN
};

struct posix_charset_type
{
    const char * const szcharset;
    const size_t       cchars;

    posix_charset_type( const char * const sz, const size_t c )
        : szcharset(sz), cchars(c) {}
};

extern const posix_charset_type g_rgposix_charsets[];
extern const size_t g_cposix_charsets;

template< typename const_iterator >
bool is_posix_charset( const_iterator icur, const_iterator iend, const char * szcharset )
{
    for( ; icur != iend && '\0' != *szcharset; ++icur, ++szcharset )
    {
        if( *icur != *szcharset )
            return false;
    }
    return '\0' == *szcharset;
}

//
// The perl_syntax class encapsulates the Perl 5 regular expression syntax. It is 
// used as a template parameter to basic_rpattern.  To customize regex syntax, create 
// your own syntax class and use it as a template parameter instead.
//

class perl_syntax_base
{
protected:
    static TOKEN s_rgreg[ UCHAR_MAX + 1 ];
    static TOKEN s_rgescape[ UCHAR_MAX + 1 ];

    struct init_perl_syntax;
    friend struct init_perl_syntax;
    static struct init_perl_syntax
    {
        init_perl_syntax();
    } s_init_perl_syntax;

    static inline TOKEN look_up( char ch, TOKEN rg[] ) { return rg[ (unsigned char)ch ]; }
    static inline TOKEN look_up( wchar_t ch, TOKEN rg[] ) { return UCHAR_MAX < ch ? NO_TOKEN : rg[ (unsigned char)ch ]; }
};

template< typename CH >
class perl_syntax : protected perl_syntax_base
{
public:
    typedef std::basic_string<CH>::iterator iterator;
    typedef std::basic_string<CH>::const_iterator const_iterator;
    typedef CH char_type;

private:
    static bool min_quant( iterator & icur, const_iterator iend )
    {
        return ( (const_iterator)++icur != iend && CH('?') == *icur ? (++icur,true) : false );
    }

public:
    static TOKEN reg_token( iterator & icur, const_iterator iend )
    { 
        assert( (const_iterator)icur != iend );
        TOKEN tok = look_up( *icur, s_rgreg );
        if( tok )
            ++icur;
        if( ESCAPE == tok && (const_iterator)icur != iend )
        {
            tok = look_up( *icur, s_rgescape );
            if( tok )
                ++icur;
            else
                tok = ESCAPE;
        }
        return tok;
    }
    static TOKEN quant_token( iterator & icur, const_iterator iend )
    {
        assert( (const_iterator)icur != iend );
        TOKEN tok = NO_TOKEN;
        switch( *icur )
        {
        case CH('*'):
            tok = min_quant( icur, iend ) ? ZERO_OR_MORE_MIN : ZERO_OR_MORE;
            break;
        case CH('+'):
            tok = min_quant( icur, iend ) ? ONE_OR_MORE_MIN : ONE_OR_MORE;
            break;
        case CH('?'):
            tok = min_quant( icur, iend ) ? ZERO_OR_ONE_MIN : ZERO_OR_ONE;
            break;
        case CH('}'):
            tok = min_quant( icur, iend ) ? END_RANGE_MIN : END_RANGE;
            break;
        case CH('{'):
            tok = BEGIN_RANGE;
            ++icur;
            break;
        case CH(','):
            tok = RANGE_SEPARATOR;
            ++icur;
            break;
        }
        return tok;
    }
    static TOKEN charset_token( iterator & icur, const_iterator iend )
    {
        assert( (const_iterator)icur != iend );
        TOKEN tok = NO_TOKEN;
        switch( *icur )
        {
        case CH('-'):
            tok = CHARSET_RANGE;
            ++icur;
            break;
        case CH('^'):
            tok = CHARSET_NEGATE;
            ++icur;
            break;
        case CH(']'):
            tok = CHARSET_END;
            ++icur;
            break;
        case CH('\\'):
            tok = CHARSET_ESCAPE;
            if( (const_iterator)++icur == iend )
                break;
            switch( *icur )
            {
			case CH('b'):
			    tok = CHARSET_BACKSPACE;
				++icur;
				break;
            case CH('d'):
                tok = ESC_DIGIT;
                ++icur;
                break;
            case CH('D'):
                tok = ESC_NOT_DIGIT;
                ++icur;
                break;
            case CH('s'):
                tok = ESC_SPACE;
                ++icur;
                break;
            case CH('S'):
                tok = ESC_NOT_SPACE;
                ++icur;
                break;
            case CH('w'):
                tok = ESC_WORD;
                ++icur;
                break;
            case CH('W'):
                tok = ESC_NOT_WORD;
                ++icur;
                break;
            }
            break;
        case CH('['):
            for( size_t i=0; !tok && i < g_cposix_charsets; ++i )
            {
                if( is_posix_charset<const_iterator>( icur, iend, g_rgposix_charsets[i].szcharset ) )
                {
                    tok = TOKEN(CHARSET_ALNUM + i);
                    std::advance( icur, g_rgposix_charsets[i].cchars );
                }
            }
            break;
        }
        return tok;
    }
    static TOKEN subst_token( iterator & icur, const_iterator iend )
    {
        assert( (const_iterator)icur != iend );
        TOKEN tok = NO_TOKEN;
        switch( *icur )
        {
        case CH('\\'):
            tok = SUBST_ESCAPE;
            if( (const_iterator)++icur != iend )
                switch( *icur )
                {
                case CH('Q'):
                    tok = SUBST_QUOTE_META_ON;
                    ++icur;
                    break;
                case CH('U'):
                    tok = SUBST_UPPER_ON;
                    ++icur;
                    break;
                case CH('u'):
                    tok = SUBST_UPPER_NEXT;
                    ++icur;
                    break;
                case CH('L'):
                    tok = SUBST_LOWER_ON;
                    ++icur;
                    break;
                case CH('l'):
                    tok = SUBST_LOWER_NEXT;
                    ++icur;
                    break;
                case CH('E'):
                    tok = SUBST_ALL_OFF;
                    ++icur;
                    break;
                }
            break;
        case CH('$'):
            tok = SUBST_BACKREF;
            if( (const_iterator)++icur != iend )
                switch( *icur )
                {
                case CH('&'):
                    tok = SUBST_MATCH;
                    ++icur;
                    break;
                case CH('`'):
                    tok = SUBST_PREMATCH;
                    ++icur;
                    break;
                case CH('\''):
                    tok = SUBST_POSTMATCH;
                    ++icur;
                    break;
                }
            break;
        }
        return tok;
    }
    static TOKEN ext_token( iterator & icur, const_iterator iend, unsigned & flags )
    {
        assert( (const_iterator)icur != iend );
        bool finclude;
        TOKEN tok = NO_TOKEN;
        if( CH('?') == *icur )
        {
            tok = EXT_UNKNOWN;
            if( (const_iterator)++icur != iend )
            {
                switch( *icur )
                {
                case CH(':'):
                    tok = EXT_NOBACKREF;
                    ++icur;
                    break;
                case CH('='):
                    tok = EXT_POS_LOOKAHEAD;
                    ++icur;
                    break;
                case CH('!'):
                    tok = EXT_NEG_LOOKAHEAD;
                    ++icur;
                    break;
                case CH('<'):
                    if( (const_iterator)++icur == iend )
                        break;
                    switch( *icur )
                    {
                    case CH('='):
                        tok = EXT_POS_LOOKBEHIND;
                        ++icur;
                        break;
                    case CH('!'):
                        tok = EXT_NEG_LOOKBEHIND;
                        ++icur;
                        break;
                    }
                    break;
                case CH('>'):
                    tok = EXT_INDEPENDENT;
                    ++icur;
                    break;
                default:
                    finclude = true;
                    do 
                    {
                        if( CH(':') == *icur )
                        {
                            tok = EXT_NOBACKREF;
                            ++icur;
                            break;
                        }
                        if( CH(')') == *icur )
                        {
                            tok = EXT_NOBACKREF;
                            break;
                        }
                        if( CH('-') == *icur && finclude )
                            finclude = false;
                        else if( CH('i') == *icur )
                            flags = finclude ? ( flags | NOCASE )     : ( flags & ~NOCASE );
                        else if( CH('m') == *icur )
                            flags = finclude ? ( flags | MULTILINE )  : ( flags & ~MULTILINE );
                        else if( CH('s') == *icur )
                            flags = finclude ? ( flags | SINGLELINE ) : ( flags & ~SINGLELINE );
                        else
                            break;
                    } while( (const_iterator)++icur != iend );
                    break;
                }
            }
        }
        return tok;
    }
};

//
// Implements the basic POSIX regular expression syntax
//
template< typename CH >
class posix_syntax
{
public:
    typedef std::basic_string<CH>::iterator iterator;
    typedef std::basic_string<CH>::const_iterator const_iterator;
    typedef CH char_type;

    static TOKEN reg_token( iterator & icur, const_iterator iend )
    {
        TOKEN tok = NO_TOKEN;
        switch( *icur )
        {
        case '.':
            tok = MATCH_ANY;
            ++icur;
            break;
        case '^':
            tok = BEGIN_LINE;
            ++icur;
            break;
        case '$':
            tok = END_LINE;
            ++icur;
            break;
        case '[':
            tok = BEGIN_CHARSET;
            ++icur;
            break;
        case '\\':
            tok = ESCAPE;
            ++icur;
            if( (const_iterator)icur != iend )
            {
                switch( *icur )
                {
                case '(':
                    tok = BEGIN_GROUP;
                    ++icur;
                    break;
                case ')':
                    tok = END_GROUP;
                    ++icur;
                    break;
                case '|':
                    tok = ALTERNATION;
                    ++icur;
                    break;
                }
            }
            break;
        }
        return tok;
    }
    static TOKEN quant_token( iterator & icur, const_iterator iend )
    {
        TOKEN tok = NO_TOKEN;
        switch( *icur )
        {
        case '*':
            tok = ZERO_OR_MORE;
            ++icur;
            break;
        case ',':
            tok = RANGE_SEPARATOR;
            ++icur;
            break;
        case '\\':
            ++icur;
            if( (const_iterator)icur != iend )
            {
                switch( *icur )
                {
                case '?':
                    tok = ZERO_OR_ONE;
                    ++icur;
                    break;
                case '+':
                    tok = ONE_OR_MORE;
                    ++icur;
                    break;
                case '{':
                    tok = BEGIN_RANGE;
                    ++icur;
                    break;
                case '}':
                    tok = END_RANGE;
                    ++icur;
                    break;
                default:
                    --icur;
                    break;
                }
            }
            else
            {
                --icur;
            }
        }
        return tok;
    }
    static TOKEN charset_token( iterator & icur, const_iterator iend )
    {
        TOKEN tok = NO_TOKEN;
        switch( *icur )
        {
        case '^':
            tok = CHARSET_NEGATE;
            ++icur;
            break;
        case '-':
            tok = CHARSET_RANGE;
            ++icur;
            break;
        case ']':
            tok = CHARSET_END;
            ++icur;
            break;
        case '[':
            for( size_t i=0; !tok && i < g_cposix_charsets; ++i )
            {
                if( is_posix_charset<const_iterator>( icur, iend, g_rgposix_charsets[i].szcharset ) )
                {
                    tok = TOKEN(CHARSET_ALNUM + i);
                    std::advance( icur, g_rgposix_charsets[i].cchars );
                }
            }
            break;
        }
        return tok;
    }
    static TOKEN subst_token( iterator & icur, const_iterator iend )
    {
        TOKEN tok = NO_TOKEN;
        if( '\\' == *icur )
        {
            tok = SUBST_ESCAPE;
            ++icur;
            if( (const_iterator)icur != iend && '0' <= *icur && '9' >= *icur )
            {
                tok = SUBST_BACKREF;
            }
        }
        return tok;
    }
    static TOKEN ext_token( iterator &, const_iterator, unsigned & )
    {
        return NO_TOKEN;
    }
};

} // namespace regex
#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\ifilttst\filtpars.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       filtpars.cxx
//
//  Contents:   Definitions of the CFiltParse methods
//
//  Classes:
//
//  Functions:  CFiltParse, ~CFiltParse, Init, GetNextConfig,
//              ParseFlags, GetAttributes
//
//  Coupling:
//
//  Notes:
//
//  History:    9-21-1996   ericne   Created
//
//----------------------------------------------------------------------------


#include "pch.cxx"
#include <ctype.h>
#include "utility.hxx"
#include "mydebug.hxx"
#include "filtpars.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CFiltParse::CFiltParse
//
//  Synopsis:   Constructor.  Default initialization
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    9-21-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CFiltParse::CFiltParse( )
: m_pNextListNode( NULL )
{
    // Zero all the fields of m_FirstListNode (this makes the "next" field 0)
    memset( (void*) &m_FirstListNode, (int)0, sizeof( ListNode ) );

} //CFiltParse::CFiltParse

//+---------------------------------------------------------------------------
//
//  Member:     CFiltParse::~CFiltParse
//
//  Synopsis:   Destructor.  Cleans up the heap
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    9-21-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CFiltParse::~CFiltParse( )
{

    ListNode *pCurrentNode = m_FirstListNode.next;
    ListNode *pTempNode = NULL;
    ULONG    ul = 0;

    while( NULL != pCurrentNode )
    {
        pTempNode = pCurrentNode;
        pCurrentNode = pCurrentNode->next;
        // If there are any attributes, delete any lpwstr's
        for( ul=0; ul < pTempNode->Configuration.ulActNbrAttributes; ul++ )
        {
            if( PRSPEC_LPWSTR ==
                pTempNode->Configuration.aAttributes[ ul ].psProperty.ulKind )
            {
                delete [] pTempNode->Configuration.aAttributes[ ul ].
                                                   psProperty.lpwstr;
            }
        }
        if( pTempNode->Configuration.aAttributes )
            delete [] pTempNode->Configuration.aAttributes;
        delete pTempNode->Configuration.pdwFlags;
        delete [] pTempNode->Configuration.szSectionName;
        delete pTempNode;
    }

} //CFiltParse::~CFiltParse

//+---------------------------------------------------------------------------
//
//  Member:     CFiltParse::Init
//
//  Synopsis:   Parses the contents of the .ini file
//
//  Arguments:  [pcFileName] -- name of data file
//
//  Returns:    TRUE if file was parsed successfully, FALSE otherwise
//
//  History:    9-22-1996   ericne   Created
//
//  Notes:      The full path to the *.ini file must be specified
//
//----------------------------------------------------------------------------

BOOL CFiltParse::Init( LPCTSTR szFileName )
{
    int          iFlags = 0;
    int          iSectionIndex = 0;
    TCHAR        szFlags[ MAX_LINE_SIZE ];
    TCHAR        szSectionNames[ MAX_SECTION_NAMES_SIZE ];
    UINT         uiAttributeCount = 0;
    DWORD        dwNbrChars = 0;
    DWORD        dwFileAttributes = 0;
    ULONG        ulNbrAttributes = 0;
    ListNode     *pNewNode = NULL;
    ListNode     *pLastListNode = &m_FirstListNode;
    FULLPROPSPEC *pAttributes = NULL;

    // Check to see if the ini file exists:
    dwFileAttributes = GetFileAttributes( szFileName );

    // If the file doesn't exist, create a default configuration
    if( 0xFFFFFFFF == dwFileAttributes )
    {
        _tprintf( _T("WARNING: Initialization file %s not found.  Using a")
                  _T(" default configuration.\r\n"), szFileName );

        pNewNode = new ListNode;

        pNewNode->Configuration.grfFlags = IFILTER_INIT_APPLY_INDEX_ATTRIBUTES;
        pNewNode->Configuration.cAttributes = 0;
        pNewNode->Configuration.aAttributes = NULL;
        pNewNode->Configuration.pdwFlags = new DWORD(0);
        pNewNode->Configuration.ulActNbrAttributes = 0;
        pNewNode->Configuration.szSectionName =
            new TCHAR[ _tcslen( szDefaultSectionName ) + 1 ];
        _tcscpy( pNewNode->Configuration.szSectionName, szDefaultSectionName );

        pNewNode->next = NULL;

        m_pNextListNode = m_FirstListNode.next = pNewNode;

        return( TRUE );

    }

    // Get the Section names from the *.ini file
    dwNbrChars = GetPrivateProfileString( NULL,
                                           NULL,
                                           _T(""),
                                           szSectionNames,
                                           MAX_SECTION_NAMES_SIZE,
                                           szFileName );

    // Make sure we got some section names
    if( 0 == dwNbrChars )
    {
        _tprintf( _T("Parsing error: no sections found in %s\r\n"),
                  szFileName );
        return( FALSE );
    }

    // Make sure we didn't fill the buffer
    if( MAX_SECTION_NAMES_SIZE - 2 == dwNbrChars )
    {
        _tprintf( _T("Parsing error: too many section names were found in ")
                  _T("%s\r\n"), szFileName );
        return( FALSE );
    }

    while( szSectionNames[ iSectionIndex ] )
    {

        dwNbrChars =
            GetPrivateProfileString( &szSectionNames[ iSectionIndex ],
                                      _T("Flags"),
                                      _T(""),
                                      szFlags,
                                      MAX_LINE_SIZE,
                                      szFileName );

        // Parse the flags
        if( ! ParseFlags( szFlags, &iFlags ) )
            return( FALSE );

        // Get the number of attributes
        uiAttributeCount =
            GetPrivateProfileInt( &szSectionNames[ iSectionIndex ],
                                   _T("cAttributes"),
                                   0,
                                   szFileName );

        // Get the attributes listed in this section
        if( ! GetAttributes( &szSectionNames[ iSectionIndex ],
                             szFileName,
                             pAttributes,
                             ulNbrAttributes ) )
        {
            return( FALSE );
        }

        // Create a new ListNode
        pNewNode = new ListNode;

        // Fill in the Configuration information
        pNewNode->Configuration.grfFlags = iFlags;
        pNewNode->Configuration.cAttributes = uiAttributeCount;
        pNewNode->Configuration.aAttributes = pAttributes;
        pNewNode->Configuration.ulActNbrAttributes = ulNbrAttributes;

        // Create a new dword for the pdwFlags
        pNewNode->Configuration.pdwFlags = new DWORD( 0 );

        // Save the secion name in the CONFIG structure
        pNewNode->Configuration.szSectionName =
            new TCHAR[ _tcslen( &szSectionNames[ iSectionIndex ] ) + 1 ];

        _tcscpy( pNewNode->Configuration.szSectionName,
                &szSectionNames[ iSectionIndex ] );

        // Put the node at the end of the list
        pLastListNode->next = pNewNode;
        pLastListNode = pNewNode;
        pNewNode->next = NULL;

        // Increment the section index past the current section name
        while( szSectionNames[ iSectionIndex++ ] )
        {
            ( (void)0 ); // No work needs to be done here
        }

    }

    // Initialize the next node pointer
    m_pNextListNode = m_FirstListNode.next;

    // Successfully parsed the file:
    return( TRUE );

} //CFiltParse::Init

//+---------------------------------------------------------------------------
//
//  Member:     CFiltParse::GetNextConfig
//
//  Synopsis:   extracts the next configuration from the list
//
//  Arguments:  [pConfiguration] -- pointer to the configuration structure
//
//  Returns:    TRUE if successful, FALSE if there are no more configurations
//
//  History:    9-22-1996   ericne   Created
//
//  Notes:      This function performs a bit-wise copy of the config structure
//              which contains pointers.  This is intentional.  All pointers
//              to dynamically allocated memory are stored in the linked list
//              and are cleaned up in the destructor.  The client is not
//              responsible for deleting the memory, and shouldn't.
//
//----------------------------------------------------------------------------

BOOL CFiltParse::GetNextConfig( CONFIG *pConfiguration )
{
    // If we are at the end of the list, return.
    if( NULL == m_pNextListNode )
        return( FALSE );

    // Bit-wise copy the CONFIG structure, pointers included.
    memcpy( (void*) pConfiguration,
            (void*) &(m_pNextListNode->Configuration),
            sizeof( CONFIG ) );

    // Advance the current node pointer
    m_pNextListNode = m_pNextListNode->next;

    return( TRUE );

} //CFiltParse::GetNextConfig

//+---------------------------------------------------------------------------
//
//  Member:     CFiltParse::ParseFlags
//
//  Synopsis:   Makes extensive use of streams to extract individual tokens
//              from a single line of the data file.  The tokens should
//              correspont to IFilter Init flags.  Their values are bit-wise
//              ORed together and stored in m_Flags
//
//  Arguments:  (none)
//
//  Returns:    TRUE if successful
//              FALSE if an error occurs
//
//  History:    9-22-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CFiltParse::ParseFlags( LPTSTR szFlags, int * piFlags )
{
    BOOL        fIsLegalToken = FALSE;
    LPCTSTR     szTokenBuffer = _tcstok( szFlags, _T(" \t") );

    // initialize *piFlags
    *piFlags = 0;

    // While there are more tokens in szFlags:
    while( NULL != szTokenBuffer )
    {
        // Assume the token is not legal
        fIsLegalToken = FALSE;

        // Try to find a match for this token
        for( int iCount = 0; iCount < 8; iCount++ )
        {
            if( 0 == _tcsicmp( szTokenBuffer, strInitFlags[ iCount ] ) )
            {
                // Bitwise-or of *piFlags with 1 left-shifted by iCount
                *piFlags |= ( 1 << iCount );
                fIsLegalToken = TRUE;
                break;
            }
        }

        // If no match was found
        if( ! fIsLegalToken )
        {
            _tprintf( _T("Parsing error: Illegal Init flag: %s\r\n"),
                      szTokenBuffer );
            return( FALSE );
        }

        // Get the next token
        szTokenBuffer = _tcstok( NULL, _T(" \t") );

    }

    return( TRUE );

} //CFiltParse::GetFlags

//+---------------------------------------------------------------------------
//
//  Member:     CFiltParse::GetAttributes
//
//  Synopsis:   Gets the correct number of attributes from the data file
//
//  Arguments:  (none)
//
//  Returns:    TRUE if successful,
//              FALSE if an error occurs or the end of file is reached
//
//  History:    9-22-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CFiltParse::GetAttributes( const TCHAR *szSectionName,
                                const TCHAR *szFileName,
                                FULLPROPSPEC *&pFullPropspec,
                                ULONG &ulNbrAttributes )
{
    TCHAR   szAttributeString[ MAX_LINE_SIZE ];
    LPTSTR  szGuidBuffer = NULL;
    LPTSTR  szPropspecBuffer = NULL;
    LPTSTR  szTestBuffer = NULL;
    TCHAR   szKeyNames[ MAX_KEY_NAMES_SIZE ];
    UINT    uiKeyIndex = 0;
    UINT    uiAttributeIndex = 0;
    BOOL    fSuccessful = FALSE;
    DWORD   dwNbrChars = 0;

    // Initialize m_Attributes field
    pFullPropspec = NULL;
    ulNbrAttributes = 0;

    // Enumerate all the Key names in this section:
    dwNbrChars = GetPrivateProfileString( szSectionName,
                                           NULL,
                                           _T(""),
                                           szKeyNames,
                                           MAX_KEY_NAMES_SIZE,
                                           szFileName );

    // Make sure we had enough room:
    if( MAX_KEY_NAMES_SIZE - 2 == dwNbrChars )
    {
        _tprintf( _T("Parse error: too many keys found in section %s ")
                  _T("in file %s\r\n"), szSectionName, szFileName );
        return( FALSE );
    }

    // Find out how many attributes are specified:
    while( szKeyNames[ uiKeyIndex ] )
    {
        if( &szKeyNames[ uiKeyIndex ] ==
            _tcsstr( &szKeyNames[ uiKeyIndex ], _T("aAttributes") ) )
        {
            ++ulNbrAttributes;
        }
        while( szKeyNames[ uiKeyIndex++ ] )
        {
            ( (void)0 );
        }
    }

    // If no attributes are specified, return TRUE (we're done)
    if( 0 == ulNbrAttributes )
        return( TRUE );

    // Allocate the correct number of attributes
    pFullPropspec = new FULLPROPSPEC[ ulNbrAttributes ];

    // Reset the Key index
    uiKeyIndex = 0;

    // try-finally block simplifies clean-up
    __try
    {

        // Loop over all the key names:
        // The (dis)advantage of this approach is that it allows a user to
        // specify a number of attributes in cAttributes, but then allocate a
        // different number of attributes, to see how the filter handles this

        while( szKeyNames[ uiKeyIndex ] )
        {
            // Assert that I don't overwrite the Attribute array
            // (Debug version only)
            _ASSERT( uiAttributeIndex < ulNbrAttributes );

            // If this key is not specifying an attribute, continue
            if( &szKeyNames[ uiKeyIndex ] !=
                _tcsstr( &szKeyNames[ uiKeyIndex ], _T("aAttributes") ) )
            {
                while( szKeyNames[ uiKeyIndex++ ] )
                {
                    ( (void)0 );
                }
                continue;
            }

            // Get the attribute string
            dwNbrChars = GetPrivateProfileString( szSectionName,
                                                   &szKeyNames[ uiKeyIndex ],
                                                   _T(""),
                                                   szAttributeString,
                                                   MAX_LINE_SIZE,
                                                   szFileName );

            // Pull out the guid token:
            if( NULL ==
                ( szGuidBuffer = _tcstok( szAttributeString, _T(" \t") ) ) )
            {
                _tprintf( _T("Parsing error: Expecting guid.\r\n") );
                __leave;
            }

            // Pull out the Propid
            if( NULL == ( szPropspecBuffer = _tcstok( NULL, _T(" \t") ) ) )
            {
                _tprintf( _T("Parsing error: Expecting propspec.\r\n") );
                __leave;
            }

            // Make sure the string stream is empty now
            if( NULL != ( szTestBuffer = _tcstok( NULL, _T(" \t") ) ) )
            {
                _tprintf( _T("Parsing error: %s was unexpected at this")
                          _T(" time.\r\n"), szTestBuffer );
                __leave;
            }

            // Convert the guid string to a guid
            if( ! StrToGuid( szGuidBuffer,
                             &pFullPropspec[ uiAttributeIndex ].guidPropSet ) )
            {
                _tprintf( _T("Parsing error: could not convert %s to")
                          _T(" a GUID\r\n"), szGuidBuffer );
                __leave;
            }

            if( ! StrToPropspec( szPropspecBuffer,
                               &pFullPropspec[ uiAttributeIndex ].psProperty ) )
            {
                _tprintf( _T("Parsing error: could not convert %s to a")
                          _T(" PROPSPEC\r\n"), szPropspecBuffer );
                __leave;
            }

            // Advanve the Attribute index
            ++uiAttributeIndex;

            // Advance uiKeyIndex
            while( szKeyNames[ uiKeyIndex++ ] )
            {
                ( (void)0 );
            }

        }

        // Assert that I copied exactly the correct number of attributes
        // (Debug version only)
        _ASSERT( uiAttributeIndex == ulNbrAttributes );

        // Set the success flag
        fSuccessful = TRUE;

    }

    __finally
    {
        // If not successful, clean the heap and reset return values
        if( ! fSuccessful )
        {
            if( pFullPropspec )
            {
                delete [] pFullPropspec;
                pFullPropspec = NULL;
            }
            ulNbrAttributes = 0;
        }

    }

    return fSuccessful;

} //CFiltParse::GetAttributes
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\ifilttst\clog.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       mylog.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  Coupling:
//
//  Notes:
//
//  History:    10-15-1996   ericne   Created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#include <time.h>
#include "clog.hxx"
#include "mydebug.hxx"

// These functions are the same regardless of whether NO_NTLOG is defined or not
//+---------------------------------------------------------------------------
//
//  Member:     CLog::Log
//
//  Synopsis:   Log a message.  This function creates a va_list object and calls
//              the appropriate method to send the message to the log file
//
//  Arguments:  [dwStyle]      -- Style of this message
//              [szFileName] -- Name of source file containing this call
//              [iLine]        -- Line number of this method call
//              [szFormat]   -- Format string of message
//              [ ... ]        -- Variable argument list
//
//  Returns:    TRUE if successful, FALSE otherwise
//
//  History:    10-17-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CLog::Log( DWORD dwStyle,          // Flags to be applied to this message
                LPTSTR szFileName,    // Name of file containing function call
                int iLine,              // Line number of function call
                LPCTSTR szFormat,     // Format of the message
                ... )                   // other arguments
{
    BOOL    fRetVal = FALSE;
    va_list va;

    __try
    {
        va_start( va, szFormat );

        fRetVal = vLog( dwStyle, szFileName, iLine, szFormat, va );
    }
    __finally
    {
        va_end( va );
    }

    return( fRetVal );

} //CLog::Log

void CLog::Disable()
{
    m_fEnabled = FALSE;
}

void CLog::Enable()
{
    m_fEnabled = TRUE;
}

void CLog::SetThreshold( DWORD dwThreshold )
{
    m_dwThreshold = dwThreshold;
}


//
// If NO_NTLOG is defined ...
//

#ifdef NO_NTLOG

#include "memsnap.hxx"

// Don't re-order this list!
LPCTSTR szMessageLevel[ cMessageLevels ] = { _T("ABORT"),
                                               _T("SEV1"),
                                               _T("SEV2"),
                                               _T("SEV3"),
                                               _T("WARN"),
                                               _T("PASS"),
                                               _T("CALLTREE"),
                                               _T("SYSTEM"),
                                               _T("TEST"),
                                               _T("VARIATION"),
                                               _T("BLOCK"),
                                               _T("BREAK"),
                                               _T("TESTDEBUG"),
                                               _T("INFO"),
                                               _T(""),
                                               _T("") };

//+---------------------------------------------------------------------------
//
//  Member:     ::CLog
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-16-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CLog::CLog( )
:   m_pLogFile( NULL ),
    m_dwLogStyle( 0 ),
    m_fEnabled( TRUE ),
    m_dwThreshold( dwThresholdMask )
{
    InitializeCriticalSection( &m_CriticalSection );

    for( int iLoop = 0; iLoop < cMessageLevels; iLoop++ )
        m_ulNbrMessages[ iLoop ] = ( ULONG ) 0;

} //::CLog

//+---------------------------------------------------------------------------
//
//  Member:     ::~CLog
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-16-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CLog::~CLog( )
{
    struct tm *newtime;
    time_t aclock;

    if( m_fEnabled && NULL != m_pLogFile )
    {
        // Put a blank line between the stats and the memory snapshot
        _ftprintf( m_pLogFile, _T("\n****\n") );

        // Display a snapshot of the memory
        memsnap( m_pLogFile );

        // Get time in seconds
        time( &aclock );

        // Convert time to struct
        newtime = localtime( &aclock );

        // Display the time of completion
        _ftprintf( m_pLogFile, _T("\n**** LOG TERMINATED  %s\n"),
                   _tasctime( newtime ) );
    }

    // Close the file stream
    if( NULL != m_pLogFile && stdout != m_pLogFile )
        fclose( m_pLogFile );

    m_pLogFile = NULL;

    // Delete the critical section
    DeleteCriticalSection( &m_CriticalSection );

} //::~CLog

//+---------------------------------------------------------------------------
//
//  Member:     ::InitLog
//
//  Synopsis:
//
//  Arguments:  [szFileName] --
//              [dwStyle]      --
//
//  Returns:
//
//  History:    10-16-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CLog::InitLog( LPCTSTR szFileName, DWORD dwStyle )
{
    LPCTSTR szMode = _T("w");
    struct  tm *newtime;
    time_t  aclock;

    // If the log has been initialized already, don't reinitialize it
    if( NULL != m_pLogFile )
        return( FALSE );

    m_dwLogStyle = dwStyle;

    // If the file name is null, send output to stdout
    if( NULL == szFileName )
        m_pLogFile = stdout;
    else
        m_pLogFile = _tfopen( szFileName, szMode );

    // If the log file failed to open, return FALSE
    if( NULL == m_pLogFile )
    {
        _RPT1( _CRT_WARN, "CLog::InitLog - Unable to open log file %s\n",
               ( szFileName ? szFileName : _T("<standard output") ) );
        return( FALSE );
    }

    // Get time in seconds
    time( &aclock );

    // Convert time to struct
    newtime = localtime( &aclock );

    // Display a rudimentary header
    _ftprintf( m_pLogFile, _T("**** LOG INITIATED : %s"),
               _tasctime( newtime ) );

    _ftprintf( m_pLogFile, _T("**** LAST COMPILED : %s %s\n"),
               _T(__DATE__), _T(__TIME__) );

    _ftprintf( m_pLogFile, _T("**** COMMAND LINE  : %s\n"),
               GetCommandLine( ) );

    _ftprintf( m_pLogFile, _T("\n") );

    // Display a snapshot of the memory
    memsnap( m_pLogFile );

    // Print a blank line
    _ftprintf( m_pLogFile, _T("\n****\n") );

    return( TRUE );
} //::InitLog

//+---------------------------------------------------------------------------
//
//  Member:     CLog::AddParticipant
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-05-1997   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CLog::AddParticipant()
{
    if( NULL == m_pLogFile )
        return( FALSE );

    return( TRUE );
} //CLog::AddParticipant

//+---------------------------------------------------------------------------
//
//  Member:     CLog::RemoveParticipant
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-05-1997   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CLog::RemoveParticipant()
{
    if( NULL == m_pLogFile )
        return( FALSE );

    return( TRUE );

} //CLog::RemoveParticipant

//+---------------------------------------------------------------------------
//
//  Member:     ::Log
//
//  Synopsis:
//
//  Arguments:  [dwStyle]    --
//              [szFile]   --
//              [iLine]      --
//              [szFormat] --
//
//  Returns:
//
//  History:    10-16-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CLog::vLog( DWORD dwStyle,          // Flags to be applied to this message
                 LPTSTR szFileName,    // Name of file containing function call
                 int iLine,              // Line number of function call
                 LPCTSTR szFormat,     // Format of the message to be logged
                 va_list va )            // other arguments
{
    int     iLoop = 0;                  // Loop counter
    BOOL    fIsLegalTestType = FALSE;   // Flag to determine output style
    DWORD   dwBitMask = 1L;             // Used to isolate flags in dwStyle
    TCHAR   szMessage[ MaxLogLineLength ];    // Formatted message
    BOOL    fSuccessful = TRUE;         // Return value

    // If the log has been disabled, return
    if( ! m_fEnabled )
        return( TRUE );

    // If the log has not been initialized, return FALSE
    if( NULL == m_pLogFile )
        return( FALSE );

    // If the style exceeds the threshold, don't log this message
    if( m_dwThreshold < ( dwStyle & dwThresholdMask ) )
        return( TRUE );

    // Try-finally block ensures that the critical section will be released
    __try
    {
        // Acquire critical section
        EnterCriticalSection( &m_CriticalSection );

        // If dwStyle is TLS_BREAK, call DebugBreak
        if( dwStyle & TLS_BREAK )
            DebugBreak( );

        // If the current dwStyle does not have a displayable type, return
        if( ! ( dwStyle & m_dwLogStyle & dwMessageTypesMask ) )
            __leave;

        if( -1 == _vsntprintf( szMessage, MaxLogLineLength, szFormat, va ) )
        {
            // BUGBUG The actual message length excees the maximum length per
            // line.  Just display MaxLogLineLength characters.
        }

        // Display the current thread id
        if( 0 > _ftprintf( m_pLogFile, _T("%d.%d : "),
                           GetCurrentProcessId(), GetCurrentThreadId() ) )
        {
            fSuccessful = FALSE;
            __leave;
        }

        // Display the test types that should be applied to this message
        // (TEST, VARIATION,...)
        for( iLoop = 0, dwBitMask = 1L;
             iLoop < cMessageLevels;
             iLoop++, dwBitMask <<= 1L )
        {
            // Display the type of test this is
            if( dwStyle & m_dwLogStyle & dwTestTypesMask & dwBitMask )
            {
                if( 0 > _ftprintf( m_pLogFile, _T("+%s"),
                                   szMessageLevel[ iLoop ] ) )
                {
                    fSuccessful = FALSE;
                    __leave;
                }
                ++m_ulNbrMessages[ iLoop ];
                fIsLegalTestType = TRUE;
                break;
            }
        }

        // If this is an illegal test type, display the Filename and Line number
        if( ! fIsLegalTestType )
        {
            if( 0 > _ftprintf( m_pLogFile, _T("+FILE : %s +LINE : %d"),
                       szFileName, iLine ) )
            {
                fSuccessful = FALSE;
                __leave;
            }
        }

        // Display the type of this message (PASS, SEV1, etc..)
        for( iLoop = 0, dwBitMask = 1L;
             iLoop < cMessageLevels && fIsLegalTestType;
             iLoop++, dwBitMask <<= 1L )
        {
            // Display the type of message this is
            if( dwStyle & m_dwLogStyle & dwMessageTypesMask & dwBitMask )
            {
                if( 0 > _ftprintf( m_pLogFile, _T("+%s"),
                                   szMessageLevel[ iLoop ] ) )
                {
                    fSuccessful = FALSE;
                    __leave;
                }
                ++m_ulNbrMessages[ iLoop ];
                break;
            }
        }

        if( 0 > _ftprintf( m_pLogFile, _T(" \t%s\n"), szMessage ) )
        {
            fSuccessful = FALSE;
            __leave;
        }

    } // __try

    __finally
    {
        // Release ownership of critical section
        LeaveCriticalSection( &m_CriticalSection );
    }

    return( fSuccessful );

} //::Log

//+---------------------------------------------------------------------------
//
//  Member:     CLog::ReportStats
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-18-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CLog::ReportStats( )
{
    // Total tests is number of tests plus number of variations
    ULONG ulNbrTests = 0;

    if( ! m_fEnabled || NULL == m_pLogFile )
        return;

    __try
    {
        EnterCriticalSection( &m_CriticalSection );

        ulNbrTests =    m_ulNbrMessages[ 0 ] + m_ulNbrMessages[ 1 ] +
                        m_ulNbrMessages[ 2 ] + m_ulNbrMessages[ 3 ] +
                        m_ulNbrMessages[ 4 ] + m_ulNbrMessages[ 5 ] +
                        m_ulNbrMessages[ 10 ];

       _ftprintf( m_pLogFile, _T("\n") );

       _ftprintf( m_pLogFile, _T("LOG REPORT---------------------------\n") );

       _ftprintf( m_pLogFile, _T("  Total Tests :       %5d\n"), ulNbrTests );

       _ftprintf( m_pLogFile, _T("-------------------------------------\n") );

       _ftprintf( m_pLogFile, _T("  Tests Passed        %5d   %3d%%\n"),
                  m_ulNbrMessages[ 5 ],
                  (ulNbrTests ? m_ulNbrMessages[ 5 ] * 100 / ulNbrTests : 0 ) );

       _ftprintf( m_pLogFile, _T("  Tests Warned        %5d   %3d%%\n"),
                  m_ulNbrMessages[ 4 ],
                  (ulNbrTests ? m_ulNbrMessages[ 4 ] * 100 / ulNbrTests : 0 ) );

       _ftprintf( m_pLogFile, _T("  Tests Failed SEV3   %5d   %3d%%\n"),
                  m_ulNbrMessages[ 3 ],
                  (ulNbrTests ? m_ulNbrMessages[ 3 ] * 100 / ulNbrTests : 0 ) );

       _ftprintf( m_pLogFile, _T("  Tests Failed SEV2   %5d   %3d%%\n"),
                  m_ulNbrMessages[ 2 ],
                  (ulNbrTests ? m_ulNbrMessages[ 2 ] * 100 / ulNbrTests : 0 ) );

       _ftprintf( m_pLogFile, _T("  Tests Failed SEV1   %5d   %3d%%\n"),
                  m_ulNbrMessages[ 1 ],
                  (ulNbrTests ? m_ulNbrMessages[ 1 ] * 100 / ulNbrTests : 0 ) );

       _ftprintf( m_pLogFile, _T("  Tests Blocked       %5d   %3d%%\n"),
                  m_ulNbrMessages[ 11 ],
                  (ulNbrTests ? m_ulNbrMessages[ 11 ] * 100 / ulNbrTests : 0 ));

       _ftprintf( m_pLogFile, _T("  Tests Aborted       %5d   %3d%%\n"),
                  m_ulNbrMessages[ 0 ],
                  (ulNbrTests ? m_ulNbrMessages[ 0 ] * 100 / ulNbrTests : 0 ) );

       _ftprintf( m_pLogFile, _T("-------------------------------------\n") );
    } // __try

    __finally
    {
        LeaveCriticalSection( &m_CriticalSection );
    }

} //CLog::ReportStats

//
// NO_NTLOG has not been defined.  OK to use NTLOG mechanism
//

#else  // NO_NTLOG has not been defined


//+---------------------------------------------------------------------------
//
//  Member:     ::CLog
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-15-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CLog::CLog( )
:   m_hLog( NULL ),
    m_fEnabled( TRUE ),
    m_dwThreshold( dwThresholdMask )
{
} //::CLog

//+---------------------------------------------------------------------------
//
//  Member:     ::~CLog
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-15-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CLog::~CLog()
{
    if( NULL != m_hLog )
    {
        if( ! tlDestroyLog( m_hLog ) )
        {
            _RPT0( _CRT_WARN, "CLog::~CLog : tlDestroyLog failed.\n" );
        }
        m_hLog = NULL;
    }
} //::~CLog

//+---------------------------------------------------------------------------
//
//  Member:     CLog::ReportStats
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-1997   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CLog::ReportStats( )
{
    if( ! m_fEnabled || NULL == m_hLog )
        return;

    tlReportStats( m_hLog );
} //CLog::ReportStats

//+---------------------------------------------------------------------------
//
//  Member:     ::InitLog
//
//  Synopsis:   used ntlog!tlCreateLog and tlAddParticipant to initialize the
//              log flie
//
//  Arguments:  [szFileName] -- namme of the log file
//              [dwStyle]      -- Style of the log file
//
//  Returns:    TRUE if successful, FALSE otherwise
//
//  History:    10-15-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CLog::InitLog( LPCTSTR szFileName, DWORD dwStyle )
{
    // If the file name is null, log to the monitor
    DWORD dwMonitor = ( szFileName ? 0L : TLS_MONITOR );

    // If the log has been initialized already, return FASLE
    if( NULL != m_hLog )
        return( FALSE );

    // Create the log
    m_hLog = tlCreateLog( szFileName, dwStyle | dwMonitor );

    // See if the file was opened correctly
    if( NULL == m_hLog )
    {
        _RPT1( _CRT_WARN, "CLog::InitLog - Could not open log file %s\n",
               ( szFileName ? szFileName : _T("<standard output>") ) );
        return( FALSE );
    }

    return( TRUE );

} //::InitLog

//+---------------------------------------------------------------------------
//
//  Member:     CLog::AddParticipant
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-05-1997   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CLog::AddParticipant()
{
    // If m_hLog is NULL, the log has not been created
    if( NULL == m_hLog )
        return( FALSE );

    // Add a participant
    return( tlAddParticipant( m_hLog, ( DWORD )0, ( int )0 ) );

} //CLog::AddParticipant

//+---------------------------------------------------------------------------
//
//  Member:     CLog::RemoveParticipant
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-05-1997   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CLog::RemoveParticipant()
{
    // Bad call if m_hLog is NULL
    if( NULL == m_hLog )
        return( FALSE );

    return( tlRemoveParticipant( m_hLog ) );

} //CLog::RemoveParticipant

//+---------------------------------------------------------------------------
//
//  Member:     CLog::vLog
//
//  Synopsis:   Uses ntlog!tlLog to send a message to the log file
//
//  Arguments:  [dwStyle]      -- style of message
//              [szFileName] -- name of file containing the function call
//              [iLine]        -- line number of function call
//              [szFormat]   -- format string
//              [va]           -- variable argument list
//
//  Returns:    TRUE if successful, false otherwise
//
//  History:    1-15-1997   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CLog::vLog( DWORD dwStyle,          // Flags to be applied to this message
                 LPTSTR szFileName,    // Name of file containing function call
                 int iLine,              // Line number of function call
                 LPCTSTR szFormat,     // Format of the message
                 va_list va )            // other arguments
{
    TCHAR   szMessage[ MaxLogLineLength ];
    BOOL    fReturnValue = TRUE;

    if( ! m_fEnabled )
        return( TRUE );

    if( NULL == m_hLog )
        return( FALSE );

    // If the style exceeds the threshold, don't log this message
    if( m_dwThreshold < ( dwStyle & dwThresholdMask ) )
        return( TRUE );

    if( -1 == _vsntprintf( szMessage, MaxLogLineLength, szFormat, va ) )
    {
        // Only display the first MaxLogLineLength characters of this message
    }

    return( tlLog( m_hLog, dwStyle, szFileName, iLine, szMessage ) );

} //CLog::Log

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\ifilttst\filttest.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       filttest.cxx
//
//  Contents:   Definitions for CFiltTest methods
//
//  Classes:
//
//  Functions:  methods of CFiltTest
//
//  Coupling:
//
//  Notes:      Allocations: This function assumes that a newhandler has been
//              defined to handle failed allocations.
//
//  History:    9-16-1996   ericne   Created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#include "utility.hxx"
#include "mydebug.hxx"
#include "filttest.hxx"

// added by t-shawnh 09/19/97
#include "nlfilter.hxx"
// t-shawnh

// Must be compiled with the UNICODE flag
#if ! defined( UNICODE ) && ! defined( _UNICODE )
    #error( "UNICODE must be defined" )
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CFiltTest::CFiltTest
//
//  Synopsis:   Constructor for CFiltTest
//
//  Arguments:  [pwcFile] -- Wide character string containing file name
//
//  Returns:    none
//
//  History:    9-19-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CFiltTest::CFiltTest( CLog * pLog )
:   m_pLog( pLog ),
    m_fIsText( FALSE ),
    m_pIFilter( NULL ),
    m_pDumpFile( NULL ),
    m_verbosity( HIGH ),
    m_fLegitOnly( FALSE ),
    m_ChunkStatsListHead(),
    m_pwcTextBuffer( NULL ),
    m_fIsInitialized( FALSE ),
    m_szInputFileName( NULL ),
    m_fSharedLog( NULL == pLog ? FALSE : TRUE )
{

} //CFiltTest::CFiltTest

//+---------------------------------------------------------------------------
//
//  Member:     CFiltTest::~CFiltTest
//
//  Synopsis:   Destructor: cleans up dynamically allocated memory
//
//  Arguments:  (none)
//
//  Returns:    none
//
//  History:    9-19-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CFiltTest::~CFiltTest()
{
    if( NULL != m_pLog )
    {
        if( m_fSharedLog )
        {
            if( ! m_pLog->RemoveParticipant() )
            {
               _RPT1( _CRT_WARN,
                       "Could not remote this thread as a participant of log for input file %ls\r\n",
                       m_szInputFileName );
            }
        }
        else
        {
            m_pLog->ReportStats();

            if( ! m_pLog->RemoveParticipant() )
            {
               _RPT1( _CRT_WARN,
                       "Could not remote this thread as a participant of log for input file %ls\r\n",
                       m_szInputFileName );
            }

            delete m_pLog;
        }
    }

    if( NULL != m_szInputFileName )
        delete [] m_szInputFileName;

    if( NULL != m_pwcTextBuffer )
        delete [] m_pwcTextBuffer;

    if( NULL != m_pDumpFile && stdout != m_pDumpFile )
        fclose( m_pDumpFile );

    FlushList( );

} //CFiltTest::~CFiltTest

//+---------------------------------------------------------------------------
//
//  Member:     CFiltTest::Init
//
//  Synopsis:   Initialized the test
//
//  Arguments:  [szInputFileName] -- Name of the input file
//              [szLogFileName]   -- Name of the file to log results
//              [szDumpFileName]  -- Name of the file to dump text
//              [verbosity]        -- Level of verbosity
//
//  Returns:    TRUE if init was successful
//              FALSE if init failed.
//
//  History:    9-20-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CFiltTest::Init( const WCHAR * szInputFileName,
                      const WCHAR * szLogFileName,
                      const WCHAR * szDumpFileName,
                      const WCHAR * szIniFileName,
                      Verbosity verbosity,
                      BOOL  fLegitOnly )
{
    WCHAR szIniPathName[ MAX_PATH ];

    // For use in writting the Unicode byte-order mark to the dump file
    WCHAR wcBOM = 0xFEFF;
    DWORD dwNbrBytes = 0;

    _ASSERT( NULL != szInputFileName );
    _ASSERT( NULL != szIniFileName );

    // Set the legit only flag
    m_fLegitOnly = fLegitOnly;

    // Allocate space for the filename
    m_szInputFileName = NEW WCHAR[ wcslen(szInputFileName) + 1 ];
    wcscpy( m_szInputFileName, szInputFileName );

    // Allocate space for the text returned by GetText
    m_pwcTextBuffer = NEW WCHAR[ BUFFER_SIZE + 1 ];

    // Set the verbosity
    m_verbosity = verbosity;

    // Create a log if necessary:
    if( NULL == m_pLog )
        m_pLog = NEW CLog;

    _ASSERT( NULL != m_pLog );

    // If logging is enabled, initialize the log
    if( NULL != szLogFileName )
    {
        if( ! m_fSharedLog )
        {
            if( ! m_pLog->InitLog( szLogFileName ) )
            {
                printf( "Could not open the log file %ls\r\n"
                        "Could not initialize the test for file %ls\r\n",
                        szLogFileName, szInputFileName );
                return( FALSE );
            }

            if( ! m_pLog->AddParticipant() )
            {
                printf( "Could not add this thread as a participant to"
                        " the log file %ls.\r\n", szLogFileName );
                return( FALSE );
            }

            // Set the log threshold
            m_pLog->SetThreshold( VerbosityToLogStyle( verbosity ) );

        }
        else
        {
            // Otherwise, only add as a participant
            if( ! m_pLog->AddParticipant() )
            {
                printf( "Could not add this thread as a participant to"
                        " the log file %ls.\r\n", szLogFileName );
                return( FALSE );
            }
        }

        // Send a message to the log file indicating which input file is
        // being filtered
        m_pLog->Log( TLS_TEST | TL_INFO, L"**** Input file : %ls",
                   szInputFileName );

    }
    else
    {
        // Disable the log.  Log messages will now be ignored
        m_pLog->Disable();
    }

    // If dumping is not enabled, leave m_pDumpFile == NULL
    // BUGBUG is there an easy way to redirect output to NUL?
    if( NULL != szDumpFileName )
    {
        // Fill in the dummping information
        if( NULL == szDumpFileName )
        {
            m_pDumpFile = stdout;
        }
        else
        {
            m_pDumpFile = _wfopen( szDumpFileName, L"wb" );

            // Write the Unicode byte-order mark to the file
            if( NULL != m_pDumpFile )
            {
                putwc( wcBOM, m_pDumpFile );
            }
            else
            {
                m_pLog->Log( TLS_TEST | TL_SEV1, L"Could not open the Dump file"
                           L" %ls Could not initialize test for file %ls",
                           szDumpFileName, szInputFileName );
                return( FALSE );
            }
        }
    }

    // Parse the input data file containing configuration information
    GetFullPathName( szIniFileName, MAX_PATH, szIniPathName, NULL );

    if( ! m_FiltParse.Init( szIniPathName ) )
    {
        m_pLog->Log( TLS_TEST | TL_SEV1, L"Could not parse the input file." );
        return( FALSE );
    }

    return( TRUE );

} //CFiltTest::Init

//+---------------------------------------------------------------------------
//
//  Member:     CFiltTest::FlushList
//
//  Synopsis:   Deletes all the nodes in the linked list
//
//  Arguments:  (none)
//
//  Returns:    none
//
//  History:    9-19-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CFiltTest::FlushList( )
{
    // Clean up the memory allocated in the ChunkIDList
    CListNode *pListNode = m_ChunkStatsListHead.next;
    CListNode *pTempNode = NULL;

    while( NULL != pListNode )
    {
        pTempNode = pListNode;
        pListNode = pListNode->next;
        delete pTempNode;   // Calls destructor for ChunkStats
    }

    m_ChunkStatsListHead.next = NULL;

} //CFiltTest::FlushList

BOOL CFiltTest::IsCurrentChunkContents()
{
    static const GUID guidContents = PSGUID_STORAGE;

    if( CHUNK_TEXT == m_CurrentChunkStats.flags &&
        guidContents == m_CurrentChunkStats.attribute.guidPropSet &&
        PRSPEC_PROPID == m_CurrentChunkStats.attribute.psProperty.ulKind &&
        PID_STG_CONTENTS == m_CurrentChunkStats.attribute.psProperty.propid )
    {
        return TRUE;
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CFiltTest::ValidateChunkStats
//
//  Synopsis:   Checks the fields of m_CurrentChunkStats for sanity and adds
//              it to the end of the liked list
//
//  Arguments:  (none)
//
//  Returns:    void
//
//  History:    9-19-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CFiltTest::ValidateChunkStats( )
{
    CListNode   *pNewNode = NULL;
    CListNode   *pLastNode = &m_ChunkStatsListHead;

    // Make sure nobody has messed with the head of the list
    _ASSERT( 0 == m_ChunkStatsListHead.ChunkStats.idChunk );

    // Check that the current chunk has a recognized value for the flags field
    if( CHUNK_VALUE != m_CurrentChunkStats.flags &&
         CHUNK_TEXT != m_CurrentChunkStats.flags )
    {
        m_pLog->Log( TLS_TEST | TL_SEV1, L"The current chunk has an illegal"
                   L" value for the flags field.  Legal values are 1 and 2." );
        LogChunkStats( m_CurrentChunkStats );
    }
    else
    {
        m_pLog->Log( TLS_TEST | TL_PASS, L"The current chunk has a legal value"
                     L" for the flags field." );
    }

    // Check that the current chunk has a legal break yype
    if( CHUNK_NO_BREAK > m_CurrentChunkStats.breakType ||
        CHUNK_EOC      < m_CurrentChunkStats.breakType )
    {
        m_pLog->Log( TLS_TEST | TL_SEV1, L"The current chunk has an illegal"
                   L" value for breakType. Legal values are from 0 to 4." );
        LogChunkStats( m_CurrentChunkStats );
    }
    else
    {
        m_pLog->Log( TLS_TEST | TL_PASS, L"The current chunk has a legal value"
                   L" for breakType." );
    }

    // The idChunkSource should not be larger than the id of the current chunk
    if( m_CurrentChunkStats.idChunkSource > m_CurrentChunkStats.idChunk )
    {
        m_pLog->Log( TLS_TEST | TL_WARN, L"For the current chunk, idChunkSource"
                   L" is greater than idChunk." );
        LogChunkStats( m_CurrentChunkStats );
    }

    // If the idCunkSource is not equal to the idChunk, the chunk
    // cannot be a contents chunk
    if( m_CurrentChunkStats.idChunkSource != m_CurrentChunkStats.idChunk &&
        IsCurrentChunkContents() )
    {
        m_pLog->Log( TLS_TEST | TL_SEV1, L"ERROR: For the current chunk,"
               L" idChunkSource is not equal to idChunk and the chunk does"
               L" not contain a pseudo-property. This is not legal (see"
               L" IFilter spec for GetChunk)" );
        LogChunkStats( m_CurrentChunkStats );
    }

    // Check the propspec for validity
    ValidatePropspec( );

    // Step to the end of the list.
    while( NULL != pLastNode->next )
    {
        pLastNode = pLastNode->next;
    }

    // Before placing the chunk at the end of the list, verify that its ID
    // is in fact larger than that of the last chunk in the list
    if( m_CurrentChunkStats.idChunk <= pLastNode->ChunkStats.idChunk)
    {
        if( 0 == m_CurrentChunkStats.idChunk )
        {
            m_pLog->Log( TLS_TEST | TL_SEV1, L"Zero is an"
                         L" illegal value for chunk id." );
        }

        if( pLastNode != &m_ChunkStatsListHead )
        {
            m_pLog->Log( TLS_TEST | TL_SEV1, L"The current chunk ID is not"
                         L" greater than the previous." );
        }

        LogChunkStats( m_CurrentChunkStats );
    }
    else
    {
        m_pLog->Log( TLS_TEST | TL_PASS, L"The current chunk has a legal value"
                      L" for chunk id." );
    }

    // Allocate space for a new CListNode:
    pNewNode = NEW CListNode;

    // Dump the chunk statistics:
    DisplayChunkStats( m_CurrentChunkStats, m_pDumpFile );

    // Add the data to the end of the list:
    pLastNode->next = pNewNode;
    pNewNode->next = NULL;

    // Fill in the ChunkStats field by using CStatChunk's overloaded
    // assignment operator:
    pNewNode->ChunkStats = m_CurrentChunkStats;

} //CFiltTest::ValidateChunkStats

//+---------------------------------------------------------------------------
//
//  Member:     CFiltTest::ValidatePropspec
//
//  Synopsis:   Validate that the current chunk should have been emitted, based
//              on the attributes specified in the filter configuration
//
//  Arguments:  (none)
//
//  Returns:    none
//
//  History:    9-25-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CFiltTest::ValidatePropspec( )
{
    UINT             uiLoop = 0;
    UINT             uiLoopMax = 0;
    BOOL             fIsLegalAttribute = FALSE;
    GUID             psguid_storage = PSGUID_STORAGE;
    const GUID &     guidPropSet = m_CurrentChunkStats.attribute.guidPropSet;
    const PROPSPEC & psProperty = m_CurrentChunkStats.attribute.psProperty;

    // Check to see if the ulKind field is OK
    if( PRSPEC_PROPID == psProperty.ulKind ||
        PRSPEC_LPWSTR == psProperty.ulKind )
    {
        m_pLog->Log( TLS_TEST | TL_PASS, L"The current chunk has a valid value"
                   L" for the attribute.psProperty.ulKind field" );
    }
    else
    {
        m_pLog->Log( TLS_TEST | TL_SEV1, L"The current chunk has an invalid"
                   L" value for the attribute.psProperty.ulKind field."
                   L" Accepted values are 0 and 1." );
        // Nothing else we can do now, so return.
        return;
    }

    // If the PROPSPEC is a PROPID, make sure the value is not 0 or 1
    if( PRSPEC_PROPID == psProperty.ulKind &&
        ( 0 == psProperty.propid || 1 == psProperty.propid ) )
    {
        m_pLog->Log( TLS_TEST | TL_SEV1, L"The current chunk has an invalid"
                   L" value for the attribute.psProperty.propid field."
                   L" Illegal values are 0 and 1." );
    }
    else
    {
        m_pLog->Log( TLS_TEST | TL_PASS, L"The current chunk has a valid value"
                   L" for the attribute.psProperty.propid field" );
    }

    // If some attributes were requested explicitly in aAttributes, only
    // look in aAttributes for a match
    if( 0 != m_CurrentConfig.cAttributes )
    {
        // Loop over the smaller of cAttributes and ulActNbrAttributes
        if( m_CurrentConfig.cAttributes < m_CurrentConfig.ulActNbrAttributes )
            uiLoopMax = m_CurrentConfig.cAttributes;
        else
            uiLoopMax = m_CurrentConfig.ulActNbrAttributes;

        // Loop over all attributes in the current configuration
        for( uiLoop = 0; uiLoop < uiLoopMax; uiLoop++ )
        {
            // If the properties are of different type, continue
            if( psProperty.ulKind !=
                m_CurrentConfig.aAttributes[ uiLoop ].psProperty.ulKind )
                continue;

            // If the guids don't match, continue
            if( guidPropSet !=
                m_CurrentConfig.aAttributes[ uiLoop ].guidPropSet )
                continue;

            // If propid, compare the id's. NOTE: If the first condition
            // eveluates to FALSE, the second is not eveluated at all.
            if( ( PRSPEC_PROPID == psProperty.ulKind ) &&
                ( psProperty.propid ==
                  m_CurrentConfig.aAttributes[ uiLoop ].psProperty.propid ) )
            {
                fIsLegalAttribute = TRUE;
                break;
            }

            // If pwstr, compare the strings. NOTE: If the first condition
            // evaluates to FALSE, the second is not evaluated at all.
            if( ( PRSPEC_LPWSTR == psProperty.ulKind ) &&
                ( 0 == wcscmp( psProperty.lpwstr,
                  m_CurrentConfig.aAttributes[ uiLoop ].psProperty.lpwstr ) ) )
            {
                fIsLegalAttribute = TRUE;
                break;
            }
        } // for
    }
    else if( m_CurrentConfig.grfFlags & IFILTER_INIT_APPLY_INDEX_ATTRIBUTES )
    {
        // The filter has been configured to emit everything
        fIsLegalAttribute = TRUE;

        // NOTE: The flag IFILTER_INIT_APPLY_OTHER_ATTRIBUTES has no meaning,
        // so I do not test for it.
    }
    else
    {
        // The filter should only be emitting contents
        if( PRSPEC_PROPID == psProperty.ulKind &&
            psguid_storage == guidPropSet &&
            PID_STG_CONTENTS == psProperty.propid )
        {
            fIsLegalAttribute = TRUE;
        }
    }

    // If this chunk has an unrequested attribute, display the error
    if( ! fIsLegalAttribute )
    {
        m_pLog->Log( TLS_TEST | TL_SEV1, L"The filter has emitted a chunk which"
                   L" it was not requested to emit. Check the initialization"
                   L" parameters in section %s of the initialization file.",
                   m_CurrentConfig.szSectionName );

        // Write the offensive chunk stats to the log file for later inspection
        LogChunkStats( m_CurrentChunkStats );
    }
    else
    {
        m_pLog->Log( TLS_TEST | TL_PASS, L"The attribute of the current chunk"
                   L" correctly matches the attributes specified in the"
                   L" call to Init()." );
    }

} //CFiltTest::ValidatePropspec


//+---------------------------------------------------------------------------
//
//  Member:     CFiltTest::ExecuteTests
//
//  Synopsis:   Picks a configuration from the config list, binds the filter,
//              and initializes it with the configution. It then performs the
//              validation test. Then it re-initializes the filter and performs
//              the consistency test.  Then it re-initialized the filter and
//              performs the invalid input test.  Then it releases the filter,
//              picks a new configuration and repeats the whole process until
//              all the configurations have been tested.
//
//  Arguments:  (none)
//
//  Returns:    none
//
//  History:    9-19-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CFiltTest::ExecuteTests()
{
    DWORD   dwNbrBytes = 0;

    while( m_FiltParse.GetNextConfig( &m_CurrentConfig ) )
    {
        m_pLog->Log( TLS_TEST | TL_INFO, L"**** New configuration ****" );

        LogConfiguration( m_CurrentConfig );

        // Bind the filter:
        if( ! BindFilter( ) )
        {
            printf( "LoadIFilter failed before the Legitimacy Test. "
                    "Test quitting.\r\n" );
            return;
        }

        // Initialize the filter
        if( ! InitializeFilter( m_CurrentConfig ) )
        {
            ReleaseFilter( );
            continue;
        }

        // Perform the validation test:
        LegitimacyTest( );

        // If the m_fLegitOnly member is TRUE, don't perform any more tests
        if( m_fLegitOnly )
        {
            ReleaseFilter( );
            FlushList( );
            continue;
        }

        // Only rebind the filter if IFILTER_INIT_INDEXING_ONLY flag is on:
        if( m_CurrentConfig.grfFlags & IFILTER_INIT_INDEXING_ONLY )
        {
            ReleaseFilter( );
            if( ! BindFilter( ) )
            {
                printf( "After successfully loading the filter for the "
                        "Legitimacy Test,\r\nthe filter was released and "
                        "LoadIFilter was called again.\r\nIt failed.  "
                        "Test quitting.\r\n" );
                return;
            }
        }

        // Initialize the filter
        if( ! InitializeFilter( m_CurrentConfig ) )
        {
            printf( "After successfully running the Legitimacy Test, a call"
                    " to ::Init()\r\nto re-initialize the filter failed."
                    " Test quitting.\r\n" );
            FlushList( );
            ReleaseFilter( );
            continue;
        }

        // Perform the consistency test test:
        ConsistencyTest( );

        // Only rebind the filter if IFILTER_INIT_INDEXING_ONLY flag is on:
        if( m_CurrentConfig.grfFlags & IFILTER_INIT_INDEXING_ONLY )
        {
            ReleaseFilter( );
            if( ! BindFilter( ) )
            {
                printf( "After successfully loading the filter for the "
                        "Legitimacy Test\r\n and the Consistency Test, the "
                        "filter was released and LoadIFilter\r\nwas called "
                        "again. It failed. Test quitting.\r\n" );
                return;
            }
        }

        // Initialize the filter
        if( ! InitializeFilter( m_CurrentConfig ) )
        {
            printf( "After successfully running the Legitimacy Test and the "
                    "Consistency Test,\r\na call to ::Init() to re-initialize"
                    " the filter failed. Test quitting.\r\n" );
            FlushList( );
            ReleaseFilter( );
            continue;
        }

        // Perform the invalid input test:
        IllegitimacyTest( );

        // Flush the list:
        FlushList( );

        // Release the filter:
        ReleaseFilter( );

    }

} //CFiltTest::ExecuteTests

//+---------------------------------------------------------------------------
//
//  Member:     CFiltTest::BindFilter
//
//  Synopsis:   Bind the filter to m_pIFilter using LoadIFilter
//
//  Arguments:  (none)
//
//  Returns:    TRUE if successful, FALSE otherwise
//
//  History:    9-19-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CFiltTest::BindFilter( )
{
    SCODE sc = S_OK;

    _ASSERT( ! m_fIsInitialized );

    // Bind the filter:

    // added by t-shawnh 09/19/97
    sc = NLLoadIFilter( m_szInputFileName, (IUnknown*)0, (void**) &m_pIFilter );

    if (FAILED(sc))
    {
       sc = LoadIFilter( m_szInputFileName, (IUnknown*)0, (void**) &m_pIFilter );
    }
    // t-shawnh

    if( FAILED( sc ) )
    {
        m_pLog->Log( TLS_TEST | TL_SEV1, L"Unable to bind filter to file %ls"
                   L" Return code is 0x%08x", m_szInputFileName, sc );
        return( FALSE );
    }

    m_pLog->Log( TLS_TEST | TL_INFO, L"Successfully bound filter." );

    return( TRUE );

} //CFiltTest::BindFilter

//+---------------------------------------------------------------------------
//
//  Member:     CFiltTest::InitializeFilter
//
//  Synopsis:   Initializes the filter with the configuration specified
//
//  Arguments:  [Configuration] -- structure which contains all the parameters
//              needed to initialize a filter
//
//  Returns:    TRUE if successful, FALSE otherwise
//
//  History:    9-19-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CFiltTest::InitializeFilter( const CONFIG & Configuration )
{
    // Initialize the filter
    SCODE sc = S_OK;
    _ASSERT( NULL != Configuration.pdwFlags );

    // Set *pdwFlags equal to an illegal value to make sure Init sets it
    // correctly
    *Configuration.pdwFlags = -1;

    __try
    {
        sc = m_pIFilter->Init( Configuration.grfFlags,
                               Configuration.cAttributes,
                               Configuration.aAttributes,
                               Configuration.pdwFlags );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        m_pLog->Log( TLS_TEST | TL_SEV1, L"Exception 0x%08X occured in IFilter"
                   L"::Init() The filter is bound to %ls  Below are the"
                   L" parameters which led to the exception.",
                   GetExceptionCode(), m_szInputFileName );
        LogConfiguration( Configuration );
        return( FALSE );
    }

    // Check to see if Init failed
    if( FAILED( sc ) )
    {
        // It is legal for Init to return FILTER_E_PASSWORD or FILTER_E_ACCESS
        if( FILTER_E_PASSWORD == sc )
        {
            m_pLog->Log( TLS_TEST | TL_PASS, L"IFilter::Init returned"
                         L" FILTER_E_PASSWORD. The filter is bound to %ls."
                         L" The test cannot continue.", m_szInputFileName );
        }
        else if( FILTER_E_ACCESS == sc )
        {
            m_pLog->Log( TLS_TEST | TL_PASS, L"IFilter::Init returned"
                         L" FILTER_E_ACCESS. The filter is bound to %ls."
                         L" The test cannot continue.", m_szInputFileName );
        }
        else
        {
            // Log a message if init failed.  It is ok to fail if cAttributes
            // is > 0 and aAttributes is NULL
            if( ( 0 == Configuration.cAttributes ) ||
                ( NULL != Configuration.aAttributes ) )
            {
                m_pLog->Log( TLS_TEST | TL_SEV1, L"Tried to initialize filer. "
                           L" Expecting a return code of S_OK.  Return code was"
                           L" 0x%08x  Filter is bound to %ls.  Below are the"
                           L" parameters which led to the failure.", sc,
                           m_szInputFileName );
                LogConfiguration( Configuration );
            }
            else
            {
                m_pLog->Log( TLS_TEST | TL_PASS, L"Passed invalid parameters to"
                           L" Init.  cAttributes > 0 and aAttributes == NULL. "
                           L" Return code is 0x%08x", sc );
            }
        }
        return( FALSE );
    }

    // If the call succeeded and the parameters were bad, something is wrong
    if( ( 0 < Configuration.cAttributes ) &&
        ( NULL == Configuration.aAttributes ) )
    {
        m_pLog->Log( TLS_TEST | TL_SEV1, L"Passed invalid parameters to Init. "
                   L" cAttributes > 0 and aAttributes == NULL. Expecting call"
                   L" to fail. Return code is 0x%08x. The filter is bound to"
                   L" %ls", sc, m_szInputFileName );
        return( FALSE );
    }

    // Check the pdwFlags return value for legitimacy
    if( 0 != *Configuration.pdwFlags &&
        IFILTER_FLAGS_OLE_PROPERTIES != *Configuration.pdwFlags )
    {
        m_pLog->Log( TLS_TEST | TL_SEV1, L"Init() returned an invalid value for"
                   L" pdwFlags.  Acceptable values are 0 and IFILTER_FLAGS_OLE"
                   L"_PROPERTIES. Returned value is %d",
                   *Configuration.pdwFlags );
        return( FALSE );
    }
    else
    {
        m_pLog->Log( TLS_TEST | TL_PASS, L"Init() returned a valid value for"
                   L" pdwFlags." );
    }

    // Set the initialized flag:
    m_fIsInitialized = TRUE;

    m_pLog->Log( TLS_TEST | TL_INFO, L"Successfully initialized filter." );

    return( TRUE );

} //CFiltTest::InitializeFilter

//+---------------------------------------------------------------------------
//
//  Member:     CFiltTest::ReleaseFilter
//
//  Synopsis:   Releases the filter
//
//  Arguments:  (none)
//
//  Returns:    none
//
//  History:    9-19-1996   ericne   Created
//
//  Notes:      This is necessary because Release() lowers the reference count
//              on the filter object and allows it to be deleted by the system
//
//----------------------------------------------------------------------------

void CFiltTest::ReleaseFilter()
{
    // Turn off the Initialized flag:
    m_fIsInitialized = FALSE;

    // Release the filter:
    if( 0 != m_pIFilter->Release() )
    {
        m_pLog->Log( TLS_TEST | TL_SEV1, L"The return value of IFilter::Release()"
                   L" is not zero.  This indicates that there is a resource"
                   L" leak in the filter" );
    }

    m_pLog->Log( TLS_TEST | TL_INFO, L"Released filter" );

} //CFiltTest::ReleaseFilter

//+---------------------------------------------------------------------------
//
//  Member:     CFiltTest::LegitimacyTest
//
//  Synopsis:   Get all the chunks from the object, validate them, add them to
//              the list of chunks, and call GetTextFromTextChunk() or
//              GetValueFromValueChunk().  This is the "sane" test, intended
//              to validate that the ifilter is in minimum working condition.
//
//  Arguments:  (none)
//
//  Returns:    none
//
//  History:    9-19-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CFiltTest::LegitimacyTest( )
{
    SCODE sc = S_OK;
    //STAT_CHUNK OldChunkStats = m_ChunkStatsListHead.ChunkStats;

    _ASSERT( m_fIsInitialized );

    m_pLog->Log( TLS_TEST | TL_INFO, L"Performing validation test."
               L" In this part of the test, the chunks structures returned"
               L" by the filter are checked for correctness, and the return"
               L" values of the filter calls are checked." );

    // Break out of this loop when GetChunk returns FILTER_E_END_OF_CHUNKS
    while( 1 )
    {
        __try
        {
            sc = m_pIFilter->GetChunk( &m_CurrentChunkStats );
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            m_pLog->Log( TLS_TEST | TL_SEV1, L"Exception 0x%08X occured in"
                       L" GetChunk(). The filter is bound to %ls Legitimacy"
                       L" Test is quitting.", GetExceptionCode(),
                       m_szInputFileName );
            return;
        }

        // Break if we are at the end of the chunks
        if( FILTER_E_END_OF_CHUNKS == sc )
            break;

        if( FILTER_E_EMBEDDING_UNAVAILABLE == sc )
        {
            m_pLog->Log( TLS_TEST | TL_INFO, L"Encountered an embedding for"
                       L" which a filter is not available." );
            continue;
        }

        if( FILTER_E_LINK_UNAVAILABLE == sc)
        {
            m_pLog->Log( TLS_TEST | TL_INFO, L"Encountered a link for which a"
                       L" filter is not available." );
            continue;
        }

        if( FILTER_E_PASSWORD == sc )
        {
            m_pLog->Log( TLS_TEST | TL_INFO, L"Access failure: GetChunk()"
                       L" returned FILTER_E_PASSWORD." );
            continue;
        }

        if( FILTER_E_ACCESS == sc )
        {
            m_pLog->Log( TLS_TEST | TL_INFO, L"Access failure: GetChunk()"
                       L" returned FILTER_E_ACCESS." );
            break;
        }

        if( FAILED( sc ) )
        {
            m_pLog->Log( TLS_TEST | TL_SEV1, L"GetChunk() failed for unknown"
                       L" reason. The return code is 0x%08x", sc );
            return;
        }
        else
        {
            m_pLog->Log( TLS_TEST | TL_PASS, L"GetChunk() succeeded." );
        }

        // Otherwise, we have a valid chunk.

        // Validate the chunk statistics
        ValidateChunkStats( );

        // Set the m_fIsText field:
        if( CHUNK_VALUE == m_CurrentChunkStats.flags )
            m_fIsText = FALSE;
        else
            m_fIsText = TRUE;

        // Get the text or value from chunk
        if( m_fIsText )
            GetTextFromTextChunk( );
        else
            GetValueFromValueChunk( );

        // Save the old chunk stats for future comparison
        //OldChunkStats = m_CurrentChunkStats;

    }
    // Last call to GetChunk() should not change m_CurrentChunkStats
    //if( OldChunkStats != m_CurrentChunkStats )
    //{
    //    m_pLog->Log( TLS_TEST | TL_WARN, L"Final call to GetChunk() modified"
    //               L" the STAT_CHUNK structure." );
    //}

} //CFiltTest::LegitimacyTest

//+---------------------------------------------------------------------------
//
//  Member:     CFiltTest::GetTextFromTextChunk
//
//  Synopsis:   Call GetText() until all the text has been returned.  Validate
//              all return codes.
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    9-19-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CFiltTest::GetTextFromTextChunk( )
{
    BOOL    fNoMoreText = FALSE;
    BOOL    fIsFirstTime = TRUE;
    SCODE   sc = S_OK;
    ULONG   ulBufferCount = BUFFER_SIZE;

    _ASSERT( m_fIsText );
    _ASSERT( m_fIsInitialized );


    // Try-finally block to simplify clean-up
    __try
    {
        if( NULL != m_pDumpFile )
            fwprintf( m_pDumpFile, L"\r\n" );

        while( 1 )
        {
            // Reset ulBufferCount
            ulBufferCount = BUFFER_SIZE;

            __try
            {
                sc = m_pIFilter->GetText( &ulBufferCount, m_pwcTextBuffer );
            }
            __except( EXCEPTION_EXECUTE_HANDLER )
            {
                m_pLog->Log( TLS_TEST | TL_SEV1, L"Calling GetText() on a text"
                           L" chunk produced exception 0x%08X",
                           GetExceptionCode() );
                LogChunkStats( m_CurrentChunkStats );
                __leave;
            }

            // Break if we have reached the end of the text:
            if ( FILTER_E_NO_MORE_TEXT == sc )
            {
                // If this is the first loop through, display a warning
//              if( fIsFirstTime )
//              {
//                  m_pLog->Log( TLS_TEST | TL_WARN, L"First call to GetText()"
//                             L" on the chunk with chunk id %d returned"
//                             L" FILTER_E_NO_MORE_TEXT.",
//                             m_CurrentChunkStats.idChunk );
//              }
                break;
            }

            // Set the "first time" flag
            fIsFirstTime = FALSE;

            // If this evaluates to true, there is a problem:
            if( fNoMoreText )
            {
                m_pLog->Log( TLS_TEST | TL_SEV1, L"Previous call to GetText()"
                           L" returned FILTER_S_LAST_TEXT. Expected next"
                           L" call to return FILTER_E_END_OF_TEXT."
                           L" GetText() returned 0x%08x", sc );
                fNoMoreText = FALSE;
            }
            else
            {
                // No need to display any message here
            }

            // Check for failure
            if( FAILED( sc ) )
            {
                m_pLog->Log( TLS_TEST | TL_SEV1, L"Call to GetText() failed for "
                           L"unknown reason. The return code is 0x%08x", sc );
                __leave;
            }
            else
            {
                m_pLog->Log( TLS_TEST | TL_PASS, L"Call to GetText() succeeded.");
            }

            // Make sure ulBufferCount is <= what it was before the call
            if( ulBufferCount > BUFFER_SIZE )
            {
                m_pLog->Log( TLS_TEST | TL_SEV1, L"Called GetText() and checked"
                           L" value of *pcwcBuffer. Expected: *pcwcBuffer"
                           L" <= value prior to call. Found: *pcwcBuffer"
                           L" > value prior to call." );
            }
            else
            {
                m_pLog->Log( TLS_TEST | TL_PASS, L"After call to GetText(), *pcwc"
                       L"Buffer is <= its value prior to the call" );
            }

            // BUGBUG: Maybe I should save the text in the List for future
            // comparison.

            // Before dumping the text, make sure it's null-terminated
            m_pwcTextBuffer[ ulBufferCount ] = L'\0';

            // Dump the text
            DisplayText( m_pwcTextBuffer, m_pDumpFile );

            // Set the fNoMoreChunks field if necessary.
            if( FILTER_S_LAST_TEXT == sc )
            {
                // Next GetText() call should return FILTER_E_NO_MORE_TEXT
                fNoMoreText = TRUE;
            }

        }

        // output some blank lines to keep the dump file looking neat
        if( NULL != m_pDumpFile )
            fwprintf( m_pDumpFile, L"\r\n\r\n" );

        // BUGBUG make sure last call to GetText() didn't change m_pwcTextBuffer

        //if( BUFFER_SIZE != ulBufferCount )
        //{
        //    m_pLog->Log( TLS_TEST | TL_WARN, L"Final call to GetText()"
        //               L" modified ulBufferCount." );
        //}
    }

    __finally
    {
        // Make sure no unhandled exceptions occured in the try block
        _ASSERT( ! AbnormalTermination() );

        // Any clean up code goes here

    }

} //CFiltTest::GetTextFromTextChunk

//+---------------------------------------------------------------------------
//
//  Member:     CFiltTest::GetValueFromValueChunk
//
//  Synopsis:   Call GetValue on chunk containing a value until all values
//              are returned.  There should only be one value.  Verify the
//              return codes
//
//  Arguments:  (none)
//
//  Returns:    none
//
//  History:    9-19-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CFiltTest::GetValueFromValueChunk( )
{
    int         iNbrChars = 0;
    SCODE       sc = S_OK;
    DWORD       dwByteCount = 0;
    PROPVARIANT *pPropValue = NULL;

    // Only in the debug version
    _ASSERT( ! m_fIsText );
    _ASSERT( m_fIsInitialized );

    // Try-finally block to simplify clean-up
    __try
    {

        // First call to GetValue should not return FILTER_E_NO_MORE_VALUES
        __try
        {
            sc = m_pIFilter->GetValue( &pPropValue );
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            m_pLog->Log( TLS_TEST | TL_SEV1, L"Exception 0x%08X occured in"
                       L" GetValue()", GetExceptionCode() );
            __leave;
        }

        if( FILTER_E_NO_MORE_VALUES == sc )
        {
            m_pLog->Log( TLS_TEST | TL_WARN, L"First call to GetValue() returned"
                       L" FILTER_E_NO_MORE_VALUES." );
            __leave;
        }

        // Check for a failure
        if( FAILED( sc ) )
        {
            m_pLog->Log( TLS_TEST | TL_SEV1, L"GetValue() failed for unknown"
                       L" reason Return value is 0x%08x", sc );
            __leave;
        }
        else
        {
            m_pLog->Log( TLS_TEST | TL_PASS, L"GetValue() succeeded" );
        }

        // Make sure we have a PROPSPEC structure
        if( NULL == pPropValue )
        {
            m_pLog->Log( TLS_TEST | TL_SEV1, L"GetValue() misbehaved by not"
                       L" returning a valid PROPVARIANT structure." );
            LogChunkStats( m_CurrentChunkStats );
            __leave;
        }
        else
        {
            m_pLog->Log( TLS_TEST | TL_PASS, L"GetValue() returned a valid "
                       L"PROPVARIANT" );
        }

        // BUGBUG Think about storing the property for later validation

        DisplayValue( pPropValue, m_pDumpFile );

    } // __try

    __finally
    {

        // Make sure no unhandled exception occured
        _ASSERT( ! AbnormalTermination() );

        // Free the memory allocated by GetValue()
        if( pPropValue )
            FreePropVariant( pPropValue );
    }

} //CFiltTest::GetValueFromValueChunk

//+---------------------------------------------------------------------------
//
//  Member:     CFiltTest::ConsistencyTest
//
//  Synopsis:   Called by ExecuteTests() after reinitializing the filter.
//              Call GetChunk() and make sure the STAT_CHUNK's returned
//              are exactly equal to those stored in the list.  This function
//              should be called only after the validation test has completed.
//
//  Arguments:  (none)
//
//  Returns:    none
//
//  History:    9-19-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CFiltTest::ConsistencyTest( )
{
    // This function is called after the filter has been reinitialized.
    // It runs through the entire document and checks that the chunks
    // returned are identical to those returned previously.
    SCODE sc = S_OK;
    CListNode *CurrentListNode = m_ChunkStatsListHead.next;

    // Only in debug version
    _ASSERT( m_fIsInitialized );

    m_pLog->Log( TLS_TEST | TL_INFO, L"Performing consistency test."
           L" The filter has been reinitialized and the test will now"
           L" validate that the chunks emitted are the same as those"
           L" that were emitted previously, including Chunk ID's." );

    // Break out of this loop when GetChunk() returns FILTER_E_END_OF_CHUNKS
    while( 1 )
    {
        // Try to get a chunk
        __try
        {
            sc = m_pIFilter->GetChunk( &m_CurrentChunkStats );
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            m_pLog->Log( TLS_TEST | TL_SEV1, L"Exception 0x%08X occured in"
                       L" GetChunk(). Consistency Test is quitting.",
                       GetExceptionCode() );
            return;
        }

        // Break if sc is FILTER_E_END_OF_CHUNKS
        if( FILTER_E_END_OF_CHUNKS == sc )
            break;

        if( FILTER_E_EMBEDDING_UNAVAILABLE == sc )
            continue;

        if( FILTER_E_LINK_UNAVAILABLE == sc)
            continue;

        if( FILTER_E_PASSWORD == sc )
            continue;

        if( FILTER_E_ACCESS == sc )
            break;

        if( FAILED( sc ) )
        {
            m_pLog->Log( TLS_TEST | TL_SEV1, L"GetChunk() failed for unknown"
                       L" reason. The return code is 0x%08x", sc );
            return;
        }
        else
        {
            m_pLog->Log( TLS_TEST | TL_PASS, L"GetChunk() succeeded after "
                       L"reinitialization" );
        }

        // Otherwise, we have a valid chunk.

        // See if we have more nodes in the list to compare to:
        if( NULL == CurrentListNode )
        {
            m_pLog->Log( TLS_TEST | TL_SEV1, L"Upon reinitialization of the"
                       L" filter, an extra chunk has been emitted that was"
                       L" not emitted previously." );
            m_pLog->Log( TLS_TEST | TL_INFO, L"Chunk structure found:" );
            LogChunkStats( m_CurrentChunkStats );
            continue;
        }
        else
        {
            // No message needs to be displayed here
        }

        // Make sure the Current chunk statistics are the same as those
        // in the list.  Here I am using the != operator overloaded for
        // CStatChunk
        if( CurrentListNode->ChunkStats != m_CurrentChunkStats )
        {
            m_pLog->Log( TLS_TEST | TL_SEV1, L"Upon reinitialization of the"
                       L" filter, a chunk has been emitted that does not"
                       L" exactly match the corresponding chunk emitted"
                       L" previously." );
            m_pLog->Log( TLS_TEST | TL_INFO, L"Chunk structure expected:" );
            LogChunkStats( CurrentListNode->ChunkStats );
            m_pLog->Log( TLS_TEST | TL_INFO, L"Chunk structure found:" );
            LogChunkStats( m_CurrentChunkStats );
        }
        else
        {
            m_pLog->Log( TLS_TEST | TL_PASS, L"Upon reinitialization of the"
                       L" filter, the chunk structure returned exactly matches"
                       L" the chunk structure returned earlier." );
        }

        // Advance the CurrentListNode pointer
        CurrentListNode = CurrentListNode->next;

    }

    // BUGBUG Final call to GetChunk should not change m_CurrentChunkStats

    // No more chunks will be emitted.
    // Make sure we are at the end of of the list:
    if( NULL != CurrentListNode )
    {
        m_pLog->Log( TLS_TEST | TL_SEV1, L"Upon reinitialization of the filter,"
                   L" fewer chunks were emitted than were emitted"
                   L" previously." );
        while( NULL != CurrentListNode )
        {
            m_pLog->Log( TLS_TEST | TL_INFO, L"Chunk structure expected:" );
            LogChunkStats( CurrentListNode->ChunkStats );
            CurrentListNode = CurrentListNode->next;
        }
    }
    else
    {
        m_pLog->Log( TLS_TEST | TL_PASS, L"Upon reinitialization of the filter,"
                   L" the same number of chunks were emitted than were"
                   L" emmitted previously." );
    }


} //CFiltTest::ConsistencyTest

//+---------------------------------------------------------------------------
//
//  Member:     CFiltTest::IllegitimacyTest
//
//  Synopsis:   Called from ExecuteTests() after reinitializing the filter.
//              Call GetChunk(), validate the chunk structures again, then
//              call GetTextfromValueChunk() and GetValueFromTextChunk() to
//              make sure the filter is well-behaved.
//
//  Arguments:  (none)
//
//  Returns:    none
//
//  History:    9-19-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CFiltTest::IllegitimacyTest( )
{
    // This function does unexpected things to the filter and checks
    // return codes for compliance with the IFilter spec.

    SCODE sc = S_OK;
    CListNode *CurrentListNode = m_ChunkStatsListHead.next;

    // Debug version only
    _ASSERT( m_fIsInitialized );

    m_pLog->Log( TLS_TEST | TL_INFO, L"Performing the invalid input test."
               L" The filter has been reinitialized and the test will now"
               L" make inappropriate IFilter method calls and verify the"
               L" return codes.  In addition, it will double-check the"
               L" chunk structures returned by GetChunk()." );

    // Break out of this loop when GetChunk() returns FILTER_E_END_OF_CHUNKS
    while( 1 )
    {
        // Try to get a chunk
        __try
        {
            sc = m_pIFilter->GetChunk( &m_CurrentChunkStats );
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            m_pLog->Log( TLS_TEST | TL_SEV1, L"Exception 0x%08X occured in"
                       L" GetChunk(). Invalid Input Test is quitting.",
                       GetExceptionCode() );
            return;
        }

        // Break if sc is FILTER_E_END_OF_CHUNKS
        if( FILTER_E_END_OF_CHUNKS == sc )
            break;

        if( FILTER_E_EMBEDDING_UNAVAILABLE == sc )
            continue;

        if( FILTER_E_LINK_UNAVAILABLE == sc)
            continue;

        if( FILTER_E_PASSWORD == sc )
            continue;

        if( FILTER_E_ACCESS == sc )
            break;

        if( FAILED( sc ) )
        {
            m_pLog->Log( TLS_TEST | TL_SEV1, L"GetChunk() failed for unknown"
                       L" reason. The return code is 0x%08x", sc );
            return;
        }
        else
        {
            m_pLog->Log( TLS_TEST | TL_PASS, L"Upon reinitilization of the"
                       L" filter,GetChunk() succeeded." );
        }

        // Otherwise, we have a valid chunk.

        // See if we have more nodes in the list to compare to:
        if( NULL == CurrentListNode )
        {
            m_pLog->Log( TLS_TEST | TL_SEV1, L"Upon reinitialization of the"
                       L" filter, an extra chunk has been emitted that was"
                       L" not emitted previously." );
            m_pLog->Log( TLS_TEST | TL_INFO, L"Chunk structure found:" );
            LogChunkStats( m_CurrentChunkStats );
            continue;
        }
        else
        {
            // No message needs to be displayed here
        }

        // Make sure the Current chunk statistics are the same as those
        // in the list.  Here I am using the != operator overloaded for
        // CStatChunk
        if( CurrentListNode->ChunkStats != m_CurrentChunkStats )
        {
            m_pLog->Log( TLS_TEST | TL_SEV1, L"Upon reinitialization of the filt"
                       L"er, a chunk has been emitted that does not exactly"
                       L" match the corresponding chunk emitted previously." );
            m_pLog->Log( TLS_TEST | TL_INFO, L"Chunk structure expected:" );
            LogChunkStats( CurrentListNode->ChunkStats );
            m_pLog->Log( TLS_TEST | TL_INFO, L"Chunk structure found:" );
            LogChunkStats( m_CurrentChunkStats );
        }
        else
        {
            m_pLog->Log( TLS_TEST | TL_PASS, L"Upon reinitilization of the filter"
                       L", the chunk structure returned by GetChunk() exactly"
                       L" matches the chunk structure returned earlier." );
        }

        // Advance the CurrentListNode pointer
        CurrentListNode = CurrentListNode->next;

        // See if we have text or a property
        if( CHUNK_VALUE == m_CurrentChunkStats.flags )
            m_fIsText = FALSE;
        else
            m_fIsText = TRUE;

        // Call the appropriate functions:
        if( m_fIsText )
            GetValueFromTextChunk( );
        else
            GetTextFromValueChunk( );

    }

    // BUGBUG Final call to GetChunk should not change m_CurrentChunkStats

    // No more chunks will be emitted.
    // Make sure we are at the end of of the list:
    if( NULL != CurrentListNode )
    {
        m_pLog->Log( TLS_TEST | TL_SEV1, L"Upon reinitialization of the filter,"
                   L" fewer chunks were emitted than were emitted previously.");
        while( NULL != CurrentListNode )
        {
            m_pLog->Log( TLS_TEST | TL_INFO, L"Chunk structure expected:" );
            LogChunkStats( CurrentListNode->ChunkStats );
            CurrentListNode = CurrentListNode->next;
        }
    }
    else
    {
        m_pLog->Log( TLS_TEST | TL_PASS, L"Upon reinitialization of the filter,"
                   L" the same number of chunks were emitted as were emitted"
                   L" previously." );
    }

    // Make another call to GetChunk() to make sure it still returns
    // FILTER_E_END_OF_CHUNKS
    __try
    {
        sc = m_pIFilter->GetChunk( &m_CurrentChunkStats );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        m_pLog->Log( TLS_TEST | TL_SEV1, L"Exception 0x%08X occured in GetChunk()"
                   L" Consistency Test is quitting.", GetExceptionCode() );
        return;
    }

    if( FILTER_E_END_OF_CHUNKS != sc )
    {
        m_pLog->Log( TLS_TEST | TL_SEV1, L"Called GetChunk() one extra time"
                   L" after end of chunks.  Expected FILTER_E_END_OF_CHUNKS."
                   L" Return code is 0x%08x", sc );
    }
    else
    {
        m_pLog->Log( TLS_TEST | TL_PASS, L"Calling GetChunk() after end of"
                   L" chunks returned FILTER_E_END_OF_CHUNKS." );
    }

    // BUGBUG Final call to GetChunk should not change m_CurrentChunkStats

} //CFiltTest::IllegitimacyTest

//+---------------------------------------------------------------------------
//
//  Member:     CFiltTest::GetValueFromTextChunk
//
//  Synopsis:   Called from IllegitimacyTest() to see if anything unexpected
//              happens when we try to get a value from a chunk that contains
//              text.
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    9-19-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CFiltTest::GetValueFromTextChunk( )
{
    // This function is used by the illegitimacy function to verify
    // that unexpected things don't happen when GetValue() is called
    // on a chunk containing text

    BOOL        fIsFirstTime = FALSE;
    SCODE       sc = S_OK;
    ULONG       ulBufferCount = BUFFER_SIZE;
    PROPVARIANT *pPropValue = NULL;

    // Debug version only
    _ASSERT( m_fIsText );
    _ASSERT( m_fIsInitialized );

    // try-finally block to simplify clean-up
    __try
    {

        // Try to get a value
        __try
        {
            sc = m_pIFilter->GetValue( &pPropValue );
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            m_pLog->Log( TLS_TEST | TL_SEV1, L"Exception 0x%08X occured in"
                       L" GetValue().", GetExceptionCode() );
            __leave;
        }

        // Make sure we got the correct return code
        if( FILTER_E_NO_VALUES != sc )
        {
            m_pLog->Log( TLS_TEST | TL_SEV1, L"Called GetValue() on a text"
                       L" chunk. Expected FILTER_E_NO_VALUES to be returned."
                       L" Return value is 0x%08x", sc );
            LogChunkStats( m_CurrentChunkStats );
        }
        else
        {
            m_pLog->Log( TLS_TEST | TL_PASS, L"GetValue() on a text chunk"
                       L" returned FILTER_E_NO_VALUES." );
        }

        // Make sure a PROPVARIANT was not allocated
        if( pPropValue )
        {
            m_pLog->Log( TLS_TEST | TL_SEV1, L"Called GetValue() on a text chunk."
                       L" GetValue() erroneously allocated a PROPVARIANT." );
            LogChunkStats( m_CurrentChunkStats );
            FreePropVariant( pPropValue );
            pPropValue = NULL;
        }
        else
        {
            m_pLog->Log( TLS_TEST | TL_PASS, L"GetValue() on a text chunk did"
                       L" not allocate a PROPVARIANT." );
        }


        // Make sure calls to GetText() will now succeed

        // Break when GetText() returns FILTER_E_NO_MORE_TEXT
        while( 1 )
        {

            // Reset ulBufferCount
            ulBufferCount = BUFFER_SIZE;

            // First call to GetText() should not return FILTER_E_NO_MORE_TEXT
            __try
            {
                sc = m_pIFilter->GetText( &ulBufferCount, m_pwcTextBuffer );
            }
            __except( EXCEPTION_EXECUTE_HANDLER )
            {
                m_pLog->Log( TLS_TEST | TL_SEV1, L"After calling GetValue() on"
                           L" a text chunk, a call to GetText() produced"
                           L" exception 0x%08X", GetExceptionCode() );
                __leave;
            }

            // If no more text, break
            if( FILTER_E_NO_MORE_TEXT == sc )
            {
                // If this is the first time through loop, display warning
//              if( fIsFirstTime )
//              {
//                  m_pLog->Log( TLS_TEST | TL_WARN, L"First call to GetText()"
//                             L" after calling GetValue() on a text chunk"
//                             L" returned FILTER_E_NO_MORE_TEXT." );
//              }
                break;
            }

            // Set the "fisrt time" flag
            fIsFirstTime = FALSE;

            // See if the call failed
            if( FAILED( sc ) )
            {
                m_pLog->Log( TLS_TEST | TL_SEV1, L"After calling GetValue() on a"
                           L" text chunk, the call to GetText() failed."
                           L" The return value is 0x%08x", sc );
                __leave;
            }
            else
            {
                m_pLog->Log( TLS_TEST | TL_PASS, L"After calling GetValue() on a"
                           L" text chunk, the call to GetText() succeeded." );
            }

            // Make sure ulBufferCount is <= what it was before the call
            if( ulBufferCount > BUFFER_SIZE )
            {
                m_pLog->Log( TLS_TEST | TL_SEV1, L"After calling GetValue() on a"
                           L" text chunk, I called GetText() and checked the"
                           L" value of *pcwcBuffer. Expected: *pcwcBuffer <="
                           L" value prior to call. Found: *pcwcBuffer > value"
                           L" prior to call." );
            }
            else
            {
                m_pLog->Log( TLS_TEST | TL_PASS, L"After call to GetText(), *pcwc"
                           L"Buffer is <= its value prior to the call" );
            }

        }

        // BUGBUG Check to make sure the last call to GetText() didn't change
        // ulBufferCount or m_pwcTextBuffer

        // Call GetText() one more time to make sure it does the right thing
        __try
        {
            sc = m_pIFilter->GetText( &ulBufferCount, m_pwcTextBuffer );
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            m_pLog->Log( TLS_TEST | TL_SEV1, L"Calling GetText() after it"
                       L" returned FILTER_E_NO_MORE_TEXT resulted in"
                       L" exception 0x%08X", GetExceptionCode() );
            __leave;
        }

        if( FILTER_E_NO_MORE_TEXT == sc )
        {
            m_pLog->Log( TLS_TEST | TL_PASS, L"After GetText() returned"
                       L" FILTER_E_NO_MORE_TEXT, another call to GetText()"
                       L" still returned FILTER_E_NO_MORE_TEXT." );
        }
        else if( E_INVALIDARG == sc )
        {
            m_pLog->Log( TLS_TEST | TL_PASS, L"After GetText() returned"
                       L" FILTER_E_NO_MORE_TEXT, another call to GetText()"
                       L" returned E_INVALIDARG", sc );
        }
        else
        {
            m_pLog->Log( TLS_TEST | TL_SEV1, L"After GetText() returned"
                       L" FILTER_E_NO_MORE_TEXT, another call to GetText()"
                       L" returned 0x%08x", sc );
        }

        // BUGBUG Check to make sure the last call to GetText() didn't change
        // ulBufferCount or m_pwcTextBuffer

    }

    __finally
    {

        // Make sure there were no unhandled exceptions in the try block.
        _ASSERT( ! AbnormalTermination() );

        // Clean up the heap
        if( pPropValue )
            FreePropVariant( pPropValue );

    }

} //CFiltTest::GetValueFromTextChunk

//+---------------------------------------------------------------------------
//
//  Member:     CFiltTest::GetTextFromValueChunk
//
//  Synopsis:   Called from IllegitimacyTest() to see if anything unexpected
//              happens when we try to get text from a chunk that contains a
//              value.
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    9-19-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CFiltTest::GetTextFromValueChunk( )
{
    // This function is used by the illegitimacy test to verify
    // that unexpected behavior does not occur when GetText is called
    // on a chunk that contains a value

    SCODE       sc = S_OK;
    WCHAR       *pwcTempBuffer = NULL;
    ULONG       ulBufferCount = BUFFER_SIZE;
    PROPVARIANT *pPropValue = NULL;

    // Debug version only
    _ASSERT( ! m_fIsText );
    _ASSERT( m_fIsInitialized );

    // Try-finally block to simplify clean-up
    __try
    {

        // Allocate space for the temp buffer
        pwcTempBuffer = NEW WCHAR[ BUFFER_SIZE ];

        // Fill the temp buffer with a known garbage value
        memset( (void*) pwcTempBuffer, (int)0xCC, BUFFER_SIZE * sizeof(WCHAR) );

        // Copy the contents of the temp buffer into the TextBuffer
        memcpy( (void*) m_pwcTextBuffer, (void*) pwcTempBuffer,
                BUFFER_SIZE * sizeof(WCHAR) );

        // Call GetText on the value chunk
        __try
        {
            sc = m_pIFilter->GetText( &ulBufferCount, m_pwcTextBuffer );
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            m_pLog->Log( TLS_TEST | TL_SEV1, L"Called GetText() on a chunk"
                       L" containing a value.  Exception 0x%08X occured in"
                       L" GetText().", GetExceptionCode() );
            __leave;
        }

        // Make sure we got the correct return value
        if( FILTER_E_NO_TEXT != sc )
        {
            m_pLog->Log( TLS_TEST | TL_SEV1, L"Called GetText() on a value"
                       L" chunk. Expected FILTER_E_NO_TEXT to be returned."
                       L" Return value is 0x%08x", sc );
            LogChunkStats( m_CurrentChunkStats );
        }
        else
        {
            m_pLog->Log( TLS_TEST | TL_PASS, L"Called GetText() on a value"
                       L" chunk. FILTER_E_NO_TEXT was returned." );
        }

        // Make sure ulBufferCount was not modified
        if( BUFFER_SIZE != ulBufferCount )
        {
            m_pLog->Log( TLS_TEST | TL_WARN, L"Called GetText() on a chunk"
                       L" containing a value. GetText() erroneously"
                       L" modified pcwcBuffer." );
        }

        // Make sure the Buffer was not modified
        if( 0 != memcmp( (void*) m_pwcTextBuffer, (void*) pwcTempBuffer,
                         BUFFER_SIZE * sizeof(WCHAR) ) )
        {
            m_pLog->Log( TLS_TEST | TL_WARN, L"Called GetText() on a chunk"
                       L" containing a value. GetText() erroneously"
                       L" modified awcBuffer." );
        }

        // Try to get a value
        __try
        {
            sc = m_pIFilter->GetValue( &pPropValue );
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            m_pLog->Log( TLS_TEST | TL_SEV1, L"After calling GetText() on a"
                       L" chunk containing a value, a call to GetValue()"
                       L" procuced exception 0x%08X", GetExceptionCode() );
            __leave;
        }

        // First call to GetValue() should not return FILTER_E_NO_MORE_VALUES
        if( FILTER_E_NO_MORE_VALUES == sc )
        {
            m_pLog->Log( TLS_TEST | TL_WARN, L"First call to GetValue() after"
                       L" calling GetText() on a value chunk returned"
                       L" FILTER_E_NO_MORE_VALUES." );
            __leave;
        }

        // The call should have succeeded
        if( FAILED( sc ) )
        {
            m_pLog->Log( TLS_TEST | TL_SEV1, L"After calling GetText() on a chunk"
                   L" containing a value, a call to GetValue() failed."
                   L" The return code is 0x%08x", sc );
            __leave;
        }
        else
        {
            m_pLog->Log( TLS_TEST | TL_PASS, L"After calling GetText() on a chunk"
                       L" containing a value, calling GetValue() succeeded." );
        }

        // Make sure we have a valid PROPVARIANT
        if( NULL == pPropValue )
        {
            m_pLog->Log( TLS_TEST | TL_SEV1, L"After calling GetText() on a chunk"
                       L" containing a value, GetValue() failed to allocate"
                       L" a PROPVARIANT." );
        }
        else
        {
            m_pLog->Log( TLS_TEST | TL_PASS, L"After calling GetText() on a chunk"
                       L" containing a value, GetValue() successfully"
                       L" allocated a PROPVARIANT." );
            // free the memory, since we will be calling GetValue again
            FreePropVariant( pPropValue );
            pPropValue = NULL;
        }

        // Another call to GetValue() should return FILTER_E_NO_MORE_VALUES
        __try
        {
            sc = m_pIFilter->GetValue( &pPropValue );
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            m_pLog->Log( TLS_TEST | TL_SEV1, L"I called GetText() on a value"
                       L" chunk. I then called GetValue() twice.  The second"
                       L" call produced exception 0x%08X", GetExceptionCode() );
            __leave;
        }

        if( FILTER_E_NO_MORE_VALUES != sc )
        {
            m_pLog->Log( TLS_TEST | TL_WARN, L"I called GetText() on a value"
                       L" chunk. Then, I called GetValue() twice, expecting"
                       L" FILTER_E_NO_MORE_VALUES. GetValue() returned 0x%08x",
                       sc );
        }

        // Check that GetValue() did not allocate a pPropValue
        if( pPropValue )
        {
            m_pLog->Log( TLS_TEST | TL_WARN, L"I called GetText() on a value"
                       L" chunk. Then, I called GetValue() twice, expecting"
                       L" FILTER_E_NO_MORE_VALUES. In the second call, a"
                       L" PROPVARIANT was erroneously allocated." );
            FreePropVariant( pPropValue );
            pPropValue = NULL;
        }

    } // try

    __finally
    {
        // Make sure no unhandled exceptions occured in the try block
        _ASSERT( ! AbnormalTermination() );

        // Clean up the heap
        if( pPropValue )
            FreePropVariant( pPropValue );
        if( pwcTempBuffer )
            delete [] pwcTempBuffer;
    }

} //CFiltTest::GetTextFromValueChunk

//+---------------------------------------------------------------------------
//
//  Member:     CFiltTest::LogConfiguration
//
//  Synopsis:   Displays the configuration to  pFileStream in ANSI
//
//  Arguments:  [config] -- the configuration to be displayed
//              [pFileStream] - FILE* to which the output is directed
//
//  Returns:    none
//
//  History:    9-25-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CFiltTest::LogConfiguration( const CONFIG & config )
{
    TCHAR   szGuidBuffer[ GuidBufferSize ];
    UINT    uiLoop = 0;

    m_pLog->Log( TLS_TEST | TL_INFO, L"Section name : %s", config.szSectionName);

    // display grfFlags
    m_pLog->Log( TLS_TEST | TL_INFO, L"grfFlags     : %d", config.grfFlags );

    // display the attribute count
    m_pLog->Log( TLS_TEST | TL_INFO, L"cAttributes  : %d", config.cAttributes );

    // If there are no atributes, say so
    if( 0 == config.ulActNbrAttributes )
    {
        m_pLog->Log( TLS_TEST | TL_INFO, L"aAttributes  : NONE" );
    }
    // Otherwise, display all the attributes
    for( uiLoop = 0; uiLoop < config.ulActNbrAttributes; uiLoop++ )
    {
        m_pLog->Log( TLS_TEST | TL_INFO, L"Attribute %d:", uiLoop + 1 );

        GetStringFromCLSID( config.aAttributes[ uiLoop ].guidPropSet,
                            szGuidBuffer, GuidBufferSize );

        m_pLog->Log( TLS_TEST | TL_INFO, L"\tGUID   : %s", szGuidBuffer );

        if( PRSPEC_PROPID == config.aAttributes[ uiLoop ].psProperty.ulKind )
        {
            m_pLog->Log( TLS_TEST | TL_INFO, L"\tPROPID : 0x%08x",
                      config.aAttributes[ uiLoop ].psProperty.propid );
        }
        else
        {
            // Display the lpwstr
            m_pLog->Log( TLS_TEST | TL_INFO, L"\tLPWSTR : %ls",
                      config.aAttributes[ uiLoop ].psProperty.lpwstr );
        }
    }

    // display pdwFlags
    m_pLog->Log( TLS_TEST | TL_INFO, L"pdwFlags     : %d", *config.pdwFlags );

} //CFiltTest::LogConfiguration

//+---------------------------------------------------------------------------
//
//  Member:     CFiltTest::DisplayChunkStats
//
//  Synopsis:   Displays the structure of the chunk passed in ChunkStats
//
//  Arguments:  [ChunkStats] -- STAT_CHUNK containing the information for
//                              the chunk to be displayed.
//              [pFileStream] - FILE* to which the output is directed
//
//  Returns:    none
//
//  History:    9-19-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CFiltTest::DisplayChunkStats( const STAT_CHUNK &ChunkStats,
                                   FILE *  pFileStream )
{
    TCHAR szGuidBuffer[ GuidBufferSize ];

    // Only print the chunk state if the verbosity is HIGH
    if( HIGH  > m_verbosity || NULL == pFileStream )
        return;

    // Insert a blank line
    fwprintf( pFileStream, L"\r\nChunk statistics:\r\n" );

    // Print the chunk id
    fwprintf( pFileStream, L"Chunk ID: ........... %d\r\n", ChunkStats.idChunk);

    // Print the break type (in English if possible)
    if( CHUNK_NO_BREAK > ChunkStats.breakType ||
        CHUNK_EOC      < ChunkStats.breakType )  // not legal
    {
        fwprintf( pFileStream, L"Illegal Break Type: . %d\r\n",
                  ChunkStats.breakType );
    }
    else
    {
        fwprintf( pFileStream, L"Chunk Break Type: ... %ls\r\n",
                  BreakType[ ChunkStats.breakType ] );
    }

    // Print the Chunk state (in English if possible)
    if( CHUNK_TEXT == ChunkStats.flags || CHUNK_VALUE == ChunkStats.flags)
    {
        fwprintf( pFileStream, L"Chunk State: ........ %ls\r\n",
                  ChunkState[ ChunkStats.flags - 1 ] );
    }
    else
    {
        fwprintf( pFileStream, L"Bad Chunk State: .... %d\r\n",
                  ChunkStats.flags );
    }

    // Print the locale
    fwprintf( pFileStream, L"Chunk Locale: ....... 0x%08x\r\n",
              ChunkStats.locale );

    // Print the Chunk id source
    fwprintf( pFileStream, L"Chunk Source ID: .... %d\r\n",
              ChunkStats.idChunkSource );

    // Print the start source
    fwprintf( pFileStream, L"Chunk Start Source .. 0x%08x\r\n",
              ChunkStats.cwcStartSource );

    // Print the length source
    fwprintf( pFileStream, L"Chunk Length Source . 0x%08x\r\n",
              ChunkStats.cwcLenSource );

    // Display the guid
    GetStringFromCLSID( ChunkStats.attribute.guidPropSet, szGuidBuffer,
                        GuidBufferSize );
    _ftprintf( pFileStream, _T("GUID ................ %s\r\n"), szGuidBuffer );

    // Display the contents of the PROPSPEC field (careful of the union)
    if( PRSPEC_LPWSTR == ChunkStats.attribute.psProperty.ulKind )
    {
        fwprintf( pFileStream, L"Property name ....... %ls\r\n",
                  ChunkStats.attribute.psProperty.lpwstr );
    }
    else if( PRSPEC_PROPID == ChunkStats.attribute.psProperty.ulKind )
    {
        fwprintf( pFileStream, L"Property ID ......... 0x%08x\r\n",
                  ChunkStats.attribute.psProperty.propid );
    }
    else
    {
        fwprintf( pFileStream, L"Bad ulKind field .... %d\r\n",
                  ChunkStats.attribute.psProperty.ulKind );
    }

    // Insert a blank line
    fwprintf( pFileStream, L"\r\n" );


} //CFiltTest::DisplayChunkStats

//+---------------------------------------------------------------------------
//
//  Member:     CFiltTest::LogChunkStats
//
//  Synopsis:
//
//  Arguments:  [ChunkStats] --
//
//  Returns:
//
//  History:    2-03-1997   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CFiltTest::LogChunkStats( const STAT_CHUNK & ChunkStats )
{
    TCHAR szGuidBuffer[ GuidBufferSize ];

    // Insert a blank line
    m_pLog->Log( TLS_TEST | TL_INFO, L"Chunk statistics:" );

    // Print the chunk id
    m_pLog->Log( TLS_TEST | TL_INFO, L"Chunk ID: ........... %d",
                 ChunkStats.idChunk);

    // Print the break type (in English if possible)
    if( CHUNK_NO_BREAK > ChunkStats.breakType ||
        CHUNK_EOC      < ChunkStats.breakType )  // not legal
    {
        m_pLog->Log( TLS_TEST | TL_INFO, L"Illegal Break Type: . %d",
                     ChunkStats.breakType );
    }
    else
    {
        m_pLog->Log( TLS_TEST | TL_INFO, L"Chunk Break Type: ... %ls",
                     BreakType[ ChunkStats.breakType ] );
    }

    // Print the Chunk state (in English if possible)
    if( CHUNK_TEXT == ChunkStats.flags || CHUNK_VALUE == ChunkStats.flags)
    {
        m_pLog->Log( TLS_TEST | TL_INFO, L"Chunk State: ........ %ls",
                     ChunkState[ ChunkStats.flags - 1 ] );
    }
    else
    {
        m_pLog->Log( TLS_TEST | TL_INFO, L"Bad Chunk State: .... %d",
                     ChunkStats.flags );
    }

    // Print the locale
    m_pLog->Log( TLS_TEST | TL_INFO, L"Chunk Locale: ....... 0x%08x",
                 ChunkStats.locale );

    // Print the Chunk id source
    m_pLog->Log( TLS_TEST | TL_INFO, L"Chunk Source ID: .... %d",
                 ChunkStats.idChunkSource );

    // Print the start source
    m_pLog->Log( TLS_TEST | TL_INFO, L"Chunk Start Source .. 0x%08x",
                 ChunkStats.cwcStartSource );

    // Print the length source
    m_pLog->Log( TLS_TEST | TL_INFO, L"Chunk Length Source . 0x%08x",
                 ChunkStats.cwcLenSource );

    // Display the guid
    GetStringFromCLSID( ChunkStats.attribute.guidPropSet, szGuidBuffer,
                        GuidBufferSize );
    m_pLog->Log( TLS_TEST | TL_INFO, L"GUID ................ %s",
                 szGuidBuffer );

    // Display the contents of the PROPSPEC field (careful of the union)
    if( PRSPEC_LPWSTR == ChunkStats.attribute.psProperty.ulKind )
    {
        m_pLog->Log( TLS_TEST | TL_INFO, L"Property name ....... %ls",
                     ChunkStats.attribute.psProperty.lpwstr );
    }
    else if( PRSPEC_PROPID == ChunkStats.attribute.psProperty.ulKind )
    {
        m_pLog->Log( TLS_TEST | TL_INFO, L"Property ID ......... 0x%08x",
                     ChunkStats.attribute.psProperty.propid );
    }
    else
    {
        m_pLog->Log( TLS_TEST | TL_INFO, L"Bad ulKind field .... %d",
                     ChunkStats.attribute.psProperty.ulKind );
    }

} //CFiltTest::LogChunkStats


//+---------------------------------------------------------------------------
//
//  Member:     CFiltTest::DisplayText
//
//  Synopsis:   Either dumps the text to a Unicode file, or converts the text
//              to ASCII and displays dumps it to the console
//
//  Arguments:  [pwcTextBuffer] -- Wide character buffer storing the text
//              [pFileStream] ---- FILE* to which the output is directed
//
//  Returns:    none
//
//  History:    9-20-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CFiltTest::DisplayText( const WCHAR * pwcTextBuffer,
                                    FILE * pFileStream )
{
    int iLoop = 0;

    if( NULL == pFileStream )
        return;

    for( iLoop = 0; pwcTextBuffer[ iLoop ]; iLoop++ )
    {
        // Handle the return characters correctly
        if( 0x000A == pwcTextBuffer[ iLoop ] )
            fwprintf( pFileStream, L"\r\n" );
        else
            fputwc( pwcTextBuffer[ iLoop ], pFileStream );
    }
    //fwprintf( pFileStream, L"\r\n\r\n" );

} //CFiltTest::DisplayText

//+---------------------------------------------------------------------------
//
//  Member:     CFiltTest::DisplayValue
//
//  Synopsis:   Dumps the value to the screen or to the log file
//
//  Arguments:  [pPropValue] -- PROPVARIANT structure
//              [pFileStream] - FILE* to which the output is directed
//
//  Returns:    void
//
//  History:    9-20-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CFiltTest::DisplayValue( const PROPVARIANT * pPropValue,
                              FILE * pFileStream )
{

    ULONG ul=0;     // Loop counter for VT_ARRAY values

    if( NULL == pFileStream )
        return;

    // Display the property
    fwprintf( pFileStream, L"\r\n" );

    switch( pPropValue->vt )
    {
        case VT_EMPTY:
        case VT_NULL:
        case VT_ILLEGAL:
            m_pLog->Log( TLS_TEST | TL_SEV1, L"GetValue() returned a PROPVARIANT"
                       L" with an invalid vt field.  The value of the"
                       L" field is 0x%08x", pPropValue->vt );
            break;

        // Here are some non-vector cases

        case VT_UI1:
            fwprintf( pFileStream, L"0x%02hx\r\n", (USHORT)pPropValue->bVal );
            break;

        case VT_I2:
            fwprintf( pFileStream, L"0x%04hx\r\n", pPropValue->iVal );
            break;

        case VT_UI2:
            fwprintf( pFileStream, L"0x%04hx\r\n", pPropValue->uiVal );
            break;

        case VT_I4:
            fwprintf( pFileStream, L"0x%08x\r\n", pPropValue->lVal );
            break;

        case VT_UI4:
            fwprintf( pFileStream, L"0x%08x\r\n", pPropValue->ulVal );
            break;

        case VT_I8:
            fwprintf( pFileStream, L"0x%016I64x\r\n", pPropValue->hVal );
            break;

        case VT_UI8:
            fwprintf( pFileStream, L"0x%016I64x\r\n", pPropValue->uhVal );
            break;

        case VT_R4:
            fwprintf( pFileStream, L"%g\r\n", (double)pPropValue->fltVal );
            break;

        case VT_R8:
            fwprintf( pFileStream, L"%g\r\n", pPropValue->dblVal );
            break;

        case VT_LPWSTR:
            fwprintf( pFileStream, L"%ls\r\n", pPropValue->pwszVal );
            break;

        case VT_LPSTR:
            fwprintf( pFileStream, L"%hs\r\n", pPropValue->pszVal );
            break;

        case VT_BSTR:
            fwprintf( pFileStream, L"%ls\r\n", pPropValue->bstrVal );
            break;

        // Here are the vector cases:

        case VT_VECTOR | VT_UI1:
            for( ul=0; ul<pPropValue->caub.cElems; ul++ )
                fwprintf( pFileStream, L"0x%02hx\r\n",
                          (USHORT)pPropValue->caub.pElems[ul] );
            break;

        case VT_VECTOR | VT_I2:
            for( ul=0; ul<pPropValue->cai.cElems; ul++ )
                fwprintf( pFileStream, L"0x%04hx\r\n",
                          pPropValue->cai.pElems[ul] );
            break;

        case VT_VECTOR | VT_UI2:
            for( ul=0; ul<pPropValue->caui.cElems; ul++ )
                fwprintf( pFileStream, L"0x%04hx\r\n",
                          pPropValue->caui.pElems[ul] );
            break;

        case VT_VECTOR | VT_I4:
            for( ul=0; ul<pPropValue->cal.cElems; ul++ )
                fwprintf( pFileStream, L"0x%08x\r\n",
                          pPropValue->cal.pElems[ul] );
            break;

        case VT_VECTOR | VT_UI4:
            for( ul=0; ul<pPropValue->caul.cElems; ul++ )
                fwprintf( pFileStream, L"0x%08x\r\n",
                          pPropValue->caul.pElems[ul] );
            break;

        case VT_VECTOR | VT_I8:
            for( ul=0; ul<pPropValue->cah.cElems; ul++ )
                fwprintf( pFileStream, L"0x%016I64x\r\n",
                          pPropValue->cah.pElems[ul] );
            break;

        case VT_VECTOR | VT_UI8:
            for( ul=0; ul<pPropValue->cauh.cElems; ul++ )
                fwprintf( pFileStream, L"0x%016I64x\r\n",
                          pPropValue->cauh.pElems[ul] );
            break;

        case VT_VECTOR | VT_R4:
            for( ul=0; ul<pPropValue->caflt.cElems; ul++ )
                fwprintf( pFileStream, L"%g\r\n",
                          (double)pPropValue->caflt.pElems[ul] );
            break;

        case VT_VECTOR | VT_R8:
            for( ul=0; ul<pPropValue->cadbl.cElems; ul++ )
                fwprintf( pFileStream, L"%g\r\n",
                          pPropValue->cadbl.pElems[ul] );
            break;

        case VT_VECTOR | VT_LPWSTR:
            for( ul=0; ul<pPropValue->calpwstr.cElems; ul++ )
                fwprintf( pFileStream, L"%ls\r\n",
                          pPropValue->calpwstr.pElems[ul] );
            break;

        case VT_VECTOR | VT_LPSTR:
            for( ul=0; ul<pPropValue->calpstr.cElems; ul++ )
                fwprintf( pFileStream, L"%hs\r\n",
                          pPropValue->calpstr.pElems[ul] );
            break;

        case VT_VECTOR | VT_BSTR:
            for( ul=0; ul<pPropValue->cabstr.cElems; ul++ )
                fwprintf( pFileStream, L"%ls\r\n",
                          pPropValue->cabstr.pElems[ul] );
            break;

        default:
            // BUGBUG Lots of other cases to handle.
            m_pLog->Log( TLS_TEST | TL_INFO, L"0x%08x: This property cannot be"
                         L" displayed at this time.", pPropValue->vt );
            break;
    }

    // Insert a blank line
    fwprintf( pFileStream, L"\r\n" );

} //CFiltTest::DisplayValue
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\ifilttst\cmdparse.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       cmdparse.cxx
//
//  Contents:   Member functions implementation of CCmdLineParserA class
//
//  Classes:    
//
//  Functions:  
//
//  History:    11-08-94   SriniG   Created
//              11-22-96   Ericne   Removed CString dependancy, 
//                                  made template, improved efficiency
//
//----------------------------------------------------------------------------

#include "cmdparse.hxx"

// This is a type-safe way of dealing with template character constants
const char  CCmdLineParserTemplate<char>::m_slash = '/';
const char  CCmdLineParserTemplate<char>::m_hyphen = '-';

const WCHAR CCmdLineParserTemplate<WCHAR>::m_slash = L'/';
const WCHAR CCmdLineParserTemplate<WCHAR>::m_hyphen = L'-';

//
// Helper functions
//

inline int StringCompare( const char * szFirst, const char * szSecond )
{
    return strcmp( szFirst, szSecond );
}

inline int StringCompare( const wchar_t * szFirst, const wchar_t * szSecond )
{
    return wcscmp( szFirst, szSecond );
}

//+---------------------------------------------------------------------------
//
//  Function:   CCmdLineParserTemplate
//
//  Synopsis:   Constructor
//
//  Arguments:  [argc] --  The "main" parameter
//              [argv] --  The "main" parameter
//
//  Returns:    
//
//  History:    11-08-94   SriniG   Created
//              11-22-96   Ericne   Removed CString dependancy, 
//                                  made template, improved efficiency
//
//  Notes:      
//
//----------------------------------------------------------------------------

template<class T>
CCmdLineParserTemplate<T>::CCmdLineParserTemplate( int & argc, T **& argv )
    : m_argc( argc ), 
      m_argv( argv )
{
    int iLoop = 0;
    
    // argc and argv are modifiable. Change all switches that start with 
    // m_hyphen to m_slash.
    for( iLoop = 1; iLoop < m_argc; iLoop++ )
    {
        if( m_hyphen == *argv[ iLoop ] )
            *argv[ iLoop ] = m_slash;
    }
}

template<class T>
CCmdLineParserTemplate<T>::~CCmdLineParserTemplate()
{
}

//+---------------------------------------------------------------------------
//
//  Function:   IsFlagExist
//
//  Synopsis:   Checks for the existence of a flag in the cmd line
//
//  Arguments:  [szFlag] -- flag string, don't include m_slash or m_hyphen
//
//  Returns:    True if the flag exists, False if not
//
//  History:    11-08-94   SriniG   Created
//              11-22-96   Ericne   Removed CString dependancy, 
//                                  made template, improved efficiency
//
//  Notes:      
//
//----------------------------------------------------------------------------

template<class T>
BOOL CCmdLineParserTemplate<T>::IsFlagExist( const T * szFlag )
{

    for( int iLoop = 1; iLoop < m_argc; iLoop++ )
    {
        if( ( m_slash == *m_argv[ iLoop ] || m_hyphen == *m_argv[ iLoop ] ) &&
            ( 0 == StringCompare( m_argv[ iLoop ] + 1, szFlag ) ) )
        {
            // Keep track of which params have been referenced
            *m_argv[ iLoop ] = m_hyphen;

            return( TRUE );
        }
    }

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   EnumerateFlag
//
//  Synopsis:   Enumerates the parameters associated with a given flag
//
//  Arguments:  [szFlag] -- The flag
//              [pParams] -- pointer to the array of parameter strings
//              [cCount]  -- Number of parameters associated with the flag.
//
//  Returns:    True if flag exists, False if the flag doesn't
//
//  History:    11-08-94   SriniG   Created
//              11-22-96   Ericne   Removed CString dependancy, 
//                                  made template, improved efficiency
//
//  Notes:      
//
//----------------------------------------------------------------------------
                                                                              
template<class T>
BOOL CCmdLineParserTemplate<T>::EnumerateFlag( const T * szFlag, 
                                               T **& pParams, 
                                               int & nCount )
{
    // Initialize the reference parameters
    pParams = NULL;
    nCount = 0;
    
    // Make sure we have a valid string
    if( NULL == szFlag )
        return( FALSE );

    // Make pParams to point to the first parameter. cCount should give 
    // the number of parameters that follow flag
    for( int iLoop = 1; iLoop < m_argc; iLoop++ )
    {
        if( ( m_slash == *m_argv[ iLoop ] || m_hyphen == *m_argv[ iLoop ] ) &&
            ( 0 == StringCompare( m_argv[ iLoop ] + 1, szFlag ) ) )
        {
            // Keep track of which params have been referenced
            *m_argv[ iLoop ] = m_hyphen;

            // Count the number of parameters following the flag
            for( int jLoop = iLoop + 1; jLoop < m_argc; jLoop++ )
            {
                // BUGBUG can't have a negative number as a parameter.
                if( m_slash == *m_argv[ jLoop ] || 
                    m_hyphen == *m_argv[ jLoop ] )
                    break;
                else
                    ++nCount;
            }
            
            // If we found parameters, set pParams to point to the first
            if( nCount > 0 )
            {
                pParams = m_argv + iLoop + 1;
            }

            // No need to look further
            return( TRUE );
        }
    }

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     ::GetNextFlag
//
//  Synopsis:   Can get the flags in order. Can be used after attempting
//              to retrieve all accepted parameters -- any parameters left over
//              are not recognized
//
//  Arguments:  [szFlag] -- reference to a character pointer
//
//  Returns:    FALSE if there are no more flags to return
//
//  History:    11-22-96   Ericne   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

template<class T>
BOOL CCmdLineParserTemplate<T>::GetNextFlag( T *& szFlag )
{
    // Initialize the reference parameter
    szFlag = NULL;

    // Find the first unreferenced parameter and return a pointer to it
    for( int iLoop = 1; iLoop < m_argc; iLoop++ )
    {
        if( m_slash == *m_argv[ iLoop ] )
        {
            *m_argv[ iLoop ] = m_hyphen;
            szFlag = m_argv[ iLoop ] + 1;
            return( TRUE );
        }
    }
    return( FALSE );
} //::GetNextFlag
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\ifilttst\ifilttst.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       ftest.cxx
//
//  Contents:   Code for launching the filter test
//
//  Classes:    none
//
//  Functions:  main() -------- Processes command line switches, handles
//                              directory filtering
//              usage() ------- Displays a usage message
//              LaunchTest() -- Creates a CFiltTest object, initializes it,
//                              and executes the test
//
//  Coupling:
//
//  Notes:      About allocations:  In this project, the keyword 'new' does
//              no appear explicitely.  Instead, I use a 'NEW' macro.  If the
//              code is compiled with the DEBUG flag, NEW will expand to
//              new( __FILE__, __LINE__ ), which will invoke an overloaded
//              new operator to keeps track of my allocations.  Otherwise,
//              NEW simply expands to 'new'.
//
//              More about allocations: This program uses a newhandler to
//              handle failed allocations. The newhandler loops until enough
//              free memory is available, so every allocation is guaranteed
//              to succeed.
//
//  History:    9-16-1996   ericne   Created
//
//----------------------------------------------------------------------------


#include "pch.cxx"
#include <new.h>
#include <process.h>
#include "clog.hxx"
#include "workq.cxx"
#include "mydebug.hxx"
#include "filttest.hxx"
#include "cmdparse.cxx"
#include "oleinit.hxx"

// Must be compiled with the UNICODE flag
#if ! defined( UNICODE ) && ! defined( _UNICODE )
    #error( "UNICODE must be defined" )
#endif

// Global work queue of size 10
CWorkQueue< WCHAR*, 10 > g_WorkQueue;

// Global parameters
int         g_iDepth            = 1;        // Recursion depth, -1 is full
int         g_cLoops            = 1;        // Loop counter, -1 is loop forever
BOOL        g_fLogToFile        = FALSE;    // TRUE if log should be sent to
BOOL        g_fDumpToFile       = FALSE;
BOOL        g_fIsLoggingEnabled = TRUE;
BOOL        g_fIsDumpingEnabled = TRUE;
BOOL        g_fLegitOnly        = FALSE;
WCHAR      *g_szIniFileName     = L"ifilttst.ini";
CLog       *g_pLog              = NULL;
Verbosity   g_verbosity         = HIGH;

//+---------------------------------------------------------------------------
//
//  Function:   out_of_store
//
//  Synopsis:   A new handeler function.  When new fails, this function gets
//              invoked.  It sleeps for a while and then returns 1, indicating
//              that the allocation should be retried.  In addition, it
//              displays a message so the user knows what's happening.
//
//  Arguments:  [size] -- The size, in bytes, of the memory block to be
//                        allocated
//
//  Returns:    1
//
//  History:    10-03-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

int __cdecl out_of_store( size_t )
{

    printf( "An allocation failed.  Will re-try in %d milliseconds\r\n",
            dwSleepTime );

    Sleep( dwSleepTime );

    return( 1 );

} //out_of_store

//+---------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   Displays a usage message
//
//  Arguments:  [pcExecName] -- name of the executable ( call with argv[0] )
//
//  Returns:    none
//
//  History:    10-01-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void Usage( const WCHAR * szExecName )
{
    printf( "\r\nUSAGE:\r\n" );
    printf( "%ls /i <input file>[...] [/ini <ini file>] [/l [<log file>]] [/d]"
            " [/-l] [/-d] [/legit] [/stress] [/v <verbosity>] [/t <threads>]"
            " [/r [<depth>]] [/c <loops>]\r\n", szExecName );
    printf( "\r\n" );
    printf( "\t<input file> is the file/directory/pattern to which to bind.\r\n"
            "\t\tWildcards are OK. More than one input file is OK.\r\n" );
    printf( "\t<ini file> is the initialization file to use.  If none is\r\n"
            "\t\tspecified, it defaults to ifilttst.ini.\r\n");
    printf( "\t[/l] enables logging to a file. By default, the log filename\r\n"
            "\t\tis the input file name with a .log extension. If you\r\n"
            "\t\tspecify a log file name, all the log messages will be sent\r\n"
            "\t\tto a single file.\r\n");
    printf( "\t[/d] enables dumping to a file.  The dump filename is the\r\n"
            "\t\tinput file name with a .dmp extension.\r\n" );
    printf( "\t[/-l] disables logging.  This flag overrides /l.\r\n" );
    printf( "\t[/-d] disables dumping.  This flag overrides /d.\r\n" );
    printf( "\t[/legit] forces the test to run only the Validation Test.\r\n"
            "\t\tThe Consistency and Invalid Input Tests are skipped.\r\n" );
    printf( "\t[/stress] forces the test to run in stress mode. This is the\r\n"
            "\t\t same as specifying /-l /-d /legit /v 0 /c 0\r\n" );
    printf( "\t<verbosity> is an integer representing the verbosity level\r\n"
            "\t\tAcceptable values are from %d through %d, with %d being the\r\n"
            "\t\tmost verbose. (default is %d)\r\n", MUTE, HIGH, HIGH, HIGH );
    printf( "\t<threads> is an integer representing the number of threads\r\n"
            "\t\tto launch. Only useful if filtering multiple files.\r\n"
            "\t\t(default is 1)\r\n" );
    printf( "\t<depth> is an integer representing the depth to recurse.\r\n"
            "\t\tNo value or a value of 0 indicates full recursion. (default"
            " is 1)\r\n" );
    printf( "\t<loops> is an integer representing the number of times to\r\n"
            "\t\tloop.  A value of 0 means loop infinetly. (default is 1)\r\n");
} //Usage


//+---------------------------------------------------------------------------
//
//  Function:   LaunchTest
//
//  Synopsis:   If necessary, determines what the log and dump file names should
//              be, creates a CFiltTest object, initializes it, and executes the
//              test.
//
//  Arguments:  [szInputFileName] -- Full path to input file
//
//  Returns:    void
//
//  History:    9-26-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void LaunchTest( WCHAR * szInputFileName )
{
    // This function determines the log and dump filenames from the input
    // filename
    WCHAR       *szLogFileName  = NULL;
    WCHAR       *szDumpFileName = NULL;
    CFiltTest   *pThisFiltTest  = NULL;

    // Try-finally block simplifies clean-up
    try
    {
        // If we are logging to a file, create the filename
        if( g_fLogToFile )
        {
            szLogFileName = NEW WCHAR[ MAX_PATH ];

            wcscpy( szLogFileName, szInputFileName );
            wcscat( szLogFileName, L".log" );
        }

        // If we are dumping to a file, create the filename
        if( g_fDumpToFile )
        {
            szDumpFileName = NEW WCHAR[ MAX_PATH ];

            wcscpy( szDumpFileName, szInputFileName );
            wcscat( szDumpFileName, L".dmp" );
        }

        // Create the Filter test object
        pThisFiltTest = NEW CFiltTest( g_pLog );

        if( pThisFiltTest->Init( szInputFileName,
                                 szLogFileName,
                                 szDumpFileName,
                                 g_szIniFileName,
                                 g_verbosity,
                                 g_fLegitOnly ) )
        {
            pThisFiltTest->ExecuteTests( );
        }
    } // _try
    catch(...)
    {
    }

//  _finally
    {
        // Clean up the heap
        if( pThisFiltTest )
            delete pThisFiltTest;

        if( szLogFileName )
            delete [] szLogFileName;

        if( szDumpFileName )
            delete [] szDumpFileName;
    }

} //LaunchTest

//+---------------------------------------------------------------------------
//
//  Function:   FindAllFiles
//
//  Synopsis:   Find all the files that meet the restriction and put them in
//              the queue.
//
//  Arguments:  [szPath] --
//              [iDepth]   --
//
//  Returns:
//
//  History:    10-14-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void FindAllFiles( WCHAR *szPath, int iDepth )
{
    HANDLE hSearch = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FindData;
    WCHAR szNewPath[ MAX_PATH + 2 ];
    WCHAR szNewSearch[ MAX_PATH + 2 ];
    WCHAR *szWorkItem = NULL;

    // Check the depth restriction:
    if( 0 == iDepth )
        return;

    hSearch = FindFirstFile( szPath, &FindData );

    if ( 0 == *szPath )
        return;

    if( INVALID_HANDLE_VALUE != hSearch )
    {
        // Find all the files that match the pattern and put them in the queue
        do
        {
            WCHAR *szExtension = wcsrchr( FindData.cFileName, '.' );

            // If this is a directory, continue
            if( FILE_ATTRIBUTE_DIRECTORY & FindData.dwFileAttributes )
                continue;

            // If the extension equals ".log" or ".dmp", continue
            if( NULL != szExtension &&
                ( 0 == wcscmp( szExtension, L".log" ) ||
                  0 == wcscmp( szExtension, L".dmp" ) ) )
                continue;

            // Copy the path into NewPath
            wcscpy( szNewPath, szPath );

            // Remove the restriction part of the path
            *( wcsrchr( szNewPath, L'\\' ) + 1 ) = L'\0';

            // Append the file name of the matching file
            wcscat( szNewPath, FindData.cFileName );

            // Dynamically create a new work item
            szWorkItem = NEW WCHAR[ wcslen( szNewPath ) + 1 ];

            // Copy the full path into the new work item
            wcscpy( szWorkItem, szNewPath );

            // Put the work item in the queue
            g_WorkQueue.AddItem( szWorkItem );

            // We don't own this item anymore, so set the pointer to NULL
            szWorkItem = NULL;

        } while( FindNextFile( hSearch, &FindData ) );

        // Close the search handle
        FindClose( hSearch );
        hSearch = INVALID_HANDLE_VALUE;
    }

    // Now, recurse into the subdirectories and search for the same pattern.

    // Copy the origional path into a new path for the new search

    wcscpy( szNewSearch, szPath );

    // Remove the restriction
    *( wcsrchr( szNewSearch, L'\\' ) + 1 ) = L'\0';

    // Append a star
    wcscat( szNewSearch, L"*" );

    // Since we're looking for a wildcard, this should succeed
    hSearch = FindFirstFile( szNewSearch, &FindData );

    if( INVALID_HANDLE_VALUE == hSearch )
    {
        return;
    }

    do
    {
        // Recurse into this subdirectory looking for the same pattern

        if( ( FILE_ATTRIBUTE_DIRECTORY & FindData.dwFileAttributes ) &&
            ( 0 != wcscmp( FindData.cFileName, L"." ) ) &&
            ( 0 != wcscmp( FindData.cFileName, L".." ) ) )
        {
            // Copy the search string into NewPath
            wcscpy( szNewPath, szNewSearch );

            // Remove the "*" at the end
            *( wcsrchr( szNewPath, L'\\' ) + 1 ) = L'\0';

            // Append the directory name found
            wcscat( szNewPath, FindData.cFileName );

            // Append a slash
            wcscat( szNewPath, L"\\" );

            // Finally, append the origional search restriction
            wcscat( szNewPath, wcsrchr( szPath, L'\\' ) + 1 );

            // Recurse
            FindAllFiles( szNewPath, iDepth - 1 );
        }
    } while( FindNextFile( hSearch, &FindData ) );

    FindClose( hSearch );

    hSearch = INVALID_HANDLE_VALUE;

} //FindAllFiles

//+---------------------------------------------------------------------------
//
//  Function:   Producer
//
//  Synopsis:   A thread which collects all the input file names and puts them
//              in the work queue
//
//  Arguments:  [lpvThreadParam] -- The input file name
//
//  Returns:    0
//
//  History:    10-01-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

DWORD WINAPI Producer( PVOID pvThreadParam )
{
    WCHAR szFullPath[ MAX_PATH + 2 ];
    DWORD dwAttrib = 0;
    int   cLoops = g_cLoops;

    GetFullPathName( (WCHAR*)pvThreadParam, MAX_PATH, szFullPath, NULL );

    // If the input is recognized as a directory, only recurse into this
    // directory.  Otherwise, recurse into all subdirectories and try to
    // match the pattern

    dwAttrib = GetFileAttributes( szFullPath );

    if( ( 0xFFFFFFFF != dwAttrib ) && ( FILE_ATTRIBUTE_DIRECTORY & dwAttrib ) )
    {
        // It's a directory.  If the last character is a '\\', add "*"
        // Otherwise, add "\\*"
        if( L'\\' == szFullPath[ wcslen( szFullPath ) - 1 ] )
        {
            wcscat( szFullPath, L"*" );
        }
        else
        {
            wcscat( szFullPath, L"\\*" );
        }
    }

    while( cLoops-- )
    {
        FindAllFiles( szFullPath, g_iDepth );
    }

    return( 0 );

} //Producer

//+---------------------------------------------------------------------------
//
//  Function:   Consumer
//
//  Synopsis:   Pulls stuff out of the work queue and calls LaunchTest on the
//              file name.  It is also responsible for deleting the file
//              names it pulls out of the list
//
//  Arguments:  [lpvThreadParam] -- Thread number
//
//  Returns:    0
//
//  History:    10-01-1996   ericne   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

DWORD WINAPI Consumer( PVOID pvThreadParam )
{
    WCHAR *szInputFileName = NULL;
    COleInitialize OleIsInitialized;  // This object ensures OLE is initialized
                                      // for this thread

    while( g_WorkQueue.GetItem( szInputFileName ) )
    {
        // Display which thread is filtering which document
        if( NORMAL <= g_verbosity )
        {
            wprintf(L"Thread %d is filtering %s\r\n",
                    (UINT_PTR)pvThreadParam, szInputFileName );
        }

        LaunchTest( szInputFileName );
        delete [] szInputFileName;
    }

    return( 0 );

} //Consumer

//+---------------------------------------------------------------------------
//
//  Function:   wmain
//
//  Synopsis:   Processes command switches, Launched producer and consumer
//              threads
//
//  Arguments:  [argc] -- The number of command line parameters
//              [argv] -- The value of the command line parameters
//
//  Returns:    0
//
//  History:    10-01-1996   ericne   Created
//
//  Notes:      extern "C" to satisfy the linker
//
//----------------------------------------------------------------------------

extern "C" int __cdecl wmain( int argc, WCHAR **argv )
{
    int             iLoop = 0;
    int             iCount = 0;
    int             iNbrConsumers = 1;
    int             iNbrProducers = 1;
    WCHAR           **ppwcParams = NULL;
    WCHAR           *pwcBadParam = NULL;
    _PNH            pfOldNewHandler = NULL;
    LPCWSTR         *rgszInputFileName;
    TCHAR           szLogFileName[ MAX_PATH ];
    DWORD           dwThreadID = 0;
    HANDLE          *hConsumerThreads = NULL;
    HANDLE          *hProducerThreads = NULL;
    CCmdLineParserW CmdLineParser( argc, argv );


    try
    {
        // Set the new handeler routine
        pfOldNewHandler = _set_new_handler( out_of_store );

        // Check the command line parameters:
        if( CmdLineParser.IsFlagExist( L"?" ) )
        {
            Usage( argv[0] );
            exit( 0 );
        }

        // Find /d flag
        if( CmdLineParser.IsFlagExist( L"d" ) )
            g_fDumpToFile = TRUE;

        // Find /-l flag
        if( CmdLineParser.IsFlagExist( L"-l" ) )
            g_fIsLoggingEnabled = FALSE;

        // Find /-d flag
        if( CmdLineParser.IsFlagExist( L"-d" ) )
            g_fIsDumpingEnabled = FALSE;

        // Find the legit flag
        if( CmdLineParser.IsFlagExist( L"legit" ) )
            g_fLegitOnly = TRUE;

        // Find /i flag
        if( CmdLineParser.EnumerateFlag( L"i", ppwcParams, iCount ) )
        {
            if( 1 > iCount )
            {
                Usage( argv[0] );
                printf( "ERROR: 1 or more input files must be specified\r\n" );
                exit( -1 );
            }

            iNbrProducers = iCount;

            // Create array of file patterns
            rgszInputFileName = NEW LPCWSTR[ iCount ];

            for( int iParam=0; iParam < iCount; iParam++ )
            {
                rgszInputFileName[ iParam ] = ppwcParams[ iParam ];
            }

        }
        else
        {
            Usage( argv[0] );
            printf( "ERROR: An input file must be specified\r\n" );
            exit( -1 );
        }

        // find the /ini flag
        if( CmdLineParser.EnumerateFlag( L"ini", ppwcParams, iCount ) )
        {
            if( 1 != iCount )
            {
                Usage( argv[0] );
                printf( "ERROR: You must specify exactly one"
                        " initialization file.\r\n" );
                exit( -1 );
            }

            g_szIniFileName = ppwcParams[0];
        }

        // Find the /v flag
        if( CmdLineParser.EnumerateFlag( L"v", ppwcParams, iCount ) )
        {
            if( 1 != iCount )
            {
                Usage( argv[0] );
                printf( "ERROR: You must specify exactly 1 verbosity\r\n" );
                exit( -1 );
            }

            // Get the new verbosity:
            g_verbosity = (Verbosity) _wtoi( ppwcParams[0] );

            if( MUTE > g_verbosity || HIGH < g_verbosity )
            {
                printf( "ERROR: The verbosity must be between %d and %d"
                        " inclusive.\r\n", MUTE, HIGH );
                exit( -1 );
            }
        }

        // Find the /l flag
        if( CmdLineParser.EnumerateFlag( L"l", ppwcParams, iCount ) )
        {
            g_fLogToFile = TRUE;

            if( 1 < iCount )
            {
                Usage( argv[0] );
                printf( "ERROR: You may only specity one log file\r\n" );
                exit( -1 );
            }
            else if( 1 == iCount )
            {
                // Create a common log file object
                g_pLog = NEW CLog;

                // Should succeed because of the new handler
                _ASSERT( NULL != g_pLog );

                // Convert to tchar:
                _stprintf( szLogFileName, _T("%ls"), ppwcParams[0] );

                // Initialize the log
                if( ! g_pLog->InitLog( szLogFileName ) )
                {
                    printf( "ERROR: Could not initialize log file %s\r\n",
                            szLogFileName );
                    exit( -1 );
                }

                // Set the log threshold
                g_pLog->SetThreshold( VerbosityToLogStyle( g_verbosity ) );

            }
        }

        // Find the /t flag
        if( CmdLineParser.EnumerateFlag( L"t", ppwcParams, iCount ) )
        {
            if( 1 != iCount )
            {
                Usage( argv[0] );
                printf( "ERROR: You must specify only 1 thread count\r\n" );
                exit( -1 );
            }

            // Get the new thread count
            iNbrConsumers = _wtoi( ppwcParams[0] );

            if( 1 > iNbrConsumers || MAXIMUM_WAIT_OBJECTS < iNbrConsumers )
            {
                printf( "The thread count must be between 1 and %d inclusive\r\n",
                        MAXIMUM_WAIT_OBJECTS );
                exit( -1 );
            }

        }

        // Find the /r flag
        if( CmdLineParser.EnumerateFlag( L"r", ppwcParams, iCount ) )
        {
            // If no depth is specified, assume full recursion
            if( 0 == iCount )
            {
                g_iDepth = -1;
            }
            else
            {
                g_iDepth = _wtoi( ppwcParams[0] );

                // Special case, if the recurse depth is 0, perform full recursion
                if( 0 == g_iDepth )
                    g_iDepth = -1;
            }
        }

        // Find the /c flag
        if( CmdLineParser.EnumerateFlag( L"c", ppwcParams, iCount ) )
        {
            if( 1 != iCount )
            {
                Usage( argv[0] );
                printf( "ERROR: You may only specify 1 loop count\r\n" );
                exit( -1 );
            }

            // Get the new thread count
            g_cLoops = _wtoi( ppwcParams[0] );

            // Special case: if cLoops == 0, loop forever
            if( 0 == g_cLoops )
                g_cLoops = -1;
        }

        // This flag configures for a stress test
        if( CmdLineParser.IsFlagExist( L"stress" ) )
        {
            g_fIsLoggingEnabled = FALSE;
            g_fIsDumpingEnabled = FALSE;
            g_fLegitOnly = TRUE;
            g_verbosity = MUTE;
            g_cLoops = -1;
        }

        if( CmdLineParser.GetNextFlag( pwcBadParam ) )
        {
            Usage( argv[0] );
            printf( "ERROR: Unknown command line switch : %ls\r\n", pwcBadParam );
            exit( -1 );
        }

        // Done processing switches

        // Allocate memory for the thread handles
        hProducerThreads = NEW HANDLE[ iNbrProducers ];
        hConsumerThreads = NEW HANDLE[ iNbrConsumers ];

        // Launch the producer threads
        for( iLoop = 0; iLoop < iNbrProducers; iLoop++ )
        {
            while( NULL == ( hProducerThreads[ iLoop ] = CreateThread(
                   NULL, 0, &Producer, (void*)rgszInputFileName[ iLoop ],
                   0, &dwThreadID ) ) )
            {
                Sleep( dwSleepTime );
            }
        }

        // Launch the consumer threads
        for( iLoop = 0; iLoop < iNbrConsumers; iLoop++ )
        {
            while( NULL == ( hConsumerThreads[ iLoop ] = CreateThread(
                   NULL, 0, &Consumer, (void*)IntToPtr(iLoop), 0, &dwThreadID ) ) )
            {
                Sleep( dwSleepTime );
            }
        }

        // Wait for all the producers to finish
        WaitForMultipleObjects( (DWORD) iNbrProducers,
                                hProducerThreads,
                                TRUE,
                                INFINITE );

        // Signal the Consumer threads to finish.
        g_WorkQueue.Done();

        // Wait for the consumer threads to finish
        WaitForMultipleObjects( (DWORD) iNbrConsumers,
                                hConsumerThreads,
                                TRUE,
                                INFINITE );
    }
    catch (...)
    {
    }

    {
        // Close all the handles
        if( NULL != hProducerThreads )
        {
            for( iLoop=0; iLoop < iNbrProducers; iLoop++ )
            {
                if( NULL != hProducerThreads[ iLoop ] )
                {
                    (void)CloseHandle( hProducerThreads[ iLoop ] );
                    hProducerThreads[ iLoop ] = NULL;
                }
            }
            delete[] hProducerThreads;
            hProducerThreads = NULL;
        }

        if( NULL != hConsumerThreads )
        {
            for( iLoop = 0; iLoop < iNbrConsumers; iLoop++ )
            {
                if( NULL != hConsumerThreads[ iLoop ] )
                {
                    (void)CloseHandle( hConsumerThreads[ iLoop ] );
                    hConsumerThreads[ iLoop ] = NULL;
                }
            }
            delete[] hConsumerThreads;
            hConsumerThreads = NULL;
        }

        if( NULL != rgszInputFileName )
        {
            delete[] rgszInputFileName;
            rgszInputFileName = NULL;
        }

        // If there is a shared log, report stats and quit
        if( NULL != g_pLog )
        {
            g_pLog->ReportStats( );
            delete g_pLog;
            g_pLog = NULL;
        }

        // Restore the old new handler
        _set_new_handler( pfOldNewHandler );

        // Shut down CI to prevent memory leaks
        CIShutdown();
    }

    return( 0 );
} //main
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\ifilttst\pch.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       pch.cxx
//
//  Contents:   include <windows.h>
//
//  Classes:    
//
//  Functions:  
//
//  Coupling:   
//
//  Notes:      
//
//  History:    1-17-1997   ericne   Created
//
//----------------------------------------------------------------------------

#pragma once

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <query.h>
#include <filter.h>
#include <filterr.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\ifilttst\memsnap.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       memsnap.cxx
//
//  Contents:   
//
//  Classes:    
//
//  Functions:  void memsnap( FILE* ) a function for sending a snapshot of
//              all the processes in memory to a file stream
//
//  Coupling:   
//
//  Notes:      This function is used by CLog::Log when compiled with NO_NTLOG
//              If you plan on using ntlog.dll, you do not even need this module
//
//  History:    10-22-1996   ericne   Created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop
#include "memsnap.hxx"

// from pmon
#define BUFFER_SIZE 64*1024

//+---------------------------------------------------------------------------
//
//  Function:   memsnap
//
//  Synopsis:   Sends a snapshot of the current memory state to the indicated
//              file stream
//
//  Arguments:  [pLogFile] -- File stream pointer
//
//  Returns:    (none)
//
//  History:    10-22-1996   ericne   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void memsnap( FILE* pLogFile )
{
    ULONG                       Offset1;
    PUCHAR                      CurrentBuffer;
    NTSTATUS                    Status;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;

    _ftprintf( pLogFile, _T("%10s%20s%10s%10s%10s%10s%10s%10s%10s\r\n"),
               _T("Process ID"), _T("Proc.Name"), _T("Wrkng.Set"), 
               _T("PagedPool"), _T("NonPgdPl"), _T("Pagefile"), _T("Commit"),
               _T("Handles"), _T("Threads") );

    // grab all process information
    // log line format, all comma delimited,CR delimited:
    // pid,name,WorkingSetSize,QuotaPagedPoolUsage,QuotaNonPagedPoolUsage,
    // PagefileUsage,CommitCharge<CR> log all process information
    
    // from pmon
    Offset1 = 0;
    CurrentBuffer = (PUCHAR) VirtualAlloc( NULL,
                                           BUFFER_SIZE,
                                           MEM_COMMIT,
                                           PAGE_READWRITE );
    if( NULL == CurrentBuffer )
    {
    	_tprintf( _T("VirtualAlloc Error!\r\n") );
    	return;
    }
    
    // from pmon
    // get commit charge
    // get all of the status information
    Status = NtQuerySystemInformation( SystemProcessInformation,
                                       CurrentBuffer,
                                       BUFFER_SIZE,
                                       NULL );

    if( STATUS_SUCCESS == Status )  
    {
        while( 1 )
        {
    
            // get process info from buffer
            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) &CurrentBuffer[Offset1];
            Offset1 += ProcessInfo->NextEntryOffset;
    
            // print in file
            _ftprintf( pLogFile,_T("%10i%20ws%10u%10u%10u%10u%10u%10u%10u\r\n"),
                       ProcessInfo->UniqueProcessId,
                       ProcessInfo->ImageName.Buffer,
                       ProcessInfo->WorkingSetSize,
                       ProcessInfo->QuotaPagedPoolUsage,
                       ProcessInfo->QuotaNonPagedPoolUsage,
                       ProcessInfo->PagefileUsage,
                       ProcessInfo->PrivatePageCount,
                       ProcessInfo->HandleCount,
                       ProcessInfo->NumberOfThreads );
    
            if( 0 == ProcessInfo->NextEntryOffset )
                break;
        }
    }
    else
    {
        _ftprintf( pLogFile, _T("NtQuerySystemInformation call failed!\r\n") );
    }
    
    // Free the memory
    VirtualFree( CurrentBuffer, 0, MEM_RELEASE );
    
} //memsnap
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\isrchdmp\isearch.h ===
/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __isearch_h__
#define __isearch_h__

#ifndef __ISearchQueryHits_FWD_DEFINED__
#define __ISearchQueryHits_FWD_DEFINED__
typedef interface ISearchQueryHits ISearchQueryHits;
#endif  /* __ISearchQueryHits_FWD_DEFINED__ */

#ifndef __ISearchQueryHits_INTERFACE_DEFINED__
#define __ISearchQueryHits_INTERFACE_DEFINED__

/* interface ISearchQueryHits */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_ISearchQueryHits;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ed8ce7e0-106c-11ce-84e2-00aa004b9986")
    ISearchQueryHits : public IUnknown
    {
    public:
        virtual SCODE STDMETHODCALLTYPE Init( 
            /* [in] */ IFilter __RPC_FAR *pflt,
            /* [in] */ ULONG ulFlags) = 0;
        
        virtual SCODE STDMETHODCALLTYPE NextHitMoniker( 
            /* [out][in] */ ULONG __RPC_FAR *pcMnk,
            /* [size_is][out] */ IMoniker __RPC_FAR *__RPC_FAR *__RPC_FAR *papMnk) = 0;
        
        virtual SCODE STDMETHODCALLTYPE NextHitOffset( 
            /* [out][in] */ ULONG __RPC_FAR *pcRegion,
            /* [size_is][out] */ FILTERREGION __RPC_FAR *__RPC_FAR *paRegion) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct ISearchQueryHitsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISearchQueryHits __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISearchQueryHits __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISearchQueryHits __RPC_FAR * This);
        
        SCODE ( STDMETHODCALLTYPE __RPC_FAR *Init )( 
            ISearchQueryHits __RPC_FAR * This,
            /* [in] */ IFilter __RPC_FAR *pflt,
            /* [in] */ ULONG ulFlags);
        
        SCODE ( STDMETHODCALLTYPE __RPC_FAR *NextHitMoniker )( 
            ISearchQueryHits __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *pcMnk,
            /* [size_is][out] */ IMoniker __RPC_FAR *__RPC_FAR *__RPC_FAR *papMnk);
        
        SCODE ( STDMETHODCALLTYPE __RPC_FAR *NextHitOffset )( 
            ISearchQueryHits __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *pcRegion,
            /* [size_is][out] */ FILTERREGION __RPC_FAR *__RPC_FAR *paRegion);
        
        END_INTERFACE
    } ISearchQueryHitsVtbl;

    interface ISearchQueryHits
    {
        CONST_VTBL struct ISearchQueryHitsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISearchQueryHits_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISearchQueryHits_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define ISearchQueryHits_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define ISearchQueryHits_Init(This,pflt,ulFlags)        \
    (This)->lpVtbl -> Init(This,pflt,ulFlags)

#define ISearchQueryHits_NextHitMoniker(This,pcMnk,papMnk)      \
    (This)->lpVtbl -> NextHitMoniker(This,pcMnk,papMnk)

#define ISearchQueryHits_NextHitOffset(This,pcRegion,paRegion)  \
    (This)->lpVtbl -> NextHitOffset(This,pcRegion,paRegion)

#endif /* COBJMACROS */


#endif  /* C style interface */



SCODE STDMETHODCALLTYPE ISearchQueryHits_Init_Proxy( 
    ISearchQueryHits __RPC_FAR * This,
    /* [in] */ IFilter __RPC_FAR *pflt,
    /* [in] */ ULONG ulFlags);


void __RPC_STUB ISearchQueryHits_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


SCODE STDMETHODCALLTYPE ISearchQueryHits_NextHitMoniker_Proxy( 
    ISearchQueryHits __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *pcMnk,
    /* [size_is][out] */ IMoniker __RPC_FAR *__RPC_FAR *__RPC_FAR *papMnk);


void __RPC_STUB ISearchQueryHits_NextHitMoniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


SCODE STDMETHODCALLTYPE ISearchQueryHits_NextHitOffset_Proxy( 
    ISearchQueryHits __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *pcRegion,
    /* [size_is][out] */ FILTERREGION __RPC_FAR *__RPC_FAR *paRegion);


void __RPC_STUB ISearchQueryHits_NextHitOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ISearchQueryHits_INTERFACE_DEFINED__ */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\ifilttst\tracer.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       tracer.cxx
//
//  Contents:   
//
//  Classes:    
//
//  Functions:  
//
//  Coupling:   
//
//  Notes:      
//
//  History:    10-28-1996   ericne   Created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#include "tracer.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CTracer::CTracer
//
//  Synopsis:   
//
//  Arguments:  (none)
//
//  Returns:    
//
//  History:    10-28-1996   ericne   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CTracer::CTracer( )
: m_hTempFile( ),
  m_hMappedFile( ),
  m_tcsFileStart( NULL ),
  m_dwPut( 0 ),
  m_dwGet( 0 )
{
} //CTracer::CTracer

//+---------------------------------------------------------------------------
//
//  Member:     CTracer::~CTracer
//
//  Synopsis:   
//
//  Arguments:  (none)
//
//  Returns:    
//
//  History:    10-28-1996   ericne   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CTracer::~CTracer( )
{
    if( NULL != m_tcsFileStart )
    {
        if( ! UnmapViewOfFile( (LPCVOID) m_tcsFileStart ) )
            _tprintf( _T("Unable to unmap view to the temporary file.\r\n")
                      _T("GetLastError return 0x%08X\r\n"), GetLastError());
    }
} //CTracer::~CTracer

//+---------------------------------------------------------------------------
//
//  Member:     CTracer::Init
//
//  Synopsis:   
//
//  Arguments:  (none)
//
//  Returns:    TRUE if successful, FALSE otherwise
//
//  History:    10-28-1996   ericne   Created
//
//  Notes:      CAutoHandle is a "smart" handle object that calls CloseHandle
//              in the destructor
//
//----------------------------------------------------------------------------

BOOL CTracer::Init( )
{
    TCHAR szFileName[ L_tmpnam ];
    CFileHandle FileHandle; 
    CAutoHandle MapHandle;
     
    // Create a temporary file name
    if( NULL == _ttmpnam( szFileName ) )
    {
        return( FALSE );
    }

    // Open the file
    FileHandle  = CreateFile( szFileName,
                              GENERIC_READ | GENERIC_WRITE,
                              0,
                              NULL,
                              CREATE_NEW,
                              FILE_FLAG_DELETE_ON_CLOSE,
                              NULL );

    // MAke sure it was opened successfully
    if( INVALID_HANDLE_VALUE == FileHandle )
    {
        _ftprintf( stderr, _T("Unable to create temporary file\r\n")
                   _T("GetLastError returns 0x%08X\r\n"), GetLastError() );
        return( FALSE );
    }

    // Create a file mapping
    MapHandle     = CreateFileMapping( FileHandle.GetHandle(),
                                       NULL,
                                       PAGE_READWRITE,
                                       0,
                                       dwMaxFileSize,
                                       NULL );

    // Make sure the file was mapped successfully
    if( NULL == MapHandle )
    {
        _ftprintf( stderr, _T("Unable to create mapped temp file\r\n")
                   _T("GetLastError returns 0x%08X\r\n"), GetLastError() );
        return( FALSE );
    }

    // Map a view of the entire file
    m_tcsFileStart = (LPTSTR) MapViewOfFile( MapHandle.GetHandle(),
                                             FILE_MAP_ALL_ACCESS,
                                             0,
                                             0,
                                             0 ); // Map the whole file

    // Make sure we have a valid view of the file
    if( NULL == m_tcsFileStart )
    {
        _ftprintf( stderr, _T("Unable to map view of temporary file\r\n")
                   _T("GetLastError returns 0x%08X\r\n"), GetLastError() );
        return( FALSE );
    }

    // Make the first character in the file the EndOfEntry character
    m_tcsFileStart[ m_dwPut++ ] = tcsEndOfEntry;
    
    // Copy the file handle (increments the ref count)
    m_hTempFile   = FileHandle;

    // Copy the map handle (increments the ref count)
    m_hMappedFile = MapHandle;

    return( TRUE );
} //CTracer::Init

//+---------------------------------------------------------------------------
//
//  Member:     CTracer::Trace
//
//  Synopsis:   Enter the message into the trace file
//
//  Arguments:  [szFormat] -- the format string
//
//  Returns:    (none)
//
//  History:    10-28-1996   ericne   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CTracer::Trace( LPCTSTR szFormat, ... )
{
    va_list va;

    if( m_dwPut >= dwMaxCharsInFile )
        return;

    va_start( va, szFormat );

    m_dwPut += _vsntprintf( &m_tcsFileStart[ m_dwPut ],
                            dwMaxCharsInFile - m_dwPut,
                            szFormat,
                            va );

    m_tcsFileStart[ m_dwPut++ ] = tcsEndOfEntry;

    va_end( va );

} //CTracer::Trace

//+---------------------------------------------------------------------------
//
//  Member:     CTracer::Dump
//
//  Synopsis:   reads the past cEntries from the trace file and sends them
//              to pFile
//
//  Arguments:  [pFile]    -- file stream pointer
//              [cEntries] -- count of entries to dump
//
//  Returns:    (none)
//
//  History:    10-28-1996   ericne   Created
//
//  Notes:      Passing in a negative number for cEntries dumps all the entries
//
//----------------------------------------------------------------------------

void CTracer::Dump( FILE* pFile, int cEntries )
{
    m_dwGet = m_dwPut - 1;  // At last tcsEndOfEntry

    while( cEntries-- && 0 < m_dwGet )
    {
        // This cannot read before beginning of file since first 
        // tchar in file is tcsEndOfEntry
        while( tcsEndOfEntry != m_tcsFileStart[ --m_dwGet ] ) 
            { }

        // This uses the fact that the EndOfEntry character is '\0'
        _ftprintf( pFile, _T("\r\n%s"), &m_tcsFileStart[ m_dwGet + 1 ] );
    }
} //CTracer::Dump

//+---------------------------------------------------------------------------
//
//  Member:     CTracer::Clear
//
//  Synopsis:   Flushes the contents of the trace file
//
//  Arguments:  (none)
//
//  Returns:    (none)
//
//  History:    10-29-1996   ericne   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CTracer::Clear( )
{
    m_dwPut = m_dwGet = 0;
    m_tcsFileStart[ m_dwPut++ ] = tcsEndOfEntry;
} //CTracer::Clear

//+---------------------------------------------------------------------------
//
//  Member:     CTracer::Interact
//
//  Synopsis:   Enters into an interactive dialog with the user, displays the
//              previous n entries in the trace file, and optionally sends
//              them to a user-specified file
//
//  Arguments:  (none)
//
//  Returns:    (none)
//
//  History:    10-29-1996   ericne   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CTracer::Interact( )
{
    const int nMaxCommentLength = 80;
    int       cEntries = 0;
    FILE*     pFile = NULL;
    TCHAR     tcsComment[ nMaxCommentLength ];
    TCHAR     tcsFileName[ MAX_PATH ];
    TCHAR     tcsYesNo = _T('\0');

    while( 1 )
    {
        _tprintf( _T("\r\nHow many of the entries would you like see?\r\n")
                  _T("( -1 for all, 0 to quit )\r\n") );
        fflush( stdin );
        _tscanf( _T("%i"), &cEntries );

        if( 0 == cEntries )
            break;

        Dump( stdout, cEntries );

        do
        {
            _tprintf( _T("\r\nWould you like to send ")
                      _T("this to a file (y/n)? ") );
            fflush( stdin );
            tcsYesNo = (TCHAR) _totlower( _gettchar() );

        } while( _T('n') != tcsYesNo && _T('y') != tcsYesNo );

        if( _T('y') == tcsYesNo )
        {
            _tprintf( _T("\r\nEnter the name of the file ")
                      _T("to which to append\r\n") );
            fflush( stdin );
            _getts( tcsFileName );

            pFile = _tfopen( tcsFileName, _T("a+") );

            _tprintf( _T("\r\nEnter a comment for this trace ") 
                      _T("(max %i chars)\r\n"), nMaxCommentLength );
            fflush( stdin );
            _getts( tcsComment );

            if( NULL != pFile )
            {
                _ftprintf( pFile, _T("\r\n\r\n%s\r\n"), tcsComment );
    
                Dump( pFile, cEntries );

                fclose( pFile );
            }
        }
    }
} //CTracer::Interact
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\ifilttst\statchnk.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       statchnk.cxx
//
//  Contents:   
//
//  Classes:    
//
//  Functions:  
//
//  Coupling:   
//
//  Notes:      
//
//  History:    10-14-1996   ericne   Created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#include "statchnk.hxx"
#include "mydebug.hxx"
#include "utility.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CStatChunk::CStatChunk
//
//  Synopsis:   
//
//  Arguments:  (none)
//
//  Returns:    
//
//  History:    10-14-1996   ericne   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CStatChunk::CStatChunk()
{ 
    // Set the fields equal to zero
    idChunk         = 0;
    breakType       = CHUNK_NO_BREAK;
    flags           = CHUNK_TEXT;
    locale          = 0;
    idChunkSource   = 0;
    cwcStartSource  = 0;
    cwcLenSource    = 0;

    // Set all the sub-fields of the attribute fields to zero
    memset( (void*)&attribute, (int)0, sizeof( FULLPROPSPEC ) );

    // Reset the value of the ulKind field since a value of 0 indicates pwstr
    attribute.psProperty.ulKind = PRSPEC_PROPID;

} //CStatChunk::CStatChunk

//+---------------------------------------------------------------------------
//
//  Member:     CStatChunk::CStatChunk
//
//  Synopsis:   
//
//  Arguments:  [ToCopy] -- 
//
//  Returns:    
//
//  History:    10-14-1996   ericne   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CStatChunk::CStatChunk( const CStatChunk & ToCopy )
{
    // Set the fields
    idChunk         = ToCopy.idChunk;
    breakType       = ToCopy.breakType;
    flags           = ToCopy.flags;
    locale          = ToCopy.locale;
    idChunkSource   = ToCopy.idChunkSource;
    cwcStartSource  = ToCopy.cwcStartSource;
    cwcLenSource    = ToCopy.cwcLenSource;

    // First, perform a bitwise copy of the attribute field
    memcpy( (void*)&attribute, (void*)&ToCopy.attribute, 
            sizeof( FULLPROPSPEC ) );

    // If the attribute contains a pwstr, create room for it:
    if( PRSPEC_LPWSTR == ToCopy.attribute.psProperty.ulKind )
    {
        size_t lpwstrlen = wcslen( ToCopy.attribute.psProperty.lpwstr );

        attribute.psProperty.lpwstr = NEW WCHAR[ lpwstrlen + 1 ];

        if( attribute.psProperty.lpwstr )
        {
            wcscpy( attribute.psProperty.lpwstr, 
                    ToCopy.attribute.psProperty.lpwstr );
        }
    }
} //CStatChunk::CStatChunk

//+---------------------------------------------------------------------------
//
//  Member:     CStatChunk::~CStatChunk
//
//  Synopsis:   
//
//  Arguments:  (none)
//
//  Returns:    
//
//  History:    10-14-1996   ericne   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CStatChunk::~CStatChunk()
{
    if( PRSPEC_LPWSTR == attribute.psProperty.ulKind &&
        NULL != attribute.psProperty.lpwstr )
    {
        delete [] attribute.psProperty.lpwstr;
    }
} //CStatChunk::~CStatChunk

//+---------------------------------------------------------------------------
//
//  Member:     CStatChunk::operator=
//
//  Synopsis:   Overloaded assignment operator.  Frees any memory if necessary
//              then copies the parameter
//
//  Arguments:  [ToCopy] -- The object to copy
//
//  Returns:    a reference to this
//
//  History:    10-14-1996   ericne   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CStatChunk & CStatChunk::operator=( const CStatChunk & ToCopy )
{
    // Make sure this is not a self copy
    if( this == &ToCopy )
        return( *this );
    
    return( operator=( ( STAT_CHUNK ) ToCopy ) );

} //CStatChunk::operator=

//+---------------------------------------------------------------------------
//
//  Member:     CStatChunk::operator
//
//  Synopsis:   
//
//  Arguments:  [ToCopy] -- 
//
//  Returns:    
//
//  History:    10-21-1996   ericne   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CStatChunk & CStatChunk::operator=( const STAT_CHUNK & ToCopy )
{
    // Clean up the old mess
    this->~CStatChunk();

    // Copy the fields
    idChunk         = ToCopy.idChunk;
    breakType       = ToCopy.breakType;
    flags           = ToCopy.flags;
    locale          = ToCopy.locale;
    idChunkSource   = ToCopy.idChunkSource;
    cwcStartSource  = ToCopy.cwcStartSource;
    cwcLenSource    = ToCopy.cwcLenSource;

    // First, perform a bitwise copy of the attribute field
    memcpy( (void*)&attribute, (void*)&ToCopy.attribute, 
            sizeof( FULLPROPSPEC ) );

    // If the attribute contains a lpwstr, create room for it:
    if( PRSPEC_LPWSTR == ToCopy.attribute.psProperty.ulKind )
    {
        size_t lpwstrlen = wcslen( ToCopy.attribute.psProperty.lpwstr );

        attribute.psProperty.lpwstr = NEW WCHAR[ lpwstrlen + 1 ];

        if( attribute.psProperty.lpwstr )
        {
            wcscpy( attribute.psProperty.lpwstr, 
                    ToCopy.attribute.psProperty.lpwstr );
        }
    }

    return( *this );

} //CStatChunk::operator


//+---------------------------------------------------------------------------
//
//  Member:     CStatChunk::Display
//
//  Synopsis:   Formatted display of the STAT_CHUNK structure
//
//  Arguments:  [pFileStream] -- Output stream, stdout by default
//
//  Returns:    void
//
//  History:    10-14-1996   ericne   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CStatChunk::Display( FILE* pFileStream ) const
{
    TCHAR szGuidBuffer[ GuidBufferSize ];

    // Insert a blank line
    fwprintf( pFileStream, L"\r\nChunk statistics:\r\n" );

    // Print the chunk id
    fwprintf( pFileStream, L"Chunk ID: ........... %d\r\n", idChunk);

    // Print the break type (in English if possible)
    if( CHUNK_NO_BREAK > breakType || 
        CHUNK_EOC      < breakType )  // not legal
    {
        fwprintf( pFileStream, L"Illegal Break Type: . %d\r\n", breakType );
    }
    else
    {
        fwprintf( pFileStream, L"Chunk Break Type: ... %ls\r\n", 
                  BreakType[ breakType ] );
    }

    // Print the Chunk state (in English if possible)
    if( CHUNK_TEXT == flags || CHUNK_VALUE == flags)
    {
        fwprintf( pFileStream, L"Chunk State: ........ %ls\r\n", 
                  ChunkState[ flags - 1 ] );
    }
    else
    {
        fwprintf( pFileStream, L"Bad Chunk State: .... %d\r\n", flags );
    }

    // Print the locale
    fwprintf( pFileStream, L"Chunk Locale: ....... 0x%08x\r\n", locale );

    // Print the Chunk id source
    fwprintf( pFileStream, L"Chunk Source ID: .... %d\r\n", idChunkSource );

    // Print the start source
    fwprintf( pFileStream, L"Chunk Start Source .. 0x%08x\r\n", 
              cwcStartSource );

    // Print the length source
    fwprintf( pFileStream, L"Chunk Length Source . 0x%08x\r\n", 
              cwcLenSource );

    // Display the guid
    GetStringFromCLSID( attribute.guidPropSet, szGuidBuffer, GuidBufferSize );
    fwprintf( pFileStream, L"GUID ................ %s\r\n", szGuidBuffer );

    // Display the contents of the PROPSPEC field (careful of the union)
    if( PRSPEC_LPWSTR == attribute.psProperty.ulKind )
    {
        fwprintf( pFileStream, L"Property name ....... %ls\r\n", 
                  attribute.psProperty.lpwstr );
    }
    else if( PRSPEC_PROPID == attribute.psProperty.ulKind )
    {
        fwprintf( pFileStream, L"Property ID ......... 0x%08x\r\n", 
                  attribute.psProperty.propid );
    }
    else
    {
        fwprintf( pFileStream, L"Bad ulKind field .... %d\r\n", 
                  attribute.psProperty.ulKind );
    }

    // Insert a blank line
    fwprintf( pFileStream, L"\r\n" );
    
} //CStatChunk::Display

//+---------------------------------------------------------------------------
//
//  Function:   operator==
//
//  Synopsis:   
//
//  Arguments:  [ChunkA] -- 
//              [ChunkB] -- 
//
//  Returns:    
//
//  History:    10-14-1996   ericne   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

int operator==( const STAT_CHUNK & ChunkA, const STAT_CHUNK & ChunkB )
{
    return( ! ( ChunkA != ChunkB ) );
} //operator

//+---------------------------------------------------------------------------
//
//  Function:   operator!=
//
//  Synopsis:   
//
//  Arguments:  [ChunkA] -- 
//              [ChunkB] -- 
//
//  Returns:    1 If the chunks are not equal
//              0 if the chunks are equal
//
//  History:    10-14-1996   ericne   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

int operator!=( const STAT_CHUNK & ChunkA, const STAT_CHUNK & ChunkB )
{

    // Check chunk ID
    if( ChunkA.idChunk != ChunkB.idChunk )
    {
        return( 1 );
    }
    
    // Check the breaktype
    if( ChunkA.breakType != ChunkB.breakType )
    {
        return( 1 );
    }
    
    // Check the flags
    if( ChunkA.flags != ChunkB.flags )
    {
        return( 1 );
    }

    // Check the locale
    if( ChunkA.locale != ChunkB.locale )
    {
        return( 1 );
    }

    // Check the GUID
    if( ChunkA.attribute.guidPropSet != ChunkB.attribute.guidPropSet )
    {
        return( 1 );
    }

    // Make sure they have the same ulKind
    if( ChunkA.attribute.psProperty.ulKind != 
        ChunkB.attribute.psProperty.ulKind )
    {
        return( 1 );
    }

	if( PRSPEC_PROPID == ChunkA.attribute.psProperty.ulKind &&
		PRSPEC_PROPID == ChunkB.attribute.psProperty.ulKind )
	{
		// compare the propid's
		if( ChunkA.attribute.psProperty.propid != 
			ChunkB.attribute.psProperty.propid )
		{
			return( 1 );
		}
	}
	else
	{
		// compare the pwstr's
		if( 0 != _wcsicmp( ChunkA.attribute.psProperty.lpwstr,
						   ChunkB.attribute.psProperty.lpwstr ) )
		{
			return( 1 );
		}
	}

    // Check the chunk source
    if( ChunkA.idChunkSource != ChunkB.idChunkSource )
    {
        return( 1 );
    }

    // Check the start source
    if( ChunkA.cwcStartSource != ChunkB.cwcStartSource )
    {
        return( 1 );
    }

    // check the source length
    if( ChunkA.cwcLenSource != ChunkB.cwcLenSource )
    {
        return( 1 );
    }

	// They are equal, return 0:
	return( 0 );

} //operator
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\ifilttst\nlfilter.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-1997.
//
//  File:       nlquery.cxx
//
//  Contents:   Net Library query implementation; 
//
//  Functions:
//
//  History:    8-1-97    Shawn Harris   Created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#include <windows.h>
#include <winreg.h>
#include <stdio.h>
#include <wchar.h>
#include <objbase.h>
#include <unknwn.h>
#include <filter.h>
#include <ntquery.h>
#include <winbase.h>
#include "nlfilter.hxx"
#include "oleinit.hxx"

#define MAX_BUFFER_CHARS ( MAX_BUFFER / sizeof TCHAR )

HRESULT NLLoadIFilter(LPCTSTR pcszFilename, IUnknown *pIUnknownOuter, void **ppv)
{
    HKEY     hKey = NULL;
    HKEY     hKeyFilterType = NULL;

    HRESULT  hr = ERROR_SUCCESS;

    BYTE     lpszFileContentType[MAX_BUFFER];
    BYTE     lpszNLFilterType[MAX_BUFFER];
    BYTE     lpszFilterCLSID[MAX_BUFFER];
    BYTE     lpszBuffer[MAX_BUFFER];

    LPCTSTR  lpszExt = NULL;

    DWORD    dwVal1 = MAX_BUFFER_CHARS;
    DWORD    dwVal2 = MAX_BUFFER;
    DWORD    dwTypeCode = REG_SZ;
    DWORD    dwIndex = 0;

    FILETIME lpftLastWriteTime;

    CLSID    clsidNLFilter;

    // This object insures ole is intialized
    COleInitialize OleIsInitialized;

    // Check if filename exists
    if( NULL == pcszFilename )
        return E_FAIL;

    // Get file extension 
    lpszExt = _tcsrchr( pcszFilename, (int)_T('.') );

    // Check for valid extension
    if( NULL == lpszExt )
        return E_FAIL;

    hr = RegOpenKeyEx(HKEY_CLASSES_ROOT,
                      lpszExt,
                      NULL,
                      KEY_READ,
                      &hKey);

    if( ERROR_SUCCESS != hr )
        return E_FAIL;

    hr = RegEnumValue(hKey,
                      (DWORD)0,
                      (LPTSTR)lpszBuffer,
                      &dwVal1,
                      NULL,
                      &dwTypeCode,
                      (LPBYTE)lpszFileContentType,
                      &dwVal2);

    RegCloseKey(hKey);

    if( ERROR_SUCCESS != hr )
        return E_FAIL;

    hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,                                      
                      _T("Software\\Microsoft\\Site Server\\3.0\\Search\\Filters"),
                      NULL, 
                      KEY_READ, 
                      &hKey);

    if( ERROR_SUCCESS != hr )
        return E_FAIL;

    for( dwIndex=0; hr != ERROR_NO_MORE_ITEMS; dwIndex++ )
    {

        dwVal1 = MAX_BUFFER_CHARS;
        hr = RegEnumKeyEx(hKey, 
                          dwIndex, 
                          (LPTSTR)lpszNLFilterType, 
                          &dwVal1, 
                          NULL, 
                          NULL, 
                          NULL, 
                          &lpftLastWriteTime);

        if( ERROR_SUCCESS != hr )
            break;

        // Check for a match
        if( 0 == _tcsicmp( (LPCTSTR)lpszFileContentType, (LPCTSTR)lpszNLFilterType ) )
            break;
    } 

    // Fail if no match was found
    if( ERROR_SUCCESS != hr )
    {
        RegCloseKey(hKey);
        return E_FAIL;
    }

    hr = RegOpenKeyEx(hKey,
                      (LPCTSTR)lpszNLFilterType,
                      NULL,
                      KEY_READ,
                      &hKeyFilterType );

    RegCloseKey( hKey );

    if( ERROR_SUCCESS != hr )
        return E_FAIL;

    dwVal1 = MAX_BUFFER_CHARS;
    dwVal2 = MAX_BUFFER;
    hr = RegEnumValue(hKeyFilterType,
                      (DWORD)0,
                      (LPTSTR)lpszBuffer,
                      &dwVal1,
                      NULL,
                      &dwTypeCode,
                      (LPBYTE)lpszFilterCLSID,
                      &dwVal2);

    RegCloseKey(hKeyFilterType);

    if( ERROR_SUCCESS != hr )
        return E_FAIL;

    hr = CLSIDFromString((LPOLESTR)lpszFilterCLSID, &clsidNLFilter);

    IUnknown *pUkn = NULL;
    IPersistFile *pIFile = NULL;
    hr = ::CoCreateInstance(clsidNLFilter,
                            pIUnknownOuter,
                            CLSCTX_ALL,
                            IID_IUnknown,
                            (void **)&pUkn);

    if( SUCCEEDED(hr) )
    {
        hr = pUkn->QueryInterface(IID_IFilter, (void **)ppv);
        hr = pUkn->QueryInterface(IID_IPersistFile, (void **)&pIFile);
        pUkn->Release();
        pIFile->Load(pcszFilename, 0);
        pIFile->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\ifilttst\ntlog.h ===
/*---------------------------------------------------------------------------*\
| NTLOG OBJECT
|   This module defines the NTLOG object.  This header must be include in all
|   modules which make NTLOG calls, or utilizes the definitions.
|
|
| Copyright (C) 1990-2001 Microsoft Corp.
|
\*---------------------------------------------------------------------------*/

#ifndef _NTLOG_
#define _NTLOG_

// If doing C++ stuff, this needs to be here to
// prevent decorating of symbols.
//
#ifdef __cplusplus
extern "C" {
#endif

// **NEW** 10/26/96 Log path environment variable **NEW**
// if the environment variable _NTLOG_LOGPATH is set to a non-empty string
// the value of this variable will be prepended to the log name
// The path should NOT include a trailing backslash.

// No validation is performed on the path, however, if the value is invalid,
// the call to tlCreateLog will fail because CreateFile will fail.

// Basically should be used to force logfiles to a location other than the current directory
// without changing the source file.

// **NEW** 1/20/97 environment variable to force diffable files **NEW**
// if the environment variable _NTLOG_DIFFABLE is set, then log files
// will not contain process and thread specific data, and time and date data.
//


// NTLOG STYLES
//  The folowing are logging levels in which the Log Object can prejudice
//  itself.  These are used by the tlLogCreate() in initializing the
//  Log Object information.  A combination of characteristics is obtained
//  by bitwise OR'ing these identifiers together.
//
#define LOG_LEVELS    0x0000FFFFL    // These are used to mask out the
#define LOG_STYLES    0xFFFF0000L    // styles or levels from log object.

#define TLS_LOGALL    0x0000FFFFL    // Log output.  Logs all the time.
#define TLS_LOG       0x00000000L    // Log output.  Logs all the time.
#define TLS_INFO      0x00002000L    // Log information.
#define TLS_ABORT     0x00000001L    // Log Abort, then kill process.
#define TLS_SEV1      0x00000002L    // Log at Severity 1 level
#define TLS_SEV2      0x00000004L    // Log at Severity 2 level
#define TLS_SEV3      0x00000008L    // Log at Severity 3 level
#define TLS_WARN      0x00000010L    // Log at Warn level
#define TLS_PASS      0x00000020L    // Log at Pass level
#define TLS_BLOCK     0x00000400L    // Block the variation.
#define TLS_BREAK     0x00000800L    // Debugger break;
#define TLS_CALLTREE  0x00000040L    // Log call-tree (function tracking).
#define TLS_SYSTEM    0x00000080L    // Log System debug.
#define TLS_TESTDEBUG 0x00001000L    // Debug level.
#define TLS_TEST      0x00000100L    // Log Test information (user).
#define TLS_VARIATION 0x00000200L    // Log testcase level.

#define TLS_REFRESH   0x00010000L    // Create new file || trunc to zero.
#define TLS_SORT      0x00020000L    // Sort file output by instance.
#define TLS_DEBUG     0x00040000L    // Output to debug (com) monitor).
#define TLS_MONITOR   0x00080000L    // Output to 2nd screen.
#define TLS_VIDCOLOR  0x00100000L    // Use different colors for display output
#define TLS_PROLOG    0x00200000L    // Prolog line information.
#define TLS_WINDOW    0x00400000L    // Log to windows.
#define TLS_ACCESSON  0x00800000L    // Keep log-file open.
#define TLS_DIFFABLE  0x01000000L    // make log file windiff'able (no dates..)
#define TLS_NOHEADER  0x02000000L    // suppress headers so it is more diffable
#define TLS_TIMESTAMP 0x04000000L    // To print the timestamps
#define TLS_VIDEOLOG  0x08000000L    // convert ?.log to ?.bpp.log (color depth)
#define TLS_HTML      0x10000000L    // write log file as an html.


// NTLOG tlLogOut() PARAMETERS
//   The following defines are used in the tlLogOut() function to output the
//   filename and line numbers associated with the caller.  This uses the
//   preprocessors capabilities for obtaining the file/line.
//
#define TL_LOG       TLS_LOG      ,TEXT(__FILE__),(int)__LINE__
#define TL_ABORT     TLS_ABORT    ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV1      TLS_SEV1     ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV2      TLS_SEV2     ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV3      TLS_SEV3     ,TEXT(__FILE__),(int)__LINE__
#define TL_WARN      TLS_WARN     ,TEXT(__FILE__),(int)__LINE__
#define TL_PASS      TLS_PASS     ,TEXT(__FILE__),(int)__LINE__
#define TL_BLOCK     TLS_BLOCK    ,TEXT(__FILE__),(int)__LINE__
#define TL_INFO      TLS_INFO     ,TEXT(__FILE__),(int)__LINE__
#define TL_BREAK     TLS_BREAK    ,TEXT(__FILE__),(int)__LINE__
#define TL_CALLTREE  TLS_CALLTREE ,TEXT(__FILE__),(int)__LINE__
#define TL_SYSTEM    TLS_SYSTEM   ,TEXT(__FILE__),(int)__LINE__
#define TL_TESTDEBUG TLS_TESTDEBUG,TEXT(__FILE__),(int)__LINE__
#define TL_TEST      TLS_TEST     ,TEXT(__FILE__),(int)__LINE__
#define TL_VARIATION TLS_VARIATION,TEXT(__FILE__),(int)__LINE__


//  Struct used by tlGet/SetVar/TestStats
//
typedef struct _NTLOGSTATS {
    int nAbort;
    int nBlock;
    int nSev1;
    int nSev2;
    int nSev3;
    int nWarn;
    int nPass;
}
NTLOGSTATS, *LPNTLOGSTATS;


//  Use enumerated indexes to access palette.
//  Colors are defined in wincon.h

typedef struct _VIDEOPALETTE {
    WORD  wINDEX_DEFAULT;
    WORD  wINDEX_INFO;
    WORD  wINDEX_SEV1;
    WORD  wINDEX_SEV2;
    WORD  wINDEX_SEV3;
    WORD  wINDEX_BLOCK;
    WORD  wINDEX_ABORT;
    WORD  wINDEX_WARN;
    WORD  wINDEX_PASS;
}
VIDEOPALETTE, *LPVIDEOPALETTE;


// NTLOG API (EXPORT METHODS)
//   These routines are exported from the library.  These should be the only
//   interface with the NTLOG object.
//
HANDLE APIENTRY  tlCreateLog_W(LPCWSTR,DWORD);
HANDLE APIENTRY  tlCreateLog_A(LPCSTR,DWORD);
HANDLE APIENTRY  tlCreateLogEx_W(LPCWSTR,DWORD,LPSECURITY_ATTRIBUTES);
HANDLE APIENTRY  tlCreateLogEx_A(LPCSTR,DWORD,LPSECURITY_ATTRIBUTES);
BOOL   APIENTRY  tlDestroyLog(HANDLE);
BOOL   APIENTRY  tlAddParticipant(HANDLE,DWORD,int);
BOOL   APIENTRY  tlRemoveParticipant(HANDLE);
DWORD  APIENTRY  tlParseCmdLine_W(LPCWSTR);
DWORD  APIENTRY  tlParseCmdLine_A(LPCSTR);
int    APIENTRY  tlGetLogFileName_W(HANDLE,LPWSTR);
int    APIENTRY  tlGetLogFileName_A(HANDLE,LPSTR);
BOOL   APIENTRY  tlSetLogFileName_W(HANDLE,LPCWSTR);
BOOL   APIENTRY  tlSetLogFileName_A(HANDLE,LPCSTR);
DWORD  APIENTRY  tlGetLogInfo(HANDLE);
DWORD  APIENTRY  tlSetLogInfo(HANDLE,DWORD);
HANDLE APIENTRY  tlPromptLog(HWND,HANDLE);
int    APIENTRY  tlGetTestStat(HANDLE,DWORD);
int    APIENTRY  tlGetVariationStat(HANDLE,DWORD);
VOID   APIENTRY  tlClearTestStats(HANDLE);
VOID   APIENTRY  tlClearVariationStats(HANDLE);
VOID   APIENTRY  tlSetTestStats(HANDLE,LPNTLOGSTATS);
VOID   APIENTRY  tlSetVariationStats(HANDLE,LPNTLOGSTATS);
BOOL   APIENTRY  tlStartVariation(HANDLE);
DWORD  APIENTRY  tlEndVariation(HANDLE);
VOID   APIENTRY  tlReportStats(HANDLE);
BOOL   APIENTRY  tlLogX_W(HANDLE,DWORD,LPCWSTR,int,LPCWSTR);
BOOL   APIENTRY  tlLogX_A(HANDLE,DWORD,LPCSTR,int,LPCSTR);
BOOL   FAR __cdecl tlLog_W(HANDLE,DWORD,LPCWSTR,int,LPCWSTR,...);
BOOL   FAR __cdecl tlLog_A(HANDLE,DWORD,LPCSTR,int,LPCSTR,...);
BOOL   APIENTRY  tlGetVideoPalette(HANDLE,LPVIDEOPALETTE);
BOOL   APIENTRY  tlSetVideoPalette(HANDLE,LPVIDEOPALETTE);
BOOL   APIENTRY  tlResetVideoPalette(HANDLE);
VOID   APIENTRY  tlAdjustFileName_W(HANDLE,LPWSTR,UINT);
VOID   APIENTRY  tlAdjustFileName_A(HANDLE,LPSTR,UINT);
BOOL   APIENTRY  tlIsTerminalServerSession();
BOOL   APIENTRY  tlFlushLogFileBuffer(HANDLE);

// HCT Assertion API
BOOL   APIENTRY  tlhct_StartAssertion_W(HANDLE,LPCWSTR,int,LPCWSTR,LPCWSTR,LPCWSTR);
BOOL   APIENTRY  tlhct_StartAssertion_A(HANDLE,LPCSTR,int,LPCSTR,LPCSTR,LPCSTR);
BOOL   APIENTRY  tlhct_InfoAssertion_W(HANDLE,LPCWSTR,int,LPCWSTR,DWORD,LPCWSTR);
BOOL   APIENTRY  tlhct_InfoAssertion_A(HANDLE,LPCSTR,int,LPCSTR,DWORD,LPCSTR);
BOOL   APIENTRY  tlhct_EndAssertion_W(HANDLE,LPCWSTR,int,LPCWSTR,LPCWSTR);
BOOL   APIENTRY  tlhct_EndAssertion_A(HANDLE,LPCSTR,int,LPCSTR,LPCSTR);
BOOL   APIENTRY  tlhct_LogToolInfo_W(HANDLE,LPCWSTR,int,LPCWSTR,LPCWSTR);
BOOL   APIENTRY  tlhct_LogToolInfo_A(HANDLE,LPCSTR,int,LPCSTR,LPCSTR);


#ifdef UNICODE
#define tlCreateLog         tlCreateLog_W
#define tlCreateLogEx       tlCreateLogEx_W
#define tlParseCmdLine      tlParseCmdLine_W
#define tlGetLogFileName    tlGetLogFileName_W
#define tlSetLogFileName    tlSetLogFileName_W
#define tlLogX              tlLogX_W
#define tlLog               tlLog_W
#define tlAdjustFileName    tlAdjustFileName_W
#define tlhct_StartAssertion(hLog, Assert, Title, Desc)  tlhct_StartAssertion_W(hLog, TEXT(__FILE__), __LINE__, Assert, Title, Desc)
#define tlhct_InfoAssertion(hLog, Assert, Title, Desc)   tlhct_InfoAssertion_W(hLog, TEXT(__FILE__), __LINE__, Assert, Title, Desc)
#define tlhct_EndAssertion(hLog, Assert, Result)         tlhct_EndAssertion_W(hLog, TEXT(__FILE__), __LINE__, Assert, Result)
#define tlhct_LogToolInfo(hLog, Test, Version)           tlhct_LogToolInfo_W(hLog, TEXT(__FILE__), __LINE__, Test, Version)

#else
#define tlCreateLog         tlCreateLog_A
#define tlCreateLogEx       tlCreateLogEx_A
#define tlParseCmdLine      tlParseCmdLine_A
#define tlGetLogFileName    tlGetLogFileName_A
#define tlSetLogFileName    tlSetLogFileName_A
#define tlLogX              tlLogX_A
#define tlLog               tlLog_A
#define tlAdjustFileName    tlAdjustFileName_A
#define tlhct_StartAssertion(hLog, Assert, Title, Desc)  tlhct_StartAssertion_A(hLog, __FILE__, __LINE__, Assert, Title, Desc)
#define tlhct_InfoAssertion(hLog, Assert, Title, Desc)   tlhct_InfoAssertion_A(hLog, __FILE__, __LINE__, Assert, Title, Desc)
#define tlhct_EndAssertion(hLog, Assert, Result)         tlhct_EndAssertion_A(hLog, __FILE__, __LINE__, Assert, Result)
#define tlhct_LogToolInfo(hLog, Test, Version)           tlhct_LogToolInfo_A(hLog, __FILE__, __LINE__, Test, Version)
#endif

// HCT Assertion ResultCodes
/* dwResultCode values for calls to hct_InfoAssertion() */
#define HCT_PASS    0
#define HCT_FAIL    1
#define HCT_WARN    2
#define HCT_INFO    3


// RATS MACROS
//   These macros are provided as a common logging interface which is
//   compatible with the RATS logging-macros.
//
#define TESTDATA                 HANDLE        hLog;
#define TESTOTHERDATA            extern HANDLE hLog;


//  These must be useless.  TL_* macros do not include TLS_TEST or
//  TLS_VARIATION, so they DO NOT count in the stats.  Leaving them around
//  for 'backwards compatibility, if anyone was actually using them...
//
#define L_PASS                   hLog,TL_PASS
#define L_WARN                   hLog,TL_WARN
#define L_DEBUG                  hLog,TL_TESTDEBUG
#define L_TRACE                  hLog,TL_SYSTEM
#define L_FAIL                   hLog,TL_SEV1
#define L_FAIL2                  hLog,TL_SEV2
#define L_FAIL3                  hLog,TL_SEV3
#define L_BLOCK                  hLog,TL_BLOCK


//  macros for incrementing test/variation counts for various log levels
//
#define L_TESTPASS                   hLog,TLS_TEST | TL_PASS
#define L_TESTWARN                   hLog,TLS_TEST | TL_WARN
#define L_TESTDEBUG                  hLog,TLS_TEST | TL_TESTDEBUG
#define L_TESTTRACE                  hLog,TLS_TEST | TL_SYSTEM
#define L_TESTFAIL                   hLog,TLS_TEST | TL_SEV1
#define L_TESTFAIL2                  hLog,TLS_TEST | TL_SEV2
#define L_TESTFAIL3                  hLog,TLS_TEST | TL_SEV3
#define L_TESTBLOCK                  hLog,TLS_TEST | TL_BLOCK
#define L_TESTABORT                  hLog,TLS_TEST | TL_ABORT

#define L_VARPASS                   hLog,TLS_VARIATION | TL_PASS
#define L_VARWARN                   hLog,TLS_VARIATION | TL_WARN
#define L_VARDEBUG                  hLog,TLS_VARIATION | TL_TESTDEBUG
#define L_VARTRACE                  hLog,TLS_VARIATION | TL_SYSTEM
#define L_VARFAIL                   hLog,TLS_VARIATION | TL_SEV1
#define L_VARFAIL2                  hLog,TLS_VARIATION | TL_SEV2
#define L_VARFAIL3                  hLog,TLS_VARIATION | TL_SEV3
#define L_VARBLOCK                  hLog,TLS_VARIATION | TL_BLOCK
#define L_VARABORT                  hLog,TLS_VARIATION | TL_ABORT


#define TESTBEGIN(cmd,logfilename){                                                       \
                                      DWORD __tlFlags;                                    \
                                      __tlFlags = tlParseCmdLine(cmd);                    \
                                      hLog      = tlCreateLog(logfilename,__tlFlags);     \
                                      tlAddParticipant(hLog,0l,0);

#define TESTEND                       tlRemoveParticipant(hLog);                          \
                                      tlDestroyLog(hLog);                                 \
                                  }

#define VARIATION(name,flags)    if(tlStartVariation(hLog))                                                  \
                                 {                                                                           \
                                     DWORD __dwResult;                                                       \
                                     tlLog(hLog,TL_VARIATION,TEXT("%s"),(LPTSTR)name);

#define ENDVARIATION                 __dwResult = tlEndVariation(hLog);                                      \
                                     tlLog(hLog,__dwResult | TL_VARIATION,TEXT("End Variation reported"));   \
                                 }


#define ENTERTHREAD(_hLG,_szNM)  {                                                                           \
                                    LPTSTR _lpFN = _szNM;                                                    \
                                    tlAddParticipant(_hLG,0,0);                                              \
                                    tlLog(_hLG,TL_CALLTREE,TEXT("Entering %s()"),(LPTSTR)_lpFN);


#define LEAVETHREAD(_hLG,_ret)                                                                               \
                                    tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);             \
                                    tlRemoveParticipant(_hLG);                                               \
                                    return(_ret);                                                            \
                                 }

#define LEAVETHREADVOID(_hLG)                                                                                \
                                     tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);            \
                                     tlRemoveParticipant(_hLG);                                              \
                                     return;                                                                 \
                                 }


// Macro to report variation PASS/FAIL statistic (based on an expression)
//
#define THPRINTF                tlLog
#define TESTRESULT(expr,msg)    (expr) ? tlLog(L_TESTPASS,TEXT("%s"),(LPTSTR)msg) : tlLog(L_TESTFAIL2,TEXT("%s"),(LPTSTR)msg)
#define TESTFAIL(msg)           TESTSEV2(msg)
#define TESTSEV1(msg)           tlLog(L_TESTFAIL ,TEXT("%s"),(LPTSTR)msg);
#define TESTSEV2(msg)           tlLog(L_TESTFAIL2,TEXT("%s"),(LPTSTR)msg);
#define TESTSEV3(msg)           tlLog(L_TESTFAIL3,TEXT("%s"),(LPTSTR)msg);
#define TESTPASS(msg)           tlLog(L_TESTPASS ,TEXT("%s"),(LPTSTR)msg);
#define TESTABORT(msg)          tlLog(L_TESTABORT,TEXT("%s"),(LPTSTR)msg);
#define TESTWARN(expr,msg)      if(expr) tlLog(L_TESTWARN,TEXT("%s"),(LPTSTR)msg);
#define TESTBLOCK(expr,msg)     if(expr) tlLog(L_TESTBLOCK,TEXT("%s"),(LPTSTR)msg);

#define VARRESULT(expr,msg)    (expr) ? tlLog(L_VARPASS,TEXT("%s"),(LPTSTR)msg) : tlLog(L_VARFAIL2,TEXT("%s"),(LPTSTR)msg)
#define VARFAIL(msg)           VARSEV2(msg)
#define VARSEV1(msg)           tlLog(L_VARFAIL ,TEXT("%s"),(LPTSTR)msg);
#define VARSEV2(msg)           tlLog(L_VARFAIL2,TEXT("%s"),(LPTSTR)msg);
#define VARSEV3(msg)           tlLog(L_VARFAIL3,TEXT("%s"),(LPTSTR)msg);
#define VARPASS(msg)           tlLog(L_VARPASS ,TEXT("%s"),(LPTSTR)msg);
#define VARABORT(msg)          tlLog(L_VARABORT,TEXT("%s"),(LPTSTR)msg);
#define VARWARN(expr,msg)      if(expr) tlLog(L_VARWARN,TEXT("%s"),(LPTSTR)msg);
#define VARBLOCK(expr,msg)     if(expr) tlLog(L_VARBLOCK,TEXT("%s"),(LPTSTR)msg);


#define VAR_SI          0x01                                 // Ship Issue
#define VAR_NSI         0x02                                 // Non-ship Issue
#define VAR_LI          0x03                                 // Less Important
#define VAR_ISSUE_MASK  0x03                                 // To get ship-issue bits only
#define VAR_TIMEABLE    0x04                                 // Var. used in timing suites
#define CORE_API        0x08                                 // API is in most used list
#define CORE_SI         (CORE_API | VAR_TIMEABLE | VAR_SI )  //
#define CORE_NSI        (CORE_API | VAR_TIMEABLE | VAR_NSI)  //
#define NONCORE_SI      (VAR_TIMEABLE | VAR_SI )             //
#define NONCORE_NSI     (VAR_TIMEABLE | VAR_NSI)             //



// CALLTREE Macros
//   These macros are useful for bracketing function-calls.
//
#define ENTER(_hLG,_szNM) {                                                                 \
                              LPTSTR _lpFN = _szNM;                                         \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Entering %s()"),(LPTSTR)_lpFN);


#define LEAVE(_hLG,_ret)                                                                    \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);  \
                              return(_ret);                                                 \
                          }

#define LEAVEVOID(_hLG)                                                                     \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);  \
                              return;                                                       \
                          }

#ifdef __cplusplus
}
#endif

#define LPSZ_KEY_EMPTY    TEXT("None")
#define LPSZ_TERM_SERVER  TEXT("Terminal Server")

#endif  // _NTLOG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\ifilttst\utility.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       utility.cxx
//
//  Contents:   Helpful functions
//
//  Classes:    
//
//  Functions:  == and != for STAT_CHUNK, StrToGuid, HexStrToULONG
//              StrToPropspec, GuidToPwc
//
//  Coupling:   
//
//  Notes:      
//
//  History:    9-24-1996   ericne   Created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#include "utility.hxx"
#include "mydebug.hxx"

//+---------------------------------------------------------------------------
//
//  Function:   FreePropVariant
//
//  Synopsis:   Frees the memory associated with the PROPVARIANT struct
//
//  Arguments:  [pPropValue] -- pointer to a PROPVARIANT
//
//  Returns:    VOID
//
//  History:    10-14-1996   ericne   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void FreePropVariant( PROPVARIANT *& pPropValue )
{

    HRESULT hResult = PropVariantClear( pPropValue );

    _ASSERT( S_OK == hResult );

    CoTaskMemFree( pPropValue );

} //FreePropVariant


//+---------------------------------------------------------------------------
//
//  Function:   StrToGuid
//
//  Synopsis:   Converts a precisely formatted string into a GUID
//
//  Arguments:  [szString] -- the string containing the guid information
//              [pGuid]    -- a pointer to the guid
//
//  Returns:    TRUE if successful, FALSE if some error occurs
//
//  History:    9-23-1996   ericne   Created
//
//  Notes:      This functions does extensive error checking to make
//              sure it has a correctly formatted guid string.
//
//----------------------------------------------------------------------------

BOOL StrToGuid( LPCTSTR szString, GUID *pGuid )
{
    // Here is a sample guid string:
    // AA568EEC-E0E5-11CF-8FDA-00AA00A14F93 
    
    int     iIndex = 0;
    int     iCounter = 0;
    ULONG   ulTemp = 0;

    // Make sure the input string is formatted correctly
    if( _T('-')  != szString[8]  || _T('-') != szString[13] || 
        _T('-')  != szString[18] || _T('-') != szString[23] || 
        _T('\0') != szString[36] )
    {
        printf( "Unable to parse guid %s\r\n", szString );
        return( FALSE );
    }

    // Fill in the first 3 guid fields:
    if( ! HexStrToULONG( &szString[0], 8, &ulTemp  ) )
        return( FALSE );
    pGuid->Data1 = ulTemp;
    
    if( ! HexStrToULONG( &szString[9], 4, &ulTemp  ) )
        return( FALSE );
    pGuid->Data2 = ( USHORT )ulTemp;
    
    if( ! HexStrToULONG( &szString[14], 4, &ulTemp  ) )
        return( FALSE );
    pGuid->Data3 = ( USHORT )ulTemp;
    
    // Fill in the first two characters in the 4th guid field
    if( ! HexStrToULONG( &szString[19], 2, &ulTemp  ) )
        return( FALSE );
    pGuid->Data4[0] = (unsigned char)ulTemp;

    if( ! HexStrToULONG( &szString[21], 2, &ulTemp  ) )
        return( FALSE );
    pGuid->Data4[1] = (unsigned char)ulTemp;

    // Fill in the rest of the 4th guid field:
    for( iCounter = 24, iIndex = 2; 
         ( iCounter < 36 ) && ( iIndex < 8 ); 
         iCounter += 2, ++iIndex )
    {
        if( ! HexStrToULONG( &szString[iCounter], 2, &ulTemp  ) )
            return( FALSE );
        pGuid->Data4[iIndex] = (unsigned char)ulTemp;
    }

    return( TRUE );
} //StrToGuid

//+---------------------------------------------------------------------------
//
//  Function:   HexStrToULONG
//
//  Synopsis:   Uses strtoul to convert a string of hex digits to an
//              unsigned long.
//
//  Arguments:  [szHexString]  -- The string to convert
//              [uiStopOffset] -- The number of digits to consider
//              [pUlong]       -- a pointer to the ULONG to fill in
//
//  Returns:    TRUE if successful, FALSE if the string cannot be converted
//
//  History:    9-23-1996   ericne   Created
//
//  Notes:      The main purpose of this function is to catch possible user
//              typos of the form '-fff', where the leading hyphen could be
//              misinterpreted by strtoul as a minus sign.
//
//----------------------------------------------------------------------------

BOOL HexStrToULONG( LPCTSTR szHexString, UINT uiStopOffset, ULONG *pUlong )
{
    LPTSTR szStopString = NULL;
    ULONG ulTemp = 0;
    TCHAR szStringToChange[ MAX_LINE_SIZE ];
    
    if( MAX_LINE_SIZE <= uiStopOffset )
    {
        printf( "ERROR in HexStrToULONG.  uiStopOffset too large\r\n" );
        return( FALSE );
    }

    // copy the part of the string to be converted into its own buffer
    _tcsncpy( szStringToChange, szHexString, uiStopOffset );
    szStringToChange[ uiStopOffset ] = '\0';

    // First, make sure the leading character is not a '-'
    if( _T('-') == *szStringToChange )
    {
        printf( "Parsing error: Unable to convert %s to unsigned long\r\n", 
                szStringToChange );
        return( FALSE );
    }

    // Convert the string to an unsigned long
    ulTemp = _tcstoul( szStringToChange, &szStopString, 16 );

    // Make sure the stop offset is correct
    if( szStopString != szStringToChange + uiStopOffset )
    {
        printf( "Parsing error: Unable to convert %s to unsigned long\r\n", 
                szStringToChange );
        return( FALSE );
    }

    (*pUlong) = ulTemp;

    return( TRUE );

} //HexStrToULONG

//+---------------------------------------------------------------------------
//
//  Function:   StrToPropspec
//
//  Synopsis:   converts a string to a PROPSPEC structure
//
//  Arguments:  [szString]  -- the ANSI string
//              [pPropspec] -- a pointer to the PROPSPEC structure
//
//  Returns:    TRUE if successful, FALSE if an error occurs.
//
//  History:    9-23-1996   ericne   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

BOOL StrToPropspec( LPCTSTR szString, PROPSPEC *pPropspec )
{
    UINT    uiStringLength = _tcslen( szString );
    ULONG   ulTemp = 0;

    // If " is the first and last char in the PropSpec buffer,
    // treat it like a string.
    if( _T('\"') == szString[0] && _T('\"') == szString[ uiStringLength - 1 ] )
    {
        pPropspec->ulKind = PRSPEC_LPWSTR;

        // Allocate an array of wide characters:
        pPropspec->lpwstr = NEW WCHAR[ uiStringLength - 1 ];
        
        // Write the string into the buffer not including leading or trailing
        // double-quotes
        _snwprintf( pPropspec->lpwstr, uiStringLength - 2, L"%s", &szString[1]);
        pPropspec->lpwstr[ uiStringLength - 2 ] = _T('\0');
    }
    // Otherwise, treat it like a propid
    else
    {
        pPropspec->ulKind = PRSPEC_PROPID;
        
        // Convert the propid string into a propid
        if( ! HexStrToULONG( szString, uiStringLength, &ulTemp ) )
            return( FALSE );
        pPropspec->propid = ulTemp;
    }

    return( TRUE );

} //StrToPropspec

//+---------------------------------------------------------------------------
//
//  Function:   GetStringFromCLSID
//
//  Synopsis:   Converts a clsid (a.k.a. guid) to a string
//
//  Arguments:  [refclsid] -- 
//              [szString] -- 
//              [count]    -- 
//
//  Returns:    
//
//  History:    2-04-1997   ericne   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

LPTSTR GetStringFromCLSID( REFCLSID refclsid, LPTSTR szString, size_t count)
{
    _sntprintf( szString, count,
                _T("%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X"),
                refclsid.Data1,
                refclsid.Data2,
                refclsid.Data3,
                refclsid.Data4[0],
                refclsid.Data4[1],
                refclsid.Data4[2],
                refclsid.Data4[3],
                refclsid.Data4[4],
                refclsid.Data4[5],
                refclsid.Data4[6],
                refclsid.Data4[7] );

    return( szString );

} //GetStringFromCLSID
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\loccat\loccat.cxx ===
//+-------------------------------------------------------------------------
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (c) Microsoft Corporation, 1999 - 1999.  All Rights Reserved.
//
// PROGRAM:  loccat.cxx
//
// PURPOSE:  Illustrates LocateCatalogs usage
//
// PLATFORM: Windows
//
//--------------------------------------------------------------------------

#define UNICODE

#include <stdio.h>
#include <wchar.h>
#include <windows.h>
#include <ole2.h>
#include <ntquery.h>

void Usage()
{
    printf( "usage: loccat path\n" );
    exit( 1 );
} //Usage

//+-------------------------------------------------------------------------
//
//  Function:   LookupCatalogs
//
//  Synopsis:   Looks for catalogs and machines matching the scope
//
//  Arguments:  [pwcScope]   - The scope used to find the catalog(s)
//
//  Returns:    Result of the operation
//
//--------------------------------------------------------------------------

HRESULT LookupCatalog( WCHAR const * pwcScope )
{
    HRESULT hr;
    int iBmk = 0;

    do
    {
        WCHAR awcMachine[ MAX_PATH ], awcCatalog[ MAX_PATH ];
        ULONG cwcMachine = sizeof awcMachine / sizeof WCHAR;
        ULONG cwcCatalog = sizeof awcCatalog / sizeof WCHAR;

        hr = LocateCatalogs( pwcScope,       // scope to lookup
                             iBmk,           // go with the first match
                             awcMachine,     // returns the machine
                             &cwcMachine,    // buffer size in/out
                             awcCatalog,     // returns the catalog
                             &cwcCatalog );  // buffer size in/out

        if ( S_OK == hr )
        {
            printf( "machine: '%ws', catalog: '%ws'\n", awcMachine, awcCatalog );
            iBmk++;
        }
        else if ( S_FALSE == hr )
        {
            // no more catalogs...

            if ( 0 == iBmk )
                printf( "no catalogs matched the path %ws\n", pwcScope );
        }
        else if ( FAILED( hr ) )
        {
            printf( "LocateCatalogs failed: %#x\n", hr );
        }
    } while ( S_OK == hr );

    return hr;
} //LookupCatalogs

//+-------------------------------------------------------------------------
//
//  Function:   wmain
//
//  Synopsis:   Entry point for the app.
//
//  Arguments:  [argc]     - Argument count
//              [argv]     - Arguments
//
//--------------------------------------------------------------------------

extern "C" int __cdecl wmain( int argc, WCHAR * argv[] )
{
    if ( 2 != argc )
        Usage();

    HRESULT hr = LookupCatalog( argv[1] );

    if ( FAILED( hr ) )
        return -1;

    return 0;
} //wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\ifilttst\workq.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       workq.cxx
//
//  Contents:   Definitions of CWorkQueue methods
//
//  Classes:    
//
//  Functions:  Constructor, destructor, AddItem, GetNextItem, Done
//
//  Coupling:   
//
//  Notes:      For use in uni- or multi-threaded applications
//
//  History:    9-30-1996   ericne   Created
//
//----------------------------------------------------------------------------

#include "workq.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     ::CWorkQueue
//
//  Synopsis:   Initializes members
//
//  Arguments:  (none)
//
//  Returns:    
//
//  History:    9-30-1996   ericne   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

template<class T, int I>
CWorkQueue<T,I>::CWorkQueue()
: m_iAddItemIndex( 0 ),
  m_iGetItemIndex( 0 ),
  m_hSemFull( NULL ),
  m_hSemEmpty( NULL ),
  m_hEventDone( NULL )
  
{
    InitializeCriticalSection( &m_CriticalSection );
    
    // Create a semaphore with an initial count of 0.  Each time
    // GetItem is called, this value is decrimented.  Each time
    // AddItem is called, this value is incremented.
    while( 1 )
    {
        m_hSemFull = CreateSemaphore( NULL,     // No security attributes
                                      0,        // Initial value of 0
                                      I,        // Maximum value of I
                                      NULL );   // No name
        if( NULL != m_hSemFull )
            break;
        printf( "CreateSemaphore failed. Will try again in %d milliseconds.\r\n"
                "GetLastError() returned 0x%08x\r\n", 
                dwSleepTime, GetLastError() );
        Sleep( dwSleepTime );
    }

    // Create a semaphore with an initial count of I.  Each time 
    // AddItem is called, this value is decrimented.  Each time
    // GetItem is called, this value is incremented.
    while( 1 )
    {
        m_hSemEmpty = CreateSemaphore( NULL,    // No security attributes
                                       I,       // Initial value of I
                                       I,       // Maximum value of I
                                       NULL );  // No name
        if( NULL != m_hSemEmpty )
            break;
        printf( "CreateSemaphore failed. Will try again in %d milliseconds.\r\n"
                "GetLastError() returned 0x%08x\r\n", 
                dwSleepTime, GetLastError() );
        Sleep( dwSleepTime );
    }

    // This event is used by a producer thread to signal the consumer threads
    // that no additional work items will be placed in the queue
    while( 1 )
    {
        m_hEventDone = CreateEvent( NULL,   // No security attributes
                                    TRUE,   // Manual reset
                                    FALSE,  // Initial state of non-signaled
                                    NULL ); // No name
        if( NULL != m_hEventDone )
            break;
        printf( "CreateEvent failed. Will try again in %d milliseconds.\r\n"
                "GetLastError() returned 0x%08x\r\n", 
                dwSleepTime, GetLastError() );
        Sleep( dwSleepTime );
    }

} //::CWorkQueue

//+---------------------------------------------------------------------------
//
//  Member:     ::~CWorkQueue
//
//  Synopsis:   Closes the handles to the semaphores
//
//  Arguments:  (none)
//
//  Returns:    
//
//  History:    9-30-1996   ericne   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

template<class T, int I>
CWorkQueue<T,I>::~CWorkQueue()
{

    if( ! CloseHandle( m_hSemFull ) )
        printf( "~CWorkQueue(): Could not close handle to semaphore."
                "GetLastError() returns 0x%08x", GetLastError() );

    if( ! CloseHandle( m_hSemEmpty ) )
        printf( "~CWorkQueue(): Could not close handle to semaphore."
                "GetLastError() returns 0x%08x", GetLastError() );

    if( ! CloseHandle( m_hEventDone ) )
        printf( "~CWorkQueue(): Could not close handle to event."
                "GetLastError() returns 0x%08x", GetLastError() );

    DeleteCriticalSection( &m_CriticalSection );

} //::~CWorkQueue

//+---------------------------------------------------------------------------
//
//  Member:     ::AddItem
//
//  Synopsis:   Adds an item to the queue
//
//  Arguments:  [ToAdd] -- The item to add
//
//  Returns:    none
//
//  History:    9-30-1996   ericne   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

template<class T, int I>
void CWorkQueue<T,I>::AddItem( const T &ToAdd )
{

    // Wait until m_hSemEmpty is greater than zero, then decriment
    if( WAIT_OBJECT_0 != WaitForSingleObject( m_hSemEmpty, INFINITE ) )
        printf( "CWorkQueue::AddItem() : Wait for semaphore failed.\r\n"
                "GetLastError() returns 0x%08x\r\n", GetLastError() );
    
    // enter the critical section
    EnterCriticalSection( &m_CriticalSection );

    // Bit-wise copy the structure
    memcpy( (void*)&m_WorkItems[m_iAddItemIndex], (void*)&ToAdd, sizeof( T ) );

    // Increment the index
    m_iAddItemIndex = ( m_iAddItemIndex + 1 ) % I;

    // Leave the critical section
    LeaveCriticalSection( &m_CriticalSection );

    // Incriment m_hSemFull
    if( ! ReleaseSemaphore( m_hSemFull, 1, NULL ) )
        printf( "CWorkQueue::AddItem() : Could not release semaphore.\r\n"
                "GetLastError() returns 0x%08x\r\n", GetLastError() );

} //::AddItem

//+---------------------------------------------------------------------------
//
//  Member:     ::Done
//
//  Synopsis:   Called by a producer thread when it is finished adding stuff 
//              to the queue
//
//  Arguments:  (none)
//
//  Returns:    void
//
//  History:    10-01-1996   ericne   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

template<class T, int I>
void CWorkQueue<T,I>::Done( )
{

    // Since this is a manual-reset event, m_hEventDone stays signaled forever.
    SetEvent( m_hEventDone );

} //::Done

//+---------------------------------------------------------------------------
//
//  Member:     ::GetItem
//
//  Synopsis:   Gets the next work item from the queue.
//
//  Arguments:  [NextItem] -- Passed by reference.  Item is filled in by 
//                            the function
//
//  Returns:    TRUE if an item was gotten from the queue
//              FALSE if queue is empty and m_hEventDone is signaled
//
//  History:    9-30-1996   ericne   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

template<class T, int I>
BOOL CWorkQueue<T,I>::GetItem( T &NextItem )
{

    DWORD dwWait = 0;
    HANDLE pHandles[2] = { m_hSemFull, m_hEventDone };

    // wait until m_hSemFull is > 0 or until m_hEventDone is set
    dwWait = WaitForMultipleObjects( 2, pHandles, FALSE, INFINITE );

    if( WAIT_OBJECT_0 == dwWait ) 
    {
        // There are more work items in the list 
        // ( done event may or may not be set )
        
        EnterCriticalSection( &m_CriticalSection );
    
        memcpy( (void*) &NextItem, 
                (void*) &m_WorkItems[m_iGetItemIndex], 
                sizeof( T ) );

        m_iGetItemIndex = ( m_iGetItemIndex + 1 ) % I;

        LeaveCriticalSection( &m_CriticalSection );
    
        if( ! ReleaseSemaphore( m_hSemEmpty, 1, NULL ) )
            printf( "CWorkQueue::GetItem() : Could not release semaphore.\r\n"
                    "GetLastError() returns 0x%08x\r\n", GetLastError() );

        return( TRUE );

    }
    else if( WAIT_OBJECT_0 + 1 == dwWait )
    {
        // Nothing more in list and done event has been set        
    }
    else
    {
        // An error occured
        printf( "CWorkQueue::GetItem() : Wait failed.\r\n"
                "GetLastError() returns 0x%08x\r\n", GetLastError() );
    }

    return( FALSE );

} //::GetItem
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\lrsample\lrsample.cxx ===
//+-------------------------------------------------------------------------
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1998 - 2001 Microsoft Corporation.  All Rights Reserved.
//
// PROGRAM:  lrsample.cxx
//
// PURPOSE:  Sample wordbreaker and stemmer.
//
// PLATFORM: Windows 2000 and later
//
//--------------------------------------------------------------------------

#include <stdio.h>
#include <wchar.h>

#include <windows.h>
#include <objidl.h>
#include <indexsrv.h>
#include <cierror.h>
#include <filterr.h>

#include "lrsample.hxx"
#include "filtreg.hxx"
#include "langreg.hxx"

//#define LEXICON_STEMMER
//#define PORTER_STEMMER
#define SIMPLE_LIST_STEMMER

// The CLSID for the wordbreaker

CLSID CLSID_SampleWordBreaker = /* d225281a-7ca9-4a46-ae7d-c63a9d4815d4 */
{
    0xd225281a,  0x7ca9, 0x4a46,
    {0xae, 0x7d, 0xc6, 0x3a, 0x9d, 0x48, 0x15, 0xd4}
};

// The CLSID of the stemmer

CLSID CLSID_SampleStemmer = /* 0a275611-aa4d-4b39-8290-4baf77703f55 */
{
    0x0a275611, 0xaa4d, 0x4b39,
    {0x82, 0x90, 0x4b, 0xaf, 0x77, 0x70, 0x3f, 0x55}
};

// Global module refcount

long g_cInstances = 0;
HMODULE g_hModule = 0;

#ifdef PORTER_STEMMER

    #include "porter.hxx"

#endif //PORTER_STEMMER

#ifdef LEXICON_STEMMER

    #include "stem.hxx"

    CStem * g_pStem = 0;

#endif //LEXICON_STEMMER

#ifdef SIMPLE_LIST_STEMMER

    // This is just a simple hard-coded list of words and stem forms.

    struct SStemForm
    {
        USHORT iList; // first index into aStems
        USHORT iForm; // second index into aStems
    };

    const SStemForm aStemForms[] =
    {
        {  0, 0 },     // abide
        {  0, 2 },     // abided
        {  0, 4 },     // abides
        {  0, 3 },     // abiding
        {  0, 1 },     // abode
        {  1, 0 },     // bat
        {  2, 0 },     // batch
        {  2, 2 },     // batched
        {  2, 1 },     // batches
        {  2, 3 },     // batching
        {  1, 1 },     // bats
        {  1, 2 },     // batted
        {  1, 3 },     // batting
        {  3, 0 },     // bear
        {  3, 1 },     // bears
        {  4, 1 },     // began
        {  4, 0 },     // begin
        {  4, 3 },     // beginning
        {  4, 4 },     // begins
        {  4, 2 },     // begun
        {  3, 2 },     // bore
        {  3, 4 },     // born
        {  3, 3 },     // borne
        {  5, 0 },     // dance
        {  5, 1 },     // danced
        {  5, 2 },     // dances
        {  5, 3 },     // dancing
        {  6, 0 },     // heave
        {  6, 1 },     // heaved
        {  6, 3 },     // heaves
        {  6, 4 },     // heaving
        {  7, 0 },     // hero
        {  7, 1 },     // heroes
        {  6, 2 },     // hove
        {  8, 0 },     // keep
        {  8, 4 },     // keeping
        {  8, 1 },     // keeps
        {  8, 2 },     // kept
        {  9, 0 },     // misspell
        {  9, 1 },     // misspelled
        {  9, 3 },     // misspelling
        {  9, 4 },     // misspells
        {  9, 2 },     // misspelt
        { 10, 0 },     // plead
        { 10, 1 },     // pleaded
        { 10, 3 },     // pleading
        { 10, 4 },     // pleads
        { 10, 0 },     // pled
        { 11, 2 },     // ran
        { 11, 0 },     // run
        { 11, 3 },     // running
        { 11, 1 },     // runs
        { 12, 1 },     // swam
        { 12, 0 },     // swim
        { 12, 3 },     // swimming
        { 12, 4 },     // swims
        { 12, 2 },     // swum
        { 13, 2 },     // underlain
        { 13, 1 },     // underlay
        { 13, 0 },     // underlie
        { 13, 4 },     // underlies
        { 13, 3 },     // underlying
    };

    const ULONG cStemForms = ArraySize( aStemForms );
    const ULONG cMaxStemForms = 8;

    const WCHAR * aStems[][ cMaxStemForms ] =
    {
        { L"abide", L"abode", L"abided", L"abiding", L"abides" },     // 0
        { L"bat", L"bats", L"batted", L"batting" },                   // 1
        { L"batch", L"batches", L"batched", L"batching" },            // 2
        { L"bear", L"bears", L"bore", L"borne", L"born" },            // 3
        { L"begin", L"began", L"begun", L"beginning", L"begins" },    // 4
        { L"dance", L"danced", L"dances", L"dancing" },               // 5
        { L"heave", L"heaved", L"hove", L"heaves", L"heaving" },      // 6
        { L"hero", L"heroes" },                                       // 7
        { L"keep", L"keeps", L"kept", L"keeping" },                   // 8
        { L"misspell", L"misspelled", L"misspelt", L"misspelling",
          L"misspells" },                                             // 9
        { L"plead", L"pleaded", L"pled", L"pleading", L"pleads" },    // 10
        { L"run", L"runs", L"ran", L"running" },                      // 11
        { L"swim", L"swam", L"swum", L"swimming", L"swims" },         // 12
        { L"underlie", L"underlay", L"underlain", L"underlying",
          L"underlies" },                                             // 13
    };

    int __cdecl StemCompare( const void *p1, const void *p2 )
    {
        SStemForm const * pForm = (SStemForm const *) p2;
        WCHAR const * pwcWord = (WCHAR const *) p1;
        return wcscmp( pwcWord, aStems[ pForm->iList ][ pForm->iForm ] );
    }

#endif // SIMPLE_LIST_STEMMER

//+-------------------------------------------------------------------------
//
//  Function:   IsWordChar
//
//  Synopsis:   Find whether the i'th character in the buffer _pwcChunk
//              is a word character (rather than word break)
//
//  Arguments:  [pwcChunk] -- Characters whose type information is checked
//              [i]        -- Index of character to check
//              [pInfo1]   -- Type 1 information
//              [pInfo3]   -- Type 3 information
//
//  Returns:    TRUE if the character is a word character
//              FALSE if it's a word breaking character
//
//--------------------------------------------------------------------------

__forceinline BOOL IsWordChar(
    WCHAR const * pwcChunk,
    int           i,
    WORD const *  pInfo1,
    WORD const *  pInfo3 )
{
    // Any alphabetic, digit, or non-spacing character is part of a word

    if ( ( 0 != ( pInfo1[i] & ( C1_ALPHA | C1_DIGIT ) ) ) ||
         ( 0 != ( pInfo3[i] & C3_NONSPACING ) ) )
        return TRUE;

    WCHAR c = pwcChunk[i];

    // Underscore is part of a word

    if ( L'_' == c )
        return TRUE;

    //
    // A non-breaking space followed by a non-spacing character should not
    // be a word breaker.
    //

    if ( 0xa0 == c ) // non breaking space
    {
        // followed by a non-spacing character (looking ahead is okay)

        if ( 0 != ( pInfo3[i+1] & C3_NONSPACING ) )
            return TRUE;
    }

    return FALSE;
} //IsWordChar

//+---------------------------------------------------------------------------
//
//  Function:   ScanChunk
//
//  Synopsis:   For each character find its type information flags
//
//  Arguments:  [pwcChunk] -- Characters whose type information is retrieved
//              [cwc]      -- Number of characters to scan
//              [pInfo1]   -- Type 1 information is written here
//              [pInfo3]   -- Type 3 information is written here
//
//  Returns:    S_OK if successful or an error code
//
//----------------------------------------------------------------------------

HRESULT ScanChunk(
    WCHAR const * pwcChunk,
    ULONG         cwc,
    WORD *        pInfo1,
    WORD *        pInfo3 )
{
    if ( !GetStringTypeW( CT_CTYPE1,         // POSIX character typing
                          pwcChunk,          // Source
                          cwc,               // Size of source
                          pInfo1 ) )         // Character info 1
        return HRESULT_FROM_WIN32( GetLastError() );

    if ( !GetStringTypeW( CT_CTYPE3,         // Additional POSIX
                          pwcChunk,          // Source
                          cwc,               // Size of source
                          pInfo3 ) )         // Character info 3
        return HRESULT_FROM_WIN32( GetLastError() );

    return S_OK;
} //ScanChunk

//+---------------------------------------------------------------------------
//
//  Member:     CSampleWordBreaker::Tokenize
//
//  Synopsis:   Break a block of text into individual words
//
//  Arguments:  [pTextSource]  -- Source of characters to work on
//              [cwc]          -- Number of characters to process
//              [pWordSink]    -- Where to send the words found
//              [cwcProcessed] -- Returns the # of characters tokenized
//
//  Returns:    S_OK if successful or an error code
//
//----------------------------------------------------------------------------

HRESULT CSampleWordBreaker::Tokenize(
    TEXT_SOURCE * pTextSource,
    ULONG         cwc,
    IWordSink *   pWordSink,
    ULONG &       cwcProcessed )
{
    // Leave space for one (unused) lookahead

    WORD aInfo1[ CSampleWordBreaker::cwcAtATime + 1 ];
    WORD aInfo3[ CSampleWordBreaker::cwcAtATime + 1 ];

    // Initialize this so we can go 1 beyond in IsWordChar()

    aInfo3 [ CSampleWordBreaker::cwcAtATime ] = C3_NONSPACING;

    // Get a pointer to the text we'll be working on

    const WCHAR * pwcChunk = &pTextSource->awcBuffer[ pTextSource->iCur ];

    HRESULT hr = ScanChunk( pwcChunk, cwc, aInfo1, aInfo3 );
    if ( FAILED( hr ) )
        return hr;

    BOOL fWordHasZWS = FALSE; // Does the current word have a 0-width-space?
    ULONG cwcZWS;             // Length of word minus embedded 0-width-spaces

    //
    // iBeginWord is the offset into aInfoX of the beginning character of
    // a word.  iCur is the first unprocessed character.
    // They are indexes into the current block (_pwcChunk).
    //

    ULONG iBeginWord = 0;
    ULONG iCur = 0;

    // Temp buffer for a word having zero-width space

    WCHAR awcBufZWS[ CSampleWordBreaker::cwcAtATime ];

    // Send words from the current block to word sink

    while ( iCur < cwc )
    {
        // Skip whitespace, punctuation, etc.

        for (; iCur < cwc; iCur++)
            if ( IsWordChar( pwcChunk, iCur, aInfo1, aInfo3 ) )
                break;

        // iCur points to a word char or is equal to cwc

        iBeginWord = iCur;
        if ( iCur < cwc )
            iCur++; // we knew it pointed at word character

        //
        // Find word break. Filter may output Unicode zero-width-space, which
        // should be ignored by the wordbreaker.
        //

        fWordHasZWS = FALSE;
        for ( ; iCur < cwc; iCur++ )
        {
            if ( !IsWordChar( pwcChunk, iCur, aInfo1, aInfo3 ) )
            {
                if ( ZERO_WIDTH_SPACE == pwcChunk[iCur] )
                    fWordHasZWS = TRUE;
                else
                    break;
            }
        }

        if ( fWordHasZWS )
        {
            // Copy word into awcBufZWS after stripping zero-width-spaces

            cwcZWS = 0;
            for ( ULONG i = iBeginWord; i < iCur; i++ )
            {
                if ( ZERO_WIDTH_SPACE != pwcChunk[i] )
                    awcBufZWS[cwcZWS++] = pwcChunk[i];
            }
        }

        // iCur points to a non-word char or is equal to cwc

        if ( iCur < cwc )
        {
            // store the word and its source position

            if ( fWordHasZWS )
                hr = pWordSink->PutWord( cwcZWS,
                                         awcBufZWS,    // stripped word
                                         iCur - iBeginWord,
                                         pTextSource->iCur + iBeginWord );
            else
                hr = pWordSink->PutWord( iCur - iBeginWord,
                                         pwcChunk + iBeginWord, // the word
                                         iCur - iBeginWord,
                                         pTextSource->iCur + iBeginWord );

            if ( FAILED( hr ) )
                return hr;

            iCur++; // we knew it pointed at non-word char
            iBeginWord = iCur; // in case we exit the loop now
        }
    } // next word

    // End of words in chunk.
    // iCur == cwc
    // iBeginWord points at beginning of word or == cwc

    if ( 0 == iBeginWord )
    {
        // A single word fills from beginning of this chunk
        // to the end. This is either a very long word or
        // a short word in a leftover buffer.

        // store the word and its source position

        if ( fWordHasZWS )
            hr = pWordSink->PutWord( cwcZWS,
                                     awcBufZWS,          // stripped word
                                     iCur,
                                     pTextSource->iCur ); // its source pos.
        else
            hr = pWordSink->PutWord( iCur,
                                     pwcChunk,           // the word
                                     iCur,
                                     pTextSource->iCur ); // its source pos.

        if ( FAILED( hr ) )
            return hr;

        // Position it to not add the word twice.

        iBeginWord = iCur;
    }

    //
    // If this is the last chunk from text source, then process the
    // last fragment.
    //

    if ( ( cwc < CSampleWordBreaker::cwcAtATime ) && ( iBeginWord != iCur ) )
    {
        // store the word and its source position

        if ( fWordHasZWS )
            hr = pWordSink->PutWord( cwcZWS,
                                     awcBufZWS,    // stripped word
                                     iCur - iBeginWord,
                                     pTextSource->iCur + iBeginWord );
        else
            hr = pWordSink->PutWord( iCur - iBeginWord,
                                     pwcChunk + iBeginWord,  // the word
                                     iCur - iBeginWord,
                                     pTextSource->iCur + iBeginWord );

        if ( FAILED( hr ) )
            return hr;

        iBeginWord = iCur;
    }

    cwcProcessed = iBeginWord;
    return S_OK;
} //Tokenize

//+---------------------------------------------------------------------------
//
//  Member:     CSampleWordBreaker::BreakText
//
//  Synopsis:   Break a block of text into individual words
//
//  Arguments:  [pTextSource]  -- Source of characters to work on
//              [pWordSink]    -- Where to send the words found
//              [pPhraseSink]  -- Where to send the phrases found (not used)
//
//  Returns:    S_OK if successful or an error code
//
//----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CSampleWordBreaker::BreakText(
    TEXT_SOURCE * pTextSource,
    IWordSink *   pWordSink,
    IPhraseSink * pPhraseSink )
{
    // Validate arguments

    if ( 0 == pTextSource )
        return E_INVALIDARG;

    if ( ( 0 == pWordSink ) || ( pTextSource->iCur == pTextSource->iEnd ) )
        return S_OK;

    if ( pTextSource->iCur > pTextSource->iEnd )
        return E_INVALIDARG;

    ULONG cwcProcessed;   // # chars actually processed by Tokenize()
    HRESULT hr = S_OK;

    // Pull text from the text source and tokenize it

    do
    {
        BOOL fFirstTime = TRUE;

        while ( pTextSource->iCur < pTextSource->iEnd )
        {
            ULONG cwc = pTextSource->iEnd - pTextSource->iCur;

            // Process in buckets of cwcAtATime only
                  
            if ( cwc >= CSampleWordBreaker::cwcAtATime )
                cwc = CSampleWordBreaker::cwcAtATime;
            else if ( !fFirstTime )
                break;

            hr = Tokenize( pTextSource, cwc, pWordSink, cwcProcessed );
            if ( FAILED( hr ) )
                return hr;

            pTextSource->iCur += cwcProcessed;
            fFirstTime = FALSE;
        }

        hr = pTextSource->pfnFillTextBuffer( pTextSource );
    } while ( SUCCEEDED( hr ) );

    //
    // If anything failed except for running out of text, report the error.
    // Otherwise, for cases like out of memory, files will not get retried or
    // reported as failures properly.
    //

    if ( ( FAILED( hr ) ) &&
         ( FILTER_E_NO_MORE_VALUES != hr ) &&
         ( FILTER_E_NO_TEXT != hr ) &&
         ( FILTER_E_NO_VALUES != hr ) &&
         ( FILTER_E_NO_MORE_TEXT != hr ) &&
         ( FILTER_E_END_OF_CHUNKS != hr ) &&
         ( WBREAK_E_END_OF_TEXT != hr ) )
        return hr;

    ULONG cwc = pTextSource->iEnd - pTextSource->iCur;

    if ( 0 == cwc )
        return S_OK;

    return Tokenize( pTextSource, cwc, pWordSink, cwcProcessed );
} //BreakText

//+---------------------------------------------------------------------------
//
//  Member:     CSampleStemmer::GenerateWordForms
//
//  Synopsis:   From the input word, emit the original and alternate forms
//              of the word.
//
//  Arguments:  [pwcInBuf]   -- The original word to stem (not 0-terminated)
//              [cwc]        -- Length in characters of the word
//              [pStemSink]  -- Where to emit the stems
//
//  Returns:    S_OK if successful or an error code
//
//----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CSampleStemmer::GenerateWordForms(
    WCHAR const *   pwcInBuf,
    ULONG           cwc,
    IWordFormSink * pWordFormSink )
{
    // Validate the arguments

    if ( ( 0 == pwcInBuf ) || ( 0 == pWordFormSink ) )
        return E_INVALIDARG;

    HRESULT hr = S_OK;

#ifdef PORTER_STEMMER

    //
    // If the word is small enough, attempt to get the stemmed form of the
    // word.  Emit both forms if they are different.  The Porter algorithm
    // does the opposite of what's required here, but doing the right thing
    // requires a lexicon.
    //

    if ( cwc < cwcMaxPorterWord )
    {
        // Make a temporary buffer for the word

        WCHAR awcPorter[ cwcMaxPorterWord ];
        CopyMemory( awcPorter, pwcInBuf, sizeof(WCHAR) * cwc );
        awcPorter[cwc] = 0;

        // Convert it to lowercase and save the original in lowercase
    
        CharLower( awcPorter );
        WCHAR awcOriginal[ cwcMaxPorterWord ];
        wcscpy( awcOriginal, awcPorter );

        // Get the stemmed form of the word
    
        GetPorterStemForm( awcPorter );

        // If it's different from the original, emit it.

        if ( wcscmp( awcOriginal, awcPorter ) )
        {
            hr = pWordFormSink->PutAltWord( awcPorter,
                                        wcslen( awcPorter ) );
            if ( FAILED( hr ) )
                return hr;
        }
    }

#endif //PORTER_STEMMER

#ifdef LEXICON_STEMMER

    //
    // If the word is small enough to work with the stemmer, attempt to get
    // various forms of the word.
    //

    if ( cwc < cbMaxStem )
    {
        //
        // Convert the original string to 8-bit characters.  This is OK since
        // it's is an English stemmer that can safely assume such characters.
        //

        char acOriginal[ cbMaxStem ];
        for ( unsigned i = 0; i < cwc; i++ )
            acOriginal[ i ] = (char) pwcInBuf[ i ];
        acOriginal[ i ] = 0;

        // Enumerate all stem-sets that contain the word.

        unsigned iBmk = stemInvalid;
        unsigned iStemSet = stemInvalid;
        char ac[ cbMaxStem ];
    
        while ( g_pStem->FindStemSet( acOriginal, iBmk, iStemSet ) )
        {
            // Enumerate all forms of the stem-set, root first.
    
            CStemSet set( g_pStem->GetStemSetRoot(), iStemSet );
            unsigned iStemBmk = stemInvalid;

            while ( set.GetForm( ac, iStemBmk ) )
            {
                if ( strcmp( ac, acOriginal ) )
                {
                    WCHAR awcForm[ cbMaxStem ];
                    mbstowcs( awcForm, ac, -1 );
    
                    hr = pWordFormSink->PutAltWord( awcForm,
                                                wcslen( awcForm ) );
                    if ( FAILED( hr ) )
                        return hr;
                }
            }
        }
    }

#endif //LEXICON_STEMMER

#ifdef SIMPLE_LIST_STEMMER

    // Look up the word in the simple list of stem forms

    SStemForm const * pStemForm = (SStemForm *) bsearch( pwcInBuf,
                                                         aStemForms,
                                                         cStemForms,
                                                         sizeof SStemForm,
                                                         StemCompare );

    if ( 0 != pStemForm )
    {
        // Found it, now iterate all the forms

        ULONG iList = pStemForm->iList;
        ULONG iForm = 0;

        while ( 0 != aStems[ iList ][ iForm ] )
        {
            WCHAR const * pwc = aStems[ iList ][ iForm ];

            // Don't emit the original word yet

            if ( 0 != wcscmp( pwc, pwcInBuf ) )
            {
                hr = pWordFormSink->PutAltWord( pwc,
                                                wcslen( pwc ) );
                if ( FAILED( hr ) )
                    return hr;
            }

            iForm++;
        }
    }

#endif //SIMPLE_LIST_STEMMER

    // Emit the original word

    return pWordFormSink->PutWord( pwcInBuf, cwc );
} //StemWord

//+-------------------------------------------------------------------------
//
//  Method:     CLanguageResourceSampleCF::CLanguageResourceSampleCF
//
//  Synopsis:   Language resource class factory constructor
//
//--------------------------------------------------------------------------

CLanguageResourceSampleCF::CLanguageResourceSampleCF() :
    _lRefs( 1 )
{
    InterlockedIncrement( &g_cInstances );
} //CLanguageResourceSampleCF

//+-------------------------------------------------------------------------
//
//  Method:     CLanguageResourceSampleCF::~CLanguageResourceSampleCF
//
//  Synopsis:   Language resource class factory destructor
//
//--------------------------------------------------------------------------

CLanguageResourceSampleCF::~CLanguageResourceSampleCF()
{
    InterlockedDecrement( &g_cInstances );
} //~LanguageResourceSampleCF

//+-------------------------------------------------------------------------
//
//  Method:     CLanguageResourceSampleCF::QueryInterface
//
//  Synopsis:   Rebind to the requested interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CLanguageResourceSampleCF::QueryInterface(
    REFIID   riid,
    void  ** ppvObject )
{
    if ( IID_IClassFactory == riid )
        *ppvObject = (IUnknown *) (IClassFactory *) this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *) (IPersist *) this;
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     CLanguageResourceSampleCF::AddRef
//
//  Synopsis:   Increments the refcount
//
//  Returns:    The new refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CLanguageResourceSampleCF::AddRef()
{
    return InterlockedIncrement( &_lRefs );
} //AddRef

//+-------------------------------------------------------------------------
//
//  Method:     CLanguageResourceSampleCF::Release
//
//  Synopsis:   Decrement refcount.  Delete self if necessary.
//
//  Returns:    The new refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CLanguageResourceSampleCF::Release()
{
    long lTmp = InterlockedDecrement( &_lRefs );

    if ( 0 == lTmp )
        delete this;

    return lTmp;
} //Release

//+-------------------------------------------------------------------------
//
//  Method:     CLanguageResourceSampleCF::CreateInstance
//
//  Synopsis:   Creates new Language Resource sample object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//  Returns:    S_OK if successful or an appropriate error code
//
//--------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CLanguageResourceSampleCF::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID     riid,
    void * *   ppvObject )
{
    *ppvObject = 0;

    if ( IID_IStemmer == riid )
        *ppvObject = new CSampleStemmer();
    else if ( IID_IWordBreaker == riid )
        *ppvObject = new CSampleWordBreaker();
    else
        return E_NOINTERFACE;

    if ( 0 == *ppvObject )
        return E_OUTOFMEMORY;

    return S_OK;
} //CreateInstance

//+-------------------------------------------------------------------------
//
//  Method:     CLanguageResourceSampleCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CLanguageResourceSampleCF::LockServer( BOOL fLock )
{
    if ( fLock )
        InterlockedIncrement( &g_cInstances );
    else
        InterlockedDecrement( &g_cInstances );

    return S_OK;
} //LockServer

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Ole DLL load class routine
//
//  Arguments:  [cid]    -- Class to load
//              [iid]    -- Interface to bind to on class object
//              [ppvObj] -- Interface pointer returned here
//
//  Returns:    Sample language resource class factory
//
//--------------------------------------------------------------------------

extern "C" HRESULT STDMETHODCALLTYPE DllGetClassObject(
    REFCLSID cid,
    REFIID   iid,
    void **  ppvObj )
{
    IUnknown * pUnk = 0;
    *ppvObj = 0;

    if ( CLSID_SampleWordBreaker == cid ||
         CLSID_SampleStemmer == cid )
    {
        pUnk = new CLanguageResourceSampleCF();

        if ( 0 == pUnk )
            return E_OUTOFMEMORY;

        #ifdef LEXICON_STEMMER

            if ( 0 == g_pStem )
                g_pStem = MakeStemObject( g_hModule );
    
            if ( 0 == g_pStem )
            {
                pUnk->Release();
                return E_OUTOFMEMORY;
            }
    
        #endif //LEXICON_STEMMER

    }
    else
    {
        *ppvObj = 0;
        return E_NOINTERFACE;
    }

    HRESULT hr = pUnk->QueryInterface( iid, ppvObj );

    pUnk->Release();

    return hr;
} //DllGetClassObject

//+-------------------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Notifies DLL to unload (cleanup global resources)
//
//  Returns:    S_OK if it is acceptable for caller to unload DLL.
//              S_FALSE otherwise.
//
//--------------------------------------------------------------------------

extern "C" HRESULT STDMETHODCALLTYPE DllCanUnloadNow( void )
{
    if ( 0 == g_cInstances )
        return S_OK;

    return S_FALSE;
} //DllCanUnloadNow

//+-------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Standard main entry point for the module.
//
//--------------------------------------------------------------------------

BOOL WINAPI DllMain(
    HANDLE hInstance,
    DWORD  dwReason,
    void * lpReserved )
{
    if ( DLL_PROCESS_ATTACH == dwReason )
    {
        g_hModule = (HMODULE) hInstance;
        DisableThreadLibraryCalls( (HINSTANCE) hInstance );
    }

    return TRUE;
} //DllMain

SLangRegistry const English_Sample_LangRes =
{
    L"English_Sample", MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_SAMPLE ),
    { L"{d225281a-7ca9-4a46-ae7d-c63a9d4815d4}",
      L"English_Sample Word Breaker",
      L"lrsample.dll",
      L"both" },
    { L"{0a275611-aa4d-4b39-8290-4baf77703f55}",
      L"English_Sample Stemmer",
      L"lrsample.dll",
      L"both" }
};

//+-------------------------------------------------------------------------
//
//  Method:     DllRegisterServer
//
//  Synopsis:   Registers the language resources in the registry
//
//--------------------------------------------------------------------------

STDAPI DllRegisterServer()
{
    return RegisterALanguageResource( English_Sample_LangRes );
} //DllRegisterServer

//+-------------------------------------------------------------------------
//
//  Method:     DllUnregisterServer
//
//  Synopsis:   Removes the language resources from the registry
//
//--------------------------------------------------------------------------

STDAPI DllUnregisterServer()
{
    return UnRegisterALanguageResource( English_Sample_LangRes );
} //DllUnregisterServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\pch\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <shellapi.h>
#include <commdlg.h>
#include <commctrl.h>

#include <ddeml.h>

#include <stdlib.h>
#include <stddef.h>
#include <time.h>
#include <limits.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <direct.h>
#include <crt\io.h>

#define _CAIROSTG_
#define _DCOM_

//#define OLEDBVER 0x0250 // enable ICommandTree interface

#include <cidebnot.h>
#include <cierror.h>

#include <oleext.h>
#include <oledberr.h>
#include <oledb.h>
#include <dbcmdtre.hxx>
#include <cmdtree.h>
#include <query.h>

#include <filterr.h>            // used in webhits!

//
// Query-specific
//

#include <stgprop.h>

#include <restrict.hxx>
#include <stgvar.hxx>
#include <vquery.hxx>


#include <ciexcpt.hxx>
#include <smart.hxx>
#include <tsmem.hxx>
#include <xolemem.hxx>
#include <dynarray.hxx>
#include <dynstack.hxx>
#include <dblink.hxx>
#include <cisem.hxx>
#include <thrd32.hxx>
#include <readwrit.hxx>
#include <ci.h>
#include <ci64.hxx>

#include <qutildbg.hxx>
#include <cidebug.hxx>

#include <align.hxx>

#include <tgrow.hxx>
#include <funypath.hxx>
#include <params.hxx>
#include <propspec.hxx>

#include <dbqrslt.hxx>
#include <tfilt.hxx>

#include <qlibutil.hxx>
#include <parser.hxx>
#include <catstate.hxx>
#include <doquery.hxx>
#include <scanner.hxx>
#include <lgplist.hxx>
#include <plist.hxx>
//#include <wcstoi64.hxx>
#include <strrest.hxx>

#include <string.hxx>
#include <fmapio.hxx>
#include <mbutil.hxx>
#include <qcanon.hxx>
#include <gibralt.hxx>

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\pch\empty.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999.
//
//  File:       empty.cxx
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\isrchdmp\isrchdmp.cxx ===
//+-------------------------------------------------------------------------
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
// PROGRAM:  isrchdmp.cx
//
// PURPOSE:  Illustrates a minimal query using Indexing Service.
//
// PLATFORM: Windows NT
//
//--------------------------------------------------------------------------

#ifndef UNICODE
#define UNICODE
#endif //ndef UNICODE

#include <stdio.h>
#include <windows.h>

#define OLEDBVER 0x0250 // need the command tree definitions
#define DBINITCONSTANTS

#include <oledberr.h>
#include <oledb.h>
#include <cmdtree.h>

#include <ntquery.h>
#include <filter.h>

#include "isearch.h"
#include "array.hxx"

//+-------------------------------------------------------------------------
//
//  Template:   XInterface
//
//  Synopsis:   Template for managing ownership of interfaces
//
//--------------------------------------------------------------------------

template<class T> class XInterface
{
public:
    XInterface( T * p = 0 ) : _p( p ) {}
    ~XInterface() { if ( 0 != _p ) _p->Release(); }
    T * operator->() { return _p; }
    T * GetPointer() const { return _p; }
    IUnknown ** GetIUPointer() { return (IUnknown **) &_p; }
    T ** GetPPointer() { return &_p; }
    void ** GetQIPointer() { return (void **) &_p; }
    T * Acquire() { T * p = _p; _p = 0; return p; }

private:
    T * _p;
};

typedef void (__stdcall * PFnCIShutdown)(void);
typedef HRESULT (__stdcall * PFnMakeISearch)( ISearchQueryHits ** ppSearch,
                                              DBCOMMANDTREE * pRst,
                                              WCHAR const * pwcPath );

PFnCIShutdown g_pCIShutdown = 0;
PFnMakeISearch g_pMakeISearch = 0;

//+-------------------------------------------------------------------------
//
//  Function:   DoQuery
//
//  Synopsis:   Creates and executes a query, then displays the results.
//
//  Arguments:  [pwcQueryCatalog]    - Catalog name over which query is run
//              [pwcQueryMachine]    - Machine name on which query is run
//              [pwcQueryRestrition] - The actual query string
//              [fDisplayTree]       - TRUE to display the command tree
//
//  Returns:    HRESULT result of the query
//
//--------------------------------------------------------------------------

HRESULT DoQuery(
    WCHAR const * pwcFilename,
    WCHAR const * pwcQueryRestriction )
{
    // Create an OLE DB query tree from a text restriction

    DBCOMMANDTREE * pTree;
    HRESULT hr = CITextToSelectTree( pwcQueryRestriction,      // the query itself
                                     &pTree,                   // resulting tree
                                     0,                        // no custom properties
                                     0,                        // no custom properties
                                     GetSystemDefaultLCID() ); // default locale
    if ( FAILED( hr ) )
        return hr;

    // Make the ISearchQueryHits object

    XInterface<ISearchQueryHits> xISearch;
    hr = g_pMakeISearch( xISearch.GetPPointer(),
                         pTree,
                         0 );
    if ( FAILED( hr ) )
        return hr;

    XInterface<IFilter> xIFilter;
    hr = LoadIFilter( pwcFilename, 0, xIFilter.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    ULONG ulFlags;
    hr = xIFilter->Init( IFILTER_INIT_CANON_PARAGRAPHS |
                         IFILTER_INIT_CANON_HYPHENS |
                         IFILTER_INIT_APPLY_INDEX_ATTRIBUTES,
                         0,
                         0,
                         &ulFlags );
    if ( FAILED( hr ) )
        return hr;

    hr = xISearch->Init( xIFilter.GetPointer(), ulFlags );
    if ( FAILED( hr ) )
        return hr;

    //
    // Retrieve all the hit info.  the info is wrt output from the IFilter.
    // a separate pass over a different IFilter is needed to match up
    // text to the hit info.
    //

    TArray<FILTERREGION> aHits;

    ULONG cRegions;
    FILTERREGION* aRegion;
    hr = xISearch->NextHitOffset( &cRegions, &aRegion );
    
    while ( S_OK == hr )
    {
        for ( ULONG i = 0; i < cRegions; i++ )
            aHits.Append( aRegion[i] );

        CoTaskMemFree( aRegion );
        hr = xISearch->NextHitOffset( &cRegions, &aRegion );
    }

    for ( ULONG i = 0; i < aHits.Count(); i++ )
        printf( "hit %d, chunk %d start %d extent %d\n",
                i, aHits[i].idChunk, aHits[i].cwcStart, aHits[i].cwcExtent );

    return hr;
} //DoQuery

//+-------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   Displays information about how to use the app and exits
//
//--------------------------------------------------------------------------

void Usage()
{
    printf( "usage: isrchdmp query [/f:filename]\n\n" );
    printf( "    query        an Indexing Service query\n" );
    printf( "    /f:filename  filename to search\n" );
    exit( -1 );
} //Usage

HINSTANCE GetFunctions()
{
    HINSTANCE h = LoadLibrary( L"query.dll" );

    if ( 0 != h )
    {
        #ifdef _WIN64
            char const * pcCIShutdown = "?CIShutdown@@YAXXZ";
            char const * pcMakeISearch = "?MakeISearch@@YAJPEAPEAUISearchQueryHits@@PEAVCDbRestriction@@PEBG@Z";
        #else
            char const * pcCIShutdown = "?CIShutdown@@YGXXZ";
            char const * pcMakeISearch = "?MakeISearch@@YGJPAPAUISearchQueryHits@@PAVCDbRestriction@@PBG@Z";
        #endif

        g_pCIShutdown = (PFnCIShutdown) GetProcAddress( h, pcCIShutdown );

        if ( 0 == g_pCIShutdown )
        {
            FreeLibrary( h );
            return 0;
        }

        g_pMakeISearch = (PFnMakeISearch) GetProcAddress( h, pcMakeISearch );

        if ( 0 == g_pMakeISearch )
        {
            FreeLibrary( h );
            return 0;
        }
    }

    return h;
} //GetFunctions

//+-------------------------------------------------------------------------
//
//  Function:   wmain
//
//  Synopsis:   Entry point for the app.  Parses command line arguments
//              and issues a query.
//
//  Arguments:  [argc]     - Argument count
//              [argv]     - Arguments
//
//--------------------------------------------------------------------------

extern "C" int __cdecl wmain( int argc, WCHAR * argv[] )
{
    WCHAR const * pwcFilename    = 0;
    WCHAR const * pwcRestriction = 0;         // no default restriction

    // Parse command line parameters

    for ( int i = 1; i < argc; i++ )
    {
        if ( L'-' == argv[i][0] || L'/' == argv[i][0] )
        {
            WCHAR wc = (WCHAR) toupper( argv[i][1] );

            if ( ':' != argv[i][2] && 'D' != wc )
                Usage();

            if ( 'F' == wc )
                pwcFilename = argv[i] + 3;
            else
                Usage();
        }
        else if ( 0 != pwcRestriction )
            Usage();
        else
            pwcRestriction = argv[i];
    }

    // A query restriction is necessary.  Fail if none is given.

    if ( 0 == pwcRestriction )
        Usage();

    // Load query.dll entrypoints

    HINSTANCE h = GetFunctions();

    if ( 0 == h )
    {
        printf( "can't load query.dll entrypoints\n" );
        return -1;
    }

    HRESULT hr = CoInitialize( 0 );

    // Run the query

    if ( SUCCEEDED( hr ) )
    {
        hr = DoQuery( pwcFilename, pwcRestriction );

        g_pCIShutdown();
        CoUninitialize();
    }

    if ( FAILED( hr ) )
    {
        printf( "the query '%ws' failed with error %#x\n",
                pwcRestriction, hr );
        return -1;
    }

    FreeLibrary( h );

    printf( "done!\n" );

    return 0;
} //wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\propci\mmfile.cxx ===
//
// Class for reading memory mapped files with a standard
// stream interface like the fX C runtime.  In NT 404
// this class is at least 50% faster than the fopen routines.
//

#include <pch.cxx>
#pragma hdrstop

#include "mmfile.hxx"

#define _CR 13
#define _LF 10

CMMFile::CMMFile(WCHAR const *szFile,BOOL fWrite)
{
  ULONG ulSizeHigh;
  DWORD dwAccess,dwProtect,dwFileAccess,dwCreate;

  _hfFile = 0;
  _hMapping = 0;
  _pvView = 0;
  _fWrite = fWrite;
  _ulFileSize = 0;
  _ulChunk = MMF_CHUNK;

  if (fWrite)
    {
      dwFileAccess = GENERIC_READ | GENERIC_WRITE;
      dwCreate = OPEN_ALWAYS;
      dwProtect = PAGE_READWRITE;
      dwAccess = FILE_MAP_ALL_ACCESS;
    }
  else
    {
      dwFileAccess = GENERIC_READ;
      dwCreate = OPEN_EXISTING;
      dwProtect = PAGE_READONLY;
      dwAccess = FILE_MAP_READ;
    }

  if (INVALID_HANDLE_VALUE !=
      (_hfFile = CreateFile(szFile,dwFileAccess,FILE_SHARE_READ,0,dwCreate,FILE_ATTRIBUTE_NORMAL,0)))
    {
      if (_ulFileSize = GetFileSize(_hfFile,&ulSizeHigh))
        {
          if (_hMapping = CreateFileMapping((HANDLE) _hfFile,NULL,dwProtect,0,0,NULL))
            _pvView = (BYTE *) MapViewOfFile(_hMapping,dwAccess,0,0,0);
          if (!(_hMapping && _pvView))
            {
              if (_pvView)
                UnmapViewOfFile(_pvView);
              _pvView = 0;
              if (_hMapping)
                CloseHandle(_hMapping);
              _hMapping = 0;
              if (_hfFile)
                CloseHandle(_hfFile);
              _hfFile = 0;
            }
        }
    }

   if ( INVALID_HANDLE_VALUE == _hfFile )
       _hfFile = 0;

  _pcCurrent = (char *) _pvView;
} //CMMFile

CMMFile::~CMMFile(void)
{
  if (_pvView)
    UnmapViewOfFile(_pvView);
  if (_hMapping)
    CloseHandle(_hMapping);
  if (_hfFile)
    CloseHandle(_hfFile);
  _hfFile = 0;
} //~CMMFile

//
// clone c runtime fgets()
//
BOOL CMMFile::GetS(char *sz,int iMaxLen)
{
  BOOL fRet;
  int i,ic;

  if (iMaxLen)
    {
      *sz = 0;
      iMaxLen--;
    }

  if (isEOF())
    fRet = FALSE;
  else
    {
      fRet = TRUE;
      for (i=0; (i < iMaxLen) &&
                ((sz[i] = (char) GetChar()) != MMF_EOF) &&
                (sz[i] != _CR) &&
                (sz[i] != _LF);
           i++)
        ;

      if (sz[i] == MMF_EOF)
        sz[i] = 0;
      else
        {
          if ((ic = GetChar()) != _LF)
            UnGetChar(ic);
          if (sz[i] == _CR)
            sz[i] = _LF;
          sz[i+1] = 0;
        }
    }
  return(fRet);
} //GetS

ULONG CMMFile::Grow(ULONG ulNewSize)
{
  ULONG ulOffset;

  ulNewSize = _RoundUpToChunk(ulNewSize);

  if (_ulFileSize < ulNewSize)
    {
      if (_pvView)
        {
          ulOffset = (ULONG) (_pcCurrent - (char *) _pvView);
          UnmapViewOfFile(_pvView);
          _pvView = NULL;
        }
      else ulOffset = 0L;

      if (_hMapping)
        {
          CloseHandle(_hMapping);
          _hMapping = 0;
        }
      _ulFileSize = ulNewSize;
      if (_hMapping = CreateFileMapping(_hfFile,NULL,PAGE_READWRITE,0,_ulFileSize,NULL))
        _pvView = MapViewOfFile(_hMapping,FILE_MAP_ALL_ACCESS,0,0,0);
      _pcCurrent = (char *) _pvView + ulOffset;
    }
  return(_ulFileSize);
} //Grow

int CMMFile::PutJustS(char *sz)
{
  ULONG ulLen = strlen(sz);

  Grow(Tell() + ulLen);

  memcpy(_pcCurrent,sz,ulLen);
  _pcCurrent += ulLen;

  return((int) ulLen);
} //PutS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\propci\proprec_stub.cxx ===
#include <pch.cxx>
#pragma hdrstop

#include "proprec.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\lrtest\lrtest.cxx ===
//+-------------------------------------------------------------------------
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// PROGRAM:  lrtest.cxx
//
// Test program for invoking language resources including wordbreakers
// and stemmers.  Also invokes filters.
//
// PLATFORM: Windows
//
//--------------------------------------------------------------------------

#ifndef UNICODE
    #define UNICODE
#endif

#define _OLE32_

#include <windows.h>
#include <oleext.h>
#include <psapi.h>

#include <stdlib.h>
#include <stdio.h>
#include <limits.h>
#include <eh.h>

#include <ntquery.h>
#include <filterr.h>
#include <cierror.h>
#include <indexsrv.h>

#include "minici.hxx"

#define USE_FAKE_COM

//
// These are undocumented Indexing Service functions, but they're needed
// to load filters and not crash, and to load the plain text filter.
//

typedef void (__stdcall * PFnCIShutdown)( void );
typedef HRESULT (__stdcall * PFnLoadTextFilter)( WCHAR const * pwcPath,
                                                 IFilter ** ppIFilter );

PFnCIShutdown g_pCIShutdown = 0;
PFnLoadTextFilter g_pLoadTextFilter = 0;

// If this is non-zero, it's a file handle to which output is streamed

FILE * g_fpOut = 0;

// If TRUE, strings from wordbreakers and stemmers are dumped in hex

BOOL g_fDumpAsHex = FALSE;

enum enumFilterLoadMechanism
{
    eIPersistFile,
    eIPersistStream,
    eIPersistStorage
};

//+-------------------------------------------------------------------------
//
//  Function:   out
//
//  Synopsis:   Like printf, only will send output to the output file if
//              specified, or just to the console.  Appends a carriage
//              return / line feed to the text.
//
//  Arguments:  [pwcFormat] -- Characters whose type information is checked
//              [...]       -- Variable arguments
//
//  Returns:    count of characters emitted.
//
//--------------------------------------------------------------------------

int out( const WCHAR * pwcFormat, ... )
{
    va_list arglist;
    va_start( arglist, pwcFormat );

    // Writing to the output file is done in binary mode so the output can be
    // Unicode.  The side-effect is that "\n" isn't translated into "\r\n"
    // automatically, so it has to be explicit.

    int i;

    if ( 0 != g_fpOut )
    {
        i = vfwprintf( g_fpOut, pwcFormat, arglist );
        i += fwprintf( g_fpOut, L"\r\n" );
    }
    else
    {
        i = vwprintf( pwcFormat, arglist );
        i += wprintf( L"\n" );
    }

    va_end( arglist );
    return i;
} //out

//+-------------------------------------------------------------------------
//
//  Function:   outstr
//
//  Synopsis:   Like printf, only will send output to the output file if
//              specified, or just to the console.
//
//  Arguments:  [pwcFormat] -- Characters whose type information is checked
//              [...]       -- Variable arguments
//
//  Returns:    count of characters emitted.
//
//--------------------------------------------------------------------------

int outstr( const WCHAR * pwcFormat, ... )
{
    va_list arglist;
    va_start( arglist, pwcFormat );

    int i;

    if ( 0 != g_fpOut )
        i = vfwprintf( g_fpOut, pwcFormat, arglist );
    else
        i = vwprintf( pwcFormat, arglist );

    va_end( arglist );
    return i;
} //outstr

//+-------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   Displays usage information about the application, then exits.
//
//--------------------------------------------------------------------------

void Usage()
{
    printf( "usage: lrtest [/d] [/b] [/f] [/q] [/s] [/x:#] /c:clsid [/o:file] [/i:file] [text]\n" );
    printf( "\n" );
    printf( "  Language Resource test program\n" );
    printf( "\n" );
    printf( "  arguments:\n" );
    printf( "    /b     Load the wordbreaker (can't be used with /s or /f)\n" );
    printf( "    /c:    CLSID of the wordbreaker or stemmer to load\n" );
    printf( "    /d     Dumps output strings in hex as well as strings\n" );
    printf( "    /f     Load the filter (can't be used with /b or /s)\n" );
    printf( "           If /c isn't specified, use Indexing Service's LoadIFilter\n" );
    printf( "    /fs    Same as /f, but uses IPersistStream, not IPersistFile\n" );
    printf( "    /ft    Same as /f, but uses IPersistStorage, not IPersistFile\n" );
    printf( "    /i:    Path of an input file, if [text] isn't specified\n" );
    printf( "    /m:    Optional path of the dll to load. Overrides COM CLSID lookup\n" );
    printf( "    /n     No status information. Used with /f, only displays filter output\n" );
    printf( "    /o:    Path of an output file.  If not specified, console is used\n" );
    printf( "    /q     If wordbreaking, do so for query instead of indexing\n" );
    printf( "    /s     Load the stemmer (can't be used with /b or /f)\n" );
    printf( "    /t     No text information; just chunks. Used with /f\n" );
    printf( "    /x:#   Maximum token size, default is 100\n" );
    printf( "    text   Text to wordbreak or stem, if /i: isn't specified\n" );
    printf( "\n" );
    printf( "  examples:\n" );
    printf( "    lrtest /b /c:{369647e0-17b0-11ce-9950-00aa004bbb1f} \"Alice's restaurant\"\n" );
    printf( "    lrtest /b /q /c:{369647e0-17b0-11ce-9950-00aa004bbb1f} \"data-base\"\n" );
    printf( "    lrtest /b /c:{369647e0-17b0-11ce-9950-00aa004bbb1f} /i:foo.doc\n" );
    printf( "    lrtest /b /c:{369647e0-17b0-11ce-9950-00aa004bbb1f} /m:wb.dll /i:foo.doc\n" );
    printf( "    lrtest /d /s /c:{eeed4c20-7f1b-11ce-be57-00aa0051fe20} peach /o:output.txt\n" );
    printf( "    lrtest /f /c:{f07f3920-7b8c-11cf-9be8-00aa004b9986} /i:foo.doc\n" );
    printf( "    lrtest /f /i:foo.doc\n" );
    printf( "    lrtest /fs /i:foo.doc\n" );
    printf( "\n" );

    exit( 1 );
} //Usage

//+-------------------------------------------------------------------------
//
//  Function:   GetModuleOfAddress
//
//  Synopsis:   Returns the module handle of a given address or 0
//
//  Arguments:  [pAddress] -- Address in one of the modules loaded
//
//--------------------------------------------------------------------------

HMODULE GetModuleOfAddress( void * pAddress )
{
    DWORD cbNeeded;
    BOOL fOK = EnumProcessModules( GetCurrentProcess(),
                                   0,
                                   0,
                                   &cbNeeded );
    if ( fOK )
    {
        ULONG cModules = cbNeeded / sizeof HMODULE;
        XPtr<HMODULE> aModules( cModules );
        fOK = EnumProcessModules( GetCurrentProcess(),
                                  aModules.Get(),
                                  cbNeeded,
                                  &cbNeeded );
        if ( fOK )
        {
            for ( ULONG i = 0; i < cModules; i++ )
            {
                MODULEINFO mi;
    
                GetModuleInformation( GetCurrentProcess(),
                                      aModules[ i ],
                                      &mi,
                                      sizeof mi );
                if ( ( pAddress >= mi.lpBaseOfDll ) &&
                     ( pAddress < ( (BYTE *) mi.lpBaseOfDll + mi.SizeOfImage ) ) )
                {
                    return aModules[i];
                }
            }
        }
    }

    return 0;
} //GetModuleOfAddress

//+-------------------------------------------------------------------------
//
//  Function:   DumpStringAsHex
//
//  Synopsis:   Emits a string in hex format. Useful for East Asian languages.
//
//--------------------------------------------------------------------------

void DumpStringAsHex( WCHAR const * pwc, ULONG cwc )
{
    if ( g_fDumpAsHex )
    {
        for ( ULONG i = 0; i < cwc; i++ )
        {
            if ( 0 != i )
                outstr( L" " );

            outstr( L"%#x", pwc[ i ] );
        }

        out( L"" );
    }
} //DumpStringAsHex

//+---------------------------------------------------------------------------
//
//  Class:      CIStream
//
//  Purpose:    Wraps a file with an IStream.
//
//----------------------------------------------------------------------------

class CIStream : public IStream
{
public:
    CIStream() : _hFile( INVALID_HANDLE_VALUE ),
                 _cRef( 1 ),
                 _lOffset( 0 ),
                 _cbData( 0 )
    {
    }

    ~CIStream()
    {
        Free();
    }

    void Free()
    {
        if ( INVALID_HANDLE_VALUE != _hFile )
        {
            CloseHandle( _hFile );
            _hFile = INVALID_HANDLE_VALUE;
        }
    }

    HRESULT Open( WCHAR const * pwcFile )
    {
        Free();

        _hFile = CreateFile( pwcFile,
                             GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE |
                                 FILE_SHARE_DELETE,
                             0,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             0 );

        if ( INVALID_HANDLE_VALUE == _hFile )
            return HRESULT_FROM_WIN32( GetLastError() );

        _cbData = GetFileSize( _hFile, 0 );

        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, void ** ppvObj )
    {
        if ( 0 == ppvObj )
            return E_INVALIDARG;

        *ppvObj = 0;

        if ( IID_IStream == riid )
            *ppvObj = (IStream *) this;
        else if ( IID_IUnknown == riid )
            *ppvObj = (IUnknown *) this;
        else
            return E_NOINTERFACE;

        AddRef();
        return S_OK;
    }

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return InterlockedIncrement( &_cRef );
    }

    ULONG STDMETHODCALLTYPE Release()
    {
        unsigned long uTmp = InterlockedDecrement( &_cRef );

        if ( 0 == uTmp )
            delete this;

        return uTmp;
    }

    HRESULT STDMETHODCALLTYPE Read(
        void *  pv,
        ULONG   cb,
        ULONG * pcbRead )
    {
        DWORD dwOff = SetFilePointer( _hFile,
                                      _lOffset,
                                      0,
                                      FILE_BEGIN );

        if ( INVALID_SET_FILE_POINTER == dwOff )
            return HRESULT_FROM_WIN32( GetLastError() );

        BOOL f = ReadFile( _hFile,
                           pv,
                           cb,
                           pcbRead,
                           0 );

        if ( !f )
            return HRESULT_FROM_WIN32( GetLastError() );

        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE Write(
        VOID const * pv,
        ULONG        cb,
        ULONG *      pcbWritten )
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE Seek(
        LARGE_INTEGER    dlibMoveIn,
        DWORD            dwOrigin,
        ULARGE_INTEGER * plibNewPosition )
    {
        HRESULT hr = S_OK;
        LONG dlibMove = dlibMoveIn.LowPart;
        ULONG cbNewPos = dlibMove;
    
        switch(dwOrigin)
        {
            case STREAM_SEEK_SET:
                if (dlibMove >= 0)
                    _lOffset = dlibMove;
                else
                    hr = STG_E_SEEKERROR;
                break;
            case STREAM_SEEK_CUR:
                if (!(dlibMove < 0 && ( -dlibMove > _lOffset)))
                    _lOffset += (ULONG) dlibMove;
                else
                    hr = STG_E_SEEKERROR;
                break;
            case STREAM_SEEK_END:
                if (!(dlibMove < 0 ))
                    _lOffset = _cbData + dlibMove;
                else
                    hr = STG_E_SEEKERROR;
                break;
            default:
                hr = STG_E_SEEKERROR;
        }
    
        if ( 0 != plibNewPosition )
            ULISet32(*plibNewPosition, _lOffset);
    
        return hr;
    }

    HRESULT STDMETHODCALLTYPE SetSize( ULARGE_INTEGER cb )
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE CopyTo(
        IStream *        pstm,
        ULARGE_INTEGER   cb,
        ULARGE_INTEGER * pcbRead,
        ULARGE_INTEGER * pcbWritten )
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE Commit( DWORD grfCommitFlags )
    {
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE Revert()
    {
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE LockRegion(
        ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD          dwLockType )
    {
        return STG_E_INVALIDFUNCTION;
    }

    HRESULT STDMETHODCALLTYPE UnlockRegion(
        ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD          dwLockType)
    {
        return STG_E_INVALIDFUNCTION;
    }

    HRESULT STDMETHODCALLTYPE Stat(
        STATSTG * pstatstg,
        DWORD     statflag )
    {
        memset( pstatstg, 0, sizeof STATSTG );
        pstatstg->type = STGTY_STREAM;
        pstatstg->cbSize.QuadPart = _cbData;
        pstatstg->grfMode = STGM_READ;
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE Clone( IStream ** ppstm )
    {
        return E_NOTIMPL;
    }

private:

    LONG   _cRef;
    HANDLE _hFile;
    LONG   _lOffset;
    LONG   _cbData;
};

//+---------------------------------------------------------------------------
//
//  Class:      CPlainTextSource
//
//  Purpose:    Takes a simple buffer and provides a TEXT_SOURCE for it, which
//              can be passed to wordbreakers.
//
//----------------------------------------------------------------------------

class CPlainTextSource : public TEXT_SOURCE
{
public:
    CPlainTextSource(
        WCHAR const * pwcText,
        ULONG         cwc )
    {
        awcBuffer = pwcText;
        iCur = 0;
        iEnd = cwc;
        pfnFillTextBuffer = PlainFillBuf;
    }

    static HRESULT __stdcall PlainFillBuf( TEXT_SOURCE * pTextSource )
    {
        return WBREAK_E_END_OF_TEXT;
    }
};

//+---------------------------------------------------------------------------
//
//  Class:      CFilterTextSource
//
//  Purpose:    Takes an IFilter and provides a TEXT_SOURCE for it, which
//              can be passed to wordbreakers.
//
//----------------------------------------------------------------------------

#pragma warning(disable: 4512) 

class CFilterTextSource : public TEXT_SOURCE
{
public:
    CFilterTextSource( IFilter & filter ) :
        _filter( filter ),
        _hr( S_OK )
    {
        awcBuffer = _awcBuffer;
        iCur = 0;
        iEnd = 0;
        pfnFillTextBuffer = FilterFillBuf;

        // Get the first chunk

        _hr = _filter.GetChunk( &_Stat );

        // Get text for the chunk

        FillBuf();
    }

    static HRESULT __stdcall FilterFillBuf( TEXT_SOURCE * pTextSource )
    {
        CFilterTextSource & This = * (CFilterTextSource *) pTextSource;
        return This.FillBuf();
    }

private:
    HRESULT FillBuf()
    {
        // Never continue past an error condition except FILTER_E_NO_MORE_TEXT

        if ( FAILED( _hr ) && _hr != FILTER_E_NO_MORE_TEXT )
            return _hr;
    
        if ( iCur > iEnd )
        {
            out( L"TEXT_SOURCE iCur (%#x) > iEnd (%#x), this is incorrect\n",
                 iCur, iEnd );
            _hr = E_INVALIDARG;
            return _hr;
        }

        // Move any existing text to beginning of buffer.
    
        ULONG ccLeftOver = iEnd - iCur;
        if ( ccLeftOver > 0 )
            MoveMemory( _awcBuffer,
                        &_awcBuffer[iCur],
                        ccLeftOver * sizeof WCHAR );
    
        iCur = 0;
        iEnd = ccLeftOver;
        ULONG ccRead = BufferWChars() - ccLeftOver;
        const ULONG BUFFER_SLOP = 10; 
    
        //
        // Get some more text.  If *previous* call to GetText returned
        // FILTER_S_LAST_TEXT, or FILTER_E_NO_MORE_TEXT then don't even
        // bother trying.
        //
    
        if ( FILTER_S_LAST_TEXT == _hr || FILTER_E_NO_MORE_TEXT == _hr )
            _hr = FILTER_E_NO_MORE_TEXT;
        else
        {
            _hr = _filter.GetText( &ccRead,
                                   &_awcBuffer[ccLeftOver] );
            if ( SUCCEEDED( _hr ) )
            {
                iEnd += ccRead;
                ccLeftOver += ccRead;
                ccRead = BufferWChars() - ccLeftOver;
    
                while ( ( S_OK == _hr ) && ( ccRead > BUFFER_SLOP ) )
                {
                    // Attempt to fill in as much of buffer as possible

                    _hr = _filter.GetText( &ccRead,
                                           &_awcBuffer[ccLeftOver] );
                    if ( SUCCEEDED( _hr ) )
                    {
                       iEnd += ccRead;
                       ccLeftOver += ccRead;
                       ccRead = BufferWChars() - ccLeftOver;
                    }
                }
    
                //
                // Either return FILTER_S_LAST_TEXT or return S_OK because we
                // have succeeded in adding text to the buffer.
                //

                if ( FILTER_S_LAST_TEXT == _hr )
                     return FILTER_S_LAST_TEXT;

                return S_OK;
            }
    
            if ( ( FILTER_E_NO_MORE_TEXT != _hr ) &&
                 ( FILTER_E_NO_TEXT != _hr ) )
            {
                // Weird failure, hence return, else goto next chunk

                return _hr;
            }
        }
    
        // Go to next chunk, if necessary.
    
        while ( ( FILTER_E_NO_MORE_TEXT == _hr ) ||
                ( FILTER_E_NO_TEXT == _hr ) )
        {
            _hr = _filter.GetChunk( &_Stat );

            if ( FILTER_E_END_OF_CHUNKS == _hr )
                return WBREAK_E_END_OF_TEXT;
    
            if ( FILTER_E_PARTIALLY_FILTERED == _hr )
                return WBREAK_E_END_OF_TEXT;
    
            if ( FAILED( _hr ) )
                return( _hr );

            //
            // Skip over value chunks -- note that search products don't do
            // this.  They convert VT_LPSTR, VT_BSTR, and VT_LPWSTR to
            // Unicode strings for the wordbreaker.
            //

            if ( CHUNK_TEXT != _Stat.flags )
                continue;

            ccRead = BufferWChars() - ccLeftOver;
            _hr = _filter.GetText( &ccRead,
                                   &_awcBuffer[ccLeftOver] );
            if ( SUCCEEDED( _hr ) )
            {
                iEnd += ccRead;
                ccLeftOver += ccRead;
                ccRead = BufferWChars() - ccLeftOver;
    
                while ( ( S_OK == _hr ) && ( ccRead > BUFFER_SLOP ) )
                {
                    // Attempt to fill in as much of buffer as possible

                    _hr = _filter.GetText( &ccRead,
                                           &_awcBuffer[ccLeftOver] );
                    if ( SUCCEEDED( _hr ) )
                    {
                       iEnd += ccRead;
                       ccLeftOver += ccRead;
                       ccRead = BufferWChars() - ccLeftOver;
                    }
                }
    
                //
                // Either return FILTER_S_LAST_TEXT or return S_OK because we
                // have succeeded in adding text to the buffer.
                //
                if ( FILTER_S_LAST_TEXT == _hr )
                     return FILTER_S_LAST_TEXT;

                return S_OK;
            }
        }

        if ( FAILED( _hr ) )
            return _hr;
    
        if ( 0 == ccRead )
            return WBREAK_E_END_OF_TEXT;
    
        return S_OK;
    } //FillBuf

    ULONG BufferWChars() const
    {
        return ArraySize( _awcBuffer );
    }

    IFilter &  _filter;
    HRESULT    _hr;
    STAT_CHUNK _Stat;
    WCHAR      _awcBuffer[ 1024 ];
};

//+---------------------------------------------------------------------------
//
//  Class:      CWordFormSink
//
//  Purpose:    Sample stemmer sink -- just prints the results.
//
//----------------------------------------------------------------------------

class CWordFormSink : public IWordFormSink
{
public:
    CWordFormSink() {}

    HRESULT STDMETHODCALLTYPE QueryInterface(
        REFIID  riid,
        void ** ppvObject )
    {
        *ppvObject = this;
        return S_OK;
    }

    ULONG STDMETHODCALLTYPE AddRef() { return 1; }

    ULONG STDMETHODCALLTYPE Release() { return 1; }

    HRESULT STDMETHODCALLTYPE PutAltWord(
        WCHAR const * pwcBuf,
        ULONG         cwc )
    {
        out( L"IWordFormSink::PutAltWord: cwc %d, '%.*ws'", cwc, cwc, pwcBuf );
        DumpStringAsHex( pwcBuf, cwc );
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE PutWord (
        WCHAR const * pwcBuf,
        ULONG         cwc )
    {
        out( L"IWordFormSink::PutWord: cwc %d, '%.*ws'", cwc, cwc, pwcBuf );
        DumpStringAsHex( pwcBuf, cwc );
        return S_OK;
    }
};

//+---------------------------------------------------------------------------
//
//  Class:      CWordSink
//
//  Purpose:    Sample word sink -- just prints the results.
//
//----------------------------------------------------------------------------

class CWordSink : public IWordSink
{
public:
    CWordSink() {}

    HRESULT STDMETHODCALLTYPE QueryInterface(
        REFIID  riid,
        void ** ppvObject )
    {
        *ppvObject = this;
        return S_OK;
    }

    ULONG STDMETHODCALLTYPE AddRef() { return 1; }

    ULONG STDMETHODCALLTYPE Release() { return 1; }

    HRESULT STDMETHODCALLTYPE PutWord(
        ULONG         cwc,
        WCHAR const * pwcBuf,
        ULONG         cwcSrcLen,
        ULONG         cwcSrcPos )
    {
        out( L"IWordSink::PutWord: cwcSrcLen %d, cwcSrcPos %d, cwc %d, '%.*ws'",
             cwcSrcLen, cwcSrcPos, cwc, cwc, pwcBuf );
        DumpStringAsHex( pwcBuf, cwc );
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE PutAltWord(
        ULONG         cwc,
        WCHAR const * pwcBuf,
        ULONG         cwcSrcLen,
        ULONG         cwcSrcPos )
    {
        out( L"IWordSink::PutAltWord: cwcSrcLen %d, cwcSrcPos %d, cwc %d, '%.*ws'",
             cwcSrcLen, cwcSrcPos, cwc, cwc, pwcBuf );
        DumpStringAsHex( pwcBuf, cwc );
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE StartAltPhrase()
    {
        out( L"IWordSink::StartAltPhrase" );
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE EndAltPhrase()
    {
        out( L"IWordSink::EndAltPhrase" );
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE PutBreak( WORDREP_BREAK_TYPE wbt )
    {
        out( L"IWordSink::PutBreak, type (%d) %ws",
             wbt,
             ( WORDREP_BREAK_EOW == wbt ) ? L"end of word" :
             ( WORDREP_BREAK_EOS == wbt ) ? L"end of sentence" :
             ( WORDREP_BREAK_EOP == wbt ) ? L"end of paragraph" :
             ( WORDREP_BREAK_EOC == wbt ) ? L"end of chapter" :
             L"invalid break type" );
        return S_OK;
    }
};

//+---------------------------------------------------------------------------
//
//  Class:      CPhraseSink
//
//  Purpose:    Sample phrase sink -- just prints the results.
//
//----------------------------------------------------------------------------

class CPhraseSink: public IPhraseSink
{
public:
    CPhraseSink() {}

    HRESULT STDMETHODCALLTYPE QueryInterface(
        REFIID  riid,
        void ** ppvObject )
    {
        // Assume the caller is well-behaved

        *ppvObject = this;
        return S_OK;
    }

    ULONG STDMETHODCALLTYPE AddRef() { return 1; }

    ULONG STDMETHODCALLTYPE Release() { return 1; }

    HRESULT STDMETHODCALLTYPE PutSmallPhrase(
        const WCHAR * pwcNoun,
        ULONG         cwcNoun,
        const WCHAR * pwcModifier,
        ULONG         cwcModifier,
        ULONG         ulAttachmentType )
    {
        out( L"IPhraseSink::PutSmallPhrase" );
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE PutPhrase(
        WCHAR const * pwcPhrase,
        ULONG         cwcPhrase )
    {
        out( L"IPhraseSink::PutPhrase: cwcPhrase %d, '%.*ws'",
             cwcPhrase, cwcPhrase, pwcPhrase );
        DumpStringAsHex( pwcPhrase, cwcPhrase );
        return S_OK;
    }
};

//+---------------------------------------------------------------------------
//
//  Function:   GetVersionKey
//
//  Purpose:    Displays a particular version key
//
//  Arguments:  [pbInfo]   -- The version inforomation
//              [pwcLang]  -- The language of the string requested
//              [pwcKey]   -- Key name to retrieve
//
//  Returns:    TRUE if a value was found, FALSE otherwise
//
//----------------------------------------------------------------------------

BOOL GetVersionKey(
    BYTE *        pbInfo,
    WCHAR const * pwcLang,
    WCHAR const * pwcKey )
{
    WCHAR awcKey[ 128 ];
    wsprintf( awcKey, L"\\StringFileInfo\\%ws\\%ws", pwcLang, pwcKey );

    WCHAR * pwcResult = 0;
    UINT cb = 0;

    if ( VerQueryValue( pbInfo,
                        awcKey,
                        (PVOID *) &pwcResult,
                        &cb ) )
    {
        out( L"  %ws: '%ws'", pwcKey, pwcResult );
        return TRUE;
    }

    return FALSE;
} //GetVersionKey

//+---------------------------------------------------------------------------
//
//  Function:   OutputFiletime
//
//  Purpose:    Displays a filetime
//
//  Arguments:  [pwcHeader]   -- Prefix to print before the filetime
//              [ft]          -- Filetime to print, in UTC originally
//
//----------------------------------------------------------------------------

void OutputFiletime( WCHAR const * pwcHeader, FILETIME & ft )
{
    FILETIME ftLocal;
    FileTimeToLocalFileTime( &ft, &ftLocal );

    SYSTEMTIME st;
    FileTimeToSystemTime( &ftLocal, &st );
    BOOL pm = st.wHour >= 12;

    if ( st.wHour > 12 )
        st.wHour -= 12;
    else if ( 0 == st.wHour )
        st.wHour = 12;

    out( L"%ws: %2d-%02d-%04d %2d:%02d%wc",
         pwcHeader,
         (DWORD) st.wMonth,
         (DWORD) st.wDay,
         (DWORD) st.wYear,
         (DWORD) st.wHour,
         (DWORD) st.wMinute,
         pm ? L'p' : L'a' );
} //OutputFiletime

//+---------------------------------------------------------------------------
//
//  Function:   DisplayModuleInformation
//
//  Purpose:    Displays information about a module -- dates and version
//
//  Arguments:  [hMod]       -- Module handle
//
//----------------------------------------------------------------------------

HRESULT DisplayModuleInformation( HINSTANCE hMod )
{
    WCHAR awcDllPath[ MAX_PATH ];
    DWORD cwcCopied = GetModuleFileName( hMod,
                                         awcDllPath,
                                         ArraySize( awcDllPath ) );
    awcDllPath[ ArraySize( awcDllPath ) - 1 ] = 0;
    if ( 0 == cwcCopied )
        return HRESULT_FROM_WIN32( GetLastError() );

    out( L"dll loaded: %ws", awcDllPath );

    DWORD dwHandle;
    DWORD cbVersionInfo = GetFileVersionInfoSize( awcDllPath, &dwHandle );
    if ( 0 == cbVersionInfo )
    {
        printf( "can't get dll version information size, error %d\n",
                GetLastError() );
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    XPtr<BYTE> xVersionInfo( cbVersionInfo );
    if ( xVersionInfo.IsNull() )
        return E_OUTOFMEMORY;

    BOOL fOK = GetFileVersionInfo( awcDllPath,
                                   0,
                                   cbVersionInfo,
                                   xVersionInfo.Get() );
    if ( !fOK )
    {
        printf( "unable to retrieve version information, error %d\n",
                GetLastError() );
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    // Get the DLL version number

    void * pvValue = 0;
    UINT cbValue = 0;

    fOK = VerQueryValue( xVersionInfo.Get(),
                         L"\\",
                         &pvValue,
                         &cbValue );
    if ( !fOK || ( 0 == cbValue ) )
    {
        printf( "can't retrieve version root value, error %d\n",
                GetLastError() );
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    VS_FIXEDFILEINFO & ffi = * (VS_FIXEDFILEINFO *) pvValue;

    out( L"  dll version %u.%u.%u.%u",
         HIWORD( ffi.dwFileVersionMS ),
         LOWORD( ffi.dwFileVersionMS ),
         HIWORD( ffi.dwFileVersionLS ),
         LOWORD( ffi.dwFileVersionLS ) );

    if ( ( cbValue >= sizeof VS_FIXEDFILEINFO ) &&
         ( 0 != ffi.dwFileDateLS && 0 != ffi.dwFileDateMS ) )
    {
        FILETIME ft;
        ft.dwLowDateTime = ffi.dwFileDateLS;
        ft.dwHighDateTime = ffi.dwFileDateMS;
        OutputFiletime( L"  version creation date: ", ft );
    }

    HANDLE h = CreateFile( awcDllPath,
                           FILE_GENERIC_READ,
                           FILE_SHARE_READ | FILE_SHARE_DELETE,
                           0,
                           OPEN_EXISTING,
                           0,
                           0 );
    if ( INVALID_HANDLE_VALUE != h )
    {
        FILETIME ftCreate, ftLastWrite;
        fOK = GetFileTime( h, &ftCreate, 0, &ftLastWrite );
        if ( fOK )
        {
            OutputFiletime( L"  file create time", ftCreate );
            OutputFiletime( L"  file last write time", ftLastWrite );
        }

        CloseHandle( h );
    }

    //
    // Get the language string.  Not every dll stores it correctly, so fall
    // back on English locales known to work for some special cases.
    //

    WCHAR awcLang[9];
    awcLang[0] = 0;

    DWORD * pdwLang;
    UINT cb;

    if ( VerQueryValue( xVersionInfo.Get(),
                        L"VarFileInfo\\Translation",
                        (PVOID *) &pdwLang,
                        &cb ) &&
         ( cb >= 4 ) )
    {
        wsprintf( awcLang,
                  L"%04x%04x",
                  LOWORD( *pdwLang ),
                  HIWORD( *pdwLang ) );
    }

    if ( 0 == awcLang[0] )
    {
        // Try English Unicode

        wcscpy( awcLang, L"040904B0" );
        if ( !GetVersionKey( xVersionInfo.Get(),
                             awcLang,
                             L"FileVersion" ) )
        {
            // Try English

            wcscpy( awcLang, L"040904E4" );
            if ( !GetVersionKey( xVersionInfo.Get(),
                                 awcLang,
                                 L"FileVersion" ) )
            {
                // Try English null codepage

                wcscpy( awcLang, L"04090000" );
                if ( !GetVersionKey( xVersionInfo.Get(),
                                     awcLang,
                                     L"FileVersion" ) )
                    awcLang[0] = 0;
            }
        }
    }
    else
    {
        GetVersionKey( xVersionInfo.Get(), awcLang, L"FileVersion" );
    }

    // Display additional version information if we found the language

    if ( 0 != awcLang[0] )
    {
        GetVersionKey( xVersionInfo.Get(), awcLang, L"FileDescription" );
        GetVersionKey( xVersionInfo.Get(), awcLang, L"CompanyName" );
        GetVersionKey( xVersionInfo.Get(), awcLang, L"ProductName" );
    }

    return S_OK;
} //DisplayModuleInformation

//+---------------------------------------------------------------------------
//
//  Function:   CreateFromModule
//
//  Purpose:    Creates a COM object given a dll
//
//  Arguments:  [clsid]     -- Class ID of the object to load
//              [iid]       -- Interface ID requested
//              [ppvObject] -- Returns the object created
//              [pwcModule] -- Dll to load
//              [fShowStatusInfo] -- TRUE to print status information
//
//  Returns:    HRESULT, S_OK if successful
//
//----------------------------------------------------------------------------

HRESULT CreateFromModule(
    REFIID        clsid,
    REFIID        iid,
    void **       ppvObject,
    WCHAR const * pwcModule,
    BOOL          fShowStatusInfo = TRUE )
{
    // Note: the module handle will be leaked.  It's OK for a test program.

    HMODULE hMod = LoadLibrary( pwcModule );
    if ( 0 == hMod )
        return HRESULT_FROM_WIN32( GetLastError() );

    // Display information about the module -- ignore errors

    if ( fShowStatusInfo )
        DisplayModuleInformation( hMod );

    LPFNGETCLASSOBJECT pfn = (LPFNGETCLASSOBJECT)
                             GetProcAddress( hMod, "DllGetClassObject" );
    if ( 0 == pfn )
    {
        printf( "can't get DllGetClassObject: %d\n", GetLastError() );
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    XInterface<IClassFactory> xClassFactory;
    HRESULT hr = pfn( clsid,
                      IID_IClassFactory,
                      xClassFactory.GetQIPointer() );
    if ( FAILED( hr ) )
    {
        printf( "can't instantiate the class factory: %#x\n", hr );
        return hr;
    }

    return xClassFactory->CreateInstance( 0, iid, ppvObject );
} //CreateFromModule

//+---------------------------------------------------------------------------
//
//  Function:   FakeCoCreateInstance
//
//  Purpose:    Creates a COM object
//
//  Arguments:  [clsid]     -- Class ID of the object to load
//              [iid]       -- Interface ID requested
//              [ppvObject] -- Returns the object created
//              [fShowStatusInfo] -- TRUE to print status information
//
//  Returns:    HRESULT, S_OK if successful
//
//  Needed because some wordbreakers register as single-threaded.  Search
//  products require multi-threaded because marshalling across apartments
//  doesn't work and because it's too inefficient, especially on
//  multi-processor machines.
//
//----------------------------------------------------------------------------

HRESULT FakeCoCreateInstance(
    REFIID  clsid,
    REFIID  iid,
    void ** ppvObject,
    BOOL    fShowStatusInfo = TRUE )
{
    WCHAR awcCLSID[ 40 ];
    StringFromGUID2( clsid, awcCLSID, ArraySize( awcCLSID ) );

    WCHAR awcKey[200];
    swprintf( awcKey, L"CLSID\\%ws\\InprocServer32", awcCLSID );

    HKEY hKey;
    DWORD dwErr = RegOpenKey( HKEY_CLASSES_ROOT, awcKey, &hKey );
    if ( NO_ERROR != dwErr )
        return HRESULT_FROM_WIN32( dwErr );

    WCHAR awcDll[MAX_PATH + 1];
    DWORD dwType;
    DWORD dwSize = sizeof awcDll;
    dwErr = RegQueryValueEx( hKey,
                             L"",
                             0,
                             &dwType,
                             (LPBYTE) awcDll,
                             &dwSize );
    RegCloseKey( hKey );
    if ( 0 != dwErr )
        return HRESULT_FROM_WIN32( dwErr );

    return CreateFromModule( clsid, iid, ppvObject, awcDll, fShowStatusInfo );
} //FakeCoCreateInstance

//+---------------------------------------------------------------------------
//
//  Function:   Stem
//
//  Purpose:    Stems the input text using the specified stemmer
//
//  Arguments:  [pwcText]     -- The text to be stemmed
//              [clsid]       -- Class ID of the stemmer to use
//              [pwcModule]   -- Optional module name to override COM lookup.
//              [cwcMaxToken] -- Maximum token size for the stemmer
//
//----------------------------------------------------------------------------

HRESULT Stem(
    WCHAR const * pwcText,
    WCHAR const * pwcModule,
    CLSID &       clsid,
    ULONG         cwcMaxToken )
{
    XInterface<IStemmer> xStemmer;
    HRESULT hr = S_OK;

    if ( 0 != pwcModule )
    {
        hr = CreateFromModule( clsid,
                               IID_IStemmer,
                               xStemmer.GetQIPointer(),
                               pwcModule );
    }
    else
    {
        #ifdef USE_FAKE_COM
            hr = FakeCoCreateInstance( clsid,
                                       IID_IStemmer,
                                       xStemmer.GetQIPointer() );
        #else
            hr = CoCreateInstance( clsid,
                                   0,
                                   CLSCTX_INPROC_SERVER,
                                   IID_IStemmer,
                                   xStemmer.GetQIPointer() );
        #endif
    }

    if ( FAILED( hr ) )
    {
        printf( "can't CoCreateInstance the stemmer: %#x\n", hr );
        return hr;
    }

    BOOL fLicense = FALSE;
    hr = xStemmer->Init( cwcMaxToken, &fLicense );
    if ( FAILED( hr ) )
    {
        printf( "can't Init() in the stemmer: %#x\n", hr );
        return hr;
    }

    out( L"Stemmer requires license: %ws", fLicense ? L"Yes" : L"No" );

    const WCHAR *pwcsLicense = 0;
    hr = xStemmer->GetLicenseToUse( &pwcsLicense );
    if ( FAILED( hr ) )
        out( L"can't GetLicenseToUse() in the stemmer: %#x\n", hr );
    else
        out( L"Stemmer license: '%ws'", pwcsLicense );

    CWordFormSink sink;

    if ( 0 != pwcText )
    {
        out( L"Original text: '%ws'", pwcText );
        hr = xStemmer->GenerateWordForms( pwcText, (ULONG) wcslen( pwcText ), &sink );
        if ( FAILED( hr ) )
        {
            printf( "can't GenerateWordForms() in the stemmer: %#x\n", hr );
            return hr;
        }
    }

    return S_OK;
} //Stem

//+---------------------------------------------------------------------------
//
//  Function:   WordBreak
//
//  Purpose:    Wordbreaks the input text or file
//
//  Arguments:  [fQuery]       -- TRUE if query time FALSE if index time
//              [pwcText]      -- The text to be wordbroken.
//              [pwcInputFile] -- Filename to be wordbroken if pwcText is 0
//              [pwcModule]    -- Optional module name to override COM lookup.
//              [clsid]        -- Class ID of the wordbreaker to use
//              [cwcMaxToken]  -- Maximum token size for the wordbreaker
//
//----------------------------------------------------------------------------

HRESULT WordBreak(
    BOOL          fQuery,
    WCHAR const * pwcText,
    WCHAR const * pwcInputFile,
    WCHAR const * pwcModule,
    CLSID &       clsid,
    ULONG         cwcMaxToken )
{
    XInterface<IWordBreaker> xWordBreaker;
    HRESULT hr = S_OK;

    if ( 0 != pwcModule )
    {
        hr = CreateFromModule( clsid,
                               IID_IWordBreaker,
                               xWordBreaker.GetQIPointer(),
                               pwcModule );
    }
    else
    {
        #ifdef USE_FAKE_COM
            hr = FakeCoCreateInstance( clsid,
                                       IID_IWordBreaker,
                                       xWordBreaker.GetQIPointer() );
        #else
            hr = CoCreateInstance( clsid,
                                   0,
                                   CLSCTX_INPROC_SERVER,
                                   IID_IWordBreaker,
                                   xWordBreaker.GetQIPointer() );
        #endif
    }

    if ( FAILED( hr ) )
    {
        printf( "can't CoCreateInstance the wordbreaker: %#x\n", hr );
        return hr;
    }

    BOOL fLicense = FALSE;
    hr = xWordBreaker->Init( fQuery, cwcMaxToken, &fLicense );
    if ( FAILED( hr ) )
    {
        printf( "can't Init() in the wordbreaker: %#x\n", hr );
        return hr;
    }

    out( L"Wordbreaker requires license: %ws", fLicense ? L"Yes" : L"No" );

    const WCHAR *pwcsLicense = 0;
    hr = xWordBreaker->GetLicenseToUse( &pwcsLicense );
    if ( FAILED( hr ) )
    {
        printf( "can't GetLicenseToUse() in the wordbreaker: %#x\n", hr );
        return hr;
    }

    out( L"Wordbreaker license: '%ws'", pwcsLicense );

    CWordSink wordSink;
    CPhraseSink phraseSink;

    if ( 0 != pwcText )
    {
        out( L"Original text: '%ws'", pwcText );

        CPlainTextSource textSource( pwcText, (ULONG) wcslen( pwcText ) );

        hr = xWordBreaker->BreakText( &textSource, &wordSink, &phraseSink );
        if ( FAILED( hr ) )
        {
            printf( "can't BreakText() in the wordbreaker: %#x\n", hr );
            return hr;
        }
    }
    else
    {
        out( L"Wordbreaking text from file %ws", pwcInputFile );

        // Load the Indexing Service filter (should be fine for testing).

        XInterface<IFilter> xIFilter;
        hr = LoadIFilter( pwcInputFile, 0, xIFilter.GetQIPointer() );
        if ( FAILED( hr ) )
        {
            // Fall back on the plain text filter.

            printf( "Can't load filter, error %#x. Trying text filter.\n",
                    hr );

            hr = g_pLoadTextFilter( pwcInputFile, xIFilter.GetPPointer() );
            if ( FAILED( hr ) )
            {
                printf( "can't load filter, error %#x\n", hr );
                return hr;
            }
        }

        // Initialize the filter

        ULONG ulFlags = 0;
        hr = xIFilter->Init( IFILTER_INIT_CANON_PARAGRAPHS |
                             IFILTER_INIT_CANON_HYPHENS |
                             IFILTER_INIT_APPLY_INDEX_ATTRIBUTES,
                             0,
                             0,
                             &ulFlags );
        if ( FAILED( hr ) )
        {
            printf( "can't initialize filter, error %#x\n", hr );
            return hr;
        }

        CFilterTextSource textSource( xIFilter.GetReference() );

        hr = xWordBreaker->BreakText( &textSource, &wordSink, &phraseSink );
        if ( FAILED( hr ) )
        {
            printf( "can't BreakText() in the wordbreaker: %#x\n", hr );
            return hr;
        }
    }

    return S_OK;
} //WordBreak

//+-------------------------------------------------------------------------
//
//  Function:   Render
//
//  Synopsis:   Prints an item in a safearray
//
//  Arguments:  [vt]  - type of the element
//              [pa]  - pointer to the item
//
//--------------------------------------------------------------------------

void PrintSafeArray( VARTYPE vt, LPSAFEARRAY pa );

void Render( VARTYPE vt, void * pv )
{
    if ( VT_ARRAY & vt )
    {
        PrintSafeArray( (VARTYPE) (vt - VT_ARRAY), *(SAFEARRAY **) pv );
        return;
    }

    switch ( vt )
    {
        case VT_UI1: outstr( L"%u", (unsigned) *(BYTE *)pv ); break;
        case VT_I1: outstr( L"%d", (int) *(CHAR *)pv ); break;
        case VT_UI2: outstr( L"%u", (unsigned) *(USHORT *)pv ); break;
        case VT_I2: outstr( L"%d", (int) *(SHORT *)pv ); break;
        case VT_UI4:
        case VT_UINT: outstr( L"%u", (unsigned) *(ULONG *)pv ); break;
        case VT_I4:
        case VT_ERROR:
        case VT_INT: outstr( L"%d", *(LONG *)pv ); break;
        case VT_UI8: outstr( L"%I64u", *(unsigned __int64 *)pv ); break;
        case VT_I8: outstr( L"%I64d", *(__int64 *)pv ); break;
        case VT_R4: outstr( L"%f", *(float *)pv ); break;
        case VT_R8: outstr( L"%lf", *(double *)pv ); break;
        case VT_DECIMAL:
        {
            double dbl;
            HRESULT hr = VarR8FromDec( (DECIMAL *) pv, &dbl );
            if ( SUCCEEDED( hr ) )
                outstr( L"%lf", dbl );
            break;
        }
        case VT_CY:
        {
            double dbl;
            HRESULT hr = VarR8FromCy( * (CY *) pv, &dbl );
            if ( SUCCEEDED( hr ) )
                outstr( L"%lf", dbl );
            break;
        }
        case VT_BOOL: outstr( *(VARIANT_BOOL *)pv ? L"TRUE" : L"FALSE" ); break;
        case VT_BSTR: outstr( L"%ws", *(BSTR *) pv ); break;
        case VT_VARIANT:
        {
            PROPVARIANT * pVar = (PROPVARIANT *) pv;
            Render( pVar->vt, & pVar->lVal );
            break;
        }
        case VT_DATE:
        {
            SYSTEMTIME st;
            BOOL fOK = VariantTimeToSystemTime( *(DATE *)pv, &st );

            if ( !fOK )
                break;

            BOOL pm = st.wHour >= 12;

            if ( st.wHour > 12 )
                st.wHour -= 12;
            else if ( 0 == st.wHour )
                st.wHour = 12;

            outstr( L"%2d-%02d-%04d %2d:%02d%wc",
                    (DWORD) st.wMonth,
                    (DWORD) st.wDay,
                    (DWORD) st.wYear,
                    (DWORD) st.wHour,
                    (DWORD) st.wMinute,
                    pm ? L'p' : L'a' );
            break;
        }
        case VT_EMPTY:
        case VT_NULL:
            break;
        default :
        {
            outstr( L"(vt 0x%x)", (int) vt );
            break;
        }
    }
} //Render

//+-------------------------------------------------------------------------
//
//  Function:   PrintSafeArray
//
//  Synopsis:   Prints items in a safearray
//
//  Arguments:  [vt]  - type of elements in the safearray
//              [pa]  - pointer to the safearray
//
//--------------------------------------------------------------------------

void PrintSafeArray( VARTYPE vt, LPSAFEARRAY pa )
{
    // Get the dimensions of the array

    UINT cDim = SafeArrayGetDim( pa );
    if ( 0 == cDim )
        return;

    XPtr<LONG> xDim( cDim );
    XPtr<LONG> xLo( cDim );
    XPtr<LONG> xUp( cDim );

    for ( UINT iDim = 0; iDim < cDim; iDim++ )
    {
        HRESULT hr = SafeArrayGetLBound( pa, iDim + 1, &xLo[iDim] );
        if ( FAILED( hr ) )
            return;

        xDim[ iDim ] = xLo[ iDim ];

        hr = SafeArrayGetUBound( pa, iDim + 1, &xUp[iDim] );
        if ( FAILED( hr ) )
            return;

        outstr( L"{" );
    }

    // slog through the array

    UINT iLastDim = cDim - 1;
    BOOL fDone = FALSE;

    while ( !fDone )
    {
        // inter-element formatting

        if ( xDim[ iLastDim ] != xLo[ iLastDim ] )
            outstr( L"," );

        // Get the element and render it

        void *pv;
        HRESULT hr = SafeArrayPtrOfIndex( pa, xDim.Get(), &pv );
        if ( FAILED( hr ) )
            return;

        Render( vt, pv );

        // Move to the next element and carry if necessary

        ULONG cOpen = 0;

        for ( LONG iDim = iLastDim; iDim >= 0; iDim-- )
        {
            if ( xDim[ iDim ] < xUp[ iDim ] )
            {
                xDim[ iDim ] = 1 + xDim[ iDim ];
                break;
            }

            outstr( L"}" );

            if ( 0 == iDim )
                fDone = TRUE;
            else
            {
                cOpen++;
                xDim[ iDim ] = xLo[ iDim ];
            }
        }

        for ( ULONG i = 0; !fDone && i < cOpen; i++ )
            outstr( L"{" );
    }
} //PrintSafeArray

//+-------------------------------------------------------------------------
//
//  Function:   PrintVectorItems
//
//  Synopsis:   Prints items in a PROPVARIANT vector
//
//  Arguments:  [pVal]  - The array of values
//              [cVals] - The count of values
//              [pcFmt] - The format string
//
//--------------------------------------------------------------------------

template<class T> void PrintVectorItems(
    T *           pVal,
    ULONG         cVals,
    WCHAR const * pwcFmt )
{
    outstr( L"{ " );

    for( ULONG iVal = 0; iVal < cVals; iVal++ )
    {
        if ( 0 != iVal )
            outstr( L"," );
        outstr( pwcFmt, *pVal++ );
    }

    outstr( L" }" );
} //PrintVectorItems

//+-------------------------------------------------------------------------
//
//  Function:   DisplayValue
//
//  Synopsis:   Displays a PROPVARIANT value.  Limited formatting is done.
//
//  Arguments:  [pVar] - The value to display
//
//--------------------------------------------------------------------------

void DisplayValue( PROPVARIANT const * pVar )
{
    if ( 0 == pVar )
    {
        outstr( L"NULL" );
        return;
    }

    // Display the most typical variant types

    PROPVARIANT const & v = *pVar;

    switch ( v.vt )
    {
        case VT_EMPTY : break;
        case VT_NULL : break;
        case VT_I4 : outstr( L"%10d", v.lVal ); break;
        case VT_UI1 : outstr( L"%10d", v.bVal ); break;
        case VT_I2 : outstr( L"%10d", v.iVal ); break;
        case VT_R4 : outstr( L"%10f", v.fltVal ); break;
        case VT_R8 : outstr( L"%10lf", v.dblVal ); break;
        case VT_BOOL : outstr( v.boolVal ? L"TRUE" : L"FALSE" ); break;
        case VT_I1 : outstr( L"%10d", v.cVal ); break;
        case VT_UI2 : outstr( L"%10u", v.uiVal ); break;
        case VT_UI4 : outstr( L"%10u", v.ulVal ); break;
        case VT_INT : outstr( L"%10d", v.lVal ); break;
        case VT_UINT : outstr( L"%10u", v.ulVal ); break;
        case VT_I8 : outstr( L"%20I64d", v.hVal ); break;
        case VT_UI8 : outstr( L"%20I64u", v.hVal ); break;
        case VT_ERROR : outstr( L"%#x", v.scode ); break;
        case VT_LPSTR : outstr( L"%S", v.pszVal ); break;
        case VT_LPWSTR : outstr( L"%ws", v.pwszVal ); break;
        case VT_BSTR : outstr( L"%ws", v.bstrVal ); break;
        case VT_BLOB :
        {
            outstr( L"blob cb %u ", v.blob.cbSize );
            for ( unsigned x = 0; x < v.blob.cbSize; x++ )
                outstr( L" %#x ", v.blob.pBlobData[x] );
            break;
        }
        case VT_CY:
        {
            double dbl;
            HRESULT hr = VarR8FromCy( v.cyVal, &dbl );

            if ( SUCCEEDED( hr ) )
                outstr( L"%lf", dbl );
            break;
        }
        case VT_DECIMAL :
        {
            double dbl;
            HRESULT hr = VarR8FromDec( (DECIMAL *) &v.decVal, &dbl );

            if ( SUCCEEDED( hr ) )
                outstr( L"%lf", dbl );
            break;
        }
        case VT_FILETIME :
        case VT_DATE :
        {
            SYSTEMTIME st;
            ZeroMemory( &st, sizeof st );

            if ( VT_DATE == v.vt )
            {
                BOOL fOK = VariantTimeToSystemTime( v.date, &st );

                if ( !fOK )
                    break;
            }
            else
            {
                FILETIME ft;
                BOOL fOK = FileTimeToLocalFileTime( &v.filetime, &ft );

                if ( fOK )
                    FileTimeToSystemTime( &ft, &st );

                if ( !fOK )
                    break;
            }

            BOOL pm = st.wHour >= 12;

            if ( st.wHour > 12 )
                st.wHour -= 12;
            else if ( 0 == st.wHour )
                st.wHour = 12;

            outstr( L"%2d-%02d-%04d %2d:%02d%wc",
                    (DWORD) st.wMonth,
                    (DWORD) st.wDay,
                    (DWORD) st.wYear,
                    (DWORD) st.wHour,
                    (DWORD) st.wMinute,
                    pm ? L'p' : L'a' );
            break;
        }
        case VT_VECTOR | VT_I1:
            PrintVectorItems( v.cac.pElems, v.cac.cElems, L"%d" ); break;
        case VT_VECTOR | VT_I2:
            PrintVectorItems( v.cai.pElems, v.cai.cElems, L"%d" ); break;
        case VT_VECTOR | VT_I4:
            PrintVectorItems( v.cal.pElems, v.cal.cElems, L"%d" ); break;
        case VT_VECTOR | VT_I8:
            PrintVectorItems( v.cah.pElems, v.cah.cElems, L"%I64d" ); break;
        case VT_VECTOR | VT_UI1:
            PrintVectorItems( v.caub.pElems, v.caub.cElems, L"%u" ); break;
        case VT_VECTOR | VT_UI2:
            PrintVectorItems( v.caui.pElems, v.caui.cElems, L"%u" ); break;
        case VT_VECTOR | VT_UI4:
            PrintVectorItems( v.caul.pElems, v.caul.cElems, L"%u" ); break;
        case VT_VECTOR | VT_ERROR:
            PrintVectorItems( v.cascode.pElems, v.cascode.cElems, L"%#x" ); break;
        case VT_VECTOR | VT_UI8:
            PrintVectorItems( v.cauh.pElems, v.cauh.cElems, L"%I64u" ); break;
        case VT_VECTOR | VT_BSTR:
            PrintVectorItems( v.cabstr.pElems, v.cabstr.cElems, L"%ws" ); break;
        case VT_VECTOR | VT_LPSTR:
            PrintVectorItems( v.calpstr.pElems, v.calpstr.cElems, L"%S" ); break;
        case VT_VECTOR | VT_LPWSTR:
            PrintVectorItems( v.calpwstr.pElems, v.calpwstr.cElems, L"%ws" ); break;
        case VT_VECTOR | VT_R4:
            PrintVectorItems( v.caflt.pElems, v.caflt.cElems, L"%f" ); break;
        case VT_VECTOR | VT_R8:
            PrintVectorItems( v.cadbl.pElems, v.cadbl.cElems, L"%lf" ); break;
        default :
        {
            if ( VT_ARRAY & v.vt )
                PrintSafeArray( (VARTYPE) ( v.vt - VT_ARRAY ), v.parray );
            else
                outstr( L"vt 0x%05x", v.vt );
            break;
        }
    }
} //DisplayValue

//+---------------------------------------------------------------------------
//
//  Function:   Filter
//
//  Purpose:    Invokes an IFilter on a file
//
//  Arguments:  [pwcInputFile] -- Filename to be filtered
//              [filterLoad]   -- How to load the file into the filter.
//              [pwcModule]    -- Optional module name to override COM lookup.
//              [pCLSID]       -- Optional class ID of the filter to use.
//                                Required if pwcModule is specified.
//              [fShowStatusInfo] -- TRUE  to get other information
//                                   FALSE for only output from the filter
//              [fGetText]     -- TRUE to retrieve text, FALSE to skip it
//
//----------------------------------------------------------------------------

HRESULT Filter(
    WCHAR const *           pwcInputFile,
    enumFilterLoadMechanism filterLoad,
    WCHAR const *           pwcModule,
    CLSID *                 pCLSID,
    BOOL                    fShowStatusInfo,
    BOOL                    fGetText )
{
    XInterface<IFilter> xFilter;
    HRESULT hr = S_OK;

    if ( 0 != pwcModule )
    {
        // If the DLL is specified, use it

        if ( fShowStatusInfo )
            out( L"loading filter based on module name" );

        hr = CreateFromModule( *pCLSID,
                               IID_IFilter,
                               xFilter.GetQIPointer(),
                               pwcModule,
                               fShowStatusInfo );
    }
    else if ( 0 != pCLSID )
    {
        // If we just have a CLSID and no module, use it

        if ( fShowStatusInfo )
            out( L"loading filter based on CLSID and the registry" );

        #ifdef USE_FAKE_COM
            hr = FakeCoCreateInstance( *pCLSID,
                                       IID_IFilter,
                                       xFilter.GetQIPointer(),
                                       fShowStatusInfo );
        #else
            hr = CoCreateInstance( *pCLSID,
                                   0,
                                   CLSCTX_INPROC_SERVER,
                                   IID_IFilter,
                                   xFilter.GetQIPointer() );
        #endif
    }
    else
    {
        // Use Indexing Service to load the filter

        if ( fShowStatusInfo )
            out( L"loading filter based on Indexing Service's LoadIFilter()" );

        hr = LoadIFilter( pwcInputFile, 0, xFilter.GetQIPointer() );

        if ( SUCCEEDED( hr ) && fShowStatusInfo )
        {
            // Dereference the VTable to get a pointer into the DLL

            HMODULE hMod = GetModuleOfAddress( * (void **) xFilter.GetPointer() );

            if ( 0 != hMod )
                DisplayModuleInformation( hMod );
        }
    }

    if ( FAILED( hr ) )
    {
        printf( "can't load the filter: %#x\n", hr );
        return hr;
    }

    // Does the filter support IPersistStorage?

    XInterface<IStorage> xStorage;
    XInterface<IPersistStorage> xPersistStorage;
    hr = xFilter->QueryInterface( IID_IPersistStorage,
                                  xPersistStorage.GetQIPointer() );
    if ( FAILED( hr ) )
    {
        if ( fShowStatusInfo )
            out( L"  filter doesn't support IPersistStorage, error %#x", hr );
        if ( eIPersistStorage == filterLoad )
            return hr;
    }
    else
    {
        if ( fShowStatusInfo )
            out( L"  filter supports IPersistStorage" );

        if ( eIPersistStorage == filterLoad )
        {
            if ( fShowStatusInfo )
                out( L"  loading via IPersistStorage" );

            hr = StgOpenStorage( pwcInputFile,
                                 0,
                                 STGM_READ | STGM_SHARE_DENY_WRITE,
                                 0,
                                 0,
                                 xStorage.GetPPointer() );
            if ( FAILED( hr ) )
            {
                printf( "can't open the file into a storage %#x\n", hr );
                return hr;
            }

            hr = xPersistStorage->Load( xStorage.GetPointer() );
            if ( FAILED( hr ) )
            {
                printf( "can't Load() the storage into the filter %#x\n", hr );
                return hr;
            }
        }
    }

    xPersistStorage.Free();

    // Does the filter support IPersistStream?

    XInterface<CIStream> xStream;
    XInterface<IPersistStream> xPersistStream;
    hr = xFilter->QueryInterface( IID_IPersistStream,
                                  xPersistStream.GetQIPointer() );
    if ( FAILED( hr ) )
    {
        if ( fShowStatusInfo )
            out( L"  filter doesn't support IPersistStream, error %#x", hr );
        if ( eIPersistStream == filterLoad )
            return hr;
    }
    else
    {
        if ( fShowStatusInfo )
            out( L"  filter supports IPersistStream" );

        if ( eIPersistStream == filterLoad )
        {
            if ( fShowStatusInfo )
                out( L"  loading via IPersistStream" );
            xStream.Set( new CIStream() );
            hr = xStream->Open( pwcInputFile );
            if ( FAILED( hr ) )
            {
                printf( "can't open the file into a stream %#x\n", hr );
                return hr;
            }

            hr = xPersistStream->Load( xStream.GetPointer() );
            if ( FAILED( hr ) )
            {
                printf( "can't Load() the stream into the filter %#x\n", hr );
                return hr;
            }
        }
    }

    xPersistStream.Free();

    // Does the filter support IPersistFile?

    XInterface<IPersistFile> xPersistFile;
    hr = xFilter->QueryInterface( IID_IPersistFile,
                                  xPersistFile.GetQIPointer() );
    if ( FAILED( hr ) )
    {
        if ( fShowStatusInfo )
            out( L"filter doesn't support IPersistFile, error %#x\n", hr );
        if ( eIPersistFile == filterLoad )
            return hr;
    }
    else
    {
        if ( fShowStatusInfo )
            out( L"  filter supports IPersistFile" );

        if ( eIPersistFile == filterLoad )
        {
            if ( fShowStatusInfo )
                out( L"  loading via IPersistFile" );

            hr = xPersistFile->Load( pwcInputFile,
                                     STGM_READ | STGM_SHARE_DENY_NONE );
            if ( FAILED( hr ) )
            {
                printf( "can't Load() the file into the filter %#x\n", hr );
                return hr;
            }
        }
    }

    xPersistFile.Free();

    // Initailize the IFilter

    ULONG ulFlags = 0;
    hr = xFilter->Init( IFILTER_INIT_CANON_PARAGRAPHS |
                        IFILTER_INIT_HARD_LINE_BREAKS |
                        IFILTER_INIT_CANON_HYPHENS |
                        IFILTER_INIT_CANON_SPACES |
                        IFILTER_INIT_INDEXING_ONLY |
                        IFILTER_INIT_APPLY_INDEX_ATTRIBUTES,
                        0,
                        0,
                        &ulFlags );
    if ( FAILED( hr ) )
    {
        printf( "can't Init() the filter, error %#x\n", hr );
        return hr;
    }

    if ( fShowStatusInfo )
        out( L"  flags returned from IFilter::Init(): %#x", ulFlags );

    // Pull all the data out of the filter

    BOOL fText;
    STAT_CHUNK StatChunk;
    StatChunk.attribute.psProperty.ulKind = PRSPEC_PROPID;

    do
    {
        const ULONG cwcMaxBuffer = 1024;
        WCHAR awcBuffer[ cwcMaxBuffer ];

        hr = xFilter->GetChunk( &StatChunk );
        if ( FILTER_E_EMBEDDING_UNAVAILABLE == hr )
        {
            if ( fShowStatusInfo )
                out( L"[-- encountered an embedding for which no filter is available --]" );
            continue;
        }

        if ( FILTER_E_LINK_UNAVAILABLE == hr )
        {
            if ( fShowStatusInfo )
                out( L"[-- encountered a link for which no filter is available --]" );
            continue;
        }

        if ( FAILED( hr ) && hr != FILTER_E_END_OF_CHUNKS )
        {
            out( L"GetChunk returned error %#x", hr );
            break;
        }

        if ( FILTER_E_END_OF_CHUNKS == hr )
            break;

        fText = ( CHUNK_TEXT == StatChunk.flags );

        // Display information about the chunk

        if ( fShowStatusInfo )
        {
            out( L"" );
            out( L"----------------------------------------------------------------------" );

            outstr( L"  attribute: %08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                    StatChunk.attribute.guidPropSet.Data1,
                    StatChunk.attribute.guidPropSet.Data2,
                    StatChunk.attribute.guidPropSet.Data3,
                    StatChunk.attribute.guidPropSet.Data4[0],
                    StatChunk.attribute.guidPropSet.Data4[1],
                    StatChunk.attribute.guidPropSet.Data4[2],
                    StatChunk.attribute.guidPropSet.Data4[3],
                    StatChunk.attribute.guidPropSet.Data4[4],
                    StatChunk.attribute.guidPropSet.Data4[5],
                    StatChunk.attribute.guidPropSet.Data4[6],
                    StatChunk.attribute.guidPropSet.Data4[7] );
    
            if ( StatChunk.attribute.psProperty.ulKind == PRSPEC_PROPID )
                out( L" %d (%#x)",
                     StatChunk.attribute.psProperty.propid,
                     StatChunk.attribute.psProperty.propid );
            else
                out( L" \"%ws\"", StatChunk.attribute.psProperty.lpwstr );
    
            out( L"  idChunk: %d (%#x)", StatChunk.idChunk, StatChunk.idChunk );
            outstr( L"  breakType: %d (%#x)", StatChunk.breakType, StatChunk.breakType );
    
            switch ( StatChunk.breakType )
            {
                case CHUNK_NO_BREAK: out( L" (no break) " ); break;
                case CHUNK_EOW: out( L" (end of word) " ); break;
                case CHUNK_EOS: out( L" (end of sentence) " ); break;
                case CHUNK_EOP: out( L" (end of paragraph) " ); break;
                case CHUNK_EOC: out( L" (end of chapter) " ); break;
                default : out( L" (unknown break type) " ); break;
            }
    
            outstr( L"  flags: %d (%#x)", StatChunk.flags, StatChunk.flags );
    
            if ( CHUNK_TEXT & StatChunk.flags )
                out( L" (text) " );
    
            if ( CHUNK_VALUE & StatChunk.flags )
                out( L" (value) " );
    
            out( L"  locale: %d (%#x)", StatChunk.locale, StatChunk.locale );
            out( L"  idChunkSource: %d (%#x)",
                 StatChunk.idChunkSource,
                 StatChunk.idChunkSource );
            out( L"  cwcStartSource: %d (%#x)",
                 StatChunk.cwcStartSource,
                 StatChunk.cwcStartSource );
            out( L"  cwcLenSource: %d (%#x)",
                 StatChunk.cwcLenSource,
                 StatChunk.cwcLenSource );
            out( L"  ------------------------------------------" );
        }

        if ( !fGetText )
            continue;

        // Retrieve all the data in the chunk

        do
        {
            if ( fText )
            {
                ULONG cwcBuffer = cwcMaxBuffer;
                hr = xFilter->GetText( &cwcBuffer, awcBuffer );
                if ( FAILED( hr ) && ( FILTER_E_NO_MORE_TEXT != hr ) )
                {
                    out( L"error %#x from GetText\n", hr );
                    return hr;
                }

                if ( FILTER_E_NO_MORE_TEXT == hr )
                    break;

                awcBuffer[cwcBuffer] = 0;
                out( L"%ws", awcBuffer );

                if ( g_fDumpAsHex )
                {
                    out( L"<--------> %d WCHARs in hex <-------->", cwcBuffer );
                    DumpStringAsHex( awcBuffer, cwcBuffer );
                }
            }
            else
            {
                PROPVARIANT * pPropValue = 0;
                hr = xFilter->GetValue( &pPropValue );

                if ( FAILED( hr ) )
                {
                    if ( ( FILTER_E_NO_MORE_VALUES == hr ) ||
                         ( FILTER_E_NO_VALUES == hr ) )
                        break;

                    out( L"GetValue failed, error %#x\n", hr );
                    return hr;
                }

                if ( fShowStatusInfo )
                    out( L"[-- variant type %d (%#x) --]", pPropValue->vt, pPropValue->vt );

                DisplayValue( pPropValue );
                out( L"" );

                if ( 0 != pPropValue )
                {
                    PropVariantClear( pPropValue );
                    CoTaskMemFree( pPropValue );
                    pPropValue = 0;
                }
            }
        } while( TRUE ); // data in a chunk
    } while( TRUE ); // for each chunk

    if ( fShowStatusInfo )
    {
        out( L"" );
        out( L"======================================================================" );
        out( L"Filtering completed" );
    }

    xStream.Free();
    xStorage.Free();
    xFilter.Free();

    // Now see if the file handle is still being locked by the filter

    HANDLE hFile = CreateFile( pwcInputFile,
                               GENERIC_READ,
                               0, //no sharing
                               0,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               0 );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
        out( L"Filter didn't release file; can't open %ws, error %#x\n", pwcInputFile, GetLastError() );
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    out( L"Filter closed file properly when released\n" );

    CloseHandle( hFile );

    return S_OK;
} //Filter

//+-------------------------------------------------------------------------
//
//  Function:   GetQueryFunctions
//
//  Synopsis:   Loads needed undocumented functions from query.dll.
//
//  Returns:    The module handle or 0 on failure.
//
//--------------------------------------------------------------------------

HINSTANCE GetQueryFunctions()
{
    HINSTANCE h = LoadLibrary( L"query.dll" );

    if ( 0 != h )
    {
        #ifdef _WIN64
            char const * pcCIShutdown = "?CIShutdown@@YAXXZ";
        #else
            char const * pcCIShutdown = "?CIShutdown@@YGXXZ";
        #endif

        g_pCIShutdown = (PFnCIShutdown) GetProcAddress( h, pcCIShutdown );
        if ( 0 == g_pCIShutdown )
        {
            printf( "can't get CIShutdown function address\n" );
            FreeLibrary( h );
            return 0;
        }

        g_pLoadTextFilter = (PFnLoadTextFilter)
                            GetProcAddress( h, "LoadTextFilter" );

        if ( 0 == g_pLoadTextFilter )
        {
            printf( "can't get LoadTextFilter function address\n" );
            FreeLibrary( h );
            return 0;
        }
    }

    return h;
} //GetQueryFunctions

//+-------------------------------------------------------------------------
//
//  Function:   ExceptionFilter
//
//  Synopsis:   Displays information about the exception
//
//  Arguments:  [pep] -- Exception pointers
//
//  Returns:    EXCEPTION_EXECUTE_HANDLER
//
//--------------------------------------------------------------------------

int ExceptionFilter( EXCEPTION_POINTERS * pep )
{
    printf( "fatal exception caught\n" );

    EXCEPTION_RECORD & r = * ( pep->ExceptionRecord );

    printf( "  exception code: %#x\n", r.ExceptionCode );
    printf( "  exception address %#p\n", r.ExceptionAddress );

    if ( ( EXCEPTION_ACCESS_VIOLATION == r.ExceptionCode ) &&
         ( r.NumberParameters >= 2 ) )
    {
        printf( "  attempted %ws at address %#p\n",
                ( 0 == r.ExceptionInformation[0] ) ?
                L"read" : L"write",
                (void *) r.ExceptionInformation[1] );
    }

    #ifdef _X86_

        CONTEXT & c = * (CONTEXT *) (pep->ContextRecord );

        if ( 0 != ( c.ContextFlags & CONTEXT_INTEGER ) )
        {
            printf( "  eax: %#x\n", c.Eax );
            printf( "  ebx: %#x\n", c.Ebx );
            printf( "  ecx: %#x\n", c.Ecx );
            printf( "  edx: %#x\n", c.Edx );
            printf( "  edi: %#x\n", c.Edi );
            printf( "  esi: %#x\n", c.Esi );
        }

        if ( 0 != ( c.ContextFlags & CONTEXT_CONTROL ) )
        {
           printf( "  ebp: %#x\n", c.Ebp );
           printf( "  eip: %#x\n", c.Eip );
           printf( "  esp: %#x\n", c.Esp );
        }

    #endif // _X86_

    // Attempt to get the module name where the exception happened

    HMODULE hMod = GetModuleOfAddress( r.ExceptionAddress );

    if ( 0 != hMod )
    {
        WCHAR awcPath[ MAX_PATH ];
        DWORD cwc= GetModuleFileName( hMod,
                                      awcPath,
                                      ArraySize( awcPath ) );
        awcPath[ ArraySize( awcPath ) - 1 ] = 0;
        if ( 0 != cwc )
            printf( "  exception in module %ws\n", awcPath );
    }

    return EXCEPTION_EXECUTE_HANDLER;
} //ExceptionFilter

//+-------------------------------------------------------------------------
//
//  Function:   wmain
//
//  Synopsis:   Main entrypoint for the program
//
//  Arguments:  [argc]  -- Count of command-line arguments
//              [argv]  -- The command-line arguments
//
//  Returns:    Application return code
//
//--------------------------------------------------------------------------

extern "C" int __cdecl wmain( int argc, WCHAR * argv[] )
{
    // Parse the command-line arguments

    BOOL fWordBreak = FALSE;
    BOOL fQuery = FALSE;
    BOOL fStem = FALSE;
    BOOL fFilter = FALSE;
    BOOL fGetText = TRUE;
    BOOL fShowStatusInfo = TRUE;
    enumFilterLoadMechanism filterLoad = eIPersistFile;
    WCHAR const * pwcModule = 0;
    WCHAR const * pwcInputFile = 0;
    WCHAR const * pwcOutputFile = 0;
    WCHAR *pwcText = 0;
    WCHAR const * pwcCLSID = 0;
    ULONG cwcMaxToken = 100;

    for ( int i = 1; i < argc; i++ )
    {
        if ( L'-' == argv[i][0] || L'/' == argv[i][0] )
        {
            WCHAR wc = towupper( argv[i][1] );

            if ( ':' != argv[i][2] &&
                 'B' != wc &&
                 'D' != wc &&
                 'F' != wc &&
                 'T' != wc &&
                 'N' != wc &&
                 'Q' != wc &&
                 'S' != wc )
                Usage();

            if ( 'C' == wc )
                pwcCLSID = argv[i] + 3;
            else if ( 'D' == wc )
                g_fDumpAsHex = TRUE;
            else if ( 'I' == wc )
            {
                if ( 0 != pwcText )
                    Usage();

                pwcInputFile = argv[i] + 3;
            }
            else if ( 'M' == wc )
                pwcModule = argv[i] + 3;
            else if ( 'N' == wc )
                fShowStatusInfo = FALSE;
            else if ( 'O' == wc )
                pwcOutputFile = argv[i] + 3;
            else if ( 'S' == wc )
                fStem = TRUE;
            else if ( 'T' == wc )
                fGetText = FALSE;
            else if ( 'B' == wc )
                fWordBreak = TRUE;
            else if ( 'F' == wc )
            {
                fFilter = TRUE;

                WCHAR wcNext = towupper( argv[i][2] );

                if ( L'S' == wcNext )
                    filterLoad = eIPersistStream;
                else if ( L'T' == wcNext )
                    filterLoad = eIPersistStorage;
                else if ( 0 != wcNext )
                    Usage();
            }
            else if ( 'Q' == wc )
                fQuery = TRUE;
            else if ( 'X' == wc )
                cwcMaxToken = _wtoi( argv[i] + 3 );
            else
                Usage();
        }
        else if ( 0 != pwcText || 0 != pwcInputFile )
            Usage();
        else
            pwcText = argv[i];
    }

    // We have to either wordbreak, stem, or filter

    if ( ( fWordBreak + fStem + fFilter ) != 1 )
        Usage();

    // We need the classid of the wordbreaker or stemmer to load

    if ( ( fWordBreak || fStem ) && ( 0 == pwcCLSID ) )
        Usage();

    // If we're loading by module, we need a CLSID

    if ( ( 0 != pwcModule ) && ( 0 == pwcCLSID ) )
        Usage();

    // Need input text or an input file to wordbreak

    if ( fWordBreak && ( 0 == pwcText ) && ( 0 == pwcInputFile ) )
        Usage();

    // Need input text to stem

    if ( fStem && ( 0 == pwcText ) )
        Usage();

    // Need input file to filter

    if ( fFilter && ( 0 == pwcInputFile ) )
        Usage();

    CLSID clsid;
    if ( 0 != pwcCLSID )
    {
        HRESULT hr = CLSIDFromString( (LPOLESTR) pwcCLSID, &clsid );
        if ( FAILED( hr ) )
        {
            printf( "can't convert CLSID string to a CLSID: %#x\n", hr );
            exit( 1 );
        }
    }

    // Get the full path of the input file, if specified

    WCHAR awcPath[MAX_PATH];
    if ( 0 != pwcInputFile )
    {
        _wfullpath( awcPath, pwcInputFile, MAX_PATH );
        pwcInputFile = awcPath;
    }

    // Get the full path of the output file, if specified, then open it

    WCHAR awcOutputPath[MAX_PATH];
    if ( 0 != pwcOutputFile )
    {
        _wfullpath( awcOutputPath, pwcOutputFile, MAX_PATH );
        pwcOutputFile = awcOutputPath;

        g_fpOut = _wfopen( pwcOutputFile, L"wb" );
        if ( 0 == g_fpOut )
        {
            printf( "unable to open output file '%ws'\n", pwcOutputFile );
            exit( 1 );
        }

        const WCHAR awcUnicodeHeader[] = { 0xfeff, 0x0000 };
        fwprintf( g_fpOut, awcUnicodeHeader );
    }

    // Initialize COM multi-threaded, just like search products do

    HRESULT hr = CoInitializeEx( 0, COINIT_MULTITHREADED );
    if ( FAILED( hr ) )
    {
        printf( "can't initialize com: %#x\n", hr );
        exit( 1 );
    }

    // Load query.dll private exports

    HINSTANCE hQuery = GetQueryFunctions();
    if ( 0 == hQuery )
    {
        printf( "can't load needed functions from query.dll\n" );
        exit( 1 );
    }

    // Do the work

    __try
    {
        if ( fStem )
            Stem( pwcText,
                  pwcModule,
                  clsid,
                  cwcMaxToken );
    
        if ( fWordBreak )
            WordBreak( fQuery,
                       pwcText,
                       pwcInputFile,
                       pwcModule,
                       clsid,
                       cwcMaxToken );

        if ( fFilter )
            Filter( pwcInputFile,
                    filterLoad,
                    pwcModule,
                    ( 0 == pwcCLSID ) ? 0 : &clsid,
                    fShowStatusInfo,
                    fGetText );
    }
    __except( ExceptionFilter( GetExceptionInformation() ) )
    {
        printf( "fatal exception code %#x\n", GetExceptionCode() );

        exit( -1 );
    }

    // Shut down query.dll's filter loading code so it won't AV on exit.

    g_pCIShutdown();

    FreeLibrary( hQuery );

    CoUninitialize();

    if ( 0 != g_fpOut )
    {
        fclose( g_fpOut );
        g_fpOut = 0;
    }

    return 0;
} //wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\propdump\proprec_stub.cxx ===
#include <pch.cxx>
#pragma hdrstop

#include "proprec.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\propci\propci.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       main.cxx
//
//  Contents:   Fixes a catalog after propagating from one machine to another.
//
//  History:    12 Jan 2000    dlee   Created from propdump
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <proprec.hxx>
#include <propdesc.hxx>
#include "mmfile.hxx"

DECLARE_INFOLEVEL(ci)

unsigned const SixtyFourK = 1024 * 64;

//#define LOG

CCoTaskAllocator CoTaskAllocator; // exported data definition

void * CCoTaskAllocator::Allocate(ULONG cbSize)
{
    return CoTaskMemAlloc( cbSize );
}

void CCoTaskAllocator::Free(void *pv)
{
    CoTaskMemFree(pv);
}

void Usage()
{
    printf( "Usage: PropCi directory\n");
    printf( "       directory specifies the directory where the catalog exists.\n");
    printf( "\n" );
    printf( "This application converts file indexes in the catalog specified.\n" );
    exit( 1 );
}

WCHAR const * wcsistr( WCHAR const * wcsString, WCHAR const * wcsPattern )
{
    if ( (wcsPattern == 0) || (*wcsPattern == 0) )
        return wcsString;

    ULONG cwcPattern = wcslen(wcsPattern);

    while ( *wcsString != 0 )
    {
        while ( (*wcsString != 0) &&
                (towupper(*wcsString) != towupper(*wcsPattern)) )
            wcsString++;

        if ( 0 == *wcsString )
            return 0;

        if ( _wcsnicmp( wcsString, wcsPattern, cwcPattern) == 0 )
            return wcsString;

        wcsString++;
    }

    return 0;
} //wcsistr

void AppendBackslash( WCHAR *p )
{
    int x = wcslen( p );
    if ( 0 != x && L'\\' != p[x-1] )
    {
        p[x] = L'\\';
        p[x+1] = 0;
    }
} //AppendBackslash


void FindFieldRec(
    WCHAR const * pwcFile,
    PROPID        pid,
    CPropDesc &   prop,
    ULONG &       cTotal,
    ULONG &       cFixed,
    ULONG &       culFixed )
{
    cTotal = 0;
    cFixed = 0;
    culFixed = 0;

    HANDLE h = CreateFile( pwcFile,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           0,
                           OPEN_EXISTING,
                           0,
                           0 );

    if ( INVALID_HANDLE_VALUE == h )
    {
        printf( "Can't open file %ws. Error %u\n", pwcFile, GetLastError() );
        exit( 1 );
    }

    ULONG cbRead;
    static BYTE abTemp[SixtyFourK];
    if ( ReadFile( h,
                   abTemp,
                   sizeof abTemp ,
                   &cbRead,
                   0 ) )
    {
        // Loop through records

        BOOL fFound = FALSE;
        CPropDesc * pPropDesc = (CPropDesc *)abTemp;

        for ( unsigned i = 0;
              i < cbRead/(sizeof(CPropDesc) + sizeof(ULONG));
              i++, pPropDesc = (CPropDesc *)(((BYTE *)pPropDesc) + sizeof(CPropDesc) + sizeof(ULONG)) )
        {
            if ( 0 != pPropDesc->Pid() )
            {
                if ( pPropDesc->Pid() == pid )
                {
                    memcpy( &prop, pPropDesc, sizeof prop );
                    fFound = TRUE;
                }

                cTotal++;

                if ( pPropDesc->Offset() != -1 )
                {
                    cFixed++;
                    culFixed += (pPropDesc->Size() / sizeof(DWORD));
                }
            }
        }

        if ( !fFound )
        {
            printf( "can't find pid %#x\n", pid );
            exit( 1 );
        }
    }
    else
    {
        printf( "Can't read file %ws.  Error %u\n", pwcFile, GetLastError() );
        exit( 1 );
    }

#ifdef LOG
    printf( "pid %d, total %d, fixed %d\n", pid, cTotal, cFixed );

    printf( "  pid %d, vt %d, ostart %d, cbmax %d, ordinal %d, mask %d, rec %d, fmodify %d\n",
               prop.Pid(),
               prop.Type(),
               prop.Offset(),
               prop.Size(),
               prop.Ordinal(),
               prop.Mask(),
               prop.Record(),
               prop.Modifiable() );
#endif

    CloseHandle( h );
} //FindFieldRec

NTSTATUS CiNtOpenNoThrow(
    HANDLE & h,
    WCHAR const * pwcsPath,
    ACCESS_MASK DesiredAccess,
    ULONG ShareAccess,
    ULONG OpenOptions )
{
    h = INVALID_HANDLE_VALUE;
    UNICODE_STRING uScope;

    if ( !RtlDosPathNameToNtPathName_U( pwcsPath,
                                       &uScope,
                                        0,
                                        0 ) )
        return STATUS_INSUFFICIENT_RESOURCES;

    //
    // Open the file
    //

    OBJECT_ATTRIBUTES ObjectAttr;

    InitializeObjectAttributes( &ObjectAttr,          // Structure
                                &uScope,              // Name
                                OBJ_CASE_INSENSITIVE, // Attributes
                                0,                    // Root
                                0 );                  // Security

    IO_STATUS_BLOCK IoStatus;
    NTSTATUS Status = NtOpenFile( &h,                 // Handle
                                  DesiredAccess,      // Access
                                  &ObjectAttr,        // Object Attributes
                                  &IoStatus,          // I/O Status block
                                  ShareAccess,        // Shared access
                                  OpenOptions );      // Flags

    RtlFreeHeap( RtlProcessHeap(), 0, uScope.Buffer );

    return Status;
} //CiNtOpenNoThrow

FILEID GetFileId( WCHAR * pwcPath )
{
    if ( 2 == wcslen( pwcPath ) )
        wcscat( pwcPath, L"\\" );

    HANDLE h;
    NTSTATUS status = CiNtOpenNoThrow( h,
                                       pwcPath,
                                       FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                                       FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                       0 );

    if ( FAILED( status ) )
    {
        printf( "Can't open file %ws to get fileid. Error %#x\n", pwcPath, status );
        return 0;
    }

    FILE_INTERNAL_INFORMATION fii;
    IO_STATUS_BLOCK IoStatus;
    status = NtQueryInformationFile( h,
                                     &IoStatus,
                                     &fii,
                                     sizeof fii,
                                     FileInternalInformation );

    NtClose( h );

    if ( NT_SUCCESS( status ) )
        status = IoStatus.Status;

    if ( NT_SUCCESS( status ) )
        return fii.IndexNumber.QuadPart;

    return 0;
} //GetFileId

void GetRecordInformation(
    WCHAR const * pwcFile,
    ULONG &       cRecPerBuf,
    ULONG &       cbRec )
{
    cRecPerBuf = 0;
    cbRec = 0;

    HANDLE h = CreateFile( pwcFile,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           0,
                           OPEN_EXISTING,
                           0,
                           0 );

    if ( INVALID_HANDLE_VALUE == h )
    {
        printf( "Can't open file %ws. Error %u\n", pwcFile, GetLastError() );
        exit( 1 );
    }

    ULONG cbRead;

    static BYTE abTemp[SixtyFourK];
    if ( ReadFile( h,
                   abTemp,
                   sizeof(abTemp),
                   &cbRead,
                   0 ) )
    {
        //
        // Determine record size
        //

        if ( abTemp[0] != 0 || abTemp[1] != 0 )
        {
            printf( "Record 0 not blank.  File corrupt!\n" );
            exit( 1 );
        }

        // First record should be all empty and only the first
        // record should be so. So counting all leading zeros gives us
        // the size of the record.
        for ( unsigned i = 0; i < cbRead && abTemp[i] == 0; i++ )
            continue;

        if ( i == cbRead )
        {
            printf( "First %uK segment all zero!.  File corrupt!\n", sizeof(abTemp)/1024 );
            exit( 1 );
        }

        switch ( *(USHORT *)&abTemp[i] )
        {
            case 0x5555:
            case 0xAAAA:
            case 0xBBBB:
            case 0xCCCC:
            case 0xDDDD:
                cbRec = i;
    
                if ( cbRec % 4 != 0 )
                {
                    printf( "Record size (%u bytes) not DWORD aligned!\n\n", cbRec );
                    exit( 1 );
                }
    
                cRecPerBuf = sizeof(abTemp) / cbRec;
                break;
    
            default:
                printf( "First non-zero byte is not a proper signature (%u)!\n", *(SHORT *)&abTemp[i] );
                exit( 1 );
        }
    }
    else
    {
        printf( "can't read from file %ws, error %d\n", pwcFile, GetLastError() );
        exit( 1 );
    }

#ifdef LOG
    printf( "cRecPerBuf %d, cbRec %d\n", cRecPerBuf, cbRec );
#endif

    CloseHandle( h );
} //GetRecordInformation

void PatchFileIDs(
    WCHAR const * pwcDir,
    WCHAR const * pwcPri,
    WCHAR const * pwcSec )
{
    //
    // First, read the property specifications for secondary wid, fileindex,
    // lastseen, and path.  The first 3 are in the primary and the last in
    // the secondary.
    //

    WCHAR awcPriProp[ MAX_PATH ];
    wcscpy( awcPriProp, pwcDir );
    wcscat( awcPriProp, L"CIP10000.001" );

    ULONG cPriTotal, cPriFixed, culPriFixed;
    CPropDesc SecWidPtrFieldRec;

    FindFieldRec( awcPriProp,
                  pidSecondaryStorage,
                  SecWidPtrFieldRec,
                  cPriTotal,
                  cPriFixed,
                  culPriFixed );

    CPropDesc FileIdFieldRec;
    FindFieldRec( awcPriProp,
                  pidFileIndex,
                  FileIdFieldRec,
                  cPriTotal,
                  cPriFixed,
                  culPriFixed );

    CPropDesc LastSeenFieldRec;
    FindFieldRec( awcPriProp,
                  pidLastSeenTime,
                  LastSeenFieldRec,
                  cPriTotal,
                  cPriFixed,
                  culPriFixed );

    WCHAR awcSecProp[ MAX_PATH ];
    wcscpy( awcSecProp, pwcDir );
    wcscat( awcSecProp, L"CIP20000.001" );

    ULONG cSecTotal, cSecFixed, culSecFixed;
    CPropDesc PathFieldRec;

    FindFieldRec( awcSecProp,
                  pidPath,
                  PathFieldRec,
                  cSecTotal,
                  cSecFixed,
                  culSecFixed );

    //
    // Get information about the number and size of records.
    //

    ULONG cPriRecPerBuf, cbPriRec;
    GetRecordInformation( pwcPri, cPriRecPerBuf, cbPriRec );

    ULONG cSecRecPerBuf, cbSecRec;
    GetRecordInformation( pwcSec, cSecRecPerBuf, cbSecRec );

    //
    // Walk the property store, get the secondary wid, read the path from
    // the secondary store, lookup the fileid, and write the fileid back
    // info the primary store.
    //

    CMMFile pri( pwcPri, TRUE );
    if ( !pri.Ok() )
    {
        printf( "can't map primary\n" );
        exit( 1 );
    }

    BYTE * pb = (BYTE *) pri.GetMapping();
    BYTE * pbBase = pb;

    CMMFile sec( pwcSec, TRUE );
    if ( !sec.Ok() )
    {
        printf( "can't map secondary\n" );
        exit( 1 );
    }

    BYTE * pbSecBase = (BYTE *) sec.GetMapping();

    FILETIME ftNow;
    GetSystemTimeAsFileTime( &ftNow );

#ifdef LOG
    printf( "pb %#x, size %d\n", pb, pri.FileSize() );
#endif

    ULONG iRec = 0, iRecTotal = 0;

    do
    {
#ifdef LOG
        printf( "record %d\n", iRecTotal );
#endif
        // If we're at the end of a 64k page, go on to the next one.

        if ( iRec == cPriRecPerBuf )
        {
            iRec = 0;
            pb += 65536;
        }

        COnDiskPropertyRecord * pRec = new( iRec, pb, cbPriRec/4 ) COnDiskPropertyRecord;

        if ( (BYTE *) pRec >= ( pbBase + pri.FileSize() ) )
            break;

        if ( pRec->IsTopLevel() )
        {
            PROPVARIANT var;
            static BYTE abExtra[MAX_PATH * 5];
            unsigned cbExtra = sizeof(abExtra);

            pRec->ReadFixed( SecWidPtrFieldRec.Ordinal(),
                             SecWidPtrFieldRec.Mask(),
                             SecWidPtrFieldRec.Offset(),
                             cPriTotal,
                             SecWidPtrFieldRec.Type(),
                             var,
                             abExtra,
                             &cbExtra,
                             *((PStorage *)0) );

            if ( VT_UI4 != var.vt )
            {
                printf( "failure: secondary wid wasn't a UI4\n" );
                exit( 1 );
            }

#ifdef LOG
            printf( "secondary wid %d\n", var.ulVal );
#endif

            ULONG iTargetSection = var.ulVal/cSecRecPerBuf;

            BYTE * pbSec = pbSecBase + ( iTargetSection * SixtyFourK );

            // Get the secondary store record

            COnDiskPropertyRecord * pRec2 = new( var.ulVal % cSecRecPerBuf, pbSec, cbSecRec/4 ) COnDiskPropertyRecord;

            // Read the path
            cbExtra = sizeof abExtra;

#ifdef LOG
            printf( "pRec2: %#x\n", pRec2 );
#endif

            var.vt = VT_EMPTY;

            if ( !pRec2->ReadVariable( PathFieldRec.Ordinal(),
                                       PathFieldRec.Mask(),
                                       culSecFixed,
                                       cSecTotal,
                                       cSecFixed,
                                       var,
                                       abExtra,
                                       &cbExtra ) )
            {
                // It's in an overflow record

                BOOL fOk;

                do
                {
                    //
                    // Check for existing overflow block.
                    //
    
                    WORKID widOverflow = pRec2->OverflowBlock();
    
                    if ( 0 == widOverflow )
                        break;

                    iTargetSection = widOverflow / cSecRecPerBuf;
                    pbSec = pbSecBase + ( iTargetSection * SixtyFourK );
                    pRec2 = new( widOverflow % cSecRecPerBuf, pbSec, cbSecRec/4 ) COnDiskPropertyRecord;

#ifdef LOG
                    printf( "overflow pRec2: %#x\n", pRec2 );
#endif
                    ULONG Ordinal = PathFieldRec.Ordinal() - cSecFixed;
                    DWORD Mask = (1 << ((Ordinal % 16) * 2) );
    
                    fOk = pRec2->ReadVariable( Ordinal,  // Ordinal (assuming 0 fixed)
                                               Mask,     // Mask (assuming 0 fixed)
                                               0,        // Fixed properties
                                               cSecTotal - cSecFixed,
                                               0,        // Count of fixed properties
                                               var,
                                               abExtra,
                                               &cbExtra );
                } while ( !fOk );
            }

            if ( VT_LPWSTR == var.vt )
            {
                // Get and set the fileindex for this volume

                FILEID fid = GetFileId( var.pwszVal );

                PROPVARIANT varId;
                varId.vt = VT_UI8;
                varId.hVal.QuadPart = fid;

                pRec->WriteFixed( FileIdFieldRec.Ordinal(),
                                  FileIdFieldRec.Mask(),
                                  FileIdFieldRec.Offset(),
                                  FileIdFieldRec.Type(),
                                  cPriTotal,
                                  varId );

                // Set the last seen time so we don't reindex the file

                PROPVARIANT varLS;
                varLS.vt = VT_FILETIME;
                varLS.filetime = ftNow;

                pRec->WriteFixed( LastSeenFieldRec.Ordinal(),
                                  LastSeenFieldRec.Mask(),
                                  LastSeenFieldRec.Offset(),
                                  LastSeenFieldRec.Type(),
                                  cPriTotal,
                                  varLS );

#ifdef LOG
                printf( "fileid %#I64x, %ws\n", fid, var.pwszVal );
#endif
            }
        }

        if ( pRec->IsValidType() )
        {
            iRec += pRec->CountRecords();
            iRecTotal += pRec->CountRecords();
        }
        else
        {
            iRec++;
            iRecTotal++;
        }
    } while ( TRUE );

    pri.Flush();
} //PatchFileIDs

void GetNtVolumeInformation(
    ULONG       ulVolumeId,
    ULONGLONG & ullVolumeCreationTime,
    ULONG &     ulVolumeSerialNumber,
    ULONGLONG & ullJournalId )
{
    ullVolumeCreationTime = 0;
    ulVolumeSerialNumber = 0;
    ullJournalId = 0;

    WCHAR wszVolumePath[] = L"\\\\.\\a:";
    wszVolumePath[4] = (WCHAR) ulVolumeId;

    FILE_FS_VOLUME_INFORMATION VolumeInfo;
    VolumeInfo.VolumeCreationTime.QuadPart = 0;
    VolumeInfo.VolumeSerialNumber = 0;

    HANDLE hVolume = CreateFile( wszVolumePath,
                                 GENERIC_READ | GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 0,
                                 OPEN_EXISTING,
                                 0,
                                 0 );

    if ( INVALID_HANDLE_VALUE == hVolume )
    {
        printf( "failure: can't open volume %ws\n", wszVolumePath );
        exit( 1 );
    }

    IO_STATUS_BLOCK iosb;
    RtlZeroMemory( &VolumeInfo, sizeof VolumeInfo );
    NtQueryVolumeInformationFile( hVolume,
                                  &iosb,
                                  &VolumeInfo,
                                  sizeof(VolumeInfo),
                                  FileFsVolumeInformation );

    //
    // This call will only succeed on NTFS NT5 w/ USN Journal enabled.
    //

    USN_JOURNAL_DATA UsnJournalInfo;
    RtlZeroMemory( &UsnJournalInfo, sizeof UsnJournalInfo );
    NTSTATUS Status = NtFsControlFile( hVolume,
                                       0,
                                       0,
                                       0,
                                       &iosb,
                                       FSCTL_QUERY_USN_JOURNAL,
                                       0,
                                       0,
                                       &UsnJournalInfo,
                                       sizeof UsnJournalInfo );

    if ( NT_SUCCESS(Status) && NT_SUCCESS( iosb.Status ) )
    {
        // cool, it's a usn volume
    } 
    else if ( ( STATUS_JOURNAL_NOT_ACTIVE == Status ||
                STATUS_INVALID_DEVICE_STATE == Status ) )
    {
        //
        // Usn journal not created, create it
        //

        CREATE_USN_JOURNAL_DATA usnCreateData;
        usnCreateData.MaximumSize = 0x800000; // 8 meg
        usnCreateData.AllocationDelta = 0x100000; // 1 meg

        Status = NtFsControlFile( hVolume,
                                  0,
                                  0,
                                  0,
                                  &iosb,
                                  FSCTL_CREATE_USN_JOURNAL,
                                  &usnCreateData,
                                  sizeof usnCreateData,
                                  0,
                                  0 );
        if ( NT_SUCCESS( Status ) && NT_SUCCESS( iosb.Status ) )
        {
            Status = NtFsControlFile( hVolume,
                                      0,
                                      0,
                                      0,
                                      &iosb,
                                      FSCTL_QUERY_USN_JOURNAL,
                                      0,
                                      0,
                                      &UsnJournalInfo,
                                      sizeof UsnJournalInfo );

            if (! ( NT_SUCCESS(Status) && NT_SUCCESS( iosb.Status ) ) )
            {
                printf( "can't query usn vol info after creating it %#x\n", Status );
                exit( 1 );
            }
        }
        else
        {
            printf( "can't create usn journal %#x\n", Status );
            exit( 1 );
        }
    }
    else
    {
        printf( "can't get USN information, probably FAT: %#x\n", Status );
    }

    ullVolumeCreationTime = VolumeInfo.VolumeCreationTime.QuadPart;
    ulVolumeSerialNumber = VolumeInfo.VolumeSerialNumber;
    ullJournalId = UsnJournalInfo.UsnJournalID;

    printf( "      new volumecreationtime: %#I64x\n", ullVolumeCreationTime );
    printf( "      new volumeserialnumber: %#x\n", ulVolumeSerialNumber );
    printf( "      new journalid: %#I64x\n", ullJournalId );

    CloseHandle( hVolume );
} //GetNtVolumeInformation

void PatchScopeTable( WCHAR const * pwcDir )
{
    // Find out how many scopes are in the scope table

    ULONG cScopes = 0;

    {
        WCHAR awcControl[ MAX_PATH ];
        wcscpy( awcControl, pwcDir );
        wcscat( awcControl, L"cisp0000.000" );

        CMMFile Control( awcControl, FALSE );

        if ( 0 == Control.GetMapping() )
        {
            printf( "can't open file %ws\n", awcControl );
            exit( 1 );
        }
 
        cScopes = ((ULONG *) Control.GetMapping())[4];
    }

    WCHAR awcOne[ MAX_PATH ];
    wcscpy( awcOne, pwcDir );
    wcscat( awcOne, L"cisp0000.001" );
    
    // Loop through the scopes and patch 

    {
        printf( "  scope table: %ws has %d scopes\n", awcOne, cScopes );

        CMMFile One( awcOne, TRUE );
        if ( !One.Ok() )
        {
            printf( "can't map scope table\n" );
            exit( 1 );
        }
    
        BYTE * pb = (BYTE *) One.GetMapping();
    
        for ( ULONG i = 0; i < cScopes; i++ )
        {
            const LONGLONG eSigCiScopeTable = 0x5158515851585158i64;
            LONGLONG signature;
            memcpy( &signature, pb, sizeof signature );
            pb += sizeof signature;

            if ( 0 == signature )
                break;

            printf( "  scope record: \n" );

            if ( eSigCiScopeTable != signature )
            {
                printf( "invalid scope signature: %#I64x\n", signature );
                exit( 1 );
            }

            VOLUMEID volumeId;
            memcpy( &volumeId, pb, sizeof volumeId );
            printf( "    volumeId: %x\n", volumeId );
            pb += sizeof volumeId;

            ULONGLONG  ullNewVolumeCreationTime;
            ULONG      ulNewVolumeSerialNumber;
            ULONGLONG  ullNewJournalId;

            GetNtVolumeInformation( volumeId,
                                    ullNewVolumeCreationTime,
                                    ulNewVolumeSerialNumber,
                                    ullNewJournalId );

            ULONGLONG ullVolumeCreationTime;
            memcpy( &ullVolumeCreationTime, pb, sizeof ullVolumeCreationTime );
            printf( "    creation time: %#I64x\n", ullVolumeCreationTime );
            memcpy( pb,
                    &ullNewVolumeCreationTime,
                    sizeof ullNewVolumeCreationTime );
            pb += sizeof ullVolumeCreationTime;

            ULONG ulVolumeSerialNumber;
            memcpy( &ulVolumeSerialNumber, pb, sizeof ulVolumeSerialNumber );
            printf( "    serial number: %x\n", ulVolumeSerialNumber );
            memcpy( pb,
                    &ulNewVolumeSerialNumber,
                    sizeof ulNewVolumeSerialNumber );
            pb += sizeof ulVolumeSerialNumber;
    
            if ( CI_VOLID_USN_NOT_ENABLED == volumeId )
            {
                FILETIME ft;
                memcpy( &ft, pb, sizeof ft );
                printf( "    filetime: %#I64x\n", ft );
                pb += sizeof ft;
            }
            else
            {
                USN usn;
                memcpy( &usn, pb, sizeof usn );
                printf( "    usn: %#I64x\n", usn );
                USN usnNewMax = 0;
                memcpy( pb,
                        &usnNewMax,
                        sizeof usnNewMax );
                pb += sizeof usn;
    
                ULONGLONG JournalId;
                memcpy( &JournalId, pb, sizeof JournalId );
                printf( "    JournalId: %#I64x\n", JournalId );
                memcpy( pb,
                        &ullNewJournalId,
                        sizeof ullNewJournalId );
                pb += sizeof JournalId;
            }
    
            ULONG cwcPath;
            memcpy( &cwcPath, pb, sizeof cwcPath );
            pb += sizeof cwcPath;
    
            WCHAR awcPath[ MAX_PATH ];
            memcpy( awcPath, pb, cwcPath * sizeof WCHAR );
            printf( "    path: %ws\n", awcPath );
            pb += ( cwcPath * sizeof WCHAR );
        }

        One.Flush();
    }

    WCHAR awcTwo[ MAX_PATH ];
    wcscpy( awcTwo, pwcDir );
    wcscat( awcTwo, L"cisp0000.002" );

    BOOL f = CopyFile( awcOne, awcTwo, FALSE );

    if ( !f )
    {
        printf( "can't copy scope list, error %d\n", GetLastError() );
        exit( 1 );
    }
} //PatchScopeDir

extern "C" int __cdecl wmain( int argc, WCHAR * argv[] )
{
    if ( 2 != argc )
        Usage();

    //
    // The lone argument is the catalog directory, with or without catalog.wci
    //

    if ( wcslen( argv[1] ) > ( MAX_PATH-20 ) )
        Usage();

    WCHAR awcDir[ MAX_PATH ];
    wcscpy( awcDir, argv[1] );

    AppendBackslash( awcDir );

    if ( 0 == wcsistr( awcDir, L"catalog.wci" ) )
        wcscat( awcDir, L"catalog.wci\\" );

    // Find and validate the primary and secondary stores exist

    WCHAR awcPri[MAX_PATH];
    wcscpy( awcPri, awcDir );
    wcscat( awcPri, L"*.ps1" );

    WIN32_FIND_DATA findData;
    HANDLE h = FindFirstFile( awcPri, &findData );
    if ( INVALID_HANDLE_VALUE == h )
    {
        printf( "can't find primary *.ps1 store\n" );
        exit( 1 );
    }
    FindClose( h );
    wcscpy( awcPri, awcDir );
    wcscat( awcPri, findData.cFileName );

    WCHAR awcSec[MAX_PATH];
    wcscpy( awcSec, awcDir );
    wcscat( awcSec, L"*.ps2" );

    h = FindFirstFile( awcSec, &findData );
    if ( INVALID_HANDLE_VALUE == h )
    {
        printf( "can't find secondary *.ps2 store\n" );
        exit( 1 );
    }
    FindClose( h );
    wcscpy( awcSec, awcDir );
    wcscat( awcSec, findData.cFileName );

    //
    // Do the core work here -- patch the file IDs in the primary store.
    // Also whack the last seen times so the files aren't refiltered in
    // case they were copied to the target machine after the catalog was
    // snapped.
    //

    printf( "patching file IDs\n" );
    PatchFileIDs( awcDir, awcPri, awcSec );

    //
    // Patch the scope table so cisvc doesn't think it's a different volume.
    //

    printf( "patching the scope table\n" );
    PatchScopeTable( awcDir );

    //
    // Delete the old fileid hash table since the fileids are wrong.
    // It'll get recreated automatically when the catalog is opened.
    //

    printf( "deleting the fileid hash map\n" );
    WCHAR awcHashMap[ MAX_PATH ];
    wcscpy( awcHashMap, awcDir );
    wcscat( awcHashMap, L"cicat.fid" );

    DeleteFile( awcHashMap );

    printf( "catalog successfully converted\n" );

    return 0;
} //wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\propdump\main.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       propdump.cxx
//
//  Contents:   Property file dump utility
//
//  History:    29 Oct 1996     KyleP   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <proprec.hxx>
#include <propdesc.hxx>


DECLARE_INFOLEVEL(ci)

unsigned const SixtyFourK = 1024 * 64;
unsigned const cMaxFields = 10;

unsigned fVerbose = 0;

enum eRecType
{
    Virgin,
    Top,
    Overflow,
    Free
};

struct SmallInfo
{
    ULONG Type;
    ULONG Length;
    ULONG ulPrev;
    ULONG ulNext;
    ULONG ulChainLength;
};

void Usage()
{
    printf("Usage: PropDump [-?] [-v] [-m] [-f primary_field] [-s secondary_field] <primary file> [<secondary file>]\n");
    printf("       -? to dump this usage information.\n");
    printf("       -v to be verbose.\n");
    printf("       -m[o] to dump the metadata (o --> only. No integrity check).\n");
    printf("       -f field is used to dump a specific field in the primary store records.\n");
    printf("       -s field is used to dump a specific field in the secondary store records.\n");
    printf("       -c secWidPtrField is used to check for consistency between pri and sec stores. Param is usually 3.\n");
    printf("       -w[ps] <workid> dump only <workid> in primary/secondary store\n");
    printf("       <primary file> is the name of the primary file.\n");
    printf("       <secondary file> is the name of secondary file.\n");
    printf("       Specify primary and secondary for the two-level prop store.\n");
    printf("       If secondary is not specified, the primary will be construed as the name of the single store.\n");
}

char *   pszPrimFile = 0;
char *   pszSecFile = 0;
BOOL     fReadMetadata = 0;
BOOL     fMetadataOnly = 0;

unsigned cField1 = 0;
unsigned cField2 = 0;
int      aiField1[cMaxFields];
int      aiField2[cMaxFields];
BOOL     fTwoLevel = FALSE;
ULONG    cPriRecPerBuf, cbPriRec, cPriTotal, cPriFixed;
ULONG    cSecRecPerBuf, cbSecRec, cSecTotal, cSecFixed;
ULONG    cMaxWidsInSecStore;
int      cWidPtrField = 0;
ULONG    widPrimary = 0xFFFFFFFF;
ULONG    widSecondary = 0xFFFFFFFF;

const DWORD PrimaryStore = 0;
const DWORD SecondaryStore = 1;

void DumpStore(char *pszFile, unsigned cField, int *aiField, DWORD dwLevel, ULONG wid);
void CheckConsistencyBetweenStores(char * pszPrimFile, char *pszSecFile);

CPropDesc aFieldRec[cMaxFields];
CPropDesc SecWidPtrFieldRec;

int __cdecl main( int argc, char * argv[] )
{
    if (argc < 2)
    {
        Usage();
        return 0;
    }

    for ( int i = 1; i < argc; i++ )
    {
        if ( argv[i][0] == '-' )
        {
            switch ( argv[i][1] )
            {

            case '?':
                Usage();
                return 0;

            case 'v':
            case 'V':
                fVerbose = 1;
                break;

            case 'm':
            case 'M':
                fReadMetadata = TRUE;
                if ( argv[i][2] == 'o' || argv[i][2] == 'O' )
                    fMetadataOnly = TRUE;
                break;

            case 'f':
            case 'F':
                i++;

                if ( cField1 < cMaxFields )
                    aiField1[cField1++] = strtol( argv[i], 0, 10 );
                break;


            case 's':
            case 'S':
                i++;

                if ( cField2 < cMaxFields )
                    aiField2[cField2++] = strtol( argv[i], 0, 10 );
                break;

            case 'c':
            case 'C':
                i++;
                cWidPtrField = strtol(argv[i], 0, 10);
                // this works only if fReadMetadata is turned on
                fReadMetadata = TRUE;
                break;

            case 'w':
            case 'W':
                switch ( argv[i][2] )
                {
                case 'p':
                case 'P':
                case '\0':
                    i++;
                    widPrimary = strtol(argv[i], 0, 10);
                    break;

                case 's':
                case 'S':
                    i++;
                    widSecondary = strtol(argv[i], 0, 10);
                    break;
                }
            }
        }
        else
        {
            if (!pszPrimFile)
                pszPrimFile = argv[i];
            else
            {
                pszSecFile = argv[i];
                fTwoLevel = TRUE;
            }
        }
    }

    // If we don't have a primary file or a secondary file, look for them in the current directory.
    if (!pszPrimFile)
    {
        fTwoLevel = TRUE;
        pszPrimFile = "00000002.ps1";
        pszSecFile = "00000002.ps2";
    }

    // Verify that the propstore files are indeed available!
    if (0xFFFFFFFF == GetFileAttributesA(pszPrimFile))
    {
        printf("Can't find primary file %s for reason %d\n", pszPrimFile, GetLastError());
        return 0;
    }

    if (0xFFFFFFFF == GetFileAttributesA(pszSecFile))
    {
        printf("Can't find secondary file. Assuming single level property store\n");
        fTwoLevel = FALSE;
    }
    else
        fTwoLevel = TRUE;

    cPriRecPerBuf = cbPriRec = cSecRecPerBuf = cbSecRec = 0;

    //
    // CheckConsistencyBetweenStores relies on some of the information gathered
    // by calls to DumpStore, so they should be called before consistency check.
    //

    DumpStore(pszPrimFile, cField1, aiField1, PrimaryStore, widPrimary );
    if (fTwoLevel)
    {
        DumpStore(pszSecFile, cField2, aiField2, SecondaryStore, widSecondary);
        if (cWidPtrField > 0)
        {
            CheckConsistencyBetweenStores(pszPrimFile, pszSecFile);
        }
    }

    return 0;
}

void DumpStore(char *pszFile, unsigned cField, int *aiField, DWORD dwLevel, ULONG wid )
{
    BYTE abTemp[SixtyFourK];

    //
    // First, read out the metadata
    //

    unsigned cFixed = 0;
    unsigned cTotal = 0;
    unsigned culFixed = 0;

    if ( fReadMetadata || cField != 0 )
    {
        //
        // Build path.
        //

        char szPath[MAX_PATH];
        strcpy( szPath, pszFile );
        char * pLastSlash = strrchr( szPath, '\\' );
        if (pLastSlash)
            pLastSlash++;
        else
            pLastSlash = szPath;
        if (fTwoLevel)
        {
            if (PrimaryStore == dwLevel)
                strcpy( pLastSlash, "CIP10000.001" );
            else
                strcpy( pLastSlash, "CIP20000.001" );
        }
        else
            strcpy( pLastSlash, "CIPS0000.001" );

        HANDLE h = CreateFileA( szPath,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                0,
                                OPEN_EXISTING,
                                0,
                                0 );

        if ( INVALID_HANDLE_VALUE == h )
        {
            printf( "Can't open file %s. Error %u\n", szPath, GetLastError() );
            return;
        }

        ULONG cbRead;

        if ( ReadFile( h,
                       abTemp,
                       sizeof(abTemp),
                       &cbRead,
                       0 ) )
        {
            //
            // Loop through records
            //

            CPropDesc * pPropDesc = (CPropDesc *)abTemp;

            if ( fReadMetadata )
                printf( "Record\t%-25s  Type\t\tOffset\tSize\tOrdinal\tMask\n",
                        "   Pid" );

            for ( unsigned i = 0;
                  i < cbRead/(sizeof(CPropDesc) + sizeof(ULONG));
                  i++, pPropDesc = (CPropDesc *)(((BYTE *)pPropDesc) + sizeof(CPropDesc) + sizeof(ULONG)) )
            {
                if ( pPropDesc->Pid() != 0 )
                {
                    if ( fReadMetadata )
                    {
                        char * pszPidName = 0;
                        char * pszMarker = "";
                        switch (pPropDesc->Pid())
                        {
                        case pidSecurity:
                            pszPidName = "pidSecurity"; break;
                        case pidDirectory:
                            pszPidName = "pidDirectory";        break;
                        case pidClassId:
                            pszPidName = "pidClassId";  break;
                        case pidStorageType:
                            pszPidName = "pidStorageType";      break;
                        case pidFileIndex:
                            pszPidName = "pidFileIndex";        break;
                        case pidVolumeId:
                            pszPidName = "pidVolumeId"; break;
                        case pidParentWorkId:
                            pszPidName = "pidParentWorkId";     break;
                        case pidLastChangeUsn:
                            pszPidName = "pidLastChangeUsn";    break;
                        case pidName:
                            pszPidName = "pidName";     break;
                        case pidSize:
                            pszPidName = "pidSize";     break;
                        case pidAttrib:
                            pszPidName = "pidAttrib";   break;
                        case pidWriteTime:
                            pszPidName = "pidWriteTime";        break;
                        case pidCreateTime:
                            pszPidName = "pidCreateTime";       break;
                        case pidAccessTime:
                            pszPidName = "pidAccessTime";       break;
                        case pidShortName:
                            pszPidName = "pidShortName";        break;
                        case pidWorkId:
                            pszPidName = "pidWorkId";   break;
                        case pidUnfiltered:
                            pszPidName = "pidUnfiltered";       break;
                        case pidRevName:
                            pszPidName = "pidRevName";  break;
                        case pidVirtualPath:
                            pszPidName = "pidVirtualPath";      break;
                        case pidLastSeenTime:
                            pszPidName = "pidLastSeenTime";     break;
                        case pidPath:
                            pszPidName = "pidPath";
                            pszMarker = "**";
                            break;
                        case pidSecondaryStorage:
                            pszPidName = "pidSecondaryStorage";
                            pszMarker = "*";
                            break;
                        }

                        static char achBuf[20];

                        if ( 0 == pszPidName )
                        {
                            sprintf( achBuf, "   %d(0x%x)",
                                     pPropDesc->Pid(), pPropDesc->Pid() );
                        }
                        else
                        {
                            sprintf( achBuf, "%-3s%d(%s)",
                                     pszMarker, pPropDesc->Pid(), pszPidName );
                        }
                        printf( "%u:\t%-25s  %u (0x%x)\t%d\t%u\t%u\t0x%x\n",
                                pPropDesc->Record(),
                                achBuf,
                                pPropDesc->Type(), pPropDesc->Type(),
                                pPropDesc->Offset(),
                                pPropDesc->Size(),
                                pPropDesc->Ordinal(),
                                pPropDesc->Mask() );
                    }

                    cTotal++;

                    if ( pPropDesc->Offset() != -1 )
                    {
                        cFixed++;
                        culFixed += (pPropDesc->Size() / sizeof(DWORD));
                    }

                    // copy the description of the sec top-level wid ptr for later use
                    if ( PrimaryStore == dwLevel && cWidPtrField && cWidPtrField == (int)pPropDesc->Record() )
                    {
                        memcpy( &SecWidPtrFieldRec, pPropDesc, sizeof(aFieldRec[0]) );
                    }

                    for ( unsigned j = 0; j < cField; j++ )
                    {
                        if ( aiField[j] == (int)pPropDesc->Record() )
                            memcpy( &aFieldRec[j], pPropDesc, sizeof(aFieldRec[0]) );

                        if (cWidPtrField && cWidPtrField == (int)j )
                        {
                            // verify that we are capturing the right property
                            // description for the sec top-level wid ptr
                            for (int k = 0; k < sizeof(aFieldRec[0]); k++)
                            {
                                Win4Assert(RtlEqualMemory(&aFieldRec[j], &SecWidPtrFieldRec, sizeof(SecWidPtrFieldRec)));
                            }
                        }
                    }
                }
            }

            printf( "\n%u Properties, %u Fixed totaling %u bytes  (* = Secondary link, ** = Path)\n\n",
                    cTotal, cFixed, culFixed * sizeof(DWORD) );
        }
        else
        {
            printf( "Can't read file %s.  Error %u\n", szPath, GetLastError() );
            return;
        }

        CloseHandle(h);

        if ( fMetadataOnly )
            return;
    }


    HANDLE h = CreateFileA( pszFile,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            0,
                            OPEN_EXISTING,
                            0,
                            0 );

    if ( INVALID_HANDLE_VALUE == h &&
         ERROR_SHARING_VIOLATION == GetLastError() )
    {
        h = CreateFileA( pszFile,
                         GENERIC_READ,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         0,
                         OPEN_EXISTING,
                         0,
                         0 );
    }

    if ( INVALID_HANDLE_VALUE == h )
    {
        printf( "Can't open file %s. Error %u\n", pszFile, GetLastError() );
        return;
    }

    BY_HANDLE_FILE_INFORMATION fi;

    if ( !GetFileInformationByHandle( h, &fi ) )
    {
        printf( "Error %u getting size from handle\n", GetLastError() );
        return;
    }

    ULONG oFile = 0;
    ULONG cbRec = 0;
    ULONG cRecPerBuf;
    ULONG cRecTotal;
    ULONG cTotalSections = 0;

    HANDLE hSmallInfo;
    SmallInfo * aSmallInfo = 0;

    ULONG iSection = 0;

    BOOL fFirst = TRUE;

    ULONG iCurrentPct = 0;

    ULONG cTopLevel = 0;
    ULONG cOverflow = 0;
    ULONG cFree = 0;
    ULONG cVirgin = 0;

    for (;;)
    {
        ULONG cbRead;

        if ( ReadFile( h,
                       abTemp,
                       sizeof(abTemp),
                       &cbRead,
                       0 ) )
        {
            if (fVerbose)
                printf( "READ: 0x%x bytes, offset 0x%x\n", cbRead, oFile );

            if ( 0 == cbRead )
                break;

            if ( fFirst )
            {
                //
                // Determine record size
                //

                if ( abTemp[0] != 0 || abTemp[1] != 0 )
                {
                    printf( "Record 0 not blank.  File corrupt!\n" );
                    break;
                }

                // First record should be all empty and only the first
                // record should be so. So counting all leading zeros gives us
                // the size of the record.
                for ( unsigned i = 0; i < cbRead && abTemp[i] == 0; i++ )
                    continue;

                if ( i == cbRead )
                {
                    printf( "First %uK segment all zero!.  File corrupt!\n", sizeof(abTemp)/1024 );
                    break;
                }

                switch ( *(USHORT *)&abTemp[i] )
                {
                case 0x5555:
                case 0xAAAA:
                case 0xBBBB:
                case 0xCCCC:
                case 0xDDDD:
                    cbRec = i;

                    if ( cbRec % 4 != 0 )
                    {
                        printf( "Record size (%u bytes) not DWORD aligned!\n\n", cbRec );
                        return;
                    }

                    cRecPerBuf = sizeof(abTemp) / cbRec;
                    printf( "Record size: %u bytes (%u / %uK)\n", i, cRecPerBuf, sizeof(abTemp)/1024 );
                    cTotalSections = (fi.nFileSizeLow + sizeof(abTemp) - 1)/ sizeof abTemp;

                    hSmallInfo = LocalAlloc( LMEM_MOVEABLE,
                                             ((fi.nFileSizeLow / sizeof(abTemp)) + 1) * cRecPerBuf * sizeof(SmallInfo) );
                    aSmallInfo = (SmallInfo *)LocalLock( hSmallInfo );

                    break;

                default:
                    printf( "First non-zero byte is not a proper signature (%u)!\n", *(SHORT *)&abTemp[i] );
                    return;
                }

                if (PrimaryStore == dwLevel)
                {
                    cPriRecPerBuf = cRecPerBuf;
                    cbPriRec = cbRec;
                    cPriTotal = cTotal;
                    cPriFixed = cFixed;
                }
                else
                {
                    cSecRecPerBuf = cRecPerBuf;
                    cbSecRec = cbRec;
                    cSecTotal = cTotal;
                    cSecFixed = cFixed;
                }

                fFirst = FALSE;
            }

            ULONG iRec = 0;

            while ( iRec < cRecPerBuf )
            {
                COnDiskPropertyRecord * pRec = new( iRec, abTemp, cbRec/4 ) COnDiskPropertyRecord;

                if ( !pRec->IsValidType() )
                {
                    printf( "Record 0x%x (%u:%u) (file offset 0x%x) is corrupt!\n",
                            iSection * cRecPerBuf + iRec,
                            iSection, iRec,
                            iSection * sizeof(abTemp) + iRec * cbRec );
                }

                if (fVerbose )
                    printf( "%u:%u, %s, length = %u record(s)",
                        iSection, iRec,
                        pRec->IsNormalTopLevel() ? "Top Level Normal" :
                            pRec->IsOverflow() ? "Overflow" :
                                pRec->IsFreeRecord() ? "Free Normal" :
                                    pRec->IsTopLevel() ? "Top Level Lean":
                                        pRec->IsLeanFreeRecord() ? "Free Lean":
                                    "Virgin",
                        pRec->CountRecords() );

                aSmallInfo[iSection*cRecPerBuf + iRec].ulChainLength = 0;

                BOOL fPrint = (0xFFFFFFFF == wid || iSection*cRecPerBuf + iRec == wid);

                if ( pRec->IsOverflow() )
                {
                    aSmallInfo[iSection*cRecPerBuf + iRec].Type = Overflow;
                    cOverflow++;

                    for ( unsigned j = 0; j < cField; j++ )
                    {
                        PROPVARIANT var;
                        BYTE abExtra[MAX_PATH * 5];
                        unsigned cbExtra = sizeof(abExtra);

                        if ( 0 == j && fPrint )
                            printf( "%6u: ", iSection*cRecPerBuf + iRec );

                        if ( aFieldRec[j].IsFixedSize() )
                            continue;

                        ULONG Ordinal = aFieldRec[j].Ordinal() - cFixed;
                        DWORD Mask = (1 << ((Ordinal % 16) * 2) );

                        BOOL fOk = pRec->ReadVariable( Ordinal,
                                                       Mask,
                                                       0,
                                                       cTotal - cFixed,
                                                       0,
                                                       var,
                                                       abExtra,
                                                       &cbExtra );

                        if ( fOk && fPrint )
                        {
                            switch ( var.vt )
                            {
                            case VT_LPSTR:
                                printf( "%s ", var.pszVal );
                                break;

                            case VT_LPWSTR:
                                printf( "%ws ", var.pwszVal );
                                break;
                            }
                        }
                    }

                    if ( 0 != cField && fPrint )
                        printf( "\n" );
                }
                else if ( pRec->IsNormalTopLevel() )
                {
                    aSmallInfo[iSection*cRecPerBuf + iRec].Type = Top;
                    aSmallInfo[iSection*cRecPerBuf + iRec].ulChainLength = pRec->GetOverflowChainLength();
                    cTopLevel++;

                    for ( unsigned j = 0; j < cField; j++ )
                    {
                        PROPVARIANT var;
                        BYTE abExtra[MAX_PATH * 5];
                        unsigned cbExtra = sizeof(abExtra);

                        if ( 0 == j && fPrint )
                            printf( "%6u: ", iSection*cRecPerBuf + iRec );

                        if ( aFieldRec[j].IsFixedSize() )
                        {
                            pRec->ReadFixed( aFieldRec[j].Ordinal(),
                                             aFieldRec[j].Mask(),
                                             aFieldRec[j].Offset(),
                                             cTotal,
                                             aFieldRec[j].Type(),
                                             var,
                                             abExtra,
                                             &cbExtra,
                                             *((PStorage *)0) );

                            if ( fPrint )
                            {
                                switch ( var.vt )
                                {
                                case VT_EMPTY:
                                    printf( "n/a " );
                                    break;

                                case VT_I4:
                                    printf( "%8d ", var.lVal );
                                    break;

                                case VT_UI4:
                                    printf( "%8u ", var.ulVal );
                                    break;

                                case VT_FILETIME:
                                    {
                                        SYSTEMTIME stTime;

                                        FileTimeToSystemTime( &var.filetime, &stTime );

                                        WCHAR awcBuffer[100] = L"???";

                                        GetDateFormat( LOCALE_USER_DEFAULT,   // locale
                                                       0,                     // flags
                                                       &stTime,               // time
                                                       L"MM/dd/yy  ",         // format
                                                       awcBuffer,             // output
                                                       sizeof(awcBuffer)/sizeof(awcBuffer[0]) );

                                        GetTimeFormat( LOCALE_USER_DEFAULT,   // locale
                                                       0,                     // flags
                                                       &stTime,               // time
                                                       L"hh:mmt",             // format
                                                       awcBuffer + 10,        // output
                                                       sizeof(awcBuffer)/sizeof(awcBuffer[0]) - 10 );

                                        awcBuffer[15] += 0x20;  // lowercase

                                        printf( "%ws ", awcBuffer );
                                    }
                                    break;

                                case VT_I8:
                                    printf( "%12hu ", var.hVal );
                                    break;

                                case VT_UI8:
                                    printf( "0x%08lx%08lx ", (ULONG) (var.uhVal.QuadPart>>32), (ULONG) var.uhVal.QuadPart );
                                    break;
                                }
                            }
                        }
                        else
                        {
                            BOOL fOk = pRec->ReadVariable( aFieldRec[j].Ordinal(),
                                                           aFieldRec[j].Mask(),
                                                           culFixed,
                                                           cTotal,
                                                           cFixed,
                                                           var,
                                                           abExtra,
                                                           &cbExtra );

                            if ( fOk && fPrint )
                            {
                                switch ( var.vt )
                                {
                                case VT_LPSTR:
                                    printf( "%s ", var.pszVal );
                                    break;

                                case VT_LPWSTR:
                                    printf( "%ws ", var.pwszVal );
                                    break;
                                }
                            }
                        }
                    }

                    if ( 0 != cField && fPrint )
                        printf( "\n" );
                }
                else if ( pRec->IsTopLevel() )
                {
                    // This is a lean top level record
                    aSmallInfo[iSection*cRecPerBuf + iRec].Type = Top;
                    aSmallInfo[iSection*cRecPerBuf + iRec].ulChainLength = 0;
                    cTopLevel++;

                    for ( unsigned j = 0; j < cField; j++ )
                    {
                        PROPVARIANT var;
                        BYTE abExtra[MAX_PATH * 5];
                        unsigned cbExtra = sizeof(abExtra);

                        if ( 0 == j && fPrint )
                            printf( "%6u: ", iSection*cRecPerBuf + iRec );

                        Win4Assert(aFieldRec[j].IsFixedSize());

                        {
                            pRec->ReadFixed( aFieldRec[j].Ordinal(),
                                             aFieldRec[j].Mask(),
                                             aFieldRec[j].Offset(),
                                             cTotal,
                                             aFieldRec[j].Type(),
                                             var,
                                             abExtra,
                                             &cbExtra,
                                             *((PStorage *)0) );

                            if ( fPrint )
                            {
                                switch ( var.vt )
                                {
                                case VT_EMPTY:
                                    printf( "n/a " );
                                    break;

                                case VT_I4:
                                    printf( "%8d ", var.lVal );
                                    break;

                                case VT_UI4:
                                    printf( "%8u ", var.ulVal );
                                    break;

                                case VT_FILETIME:
                                    {
                                        SYSTEMTIME stTime;

                                        FileTimeToSystemTime( &var.filetime, &stTime );

                                        WCHAR awcBuffer[100] = L"???";

                                        GetDateFormat( LOCALE_USER_DEFAULT,   // locale
                                                       0,                     // flags
                                                       &stTime,               // time
                                                       L"MM/dd/yy  ",         // format
                                                       awcBuffer,             // output
                                                       sizeof(awcBuffer)/sizeof(awcBuffer[0]) );

                                        GetTimeFormat( LOCALE_USER_DEFAULT,   // locale
                                                       0,                     // flags
                                                       &stTime,               // time
                                                       L"hh:mmt",             // format
                                                       awcBuffer + 10,        // output
                                                       sizeof(awcBuffer)/sizeof(awcBuffer[0]) - 10 );

                                        awcBuffer[15] += 0x20;  // lowercase

                                        printf( "%ws ", awcBuffer );

                                    }
                                    break;

                                case VT_I8:
                                    printf( "%12hu ", var.hVal );
                                    break;

                                case VT_UI8:
                                    printf( "0x%08lx%08lx ", (ULONG) (var.uhVal.QuadPart>>32), (ULONG) var.uhVal.QuadPart );
                                    break;
                                }
                            }
                        }
                    }

                    if ( 0 != cField && fPrint )
                        printf( "\n" );
                }
                else if ( pRec->IsFreeRecord() )
                {
                    aSmallInfo[iSection*cRecPerBuf + iRec].Type = Free;
                    cFree++;
                }
                else
                {
                    aSmallInfo[iSection*cRecPerBuf + iRec].Type = Virgin;
                    cVirgin++;
                }

                if (pRec->IsNormalTopLevel() || pRec->IsOverflow())
                {
                    aSmallInfo[iSection*cRecPerBuf + iRec].ulPrev = pRec->ToplevelBlock();
                    aSmallInfo[iSection*cRecPerBuf + iRec].ulNext = pRec->OverflowBlock();

                    if ( pRec->OverflowBlock() != 0 )
                    {
                        /* printf( ", Overflow = %u:%u (file offset 0x%x)",
                                pRec->OverflowBlock() / cRecPerBuf,
                                pRec->OverflowBlock() % cRecPerBuf,
                                (pRec->OverflowBlock() / cRecPerBuf) * sizeof(abTemp) +
                                    (pRec->OverflowBlock() % cRecPerBuf) * cbRec ); */
                    }
                }
                else if (pRec->IsTopLevel())
                {
                    aSmallInfo[iSection*cRecPerBuf + iRec].ulPrev = 0;
                    aSmallInfo[iSection*cRecPerBuf + iRec].ulNext = 0;
                }
                else if (pRec->IsFreeRecord())
                {
                    aSmallInfo[iSection*cRecPerBuf + iRec].ulPrev = pRec->GetPreviousFreeRecord();
                    aSmallInfo[iSection*cRecPerBuf + iRec].ulNext = pRec->GetNextFreeRecord();
                }
                aSmallInfo[iSection*cRecPerBuf + iRec].Length = pRec->CountRecords();

                if ( pRec->CountRecords() == 0 )
                {
                    printf( "Record %u (file offset 0x%x) is zero length!\n",
                            iSection * cRecPerBuf + iRec,
                            iSection * sizeof(abTemp) + iRec * cbRec );
                }

                if (fVerbose)
                    printf( "\n" );

                if ( pRec->IsValidType() )
                    iRec += pRec->CountRecords();
                else
                    iRec++;

                ULONG iPct = (iSection * (100/5) / cTotalSections) * 5;
                if (iPct != iCurrentPct)
                {
                    iCurrentPct = iPct;
                    if (0 == wid)
                        printf( "Read %u%%\n", iCurrentPct );
                }

            }

            iSection++;
            oFile += cbRead;
        }
        else
        {
            ULONG Status = GetLastError();

            if ( Status == ERROR_HANDLE_EOF )
                break;
            else
            {
                printf( "Error %u reading file.\n", Status );
            }
        }
    }

    if (SecondaryStore == dwLevel)
        cMaxWidsInSecStore = iSection * cRecPerBuf;

    if (wid == 0 || wid == 0xFFFFFFFF)
    {
        printf( "Read 100%%\n" );
        printf( "%6u Top-Level records\n"
                "%6u Overflow records\n"
                "%6u Free records\n"
                "%6u Virgin records\n", cTopLevel, cOverflow, cFree, cVirgin );
    }

    CloseHandle( h );

    //
    // Now check inter-record state
    //

    unsigned iRec = 0;
    unsigned iCurrentSection = 0;
    iCurrentPct = 0;

    while ( iRec < iSection * cRecPerBuf )
    {
        if ( aSmallInfo[iRec].Type == Top )
        {
            unsigned iOverflowRec = aSmallInfo[iRec].ulNext;
            unsigned cOverflowRec = 0;

            while ( 0 != iOverflowRec )
            {
                if ( aSmallInfo[iOverflowRec].Type != Overflow )
                {
                    printf( "Record 0x%x (%u:%u) (file offset 0x%x) should be overflow and is not!\n   Top level = 0x%x (%u:%u) (file offset 0x%x)\n",
                            iOverflowRec,
                            iOverflowRec / cRecPerBuf,
                            iOverflowRec % cRecPerBuf,
                            (iOverflowRec / cRecPerBuf) * sizeof(abTemp) +
                                (iOverflowRec % cRecPerBuf) * cbRec,
                            iRec,
                            iRec / cRecPerBuf,
                            iRec % cRecPerBuf,
                            (iRec / cRecPerBuf) * sizeof(abTemp) +
                                (iRec % cRecPerBuf) * cbRec );

                    break;
                }

                iOverflowRec = aSmallInfo[iOverflowRec].ulNext;
                cOverflowRec++;
                if ( cOverflowRec > aSmallInfo[iRec].ulChainLength )
                    break;
            }

            if ( aSmallInfo[iRec].ulChainLength != cOverflowRec )
            {
                printf( "Record 0x%x (%u:%u) (file offset 0x%x) chain length mismatch %d,%d!\n",
                        iRec,
                        iRec / cRecPerBuf,
                        iRec % cRecPerBuf,
                        (iRec / cRecPerBuf) * sizeof(abTemp) +
                                (iRec % cRecPerBuf) * cbRec,
                        aSmallInfo[iRec].ulChainLength, cOverflowRec );
            }
        }

        if (aSmallInfo[iRec].Length == 0)
        {
            printf( "%u:%u (file offset 0x%x) zero length record!\n",
                    iRec / cRecPerBuf,
                    iRec % cRecPerBuf,
                    (iRec / cRecPerBuf) * sizeof(abTemp) +
                        (iRec % cRecPerBuf) * cbRec );

            iRec++;
        } else {
            iRec += aSmallInfo[iRec].Length;
        }

        if ( (iRec / cRecPerBuf) != iCurrentSection )
        {
            if (fVerbose)
                printf( "Checked section %u\n", iCurrentSection );

            ULONG iPct = (iCurrentSection * (100/5) / iSection) * 5;
            if (iPct != iCurrentPct)
            {
                iCurrentPct = iPct;
                if (wid == 0 || wid == 0xFFFFFFFF)
                    printf( "Checked %u%%\n", iCurrentPct );
            }

            iCurrentSection = (iRec / cRecPerBuf);
        }
    }

    if (wid == 0 || wid == 0xFFFFFFFF)
        printf( "Checked 100%%\n" );

    LocalUnlock( hSmallInfo );
    LocalFree( hSmallInfo );
}

void CheckConsistencyBetweenStores(char * pszPriFile, char *pszSecFile)
{
    BYTE abTemp[SixtyFourK];
    BYTE abTemp2[SixtyFourK];
    ULONG iSection2 = 0, iTargetSection = 0, oFile = 0, iSection = 0;
    ULONG cInconsistencies = 0;
    ULONG cPriTotalSections = 0;
    ULONG cSecTotalSections = 0;
    ULONG iCurrentPct = 0;

    HANDLE hPri = CreateFileA( pszPriFile,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            0,
                            OPEN_EXISTING,
                            0,
                            0 );

    if ( INVALID_HANDLE_VALUE == hPri )
    {
        printf( "Can't open file %s. Error %u\n", pszPriFile, GetLastError() );
        return;
    }

    HANDLE hSec = CreateFileA( pszSecFile,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            0,
                            OPEN_EXISTING,
                            0,
                            0 );

    if ( INVALID_HANDLE_VALUE == hSec )
    {
        printf( "Can't open file %s. Error %u\n", pszSecFile, GetLastError() );
        return;
    }

    BY_HANDLE_FILE_INFORMATION fi;

    if ( GetFileInformationByHandle( hPri, &fi ) )
    {
        cPriTotalSections = (fi.nFileSizeLow + sizeof(abTemp) - 1)/ sizeof abTemp;
    }
    else
    {
        printf( "Error %u getting size from primary's handle\n", GetLastError() );
        return;
    }

    if ( GetFileInformationByHandle( hSec, &fi ) )
    {
        cSecTotalSections = (fi.nFileSizeLow + sizeof(abTemp) - 1)/ sizeof abTemp;
    }
    else
    {
        printf( "Error %u getting size from secondary's handle\n", GetLastError() );
        return;
    }

    ULONG ulSecWidPtr = widInvalid;

    // read the first large page of the secondary store into memory.
    DWORD cbRead2;
    ReadFile( hSec, abTemp2, sizeof(abTemp2), &cbRead2, 0 );

    for (;;)
    {
        ULONG cbRead;

        if ( ReadFile( hPri, abTemp, sizeof(abTemp), &cbRead, 0 ) )
        {
            if ( 0 == cbRead )
                break;

            ULONG iRec = 0;

            while ( iRec < cPriRecPerBuf )
            {
                COnDiskPropertyRecord * pRec = new( iRec, abTemp, cbPriRec/4 ) COnDiskPropertyRecord;

                if ( pRec->IsTopLevel() )
                {
                    Win4Assert(!pRec->IsNormalTopLevel());

                    PROPVARIANT var;
                    BYTE abExtra[MAX_PATH * 5];
                    unsigned cbExtra = sizeof(abExtra);

                    Win4Assert(SecWidPtrFieldRec.IsFixedSize());

                    {
                        pRec->ReadFixed( SecWidPtrFieldRec.Ordinal(),
                                         SecWidPtrFieldRec.Mask(),
                                         SecWidPtrFieldRec.Offset(),
                                         cPriTotal,
                                         SecWidPtrFieldRec.Type(),
                                         var,
                                         abExtra,
                                         &cbExtra,
                                         *((PStorage *)0) );

                        switch ( var.vt )
                        {
                        case VT_EMPTY:
                            Win4Assert(!"Reading VT_EMPTY. Expect to read VT_UI4");
                            break;

                        case VT_I4:
                            Win4Assert(!"Reading VT_I4. Expect to read VT_UI4");
                            break;

                        case VT_UI4:
                        {
                            // Do we need to read a new large page?
                            iTargetSection = var.ulVal/cSecRecPerBuf;
                            if (var.ulVal > cMaxWidsInSecStore)  // ensure that it is a valid wid in secondary store.
                            {
                                printf("Wid %u (0x%x) is pointing to a non-existent wid %u (0x%x) in Secondary store.\n",
                                       iSection*cPriRecPerBuf + iRec, iSection*cPriRecPerBuf + iRec,
                                       var.ulVal, var.ulVal);
                                continue;
                            }

                            if (iSection2 != iTargetSection)
                            {
                                // seek to the target section and read the large page into buffer.
                                //SetFilePointer(hSec, (iTargetSection - iSection2)*SixtyFourK, 0, FILE_CURRENT);
                                SetFilePointer(hSec, iTargetSection*SixtyFourK, 0, FILE_BEGIN);
                                ReadFile( hSec, abTemp2, sizeof(abTemp2), &cbRead2, 0 );
                                iSection2 = iTargetSection;
                            }

                            // Get the record in question.
                            COnDiskPropertyRecord * pRec2 = new( var.ulVal % cSecRecPerBuf, abTemp2, cbSecRec/4 ) COnDiskPropertyRecord;

                            // Now grill it!
                            if (!pRec2->IsNormalTopLevel())
                            {
                                cInconsistencies++;
                                // Invalid record type
                                printf("Error: Wid %u (0x%x), (%u:%u) is pointing to a non-toplevel  wid %u (0x%x), ",
                                       iSection*cPriRecPerBuf + iRec,
                                       iSection*cPriRecPerBuf + iRec,
                                       iSection, iRec,
                                       var.ulVal, var.ulVal);

                                 printf("(%u:%u), %s, length = %u record(s)\n",
                                    iSection2, var.ulVal % cSecRecPerBuf,
                                    pRec2->IsNormalTopLevel() ? "Top Level Normal" :
                                        pRec2->IsOverflow() ? "Overflow" :
                                            pRec2->IsFreeRecord() ? "Free Normal" :
                                                pRec2->IsTopLevel() ? "Top Level Lean":
                                                    pRec2->IsLeanFreeRecord() ? "Free Lean":
                                                "Virgin",
                                    pRec2->CountRecords() );
                            }
                            break;
                        }

                        case VT_FILETIME:
                            Win4Assert(!"Reading VT_FILETIME. Expect to read VT_UI4");
                            break;

                        case VT_I8:
                            Win4Assert(!"Reading VT_I8. Expect to read VT_UI4");
                            break;

                        case VT_UI8:
                            Win4Assert(!"Reading VT_UI8. Expect to read VT_UI4");
                            break;
                        }
                    }
                }
                else if ( pRec->IsFreeRecord() )
                {

                }
                else
                {

                }

                if ( pRec->CountRecords() == 0 )
                {
                    printf( "Record %u (file offset 0x%x) is zero length!\n",
                            iSection * cPriRecPerBuf + iRec,
                            iSection * sizeof(abTemp) + iRec * cbPriRec );
                }

                if ( pRec->IsValidType() )
                    iRec += pRec->CountRecords();
                else
                    iRec++;

                ULONG iPct = (iSection * (100/5) / cPriTotalSections) * 5;
                if (iPct != iCurrentPct)
                {
                    iCurrentPct = iPct;
                    printf( "Read %u%%\n", iCurrentPct );
                }
            }

            iSection++;
            oFile += cbRead;
        }
        else
        {
            ULONG Status = GetLastError();

            if ( Status == ERROR_HANDLE_EOF )
                break;
            else
            {
                printf( "Error %u reading file.\n", Status );
            }
        }
    }

    CloseHandle( hPri );
    CloseHandle( hSec );

    if (cInconsistencies)
    {
        printf("%d inconsistencies were detected between the two stores.\n", cInconsistencies);
    }
    else
        printf("No inconsistencies were detected between the two stores.\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\propdump\vmapdump.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 2000.
//
//  File:       vmapdump.cxx
//
//  Contents:   VMAP dump utility
//
//  History:    22 Jan 1998     AlanW   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <vmap.hxx>


DECLARE_INFOLEVEL(ci)

unsigned fVerbose = 0;

int VMapDump( char * pszPath );

int __cdecl main( int argc, char * argv[] )
{
    char *   pszFile = argv[1];
    unsigned cFail = 0;

    for ( int i = 1; i < argc; i++ )
    {
        if ( argv[i][0] == '-' )
        {
            switch ( argv[i][1] )
            {
            case 'v':
            case 'V':
                fVerbose = 1;
                break;

#if 0
            case 'm':
            case 'M':
                fReadMetadata = TRUE;
                break;

            case 'f':
            case 'F':
                i++;

                if ( cField < cMaxFields )
                    aiField[cField++] = strtol( argv[i], 0, 10 );
                break;
#endif // 0

            default:
                fprintf(stderr, "Usage: file ...\n");
                exit(2);
            }
            continue;
        }
        else
        {
            pszFile = argv[i];

            cFail += VMapDump(pszFile);
        }
    }

    return cFail != 0;
}


int VMapDump( char * pszPath )
{
    HANDLE h = CreateFileA( pszPath,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            0,
                            OPEN_EXISTING,
                            0,
                            0 );

    if ( INVALID_HANDLE_VALUE == h )
    {
        printf( "Can't open file %s. Error %u\n", pszPath, GetLastError() );
        return 1;
    }

    printf( "fileaddr  rec\tparent\ttype\n"
                       "\t\tvirtual scope\n"
                       "\t\tphysical scope\n" );

    ULONG cbRead;
    CVMapDesc VMapDesc;


    for ( unsigned i = 0; ; i++ )
    {
        if ( ! ReadFile( h, &VMapDesc, sizeof VMapDesc, &cbRead, 0 ) )
        {
            fprintf(stderr, "Error %d reading %s\n", GetLastError(), pszPath );
            CloseHandle( h );
            return 1;
        }

        if (cbRead == 0)
            break;

        if (VMapDesc.IsFree())
            continue;

        printf("%08x  %d.\t%d\t%03x",
               i*sizeof VMapDesc, i, 
               VMapDesc.Parent(), VMapDesc.RootType() );

        if (VMapDesc.IsManual())
            printf(" ManualRoot");
        if (VMapDesc.IsAutomatic())
            printf(" AutomaticRoot");
        if (VMapDesc.IsInUse())
            printf(" UsedRoot");
        if (VMapDesc.IsNNTP())
            printf(" NNTPRoot");
        if (VMapDesc.IsNonIndexedVDir())
            printf(" NonIndexedVDir");
        if (VMapDesc.IsIMAP())
            printf(" IMAPRoot");

        printf("\n");

        unsigned cchVirtual = VMapDesc.VirtualLength();
        unsigned cchPhysical = VMapDesc.PhysicalLength();

        if (cchVirtual > MAX_PATH)
        {
            fprintf(stderr, "Error - Virtual path len too long, %d\n", cchVirtual );
            cchVirtual = MAX_PATH;
        }
        if (cchPhysical > MAX_PATH)
        {
            fprintf(stderr, "Error - Physical path len too long, %d\n", cchPhysical );
            cchPhysical = MAX_PATH;
        }

        printf("\t\t%*.64ws\n\t\t%*.64ws\n",
               cchVirtual, VMapDesc.VirtualPath(),
               cchPhysical, VMapDesc.PhysicalPath() );
    }
    CloseHandle( h );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\propdump\clogdump.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 2000.
//
//  File:       clogdump.cxx
//
//  Contents:   Changelog dump utility
//
//  History:    04 Mar 1998     AlanW   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <changlog.hxx>


DECLARE_INFOLEVEL(ci)

unsigned fVerbose = 0;

int ChangeLogDump( char * pszPath );

int __cdecl main( int argc, char * argv[] )
{
    char *   pszFile = argv[1];
    unsigned cFail = 0;

    for ( int i = 1; i < argc; i++ )
    {
        if ( argv[i][0] == '-' )
        {
            switch ( argv[i][1] )
            {
            case 'v':
            case 'V':
                fVerbose = 1;
                break;

#if 0
            case 'm':
            case 'M':
                fReadMetadata = TRUE;
                break;

            case 'f':
            case 'F':
                i++;

                if ( cField < cMaxFields )
                    aiField[cField++] = strtol( argv[i], 0, 10 );
                break;
#endif // 0

            default:
                fprintf(stderr, "Usage: file ...\n");
                exit(2);
            }
            continue;
        }
        else
        {
            pszFile = argv[i];

            cFail += ChangeLogDump(pszFile);
        }
    }

    return cFail != 0;
}


int ChangeLogDump( char * pszPath )
{
    HANDLE h = CreateFileA( pszPath,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            0,
                            OPEN_EXISTING,
                            0,
                            0 );

    if ( INVALID_HANDLE_VALUE == h )
    {
        printf( "Can't open file %s. Error %u\n", pszPath, GetLastError() );
        return 1;
    }

    printf( "fileaddr  rec\t\tUSN\tWorkID\tVolID\tAction\tRetries\n" );

    ULONG cbRead;
    struct ChangeRecord {
        CDocNotification aRecord[cDocInChunk];
        ULONG ulChecksum;
    } ChangeRecord;


    for ( unsigned i = 0; ; i++ )
    {
        if ( ! ReadFile( h, &ChangeRecord, sizeof ChangeRecord, &cbRead, 0 ) )
        {
            fprintf(stderr, "Error %d reading %s\n", GetLastError(), pszPath );
            CloseHandle( h );
            return 1;
        }

        if (cbRead == 0)
            break;

        for ( unsigned j = 0; j < cDocInChunk; j++ )
        {
            CDocNotification * pRecord = &ChangeRecord.aRecord[j];

            if (0 == pRecord->Wid())
                continue;

            printf("%08x  %d.\t",
                   i*sizeof ChangeRecord + j*sizeof (CDocNotification),
                   i*cDocInChunk + j );

            if ( widInvalid == pRecord->Wid() )
            {
                printf( "<unused>\n" );
                continue;
            }

            char szUSN[40];
            _i64toa( pRecord->Usn(), szUSN, 10 );
            printf("%11s\t%6d\t%5d\t%5d\t%5d\n",
                   szUSN, pRecord->Wid(),
                   pRecord->VolumeId(), pRecord->Action(), pRecord->Retries() );
        }
    }
    CloseHandle( h );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\srch\brdoc.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       document.cxx
//
//  Contents:   The Document part of the browser
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#define TheSearch pSearch

const int UNICODE_PARAGRAPH_SEPARATOR=0x2029;

const GUID guidStorage = PSGUID_STORAGE;

//+-------------------------------------------------------------------------
//
//  Member:     Position::Compare, public
//
//  Synopsis:   Compare two positions
//
//--------------------------------------------------------------------------

int Position::Compare( const Position& pos ) const
{
   int diff = _para - pos.Para();
   if ( diff == 0 )
      diff = _begOff - pos.BegOff();
   return diff;
}

//+-------------------------------------------------------------------------
//
//  Member:     Hit::Hit, public
//
//  Synopsis:   Create hit from an array of positions
//
//--------------------------------------------------------------------------

Hit::Hit( const Position * aPos, unsigned cPos )
: _cPos(cPos)
{
    _aPos = new Position[cPos];

    memcpy( _aPos, aPos, sizeof(Position) * cPos );
}

Hit::~Hit()
{
    delete _aPos;
}

//+-------------------------------------------------------------------------
//
//  Member:     HitIter::GetPositionCount, public
//
//  Synopsis:   return number of positions or zero
//
//--------------------------------------------------------------------------

int HitIter::GetPositionCount() const
{
    if (_iHit < _pDoc->_cHit && _pDoc->_aHit[_iHit])
        return _pDoc->_aHit[_iHit]->Count();

    return 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     HitIter::GetPosition, public
//
//  Synopsis:   return position by value
//
//--------------------------------------------------------------------------

Position HitIter::GetPosition ( int i ) const
{
     if ( _iHit < _pDoc->_cHit && _pDoc->_aHit[_iHit] )
          return _pDoc->_aHit[_iHit]->GetPos(i);
     else
     {
          Position pos;
          return( pos );
     }
}

//+-------------------------------------------------------------------------
//
//  Member:     Document::Document, public
//
//  Synopsis:   Initialize document with filename
//
//--------------------------------------------------------------------------

Document::Document(WCHAR const* filename, LONG rank, BOOL fDelete)
: _filename(0),
  _rank (rank),
  _buffer(0),
  _bufLen(0),
  _bufEnd(0),
  _pFilter(0),
  _aParaOffset(0),
  _isInit(FALSE),
  _cHit(0),
  _aParaLine(0),
  _maxParaLen(0),
  _cPara(0),
  _chunkCount(0),
  _fDelete( fDelete )
{
    _filename = new WCHAR[ wcslen( filename ) + 1 ];
    wcscpy( _filename, filename );
}

//+-------------------------------------------------------------------------
//
//  Member:     Document::Document, public
//
//  Synopsis:   Initialize document
//
//--------------------------------------------------------------------------

Document::Document()
: _filename(0),
  _buffer(0),
  _bufLen(0),
  _bufEnd(0),
  _pFilter(0),
  _aParaOffset(0),
  _isInit(FALSE),
  _cHit(0),
  _aParaLine(0),
  _maxParaLen(0),
  _cPara(0),
  _chunkCount(0),
  _fDelete( FALSE )
{}

//+-------------------------------------------------------------------------
//
//  Member:     Document::~Document, public
//
//  Synopsis:   Free document
//
//--------------------------------------------------------------------------

Document::~Document()
{
    Free();
}

//+-------------------------------------------------------------------------
//
//  Member:     Document::Free, public
//
//  Synopsis:   Free document storage
//
//--------------------------------------------------------------------------

void Document::Free()
{
    if ( 0 != _filename )
    {
        if ( _fDelete )
            DeleteFile( _filename );

        delete [] _filename;
    }

    if (!_isInit)
        return;

    for ( unsigned i = 0; i < _cHit; i++ )
    {
        delete _aHit[i];
        _aHit[i] = 0;
    }

    // _aHit is embedded

    delete []_aParaOffset;
    _aParaOffset = 0;

    if (_aParaLine)
    {
        for (int i = 0; i < _cPara; i++)
        {
            while (_aParaLine[i].next != 0)
            {
                ParaLine* p = _aParaLine[i].next;
                _aParaLine[i].next = _aParaLine[i].next->next;
                delete p;
            }
        }
        delete _aParaLine;
    }

    delete _buffer;

    _buffer = 0;

    _bufEnd = 0;
    _cHit = 0;

    _isInit = FALSE;
} //Free

//+-------------------------------------------------------------------------
//
//  Member:     Document::Init, public
//
//  Synopsis:   Read-in file, fill array of hits
//
//--------------------------------------------------------------------------

SCODE Document::Init(ISearchQueryHits *pSearch)
{
    BOOL noHits = FALSE;

    SCODE sc = S_OK;

    TRY
    {
        AllocBuffer( _filename );
        BindToFilter( _filename );

        ULONG ulFlags;
        sc = _pFilter->Init( IFILTER_INIT_CANON_PARAGRAPHS |
                             IFILTER_INIT_CANON_HYPHENS |
                             IFILTER_INIT_APPLY_INDEX_ATTRIBUTES,
                             0, 0, &ulFlags );

        if (FAILED (sc))
            THROW (CException(sc));

        ReadFile();

        BreakParas();

        if (Paras() != 0)
        {
            BreakLines();

#if 0
            // some filters don't behave correctly if you just re-init them,
            // so release the filter and re-open it.

            _pFilter->Release();
            _pFilter = 0;
            BindToFilter();
#endif

            sc = _pFilter->Init ( IFILTER_INIT_CANON_PARAGRAPHS |
                                  IFILTER_INIT_CANON_HYPHENS |
                                  IFILTER_INIT_APPLY_INDEX_ATTRIBUTES,
                                  0, 0, &ulFlags );
            sc = TheSearch->Init( _pFilter, ulFlags );

            if (FAILED (sc))
            {
                if ( QUERY_E_ALLNOISE != sc )
                    THROW (CException(sc));
                // we can still show the file

                sc = S_OK;
                noHits = TRUE;
            }

            // SUCCESS
            _isInit = TRUE;
        }
    }
    CATCH ( CException, e )
    {
        _isInit = FALSE;
        sc = e.GetErrorCode();
    }
    END_CATCH;

    if (!noHits)
    {
        //
        // pull up all the hits
        //

        ULONG count;
        FILTERREGION* aRegion;
        SCODE sc = TheSearch->NextHitOffset ( &count, &aRegion );

        while (sc == S_OK)
        {
            XCoMem<FILTERREGION> xRegion( aRegion );

            CDynArrayInPlace<Position> aPos( count );

            for (unsigned i = 0; i < count; i++)
                aPos [i] = RegionToPos ( aRegion [i] );

            xRegion.Free();

            XPtr<Hit> xHit( new Hit( aPos.GetPointer(), count ) );

            _aHit[_cHit] = xHit.Get();
            _cHit++;
            xHit.Acquire();

            sc = TheSearch->NextHitOffset ( &count, &aRegion );
        }
    }
    else
    {
        _cHit = 0;
        _isInit = (_bufEnd - _buffer) != 0;
    }

    if ( _pFilter )
    {
        _pFilter->Release();
        _pFilter = 0;
    }

    return _isInit ? S_OK : sc;
}

Position Document::RegionToPos ( FILTERREGION& region )
{
    static int paraHint = 0;
    static int iChunkHint = 0;
    static Position posNull;

    ULONG offset = ULONG (-1);

    // translate region to offset into buffer
    if (iChunkHint >= _chunkCount || _chunk[iChunkHint].ChunkId() != region.idChunk )
    {
        iChunkHint = 0;

        while ( iChunkHint < _chunkCount && _chunk[iChunkHint].ChunkId() < region.idChunk )
        {
            iChunkHint++;
        }

        if (iChunkHint >= _chunkCount || _chunk[iChunkHint].ChunkId() != region.idChunk)
            return posNull;
    }

    Win4Assert ( iChunkHint < _chunkCount );
    Win4Assert ( _chunk[iChunkHint].ChunkId() == region.idChunk );

    offset = _chunk[iChunkHint].Offset() + region.cwcStart;

    if (paraHint >= _cPara || _aParaOffset[paraHint] > offset )
        paraHint = 0;

    Win4Assert ( _aParaOffset[paraHint] <= offset );

    for ( ; paraHint <= _cPara; paraHint++)
    {
        // _aParaOffset[_cPara] is valid!

        if (_aParaOffset[paraHint] > offset)
        {
            Win4Assert (paraHint > 0);
            paraHint--;
            return Position ( paraHint,
                              offset - _aParaOffset[paraHint],
                              region.cwcExtent );
        }
    }

    return posNull;
}

//+-------------------------------------------------------------------------
//
//  Member:     Document::AllocBuffer, public
//
//  Synopsis:   Allocate buffer for file text
//
//--------------------------------------------------------------------------

void Document::AllocBuffer ( WCHAR const * pwcPath )
{
    //
    //  We should keep allocating buffers on demand,
    //  but for this simple demo we'll just get the
    //  file size up front and do a single buffer
    //  allocation of 2.25 the size (to accommodate
    //  Unicode expansion). THIS IS JUST A DEMO!
    //

    HANDLE hFile = CreateFile ( pwcPath,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               0, // security
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               0 ); // template

    if ( INVALID_HANDLE_VALUE == hFile )
        THROW( CException() );

    _bufLen = GetFileSize(hFile, 0 );
    CloseHandle ( hFile );

    // Unicode from ASCII, twice and then some

    _bufLen = 2 * _bufLen + _bufLen / 4 + 1;

    _buffer = new WCHAR [_bufLen + 1];
    _buffer[ _bufLen ] = 0;
}

typedef HRESULT (__stdcall * PFnLoadTextFilter)( WCHAR const * pwcPath,
                                                 IFilter ** ppIFilter );

PFnLoadTextFilter g_pLoadTextFilter = 0;

SCODE MyLoadTextFilter( WCHAR const *pwc, IFilter **ppFilter )
{
    if ( 0 == g_pLoadTextFilter )
    {
        g_pLoadTextFilter = (PFnLoadTextFilter) GetProcAddress( GetModuleHandle( L"query.dll" ), "LoadTextFilter" );

        if ( 0 == g_pLoadTextFilter )
            return HRESULT_FROM_WIN32( GetLastError() );
    }

    return g_pLoadTextFilter( pwc, ppFilter );
}

//+-------------------------------------------------------------------------
//
//  Member:     Document::BindToFilter, public
//
//  Synopsis:   Bind to appropriate filter for the document
//
//--------------------------------------------------------------------------

void Document::BindToFilter( WCHAR const * pwcPath )
{
    //
    // Bind to the filter interface
    //

    SCODE sc = LoadIFilter( pwcPath, 0, (void **)&_pFilter );

    if ( FAILED(sc) )
    {
        sc = MyLoadTextFilter( pwcPath, &_pFilter );
        if ( FAILED(sc) )
            THROW( CException(sc) );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     Document::ReadFile, public
//
//  Synopsis:   Read file into buffer using the filter
//
//--------------------------------------------------------------------------

void Document::ReadFile ()
{
    SCODE sc;
    ULONG lenSoFar = 0;
    int   cChunk = 0;
    BOOL  fSeenProp = FALSE;

    STAT_CHUNK statChunk;
    sc = _pFilter->GetChunk ( &statChunk );

    // what about all these glueing flags?
    // Take them into account at some point
    // to test more complicated chunking

    while (SUCCEEDED(sc)
          || FILTER_E_LINK_UNAVAILABLE == sc
          || FILTER_E_EMBEDDING_UNAVAILABLE == sc )
    {

        if ( SUCCEEDED( sc ) && (statChunk.flags & CHUNK_TEXT) )
        {
            // read the contents only

            if ( statChunk.attribute.guidPropSet == guidStorage &&
                 statChunk.attribute.psProperty.ulKind == PRSPEC_PROPID &&
                 statChunk.attribute.psProperty.propid == PID_STG_CONTENTS )
            {
                if ( statChunk.breakType != CHUNK_NO_BREAK )
                {
                    switch( statChunk.breakType )
                    {
                        case CHUNK_EOW:
                        case CHUNK_EOS:
                            _buffer[lenSoFar++] = L' ';
                            break;
                        case CHUNK_EOP:
                        case CHUNK_EOC:
                            _buffer[lenSoFar++] = UNICODE_PARAGRAPH_SEPARATOR;
                            break;
                    }
                }

                _chunk [cChunk].SetChunkId (statChunk.idChunk);
                Win4Assert ( cChunk == 0 || statChunk.idChunk > _chunk [cChunk - 1].ChunkId () );
                _chunk [cChunk].SetOffset (lenSoFar);
                cChunk++;

                do
                {
                    ULONG lenThis = _bufLen - lenSoFar;
                    if (lenThis == 0)
                        break;

                    sc = _pFilter->GetText( &lenThis, _buffer+lenSoFar );

                    // The buffer may be filled with zeroes.  Nice filter.

                    if ( SUCCEEDED(sc) && 0 != lenThis )
                    {
                        lenThis = __min( lenThis,
                                         wcslen( _buffer + lenSoFar ) );
                        lenSoFar += lenThis;
                    }
                }
                while (SUCCEEDED(sc));
            }
        } // if SUCCEEDED( sc )

        // next chunk, please
        sc = _pFilter->GetChunk ( &statChunk );
    }

    _bufEnd = _buffer + lenSoFar;

    Win4Assert( lenSoFar <= _bufLen );

    _chunkCount = cChunk;
}


//+-------------------------------------------------------------------------
//
//  Member:     Document::BreakParas, public
//
//  Synopsis:   Break document into paragraphs separated by line feeds
//
//--------------------------------------------------------------------------

#define PARAS 25

void Document::BreakParas()
{
    int maxParas = PARAS;
    _aParaOffset = new unsigned [ maxParas ];
    WCHAR * pCur = _buffer;
    _cPara = 0;
    _maxParaLen = 0;

    do
    {
        if ( _cPara == maxParas )
        {
            // grow array
            unsigned * tmp = new unsigned [maxParas * 2];
            for ( int n = 0; n < maxParas; n++ )
                tmp[n] = _aParaOffset[n];
            delete []_aParaOffset;
            _aParaOffset = tmp;
            maxParas *= 2;
        }
        _aParaOffset [_cPara] = (UINT)(pCur - _buffer);

        pCur = EatPara(pCur);

        _cPara++;

    } while ( pCur < _bufEnd );

    // store end of buffer offset as _aParaOffset[_cPara]

    if ( _cPara == maxParas )
    {
        // grow array
        unsigned * tmp = new unsigned [maxParas + 1];
        for ( int n = 0; n < maxParas; n++ )
            tmp[n] = _aParaOffset[n];
        delete []_aParaOffset;
        _aParaOffset = tmp;
        maxParas += 1;
    }

    _aParaOffset [_cPara] = (UINT)(pCur - _buffer - 1);
}

//+-------------------------------------------------------------------------
//
//  Member:     Document::EatPara, private
//
//  Synopsis:   Skip till the line feed
//
//--------------------------------------------------------------------------

WCHAR * Document::EatPara( WCHAR * pCur )
{
    // search for newline or null
    int pos = 0;
    int c;

    while ( pCur < _bufEnd
            && (c = *pCur) != L'\n'
            && c != L'\r'
            && c != L'\0'
            && c != UNICODE_PARAGRAPH_SEPARATOR )
    {
        pos++;
        pCur++;
    }
    // eat newline and/or carriage return
    pCur++;
    if ( pCur < _bufEnd
         && *(pCur-1) == L'\r'
         && *pCur == L'\n' )
         pCur++;

    if ( pos > _maxParaLen )
        _maxParaLen = pos;
    return pCur;
}

int BreakLine ( WCHAR* buf, int cwcBuf, int cwcMax )
{
    if (cwcBuf <= cwcMax)
        return cwcBuf;
    Win4Assert (cwcMax > 0);
    // look backwards for whitespace
    int len = cwcMax;
    int c = buf[len-1];
    while (c != L' ' && c != L'\t')
    {
        len--;
        if (len < 1)
            break;
        c = buf[len-1];
    }
    if (len == 0)
    {
        // a single word larger than screen width
        // try scanning forward
        len = cwcMax;
        c = buf[len];
        while (c != L' ' && c != L'\t')
        {
            len++;
            if (len == cwcBuf)
                break;
            c = buf[len];
        }
    }
    return len;
}

const int MAX_LINE_LEN = 110;

void Document::BreakLines()
{
    _aParaLine = new ParaLine [_cPara];
    for (int i = 0; i < _cPara; i++)
    {
        int cwcLeft = _aParaOffset[i+1] - _aParaOffset[i];

        if (cwcLeft < MAX_LINE_LEN)
            _aParaLine[i].offEnd = cwcLeft;
        else
        {
            ParaLine* pParaLine = &_aParaLine[i];
            WCHAR* buf = _buffer + _aParaOffset[i];
            int cwcOffset = 0;

            for (;;)
            {
                int cwcLine = BreakLine ( buf + cwcOffset, cwcLeft, MAX_LINE_LEN );
                cwcOffset += cwcLine;
                pParaLine->offEnd = cwcOffset;
                cwcLeft -= cwcLine;
                if (cwcLeft == 0)
                    break;
                pParaLine->next = new ParaLine;
                pParaLine = pParaLine->next;
            };
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     Document::GetLine, public
//
//  Arguments:  [nPara] -- paragraph number
//              [off] -- offset within paragraph
//              [cwc] -- in/out chars to copy / copied
//              [buf] -- target buffer
//
//  Synopsis:   Copy text from paragraph to buffer
//
//--------------------------------------------------------------------------


BOOL Document::GetLine(int nPara, int off, int& cwc, WCHAR* buf)
{
    Win4Assert (_buffer != 0);
    if (nPara >= _cPara)
        return FALSE;

    const WCHAR * pText = _buffer + _aParaOffset[nPara] + off;

    // _aParaOffset [_cPara] is the offset of the end of buffer
    int cwcPara = _aParaOffset[nPara+1] - (_aParaOffset[nPara] + off);

    cwc = __min ( cwc, cwcPara );
    memcpy ( buf, pText, cwc * sizeof(WCHAR));
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     Document::GetWord, public
//
//  Synopsis:
//  Copy the string into buffer
//
//--------------------------------------------------------------------------

void Document::GetWord(int nPara, int offSrc, int cwcSrc, WCHAR* buf)
{
    Win4Assert (_buffer != 0);
    Win4Assert ( nPara < _cPara );

    WCHAR * p = _buffer + _aParaOffset[nPara];

    Win4Assert ( p + offSrc + cwcSrc <= _bufEnd );

    memcpy ( buf, p + offSrc, cwcSrc * sizeof(WCHAR));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\qryperf\qryperf.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       qryperf.CXX
//
//  Contents:   performance test program
//
//  History:    16 March 1996   dlee    Created (from fsdbdrt)
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#define STRESS

#ifdef STRESS
    #define GET_DATA_TOO
    unsigned cThreads = 8;
    const unsigned cLoopTimes = 0xffffffff;
    WCHAR *pwcCatalog = L"system";
    WCHAR *pwcMachine = L".";
    BOOL g_fStopNow = FALSE;
    const unsigned cmsSleep = 3000; // 0
    unsigned g_cmsSleep;
    BOOL g_fFetchRowsAtWill = TRUE;
#else
    const unsigned cThreads = 8;
    const unsigned cLoopTimes = 1000;
    WCHAR *pwcCatalog = L"encarta";
    WCHAR *pwcMachine = L".";
#endif

BOOL g_fSQL = FALSE;

#define DBINITCONSTANTS

#include <crt\io.h>
#include <time.h>
#include <process.h>
#include <propvar.h>
#include <olectl.h>

#include <doquery.hxx>

WCHAR g_awcCatalog[ MAX_PATH ];
WCHAR g_awcMachine[ MAX_PATH ];
BOOL g_fSequential = FALSE;

template<class T> T Rand2( T t ) { return (T) abs( (int) ( rand() % t ) ); }
template<class T> T Rand( T t ) { return (T) abs( GetTickCount() % t ); }

CCoTaskAllocator CoTaskAllocator;
void * CCoTaskAllocator::Allocate(ULONG cbSize)
{
    return CoTaskMemAlloc( cbSize );
}

void CCoTaskAllocator::Free( void *pv )
{
    CoTaskMemFree( pv );
}

BOOL isEven(unsigned n)
{
    return ( 0 == ( n & 1 ) );
}

static const GUID guidSystem = PSGUID_STORAGE;
static const GUID guidQuery = PSGUID_QUERY;
static const GUID guidRowsetProps = DBPROPSET_ROWSET;

static CDbColId psName( guidSystem, PID_STG_NAME );
static CDbColId psPath( guidSystem, PID_STG_PATH );
static CDbColId psSize( guidSystem, PID_STG_SIZE );
static CDbColId psWriteTime( guidSystem, PID_STG_WRITETIME );
static CDbColId psContents( guidSystem, PID_STG_CONTENTS );
static CDbColId psRank( guidQuery, DISPID_QUERY_RANK );

static CDbColId * aColIds[] =
{
    &psName, &psPath, &psSize, &psWriteTime, &psRank
};

static ULONG cColIds = sizeof aColIds / sizeof aColIds[0];

CDbCmdTreeNode * FormQueryTree( CDbCmdTreeNode * pRst,
                                CDbColumns & Cols,
                                CDbSortSet * pSort );

IRowsetScroll * InstantiateRowset(
    ICommand *pCommandIn,
    DWORD dwDepth,
    LPWSTR pwszScope,
    XPtr<CDbCmdTreeNode> & xTree,
    WCHAR const * pwcQuery,
    REFIID riid,
    BOOL fAsynchronous );

HACCESSOR MapColumns(
        IUnknown * pUnknown,
        ULONG cCols,
        DBBINDING * pBindings,
        const DBID * pColIds );

void ReleaseAccessor( IUnknown * pUnknown, HACCESSOR hAcc );

DWORD __stdcall RunPerfTest(void *pv);

void LogError( char const * pszFormat, ... );

void GetProcessInfo(
    WCHAR * pwcImage,
    LARGE_INTEGER & liUserTime,
    LARGE_INTEGER & liKernelTime,
    ULONG & cHandles,
    ULONGLONG & cbWorkingSet,
    ULONGLONG & cbPeakWorkingSet,
    ULONGLONG & cbPeakVirtualSize,
    ULONGLONG & cbNonPagedPoolUsage,
    ULONGLONG & cbPeakNonPagedPoolUsage );

inline _int64 mkTime( FILETIME ft )
{
    return (_int64) ft.dwLowDateTime +
           ( ( (_int64 ) ft.dwHighDateTime ) << 32 );
} //mkTime

inline _int64 mkTime( FILETIME ftK, FILETIME ftU )
{
    return mkTime( ftK ) + mkTime( ftU );
} //mkTime

inline _int64 mkTime( LARGE_INTEGER li )
{
    return (_int64) li.LowPart +
           ( ( (_int64) li.HighPart ) << 32 );
} //mkTime

inline _int64 mkTime( LARGE_INTEGER liK, LARGE_INTEGER liU )
{
    return mkTime( liK ) + mkTime( liU );
} //mkTime

void GetCiSvcTimes(
    LARGE_INTEGER & liCiSvcKernelTime,
    LARGE_INTEGER & liCiSvcUserTime )
{
    ULONG cHandles;
    ULONGLONG cbWorkingSet;
    ULONGLONG cbPeakWorkingSet;
    ULONGLONG cbPeakVirtualSize;
    ULONGLONG cbNonPagedPoolUsage;
    ULONGLONG cbPeakNonPagedPoolUsage;
    GetProcessInfo( L"cisvc.exe",
                    liCiSvcUserTime,
                    liCiSvcKernelTime,
                    cHandles,
                    cbWorkingSet,
                    cbPeakWorkingSet,
                    cbPeakVirtualSize,
                    cbNonPagedPoolUsage,
                    cbPeakNonPagedPoolUsage );
} //GetCiSvcTimes

void RunQuerySuite()
{
    HANDLE ah[ 200 ];
    DWORD dwID;

    for ( unsigned x = 0; x < cThreads; x++ )
    {
        #ifdef STRESS

            Sleep( GetCurrentThreadId() );

        #endif // STRESS

        ah[x] = CreateThread( 0,
                              65536,
                              RunPerfTest,
                              0,
                              0,
                              &dwID );
    }

    WaitForMultipleObjects( cThreads, ah, TRUE, INFINITE );

    for ( x = 0; x < cThreads; x++ )
        CloseHandle( ah[x] );
} //RunQuerySuite

void Usage()
{
    printf( "usage: qryperf [-c:catalog] [-m:machine] [-d:delay(ms)] [-q(onarch)] [-s:(0|1)] [-t:threads] -f(etch at will)\n" );

    exit(1);
} //Usage

extern "C" int __cdecl wmain( int argc, WCHAR * argv[] )
{
    HRESULT hr = CoInitialize( 0 );

    if ( FAILED( hr ) )
        exit( 1 );

    wcscpy( g_awcCatalog, pwcCatalog );
    wcscpy( g_awcMachine, pwcMachine );

    #ifdef STRESS
        g_cmsSleep = cmsSleep;
    #endif

    for ( int i = 1; i < argc; i++ )
    {
        if ( '/' == argv[i][0] || '-' == argv[i][0] )
        {
            WCHAR c = (WCHAR) tolower( argv[i][1] );

            if ( L':' != argv[i][2] && c != L'q' && c != 'f' )
                Usage();

            if ( L'c' == c )
            {
                if ( wcslen( argv[i] + 3 ) >= MAX_PATH )
                    Usage();

                wcscpy( g_awcCatalog, argv[i] + 3 );
            }
            else if ( L'm' == c )
            {
                if ( wcslen( argv[i] + 3 ) >= MAX_PATH )
                    Usage();

                wcscpy( g_awcMachine, argv[i] + 3 );
            }
    #ifdef STRESS
            else if ( L'd' == c )
                g_cmsSleep = _wtoi( argv[i] + 3 );
            else if ( 't' == c )
                cThreads = _wtoi( argv[i] + 3 );
            else if ( 'f' == c )
                g_fFetchRowsAtWill = FALSE;
    #endif
            else if ( 'q' == c )
                g_fSQL = TRUE;
            else if ( L's' == c )
                g_fSequential = _wtoi( argv[i] + 3 );
            else
                Usage();
        }
        else
            Usage();
    }

    HANDLE hproc = GetCurrentProcess();
    FILETIME ftCreate,ftExit,ftKernel,ftUser;
    GetProcessTimes( hproc, &ftCreate, &ftExit, &ftKernel, &ftUser );
    _int64 openTime = mkTime( ftKernel, ftUser );

    {
        CI_STATE state;
        state.cbStruct = sizeof state;
        CIState( g_awcCatalog, g_awcMachine, &state );
    }

    LARGE_INTEGER liCiSvcUserTime;
    LARGE_INTEGER liCiSvcKernelTime;
    GetCiSvcTimes( liCiSvcKernelTime, liCiSvcUserTime );
    _int64 ciStartTime = mkTime( liCiSvcKernelTime, liCiSvcUserTime );

    GetProcessTimes( hproc, &ftCreate, &ftExit, &ftKernel, &ftUser );
    _int64 startTime = mkTime( ftKernel, ftUser );

    RunQuerySuite();

    CIShutdown();

    GetProcessTimes( hproc, &ftCreate, &ftExit, &ftKernel, &ftUser );
    _int64 endTime = mkTime( ftKernel, ftUser );

    GetCiSvcTimes( liCiSvcKernelTime, liCiSvcUserTime );
    _int64 ciEndTime = mkTime( liCiSvcKernelTime, liCiSvcUserTime );

#ifdef STRESS
    printf( "stress test client time: %d ms cisvc time: %d ms\n",
            (DWORD) ((endTime - startTime) / 10000 ),
            (DWORD) ((ciEndTime - ciStartTime) / 10000 ) );
#else
    printf( "%s test client time: %d ms cisvc time: %d ms\n",
            g_fSequential ? "sequential" : "non-sequential",
            (DWORD) ((endTime - startTime) / 10000 ),
            (DWORD) ((ciEndTime - ciStartTime) / 10000 ) );
#endif

    CoUninitialize();

    return 0;
} //main

#ifdef GET_DATA_TOO

class CBookMark
{
public:
    CBookMark() : cbBmk (0) {}
    CBookMark( DBBOOKMARK bmkSpecial ) : cbBmk (1)
    {
        abBmk[0] = (BYTE) bmkSpecial;
    }
    BOOL IsValid() const { return 0 != cbBmk; }
    void Invalidate () { cbBmk = 0; }
    BOOL IsEqual ( CBookMark& bmk)
    {
        if (cbBmk != bmk.cbBmk)
            return FALSE;

        return memcmp ( abBmk, bmk.abBmk, cbBmk ) == 0;
    }
    void MakeFirst()
    {
        cbBmk = sizeof (BYTE);
        abBmk[0] = (BYTE) DBBMK_FIRST;
    }
    BOOL IsFirst()
    {
        return cbBmk == sizeof(BYTE) && abBmk[0] == (BYTE) DBBMK_FIRST;
    }

    DBLENGTH cbBmk;
    BYTE     abBmk[ 50 ];
};

void FetchAtWill(
    IRowset *   pRowset,
    IUnknown *  pAccessor,
    HACCESSOR   hAccessor,
    DBCOUNTITEM cHits )
{
    if ( 0 == cHits )
        return;

    XInterface<IRowsetScroll> xRS;
    SCODE sc = pRowset->QueryInterface( IID_IRowsetScroll, xRS.GetQIPointer() );

    if ( FAILED( sc ) )
    {
        LogError( "Can't QI for IID_IRowsetScroll\n" );
        return;
    }

    const DBROWCOUNT cMaxToGet = 8;
    HROW aHRows[ cMaxToGet ];
    HROW * paHRows = aHRows;

    // Fetch relative to first

    const BYTE bmkFirst = (BYTE) DBBMK_FIRST;

    for ( unsigned i = 0; i < 5 && !g_fStopNow; i++ )
    {
        DBCOUNTITEM cRows;
        DBROWCOUNT cToGet = 1 + Rand2( cMaxToGet - 1 );
        DBROWOFFSET iStart = Rand2( cHits );
        sc = xRS->GetRowsAt( 0, 0, 1, &bmkFirst, iStart, cToGet, &cRows, &paHRows );

        if ( SUCCEEDED( sc ) )
            xRS->ReleaseRows( cRows, aHRows, 0, 0, 0 );
        else
            LogError( "can't get %d rows at %d out of %d\n", cToGet, iStart, cHits );
    }

    // Fetch relative to last

    const BYTE bmkLast = (BYTE) DBBMK_LAST;

    for ( i = 0; i < 5 && !g_fStopNow; i++ )
    {
        DBCOUNTITEM cRows;
        DBROWCOUNT cToGet = 1 + Rand2( cMaxToGet - 1 );
        DBROWOFFSET iStart = Rand2( cHits );
        sc = xRS->GetRowsAt( 0, 0, 1, &bmkLast, -iStart, cToGet, &cRows, &paHRows );

        if ( SUCCEEDED( sc ) )
            xRS->ReleaseRows( cRows, aHRows, 0, 0, 0 );
        else
            LogError( "can't get %d rows at %d from last out of %d\n", cToGet, -iStart, cHits );
    }

    // Fetch relative to a random location

    static GUID guidBmk = DBBMKGUID;
    static CDbColId dbcolBookMark( guidBmk, PROPID_DBBMK_BOOKMARK );

    DBBINDING aBmkColumn[] = { 0, sizeof DBLENGTH, 0, 0, 0, 0, 0,
                               DBPART_VALUE | DBPART_LENGTH,
                               DBMEMOWNER_CLIENTOWNED,
                               DBPARAMIO_NOTPARAM,
                               50,
                               0,
                               DBTYPE_BYTES,
                               0, 0 };

    XInterface<IAccessor> xAccessor;
    sc = xRS->QueryInterface( IID_IAccessor, xAccessor.GetQIPointer() );
    if ( FAILED( sc ) )
    {
        LogError( "can't create bookmark accessor IAccessor: %#x\n", sc );
        return;
    }

    HACCESSOR hBmkAccessor;
    sc = xAccessor->CreateAccessor( DBACCESSOR_ROWDATA,
                                    1,
                                    aBmkColumn,
                                    0,
                                    &hBmkAccessor,
                                    0 );
    if ( FAILED(sc) )
    {
        LogError( "can't create accessor\n" );
        return;
    }

    HROW aBmkHRows[ 1 ];
    HROW * paBmkHRows = aBmkHRows;
    DBROWOFFSET iBmkStart = Rand2( cHits );
    DBCOUNTITEM cBmkRows;
    sc = xRS->GetRowsAt( 0, 0, 1, &bmkFirst, iBmkStart, 1, &cBmkRows, &paBmkHRows );

    if ( SUCCEEDED( sc ) )
    {
        CBookMark bmk;
        sc = xRS->GetData( aBmkHRows[0], hBmkAccessor, &bmk );

        if ( SUCCEEDED( sc ) && ( DB_S_ERRORSOCCURRED != sc ) )
        {
            for ( unsigned i = 0; i < 5 && !g_fStopNow; i++ )
            {
                DBCOUNTITEM cRows;
                DBROWCOUNT cToGet = 1 + Rand2( cMaxToGet - 1 );
                DBROWOFFSET iStart = Rand2( cHits ) - iBmkStart;

                sc = xRS->GetRowsAt( 0, 0, bmk.cbBmk, bmk.abBmk, iStart,
                                     cToGet, &cRows, &paHRows );

                if ( SUCCEEDED( sc ) )
                    xRS->ReleaseRows( cRows, aHRows, 0, 0, 0 );
                else
                    LogError( "can't getrowsat %d rows %d relative to bmk at %d, rowset has %d: %#x\n",
                              cToGet, iStart, iBmkStart, cHits, sc );
            }
        }
        else
            LogError( "can't GetData the bmk row: %#x\n", sc );

        xRS->ReleaseRows( 1, aBmkHRows, 0, 0, 0 );
    }
    else
        LogError( "can't GetRowsAt the bmk row: %#x\n", sc );

    ReleaseAccessor( pAccessor, hBmkAccessor );
} //FetchAtWill

#endif

static DBBINDING aPropTestCols[] =
{
  { 0,(sizeof ULONG_PTR)*0,0,0,0,0,0, DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM, 0, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0 },
  { 0,(sizeof ULONG_PTR)*1,0,0,0,0,0, DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM, 0, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0 },
  { 0,(sizeof ULONG_PTR)*2,0,0,0,0,0, DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM, 0, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0 },
  { 0,(sizeof ULONG_PTR)*3,0,0,0,0,0, DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM, 0, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0 },
  { 0,(sizeof ULONG_PTR)*4,0,0,0,0,0, DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM, 0, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0 },
};

void RunPerfQuery(
    CDbRestriction & CiRst,
    WCHAR const *    pwcQuery,
    unsigned         cExpectedHits,
    ICommand *       pCommand,
    BOOL             fSeq,
    BOOL             fAsynchronous )
{
    CDbColumns cols( 5 );
    BOOL fOk = cols.Add( psName, 0 );
    if ( fOk )
        cols.Add( psSize, 1 );
    if ( fOk )
        cols.Add( psWriteTime, 2 );
    if ( fOk )
        cols.Add( psPath, 3 );
    if ( fOk )
        cols.Add( psRank, 4 );

    if ( !fOk )
    {
        LogError(" can't create column specification\n" );
        return;
    }

    unsigned cRetries = 0;
    DBCOUNTITEM cRowsReturned = 0;
    IRowset * pRowset = 0;

    {
        CDbSortSet ss( 1 );

#ifdef STRESS
        int x = Rand( cColIds );
        int y = rand();
        fOk = ss.Add( *aColIds[x],
                      isEven( rand() ) ? QUERY_SORTDESCEND : QUERY_SORTASCEND,
                      0 );
#else
        fOk = ss.Add( psRank, QUERY_SORTDESCEND, 0);
#endif

        if ( !fOk )
        {
            LogError(" can't create sort specification\n" );
            return;
        }

        XPtr<CDbCmdTreeNode> xCmdTree( FormQueryTree( &CiRst,
                                                      cols,
                                                      fSeq ? 0 : &ss ) );

        if ( xCmdTree.IsNull() )
            return;

        pRowset = InstantiateRowset( pCommand,
                                     QUERY_DEEP,   // Depth
                                     L"\\",        // Scope
                                     xCmdTree,     // DBCOMMANDTREE
                                     pwcQuery,
                                     fSeq ? IID_IRowset :
                                            IID_IRowsetScroll,
                                     fAsynchronous );

        if ( 0 == pRowset )
        {
            LogError(" can't get rowset\n" );
            return;
        }

        XInterface<IRowset> xRowset( pRowset );

#ifdef GET_DATA_TOO

        // Get data

        DBID aDbCols[5];
        aDbCols[0] = psName;
        aDbCols[1] = psSize;
        aDbCols[2] = psWriteTime;
        aDbCols[3] = psPath;
        aDbCols[4] = psRank;

        IUnknown * pAccessor = pRowset;
        HACCESSOR hAccessor = MapColumns( pAccessor,
                                          5,
                                          aPropTestCols,
                                          aDbCols );
        if ( 0 == hAccessor )
            return;

#endif // GET_DATA_TOO

        DBCOUNTITEM cTotal = 0;

#ifdef STRESS
        const unsigned cFetchPasses = g_fFetchRowsAtWill ? 1000 : 5;
#else
        const unsigned cFetchPasses = 3;
#endif

        for ( unsigned i = 0; i < cFetchPasses; i++ )
        {
#ifdef STRESS
            if ( g_fStopNow )
                break;
#endif
            HROW aHRow[10];
            HROW * pgrhRows = aHRow;

            SCODE sc = pRowset->GetNextRows(0, 0, 10, &cRowsReturned, &pgrhRows);

            if ( FAILED( sc ) )
            {
                LogError( "'%ws' IRowset->GetNextRows returned 0x%x, cTotal: %d, cRowsReturned: %d\n",
                          pwcQuery, sc, cTotal, cRowsReturned );
                break;
            }

            cTotal += cRowsReturned;

#ifdef GET_DATA_TOO
            PROPVARIANT* data[5];

            for ( ULONG r = 0; r < cRowsReturned; r++ )
            {
                SCODE sc = pRowset->GetData( pgrhRows[r],
                                             hAccessor,
                                             &data );
            }
#endif // GET_DATA_TOO

            if ( 0 != cRowsReturned )
                pRowset->ReleaseRows( cRowsReturned, pgrhRows, 0, 0, 0 );

            if ( DB_S_ENDOFROWSET == sc )
                break;
        }

#ifdef GET_DATA_TOO

        if ( !fSeq && g_fFetchRowsAtWill )
            FetchAtWill( pRowset, pAccessor, hAccessor, cTotal );

        ReleaseAccessor( pAccessor, hAccessor );

        //printf( "query %ws returned %d hits\n", pwcQuery, cTotal );
#endif // GET_DATA_TOO

        if ( 0 == cTotal )
            printf( "query %ws returned no hits\n", pwcQuery );

#if 0
        if ( cTotal < __min( 30, cExpectedHits ) )
            printf( "query %ws returned %d hits, expecting %d\n",
                    pwcQuery, cTotal, cExpectedHits );
#endif
    }

} //RunPerfQuery

struct SQuery
{
    WCHAR const * pwcQuery;
    unsigned cEncartaHits;
};

static SQuery aQueries[] =
{

#ifdef STRESS

    { L"stereo", 4 },
    { L"flex", 2 },
    { L"agassi", 1 },
    { L"detroit", 108 },
    { L"miami", 60 },
    { L"edison", 25 },
    { L"bulb", 33 },
    { L"elephant", 87 },
    { L"radius", 43 },
    { L"amplifier", 17 },
    { L"drunk", 10 },
    { L"grunt", 3 },
    { L"war", 4241 },
    { L"peace", 812 },
    { L"river", 3402 },
    { L"not", 4002 },
    { L"city", 5567 },
    { L"century", 4470 },

#else

    { L"stereo", 4 },
    { L"flex", 2 },
    { L"agassi", 1 },
    { L"detroit", 108 },
    { L"miami", 60 },
    { L"edison", 25 },
    { L"web", 57 },
    { L"bulb", 33 },
    { L"microsoft", 15 },
    { L"elephant", 87 },
    { L"radius", 43 },
    { L"amplifier", 17 },
    { L"drunk", 10 },
    { L"grunt", 3 },

#endif // STRESS

};

DWORD __stdcall RunPerfTest(void *pv)
{
    static long cQueriesSoFar = 0;

//    #ifdef STRESS
//    srand( GetTickCount() + GetCurrentThreadId() );
//    #endif

    XInterface<ICommand> xCommand;

    do
    {
        ICommand * pCommand = 0;
        SCODE sc = CICreateCommand( (IUnknown **) &pCommand,
                                    0,
                                    IID_ICommand,
                                    g_awcCatalog,
                                    g_awcMachine );
        if ( FAILED( sc ) )
            LogError( "CICreateCommand failed: 0x%x\n", sc );
        else
            xCommand.Set( pCommand );
    } while ( xCommand.IsNull() );

    for ( int x = 0; x < cLoopTimes; x++ )
    {
        try
        {
            const int cQueries = sizeof aQueries / sizeof aQueries[0];

            #ifdef STRESS
                int j = Rand( cQueries );
            #else
                int j = ( x % cQueries );
            #endif // STRESS

            CDbContentRestriction CiRst( aQueries[j].pwcQuery, psContents );

            if ( !CiRst.IsValid() )
                continue;

            #ifdef STRESS
                if ( 0 != g_cmsSleep )
                    Sleep( Rand( g_cmsSleep ) );

                ICommand *pCmd = isEven( x ) ? xCommand.GetPointer() : 0;
                BOOL fSeq = ( Rand( 100 ) < 70 );
                BOOL fAsynchronous = FALSE;
                if ( !fSeq )
                    fAsynchronous = ( Rand( 100 ) < 30 );

                RunPerfQuery( CiRst,
                              aQueries[j].pwcQuery,
                              aQueries[j].cEncartaHits,
                              pCmd,
                              fSeq,
                              fAsynchronous );

                InterlockedIncrement( &cQueriesSoFar );
                if ( 0 == ( cQueriesSoFar % 10 ) )
                    printf( "%d queries on catalog '%ws', machine '%ws'\n",
                            cQueriesSoFar, g_awcCatalog, g_awcMachine );

                if ( g_fStopNow )
                    return 0;
            #else
                RunPerfQuery( CiRst,
                              aQueries[j].pwcQuery,
                              aQueries[j].cEncartaHits,
                              xCommand.GetPointer(),
                              g_fSequential,
                              FALSE );
            #endif //STRESS
        }
        catch( CException & e )
        {
            // ignore
        }
    }

    return 0;
} //RunPerfTest

//+---------------------------------------------------------------------------
//
//  Function:   FormQueryTree
//
//  Synopsis:   Forms a query tree consisting of the projection nodes,
//              sort node(s), selection node and the restriction tree.
//
//  Arguments:  [pRst]   - pointer to Restriction tree describing the query
//              [Cols]   - Columns in the resulting table
//              [pSort]  - pointer to sort set; may be null
//
//  Returns:    A pointer to the query tree. It is the responsibility of
//              the caller to later free it.
//
//  History:    06 July 1995   AlanW   Created
//
//----------------------------------------------------------------------------

CDbCmdTreeNode * FormQueryTree( CDbCmdTreeNode * pRst,
                                CDbColumns & Cols,
                                CDbSortSet * pSort )
{
    CDbCmdTreeNode *  pTree = 0;        // return value

    if ( 0 != pRst )
    {
        //
        // First create a selection node and append the restriction tree to it
        //
        CDbSelectNode * pSelect = new CDbSelectNode();
        if ( 0 == pSelect )
        {
            LogError("FormQueryTree: can't make CDbSelectNode\n" );
            return 0;
        }

        pTree = pSelect;
        if ( !pSelect->IsValid() )
        {
            delete pTree;
            LogError("FormQueryTree: select node isn't valid\n" );
            return 0;
        }

        //
        // Clone the restriction and use it.
        //
        CDbCmdTreeNode * pExpr = pRst->Clone();
        if ( 0 == pExpr )
        {
            delete pTree;
            LogError("FormQueryTree: can't clone the restriction\n" );
            return 0;
        }
#ifdef STRESS
        else
        {
            CDbContentRestriction * p = (CDbContentRestriction *) pExpr;
            if ( !p->IsValid() )
            {
                LogError( "clone failed illegally!\n" );
                DebugBreak();
            }
        }
#endif

        //
        // Now make the restriction a child of the selection node.
        //
        pSelect->AddRestriction( pExpr );
    }
    else
    {
        //
        // No restriction.  Just use table ID node as start of tree.
        //
        pTree = new CDbTableId();
        if ( 0 == pTree )
        {
            LogError("FormQueryTree: can't make CDbTableId\n" );
            return 0;
        }
    }

    //
    // Next create the projection nodes
    //
    CDbProjectNode * pProject = new CDbProjectNode();
    if ( 0 == pProject )
    {
        delete pTree;
        LogError("FormQueryTree: can't make CDbProjectNode\n" );
        return 0;
    }

    //
    // Make the selection a child of the projection node.
    //
    pProject->AddTable( pTree );
    pTree = pProject;

    //
    // Next add all the columns in the state.
    //
    unsigned int cCol = Cols.Count();
    for ( unsigned int i = 0; i < cCol; i++ )
    {
        if ( !pProject->AddProjectColumn( Cols.Get(i) ))
        {
            delete pTree;
            LogError("FormQueryTree: can't add project column\n" );
            return 0;
        }
    }

    //
    // Next add a sort node and make the project node a child of the
    // sort node
    //

    if (pSort && pSort->Count())
    {
        unsigned int cSortProp = pSort->Count();
        CDbSortNode * pSortNode = new CDbSortNode();

        if ( 0 == pSortNode )
        {
            delete pTree;
            LogError("FormQueryTree: create sort node\n" );
            return 0;
        }

        //
        // Make the project node a child of the sort node.
        //
        if ( ! pSortNode->AddTable( pTree ) )
        {
            delete pTree;
            delete pSortNode;
            LogError( "FormQueryTree: can't add table to sortnode\n" );
            return 0;
        }

        pTree = pSortNode;

        for( i = 0; i < cSortProp; i++ )
        {
            //
            // Add the sort column.
            //

            CDbSortKey const &key = pSort->Get( i );

#ifdef STRESS

            if ( 0 == &key )
            {
                LogError( "0 sort key!\n" );
                DebugBreak();
            }
#endif

            if ( !pSortNode->AddSortColumn( key ) )
            {
                delete pTree;
                LogError("FormQueryTree: can't add sort column\n");
                return 0;
            }

#ifdef STRESS
            DBCOMMANDTREE *p = (DBCOMMANDTREE *) (void *) pSortNode;
            p = p->pctFirstChild;
            p = p->pctNextSibling;
            p = p->pctFirstChild;

            if ( DBOP_sort_list_element != p->op ||
                 DBVALUEKIND_SORTINFO != p->wKind ||
                 0 == p->value.pdbsrtinfValue )
            {
                LogError( "p: %#p, bad sort element!\n", p );
                DebugBreak();
            }
#endif
        }
    }

    return pTree;
} //FormQueryTree

//+---------------------------------------------------------------------------
//
//  Class:      CAsynchNotify
//
//  Synopsis:   Class for the IDBAsynchNotify callbacks
//
//  History:    07 May 1999   dlee   Created
//
//----------------------------------------------------------------------------

class CAsynchNotify : public IDBAsynchNotify
{
public:
    CAsynchNotify() :
        _cRef( 1 ),
        _cLowResource( 0 ),
        _hEvent( 0 )
    {
        _hEvent = CreateEventW( 0, TRUE, FALSE, 0 );

        if ( 0 == _hEvent )
            LogError( "can't create notify event, %d\n", GetLastError() );
    }

    ~CAsynchNotify()
    {
        if ( 0 != _cRef )
            LogError( "CAsynchNotify refcounting is broken: %d\n", _cRef );

        if ( 0 != _hEvent )
            CloseHandle( _hEvent );
    }

    BOOL IsValid() const { return 0 != _hEvent; }

    //
    // IUnknown methods.
    //

    STDMETHOD(QueryInterface) ( REFIID riid, LPVOID *ppiuk )
    {
        *ppiuk = (void **) this; // hold our breath and jump
        AddRef();
        return S_OK;
    }

    STDMETHOD_( ULONG, AddRef ) () { return InterlockedIncrement( &_cRef ); }

    STDMETHOD_( ULONG, Release) () { return InterlockedDecrement( &_cRef ); }

    //
    // IDBAsynchNotify methods
    //

    STDMETHOD( OnLowResource ) ( DB_DWRESERVE dwReserved )
    {
        _cLowResource++;

        // If we've failed a few times due to low resource, give up
        // on the query since there may not be sufficient resources
        // to ever get an OnStop call.

        if ( _cLowResource >= 5 )
            SetEvent( _hEvent );

        return S_OK;
    }

    STDMETHOD( OnProgress ) ( HCHAPTER hChap, DBASYNCHOP ulOp,
                              DBCOUNTITEM ulProg, DBCOUNTITEM ulProgMax,
                              DBASYNCHPHASE ulStat, LPOLESTR pwszStatus )
    {
        return S_OK;
    }

    STDMETHOD( OnStop ) ( HCHAPTER hChap, ULONG ulOp,
                          HRESULT hrStat, LPOLESTR pwszStatus )
    {
        // If the query is complete (successfully or not), set the event

        if ( DBASYNCHOP_OPEN == ulOp )
            SetEvent( _hEvent );

        return S_OK;
    }

    void Wait()
    {
        WaitForSingleObject( _hEvent, INFINITE );
    }

private:
    LONG   _cRef;
    LONG   _cLowResource;
    HANDLE _hEvent;
};

//+---------------------------------------------------------------------------
//
//  Function:   WaitForQueryToComplete
//
//  Synopsis:   Waits for the query to complete.
//
//  Arguments:  [pRowset] -- the asynchronous rowset
//
//  History:    07 May 1999   dlee   Created
//
//----------------------------------------------------------------------------

SCODE WaitForQueryCompletion( IRowset * pRowset )
{
    SCODE sc = S_OK;

    if ( Rand( 100 ) < 50 )
    {
        // Register for notifications

        XInterface<IConnectionPointContainer> xCPC;
        sc = pRowset->QueryInterface( IID_IConnectionPointContainer,
                                      xCPC.GetQIPointer() );
        if (FAILED(sc))
        {
            LogError( "Can't QI for IConnectionPointContainer: %#x\n",sc );
            return sc;
        }

        XInterface<IConnectionPoint> xCP;
        sc = xCPC->FindConnectionPoint( IID_IDBAsynchNotify,
                                        xCP.GetPPointer() );
        if (FAILED(sc) && CONNECT_E_NOCONNECTION != sc )
        {
            LogError( "FindConnectionPoint failed: %#x\n",sc );
            return sc;
        }

        CAsynchNotify Notify;

        if ( !Notify.IsValid() )
            return HRESULT_FROM_WIN32( GetLastError() );

        DWORD dwAdviseID;
        sc = xCP->Advise( (IUnknown *) &Notify, &dwAdviseID );
        if (FAILED(sc))
        {
            LogError( "IConnectionPoint->Advise failed: %#x\n",sc );
            return sc;
        }

        //
        // In a real app, we'd be off doing other work rather than waiting
        // for the query to complete, but this will do.
        // MsgWaitForSingleObject is a good choice for a GUI app.  You could
        // also post a user-defined windows message when a notification is
        // received.
        //

        Notify.Wait();

        sc = xCP->Unadvise( dwAdviseID );

        if ( S_OK != sc )
        {
            LogError( "IConnectionPoint->Unadvise returned %#x\n", sc );
            return sc;
        }

        Notify.Release();
    }
    else
    {
        // Poll.  In a real app, real work would happen between checks.

        XInterface<IDBAsynchStatus> xIDBAsynch;
        sc = pRowset->QueryInterface( IID_IDBAsynchStatus,
                                      xIDBAsynch.GetQIPointer() );
        if ( FAILED( sc ) )
            return sc;
    
        do
        {
            DBCOUNTITEM Numerator, Denominator;
            DBASYNCHPHASE Phase;
            sc = xIDBAsynch->GetStatus( DB_NULL_HCHAPTER,
                                        DBASYNCHOP_OPEN,
                                        &Numerator,
                                        &Denominator,
                                        &Phase,
                                        0 );
            if ( FAILED( sc ) || ( DBASYNCHPHASE_COMPLETE == Phase ) )
                break;
    
            Sleep( 20 );  // Give the query a chance to run
        } while ( TRUE );
    }
    
    return sc;
} //WaitForQueryCompletion

//+---------------------------------------------------------------------------
//
//  Function:   InstantiateRowset
//
//  Synopsis:   Forms a query tree consisting of the projection nodes,
//              sort node(s), selection node and the restriction tree.
//
//  Arguments:  [dwDepth]   - Query depth, one of QUERY_DEEP or QUERY_SHALLOW
//              [pswzScope] - Query scope
//              [pTree]     - pointer to DBCOMMANDTREE for the query
//              [riid]      - Interface ID of the desired rowset interface
//
//  Returns:    IRowsetScroll* - a pointer to an instantiated rowset
//
//  History:    22 July 1995   AlanW   Created
//
//  Notes:      Although the returned pointer is to IRowsetScroll, the
//              returned pointer may only support IRowset, depending
//              upon the riid parameter.
//
//              Ownership of the query tree is given to the ICommandTree
//              object.  The caller does not need to delete it.
//
//              Use InstantiateMultipleRowsets for categorized queries.
//
//----------------------------------------------------------------------------

static const DBID dbcolNull = { {0,0,0,{0,0,0,0,0,0,0,0}},DBKIND_GUID_PROPID,0};
static const GUID guidQueryExt = DBPROPSET_QUERYEXT;

IRowsetScroll * InstantiateRowset(
    ICommand *             pCommandIn,
    DWORD                  dwDepth,
    LPWSTR                 pwszScope,
    XPtr<CDbCmdTreeNode> & xTree,
    WCHAR const *          pwcQuery,
    REFIID                 riid,
    BOOL                   fAsynchronous )
{
    ICommand * pCommand;
    XInterface<ICommand> xCommand;
    if ( 0 == pCommandIn )
    {
        SCODE sc = CICreateCommand( (IUnknown **) &pCommand,
                                    0,
                                    IID_ICommand,
                                    g_awcCatalog,
                                    g_awcMachine );
        if ( FAILED( sc ) )
        {
            LogError( "InstantiateRowset - error 0x%x, Unable to create icommand'\n", sc );
            return 0;
        }

        xCommand.Set( pCommand );
    }
    else
    {
        pCommand = pCommandIn;
    }

    if ( 0 == pCommand )
        return 0;

    if ( g_fSQL )
    {
        XInterface<ICommandText> xCommandText;
        SCODE sc = pCommand->QueryInterface( IID_ICommandText,
                                             xCommandText.GetQIPointer() );
        if ( FAILED( sc ) )
        {
            LogError( "InstantiateRowset error %#x, can't qi ICommandText\n", sc );
            return 0;
        }

        WCHAR awc[ 300 ];
        swprintf( awc,
                  L"SELECT %ws FROM %ws..SCOPE('\"%ws\"') WHERE CONTAINS('%ws')",
                  L"Filename, Size, Write, Path, Rank",
                  //g_awcMachine,
                  g_awcCatalog,
                  pwszScope,
                  pwcQuery );

        sc = xCommandText->SetCommandText( DBGUID_SQL, awc );
        if ( FAILED( sc ) )
        {
            LogError( "InstantiateRowset error %#x, can't set text\n", sc );
            return 0;
        }

#if 1
        XInterface<ICommandProperties> xCommandProperties;
        sc = xCommandText->QueryInterface( IID_ICommandProperties,
                                           xCommandProperties.GetQIPointer() );
        if ( FAILED (sc) )
        {
            LogError( "InstantiateRowset error %#x, can't qi commandprops\n", sc );
            return 0;
        }

        // set the machine name

        DBPROPSET PropSet;
        DBPROP    Prop;

        const GUID guidQueryCorePropset = DBPROPSET_CIFRMWRKCORE_EXT;

        PropSet.rgProperties    = &Prop;
        PropSet.cProperties     = 1;
        PropSet.guidPropertySet = guidQueryCorePropset;
        
        Prop.dwPropertyID       = DBPROP_MACHINE;
        Prop.colid              = DB_NULLID;
        Prop.vValue.vt          = VT_BSTR;
        Prop.vValue.bstrVal     = SysAllocString( g_awcMachine );

        if ( 0 == Prop.vValue.bstrVal )
        {
            LogError( "InstantiateRowset error %#x, can't allocate sql machine\n", sc );
            return 0;
        }

        sc = xCommandProperties->SetProperties ( 1, &PropSet );
        
        VariantClear( &Prop.vValue );

        if ( FAILED (sc) )
        {
            LogError( "InstantiateRowset error %#x can't set sql machine\n", sc );
            return 0;
        }
#endif

        XInterface<ICommandPrepare> xCommandPrepare;
        sc = xCommandText->QueryInterface( IID_ICommandPrepare,
                                           xCommandPrepare.GetQIPointer() );
        if ( FAILED (sc) )
        {
            LogError( "InstantiateRowset error %#x, can't qi prepare\n", sc );
            return 0;
        }

        sc = xCommandPrepare->Prepare( 1 );
        if ( FAILED (sc) )
        {
            LogError( "InstantiateRowset error %#x, can't prepare\n", sc );
            return 0;
        }
    }
    else
    {
        XInterface<ICommandTree> xCmdTree;
        HRESULT sc = pCommand->QueryInterface( IID_ICommandTree,
                                               xCmdTree.GetQIPointer() );
        if (FAILED (sc) )
        {
            LogError( "QI for ICommandTree failed %#x\n", sc );
            return 0;
        }
    
        DBCOMMANDTREE * pRoot = xTree->CastToStruct();
    
        sc = xCmdTree->SetCommandTree( &pRoot, DBCOMMANDREUSE_NONE, FALSE);
        if (FAILED (sc) )
        {
            LogError("SetCommandTree failed, %08x\n", sc);
            return 0;
        }
    
        xTree.Acquire();
    }

    #ifdef GET_DATA_TOO
    {
        const unsigned MAX_PROPS = 8;
        DBPROPSET aPropSet[MAX_PROPS];
        DBPROP aProp[MAX_PROPS];
        ULONG cProps = 0;

        // We can handle PROPVARIANTs

        aProp[cProps].dwPropertyID = DBPROP_USEEXTENDEDDBTYPES;
        aProp[cProps].dwOptions = DBPROPOPTIONS_OPTIONAL;
        aProp[cProps].dwStatus = 0;
        aProp[cProps].colid = dbcolNull;
        aProp[cProps].vValue.vt = VT_BOOL;
        aProp[cProps].vValue.boolVal = VARIANT_TRUE;

        aPropSet[cProps].rgProperties = &aProp[cProps];
        aPropSet[cProps].cProperties = 1;
        aPropSet[cProps].guidPropertySet = guidQueryExt;

        cProps++;

        XInterface<ICommandProperties> xCmdProp;
        SCODE sc = pCommand->QueryInterface( IID_ICommandProperties,
                                             xCmdProp.GetQIPointer() );
        if (FAILED (sc) )
        {
            LogError( "can't qi to commandprops\n", sc );
            return 0;
        }

        sc = xCmdProp->SetProperties( cProps, aPropSet );

        if (FAILED (sc) || DB_S_ERRORSOCCURRED == sc )
        {
            LogError( "can't set commandprops: 0x%lx\n", sc );
            return 0;
        }
    }
    #endif // GET_DATA_TOO

#ifdef STRESS
    {
        const unsigned MAX_PROPS = 1;
        DBPROPSET aPropSet[MAX_PROPS];
        DBPROP aProp[MAX_PROPS];
        ULONG cProps = 0;

        // Mark the icommand as synch or asynch.  Note that we always have
        // to set it since we may have an old ICommand that previously had
        // a different state set.

        aProp[cProps].dwPropertyID = DBPROP_IDBAsynchStatus;
        aProp[cProps].dwOptions = DBPROPOPTIONS_REQUIRED;
        aProp[cProps].dwStatus = 0;
        aProp[cProps].colid = dbcolNull;
        aProp[cProps].vValue.vt = VT_BOOL;
        aProp[cProps].vValue.boolVal = fAsynchronous ? VARIANT_TRUE : VARIANT_FALSE;

        aPropSet[cProps].rgProperties = &aProp[cProps];
        aPropSet[cProps].cProperties = 1;
        aPropSet[cProps].guidPropertySet = guidRowsetProps;

        cProps++;

        XInterface<ICommandProperties> xCmdProp;
        SCODE sc = pCommand->QueryInterface( IID_ICommandProperties,
                                             xCmdProp.GetQIPointer() );
        if (FAILED (sc) )
        {
            LogError( "can't qi to commandprops\n", sc );
            return 0;
        }

        sc = xCmdProp->SetProperties( cProps, aPropSet );

        if (FAILED (sc) || DB_S_ERRORSOCCURRED == sc )
        {
            LogError( "can't set commandprops: 0x%lx\n", sc );
            return 0;
        }
    }
#endif

    XInterface<IRowsetScroll> xRowset;
    SCODE sc = pCommand->Execute( 0,                    // no aggr. IUnknown
                                  riid,                 // IID for i/f to return
                                  0,                    // disp. params
                                  0,                    // chapter
                                  (IUnknown **) xRowset.GetPPointer() );

    if ( FAILED (sc) )
    {
        LogError("ICommand::Execute failed, %08x\n", sc);
        if ( !xRowset.IsNull() )
            LogError( "pRowset is 0x%x when it should be 0\n", xRowset.GetPointer() );
    }

    if ( SUCCEEDED( sc ) && fAsynchronous )
    {
        sc = WaitForQueryCompletion( xRowset.GetPointer() );

        if ( FAILED( sc ) )
            xRowset.Free();
    }

    return xRowset.Acquire();
} //InstantiateRowset

//+-------------------------------------------------------------------------
//
//  Function:   MapColumns, public
//
//  Synopsis:   Map column IDs in column bindings.  Create an accessor
//              for the binding array.
//
//  Arguments:  [pUnknown]  -- Interface capable of returning IColumnsInfo and
//                             IAccessor
//              [cCols]     -- number of columns in arrays
//              [pBindings] -- column data binding array
//              [pDbCols]   -- column IDs array
//
//  Returns:    HACCESSOR - a read accessor for the column bindings.
//
//  History:    18 May 1995     AlanW     Created
//
//--------------------------------------------------------------------------

static DBORDINAL aMappedColumnIDs[20];

HACCESSOR MapColumns(
    IUnknown *   pUnknown,
    ULONG        cCols,
    DBBINDING *  pBindings,
    const DBID * pDbCols )
{
    XInterface<IColumnsInfo> xColumnsInfo;
    SCODE sc = pUnknown->QueryInterface( IID_IColumnsInfo,
                                         xColumnsInfo.GetQIPointer() );
    if ( FAILED( sc ) )
    {
        LogError( "IUnknown::QueryInterface for IColumnsInfo returned 0x%lx\n", sc );
        return 0;
    }

    sc = xColumnsInfo->MapColumnIDs(cCols, pDbCols, aMappedColumnIDs);

    if (S_OK != sc)
    {
        LogError( "IColumnsInfo->MapColumnIDs returned 0x%lx\n",sc);
        return 0;
    }

    for (ULONG i = 0; i < cCols; i++)
        pBindings[i].iOrdinal = aMappedColumnIDs[i];

    XInterface<IAccessor> xAccessor;
    sc = pUnknown->QueryInterface( IID_IAccessor, xAccessor.GetQIPointer() );
    if ( FAILED( sc ) )
    {
        LogError( "IRowset::QueryInterface for IAccessor returned 0x%lx\n", sc );
        return 0;
    }

    HACCESSOR hAcc = 0;
    sc = xAccessor->CreateAccessor( DBACCESSOR_ROWDATA,
                                    cCols, pBindings, 0, &hAcc, 0 );

    if (S_OK != sc)
        LogError( "IAccessor->CreateAccessor returned 0x%lx\n",sc);

    return hAcc;
} //MapColumns

//+-------------------------------------------------------------------------
//
//  Function:   ReleaseAccessor, public
//
//  Synopsis:   Release an accessor obtained from MapColumns
//
//  Arguments:  [pUnknown]  -- Something that we can QI the IAccessor on
//              [hAcc]      -- Accessor handle to be released.
//
//  Returns:    nothing
//
//  History:    14 June 1995     AlanW     Created
//
//--------------------------------------------------------------------------

void ReleaseAccessor( IUnknown * pUnknown, HACCESSOR hAcc )
{
    XInterface<IAccessor> xAccessor;
    SCODE sc = pUnknown->QueryInterface( IID_IAccessor, xAccessor.GetQIPointer() );
    if ( FAILED( sc ) )
    {
        LogError( "IUnknown::QueryInterface for IAccessor returned 0x%lx\n", sc );
        return;
    }

    sc = xAccessor->ReleaseAccessor( hAcc, 0 );

    if (S_OK != sc)
        LogError( "IAccessor->ReleaseAccessor returned 0x%lx\n",sc);
} //ReleaseAccessor

//+-------------------------------------------------------------------------
//
//  Function:   LogError, public
//
//  Synopsis:   Prints a verbose-mode message.
//
//  Arguments:  [pszfmt] -- Format string
//
//  History:    13-Jul-93 KyleP     Created
//
//--------------------------------------------------------------------------

void LogError( char const * pszfmt, ... )
{
    va_list pargs;
    va_start(pargs, pszfmt);
    vprintf( pszfmt, pargs );
    va_end(pargs);
    _flushall();
} //LogError
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\srch\brmodel.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       model.cxx
//
//  Contents:   The Model part of the browser
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#define TheSearch _pSearch

//+-------------------------------------------------------------------------
//
//  Member:     Model::Model, public
//
//  Synopsis:
//
//--------------------------------------------------------------------------

Model::Model ()
: _pResult(0),
  _aDoc(0),
  _cForce(0),
  _fHiliteAll( FALSE ),
  _iDoc(0),
  _pSearch(0)
{}

//+-------------------------------------------------------------------------
//
//  Member:     Model::~Model, public
//
//  Synopsis:
//
//--------------------------------------------------------------------------
Model::~Model()
{
    for ( unsigned i = 0; i < _cDoc; i++ )
        delete _aDoc[i];

    delete []_aDoc;

    delete _pResult;

    if (TheSearch)
        TheSearch->Release();
}

//+-------------------------------------------------------------------------
//
//  Member:     Model::Force, public
//
//  Synopsis:   Display a subset of files
//
//--------------------------------------------------------------------------
void Model::Force ( char* pStr )
{
    while (_cForce < MAX_FORCE && isdigit(*pStr) )
    {
        _aForce[_cForce] = (unsigned)atoi ( pStr );
        _cForce++;
        while (*pStr && isdigit(*pStr) )
            pStr++;
        while (*pStr && isspace(*pStr))
            pStr++;
    }
}

typedef HRESULT (__stdcall * PFnMakeISearch)( ISearchQueryHits ** ppSearch,
                                              DBCOMMANDTREE const * pRst,
                                              WCHAR const * pwcPath );
PFnMakeISearch g_pMakeISearch = 0;
SCODE MyMakeISearch( ISearchQueryHits **ppSearch,
                     DBCOMMANDTREE const * pRst,
                     WCHAR const * pwcPath )
{
    if ( 0 == g_pMakeISearch )
    {
        #ifdef _WIN64
            char const * pcMakeISearch = "?MakeISearch@@YAJPEAPEAUISearchQueryHits@@PEAVCDbRestriction@@PEBG@Z";
        #else
            char const * pcMakeISearch = "?MakeISearch@@YGJPAPAUISearchQueryHits@@PAVCDbRestriction@@PBG@Z";
        #endif

        g_pMakeISearch = (PFnMakeISearch) GetProcAddress( GetModuleHandle( L"query.dll" ), pcMakeISearch );

        if ( 0 == g_pMakeISearch )
            return HRESULT_FROM_WIN32( GetLastError() );
    }

    return g_pMakeISearch( ppSearch,
                           pRst,
                           pwcPath );
} //MyMakeISearch

//+-------------------------------------------------------------------------
//
//  Member:     Model::CollectFiles, public
//
//  Synopsis:   Parse command line, get restriction and list of docs,
//              create array of docs, initialize the first one.
//              In response to window creation
//
//--------------------------------------------------------------------------

SCODE Model::CollectFiles ( CQueryResult *pResult )
{
    _pResult = pResult;

    _cDoc = 1;
    _aDoc = new Document * [ _cDoc ];

    unsigned countSoFar = 0;
    for ( unsigned iDoc = 0; iDoc< _cDoc; iDoc++)
    {
        if (_cForce == 0 || isForced(iDoc))
        {
            Document * newDoc = new Document( pResult->_pwcPath,
                                              1000,
                                              pResult->_fDeleteWhenDone );
            //
            //  Insert into sorted list of documents
            //
            unsigned i=0;
            while ( i < countSoFar && newDoc->Rank() <= _aDoc[i]->Rank() )
                i++;
            // _aDoc[i]->Rank() > newDoc->Rank() || i == countSoFar
            for ( unsigned j = countSoFar; j > i; j-- )
                _aDoc[j] = _aDoc[j-1];
            _aDoc[i] = newDoc;
            countSoFar++;
        }
    }
    _iDoc = 0;
    _cDoc = countSoFar;

    SCODE sc = MyMakeISearch( &TheSearch, _pResult->_pTree, pResult->_pwcPath );

    if ( !FAILED( sc ) && 0 != TheSearch )
        return InitDocument();

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     Model::isForced, public
//
//  Synopsis:   Check if idx is on a forced list
//
//--------------------------------------------------------------------------

BOOL Model::isForced(unsigned idx)
{
    for (unsigned i = 0; i < _cForce; i++)
        if (_aForce[i] == idx)
            return(TRUE);
    return(FALSE);
}

//+-------------------------------------------------------------------------
//
//  Member:     Model::InitDocument, public
//
//  Synopsis:   Initialize current document
//
//--------------------------------------------------------------------------

SCODE Model::InitDocument()
{
    if ( 0 == _cDoc )
        return E_FAIL;

    SCODE sc = S_OK;

    if ( !_aDoc[_iDoc]->IsInit() )
        sc = _aDoc[_iDoc]->Init( TheSearch );

    if ( SUCCEEDED( sc ) )
        _hitIter.Init ( _aDoc[_iDoc] );

    if ( 0 != TheSearch )
    {
        TheSearch->Release();
        TheSearch = 0;
    }

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\qryperf\procinfo.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999.
//
//  File:       procinfo.cxx
//
//  Contents:   performance test program
//
//  History:    16 March 1996   dlee    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

extern "C"
{
    #include <nt.h>
    #include <ntioapi.h>
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <ntexapi.h>
}

#include <windows.h>

#include <stdio.h>

void GetProcessInfo(
    WCHAR * pwcImage,
    LARGE_INTEGER & liUserTime,
    LARGE_INTEGER & liKernelTime,
    ULONG & cHandles,
    ULONGLONG & cbWorkingSet,
    ULONGLONG & cbPeakWorkingSet,
    ULONGLONG & cbPeakVirtualSize,
    ULONGLONG & cbNonPagedPoolUsage,
    ULONGLONG & cbPeakNonPagedPoolUsage )
{
    BYTE ab[81920];

    NTSTATUS status = NtQuerySystemInformation( SystemProcessInformation,
                                                ab,
                                                sizeof ab,
                                                NULL );

    if ( NT_SUCCESS( status ) )
    {
        DWORD dwProcId = GetCurrentProcessId();

        DWORD cbOffset = 0;
        PSYSTEM_PROCESS_INFORMATION pCurrent = 0;
        do
        {
            pCurrent = (PSYSTEM_PROCESS_INFORMATION)&(ab[cbOffset]);

            //printf(" image: '%ws'\n", pCurrent->ImageName.Buffer );

            if ( ( 0 == pwcImage && pCurrent->UniqueProcessId == LongToHandle( dwProcId ) ) ||
                 ( 0 != pwcImage && 0 != pCurrent->ImageName.Buffer && !_wcsicmp( pwcImage, pCurrent->ImageName.Buffer ) ) )
            {
                liUserTime = pCurrent->UserTime;
                liKernelTime = pCurrent->KernelTime;
                cHandles = pCurrent->HandleCount;
                cbWorkingSet = pCurrent->WorkingSetSize;
                cbPeakWorkingSet = pCurrent->PeakWorkingSetSize;
                cbPeakVirtualSize = pCurrent->PeakVirtualSize;
                cbNonPagedPoolUsage = pCurrent->QuotaNonPagedPoolUsage;
                cbPeakNonPagedPoolUsage = pCurrent->QuotaPeakNonPagedPoolUsage;

                return;
            }
  
            cbOffset += pCurrent->NextEntryOffset;
        } while (pCurrent->NextEntryOffset);
    }
}

#if 0
void PrintProcessInfo()
{
    ULONG cHandles;
    ULONG cbWorkingSet;
    ULONG cbPeakWorkingSet;
    ULONG cbPeakVirtualSize;
    ULONG cbNonPagedPoolUsage;
    ULONG cbPeakNonPagedPoolUsage;

    GetProcessInfo( cHandles,
                    cbWorkingSet,
                    cbPeakWorkingSet,
                    cbPeakVirtualSize,
                    cbNonPagedPoolUsage,
                    cbPeakNonPagedPoolUsage );

    printf( "info:\n  cbWorkingSet %d\n"
            "  cbPeakWorkingSet %d\n"
            "  cbPeakVirtualSize %d\n"
            "  cbNonPagedPoolUsage %d\n"
            "  cbPeakNonPagedPoolUsage %d\n"
            "  cHandles: %d\n",
        cbWorkingSet,
        cbPeakWorkingSet,
        cbPeakVirtualSize,
        cbNonPagedPoolUsage,
        cbPeakNonPagedPoolUsage,
        cHandles );
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\srch\brctrl.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999.
//
//  File:       brctrl.cxx
//
//  Contents:   
//
//  History:    15 Aug 1996     DLee    Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#define TheView (*_pView)
#define TheModel (*_pModel)

// Member functions responding to messages

LRESULT WINAPI BrowseWndProc(
    HWND   hwnd,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam)
{
    LRESULT lr = 0;
    CBrowseWindow *pbw = (CBrowseWindow *) GetWindowLongPtr( hwnd, 0 );

    switch (msg)
    {
        case WM_CREATE:
        {
            App.BrowseLastError() = S_OK;
            CREATESTRUCT *pcs = (CREATESTRUCT *) lParam;
            MDICREATESTRUCT *pmcs = (MDICREATESTRUCT *) pcs->lpCreateParams;
            CQueryResult *pResults = (CQueryResult *) pmcs->lParam;
            pbw = new CBrowseWindow();
            SetWindowLongPtr( hwnd, 0, (LONG_PTR) pbw);
            lr = pbw->TheBrowseController.Create( pResults,
                                                  hwnd,
                                                  &pbw->TheBrowseModel,
                                                  &pbw->TheBrowseView,
                                                  App.BrowseFont() );
            break;
        }
        case WM_MDIACTIVATE :
            pbw->TheBrowseController.Activate( hwnd, lParam );
            break;
        case WM_SIZE:
            lr = DefMDIChildProc( hwnd, msg, wParam, lParam );
            pbw->TheBrowseController.Size( hwnd, lParam );
            break;
        case WM_VSCROLL:
            pbw->TheBrowseController.VScroll(hwnd, wParam, lParam);
            break;
        case WM_HSCROLL:
            pbw->TheBrowseController.HScroll(hwnd, wParam, lParam);
            break;
        case WM_KEYDOWN:
            pbw->TheBrowseController.KeyDown (hwnd, wParam );
            lr = DefMDIChildProc(hwnd,msg,wParam,lParam);
            break;
        case WM_CHAR:
            pbw->TheBrowseController.Char (hwnd, wParam);
            lr = DefMDIChildProc(hwnd,msg,wParam,lParam);
            break;
        case WM_PAINT:
            pbw->TheBrowseController.Paint(hwnd);
            break;
        case wmMenuCommand:
            pbw->TheBrowseController.Command(hwnd, wParam);
            break;
        case wmInitMenu:
            pbw->TheBrowseController.EnableMenus();
            break;
        case WM_DESTROY:
            SetWindowLongPtr(hwnd,0,0);
            delete pbw;
            SetProcessWorkingSetSize( GetCurrentProcess(), -1, -1 );
            break;
        case wmNewFont:
            pbw->TheBrowseController.NewFont(hwnd, wParam);
            break;
        case WM_LBUTTONUP:
            pbw->TheBrowseView.ButtonUp( wParam, lParam );
            break;
        case WM_LBUTTONDOWN:
            pbw->TheBrowseView.ButtonDown( wParam, lParam );
            break;
        case WM_LBUTTONDBLCLK:
            pbw->TheBrowseView.DblClk( wParam, lParam );
            break;
        case WM_MOUSEMOVE :
            pbw->TheBrowseView.MouseMove( wParam, lParam );
            break;
        case WM_MOUSEWHEEL :
            lr = pbw->TheBrowseController.MouseWheel( hwnd, wParam, lParam );
            break;
        case WM_CONTEXTMENU :
            pbw->TheBrowseController.ContextMenu( hwnd, wParam, lParam );
            break;
        case EM_GETSEL:
        {
            if ( pbw->TheBrowseView.GetSelection().SelectionExists() )
                lr = MAKELRESULT( 1, 2 );
            else
                lr = 0;
            break;
        }
        default:
            lr = DefMDIChildProc(hwnd,msg,wParam,lParam);
            break;
    }

    return lr;
} //BrowseWndProc

void Control::ContextMenu(
    HWND   hwnd,
    WPARAM wParam,
    LPARAM lParam )
{
    POINT pt;
    pt.x = LOWORD( lParam );
    pt.y = HIWORD( lParam );

    GetCursorPos( &pt );

    HMENU hMenu = LoadMenu( App.Instance(), L"BrowseContextMenu" );

    if ( 0 != hMenu )
    {
        HMENU hTrackMenu = GetSubMenu( hMenu, 0 );
        if ( 0 != hTrackMenu )
        {
            if ( !TheView.GetSelection().SelectionExists() )
                EnableMenuItem( hTrackMenu,
                                IDM_EDITCOPY,
                                MF_BYCOMMAND | MF_GRAYED );

            // yes, the function returns a BOOL that you switch on

            BOOL b = TrackPopupMenuEx( hTrackMenu,
                                       TPM_LEFTALIGN | TPM_RIGHTBUTTON |
                                           TPM_RETURNCMD,
                                       pt.x,
                                       pt.y,
                                       hwnd,
                                       0 );
            switch ( b )
            {
                case IDM_BROWSE_OPEN :
                {
                    ViewFile( TheModel.Filename(),
                              fileOpen );
                    break;
                }
                case IDM_BROWSE_EDIT :
                {
                    POINT winpt;
                    winpt.x = 0;
                    winpt.y = 0;
                    ClientToScreen( hwnd, &winpt );
                    ViewFile( TheModel.Filename(),
                              fileEdit,
                              TheView.ParaFromY( pt.y - winpt.y ) );
                    break;
                }
                case IDM_EDITCOPY :
                {
                    Command( hwnd, b );
                    break;
                }
            }
        }

        DestroyMenu( hMenu );
    }
} //ContextMenu

LRESULT Control::Create(
    CQueryResult * pResults,
    HWND           hwnd,
    Model *        pModel,
    View *         pView,
    HFONT          hFont )
{
    LRESULT lr = 0;

    _iWheelRemainder = 0;
    _pModel = pModel;
    _pView = pView;
    SCODE sc = TheModel.CollectFiles( pResults );

    if ( SUCCEEDED( sc ) )
    {
        TheView.Init( hwnd, _pModel, hFont );

        // Go to first query hit (if any)

        Position pos;

        if ( TheModel.GetPositionCount() != 0 )
            pos = TheModel.GetPosition(0);

        TheView.SetRange ( TheModel.MaxParaLen(), TheModel.Paras());

        RECT rc;
        GetClientRect(hwnd,&rc);

        TheView.Size( rc.right, rc.bottom );

        TheView.SetScroll (pos);

        EnableMenus();
   }
   else
   {
       // no better way to get the error back

       App.BrowseLastError() = sc;
       lr = -1; // don't continue creating the window
   }

   return lr;
} //Create

void Control::Activate( HWND hwnd, LPARAM lParam )
{
    if ( hwnd == (HWND) lParam )
    {
        int apos[3] = { 0, 0, 0 };
        int cPos = 2;

        HDC hdc = GetDC( hwnd );

        if ( 0 == hdc )
            return;

        SIZE size;

        WCHAR awcLines[100];
        CResString strLines( IDS_BRSTAT_CLINES );
        wsprintf( awcLines, strLines.Get(), TheModel.ParaCount() );
        GetTextExtentPoint( hdc, awcLines, wcslen( awcLines ), &size );
        apos[0] = 2 * size.cx;

        WCHAR awcHits[100];
        CResString strHits( IDS_BRSTAT_CHITS );
        wsprintf( awcHits, strHits.Get(), TheModel.HitCount(), TheModel.HitCount() );
        GetTextExtentPoint( hdc, awcHits, wcslen( awcHits ), &size );
        apos[1] = 2 * size.cx + apos[0];

        ReleaseDC( hwnd, hdc );

        SendMessage( App.StatusBarWindow(), SB_SETPARTS, cPos, (LPARAM) apos );

        SendMessage( App.StatusBarWindow(), SB_SETTEXT, 0, (LPARAM) awcLines );

        static UINT aDisable[] = { IDM_SEARCH,
                                   IDM_SEARCHCLASSDEF,
                                   IDM_SEARCHFUNCDEF,
                                   IDM_BROWSE,
                                   IDM_DISPLAY_PROPS };
        UpdateButtons( aDisable, 5, FALSE );

        EnableMenus();
    }
} //Activate

void Control::NewFont ( HWND hwnd, WPARAM wParam)
{
    TheView.FontChange ( hwnd, (HFONT) wParam );
    InvalidateRect(hwnd, NULL, TRUE);
} //NewFont

void Control::SetScrollBars ( HWND hwnd )
{
    SetScrollPos ( hwnd, SB_VERT, TheView.VScrollPara(), TRUE );
    SetScrollPos ( hwnd, SB_HORZ, TheView.HScrollPos(), TRUE );
} //SetScrollBars

// Go to next query hit when 'n' pressed

void Control::Char ( HWND hwnd, WPARAM wparam )
{
    Position pos;
    HCURSOR hCursor;
    BOOL success;

    switch ( wparam )
    {
        case 'n':
        {
            if ( !TheModel.NextHit() )
                break;

            pos = TheModel.GetPosition(0);
            TheView.SetScroll( pos );
            SetScrollBars (hwnd);

            EnableMenus();
            InvalidateRect(hwnd, NULL, TRUE);
            break;
        }
        case 'p':
        {
            if ( !TheModel.PrevHit() )
                break;

            pos = TheModel.GetPosition(0);
            TheView.SetScroll( pos );
            SetScrollBars(hwnd);

            EnableMenus();
            InvalidateRect(hwnd, NULL, TRUE);
            break;
        }
        case 'N':
        {
            hCursor = SetCursor (LoadCursor(0, IDC_WAIT));
            ShowCursor (TRUE);
            success = S_OK == TheModel.NextDoc();
            ShowCursor(FALSE);
            SetCursor (hCursor);

            if ( success )
            {
                if ( TheModel.GetPositionCount() != 0 )
                {
                    pos = TheModel.GetPosition(0);
                }
                TheView.SetRange ( TheModel.MaxParaLen(), TheModel.Paras());
                TheView.SetScrollMax();
                TheView.SetScroll (pos);
                UpdateScroll(hwnd);

                InvalidateRect(hwnd, NULL, TRUE);
                EnableMenus();
                SetWindowText( hwnd, TheModel.Filename() );
            }
            break;
        }
        case 'P':
        {
            hCursor = SetCursor (LoadCursor(0, IDC_WAIT));
            ShowCursor (TRUE);
            success = TheModel.PrevDoc();
            ShowCursor(FALSE);
            SetCursor (hCursor);
            if ( success )
            {
                if ( TheModel.GetPositionCount() != 0 )
                    pos = TheModel.GetPosition(0);

                TheView.SetRange ( TheModel.MaxParaLen(), TheModel.Paras());
                TheView.SetScrollMax();
                TheView.SetScroll (pos);
                UpdateScroll(hwnd);
                InvalidateRect(hwnd, NULL, TRUE);
                EnableMenus();
                SetWindowText( hwnd, TheModel.Filename() );
            }
            break;
        }
    }
} //Char

void Control::EnableMenus()
{
    UINT ui = IDM_NEXT_HIT;
    UpdateButtons( &ui, 1, ! TheModel.isLastHit() );
    ui = IDM_PREVIOUS_HIT;
    UpdateButtons( &ui, 1, ! TheModel.isFirstHit() );

    HMENU hmenu = GetMenu( App.AppWindow() );

    EnableMenuItem(hmenu,IDM_NEXT_HIT,MF_BYCOMMAND |
                   (TheModel.isLastHit() ? MF_GRAYED | MF_DISABLED  :
                                           MF_ENABLED) );

    EnableMenuItem(hmenu,IDM_PREVIOUS_HIT,MF_BYCOMMAND |
                   (TheModel.isFirstHit() ? MF_GRAYED | MF_DISABLED  :
                                            MF_ENABLED) );

    EnableMenuItem( hmenu, IDM_NEWSEARCH, MF_ENABLED );

    int cHits = TheModel.HitCount();

    WCHAR awcHits[100];
    if ( 0 == cHits )
    {
        awcHits[0] = 0;
    }
    else
    {
        CResString strHits( IDS_BRSTAT_CHITS );
        wsprintf( awcHits,
                  strHits.Get(),
                  TheModel.CurrentHit() + 1,
                  cHits );
    }
    SendMessage( App.StatusBarWindow(), SB_SETTEXT, 1, (LPARAM) awcHits );
} //EnableMenus

void Control::Size ( HWND hwnd, LPARAM lParam )
{
    TheView.Size ( LOWORD(lParam), HIWORD(lParam) );
    TheView.SetScrollMax();
    UpdateScroll( hwnd );
    // in case we have to scroll to close up the gap
    // at the bottom of the window
    int delta = TheView.IncVScrollPos( 0 );
    if (delta != 0)
    {
        MyScrollWindow (hwnd, 0, -delta * TheView.LineHeight(), 0, 0 );
        SetScrollPos (hwnd, SB_VERT, TheView.VScrollPara(), TRUE );
        UpdateWindow(hwnd);
    }
} //Size

void Control::UpdateScroll( HWND hwnd)
{
    TheView.SetRange ( TheModel.MaxParaLen(), TheModel.Paras());

    SetScrollRange(hwnd, SB_VERT, 0, TheView.VScrollMax(), FALSE );
    SetScrollRange(hwnd, SB_HORZ, 0, TheView.HScrollMax(), FALSE );

    SetScrollBars (hwnd);

    // proportional scroll box
    SCROLLINFO si;
    si.cbSize = sizeof(si);
    si.fMask = SIF_PAGE;
    si.nPage = TheView.VisibleLines();
    SetScrollInfo( hwnd, SB_VERT, &si, TRUE );
} //UpdateScroll

LRESULT Control::MouseWheel( HWND hwnd, WPARAM wParam, LPARAM lParam )
{
    // forward what we don't process

    if ( wParam & ( MK_SHIFT | MK_CONTROL ) )
        return DefMDIChildProc( hwnd, WM_MOUSEWHEEL, wParam, lParam );

    // add the current scroll to the remainder from last time

    int iDelta = (int) (short) HIWORD( wParam );
    iDelta += _iWheelRemainder;

    // if there isn't enough to process this time, just return

    if ( abs( iDelta ) < WHEEL_DELTA )
    {
        _iWheelRemainder = iDelta;
        return 0;
    }

    // compute the remainder and amount to scroll

    _iWheelRemainder = ( iDelta % WHEEL_DELTA );
    iDelta /= WHEEL_DELTA;

    BOOL fDown;
    if ( iDelta < 0 )
    {
        fDown = TRUE;
        iDelta = -iDelta;
    }
    else
        fDown = FALSE;

    // get the # of lines to scroll per WHEEL_DELTA

    int cLines;
    SystemParametersInfo( SPI_GETWHEELSCROLLLINES, 0, &cLines, 0 );
    if ( 0 == cLines )
        return 0;

    int cVisibleLines = TheView.VisibleLines();

    // if scrolling a page, do so.  don't scroll more than one page

    if ( WHEEL_PAGESCROLL == cLines )
        iDelta = __max( 1, (cVisibleLines - 1) );
    else
    {
        iDelta *= cLines;
        if ( iDelta >= cVisibleLines )
            iDelta = __max( 1, (cVisibleLines - 1) );
    }

    // phew.  do the scroll

    if ( 0 != iDelta )
    {
        int delta = TheView.IncVScrollPos( fDown ? iDelta : -iDelta );
        MyScrollWindow( hwnd, 0, -delta * TheView.LineHeight(), 0, 0, FALSE );
        SetScrollPos( hwnd, SB_VERT, TheView.VScrollPara(), TRUE );
        UpdateWindow( hwnd );
    }

    return iDelta;
} //MouseWheel

void Control::VScroll( HWND hwnd, WPARAM wParam, LPARAM lParam )
{
    int nVScrollInc;
    int delta = 0;

    switch (LOWORD(wParam))
    {
        case SB_TOP:
            TheView.Home();
            InvalidateRect (hwnd, 0, TRUE);
            delta = 1;
            break;
        case SB_BOTTOM:
            TheView.End();
            InvalidateRect (hwnd, 0, TRUE);
            delta = 1;
            break;

        case SB_LINEUP:
            delta = TheView.IncVScrollPos( -1 );
            MyScrollWindow (hwnd, 0, -delta * TheView.LineHeight(), 0, 0, FALSE );
            break;
        case SB_LINEDOWN:
            nVScrollInc = 1;
            delta = TheView.IncVScrollPos( 1 );
            MyScrollWindow (hwnd, 0, -delta * TheView.LineHeight(), 0, 0, FALSE );
            break;

        case SB_PAGEUP:
            nVScrollInc = - max ( 1, TheView.VisibleLines() - 1);
            delta = TheView.IncVScrollPos( nVScrollInc );
            MyScrollWindow (hwnd, 0, -delta * TheView.LineHeight(), 0, 0, FALSE );
            break;
        case SB_PAGEDOWN:
            nVScrollInc = max ( 1, TheView.VisibleLines() - 1);
            delta = TheView.IncVScrollPos( nVScrollInc );
            MyScrollWindow (hwnd, 0, -delta * TheView.LineHeight(), 0, 0, FALSE );
            break;

        case SB_THUMBTRACK:
            delta = TheView.JumpToPara ( HIWORD(wParam) );
            MyScrollWindow (hwnd, 0, -delta * TheView.LineHeight(), 0, 0, FALSE );
            break;
        default:
            break;
    }

    if ( delta != 0 )
    {
        SetScrollPos (hwnd, SB_VERT, TheView.VScrollPara(), TRUE );
        UpdateWindow(hwnd);
    }
} //VScroll

void Control::HScroll( HWND hwnd, WPARAM wParam, LPARAM lParam )
{
}

void Control::KeyDown ( HWND hwnd, WPARAM wparam )
{
    switch(wparam)
    {
        case VK_HOME:
            SendMessage( hwnd, WM_VSCROLL, SB_TOP, 0L );
            break;
        case VK_END:
            SendMessage( hwnd, WM_VSCROLL, SB_BOTTOM, 0L );
            break;
        case VK_PRIOR:
            SendMessage( hwnd, WM_VSCROLL, SB_PAGEUP, 0L );
            break;
        case VK_NEXT:
            SendMessage( hwnd, WM_VSCROLL, SB_PAGEDOWN, 0L );
            break;
        case VK_UP:
            SendMessage( hwnd, WM_VSCROLL, SB_LINEUP, 0L );
            break;
        case VK_DOWN:
            SendMessage( hwnd, WM_VSCROLL, SB_LINEDOWN, 0L );
            break;
        case VK_LEFT:
            SendMessage( hwnd, WM_HSCROLL, SB_PAGEUP, 0L );
            break;
        case VK_RIGHT:
            SendMessage( hwnd, WM_HSCROLL, SB_PAGEDOWN, 0L );
            break;
    }
} //KeyDown

// Menu commands processing

void Control::Command ( HWND hwnd, WPARAM wParam )
{
    switch ( wParam )
    {
        case IDM_NEXT_HIT:
            SendMessage ( hwnd, WM_CHAR, 'n', 0L );
            break;
        case IDM_PREVIOUS_HIT:
            SendMessage ( hwnd, WM_CHAR, 'p', 0L );
            break;
        case IDM_NEWSEARCH:
            // close the browser window
            PostMessage( hwnd, WM_CLOSE, 0, 0 );
            break;
        case IDM_EDITCOPY :
            TheView.EditCopy( hwnd, wParam );
    }
} //Command
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\srch\lview.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999.
//
//  File:       lview.cxx
//
//  Contents:   
//
//  History:    15 Aug 1996     DLee    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

//
// Window procedure for ListView
//

LRESULT WINAPI ListViewWndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    CListView *pControl = (CListView *) GetWindowLongPtr(hwnd, 0);
    LRESULT lRet = 0;

    switch (msg)
    {
        case WM_CREATE :
            pControl = new CListView;
            pControl->Create (GetParent(hwnd), hwnd);
            SetWindowLongPtr (hwnd, 0, (LONG_PTR) pControl);
            break;
        case WM_DESTROY :
            delete pControl;
            lRet = DefWindowProc(hwnd, msg, wParam, lParam);
            break;
        case WM_SETFONT:
            pControl->SetFont ((HFONT)wParam);
            break;
        case WM_SETFOCUS:
            pControl->SetFocus();
            lRet = DefWindowProc(hwnd, msg, wParam, lParam);
            break;
        case wmInsertItem:
            pControl->InsertItem ((int)lParam);
            break;
        case wmDeleteItem:
            pControl->DeleteItem ((int)lParam);
            break;
        case wmUpdateItem:
            pControl->InvalidateItem ((int)lParam);
            break;

        case wmSetCountBefore:
            pControl->SetCountBefore ((int)lParam);
            break;
        case wmSetCount:
            pControl->SetTotalCount ((int)lParam);
            break;
        case wmResetContents:
            pControl->ResetContents();
            break;

        case WM_SIZE:
            pControl->Size (wParam, LOWORD(lParam), HIWORD(lParam));
            break;
        case WM_PAINT:
            {
                PAINTSTRUCT paint;
                BeginPaint ( hwnd, &paint );
                pControl->Paint (paint);
                EndPaint(hwnd, &paint );
            }
            break;
        case WM_LBUTTONUP:
            pControl->ButtonUp(HIWORD(lParam));
            break;
        case WM_LBUTTONDOWN:
            pControl->ButtonDown(HIWORD(lParam));
            break;
        case WM_LBUTTONDBLCLK:
            SendMessage (pControl->Parent(),
                        WM_COMMAND,
                        MAKEWPARAM(idListChild, LBN_DBLCLK),
                        (LPARAM) hwnd);
            break;
        case WM_KEYDOWN:
            pControl->KeyDown ((int)wParam);
            break;
        case WM_VSCROLL:
            pControl->Vscroll ((int)LOWORD(wParam), (int)HIWORD(wParam));
            break;
        case WM_MOUSEWHEEL :
            lRet = pControl->MouseWheel( hwnd, wParam, lParam );
            break;
        case wmContextMenuHitTest:
            lRet = pControl->ContextMenuHitTest( wParam, lParam );
            break;
        default :
            lRet = DefWindowProc(hwnd, msg, wParam, lParam);
            break;
    }

    return lRet;
} //ListViewWndProc

CListView::CListView ()
: _hwndParent(0),
  _hwnd(0),
  _cBefore(0),
  _cTotal (0),
  _cx(0),
  _cy(0),
  _cyLine(1),
  _cLines(0),
  _hfont(0),
  _iWheelRemainder(0)
{}

LRESULT CListView::MouseWheel(
    HWND   hwnd,
    WPARAM wParam,
    LPARAM lParam )
{
    // forward what we don't process

    if ( wParam & ( MK_SHIFT | MK_CONTROL ) )
        return DefWindowProc( hwnd, WM_MOUSEWHEEL, wParam, lParam );

    // add the current scroll to the remainder from last time

    int iDelta = (int) (short) HIWORD( wParam );
    iDelta += _iWheelRemainder;

    // if there isn't enough to process this time, just return

    if ( abs( iDelta ) < WHEEL_DELTA )
    {
        _iWheelRemainder = iDelta;
        return 0;
    }

    // compute the remainder and amount to scroll

    _iWheelRemainder = ( iDelta % WHEEL_DELTA );
    iDelta /= WHEEL_DELTA;

    BOOL fDown;
    if ( iDelta < 0 )
    {
        fDown = TRUE;
        iDelta = -iDelta;
    }
    else
        fDown = FALSE;

    // get the # of lines to scroll per WHEEL_DELTA

    int cLines;
    SystemParametersInfo( SPI_GETWHEELSCROLLLINES, 0, &cLines, 0 );
    if ( 0 == cLines )
        return 0;

    int cVisibleLines = _cLines;

    // if scrolling a page, do so.  don't scroll more than one page

    if ( WHEEL_PAGESCROLL == cLines )
        iDelta = __max( 1, (cVisibleLines - 1) );
    else
    {
        iDelta *= cLines;
        if ( iDelta >= cVisibleLines )
            iDelta = __max( 1, (cVisibleLines - 1) );
    }

    // phew.  do the scroll

    if ( 0 != iDelta )
    {
        if ( fDown )
            _GoDown( iDelta );
        else
            _GoUp( iDelta );
    }

    return iDelta;
} //MouseWheel

LRESULT CListView::ContextMenuHitTest(
    WPARAM wParam,
    LPARAM lParam )
{
    POINT pt;

    // cast required to sign extend [multimon bug]
    pt.x = (LONG)(short)LOWORD( lParam );
    pt.y = (LONG)(short)HIWORD( lParam );

    RECT rc;
    GetWindowRect( _hwnd, &rc );

    // did they click in the window?

    if ( !PtInRect( &rc, pt ) )
        return -1;

    // convert y to window view coordinates

    int vy = pt.y - rc.top;

    // did they click on a line in the window?

    int line = vy / _cyLine;
    int newLine = line;
    if ( line >= _cLines || line >= _cTotal )
        return -1;

    // make this line the current selection

    ButtonDown( vy );

    return line;
} //ContextMenuHitTest

//
// Create
//

void CListView::Create (HWND hwndParent, HWND hwnd)
{
    _hwndParent = hwndParent;
    _hwnd = hwnd;
    MEASUREITEMSTRUCT measure;
    measure.CtlType = odtListView;
    //
    // Owner: Measure item!
    //
    SendMessage (_hwndParent, wmMeasureItem, 0, (LPARAM) &measure);
    _cyLine = measure.itemHeight;
} //Create

//
// Key Down
//

void CListView::KeyDown (int nKey)
{
    switch (nKey)
    {
        case ' ' :
            ButtonDown( 0 );
            break;
        case 11:
        case 13:
            // treat ENTER as a double-click
            //
            // Owner: Double click!
            //
            SendMessage (_hwndParent, WM_COMMAND, MAKEWPARAM(idListChild, LBN_DBLCLK), (LPARAM) _hwnd);
            break;
        //
        // Translate keystrokes into scrolling actions
        //
        case VK_HOME:
            SendMessage (_hwnd, WM_VSCROLL, SB_TOP, 0L);
            break;
        case VK_END:
            SendMessage (_hwnd, WM_VSCROLL, SB_BOTTOM, 0L);
            break;
        case VK_PRIOR:
            SendMessage (_hwnd, WM_VSCROLL, SB_PAGEUP, 0L);
            break;
        case VK_NEXT:
            SendMessage (_hwnd, WM_VSCROLL, SB_PAGEDOWN, 0L);
            break;
        case VK_UP:
            SelectUp ();
            break;
        case VK_DOWN:
            SelectDown ();
            break;
    }
} //KeyDown

void CListView::UpdateHighlight(
    int oldLine,
    int newLine )
{
    // unhighlight
    if ( -1 != oldLine )
        RefreshRow( oldLine );

     // highlight
    if ( oldLine != newLine )
        RefreshRow( newLine );

    UpdateWindow (_hwnd);
} //UpdateHighlight

void CListView::SelectUp ()
{
    int newLine;

    if ( SendMessage( _hwndParent, wmListNotify, listSelectUp, (LPARAM)&newLine ))
        UpdateHighlight( newLine + 1, newLine );
} //SelectUp

void CListView::SelectDown ()
{
    int newLine;

    if ( SendMessage( _hwndParent, wmListNotify, listSelectDown, (LPARAM)&newLine ))
        UpdateHighlight( newLine - 1, newLine );
} //SelectDown

//
// Button up (select)
//

void CListView::ButtonUp (int y)
{
}

void CListView::ButtonDown (int y)
{
    int line = y / _cyLine;
    int newLine = line;
    if (line >= _cLines)
        return;
    //
    // Owner: Selection made!
    //
    if (SendMessage (_hwndParent, wmListNotify, listSelect, (LPARAM)&line ))
        UpdateHighlight( line, newLine );

    ::SetFocus (_hwnd);
} //ButtonDown

void CListView::SetFocus()
{
    //
    // Owner: Focus!
    //
    SendMessage (_hwndParent, WM_COMMAND, MAKEWPARAM(idListChild, LBN_SETFOCUS), (LPARAM) _hwnd);
} //SetFocus

//
// Size
//

void CListView::Size (WPARAM flags, int cx, int cy)
{
    int cxOld = _cx;
    int cyOld = _cy;
    _cx = cx;
    _cy = cy;

    BOOL fInvalidate = FALSE;

    if (cy != cyOld)
    {
        _cLines = cy / _cyLine;
        //
        // Owner: Size!
        //
        long cRows = _cLines;
        fInvalidate = (BOOL)SendMessage(_hwndParent, wmListNotify, listSize, (LPARAM) &cRows);
    }

    // Don't repaint the common area

    RECT rect;
    rect.top = 0;
    rect.left = 0;
    rect.bottom = min (cy, cyOld);
    rect.right = min (cx, cxOld);

    // no need -- user does this for free, and it causes repaint bugs
    // ValidateRect (_hwnd, &rect );

    if (cy != cyOld)
    {
        if ( fInvalidate )
            InvalidateAndUpdateScroll();
        else
            UpdateScroll();
    }
} //Size

//
// Paint
//

void CListView::Paint (PAINTSTRUCT& paint)
{
    RECT& rect = paint.rcPaint;
    int lineStart = rect.top / _cyLine;
    int lineEnd = (rect.bottom + _cyLine - 1) / _cyLine;
    DRAWITEMSTRUCT draw;
    draw.hwndItem = _hwnd;
    draw.itemAction = ODA_DRAWENTIRE;
    HDC hdc = paint.hdc;
    draw.hDC = hdc;
    HFONT hfontOld = (HFONT) SelectObject (hdc, _hfont);

    for (int i = lineStart; i < lineEnd; i++)
    {
        draw.itemState = 0;

        if ( GetFocus() == _hwnd )
            draw.itemState |= ODS_FOCUS;

        draw.itemID = i;
        draw.rcItem.top = 0;
        draw.rcItem.left = 0;
        draw.rcItem.bottom = _cyLine;
        draw.rcItem.right = _cx;

        SetViewportOrgEx( hdc, 0, i * _cyLine, 0 );
        //
        // Owner: Draw item!
        //
        SendMessage (_hwndParent, wmDrawItem, 0, (LPARAM)&draw);
    }
    SelectObject (hdc, hfontOld);
} //Paint

//
// Set Font
//

void CListView::SetFont (HFONT hfontNew)
{
    _hfont = hfontNew;
    MEASUREITEMSTRUCT measure;
    measure.CtlType = odtListView;
    //
    // Owner: Measure item
    //
    SendMessage (_hwndParent, wmMeasureItem, 0, (LPARAM) &measure);
    _cyLine = measure.itemHeight;
    long cRows = (_cy + _cyLine - 1) / _cyLine;
    _cLines = cRows;
    //
    // Owner: Size
    //
    SendMessage(_hwndParent, wmListNotify, listSize, (LPARAM) &cRows);
    InvalidateAndUpdateScroll();
} //SetFont


//
// Scrolling
//

void CListView::Vscroll ( int action, int nPos)
{
    switch (action)
    {
        case SB_LINEUP:
            LineUp ();
            break;
        case SB_LINEDOWN:
            LineDown ();
            break;
        case SB_THUMBTRACK:
            // don't refresh when thumb dragging
            // over many hits (too expensive)
            break;

        case SB_THUMBPOSITION:
            if (_cTotal > 65535)
            {
                SCROLLINFO si; si.cbSize = sizeof si;
                si.fMask = SIF_TRACKPOS;
                GetScrollInfo (_hwnd, SB_VERT, &si);
                nPos = si.nTrackPos;
            }
            ScrollPos (nPos);
            break;
        case SB_PAGEDOWN:
            PageDown ();
            break;
        case SB_PAGEUP:
            PageUp ();
            break;
        case SB_TOP:
            Top ();
            break;
        case SB_BOTTOM:
            Bottom ();
            break;

    }
} //VScroll

void CListView::LineUp ()
{
    long cLine = 1;
    //
    // Owner: Line up!
    //
    SendMessage(_hwndParent, wmListNotify, listScrollLineUp, (LPARAM) &cLine);
    if (cLine == 1)
    {
        if (_cBefore != 0)
            _cBefore--;

        // Force scroll and redraw
        RECT rect;
        GetClientRect (_hwnd, &rect);
        MyScrollWindow (_hwnd, 0, _cyLine, &rect, &rect);
        UpdateScroll();
    }
} //LineUp

void CListView::LineDown ()
{
    long cLine = 1;
    //
    // Owner: Line down!
    //
    SendMessage(_hwndParent, wmListNotify, listScrollLineDn, (LPARAM) &cLine);
    if (cLine == 1)
    {
        RECT rect;
        GetClientRect (_hwnd, &rect);
        MyScrollWindow (_hwnd, 0, -_cyLine, &rect, &rect);
        _cBefore++;
        UpdateScroll();
    }
} //LineDown

void CListView::_GoUp(
    long cToGo )
{
    CWaitCursor wait;

    long count = cToGo;

    count = __min( count, _cBefore );

    //
    // Owner: Page up!
    //
    SendMessage(_hwndParent, wmListNotify, listScrollPageUp, (LPARAM) &count);

    // _cBefore is approximate; don't give up if it is too big

    if ( 0 == count )
    {
        if ( _cBefore > 0 )
            count = _cBefore - 1;
        else
            count = 1; // worst case; scroll up one line

        SendMessage( _hwndParent,
                     wmListNotify,
                     listScrollPageUp,
                     (LPARAM) &count );
    }

    // gee, we're having a bad hair day

    if ( 0 == count )
    {
        count = 1; // worst case; scroll up one line

        SendMessage( _hwndParent,
                     wmListNotify,
                     listScrollPageUp,
                     (LPARAM) &count );
    }

    if ( 0 != count )
    {
        // count == number of lines open at the top
        _cBefore -= count;
        if (_cBefore < 0)
            _cBefore = 0;
        InvalidateAndUpdateScroll();
    }
} //_GoUp

void CListView::PageUp ()
{
    _GoUp( _cLines - 1 );
} //PageUp

void CListView::_GoDown(
    long cToGo )
{
    CWaitCursor wait;

    long count = cToGo;
    //
    // Owner: Page Down!
    //
    SendMessage(_hwndParent, wmListNotify, listScrollPageDn, (LPARAM) &count);
    // count == number of lines open at the bottom

    if ( 0 != count )
    {
        _cBefore += count;
        if (_cBefore >= ( _cTotal - _cLines ) )
            _cBefore = ( _cTotal - _cLines );
        InvalidateAndUpdateScroll();
    }
} //_GoDown

void CListView::PageDown ()
{
    _GoDown( _cLines - 1 );
} //PageDown

void CListView::Top ()
{
    long count = _cLines;
    //
    // Owner: Top!
    //
    SendMessage(_hwndParent, wmListNotify, listScrollTop, (LPARAM) &count );
    _cBefore = 0;
    InvalidateAndUpdateScroll();
} //Top

void CListView::Bottom ()
{
    long count = _cLines;
    //
    // Owner: Bottom!
    //
    SendMessage(_hwndParent, wmListNotify, listScrollBottom,  (LPARAM) &count);
    // count == number of lines visible
    _cBefore = _cTotal - count;
    if (_cBefore < 0)
        _cBefore = 0;
    InvalidateAndUpdateScroll();
} //Bottom

void CListView::ScrollPos (int pos)
{
    long iRow = pos;
    //
    // Owner: Scroll Position!
    //
    SendMessage(_hwndParent, wmListNotify, listScrollPos, (LPARAM) &iRow);
    if (iRow != -1)
    {
        _cBefore = iRow;
        InvalidateAndUpdateScroll();
    }
} //ScrollPos


//
// Message: Reset Contents
//

void CListView::ResetContents()
{
    _cBefore = 0;
    _cTotal = 0;
    UpdateScroll();

    RECT rect;
    GetClientRect (_hwnd, &rect);
    InvalidateRect (_hwnd, &rect, TRUE );
    UpdateWindow (_hwnd);
} //ResetContents

void CListView::InvalidateAndUpdateScroll()
{
    RECT rect;
    GetClientRect (_hwnd, &rect);
    InvalidateRect (_hwnd, &rect, TRUE );

    UpdateScroll();
} //InvalidateAndUpdateScroll

//
// Message: Insert item after iRow
//

void CListView::InsertItem (int iRow)
{
    Win4Assert (iRow < _cLines );
    RECT rect;
    GetClientRect (_hwnd, &rect);
    rect.top = (iRow + 1) * _cyLine;
    MyScrollWindow( _hwnd, 0, _cyLine, &rect, &rect, FALSE );
    _cTotal++;
    UpdateWindow (_hwnd);
    UpdateScroll();
} //InsertItem

//
// Message: Delete item
//

void CListView::DeleteItem (int iRow)
{
    Win4Assert (iRow < _cLines );
    RECT rect;

    GetClientRect (_hwnd, &rect);
    rect.top = (iRow + 1) * _cyLine;
    MyScrollWindow( _hwnd, 0, -_cyLine, &rect, &rect, FALSE );

    _cTotal--;
    if (_cTotal < 0)
        _cTotal = 0;

    // Invalidate the area which was
    // scrolled up (the last row before scrolling), if visible
    if ( _cTotal && _cTotal < _cLines )
    {
        RefreshRow( _cTotal );
    }

    UpdateScroll();
} //DeleteItem

//
// Message: Invalidate item
//

void CListView::InvalidateItem (int iRow)
{
    Win4Assert (iRow <= _cLines );
    RefreshRow (iRow);
    UpdateWindow (_hwnd);
} //InvalidateItem

//
// Message: Set count before
//

void CListView::SetCountBefore (int cBefore)
{
    _cBefore = cBefore;
    SetScrollPos (_hwnd, SB_VERT, _cBefore, TRUE);
} //SetCountBefore

//
// Message: Set total count
//

void CListView::SetTotalCount (int cTotal)
{
    _cTotal = cTotal;
    UpdateScroll ();
} //SetTotalCount



//
// Internal methods
//

void CListView::RefreshRow (int iRow)
{
    Win4Assert ( iRow < _cLines );
    RECT rect;
    rect.top = iRow * _cyLine;
    rect.left = 0;
    rect.bottom = rect.top + _cyLine;
    rect.right = _cx;
    InvalidateRect (_hwnd, &rect, TRUE );
} //RefreshRow

void CListView::UpdateScroll()
{
    if (_cTotal - _cLines >= 0)
    {
        ShowScrollBar( _hwnd, SB_VERT, TRUE );
        SetScrollRange (_hwnd, SB_VERT, 0, _cTotal - 1, FALSE);
        SetScrollPos (_hwnd, SB_VERT, _cBefore, TRUE);

        // proportional scroll box
        SCROLLINFO si;
        si.cbSize = sizeof(si);
        si.fMask = SIF_PAGE;
        si.nPage = _cLines;
        SetScrollInfo( _hwnd, SB_VERT, &si, TRUE );

        EnableScrollBar (_hwnd, SB_VERT, ESB_ENABLE_BOTH );
    }
    else
    {
        _cBefore = 0;

        ShowScrollBar( _hwnd, SB_VERT, FALSE );
        EnableScrollBar (_hwnd, SB_VERT, ESB_DISABLE_BOTH );
    }
} //UpdateScroll
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\srch\brview.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       brview.cxx
//
//  Contents:   
//
//  History:    15 Aug 1996     DLee    Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#define TheModel _layout.GetModel()

#define UNICODE_PARAGRAPH_SEPARATOR 0x2029

const int BUFLEN = 256;
WCHAR LineBuffer[BUFLEN + 1];

const int cpLeftMargin = 3;

int TrimEOL (WCHAR * pwcLine, int cwcLine)
{
    // If the line ends in \r\n or \n, don't include that in the length.
    // TabbedTextOut() prints garbage when it sees \r or \n

    if ((cwcLine >= 2) && (pwcLine[cwcLine - 2] == L'\r'))
        cwcLine -= 2;
    else if ((cwcLine >= 1) &&
             ((pwcLine[cwcLine - 1] == L'\r') ||
              (pwcLine[cwcLine - 1] == UNICODE_PARAGRAPH_SEPARATOR) ||
              (pwcLine[cwcLine - 1] == L'\n')))
        cwcLine--;

    return cwcLine;
} //TrimEOL

void TextMetrics::GetSizes ( CharDim& dim )
{
    dim.cxChar = _tm.tmAveCharWidth;
    dim.cyChar = _tm.tmHeight + _tm.tmExternalLeading;
} //GetSizes

void View::_NoSelection()
{
    _Selection.None();
} //NoSelection

void View::_UpdateSelection(
    LPARAM lParam )
{
    int x = (int) (short) LOWORD( lParam );
    int y = (int) (short) HIWORD( lParam );
    if ( y < 0 )
        y = 0;
    else if ( y > _cyClient )
        y = _cyClient;
    int para, o;
    GetParaAndOffset( x, y, para, o );

    if ( _fStartIsAnchor )
    {
        if ( ( para < _Selection.ParaStart() ) ||
             ( ( para == _Selection.ParaStart() ) &&
               ( o < _Selection.OffStart() ) ) )
        {
            _Selection.SetEnd( _Selection.ParaStart(), _Selection.OffStart() );
            _Selection.SetStart( para, o );
            _fStartIsAnchor = FALSE;
        }
        else
        {
            _Selection.SetEnd( para, o );
        }
    }
    else
    {
        if ( ( para > _Selection.ParaEnd() ) ||
             ( ( para == _Selection.ParaEnd() ) &&
               ( o > _Selection.OffEnd() ) ) )
        {
            _Selection.SetStart( _Selection.ParaEnd(), _Selection.OffEnd() );
            _Selection.SetEnd( para, o );
            _fStartIsAnchor = TRUE;
        }
        else
        {
            _Selection.SetStart( para, o );
        }
    }

    if ( _fFullSelRepaint )
    {
        InvalidateRect( _hwnd, NULL, FALSE );
        _fFullSelRepaint = FALSE;
    }
    else
    {
        int yMin = __min( y, _cpLastSelY );
        int yMax = __max( y, _cpLastSelY );
    
        RECT rc;
        rc.left = 0;
        rc.right = _cxClient;
        rc.top = yMin - LineHeight();
        rc.bottom = yMax + LineHeight();
    
        InvalidateRect( _hwnd, &rc, FALSE );
    }

    _cpLastSelY = y;
} //_UpdateSelection

void View::ButtonUp( WPARAM wParam, LPARAM lParam )
{
    _fSelecting = FALSE;
    if ( GetCapture() == _hwnd )
        ReleaseCapture();

    if ( _fDblClk )
        return;

    if ( _Selection.IsNull() )
    {
        _Selection.None();
        return;
    }
    else
    {
        _UpdateSelection( lParam );
    }
} //ButtonUp

void View::MouseMove( WPARAM wParam, LPARAM lParam )
{
    if ( _fSelecting &&
         ( wParam & MK_LBUTTON ) )
        _UpdateSelection( lParam );
} //MouseMove

void View::ButtonDown( WPARAM wParam, LPARAM lParam )
{
    BOOL fOldSel = _Selection.SelectionExists();

    _fDblClk = FALSE;
    SetCapture( _hwnd );
    _fStartIsAnchor = TRUE;
    _fSelecting = TRUE;
    _NoSelection();
    int x = LOWORD( lParam );
    int y = HIWORD( lParam );
    _cpLastSelY = y;
    int para, o;
    GetParaAndOffset( x, y, para, o );
    _Selection.SetStart( para, o );
    _fFullSelRepaint = FALSE;

    if ( fOldSel )
        InvalidateRect( _hwnd, NULL, FALSE );
} //ButtonDown

int GetCharOffset(
    HDC     hdc,
    int     iClickX,
    WCHAR * pwcLine,
    int     cwcLine,
    int     cpLeft )
{
    // a click in the left margin counts

    if ( 0 != cwcLine && iClickX < cpLeft )
        return 0;

    int l = cpLeft;

    for ( int c = 0; c < cwcLine; c++ )
    {
        int dx = LOWORD( GetTabbedTextExtent( hdc, pwcLine, 1 + c, 0, 0 ) );

        if ( iClickX >= l && iClickX <= dx + cpLeft )
            break;

        l = dx + cpLeft;
    }

    return c;
} //GetCharOffset

void View::GetParaAndOffset(
    int x,
    int y,
    int & para,
    int & offset )
{
    offset = 0;
    HDC hdc = GetDC( _hwnd );

    if ( 0 == hdc )
        return;

    HFONT hOldFont = (HFONT) SelectObject( hdc, _layout.Font() );

    para   = _layout.FirstPara();
    int paLine = _layout.FirstLineInPara();     // line within paragraph

    int paOffBeg;   // line beginning offset within paragraph
    int paOffEnd;   // line end offset within paragraph
    int line = 0;           // line # counting from top of window
    int left = cpLeftMargin - _layout.XBegin();

    while ( _layout.GetLineOffsets( para, paLine, paOffBeg, paOffEnd ) )
    {
        do
        {
            int top = _layout.Y ( line );
            int bottom = top + _layout.CyChar();

            if ( y >= top && y <= bottom )
            {
                // got the line, now find the word selected

                int cwcLine = __min ( BUFLEN, paOffEnd - paOffBeg );

                if ( TheModel.GetLine(para, paOffBeg, cwcLine, LineBuffer ) )
                {
                    cwcLine = TrimEOL( LineBuffer, cwcLine );
                    offset = paOffBeg + GetCharOffset( hdc,
                                                       x,
                                                       LineBuffer,
                                                       cwcLine,
                                                       cpLeftMargin );
                }
                goto cleanup;
            }

            line++;
            if (line >= _layout.MaxLines())
                goto cleanup;
            paLine++;
        } while ( _layout.GetLineOffsets( para, paLine, paOffBeg, paOffEnd ) );

        // next paragraph
        para++;
        paLine = 0;
    }

cleanup:
    SelectObject( hdc, hOldFont );
    ReleaseDC( _hwnd, hdc );
} //GetParaAndOffset

void View::EditCopy( HWND hwnd, WPARAM wParam )
{
    if ( _Selection.SelectionExists() )
    {
        // is everything in one paragraph? -- easy case

        if ( _Selection.IsInOnePara() )
        {
            int cwcLine = __min ( BUFLEN,
                                  _Selection.OffEnd() - _Selection.OffStart() );
            TheModel.GetLine( _Selection.ParaStart(),
                              _Selection.OffStart(),
                               cwcLine, LineBuffer );
            cwcLine = TrimEOL( LineBuffer, cwcLine );
            LineBuffer[cwcLine] = 0;
    
            PutInClipboard( LineBuffer );
        }
        else
        {
            // compute how much text to copy

            int cwcTotal = 0;
    
            for ( int p = _Selection.ParaStart();
                  p <= _Selection.ParaEnd();
                  p++ )
            {
                int cwcLine = BUFLEN;
                if ( p == _Selection.ParaStart() )
                {
                    TheModel.GetLine( p, _Selection.OffStart(),
                                      cwcLine, LineBuffer );
                }
                else if ( p == _Selection.ParaEnd() )
                {
                    TheModel.GetLine( p, 0, cwcLine, LineBuffer );
                    cwcLine = _Selection.OffEnd();
                }
                else
                {
                    TheModel.GetLine( p, 0, cwcLine, LineBuffer );
                }
                cwcTotal += cwcLine;
            }

            // allocate a buffer and copy the text

            XArray<WCHAR> aClip( cwcTotal + 1 );
            WCHAR *pwc = (WCHAR *) aClip.GetPointer();

            cwcTotal = 0;

            for ( p = _Selection.ParaStart();
                  p <= _Selection.ParaEnd();
                  p++ )
            {
                int cwcLine = BUFLEN;
                if ( p == _Selection.ParaStart() )
                {
                    TheModel.GetLine( p, _Selection.OffStart(),
                                      cwcLine, LineBuffer );
                }
                else if ( p == _Selection.ParaEnd() )
                {
                    TheModel.GetLine( p, 0, cwcLine, LineBuffer );
                    cwcLine = _Selection.OffEnd();
                }
                else
                {
                    TheModel.GetLine( p, 0, cwcLine, LineBuffer );
                }
                LineBuffer[cwcLine] = 0;
                wcscpy( pwc + cwcTotal, LineBuffer );
                cwcTotal += cwcLine;
            }
    
            PutInClipboard( pwc );
        }
    }
} //EditCopy

BOOL isWhite( WCHAR c )
{
    // well, actually white space and C++ break characters

    return ( L' ' == c ||
             L'\r' == c ||
             L'\n' == c ||
             L'\t' == c ||
             L'\\' == c ||
             L'\'' == c ||
             L'\"' == c ||
             L':' == c ||
             L';' == c ||
             L',' == c ||
             L'[' == c ||
             L']' == c ||
             L'{' == c ||
             L'}' == c ||
             L'(' == c ||
             L')' == c ||
             L'/' == c ||
             L'+' == c ||
             L'-' == c ||
             L'=' == c ||
             L'*' == c ||
             L'^' == c ||
             L'~' == c ||
             L'&' == c ||
             L'!' == c ||
             L'?' == c ||
             L'<' == c ||
             L'>' == c ||
             L'.' == c ||
             L'|' == c ||
             UNICODE_PARAGRAPH_SEPARATOR == c );
} //isWhite

BOOL GetSelectedWord(
    HDC hdc,
    int iClickX,
    WCHAR *pwcLine,
    int cwcLine,
    int cpLeft,
    int &rStart,
    int &rEnd )
{
    // what character had the click?

    int c = GetCharOffset( hdc, iClickX, pwcLine, cwcLine, cpLeft );

    // move left and right till white space is found

    if ( c != cwcLine )
    {
        rEnd = c;

        while ( rEnd < (cwcLine - 1) && !isWhite( pwcLine[ rEnd ] ) )
            rEnd++;

        // selection doesn't include end

        if ( ( rEnd == ( cwcLine - 1 ) ) &&
             ( !isWhite( pwcLine[ rEnd ] ) ) )
            rEnd++;

        rStart = c;
        while ( rStart > 0 && !isWhite( pwcLine[ rStart ] ) )
            rStart--;

        // don't include white space if not at start of line

        if ( rStart < c && isWhite( pwcLine[ rStart ] ) )
            rStart++;

        // did we grab anything?

        return ( rEnd > rStart );
    }
    else
    {
        return FALSE;
    }
} //GetSelectedWord

int View::ParaFromY(
    int y )
{
    int para   = _layout.FirstPara();
    int paLine = _layout.FirstLineInPara();     // line within paragraph

    int paOffBeg;   // line beginning offset within paragraph
    int paOffEnd;   // line end offset within paragraph
    int line = 0;           // line # counting from top of window
    int left = cpLeftMargin - _layout.XBegin();

    while ( _layout.GetLineOffsets( para, paLine, paOffBeg, paOffEnd ) )
    {
        do
        {
            int top = _layout.Y( line );
            int bottom = top + _layout.CyChar();

            if ( y >= top && y <= bottom )
            {
                return 1 + para;
            }

            line++;
            if (line >= _layout.MaxLines())
                return _layout.FirstPara();
            paLine++;
        } while ( _layout.GetLineOffsets( para, paLine, paOffBeg, paOffEnd ) );

        // next paragraph
        para++;
        paLine = 0;
    }

    return _layout.FirstPara();
} //ParaFromY

void View::DblClk( WPARAM wParam, LPARAM lParam )
{
    _fDblClk = TRUE;

    BOOL fCtrl = ( 0 != ( 0x8000 & GetAsyncKeyState( VK_CONTROL ) ) );

    int x = LOWORD( lParam );
    int y = HIWORD( lParam );

    Selection oldSel( _Selection );
    _Selection.None();

    HDC hdc = GetDC( _hwnd );

    if ( 0 == hdc )
        return;

    HFONT hOldFont = (HFONT) SelectObject( hdc, _layout.Font() );

    int para   = _layout.FirstPara();
    int paLine = _layout.FirstLineInPara();     // line within paragraph

    int paOffBeg;   // line beginning offset within paragraph
    int paOffEnd;   // line end offset within paragraph
    int line = 0;           // line # counting from top of window
    int left = cpLeftMargin - _layout.XBegin();

    while (_layout.GetLineOffsets ( para, paLine, paOffBeg, paOffEnd ))
    {
        do
        {
            int top = _layout.Y ( line );
            int bottom = top + _layout.CyChar();

            if ( y >= top && y <= bottom )
            {
                // if ctrl key is down, attempt to fire up an editor

                if ( fCtrl )
                {
                    ViewFile( _pModel->Filename(), fileEdit, 1+para );
                    goto cleanup;
                }

                // got the line, now find the word selected

                int cwcLine = __min ( BUFLEN, paOffEnd - paOffBeg );

                if ( TheModel.GetLine(para, paOffBeg, cwcLine, LineBuffer ) )
                {
                    cwcLine = TrimEOL( LineBuffer, cwcLine );

                    int iStart, iEnd;

                    if ( GetSelectedWord( hdc,
                                          x,
                                          LineBuffer,
                                          cwcLine,
                                          cpLeftMargin,
                                          iStart,
                                          iEnd ) )
                        _Selection.Set( para,
                                        paOffBeg + iStart,
                                        para,
                                        paOffBeg + iEnd );

                    RECT rc;
                    rc.left = 0; rc.right = _cxClient;
                    rc.top = top; rc.bottom = bottom;
                    InvalidateRect( _hwnd, &rc, FALSE );
                }
            }
            else if ( oldSel.IsInSelection( para ) )
            {
                RECT rc;
                rc.left = 0; rc.right = _cxClient;
                rc.top = top; rc.bottom = bottom;
                InvalidateRect( _hwnd, &rc, FALSE );
            }

            line++;
            if (line >= _layout.MaxLines())
                goto cleanup;
            paLine++;
        } while (_layout.GetLineOffsets (para, paLine, paOffBeg, paOffEnd ));

        // next paragraph
        para++;
        paLine = 0;
    }

cleanup:

    SelectObject( hdc, hOldFont );
    ReleaseDC( _hwnd, hdc );

    UpdateWindow( _hwnd );
} //DblClk

void View::Size ( int cx, int cy )
{
    _cyClient = cy;
    _cxClient = cx;
}

void View::SetScrollMax ()
{
    int linesFromEnd = _cyClient / _layout.CyChar() - 2;
    int cline;
    for (int para = TheModel.Paras() - 1; para >= 0; para--)
    {
        cline = _layout.LinesInPara(para);
        if (linesFromEnd < cline)
            break;
        linesFromEnd -= cline;
    }

    _paraVScrollMax = TheModel.Paras() - 1;

    if ( _paraVScrollMax < 0 )
    {
        _paraVScrollMax = 0;
        _paLineVScrollMax = 0;
    }
    else
    {
        _paLineVScrollMax = cline - 1 - linesFromEnd;
    }
}

void View::SetRange ( int maxParaLen, int cParas )
{
    _layout.SetParaRange(cParas);
#if 0
    _nHScrollMax = 2 + maxParaLen - _cxClient / _layout.CxChar();
    if ( _nHScrollMax < 0 )
#endif
        _nHScrollMax = 0;
}

void View::SetScroll( Position & pos )
{
    _fFullSelRepaint = TRUE;

    int paLine, paOffBeg, paOffEnd;
    _layout.Locate (pos.Para(), pos.BegOff(), paLine, paOffBeg, paOffEnd);
    if (paLine >= 3)
    {
        _paraVScroll = pos.Para();
        _paLineVScroll = paLine - 3;
    }
    else
    {
        // show last line of prev para
        int iOffset = ( 0 == _cyClient ) ? 6 : ( VisibleLines() / 3 );
        _paraVScroll = pos.Para() - iOffset;

        if (_paraVScroll >= 0 )
        {
            _paLineVScroll = _layout.LinesInPara(_paraVScroll) - 1;
        }
        else
        {
            _paraVScroll = 0;
            _paLineVScroll = 0;
        }
    }

#if 0
    if ( pos.EndOff() - _nHScrollPos + 1 > _cxClient / _layout.CxChar() )
        _nHScrollPos =  pos.EndOff() - _cxClient / _layout.CxChar() + 1;
    else
        _nHScrollPos = 0;
    _nHScrollPos = min ( _nHScrollPos, _nHScrollMax );
#else
    _nHScrollPos = 0;
#endif
}


int View::JumpToPara ( int para )
{
    _fFullSelRepaint = TRUE;

    int delta = 0;
    int paraStart;
    int paraEnd;
    if (para == _paraVScroll)
    {
        return 0;
    }
    else if (para < _paraVScroll)
    {
        // jumping backwards, delta negative
        delta = -_paLineVScroll;
        for ( int p = _paraVScroll - 1; p >= para; p--)
            delta -= _layout.LinesInPara(p);

    }
    else
    {
        // jumping forward, delta positive
        delta = _layout.LinesInPara(_paraVScroll) - _paLineVScroll;
        for (int p = _paraVScroll + 1; p < para; p++)
            delta += _layout.LinesInPara(p);
    }
    _paraVScroll = para;
    _paLineVScroll = 0;
    // return delta from previous position
    return delta;
}

int View::IncVScrollPos ( int cLine )
{
    _fFullSelRepaint = TRUE;

    int para;

    if (cLine >= 0)
    {
        // first back up to the beginning
        // of the current para
        int cLineLeft = cLine + _paLineVScroll;
        // move forward
        for (para = _paraVScroll; para <= _paraVScrollMax; para++)
        {
            int ln = _layout.LinesInPara(para);
            if (cLineLeft < ln)
                break;
            cLineLeft -= ln;
        }

        if (para > _paraVScrollMax)
        {
            // overshot the end
            // move back
            _paraVScroll = _paraVScrollMax;
            int cline = _layout.LinesInPara(_paraVScroll);
            _paLineVScroll = _paLineVScrollMax;
            cLineLeft += cline - _paLineVScrollMax;
            cLine -= cLineLeft;
        }
        else if (para == _paraVScrollMax && cLineLeft > _paLineVScrollMax)
        {
            _paraVScroll = _paraVScrollMax;
            _paLineVScroll = _paLineVScrollMax;
            cLineLeft -= _paLineVScrollMax;
            cLine -= cLineLeft;
        }
        else
        {
            // cLineLeft < Lines In Para
            _paraVScroll = para;
            _paLineVScroll = cLineLeft;
        }
    }
    else if (cLine < 0)
    {
        // first skip to the end
        // of the current para
        int cLineLeft = - cLine + (_layout.LastLineInPara(_paraVScroll) - _paLineVScroll);
        // move backward
        for (para = _paraVScroll; para >= 0; para--)
        {
            int ln = _layout.LinesInPara(para);
            if (ln > cLineLeft)
                break;
            cLineLeft -= ln;
        }

        if (para < 0)
        {
            // overshot the beginning.
            // move up one line
            _paraVScroll = 0;
            _paLineVScroll = 0;
            cLineLeft++;
            cLine += cLineLeft;
        }
        else
        {
            // cLineLeft < Lines In Para
            _paraVScroll = para;
            _paLineVScroll = _layout.LinesInPara(para) - cLineLeft - 1;
        }
    }

    return cLine;
}

int View::IncHScrollPos ( int delta )
{
    Win4Assert ( FALSE );
    // Clip the increment

    if ( delta < -_nHScrollPos )
        delta = -_nHScrollPos;
    else if ( delta > _nHScrollMax - _nHScrollPos )
        delta = _nHScrollMax - _nHScrollPos;
    _nHScrollPos += delta;
    return delta;
}

void View::Paint( HWND hwnd )
{
    _layout.Adjust ( _cxClient, _cyClient, _paraVScroll, _paLineVScroll, _nHScrollPos);
    PaintText paint (hwnd, _paraVScroll, _paLineVScroll, _layout, _Selection);
    paint.PrintLines ();
    paint.HiliteHits ();
}

PaintText::PaintText(HWND hwnd, int paraFirst, int paLineFirst, Layout& layout,
                     Selection & Selection )
    : Paint(hwnd), _paraFirst(paraFirst), _paLineFirst(paLineFirst),
      _layout(layout), _Selection( Selection )
{
    _hOldFont = (HFONT) SelectObject ( hdc, _layout.Font() );

    SetBkColor ( hdc, GetSysColor(COLOR_WINDOW) );
    SetTextColor( hdc, GetSysColor(COLOR_WINDOWTEXT) );
}

PaintText::~PaintText()
{
    SelectObject ( hdc, _hOldFont );
}

void Layout::SetParaRange (int cParas)
{
    _cParas = cParas;
    _aParaLine = _pModel->GetParaLine();
}

void Layout::Adjust (int cx, int cy, int& paraVScroll, int& paLineVScroll, int nHScrollPos)
{
    _cLine = (cy + _dim.cyChar - 1) / _dim.cyChar;
    _cCharWidth = cx / _dim.cxChar;
    _xBegin = nHScrollPos * _dim.cxChar;

    if ( paraVScroll < 0 )
    {
        paraVScroll = 0;
        paLineVScroll = 0;
    }
    _paLineFirst = paLineVScroll;
    _paraFirst = paraVScroll;
}

int Layout::Y (int line ) const
{
    return line * _dim.cyChar;
}

void Layout::Locate (int para, int paOff, int& paLine, int& paOffBeg, int& paOffEnd ) const
{
    Win4Assert(para < _cParas);
    paLine = 0;
    paOffBeg = 0;
    for (ParaLine const* p = &_aParaLine[para]; p != 0 && p->offEnd <= paOff; p = p->next)
    {
        paOffBeg = p->offEnd;
        paLine++;
    }
    if (p == 0)
        paOffEnd = 0;
    else
        paOffEnd = p->offEnd;
}

BOOL Layout::GetLineOffsets (int para, int paLine, int& paOffBeg, int& paOffEnd) const
{
    if (para < _paraFirst || para > LastPara() || para >= _cParas)
        return FALSE;

    ParaLine const * p = &_aParaLine[para];
    paOffBeg = 0;
    for (int line = 0; line < paLine; line++)
    {
        paOffBeg = p->offEnd;
        p = p->next;
        if (p == 0)
            return FALSE;
    }
    paOffEnd = p->offEnd;
    Win4Assert ( paOffEnd >= paOffBeg);
    return TRUE;
}

int Layout::LastPara() const
{
    // at most this number
    return _paraFirst + _cLine;
}

int Layout::LineNumber (int para, int paLine) const
{
    if (para == _paraFirst)
    {
        return paLine - _paLineFirst;
    }
    int curPara = _paraFirst + 1;
    int curLine = LinesInPara(_paraFirst) - _paLineFirst;

    while (curPara < para)
    {
        curLine += LinesInPara(curPara);
        curPara++;
    }
    return curLine + paLine;
}

int Layout::LinesInPara (int para) const
{
    Win4Assert(para < _cParas);
    int line = 1;
    for (ParaLine const * p = _aParaLine[para].next; p != 0; p = p->next)
        line++;
    return line;
}

void EnableHilite( HDC hdc )
{
    SetBkColor( hdc, GetSysColor(COLOR_HIGHLIGHT) );
    SetTextColor( hdc, GetSysColor(COLOR_HIGHLIGHTTEXT) );
}

void EnableHitHilite( HDC hdc )
{
//    SetBkColor( hdc, GetSysColor(COLOR_ACTIVECAPTION) );
//    SetTextColor( hdc, GetSysColor(COLOR_CAPTIONTEXT) );

//    SetBkColor( hdc, GetSysColor(COLOR_INACTIVECAPTION) );
//    SetTextColor( hdc, GetSysColor(COLOR_INACTIVECAPTIONTEXT) );

//    SetBkColor( hdc, GetSysColor(COLOR_HIGHLIGHTTEXT) );
//    SetTextColor( hdc, GetSysColor(COLOR_HIGHLIGHT) );

    SetBkColor( hdc, GetSysColor(COLOR_WINDOWTEXT) );
    SetTextColor( hdc, GetSysColor(COLOR_WINDOW) );

//    SetBkColor( hdc, GetSysColor(COLOR_HIGHLIGHT) );
//    SetTextColor( hdc, GetSysColor(COLOR_HIGHLIGHTTEXT) );
}

void EnableNonCurrentHitHilite( HDC hdc )
{
    SetBkColor ( hdc, GetSysColor(COLOR_WINDOW) );
    SetTextColor( hdc, GetSysColor(COLOR_HIGHLIGHT) );
}

void DisableHilite( HDC hdc )
{
    SetBkColor ( hdc, GetSysColor(COLOR_WINDOW) );
    SetTextColor ( hdc, GetSysColor(COLOR_WINDOWTEXT) );
}

void PaintText::PrintLines ()
{
    int para   = _layout.FirstPara();
    int paLine = _layout.FirstLineInPara();     // line within paragraph
    int paOffBeg;   // line beginning offset within paragraph
    int paOffEnd;   // line end offset within paragraph

    int line = 0;           // line # counting from top of window
    int left = cpLeftMargin - _layout.XBegin();

    while (_layout.GetLineOffsets ( para, paLine, paOffBeg, paOffEnd ))
    {
        // print paragraph
        do
        {
            // clip to the update rect
            int top = _layout.Y ( line );
            int bottom = top + _layout.CyChar();

            if ( top <= rcPaint.bottom && bottom >= rcPaint.top)
            {
                int cwcLine = __min ( BUFLEN, paOffEnd - paOffBeg );
                if (!TheModel.GetLine( para, paOffBeg, cwcLine, LineBuffer ))
                    return;
    
                cwcLine = TrimEOL( LineBuffer, cwcLine );

                if ( 0 == cwcLine )
                {
                    // to make selections look better...
                    wcscpy(LineBuffer,L" ");
                    cwcLine = 1;
                }

                Win4Assert( cwcLine >= 0 );

                if ( _Selection.IsInSelection( para ) )
                {
                    if ( ( para > _Selection.ParaStart() ) &&
                         ( para < _Selection.ParaEnd() ) )
                    {
                        EnableHilite( hdc );
                        TabbedTextOut( hdc, left, top, LineBuffer, cwcLine,
                                       0, 0, left );
                        DisableHilite( hdc );
                    }
                    else
                    {
                        int l = left;
                        for ( int c = 0; c < cwcLine; c++ )
                        {
                            if ( _Selection.IsInSelection( para, c + paOffBeg ) )
                                EnableHilite( hdc );
                            LONG dim = TabbedTextOut( hdc, l, top,
                                                      LineBuffer + c, 1,
                                                      0, 0, left );
                            DisableHilite( hdc );
                            l += LOWORD(dim);
                        }
                    }
                }
                else
                {
                    TabbedTextOut( hdc, left, top, LineBuffer, cwcLine,
                                   0, 0, left );
                }
            }

            line++;
            if (line >= _layout.MaxLines())
                return;
            paLine++;
        } while (_layout.GetLineOffsets( para, paLine, paOffBeg, paOffEnd ));

        // next paragraph
        para++;
        paLine = 0;
    }
} //PrintLines

void PaintText::HiliteHits ()
{
    TheModel.HiliteAll( TRUE );

    if ( TheModel.FirstHit() )
    {
        do
        {
            if ( !TheModel.isSavedCurrent() )
                PrintCurrentHit( FALSE );
        }
        while( TheModel.NextHit() );

        TheModel.RestoreHilite();
    }

    TheModel.HiliteAll( FALSE );

    PrintCurrentHit( TRUE );
} //HiliteHits

const int WORDBUFLEN = 80;
static WCHAR WordBuffer [WORDBUFLEN];

void PaintText::PrintCurrentHit( BOOL fCurrent )
{
    if ( fCurrent )
        EnableHitHilite( hdc );
    else
        EnableNonCurrentHitHilite( hdc );

    int cPos = TheModel.GetPositionCount();
    int iPos = 0;
    Position pos = TheModel.GetPosition(iPos);

    int left = cpLeftMargin - _layout.XBegin();

    while ( iPos < cPos )
    {
        int curPara = pos.Para();

        if ( curPara > _layout.LastPara() )
            break;

        if (curPara >= _layout.FirstPara())
        {
            int paLine;     // line within paragraph
            int paOffBeg;   // line beginning offset within paragraph
            int paOffEnd;   // line end offset within paragraph

            _layout.Locate ( curPara, pos.BegOff(), paLine, paOffBeg, paOffEnd );

            int line = _layout.LineNumber ( curPara, paLine );

            // Output the line with highlights

            int cwcLine = __min ( BUFLEN, paOffEnd - paOffBeg );
            if (!TheModel.GetLine (curPara, paOffBeg, cwcLine, LineBuffer ))
                break;

            cwcLine = TrimEOL( LineBuffer, cwcLine );

            int top = _layout.Y (line);

            do
            {
                int cwc = __min( pos.Len(), WORDBUFLEN);
                TheModel.GetWord( curPara, pos.BegOff(), cwc, WordBuffer );
                Win4Assert ( cwc >= 0 );

                // Find out how much space it takes before the highlight

                DWORD dwExt = GetTabbedTextExtent ( hdc,
                                                    LineBuffer,
                                                    pos.BegOff() - paOffBeg,
                                                    0, 0 );

                // Print hilighted text

                TabbedTextOut ( hdc,
                                left + LOWORD(dwExt),
                                top,
                                WordBuffer,
                                cwc,
                                0, 0,
                                left );

                iPos++;
                if (iPos >= cPos)
                    break;
                pos = TheModel.GetPosition(iPos);

            } while ( pos.Para() == curPara );
        }
        else
        {
            iPos++;
        }
    }

    DisableHilite( hdc );
} //PrintCurrentHit
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\srch\srchq.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       srchq.cxx
//
//  Contents:   
//
//  History:    15 Aug 1996     DLee    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#define guidCPP { 0x8DEE0300, 0x16C2, 0x101B, { 0xB1, 0x21, 0x08, 0x00, 0x2B, 0x2E, 0xCD, 0xA9 } }

static GUID guidCPlusPlus = guidCPP;

static GUID guidBmk =       DBBMKGUID;
static const GUID guidQueryExt = DBPROPSET_QUERYEXT;
static const GUID guidRowsetProps = DBPROPSET_ROWSET;

static const DBID dbcolNull = { {0,0,0,{0,0,0,0,0,0,0,0}},DBKIND_GUID_PROPID,0};

#define guidZero { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }

const DBID dbcolCPlusPlusClass = { guidCPP, DBKIND_GUID_NAME, L"class" };
const DBID dbcolCPlusPlusFunc = { guidCPP, DBKIND_GUID_NAME, L"func" };

const DBID dbcolBookMark = { DBBMKGUID, DBKIND_GUID_PROPID, (LPWSTR) (ULONG_PTR) PROPID_DBBMK_BOOKMARK };

const DBID dbcolPath =  { PSGUID_STORAGE, DBKIND_GUID_PROPID,
                             (LPWSTR) ULongToPtr( PID_STG_PATH ) };

const DBBINDING dbbindingPath = {  0,
                                   0,
                                   0,
                                   0,
                                   0,
                                   0,
                                   0,
                                   DBPART_VALUE,
                                   DBMEMOWNER_PROVIDEROWNED,
                                   DBPARAMIO_NOTPARAM,
                                   sizeof (WCHAR *),
                                   0,
                                   DBTYPE_WSTR|DBTYPE_BYREF,
                                   0,
                                   0,
                                 };


DBBINDING aBmkColumn[] =  {  0,
                             sizeof DBLENGTH,
                             0,
                             0,
                             0,
                             0,
                             0,
                             DBPART_VALUE | DBPART_LENGTH,
                             DBMEMOWNER_CLIENTOWNED,
                             DBPARAMIO_NOTPARAM,
                             MAX_BOOKMARK_LENGTH,
                             0,
                             DBTYPE_BYTES,
                             0,
                             0,
                         };

CIPROPERTYDEF aCPPProperties[] =
{
    {
        L"FUNC",
        DBTYPE_WSTR | DBTYPE_BYREF,
        {
            { 0x8dee0300, 0x16c2, 0x101b, 0xb1, 0x21, 0x08, 0x00, 0x2b, 0x2e, 0xcd, 0xa9 },
            DBKIND_GUID_NAME,
            L"func"
        }
    },
    {
        L"CLASS",
        DBTYPE_WSTR | DBTYPE_BYREF,
        {
            { 0x8dee0300, 0x16c2, 0x101b, 0xb1, 0x21, 0x08, 0x00, 0x2b, 0x2e, 0xcd, 0xa9 },
            DBKIND_GUID_NAME,
            L"class"
        }
    }
};

unsigned cCPPProperties = sizeof aCPPProperties /
                          sizeof aCPPProperties[0];

SCODE ParseQuery(
    WCHAR *          pwcQuery,
    ULONG            ulDialect,
    LCID             lcid,
    DBCOMMANDTREE ** ppQuery )
{
    *ppQuery = 0;

    return CITextToSelectTreeEx( pwcQuery,
                                 ulDialect,
                                 ppQuery,
                                 cCPPProperties,
                                 aCPPProperties,
                                 lcid );
} //ParseQuery

//-----------------------------------------------------------------------------
//
//  Function:   GetOleDBErrorInfo
//
//  Synopsis:   Retrieves the secondary error from the OLE DB error object.
//
//  Arguments:  [pErrSrc]      - Pointer to object that posted the error.
//              [riid]         - Interface that posted the error.
//              [lcid]         - Locale in which the text is desired.
//              [pErrorInfo]   - Pointer to memory where ERRORINFO should be.
//              [ppIErrorInfo] - Holds the returning IErrorInfo. Caller
//                               should release this.
//
//  Returns:    HRESULT for whether the error info was retrieved
//
//-----------------------------------------------------------------------------

HRESULT GetOleDBErrorInfo(
    IUnknown *    pErrSrc,
    REFIID        riid,
    LCID          lcid,
    ERRORINFO *   pErrorInfo,
    IErrorInfo ** ppIErrorInfo )
{
    *ppIErrorInfo = 0;

    // See if an error is available that is of interest to us.

    XInterface<ISupportErrorInfo> xSupportErrorInfo;
    HRESULT hr = pErrSrc->QueryInterface( IID_ISupportErrorInfo,
                                          xSupportErrorInfo.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    hr = xSupportErrorInfo->InterfaceSupportsErrorInfo( riid );
    if ( FAILED( hr ) )
        return hr;

    // Get the current error object. Return if none exists.

    XInterface<IErrorInfo> xErrorInfo;
    hr = GetErrorInfo( 0, xErrorInfo.GetPPointer() );
    if ( xErrorInfo.IsNull() )
        return hr;

    // Get the IErrorRecord interface and get the count of errors.

    XInterface<IErrorRecords> xErrorRecords;
    hr = xErrorInfo->QueryInterface( IID_IErrorRecords,
                                     xErrorRecords.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    ULONG cErrRecords;
    hr = xErrorRecords->GetRecordCount( &cErrRecords );
    if ( 0 == cErrRecords )
        return hr;

#if 0 // A good way to get the complete error message...

    XInterface<IErrorInfo> xErrorInfoRec;
    ERRORINFO ErrorInfo;
    for ( unsigned i=0; i<cErrRecords; i++ )
    {
        // Get basic error information.

        xErrorRecords->GetBasicErrorInfo( i, &ErrorInfo );

        // Get error description and source through the IErrorInfo interface
        // pointer on a particular record.

        xErrorRecords->GetErrorInfo( i, lcid, xErrorInfoRec.GetPPointer() );

        XBStr bstrDescriptionOfError;
        XBStr bstrSourceOfError;

        BSTR bstrDesc = bstrDescriptionOfError.GetPointer();
        BSTR bstrSrc = bstrSourceOfError.GetPointer();

        xErrorInfoRec->GetDescription( &bstrDesc ); 
        xErrorInfoRec->GetSource( &bstrSrc );

        // At this point, you could call GetCustomErrorObject and query for
        // additional interfaces to determine what else happened.

        wprintf( L"%s (%#x)\n%s\n", bstrDesc, ErrorInfo.hrError, bstrSrc );    
    }
#endif

    // Get basic error information for the most recent error

    ULONG iRecord = cErrRecords - 1;
    hr = xErrorRecords->GetBasicErrorInfo( iRecord, pErrorInfo );
    if ( FAILED( hr ) )
        return hr;

    return xErrorRecords->GetErrorInfo( iRecord, lcid, ppIErrorInfo );
} //GetOleDBErrorInfo

//
// CSearchQuery
//

CSearchQuery::CSearchQuery(
    const XGrowable<WCHAR> & xCatList,
    WCHAR *pwcQuery,
    HWND hNotify,
    int  cRowsDisp,
    LCID  lcid,
    ESearchType srchType,
    IColumnMapper & columnMapper,
    CColumnList &columns,
    CSortList &sort,
    ULONG ulDialect,
    ULONG ulLimit,
    ULONG ulFirstRows )
    : _hwndNotify(hNotify),
      _hwndList (0),
      _cRowsTotal(0),
      _cHRows(0),
      _cRowsDisp(cRowsDisp),
      _lcid(lcid),
      _fDone(FALSE),
      _srchType(srchType),
      _columns(columns),
      _columnMapper(columnMapper),
      _hAccessor(0),
      _hBmkAccessor(0),
      _hBrowseAccessor(0),
      _iRowCurrent(0),
      _hRegion(0),
      _pctDone(0),
      _dwQueryStatus(0),
      _scLastError(0),
      _dwStartTime(0),
      _dwEndTime(0),
      _prstQuery(0),
      _xCatList( xCatList )
{
    srchDebugOut((DEB_TRACE,"top of CSearchQuery()\n"));

    _dwStartTime = GetTickCount();

    _bmkTop.MakeFirst();

    for (int i = 0; i < cMaxRowCache; i++)
        _aHRows [i] = 0;

    ICommand *pICommand = 0;
    SCODE sc = InstantiateICommand( &pICommand );

    if ( FAILED( sc ) )
        THROW( CException( sc ) );

    XInterface< ICommand> xCommand( pICommand );

    _xwcQuery.SetSize(wcslen(pwcQuery) + 1);

    wcscpy(_xwcQuery.Get(),pwcQuery);

    switch ( ulDialect )
    {
    case    ISQLANG_V1:
    case    ISQLANG_V2:
        {
            if (srchNormal == _srchType)
            {
                sc = ParseQuery( _xwcQuery.Get(), ulDialect, lcid, &_prstQuery );

                if ( FAILED(sc) )
                    THROW( CException(sc) );
            }
            else
            {
                XArray<WCHAR> xQuery( wcslen( _xwcQuery.Get() ) + 50 );

                wcscpy( xQuery.Get(), ( _srchType == srchClass ) ? L"@class " : L"@func " );
                wcscat( xQuery.Get(), _xwcQuery.Get() );

                sc = ParseQuery( xQuery.Get(), ulDialect, lcid, &_prstQuery );

                if ( FAILED(sc) )
                    THROW( CException(sc) );
            }

            XArray<WCHAR> xColumns;
            columns.MakeList( xColumns );

            XArray<WCHAR> xSort;
            sort.MakeList( xSort );

            DBCOMMANDTREE *pTree;
            sc = CIRestrictionToFullTree( _prstQuery,
                                          xColumns.Get(),
                                          xSort.Get(),
                                          0,
                                          &pTree,
                                          0,
                                          0,
                                          lcid );
            if ( FAILED( sc ) )
                THROW( CException(sc) );

            XInterface<ICommandTree> xCommandTree;
            sc = pICommand->QueryInterface( IID_ICommandTree, xCommandTree.GetQIPointer() );
            if ( FAILED( sc ) )
                THROW( CException(sc) );

            sc = xCommandTree->SetCommandTree( &pTree, DBCOMMANDREUSE_NONE, FALSE);
            if (FAILED (sc) )
                THROW( CException( sc ) );
            break;
        }
    case    SQLTEXT:
        {
            WCHAR       awcCommand[cwcMaxQuery];
            WCHAR       awcPropList[cwcMaxQuery] = L"Path";
            CResString  wstrQueryFormat(IDS_SQLQUERY_FORMAT);

            XInterface<ICommandText> xCommandText;
            sc = pICommand->QueryInterface( IID_ICommandText, xCommandText.GetQIPointer() );

            if ( FAILED( sc ) )
                THROW( CException( sc ) );

            // set the list of columns
            // !! Allways select the PATH column !!
            for ( ULONG iCol = 0; iCol < _columns.NumberOfColumns(); iCol++ )
            {
                if ( _wcsicmp ( _columns.GetColumn(iCol), L"Path" ) )
                {
                    wcscat( awcPropList, L", " );
                    wcscat( awcPropList, _columns.GetColumn( iCol ) );
                }
            }

            WCHAR awcMachine[MAX_PATH];
            WCHAR awcCatalog[MAX_PATH];
            WCHAR awcPath[MAX_PATH];
            BOOL fDeep;

            // What about ditributed queries?  Not supported, but that's OK
            // since this is a test tool.

            GetCatListItem( _xCatList, 0, awcMachine, awcCatalog, awcPath, fDeep );

            swprintf( awcCommand, wstrQueryFormat.Get(), awcPropList, awcCatalog, awcPath, pwcQuery );

            srchDebugOut((DEB_TRACE, "SQL query: %ws\n", awcCommand));

            sc = xCommandText->SetCommandText( DBGUID_SQL, awcCommand);

            if ( FAILED (sc) )
                THROW( CException( sc ) );

            XInterface<ICommandPrepare> xCommandPrepare;

            sc = pICommand->QueryInterface( IID_ICommandPrepare, xCommandPrepare.GetQIPointer() );

            if ( FAILED (sc) )
                THROW( CException( sc ) );

            sc = xCommandPrepare->Prepare( 1 );

            if ( FAILED (sc) )
                THROW( CException( sc ) );

            XInterface<ICommandProperties> xCommandProperties;

            sc = pICommand->QueryInterface( IID_ICommandProperties, xCommandProperties.GetQIPointer() );

            if ( FAILED (sc) )
                THROW( CException( sc ) );

            // set the machine name

            DBPROPSET   PropSet;
            DBPROP      Prop;

            const GUID  guidQueryCorePropset = DBPROPSET_CIFRMWRKCORE_EXT;

            PropSet.rgProperties    = &Prop;
            PropSet.cProperties     = 1;
            PropSet.guidPropertySet = guidQueryCorePropset;

            Prop.dwPropertyID       = DBPROP_MACHINE;
            Prop.colid              = DB_NULLID;
            Prop.vValue.vt          = VT_BSTR;
            Prop.vValue.bstrVal     = SysAllocString( awcMachine );

            if ( NULL == Prop.vValue.bstrVal )
                THROW( CException( E_OUTOFMEMORY ) );

            sc = xCommandProperties->SetProperties ( 1, &PropSet );

            VariantClear( &Prop.vValue );

            if ( FAILED (sc) )
                THROW( CException( sc ) );

            // try to get the restriction

            DBPROPIDSET     PropIDSet;
            DBPROPID        PropID = MSIDXSPROP_QUERY_RESTRICTION;

            PropIDSet.rgPropertyIDs     = &PropID;
            PropIDSet.cPropertyIDs      = 1;

            const GUID guidMSIDXS_ROWSETEXT = DBPROPSET_MSIDXS_ROWSETEXT;
            PropIDSet.guidPropertySet   = guidMSIDXS_ROWSETEXT;

            ULONG cPropSets;
            DBPROPSET *pPropSet;
            sc = xCommandProperties->GetProperties ( 1, &PropIDSet, &cPropSets, &pPropSet );

            if ( FAILED (sc) )
                THROW( CException( sc ) );

            Win4Assert( 1 == cPropSets );
            XCoMem<DBPROPSET> xPropSet( pPropSet );
            XCoMem<DBPROP> xProp( pPropSet->rgProperties );


            srchDebugOut((DEB_TRACE, "SQL query as tripolish: %ws\n",
                          pPropSet->rgProperties->vValue.bstrVal ));

            // MSIDXSPROP_QUERY_RESTRICTION returns the restriction in in Triplish1 syntax.
            // It is sometimes bogus.  Just set a zero and ignore the error for now.

            DBCOMMANDTREE *pQuery = 0;

            ParseQuery( pPropSet->rgProperties->vValue.bstrVal,
                        ISQLANG_V1,
                        lcid,
                        &pQuery );

            _prstQuery = pQuery;

            sc = VariantClear( &pPropSet->rgProperties->vValue );

            if ( FAILED (sc) )
                THROW( CException( sc ) );

            break;
        }
    }

    // Set the property that says we want to use asynch. queries
    {

        ICommandProperties * pCmdProp = 0;
        sc = pICommand->QueryInterface( IID_ICommandProperties,
                                     (void **)&pCmdProp );
        if (FAILED (sc) )
            THROW( CException( sc ) );

        XInterface< ICommandProperties > xComdProp( pCmdProp );

        const unsigned MAX_PROPS = 8;
        DBPROPSET aPropSet[MAX_PROPS];
        DBPROP    aProp[MAX_PROPS];

        ULONG cProps = 0;

        // asynchronous, watchable query

        aProp[cProps].dwPropertyID = DBPROP_IDBAsynchStatus;
        aProp[cProps].dwOptions = DBPROPOPTIONS_REQUIRED;
        aProp[cProps].dwStatus = 0;
        aProp[cProps].colid = dbcolNull;
        aProp[cProps].vValue.vt = VT_BOOL;
        aProp[cProps].vValue.boolVal = VARIANT_TRUE;

        aPropSet[cProps].rgProperties = &aProp[cProps];
        aPropSet[cProps].cProperties = 1;
        aPropSet[cProps].guidPropertySet = guidRowsetProps;

        cProps++;

        aProp[cProps].dwPropertyID = DBPROP_IRowsetWatchRegion;
        aProp[cProps].dwOptions = DBPROPOPTIONS_REQUIRED;
        aProp[cProps].dwStatus = 0;
        aProp[cProps].colid = dbcolNull;
        aProp[cProps].vValue.vt = VT_BOOL;
        aProp[cProps].vValue.boolVal = VARIANT_TRUE;

        aPropSet[cProps].rgProperties = &aProp[cProps];
        aPropSet[cProps].cProperties = 1;
        aPropSet[cProps].guidPropertySet = guidRowsetProps;

        cProps++;

        // don't timeout queries

        aProp[cProps].dwPropertyID = DBPROP_COMMANDTIMEOUT;
        aProp[cProps].dwOptions = DBPROPOPTIONS_OPTIONAL;
        aProp[cProps].dwStatus = 0;
        aProp[cProps].colid = dbcolNull;
        aProp[cProps].vValue.vt = VT_I4;
        aProp[cProps].vValue.lVal = 0;

        aPropSet[cProps].rgProperties = &aProp[cProps];
        aPropSet[cProps].cProperties = 1;
        aPropSet[cProps].guidPropertySet = guidRowsetProps;

        cProps++;

        // We can handle PROPVARIANTs

        aProp[cProps].dwPropertyID = DBPROP_USEEXTENDEDDBTYPES;
        aProp[cProps].dwOptions = DBPROPOPTIONS_OPTIONAL;
        aProp[cProps].dwStatus = 0;
        aProp[cProps].colid = dbcolNull;
        aProp[cProps].vValue.vt = VT_BOOL;
        aProp[cProps].vValue.boolVal = VARIANT_TRUE;

        aPropSet[cProps].rgProperties = &aProp[cProps];
        aPropSet[cProps].cProperties = 1;
        aPropSet[cProps].guidPropertySet = guidQueryExt;

        cProps++;

        if ( App.ForceUseCI() )
        {
            // Set the property that says we don't want to enumerate

            aProp[cProps].dwPropertyID = DBPROP_USECONTENTINDEX;
            aProp[cProps].dwOptions = DBPROPOPTIONS_OPTIONAL;
            aProp[cProps].dwStatus = 0;
            aProp[cProps].colid = dbcolNull;
            aProp[cProps].vValue.vt = VT_BOOL;
            aProp[cProps].vValue.boolVal = VARIANT_TRUE;

            aPropSet[cProps].rgProperties = &aProp[cProps];
            aPropSet[cProps].cProperties = 1;
            aPropSet[cProps].guidPropertySet = guidQueryExt;

            cProps++;
        }

        Win4Assert( MAX_PROPS >= cProps );

        sc = pCmdProp->SetProperties( cProps, aPropSet );

        if (FAILED (sc) || DB_S_ERRORSOCCURRED == sc )
            THROW( CException( sc ) );
    }

    if ( 0 != ulLimit || 0 != ulFirstRows )
    {
        static const DBID dbcolNull = { { 0,0,0, { 0,0,0,0,0,0,0,0 } },
                                        DBKIND_GUID_PROPID, 0 };
    
        DBPROP aRowsetProp[1];
        aRowsetProp[0].dwOptions = DBPROPOPTIONS_OPTIONAL;
        aRowsetProp[0].dwStatus = 0;
        aRowsetProp[0].colid = dbcolNull;
        aRowsetProp[0].dwPropertyID = (0 != ulLimit) ? DBPROP_MAXROWS : DBPROP_FIRSTROWS;
        aRowsetProp[0].vValue.vt = VT_I4;
        aRowsetProp[0].vValue.lVal = (LONG) (0 != ulLimit) ? ulLimit : ulFirstRows;
    
        DBPROPSET aPropSet[1];
        aPropSet[0].rgProperties = &aRowsetProp[0];
        aPropSet[0].cProperties = 1;
        aPropSet[0].guidPropertySet = DBPROPSET_ROWSET;
    
        XInterface<ICommandProperties> xICommandProperties;
        sc = pICommand->QueryInterface( IID_ICommandProperties,
                                        xICommandProperties.GetQIPointer() );
        if ( FAILED( sc ) )
            THROW( CException( sc ) );
    
        sc = xICommandProperties->SetProperties( 1,
                                                 aPropSet ); // the properties
        if (FAILED (sc) || DB_S_ERRORSOCCURRED == sc )
            THROW( CException( sc ) );
    }

    IRowsetScroll * pRowset;

    sc = pICommand->Execute( 0,                    // no aggr. IUnknown
                             IID_IRowsetScroll,    // IID for i/f to return
                             0,                    // dbparams
                             0,                    // chapter
                             (IUnknown **) & pRowset );  // Returned interface

    if ( FAILED(sc) )
    {
        // get the real error here

        ERRORINFO ErrorInfo;
        XInterface<IErrorInfo> xErrorInfo;
        SCODE sc2 = GetOleDBErrorInfo( pICommand,
                                       IID_ICommand,
                                       lcid,
                                       &ErrorInfo,
                                       xErrorInfo.GetPPointer() );

        // Post IErrorInfo only if we have a valid ptr to it.

        if (SUCCEEDED(sc2) && 0 != xErrorInfo.GetPointer())
            sc = ErrorInfo.hrError;

        THROW( CException(sc) );
    }

    _xRowset.Set( pRowset );

    IRowsetQueryStatus *pRowsetStatus;
    sc = _xRowset->QueryInterface( IID_IRowsetQueryStatus,
                                   (void**) &pRowsetStatus );
    if (SUCCEEDED( sc ) )
        _xRowsetStatus.Set( pRowsetStatus );

    IColumnsInfo *pColInfo = 0;
    sc = _xRowset->QueryInterface( IID_IColumnsInfo, (void **)&pColInfo );
    if (FAILED(sc))
        THROW( CException( sc ) );

    XInterface< IColumnsInfo > xColInfo( pColInfo );

    IAccessor *pIAccessor;
    sc = _xRowset->QueryInterface( IID_IAccessor, (void **)&pIAccessor );
    if (FAILED(sc))
        THROW (CException (sc));

    _xIAccessor.Set( pIAccessor );

    //
    // set up an accessor for bookmarks.
    //

    DBID acols[1];
    acols[0] = dbcolBookMark;
    DBORDINAL lcol;
    sc = pColInfo->MapColumnIDs(1, acols, &lcol);
    if (FAILED(sc))
        THROW (CException (sc));

    Win4Assert( 0 == lcol );
    aBmkColumn[0].iOrdinal = lcol;

    sc = _xIAccessor->CreateAccessor( DBACCESSOR_ROWDATA,
                                      1,
                                      aBmkColumn,
                                      0,
                                      &_hBmkAccessor,
                                      0 );

    if ( FAILED(sc) )
        THROW (CException (sc));

    SetupColumnMappingsAndAccessors();

    // Get a pointer to the IDBAsynchStatus for checking completion state

    IDBAsynchStatus *pDBAsynchStatus;
    sc = _xRowset->QueryInterface( IID_IDBAsynchStatus,
                                   (void**) &pDBAsynchStatus );

    if ( FAILED(sc) )
        THROW (CException (sc));

    _xDBAsynchStatus.Set( pDBAsynchStatus );
} //CSearchQuery

void CSearchQuery::InitNotifications(
    HWND hwndList)
{
    _hwndList = hwndList;

    _xWatch.Set( new CWatchQuery( this, _xRowset.GetPointer() ) );
    if (!_xWatch->Ok())
        _xWatch.Free();
    else
        _hRegion = _xWatch->Handle();
} //InitNotifications

CSearchQuery::~CSearchQuery()
{
    srchDebugOut((DEB_TRACE,"top of ~CSearchQuery()\n"));

    _xRowsetStatus.Free();

    //
    // make sure notification thread isn't stuck sleeping in our code
    // when we shut down notifications.  this is ok, but will cause
    // an unnecessary delay in shutting down the query.
    //

    if ( !_xWatch.IsNull() )
        _xWatch->IgnoreNotifications( TRUE );

    _xDBAsynchStatus.Free();

    _xWatch.Free();

    if ( !_xIAccessor.IsNull() )
    {
        if (_hAccessor)
            _xIAccessor->ReleaseAccessor( _hAccessor, 0 );

        if ( _hBmkAccessor )
            _xIAccessor->ReleaseAccessor( _hBmkAccessor, 0 );

        if ( _hBrowseAccessor )
            _xIAccessor->ReleaseAccessor( _hBrowseAccessor, 0 );

        _xIAccessor.Free();
    }

    if ( !_xRowset.IsNull() )
    {
        srchDebugOut((DEB_TRACE,"~ Releasing %d rows, first %d\n",_cHRows,_aHRows[0]));

        _xRowset->ReleaseRows(_cHRows, _aHRows, 0, 0, 0);
        _xRowset.Free();
    }

    srchDebugOut(( DEB_TRACE, "bottom of ~CSearchQuery()\n" ));
} //~CSearchQuery

BOOL CSearchQuery::ListNotify(
    HWND   hwnd,
    WPARAM action,
    long * pDist)
{
    BOOL fRet = TRUE;

    CWaitCursor wait;

    switch (action)
    {
        case listScrollLineUp:
            ScrollLineUp (pDist);
            break;
        case listScrollLineDn:
            ScrollLineDn (pDist);
            break;
        case listScrollPageUp:
            ScrollPageUp (pDist);
            break;
        case listScrollPageDn:
            ScrollPageDn (pDist);
            break;
        case listScrollTop:
            ScrollTop (pDist);
            break;
        case listScrollBottom:
            ScrollBottom (pDist);
            break;
        case listScrollPos:
            ScrollPos (pDist);
            break;
        case listSize:
            fRet = WindowResized (*(ULONG*)pDist);
            break;
        case listSelect:
            return Select (pDist);
            break;
        case listSelectUp:
            fRet = SelectUp( pDist );
            break;
        case listSelectDown:
            fRet = SelectDown( pDist );
            break;
        default:
            Win4Assert (!"Unknown action in CSearchQuery::Scroll");
    }
    return fRet;
} //ListNotify

long CSearchQuery::FindSelection()
{
    long iSel;

    if (IsSelected())
    {
        // Find out what is selected
        for (ULONG i = 0; i < _cHRows; i++)
            if (IsSelected(i))
                break;
        if (i == _cHRows)
            iSel = -1;
        else
            iSel = i;
    }
    else
    {
        iSel = -1;
    }

    return iSel;
} //FindSelection

BOOL CSearchQuery::SelectUp(
    long * piNew )
{
    *piNew = FindSelection();

    if ( -1 == *piNew || 0 == *piNew )
        return FALSE;

    (*piNew)--;

    GetBookMark( _aHRows[ *piNew ], _bmkSelect );

    return TRUE;
} //SelectUp

BOOL CSearchQuery::SelectDown(
    long * piNew )
{
    *piNew = FindSelection();

    if ( ( -1 == *piNew ) || ( *piNew == (long) ( _cHRows - 1) ) )
        return FALSE;

    (*piNew)++;

    GetBookMark( _aHRows[ *piNew ], _bmkSelect );

    return TRUE;
} //SelectDown

BOOL CSearchQuery::Select(
    long* piRow )
{
    ULONG newRow = *piRow;

    if (newRow >= _cHRows)
    {
        return FALSE;
    }

    *piRow = FindSelection();

    if (*piRow != (long)newRow)
        GetBookMark (_aHRows[newRow], _bmkSelect);
#if 0
    else
        _bmkSelect.Invalidate();
#endif

    return TRUE;
} //Select

BOOL CSearchQuery::IsSelected(
    UINT iRow )
{
    if (iRow >= _cHRows)
        return FALSE;
    CBookMark bmk;
    GetBookMark (_aHRows[iRow], bmk);
    return bmk.IsEqual (_bmkSelect);
} //IsSelected

BOOL CSearchQuery::WindowResized(
    ULONG & cRows)
{
    BOOL fInvalidate = FALSE;

    if (cRows < _cHRows)
    {
        if ( !_xWatch.IsNull() )
            _xWatch->Shrink (_hRegion, _bmkTop, cRows);
        _xRowset->ReleaseRows(_cHRows - cRows, _aHRows + cRows, 0, 0, 0);
        for (ULONG i = cRows; i < _cHRows; i++)
            _aHRows[i] = 0;

        _cHRows = cRows;
    }
    else if (cRows > _cHRows)
    {
        if (cRows > cMaxRowCache)
            cRows = cMaxRowCache;

        CBookMark bmk;
        long cSkip;
        if (_cHRows == 0)
        {
            cSkip = 0;
            bmk.MakeFirst();
        }
        else
        {
            cSkip = 1;
            GetBookMark (_aHRows[_cHRows-1], bmk);
        }
        DBCOUNTITEM cRowsFetched = 0;
        if ( !_xWatch.IsNull() )
            _xWatch->Extend (_hRegion);

        ULONG cRowsNeeded = cRows - _cHRows;
        FetchResult res = Fetch ( bmk, cSkip, cRowsNeeded, cRowsFetched, _aHRows + _cHRows, _hRegion);

        if ( cRowsFetched )
        {
            _cHRows += (ULONG) cRowsFetched;
            cRowsNeeded -= (ULONG) cRowsFetched;
        }

        if ( cRowsNeeded && _cHRows < _cRowsTotal )
        {
            // looks like we are at the ned
            // try to get rows from the top to fill up new space

            fInvalidate = TRUE;

            Win4Assert( fetchBoundary == res );

            if ( cRowsNeeded > _cRowsTotal - _cHRows )
            {
                cRowsNeeded = (ULONG) ( _cRowsTotal - _cHRows );
            }

            _cRowsDisp = cRows; // need to set this here before PageUp

            ScrollPageUp( (long*) &cRowsNeeded );
        }
    }
    _cRowsDisp = cRows;
    cRows = _cHRows;

    // return TRUE if an invalidate is needed or FALSE if just updating
    // the scroll bars is sufficient.

    return fInvalidate;
} //WindowResized

void CSearchQuery::ScrollLineUp(
    long * pDist)
{
    if (_cHRows == 0)
    {
        *pDist = 0;
        return;
    }
    // Try to fetch new first row
    HROW hrow;
    CBookMark bmk;
    GetBookMark (_aHRows[0], bmk);
    DBCOUNTITEM cRowsFetched = 0;
    if ( !_xWatch.IsNull() )
        _xWatch->Move (_hRegion);
    FetchResult res = Fetch ( bmk, -1, 1, cRowsFetched, &hrow, _hRegion);

    if ( isFetchOK( res ) && cRowsFetched == 1)
    {
        if (_cHRows == _cRowsDisp)
        {
            // Release last row
            _xRowset->ReleaseRows (1, _aHRows + _cHRows - 1, 0, 0, 0);
        }
        else
        {
            _cHRows++;
        }
        // shift all rows down
        for (ULONG i = _cHRows - 1; i > 0; i--)
            _aHRows [i] = _aHRows [i-1];
        _aHRows [0] = hrow;
        GetBookMark (hrow, _bmkTop);
    }
    else
    {
        *pDist = 0;
        _bmkTop.MakeFirst();
    }
} //ScrollLineUp

void CSearchQuery::ScrollLineDn(
    long* pDist)
{
    if (_cHRows < _cRowsDisp || _cHRows == 0)
    {
        // can't scroll
        *pDist = 0;
    }
    else
    {
        // Try to fetch new last row
        HROW hrow;
        CBookMark bmk;
        GetBookMark (_aHRows[_cHRows-1], bmk);
        DBCOUNTITEM cRowsFetched = 0;
        if ( !_xWatch.IsNull() )
            _xWatch->Move( _hRegion );
        FetchResult res = Fetch ( bmk, 1, 1, cRowsFetched, &hrow, _hRegion);
        if ( ( isFetchOK( res )  ) && ( 1 == cRowsFetched ) )
        {
            // release zeroth row
            _xRowset->ReleaseRows (1, _aHRows, 0, 0, 0);
            // shift all rows up
            for (ULONG i = 0; i < _cHRows - 1; i++)
                _aHRows [i] = _aHRows [i+1];
            // if we fetched the row
            if (cRowsFetched == 1)
                _aHRows [_cHRows - 1] = hrow;
            GetBookMark (_aHRows[0], _bmkTop);
        }
        else *pDist = 0;
    }
} //ScrollLineDn

void CSearchQuery::ScrollPageUp(
    long* pDist)
{
    if (_cHRows == 0)
    {
        *pDist = 0;
        return;
    }

    // Try to fetch new first rows
    CBookMark bmk;
    GetBookMark (_aHRows[0], bmk);
    DBCOUNTITEM cRowsFetched = 0;
    long count = *pDist;
    FetchResult res;

    if ( !_xWatch.IsNull() )
        _xWatch->Move( _hRegion );
    res = Fetch ( bmk, -count, count, cRowsFetched, _aHRowsTmp, _hRegion);

    *pDist = (long) cRowsFetched;

    if ( isFetchOK( res ) && cRowsFetched != 0)
    {
        // release rows at the end
        int cRowsToRelease = (int) ( _cHRows + cRowsFetched - _cRowsDisp );
        int cRowsToShift   = (int) ( _cRowsDisp - cRowsFetched );

        _cHRows += (ULONG) cRowsFetched;

        if (cRowsToRelease > 0)
        {
            Win4Assert ( cRowsToShift >= 0);
            _xRowset->ReleaseRows (cRowsToRelease,
                                   _aHRows + cRowsToShift, 0, 0, 0);
            _cHRows -= cRowsToRelease;
        }

        if (cRowsToShift > 0)
        {
            for (int i = 0; i < cRowsToShift; i++)
                _aHRowsTmp[cRowsFetched + i] = _aHRows[i];
        }

        for (ULONG i = 0; i < _cRowsDisp; i++)
            _aHRows[i] = _aHRowsTmp[i];

        if (res == fetchBoundary)
            _bmkTop.MakeFirst();
        else
            GetBookMark (_aHRows[0], _bmkTop);
    }
} //ScrollPageUp

void CSearchQuery::ScrollPageDn(
    long* pDist)
{
    if (_cHRows < _cRowsDisp || _cHRows == 0)
    {
        // can't scroll
        *pDist = 0;
    }
    else
    {
        // Try to fetch new bottom rows
        CBookMark bmk;
        GetBookMark (_aHRows[_cHRows-1], bmk);
        DBCOUNTITEM cRowsFetched = 0;

        if ( !_xWatch.IsNull() )
            _xWatch->Move( _hRegion );

        FetchResult res = Fetch ( bmk, 1, *pDist, cRowsFetched, _aHRowsTmp, _hRegion);
        *pDist = (long) cRowsFetched;

        if ( isFetchOK( res )  && ( cRowsFetched > 0 ) )
        {
            int cRowsToRelease = (int) ( cRowsFetched + _cHRows - _cRowsDisp );
            int cRowsToShift   = (int) ( _cRowsDisp - cRowsFetched );

            // release top rows
            _xRowset->ReleaseRows (cRowsToRelease, _aHRows, 0, 0, 0);

            // shift all rows up
            for (int i = 0; i < cRowsToShift; i++)
                _aHRows [i] = _aHRows [i+cRowsToRelease];

            for (ULONG j = 0; j < cRowsFetched; j++)
                _aHRows [cRowsToShift + j] = _aHRowsTmp[j];

            _cHRows = (ULONG) ( cRowsToShift + cRowsFetched );

            GetBookMark (_aHRows[0], _bmkTop);
        }
    }
} //ScrollPageDn

void CSearchQuery::ScrollBottom(
    long* pDist)
{
    CBookMark bmk(DBBMK_LAST);
    DBCOUNTITEM cRowsFetched = 0;

    if ( !_xWatch.IsNull() )
        _xWatch->Move (_hRegion);

    FetchResult res = Fetch ( bmk, 1 - *pDist, *pDist, cRowsFetched, _aHRowsTmp, _hRegion);

    if ( isFetchOK( res ) )
    {
        _xRowset->ReleaseRows(_cHRows, _aHRows, 0, 0, 0);
        for (ULONG i = 0; i < cRowsFetched; i++)
            _aHRows[i] = _aHRowsTmp[i];
        for (; i < _cHRows; i++)
            _aHRows[i] = 0;
        _cHRows = (ULONG) cRowsFetched;
        *pDist = (long) cRowsFetched;
        GetBookMark (_aHRows[0], _bmkTop);
    }
} //ScrollBottom

void CSearchQuery::ScrollTop(
    long* pDist)
{
    CBookMark bmk(DBBMK_FIRST);

    DBCOUNTITEM cRowsFetched = 0;
    if ( !_xWatch.IsNull() )
        _xWatch->Move (_hRegion);
    FetchResult res = Fetch ( bmk, 0, *pDist, cRowsFetched, _aHRowsTmp, _hRegion);

    if ( isFetchOK( res ) )
    {
        _xRowset->ReleaseRows(_cHRows, _aHRows, 0, 0, 0);
        for (ULONG i = 0; i < cRowsFetched; i++)
            _aHRows[i] = _aHRowsTmp[i];
        for (; i < _cHRows; i++)
            _aHRows[i] = 0;
        _cHRows = (ULONG) cRowsFetched;
        *pDist = (long) cRowsFetched;
    }
    _bmkTop.MakeFirst();
} //ScrollTop

void CSearchQuery::ScrollPos(
    long* pDist)
{
    DBCOUNTITEM cRowsFetched = 0;

    if ( !_xWatch.IsNull() )
        _xWatch->Move (_hRegion);

    if (FetchApprox (*pDist, _cRowsDisp, cRowsFetched, _aHRowsTmp, _hRegion))
    {
        _xRowset->ReleaseRows(_cHRows, _aHRows, 0, 0, 0);
        for (ULONG i = (ULONG) cRowsFetched; i < _cHRows; i++)
            _aHRows[i] = 0;

        for (i = 0; i < cRowsFetched; i++)
            _aHRows [i] = _aHRowsTmp [i];
        _cHRows = (ULONG) cRowsFetched;

        CBookMark bmk;
        GetBookMark (_aHRowsTmp[0], bmk);
        _xRowset->GetApproximatePosition(0, bmk.cbBmk, bmk.abBmk, &_iRowCurrent, &_cRowsTotal);

        if (_iRowCurrent > 0)
            _iRowCurrent--;

        *pDist = (long) _iRowCurrent;
        GetBookMark (_aHRows[0], _bmkTop);
    }
    else
        *pDist = -1;
} //ScrollPos


void CSearchQuery::InvalidateCache()
{
    ULONG cRows = _cRowsDisp;
    ULONG zero = 0;
    WindowResized (zero);
    WindowResized (cRows);
} //InvalidateCache

void CSearchQuery::UpdateProgress(
    BOOL& fMore)
{
    if ( _xRowset.IsNull() )
    {
        _pctDone = 0;
        return;
    }

#if 0
    if ( !_xRowsetStatus.IsNull() )
    {
        ULONG ulNumerator,ulDenominator;
        DWORD cFilteredDocs,cDocsToFilter;
        SCODE sc;
        if ( 0 != _cHRows )
        {
            sc = _xRowsetStatus->GetStatusEx( &_dwQueryStatus,
                                              &cFilteredDocs,
                                              &cDocsToFilter,
                                              &ulDenominator,
                                              &ulNumerator,
                                              _bmkTop.cbBmk,
                                              _bmkTop.abBmk,
                                              &_iRowCurrent,
                                              &_cRowsTotal );
            _iRowCurrent--;      // zero base
        }
        else
        {
            DWORD current;
            sc = _xRowsetStatus->GetStatusEx( &_dwQueryStatus,
                                              &cFilteredDocs,
                                              &cDocsToFilter,
                                              &ulDenominator,
                                              &ulNumerator,
                                              0,
                                              0,
                                              &current,
                                              &_cRowsTotal );
        }

        if ( FAILED( sc ) )
        {
            // query failed when we weren't looking

            _pctDone = 100;
            _iRowCurrent = 0;
            _cRowsTotal = 0;
            _fDone = TRUE;
            _dwQueryStatus = STAT_ERROR;
            _scLastError = sc;
        }
        else
        {
            Win4Assert( ulNumerator <= ulDenominator );

            _pctDone = 100 * ulNumerator;
            if ( 0 == ulDenominator )       // Prevent division by 0
                ulDenominator = 1;
            _pctDone /= ulDenominator;
        }
    }
    else
#endif // 0
    {
        DBCOUNTITEM ulNumerator, ulDenominator;
        DBASYNCHPHASE ulAsynchPhase;
        SCODE sc = _xDBAsynchStatus->GetStatus( DB_NULL_HCHAPTER,
                                                DBASYNCHOP_OPEN,
                                                &ulNumerator,
                                                &ulDenominator,
                                                &ulAsynchPhase,
                                                0 );

        if ( FAILED( sc ) )
        {
            // query failed when we weren't looking

            _pctDone = 100;
            _iRowCurrent = 0;
            _cRowsTotal = 0;
            _fDone = TRUE;
        }
        else
        {
            if ( !_xRowsetStatus.IsNull() )
                _xRowsetStatus->GetStatus( &_dwQueryStatus );

            Win4Assert( (ulAsynchPhase == DBASYNCHPHASE_COMPLETE) ?
                             (ulNumerator == ulDenominator) :
                             (ulNumerator <  ulDenominator) );

            _pctDone = 100 * (ULONG) ulNumerator;
            if ( 0 == ulDenominator )       // Prevent division by 0
                ulDenominator = 1;
            _pctDone /= (ULONG) ulDenominator;

            if (_cHRows != 0)
            {
                _xRowset->GetApproximatePosition( 0,
                                                  _bmkTop.cbBmk,
                                                  _bmkTop.abBmk,
                                                  &_iRowCurrent,
                                                  &_cRowsTotal );
                _iRowCurrent--;      // zero base
            }
            else
            {
                _xRowset->GetApproximatePosition(0, 0, 0, 0, &_cRowsTotal);
            }
        }
    }
} //UpdateProgress

void CSearchQuery::ProcessNotification(
    HWND          hwndList,
    DBWATCHNOTIFY changeType,
    IRowset *     pRowset)
{
    if ( _xRowset.GetPointer() == pRowset && !_xWatch.IsNull() )
        _xWatch->Notify( hwndList, changeType );
    _dwEndTime = GetTickCount();
} //ProcessNotification

void CSearchQuery::ProcessNotificationComplete()
{
    if ( !_xWatch.IsNull() )
        _xWatch->NotifyComplete();
} //ProcessNotificationComplete

void CSearchQuery::CreateScript(
    DBCOUNTITEM *       pcChanges,
    DBROWWATCHCHANGE ** paScript)
{
    if (_cRowsDisp == 0)
    {
        *pcChanges = 0;
        return;
    }

    Win4Assert (_cHRows == 0 || _aHRows[_cHRows-1] != 0);

    *paScript = (DBROWWATCHCHANGE*) CoTaskMemAlloc (2 * _cRowsDisp * sizeof DBROWWATCHCHANGE);

    DBCOUNTITEM cRowsFetched = 0;
    if ( !_xWatch.IsNull() )
        _xWatch->Move (_hRegion);
    //srchDebugOut((DEB_TRACE,"CreateScript fetch\n"));
    Fetch ( _bmkTop, 0, _cRowsDisp, cRowsFetched, _aHRowsTmp, _hRegion);

    if (cRowsFetched > 0)
    {
        //srchDebugOut((DEB_TRACE,"  CreateScript fetched %d rows\n",cRowsFetched));
        ULONG iSrc = 0;
        ULONG iDst = 0;

        do
        {
            if ( iDst == _cHRows || _aHRows[iDst] != _aHRowsTmp [iSrc])
            {
                // maybe the current iDst row was deleted?
                // Find out it the iSrc row appears
                // somewhere after the current row
                for (ULONG i = iDst + 1; i < _cHRows; i++)
                {
                    if (_aHRows[i] == _aHRowsTmp[iSrc])
                        break;
                }

                if (i < _cHRows && iSrc < _cRowsDisp )
                {
                    // everything from iDst up to i - 1
                    // has been deleted
                    while ( iDst < i )
                    {
                        DBROWWATCHCHANGE& change = (*paScript)[*pcChanges];
                        change.hRegion = _hRegion;
                        change.eChangeKind = DBROWCHANGEKIND_DELETE;
                        change.iRow = iSrc;
                        change.hRow =  0;
                        (*pcChanges)++;
                        iDst++;
                    }
                }
                else
                {
                    // insertion
                    DBROWWATCHCHANGE& change = (*paScript)[*pcChanges];
                    change.hRegion = _hRegion;
                    change.eChangeKind = DBROWCHANGEKIND_INSERT;
                    change.iRow = iSrc - 1;
                    change.hRow =  _aHRowsTmp[iSrc];
                    (*pcChanges)++;
                    iSrc++;
                }
            }
            else
            {
                //srchDebugOut((DEB_TRACE,"  CreateScript ignoring row %d\n",_aHRowsTmp[iSrc]));
                _xRowset->ReleaseRows ( 1, _aHRowsTmp + iSrc, 0, 0, 0);
                iDst++;
                iSrc++;
            }


        } while (iDst < _cRowsDisp && iSrc < cRowsFetched);

        if ( iSrc < cRowsFetched )
        {
            //srchDebugOut((DEB_TRACE,"  CreateScript freeing rows left behind\n"));
            _xRowset->ReleaseRows ( cRowsFetched - iSrc,
                                    _aHRowsTmp + iSrc,
                                    0, 0, 0);
        }
        else if (iSrc == cRowsFetched && iSrc < _cRowsDisp)
        {
            // the rest of the rows were deleted
            while (iDst < _cHRows)
            {
                DBROWWATCHCHANGE& change = (*paScript)[*pcChanges];
                change.hRegion = _hRegion;
                change.eChangeKind = DBROWCHANGEKIND_DELETE;
                change.iRow = iSrc;
                change.hRow =  0;
                (*pcChanges)++;
                iDst++;
            }
        }
    }

    if (*pcChanges == 0)
    {
        CoTaskMemFree (*paScript);
        *paScript = 0;
    }
} //CreateScript

void CSearchQuery::InsertRowAfter(
    int iRow,
    HROW hrow)
{
    Win4Assert (iRow >= -1 && iRow < (int) _cHRows && iRow < (int)_cRowsDisp - 1);

    int iLastRow = _cHRows - 1;
    // release last row
    if (_cHRows == _cRowsDisp)
    {
        //srchDebugOut((DEB_TRACE,"InsertRowAfter releasing 1 row %d\n",_aHRows[iLastRow]));
        _xRowset->ReleaseRows(1, _aHRows + iLastRow, 0, 0, 0);
        // shift rows down
        for (int i = iLastRow; i > iRow + 1; i--)
        {
            _aHRows [i] = _aHRows [i-1];
        }
    }
    else
    {
        // shift rows down
        for (int i = iLastRow + 1; i > iRow + 1; i--)
        {
            _aHRows [i] = _aHRows [i-1];
        }
        _cHRows++;
    }
    _aHRows [iRow + 1] = hrow;
    if (iRow == -1 && !_bmkTop.IsFirst())
    {
        GetBookMark (_aHRows[0], _bmkTop);
    }
} //InsertRowAfter

void CSearchQuery::DeleteRow(
    int iRow)
{
// with limited rows, rows to be deleted may exceed the number of
//          rows in the result
    //Win4Assert (iRow >= 0 && iRow < (int)_cHRows);

    if ( _aHRows[iRow] > 0 )
    {
        _xRowset->ReleaseRows (1, _aHRows + iRow, 0, 0, 0);
        _aHRows[iRow] = 0;
    }

    // shift  rows up
    for (ULONG i = iRow; i < _cHRows - 1; i++)
        _aHRows [i] = _aHRows [i+1];
#if 0
    if (_cHRows < _cRowsDisp)
    {
        _aHRows[_cHRows-1] = 0;
        _cHRows--;
    }
    else
    {
        // Try to fetch new last row
        HROW hrow;
        CBookMark bmk;
        GetBookMark (_aHRows[_cHRows-1], bmk);
        DBCOUNTITEM cRowsFetched = 0;
        // no need when running script
        if ( !_xWatch.IsNull() )
            _xWatch->Move (_hRegion);
        FetchResult res = Fetch ( bmk, 1, 1, cRowsFetched, &hrow, _hRegion);

        if ( isFetchOK( res ) && ( cRowsFetched > 0 ) )
            _xRowset->ReleaseRows(1, &hrow, 0, 0, 0);
    }
#else
    if ( (ULONG)iRow < _cHRows )
    {
        _aHRows[_cHRows-1] = 0;
        _cHRows--;
    }
#endif
    if (iRow == 0 && !_bmkTop.IsFirst() && _aHRows[0] != 0)
        GetBookMark (_aHRows[0], _bmkTop);
} //DeleteRow

void CSearchQuery::UpdateRow(
    int iRow,
    HROW hrow)
{
    Win4Assert (iRow >= 0 && iRow < (int)_cHRows);
    //srchDebugOut((DEB_TRACE,"UpdateRowAfter releasing 1 row %d\n",_aHRows[iRow]));
    _xRowset->ReleaseRows (1, _aHRows + iRow, 0, 0, 0);
    _aHRows[iRow] = hrow;
} //UpdateRow

BOOL CSearchQuery::GetSelectedRowData(
    WCHAR *&rpPath,
    HROW &hrow )
{
    if (!_bmkSelect.IsValid())
        return FALSE;

    DBCOUNTITEM cRowsFetched = 0;
    FetchResult res = Fetch ( _bmkSelect, 0, 1, cRowsFetched, &hrow, 0);

    if ( ( !isFetchOK( res ) ) || ( cRowsFetched != 1 ) )
        return FALSE;

    return SUCCEEDED( _xRowset->GetData( hrow, _hBrowseAccessor, &rpPath ) );

} //GetSelectedRowData

void CSearchQuery::FreeSelectedRowData(
    HROW hrow )
{
   _xRowset->ReleaseRows( 1, &hrow, 0, 0, 0 );
} //FreeSelectedRowData

BOOL CSearchQuery::Browse( enumViewFile eViewType )
{
    BOOL fOK = TRUE;

    if (!_bmkSelect.IsValid())
        return TRUE;

    HROW hrow;
    DBCOUNTITEM cRowsFetched = 0;
    FetchResult res = Fetch( _bmkSelect, 0, 1, cRowsFetched, &hrow, 0 );

    if ( ( !isFetchOK( res ) ) || ( cRowsFetched != 1 ) )
        return fOK;

    WCHAR *pwcPathFound;
    SCODE sc = _xRowset->GetData( hrow, _hBrowseAccessor, &pwcPathFound );

    if (SUCCEEDED(sc) && ( 0 != _prstQuery ) )
    {
        fOK = ViewFile( pwcPathFound, eViewType, 1, _prstQuery );
        _xRowset->ReleaseRows(1, &hrow, 0, 0, 0);
    }
    else
        fOK = FALSE;

    return fOK;
} //Browse

//
// Helper method(s)
//

void CSearchQuery::ParseCatList( WCHAR * * aScopes, WCHAR * * aCatalogs,
                                 WCHAR * * aMachines, DWORD * aDepths,
                                 ULONG & cScopes )
{
    BOOL fDeep;
    WCHAR aScope[MAX_PATH];
    WCHAR aCatalog[MAX_PATH];
    WCHAR aMachine[MAX_PATH];

    for(cScopes = 0; ; cScopes++)
    {
        if ( !GetCatListItem( _xCatList,
                             cScopes,
                             aMachine,
                             aCatalog,
                             aScope,
                             fDeep ) )
        {
            break;
        }
        aMachines[cScopes] = new WCHAR[ wcslen( aMachine ) + 1 ];
        aCatalogs[cScopes] = new WCHAR[ wcslen( aCatalog ) + 1 ];
        aScopes[cScopes] = new WCHAR[ wcslen( aScope ) + 1 ];

        wcscpy( aMachines[cScopes], aMachine );
        wcscpy( aCatalogs[cScopes], aCatalog );
        wcscpy( aScopes[cScopes], aScope );

        aDepths[cScopes] = ( fDeep ? QUERY_DEEP : QUERY_SHALLOW );

        // If the scope is virtual, set the flag and flip the slashes

        if ( L'/' == aScope[0] )
        {
            aDepths[ cScopes ] |= QUERY_VIRTUAL_PATH;
            for ( WCHAR *p = aScopes[cScopes]; *p; p++ )
                if ( L'/' == *p )
                    *p = L'\\';
        }
    }
}

SCODE CSearchQuery::InstantiateICommand(
    ICommand ** ppICommand )
{
    DWORD aDepths[ 20 ]; // hope 20 is big enough
    WCHAR * aScopes[ 20 ];
    WCHAR * aCatalogs[ 20 ];
    WCHAR * aMachines[ 20 ];
    ULONG cScopes = 0;

    SCODE sc = S_FALSE;

    ParseCatList( aScopes, aCatalogs, aMachines, aDepths, cScopes );

    *ppICommand = 0;

    sc = CIMakeICommand( ppICommand,
                         cScopes,
                         aDepths,
                         (WCHAR const * const *)aScopes,
                         (WCHAR const * const *)aCatalogs,
                         (WCHAR const * const *)aMachines );

    unsigned ii;
    for( ii = 0; ii < cScopes; ii ++)
    {
        delete [] aMachines[ii]; // This mem may not get deleted if we throw
        delete [] aCatalogs[ii]; // in this func ?
        delete [] aScopes[ii];
    }

    return sc;
} //InstantiateICommand


BOOL CSearchQuery::FetchApprox(
    LONG iFirstRow,
    LONG cToFetch,
    DBCOUNTITEM &rcFetched,
    HROW *pHRows,
    HWATCHREGION hRegion)
{
    SCODE sc;

    if ( 0 != _cRowsTotal )
    {
        sc = _xRowset->GetRowsAtRatio( hRegion,
                                       0,      // no chapters
                                       iFirstRow,
                                       _cRowsTotal,
                                       cToFetch,
                                       &rcFetched,
                                       &pHRows );
        if ( FAILED( sc ) )
            _scLastError = sc;
    }
    else
    {
        rcFetched = 0;

        sc = S_OK;
    }

    return (SUCCEEDED(sc) && rcFetched);
} //FetchApprox

FetchResult CSearchQuery::Fetch(
    CBookMark &   bmkStart,
    LONG          iFirstRow,
    LONG          cToFetch,
    DBCOUNTITEM & rcFetched,
    HROW *        pHRows,
    HWATCHREGION  hRegion)
{
    //srchDebugOut((DEB_TRACE,"  Fetch fetch\n"));

    Win4Assert (bmkStart.IsValid());

    SCODE scTmp;

    SCODE sc = _xRowset->GetRowsAt( hRegion,
                                    0,   // no chapters
                                    bmkStart.cbBmk,
                                    bmkStart.abBmk,
                                    iFirstRow,
                                    cToFetch,
                                    &rcFetched,
                                    &pHRows );
    WCHAR* szError = 0;
    WCHAR  buf[100];

    if ( FAILED( sc ) )
        _scLastError = sc;

    switch (sc)
    {
        case S_OK:
            //srchDebugOut((DEB_TRACE,"  ::fetch ok got %d rows, first: %d\n",rcFetched,pHRows[0]));
            if (cToFetch == (long)rcFetched)
                return fetchOk;
            else
                szError = L"Incomplete Fetch returned S_OK";
            break;

        case DB_S_ENDOFROWSET:
            //srchDebugOut((DEB_TRACE,"  ::fetch EOR got %d rows, first: %d\n",rcFetched,pHRows[0]));

            // Debugging
            // Turn it back on when we have frozen state!
            //
            if ( FALSE && rcFetched != 0)
            {
                HROW* pHRowsTmp = new HROW [cToFetch];
                DBCOUNTITEM cFetchedTmp = 0;
                CBookMark bmk;
                GetBookMark (pHRows[0], bmk);
                scTmp = _xRowset->GetRowsAt( hRegion,
                                             0,         // no chapters
                                             bmk.cbBmk,
                                             bmk.abBmk,
                                             0,
                                             cToFetch,
                                             &cFetchedTmp,
                                             &pHRowsTmp );
                if (FAILED(scTmp))
                {
                    szError = buf;
                    swprintf (buf, L"Repeated call returned error 0x%04x", scTmp);
                }
                else if (cFetchedTmp < rcFetched)
                {
                    szError = L"Repeated call returned fewer rows";
                }
                else
                {

                    for (ULONG i = 0; i < rcFetched; i++)
                    {
                        if (pHRows[i] != pHRowsTmp[i])
                        {
                            szError = L"Repeated call returned different HROWs";
                            break;
                        }
                    }

                }
                _xRowset->ReleaseRows(cFetchedTmp, pHRowsTmp, 0, 0, 0);
                delete pHRowsTmp;
                if (szError != 0)
                    break;
            }
            return fetchBoundary;

        case DB_E_BADSTARTPOSITION:
            //srchDebugOut((DEB_TRACE,"  ::fetch %d returned DB_E_BADSTARTPOSITION \n",cToFetch));
            //Win4Assert(sc != DB_E_BADSTARTPOSITION);
            szError = L"DB_E_BADSTARTPOSITION";
            break;
        case DB_S_BOOKMARKSKIPPED:
            szError = L"DB_S_BOOKMARKSKIPPED";
            break;
        case DB_S_ROWLIMITEXCEEDED:
            szError = L"DB_S_ROWLIMITEXCEEDED";
            break;
        case DB_E_BADBOOKMARK:
            szError = L"DB_E_BADBOOKMARK";
            break;
        case DB_E_BADCHAPTER:
            szError = L"DB_E_BADCHAPTER";
            break;
        case DB_E_NOTREENTRANT:
            szError = L"DB_E_NOTREENTRANT";
            break;
        case E_FAIL:
            szError = L"E_FAIL";
            break;
        case E_INVALIDARG:
            szError = L"E_INVALIDARG";
            break;
        case E_OUTOFMEMORY:
            szError = L"E_OUTOFMEMORY";
            break;
        case E_UNEXPECTED:
            szError = L"E_UNEXPECTED";
            break;
        default:
            szError = buf;
            swprintf (buf, L"Unexpected error 0x%04x", sc);
    }
    //MessageBox ( 0, szError, L"GetRowsAt", MB_OK );
    return fetchError;
} //Fetch

const unsigned cAtATime = 20;

void CSearchQuery::WriteResults()
{
    CBookMark bmk(DBBMK_FIRST);
    XArray<HROW> xRows( cAtATime );
    ULONG cRowsToGo = (ULONG) _cRowsTotal;
    CDynArrayInPlace<WCHAR> awcBuf( 4096 );
    int cwc = 0;

    while ( 0 != cRowsToGo )
    {
        DBCOUNTITEM cFetched = 0;
        FetchResult res = Fetch( bmk,
                                 (LONG) ( _cRowsTotal - cRowsToGo ),
                                 __min( cAtATime, cRowsToGo ),
                                 cFetched,
                                 xRows.GetPointer(),
                                 0 );

        if ( ( fetchError == res ) ||
             ( 0 == cFetched ) )
            return;

        cRowsToGo -= (ULONG) cFetched;

        for ( ULONG row = 0; row < cFetched; row++ )
        {
            WCHAR *pwcPath;
            _xRowset->GetData( xRows[ row ], _hBrowseAccessor, &pwcPath );

            while ( *pwcPath )
                awcBuf[ cwc++ ] = *pwcPath++;

            awcBuf[ cwc++ ] = L'\r';
            awcBuf[ cwc++ ] = L'\n';
        }

        _xRowset->ReleaseRows( cFetched, xRows.GetPointer(), 0, 0, 0 );
    }

    awcBuf[ cwc++ ] = 0;
    PutInClipboard( awcBuf.Get() );
} //WriteResults

const unsigned COUNT_HIDDEN_COLUMNS = 1;

void CSearchQuery::SetupColumnMappingsAndAccessors()
{
    // allocate the necessary resources

    unsigned cColumns = _columns.NumberOfColumns();
    DBID aDbCols[maxBoundCols];

    for ( unsigned iCol = 0; iCol < cColumns; iCol++ )
    {
        // Get the next desired property

        DBTYPE propType;
        unsigned int uiWidth;
        DBID *pdbid;
        SCODE sc = _columnMapper.GetPropInfoFromName( _columns.GetColumn( iCol ),
                                                      &pdbid,
                                                      &propType,
                                                      &uiWidth );
        memcpy( &aDbCols[ iCol ], pdbid, sizeof DBID );

        if (FAILED(sc))
            THROW( CException( sc ) );
    }

    IColumnsInfo *pColInfo = 0;

    SCODE sc = _xRowset->QueryInterface ( IID_IColumnsInfo,
                                          ( void ** )&pColInfo );
    if (FAILED(sc))
        THROW( CException( sc ) );

    XInterface< IColumnsInfo > xColInfo( pColInfo );

    DBORDINAL aColumnIds[ maxBoundCols ];

    // Map the columns
    sc = pColInfo->MapColumnIDs( cColumns, aDbCols, aColumnIds );

    if (FAILED(sc))
        THROW (CException (sc));

    // Map hidden columns

    DBID apsHidden[COUNT_HIDDEN_COLUMNS];

    apsHidden[0] = dbcolPath;

    DBORDINAL aColumnIdHidden[COUNT_HIDDEN_COLUMNS];

    sc = pColInfo->MapColumnIDs( 1,
                                 apsHidden,
                                 aColumnIdHidden );
    if (FAILED(sc))
        THROW (CException (sc));

    // allocate the necessary resources and cache in the
    // object

    DBBINDING aGenBindings[maxBoundCols];
    ULONG oCurrentOffset = 0;

    // Add each requested property to the binding

    for ( unsigned iBind = 0; iBind < cColumns; iBind++ )
    {
        // Set up the binding array

        aGenBindings[ iBind ].iOrdinal = aColumnIds[ iBind ];        // Ordinal of column
        aGenBindings[ iBind ].obValue = oCurrentOffset;              // Offset of data
        aGenBindings[ iBind ].obLength = 0,                          // Offset where length data is stored
        aGenBindings[ iBind ].obStatus = 0,                          // Status info for column written
        aGenBindings[ iBind ].pTypeInfo = 0,                         // Reserved
        aGenBindings[ iBind ].pObject = 0,                           // DBOBJECT structure
        aGenBindings[ iBind ].pBindExt = 0,                          // Ignored
        aGenBindings[ iBind ].dwPart = DBPART_VALUE;                 // Return data
        aGenBindings[ iBind ].dwMemOwner = DBMEMOWNER_PROVIDEROWNED; // Memory owne
        aGenBindings[ iBind ].eParamIO = 0;                          // eParamIo
        aGenBindings[ iBind ].cbMaxLen = sizeof(PROPVARIANT *);      // Size of data to return
        aGenBindings[ iBind ].dwFlags = 0;                           // Reserved
        aGenBindings[ iBind ].wType = DBTYPE_VARIANT | DBTYPE_BYREF; // Type of return data
        aGenBindings[ iBind ].bPrecision = 0;                        // Precision to use
        aGenBindings[ iBind ].bScale = 0;                            // Scale to us

        oCurrentOffset += sizeof( PROPVARIANT *);
    }

    sc = _xIAccessor->CreateAccessor( DBACCESSOR_ROWDATA,
                                      cColumns,
                                      aGenBindings,
                                      0,                // cbRowSize
                                      &_hAccessor,
                                      0 );

    if (FAILED(sc))
        THROW ( CException( sc ) );

    DBBINDING aBrowBindings[1];

    aBrowBindings[0] = dbbindingPath;
    aBrowBindings[0].iOrdinal = aColumnIdHidden[0];

    sc = _xIAccessor->CreateAccessor( DBACCESSOR_ROWDATA,
                                      1,
                                      aBrowBindings,
                                      0,                // cbRowSize
                                      &_hBrowseAccessor,
                                      0 );

    if (FAILED(sc))
        THROW ( CException( sc ) );
} //SetupColumnMappingsAndAccessors
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\srch\srchwnd.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       srchwnd.cxx
//
//  Contents:   
//
//  History:    15 Aug 1996     DLee    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <ntquery.h>

//
// Main Search Window procedure
//

LRESULT WINAPI SearchWndProc(
    HWND   hwnd,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam )
{
    LRESULT lRet = 0;
    // Find search control corresponding to this window
    CSearchControl *pControl = (CSearchControl *) GetWindowLongPtr( hwnd, 0 );

    switch (msg)
    {
        //
        // Message sent to us by ListView
        //
        case wmListNotify:
            lRet = pControl->wmListNotify (hwnd, wParam, lParam);
            break;
        case wmDrawItem :
            lRet = pControl->wmDrawItem(wParam,lParam);
            break;
        case wmMeasureItem:
            pControl->wmMeasureItem(wParam,lParam);
            break;

        // OLE DB notification
        case wmNotification:
            pControl->wmNotification(wParam,lParam);
            break;

        //------------------------------------
        case wmAccelerator :
            pControl->wmAccelerator(wParam,lParam);
            break;
        case WM_MDIACTIVATE :
            lRet = pControl->wmActivate( hwnd, wParam, lParam );
            break;
        case WM_DRAWITEM :
            lRet = pControl->wmRealDrawItem( hwnd, wParam, lParam );
            break;
        case WM_SIZE :
            lRet = pControl->wmSize(wParam,lParam);
            break;
        case wmDisplaySubwindows :
            pControl->wmDisplaySubwindows(wParam,lParam);
            break;
        case WM_CREATE :
        {
            CREATESTRUCT *pcs = (CREATESTRUCT *) lParam;
            MDICREATESTRUCT *pmcs = (MDICREATESTRUCT *) pcs->lpCreateParams;
            pControl = new CSearchControl(hwnd, (WCHAR *) pmcs->lParam);
            PostMessage( hwnd, wmDisplaySubwindows, 0, 0 );
            break;
        }
        case WM_CTLCOLORSTATIC :
            SetTextColor((HDC) wParam, GetSysColor( COLOR_BTNTEXT ) );
            // fall through
        case WM_CTLCOLORBTN :
            SetBkColor((HDC) wParam, GetSysColor( COLOR_BTNFACE ) );
            lRet = (LRESULT) (LPVOID) App.BtnFaceBrush();
            break;
        case wmNewFont :
            pControl->wmNewFont(wParam,lParam);
            break;
        case wmAppClosing :
            pControl->wmAppClosing(wParam,lParam);
            break;
        case WM_CLOSE :
            pControl->wmClose(wParam,lParam);
            lRet = DefMDIChildProc(hwnd,msg,wParam,lParam);
            break;
        case WM_DESTROY :
            delete pControl;
            break;
        case wmMenuCommand :
            pControl->wmMenuCommand(wParam,lParam);
            break;
        case WM_SETFOCUS :
        case wmGiveFocus :
            pControl->wmSetFocus(wParam,lParam);
            break;
        case WM_COMMAND :
            pControl->wmCommand(wParam,lParam);
            break;
        case wmInitMenu :
            pControl->wmInitMenu(wParam,lParam);
            break;
        case WM_SYSCOLORCHANGE :
            pControl->wmSysColorChange( wParam, lParam );
            lRet = DefMDIChildProc( hwnd, msg, wParam, lParam );
            break;
        case WM_NOTIFY :
            pControl->wmColumnNotify( wParam, lParam );
            break;
        case WM_CONTEXTMENU :
            pControl->wmContextMenu( hwnd, wParam, lParam );
            break;
        default:
            lRet = DefMDIChildProc( hwnd, msg, wParam, lParam );
            break;
    }

    return lRet;
} //SearchWndProc

//
// Scope choice dialog box proc and helper functions
//

unsigned GetCatalogListCount( HWND hdlg )
{
    unsigned cChecked = 0;

    HWND hCatList = GetDlgItem( hdlg, ID_CATALOG_LIST );
    Win4Assert( hCatList );

    unsigned iItem = ListView_GetItemCount( hCatList ) ;
    LVITEM lvi;

    for ( ; iItem > 0; iItem-- )
    {
        lvi.iItem = iItem - 1;

        if ( ListView_GetCheckState( hCatList, lvi.iItem ) )
            cChecked++;
    }

    return cChecked;
} //GetCatalogListCount

void DeleteCatalogSelectedListItems( HWND hdlg )
{
    HWND hCatList = GetDlgItem( hdlg, ID_CATALOG_LIST );
    Win4Assert( hCatList );

    unsigned iItem = ListView_GetItemCount( hCatList ) ;

    for ( ; iItem > 0; iItem-- )
    {
        if ( LVIS_SELECTED == ListView_GetItemState( hCatList, iItem - 1, LVIS_SELECTED ) )
            ListView_DeleteItem( hCatList, iItem - 1 );
    }
} //DeleteCatalogSelectedListItems

BOOL IsInList(
    HWND                         hCatList,
    SScopeCatalogMachine const & scm,
    int &                        item )
{
    unsigned iItem = ListView_GetItemCount( hCatList ) ;

    LVITEM lvi;
    WCHAR wTemp[MAX_PATH];
    lvi.pszText = (WCHAR*)wTemp;
    lvi.cchTextMax = MAX_PATH;

    for ( ; iItem > 0; iItem-- )
    {
        unsigned iCol = 0;

        lvi.iItem = iItem - 1;
        lvi.mask  = LVIF_TEXT;
    
        // machine

        lvi.iSubItem  = iCol++;
        ListView_GetItem( hCatList, &lvi );

        if ( !_wcsicmp( scm.awcMachine, lvi.pszText ) )
        {
            // catalog

            lvi.iSubItem  = iCol++;
            ListView_GetItem( hCatList, &lvi );
    
            if ( !_wcsicmp( scm.awcCatalog, lvi.pszText ) )
            {
                // scope

                lvi.iSubItem  = iCol++;
                ListView_GetItem( hCatList, &lvi );

                if ( !_wcsicmp( scm.awcScope, lvi.pszText ) )
                {
                    item = lvi.iItem;
                    return TRUE;
                }
            }
        }
    }

    return FALSE;
} //IsInList

void AddCatalogToList(
    HWND                         hdlg,
    SScopeCatalogMachine const & scm,
    BOOL                         fChecked )
{
    HWND hCatList = GetDlgItem( hdlg, ID_CATALOG_LIST );
    Win4Assert( hCatList );

    // Don't add duplicates, but check the checkbox if needed

    int item;
    if ( IsInList( hCatList, scm, item ) )
    {
        if ( fChecked )
            ListView_SetCheckState( hCatList, item, fChecked );

        return;
    }

    unsigned cItems = ListView_GetItemCount( hCatList ) ;

    LVITEM lvItem;
    unsigned iCol = 0;

    // Machine
    lvItem.mask     = LVIF_TEXT;
    lvItem.iItem    = cItems;
    lvItem.iSubItem = iCol++;
    lvItem.pszText  = (WCHAR*)scm.awcMachine;
    ListView_InsertItem( hCatList, &lvItem );

    // Catalog
    lvItem.iSubItem = iCol++;
    lvItem.pszText  = (WCHAR*)scm.awcCatalog;
    ListView_SetItem( hCatList, &lvItem );

    // Scope
    lvItem.iSubItem = iCol++;
    lvItem.pszText  = (WCHAR*)scm.awcScope;
    ListView_SetItem( hCatList, &lvItem );

    // Depth
    lvItem.iSubItem = iCol++;
    lvItem.pszText  = ( TRUE == scm.fDeep ) ? App.GetYes() : App.GetNo();
    ListView_SetItem( hCatList, &lvItem );

    ListView_SetCheckState( hCatList, cItems, fChecked );
} //AddCatalogToList

void CheckItIfInList(
    HWND                         hdlg,
    SScopeCatalogMachine const & scm )
{
    HWND hCatList = GetDlgItem( hdlg, ID_CATALOG_LIST );
    Win4Assert( hCatList );

    // Don't add duplicates, but check the checkbox if needed

    int item;
    if ( IsInList( hCatList, scm, item ) )
        ListView_SetCheckState( hCatList, item, TRUE );
} //CheckItIfInList

BOOL VerifyCatalogInfo( HWND hdlg, SScopeCatalogMachine & scm )
{
    CWaitCursor wait;

    if (IsDlgButtonChecked(hdlg,ID_SCOPE_DEEP))
        scm.fDeep = TRUE;
    else
        scm.fDeep = FALSE;

    GetDlgItemText( hdlg,
                    ID_SCOPE_EDIT,
                    scm.awcScope,
                    MAX_PATH );

    GetDlgItemText( hdlg,
                    ID_SCOPE_CATALOG_EDIT,
                    scm.awcCatalog,
                    MAX_PATH );

    GetDlgItemText( hdlg,
                    ID_SCOPE_MACHINE_EDIT,
                    scm.awcMachine,
                    SRCH_COMPUTERNAME_LENGTH );

    if ( 0 == scm.awcCatalog[0] )
    {

        //
        // If the user didn't specify a Catalog, then look for one using scope.
        //

        ULONG ccCat = sizeof(scm.awcCatalog)/sizeof(WCHAR);
        ULONG ccMachine = sizeof(scm.awcMachine)/sizeof(WCHAR);

        SCODE sc = LocateCatalogs( scm.awcScope,
                                   0,
                                   scm.awcMachine,
                                   &ccMachine,
                                   scm.awcCatalog,
                                   &ccCat );
    }

    // don't allow empty catalog names

    if ( 0 == scm.awcCatalog[0] )
    {
        SearchError( hdlg,
                     IDS_ERR_NO_CATALOG_SPECIFIED,
                     L"" );
        return FALSE;
    }

    // if scope is empty make it a global physical scope.

    if ( 0 == scm.awcScope[0] )
        wcscpy( scm.awcScope, L"\\" ); // entire catalog

    // map empty machine name to local machine

    if ( 0 == scm.awcMachine[0] )
        wcscpy( scm.awcMachine, L"." ); // local machine

    // remove leading two backslashes from machine name

    if ( L'\\' == scm.awcMachine[0] &&
         L'\\' == scm.awcMachine[1] )
    {
        WCHAR awc[SRCH_COMPUTERNAME_LENGTH + 1];
        wcscpy( awc, scm.awcMachine+2 );
        wcscpy( scm.awcMachine, awc );
    }

    CI_STATE cistate;
    cistate.cbStruct = sizeof cistate;

    if (STATUS_NOT_FOUND == CIState( scm.awcCatalog,
                                     scm.awcMachine,
                                     & cistate ) )
    {
        SearchError( hdlg,
                     IDS_ERR_BAD_CATALOG_SPECIFIED,
                     L"" );
        return FALSE;
    }

    return TRUE;
} //VerifyCatalogInfo

void CatListToString( HWND hdlg, XGrowable<WCHAR> & xCatStr )
{
    xCatStr.SetSize( 1 );
    xCatStr[0] = 0;

    HWND hCatList = GetDlgItem( hdlg, ID_CATALOG_LIST );
    Win4Assert( hCatList );

    unsigned iItem = ListView_GetItemCount( hCatList ) ;
    LVITEM lvi;
    WCHAR wTemp[MAX_PATH];
    lvi.pszText = (WCHAR*)wTemp;
    lvi.cchTextMax = MAX_PATH;

    for ( ; iItem > 0; iItem-- )
    {
        unsigned iCol = 0;
        unsigned cCatStr;
        unsigned cText;

        lvi.iItem = iItem - 1;

        if ( ListView_GetCheckState( hCatList, lvi.iItem ) )
        {
            lvi.mask  = LVIF_TEXT;
    
            // machine
            lvi.iSubItem  = iCol++;
            ListView_GetItem( hCatList, &lvi );
    
            cCatStr = wcslen( xCatStr.Get() );
            cText   = wcslen( lvi.pszText );
    
            xCatStr.SetSize( cCatStr + cText + 2 );
    
            wcscat( xCatStr.Get(), lvi.pszText );
            wcscat( xCatStr.Get(), L"," );
    
            // catalog
            lvi.iSubItem  = iCol++;
            ListView_GetItem( hCatList, &lvi );
    
            cCatStr = wcslen( xCatStr.Get() );
            cText   = wcslen( lvi.pszText );
    
            xCatStr.SetSize( cCatStr + cText + 2 );
    
            wcscat( xCatStr.Get(), lvi.pszText );
            wcscat( xCatStr.Get(), L"," );
    
            // scope
            lvi.iSubItem  = iCol++;
            ListView_GetItem( hCatList, &lvi );
    
            cCatStr = wcslen( xCatStr.Get() );
            cText   = wcslen( lvi.pszText );
    
            xCatStr.SetSize( cCatStr + cText + 2 );
    
            wcscat( xCatStr.Get(), lvi.pszText );
            wcscat( xCatStr.Get(), L"," );
    
            // depth
            lvi.iSubItem  = iCol++;
            ListView_GetItem( hCatList, &lvi );
    
            cCatStr = wcslen( xCatStr.Get() );
            cText   = 1;
    
            xCatStr.SetSize( cCatStr + cText + 2 );
    
            wcscat( xCatStr.Get(),
                    !wcscmp( App.GetYes(), lvi.pszText ) ? L"d" : L"s" );
            wcscat( xCatStr.Get(), L";" );
        }
    }
} //CatListToString

BOOL ScopeDlgInit(
    HWND   hdlg,
    LPARAM lParam,
    LPWSTR awcScopeOrig)
{
    SScopeCatalogMachine scm;

    // search control was passed as lParam
    SetWindowLongPtr(hdlg, DWLP_USER, lParam);
    XGrowable<WCHAR> *xCatList = (XGrowable<WCHAR> *) lParam;

    CheckDlgButton( hdlg, ID_SCOPE_DEEP, TRUE );

    SendDlgItemMessage( hdlg,
                        ID_SCOPE_MACHINE_EDIT,
                        EM_SETLIMITTEXT,
                        SRCH_COMPUTERNAME_LENGTH,
                        0 );

    SendDlgItemMessage( hdlg,
                        ID_SCOPE_EDIT,
                        EM_SETLIMITTEXT,
                        MAX_PATH,
                        0 );

    SendDlgItemMessage( hdlg,
                        ID_SCOPE_CATALOG_EDIT,
                        EM_SETLIMITTEXT,
                        MAX_PATH,
                        0 );

    // Setup columns in the multi catalog list box

    HWND hCatList = GetDlgItem( hdlg, ID_CATALOG_LIST );
    Win4Assert( hCatList );

    ListView_SetExtendedListViewStyleEx( hCatList,
                                         LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT,
                                         LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT );

    CResString str;
    LVCOLUMN lvc;
    unsigned iCol = 0;

    lvc.mask     = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvc.fmt      = LVCFMT_LEFT;

    lvc.cx       = 100;
    lvc.iSubItem = iCol++;
    str.Load( IDS_CATLIST_COL_MACHINE );
    lvc.pszText = str.Get();
    ListView_InsertColumn( hCatList, iCol, &lvc) ;

    lvc.cx       = 90;
    lvc.iSubItem = iCol++;
    str.Load( IDS_CATLIST_COL_CATALOG );
    lvc.pszText = str.Get();
    ListView_InsertColumn( hCatList, iCol, &lvc) ;

    lvc.cx       = 90;
    lvc.iSubItem = iCol++;
    str.Load( IDS_CATLIST_COL_SCOPE );
    lvc.pszText = str.Get();
    ListView_InsertColumn( hCatList, iCol, &lvc) ;

    lvc.cx       = 50;
    lvc.iSubItem = iCol++;
    str.Load( IDS_CATLIST_COL_SUBDIRS );
    lvc.pszText = str.Get();
    ListView_InsertColumn( hCatList, iCol, &lvc) ;

    BOOL fMultiCat = GetCatListItem( *xCatList,
                                     1,
                                     scm.awcMachine,
                                     scm.awcCatalog,
                                     scm.awcScope,
                                     scm.fDeep );

    scm.fDeep = TRUE;

    //
    // Add the catalogs from the user's environment if present.
    // The SRCHDEFAULTS variable is of the form
    //
    //  server\catalog:scope;server\catalog:scope;+server\catalog:scope
    //
    // + indicates that the server should be checked by default.  If no
    // scope is provided, then \ is used.
    //
    WCHAR wszDefaults[MAX_PATH];
    DWORD dwResult = GetEnvironmentVariableW( L"SRCHDEFAULTS", wszDefaults, MAX_PATH );
    if (dwResult && dwResult < MAX_PATH)
    {
        LPWSTR psz = wszDefaults;
        while ( *psz )
        {
            BOOL fChecked = FALSE;

            if ( *psz == L'+' )
            {
                fChecked = TRUE;
                psz++;
            }

            // Everything up to the \ is the server name
            LPWSTR pszT = wcschr( psz, L'\\' );
            if ( 0 == pszT )
            {
                break;
            }
            *pszT++ = L'\0';
            lstrcpynW( scm.awcMachine, psz, SRCH_COMPUTERNAME_LENGTH + 1 );

            // Everything up to the ; or end of string is the catalog:scope
            psz = pszT;
            pszT = wcschr( psz, L';' );
            if ( 0 != pszT )
            {
                *pszT++ = L'\0';
            }
            else
            {
                pszT = psz + wcslen( psz );
            }

            //
            //  If there is a : then that's the scope.
            //
            LPWSTR pszColon = wcschr( psz, L':' );
            if ( 0 != pszColon )
            {
                *pszColon++ = L'\0';
                lstrcpynW( scm.awcScope, pszColon, MAX_PATH );
            }
            else
            {
                // Default scope is "\"
                wcscpy( scm.awcScope, L"\\" );
            }

            lstrcpynW( scm.awcCatalog, psz, MAX_PATH );

            AddCatalogToList( hdlg, scm, fChecked );
            psz = pszT;
        }
    }
    else
    {
        // Add the well-known catalogs

        wcscpy( scm.awcScope, L"\\" );
        HRSRC hrc = FindResource( 0, (LPCWSTR) IDR_CATALOGS, RT_RCDATA );

        if ( 0 != hrc )
        {
            HGLOBAL hg = LoadResource( 0, hrc );

            if ( 0 != hg )
            {
                WCHAR * p = (WCHAR *) LockResource( hg );

                while ( 0 != p && 0 != *p )
                {
                    wcscpy( scm.awcMachine, p );
                    p += ( wcslen( p ) + 1 );
                    wcscpy( scm.awcCatalog, p );
                    p += ( wcslen( p ) + 1 );
                    AddCatalogToList( hdlg, scm, FALSE );
                }
            }
        }
    }

    if ( ! fMultiCat )
    {
        if ( GetCatListItem( *xCatList,
                             0,
                             scm.awcMachine,
                             scm.awcCatalog,
                             scm.awcScope,
                             scm.fDeep ) )
        {
            SetDlgItemText( hdlg, ID_SCOPE_EDIT, scm.awcScope );
            SetDlgItemText( hdlg, ID_SCOPE_CATALOG_EDIT, scm.awcCatalog );
            SetDlgItemText( hdlg, ID_SCOPE_MACHINE_EDIT, scm.awcMachine );
            CheckDlgButton( hdlg, ID_SCOPE_DEEP, scm.fDeep );

            CheckItIfInList( hdlg, scm );
        }
    }
    else
    {
        for ( unsigned ii = 0; ; ii ++ )
        {
            if ( GetCatListItem( *xCatList,
                                 ii,
                                 scm.awcMachine,
                                 scm.awcCatalog,
                                 scm.awcScope,
                                 scm.fDeep ) )
                AddCatalogToList( hdlg, scm, TRUE );
            else
                break;
        }
    }

    wcscpy( awcScopeOrig, scm.awcScope );

    UINT ctlID = ID_SCOPE_MACHINE_EDIT;

    SetFocus( GetDlgItem( hdlg, ctlID ) );
    MySendEMSetSel( GetDlgItem( hdlg, ctlID ), 0, (UINT) -1 );

    CenterDialog( hdlg );

    return FALSE;

} //ScopeDlgInit

INT_PTR WINAPI ScopeDlgProc(
    HWND   hdlg,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam )
{
    BOOL fRet = FALSE;

    // pointer to search control that will receive the new scope
    // safe: can have one dlg up at a time!

    SScopeCatalogMachine scm;
    static WCHAR awcScopeOrig[MAX_PATH];

    switch (msg)
    {
        case WM_INITDIALOG :
        {
            fRet = ScopeDlgInit( hdlg, lParam, awcScopeOrig );
            break;
        }

        case WM_NOTIFY:
        {
            if ( ID_CATALOG_LIST == (int) wParam )
            {
                LPNMHDR pnmh = (LPNMHDR) lParam;

                if ( LVN_KEYDOWN == pnmh->code )
                {
                    NMLVKEYDOWN * pnkd = (NMLVKEYDOWN *) lParam;

                    if ( VK_DELETE == pnkd->wVKey )
                        DeleteCatalogSelectedListItems( hdlg );
                }
            }
            break;
        }

        case WM_COMMAND :
        {
            UINT uiID = MyWmCommandID( wParam, lParam );
            switch (uiID)
            {
                case ID_SCOPE_EDIT:
                {
                    if ( EN_KILLFOCUS == HIWORD(wParam) )
                    {
                        // Try to locate a matching catalog

                        GetDlgItemText( hdlg,
                                        ID_SCOPE_EDIT,
                                        scm.awcScope,
                                        MAX_PATH );

                        // only look for a cat if the scope changed

                        if ( 0 != wcscmp( scm.awcScope, awcScopeOrig ) )
                        {
                            CWaitCursor wait;

                            ULONG ccCat = sizeof(scm.awcCatalog)/sizeof(WCHAR);
                            ULONG ccMachine = sizeof(scm.awcMachine)/sizeof(WCHAR);
    
                            SCODE sc = LocateCatalogs( scm.awcScope,
                                                       0,
                                                       scm.awcMachine,
                                                       &ccMachine,
                                                       scm.awcCatalog,
                                                       &ccCat );
    
                            if ( S_OK == sc )
                            {
                                SetDlgItemText( hdlg, ID_SCOPE_CATALOG_EDIT, scm.awcCatalog );
                                SetDlgItemText( hdlg, ID_SCOPE_MACHINE_EDIT, scm.awcMachine );
                            }
                        }
                    }
                    break;
                }

                case ID_CATALOG_ADD:
                {
                    if ( VerifyCatalogInfo( hdlg, scm ) )
                    {
                        AddCatalogToList( hdlg, scm, TRUE );

                        SetDlgItemText( hdlg, ID_SCOPE_EDIT, L"" );
                        SetDlgItemText( hdlg, ID_SCOPE_CATALOG_EDIT, L"" );
                        SetDlgItemText( hdlg, ID_SCOPE_MACHINE_EDIT, L"" );

                        SetFocus( GetDlgItem( hdlg, ID_SCOPE_MACHINE_EDIT ) );
                    }
                    break;
                }

                case IDOK:
                {
                    XGrowable<WCHAR> *xCatList = reinterpret_cast<XGrowable<WCHAR> *>
                                                        (GetWindowLongPtr(hdlg, DWLP_USER));

                    GetDlgItemText( hdlg,
                                    ID_SCOPE_EDIT,
                                    scm.awcScope,
                                    MAX_PATH );

                    GetDlgItemText( hdlg,
                                    ID_SCOPE_CATALOG_EDIT,
                                    scm.awcCatalog,
                                    MAX_PATH );

                    GetDlgItemText( hdlg,
                                    ID_SCOPE_MACHINE_EDIT,
                                    scm.awcMachine,
                                    SRCH_COMPUTERNAME_LENGTH );

                    // We look at the edit fields only if user has entered some
                    // value and nothing has been added to the catalog list.
                    // If anything has been added to catalog list, then we
                    // only look at the list and ignore these fields

                    if ( ( scm.awcScope[0] || scm.awcCatalog[0] || scm.awcMachine[0] )
                         && 0 == GetCatalogListCount( hdlg ) )
                    {
                        if ( VerifyCatalogInfo( hdlg, scm ) )
                            AddCatalogToList( hdlg, scm, TRUE );
                        else
                            break;
                    }

                    CatListToString( hdlg, *xCatList );

                    if ( 0 == (*xCatList)[0] )
                    {
                        SearchError( hdlg,
                                     IDS_ERR_NO_CATALOG_SPECIFIED,
                                     L"" );
                        break;
                    }
                }
                    // fall through!
                case IDCANCEL:
                    EndDialog( hdlg, IDOK == uiID );
                    break;
            }
            break;
        }
    }

    return fRet;
} //ScopeDlgProc

static WNDPROC g_DlgWndProc = 0;
INT_PTR WINAPI DisplayPropsDlgProc(
    HWND   hdlg,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam );

void EnableOrDisableButtons(
    HWND hdlg,
    HWND hAvail,
    HWND hDisp )
{
    int iSelAvail = (int) SendMessage( hAvail, LB_GETCURSEL, 0, 0 );
    int iSelDisp = (int) SendMessage( hDisp, LB_GETCURSEL, 0, 0 );

    HWND hAdd = GetDlgItem( hdlg, ID_PROP_ADD );
    HWND hRemove = GetDlgItem( hdlg, ID_PROP_REMOVE );

    if ( iSelAvail == -1 && GetFocus() == hAdd )
        SetFocus( hAvail );

    if ( iSelDisp == -1 && GetFocus() == hRemove )
        SetFocus( hDisp );

    EnableWindow( hAdd, iSelAvail != -1 );
    EnableWindow( hRemove, iSelDisp != -1 );
} //EnableOrDisableButtons

LRESULT WINAPI DlgSubclassProc(
    HWND   hwnd,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam )
{
    static UINT msgDrag = RegisterWindowMessage( DRAGLISTMSGSTRING );
    static iDraggedItem;

    LRESULT lRet = 0;

    if ( msgDrag == msg )
    {
        HWND hAvail = GetDlgItem( hwnd, ID_PROP_AVAIL );
        HWND hDisp = GetDlgItem( hwnd, ID_PROP_DISP );
        DRAGLISTINFO *pInfo = (DRAGLISTINFO *) lParam;

        switch( pInfo->uNotification )
        {
            case DL_BEGINDRAG :
            {
                iDraggedItem = LBItemFromPt( pInfo->hWnd,
                                             pInfo->ptCursor, TRUE );
                lRet = TRUE;
                break;
            }
            case DL_DRAGGING :
            {
                int i = -1;
                HWND hDst = hDisp;

                if ( pInfo->hWnd == hAvail )
                {
                    i = LBItemFromPt( hDisp, pInfo->ptCursor, TRUE );
                }
                else
                {
                    i = LBItemFromPt( hDisp, pInfo->ptCursor, TRUE );
                    if ( -1 == i )
                    {
                        i = LBItemFromPt( hAvail, pInfo->ptCursor, TRUE );
                        hDst = hAvail;
                    }
                }

                DrawInsert( hwnd, hDst, i );
                if ( -1 == i )
                    lRet = DL_STOPCURSOR;
                else
                    lRet = DL_MOVECURSOR;
                break;
            }
            case DL_CANCELDRAG :
            {
                DrawInsert( hwnd, pInfo->hWnd, -1 );
                lRet = DL_CURSORSET;
                break;
            }
            case DL_DROPPED :
            {
                int i = -1;
                HWND hDst = hDisp;
                if ( pInfo->hWnd == hAvail )
                {
                    i = LBItemFromPt( hDisp, pInfo->ptCursor, TRUE );
                }
                else
                {
                    i = LBItemFromPt( hDisp, pInfo->ptCursor, TRUE );
                    if ( -1 == i )
                    {
                        i = LBItemFromPt( hAvail, pInfo->ptCursor, TRUE );
                        hDst = hAvail;
                    }
                }

                if ( ( -1 != i && -1 != iDraggedItem ) &&
                     ( ! ( pInfo->hWnd == hDisp &&
                           hDst == hDisp &&
                           i == iDraggedItem ) ) )
                {
                    if ( hDst == hAvail )
                    {
                        // move displayed to avail
                        DisplayPropsDlgProc( hwnd,
                                             WM_COMMAND,
                                             (WPARAM) MAKELONG(ID_PROP_REMOVE,0),
                                             0 );
                    }
                    else if ( pInfo->hWnd == hAvail )
                    {
                        // move avail to displayed
                        WCHAR awcBuf[ cwcBufSize ];
                        SendMessage( hAvail, LB_GETTEXT, iDraggedItem, (LPARAM) awcBuf );
                        SendMessage( hDisp, LB_INSERTSTRING, i, (LPARAM ) awcBuf );
                        SendMessage( hAvail, LB_DELETESTRING, iDraggedItem, 0 );
                    }
                    else
                    {
                        // reorder displayed items
                        WCHAR awcBuf[ cwcBufSize ];
                        SendMessage( hDisp, LB_GETTEXT, iDraggedItem, (LPARAM) awcBuf );
                        SendMessage( hDisp, LB_INSERTSTRING, i, (LPARAM ) awcBuf );
                        if ( iDraggedItem > i )
                            iDraggedItem++;
                        SendMessage( hDisp, LB_DELETESTRING, iDraggedItem, 0 );
                    }
                }

                DrawInsert( hwnd, pInfo->hWnd, -1 );
                lRet = DL_CURSORSET;

                EnableOrDisableButtons( hwnd, hAvail, hDisp );
                break;
            }
        }

        return lRet;
    }

    if ( 0 != g_DlgWndProc )
        lRet = g_DlgWndProc( hwnd, msg, wParam, lParam );

    return lRet;
} //DlgSubclassProc

INT_PTR WINAPI DisplayPropsDlgProc(
    HWND   hdlg,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam )
{
    // pointer to search control that will receive the new props
    // safe: can have one dlg up at a time!
    static CSearchControl *s_pControl = 0;

    BOOL fRet = FALSE;

    switch (msg)
    {
        case WM_INITDIALOG :
        {
            // subclass the dlgproc -- we need a window proc, not a dlgproc

            g_DlgWndProc = (WNDPROC) GetWindowLongPtr( hdlg, GWLP_WNDPROC );
            SetWindowLongPtr( hdlg, GWLP_WNDPROC, (LONG_PTR) DlgSubclassProc );

            // search control was passed as lParam

            s_pControl = (CSearchControl *) lParam;

            CColumnList & columns = s_pControl->GetColumnList();
            IColumnMapper & map = s_pControl->GetColumnMapper();

            // fill the displayed and available listboxes

            HWND hAvail = GetDlgItem( hdlg, ID_PROP_AVAIL );
            HWND hDisp = GetDlgItem( hdlg, ID_PROP_DISP );
            unsigned cDisp = columns.NumberOfColumns();

            MakeDragList( hAvail );
            MakeDragList( hDisp );

            ULONG iEntry = 0;
            WCHAR const *pwcName;
            DBID *pdbid;
            DBTYPE dbtype;
            unsigned int uiWidth;

            while ( SUCCEEDED( map.EnumPropInfo( iEntry,
                                                 &pwcName,
                                                 &pdbid,
                                                 &dbtype,
                                                 &uiWidth ) ) )
            {
                if ( 0 != uiWidth )
                {
                    XArray<WCHAR> xLower( 1 + wcslen( pwcName ) );
                    wcscpy( xLower.Get(), pwcName );
                    _wcslwr( xLower.Get() + 1 );

                    BOOL fIsDisp = FALSE;

                    for ( unsigned i = 0; i < cDisp; i++ )
                    {
                        if ( !_wcsicmp( xLower.Get(), columns.GetColumn( i ) ) )
                        {
                            fIsDisp = TRUE;
                            break;
                        }
                    }

                    if (!fIsDisp)
                        SendMessage( hAvail,
                                     LB_ADDSTRING,
                                     0,
                                     (LPARAM) xLower.Get() );
                }

                iEntry++;
            }

            for ( unsigned i = 0; i < cDisp; i++ )
                SendMessage( hDisp, LB_ADDSTRING, 0,
                             (LPARAM) columns.GetColumn( i ) );

            CenterDialog( hdlg );

            EnableOrDisableButtons( hdlg, hAvail, hDisp );
            fRet = FALSE;
            break;
        }

        case WM_COMMAND :
        {
            HWND hAvail = GetDlgItem( hdlg, ID_PROP_AVAIL );
            HWND hDisp = GetDlgItem( hdlg, ID_PROP_DISP );
            WORD cmd = MyWmCommandCmd( wParam, lParam );

            switch ( MyWmCommandID( wParam, lParam ) )
            {
                case ID_PROP_ADD :
                {
                    int iSelDisp = (int) SendMessage( hDisp, LB_GETCURSEL, 0, 0 );
                    int iSelAvail = (int) SendMessage( hAvail, LB_GETCURSEL, 0, 0 );

                    if ( LB_ERR != iSelAvail )
                    {
                        WCHAR awcBuf[ cwcBufSize ];
                        SendMessage( hAvail, LB_GETTEXT, iSelAvail, (LPARAM) awcBuf );
                        SendMessage( hDisp,
                                     LB_INSERTSTRING,
                                     iSelDisp != LB_ERR ? iSelDisp : -1,
                                     (LPARAM ) awcBuf );
                        SendMessage( hAvail, LB_DELETESTRING, iSelAvail, 0 );
                    }

                    EnableOrDisableButtons( hdlg, hAvail, hDisp );
                    break;
                }

                case ID_PROP_REMOVE :
                {
                    int iSelDisp = (int) SendMessage( hDisp, LB_GETCURSEL, 0, 0 );

                    if ( LB_ERR != iSelDisp )
                    {
                        WCHAR awcBuf[ cwcBufSize ];
                        SendMessage( hDisp, LB_GETTEXT, iSelDisp, (LPARAM) awcBuf );
                        SendMessage( hAvail, LB_ADDSTRING, 0, (LPARAM ) awcBuf );
                        SendMessage( hDisp, LB_DELETESTRING, iSelDisp, 0 );
                    }

                    EnableOrDisableButtons( hdlg, hAvail, hDisp );
                    break;
                }
                case ID_PROP_AVAIL :
                {
                    if ( LBN_DBLCLK == cmd )
                        DisplayPropsDlgProc( hdlg,
                                             WM_COMMAND,
                                             (WPARAM) MAKELONG(ID_PROP_ADD,0),
                                             0 );
                    EnableOrDisableButtons( hdlg, hAvail, hDisp );
                    break;
                }
                case ID_PROP_DISP :
                {
                    if ( LBN_DBLCLK == cmd )
                        DisplayPropsDlgProc( hdlg,
                                             WM_COMMAND,
                                             (WPARAM) MAKELONG(ID_PROP_REMOVE,0),
                                             0 );

                    EnableOrDisableButtons( hdlg, hAvail, hDisp );
                    break;
                }
                case IDOK :
                {
                    HWND hDisp = GetDlgItem( hdlg, ID_PROP_DISP );
                    ULONG cDisp = (ULONG)SendMessage( hDisp, LB_GETCOUNT, 0, 0 );
                    WCHAR awcDisp[ cwcBufSize ];
                    awcDisp[0] = 0;

                    cDisp = __min( cDisp, maxBoundCols );

                    for ( unsigned i = 0; i < cDisp; i++ )
                    {
                        WCHAR awcBuf[ cwcBufSize ];

                        SendMessage( hDisp, LB_GETTEXT, i, (LPARAM) awcBuf );
                        if ( 0 != awcDisp[0] )
                            wcscat( awcDisp, L"," );
                        wcscat( awcDisp, awcBuf );
                    }

                    SetReg( CISEARCH_REG_DISPLAYPROPS, awcDisp );
                    s_pControl->SetupDisplayProps( awcDisp );
                    EndDialog( hdlg, TRUE );
                    break;
                }

                case ID_PROP_DEFAULT :
                {
                    WCHAR awcDisp[ cwcBufSize ];
                    wcscpy( awcDisp, DEFAULT_DISPLAYED_PROPERTIES );
                    SetReg( CISEARCH_REG_DISPLAYPROPS, awcDisp );
                    s_pControl->SetupDisplayProps( awcDisp );
                    EndDialog( hdlg, TRUE );
                    break;
                }

                case IDCANCEL :
                {
                    EndDialog( hdlg, FALSE );
                    break;
                }
            }
            break;
        }
    }

    return fRet;
} //DisplayPropsDlgProc

//
// Subclass window procedure for edit control
//

LRESULT WINAPI EditSubclassProc(
    HWND   hwnd,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam )
{
    LRESULT lRet = 0;
    HWND hParent = GetParent(GetParent(hwnd));

    if (0 != hParent)
    {
        CSearchControl *pControl = (CSearchControl *) GetWindowLongPtr (hParent, 0);

        if (0 != pControl)
            lRet = pControl->EditSubclassEvent(hwnd,msg,wParam,lParam);
    }

    return lRet;
} //EditSubclassProc

//
// Search Control
//

CSearchControl::CSearchControl(
    HWND    hwnd,
    WCHAR * pwcScope)
   :
#pragma warning(disable : 4355)
    _view( hwnd, *this, _columns ),
#pragma warning(default : 4355)
    _hInst( 0 ),
    _hwndSearch( hwnd ),
    _hwndQuery( 0 ),
    _hwndQueryTitle( 0 ),
    _hwndHeader( 0 ),
    _hwndList( 0 ),
    _lpOrgEditProc( 0 ),
    _pSearch( 0 ),
    _fDeep( TRUE )
{
    ISimpleCommandCreator & cmdCreator = *App.GetCommandCreator();
    XInterface<IColumnMapperCreator> xMapper;

    SCODE sc = cmdCreator.QueryInterface( IID_IColumnMapperCreator, xMapper.GetQIPointer() );
    if ( FAILED( sc ) )
        THROW( CException( sc ) );

    sc = xMapper->GetColumnMapper( L".", L"SYSTEM", _xColumnMapper.GetPPointer() );

    if ( FAILED( sc ) )
        THROW( CException( sc ) );

    SetWindowLongPtr( hwnd, 0, (LONG_PTR) this );

    _sort.SetSort( App.GetSortProp(), App.GetSortDir() );

    _lcid = App.GetLocale();
    _hInst = MyGetWindowInstance( _hwndSearch );

    _xCatList = App.CatalogList();

    // Get the first cat item
    GetCatListItem( App.CatalogList(), 0, _awcMachine, _awcCatalog, _awcScope, _fDeep );

    ResetTitle();

    InitPanes();
} //CSearchControl

LRESULT CSearchControl::wmActivate(
    HWND   hwnd,
    WPARAM wParam,
    LPARAM lParam )
{
    if ( hwnd == (HWND) lParam )
    {
        SIZE size;
        {
            HDC hdc = GetDC( _hwndQueryTitle );

            if ( 0 != hdc )
            {
                CResString str( IDS_COUNTTITLE );
                GetTextExtentPoint32( hdc, str.Get(), wcslen( str.Get() ), &size );
                ReleaseDC( _hwndQueryTitle, hdc );
            }
        }

        int apos[] = { size.cx + 2, size.cx + 102, -1 };
        SendMessage( App.StatusBarWindow(),
                     SB_SETPARTS,
                     sizeof apos / sizeof apos[ 0 ],
                     (LPARAM) apos );
        _UpdateStatusWindow( L"", L"" );

        UINT cDisable = 2;
        static UINT aDisable[] = { IDM_PREVIOUS_HIT,
                                   IDM_NEXT_HIT,
                                   IDM_BROWSE, };
        UINT cEnable = 4;
        static UINT aEnable[] = { IDM_SEARCH,
                                  IDM_SEARCHCLASSDEF,
                                  IDM_SEARCHFUNCDEF,
                                  IDM_DISPLAY_PROPS,
                                  IDM_BROWSE };

        if ( ( 0 != _pSearch ) &&
             ( _pSearch->IsSelected() ) )
            cEnable++;
        else
            cDisable++;

        UpdateButtons( aDisable, cDisable, FALSE );
        UpdateButtons( aEnable, cEnable, TRUE );

        _UpdateCount();
    }

    return 0;
} //wmActivate

void CSearchControl::_UpdateStatusWindow(
    WCHAR const * pwcMsg,
    WCHAR const * pwcReliability )
{
    SendMessage( App.StatusBarWindow(), SB_SETTEXT, SBT_OWNERDRAW | idStatusRatio, 0 );
    SendMessage( App.StatusBarWindow(), SB_SETTEXT, idStatusMsg, (LPARAM) pwcMsg );
    SendMessage( App.StatusBarWindow(), SB_SETTEXT, idStatusReliability, (LPARAM) pwcReliability );
} //_UpdateStatusWindow

LRESULT CSearchControl::wmRealDrawItem(
    HWND   hwnd,
    WPARAM wParam,
    LPARAM lParam )
{
    LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT) lParam;

    if ( lpdis->hwndItem == App.StatusBarWindow() )
    {
        ULONG iPct = 0;
        if ( 0 != _pSearch )
            iPct = _pSearch->PctDone();

        RECT rc;
        CopyRect( &rc, &lpdis->rcItem );
        rc.right += iPct;
        FillRect( lpdis->hDC, &rc, App.BtnHiliteBrush() );
        CopyRect( &rc, &lpdis->rcItem );
        rc.left += iPct;
        FillRect( lpdis->hDC, &rc, App.BtnFaceBrush() );

        if ( 0 != _pSearch )
        {
            int iOldMode = SetBkMode( lpdis->hDC, TRANSPARENT );
            COLORREF crOld = SetTextColor( lpdis->hDC,
                                           GetSysColor( COLOR_BTNTEXT ) );

            WCHAR awc[40];

            if ( QUERY_FILL_STATUS( _pSearch->QueryStatus() ) == STAT_ERROR )
            {
                CResString strError( IDS_QUERYERROR );
                wcscpy( awc, strError.Get() );
            }
            else if ( _pSearch->MostlyDone() )
            {
                CResString strDone( IDS_QUERYDONE );
                wcscpy( awc, strDone.Get() );
            }
            else
                wsprintf( awc, L"%d%%", iPct );

            DrawText( lpdis->hDC, awc, wcslen( awc ), & lpdis->rcItem,
                      DT_SINGLELINE | DT_VCENTER | DT_CENTER );

            SetTextColor( lpdis->hDC, crOld );
            SetBkMode( lpdis->hDC, iOldMode );
        }
    }

    return 1;
} //wmRealDrawItem

LRESULT CSearchControl::wmColumnNotify(
    WPARAM wParam,
    LPARAM lParam )
{
  HD_NOTIFY * pn = (HD_NOTIFY *) lParam;

  switch ( pn->hdr.code )
  {
      case HDN_ENDTRACK :
      {
          if ( (int) _view.ColumnWidth( pn->iItem ) != pn->pitem->cxy )
          {
              _view.SetColumnWidth( pn->iItem, pn->pitem->cxy );

              InvalidateRect( _hwndList, 0, TRUE );
          }
          break;
      }
      case HDN_DIVIDERDBLCLICK :
      {
          HD_ITEM hdi;
          hdi.mask = HDI_FORMAT | HDI_WIDTH | HDI_TEXT;
          hdi.cxy = _view.SetDefColumnWidth( pn->iItem );
          hdi.pszText = (WCHAR *) _columns.GetColumn( pn->iItem );
          hdi.hbm = 0;
          hdi.cchTextMax = wcslen( hdi.pszText );
          hdi.fmt =  HDF_STRING | HDF_LEFT;
          hdi.lParam = 0;
          Header_SetItem( _hwndHeader, pn->iItem, &hdi );

          InvalidateRect( _hwndList, 0, TRUE );
          break;
      }
      case HDN_ITEMCLICK :
      {
          //BOOL fUp = ( 0 == ( 0x8000 & GetAsyncKeyState( VK_CONTROL ) ) );

          // invert the old sort order

          int dir = ( _sort.GetSortDir() == SORT_UP ) ? SORT_DOWN : SORT_UP;

          _sort.SetSort( _columns.GetColumn( pn->iItem ), dir );

          wcscpy( App.GetSortProp(), _columns.GetColumn( pn->iItem ) );
          App.GetSortDir() = dir;

          PostMessage ( _hwndSearch,
                        ::wmMenuCommand,
                        IDM_SEARCH,
                        MAKELPARAM( 1, 0 ) );
          break;
      }
  }

  return DefMDIChildProc( _hwndSearch, WM_NOTIFY, wParam, lParam );
} //wmColumnNotify

void CSearchControl::SetupDisplayProps(
    WCHAR *pwcProps )
{
    _columns.SetNumberOfColumns( 0 );

    WCHAR *pwc = pwcProps;
    unsigned iPos = 0;

    do
    {
        WCHAR *pwcStart = pwc;

        while ( *pwc && ',' != *pwc )
            pwc++;

        if ( ',' == *pwc )
        {
            *pwc = 0;
            pwc++;
        }

        if ( *pwcStart )
            _columns.SetColumn( pwcStart, iPos++ );
        else
            break;
    } while ( TRUE );

    // if the list is bad -- no props added, add the default props

    if ( 0 == iPos )
    {
        WCHAR awcProp[ cwcBufSize ];
        wcscpy( awcProp, DEFAULT_DISPLAYED_PROPERTIES );
        SetupDisplayProps( awcProp );
    }

    _view.ColumnsChanged();

    _AddColumnHeadings();

} //SetupDisplayProps

void CSearchControl::_AddColumnHeadings()
{
    // delete any existing column headers

    int cItems = Header_GetItemCount( _hwndHeader );
    for ( int i = 0; i < cItems; i++ )
        Header_DeleteItem( _hwndHeader, 0 );

    // add the current column headers

    HD_ITEM hdi;
    hdi.mask = HDI_FORMAT | HDI_WIDTH | HDI_TEXT;
    hdi.hbm = 0;
    hdi.fmt =  HDF_STRING | HDF_LEFT;
    hdi.lParam = 0;

    for ( unsigned x = 0; x < _columns.NumberOfColumns(); x++ )
    {
        hdi.cxy = _view.ColumnWidth( x );
        hdi.pszText = (WCHAR *) _columns.GetColumn( x );
        hdi.cchTextMax = wcslen( hdi.pszText );
        Header_InsertItem( _hwndHeader, x, &hdi );
    }
} //_AddColumnHeadings

void CSearchControl::InitPanes ()
{
    // Query pane
    _hwndQuery = CreateWindow( L"COMBOBOX",
                               0,
                               WS_VSCROLL | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_CHILD | WS_BORDER | WS_TABSTOP | WS_GROUP,
                               0, 0, 0, 0,
                               _hwndSearch,
                               (HMENU) idQueryChild,
                               _hInst,
                               0 );

    // Get the edit field from the combobox
    // This is a hack, but I can't find any way of getting the
    // edit field from the combo box

    HWND hEdit = FindWindowEx( _hwndQuery, 0, L"EDIT", 0 );

    if ( 0 == hEdit )
        return;

    SetWindowText( hEdit, App.GetDefaultQuery() );

    _lpOrgEditProc = (WNDPROC) GetWindowLongPtr( hEdit, GWLP_WNDPROC );
    SetWindowLongPtr( hEdit, GWLP_WNDPROC, (LONG_PTR) EditSubclassProc );

    _hLastToHaveFocus = _hwndQuery;

    // List View pane
    // to be replaced by ListView

    _hwndList = CreateWindow( LIST_VIEW_CLASS,
                              L"",
                              WS_CHILD | WS_VISIBLE | WS_TABSTOP | WS_GROUP |
                              WS_VSCROLL | WS_BORDER,
                              0, 0, 0, 0,
                              _hwndSearch,
                              (HMENU) idListChild,
                              _hInst,
                              0 );
    DWORD err;
    if (_hwndList == 0)
        err = GetLastError();


    const long styleStatic = SS_LEFT | WS_CHILD;
    CResString strQuery (IDS_QUERYTITLE);

    _hwndQueryTitle = CreateWindow( L"static",
                                    strQuery.Get(),
                                    styleStatic,
                                    0,0,0,0,
                                    _hwndSearch,
                                    (HMENU) idQueryTitle,
                                    _hInst,
                                    0 );

    _hwndHeader = CreateWindowEx( 0,
                                  WC_HEADER,
                                  0,
                                  WS_CHILD | WS_BORDER |
                                  HDS_HORZ | HDS_BUTTONS,
                                  0,0,0,0,
                                  _hwndSearch,
                                  (HMENU) idHeader,
                                  _hInst,
                                  0 );

    _view.InitPanes ( _hwndQueryTitle,
                      _hwndQuery,
                      _hwndList,
                      _hwndHeader );

    WCHAR awcDisplayProps[cwcBufSize];
    ULONG cb = sizeof awcDisplayProps / sizeof awcDisplayProps[0];
    if ( !GetReg( CISEARCH_REG_DISPLAYPROPS, awcDisplayProps, &cb ) )
        wcscpy( awcDisplayProps, DEFAULT_DISPLAYED_PROPERTIES );

    SetupDisplayProps( awcDisplayProps );

    PostMessage( _hwndSearch, wmGiveFocus, 0, 0 );
} //InitPanes

CSearchControl::~CSearchControl()
{
    SetWindowLongPtr( _hwndSearch, 0, 0 );
    delete _pSearch;
} //~CSearchControl

LRESULT CSearchControl::wmListNotify(
    HWND   hwnd,
    WPARAM wParam,
    LPARAM lParam )
{
    if (!_pSearch)
    {
        *(long *)lParam = -1;
        return LRESULT(FALSE);
    }

    BOOL f = (BOOL)_pSearch->ListNotify (hwnd, wParam, (long *)lParam);

    static UINT aItem[] = { IDM_BROWSE };
    UpdateButtons( aItem, 1, _pSearch->IsSelected() );

    return (LRESULT) f;
} //wmListNotify

//
// Edit control procedure
//

LRESULT CSearchControl::EditSubclassEvent(
    HWND   hwnd,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam )
{
    LRESULT lRet = 0;

    switch (msg)
    {
#if 0
        case WM_KEYDOWN :
        {
            if ( VK_UP == wParam )
                pwc = _history.Previous();
            else if ( VK_DOWN == wParam )
                pwc = _history.Next();

            else
                lRet = CallWindowProc( _lpOrgEditProc,
                                        hwnd, msg, wParam, lParam );

            if ( 0 != pwc )
            {
                SetWindowText( hwnd, pwc );
                MySendEMSetSel( hwnd, 0, (UINT) -1 );
            }
            break;
        }
#endif
        case WM_KEYUP :
        {
            if ( VK_ESCAPE == wParam )
            {
                if ( SendMessage( _hwndQuery, CB_GETDROPPEDSTATE, 0, 0 ) )
                {
                    SendMessage( _hwndQuery, CB_SHOWDROPDOWN, (WPARAM)FALSE, 0 );
                }
            }
            lRet = CallWindowProc( _lpOrgEditProc, hwnd, msg, wParam, lParam );
            break;
        }

        case WM_CHAR :
        {
            if ( VK_RETURN == wParam || 11 == wParam )
            {
                // Handle 'enter' only if combobox list is closed. If it is open,
                // then we handle the selection message in wmCommand
                if ( FALSE == SendMessage( _hwndQuery, CB_GETDROPPEDSTATE, 0, 0 ) )
                {
                    SendMessage ( _hwndSearch,
                                  ::wmMenuCommand,
                                  IDM_SEARCH,
                                  MAKELPARAM( 1, 0 ) );
                    // swallow cr/lf
                    break;
                }
            }
            else
            {
                // Match the user entered string with the strings in the combobox
                // list box...

                lRet = CallWindowProc( _lpOrgEditProc, hwnd, msg, wParam, lParam );

                UINT uiLen = GetWindowTextLength( hwnd );

                if (0 != uiLen && VK_BACK != wParam )
                {
                    XGrowable<WCHAR> xBuf;
                    xBuf.SetSize( uiLen + 1 );

                    GetWindowText( hwnd, xBuf.Get(), uiLen + 1 );

                    int index = (int)SendMessage( _hwndQuery, CB_FINDSTRING, -1, (LPARAM) xBuf.Get() );

                    if ( CB_ERR != index)
                    {
                        unsigned uiFullLen = (unsigned)SendMessage( _hwndQuery, CB_GETLBTEXTLEN, index, 0 );
                        xBuf.SetSize( uiFullLen + 1 );

                        if ( CB_ERR != SendMessage( _hwndQuery,
                                                    CB_GETLBTEXT,
                                                    index,
                                                    (LPARAM) xBuf.Get() ) )

                        {
                            SetWindowText( hwnd, xBuf.Get() );
                            MySendEMSetSel( hwnd, uiLen, (UINT) -1 );
                        }
                    }
                }
                break;
            }

            // no break, fall through!
        }
        default :
          lRet = CallWindowProc( _lpOrgEditProc, hwnd, msg, wParam, lParam );
          break;
    }

    return lRet;
} //EditSubclassEvent

LRESULT CSearchControl::wmSize(
    WPARAM wParam,
    LPARAM lParam )
{
    // no need to do this since User doesn't have the repaint bug with
    // comboboxes that it does with edit controls

    //if (_hwndQuery)
    //    InvalidateRect(_hwndQuery, 0, TRUE);

    LRESULT lr = DefMDIChildProc(_hwndSearch, WM_SIZE, wParam, lParam);

    if ( _hwndQuery )
        _view.Size( LOWORD (lParam), HIWORD (lParam));

    return lr;
} //wmSize

LRESULT CSearchControl::wmDisplaySubwindows(
    WPARAM wParam,
    LPARAM lParam )
{
    ShowWindow(_hwndQuery,SW_SHOW);
    ShowWindow(_hwndList,SW_SHOW);
    ShowWindow(_hwndQueryTitle,SW_SHOW);
    ShowWindow(_hwndHeader,SW_SHOW);
    return 0;
} //wmDisplaySubwindows

LRESULT CSearchControl::wmContextMenu(
    HWND   hwnd,
    WPARAM wParam,
    LPARAM lParam )
{
    POINT pt;
    pt.x = LOWORD( lParam );
    pt.y = HIWORD( lParam );

    GetCursorPos( &pt );

    RECT rc;
    GetWindowRect( _hwndHeader, &rc );

    WCHAR *pwcMenu = L"bogus";

    // is the click over the properties header?

    if ( PtInRect( &rc, pt ) )
    {
        pwcMenu = L"HeaderContextMenu";
    }
    else
    {
        // do hit testing on listview -- on a hit?

        int iHit = (int) SendMessage( _hwndList,
                                      wmContextMenuHitTest,
                                      0,
                                      MAKELPARAM( pt.x, pt.y ) );

        if ( -1 != iHit )
            pwcMenu = L"ResultsContextMenu";
    }

    HMENU hMenu = LoadMenu( App.Instance(), pwcMenu );

    if ( 0 != hMenu )
    {
        HMENU hTrackMenu = GetSubMenu( hMenu, 0 );
        if ( 0 != hTrackMenu )
        {
            if ( !wcscmp( pwcMenu, L"ResultsContextMenu" ) )
                SetMenuDefaultItem( hTrackMenu, IDM_BROWSE, FALSE );

            // yes, the function returns a BOOL that you switch on

            BOOL b = TrackPopupMenuEx( hTrackMenu,
                                       TPM_LEFTALIGN | TPM_RIGHTBUTTON |
                                           TPM_RETURNCMD,
                                       pt.x,
                                       pt.y,
                                       hwnd,
                                       0 );
            switch ( b )
            {
                case IDM_EDITCOPY :
                case IDM_EDITCOPYALL :
                case IDM_DISPLAY_PROPS :
                {
                    wmMenuCommand( b, 0 );
                    break;
                }
                case IDM_BROWSE :
                {
                    _DoBrowse( fileBrowse );
                    break;
                }
                case IDM_BROWSE_OPEN :
                {
                    _DoBrowse( fileOpen );
                    break;
                }
                case IDM_BROWSE_EDIT :
                {
                    _DoBrowse( fileEdit );
                    break;
                }
            }
        }

        DestroyMenu( hMenu );
    }

    return 0;
} //wmContextMenu

void CSearchControl::_DoBrowse(
    enumViewFile eViewType )
{
    if (_pSearch)
    {
        CWaitCursor curWait;
        TRY
        {
            BOOL fIsZoomed = IsZoomed( _hwndSearch );
            BOOL fOK = _pSearch->Browse( eViewType );

            if ( !fOK && fIsZoomed )
            {
                App.ZoomMDI( _hwndSearch );
                InvalidateRect( _hwndSearch, NULL, TRUE );
            }
        }
        CATCH (CException, e)
        {
        }
        END_CATCH;
    }
} //_DoBrowse

LRESULT CSearchControl::wmCommand(
    WPARAM wParam,
    LPARAM lParam )
{
    UINT uiID = MyWmCommandID( wParam, lParam );
    HWND hCtl = MyWmCommandHWnd( wParam, lParam );
    UINT uiCmd = MyWmCommandCmd( wParam, lParam );

    switch (uiID)
    {
        case idQueryChild :
            switch (uiCmd)
            {
                case CBN_SETFOCUS:
                  _hLastToHaveFocus = _hwndQuery;
                  break;

                case CBN_SELENDOK :
                    PostMessage ( _hwndSearch,
                                  ::wmMenuCommand,
                                  IDM_SEARCH,
                                  MAKELPARAM( 1, 0 ) );
                    break;

                case CBN_DROPDOWN:
                    // This list is getting dropped
                    // Set its size
                    _view.ResizeQueryCB();
                    break;
            }
            break;
        case idListChild :
            switch (uiCmd)
            {
                case LBN_SETFOCUS :
                    _hLastToHaveFocus = _hwndList;
                    break;
                case LBN_DBLCLK :
                {
                    BOOL fCtrl = ( 0 != ( 0x8000 & GetAsyncKeyState( VK_CONTROL ) ) );
                    _DoBrowse( fCtrl ? fileOpen : fileBrowse );
                    break;
                }
            }
            break;
    }

    return 0;
} //wmCommand

LRESULT CSearchControl::wmAccelerator(
    WPARAM wParam,
    LPARAM lParam)
{
    switch (wParam)
    {
        case ACC_ALTQ :
          SetFocus(_hwndQuery);
          break;
        case ACC_ALTR :
          SetFocus(_hwndList);
          break;
        case ACC_TAB :
        case ACC_SHIFTTAB :
          if (_hLastToHaveFocus == _hwndQuery)
              SetFocus(_hwndList);
          else
              SetFocus(_hwndQuery);
          break;
    }

    return 0;
} //wmAccelerator

LRESULT CSearchControl::wmNewFont(
    WPARAM wParam,
    LPARAM lParam)
{
    HFONT hfontNew = (HFONT) wParam;

    _view.FontChanged (hfontNew);

    WCHAR awcDisplayProps[cwcBufSize];
    ULONG cb = sizeof awcDisplayProps / sizeof awcDisplayProps[0];
    if ( !GetReg( CISEARCH_REG_DISPLAYPROPS, awcDisplayProps, &cb ) )
        wcscpy( awcDisplayProps, DEFAULT_DISPLAYED_PROPERTIES );
    SetupDisplayProps( awcDisplayProps );

    SendMessage( _hwndList, WM_SETFONT, (WPARAM) hfontNew, 1L );

    SendMessage( _hwndQuery, WM_SETFONT, (WPARAM) hfontNew, 1L );

    RECT rc;
    GetClientRect( _hwndSearch, &rc );

    _view.Size( rc.right - rc.left, rc.bottom - rc.top );

    return 0;
} //wmNewFont

LRESULT CSearchControl::wmDrawItem(
    WPARAM wParam,
    LPARAM lParam)
{
    LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT) lParam;

    if (lpdis->hwndItem == _hwndList)
    {
        if (lpdis->itemID == (UINT) -1)
            lpdis->itemAction = ODA_FOCUS;

        if ( lpdis->itemAction & ODA_DRAWENTIRE )
        {
            if ( _pSearch && _pSearch->IsSelected( lpdis->itemID ) )
                lpdis->itemState |= ODS_SELECTED;

            RECT rc;
            _view.PrimeItem( lpdis, rc );

            //if ( lpdis->itemState & ( ODS_SELECTED | ODS_FOCUS ) )
            //    DrawFocusRect( lpdis->hDC, &rc );

            if ( 0 != _pSearch )
                _view.PaintItem(  _pSearch,
                                  lpdis->hDC,
                                  rc,
                                  lpdis->itemID );
        }
    }

    return 1;
} //wmDrawItem

LRESULT CSearchControl::wmAppClosing(
    WPARAM wParam,
    LPARAM lParam )
{
    SendMessage( _hwndSearch, ::wmMenuCommand, IDM_NEWSEARCH, 0 );

    return 0;
} //wmAppClosing

void CSearchControl::ResetTitle()
{
    SScopeCatalogMachine scm;


    XGrowable<WCHAR> xTitle;
    xTitle.SetSize( wcslen(_xCatList.Get()) + 50 );
    xTitle[0] = 0;

    unsigned ii;
    for ( ii = 0; ; ii++ )
    {
        if ( ! GetCatListItem( _xCatList,
                               ii,
                               scm.awcMachine,
                               scm.awcCatalog,
                               scm.awcScope,
                               scm.fDeep ) )
        {
            break;
        }

        if ( ii > 0 )
        {
            wcscat( xTitle.Get(), L", " );
        }

        if ( scm.awcMachine[0] != L'.' )
        {
            wcscat( xTitle.Get(), scm.awcMachine );
            wcscat( xTitle.Get(), L" " );
        }

        wcscat( xTitle.Get(), scm.awcCatalog );
        wcscat( xTitle.Get(), L" " );
        wcscat( xTitle.Get(), scm.awcScope );
    }

    SetWindowText( _hwndSearch, xTitle.Get() );
} //ResetTitle

//+-------------------------------------------------------------------------
//
//  Function:   MyForceMasterMerge
//
//  Synopsis:   Forces a master merge on the catalog
//
//  Arguments:  [pwcCatalog] - Catalog name
//              [pwcMachine] - Machine on which catalog resides
//
//--------------------------------------------------------------------------

HRESULT MyForceMasterMerge(
    WCHAR const * pwcCatalog,
    WCHAR const * pwcMachine )
{
    // Create the main Indexing Service administration object.

    CLSID clsid;
    HRESULT hr = CLSIDFromProgID( L"Microsoft.ISAdm", &clsid );
    if ( FAILED( hr ) )
        return hr;

    XInterface<IAdminIndexServer> xAdmin;
    hr = CoCreateInstance( clsid,
                           0,
                           CLSCTX_INPROC_SERVER,
                           __uuidof(IAdminIndexServer),
                           xAdmin.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    // Set the machine name.

    BSTR bstrMachine = SysAllocString( pwcMachine );
    if ( 0 == bstrMachine )
        return E_OUTOFMEMORY;

    XBStr xbstr( bstrMachine );
    hr = xAdmin->put_MachineName( bstrMachine );
    if ( FAILED( hr ) )
        return hr;

    // Get a catalog administration object.

    BSTR bstrCatalog = SysAllocString( pwcCatalog );
    if ( 0 == bstrCatalog )
        return E_OUTOFMEMORY;

    xbstr.Free();
    xbstr.Set( bstrCatalog );
    XInterface<ICatAdm> xCatAdmin;
    hr = xAdmin->GetCatalogByName( bstrCatalog,
                                   (IDispatch **) xCatAdmin.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    // Force the merge.

    return xCatAdmin->ForceMasterMerge();
} //MyForceMasterMerge

LRESULT CSearchControl::wmMenuCommand(
    WPARAM wParam,
    LPARAM lParam )
{
    switch (wParam)
    {
        case IDM_EDITCOPY :
            if ( ( 0 != _hwndList ) &&
                 ( _hwndList == GetFocus() ) &&
                 ( 0 != _pSearch ) &&
                 ( _pSearch->IsSelected() ) )
            {
                WCHAR *pwcPath;
                HROW hrow;

                if ( _pSearch->GetSelectedRowData( pwcPath, hrow ) )
                {
                    PutInClipboard( pwcPath );
                    _pSearch->FreeSelectedRowData( hrow );
                }
            }

            break;

        case IDM_SCOPE_AND_DEPTH:
        {
            if ( DoModalDialog( ScopeDlgProc,
                                _hwndSearch,
                                L"ScopeBox",
                                (LPARAM) &_xCatList ) )
            {
                // Get the first cat list item
                GetCatListItem( _xCatList, 0, _awcMachine, _awcCatalog, _awcScope, _fDeep );

                SendMessage(_hwndSearch,
                            ::wmMenuCommand,
                            IDM_SEARCH,
                            MAKELPARAM (1,0));
            }
            break;
        }
        case IDM_DISPLAY_PROPS:
            if ( DoModalDialog( DisplayPropsDlgProc,
                                _hwndSearch,
                                L"DisplayPropsBox",
                                (LPARAM) this ) )
            {
                SendMessage(_hwndSearch,
                            ::wmMenuCommand,
                            IDM_SEARCH,
                            MAKELPARAM (1,0));
            }
            break;

        case IDM_EDITCOPYALL :
            if (0 != _pSearch)
            {
                CWaitCursor curWait;
                _pSearch->WriteResults();
            }
            break;
        case IDM_BROWSE:
            MyPostWmCommand(_hwndSearch, idListChild, _hwndSearch, LBN_DBLCLK);
            break;

        case IDM_LIMIT_10:
            App.Limit() = 10;
            SendMessage( _hwndSearch,
                         ::wmMenuCommand,
                         IDM_SEARCH,
                         MAKELPARAM( 1, 0 ) );
            break;
        case IDM_LIMIT_300:
            App.Limit() = 300;
            SendMessage( _hwndSearch,
                         ::wmMenuCommand,
                         IDM_SEARCH,
                         MAKELPARAM( 1, 0 ) );
            break;
        case IDM_LIMIT_NONE:
            App.Limit() = 0;
            SendMessage( _hwndSearch,
                         ::wmMenuCommand,
                         IDM_SEARCH,
                         MAKELPARAM( 1, 0 ) );
            break;
        case IDM_FIRSTROWS_5:
            App.FirstRows() = 5;
            SendMessage( _hwndSearch,
                         ::wmMenuCommand,
                         IDM_SEARCH,
                         MAKELPARAM( 1, 0 ) );
            break;
        case IDM_FIRSTROWS_15:
            App.FirstRows() = 15;
            SendMessage( _hwndSearch,
                         ::wmMenuCommand,
                         IDM_SEARCH,
                         MAKELPARAM( 1, 0 ) );
            break;
        case IDM_FIRSTROWS_NONE:
            App.FirstRows() = 0;
            SendMessage( _hwndSearch,
                         ::wmMenuCommand,
                         IDM_SEARCH,
                         MAKELPARAM( 1, 0 ) );
            break;

        case IDM_DIALECT_1:
        case IDM_DIALECT_2:
            if ( wParam == IDM_DIALECT_1 )
                App.Dialect() = ISQLANG_V1;
            else
                App.Dialect() = ISQLANG_V2;
            break;

        case IDM_DIALECT_3:
            App.Dialect() = SQLTEXT;
            break;

        case IDM_LOCALE_NEUTRAL:
        case IDM_LOCALE_CHINESE_TRADITIONAL:
        case IDM_LOCALE_CHINESE_SIMPLIFIED:
        case IDM_LOCALE_CHINESE_HONGKONG:
        case IDM_LOCALE_CHINESE_SINGAPORE:
        case IDM_LOCALE_CHINESE_MACAU:
        case IDM_LOCALE_DUTCH_DUTCH:
        case IDM_LOCALE_ENGLISH_CAN:
        case IDM_LOCALE_ENGLISH_US:
        case IDM_LOCALE_ENGLISH_UK:
        case IDM_LOCALE_FINNISH_DEFAULT:
        case IDM_LOCALE_FARSI_DEFAULT:
        case IDM_LOCALE_FRENCH_FRENCH:
        case IDM_LOCALE_FRENCH_CANADIAN:
        case IDM_LOCALE_GERMAN_GERMAN:
        case IDM_LOCALE_GREEK_DEFAULT:
        case IDM_LOCALE_HEBREW_DEFAULT:
        case IDM_LOCALE_HINDI_DEFAULT:
        case IDM_LOCALE_ITALIAN_ITALIAN:
        case IDM_LOCALE_JAPANESE_DEFAULT:
        case IDM_LOCALE_KOREAN_KOREAN:
//        case IDM_LOCALE_KOREAN_JOHAB:
        case IDM_LOCALE_POLISH_DEFAULT:
        case IDM_LOCALE_ROMANIAN_DEFAULT:
        case IDM_LOCALE_RUSSIAN_DEFAULT:
        case IDM_LOCALE_SPANISH_CASTILIAN:
        case IDM_LOCALE_SPANISH_MEXICAN:
        case IDM_LOCALE_SPANISH_MODERN:
        case IDM_LOCALE_SWAHILI_DEFAULT:
        case IDM_LOCALE_SWEDISH_DEFAULT:
        case IDM_LOCALE_THAI_DEFAULT:
        case IDM_LOCALE_TURKISH_DEFAULT:
        case IDM_LOCALE_UKRAINIAN_DEFAULT:
        case IDM_LOCALE_VIETNAMESE_DEFAULT:
        {
            for ( ULONG i = 0; i < cLocaleEntries; i++ )
            {
                if ( wParam == aLocaleEntries[ i ].iMenuOption )
                {
                    _lcid = aLocaleEntries[ i ].lcid;
                    App.SetLocale( _lcid );
                    break;
                }
            }
            break;
        }

        case IDM_FORCE_USE_CI :
        {
            BOOL fTmp = App.ForceUseCI();
            App.ForceUseCI() = !fTmp;
            break;
        }
        case IDM_CATALOG_STATUS:
            // what about distributed queries?  They aren't supported

            CreateDialogParam( _hInst,
                               L"CatalogStatusBox",
                               App.AppWindow(),
                               StatusDlgProc,
                               (LPARAM) this );
            break;
        case IDM_MASTER_MERGE:
        {
            // what about distributed queries?
            SCODE sc = MyForceMasterMerge( CatalogOrNull(),
                                           Machine() );
            if ( FAILED( sc ) )
            {
                WCHAR awcError[MAX_PATH];
                FormatSrchError( sc, awcError, _lcid );
                MessageBox( _hwndSearch,
                            awcError,
                            _awcScope,
                            MB_OK|MB_ICONEXCLAMATION );
            }
            break;
        }
        case IDM_SEARCH :
        case IDM_SEARCHCLASSDEF :
        case IDM_SEARCHFUNCDEF :
        {
            CWaitCursor curWait;

            // Scope change invokes a new query, so make sure title bar is ok
            ResetTitle();

            CSearchQuery *ptmp = _pSearch;
            _pSearch = 0;

            // Let the user know we're doing something
            {
                CResString strHitCount(IDS_COUNTEND);
                _UpdateStatusWindow( strHitCount.Get(), L"" );
                UpdateWindow( App.StatusBarWindow() );
            }

            SendMessage( _hwndList, wmResetContents, 0, 0 );
            delete ptmp;

            static UINT aItem[] = { IDM_BROWSE };
            UpdateButtons( aItem, 1, FALSE );

            // Let the user know we're doing something
            {
                CResString strHitCount(IDS_COUNTSTART);
                _UpdateStatusWindow( strHitCount.Get(), L"" );
                UpdateWindow( App.StatusBarWindow() );
            }

            HWND hEdit = FindWindowEx( _hwndQuery, 0, L"EDIT", 0 );

            UINT uiLen = GetWindowTextLength(hEdit);

            if (0 == uiLen)
            {
                CResString strCount (IDS_COUNTTITLE);
                SendMessage( App.StatusBarWindow(), SB_SETTEXT, idStatusMsg, (LPARAM) strCount.Get() );
            }
            else
            {
                WCHAR * pwcBuf = new WCHAR [uiLen + 1];

                TRY
                {
                    GetWindowText (hEdit, pwcBuf, uiLen + 1);

                    ESearchType st = srchNormal;

                    if (IDM_SEARCHCLASSDEF == wParam)
                        st = srchClass;
                    else if (IDM_SEARCHFUNCDEF == wParam)
                        st = srchFunction;

                    //----------
                    // NEW QUERY
                    //----------

                    _pSearch = new CSearchQuery( _xCatList,
                                                 pwcBuf,
                                                 _hwndSearch,
                                                 _view.Lines(),
                                                 _lcid,
                                                 st,
                                                 _xColumnMapper.GetReference(),
                                                 _columns,
                                                 _sort,
                                                 App.Dialect(),
                                                 App.Limit(),
                                                 App.FirstRows() );
                    _pSearch->InitNotifications(_hwndList);

                    // Scope may have changed if server was down
                    ResetTitle();

                    // Let the user know we're doing something
                    {
                        WCHAR awcCount[100];
                        CResString strHitCount(IDS_HITCOUNT);
                        swprintf( awcCount, strHitCount.Get(), 0, 0.0f );
                        SendMessage( App.StatusBarWindow(), SB_SETTEXT, SBT_OWNERDRAW | idStatusRatio, 0 );
                        SendMessage( App.StatusBarWindow(), SB_SETTEXT, idStatusMsg, (LPARAM) awcCount );
                        UpdateWindow( App.StatusBarWindow() );
                    }

                    MySendEMSetSel( hEdit, 0, (UINT) -1 );

                    if ( CB_ERR == SendMessage( _hwndQuery, CB_FINDSTRINGEXACT, -1, (LPARAM) pwcBuf ) )
                    {
                        SendMessage( _hwndQuery, CB_INSERTSTRING, 0, (LPARAM) pwcBuf );
                    }

                    //_history.Add( pwcBuf );

                    delete [] pwcBuf;
                    pwcBuf = 0;
                }
                CATCH (CException, e )
                {
                    SCODE sc = e.GetErrorCode();
                    if ( 0 == _pSearch )
                    {
                        // check for version mismatch, otherwise just report
                        // the error

                        if ( STATUS_INVALID_PARAMETER_MIX == sc )
                        {
                            SearchError( _hwndSearch,
                                         IDS_ERR_BAD_VERSION,
                                         _awcScope );
                        }
                        else  // if ( QUERY_E_ALLNOISE != sc )
                        {
                            WCHAR awcError[MAX_PATH];
                            FormatSrchError( sc, awcError, _lcid );
                            CResString strErr( IDS_ERR_QUERY_ERROR );
                            WCHAR awcMsg[MAX_PATH];
                            swprintf( awcMsg, strErr.Get(), awcError );
                            MessageBox( _hwndSearch,
                                        awcMsg,
                                        _awcScope,
                                        MB_OK|MB_ICONEXCLAMATION );
                        }
                    }
                    else
                    {
                        delete _pSearch;
                        _pSearch = 0;
                    }

                    delete [] pwcBuf;

                    CResString strCount (IDS_COUNTTITLE);
                    SendMessage( App.StatusBarWindow(), SB_SETTEXT,
                                 idStatusMsg, (LPARAM) strCount.Get() );
                }
                END_CATCH;
            }
        }
        break;
        case IDM_NEWSEARCH :
        {
            CWaitCursor curWait;

            CSearchQuery *ptmp = _pSearch;
            _pSearch = 0;

            // Let the user know we're doing something
            {
                CResString strHitCount(IDS_COUNTEND);
                _UpdateStatusWindow( strHitCount.Get(), L"" );
                UpdateWindow( App.StatusBarWindow() );
            }

            delete ptmp;

            static UINT aItem[] = { IDM_BROWSE };
            UpdateButtons( aItem, 1, FALSE );

            ResetTitle();

            CResString strCount (IDS_COUNTTITLE);
            _UpdateStatusWindow( strCount.Get(), L"" );

            SetWindowText( _hwndQuery, L"") ;
            SendMessage( _hwndList, wmResetContents, 0, 0 );
            SetFocus( _hwndQuery );
        }
        break;
    }

    return 0;
} //wmMenuCommand

LRESULT CSearchControl::wmSetFocus(
    WPARAM wParam,
    LPARAM lParam )
{
    if (0 != _hLastToHaveFocus)
        SetFocus(_hLastToHaveFocus);

    return 0;
} //wmSetFocus

LRESULT CSearchControl::wmClose(
    WPARAM wParam,
    LPARAM lParam )
{
    SendMessage( _hwndSearch, ::wmMenuCommand, IDM_NEWSEARCH, 0 );

    return 0;
} //wmClose

void _CheckReliability(
    DWORD   dwStatus,
    DWORD   bit,
    UINT    msg,
    WCHAR * pwcMsg )
{
    if ( QUERY_RELIABILITY_STATUS( dwStatus ) & bit )
    {
        CResString str( msg );
        if ( 0 != pwcMsg[ 0 ] )
            wcscat( pwcMsg, L" / " );
        wcscat( pwcMsg, str.Get() );
    }
} //_CheckReliability

void CSearchControl::_UpdateCount()
{
    if ( _hwndSearch == App.GetActiveMDI() )
    {
        WCHAR awcCount[200];
        CResString strHitCount;
        WCHAR awcReliability[MAX_PATH];
        awcReliability[ 0 ] = 0;

        DWORD dwStatus = 0;

        if ( _pSearch )
        {
            strHitCount.Load( IDS_HITCOUNT );

            swprintf( awcCount,
                      strHitCount.Get(),
                      _pSearch->RowCount(),
                      (float) _pSearch->QueryTime() );

            dwStatus = _pSearch->QueryStatus();

            if ( 0 != _pSearch->LastError() )
            {
                FormatSrchError( _pSearch->LastError(), awcReliability, _lcid );
            }
            else
            {
                _CheckReliability( dwStatus,
                                   STAT_CONTENT_OUT_OF_DATE,
                                   IDS_RELIABILITY_OUTOFDATE,
                                   awcReliability );

                _CheckReliability( dwStatus,
                                   STAT_NOISE_WORDS,
                                   IDS_RELIABILITY_NOISE,
                                   awcReliability );

                _CheckReliability( dwStatus,
                                   STAT_PARTIAL_SCOPE,
                                   IDS_RELIABILITY_PARTIAL,
                                   awcReliability );

                _CheckReliability( dwStatus,
                                   STAT_REFRESH_INCOMPLETE,
                                   IDS_RELIABILITY_REFRESH_INCOMPLETE,
                                   awcReliability );

                _CheckReliability( dwStatus,
                                   STAT_CONTENT_QUERY_INCOMPLETE,
                                   IDS_RELIABILITY_CONTENT_QUERY_INCOMPLETE,
                                   awcReliability );

                _CheckReliability( dwStatus,
                                   STAT_TIME_LIMIT_EXCEEDED,
                                   IDS_RELIABILITY_TIME_LIMIT_EXCEEDED,
                                   awcReliability );
            }
        }
        else
        {
            CResString strCount( IDS_COUNTTITLE );
            wcscpy( awcCount, strCount.Get() );
        }

        _UpdateStatusWindow( awcCount, awcReliability );
        UpdateWindow( App.StatusBarWindow() );
    }
} //_UpdateCount

LRESULT CSearchControl::wmNotification(
    WPARAM wParam,
    LPARAM lParam)
{
    if (0 != _pSearch)
    {
        _pSearch->ProcessNotification( _hwndList,
                                       DBWATCHNOTIFY(wParam),
                                       (IRowset*)lParam);

        BOOL fMore;
        _pSearch->UpdateProgress( fMore );
        PostMessage( _hwndList, wmSetCountBefore, 0,
                     (LPARAM)_pSearch->RowCurrent() );
        PostMessage( _hwndList, wmSetCount, 0,
                     (LPARAM)_pSearch->RowCount() );
        _UpdateCount();

        _pSearch->ProcessNotificationComplete();
    }

    return 0;
} //wmNotification

LRESULT CSearchControl::wmInitMenu(
    WPARAM wParam,
    LPARAM lParam)
{
    HMENU hmenu = (HMENU) wParam;

    for ( ULONG i = 0; i < cLocaleEntries; i++ )
    {
        DWORD option = aLocaleEntries[ i ].iMenuOption;
        EnableMenuItem( hmenu, option, MF_ENABLED );

        LCID lcid = aLocaleEntries[ i ].lcid;
        CheckMenuItem( hmenu,
                       option,
                       _lcid == lcid ? MF_CHECKED : MF_UNCHECKED );
    }
    EnableMenuItem(hmenu,IDM_SEARCH,MF_ENABLED);

    if ( SQLTEXT == App.Dialect() )
    {
        EnableMenuItem( hmenu, IDM_SEARCHCLASSDEF, MF_GRAYED );
        EnableMenuItem( hmenu, IDM_SEARCHFUNCDEF, MF_GRAYED );
    }
    else
    {
        EnableMenuItem( hmenu, IDM_SEARCHCLASSDEF, MF_ENABLED );
        EnableMenuItem( hmenu, IDM_SEARCHFUNCDEF, MF_ENABLED);
    }

    EnableMenuItem(hmenu,IDM_NEWSEARCH,MF_ENABLED);
    EnableMenuItem(hmenu,IDM_SCOPE_AND_DEPTH,MF_ENABLED);
    EnableMenuItem(hmenu,IDM_FILTER_SCOPE,MF_ENABLED);

    EnableMenuItem(hmenu,IDM_DISPLAY_PROPS,MF_ENABLED);

    EnableMenuItem(hmenu, IDM_FORCE_USE_CI, MF_ENABLED);
    CheckMenuItem(hmenu, IDM_FORCE_USE_CI, App.ForceUseCI() ? MF_CHECKED : MF_UNCHECKED );

    EnableMenuItem( hmenu, IDM_DIALECT_1, MF_ENABLED );
    EnableMenuItem( hmenu, IDM_DIALECT_2, MF_ENABLED );
    EnableMenuItem( hmenu, IDM_DIALECT_3, MF_ENABLED );
    CheckMenuItem( hmenu, IDM_DIALECT_1, ISQLANG_V1 == App.Dialect() ? MF_CHECKED : MF_UNCHECKED );
    CheckMenuItem( hmenu, IDM_DIALECT_2, ISQLANG_V2 == App.Dialect() ? MF_CHECKED : MF_UNCHECKED );
    CheckMenuItem( hmenu, IDM_DIALECT_3, SQLTEXT == App.Dialect() ? MF_CHECKED : MF_UNCHECKED );

    EnableMenuItem( hmenu, IDM_LIMIT_10, MF_ENABLED );
    EnableMenuItem( hmenu, IDM_LIMIT_300, MF_ENABLED );
    EnableMenuItem( hmenu, IDM_LIMIT_NONE, MF_ENABLED );
    CheckMenuItem( hmenu, IDM_LIMIT_10, 10 == App.Limit() ? MF_CHECKED : MF_UNCHECKED );
    CheckMenuItem( hmenu, IDM_LIMIT_300, 300 == App.Limit() ? MF_CHECKED : MF_UNCHECKED );
    CheckMenuItem( hmenu, IDM_LIMIT_NONE, 0 == App.Limit() ? MF_CHECKED : MF_UNCHECKED );

    EnableMenuItem( hmenu, IDM_FIRSTROWS_5, MF_ENABLED );
    EnableMenuItem( hmenu, IDM_FIRSTROWS_15, MF_ENABLED );
    EnableMenuItem( hmenu, IDM_FIRSTROWS_NONE, MF_ENABLED );
    CheckMenuItem( hmenu, IDM_FIRSTROWS_5, 5 == App.FirstRows() ? MF_CHECKED : MF_UNCHECKED );
    CheckMenuItem( hmenu, IDM_FIRSTROWS_15, 15 == App.FirstRows() ? MF_CHECKED : MF_UNCHECKED );
    CheckMenuItem( hmenu, IDM_FIRSTROWS_NONE, 0 == App.FirstRows() ? MF_CHECKED : MF_UNCHECKED );

    EnableMenuItem(hmenu,IDM_CATALOG_STATUS,MF_ENABLED);
    EnableMenuItem(hmenu,IDM_MASTER_MERGE,MF_ENABLED);

    if ( 0 != _hwndList && _hwndList == GetFocus() )
    {
        if (0 != _pSearch && _pSearch->IsSelected())
        {
            EnableMenuItem( hmenu, IDM_BROWSE, MF_ENABLED );
            EnableMenuItem( hmenu, IDM_EDITCOPY, MF_ENABLED );
        }
    }

    if ( 0 != _pSearch && 0 != _pSearch->RowCount() )
        EnableMenuItem( hmenu, IDM_EDITCOPYALL, MF_ENABLED );

    return 0;
} //wmInitMenu

LRESULT CSearchControl::wmMeasureItem(
    WPARAM wParam,
    LPARAM lParam)
{
    MEASUREITEMSTRUCT* lpmis = (MEASUREITEMSTRUCT*) lParam;

    if (lpmis->CtlType == odtListView)
        lpmis->itemHeight = _view.GetLineHeight();

    return 0;
} //wmMeasureItem

void SStatusDlg::SetCaption()
{
    CResString str( IDS_STATUS_CAPTION );
    WCHAR awc[ MAX_PATH + 100 ];
    WCHAR *pwcCat = _CatalogOrNull();
    WCHAR *pwcScope = _Scope();
    WCHAR *pwcMachine = _Machine();
    WCHAR awcM[ SRCH_COMPUTERNAME_LENGTH + 2 ];
    if ( L'.' == *pwcMachine )
        awcM[0] = 0;
    else
    {
        awcM[0] = ' ';
        wcscpy( awcM+1, pwcMachine );
    }
    wsprintf( awc, str.Get(), awcM, pwcCat ? pwcCat : pwcScope );
    SetWindowText( _hdlg, awc );
} //SetCaption

const DWORD ALL_CI_MERGE = ( CI_STATE_SHADOW_MERGE |
                             CI_STATE_ANNEALING_MERGE |
                             CI_STATE_MASTER_MERGE |
                             CI_STATE_MASTER_MERGE_PAUSED );

void SStatusDlg::Update()
{
    CI_STATE state;
    RtlZeroMemory( &state, sizeof state );
    state.cbStruct = sizeof state;

    SCODE sc = CIState( _CatalogOrNull(),
                        _Machine(),
                        & state );

    if ( SUCCEEDED( sc ) )
    {
        SetDlgItemInt( _hdlg, ID_STAT_FTF,   state.cDocuments, FALSE );
        SetDlgItemInt( _hdlg, ID_STAT_SECQ,  state.cSecQDocuments, FALSE );
        SetDlgItemInt( _hdlg, ID_STAT_FF,    state.cFilteredDocuments, FALSE );
        SetDlgItemInt( _hdlg, ID_STAT_FTE,   state.cFreshTest, FALSE );
        SetDlgItemInt( _hdlg, ID_STAT_WL,    state.cWordList, FALSE );
        SetDlgItemInt( _hdlg, ID_STAT_PI,    state.cPersistentIndex, FALSE );
        SetDlgItemInt( _hdlg, ID_STAT_KEYS,  state.cUniqueKeys, FALSE );
        SetDlgItemInt( _hdlg, ID_STAT_FILES, state.cTotalDocuments, FALSE );
        SetDlgItemInt( _hdlg, ID_STAT_Q,     state.cQueries, FALSE );

        if ( 0 != ( state.eState & CI_STATE_SCANNING ) )
        {
            WCHAR awcTmp[50];
            swprintf( awcTmp, L"%ws: %d", App.GetYes(), state.cPendingScans );
            SetDlgItemText( _hdlg, ID_STAT_SCANNING, awcTmp );
        }
        else
        {
            SetDlgItemText( _hdlg, ID_STAT_SCANNING, App.GetNo() );
        }

        unsigned idStatus = IDS_CI_STATE_OK;

        if ( 0 != ( state.eState & CI_STATE_RECOVERING ) )
            idStatus = IDS_CI_STATE_RECOVER;
        else if ( 0 != ( state.eState & CI_STATE_HIGH_IO ) )
            idStatus = IDS_CI_STATE_HIIO;
        else if ( 0 != ( state.eState & CI_STATE_LOW_MEMORY ) )
            idStatus = IDS_CI_STATE_LOMEM;
        else if ( 0 != ( state.eState & CI_STATE_BATTERY_POWER ) )
            idStatus = IDS_CI_STATE_BATTERY;
        else if ( 0 != ( state.eState & CI_STATE_READ_ONLY ) )
            idStatus = IDS_CI_STATE_READ_ONLY;
        else if ( 0 != ( state.eState & CI_STATE_USER_ACTIVE ) )
            idStatus = IDS_CI_STATE_USER_ACTIVE;
        else if ( 0 != ( state.eState & CI_STATE_STARTING ) )
            idStatus = IDS_CI_STATE_STARTING;
        else if ( 0 != ( state.eState & CI_STATE_READING_USNS ) )
            idStatus = IDS_CI_STATE_READING_USNS;

        {
            CResString str( idStatus );
            SetDlgItemText( _hdlg, ID_STAT_STATUS, str.Get() );
        }

        if ( 0 != ( state.eState & ALL_CI_MERGE ) )
        {
            unsigned idStr;
            if ( state.eState & CI_STATE_SHADOW_MERGE )
                idStr = IDS_MERGE_SHADOW;
            else if ( state.eState & CI_STATE_ANNEALING_MERGE )
                idStr = IDS_MERGE_ANNEALING;
            else if ( state.eState & CI_STATE_MASTER_MERGE )
                idStr = IDS_MERGE_MASTER;
            else
                idStr = IDS_MERGE_MASTER_PAUSED;

            CResString str( idStr );
            WCHAR awc[ cwcBufSize ];
            swprintf( awc,
                      L"%ws %d%%",
                      str.Get(),
                      state.dwMergeProgress );
            SetDlgItemText( _hdlg, ID_STAT_MT, awc );
        }
        else
        {
            SetDlgItemText( _hdlg, ID_STAT_MT, App.GetNo() );
        }
    }
    else
    {
        WCHAR awcTmp[80];
        swprintf( awcTmp, L"0x%x", sc );
        //FormatSrchError( sc, awcTmp, App.GetLocale() );
        SetDlgItemText( _hdlg, ID_STAT_STATUS, awcTmp );

        SetDlgItemText( _hdlg, ID_STAT_FTF, L"" );
        SetDlgItemText( _hdlg, ID_STAT_SECQ, L"" );
        SetDlgItemText( _hdlg, ID_STAT_FF, L"" );
        SetDlgItemText( _hdlg, ID_STAT_FTE, L"" );
        SetDlgItemText( _hdlg, ID_STAT_WL, L"" );
        SetDlgItemText( _hdlg, ID_STAT_PI, L"" );
        SetDlgItemText( _hdlg, ID_STAT_KEYS, L"" );
        SetDlgItemText( _hdlg, ID_STAT_FILES, L"" );
        SetDlgItemText( _hdlg, ID_STAT_Q, L"" );

        SetDlgItemText( _hdlg, ID_STAT_SCANNING, L"" );
        SetDlgItemText( _hdlg, ID_STAT_MT, L"" );
    }
} //Update

INT_PTR WINAPI StatusDlgProc(
    HWND   hdlg,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam )
{
    BOOL fRet = FALSE;
    SStatusDlg * pstat = (SStatusDlg *) GetWindowLongPtr( hdlg, DWLP_USER );

    switch( msg )
    {
        case WM_INITDIALOG :
        {
            CSearchControl &ctrl = * (CSearchControl *) lParam;
            pstat = new SStatusDlg( ctrl, hdlg );
            SetWindowLongPtr( hdlg, DWLP_USER, (LONG_PTR) pstat );
            fRet = TRUE;
            SetTimer( hdlg, 2, 1000, 0);

            int left,top,right,bottom;
            if ( LoadWindowRect( &left,
                                 &top,
                                 &right,
                                 &bottom,
                                 CISEARCH_REG_STATUSPOSITION ) )
            {
                RECT rc;
                GetWindowRect( hdlg,(LPRECT) &rc );
                MoveWindow( hdlg,
                            left,
                            top,
                            rc.right - rc.left,
                            rc.bottom - rc.top,
                            FALSE );
            }

            pstat->SetCaption();
            pstat->Update();
            break;
        }
        case WM_ACTIVATE :
        {
            if ( 0 == wParam )
                App.GetCurrentDialog() = 0;
            else
                App.GetCurrentDialog() = hdlg;
            break;
        }
        case WM_TIMER :
        {
            if ( ! IsIconic( App.AppWindow() ) )
                pstat->Update();
            break;
        }
        case WM_DESTROY :
        {
            KillTimer( hdlg, 2 );
            App.GetCurrentDialog() = 0;
            SaveWindowRect( hdlg, CISEARCH_REG_STATUSPOSITION );
            SetWindowLongPtr( hdlg, DWLP_USER, 0 );
            delete pstat;
            break;
        }
        case WM_COMMAND :
        {
            UINT uiID = MyWmCommandID( wParam, lParam );

            switch( uiID )
            {
                case IDCANCEL :
                {
                    DestroyWindow( hdlg );
                    fRet = TRUE;
                    break;
                }
            }
            break;
        }
    }

    return fRet;
} //StatusDlgProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\srch\srchutil.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999.
//
//  File:       srchutil.cxx
//
//  Contents:   
//
//  History:    15 Aug 1996     DLee    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

void SetReg(
    WCHAR const * pwcName,
    WCHAR const * pwcValue)
{
    HKEY hKeyParent;

    if (ERROR_SUCCESS ==
        RegOpenKeyEx(HKEY_CURRENT_USER,CISEARCH_PARENT_REG_KEY,0,
                     KEY_ALL_ACCESS,&hKeyParent))
    {
        DWORD dwDisp;
        HKEY hKey;

        if (ERROR_SUCCESS ==
            RegCreateKeyEx(hKeyParent,CISEARCH_REG_SUBKEY,0,L"",
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,0,&hKey,&dwDisp))
        {
            RegSetValueEx(hKey,pwcName,0,REG_SZ,(LPBYTE) pwcValue,
                          sizeof(WCHAR) * (wcslen(pwcValue) + 1));
            RegCloseKey(hKey);
        }
        RegCloseKey(hKeyParent);
    }
} //SetReg

BOOL GetReg(
    WCHAR const * pwcName,
    WCHAR *       pwcValue,
    DWORD *       pdwSize)
{
    BOOL fOk = FALSE;
    HKEY hKeyParent;

    if (ERROR_SUCCESS ==
        RegOpenKeyEx(HKEY_CURRENT_USER,CISEARCH_PARENT_REG_KEY,0,
                     KEY_ALL_ACCESS,&hKeyParent))
    {
        DWORD dwDisp;
        HKEY hKey;

        if (ERROR_SUCCESS ==
            RegCreateKeyEx(hKeyParent,CISEARCH_REG_SUBKEY,0,L"",
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,0,&hKey,&dwDisp))
        {
            DWORD dwType;
            if (ERROR_SUCCESS == RegQueryValueEx(hKey,pwcName,0,&dwType,
                                                 (LPBYTE) pwcValue,pdwSize))
                fOk = TRUE;

            RegCloseKey(hKey);
        }
        RegCloseKey(hKeyParent);
    }

    return fOk;
} //GetReg


LCID GetRegLCID(
    WCHAR const * pwcName,
    LCID          defLCID )
{
    WCHAR awc[100];
    DWORD dw = sizeof awc / sizeof awc[0];

    if (GetReg(pwcName,awc,&dw))
        return _wtoi(awc);
    else
        return defLCID;
} //GetRegLCID


void SetRegLCID(
    WCHAR const * pwcName,
    LCID          lcid )
{
    WCHAR awc[20];

    // itow is not in all C runtimes _itow(iValue,awc,10);
    swprintf( awc, L"%d", lcid );
    SetReg( pwcName, awc );
} //SetRegLCID


int GetRegInt(
    WCHAR const * pwcName,
    int           iDef)
{
    WCHAR awc[100];
    DWORD dw = sizeof awc / sizeof awc[0];

    if (GetReg(pwcName,awc,&dw))
        return _wtoi(awc);
    else
        return iDef;
} //GetRegInt

void SetRegInt(
    WCHAR const * pwcName,
    int           iValue)
{
    WCHAR awc[20];

    // itow is not in all C runtimes _itow(iValue,awc,10);
    swprintf( awc, L"%d", iValue );
    SetReg( pwcName, awc );
} //SetRegInt


BOOL IsSpecificClass(
    HWND          hwnd,
    WCHAR const * pwcClass)
{
    WCHAR awcClass[60];

    GetClassName(hwnd,awcClass,(sizeof awcClass / sizeof WCHAR) - 1);

    return !wcscmp( awcClass, pwcClass );
} //IsSpecificClass

int GetLineHeight(
    HWND  hwnd,
    HFONT hFont)
{
    if (hFont == 0)
        hFont = (HFONT) SendMessage(hwnd, WM_GETFONT, 0, 0);

    HDC hdc;
    int iHeight=0;

    if (hdc = GetDC(hwnd))
    {
        HFONT hOldFont;
        if (hOldFont = (HFONT) SelectObject(hdc,hFont))
        {
            TEXTMETRIC tm;
            GetTextMetrics(hdc,&tm);
            iHeight = (tm.tmHeight + 2 * tm.tmExternalLeading);
            SelectObject(hdc,hOldFont);
        }
        ReleaseDC(hwnd,hdc);
    }

    return iHeight;
} //GetLineHeight

int GetAvgWidth(
    HWND  hwnd,
    HFONT hFont)
{
    if (hFont == 0)
        hFont = (HFONT) SendMessage(hwnd, WM_GETFONT, 0, 0);

    HDC hdc;
    LONG cpWidth = 0;

    if (hdc = GetDC(hwnd))
    {
        HFONT hOldFont;
        if (hOldFont = (HFONT) SelectObject(hdc,hFont))
        {
            TEXTMETRIC tm;
            GetTextMetrics(hdc,&tm);
            cpWidth = tm.tmAveCharWidth;
            SelectObject(hdc,hOldFont);
        }
        ReleaseDC(hwnd,hdc);
    }

    return cpWidth;
} //GetAvgWidth

INT_PTR DoModalDialog(
    DLGPROC fp,
    HWND hParent,
    WCHAR * pwcName,
    LPARAM lParam)
{
    return DialogBoxParam(MyGetWindowInstance(hParent),
                          pwcName,
                          hParent,
                          fp,
                          lParam);
} //DoModalDialog

void SaveWindowRect(
    HWND          hwnd,
    WCHAR const * pwc )
{
    if (! (IsZoomed(hwnd) || IsIconic(hwnd)))
    {
        RECT rc;
        GetWindowRect(hwnd,&rc);

        WCHAR awc[100];
        swprintf(awc,L"%d %d %d %d",rc.left,rc.top,rc.right,rc.bottom);

        SetReg( pwc, awc );
    }
} //SaveWindowRect

BOOL LoadWindowRect(
    int *         left,
    int *         top,
    int *         right,
    int *         bottom,
    WCHAR const * pwc )
{
    WCHAR awc[100];
    DWORD dw = sizeof awc / sizeof awc[0];

    if ( GetReg( pwc, awc, &dw ) )
    {
        swscanf(awc,L"%d %d %d %d",left,top,right,bottom);
        *right = *right - *left;
        *bottom = *bottom - *top;
        return TRUE;
    }
    else
    {
        *left = *top = *right = *bottom = CW_USEDEFAULT;
        return FALSE;
    }
} //LoadWindowRect

int GetWindowState(
    BOOL bApp)
{
    WCHAR awcValue[100],awcBuf[100];

    if (bApp)
        wcscpy(awcBuf,L"main");
    else
        wcscpy(awcBuf,L"mdi");

    wcscat(awcBuf,L"-state");

    DWORD dw = sizeof awcValue / sizeof awcValue[0];
    int iState;

    if (GetReg(awcBuf,awcValue,&dw))
        iState = awcValue[0] - L'0';
    else
        iState = 1;

    return iState;
} //GetWindowState

void PassOnToEdit(
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hwndActive = GetFocus();

    if ( 0 != hwndActive )
    {
        WCHAR awcBuf[60];
        int r = GetClassName(hwndActive,awcBuf,(sizeof awcBuf / sizeof WCHAR) - 1);

        if ( 0 == r )
            return;

        if ( ( !_wcsicmp( awcBuf, L"Edit" ) ) ||
             ( !_wcsicmp( awcBuf, L"RichEdit" ) ) )
            SendMessage( hwndActive, msg, wParam, lParam);
    }
} //PassOnToEdit

void WINAPI CenterDialog(
    HWND hdlg)
{
    RECT rcParent;
    RECT rc;

    GetWindowRect(hdlg,(LPRECT) &rc);
    GetWindowRect(GetParent(hdlg),(LPRECT) &rcParent);

    LONG xbias = rcParent.left + (rcParent.right - rcParent.left)/2;
    LONG ybias = rcParent.top + (rcParent.bottom - rcParent.top)/2;
    LONG lWidth = rc.right - rc.left;
    LONG lHeight = rc.bottom - rc.top;

    MoveWindow(hdlg, xbias - lWidth/2,
                     ybias - lHeight/2,
                     lWidth,lHeight,FALSE);
} //CenterDialog

//+---------------------------------------------------------------------------
//
//  Function:   ConvertGroupingStringToInt
//
//  Synopsis:   Converts a grouping string from the registry to an integer,
//              as required by the Win32 number formatting API
//
//  History:    5-Feb-99   dlee      Stole from the Win32 implementation
//
//----------------------------------------------------------------------------

int ConvertGroupingStringToInt( WCHAR const * pwcGrouping )
{
    XGrowable<WCHAR> xDest( 1 + wcslen( pwcGrouping ) );
    WCHAR * pDest = xDest.Get();

    //
    //  Filter out all non-numeric values and all zero values.
    //  Store the result in the destination buffer.
    //

    WCHAR const * pSrc  = pwcGrouping;

    while (0 != *pSrc)
    {
        if ( ( *pSrc < L'1' ) || ( *pSrc > L'9' ) )
        {
            pSrc++;
        }
        else
        {
            if (pSrc != pDest)
                *pDest = *pSrc;

            pSrc++;
            pDest++;
        }
    }

    //
    // Make sure there is something in the destination buffer.
    // Also, see if we need to add a zero in the case of 3;2 becomes 320.
    //

    if ( ( pDest == xDest.Get() ) || ( *(pSrc - 1) != L'0' ) )
    {
        *pDest = L'0';
        pDest++;
    }

    // Null terminate the buffer.

    *pDest = 0;

    // Convert the string to an integer.

    return _wtoi( xDest.Get() );
} //ConvertGroupingStringToInt

void LoadNumberFormatInfo(
    NUMBERFMT & rFormat)
{
    LCID lcid = GetUserDefaultLCID();

    WCHAR awcBuf[cwcBufSize];

    //  Get the number of decimal digits.
    GetLocaleInfo(lcid,LOCALE_IDIGITS,awcBuf,cwcBufSize);
    rFormat.NumDigits = _wtoi(awcBuf);

    //  Get the leading zero in decimal fields option.
    GetLocaleInfo(lcid,LOCALE_ILZERO,awcBuf,cwcBufSize);
    rFormat.LeadingZero = _wtoi(awcBuf);

    //  Get the negative ordering.
    GetLocaleInfo(lcid,LOCALE_INEGNUMBER,awcBuf,cwcBufSize);
    rFormat.NegativeOrder = _wtoi(awcBuf);

    //  Get the grouping left of the decimal.
    GetLocaleInfo(lcid,LOCALE_SGROUPING,awcBuf,cwcBufSize);
    rFormat.Grouping = ConvertGroupingStringToInt( awcBuf );

    //  Get the decimal separator.
    GetLocaleInfo(lcid,LOCALE_SDECIMAL,awcBuf,cwcBufSize);
    rFormat.lpDecimalSep = new WCHAR[wcslen(awcBuf) + 1];
    wcscpy(rFormat.lpDecimalSep,awcBuf);

    //  Get the thousand separator.
    GetLocaleInfo(lcid,LOCALE_STHOUSAND,awcBuf,cwcBufSize);
    rFormat.lpThousandSep = new WCHAR[wcslen(awcBuf) + 1];
    wcscpy(rFormat.lpThousandSep,awcBuf);
} //LoadNumberFormatInfo

void FreeNumberFormatInfo(
    NUMBERFMT & rFormat)
{
    delete rFormat.lpDecimalSep;
    delete rFormat.lpThousandSep;
} //FreeNumberFormatInfo

void SearchError(
    HWND          hParent,
    ULONG         dwErrorID,
    WCHAR const * pwcTitle)
{
    CResString str( dwErrorID );
    MessageBox( hParent, str.Get(), pwcTitle, MB_OK | MB_ICONEXCLAMATION );
} //SearchError

void PutInClipboard(
    WCHAR const * pwcBuffer )
{
    if ( OpenClipboard( App.AppWindow() ) )
    {
        EmptyClipboard();

        HGLOBAL hglbCopy = GlobalAlloc( GMEM_DDESHARE,
                           ( wcslen( pwcBuffer ) + 1 ) *
                           sizeof WCHAR );

        if ( 0 != hglbCopy )
        {
            WCHAR *pwc = (WCHAR *) GlobalLock( hglbCopy );
            wcscpy( pwc, pwcBuffer );
            GlobalUnlock( hglbCopy );
            SetClipboardData( CF_UNICODETEXT, hglbCopy );
        }

        CloseClipboard();
    }
} //PutInClipboard

BOOL GetRegEditor(
    WCHAR const * pwcName,
    WCHAR *       pwcValue,
    DWORD *       pdwSize)
{
    BOOL fOk = FALSE;
    HKEY hKeyParent;

    if (ERROR_SUCCESS ==
        RegOpenKeyEx(HKEY_CURRENT_USER,L"software\\microsoft",0,
                     KEY_ALL_ACCESS,&hKeyParent))
    {
        DWORD dwDisp;
        HKEY hKey;

        if (ERROR_SUCCESS ==
            RegCreateKeyEx(hKeyParent,L"Windiff",0,L"",
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,0,&hKey,&dwDisp))
        {
            DWORD dwType;
            if (ERROR_SUCCESS == RegQueryValueEx(hKey,pwcName,0,&dwType,
                                                 (LPBYTE) pwcValue,pdwSize))
                fOk = TRUE;

            RegCloseKey(hKey);
        }
        RegCloseKey(hKeyParent);
    }

    return fOk;
} //GetRegEditor

void FormatSrchError( SCODE sc, WCHAR * pwc, LCID lcid )
{
    LCID SaveLCID = GetThreadLocale();
    SetThreadLocale( lcid );

    ULONG Win32status = sc;
    if ( (Win32status & (FACILITY_WIN32 << 16)) == (FACILITY_WIN32 << 16) )
        Win32status &= ~( 0x80000000 | (FACILITY_WIN32 << 16) );

    if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                          GetModuleHandle(L"query.dll"),
                          sc,
                          0,
                          pwc,
                          MAX_PATH,
                          0 ) )
    {
        //
        //  Try looking up the error in the Win32 list of error codes
        //
        if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                              GetModuleHandle(L"kernel32.dll"),
                              Win32status,
                              0,
                              pwc,
                              MAX_PATH,
                              0 ) )
        {
            swprintf( pwc, L"0x%x", sc );
        }
    }

    SetThreadLocale(SaveLCID);
} //FormatSrchError

BOOL CopyURL( WCHAR const * pwcURL, WCHAR * awcTempName )
{
   WCHAR const * pwcSlash = wcsrchr( pwcURL, L'/' );

   if ( 0 == pwcSlash )
       return FALSE;

   pwcSlash++;

   DWORD cwc = GetTempPath( MAX_PATH, awcTempName );

   if ( 0 == cwc || cwc > MAX_PATH )
       return FALSE;

   wcscat( awcTempName, pwcSlash );

    XIHandle xhI( InternetOpenW( L"srch",
                                 INTERNET_OPEN_TYPE_PRECONFIG,
                                 0,
                                 0,
                                 0 ) );
    if ( xhI.IsNull() )
        return FALSE;

    XIHandle xhUrl( InternetOpenUrlW( xhI.Get(), pwcURL, 0, 0,
                                      INTERNET_FLAG_RELOAD |
                                      INTERNET_FLAG_DONT_CACHE |
                                      INTERNET_FLAG_PRAGMA_NOCACHE |
                                      INTERNET_FLAG_NO_CACHE_WRITE |
                                      INTERNET_FLAG_NO_COOKIES |
                                      INTERNET_FLAG_NO_UI,
                                      0 ) );

    if ( xhUrl.IsNull() )
        return FALSE;

    FILE * fp = _wfopen( awcTempName, L"wb" );

    if ( 0 == fp )
        return FALSE;

    char ac[ 1024 * 16 ];

    do
    {
        DWORD cbRead = 0;
        BOOL fOK = InternetReadFile( xhUrl.Get(),
                                     ac,
                                     sizeof ac,
                                     &cbRead );
        if ( !fOK )
        {
            fclose( fp );
            return FALSE;
        }

        if ( 0 == cbRead )
            break;

        fwrite( ac, 1, cbRead, fp );
    } while( TRUE );

    fclose( fp );

    return TRUE;
} //CopyURL

BOOL InvokeBrowser(
    WCHAR const *   pwcFilePath,
    DBCOMMANDTREE * prstQuery )
{
    WCHAR awcTempFile[MAX_PATH];
    BOOL fDeleteWhenDone = FALSE;

    if ( !_wcsnicmp( pwcFilePath, L"file:", 5 ) )
        pwcFilePath += 5;
    else if ( !_wcsnicmp( pwcFilePath, L"http:", 5 ) )
    {
        if ( !CopyURL( pwcFilePath, awcTempFile ) )
            return FALSE;

        pwcFilePath = awcTempFile;
        fDeleteWhenDone = TRUE;
    }

    BOOL fOK = TRUE;

    CQueryResult *pResult = new CQueryResult( pwcFilePath, prstQuery, fDeleteWhenDone );

    // call internal mdi browser

    if (pwcFilePath)
    {
        HWND h = App.CreateBrowser( pwcFilePath, (LPARAM) pResult );
        if ( 0 == h )
        {
            WCHAR awcError[ MAX_PATH ];
            FormatSrchError( App.BrowseLastError(), awcError, App.GetLocale() );
            WCHAR awcMsg[ MAX_PATH ];
            CResString strErr( IDS_ERR_CANT_BROWSE_FILE );
            swprintf( awcMsg, strErr.Get(), awcError );
            MessageBox( App.AppWindow(),
                        awcMsg,
                        pwcFilePath,
                        MB_OK|MB_ICONEXCLAMATION );
            fOK = FALSE;
        }
    }

    return fOK;
} //InvokeBrowser

void ExecApp(
    WCHAR const * pwcCmd)
{
    STARTUPINFO si;
    memset( &si, 0, sizeof si );
    si.cb = sizeof si;
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_SHOWDEFAULT;

    PROCESS_INFORMATION pi;

    CreateProcess( 0, (WCHAR *) pwcCmd, 0, 0, FALSE, 0, 0, 0, &si, &pi );
} //ExecApp

BOOL ViewFile(
    WCHAR const *    pwcPath,
    enumViewFile     eViewType,
    int              iLineNumber,
    DBCOMMANDTREE *  prstQuery )
{
    BOOL fOK = TRUE;
    WCHAR awcCmd[MAX_PATH + cwcBufSize];
    DWORD cbCmd = sizeof awcCmd / sizeof awcCmd[0];

    if ( fileOpen == eViewType )
    {
        HINSTANCE hinst = ShellExecute( HWND_DESKTOP,
                                        0,
                                        pwcPath,
                                        0,
                                        0,
                                        SW_SHOWNORMAL );
        if ( 32 > (DWORD_PTR) hinst )
        {
            // if no app is registered for this extension, use notepad

            wcscpy( awcCmd, L"notepad " );
            wcscat( awcCmd, pwcPath );
            ExecApp( awcCmd );
        }
    }
    else if ( fileBrowse == eViewType )
    {
        fOK = InvokeBrowser( (WCHAR *) pwcPath, prstQuery );
    }
    else if ( fileEdit == eViewType )
    {
        WCHAR awcEditor[ MAX_PATH ];

        if ( GetReg( CISEARCH_REG_EDITOR, awcEditor, &cbCmd ) )
        {
            // cool -- use it.
        }
        else
        {
            // try to use windiff's configuration

            cbCmd = sizeof awcCmd;
            if ( GetRegEditor( L"Editor", awcEditor, &cbCmd ) )
            {

                WCHAR *p = wcsstr( awcEditor, L"%p" );
                if ( p )
                    *(p+1) = L's';
                p = wcsstr( awcEditor, L"%l" );
                if ( p )
                    *(p+1) = L'd';
            }
            else
            {
  
                //wcscpy( awcEditor, L"s %ws -#%d" );

                // no editor configured -- open the file

                return ViewFile( pwcPath, fileOpen, iLineNumber, prstQuery );
            }
        }

        TRY
        {
            swprintf( awcCmd, awcEditor, pwcPath, iLineNumber );
            ExecApp( awcCmd );
        }
        CATCH( CException, e )
        {
            fOK = FALSE;
        }
        END_CATCH;
    }

    return fOK;
} //ViewFile

BOOL GetCatListItem( const XGrowable<WCHAR> & const_xCatList,
                     unsigned iItem,
                     WCHAR * pwszMachine,
                     WCHAR * pwszCatalog,
                     WCHAR * pwszScope,
                     BOOL  & fDeep )
{
    XGrowable<WCHAR> xCatList = const_xCatList;

    Win4Assert( pwszMachine && pwszCatalog && pwszScope );
    *pwszMachine = *pwszCatalog = *pwszScope = 0;
    fDeep = FALSE;

    unsigned ii;
    WCHAR * pStart = xCatList.Get();
    for( ii = 0; ii < iItem; ii++ )
    {
        pStart = wcschr( pStart, L';' );
        if ( pStart )
        {
            pStart++;
        }
        else
            break;

        if ( 0 == *pStart )
        {
            break;
        }
    }

    if ( 0 == pStart || 0 == *pStart )
    {
        return FALSE;
    }

    WCHAR * pEnd;

    // machine
    pEnd = wcschr( pStart, L',' );
    if ( !pEnd )
    {
        return FALSE;
    }
    *pEnd = 0;
    wcscpy( pwszMachine, pStart );
    pStart = pEnd + 1;

    // catalog
    pEnd = wcschr( pStart, L',' );
    if ( !pEnd )
    {
        return FALSE;
    }
    *pEnd = 0;
    wcscpy( pwszCatalog, pStart );
    pStart = pEnd + 1;

    // scope
    pEnd = wcschr( pStart, L',' );
    if ( !pEnd )
    {
        return FALSE;
    }
    *pEnd = 0;
    wcscpy( pwszScope, pStart );
    pStart = pEnd + 1;

    // depth
    fDeep = ( L'd' == *pStart || L'D' == *pStart );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\srch\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <ddeml.h>
#include <shellapi.h>
#include <commdlg.h>
#include <commctrl.h>
#include <wininet.h>

#include <stdlib.h>
#include <stddef.h>
#include <time.h>
#include <limits.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <direct.h>
#include <crt\io.h>
#include <eh.h>

#define _CAIROSTG_
#define _DCOM_

#include <oleext.h>
#include <oledberr.h>
#include <filterr.h>
#include <cierror.h>
#include <oledb.h>
#include <ciodm.h>
#include <oledbdep.h>
#include <cmdtree.h>
#include <query.h>
#include <ciintf.h>
#include <ntquery.h>

// srch-specific includes

#include "minici.hxx"
#include "srch.hxx"
#include "browser.hxx"
#include "srchmenu.hxx"
#include "srchdlg.hxx"
#include "watch.hxx"
#include "srchq.hxx"
#include "view.hxx"
#include "lview.hxx"
#include "srchwnd.hxx"

#define SQLTEXT ISQLANG_V2 + 1

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\srch\toolbar.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999.
//
//  File:       toolbar.cxx
//
//  Contents:   
//
//  History:    15 Aug 1996     DLee    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

// cImages        = Number of images in toolbar.bmp.  Note that this is not
//                  the same as the number of elements on the toolbar.
// cpImageWidth   = Width of a single button image in toolbar.bmp
// cpImageHeight  = Height of a single button image in toolbar.bmp
// cpButtonWidth  = Width of a button on the toolbar (zero = default)
// cpButtonHeight = Height of a button on the toolbar (zero = default)

const int cImages        = 12;

const int cpImageWidth   = 19;
const int cpImageHeight  = 16;
const int cpButtonWidth  = 19;
const int cpButtonHeight = 16;

TBBUTTON aButtons[] =        // Array defining the toolbar buttons
{
//    {0,  0,                  TBSTATE_ENABLED, TBSTYLE_SEP,    0, 0, 0},

    {7,  IDM_SEARCH,         TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0},
    {8,  IDM_SEARCHCLASSDEF, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0},
    {9,  IDM_SEARCHFUNCDEF,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0},

    {0,  0,                  TBSTATE_ENABLED, TBSTYLE_SEP,    0, 0, 0},

    {2,  IDM_BROWSE,         TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0},

    {0,  0,                  TBSTATE_ENABLED, TBSTYLE_SEP,    0, 0, 0},

    {11, IDM_DISPLAY_PROPS,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0},

    {0,  0,                  TBSTATE_ENABLED, TBSTYLE_SEP,    0, 0, 0},

    {0,  IDM_NEWSEARCH,      TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0},

    {0,  0,                  TBSTATE_ENABLED, TBSTYLE_SEP,    0, 0, 0},

    {6,  IDM_PREVIOUS_HIT,   TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0},
    {5,  IDM_NEXT_HIT,       TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0},

    {0,  0,                  TBSTATE_ENABLED, TBSTYLE_SEP,    0, 0, 0},

    {4,  IDM_FONT,           TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0},

    {0,  0,                  TBSTATE_ENABLED, TBSTYLE_SEP,    0, 0, 0},

    {1,  IDM_OPEN,           TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0},
    {10, IDM_TILE,           TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0},
    {3,  IDM_CASCADE,        TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0},
};

static WNDPROC _lpOrgTBProc = 0;

LRESULT WINAPI TBSubclassProc(
    HWND   hwnd,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam )
{
    LRESULT lRet = 0;

    // ordinarily, flat toolbars ride on a background window with a cool
    // bitmap.  this one doesn't -- so draw an appropriate background.

    if ( WM_ERASEBKGND == msg )
    {
        RECT rect;
        GetClientRect( hwnd, &rect );
        FillRect( (HDC) wParam, & rect, App.BtnFaceBrush() );
    }
    else
    {
        lRet = CallWindowProc( _lpOrgTBProc,
                               hwnd,
                               msg,
                               wParam,
                               lParam );
    }

    return lRet;
} //TBSubclassProc

HWND CreateTBar(
    HWND hwnd,
    HINSTANCE hInst)
{
    HWND bar = CreateToolbarEx( hwnd,
                                WS_CHILD | WS_VISIBLE |
                                    TBSTYLE_TOOLTIPS | TBSTYLE_FLAT,
                                IDM_TOOLBAR_WINDOW,
                                cImages,
                                hInst,
                                ToolbarBmpNormal,
                                aButtons,
                                sizeof aButtons / sizeof TBBUTTON,
                                cpButtonWidth,
                                cpButtonHeight,
                                cpImageWidth,
                                cpImageHeight,
                                sizeof TBBUTTON );

    if ( 0 == bar )
        return 0;

    _lpOrgTBProc = (WNDPROC) GetWindowLongPtr( bar, GWLP_WNDPROC );
    SetWindowLongPtr( bar, GWLP_WNDPROC, (LONG_PTR) TBSubclassProc );

    SendMessage( bar, TB_BUTTONSTRUCTSIZE, sizeof TBBUTTON, 0 );

    // pixels with color 192,192,192 are changed to buttonface color

    HIMAGELIST h = ImageList_LoadBitmap( hInst,
                                         MAKEINTRESOURCE( ToolbarBmpHilite ),
                                         cpImageWidth,
                                         6,
                                         RGB(192,192,192) );
    SendMessage( bar, TB_SETBITMAPSIZE, 0, MAKELONG( cpImageWidth,
                                                     cpImageHeight ) );
    SendMessage( bar, TB_SETHOTIMAGELIST, 0, (LPARAM) h );

    return bar;
} //CreateTBar

LRESULT ToolBarNotify(
    HWND hwnd,
    UINT uMessage,
    WPARAM wparam,
    LPARAM lparam,
    HINSTANCE hInst )
{
    WCHAR awcBuffer[64];

    TOOLTIPTEXT * pToolTipText = (LPTOOLTIPTEXT)lparam;

    if ( TTN_NEEDTEXT == pToolTipText->hdr.code )
    {
        int id = (int)pToolTipText->hdr.idFrom;

        if ( ( IDM_NEWSEARCH == id ) &&
             ( IsSpecificClass( GetFocus(), BROWSE_CLASS ) ) )
            id = IDS_CLOSEBROWSE;

        LoadString( hInst,
                    id,
                    awcBuffer,
                    sizeof awcBuffer / sizeof WCHAR );

        pToolTipText->lpszText = awcBuffer;
    }

    return 0;
} //ToolBarNotify

void UpdateButton(UINT iID, UINT iFlags)
{
    int iCurrentFlags = (int) SendMessage( App.ToolBarWindow(),
                                           TB_GETSTATE,
                                           iID, 0L );

    if (iCurrentFlags & TBSTATE_PRESSED)
        iFlags |= TBSTATE_PRESSED;

    SendMessage( App.ToolBarWindow(),
                 TB_SETSTATE,
                 iID,
                 MAKELPARAM( iFlags, 0 ) );
} //UpdateButton

void UpdateButtons( UINT *aId, UINT cId, BOOL fEnabled )
{
    for ( UINT i = 0; i < cId; i++ )
        UpdateButton( aId[ i ],
                      fEnabled ? TBSTATE_ENABLED : TBSTATE_INDETERMINATE );

} //UpdateButtons
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\srch\srch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       srch.cxx
//
//  Contents:   
//
//  History:    15 Aug 1996     DLee    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <htmlhelp.h>

typedef void (__stdcall * PFnCIShutdown)(void);
PFnCIShutdown g_pCIShutdown = 0;

void MyCIShutdown()
{
    if ( 0 == g_pCIShutdown )
    {
        #ifdef _WIN64
            char const * pcCIShutdown = "?CIShutdown@@YAXXZ";
        #else
            char const * pcCIShutdown = "?CIShutdown@@YGXXZ";
        #endif

        g_pCIShutdown = (PFnCIShutdown) GetProcAddress( GetModuleHandle( L"query.dll" ), pcCIShutdown );

        if ( 0 == g_pCIShutdown )
            return;
    }

    g_pCIShutdown();
} //MyCIShutdown

CSearchApp App;

int WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     pcCmdLine,
    int       nCmdShow)
{
    int iRet = 0;

    CTranslateSystemExceptions xlate;

    TRY
    {
        App.Init(hInstance,nCmdShow,pcCmdLine);
    }
    CATCH(CException, e)
    {
        // hardcode these strings -- may be out of memory!

        MessageBox( 0, L"Unable to start the application.", L"srch.exe",
                    MB_OK | MB_ICONEXCLAMATION);
        iRet = -1;
    }
    END_CATCH;

    if (0 == iRet)
        iRet = App.MessageLoop();

    srchDebugOut ((DEB_TRACE,"falling out of WinMain()\n"));

    TRY
    {
        MyCIShutdown();

        App.Shutdown( hInstance );
    }
    CATCH(CException, e)
    {
    }
    END_CATCH;

    return iRet;
} //WinMain

int CSearchApp::MessageLoop()
{
    // toss out all the init code that we'll never need again

    SetProcessWorkingSetSize( GetCurrentProcess(), (SIZE_T) -1, (SIZE_T) -1 );

    MSG msg;

    while (GetMessage(&msg,0,0,0))
    {
        if ( ( 0 == _hdlgCurrent ) ||
             ( !IsDialogMessage( _hdlgCurrent, &msg ) ) )
        {
            if (!TranslateMDISysAccel(_hMDIClientWnd,&msg) &&
                !TranslateAccelerator(_hAppWnd,_hAccTable,&msg))
            {
                if ((msg.message == WM_KEYDOWN) && (msg.wParam == VK_F1))
                    _ShowHelp( HH_DISPLAY_TOPIC, 0 );

                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }

    return (int)msg.wParam;
} //MessageLoop

LRESULT WINAPI MainWndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    return App.WndProc(hwnd,msg,wParam,lParam);
} //MainWndProc

CSearchApp::CSearchApp():
     _hInst(0),
     _hMDIClientWnd(0),
     _hAppWnd(0),
     _hStatusBarWnd(0),
     _hToolBarWnd(0),
     _hdlgCurrent(0),
     _hAccTable(0),
     _hbrushBtnFace(0),
     _hbrushBtnHilite(0),
     _hbrushHilite(0),
     _hbrushWindow(0),
     _hfontApp(0),
     _hfontBrowse(0),
     _fHelp(FALSE),
     _iAppCmdShow(0),
     _iStartupState(0),
     _iMDIStartupState(0),
     _scBrowseLastError(0),
     _sortDir(0),
     _lcid(0),
     _fToolBarOn(FALSE),
     _fStatusBarOn(FALSE),
     _fForceUseCI(FALSE),
     _ulDialect(0),
     _ulLimit(0),
     _ulFirstRows(0),
     _sortDirINI(0),
     _lcidINI(0),
     _fToolBarOnINI(FALSE),
     _fStatusBarOnINI(FALSE),
     _fForceUseCIINI(FALSE),
     _ulDialectINI(0),
     _ulLimitINI(0),
     _ulFirstRowsINI(0)
{
    RtlZeroMemory( &_NumberFmt, sizeof( NUMBERFMT ) );
    RtlZeroMemory( &_NumberFmtFloat, sizeof( NUMBERFMT ) );
    RtlZeroMemory( &_lfApp, sizeof( LOGFONT ) );
    RtlZeroMemory( &_lfBrowse, sizeof( LOGFONT ) );

    *_awcAppFont      = 0;
    *_awcBrowseFont   = 0;
    *_awcAppPath      = 0;
    *_awcHelpFile     = 0;
    *_awcSort         = 0;
    *_awcSortINI      = 0;
    *_awcDefaultQuery = 0;
} //CSearchApp

void CSearchApp::Init(
    HINSTANCE hInstance,
    int nCmdShow,
    LPSTR pcCmdLine)
{
    HRESULT hr = CoInitialize( 0 );

    if ( FAILED( hr ) )
        THROW( CException( hr ) );

    InitCommonControls();

    INITCOMMONCONTROLSEX icex;
    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC = ICC_USEREX_CLASSES;
    InitCommonControlsEx(&icex);


    _iAppCmdShow = nCmdShow;
    _hInst = hInstance;

    _InitApplication();
    _InitInstance(pcCmdLine);
} //Init

void CSearchApp::Shutdown( HINSTANCE hInst )
{
    UnregisterClass( APP_CLASS, hInst );
    UnregisterClass( SEARCH_CLASS, hInst );
    UnregisterClass( BROWSE_CLASS, hInst );
    UnregisterClass( LIST_VIEW_CLASS, hInst );

    if ( 0 != _hfontApp )
        DeleteObject( _hfontApp );

    if ( 0 != _hfontBrowse )
        DeleteObject( _hfontBrowse );

    FreeNumberFormatInfo( _NumberFmt );
    FreeNumberFormatInfo( _NumberFmtFloat );

    _xCmdCreator.Free();

    CoUninitialize();
} //Shutdown

CSearchApp::~CSearchApp()
{
} //~CSearchApp

BOOL WINAPI AboutDlgProc(
    HWND hdlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fRet = FALSE;

    switch (msg)
    {
        case WM_INITDIALOG :
            CenterDialog(hdlg);
            fRet = TRUE;
            break;
        case WM_COMMAND :
            EndDialog(hdlg,TRUE);
            break;
    }

    return fRet;
} //AboutDlgProc

#if 0

BOOL WINAPI BrowseToolDlgProc(
    HWND hdlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fRet = FALSE;
    UINT uiID;
    WCHAR awcCmd[MAX_PATH];
    DWORD dwSize;
    int fStrip;

    switch (msg)
    {
        case WM_INITDIALOG :
            dwSize = sizeof awcCmd / sizeof awcCmd[0];
            if (!GetReg(CISEARCH_REG_BROWSE,awcCmd,&dwSize))
                wcscpy(awcCmd,BROWSER);

            fStrip = GetRegInt(CISEARCH_REG_BROWSESTRIP,FALSE);

            SetDlgItemText(hdlg,ID_BR_EDIT,L"");
            EnableWindow(GetDlgItem(hdlg,ID_BR_EDIT),FALSE);
            EnableWindow(GetDlgItem(hdlg,ID_BR_STRIP),FALSE);

            if (!_wcsicmp(awcCmd,BROWSER))
                CheckRadioButton(hdlg,ID_BR_BROWSER,ID_BR_CUSTOM,ID_BR_BROWSER);
            else if (!_wcsicmp(awcCmd,BROWSER_SLICK))
                CheckRadioButton(hdlg,ID_BR_BROWSER,ID_BR_CUSTOM,ID_BR_SLICK);
            else if (!_wcsicmp(awcCmd,BROWSER_SLICK_SEARCH))
                CheckRadioButton(hdlg,ID_BR_BROWSER,ID_BR_CUSTOM,ID_BR_SLICK_SEARCH);
            else
            {
                CheckRadioButton(hdlg,ID_BR_BROWSER,ID_BR_CUSTOM,ID_BR_CUSTOM);
                SetDlgItemText(hdlg,ID_BR_EDIT,awcCmd);
                EnableWindow(GetDlgItem(hdlg,ID_BR_EDIT),TRUE);
                EnableWindow(GetDlgItem(hdlg,ID_BR_STRIP),TRUE);
                CheckDlgButton(hdlg,ID_BR_STRIP,fStrip);
            }

            CenterDialog(hdlg);

            fRet = TRUE;
            break;
        case WM_COMMAND :
            uiID = MyWmCommandID(wParam,lParam);
            switch (uiID)
            {
                case ID_BR_BROWSER:
                case ID_BR_SLICK:
                case ID_BR_SLICK_SEARCH:
                case ID_BR_CUSTOM:
                    SetDlgItemText(hdlg,ID_BR_EDIT,L"");
                    EnableWindow(GetDlgItem(hdlg,ID_BR_EDIT),ID_BR_CUSTOM == uiID);
                    EnableWindow(GetDlgItem(hdlg,ID_BR_STRIP),ID_BR_CUSTOM == uiID);
                    CheckRadioButton(hdlg,ID_BR_BROWSER,ID_BR_CUSTOM,uiID);

                    if (ID_BR_CUSTOM == uiID)
                    {
                        SetFocus(GetDlgItem(hdlg,ID_BR_EDIT));
                        MySendEMSetSel(GetDlgItem(hdlg,ID_BR_EDIT),0,(UINT) -1);
                    }

                    break;
                case IDOK:
                    fStrip = FALSE;

                    if (IsDlgButtonChecked(hdlg,ID_BR_BROWSER))
                        wcscpy(awcCmd,BROWSER);
                    else if (IsDlgButtonChecked(hdlg,ID_BR_SLICK))
                        wcscpy(awcCmd,BROWSER_SLICK);
                    else if (IsDlgButtonChecked(hdlg,ID_BR_SLICK_SEARCH))
                        wcscpy(awcCmd,BROWSER_SLICK_SEARCH);
                    else
                    {
                        GetDlgItemText(hdlg,ID_BR_EDIT,awcCmd,sizeof awcCmd);
                        fStrip = IsDlgButtonChecked(hdlg,ID_BR_STRIP);
                    }
                    if (0 == awcCmd[0])
                        wcscpy(awcCmd,BROWSER);
                    SetReg(CISEARCH_REG_BROWSE,awcCmd);
                    SetRegInt(CISEARCH_REG_BROWSESTRIP,fStrip);
                    // fall through!
                case IDCANCEL:
                    EndDialog(hdlg,IDOK == uiID);
                    break;
            }
            break;
    }

    return fRet;
} //BrowseToolDlgProc

#endif

void CSearchApp::_SizeMDIAndBars(
    BOOL fMove,
    int  iDX,
    int  iDY )
{
    if (_hMDIClientWnd)
    {
        int iMdiDY = iDY;
        int iMdiY = 0;

        if (_fToolBarOn)
        {
            RECT rc;
            GetWindowRect( _hToolBarWnd, &rc );
            iMdiY = rc.bottom - rc.top;
            iMdiDY -= iMdiY;
        }

        if (_fStatusBarOn)
        {
            RECT rc;
            GetWindowRect( _hStatusBarWnd, &rc );
            iMdiDY -= ( rc.bottom - rc.top );
        }

        MoveWindow( _hMDIClientWnd, 0, iMdiY, iDX, iMdiDY, TRUE );
    }

    if ( _fStatusBarOn && !fMove )
        InvalidateRect( _hStatusBarWnd, 0, TRUE );
} //_SizeMDIAndBars

void CSearchApp::_SaveProfileData()
{
    _SaveWindowState(FALSE);
    _SaveWindowState(TRUE);

    if ( _ulLimit != _ulLimitINI )
        SetRegInt( CISEARCH_REG_LIMIT, _ulLimit );

    if ( _ulFirstRows != _ulFirstRowsINI )
        SetRegInt( CISEARCH_REG_FIRSTROWS, _ulFirstRows );

    if ( _ulDialect != _ulDialectINI )
        SetRegInt( CISEARCH_REG_DIALECT, _ulDialect );

    if (_fToolBarOn != _fToolBarOnINI)
        SetRegInt(CISEARCH_REG_TOOLBAR,_fToolBarOn);

    if (_fStatusBarOn != _fStatusBarOnINI)
        SetRegInt(CISEARCH_REG_STATUSBAR,_fStatusBarOn);

    if (_fForceUseCI != _fForceUseCIINI)
        SetRegInt(CISEARCH_REG_FORCEUSECI,_fForceUseCI);

    if (_sortDir != _sortDirINI)
        SetRegInt(CISEARCH_REG_SORTDIR,_sortDir);

    if ( _wcsicmp( _awcSortINI, _awcSort ) )
        SetReg( CISEARCH_REG_SORTPROP, _awcSort );

    if ( _lcid != _lcidINI )
        SetRegLCID( CISEARCH_REG_LOCALE, _lcid );

    _MarshallFont(_lfApp,_awcAppFont,CISEARCH_REG_FONT);
    _MarshallFont(_lfBrowse,_awcBrowseFont,CISEARCH_REG_BROWSEFONT);
} //_SaveProfileData

void CSearchApp::_UnMarshallFont(
    LOGFONT &lf,
    WCHAR *pwcFont,
    WCHAR *pwcRegEntry)
{
    DWORD dwSize = MAX_PATH;
    if (GetReg(pwcRegEntry,pwcFont,&dwSize))
    {
        int iItalic,iUnderline,iStrikeOut,iCharSet,iQuality,iPitchAndFamily;

        swscanf(pwcFont,L"%d,%d,%d,%d,%d,%d,%d,%d,%d",&lf.lfHeight,
                &lf.lfWidth,&lf.lfWeight,&iItalic,&iUnderline,
                &iStrikeOut,&iCharSet,&iQuality,&iPitchAndFamily);

        WCHAR *pwc = pwcFont;
        for (int i = 0; *pwc && i < 9; pwc++)
            if (*pwc == ',')
                i++;

        wcscpy(lf.lfFaceName,pwc);
        lf.lfItalic = (BYTE) iItalic;
        lf.lfUnderline = (BYTE) iUnderline;
        lf.lfStrikeOut = (BYTE) iStrikeOut;
        lf.lfCharSet = (BYTE) iCharSet;
        lf.lfQuality = (BYTE) iQuality;
        lf.lfPitchAndFamily = (BYTE) iPitchAndFamily;
    }
} //_UnMarshallFont

void CSearchApp::_MarshallFont(
    LOGFONT &lf,
    WCHAR *pwcOriginal,
    WCHAR *pwcRegEntry)
{
    WCHAR awcTmp[MAX_PATH];

    swprintf(awcTmp,L"%d,%d,%d,%d,%d,%d,%d,%d,%d,%ws",lf.lfHeight,
             lf.lfWidth,lf.lfWeight,(int) lf.lfItalic,
             (int) lf.lfUnderline,(int) lf.lfStrikeOut,
             (int) lf.lfCharSet,(int) lf.lfQuality,
             (int) lf.lfPitchAndFamily,lf.lfFaceName);

    if (wcscmp(pwcOriginal,awcTmp))
        SetReg(pwcRegEntry,awcTmp);
} //_MarshallFont

void CSearchApp::_ReadDefaultFonts()
{
    _UnMarshallFont(_lfApp,_awcAppFont,CISEARCH_REG_FONT);
    _UnMarshallFont(_lfBrowse,_awcBrowseFont,CISEARCH_REG_BROWSEFONT);
} //_ReadDefaultFont

LRESULT CSearchApp::WndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    LRESULT lRet = 0;
    UINT uiStatus,uiFmt;
    RECT rc;
    CLIENTCREATESTRUCT ccs;
    CHOOSEFONT chf;
    HDC hdc;
    HWND hwndActive;
    WCHAR * pwcBuf;
    LONG l;
    BOOL bOn;
    HMENU hSysMenu;
    WCHAR awcWindowClass[60],*pwcAboutBonus;
    UINT uiID,uiFlags,uiCmd;

    switch (msg)
    {
        case WM_ENTERIDLE :
            if ((wParam == MSGF_MENU) && (GetKeyState(VK_F1) & 0x8000))
            {
                _fHelp = TRUE;
                PostMessage(hwnd,WM_KEYDOWN,VK_RETURN,0);
            }
            break;
        case WM_NOTIFY :
            lRet = ToolBarNotify( hwnd, msg, wParam, lParam, App.Instance() );
            break;
        case WM_MENUSELECT :
        {
            UINT uiFlags = MyMenuSelectFlags( wParam, lParam );
            UINT uiCmd = MyMenuSelectCmd( wParam, lParam );
            HMENU hmenu = MyMenuSelectHMenu( wParam, lParam );

            if (_fStatusBarOn)
            {
                UINT uiID = 0;

                if ( 0xffff == uiFlags && 0 == hmenu )
                    uiID = (UINT) -1;
                else if ( MFT_SEPARATOR == uiFlags )
                    uiID = 0;
                else if ( MF_POPUP == uiFlags )
                    uiID = 0;
                else
                {
                    uiID = uiCmd;
                    if ( uiID >= IDM_WINDOWCHILD )
                        if (uiID < (IDM_WINDOWCHILD + 20))
                            uiID = IDS_IDM_WINDOWCHILD;
                        else
                            uiID = 0;
                }

                if ( -1 == uiID )
                {
                    SendMessage( _hStatusBarWnd, SB_SIMPLE, FALSE, 0 );
                }
                else
                {
                    SendMessage( _hStatusBarWnd, SB_SIMPLE, TRUE, 0 );

                    if ( 0 != uiID )
                    {
                        WCHAR awc[ 200 ];

                        LoadString( _hInst, uiID, awc, sizeof awc / sizeof WCHAR );
                        SendMessage( _hStatusBarWnd, SB_SETTEXT, 255,
                                     (LPARAM) awc );
                    }
                }
            }
            break;
        }
        case WM_COMMAND :
        {
            uiID = MyWmCommandID(wParam,lParam);
            switch (uiID)
            {
                case IDM_STATUS_BAR :
                case IDM_ICON_BAR :
                  uiStatus = GetMenuState(GetMenu(hwnd),uiID,MF_BYCOMMAND);
                  bOn = ! (uiStatus & MF_CHECKED);
                  if (uiID == IDM_STATUS_BAR)
                  {
                      _fStatusBarOn = bOn;
                      ShowWindow(_hStatusBarWnd,bOn ? SW_SHOW : SW_HIDE);
                  }
                  else
                  {
                      _fToolBarOn = bOn;
                      ShowWindow(_hToolBarWnd,bOn ? SW_SHOW : SW_HIDE);
                  }
                  CheckMenuItem(GetMenu(hwnd),uiID,bOn ? MF_CHECKED : MF_UNCHECKED);
                  GetClientRect(hwnd,&rc);
                  _SizeMDIAndBars( FALSE, rc.right, rc.bottom );
                  break;
                case IDM_FONT :
                  {
                  BOOL fApp = IsSpecificClass(GetActiveMDI(),SEARCH_CLASS);
                  LOGFONT *pLogFont = fApp ? &_lfApp : &_lfBrowse;
                  HFONT &rhFont = fApp ? _hfontApp : _hfontBrowse;

                  hdc = GetDC(hwnd);
                  memset(&chf,0,sizeof CHOOSEFONT);
                  chf.lStructSize = sizeof CHOOSEFONT;
                  chf.hwndOwner = hwnd;
                  chf.hDC = hdc;
                  chf.lpLogFont = pLogFont;
                  chf.Flags = CF_SCREENFONTS | CF_INITTOLOGFONTSTRUCT;
                  chf.nFontType = SCREEN_FONTTYPE;
                  if (ChooseFont(&chf))
                  {
                      HFONT hOldFont = rhFont;
                      HFONT hNewFont = CreateFontIndirect(pLogFont);
                      if (hNewFont)
                      {
                          rhFont = hNewFont;
                          _SendToSpecificChildren(fApp ? SEARCH_CLASS :
                                                         BROWSE_CLASS,
                                                  wmNewFont,
                                                  (WPARAM) hNewFont,0);

                          if (hOldFont)
                              DeleteObject(hOldFont);
                      }
                  }
                  ReleaseDC(hwnd,hdc);
                  }
                  break;
                case IDM_OPEN :
                  SendMessage(hwnd,wmOpenCatalog,TRUE,0);
                  break;
                case IDM_ABOUT :
                {
                  CResString strApp( IDS_APPNAME );
                  CResString strBonus( IDS_ABOUT_BONUS );
                  ShellAbout(hwnd,
                             strApp.Get(),
                             strBonus.Get(),
                             LoadIcon(_hInst,L"SrchIcon"));
                  break;
                }
                //case IDM_BROWSE_TOOL :
                //  DoModalDialog(BrowseToolDlgProc,hwnd,L"BrowseToolBox",0);
                //  break;
                case IDM_EXIT :
                  SendMessage(hwnd,WM_CLOSE,0,0);
                  break;
                case IDM_TILE :
                  SendMessage(_hMDIClientWnd,WM_MDITILE,MDITILE_HORIZONTAL,0);
                  break;
                case IDM_CASCADE :
                  SendMessage(_hMDIClientWnd,WM_MDICASCADE,0,0);
                  break;
                case IDM_ARRANGE :
                  SendMessage(_hMDIClientWnd,WM_MDIICONARRANGE,0,0);
                  break;
                case IDM_EDITUNDO:
                  PassOnToEdit(EM_UNDO,0,0);
                  break;
                case IDM_EDITCOPY:
                  PassOnToEdit(WM_COPY,0,0);
                  _SendToActiveMDI(wmMenuCommand,uiID,1L);
                  break;
                case IDM_EDITPASTE:
                  PassOnToEdit(WM_PASTE,0,0);
                  break;
                case IDM_EDITCUT:
                  PassOnToEdit(WM_CUT,0,0);
                  break;
                case IDM_EDITCLEAR:
                  PassOnToEdit(EM_REPLACESEL,0,(LPARAM) L"");
                  break;
                case ACC_CTRLSPACE :
                  if ((hwndActive = GetActiveMDI()) &&
                      (hSysMenu = GetSystemMenu(hwndActive,FALSE)))
                      PostMessage(hwndActive,WM_SYSCOMMAND,SC_KEYMENU,(DWORD) '-');
                  else
                      MessageBeep(0);
                  break;
                case ACC_ALTR :
                case ACC_ALTQ :
                case ACC_TAB :
                case ACC_SHIFTTAB :
                  _SendToActiveMDI(wmAccelerator,uiID,0);
                  break;
                case IDM_CLOSE :
                  _SendToActiveMDI(WM_CLOSE,0,0);
                  break;
                case IDM_HELP_CONTENTS :
                  _ShowHelp( HH_DISPLAY_TOPIC, 0 );
                  break;

                case IDM_SEARCH :
                case IDM_SEARCHCLASSDEF :
                case IDM_SEARCHFUNCDEF :
                case IDM_NEWSEARCH :
                case IDM_BROWSE :
                case IDM_NEXT_HIT :
                case IDM_PREVIOUS_HIT :
                case IDM_WRITE_RESULTS :
                case IDM_SCOPE_AND_DEPTH :
                case IDM_FILTER_SCOPE :

                case IDM_LOCALE_NEUTRAL:
                case IDM_LOCALE_CHINESE_TRADITIONAL:
                case IDM_LOCALE_CHINESE_SIMPLIFIED:
                case IDM_LOCALE_CHINESE_HONGKONG:
                case IDM_LOCALE_CHINESE_SINGAPORE:
                case IDM_LOCALE_CHINESE_MACAU:
                case IDM_LOCALE_DUTCH_DUTCH:
                case IDM_LOCALE_ENGLISH_CAN:
                case IDM_LOCALE_ENGLISH_US:
                case IDM_LOCALE_ENGLISH_UK:
                case IDM_LOCALE_FINNISH_DEFAULT:
                case IDM_LOCALE_FARSI_DEFAULT:
                case IDM_LOCALE_FRENCH_FRENCH:
                case IDM_LOCALE_FRENCH_CANADIAN:
                case IDM_LOCALE_GERMAN_GERMAN:
                case IDM_LOCALE_GREEK_DEFAULT:
                case IDM_LOCALE_HEBREW_DEFAULT:
                case IDM_LOCALE_HINDI_DEFAULT:
                case IDM_LOCALE_ITALIAN_ITALIAN:
                case IDM_LOCALE_JAPANESE_DEFAULT:
                case IDM_LOCALE_KOREAN_KOREAN:
//                case IDM_LOCALE_KOREAN_JOHAB:
                case IDM_LOCALE_POLISH_DEFAULT:
                case IDM_LOCALE_ROMANIAN_DEFAULT:
                case IDM_LOCALE_RUSSIAN_DEFAULT:
                case IDM_LOCALE_SPANISH_CASTILIAN:
                case IDM_LOCALE_SPANISH_MEXICAN:
                case IDM_LOCALE_SPANISH_MODERN:
                case IDM_LOCALE_SWAHILI_DEFAULT:
                case IDM_LOCALE_SWEDISH_DEFAULT:
                case IDM_LOCALE_THAI_DEFAULT:
                case IDM_LOCALE_TURKISH_DEFAULT:
                case IDM_LOCALE_UKRAINIAN_DEFAULT:
                case IDM_LOCALE_VIETNAMESE_DEFAULT:

                case IDM_DISPLAY_PROPS:
                case IDM_CATALOG_STATUS:
                case IDM_MASTER_MERGE:
                case IDM_FORCE_USE_CI:
                case IDM_EDITCOPYALL :
                case IDM_DIALECT_1 :
                case IDM_DIALECT_2 :
                case IDM_DIALECT_3 :
                case IDM_LIMIT_10 :
                case IDM_LIMIT_300 :
                case IDM_LIMIT_NONE :
                case IDM_FIRSTROWS_5 :
                case IDM_FIRSTROWS_15 :
                case IDM_FIRSTROWS_NONE :

                    _SendToActiveMDI(wmMenuCommand,uiID,1L);
                    break;
                default :
                  lRet = DefFrameProc(hwnd,_hMDIClientWnd,msg,wParam,lParam);
                  break;
              }
            break;
        }
        case wmOpenCatalog:
        {
            BOOL fDialog = (BOOL) wParam;

            if ( !fDialog ||
                 DoModalDialog( ScopeDlgProc,
                                hwnd,
                                L"ScopeBox",
                                (LPARAM) &_xCatList ) )
            {
                _MakeMDI( _xCatList.Get(),
                          SEARCH_CLASS,
                          0,0,
                          (LPARAM) _xCatList.Get());
            }
            break;
        }
        case WM_DRAWITEM :
            _SendToActiveMDI(msg, wParam, lParam );
            break;
        case WM_SIZE :
            SendMessage( _hToolBarWnd, msg, wParam, lParam );
            SendMessage( _hStatusBarWnd, msg, wParam, lParam );
            _SizeMDIAndBars( FALSE, LOWORD( lParam ), HIWORD( lParam ) );
            break;
        case WM_MOVE :
            GetClientRect( hwnd, &rc );
            _SizeMDIAndBars( TRUE, rc.right, rc.bottom );
            break;
        case WM_SYSCOLORCHANGE :
        case WM_SETTINGCHANGE :
            _hbrushBtnFace = CreateSolidBrush( GetSysColor( COLOR_BTNFACE ) );
            _hbrushBtnHilite = CreateSolidBrush( GetSysColor( COLOR_BTNHIGHLIGHT ) );
            _hbrushHilite = CreateSolidBrush( GetSysColor( COLOR_HIGHLIGHT ) );
            _hbrushWindow = CreateSolidBrush( GetSysColor( COLOR_WINDOW ) );
            SendMessage( App.StatusBarWindow(), msg, wParam, lParam );
            SendMessage( App.ToolBarWindow(), msg, wParam, lParam );
            _SendToMDIChildren( msg, wParam, lParam );
            lRet = DefFrameProc( hwnd, _hMDIClientWnd, msg, wParam, lParam );
            break;
        case WM_SYSCOMMAND :
            if (wParam == SC_CLOSE)
                SendMessage( hwnd, WM_CLOSE, 0, 0 );
            else
                lRet = DefFrameProc( hwnd, _hMDIClientWnd, msg, wParam, lParam );
            break;
        case WM_CLOSE :
            _SaveProfileData();
            _SendToMDIChildren( wmAppClosing, 0, 0 );
            DestroyWindow(hwnd);
            break;
        case WM_ENDSESSION :
            _SaveProfileData();
            lRet = DefFrameProc(hwnd,_hMDIClientWnd,msg,wParam,lParam);
            break;
        case WM_CREATE :
        {
            ccs.hWindowMenu = GetSubMenu(GetMenu(hwnd),WINDOWMENU);
            ccs.idFirstChild = IDM_WINDOWCHILD;
            _hMDIClientWnd = CreateWindowEx( WS_EX_CLIENTEDGE,
                                             L"mdiclient",0,
                                             WS_CHILD|WS_CLIPCHILDREN,
                                             0,0,0,0,
                                             hwnd,(HMENU) 0xcac,_hInst,
                                             (LPSTR) &ccs);
            ShowWindow(_hMDIClientWnd,SW_SHOW);
            PostMessage(hwnd,wmSetState,_iStartupState,0);
            break;
        }
        case wmSetState :
            if (_iAppCmdShow != SW_SHOWNORMAL)
                ShowWindow(hwnd,_iAppCmdShow);
            else if (wParam == 1)
                ShowWindow(hwnd,SW_SHOWMAXIMIZED);
            else
                ShowWindow(hwnd,SW_SHOW);
            break;
        case WM_DESTROY :
            SaveWindowRect( hwnd, CISEARCH_REG_POSITION );

//            HtmlHelp( hwnd, _awcHelpFile, HH_CLOSE_ALL, 0 );
            PostQuitMessage(0);
            break;
        case WM_INITMENU :
        {
            HMENU hmenu = (HMENU) wParam;

            // Disable all those that may conditionally be enabled later
            EnableMenuItem(hmenu,IDM_EDITUNDO,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_EDITCUT,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_EDITCOPY,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_EDITCLEAR,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_EDITPASTE,MF_GRAYED);

            EnableMenuItem(hmenu,IDM_BROWSE,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_NEXT_HIT,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_PREVIOUS_HIT,MF_GRAYED);

            EnableMenuItem( hmenu, IDM_DIALECT_1, MF_GRAYED );
            EnableMenuItem( hmenu, IDM_DIALECT_2, MF_GRAYED );
            EnableMenuItem( hmenu, IDM_DIALECT_3, MF_GRAYED );

            EnableMenuItem( hmenu, IDM_LIMIT_10, MF_GRAYED );
            EnableMenuItem( hmenu, IDM_LIMIT_300, MF_GRAYED );
            EnableMenuItem( hmenu, IDM_LIMIT_NONE, MF_GRAYED );
            
            EnableMenuItem( hmenu, IDM_FIRSTROWS_5, MF_GRAYED );
            EnableMenuItem( hmenu, IDM_FIRSTROWS_15, MF_GRAYED );
            EnableMenuItem( hmenu, IDM_FIRSTROWS_NONE, MF_GRAYED );

            for ( ULONG i = 0; i < cLocaleEntries; i++ )
            {
                int option = aLocaleEntries[ i ].iMenuOption;
                EnableMenuItem( hmenu, option, MF_GRAYED );
            }

            EnableMenuItem(hmenu,IDM_SEARCH,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_SEARCHCLASSDEF,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_SEARCHFUNCDEF,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_NEWSEARCH,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_WRITE_RESULTS,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_SCOPE_AND_DEPTH,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_FILTER_SCOPE,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_DISPLAY_PROPS,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_CATALOG_STATUS,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_MASTER_MERGE,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_FORCE_USE_CI,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_EDITCOPYALL,MF_GRAYED);


            if (_CountMDIChildren())
                uiStatus = MF_ENABLED;
            else
                uiStatus = MF_GRAYED;

            EnableMenuItem(hmenu,IDM_TILE,uiStatus);
            EnableMenuItem(hmenu,IDM_CASCADE,uiStatus);
            EnableMenuItem(hmenu,IDM_ARRANGE,uiStatus);
            EnableMenuItem(hmenu,IDM_CLOSE,uiStatus);

            // Enable/Disable Edit Menu options
            if (hwndActive = GetFocus())
            {
                GetClassName(hwndActive,
                             awcWindowClass,
                             (sizeof awcWindowClass / sizeof WCHAR) - 1);

                if ( (!_wcsicmp(awcWindowClass,L"Edit")) ||
                     (!_wcsicmp(awcWindowClass,BROWSE_CLASS)) )
                {
                    if (SendMessage (hwndActive,EM_CANUNDO,0,0))
                        uiStatus = MF_ENABLED;
                    else
                        uiStatus = MF_GRAYED;

                    EnableMenuItem(hmenu,IDM_EDITUNDO,uiStatus);

                    l = (LONG)SendMessage(hwndActive,EM_GETSEL,0,0);
                    uiStatus = (HIWORD(l) == LOWORD(l)) ? MF_GRAYED : MF_ENABLED;
                    EnableMenuItem(hmenu,IDM_EDITCOPY,uiStatus);

                    if ( _wcsicmp(awcWindowClass,BROWSE_CLASS) )
                    {
                        EnableMenuItem(hmenu,IDM_EDITCUT,uiStatus);
                        EnableMenuItem(hmenu,IDM_EDITCLEAR,uiStatus);
                    }

                    uiStatus = MF_GRAYED;
                    if (OpenClipboard(hwnd))
                    {
                        uiFmt = 0;
                        while ((uiFmt = EnumClipboardFormats(uiFmt)) &&
                               (uiStatus == MF_GRAYED))
                            if (uiFmt == CF_UNICODETEXT)
                                uiStatus = MF_ENABLED;
                        CloseClipboard();
                    }

                    if ( _wcsicmp(awcWindowClass,BROWSE_CLASS) )
                        EnableMenuItem(hmenu,IDM_EDITPASTE,uiStatus);
                }
                _SendToActiveMDI(wmInitMenu,wParam,0);
            }
            break;
        }
        default:
            lRet = DefFrameProc(hwnd,_hMDIClientWnd,msg,wParam,lParam);
            break;
    }
    return lRet;
} //WndProc

void CSearchApp::_InitApplication()
{
    WNDCLASS wc;
    BOOL bRet = FALSE;

    _strTrue.Load( IDS_BOOL_TRUE );
    _strFalse.Load( IDS_BOOL_FALSE );
    _strAttrib.Load( IDS_ATTRIB_INIT );
    _strBlob.Load( IDS_BLOB_FORMAT );
    _strYes.Load( IDS_YES );
    _strNo.Load( IDS_NO );

    _hbrushBtnFace = CreateSolidBrush( GetSysColor( COLOR_BTNFACE ) );
    _hbrushBtnHilite = CreateSolidBrush( GetSysColor( COLOR_BTNHIGHLIGHT ) );
    _hbrushHilite = CreateSolidBrush( GetSysColor( COLOR_HIGHLIGHT ) );
    _hbrushWindow = CreateSolidBrush( GetSysColor( COLOR_WINDOW ) );

    // Main Window
    wc.style = 0;
    wc.lpfnWndProc = MainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = _hInst;
    wc.hIcon = LoadIcon(_hInst,L"SearchIcon");
    wc.hCursor = LoadCursor(NULL,IDC_ARROW);
    wc.hbrBackground = (HBRUSH) (COLOR_APPWORKSPACE+1);
    wc.lpszMenuName = L"SrchMenu";
    wc.lpszClassName = APP_CLASS;
    if (RegisterClass(&wc) == 0)
        THROW(CException(E_FAIL));

    // Search window
    wc.hbrBackground = _hbrushBtnFace;
    wc.hIcon = LoadIcon(_hInst,L"SearchWindowIcon");
    wc.cbWndExtra = sizeof ULONG_PTR;
    wc.lpszMenuName = 0;
    wc.lpfnWndProc = SearchWndProc;
    wc.lpszClassName = SEARCH_CLASS;
    if (RegisterClass(&wc) == 0)
        THROW(CException(E_FAIL));

    // Browse window
    wc.hbrBackground = (HBRUSH) (COLOR_WINDOW+1);
    wc.hIcon = LoadIcon(_hInst,L"BrowseWindowIcon");
    wc.lpfnWndProc = BrowseWndProc;
    wc.lpszClassName = BROWSE_CLASS;
    wc.style = CS_DBLCLKS;
    if ( RegisterClass(&wc) == 0)
        THROW(CException(E_FAIL));

    // List window
    // to be replaced by ListView

    wc.style = CS_DBLCLKS;
    wc.hIcon = 0;
    wc.cbWndExtra = sizeof ULONG_PTR;
    wc.lpfnWndProc = ListViewWndProc;
    wc.lpszClassName = LIST_VIEW_CLASS;
    if (RegisterClass(&wc) == 0)
        THROW(CException(E_FAIL));
} //_InitApplication

void CSearchApp::_CreateFonts()
{
    memset(&_lfApp,0,sizeof(LOGFONT));

    _lfApp.lfWeight = FW_NORMAL;
    _lfApp.lfHeight = -11;
    _lfApp.lfCharSet = ANSI_CHARSET;
    _lfApp.lfOutPrecision = OUT_DEFAULT_PRECIS;
    _lfApp.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    _lfApp.lfQuality = PROOF_QUALITY;
    _lfApp.lfPitchAndFamily = FF_SWISS | VARIABLE_PITCH;
    wcscpy( _lfApp.lfFaceName, L"MS SHELL DLG" ); //L"HELV");

    _lfBrowse = _lfApp;
    _lfBrowse.lfPitchAndFamily = FF_MODERN | FIXED_PITCH;
    wcscpy(_lfBrowse.lfFaceName,L"COURIER");

    _ReadDefaultFonts();

    _hfontApp = CreateFontIndirect((LPLOGFONT) &_lfApp);
    _hfontBrowse = CreateFontIndirect((LPLOGFONT) &_lfBrowse);

    if (!( _hfontApp && _hfontBrowse ))
        THROW(CException(E_FAIL));
} //_CreateFonts

void CSearchApp::_GetPaths()
{
    WCHAR awc[MAX_PATH+1],*pc;

    GetModuleFileName(_hInst,awc,MAX_PATH);
    UINT ui = (UINT) wcslen(awc);

    wcscpy(_awcAppPath,awc);
    for (pc = _awcAppPath + ui; pc > _awcAppPath; pc--)
    {
        if (*pc == '/' || *pc == '\\' || *pc == ':')
        {
            *(++pc) = '\0';
            break;
        }
    }

    wcscpy(_awcHelpFile,_awcAppPath);
    wcscat(_awcHelpFile,CISEARCH_HELPFILE);
} //_GetPaths

void Usage()
{
    SearchError( 0, IDS_ERR_USAGE, L"srch.exe" );

    PostQuitMessage( 0 );
} //Usage

void CSearchApp::_InitInstance(LPSTR pcCmdLineArg)
{
    LoadNumberFormatInfo( _NumberFmt );
    _NumberFmt.NumDigits = 0; // override: none after the decimal point!

    LoadNumberFormatInfo( _NumberFmtFloat );

    BOOL fScopeSpecified = FALSE;

    CLSID clsidCISimpleCommandCreator = CLSID_CISimpleCommandCreator;

    HRESULT hr = CoCreateInstance( clsidCISimpleCommandCreator,
                                   NULL,
                                   CLSCTX_INPROC_SERVER,
                                   IID_ISimpleCommandCreator,
                                   _xCmdCreator.GetQIPointer() );

    if ( FAILED( hr ) )
        THROW( CException( hr ) );

    SScopeCatalogMachine defaults;

    defaults.fDeep = TRUE;
    wcscpy( defaults.awcMachine, L"." );
    wcscpy( defaults.awcScope, L"\\" );
    defaults.awcCatalog[0] = 0;

    ULONG cwcMachine = sizeof defaults.awcMachine / sizeof WCHAR;
    ULONG cwcCatalog = sizeof defaults.awcCatalog / sizeof WCHAR;
    SCODE sc = LocateCatalogs( L"\\",
                               0,
                               defaults.awcMachine,
                               &cwcMachine,
                               defaults.awcCatalog,
                               &cwcCatalog );

    LPWSTR pwcCmdLine = 0;

    int argc;
    LPWSTR * argv = CommandLineToArgvW( GetCommandLineW(), &argc );
    BOOL fNamedArgs = FALSE;

    for ( int i = 1; i < argc; i++ )
    {
        if ( L'-' == argv[i][0] || L'/' == argv[i][0] )
        {
            fNamedArgs = TRUE;

            WCHAR wc = (WCHAR) toupper( (char) argv[i][1] );

            if ( ':' != argv[i][2] )
                Usage();

            if ( 'C' == wc )
            {
                WCHAR * pwcCatalog = argv[i] + 3;

                if ( wcslen( pwcCatalog ) >= MAX_PATH )
                    Usage();

                wcscpy( defaults.awcCatalog, pwcCatalog );
            }
            else if ( 'M' == wc )
            {
                WCHAR * pwcMachine = argv[i] + 3;

                if ( wcslen( pwcMachine ) >= MAX_PATH )
                    Usage();

                wcscpy( defaults.awcMachine, pwcMachine );
            }
            else if ( 'P' == wc )
            {
                WCHAR * pwcScope = argv[i] + 3;
                if ( wcslen( pwcScope ) >= MAX_PATH )
                    Usage();

                wcscpy( defaults.awcScope, pwcScope );
            }
            else if ( 'Q' == wc )
            {
                WCHAR * pwcQuery = argv[i] + 3;
                if ( wcslen( pwcQuery ) >= MAX_PATH )
                    Usage();

                wcscpy( _awcDefaultQuery, pwcQuery );
            }
            else
                Usage();
        }
        else if ( 0 != pwcCmdLine )
            Usage();
        else
        {
            if ( wcslen( argv[i] ) >= MAX_PATH )
                Usage();

            pwcCmdLine = argv[i];
        }
    }

    if ( pwcCmdLine && pwcCmdLine[0] )
    {
        if ( fNamedArgs )
            Usage();

        // make sure drive / unc is '\' terminated

        // look for machine;catalog;scope or
        //                  catalog;scope or
        //                       catalog; or
        //                          scope

        WCHAR *pwcM = 0;  // machine
        WCHAR *pwcC = 0;  // catalog
        WCHAR *pwcS = 0;  // scope

        WCHAR *pwc = wcschr( pwcCmdLine, L';' );

        if ( pwc )
        {
            *pwc++ = 0;
            WCHAR *pwc2 = wcschr( pwc, L';' );

            if ( pwc2 )
            {
                *pwc2++ = 0;
                pwcM = pwcCmdLine;
                pwcC = pwc;
                pwcS = pwc2;
            }
            else
            {
                pwcC = pwcCmdLine;
                pwcS = pwc;
            }
        }
        else
        {
            pwcS = pwcCmdLine;
        }

        if ( *pwcS )
        {
            if ( ( _wcsicmp( pwcS, L"catalog" ) ) &&
                 ( _wcsicmp( pwcS, L"\\" ) ) )
            {
                int len = wcslen( pwcS );

                if (pwcS[len - 1] != L'\\')
                {
                    pwcS[len] = L'\\';
                    pwcS[len + 1] = 0;
                }

                if ( pwcS[0] != '\\' || pwcS[1] != '\\')
                {
                    WCHAR *pwcFinal;
                    GetFullPathName(pwcS,
                                    sizeof defaults.awcScope / sizeof WCHAR,
                                    defaults.awcScope,
                                    &pwcFinal);
                }
                else wcscpy(defaults.awcScope,pwcS);
            }
            else wcscpy(defaults.awcScope,pwcS);
        }
        else wcscpy(defaults.awcScope,L"\\");  // entire catalog

        if ( pwcM )
            wcscpy( defaults.awcMachine, pwcM );

        if ( pwcC )
            wcscpy( defaults.awcCatalog, pwcC );

    }

    if ( 0 != defaults.awcCatalog[0] )
        fScopeSpecified = TRUE;

    GlobalFree( argv );

    // Populate _xCatList - Note: This doesn't handle distributed queries.
    //                            But that's OK -- it's just a test tool.

    _xCatList.SetSize( wcslen( defaults.awcMachine ) +
                       wcslen( defaults.awcCatalog ) +
                       wcslen( defaults.awcScope ) +
                       1 +  // depth
                       4 +  // delimiters
                       1    // null terminator
                       );

    wcscpy( _xCatList.Get(), defaults.awcMachine );
    wcscat( _xCatList.Get(), L"," );

    wcscat( _xCatList.Get(), defaults.awcCatalog );
    wcscat( _xCatList.Get(), L"," );

    wcscat( _xCatList.Get(), defaults.awcScope );
    wcscat( _xCatList.Get(), L"," );

    wcscat( _xCatList.Get(), defaults.fDeep ? L"d" : L"s" );
    wcscat( _xCatList.Get(), L";" );


    _GetPaths();
    _CreateFonts();

    _iStartupState = GetWindowState(TRUE);
    _iMDIStartupState = GetWindowState(FALSE);
    _fToolBarOn = _fToolBarOnINI = (BOOL) GetRegInt(CISEARCH_REG_TOOLBAR,1);
    _fStatusBarOn = _fStatusBarOnINI = (BOOL) GetRegInt(CISEARCH_REG_STATUSBAR,1);
    _fForceUseCI = _fForceUseCIINI = (BOOL) GetRegInt(CISEARCH_REG_FORCEUSECI,1);
    _sortDir = _sortDirINI = (BOOL) GetRegInt(CISEARCH_REG_SORTDIR,SORT_UP);
    _ulDialect = _ulDialectINI = (ULONG) GetRegInt( CISEARCH_REG_DIALECT, ISQLANG_V1 );
    _ulLimit = _ulLimitINI = (ULONG) GetRegInt( CISEARCH_REG_LIMIT, 0 );
    _ulFirstRows = _ulFirstRowsINI = (ULONG) GetRegInt( CISEARCH_REG_FIRSTROWS, 0 );

    DWORD dw = sizeof _awcSortINI / sizeof _awcSortINI[0];
    if (! GetReg( CISEARCH_REG_SORTPROP, _awcSortINI, &dw ) )
        wcscpy( _awcSortINI, DEFAULT_SORT_PROPERTIES );
    wcscpy( _awcSort, _awcSortINI );

    _lcid = _lcidINI = GetRegLCID( CISEARCH_REG_LOCALE, MAKELCID( MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL),
                                                                              SORT_DEFAULT ) );
    _hAccTable = LoadAccelerators(_hInst,L"SrchAcc");

    int left,top,right,bottom;
    LoadWindowRect( &left, &top, &right, &bottom, CISEARCH_REG_POSITION );

    CResString strApp( IDS_APPNAME );

    if ((_hAppWnd = CreateWindow(APP_CLASS, strApp.Get(),
                                 WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                                 left,top,right,bottom,
                                 0,0,_hInst,0)) &&
        (_hStatusBarWnd = CreateStatusWindow( SBARS_SIZEGRIP |
                                              (_fStatusBarOn ? WS_VISIBLE : 0) |
                                              WS_CHILD,
                                              L"",
                                              _hAppWnd,
                                              0 ) ) &&
        (_hToolBarWnd = CreateTBar( _hAppWnd, _hInst ) ) )
    {
        UpdateWindow(_hAppWnd);

        if (_fStatusBarOn)
            CheckMenuItem(GetMenu(_hAppWnd),IDM_STATUS_BAR,MF_CHECKED);
        if (_fToolBarOn)
            CheckMenuItem(GetMenu(_hAppWnd),IDM_ICON_BAR,MF_CHECKED);
        if (_fForceUseCI)
            CheckMenuItem(GetMenu(_hAppWnd),IDM_FORCE_USE_CI,MF_CHECKED);

        PostMessage(_hAppWnd,wmOpenCatalog,!fScopeSpecified,0);
    }
    else
    {
        THROW(CException(E_FAIL));
    }
} //_InitInstance

HWND CSearchApp::_MakeMDI(
    WCHAR const *pwcTitle,
    WCHAR *pwcClass,
    UINT uiState,
    DWORD dwStyle,
    LPARAM lParam)
{
    HWND hwndActive;

    if ((hwndActive = GetActiveMDI()) && IsZoomed(hwndActive))
        uiState = 1;
    else if (!_CountMDIChildren())
        uiState = (UINT) _iMDIStartupState;

    MDICREATESTRUCT mcs;

    mcs.szTitle = pwcTitle;
    mcs.szClass = pwcClass;
    mcs.hOwner = _hInst;
    mcs.x = mcs.cx = mcs.y = mcs.cy = CW_USEDEFAULT;

    if (1 == uiState)
        mcs.style = WS_MAXIMIZE;
    else if (2 == uiState)
        mcs.style = WS_MINIMIZE;
    else
        mcs.style = 0;

    mcs.style |= dwStyle;
    mcs.lParam = lParam;

    return (HWND) SendMessage(_hMDIClientWnd,WM_MDICREATE,0,(LPARAM) &mcs);
} //_MakeMDI

int CSearchApp::_SaveWindowState(
    BOOL fApp)
{
    int iState=0,i;
    HWND h;
    WCHAR *pwc,awcBuf[30];

    if (fApp)
    {
        pwc = L"main";
        h = _hAppWnd;
        i = _iStartupState;
    }
    else
    {
        pwc = L"mdi";
        h = GetActiveMDI();
        i = _iMDIStartupState;
    }
    if (h)
    {
        if (IsZoomed(h))
            iState = 1;
        else
            iState = 0;

        int z = fApp ? _iStartupState : _iMDIStartupState;

        if (iState != z)
        {
            if (fApp)
                _iStartupState = iState;
            else
                _iMDIStartupState = iState;

            wcscpy(awcBuf,pwc);
            wcscat(awcBuf,L"-state");
            SetRegInt(awcBuf,iState);
        }
    }
    return iState;
} //_SaveWindowState

int CSearchApp::_CountMDIChildren(void)
{
    HWND hwndActive;
    int cItems = 0;

    if ((_hMDIClientWnd) &&
        (hwndActive = GetActiveMDI()))
        do
            cItems++;
        while (hwndActive = GetNextWindow(hwndActive,GW_HWNDNEXT));

    return cItems;
} //_CountMDIChildren

int CSearchApp::_CountMDISearch(void)
{
    HWND h;
    int cItems = 0;

    if ((_hMDIClientWnd) &&
        (h = GetActiveMDI()))
    {
        do
        {
            if (IsSpecificClass(h,SEARCH_CLASS))
                cItems++;
        }
        while (h = GetNextWindow(h,GW_HWNDNEXT));
    }

    return cItems;
} //_CountMDISearch

LRESULT CSearchApp::_SendToMDIChildren(
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND h;
    LRESULT l = 0;

    if ((_hMDIClientWnd) &&
        (h = GetActiveMDI()))
    {
        do
            l = SendMessage(h,msg,wParam,lParam);
        while (h = GetNextWindow(h,GW_HWNDNEXT));
    }

    return l;
} //_SendToMDIChildren

LRESULT CSearchApp::_SendToSpecificChildren(
    WCHAR *pwcClass,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND h;
    LRESULT l = 0;

    if ((_hMDIClientWnd) &&
        (h = GetActiveMDI()))
        do
            if (IsSpecificClass(h,pwcClass))
                l = SendMessage(h,msg,wParam,lParam);
        while (h = GetNextWindow(h,GW_HWNDNEXT));

    return l;
} //_SendToSpecificChildren

LRESULT CSearchApp::_SendToActiveMDI(
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hwndActive;
    LRESULT l = 0;

    if ((_hMDIClientWnd) &&
        (hwndActive = GetActiveMDI()))
        l = SendMessage(hwndActive,msg,wParam,lParam);

    return l;
} //_SendToActiveMDI

void CSearchApp::_ShowHelp(UINT uiCmnd,DWORD dw)
{
  if (!HtmlHelp(_hAppWnd,_awcHelpFile,uiCmnd,dw))
      SearchError(_hAppWnd,IDS_ERR_CANT_OPEN_HELP,_awcHelpFile);
} //_ShowHelp

const SLocaleEntry aLocaleEntries[] =
{
    { IDM_LOCALE_NEUTRAL,
      MAKELCID( MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL), SORT_DEFAULT ) },
    { IDM_LOCALE_CHINESE_TRADITIONAL,
      MAKELCID( MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL), SORT_DEFAULT ) },
    { IDM_LOCALE_CHINESE_SIMPLIFIED,
      MAKELCID( MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED), SORT_DEFAULT ) },
    { IDM_LOCALE_CHINESE_HONGKONG,
      MAKELCID( MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_HONGKONG), SORT_DEFAULT ) },
    { IDM_LOCALE_CHINESE_SINGAPORE,
      MAKELCID( MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_SINGAPORE), SORT_DEFAULT ) },
    { IDM_LOCALE_CHINESE_MACAU,
      MAKELCID( MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_MACAU), SORT_DEFAULT ) },
    { IDM_LOCALE_DUTCH_DUTCH,
      MAKELCID( MAKELANGID( LANG_DUTCH, SUBLANG_DUTCH), SORT_DEFAULT ) },
    { IDM_LOCALE_ENGLISH_CAN,
      MAKELCID( MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_CAN), SORT_DEFAULT ) },
    { IDM_LOCALE_ENGLISH_US,
      MAKELCID( MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT ) },
    { IDM_LOCALE_ENGLISH_UK,
      MAKELCID( MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_UK), SORT_DEFAULT ) },
    { IDM_LOCALE_FINNISH_DEFAULT,
      MAKELCID( MAKELANGID( LANG_FINNISH, SUBLANG_DEFAULT), SORT_DEFAULT ) },
    { IDM_LOCALE_FARSI_DEFAULT,
      MAKELCID( MAKELANGID( LANG_FARSI, SUBLANG_DEFAULT), SORT_DEFAULT ) },
    { IDM_LOCALE_FRENCH_FRENCH,
      MAKELCID( MAKELANGID( LANG_FRENCH, SUBLANG_FRENCH), SORT_DEFAULT ) },
    { IDM_LOCALE_FRENCH_CANADIAN,
      MAKELCID( MAKELANGID( LANG_FRENCH, SUBLANG_FRENCH_CANADIAN), SORT_DEFAULT ) },
    { IDM_LOCALE_GERMAN_GERMAN,
      MAKELCID( MAKELANGID( LANG_GERMAN, SUBLANG_GERMAN), SORT_DEFAULT ) },
    { IDM_LOCALE_GREEK_DEFAULT,
      MAKELCID( MAKELANGID( LANG_GREEK, SUBLANG_DEFAULT), SORT_DEFAULT ) },
    { IDM_LOCALE_HEBREW_DEFAULT,
      MAKELCID( MAKELANGID( LANG_HEBREW, SUBLANG_DEFAULT), SORT_DEFAULT ) },
    { IDM_LOCALE_HINDI_DEFAULT,
      MAKELCID( MAKELANGID( LANG_HINDI, SUBLANG_DEFAULT), SORT_DEFAULT ) },
    { IDM_LOCALE_ITALIAN_ITALIAN,
      MAKELCID( MAKELANGID( LANG_ITALIAN, SUBLANG_ITALIAN), SORT_DEFAULT ) },
    { IDM_LOCALE_JAPANESE_DEFAULT,
      MAKELCID( MAKELANGID( LANG_JAPANESE, SUBLANG_DEFAULT), SORT_DEFAULT ) },
    { IDM_LOCALE_KOREAN_KOREAN,
      MAKELCID( MAKELANGID( LANG_KOREAN, SUBLANG_KOREAN), SORT_DEFAULT ) },
//    { IDM_LOCALE_KOREAN_JOHAB,
//      MAKELCID( MAKELANGID( LANG_KOREAN, SUBLANG_KOREAN_JOHAB), SORT_DEFAULT ) },
    { IDM_LOCALE_POLISH_DEFAULT,
      MAKELCID( MAKELANGID( LANG_POLISH, SUBLANG_DEFAULT), SORT_DEFAULT ) },
    { IDM_LOCALE_ROMANIAN_DEFAULT,
      MAKELCID( MAKELANGID( LANG_ROMANIAN, SUBLANG_DEFAULT), SORT_DEFAULT ) },
    { IDM_LOCALE_RUSSIAN_DEFAULT,
      MAKELCID( MAKELANGID( LANG_RUSSIAN, SUBLANG_DEFAULT), SORT_DEFAULT ) },
    { IDM_LOCALE_SPANISH_CASTILIAN,
      MAKELCID( MAKELANGID( LANG_SPANISH, SUBLANG_SPANISH), SORT_DEFAULT ) },
    { IDM_LOCALE_SPANISH_MEXICAN,
      MAKELCID( MAKELANGID( LANG_SPANISH, SUBLANG_SPANISH_MEXICAN), SORT_DEFAULT ) },
    { IDM_LOCALE_SPANISH_MODERN,
      MAKELCID( MAKELANGID( LANG_SPANISH, SUBLANG_SPANISH_MODERN), SORT_DEFAULT ) },
    { IDM_LOCALE_SWAHILI_DEFAULT,
      MAKELCID( MAKELANGID( LANG_SWAHILI, SUBLANG_DEFAULT), SORT_DEFAULT ) },
    { IDM_LOCALE_SWEDISH_DEFAULT,
      MAKELCID( MAKELANGID( LANG_SWEDISH, SUBLANG_DEFAULT), SORT_DEFAULT ) },
    { IDM_LOCALE_THAI_DEFAULT,
      MAKELCID( MAKELANGID( LANG_THAI, SUBLANG_DEFAULT), SORT_DEFAULT ) },
    { IDM_LOCALE_TURKISH_DEFAULT,
      MAKELCID( MAKELANGID( LANG_TURKISH, SUBLANG_DEFAULT), SORT_DEFAULT ) },
    { IDM_LOCALE_UKRAINIAN_DEFAULT,
      MAKELCID( MAKELANGID( LANG_UKRAINIAN, SUBLANG_DEFAULT), SORT_DEFAULT ) },
    { IDM_LOCALE_VIETNAMESE_DEFAULT,
      MAKELCID( MAKELANGID( LANG_VIETNAMESE, SUBLANG_DEFAULT), SORT_DEFAULT ) },
};

const ULONG cLocaleEntries = sizeof aLocaleEntries / sizeof SLocaleEntry;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\srch\view.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       view.cxx
//
//  Contents:   
//
//  History:    15 Aug 1996     DLee    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

const int cpMargin = 2;
const int cpInflate = 4;
const int cpPaneMargin = 3;
const int cpPaneSpacing = 5;
const int cpPaneBottomSpacing = 0;

const DBID colAttrib = { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) (ULONG_PTR) PID_STG_ATTRIBUTES };
const DBID colFileIndex = { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) (ULONG_PTR) PID_STG_FILEINDEX };

CSearchView::CSearchView(
    HWND                hwndSearch,
    CSearchControl &    control,
    CColumnList &       columns )
    :
    _hwndSearch( hwndSearch ),
    _hwndQuery( 0 ),
    _hwndQueryTitle( 0 ),
    _hwndList( 0 ),
    _hwndHeader( 0 ),
    _hbrushWindow( 0 ),
    _hbrushHighlight( 0 ),
    _fHavePlacedTitles( FALSE ),
    _hfontShell( 0 ),
    _cLines( 0 ),
    _control( control ),
    _columns( columns ),
    _fMucked( FALSE ),
    _iColAttrib( 0xffffffff ),
    _iColFileIndex( 0xffffffff )
{
    MakeFont();
    _cpFontHeight = ::GetLineHeight( hwndSearch, _hfontShell );
    _iLineHeightList = ::GetLineHeight( hwndSearch, App.AppFont() );
    SysColorChange ();
} //CSearchView

CSearchView::~CSearchView()
{
    if (0 != _hfontShell)
        DeleteObject(_hfontShell);

    if (0 != _hbrushWindow)
    {
        DeleteObject(_hbrushWindow);
        DeleteObject(_hbrushHighlight);
    }
} //~CSearchView

unsigned CSearchView::ColumnWidth(
    unsigned x )
{
    if ( 0 == x )
        return _aWidths[ 0 ] + cpInflate + _cpAvgWidth/2 + cpMargin;
    else
        return _aWidths[ x ] + _cpAvgWidth;
} //ColumnWidth

void CSearchView::SetColumnWidth(
    unsigned x,
    unsigned cpWidth )
{
    unsigned w;

    if ( 0 == x )
        w = cpWidth - cpInflate - _cpAvgWidth/2 - cpMargin;
    else
        w = cpWidth - _cpAvgWidth;

    if ( _aWidths[ x ] > w )
        _fMucked = TRUE;

    _aWidths[ x ] = w;
} //SetColumnWidth

unsigned CSearchView::SetDefColumnWidth(
    unsigned iCol )
{
    DBID *pdbid;
    unsigned cc;
    DBTYPE pt;

    IColumnMapper & colMap = _control.GetColumnMapper();

    SCODE sc = colMap.GetPropInfoFromName( _columns.GetColumn( iCol ),
                                           &pdbid,
                                           &pt,
                                           &cc );
    if ( FAILED( sc ) )
        THROW( CException( sc ) );

    _aPropTypes[ iCol ] = pt;

    if ( ( VT_FILETIME == pt ) || ( DBTYPE_DATE == pt ) )
        _aWidths[ iCol ] = _cpDateWidth + _cpTimeWidth;
    else if ( VT_CLSID == pt )
        _aWidths[ iCol ] = _cpGuidWidth;
    else if ( VT_BOOL == pt )
        _aWidths[ iCol ] = _cpBoolWidth;
    else if ( !memcmp( pdbid, &colAttrib, sizeof DBID ) )
    {
        _aWidths[ iCol ] = _cpAttribWidth;
        _iColAttrib = iCol;
    }
    else if ( !memcmp( pdbid, &colFileIndex, sizeof DBID ) )
    {
        _aWidths[ iCol ] = _cpFileIndexWidth;
        _iColFileIndex = iCol;
    }
    else
        _aWidths[ iCol ] = cc * _cpAvgWidth;

    // did the attrib column get redefined?

    if ( _iColAttrib == iCol && memcmp( pdbid, &colAttrib, sizeof DBID ) )
        _iColAttrib = 0xffffffff;

    // did the fileindex column get redefined?

    if ( _iColFileIndex == iCol && memcmp( pdbid, &colFileIndex, sizeof DBID ) )
        _iColFileIndex = 0xffffffff;

    return ColumnWidth( iCol );
} //SetDefColumnWidth

void CSearchView::ColumnsChanged()
{
    _ComputeFieldWidths();

    for ( unsigned iCol = 0; iCol < _columns.NumberOfColumns(); iCol++ )
        SetDefColumnWidth( iCol );
} //ColumnsChanged

void CSearchView::MakeFont()
{
    LOGFONT lf;
    memset( &lf, 0, sizeof LOGFONT );

    lf.lfHeight = -11;
    lf.lfWeight = FW_NORMAL;
    lf.lfCharSet = ANSI_CHARSET;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = PROOF_QUALITY;
    lf.lfPitchAndFamily = FF_SWISS | VARIABLE_PITCH;
    wcscpy( lf.lfFaceName, L"MS SHELL DLG" );
    _hfontShell = CreateFontIndirect( &lf );
} //MakeFont

void CSearchView::SysColorChange()
{
    if (0 != _hbrushWindow)
    {
        DeleteObject(_hbrushWindow);
        DeleteObject(_hbrushHighlight);
    }

    _colorHighlight     = GetSysColor(COLOR_HIGHLIGHT);
    _colorHighlightText = GetSysColor(COLOR_HIGHLIGHTTEXT);
    _colorWindow        = GetSysColor(COLOR_WINDOW);
    _colorWindowText    = GetSysColor(COLOR_WINDOWTEXT);

    _hbrushHighlight    = CreateSolidBrush( _colorHighlight );
    _hbrushWindow       = CreateSolidBrush( _colorWindow );
} //SysColorChange

void CSearchView::InitPanes (
    HWND hwndQueryTitle,
    HWND hwndQuery,
    HWND hwndList,
    HWND hwndHeader )
{
    _hwndQueryTitle = hwndQueryTitle;
    _hwndQuery      = hwndQuery;
    _hwndList       = hwndList;
    _hwndHeader     = hwndHeader;

    SendMessage( _hwndQueryTitle, WM_SETFONT, (WPARAM) _hfontShell, 1 );
    SendMessage( _hwndHeader, WM_SETFONT, (WPARAM) _hfontShell, 1 );
    SendMessage( _hwndQuery, WM_SETFONT, (WPARAM) App.AppFont(), 1 );
    SendMessage( _hwndList, WM_SETFONT, (WPARAM) App.AppFont(), 1 );
} //InitPanes

void CSearchView::PrimeItem(
    LPDRAWITEMSTRUCT & lpdis,
    RECT &             rc )
{
    CopyRect( &rc, &lpdis->rcItem );
    InflateRect( (LPRECT) &rc, 1, 0 );

    HBRUSH hbr;

    if ( lpdis->itemState & ODS_SELECTED )
    {
        SetBkColor( lpdis->hDC, _colorHighlight );
        SetTextColor( lpdis->hDC, _colorHighlightText );
        hbr = _hbrushHighlight;
    }
    else
    {
        SetBkColor( lpdis->hDC, _colorWindow );
        SetTextColor( lpdis->hDC, _colorWindowText );
        hbr = _hbrushWindow;
    }

    FillRect( lpdis->hDC, &rc, hbr );

    InflateRect( &rc, -cpInflate, 0 );
} //PrimeItem

inline void _drawText(
    HDC      hdc,
    RECT &   rc,
    unsigned cpWidth,
    WCHAR *  pwc,
    int      cwc,
    BOOL     fClip )
{
    RECT rctext = rc;
    rctext.right = rc.left + cpWidth;

    DrawText( hdc,
              pwc,
              cwc,
              &rctext,
              DT_VCENTER | DT_NOPREFIX | DT_RIGHT | DT_SINGLELINE |
              ( fClip ? 0 : DT_NOCLIP ) );
} //_drawText

template<class T> void _drawVectorItems(
    T *      pVal,
    ULONG    cVals,
    WCHAR *  pwcFmt,
    HDC      hdc,
    RECT &   rc,
    unsigned width )
{
    WCHAR awcBuf[ cwcBufSize ];
    unsigned ccUnused = cwcBufSize - 10;
    WCHAR *pwcEnd = awcBuf;

    *pwcEnd++ = L'{';

    for( unsigned iVal = 0;
         iVal < cVals && ccUnused > 0;
         iVal++ )
    {
        int ccPrinted = _snwprintf( pwcEnd,
                                    ccUnused,
                                    pwcFmt,
                                    iVal == 0 ? L' ': L',',
                                    *pVal++ );

        if ( ccPrinted == -1 )
            break;

        ccUnused -= ccPrinted;
        pwcEnd += ccPrinted;
    }

    if ( iVal != cVals )
    {
        *pwcEnd++ = L'.';
        *pwcEnd++ = L'.';
        *pwcEnd++ = L'.';
    }

    *pwcEnd++ = L' ';
    *pwcEnd++ = L'}';
    *pwcEnd = L'\0';

    _drawText( hdc, rc, width, awcBuf, -1, TRUE );
} //_drawVectorItems

void Append( CDynArrayInPlace<WCHAR> & xBuf, WCHAR const * pwc, unsigned cwc )
{
    for ( unsigned i = 0; i < cwc; i++ )
        xBuf[ xBuf.Count() ] = pwc[ i ];
} //Append

void Append( CDynArrayInPlace<WCHAR> & xBuf, WCHAR const * pwc )
{
    while ( 0 != *pwc )
        xBuf[ xBuf.Count() ] = *pwc++;
} //Append

void RenderSafeArray(
    WCHAR *     pwc,
    unsigned    cwcMax,
    VARTYPE     vt,
    LPSAFEARRAY pa );

void Render(
    CDynArrayInPlace<WCHAR> & xOut,
    VARTYPE                   vt,
    void *                    pv )
{
    srchDebugOut(( DEB_ITRACE, "vt %#x, pv %#x\n", vt, pv ));
    __int64 i = 0;

    XArray<WCHAR> xBuf( cwcBufSize );
    WCHAR *awcBuf = xBuf.GetPointer();
    XArray<WCHAR> xTmp( cwcBufSize );
    WCHAR *awcTmp = xTmp.GetPointer();
    static WCHAR wszfmtU[] = L"%I64u";
    WCHAR *pwszfmt = L"%I64d";
    LCID lcid = App.GetLocale();

    if ( VT_ARRAY & vt )
    {
        SAFEARRAY *psa = *(SAFEARRAY **) pv;
        *awcBuf = 0;
        RenderSafeArray( awcBuf, cwcBufSize, vt - VT_ARRAY, psa );
        Append( xOut, awcBuf );
        return;
    }

    switch ( vt )
    {
        case VT_UI1:
            i = (unsigned __int64) *(BYTE *)pv;
            goto do_ui64;

        case VT_I1:
            i = *(CHAR *)pv;
            goto do_i64;

        case VT_UI2:
            i = (unsigned __int64) *(USHORT *)pv;
            goto do_ui64;

        case VT_I2:
            i = (unsigned __int64) *(SHORT *)pv;
            goto do_i64;

        case VT_UI4:
        case VT_UINT:
            i = (unsigned __int64) *(ULONG *)pv;
            goto do_ui64;

        case VT_I4:
        case VT_ERROR:
        case VT_INT:
            i = (unsigned __int64) *(LONG *)pv;
            goto do_i64;

        case VT_UI8:
            RtlCopyMemory( &i, pv, sizeof i );
do_ui64:
            pwszfmt = wszfmtU;
            goto do_i64;

        case VT_I8:
            RtlCopyMemory( &i, pv, sizeof i );

do_i64:
        {
            swprintf( awcTmp, pwszfmt, i );
            int cwc = GetNumberFormat( lcid, 0, awcTmp,
                                       & App.NumberFormat(), awcBuf,
                                       cwcBufSize );
            Append( xOut, awcBuf, cwc - 1);
            break;
        }
        case VT_R4:
        {
            float f;
            RtlCopyMemory( &f, pv, sizeof f );
            swprintf( awcTmp, L"%f", f );
            int cwc = GetNumberFormat( lcid, 0, awcTmp,
                                       & App.NumberFormatFloat(),
                                       awcBuf,
                                       cwcBufSize );
            Append( xOut, awcBuf, cwc - 1 );
            break;
        }
        case VT_R8:
        {
            double d;
            RtlCopyMemory( &d, pv, sizeof d );
            swprintf( awcTmp, L"%lf", d );
            int cwc = GetNumberFormat( lcid, 0, awcTmp,
                                       & App.NumberFormatFloat(),
                                       awcBuf,
                                       cwcBufSize );
            Append( xOut, awcBuf, cwc - 1 );
            break;
        }
        case VT_DECIMAL:
        {
            double dbl;
            VarR8FromDec( (DECIMAL *) pv, &dbl );
            swprintf( awcTmp, L"%lf", dbl );
            int cwc = GetNumberFormat( lcid, 0, awcTmp,
                                       & App.NumberFormatFloat(),
                                       awcBuf,
                                       cwcBufSize );
            Append( xOut, awcBuf, cwc - 1 );
            break;
        }
        case VT_CY:
        {
            double dbl;
            VarR8FromCy( * (CY *) pv, &dbl );
            swprintf( awcTmp, L"%lf", dbl );
            int cwc = GetNumberFormat( lcid, 0, awcTmp,
                                       & App.NumberFormatFloat(),
                                       awcBuf,
                                       cwcBufSize );
            Append( xOut, awcBuf, cwc - 1 );
            break;
        }
        case VT_BOOL:
        {
            Append( xOut,
                    *(VARIANT_BOOL *)pv ? App.GetTrue() : App.GetFalse() );
            break;
        }
        case VT_BSTR:
        {
            BSTR bstr = *(BSTR *) pv;
            Append( xOut, bstr );
            break;
        }
        case VT_VARIANT:
        {
            PROPVARIANT * pVar = (PROPVARIANT *) pv;
            Render( xOut, pVar->vt, & pVar->lVal );
            break;
        }
        case VT_DATE:
        {
            DATE date;
            RtlCopyMemory( &date, pv, sizeof date );
            awcBuf[0] = 0;

            // no timezone is expressed or implied in variant dates.

            SYSTEMTIME SysTime;
            RtlZeroMemory( &SysTime, sizeof SysTime );
            VariantTimeToSystemTime( date, &SysTime );

            // date
            int cwc = GetDateFormat( lcid, DATE_SHORTDATE, &SysTime,
                                     0, awcBuf, cwcBufSize );
            if ( 0 != cwc )
                Append( xOut, awcBuf, cwc - 1 );

            Append( xOut, L" " );

            // time
            cwc = GetTimeFormat( lcid, 0, &SysTime, 0, awcBuf,
                                 cwcBufSize );
            if ( 0 != cwc )
                Append( xOut, awcBuf, cwc - 1 );
            break;
        }

        case VT_EMPTY:
        case VT_NULL:
        {
            break;
        }
        default :
        {
            swprintf( awcTmp, L"(vt 0x%x)", (int) vt );
            Append( xOut, awcTmp );
            break;
        }
    }
} //Render

void RenderSafeArray(
    WCHAR *     pwc,
    unsigned    cwcMax,
    VARTYPE     vt,
    LPSAFEARRAY pa )
{
    *pwc = 0;
    cwcMax -= 10; // leave room for formatting

    // Get the dimensions of the array

    CDynArrayInPlace<WCHAR> xOut;
    UINT cDim = SafeArrayGetDim( pa );
    if ( 0 == cDim )
        return;

    XArray<LONG> xDim( cDim );
    XArray<LONG> xLo( cDim );
    XArray<LONG> xUp( cDim );

    for ( UINT iDim = 0; iDim < cDim; iDim++ )
    {
        HRESULT hr = SafeArrayGetLBound( pa, iDim + 1, &xLo[iDim] );
        if ( FAILED( hr ) )
            return;

        xDim[ iDim ] = xLo[ iDim ];

        hr = SafeArrayGetUBound( pa, iDim + 1, &xUp[iDim] );
        if ( FAILED( hr ) )
            return;

        srchDebugOut(( DEB_ITRACE, "dim %d, lo %d, up %d\n",
                       iDim, xLo[iDim], xUp[iDim] ));

        xOut[ xOut.Count() ] = L'{';
    }

    // slog through the array

    UINT iLastDim = cDim - 1;
    BOOL fDone = FALSE;

    while ( !fDone && ( xOut.Count() < cwcMax ) )
    {
        // inter-element formatting

        if ( xDim[ iLastDim ] != xLo[ iLastDim ] )
            xOut[ xOut.Count() ] = L',';

        // Get the element and render it

        void *pv;
        HRESULT hr = SafeArrayPtrOfIndex( pa, xDim.GetPointer(), &pv );
        Win4Assert( SUCCEEDED( hr ) );
        Render( xOut, vt, pv );

        // Move to the next element and carry if necessary

        ULONG cOpen = 0;

        for ( LONG iDim = iLastDim; iDim >= 0; iDim-- )
        {
            if ( xDim[ iDim ] < xUp[ iDim ] )
            {
                xDim[ iDim ] = 1 + xDim[ iDim ];
                break;
            }

            xOut[ xOut.Count() ] = L'}';

            if ( 0 == iDim )
                fDone = TRUE;
            else
            {
                cOpen++;
                xDim[ iDim ] = xLo[ iDim ];
            }
        }

        for ( ULONG i = 0; !fDone && i < cOpen; i++ )
            xOut[ xOut.Count() ] = L'{';
    }

    unsigned cwc = __min( cwcMax, xOut.Count() );
    RtlCopyMemory( pwc, xOut.GetPointer(), cwc * sizeof WCHAR );

    // If it wouldn't all fit, show ...

    if ( !fDone )
    {
        pwc[ cwc++ ] = '.';
        pwc[ cwc++ ] = '.';
        pwc[ cwc++ ] = '.';
    }

    pwc[ cwc ] = 0;
} //RenderSafeArray

void CSearchView::PaintItem (
    CSearchQuery * pSearch,
    HDC            hdc,
    RECT &         rc,
    DWORD          iRow )
{
    static WCHAR wszfmtU[] = L"%u";    // unsigned scalar
    static WCHAR wszfmtVU[] = L"%lc%u"; // vector of unsigned scalars

    PROPVARIANT * aProps[ maxBoundCols ];
    unsigned cColumns;

    if ( ! pSearch->GetRow( iRow, cColumns, aProps ) )
        return;

    //
    // These must be static for IceCap profiling to work.  Declaring them on
    // stack causes __alloca_probe (alias: _chkstk) to be called.  This
    // routine plays funny games with the stack that IceCap V3 doesn't understand.
    //

    static WCHAR awcBuf[cwcBufSize];
    static WCHAR awcTmp[cwcBufSize];

    LCID lcid = App.GetLocale();
    rc.left += cpMargin; // leave a margin

    for ( unsigned i = 0; i < cColumns; i++ )
    {
        PROPVARIANT & v = * aProps[ i ];
        unsigned width = _aWidths[ i ];
        WCHAR *pwszfmt = L"%d";            // signed scalar
        WCHAR *pwszfmtV = L"%lc%d";        // vector of signed scalars
        BOOL fHighPartValid;

        switch ( v.vt )
        {
            case VT_UI1:
                v.ulVal = v.bVal;
                goto doulong;

            case VT_I1:
                v.lVal = v.cVal;
                goto dolong;

            case VT_UI2:
                v.ulVal = v.uiVal;
                goto doulong;

            case VT_I2:
                v.lVal = v.iVal;
                goto dolong;

            case VT_UI4:
            case VT_UINT:
doulong:
                pwszfmt = wszfmtU;
            case VT_I4:
            case VT_INT:
            case VT_ERROR:
dolong:
            {
                int cwc;

                if ( i == _iColAttrib )
                {
                    cwc = 0;
                    WCHAR *pwc = App.GetAttrib();
                    LONG l = v.lVal;
                    if ( l & FILE_ATTRIBUTE_READONLY )
                        awcBuf[ cwc++ ] = pwc[ 0 ];
                    if ( l & FILE_ATTRIBUTE_HIDDEN )
                        awcBuf[ cwc++ ] = pwc[ 1 ];
                    if ( l & FILE_ATTRIBUTE_SYSTEM )
                        awcBuf[ cwc++ ] = pwc[ 2 ];
                    if ( l & FILE_ATTRIBUTE_DIRECTORY )
                        awcBuf[ cwc++ ] = pwc[ 3 ];
                    if ( l & FILE_ATTRIBUTE_ARCHIVE )
                        awcBuf[ cwc++ ] = pwc[ 4 ];
                    if ( l & FILE_ATTRIBUTE_ENCRYPTED )
                        awcBuf[ cwc++ ] = pwc[ 5 ];
                    if ( l & FILE_ATTRIBUTE_NORMAL )
                        awcBuf[ cwc++ ] = pwc[ 6 ];
                    if ( l & FILE_ATTRIBUTE_TEMPORARY )
                        awcBuf[ cwc++ ] = pwc[ 7 ];
                    if ( l & FILE_ATTRIBUTE_SPARSE_FILE )
                        awcBuf[ cwc++ ] = pwc[ 8 ];
                    if ( l & FILE_ATTRIBUTE_REPARSE_POINT )
                        awcBuf[ cwc++ ] = pwc[ 9 ];
                    if ( l & FILE_ATTRIBUTE_COMPRESSED )
                        awcBuf[ cwc++ ] = pwc[ 10 ];
                    if ( l & FILE_ATTRIBUTE_OFFLINE )
                        awcBuf[ cwc++ ] = pwc[ 11 ];
                    if ( l & FILE_ATTRIBUTE_NOT_CONTENT_INDEXED )
                        awcBuf[ cwc++ ] = pwc[ 12 ];
                    awcBuf[ cwc ] = 0;
                }
                else
                {
                    if ( pwszfmt == wszfmtU )
                        _ultow( v.lVal, awcTmp, 10 );
                    else
                        _ltow( v.lVal, awcTmp, 10 );

                    cwc = GetNumberFormat( lcid, 0, awcTmp,
                                           & App.NumberFormat(), awcBuf,
                                           cwcBufSize );
                    cwc--;
                }

                _drawText( hdc, rc, width, awcBuf, cwc, _fMucked );
                break;
            }

            case VT_I8:
            {
                _i64tow( * (__int64 *) &v.hVal, awcTmp, 10 );
                int cwc = GetNumberFormat( lcid, 0, awcTmp,
                                           & App.NumberFormat(), awcBuf,
                                           cwcBufSize );
                cwc--;
                _drawText( hdc, rc, width, awcBuf, cwc, _fMucked );
                break;
            }

            case VT_UI8:
            {
                if ( i == _iColFileIndex )
                {
                    wcscpy( awcBuf, L"0x" );

                    if ( 0 != v.hVal.HighPart )
                    {
                        wsprintf( awcTmp, L"%08x,", v.hVal.HighPart );
                        wcscat( awcBuf, awcTmp );
                    }

                    wsprintf( awcTmp, L"%08x", v.hVal.LowPart );
                    wcscat( awcBuf, awcTmp );
                    _drawText( hdc, rc, width, awcBuf, -1, _fMucked );
                }
                else
                {
                    _ui64tow( *(unsigned __int64 *) &v.hVal, awcTmp, 10 );
                    int cwc = GetNumberFormat( lcid, 0, awcTmp,
                                               & App.NumberFormat(), awcBuf,
                                               cwcBufSize );
                    cwc--;
                    _drawText( hdc, rc, width, awcBuf, cwc, _fMucked );
                }
                break;
            }

            case VT_FILETIME :
            {
                awcBuf[0] = 0;

                if ( 0 == v.filetime.dwLowDateTime &&
                     0 == v.filetime.dwHighDateTime )
                {
                    _drawText( hdc, rc, width, L"0", -1, TRUE );
                }
                else
                {
                    // convert the file time to local time, then to system time
                    FILETIME LocalFTime;
                    memset( &LocalFTime, 0, sizeof LocalFTime );
                    FileTimeToLocalFileTime( &(v.filetime), &LocalFTime );
                    SYSTEMTIME SysTime;
                    memset( &SysTime, 0, sizeof SysTime );
                    FileTimeToSystemTime( &LocalFTime, &SysTime );

                    // date
                    int cwc = GetDateFormat( lcid, DATE_SHORTDATE, &SysTime,
                                             0, awcBuf, cwcBufSize );
                    int dmin = __min( _cpDateWidth, (int) width );
                    if ( 0 != cwc )
                        _drawText( hdc, rc, dmin, awcBuf, cwc - 1, _fMucked );

                    // time
                    if ( (int) width > _cpDateWidth )
                    {
                        cwc = GetTimeFormat( lcid, 0, &SysTime, 0, awcBuf,
                                             cwcBufSize );
                        int left = rc.left;
                        rc.left += _cpDateWidth;
                        int tmin = __min( _cpTimeWidth, (int) width - _cpDateWidth );
                        if ( 0 != cwc )
                            _drawText( hdc, rc, tmin, awcBuf, cwc - 1, _fMucked );
                        rc.left = left;
                    }
                }

                break;
            }

            case VT_LPWSTR :
            case DBTYPE_WSTR | DBTYPE_BYREF :
            case VT_LPSTR :
            case DBTYPE_STR | DBTYPE_BYREF :
            case VT_BSTR :
            {
                if ( 0 != v.pwszVal )
                {
                    // don't clip if it's the last column

                    UINT f = ( i == ( cColumns - 1 ) ) ? DT_NOCLIP : 0;
                    RECT rctext;
                    CopyRect( &rctext, &rc );
                    rctext.right = rc.left + width;

                    if ( ( VT_LPSTR == v.vt ) ||
                         ( ( DBTYPE_STR | DBTYPE_BYREF ) == v.vt ) )
                        DrawTextA( hdc,
                                   v.pszVal,
                                   -1,
                                   &rctext,
                                   DT_VCENTER | DT_LEFT | DT_NOPREFIX |
                                   DT_SINGLELINE | f );
                    else
                        DrawText( hdc,
                                  v.pwszVal,
                                  -1,
                                  &rctext,
                                  DT_VCENTER | DT_LEFT | DT_NOPREFIX |
                                  DT_SINGLELINE | f );
                }
                break;
            }

            case VT_R4:
            {
                swprintf( awcTmp, L"%f", v.fltVal );
                int cwc = GetNumberFormat( lcid, 0, awcTmp,
                                           & App.NumberFormatFloat(),
                                           awcBuf,
                                           cwcBufSize );
                cwc--;
                _drawText( hdc, rc, width, awcBuf, cwc, _fMucked );
                break;
            }

            case VT_DATE:
            {
                awcBuf[0] = 0;

                SYSTEMTIME SysTime;
                RtlZeroMemory( &SysTime, sizeof SysTime );
                VariantTimeToSystemTime( v.date, &SysTime );

                // date

                int cwc = GetDateFormat( lcid, DATE_SHORTDATE, &SysTime,
                                         0, awcBuf, cwcBufSize );
                int dmin = __min( _cpDateWidth, (int) width );
                if ( 0 != cwc )
                    _drawText( hdc, rc, dmin, awcBuf, cwc - 1, _fMucked );

                // time

                if ( (int) width > _cpDateWidth )
                {
                    cwc = GetTimeFormat( lcid, 0, &SysTime, 0, awcBuf,
                                         cwcBufSize );
                    int left = rc.left;
                    rc.left += _cpDateWidth;
                    int tmin = __min( _cpTimeWidth, (int) width - _cpDateWidth );
                    if ( 0 != cwc )
                        _drawText( hdc, rc, tmin, awcBuf, cwc - 1, _fMucked );
                    rc.left = left;
                }

                break;
            }

            case VT_R8:
            {
                swprintf( awcTmp, L"%lf", v.dblVal );
                int cwc = GetNumberFormat( lcid, 0, awcTmp,
                                           & App.NumberFormatFloat(),
                                           awcBuf,
                                           cwcBufSize );
                cwc--;
                _drawText( hdc, rc, width, awcBuf, cwc, _fMucked );
                break;
            }

            case VT_DECIMAL:
            {
                double dbl;
                VarR8FromDec( &v.decVal, &dbl );
                swprintf( awcBuf, L"%lf", dbl );
                _drawText( hdc, rc, width, awcBuf, -1, TRUE );
                break;
            }

            case VT_CY:
            {
                double dbl;
                VarR8FromCy( v.cyVal, &dbl );
                swprintf( awcTmp, L"$%lf", dbl );
                _drawText( hdc, rc, width, awcTmp, -1, _fMucked );
                break;
            }

            case VT_BOOL:
            {
                _drawText( hdc, rc, width,
                           v.boolVal ? App.GetTrue() : App.GetFalse(), -1, _fMucked );
                break;
            }

            case VT_CLSID:
            {
                GUID * puuid = v.puuid;
                if ( 0 != puuid )
                    swprintf( awcTmp,
                              L"{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
                              puuid->Data1,
                              puuid->Data2,
                              puuid->Data3,
                              puuid->Data4[0], puuid->Data4[1],
                              puuid->Data4[2], puuid->Data4[3],
                              puuid->Data4[4], puuid->Data4[5],
                              puuid->Data4[6], puuid->Data4[7] );
                else
                    awcTmp[0] = 0;

                _drawText( hdc, rc, width, awcTmp, -1, _fMucked );
                break;
            }

            case VT_BLOB:
            {
                swprintf( awcTmp,
                          App.GetBlob(),
                          v.blob.cbSize,
                          v.blob.pBlobData );

                _drawText( hdc, rc, width, awcTmp, -1, TRUE );
                break;
            }

            case VT_CF:
            {
                if ( 0 != v.pclipdata )
                    swprintf( awcTmp, L"vt_cf cb 0x%x, fmt 0x%x",
                              v.pclipdata->cbSize,
                              v.pclipdata->ulClipFmt );
                else
                    swprintf( awcTmp, L"vt_cf (null)" );

                _drawText( hdc, rc, width, awcTmp, -1, TRUE );
                break;
            }

            case VT_VECTOR | VT_UI1:
                pwszfmtV = wszfmtVU;
            case VT_VECTOR | VT_I1:
            {
                _drawVectorItems( v.caub.pElems,
                                  v.caub.cElems,
                                  pwszfmtV,
                                  hdc,
                                  rc,
                                  width );
                break;
            }

            case VT_VECTOR | VT_BOOL:
            case VT_VECTOR | VT_UI2:
                pwszfmtV = wszfmtVU;
            case VT_VECTOR | VT_I2:
            {
                _drawVectorItems( v.cai.pElems,
                                  v.cai.cElems,
                                  pwszfmtV,
                                  hdc,
                                  rc,
                                  width );
                break;
            }

            case VT_VECTOR | VT_UI4:
                pwszfmtV = wszfmtVU;
            case VT_VECTOR | VT_I4:
            {
                _drawVectorItems( v.cal.pElems,
                                  v.cal.cElems,
                                  pwszfmtV,
                                  hdc,
                                  rc,
                                  width );
                break;
            }

            case VT_VECTOR | VT_LPSTR:
            case VT_VECTOR | VT_LPWSTR:
            case VT_VECTOR | VT_BSTR:
            {
                _drawVectorItems( v.calpwstr.pElems,
                                  v.calpwstr.cElems,
                                  ( ( VT_VECTOR | VT_LPSTR ) == v.vt ) ?
                                      L"%wc%S" : L"%wc%s",
                                  hdc,
                                  rc,
                                  width );
                break;
            }

            case VT_VECTOR | VT_R4:
            {
                _drawVectorItems( v.caflt.pElems,
                                  v.caflt.cElems,
                                  L"%wc%f",
                                  hdc,
                                  rc,
                                  width );
                break;
            }

            case VT_VECTOR | VT_R8:
            {
                _drawVectorItems( v.cadbl.pElems,
                                  v.cadbl.cElems,
                                  L"%wc%lf",
                                  hdc,
                                  rc,
                                  width );
                break;
            }

            case VT_VECTOR | VT_I8:
            case VT_VECTOR | VT_UI8:
            {
                _drawVectorItems( v.cah.pElems,
                                  v.cah.cElems,
                                  ( v.vt == ( VT_VECTOR | VT_I8 ) ) ?
                                      L"%wc%I64d" : L"%wc%I64u",
                                  hdc,
                                  rc,
                                  width );
                break;
            }

            //case VT_VECTOR | VT_DATE:
            //case VT_VECTOR | VT_FILETIME:
            //case VT_VECTOR | VT_CF:
            //case VT_VECTOR | VT_CY:
            //case VT_VECTOR | VT_VARIANT:

            case VT_NULL :
            case VT_EMPTY :
            {
                //_drawText( hdc, rc, width, L"-", -1, TRUE );
                break;
            }

            default :
            {
                if ( VT_ARRAY & v.vt )
                {
                    RenderSafeArray( awcBuf,
                                     sizeof awcBuf / sizeof WCHAR,
                                     v.vt - VT_ARRAY,
                                     v.parray );
                    _drawText( hdc, rc, width, awcBuf, -1, TRUE );
                    break;
                }

                swprintf( awcTmp, L"(vt 0x%x)", (int) v.vt );
                _drawText( hdc, rc, width, awcTmp, -1, TRUE );
                break;
            }
        }

        rc.left += ( width + _cpAvgWidth );
    }
} //PaintItem

void CSearchView::Size(
    int cx,
    int cy )
{
    HDWP hDefer = BeginDeferWindowPos( 4 );

    if ( 0 == hDefer )
        return;

    int iFontDY = _cpFontHeight;
    int dyQuery = _iLineHeightList + _cpFontHeight / 2;
    int iListHeight = cy - ( 2 * cpPaneSpacing ) - dyQuery;

    int iX = cpPaneMargin;
    int iDX = cx - cpPaneMargin * 2;
    int iY = cpPaneSpacing;
    int iDY = iFontDY;
    int iTitleDX = iFontDY * 3;

    if (!_fHavePlacedTitles)
        hDefer = DeferWindowPos( hDefer,
                                 _hwndQueryTitle,
                                 0,
                                 iX, iY + iFontDY / 4,
                                 iTitleDX, iDY,
                                 SWP_NOZORDER );

    hDefer = DeferWindowPos( hDefer,
                             _hwndQuery,
                             0,
                             iX + iTitleDX, iY,
                             iDX - iTitleDX, dyQuery,
                             SWP_NOZORDER ); 

    if (iListHeight > 0)
    {
        HD_LAYOUT hdl;
        RECT rc = { 0, 0, cx, cy };
        hdl.prc = &rc;
        WINDOWPOS wp;
        hdl.pwpos = &wp;
        Header_Layout( _hwndHeader, &hdl );

        iY += ( dyQuery + cpPaneSpacing );

        hDefer = DeferWindowPos( hDefer,
                                 _hwndHeader,
                                 0,
                                 iX, iY,
                                 iDX, wp.cy,
                                 SWP_NOZORDER );

        int iListY = iY + wp.cy;

        iListY--; // too many black lines...

        iListHeight = cy - iListY - cpPaneBottomSpacing;

        // fit integral number of lines in listview

        int cyBorder2x = 2 * GetSystemMetrics( SM_CYBORDER );
        _cLines = ( iListHeight - cyBorder2x ) / GetLineHeight();

        hDefer = DeferWindowPos( hDefer,
                                 _hwndList,
                                 0,
                                 iX, iListY,
                                 iDX, _cLines * GetLineHeight() + cyBorder2x,
                                 SWP_NOZORDER );
    }

    EndDeferWindowPos( hDefer );

    _fHavePlacedTitles = TRUE;
} //Size

void CSearchView::FontChanged(
    HFONT hfontNew )
{
    HDC hdc = GetDC (_hwndList);

    if (hdc)
    {
        HFONT hfOld = (HFONT) SelectObject( hdc, hfontNew );
        TEXTMETRIC tm;
        GetTextMetrics (hdc, &tm);
        _iLineHeightList = (tm.tmHeight + 2 * tm.tmExternalLeading);
        SelectObject( hdc, hfOld );

        RECT rc;
        GetWindowRect(_hwndList,(LPRECT) &rc);
        _cLines = (rc.bottom - rc.top) / GetLineHeight();

        ReleaseDC( _hwndList, hdc );
    }
} //FontChanged

void CSearchView::ResizeQueryCB()
{
    RECT rect;

    ShowWindow( _hwndQuery, SW_HIDE );

    if ( GetClientRect( _hwndQuery, &rect ) )
    {
        SetWindowPos( _hwndQuery,
                      0,
                      0,
                      0,
                      rect.right,
                      5 * ( _cpFontHeight * 3 ) / 2,
                      SWP_NOZORDER | SWP_NOMOVE | SWP_NOREDRAW | SWP_DEFERERASE | 
                      SWP_NOACTIVATE );
    }
    ShowWindow( _hwndQuery, SW_SHOWNOACTIVATE );
}

inline int CSearchView::_MeasureString(
    HDC     hdc,
    WCHAR * pwcMeasure,
    RECT &  rc,
    int     cwc)
{
    RECT rcMeasure;
    CopyRect( &rcMeasure, &rc );

    DrawText( hdc, pwcMeasure, cwc, &rcMeasure,
              DT_CALCRECT | DT_SINGLELINE | DT_BOTTOM | DT_LEFT );
    return rcMeasure.right - rcMeasure.left;
} //_MeasureString

void CSearchView::_ComputeFieldWidths()
{
    HDC hdc = GetDC( _hwndList );

    if ( 0 == hdc )
        return;

    HFONT hfOld = (HFONT) SelectObject( hdc, (HGDIOBJ) App.AppFont() );

    TEXTMETRIC tm;
    GetTextMetrics( hdc, &tm );
    _cpAvgWidth = tm.tmAveCharWidth;

    RECT rc = { 0, 0, 2000, 2000 };

    SYSTEMTIME st;
    RtlZeroMemory( &st, sizeof st );
    st.wMonth = 12;
    st.wDay = 28;
    st.wDayOfWeek = 3;
    st.wYear = 1994;

    LCID lcid = App.GetLocale();
    WCHAR awc[ cwcBufSize ];
    int cwc = GetDateFormat( lcid, DATE_SHORTDATE, &st, 0, awc, cwcBufSize );
    _cpDateWidth = _MeasureString( hdc, awc, rc, cwc - 1 );

    st.wHour = 22;
    st.wMinute = 59;
    st.wSecond = 59;
    st.wMilliseconds = 10;

    cwc = GetTimeFormat( lcid, 0, &st, 0, awc, cwcBufSize );
    _cpTimeWidth = _MeasureString( hdc, awc, rc, cwc - 1 );
    _cpTimeWidth += _cpAvgWidth; // room between time and date...

    _cpGuidWidth = _MeasureString( hdc, L"{8dee0300-16c2-101b-b121-08002b2ecda9}", rc);

    _cpBoolWidth = _MeasureString( hdc, App.GetFalse(), rc);

    // guess that only half of the attributes will be on at once

    _cpAttribWidth = 4 + _MeasureString( hdc, App.GetAttrib(), rc ) / 2;

    _cpFileIndexWidth = _MeasureString( hdc, L"0x88888888,88888888", rc );

    SelectObject( hdc, hfOld );
    ReleaseDC( _hwndList, hdc );
} //_ComputeFieldWidths
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\srch\watch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       watch.cxx
//
//  Contents:   
//
//  History:    15 Aug 1996     DLee    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

//#define USE_WATCH_REGIONS  // last tried 10/7/96

//
// CWatchQuery
//

CWatchQuery::CWatchQuery (CSearchQuery* pClient, IRowsetScroll* pRowset)
: _pClient (pClient),
  _pContainer (0),
  _pNotifyWatch (0),
  _pPoint (0),
  _pRowsetWatch (0),
  _hRegion (0),
  _fEverGotARowsChanged(FALSE),
  _wnLast( 0 )
{
    if (!pRowset)
        THROW (CException(E_FAIL));

    _pNotifyWatch = new CRowsetNotifyWatch( pClient->_hwndNotify );

    SCODE sc = pRowset->QueryInterface( IID_IConnectionPointContainer,
                                        (void **) &_pContainer );
    if (SUCCEEDED(sc))
    {
        sc = _pContainer->FindConnectionPoint( IID_IRowsetWatchNotify,
                                               &_pPoint );
        if (SUCCEEDED(sc))
        {
            sc = _pPoint->Advise( (IUnknown *) _pNotifyWatch,
                                  &_dwAdviseID );
            if (SUCCEEDED(sc))
            {
                sc = pRowset->QueryInterface( IID_IRowsetWatchRegion,
                                              (void**) &_pRowsetWatch );
            }
        }
    }
#ifdef USE_WATCH_REGIONS
    if (_pRowsetWatch)
    {
        sc = _pRowsetWatch->CreateWatchRegion (DBWATCHMODE_MOVE, &_hRegion);
    }
#endif
    _mode = DBWATCHMODE_MOVE;
} //CWatchNotify

CWatchQuery::~CWatchQuery ()
{
    srchDebugOut(( DEB_ITRACE,
                   "~CWatchQuery, ever got a rc: %d, _wnLast: %d\n",
                   _fEverGotARowsChanged, _wnLast ));
    if (_pPoint)
    {
        _pPoint->Unadvise(_dwAdviseID);
        _pPoint->Release();
    }

    if (_pContainer)
        _pContainer->Release();
    if (_pRowsetWatch)
        _pRowsetWatch->Release();

    if (_pNotifyWatch)
        _pNotifyWatch->Release();
} //~CWatchQuery

void CWatchQuery::Notify (HWND hwndList, DBWATCHNOTIFY changeType)
{
    // don't post more notifications while we're busy

    _pNotifyWatch->HoldNotifications( TRUE );

    _wnLast = changeType;

    switch (changeType)
    {
        case DBWATCHNOTIFY_QUERYDONE:
            _pClient->Quiesce(TRUE);
             srchDebugOut(( DEB_ITRACE, "CWatchQuery::Notify - Query DONE\n"));
            break;
        case DBWATCHNOTIFY_QUERYREEXECUTED:
            _pClient->Quiesce(FALSE);
            break;
        case DBWATCHNOTIFY_ROWSCHANGED:
            RowsChanged (hwndList);
            break;
        default :
            Win4Assert( !"unexpected notification!" );
            break;
    }
} //Notify

void CWatchQuery::NotifyComplete()
{
    _pNotifyWatch->HoldNotifications( FALSE );
} //NotifyComplete

void CWatchQuery::RowsChanged (HWND hwnd)
{
    DBCOUNTITEM cChanges = 0;
    DBROWWATCHCHANGE* aChange = 0;

    _fEverGotARowsChanged = TRUE;
    SCODE sc = _pRowsetWatch->Refresh( &cChanges, &aChange );

    Win4Assert ((sc == STATUS_UNEXPECTED_NETWORK_ERROR ||
                 sc == DB_S_TOOMANYCHANGES || sc == E_FAIL) 
                && cChanges == 0);

    if ( sc == STATUS_UNEXPECTED_NETWORK_ERROR )
        sc = DB_S_TOOMANYCHANGES;

    if (sc == DB_S_TOOMANYCHANGES)
    {
        _pClient->CreateScript (&cChanges, &aChange);
    }

    srchDebugOut(( DEB_ITRACE, "CWatchQuery::RowsChanged Changes = %d\n", cChanges));

    if (cChanges != 0)
    {
        ExecuteScript (hwnd, (ULONG) cChanges, aChange);
        CoTaskMemFree (aChange);
    }
} //RowsChanged

void CWatchQuery::ExecuteScript (HWND hwndList, ULONG cChanges, DBROWWATCHCHANGE* aScript)
{
    for (ULONG i = 0; i < cChanges; i++)
    {
        switch (aScript[i].eChangeKind)
        {
            case DBROWCHANGEKIND_INSERT:
                _pClient->InsertRowAfter((int) aScript[i].iRow, aScript[i].hRow);
                SendMessage (hwndList, wmInsertItem, 0, aScript[i].iRow );
                srchDebugOut(( DEB_ITRACE, "CWatchQuery::ExecuteScript - Row INS: %d\n", aScript[i].iRow));
                break;
            case DBROWCHANGEKIND_DELETE:
                _pClient->DeleteRow ((int) aScript[i].iRow);
                SendMessage (hwndList, wmDeleteItem, 0, aScript[i].iRow );
                srchDebugOut(( DEB_ITRACE, "CWatchQuery::ExecuteScript - Row DEL: %d\n", aScript[i].iRow));
                break;
            case DBROWCHANGEKIND_UPDATE:
                _pClient->UpdateRow ((int) aScript[i].iRow, aScript[i].hRow);
                SendMessage (hwndList, wmUpdateItem, 0, aScript[i].iRow );
                srchDebugOut(( DEB_ITRACE, "CWatchQuery::ExecuteScript - Row UPD\n"));
                break;
            case DBROWCHANGEKIND_COUNT:
                _pClient->UpdateCount ((int) aScript[i].iRow);
                srchDebugOut(( DEB_ITRACE, "CWatchQuery::ExecuteScript - Row CNT\n"));
            default:
                Win4Assert (!"unknown change kind");
        }
    }
} //ExecuteScript

void CWatchQuery::Extend (HWATCHREGION hRegion)
{
#ifdef USE_WATCH_REGIONS
    if ((_mode & DBWATCHMODE_EXTEND) == 0)
    {
        _mode |= DBWATCHMODE_EXTEND;
        _mode &= ~DBWATCHMODE_MOVE;
        _pRowsetWatch->ChangeWatchMode ( hRegion, _mode);
    }
#endif
}

void CWatchQuery::Move (HWATCHREGION hRegion)
{
#ifdef USE_WATCH_REGIONS
    if ((_mode & DBWATCHMODE_MOVE) == 0)
    {
        _mode |= DBWATCHMODE_MOVE;
        _mode &= ~DBWATCHMODE_EXTEND;
        _pRowsetWatch->ChangeWatchMode ( hRegion, _mode);
    }
#endif
}

void CWatchQuery::Shrink (HWATCHREGION hRegion, CBookMark& bmk, ULONG cRows)
{
#ifdef USE_WATCH_REGIONS
    _pRowsetWatch->ShrinkWatchRegion (hRegion,
                                      0, // no chapter
                                      bmk.cbBmk, bmk.abBmk,
                                      cRows //_mode
                                      );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\usnmon\usnmon.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 1999.
//
//  File:       usnmon.cxx
//
//  Contents:   USN monitor
//
//  History:    18 Nov 1998     DLee    Created
//
//--------------------------------------------------------------------------

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif 

extern "C"
{
    #include <nt.h>
    #include <ntioapi.h>
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <ntexapi.h>
}

#include <windows.h>
#include <stdio.h>
#include <process.h>

#define MAX_PATH_WCHARS (MAX_PATH * 4 )

BOOL fVerbose = FALSE;

void usage()
{
    printf( "usage: usnmon x: [-verbose]\n" );
    printf( "You must be an administrator to run this application.\n" );
    exit( 1 );
} //usage

void IdToPath(
    HANDLE       hVol,
    LONGLONG     ll,
    WCHAR        wcVol,
    WCHAR *      pwcPath )
{
    *pwcPath = 0;

    UNICODE_STRING uScope;
    uScope.Buffer = (WCHAR *) &ll;
    uScope.Length = sizeof ll;
    uScope.MaximumLength = sizeof ll;

    OBJECT_ATTRIBUTES ObjectAttr;
    InitializeObjectAttributes( &ObjectAttr,          // Structure
                                &uScope,              // Name
                                OBJ_CASE_INSENSITIVE, // Attributes
                                hVol,                 // Root
                                0 );                  // Security

    IO_STATUS_BLOCK IoStatus;
    HANDLE h = INVALID_HANDLE_VALUE;
    NTSTATUS Status = NtOpenFile( &h,                
                                  FILE_READ_ATTRIBUTES,
                                  &ObjectAttr,       
                                  &IoStatus,         
                                  FILE_SHARE_READ |
                                      FILE_SHARE_WRITE |
                                      FILE_SHARE_DELETE,
                                  FILE_OPEN_BY_FILE_ID );
    if ( NT_ERROR( Status ) )
        return;        

    static BYTE abFileNameInformation[ MAX_PATH_WCHARS * sizeof WCHAR +
                                       sizeof FILE_NAME_INFORMATION ];

    ULONG cbMax = sizeof abFileNameInformation;

    PFILE_NAME_INFORMATION FileName = (PFILE_NAME_INFORMATION) abFileNameInformation;
    FileName->FileNameLength = cbMax - sizeof FILE_NAME_INFORMATION;

    Status = NtQueryInformationFile( h,
                                     &IoStatus,
                                     FileName, 
                                     cbMax,
                                     FileNameInformation );
    NtClose( h );
                                            
    if ( NT_ERROR( Status ) )
        return;

    // This is actually the full path, not the filename

    FileName->FileName[ FileName->FileNameLength / sizeof WCHAR ] = 0;

    pwcPath[0] = wcVol;
    pwcPath[1] = ':';
    wcscpy( pwcPath + 2, FileName->FileName );
} //IdToPath

USN PrintUsnRecords(
    HANDLE            hVol,
    WCHAR             wcVol,
    IO_STATUS_BLOCK * pIoSB,
    void *            pBuffer,
    USN               usnPrev )
{
    USN usnNextStart;
    USN_RECORD * pUsnRec;

    ULONG_PTR dwByteCount = pIoSB->Information;
    if ( 0 != dwByteCount )
    {
        usnNextStart = *(USN *)pBuffer;
        pUsnRec = (USN_RECORD *)((PCHAR)pBuffer + sizeof(USN));
        dwByteCount -= sizeof(USN);
    }
    else
    {
        usnNextStart = usnPrev;
    }

    while ( 0 != dwByteCount )
    {
        if ( fVerbose )
            printf( "usn %#I64x id %#I64x ",
                    pUsnRec->Usn,
                    pUsnRec->FileReferenceNumber );

        static WCHAR awcPath[ MAX_PATH_WCHARS + 4 ];

        IdToPath( hVol, pUsnRec->FileReferenceNumber, wcVol, awcPath );

        ULONG r = pUsnRec->Reason;

        if ( 0 == awcPath[0] || ( r & USN_REASON_RENAME_OLD_NAME ) )
        {
            IdToPath( hVol, pUsnRec->ParentFileReferenceNumber, wcVol, awcPath );

            // If the parent directory has already been deleted, just
            // print the filename.

            if ( 0 == awcPath[0] )
                printf( "(%.*ws) ",
                        pUsnRec->FileNameLength / sizeof WCHAR,
                        &pUsnRec->FileName );
            else
                printf( "%ws\\%.*ws ",
                        awcPath,
                        pUsnRec->FileNameLength / sizeof WCHAR,
                        &pUsnRec->FileName );
        }
        else
            printf( "%ws ", awcPath );

        if ( pUsnRec->SourceInfo & USN_SOURCE_AUXILIARY_DATA )
            printf( "USN_SOURCE_AUXILIARY_DATA " );

        if ( pUsnRec->SourceInfo & USN_SOURCE_DATA_MANAGEMENT )
            printf( "USN_SOURCE_DATA_MANAGEMENT " );

        if ( pUsnRec->SourceInfo & USN_SOURCE_REPLICATION_MANAGEMENT )
            printf( "USN_SOURCE_REPLICATION_MANAGEMENT " );

        if ( r & USN_REASON_DATA_OVERWRITE )
            printf( "DATA_OVERWRITE " );
        if ( r & USN_REASON_DATA_EXTEND )
            printf( "DATA_EXTEND " );
        if ( r & USN_REASON_DATA_TRUNCATION )
            printf( "DATA_TRUNCATION " );
        if ( r & USN_REASON_NAMED_DATA_OVERWRITE )
            printf( "NAMED_DATA_OVERWRITE " );
        if ( r & USN_REASON_NAMED_DATA_EXTEND )
            printf( "NAMED_DATA_EXTEND " );
        if ( r & USN_REASON_NAMED_DATA_TRUNCATION )
            printf( "NAMED_DATA_TRUNCATION " );
        if ( r & USN_REASON_FILE_CREATE )
            printf( "FILE_CREATE " );
        if ( r & USN_REASON_FILE_DELETE )
            printf( "FILE_DELETE " );
        if ( r & USN_REASON_EA_CHANGE )
            printf( "EA_CHANGE " );
        if ( r & USN_REASON_SECURITY_CHANGE )
            printf( "SECURITY_CHANGE " );
        if ( r & USN_REASON_RENAME_OLD_NAME )
            printf( "RENAME_OLD_NAME " );
        if ( r & USN_REASON_RENAME_NEW_NAME )
            printf( "RENAME_NEW_NAME " );
        if ( r & USN_REASON_INDEXABLE_CHANGE )
            printf( "INDEXABLE_CHANGE " );
        if ( r & USN_REASON_BASIC_INFO_CHANGE )
            printf( "BASIC_INFO_CHANGE " );
        if ( r & USN_REASON_HARD_LINK_CHANGE )
            printf( "HARD_LINK_CHANGE " );
        if ( r & USN_REASON_COMPRESSION_CHANGE )
            printf( "COMPRESSION_CHANGE " );
        if ( r & USN_REASON_ENCRYPTION_CHANGE )
            printf( "ENCRYPTION_CHANGE " );
        if ( r & USN_REASON_OBJECT_ID_CHANGE )
            printf( "OBJECT_ID_CHANGE " );
        if ( r & USN_REASON_REPARSE_POINT_CHANGE )
            printf( "REPARSE_POINT_CHANGE " );
        if ( r & USN_REASON_STREAM_CHANGE )
            printf( "STREAM_CHANGE " );
        if ( r & USN_REASON_CLOSE )
            printf( "CLOSE " );

        printf( "\n" );

        if ( pUsnRec->RecordLength <= dwByteCount )
        {
            dwByteCount -= pUsnRec->RecordLength;
            pUsnRec = (USN_RECORD *) ((PCHAR) pUsnRec + pUsnRec->RecordLength );
        }
        else
        {
            printf( "Usn read fsctl returned bogus dwByteCount %#x\n", dwByteCount );
            exit( -1 );
        }
    } 

    return usnNextStart;
} //PrintUsnRecords

int __cdecl main(
    int    argc,
    char * argv[] )
{
    if ( 2 != argc && 3 != argc )
        usage();

    if ( 3 == argc && argv[2][1] == 'v' )
        fVerbose = TRUE;

    WCHAR wcVol = argv[1][0];

    WCHAR wszVolumePath[] = L"\\\\.\\a:";
    wszVolumePath[4] = wcVol;
    HANDLE hVolume = CreateFile( wszVolumePath,
                                 GENERIC_READ | GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_FLAG_OVERLAPPED,
                                 NULL );

    if ( INVALID_HANDLE_VALUE == hVolume )
    {
        printf( "Usn volume open failed %d, check for admin privileges\n", GetLastError() );
        usage();
    }

    HANDLE hEvent = CreateEvent( 0, TRUE, FALSE, 0 );

    //
    // Get the Journal ID
    //

    USN_JOURNAL_DATA UsnJournalInfo;
    IO_STATUS_BLOCK IoSB;

    NTSTATUS status = NtFsControlFile( hVolume,
                                       hEvent,
                                       0,
                                       0,
                                       &IoSB,
                                       FSCTL_QUERY_USN_JOURNAL,
                                       0,
                                       0,
                                       &UsnJournalInfo,
                                       sizeof UsnJournalInfo );
    if ( STATUS_PENDING == status )
        WaitForSingleObject( hEvent, INFINITE );

    if ( !NT_SUCCESS(status) || !NT_SUCCESS(IoSB.Status) )
    {
        printf( "Error %#x / %#x returned from QUERY_USN_JOURNAL\n", status, IoSB.Status );
        return -1;
    }

    USN usnMax = UsnJournalInfo.NextUsn;

    do
    {
        READ_USN_JOURNAL_DATA usnData = { usnMax, MAXULONG, 0, 0, 1, UsnJournalInfo.UsnJournalID };

        static ULONGLONG readBuffer[2048];

        status = NtFsControlFile( hVolume,
                                  hEvent,
                                  0,
                                  0,
                                  &IoSB,
                                  FSCTL_READ_USN_JOURNAL,
                                  &usnData,
                                  sizeof usnData,
                                  &readBuffer,
                                  sizeof readBuffer );

        if ( STATUS_PENDING == status )
            WaitForSingleObject( hEvent, INFINITE );

        if ( NT_SUCCESS( status ) )
            status = IoSB.Status;

        if ( !NT_SUCCESS( status ) )
        {
            printf( "FSCTL_READ_USN_JOURNAL failed %#x\n", status );
            return -1;
        }

        usnMax = PrintUsnRecords( hVolume, wcVol, &IoSB, readBuffer, usnMax );
    } while ( TRUE );

    return 0;
} //main
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\usndump\usndump.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1997-1998
//
//  File:       usndump.cxx
//
//  Contents:   Usn dump utility. Needs admin privileges to run.
//
//  History:    05-Jul-97       SitaramR          Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

void Usage()
{
    printf( "usage: usndump  <drive_letter>, e.g. usndump c\n" );
    printf( "       requires administrative privileges to run\n" );
}

DECLARE_INFOLEVEL(ci)

//+---------------------------------------------------------------------------
//
//  Function:   PrintUsnRecords
//
//  Purpose:    Prints usn records from buffer
//
//  History:    05-Jul-97   SitaramR    Created
//              21-May-98   KLam        Added SourceInfo as output
//
//----------------------------------------------------------------------------

void PrintUsnRecords( IO_STATUS_BLOCK *iosb, void *pBuffer )
{
    USN usnNextStart;
    USN_RECORD * pUsnRec;

    ULONG_PTR dwByteCount = iosb->Information;
    if ( dwByteCount != 0 )
    {
        usnNextStart = *(USN *)pBuffer;
        pUsnRec = (USN_RECORD *)((PCHAR)pBuffer + sizeof(USN));
        dwByteCount -= sizeof(USN);
    }

    while ( dwByteCount != 0 )
    {
        if ( pUsnRec->MajorVersion != 2 || pUsnRec->MinorVersion != 0 )
        {
            printf( "Unrecognized USN version, Major=%u, Minor=%u\n",
                    pUsnRec->MajorVersion, pUsnRec->MinorVersion );
            break;
        }

        if ( 0 != pUsnRec->SourceInfo )
            printf( "FileId=%#I64x, ParentFileId=%#I64x, Usn=%#I64x, Reason=%#x, SourceInfo=%#x, FileAttr=%#x, FileName=%.*ws\n",
                    pUsnRec->FileReferenceNumber,
                    pUsnRec->ParentFileReferenceNumber,
                    pUsnRec->Usn,
                    pUsnRec->Reason,
                    pUsnRec->SourceInfo,
                    pUsnRec->FileAttributes,
                    pUsnRec->FileNameLength / sizeof WCHAR ,
                    &pUsnRec->FileName );
        else
            printf( "FileId=%#I64x, ParentFileId=%#I64x, Usn=%#I64x, Reason=%#x, FileAttr=%#x, FileName=%.*ws\n",
                    pUsnRec->FileReferenceNumber,
                    pUsnRec->ParentFileReferenceNumber,
                    pUsnRec->Usn,
                    pUsnRec->Reason,
                    pUsnRec->FileAttributes,
                    pUsnRec->FileNameLength / sizeof WCHAR,
                    &pUsnRec->FileName );

        if ( pUsnRec->RecordLength <= dwByteCount )
        {
            dwByteCount -= pUsnRec->RecordLength;
            pUsnRec = (USN_RECORD *) ((PCHAR) pUsnRec + pUsnRec->RecordLength );
        }
        else
        {
            printf( "***--- Usn read fsctl returned bogus dwByteCount 0x%x ---***\n", dwByteCount );

            THROW( CException( STATUS_UNSUCCESSFUL ) );
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Purpose:    Main dump routine
//
//  History:    05-Jul-97   SitaramR    Created
//
//----------------------------------------------------------------------------

int __cdecl main( int argc, char * argv[] )
{
    if ( argc != 2 )
    {
        Usage();
        return 0;
    }

    WCHAR wcDriveLetter = argv[1][0];

    TRY
    {
        //
        // Looking at a file?
        //

        if ( strlen(argv[1]) > 2 )
        {
            int ccUnicodeStr = strlen( argv[1] ) + 1;
            WCHAR * pUnicodeStr = new WCHAR[ccUnicodeStr];
            if ( !MultiByteToWideChar( CP_ACP, 0, argv[1], -1, pUnicodeStr, ccUnicodeStr ) )
            {
                printf("MultiByteToWideChar failed.\n");
                delete [] pUnicodeStr;
                return 0;
            }
            CFunnyPath funnyPath( pUnicodeStr );
            delete [] pUnicodeStr;

            HANDLE hFile = CreateFile( funnyPath.GetPath(),
                                       GENERIC_READ,
                                       FILE_SHARE_READ,
                                       NULL,
                                       OPEN_EXISTING,
                                       FILE_FLAG_BACKUP_SEMANTICS,
                                       NULL );

            if ( INVALID_HANDLE_VALUE == hFile && ERROR_ACCESS_DENIED == GetLastError() )
                hFile = CreateFile( funnyPath.GetPath(),
                                    GENERIC_READ,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    0,
                                    NULL );

            if ( hFile == INVALID_HANDLE_VALUE )
            {
                printf( "***--- Usn file open failed 0x%x, check for admin privileges ---***\n", GetLastError() );

                THROW( CException( HRESULT_FROM_WIN32( GetLastError() ) ) );
            }

            NTSTATUS status;

            SHandle xFile( hFile );

            IO_STATUS_BLOCK iosb;
            ULONGLONG readBuffer[100];

            for ( unsigned i = 0; i < sizeof(readBuffer)/sizeof(readBuffer[0]); i++ )
                readBuffer[i] = 0xFFFFFFFFFFFFFFFFi64;

            USN_RECORD *pUsnRec;
            status = NtFsControlFile( hFile,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &iosb,
                                      FSCTL_READ_FILE_USN_DATA,
                                      NULL,
                                      NULL,
                                      &readBuffer,
                                      sizeof(readBuffer) );

            if ( !NT_SUCCESS(status) || !NT_SUCCESS(iosb.Status) )
            {
                printf( "***--- Error 0x%x / 0x%x returned from READ_FILE_USN_DATA ---***\n", status, iosb.Status );
                return 0;
            }

            pUsnRec = (USN_RECORD *) &readBuffer;

            if ( pUsnRec->MajorVersion != 2 || pUsnRec->MinorVersion != 0 )
                printf( "Unrecognized USN version, Major=%u, Minor=%u\n",
                        pUsnRec->MajorVersion, pUsnRec->MinorVersion );
            else
                printf( "FileId=%#I64x, ParentFileId=%#I64x, Usn=%#I64x, FileAttr=%#x, FileName=%.*ws\n",
                        pUsnRec->FileReferenceNumber,
                        pUsnRec->ParentFileReferenceNumber,
                        pUsnRec->Usn,
                        pUsnRec->FileAttributes,
                        pUsnRec->FileNameLength / sizeof(WCHAR),
                        &pUsnRec->FileName );
        }
        else
        {
            //
            // Create the volume handle that will be used for usn fsctls
            //

            WCHAR wszVolumePath[] = L"\\\\.\\a:";
            wszVolumePath[4] = wcDriveLetter;
            HANDLE hVolume = CreateFile( wszVolumePath,
                                         GENERIC_READ | GENERIC_WRITE,
                                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                                         NULL,
                                         OPEN_EXISTING,
                                         0,
                                         NULL );

            if ( hVolume == INVALID_HANDLE_VALUE )
            {
                printf( "***--- Usn volume open failed 0x%x, check for admin privileges ---***\n", GetLastError() );

                THROW( CException( HRESULT_FROM_WIN32( GetLastError() ) ) );
            }

            SWin32Handle xHandleVolume( hVolume );

            IO_STATUS_BLOCK iosb;

            //
            // Get the Journal ID
            //


            USN_JOURNAL_DATA UsnJournalInfo;

            NTSTATUS status = NtFsControlFile( hVolume,
                                               NULL,
                                               NULL,
                                               NULL,
                                               &iosb,
                                               FSCTL_QUERY_USN_JOURNAL,
                                               0,
                                               0,
                                               &UsnJournalInfo,
                                               sizeof(UsnJournalInfo) );
            if ( status == STATUS_PENDING )
            {
                printf( "***--- Status_pending returned for synchronous read fsctl ---***\n" );
                return 0;
            }

            if ( !NT_SUCCESS(status) || !NT_SUCCESS(iosb.Status) )
            {
                printf( "***--- Error 0x%x / 0x%x returned from QUERY_USN_JOURNAL ---***\n", status, iosb.Status );
                return 0;
            }

            READ_USN_JOURNAL_DATA usnData = {0, MAXULONG, 0, 0, 0, UsnJournalInfo.UsnJournalID};
            ULONGLONG readBuffer[2048];

            status = NtFsControlFile( hVolume,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &iosb,
                                      FSCTL_READ_USN_JOURNAL,
                                      &usnData,
                                      sizeof(usnData),
                                      &readBuffer,
                                      sizeof(readBuffer) );

            if ( status == STATUS_PENDING )
            {
                printf( "***--- Status_pending returned for synchronous read fsctl ---***\n" );
                return 0;
            }

            if ( NT_SUCCESS( status ) )
            {
                status = iosb.Status;

                if ( STATUS_KEY_DELETED == status ||
                     STATUS_JOURNAL_ENTRY_DELETED == status )
                {
                    printf( "***--- Status key deleted, rerun ---***\n" );
                    return 0;
                }

                PrintUsnRecords( &iosb, readBuffer );

                //
                // Read usn records until the end of usn journal
                //

                USN usnStart = 0;
                while ( NT_SUCCESS( status ) )
                {
                    ULONG_PTR dwByteCount = iosb.Information;

                    if ( dwByteCount <= sizeof(USN) )
                        return 0;
                    else
                    {
                        usnStart = *(USN *)&readBuffer;
                        usnData.StartUsn = usnStart;
                        status = NtFsControlFile( hVolume,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  &iosb,
                                                  FSCTL_READ_USN_JOURNAL,
                                                  &usnData,
                                                  sizeof(usnData),
                                                  &readBuffer,
                                                  sizeof(readBuffer) );

                        if ( NT_SUCCESS( status ) )
                            status = iosb.Status;
                        else
                        {
                            printf( "***--- Error 0x%x returned from read fsctl ---***\n", status );
                            return 0;
                        }

                        if ( STATUS_KEY_DELETED == status ||
                             STATUS_JOURNAL_ENTRY_DELETED == status )
                        {
                            printf( "***--- Status key deleted, rerun usndump ---***\n" );
                            return 0;
                        }

                        PrintUsnRecords( &iosb, readBuffer );
                    }
                }

                return 0;
            }
            else
                printf( "***--- Usn read fsctl returned 0x%x, check if usn journal has created on that volume ---***\n",
                        status );
        }

        return 0;
    }
    CATCH( CException, e )
    {
       printf( "***--- Caught exception 0x%x ---***\n", e.GetErrorCode() );
    }
    END_CATCH

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\webhits\cdoc.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       cdoc.cxx
//
//  Contents:   a radically stripped down version of the document class
//              that gets rid of the notion of paragragph and maintains only
//              information relative to the stream
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <cidebug.hxx>
#include <dynstack.hxx>
#include <cimbmgr.hxx>
#include <propspec.hxx>
#include <vquery.hxx>
#include <pageman.hxx>
#include <dblink.hxx>
#include <imprsnat.hxx>
#include <queryexp.hxx>

#include "whmsg.h"
#include "webdbg.hxx"
#include "cdoc.hxx"

//+-------------------------------------------------------------------------
//
//  Function:   ComparePositions
//
//  Arguments:  const void* pPos1 - pointer to first position
//              const void* pPos2 - pointer to second position
//
//  Synopsis:   Comparison function used by qsort to sort positions array
//
//--------------------------------------------------------------------------


int _cdecl ComparePositions(
    const void* pPos1,
    const void* pPos2 )
{
    Position* pp1= (Position*) pPos1;
    Position* pp2= (Position*) pPos2;

    Win4Assert(0 != pp1 && 0 !=pp2);

    if (pp1->GetBegOffset() == pp2->GetBegOffset())
        return 0;
    else if (pp1->GetBegOffset() < pp2->GetBegOffset())
        return -1;
    else
        return 1;
}

void Hit::Sort()
{
    qsort( _aPos, _cPos, sizeof(Position), &ComparePositions );
}


//+-------------------------------------------------------------------------
//
//  Member:     Hit::Hit, public
//
//  Arguments:  [aPos]      - array of positions
//              [cPos]      - number of Positions in [aPos]
//
//  Synopsis:   Create hit from an array of positions
//
//--------------------------------------------------------------------------

Hit::Hit( const Position * aPos, unsigned cPos )
: _cPos(cPos)
{
    _aPos = new Position[cPos];

    memcpy( _aPos, aPos, sizeof(Position) * cPos );
}

Hit::~Hit()
{
    delete[] _aPos;
}

//+-------------------------------------------------------------------------
//
//  Member:     HitIter::GetPositionCount, public
//
//  Synopsis:   return number of positions or zero
//
//--------------------------------------------------------------------------

int HitIter::GetPositionCount() const
{
    if (_iHit < _pDoc->_cHit && _pDoc->_aHit[_iHit])
        return _pDoc->_aHit[_iHit]->GetPositionCount();

    return 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     HitIter::GetPosition, public
//
//  Synopsis:   return position by value
//
//--------------------------------------------------------------------------

Position HitIter::GetPosition ( int i ) const
{
     if ( _iHit < _pDoc->_cHit && _pDoc->_aHit[_iHit] )
          return _pDoc->_aHit[_iHit]->GetPos(i);
     else
     {
          Position pos;
          return( pos );
     }
}

//+-------------------------------------------------------------------------
//
//  Member:     CDocument::CDocument, public constructor
//
//  Arguments:  [filename]       - the name of the file to hit highlight
//              [rank]           - the rank of document in the hierarchy - NOT USED
//              [rSearch]        - ISearch object
//              [cmsReadTimeout] - timeout for the initial file read
//              [lockSingleThreadedFilter] - lock used for all single
//                                           threaded filters
//              [propertyList]   - properties to be emitted
//              [ulDisplayScript] - setting for displaying scripts
//
//  Synopsis:   Stream the file in chunk by chunk, scan it for hits,
//              and record those positions in the stream matching the restricition.
//
//--------------------------------------------------------------------------

CDocument::CDocument(
    WCHAR *           filename,
    ULONG             rank,
    ISearchQueryHits &         rSearch,
    DWORD             cmsReadTimeout,
    CReleasableLock & lockSingleThreadedFilter,
    CEmptyPropertyList &   propertyList,
    ULONG             ulDisplayScript )
: _filename( filename ),
  _rank( rank ),
  _bufEnd( 0 ),
  _iChunkHint( 0 ),
  _cHit( 0 ),
  _rSearch( rSearch ),
  _cmsReadTimeout( cmsReadTimeout ),
  _lockSingleThreadedFilter( lockSingleThreadedFilter )
{
    BOOL noHits = FALSE;

    //
    // cut away anything after the non-drive colon
    // like in c:\wzmail\foo.fld:12.wzm
    //

    WCHAR* pChar =  _filename;
    if ( _filename[1] == L':')
        pChar += 2;
    while (*pChar != 0 && *pChar != L':')
        pChar++;
    if(*pChar == L':')
        *pChar = 0;

    //
    // allocate a buffer to hold the file
    //

    AllocBuffer();

    //
    // attach to IFilter
    //

    BOOL fKnownFilter = BindToFilter();

    // Check if this file's extension has a script mapping (if necessary)

    BOOL fHasScriptMap = FALSE;

    if ( ( DISPLAY_SCRIPT_NONE == ulDisplayScript ) ||
         ( ( DISPLAY_SCRIPT_KNOWN_FILTER == ulDisplayScript ) &&
           ( !fKnownFilter ) ) )
    {
        WCHAR *pwcExt = wcsrchr( _filename, L'.' );
        webDebugOut(( DEB_ITRACE, "extension: '%ws'\n", pwcExt ));

        if ( 0 != pwcExt )
        {
            //
            // .asp files include .inc files.  .inc files don't have a script
            // map but they contain script.  I'm not aware of a good way to
            // enumerate all possible include file extensions for asp.
            //

            if ( !_wcsicmp( pwcExt, L".inc" ) )
                fHasScriptMap = TRUE;
            else
            {
                //
                // Must be system to read the metabase
                //
    
                CImpersonateSystem system;
                CMetaDataMgr mdMgr( TRUE, W3VRoot );
                fHasScriptMap = mdMgr.ExtensionHasScriptMap( pwcExt );
            }
        }
    }

    webDebugOut(( DEB_ITRACE,
                  "fHasScriptMap %d, fKnownFilter %d, ulDisplayScript %d\n",
                  fHasScriptMap, fKnownFilter, ulDisplayScript ));

    if ( fHasScriptMap )
    {
        if ( ( DISPLAY_SCRIPT_NONE == ulDisplayScript ) ||
             ( ( DISPLAY_SCRIPT_KNOWN_FILTER == ulDisplayScript ) &&
               ( !fKnownFilter ) ) )
        {
            THROW( CException( MSG_WEBHITS_PATH_INVALID ) );
        }
    }

    //
    // Initialize IFilter.  Pass the list of properties to be emitted, since
    // some other properties may have sensitive information (eg passwords in
    // vbscript code in .asp files).
    //

    // First count how many properties exist.

    ULONG cProps = propertyList.GetCount();
    
    // Copy the properties

    CDbColumns aSpecs( cProps );
    CDbColId prop;
    for ( unsigned iProp = 0; iProp < cProps; iProp++ )
        aSpecs.Add( prop, iProp );

    typedef CPropEntry * PCPropEntry;
    XArray<PCPropEntry> xapPropEntries(cProps);


    SCODE sc = propertyList.GetAllEntries(xapPropEntries.GetPointer(), cProps);
    Win4Assert(S_OK == sc);

    if (FAILED (sc))
        THROW (CException(sc));

    PCPropEntry *apPropEntries = xapPropEntries.GetPointer();
    for (ULONG i = 0; i < cProps; i++)
    {
        CDbColId * pcol = (CDbColId *) &aSpecs.Get( i );

        *pcol = apPropEntries[i]->PropSpec();
        if ( !pcol->IsValid())
            THROW (CException(E_OUTOFMEMORY));
    }

    webDebugOut(( DEB_ITRACE, "%d properties being processed\n", cProps ));

    ULONG ulFlags;
    sc = _xFilter->Init( IFILTER_INIT_CANON_PARAGRAPHS |
                         IFILTER_INIT_CANON_HYPHENS |
                         IFILTER_INIT_APPLY_INDEX_ATTRIBUTES,
                         cProps,
                         (FULLPROPSPEC *) aSpecs.GetColumnsArray(),
                         &ulFlags );

    if (FAILED (sc))
        THROW (CException(sc));

    //
    // pull the contents of the file into the buffer
    //

    ReadFile();

    // Some broken filters don't work right if you Init() them twice, so
    // throw away the IFilter, and get it again.

    _xFilter.Free();
    BindToFilter();

    sc = _xFilter->Init( IFILTER_INIT_CANON_PARAGRAPHS |
                         IFILTER_INIT_CANON_HYPHENS |
                         IFILTER_INIT_APPLY_INDEX_ATTRIBUTES,
                         cProps,
                         (FULLPROPSPEC *) aSpecs.GetColumnsArray(),
                         &ulFlags );
    if (FAILED (sc))
        THROW (CException(sc));

    //
    // attach to ISearchQueryHits, which will find the hits
    //

    sc = _rSearch.Init( _xFilter.GetPointer(), ulFlags );

    if (FAILED (sc))
    {
        if ( QUERY_E_INVALIDRESTRICTION != sc )
            THROW (CException(sc));

        // we can still show the file
        noHits = TRUE;
    }

    //
    // pull up all the hits
    //

    TRY
    {
        if (!noHits)
        {
            ULONG count;
            FILTERREGION* aRegion;
            SCODE sc = _rSearch.NextHitOffset( &count, &aRegion );
    
            while ( S_OK == sc )
            {
                XCoMem<FILTERREGION> xRegion( aRegion );

                webDebugOut(( DEB_ITRACE,
                              "CDOCUMENT: next hit: count %d, chunk %d offset %d, ext %d\n",
                              count,
                              aRegion[0].idChunk,
                              aRegion[0].cwcStart,
                              aRegion[0].cwcExtent ));
    
                CDynArrayInPlace<Position> aPos( count );
    
                //
                // get the positions in the hit
                //
    
                for (unsigned i = 0; i < count; i++)
                {
                    aPos[i] = RegionToPos( aRegion [i] );
                    webDebugOut(( DEB_ITRACE,
                                  "  region %d, start %d, length %d\n",
                                  i,
                                  aPos[i].GetBegOffset(),
                                  aPos[i].GetLength() ));
                }
    
                xRegion.Free();

                XPtr<Hit> xHit( new Hit( aPos.GetPointer(), count ) );

                _aHit[_cHit] = xHit.GetPointer();
                _cHit++;

                xHit.Acquire();
    
                sc = _rSearch.NextHitOffset( &count, &aRegion );
            }

            if ( FAILED( sc ) )
                THROW( CException( sc ) );
        }
    }
    CATCH( CException, e )
    {
        FreeHits();
        RETHROW();
    }
    END_CATCH;

    // done with the filter

    _xFilter.Free();

    if ( _lockSingleThreadedFilter.IsHeld() )
        _lockSingleThreadedFilter.Release();
} //CDocument

//+-------------------------------------------------------------------------
//
//  Member:     CDocument::~CDocument, public
//
//  Synopsis:   Free CDocument
//
//--------------------------------------------------------------------------

CDocument::~CDocument()
{
    FreeHits();
} //~CDocument

//+-------------------------------------------------------------------------
//
//  Member:     CDocument::Free, public
//
//  Synopsis:   Free CDocument storage
//
//--------------------------------------------------------------------------

void CDocument::FreeHits()
{
    //
    // walk through _aHit, deleting each Positions array that the
    // cells are pointing to
    //

    for ( unsigned i = 0; i < _cHit; i++ )
    {
        delete _aHit[i];
        _aHit[i] = 0;
    }
    _cHit = 0;
} //Free

//+-------------------------------------------------------------------------
//
//  Member:     CDocument::RegionToPos, public
//
//  Synopsis:   Convert a FILTERREGION to a position
//
//--------------------------------------------------------------------------

Position CDocument::RegionToPos(
    FILTERREGION& region )
{
    //
    // Use a linear search here.  In profile runs this has never shown
    // up as a problem.  Fix if this changes.
    //

    ULONG offset = ULONG (-1);

    //
    // check whether we're not trying to access an illegal chunk
    //

    if (_iChunkHint >= _chunkCount || _chunk[_iChunkHint].ChunkId() !=
        region.idChunk )
    {
        _iChunkHint = 0;

        while ( _iChunkHint < _chunkCount && _chunk[_iChunkHint].ChunkId() <
            region.idChunk )
        {
            _iChunkHint++;
        }

        if (_iChunkHint >= _chunkCount || _chunk[_iChunkHint].ChunkId()
            != region.idChunk)
        {
            return Position();
        }
    }

    //
    // _iChunkHint now contains the index of the appropriate chunk in the
    // chunk array
    //

    Win4Assert ( _iChunkHint < _chunkCount );
    Win4Assert ( _chunk[_iChunkHint].ChunkId() == region.idChunk );

    //
    // offset now stores the linear offset of the position from the
    // beginning of the stream/buffer
    //

    offset = _chunk[_iChunkHint].Offset() + region.cwcStart;

    return Position (offset,region.cwcExtent );
} //RegionToPos

//+-------------------------------------------------------------------------
//
//  Member:     CDocument::AllocBuffer, public
//
//  Synopsis:   Allocate buffer for file text
//
//--------------------------------------------------------------------------

void CDocument::AllocBuffer()
{
    HANDLE hFile = CreateFile( _filename,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               0, // security
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               0 ); // template

    if ( INVALID_HANDLE_VALUE == hFile )
        THROW( CException() );

    ULONG cbBuf = GetFileSize( hFile, 0 );
    CloseHandle( hFile );

    // Allow extra room for custom properties to be emitted from the
    // filter, plus the conversion to unicode

    _xBuffer.Init( cbBuf + cbBuf / 2 );
} //AllocBuffer

//+-------------------------------------------------------------------------
//
//  Member:     CDocument::BindToFilter, public
//
//  Synopsis:   Bind to appropriate filter for the CDocument
//
//  Returns:    TRUE if an appropriate filter was found
//              FALSE if defaulted to the text filter
//
//--------------------------------------------------------------------------

BOOL CDocument::BindToFilter()
{
    //
    // Bind to the filter interface -- try free threaded first.  If the
    // filter isn't thread-safe, grab the lock and get the filter.
    //

    SCODE sc = LoadBHIFilter( _filename, 0, _xFilter.GetQIPointer(), FALSE );

    // Is the filter not thread safe?  If so, get the lock to protect
    // the filter.  No checking is done to see that this particular
    // filter is in use -- just that some non-thread-safe filter is in use.

    if ( S_FALSE == sc )
    {
        // If the lock isn't held yet, get it (BindToFilter is called
        // twice by CDocument's constructor, so check IsHeld())

        if ( !_lockSingleThreadedFilter.IsHeld() )
            _lockSingleThreadedFilter.Request();

        // retry to load the filter as single-threaded

        sc = LoadBHIFilter( _filename, 0, _xFilter.GetQIPointer(), TRUE );
    }

    BOOL fFoundFilter = TRUE;

    if ( FAILED(sc) )
    {
        sc = LoadTextFilter( _filename, _xFilter.GetPPointer() );
        if (FAILED(sc))
            THROW (CException(sc));

        fFoundFilter = FALSE;
    }

    return fFoundFilter;
} //BindToFilter

//+-------------------------------------------------------------------------
//
//  Function:   GetThreadTime
//
//  Synopsis:   Gets the current total cpu usage for the thread
//
//--------------------------------------------------------------------------

LONGLONG GetThreadTime()
{
    FILETIME ftDummy1, ftDummy2;
    LONGLONG llUser, llKernel;
    Win4Assert( sizeof(LONGLONG) == sizeof(FILETIME) );

    GetThreadTimes( GetCurrentThread(),
                    &ftDummy1,                 // Creation time
                    &ftDummy2,                 // Exit time
                    (FILETIME *) &llUser,      // user mode time
                    (FILETIME *) &llKernel );  // kernel mode tiem

    return llKernel + llUser;
} //GetThreadTime

//+-------------------------------------------------------------------------
//
//  Member:     CDocument::ReadFile, public
//
//  Synopsis:   Read file into buffer using the filter
//
//--------------------------------------------------------------------------

void CDocument::ReadFile()
{
    // get the maximum cpu time in 100s of nano seconds.

    LONGLONG llLimitCpuTime = _cmsReadTimeout * 1000 * 10000;
    llLimitCpuTime += GetThreadTime();

    ULONG               cwcSoFar = 0;
    int                 cChunk = 0;
    BOOL                fSeenProp = FALSE;
    STAT_CHUNK  statChunk;
    SCODE               sc = _xFilter->GetChunk ( &statChunk );

    //
    // Take them into account at some point
    // to test more complicated chunking
    //

    //
    // keep getting chunks of the file, placing them in the buffer,
    // and setting the chunk offset markers that will be used to
    // interpolate the buffer
    //

    while ( SUCCEEDED(sc)
            || FILTER_E_LINK_UNAVAILABLE == sc
            || FILTER_E_EMBEDDING_UNAVAILABLE == sc
            || FILTER_E_NO_TEXT == sc )
    {

        //
        // Eliminate all chunks with idChunkSource 0 right here - these
        // cannot be hit highlighted.
        // Also eliminate all CHUNK_VALUE chunks.
        //

        if ( SUCCEEDED( sc ) && (statChunk.flags & CHUNK_TEXT) && (0 != statChunk.idChunkSource)  )
        {
            //
            // set markers
            //

            Win4Assert ( cChunk == 0 || statChunk.idChunk >
            _chunk [cChunk - 1].ChunkId() );

            //
            // If there was an end of sentence or paragraph or chapter, we
            // should introduce an appropriate spacing character.
            //
            if ( statChunk.breakType != CHUNK_NO_BREAK &&
                 cwcSoFar < _xBuffer.Count() )
            {
                switch (statChunk.breakType)
                {
                    case CHUNK_EOW:
                    case CHUNK_EOS:
                        _xBuffer[cwcSoFar++] = L' ';   // introduce a space character
                        break;

                    case CHUNK_EOP:
                    case CHUNK_EOC:
                        _xBuffer[cwcSoFar++] = UNICODE_PARAGRAPH_SEPARATOR;
                        break;
                }
            }

            //
            // The Offset into the stream depends on whether this is an
            // 'original' chunk or not
            //

            CCiPropSpec* pProp = (CCiPropSpec*) &statChunk.attribute;

            webDebugOut(( DEB_ITRACE,
                          "Chunk %d, Source %d, Contents %d, start %d, cwc %d\n",
                          statChunk.idChunk,
                          statChunk.idChunkSource,
                          pProp->IsContents(),
                          statChunk.cwcStartSource,
                          statChunk.cwcLenSource ));

            if ( (statChunk.idChunk == statChunk.idChunkSource) &&
                 pProp->IsContents() )
            {
                _chunk[cChunk].SetChunkId( statChunk.idChunk );
                _chunk[cChunk].SetOffset( cwcSoFar );
                cChunk++;
#if 0
            }
            else if ( statChunk.idChunk != statChunk.idChunkSource )
            {
                _chunk [cChunk].SetChunkId (statChunk.idChunk);

                //
                // we have to first find the offset of the source chunk
                //

                for (int i=cChunk-1;i>=0;i--)
                {
                    if (_chunk[i].ChunkId() == statChunk.idChunkSource)
                    {
                        _chunk[cChunk].SetOffset(_chunk[i].Offset()+statChunk.cwcStartSource);
                        break;
                    }
                }
                cChunk++;

            }

            //
            // if the chunk is a contents chunk and idChunkSrc = idChunk,
            // then pull it in
            //

            if ( (statChunk.idChunk == statChunk.idChunkSource) &&
                 pProp->IsContents() )
            {
#endif

                webDebugOut(( DEB_ITRACE, "CDOC: markers: chunk %d offset %d\n",
                              _chunk[cChunk-1].ChunkId(),
                              _chunk[cChunk-1].Offset() ));


                //
                // push the text into memory
                //

                do
                {
                    ULONG cwcThis = _xBuffer.Count() - cwcSoFar;
                    if ( 0 == cwcThis )
                        break;

                    sc = _xFilter->GetText( &cwcThis,
                                            _xBuffer.GetPointer() + cwcSoFar );

                    if (SUCCEEDED(sc))
                    {
                        cwcSoFar += cwcThis;
                    }
                }
                while (SUCCEEDED(sc));
            }
        } // If SUCCEEDED( sc )

        if ( GetThreadTime() > llLimitCpuTime )
        {
            webDebugOut(( DEB_ERROR, "Webhits took too long. Timeout\n" ));
            THROW( CException( MSG_WEBHITS_TIMEOUT ) );
        }

        //
        // next chunk, please
        //

        sc = _xFilter->GetChunk ( &statChunk );
    }

    _bufEnd = _xBuffer.GetPointer() + cwcSoFar;
    _chunkCount = cChunk;
} //ReadFile

WCHAR* CDocument::GetWritablePointerToOffset(
    long offset )
{
    if (offset >= 0)
    {
        if (_xBuffer.GetPointer() + offset < _bufEnd)
            return _xBuffer.GetPointer() + offset;
        else
            return _bufEnd;
    }
    else
    {
        return _xBuffer.GetPointer();
    }
} //GetWritablePointerToOffset

//+-------------------------------------------------------------------------
//
//  Member:     CDocument::GetPointerToOffset, public
//
//  Arguments:  [offset] - the offset in the stream that we want a pointer to
//
//  Synopsis:   Return a constant pointer to a specific offset in the buffer
//
//--------------------------------------------------------------------------

const WCHAR* CDocument::GetPointerToOffset(long offset) 
{
    return (const WCHAR *) GetWritablePointerToOffset(offset);
} //GetPointerToOffset
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\webhits\webhits.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       webhits.cxx
//
//  History:    05-20-96 t-matts Created
//              03-03-97 dlee    Converted to isapi
//
//  Contents:   This is the main() for the hit-highliting feature. The
//              CGI environment variables are read, yielding the filename
//              and the textual form of the restriction. The textual form
//              is then converted to internal form. The document is then
//              scanned for hits, and the positions contained in those
//              hits are sorted. Finally, HTML tags are inserted in the order
//              in which the distinct positions appear in the document, to
//              allow the user to navigate.
//
//--------------------------------------------------------------------------

#include<pch.cxx>
#pragma hdrstop

#include <cidebug.hxx>
#include <codepage.hxx>
#include <ciregkey.hxx>
#include <regacc.hxx>
#include <cpid.hxx>
#include <dblink.hxx>
#include <imprsnat.hxx>
#include <regevent.hxx>
#include <dynstack.hxx>
#include <cimbmgr.hxx>
#include <xolemem.hxx>

#include "webhits.hxx"
#include "webdbg.hxx"
#include "whmsg.h"
#include "linkhits.hxx"

#define _DECL_DLLMAIN 1

DECLARE_INFOLEVEL (web);
DECLARE_INFOLEVEL (ci);

const int ERROR_MESSAGE_SIZE=512;

BOOL g_fShutdown = TRUE;
LONG g_cThreads = 0;
CWebhitsInfo * g_pWebhitsInfo = 0;

void OutputErrorMessage( CWebServer & webServer,
                         CLanguageInfo & LanguageInfo,
                         DWORD dwMsgId,
                         WCHAR const * pwcIdqPPath,
                         WCHAR const * pwcIdqVPath,
                         WCHAR const * pwcHtwPPath,
                         WCHAR const * pwcHtwVPath,
                         WCHAR const * pwcWebhitsPPath,
                         WCHAR const * pwcWebhitsVPath,
                         WCHAR const * pwszDefaultMsg = 0,
                         WCHAR const * pwszFileName = 0,
                         ULONG ulFileLine = 0 );

//+---------------------------------------------------------------------------
//
//  Function:   GetVPathInfo
//
//  Synopsis:   Convers a vpath to a ppath
//
//  Arguments:  [webServer]    -- Used for the translation
//              [pwcVPath]     -- VPath to translate
//              [dwAccessMask] -- Access required for file, or 0 for none
//              [dwFlags]      -- Returns vpath flags (HSE_URL_FLAGS_*)
//
//  Returns:    pointer to PPath allocated on the heap.
//
//  History:    3-04-97   dlee   Created
//
//----------------------------------------------------------------------------

WCHAR * GetVPathInfo(
    CWebServer &  webServer,
    WCHAR const * pwcVPath,
    DWORD         dwAccessMask,
    DWORD &       dwFlags )
{
    WCHAR *pwc = 0;

    TRY
    {
        WCHAR awcPPath[MAX_PATH];
        dwFlags = webServer.GetPhysicalPath( pwcVPath,
                                             awcPPath,
                                             sizeof awcPPath / sizeof WCHAR,
                                             dwAccessMask );

        if ( ( 0 == wcsstr( awcPPath, L"../" ) ) &&
             ( 0 == wcsstr( awcPPath, L"..\\" ) ) )
        {
            ULONG cwc = wcslen( awcPPath ) + 1;
            pwc = new WCHAR[ cwc ];
            RtlCopyMemory( pwc, awcPPath, cwc * sizeof WCHAR );
        }
    }
    CATCH( CException, e )
    {
        // returning 0 is sufficient
    }
    END_CATCH

    return pwc;
} //GetVPathInfo

//+---------------------------------------------------------------------------
//
//  Function:   GetWebhitsVPathInfo
//
//  Synopsis:   Converts vpaths to ppaths for the query, template, and
//              webhits files.
//
//  Arguments:  [vars]      -- Source of vpaths, sink of ppaths
//              [webServer] -- Used for the translations
//
//  History:    9-06-96   srikants   Created
//
//----------------------------------------------------------------------------

void GetWebhitsVPathInfo(
    CGetEnvVars & vars,
    CWebServer &  webServer )
{
    // Translate the path of the query (idq) file if one is given.

    DWORD dwFlags;

    if ( vars.GetQueryFileVPath() )
    {
        WCHAR * pwc = GetVPathInfo( webServer,
                                    vars.GetQueryFileVPath(),
                                    0,
                                    dwFlags );

        if ( 0 == pwc )
            THROW( CWTXException( MSG_WEBHITS_IDQ_NOT_FOUND,
                                  vars.GetQueryFileVPath(),
                                  0 ) );

        vars.AcceptQueryFilePPath( pwc, dwFlags );
        webDebugOut(( DEB_ITRACE, "Query file '%ws'\n", pwc ));
    }

    // Translate the path of the template (htw) file if one is given.

    if ( vars.GetTemplateFileVPath() )
    {
        WCHAR * pwc = GetVPathInfo( webServer,
                                    vars.GetTemplateFileVPath(),
                                    0,
                                    dwFlags );

        if ( 0 == pwc )
            THROW( CWTXException( MSG_WEBHITS_NO_SUCH_TEMPLATE,
                                  vars.GetTemplateFileVPath(),
                                  0 ) );

        vars.AcceptTemplateFilePPath( pwc, dwFlags );
        webDebugOut(( DEB_ITRACE, "Template file '%ws'\n", pwc ));
    }

    // Translate the path of the WebHits file being displayed.  Read access
    // is required for this file.

    if ( vars.GetWebHitsFileVPath() )
    {
        WCHAR * pwc = GetVPathInfo( webServer,
                                    vars.GetWebHitsFileVPath(),
                                    HSE_URL_FLAGS_READ,
                                    dwFlags );

        if ( 0 == pwc )
            THROW( CException(MSG_WEBHITS_PATH_INVALID) );

        vars.AcceptWebHitsFilePPath( pwc, dwFlags );
        webDebugOut(( DEB_ITRACE, "WebHits file '%ws'\n", pwc ));
    }
    else
    {
        THROW( CException(MSG_WEBHITS_PATH_INVALID) );
    }
} //GetWebhitsVPathInfo

//+---------------------------------------------------------------------------
//
//  Function:   ProcessWebRequest
//
//  Synopsis:   Main driver method for webhits.
//
//  Arguments:  [webServer]  -- web server to use
//
//  History:    9-04-96   srikants   Created
//
//----------------------------------------------------------------------------

DWORD ProcessWebRequest( CWebServer & webServer )
{
    DWORD hse = HSE_STATUS_SUCCESS;

    //
    // Initialize the locale and codepage.
    //
    LCID lcid = GetLCID( webServer );
    ULONG urlCodePage = GetBrowserCodepage( webServer, lcid );

    CLanguageInfo langInfo;

    //
    // Set the client and output locale info to be the same as
    // the client info. If a different value is set
    // via CiLocale, it will be changed when the querystring is parsed.
    //

    langInfo.SetUrlLangInfo( urlCodePage, lcid );
    langInfo.SetRestrictionLangInfo( urlCodePage, lcid );

    CURLUnescaper unescaper( langInfo.GetUrlCodePage() );
    CCollectVar varRetriever( unescaper, webServer );

    XArray<WCHAR> xwszQueryFile;

    WCHAR awcWebhitsPPath[ MAX_PATH ];
    WCHAR awcWebhitsVPath[ MAX_PATH ];
    WCHAR awcIdqPPath[ MAX_PATH ];
    WCHAR awcIdqVPath[ MAX_PATH ];
    WCHAR awcHtwPPath[ MAX_PATH ];
    WCHAR awcHtwVPath[ MAX_PATH ];

    WCHAR const * pwcWebhitsPPath = 0;
    WCHAR const * pwcWebhitsVPath = 0;
    WCHAR const * pwcIdqPPath = 0;
    WCHAR const * pwcIdqVPath = 0;
    WCHAR const * pwcHtwPPath = 0;
    WCHAR const * pwcHtwVPath = 0;

    TRY
    {
        //
        // Refresh the registry values if necessary
        //

        g_pWebhitsInfo->Refresh();

        //
        // Are there too many threads doing webhits?
        //

        if ( g_cThreads > (LONG) g_pWebhitsInfo->GetMaxRunningWebhits() )
        {
            webDebugOut(( DEB_WARN,
                          "%d instances of webhits running\n",
                          g_cThreads ));
            THROW( CException( MSG_WEBHITS_TOO_MANY_COPIES ) );
        }

        //
        // Retrieve the necessary environment variables.
        //

        CGetEnvVars variables( webServer,
                               langInfo,
                               varRetriever,
                               unescaper );

        if (variables.GetQueryFileVPath())
        {
            xwszQueryFile.Init( wcslen(variables.GetQueryFileVPath())+1 );
            wcscpy( xwszQueryFile.GetPointer(), variables.GetQueryFileVPath() );
        }

        GetWebhitsVPathInfo( variables, webServer );

        //
        // construct Property List with static properties
        //

        XInterface<CEmptyPropertyList> xlist;

        //
        // If an idq file was specified, then parse the [NAMES] section of
        // that file to obtain custom properties
        //

        if ( variables.GetQueryFilePPath() )
        {
            Win4Assert( wcslen( variables.GetQueryFilePPath() ) < MAX_PATH );
            wcscpy( awcIdqPPath, variables.GetQueryFilePPath() );
            pwcIdqPPath = awcIdqPPath;

            Win4Assert( wcslen( variables.GetQueryFileVPath() ) < MAX_PATH );
            wcscpy( awcIdqVPath, variables.GetQueryFileVPath() );
            pwcIdqVPath = awcIdqVPath;
            xlist.Set( new CLocalGlobalPropertyList( GetGlobalStaticPropertyList(),
                                                     TRUE,
                                                     variables.GetQueryFilePPath(),
                                                     langInfo.GetUrlCodePage()) );
            ULONG iLine;
            WCHAR * pwszFile;

            SCODE sc = ((CLocalGlobalPropertyList *)xlist.GetPointer())->CheckError( iLine, &pwszFile );
            if (FAILED(sc))
                THROW(CException(sc));
        }
        else
            xlist.Set(GetGlobalStaticPropertyList());

        //
        // If a template file is specified, it should be parsed.
        //

        XPtr<CWebhitsTemplate> xTemplate;

        if ( variables.GetTemplateFileVPath() )
        {
            Win4Assert( wcslen( variables.GetTemplateFilePPath() ) < MAX_PATH );
            wcscpy( awcHtwPPath, variables.GetTemplateFilePPath() );
            pwcHtwPPath = awcHtwPPath;

            Win4Assert( wcslen( variables.GetTemplateFileVPath() ) < MAX_PATH );
            wcscpy( awcHtwVPath, variables.GetTemplateFileVPath() );
            pwcHtwVPath = awcHtwVPath;

            CWebhitsTemplate * pTemplate =
                    new CWebhitsTemplate( variables,
                                          langInfo.GetOutputCodePage() );
            xTemplate.Set( pTemplate );
        }

        //
        // convert textual query into CDbRestriction
        //

        CInternalQuery query( variables, xlist.GetReference(), langInfo.GetQueryLCID() );

        Win4Assert( wcslen( variables.GetWebHitsFilePPath() ) < MAX_PATH );
        wcscpy( awcWebhitsPPath, variables.GetWebHitsFilePPath() );
        pwcWebhitsPPath = awcWebhitsPPath;

        Win4Assert( wcslen( variables.GetWebHitsFileVPath() ) < MAX_PATH );
        wcscpy( awcWebhitsVPath, variables.GetWebHitsFileVPath() );
        pwcWebhitsVPath = awcWebhitsVPath;

        //
        // Verify a consistent SSL-setting for .htw and webhits files.
        // This fixes the problem where the webhits file requires SSL,
        // but the template file doesn't, since a port can't change its
        // SSL setting on the fly.  A work-around would be to do a redirect
        // to a bogus .htw file in the same virtual directory as the
        // webhits file to force SSL, but that seemed overkill.
        //

        if ( variables.GetTemplateFileVPath() )
        {
            //
            // This is a complete list of SSL-related flags.
            //

            const DWORD dwSSL = HSE_URL_FLAGS_SSL |
                                HSE_URL_FLAGS_NEGO_CERT |
                                HSE_URL_FLAGS_REQUIRE_CERT |
                                HSE_URL_FLAGS_MAP_CERT |
                                HSE_URL_FLAGS_SSL128;

            DWORD dwTemplate = ( variables.GetTemplateFileFlags() & dwSSL );
            DWORD dwWebHits = ( variables.GetWebHitsFileFlags() & dwSSL );

            if ( ( dwTemplate != dwWebHits ) &&
                 ( 0 != dwWebHits ) )
            {
                webDebugOut(( DEB_WARN,
                              "SSL mismatch template: 0x%x, webhits: 0x%x\n",
                              dwTemplate, dwWebHits ));
                THROW( CException( MSG_WEBHITS_INCONSISTENT_SSL ) );
            }
        }

        //
        // Impersonate if the file being webhit is remote
        //

        CImpersonateRemoteAccess imp( 0 );

        if ( CImpersonateRemoteAccess::IsNetPath( pwcWebhitsPPath ) )
        {
            CImpersonationTokenCache * pCache = g_pWebhitsInfo->GetTokenCache( webServer );
            imp.SetTokenCache( pCache );

            // Flip the slashes -- the token cache expects backslashes...

            unsigned cwc = wcslen( pwcWebhitsVPath );
            Win4Assert( cwc < MAX_PATH );
            WCHAR awcTempVPath[ MAX_PATH ];

            for ( unsigned c = 0; c < cwc; c++ )
            {
                if ( L'/' == pwcWebhitsVPath[c] )
                    awcTempVPath[c] = L'\\';
                else
                    awcTempVPath[c] = pwcWebhitsVPath[c];
            }

            awcTempVPath[ cwc ] = 0;

            //
            // If impersonation fails, try rescanning the metabase.
            // There may have been an update to vroot info.
            // Note that revocation may take a long time as a result.
            // It's really unlikely we'll have to reinit very often
            // unless the server is misconfigured.
            //

            if ( !imp.ImpersonateIfNoThrow( pwcWebhitsPPath, awcTempVPath ) )
            {
                pCache->ReInitializeIISScopes();
                imp.ImpersonateIf( pwcWebhitsPPath, awcTempVPath );
            }
        }

        //
        // construct framework for highlighting, and highlight hits
        //

        query.CreateISearch( pwcWebhitsPPath );

        //
        // two cases - either summary or full hit-highlighting
        //

        CReleasableLock lock( g_pWebhitsInfo->GetNonThreadedFilterMutex(),
                              FALSE );

        if (variables.GetHiliteType() == CGetEnvVars::SUMMARY)
        {
            XPtr<CDocument> xDoc( new CDocument(
                                  (WCHAR*) pwcWebhitsPPath,
                                  CLinkQueryHits::BOGUS_RANK,
                                  query.GetISearchRef(),
                                  g_pWebhitsInfo->GetMaxWebhitsCpuTime(),
                                  lock,
                                  xlist.GetReference(),
                                  g_pWebhitsInfo->GetDisplayScript() ) );

            PHttpOutput httpOutput( webServer, langInfo );
            httpOutput.Init( &variables, xTemplate.GetPointer() );

            HitIter iterator;
            iterator.Init( xDoc.GetPointer() );

            httpOutput.OutputHTMLHeader();

            if ( variables.IsFixedFont() )
                httpOutput.OutputPreformattedTag();

            CExtractHits hitExtractor( xDoc.GetReference(),
                                       iterator,
                                       httpOutput );

            httpOutput.OutputHTMLFooter();
        }
        else
        {
            PHttpFullOutput httpOutput( webServer, langInfo );
            httpOutput.Init(&variables, xTemplate.GetPointer());

            XPtr<CLinkQueryHits> xLQH( new CLinkQueryHits(
                                       query,
                                       variables,
                                       httpOutput,
                                       g_pWebhitsInfo->GetMaxWebhitsCpuTime(),
                                       lock,
                                       xlist.GetReference(),
                                       g_pWebhitsInfo->GetDisplayScript() ) );

            httpOutput.OutputHTMLHeader();
            xLQH->InsertLinks();
            httpOutput.OutputHTMLFooter();
        }
    }
    CATCH( CPListException, ple )
    {
        WCHAR wcTempBuffer[ERROR_MESSAGE_SIZE];

        wsprintf( wcTempBuffer,
                  L"Property list parsing query file %ls failed with error 0x%X\n",
                  xwszQueryFile.GetPointer(),
                  ple.GetPListError() );

        OutputErrorMessage( webServer,
                            langInfo,
                            ple.GetPListError(),
                            pwcIdqPPath,
                            pwcIdqVPath,
                            pwcHtwPPath,
                            pwcHtwVPath,
                            pwcWebhitsPPath,
                            pwcWebhitsVPath,
                            wcTempBuffer,
                            xwszQueryFile.GetPointer(),
                            ple.GetLine() );
    }
    AND_CATCH( CWTXException, we )
    {
        WCHAR wcTempBuffer[ERROR_MESSAGE_SIZE];

        wsprintf( wcTempBuffer,
                  L"Parsing template file %ls failed with error 0x%X\n",
                  we.GetFileName(),
                  we.GetErrorCode() );

        OutputErrorMessage( webServer,
                            langInfo,
                            we.GetErrorCode(),
                            pwcIdqPPath,
                            pwcIdqVPath,
                            pwcHtwPPath,
                            pwcHtwVPath,
                            pwcWebhitsPPath,
                            pwcWebhitsVPath,
                            wcTempBuffer,
                            we.GetFileName(),
                            we.GetLineNumber() );
    }
    AND_CATCH( CParserException, pe )
    {
        WCHAR wcTempBuffer[ERROR_MESSAGE_SIZE];
        wsprintf( wcTempBuffer,
                  L"Parsing of QUERY_STRING failed with error 0x%X\n",
                  pe.GetErrorCode() );

        OutputErrorMessage( webServer,
                            langInfo,
                            pe.GetParseError(),
                            pwcIdqPPath,
                            pwcIdqVPath,
                            pwcHtwPPath,
                            pwcHtwVPath,
                            pwcWebhitsPPath,
                            pwcWebhitsVPath,
                            wcTempBuffer );
    }
    AND_CATCH( CException,e )
    {
        OutputErrorMessage( webServer,
                            langInfo,
                            e.GetErrorCode(),
                            pwcIdqPPath,
                            pwcIdqVPath,
                            pwcHtwPPath,
                            pwcHtwVPath,
                            pwcWebhitsPPath,
                            pwcWebhitsVPath );
    }
    END_CATCH

    return hse;
} //ProcessWebRequest

//+---------------------------------------------------------------------------
//
//  Function:   OutputErrorMessage
//
//  Synopsis:   Outputs an error message based on the msg id given. It first
//              looks up for the error in webhits.dll, query.dll, then in
//              kernel32.dll.
//              If no message is found, it then uses the default message.
//
//  Arguments:  [dwMsgId]        - Message id
//              [pwszDefaultMsg] - Pointer to the default message. Will be
//                                 used if there is no pre-formatted message.
//              [pwszFileName]   - File name to be printed prior to the error
//                                 message.  Will not be printed if null.
//              [ulFileLine]     - File line number.  Not printed if zero.
//
//  History:    9-04-96   srikants   Created
//
//----------------------------------------------------------------------------

void OutputErrorMessage( CWebServer & webServer,
                         CLanguageInfo & langInfo,
                         DWORD dwMsgId,
                         WCHAR const * pwcIdqPPath,
                         WCHAR const * pwcIdqVPath,
                         WCHAR const * pwcHtwPPath,
                         WCHAR const * pwcHtwVPath,
                         WCHAR const * pwcWebhitsPPath,
                         WCHAR const * pwcWebhitsVPath,
                         WCHAR const * pwszDefaultMsg,
                         WCHAR const * pwszFileName,
                         ULONG ulFileLine )
{
    CImpersonateSystem system;

    //
    //  If the error was the result of an access denied problem, then simply
    //  return a 401 error to the browser if the path allows authentication
    //
    //  Generate the Win32 error code by removing the facility code (7) and
    //  the error bit.
    //

    if ( (STATUS_ACCESS_DENIED                              == dwMsgId) ||
         (STATUS_NETWORK_ACCESS_DENIED                      == dwMsgId) ||
         (HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED )         == dwMsgId) ||
         (HRESULT_FROM_WIN32( ERROR_INVALID_ACCESS )        == dwMsgId) ||
         (HRESULT_FROM_WIN32( ERROR_NETWORK_ACCESS_DENIED ) == dwMsgId) )
    {
        WCHAR const * pwcVPath = 0;
        WCHAR const * pwcPPath = 0;

        if ( 0 != pwcWebhitsVPath )
        {
            pwcPPath = pwcWebhitsPPath;
            pwcVPath = pwcWebhitsVPath;
        }
        else if ( 0 != pwcHtwVPath )
        {
            pwcPPath = pwcHtwPPath;
            pwcVPath = pwcHtwVPath;
        }
        else
        {
            pwcPPath = pwcIdqPPath;
            pwcVPath = pwcIdqVPath;
        }

        Win4Assert( 0 != pwcPPath );
        Win4Assert( 0 != pwcVPath );

        webDebugOut(( DEB_ITRACE, "error P and V paths: '%ws', '%ws'\n",
                      pwcPPath, pwcVPath ));

        CMetaDataMgr mdMgr( FALSE, W3VRoot, webServer.GetServerInstance() );
        ULONG Authorization = mdMgr.GetVPathAuthorization( pwcVPath );
        webDebugOut(( DEB_ITRACE, "authorization: 0x%x\n", Authorization ));

        // If the virtual directory doesn't support just anonymous,
        // this is not a remote physical path, try to authenticate.

        if ( 0 != Authorization &&
             MD_AUTH_ANONYMOUS != Authorization &&
             !CImpersonateRemoteAccess::IsNetPath( pwcPPath ) )
        {
            webDebugOut(( DEB_WARN,
                          "mapping 0x%x to 401 access denied\n",
                          dwMsgId ));
            webServer.WriteHeader( 0, "401 Access denied" );
            const char * pcAccessDenied = "Access is denied.";
            webServer.WriteClient( (BYTE *) pcAccessDenied,
                                   strlen( pcAccessDenied ) );
            return;
        }
    }

    WCHAR awcTempBuffer[ERROR_MESSAGE_SIZE];
    WCHAR * pwszErrorMessage = awcTempBuffer;
    ULONG cchAvailMessage = ERROR_MESSAGE_SIZE;

    //
    // Don't pass a specific lang id to FormatMessage since it will
    // fail if there's no message in that language. Instead set
    // the thread locale, which will get FormatMessage to use a search
    // algorithm to find a message of the appropriate language or
    // use a reasonable fallback msg if there's none.
    //
    LCID SaveLCID = GetThreadLocale();
    SetThreadLocale( langInfo.GetQueryLCID() );

    if (pwszFileName != 0)
    {
        //
        //  These are errors encountered while parsing the [names] section
        //
        DWORD_PTR args [] = {
                         (DWORD_PTR) pwszFileName,
                         (DWORD_PTR) ulFileLine,
                        };

        NTSTATUS MsgNum = MSG_WEBHITS_FILE_MESSAGE;
        if ( 0 != ulFileLine )
            MsgNum = MSG_WEBHITS_FILE_LINE_MESSAGE;

        ULONG cchMsg = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                                         FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                      GetModuleHandle(L"webhits.dll"),
                                      MsgNum,
                                      0,
                                      pwszErrorMessage,
                                      cchAvailMessage,
                                      (va_list *) args );
        pwszErrorMessage += cchMsg;
        cchAvailMessage -= cchMsg;
    }

    if ( !FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                         FORMAT_MESSAGE_ARGUMENT_ARRAY,
                         GetModuleHandle(L"webhits.dll"),
                         dwMsgId,
                         0,
                         pwszErrorMessage,
                         cchAvailMessage,
                         0 ) &&
         !FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                         FORMAT_MESSAGE_ARGUMENT_ARRAY,
                         GetModuleHandle(L"Query.dll"),
                         dwMsgId,
                         0,
                         pwszErrorMessage,
                         cchAvailMessage,
                         0 ) &&
         !FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                         FORMAT_MESSAGE_ARGUMENT_ARRAY,
                         GetModuleHandle(L"kernel32.dll"),
                         dwMsgId,
                         0,
                         pwszErrorMessage,
                         cchAvailMessage,
                         0 ) &&
         !FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                         FORMAT_MESSAGE_ARGUMENT_ARRAY,
                         GetModuleHandle(L"kernel32.dll"),
                         HRESULT_CODE(dwMsgId),
                         0,
                         pwszErrorMessage,
                         cchAvailMessage,
                         0 ) )
    {
         DWORD dwError = GetLastError();
         webDebugOut(( DEB_ERROR, "Format Message failed with error 0x%X\n",
                                  dwError ));
         if ( !pwszDefaultMsg )
         {
             wsprintf( pwszErrorMessage,
                       L"Error 0x%X occurred while running webhits \n",
                       dwMsgId );
         }
         else
         {
             Win4Assert( wcslen( pwszDefaultMsg ) < cchAvailMessage );
             wsprintf( pwszErrorMessage, L"%ws\n", pwszDefaultMsg );
         }
     }

    SetThreadLocale(SaveLCID);

    PHttpOutput httpOutput( webServer, langInfo );

    httpOutput.OutputErrorHeader();
    httpOutput.OutputErrorMessage( awcTempBuffer, wcslen(awcTempBuffer) );
    httpOutput.OutputHTMLFooter();
} //OutputErrorMessage

//+---------------------------------------------------------------------------
//
//  Function:   GetExtensionVersion - public
//
//  Synposis:   Returns extension info to the server.  This is called before
//              HttpExtensionProc is called, and it is called in System
//              context, so any initialization that requires this context
//              must be handled here.
//
//  Arguments:  [pVer]  - where the info goes
//
//  History:    96-Apr-15   dlee        Added header
//
//----------------------------------------------------------------------------

BOOL WINAPI GetExtensionVersion(
    HSE_VERSION_INFO * pVer )
{
    BOOL fOK = TRUE;

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        Win4Assert( g_fShutdown );
        Win4Assert( 0 == g_pWebhitsInfo );

        pVer->dwExtensionVersion = MAKELONG( 0, 3 );
        strcpy( pVer->lpszExtensionDesc, "Indexing Service webhits extension" );

        g_pWebhitsInfo = new CWebhitsInfo();
        g_fShutdown = FALSE;
    }
    CATCH( CException, e )
    {
        fOK = FALSE;

        webDebugOut(( DEB_WARN,
                      "GetExtensionVersion failed 0x%x\n",
                      e.GetErrorCode() ));
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    return fOK;
} //GetExtensionVersion

//+---------------------------------------------------------------------------
//
//  Function:   TerminateExtension, public
//
//  Synposis:   Called by IIS during shutdown
//
//  History:    3-Mar-97   dlee       Created
//
//----------------------------------------------------------------------------

BOOL WINAPI TerminateExtension(
    DWORD dwFlags )
{
    TRANSLATE_EXCEPTIONS;

    BOOL fOK = FALSE;

    if ( dwFlags & HSE_TERM_MUST_UNLOAD )
    {
        TRY
        {
            Win4Assert( !g_fShutdown );
            g_fShutdown = TRUE;

            webDebugOut(( DEB_WARN,
                          "Mandatory extension unload. Shutting down webhits.\n" ));

            // wait for all the isapi request threads to finish

            while ( 0 != g_cThreads )
                Sleep( 50 );

            delete g_pWebhitsInfo;
            g_pWebhitsInfo = 0;

            CIShutdown();
        }
        CATCH( CException, e )
        {
            // ignore
        }
        END_CATCH

        fOK = TRUE;
    }

    webDebugOut(( DEB_WARN,
                  "webhits extension unload: 0x%x. Flags = 0x%x\n",
                  fOK, dwFlags ));

    UNTRANSLATE_EXCEPTIONS;

    return fOK;
} //TerminateExtension

//+---------------------------------------------------------------------------
//
//  Function:   HttpExtensionProc, public
//
//  Synposis:   Handles a request from the web server
//
//  Arguments:  [pEcb] -- block from the server
//
//  History:    3-Mar-97   dlee       Created
//
//----------------------------------------------------------------------------

DWORD WINAPI HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK * pEcb )
{
    if ( g_fShutdown )
    {
        pEcb->dwHttpStatusCode = HTTP_STATUS_SERVER_ERROR;
        return HSE_STATUS_ERROR;
    }

    InterlockedIncrement( & g_cThreads );

    CWebServer webServer( pEcb );
    DWORD hseStatus = HSE_STATUS_ERROR;
    webServer.SetHttpStatus( HTTP_STATUS_OK );

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        XCom xcom;

        hseStatus = ProcessWebRequest( webServer );
    }
    CATCH( CException, e )
    {
        hseStatus = HSE_STATUS_ERROR;
        webServer.SetHttpStatus( HTTP_STATUS_SERVER_ERROR );
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    Win4Assert( HSE_STATUS_PENDING != hseStatus );

    InterlockedDecrement( & g_cThreads );

    return hseStatus;
} //HttpExtensionProc

//+---------------------------------------------------------------------------
//
//  Method:     CWebhitsInfo::CWebhitsInfo, public
//
//  Synposis:   Constructs a webhits info object
//
//  History:    18-Aug-97   dlee       Created
//
//----------------------------------------------------------------------------

CWebhitsInfo::CWebhitsInfo() :
    _regChangeEvent( wcsRegAdminTree )
{
    ReadRegValues();
} //CWebhitsInfo

//+---------------------------------------------------------------------------
//
//  Method:     CWebhitsInfo::Refresh, public
//
//  Synposis:   Checks to see if the registry has changed and refreshes it
//
//  History:    18-Aug-97   dlee       Created
//
//----------------------------------------------------------------------------

void CWebhitsInfo::Refresh()
{
    CLock lock( _mutex );

    ULONG res = WaitForSingleObject( _regChangeEvent.GetEventHandle(), 0 );

    if ( WAIT_OBJECT_0 == res )
    {
        ReadRegValues();
        _regChangeEvent.Reset();
    }
} //Refresh

//+---------------------------------------------------------------------------
//
//  Method:     CWebhitsInfo::ReadRegValues
//
//  Synposis:   Reads webhits registry info
//
//  History:    18-Aug-97   dlee       Created
//
//----------------------------------------------------------------------------

void CWebhitsInfo::ReadRegValues()
{
    CRegAccess reg( RTL_REGISTRY_CONTROL, wcsRegAdmin );

    const ULONG CI_RUNNING_WEBHITS_DEFAULT = 20;
    const ULONG CI_RUNNING_WEBHITS_MIN     = 1;
    const ULONG CI_RUNNING_WEBHITS_MAX     = 200;
    ULONG ul = reg.Read( wcsMaxRunningWebhits, CI_RUNNING_WEBHITS_DEFAULT );
    _cMaxRunningWebhits = Range( ul, CI_RUNNING_WEBHITS_MIN, CI_RUNNING_WEBHITS_MAX );

    const ULONG CI_WEBHITS_DISPLAY_SCRIPT_DEFAULT = DISPLAY_SCRIPT_KNOWN_FILTER;
    const ULONG CI_WEBHITS_DISPLAY_SCRIPT_MIN     = 0;
    const ULONG CI_WEBHITS_DISPLAY_SCRIPT_MAX     = 2;
    ul = reg.Read( wcsWebhitsDisplayScript, CI_WEBHITS_DISPLAY_SCRIPT_DEFAULT );
    _ulDisplayScript = Range( ul, CI_WEBHITS_DISPLAY_SCRIPT_MIN, CI_WEBHITS_DISPLAY_SCRIPT_MAX );

    const ULONG CI_WEBHITS_TIMEOUT_DEFAULT = 30;
    const ULONG CI_WEBHITS_TIMEOUT_MIN     = 5;
    const ULONG CI_WEBHITS_TIMEOUT_MAX     = 7200;
    ul = reg.Read( wcsMaxWebhitsCpuTime, CI_WEBHITS_TIMEOUT_DEFAULT );
    _cmsMaxWebhitsCpuTime = Range( ul, CI_WEBHITS_TIMEOUT_MIN, CI_WEBHITS_TIMEOUT_MAX );
} //ReadRegValues

//+---------------------------------------------------------------------------
//
//  Method:     GetTokenCache, public
//
//  Synposis:   Retrieves the appropriate token cache for the web server
//
//  Arguments:  [webServer] -- The web server instance
//
//  History:    18-Aug-97   dlee       Created
//
//----------------------------------------------------------------------------

CImpersonationTokenCache * CWebhitsInfo::GetTokenCache(
    CWebServer & webServer )
{
    //
    // Get the server instance of this ISAPI request
    //

    ULONG ulInstance = webServer.GetServerInstance();

    //
    // Look for a token cache for this server instance
    //

    CLock lock( _mutex );

    for ( unsigned x = 0; x < _aTokenCache.Count(); x++ )
    {
        Win4Assert( 0 != _aTokenCache[ x ] );

        if ( _aTokenCache[ x ]->GetW3Instance() == ulInstance )
            return _aTokenCache[ x ];
    }

    //
    // Not found, so create a new token cache
    //

    CImpersonateSystem system;

    XPtr<CImpersonationTokenCache> xCache( new CImpersonationTokenCache( L"" ) );

    xCache->Initialize( L"webhits",    // arbitrary name of token cache
                        TRUE,          // w3svc
                        FALSE,         // not nntp
                        FALSE,         // not imap
                        ulInstance,    // virtual server instance number
                        0,             // no nntp vserver instance
                        0 );           // no imap vserver instance

    _aTokenCache[ _aTokenCache.Count() ] = xCache.GetPointer();

    return xCache.Acquire();
} //GetTokenCache
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\webhits\linkhits.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       linkhits.cxx
//
//  Contents:   classes to insert links among query hits in HTML format
//
//--------------------------------------------------------------------------

#include<pch.cxx>
#pragma hdrstop

#include <locale.h>

#include <mbutil.hxx>
#include <htmlchar.hxx>
#include <codepage.hxx>
#include <cgiesc.hxx>
#include <weblcid.hxx>

#include "webdbg.hxx"
#include "whmsg.h"
#include "linkhits.hxx"
#include "whtmplat.hxx"

extern int _cdecl ComparePositions(const void* pPos1, const void* pPos2);

const WCHAR VPathWebHitsFile[]=L"CiWebHitsFile";
const WCHAR CommandLineVarName[]=L"QUERY_STRING";
const WCHAR RestrictionVarName[]=L"CiRestriction";
const WCHAR IDQFilenameVarName[]=L"CiQueryFile";
const WCHAR WTXFilenameVarName[]=L"CiTemplateFile";
const WCHAR HiliteTypeVarName[]=L"CiHiliteType";
const WCHAR ColorVarName[]=L"CiHiliteColor";
const WCHAR BoldVarName[]=L"CiBold";
const WCHAR ItalicVarName[]=L"CiItalic";
const WCHAR MaxLineLength[]=L"CiMaxLineLength";
const WCHAR LocaleVar[]=L"CiLocale";
const WCHAR BeginHiliteVar[]=L"CiBeginHilite";
const WCHAR EndHiliteVar[]=L"CiEndHilite";
const WCHAR NullHTWFile[]=L"null.htw";
const WCHAR CodepageVar[]=L"CiCodepage";
const WCHAR DialectVar[]=L"CiDialect";

const WCHAR ParaTag[]=L"<P>\n";
const WCHAR HRule[]=L"<HR>\n";

const WCHAR Red24BitMask[]=L"#FF0000";
const WCHAR Blue24BitMask[]=L"#0000FF";
const WCHAR Green24BitMask[]=L"#00FF00";
const WCHAR Black24BitMask[]=L"#000000";
const WCHAR Yellow24BitMask[]=L"#FFFF00";


//
// List of replacable parameters in the htx file for output generation.
//
const WCHAR wcsParamCiUrl[]         = L"CIURL";
const WCHAR wcsParamRestriction[]   = L"CIRESTRICTION";
const WCHAR wcsCharSet[]            = L"CICHARSET";
const WCHAR wcsLocale[]             = L"CILOCALE";
const WCHAR wcsCodepage[]           = L"CICODEPAGE";

const WCHAR wcsUserParamPrefix[]    = L"CIUSERPARAM";
const ULONG cwcUserParamPrefix = (sizeof(wcsUserParamPrefix)/sizeof(WCHAR))-1;

const WCHAR * awcsUserParamNames[]  = {
                              L"CIUSERPARAM1",
                              L"CIUSERPARAM2",
                              L"CIUSERPARAM3",
                              L"CIUSERPARAM4",
                              L"CIUSERPARAM5",
                              L"CIUSERPARAM6",
                              L"CIUSERPARAM7",
                              L"CIUSERPARAM8",
                              L"CIUSERPARAM9",
                              L"CIUSERPARAM10",
                                      };


//+-------------------------------------------------------------------------
//
//  Member:     CInternalQuery::CinternalQuery, public constructor
//
//  Arguments:  [rGetEnvVars]   - object that contains CGI env. variables
//              [rPList]        - property list of properties to query
//              [lcid]          - LCID (locale identifier)
//
//  Synopsis:   rGetEnvVars yields the textual restriction.
//              GetStringDbRestriction then converts it into a DbRestriction.
//
//--------------------------------------------------------------------------

CInternalQuery::CInternalQuery(
    CGetEnvVars&        rGetEnvVars,
    CEmptyPropertyList& rPList,
    LCID                lcid ):
_pDbRestriction(0),
_pISearch(0)
{
    TRY
    {
        _pDbRestriction = GetStringDbRestriction( rGetEnvVars.GetRestriction(),
                                                  rGetEnvVars.GetDialect(),
                                                  &rPList,
                                                  lcid);
    }
    CATCH( CException, e)
    {
        webDebugOut(( DEB_ERROR, "WEBHITS: failed to get DbRestriction\n" ));

        delete _pDbRestriction;
        RETHROW();
    }
    END_CATCH
}

void CInternalQuery::CreateISearch( WCHAR const * pwszPath )
{
    Win4Assert( 0 == _pISearch );
    SCODE sc = MakeISearch( &_pISearch, _pDbRestriction, pwszPath );
    if ( FAILED( sc ) )
        THROW( CException( sc ) );
} //CreateISearch


//+-------------------------------------------------------------------------
//
//  Member:     CURLUnescaper::CURLUnescaper public constructor
//
//--------------------------------------------------------------------------


CURLUnescaper::CURLUnescaper( UINT codePage ) :
    _codePage(codePage)
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CURLUnescaper::UnescapeAndConvertToUnicode
//
//  Synopsis:   Converts the given multi-byte string into a unicode string
//              based on the code page.  Decodes URL escape sequences along
//              the way.
//
//  Arguments:  [pszMbStr]   - smart array pointer to input string
//              [cch]        - length of input string
//              [xwcsBuffer] -
//
//  Returns:    Number of characters in target buffer, excluding the
//              terminating NULL.
//
//  History:    24 Nov 1997   AlanW      Created
//
//----------------------------------------------------------------------------

ULONG CURLUnescaper::UnescapeAndConvertToUnicode( char const * pszMbStr,
                                                  ULONG cch,
                                                  XArray<WCHAR> & xwcsBuffer )
{
    if ( xwcsBuffer.Get() == 0 || cch+1 > xwcsBuffer.Count() )
    {
        delete [] xwcsBuffer.Acquire();
        xwcsBuffer.Init( cch+1 );
    }

    DecodeURLEscapes( (BYTE *)pszMbStr,
                              cch,
                              xwcsBuffer.Get(),
                              _codePage );

    return cch;
}

//+-------------------------------------------------------------------------
//
//  Member:     CCollectVar::CCollectVar, public constructor
//
//  Arguments:  [rUnescaper]    - reference to an unescaper object - it will
//                                be used to unescape variables stored in
//                                the local buffer
//              [webServer]     - web server object from which variables
//                                are read.
//
//--------------------------------------------------------------------------

CCollectVar::CCollectVar(
    CURLUnescaper& rUnescaper,
    CWebServer &   webServer ):
_rUnescaper(rUnescaper),
_webServer( webServer ),
_xwcsBuffer(DEFAULT_BUFF_SIZE),
_cwcVarSize(0),
_xszBuffer(DEFAULT_BUFF_SIZE),
_cbVarSize(0)
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CCollectVar::GetEnvVar
//
//  Arguments:  [pwcsVariableName]  - the name of the variable to be retrieved
//
//  Synopsis:   Returns TRUE if the specified variable was retrieved and
//              FALSE otherwise.
//
//--------------------------------------------------------------------------

BOOL CCollectVar::GetEnvVar( CHAR const * pszVariableName)
{

    //
    // Prime to indicate that the WIDE-CHAR form of the string is
    // not valid anymore.
    //
    _cwcVarSize = 0;
    _cbVarSize = 0;

    //
    // Retrieve the variable as an ascii string
    //
    webDebugOut(( DEB_ITRACE, "WEBHITS: Getting environment variable\n" ));

    ULONG cb = _xszBuffer.Count();

    if ( ! _webServer.GetCGIVariable( pszVariableName,
                                      _xszBuffer.GetPointer(),
                                      & cb ) )
    {
        if ( cb > _xszBuffer.Count() )
        {
            //
            // have to re-size and incur the cost of the memory allocation
            //

            delete[] _xszBuffer.Acquire();
            _xszBuffer.Init( cb );
            if ( ! _webServer.GetCGIVariable( pszVariableName,
                                              _xszBuffer.GetPointer(),
                                              & cb ) )
                return FALSE;
        }
        else
        {
            return FALSE;
        }

    }

    _cbVarSize = cb;
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CCollectVar::UnescapeAndConvertToUnicode
//
//  Synopsis:   Unescapes the variable currently stored in _xszBuffer.
//
//--------------------------------------------------------------------------

inline void CCollectVar::UnescapeAndConvertToUnicode()
{
    //
    // Convert the multi-byte string into a UNICODE string.
    //
    _cwcVarSize = _rUnescaper.UnescapeAndConvertToUnicode( _xszBuffer.Get(),
                                                           _cbVarSize,
                                                           _xwcsBuffer );
}


//+-------------------------------------------------------------------------
//
//  Member:     CSmartByteArray::CSmartByteArray - public constructor
//
//  Synopsis:   allocates memory for the buffer
//--------------------------------------------------------------------------

CSmartByteArray::CSmartByteArray():
_xszBuffer(DEFAULT_BUFFER_SIZE)
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CSmartByteArray::CopyTo
//
//  Arguments:  [pwcText]    - pointer to text to be copied
//              [cwcToCopy]  - the number of characters to be copied
//
//  Synopsis:   copies the text pointed to by [pwcText] to the buffer,
//              enlarging it if necessary. A L'\0' is appended to the end
//              automatically, since this method is used to copy non-null
//              terminated strings.
//
//--------------------------------------------------------------------------

void CSmartByteArray::CopyTo(char * pszText, ULONG cbToCopy)
{
    //
    // if a buffer larger than the default one is being allocated, then
    // re-size it
    //

    if ( cbToCopy >= _xszBuffer.Count() )
    {
        delete[] _xszBuffer.Acquire();

        ULONG cbNew = max(2*_xszBuffer.Count(), cbToCopy+1);
        _xszBuffer.Init(cbNew);
    }

    RtlCopyMemory(_xszBuffer.GetPointer(),pszText,cbToCopy);

    // insert null terminator
    _xszBuffer[cbToCopy] = 0;
}


//+-------------------------------------------------------------------------
//
//  Member:     CQueryStringParser::CQueryStringParser, public constructor
//
//  Arguments:  [pwszQUERY_STRING]  - buffer in which the *ESCAPED*
//                                    QUERY_STRING is stored
//              [rUnescaper]        - ref. to unescaper object
//
//  Synopsis:   The QUERY_STRING must be passed in *ESCAPED* form, otherwise
//              it's difficult to say for example whether an ampersand delimits
//              consecutive variables or is part of the restriction
//
//--------------------------------------------------------------------------

CQueryStringParser::CQueryStringParser( char * pszQUERY_STRING,
                                        CURLUnescaper& rUnescaper):
_pszQS(pszQUERY_STRING),
_pszQSEnd(_pszQS+strlen(_pszQS)),
_pBeg(_pszQS),
_pEnd(_pszQSEnd),
_isNull(TRUE),
_rUnescaper(rUnescaper)
{
}


//+-------------------------------------------------------------------------
//
//  Member:     CQueryStringParser::FindVarEnd
//
//  Arguments:  [pwc]  - pointer to character at which to begin 'searching'
//                       for the end of the current variable assignment
//
//  Synopsis:   returns a pointer to the end of the variable assignment inside
//              of which pwc points - this is the next '&' if there are more
//              variable assignments following, or the terminating L'\0'
//              of QUERY_STRING if this is the last one.
//
//--------------------------------------------------------------------------

CHAR* CQueryStringParser::FindVarEnd(CHAR* psz)
{
    if (!psz)
        return NULL;

    while( (psz < _pszQSEnd) && *psz != '&')
        psz++;

    return psz;

}

//+-------------------------------------------------------------------------
//
//  Member:     CQueryStringParser::EatChar
//
//  Arguments:  [pwc]  - pointer to the character that is to be eaten
//
//  Synopsis:   If [pwc] points to the character before the null terminator
//              of the string, returns NULL. Otherwise, returns [pwc]+1.
//
//--------------------------------------------------------------------------

CHAR* CQueryStringParser::EatChar(char * psz)
{
   if (!psz)
       return NULL;

   psz++;
   if (*psz)
      return psz;
   else
      return NULL;
}

//+-------------------------------------------------------------------------
//
//  Member:     CQueryStringParser::EatVariableName
//
//  Arguments:  [pwc]  - pointer to the character at which to start eating
//
//  Synopsis:   Eat text until a '\0', whitespace, or '=' is encountered. If
//              a '\0' is encountered, return NULL, otherwise return a pointer
//              to the first non-blob character, where a blob character is
//              defined as anything except for whitespace, '\0', and '='.
//
//--------------------------------------------------------------------------

char * CQueryStringParser::EatVariableName(char * psz)
{
    if (!psz)
        return NULL;

    //
    // Note: this limits us to Ascii for variable names, which isn't
    // really a problem since we define all the variables.
    //

    while ( (*psz) && !isspace(*psz) && ('=' != *psz))
        psz++;

    if (*psz)
        return psz;

    return NULL;
} //EatVariableName

//+-------------------------------------------------------------------------
//
//  Member:     CQueryStringParser::ValidateArgument
//
//  Arguments:  [pwc]  - pointer to the character string to validate
//
//  Synopsis:   Returns the pointer if valid or 0 otherwise.
//
//--------------------------------------------------------------------------


char * CQueryStringParser::ValidateArgument(char * psz)
{
    if ( ( 0 == psz ) || ( 0 == *psz ) )
        return 0;

    return psz;
}


//+-------------------------------------------------------------------------
//
//  Member:     CQueryStringParser::NextVar
//
//  Synopsis:   Extract the next command-line variable contained
//              in QUERY_STRING. Returns TRUE if the next variable was
//              successfully extracted, and FALSE otherwise
//
//--------------------------------------------------------------------------

BOOL CQueryStringParser::NextVar()
{
    //
    // set the NULL flag
    //

    _isNull = TRUE;

    // we've hit the end of the buffer

    if (!_pBeg)
        return FALSE;

    // find the end of the variable assignment within the buffer
    _pEnd = FindVarEnd(_pBeg);

    if (!_pEnd || _pEnd == _pBeg)
    {
        THROW( CException(MSG_WEBHITS_QS_FORMAT_INVALID));
    }

    //
    // copy the chunk of the QUERY_STRING into the temporary buffer for
    // unescaping
    //
    _smartBuffer.CopyTo(_pBeg, (ULONG)(_pEnd-_pBeg));  // L'\0' appended
    //_rUnescaper.Unescape(_smartBuffer.GetXPtr(), _pEnd-_pBeg);

    // move to the variable name
    CHAR* pTemp1 = ValidateArgument( _smartBuffer.GetPointer() );

    if (!pTemp1)
    {
        THROW( CException(MSG_WEBHITS_QS_FORMAT_INVALID));
    }

    CHAR* pTemp2 = EatVariableName(pTemp1);

    if (!pTemp2)
    {
        THROW( CException(MSG_WEBHITS_QS_FORMAT_INVALID));
    }

    //
    // Convert the variable name into a Unicode string.
    //

    ULONG cbToConvert = (ULONG)(pTemp2-pTemp1) ;
    _rUnescaper.UnescapeAndConvertToUnicode( pTemp1, cbToConvert, _xwszVarName );

    // move to the equal sign

    pTemp1=ValidateArgument(pTemp2);

    if (!pTemp1 || (*pTemp1 != L'='))
    {
        THROW( CException(MSG_WEBHITS_QS_FORMAT_INVALID));
    }

    pTemp1 = EatChar(pTemp1);

    //
    // if not a null value keep on eating away
    //

    if (ValidateArgument(pTemp1))
    {
        // move to the variable value

        pTemp1 = ValidateArgument(pTemp1);
        if (!pTemp1)
        {
            THROW( CException(MSG_WEBHITS_QS_FORMAT_INVALID));
        }

        // get the variable value

        cbToConvert = strlen(pTemp1);

        _rUnescaper.UnescapeAndConvertToUnicode( pTemp1, cbToConvert, _xwszVarValue );
        //
        // if we got this far, the variable had a value
        //
        _isNull = FALSE;
    }
    else
    {
        //
        // null value - delete the string name
        //
        delete _xwszVarName.Acquire();
    }

     // advance to the next variable assignment
    if (_pEnd < _pszQSEnd)
    {
        _pBeg = ++_pEnd;
    }
    else
    {
        _pBeg = NULL;
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Member:     CGetEnvVars::CGetEnvVars(), public constructor
//
//  Arguments:  [webServer]     - web server to use
//              [langInfo]      - language-specific info
//              [rCollectVar]   - ref. to a variable-retrieving object
//              [rUnescaper]    - ref. to unescaper object
//
//  Synopsis:   The constructor retrieves the Filename, VPath, QUERY_STRING,
//              and Restriction.
//--------------------------------------------------------------------------

CGetEnvVars::CGetEnvVars(
    CWebServer & webServer,
    CLanguageInfo & langInfo,
    CCollectVar& rCollectVar,
    CURLUnescaper& rUnescaper ) :
_lcid(langInfo.GetUrlCodePage()),
_hiliteType(SUMMARY),
_rCollectVar( rCollectVar ),
_rUnescaper(rUnescaper),
_isBold(FALSE),
_isItalic(FALSE),
_isFixedFont(FALSE),
_ccFixedFontLine(1),
_xwc24BitColourMask(new WCHAR[8]),
_aUserParams(eMaxUserReplParams),
_langInfo( langInfo ),
_webServer( webServer ),
_dwWebHitsFileFlags( 0 ),
_dwQueryFileFlags( 0 ),
_dwTemplateFileFlags( 0 ),
_dialect( ISQLANG_V2 )
{

    for ( ULONG i = 0; i < eMaxUserReplParams; i++ )
        _aUserParams[i] = 0;

    wcscpy(_xwc24BitColourMask.GetPointer(),L"#FF0000");

    //
    //  We support only the GET and POST methods -- verify
    //

    BYTE * pszBuffer;
    ULONG  cbBuffer;

    if ( ( strcmp( webServer.GetMethod(), "GET" ) != 0 ) &&
         ( strcmp( webServer.GetMethod(), "POST" ) != 0 ) )
    {
        webDebugOut(( DEB_ERROR, "WEBHITS: invalid REQUEST_METHOD\n" ));

        THROW( CException(MSG_WEBHITS_REQUEST_METHOD_INVALID) );
    }

    XArray<WCHAR> xHTW;
    ULONG cwc;
    if ( webServer.GetCGI_PATH_INFO( xHTW, cwc ) )
    {
        webDebugOut(( DEB_ITRACE, "htw file: '%ws'\n", xHTW.GetPointer() ));

        // Allow null.htw files to not exist, in which case the file just
        // serves as a script map trigger with default formatting info.

        WCHAR *pwc = wcsrchr( xHTW.GetPointer(), L'/' );
        if ( ( 0 != pwc ) && ( _wcsicmp( pwc+1, NullHTWFile ) ) )
            _xwcsTemplateFileVPath.Set( xHTW.Acquire() );
    }

    //
    // retrieve and parse the command line - we store in the same
    // buffer in both places
    //

    RetrieveQueryString();

    ParseQUERY_STRING();
}

//+-------------------------------------------------------------------------
//
//  Member:     CGetEnvVars::ParseQUERY_STRING()
//
//  Synopsis:   parses QUERY_STRING for the various command-line parameters.
//              This method must be called AFTER RetrieveQueryString. If a
//              "crucial" variable remains unset at the end, an exception is
//              is thrown.
//
//--------------------------------------------------------------------------

void CGetEnvVars::ParseQUERY_STRING()
{
    webDebugOut(( DEB_ITRACE, "WEBHITS: parsing QS '%s'\n",
                  _xszQueryString.GetPointer() ));

    CQueryStringParser QSParser( _xszQueryString.GetPointer(), _rUnescaper );

    while(QSParser.NextVar())
    {
        XPtrST<WCHAR> xwcTempVarName;
        XPtrST<WCHAR> xwcTempVarValue;

        //
        // acquire the variable name and value from the parser, and hand it over to SetVar
        //
        if (!QSParser.IsNull())
        {
            QSParser.GetVarName(xwcTempVarName);
            QSParser.GetVarValue(xwcTempVarValue);

            SetVar(xwcTempVarName,xwcTempVarValue);
        }
    }

    VerifyQSVariablesComplete();
}

//+---------------------------------------------------------------------------
//
//  Member:     CGetEnvVars::IsUserParam
//
//  Synopsis:
//
//  Arguments:  [pwcsParam] -
//
//  Returns:
//
//  Modifies:
//
//  History:    9-10-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline ULONG CGetEnvVars::IsUserParam( const WCHAR * pwcsParam )
{

    if ( 0 == _wcsnicmp( pwcsParam, wcsUserParamPrefix, cwcUserParamPrefix) )
    {
        int i = _wtoi( pwcsParam+cwcUserParamPrefix );
        if ( i > 0 && i <= eMaxUserReplParams )
            return (ULONG) i;
        else return 0;
    }
    else
    {
        return 0;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CGetEnvVars::SetVar
//
//  Arguments:  [xwszVarName] - the name of the variable being set
//              [xwszVarValue]- the value it is being set to
//
//  Synopsis:   Sets the command-line variable [xwszVarName] to [xwszVarValue]
//              and throws if the variable name is invalid. The string
//              containing the variable name is deleted here, as is the
//              string containing the variable value if the latter is of no
//              use and should not be stored.
//
//--------------------------------------------------------------------------


void CGetEnvVars::SetVar(XPtrST<WCHAR>& xwszVarName,
                         XPtrST<WCHAR>& xwszVarValue)
{
    //
    // create local copies of the smart pointers, ensuring deletion at the end
    //

    XPtrST<WCHAR> xwszLocalVarName(xwszVarName.Acquire());
    XPtrST<WCHAR> xwszLocalVarValue(xwszVarValue.Acquire());

    webDebugOut(( DEB_ITRACE, "var '%ws', value '%ws'\n",
                  xwszLocalVarName.GetPointer(),
                  xwszLocalVarValue.GetPointer() ));

    if(_wcsicmp(xwszLocalVarName.GetPointer(),RestrictionVarName) == 0)
    {
        if ( 0 != _xwcsRestriction.GetPointer() )
            THROW( CException( MSG_WEBHITS_DUPLICATE_PARAMETER ) );

        _xwcsRestriction.Set(xwszLocalVarValue.Acquire());
    }
    else if (_wcsicmp(xwszLocalVarName.GetPointer(),HiliteTypeVarName) == 0)
    {
        if (_wcsicmp(xwszLocalVarValue.GetPointer(),L"full") == 0)
        {
            _hiliteType = FULL;
        }
    }
    else if (_wcsicmp(xwszLocalVarName.GetPointer(),IDQFilenameVarName) == 0)
    {
        if ( 0 != _xwcsQueryFileVPath.GetPointer() )
            THROW( CException( MSG_WEBHITS_DUPLICATE_PARAMETER ) );
        _xwcsQueryFileVPath.Set(xwszLocalVarValue.Acquire());
    }
    else if (_wcsicmp(xwszLocalVarName.GetPointer(),ColorVarName)==0)
    {
         if ( (*(xwszLocalVarValue.GetPointer()) == L'0') &&
              (wcslen(xwszLocalVarValue.GetPointer()) == 8))
         {
             //
             // a 24-bit colour spec is being passed in
             //
             RtlCopyMemory(_xwc24BitColourMask.GetPointer(),xwszLocalVarValue.GetPointer()+1,
                           sizeof(Red24BitMask));

             *(_xwc24BitColourMask.GetPointer())=L'#';
         }
         else if (_wcsicmp(xwszLocalVarValue.GetPointer(),L"red")==0)
         {
             RtlCopyMemory(_xwc24BitColourMask.GetPointer(),Red24BitMask,sizeof(Red24BitMask));
         }
         else if (_wcsicmp(xwszLocalVarValue.GetPointer(),L"blue")==0)
         {
             RtlCopyMemory(_xwc24BitColourMask.GetPointer(),Blue24BitMask,sizeof(Blue24BitMask));
         }
         else if (_wcsicmp(xwszLocalVarValue.GetPointer(),L"green")==0)
         {
             RtlCopyMemory(_xwc24BitColourMask.GetPointer(),Green24BitMask,sizeof(Green24BitMask));
         }
         else if (_wcsicmp(xwszLocalVarValue.GetPointer(),L"black")==0)
         {
             RtlCopyMemory(_xwc24BitColourMask.GetPointer(),Black24BitMask,sizeof(Black24BitMask));
         }
         else if (_wcsicmp(xwszLocalVarValue.GetPointer(),L"yellow")==0)
         {
             RtlCopyMemory(_xwc24BitColourMask.GetPointer(),Yellow24BitMask,sizeof(Yellow24BitMask));
         }
    }
    else if (_wcsicmp(xwszLocalVarName.GetPointer(),VPathWebHitsFile) == 0)
    {
        if ( 0 != _xwcsWebHitsFileVPath.GetPointer() )
            THROW( CException( MSG_WEBHITS_DUPLICATE_PARAMETER ) );

        _xwcsWebHitsFileVPath.Set(xwszLocalVarValue.Acquire());
    }
    else if (_wcsicmp(xwszLocalVarName.GetPointer(),BoldVarName) == 0)
    {
        _isBold=TRUE;
    }
    else if (_wcsicmp(xwszLocalVarName.GetPointer(),ItalicVarName)==0)
    {
        _isItalic=TRUE;
    }
    else if ( _wcsicmp(xwszLocalVarName.GetPointer(),MaxLineLength) == 0 )
    {
        _isFixedFont = TRUE;
        if ( xwszLocalVarValue.GetPointer() )
            _ccFixedFontLine = _wtoi( xwszLocalVarValue.GetPointer() );
        _ccFixedFontLine = max( _ccFixedFontLine, 1 );
    }
    else if ( _wcsicmp(xwszLocalVarName.GetPointer(),LocaleVar) == 0 )
    {
        //
        // Set the output and cirestriction locale info now.
        //
        if ( xwszLocalVarValue.GetPointer() )
        {
            if ( !_locale.IsNull() )
                delete _locale.Acquire();

            LCID lcid = GetLCIDFromString( xwszLocalVarValue.GetPointer() );
            _locale.Init(1+wcslen(xwszLocalVarValue.GetPointer()));
            wcscpy(_locale.GetPointer(), xwszLocalVarValue.GetPointer());

            //
            // The output will be generated using this codepage and for
            // interpretation of the "CiRestriction".
            //
            _langInfo.SetRestrictionLocale( lcid );
        }
    }
    else if ( _wcsicmp(xwszLocalVarName.GetPointer(), CodepageVar) == 0)
    {
        if (xwszLocalVarValue.GetPointer() )
        {
            if ( !_codepage.IsNull() )
                delete _codepage.Acquire();

            _codepage.Init(1+wcslen(xwszLocalVarValue.GetPointer()));
            wcscpy(_codepage.GetPointer(), xwszLocalVarValue.GetPointer());
        }
    }
    else if ( _wcsicmp(xwszLocalVarName.GetPointer(), DialectVar) == 0)
    {
        if ( xwszLocalVarValue.GetPointer() )
        {
            ULONG d = (ULONG) _wtoi( xwszLocalVarValue.GetPointer() );

            if ( d > ISQLANG_V2 || d < ISQLANG_V1 )
                THROW( CException( MSG_WEBHITS_INVALID_DIALECT ) );

            _dialect = d;
        }
    }
    else if ( _wcsicmp(xwszLocalVarName.GetPointer(),BeginHiliteVar) == 0 )
    {
        if ( 0 != _xwcsBeginHiliteTag.GetPointer() )
            THROW( CException( MSG_WEBHITS_DUPLICATE_PARAMETER ) );
#if 0 // security hole -- we can't display random html from users
        _xwcsBeginHiliteTag.Set(xwszLocalVarValue.Acquire());
#endif
    }
    else if ( _wcsicmp(xwszLocalVarName.GetPointer(),EndHiliteVar) == 0 )
    {
        if ( 0 != _xwcsEndHiliteTag.GetPointer() )
            THROW( CException( MSG_WEBHITS_DUPLICATE_PARAMETER ) );
#if 0 // security hole -- we can't display random html from users
        _xwcsEndHiliteTag.Set(xwszLocalVarValue.Acquire());
#endif
    }
    else
    {
        ULONG nUserParam = IsUserParam( xwszLocalVarName.GetPointer() );
        if ( nUserParam > 0 )
        {
            if ( 0 != _aUserParams[nUserParam-1] )
                THROW( CException( MSG_WEBHITS_DUPLICATE_PARAMETER ) );

            _aUserParams[nUserParam-1] = xwszLocalVarValue.Acquire();
        }
        else
        {
           //
           // the variable name is not recognized - throw. We don't need to
           // delete the strings as they are contained in smart pointers
           //

           webDebugOut((DEB_ERROR,"WEBHITS: bad variable name:%ws\n",
                         xwszLocalVarName.GetPointer() ));

           THROW(CException(MSG_WEBHITS_VARNAME_INVALID));
        }
    }

}

//+-------------------------------------------------------------------------
//
//  Member:     CGetEnvVars::VerifyQSVariablesComplete()
//
//  Synopsis:   Checks whether all the "crucial" variables that were to be
//              set as part of QUERY_STRING have been set, and throws an
//              exception otherwise.
//
//--------------------------------------------------------------------------


void CGetEnvVars::VerifyQSVariablesComplete()
{
    if(_xwcsRestriction.IsNull())
    {
        webDebugOut(( DEB_ERROR,
                      "WEBHITS: incomplete variable set read from QS\n" ));

        THROW(CException(MSG_WEBHITS_INVALID_QUERY));
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CGetEnvVars::RetrieveCONTENT_LENGTH
//
//  Synopsis:   retrieves and returns the  value of CONTENT_LENGTH,
//              and throws if unable to retrieve
//
//--------------------------------------------------------------------------


int CGetEnvVars::RetrieveCONTENT_LENGTH()
{
    if(!_rCollectVar.GetEnvVar("CONTENT_LENGTH"))
    {
        webDebugOut(( DEB_ERROR, "WEBHITS: failed to get CONTENT_LENGTH\n" ));

        return 0;

        THROW( CException(MSG_WEBHITS_CONTENT_LENGTH_INVALID) );
    }
    else
    {
        //
        // get the number of bytes
        //

        return _wtoi(_rCollectVar.GetVarValue());
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CGetEnvVars::RetrieveQueryString
//
//  Synopsis:   retrieves the value of QUERY_STRING, setting _xwcsQueryString
//              to point to it, and throws otherwise
//
//--------------------------------------------------------------------------

void CGetEnvVars::RetrieveQueryString()
{
    if(!_rCollectVar.GetEnvVar("QUERY_STRING"))
    {
        webDebugOut(( DEB_ERROR, "WEBHITS: failed to get QS\n" ));

        THROW( CException(MSG_WEBHITS_INVALID_QUERY) );
    }
    else
    {
        int cbToCopy  = _rCollectVar.GetMultiByteStrLen();

        //
        // we do not unescape QUERY_STRING to preserve delimiting information
        //
        _xszQueryString.Init(cbToCopy+1);

        RtlCopyMemory( _xszQueryString.GetPointer(),
                       _rCollectVar.GetMultiByteStr(),
                       cbToCopy );

        _xszQueryString[cbToCopy] = 0;
    }
}

//+-------------------------------------------------------------------------
//
//  function    GetLCID
//
//  Synopsis:   returns the locale in HTTP_ACCEPT_LANGUAGE, or if that one is
//              is not set, the one obtained from GetSystemDefaultLCID()
//
//--------------------------------------------------------------------------

LCID GetLCID( CWebServer & webServer )
{
    webDebugOut(( DEB_ITRACE,
                  "WEBHITS: Getting HTTP_ACCEPT_LANGUAGE variable\n" ));

    XArray<WCHAR> xBuffer;
    ULONG cwcBuffer;

    BOOL fOK = webServer.GetCGIVariableW( L"HTTP_ACCEPT_LANGUAGE",
                                          xBuffer,
                                          cwcBuffer );
    if ( !fOK )
    {
        LCID locale = GetSystemDefaultLCID();
        return locale;
    }

    LCID lcid = GetLCIDFromString( xBuffer.GetPointer() );
    if ( 0xFFFFFFFF == lcid )
        lcid = GetSystemDefaultLCID();

    return lcid;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetCodePageForCRunTimes
//
//  Synopsis:   Set the appropriate code page for the c-runtimes so that
//              swprintf, putchar, etc correctly translate the unicode into
//              the appropriate multi-byte sequence.
//
//  Arguments:  [codePage] - Code page of the client.
//
//  History:    9-06-96   srikants   Created
//
//----------------------------------------------------------------------------

UINT CLanguageInfo::SetCodePageForCRunTimes( UINT codePage )
{
    char szCodePage[20];

    sprintf( szCodePage,".%d", codePage );
    char * p = setlocale( LC_ALL, szCodePage );

    if ( 0 == p )
    {
        webDebugOut(( DEB_WARN,
                      "Could not set code page for %d\n. Going to system default",
                      codePage ));
        LCID lcid = GetSystemDefaultLCID();
        codePage = LocaleToCodepage( lcid );

        sprintf( szCodePage,".%d", codePage );
        char * p = setlocale( LC_ALL, szCodePage );
    }

    return codePage;
}

//+-------------------------------------------------------------------------
//
//  Member:     CSortQueryHits::Init()
//
//  Synopsis:   Initialization function for CSortQueryHits (need to do this
//              as a HitIter& is needed to fully construct this class).
//              creates array of positions sorted in order of occurrence
//              within the document (note that a position may occur several
//              times).
//
//--------------------------------------------------------------------------


void CSortQueryHits::Init()

{
    Win4Assert(0 == _aPosition);
    _positionCount = CountPositions();

    if (0 != _positionCount)
    {
        _aPosition = new Position[_positionCount];

        int iPosition=0;

        for (BOOL fOk=_rHitIter.FirstHit();fOk;fOk=_rHitIter.NextHit())
        {
            int posInHit=_rHitIter.GetPositionCount();
            for (int i=0;i<posInHit;i++)
                _aPosition[iPosition++] = _rHitIter.GetPosition(i);
        }

        Win4Assert(iPosition == _positionCount);
        qsort(_aPosition,_positionCount,sizeof(Position),&ComparePositions);
    }

}


//+-------------------------------------------------------------------------
//
//  Member:     CSortQueryHits::CountPositions()
//
//  Synopsis:   Count the total number of positions across all hits returned
//              by ISearch.
//
//--------------------------------------------------------------------------


int CSortQueryHits::CountPositions()

{
    int count=0;

    for (BOOL fOk = _rHitIter.FirstHit();fOk;fOk=_rHitIter.NextHit() )
    {
        count +=_rHitIter.GetPositionCount();
        webDebugOut(( DEB_ITRACE, "Count = %d\n", count ));
    }

    return count;
}


//+-------------------------------------------------------------------------
//
//  Member:     CLinkQueryHits::CLinkQueryHits, public constructor
//
//  Arguments:  [rInternalQuery]    - DbRestriction
//              [rGetEnvVars]       - object containing CGI env. variables
//              [rHttpOutput]       - HTTP output object
//              [cmsReadTimeout]    - Read timeout for IFilter on the doc
//              [lockSingleThreadedFilter] - lock for single-threaded filters
//              [propertyList]      - Properties to webhit
//              [ulDisplayScript]   - Flags for displaying scripts
//
//--------------------------------------------------------------------------


CLinkQueryHits::CLinkQueryHits(
    CInternalQuery &  rInternalQuery,
    CGetEnvVars &     rGetEnvVars,
    PHttpFullOutput&  rHttpOutput,
    DWORD             cmsReadTimeout,
    CReleasableLock & lockSingleThreadedFilter,
    CEmptyPropertyList &   propertyList,
    ULONG             ulDisplayScript ) :

_document( (WCHAR*) rGetEnvVars.GetWebHitsFilePPath(),
           BOGUS_RANK,
           rInternalQuery.GetISearchRef(),
           cmsReadTimeout,
           lockSingleThreadedFilter,
           propertyList,
           ulDisplayScript ),
_rGetEnvVars(rGetEnvVars),
_rInternalQuery(rInternalQuery),
_rHttpOutput(rHttpOutput),
_HitIter(),
_sortedHits(_HitIter),
_currentOffset(0),
_posIndex(0),
_tagCount(0),
_ccOutputBuffer(0)
{
    //
    // initialize the iterator
    //

    _HitIter.Init(&_document);
    _sortedHits.Init();

    //
    // set the total count of positions
    //

    _posCount = _sortedHits.GetPositionCount();

    //
    // if there are any positions, initialize the "next position" data members
    // to the first one
    //

    if (_posCount > 0)
    {
        Position    nextPos = _sortedHits.GetPosition(0);

        _nextBegOffset = nextPos.GetBegOffset();
        _nextEndOffset = nextPos.GetEndOffset();
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CLinkQueryHits::IsSeparatedBySpaces
//
//  Arguments:  [startOffset]    - beginning offset
//              [endOffset]      - ending offset
//
//  Synopsis:   returns TRUE if the positions in the current paragraph
//              determined by [startOffset] and [endOffset] are separated
//              by whitespace characters.
//
//  Note:       There is a maximum 'allowed' separation, beyond which
//              whitespace is considered significant.
//
//--------------------------------------------------------------------------

unsigned const ccSignificantWhitespace = 20;

BOOL CLinkQueryHits::IsSeparatedBySpaces(int startOffset, int endOffset)
{
    Win4Assert( startOffset <= endOffset );

    if (startOffset > endOffset)
        return FALSE;

    //
    // Small buffer for calls to GetStringTypeW
    //

    WORD awCharType[ccSignificantWhitespace];
    int len = endOffset - startOffset;

    if ( 0 == len )
        return TRUE;

    if ( len > ccSignificantWhitespace )
        return FALSE;

    const WCHAR* pStart = _document.GetPointerToOffset(startOffset);

    //
    // Check for whitespace
    //

    if ( !GetStringTypeW( CT_CTYPE1, pStart, len, awCharType ) )
    {
        webDebugOut(( DEB_ERROR, "GetStringType returned %d\n", GetLastError() ));
        return FALSE;
    }

    //
    // Only blanks are legal 'spaces'
    //

    for ( int i = 0; i < len; i++ )
    {
        if ( 0 == (awCharType[i] & C1_BLANK) )
            return FALSE;
    }

    return TRUE;

}

//+-------------------------------------------------------------------------
//
//  Member:     CLinkQueryHits::InsertLinks
//
//  Synopsis:   Hit highlight the document by inserting linked HTML tags
//
//--------------------------------------------------------------------------

void CLinkQueryHits::InsertLinks()
{

    if ( !_rHttpOutput.IsTemplateFilePresent() )
        _rHttpOutput.TagPosition(-1);

    _rHttpOutput.OutputFullHeader();

    //
    // Determine if this is a mainly text document.
    //
    if ( _rGetEnvVars.IsFixedFont() )
        _rHttpOutput.OutputPreformattedTag();

    ULONG eofOffset = _document.GetEOFOffset();

    if (_sortedHits.GetPositionCount() == 0)
    {
        //
        // There are no hits. Just render the whole text.
        //
         WCHAR*  pText = _document.GetWritablePointerToOffset(0);
        _rHttpOutput.OutputHttpText(pText,eofOffset);
    }
    else
    {
        BOOL openTag = FALSE;

        while(_currentOffset < (int) eofOffset)
        {
            WCHAR*  pText = _document.GetWritablePointerToOffset(_currentOffset);
            const ULONG cSectionSize = _nextBegOffset - _currentOffset;

            if ( cSectionSize > 0 )
            {
                _rHttpOutput.OutputHttpText(pText,cSectionSize);
                _currentOffset +=cSectionSize;

                if ( (int) eofOffset == _currentOffset )
                    break;

                pText+=cSectionSize;
            }

            const ULONG cHiliteSize = _nextEndOffset - _nextBegOffset;

            if ( cHiliteSize > 0 )
            {
                //
                // display the "<<" tag - if a tag is not already open
                //

                if (!openTag)
                {
                    _rHttpOutput.OutputLeftTag(_tagCount-1);
                    _rHttpOutput.TagPosition(_tagCount);
                    openTag = TRUE;
                }

                //
                // display the highlited position text
                //

                _rHttpOutput.OutputHilite(pText, cHiliteSize);
                _currentOffset += cHiliteSize;
                Win4Assert(_currentOffset == _nextEndOffset);
            }

            //
            // get the next distinct position
            //

            BOOL existsNextPosition = MoveToNextDifferentPosition();

            //
            // display the ">>" tag unless separated only by spaces or
            // last tag in doc in which case we have to make it point to the
            // top
            if ( !existsNextPosition )
            {
                if ( openTag )
                {
                    _rHttpOutput.OutputRightTag(-1);
                    openTag = FALSE;
                }

                _nextBegOffset = _nextEndOffset = eofOffset;
            }
            else if ( openTag && !IsSeparatedBySpaces(_currentOffset,_nextBegOffset) )
            {
                _rHttpOutput.OutputRightTag(_tagCount+1);
                _tagCount++;
                openTag = FALSE;
            }
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CExtractedHit::CExtractedHit, public constructor
//
//  Arguments:  [rDocument]    - ref. to document being hilited
//                              [rHit]         - ref. to hit being hilited
//              [rOutput]      - ref. to Http Output object
//              [cwcMargin]    - number of chars. to be printed before and
//                               after the hit
//              [cwcSeparation]- maximum number of characters that may
//                               separate consecutive positions before
//                               truncation occurs
//              [cwcDelim]     - the number of characters to print before and
//                               after a position in the case of truncation
//--------------------------------------------------------------------------


CExtractedHit::CExtractedHit(   CDocument& rDocument,
                                Hit& rHit,
                                PHttpOutput& rOutput,
                                int cwcMargin,
                                int cwcSeparation,
                                int cwcDelim ):

_rDocument(rDocument),
_rHit(rHit),
_cwcMargin(cwcMargin),
_rOutput(rOutput),
_cwcSeparation(cwcSeparation),
_cwcDelim(cwcDelim),
_cwcOutputBuffer(0)
{
   SortHit();
}

//+-------------------------------------------------------------------------
//
//  Member:     CExtractedHit::SortHit()
//
//  Synopsis:   Sort the positions in the hit in the order in which they occur
//              in the document
//
//--------------------------------------------------------------------------


void CExtractedHit::SortHit()
{
   qsort( _rHit._aPos,
          _rHit.GetPositionCount(),
          sizeof(Position),
          &ComparePositions );
}

//+-------------------------------------------------------------------------
//
//  Member:     CExtractedHit::DisplayPosition
//
//  Arguments:  [rPos]  - ref. to position being displayed
//
//  Synopsis:   Display the highlighted position (i.e. JUST the position)
//
//--------------------------------------------------------------------------

void CExtractedHit::DisplayPosition(const Position& rPos)
{
    const WCHAR* pText = _rDocument.GetPointerToOffset(rPos.GetBegOffset());
    _rOutput.OutputHilite(pText,rPos.GetLength());
}

//+-------------------------------------------------------------------------
//
//  Member:     CExtractedHit::ExtractHit()
//
//  Synopsis:   Extract the hit - i.e. display all of the positions and
//              the associated preamble/postamble text
//
//--------------------------------------------------------------------------

void CExtractedHit::ExtractHit()
{
    //
    // make sure that we are not dealing with a null hit - i.e. a hit composed
    // entirely of null positions

    if (_rHit.IsNullHit())
        return;

    // stores the number of positions in the hit

    int cPositions = _rHit.GetPositionCount();

    //
    // introduce new paragraph
    //

    _rOutput.OutputParaTag();
    _rOutput.OutputEllipsis();

    //
    // go through displaying each position
    //

    //
    // find the first non-null position in the hit
    //

    int firstRealPos = EatNullPositions();

    //
    // display the preamble
    //

    PrintPreamble(_rHit.GetPos(firstRealPos),_cwcMargin);

    //
    // display the positions and the stuff in between the positions
    //

    for (int i=firstRealPos;i < cPositions; i++)
    {
        DisplayPosition(_rHit.GetPos(i));

        // the stuff between consecutive positions

        if (i != cPositions - 1)
        {
            //
            // guard against the case where multiple identical positions are
            // returned as part of the same hit
            //


            if (_rHit.GetPos(i).GetBegOffset() <
                    _rHit.GetPos(i+1).GetBegOffset())
            {
                PrintBtwPositions(_rHit.GetPos(i),_rHit.GetPos(i+1));
            }
            else
            {
                while ( ( i != ( cPositions - 1 ) ) &&
                        ( _rHit.GetPos(i).GetBegOffset() ==
                          _rHit.GetPos(i+1).GetBegOffset() ) )
                    i++;
            }
        }
    }

    //
    // display the postamble
    //

    PrintPostamble(_rHit.GetPos(cPositions-1),_cwcMargin);

    _rOutput.OutputEllipsis();
    _rOutput.OutputHRULE();
} //ExtractHit

//+-------------------------------------------------------------------------
//
//  Member:     CExtractedHit::ComputeDistance
//
//  Arguments:  [rStartPos] - ref. to starting position
//              [rEndPos]   - ref. to end position
//
//  Synopsis:   Compute the distance in characters between the start and
//              end positions
//
//--------------------------------------------------------------------------


ULONG CExtractedHit::ComputeDistance (const Position& rStartPos,
    const Position& rEndPos)
{
    return rEndPos.GetBegOffset() - rStartPos.GetEndOffset();
}

//+-------------------------------------------------------------------------
//
//  Member:     CExtractedHit::PrintPreamble
//
//  Arguments:  [rStartPosition] - ref. to start position
//              [cwcDist]        - maximum number of characters to print
//
//
//  Synopsis:   Prints the context text preceding the hit - the number of
//              characters printed depends on cwcDist. The break is made
//              at a word boundary
//
//--------------------------------------------------------------------------

void CExtractedHit::PrintPreamble(const Position& rStartPosition,int cwcDist)
{

    WCHAR* pBeg = _rDocument.GetWritablePointerToOffset(
                                        rStartPosition.GetBegOffset()-cwcDist);
    const WCHAR* pEnd = _rDocument.GetPointerToOffset(
                                        rStartPosition.GetBegOffset());

    // Boundary case - if the beginning of the document, don't skip any thing
    if ( pBeg != _rDocument.GetPointerToOffset(0) )
    {
        while( (pBeg < pEnd) &&
               !iswspace(*pBeg) &&
               !(UNICODE_PARAGRAPH_SEPARATOR == *pBeg))
            pBeg++;
    }

    Win4Assert(pBeg <= pEnd);
    _rOutput.OutputHttpText(pBeg, CiPtrToUlong( pEnd-pBeg ));
} //PrintPreamble

//+-------------------------------------------------------------------------
//
//  Member:     CExtractedHit::PrintPostamble
//
//  Arguments:  [rStartPosition] - ref. to start position
//              [cwcDist]        - maximum number of characters to be printed
//
//  Synopsis:   Print the context text following the hit - the number of
//              characters printed depends on cwcDist. The break is made
//              at a word boundary
//
//--------------------------------------------------------------------------

void CExtractedHit::PrintPostamble(const Position& rStartPosition, int cwcDist)
{

    WCHAR* pBeg = _rDocument.GetWritablePointerToOffset(
                                         rStartPosition.GetEndOffset());
    const WCHAR*  pEnd = _rDocument.GetPointerToOffset(
                                         rStartPosition.GetEndOffset()+cwcDist);

    while( (pEnd > pBeg) &&
           !iswspace(*pEnd) &&
           !(UNICODE_PARAGRAPH_SEPARATOR == *pEnd) )
        pEnd--;

    Win4Assert(pEnd >= pBeg);

    _rOutput.OutputHttpText( pBeg, CiPtrToUlong( pEnd-pBeg ));
} //PrintPostamble

//+-------------------------------------------------------------------------
//
//  Member:     CExtractedHit::PrintBtwPositions
//
//  Arguments:  [rStartPosition] - ref. to start position
//              [rEndPosition]   - ref. to end position
//
//  Synopsis:   Display the text between the two positions, breaking at word
//              boundaries. If the positions are separated by a distance
//              greated than _cwcSeparation, then the text in-between is
//              truncated, and up to _cwcDelim characters after the first and
//              before the second position are printed, separated by an
//              ellipsis
//
//--------------------------------------------------------------------------

void CExtractedHit::PrintBtwPositions(  const Position& rStartPosition,
                                        const Position& rEndPosition)
{

    long dist;

    if ((dist=ComputeDistance(rStartPosition,rEndPosition)) > _cwcSeparation)
    {
        PrintPostamble(rStartPosition,_cwcDelim);
        _rOutput.OutputEllipsis();
        PrintPreamble(rEndPosition,_cwcDelim);
    }
    else
    {
        WCHAR* pText = _rDocument.GetWritablePointerToOffset(
            rStartPosition.GetEndOffset() );

        _rOutput.OutputHttpText(pText,dist);
    }
} //PrintBtwPositions

//+-------------------------------------------------------------------------
//
//  Member:     CExtractedHits::ExtractHits
//
//  Arguments:  same as CExtractHit constructor, except rHitIter - a hit
//              iterator replaces the hit reference
//
//  Synopsis:   Class functor to encapsulate the action of highliting the
//              hits in rHitIter. A temporary CExtractHit object is created
//              for each hit.
//
//--------------------------------------------------------------------------

CExtractHits::CExtractHits(CDocument& rDocument,
                           HitIter& rHitIter,
                           PHttpOutput& rOutput,
                           int cwcMargin,
                           int cwcDelim,
                           int cwcSeparation )

{
    for (BOOL fOK=rHitIter.FirstHit(); fOK; fOK = rHitIter.NextHit())
    {
        CExtractedHit extractedHit( rDocument,
                                    rHitIter.GetHit(),
                                    rOutput,
                                    cwcMargin,
                                    cwcDelim,
                                    cwcSeparation );
        extractedHit.ExtractHit();
    }
} //CExtractHits

//+-------------------------------------------------------------------------
//
//  Member:     PHttpOutput::PHttpOutput - public constructor
//
//  Arguments:  [webServer] -- The web server to write to
//              [langInfo]  -- Language information
//
//--------------------------------------------------------------------------

PHttpOutput::PHttpOutput(
    CWebServer & webServer,
    CLanguageInfo & langInfo ):
_hasPrintedHeader(FALSE),
_xwc24BitColourMask(new WCHAR[8]),
_isBold(FALSE),
_isItalic(FALSE),
_isInPreformat(FALSE),
_newLine(FALSE),
_cwcOutputBuffer(0),
_pGetEnvVars(NULL),
_pTemplate(NULL),
_fUseHiliteTags(FALSE),
_cwcBeginHiliteTag(0),
_cwcEndHiliteTag(0),
_webServer( webServer ),
_langInfo( langInfo )
{
    wcscpy(_xwc24BitColourMask.GetPointer(),L"#FF0000");

    _mbStr.Init( MAX_OUTPUT_BUF );
}

//+---------------------------------------------------------------------------
//
//  Member:     PHttpOutput::Init
//
//  Synopsis:   Initializes the output generation class with the environment
//              variables object and the template object.
//
//  Arguments:  [pGetEnvVars] - Pointer to the object that has the relevant
//              environment variables.
//              [pTemplate]   - [OPTIONAL] - Pointer to the template object.
//              If non-zero, this will be used to generate the output for
//              hit-highlighter.
//
//  History:    9-09-96   srikants   Created
//
//----------------------------------------------------------------------------

void PHttpOutput::Init(CGetEnvVars* pGetEnvVars, CWebhitsTemplate * pTemplate )
{
    Win4Assert( 0 != pGetEnvVars );

    delete[] _xwc24BitColourMask.Acquire();
    _pGetEnvVars = pGetEnvVars;
    _xwc24BitColourMask.Set(_pGetEnvVars->GetColour().Acquire());
    _isItalic = _pGetEnvVars->GetItalic();
    _isBold  = _pGetEnvVars->GetBold();

    _ccCurrLine = 0;
    _ccMaxLine = _pGetEnvVars->GetFixedFontLineLen();

    _pTemplate = pTemplate;

    _fUseHiliteTags = _pGetEnvVars->GetBeginHiliteTag() &&
                      _pGetEnvVars->GetEndHiliteTag();
    if ( _fUseHiliteTags )
    {
        _cwcBeginHiliteTag = wcslen( _pGetEnvVars->GetBeginHiliteTag() );
        _cwcEndHiliteTag = wcslen( _pGetEnvVars->GetEndHiliteTag() );
    }

}

#define WCHAR_COUNT(x) ( (sizeof(x)/sizeof(WCHAR))-1 )

//+-------------------------------------------------------------------------
//
//  Member:     PHttpOutput::OutputHtmlHeader()
//
//  Synopsis:   Output the HTML header
//
//--------------------------------------------------------------------------


void PHttpOutput::OutputHTMLHeader()
{

    if ( 0 == _pTemplate || !_pTemplate->DoesHeaderExist() )
    {
        WCHAR* pwszTemp;

        static const WCHAR wszHdr1[] = L"HTTP/1.0 200 OK\r\nContent-Type: text/html\r\n\r\n<HTML>\n<HEAD>\n";
        static const ULONG ccHdr1 = WCHAR_COUNT(wszHdr1);
        OutputHttp( wszHdr1, ccHdr1 );

        static const WCHAR wszHdr2[] = L"<TITLE>Query Results</TITLE>\n</HEAD>\n";
        static const ULONG ccHdr2 = WCHAR_COUNT(wszHdr2);
        OutputHttp( wszHdr2, ccHdr2 );

        static const WCHAR wszHdr3[] =  L"<H2>\"";
        static const ULONG ccHdr3 = WCHAR_COUNT(wszHdr3);
        OutputHttp( wszHdr3, ccHdr3 );

        pwszTemp = (WCHAR*) _pGetEnvVars->GetRestriction();
        OutputHttpText(pwszTemp, wcslen(pwszTemp));

        static const WCHAR wszHdr4[] = L"\" in </H2>\n";
        static const ULONG ccHdr4 = WCHAR_COUNT( wszHdr4 );
        OutputHttp( wszHdr4, ccHdr4 );

        static const WCHAR wszHdr5[] = L"<H2><a href=\"";
        static const ULONG ccHdr5 = WCHAR_COUNT(wszHdr5);
        OutputHttp( wszHdr5, ccHdr5 );

        pwszTemp = (WCHAR*) _pGetEnvVars->GetWebHitsFileVPath();
        OutputHttp(pwszTemp,wcslen(pwszTemp));

        static const WCHAR wszHdr6[] = L"\">";
        static const ULONG ccHdr6 = WCHAR_COUNT(wszHdr6);
        OutputHttp( wszHdr6, ccHdr6 );

        OutputHttpText(pwszTemp,wcslen(pwszTemp));

        static const WCHAR wszHdr7[] = L"</a> </H2><P><HR>\n<BODY>";
        static const ULONG ccHdr7 = WCHAR_COUNT(wszHdr7);
        OutputHttp( wszHdr7, ccHdr7 );
    }
    else
    {
        static const WCHAR wszHdr8[] = L"HTTP/1.0 200 OK\r\nContent-Type: text/html\r\n\r\n";
        static const ULONG ccHdr8 = WCHAR_COUNT(wszHdr8);
        OutputHttp( wszHdr8, ccHdr8 );

        CVirtualString  str;
        _pTemplate->GetWTXFile().GetHeader( str, _pTemplate->GetVariableSet() );
        OutputHttp( str.Get(), str.StrLen() );
    }

    _hasPrintedHeader = TRUE;
} //OutputHTMLHeader

//+-------------------------------------------------------------------------
//
//  Member:     PHttpOutput::OutputHtmlFooter
//
//  Synopsis:   Output HTML footer
//
//--------------------------------------------------------------------------


void PHttpOutput::OutputHTMLFooter()
{
    if ( _isInPreformat )
    {
        static const WCHAR wszTag1[] = L"</pre>";
        static const ULONG ccTag1 = WCHAR_COUNT( wszTag1 );
        OutputHttp( wszTag1, ccTag1 );
    }

    if ( 0 == _pTemplate || !_pTemplate->DoesFooterExist() )
    {
        static const WCHAR wszTag2[] = L"</BODY>\n </HTML>";
        static const ULONG ccTag2 = WCHAR_COUNT( wszTag2 );
        OutputHttp( wszTag2, ccTag2 );
    }
    else
    {
        CVirtualString  str;
        _pTemplate->GetWTXFile().GetFooter( str,
                                           _pTemplate->GetVariableSet() );
        OutputHttp( str.Get(), str.StrLen() );
    }
} //OutputHTMLFooter

//+-----------------------------------------------------------------------
//
// Member:    PHttpOutput::OutputHilite()
//
// Arguments: [pwszBuffer]      - pointer to the buffer to be output highlited
//            [cwcBuffLength]   - number of characters to print from the buff.
//
// Synopsis:  Output the buffer in highlited form
//
//+-----------------------------------------------------------------------
void PHttpOutput::OutputHilite(const WCHAR* pwszBuffer, ULONG cwcBuffLength)
{
    if ( !_fUseHiliteTags )
    {
        WCHAR wcsColourCodeEnd[] = L"</font>";
        WCHAR wcsColourTag[50];
        swprintf(wcsColourTag,L"<font color=\"%s\">",_xwc24BitColourMask.GetPointer());

        static const WCHAR wcsBoldBegin[]=L"<B>";
        static const cwcBoldBegin = wcslen( wcsBoldBegin );

        static const WCHAR wcsItalicBegin[]=L"<em>";
        static const cwcItalicBegin = wcslen( wcsItalicBegin );

        static const WCHAR wcsBoldEnd[]=L"</B>";
        static const cwcBoldEnd = wcslen(wcsBoldEnd);

        static const WCHAR wcsItalicEnd[]=L"</em>";
        static const cwcItalicEnd=wcslen(wcsItalicEnd);

        if (_isBold)
        {
            OutputHttp( wcsBoldBegin,cwcBoldBegin);
        }
        if (_isItalic)
        {
            OutputHttp( wcsItalicBegin, cwcItalicBegin);
        }

        OutputHttp(wcsColourTag,wcslen(wcsColourTag));
        OutputHttp(pwszBuffer,cwcBuffLength);
        OutputHttp(wcsColourCodeEnd,wcslen(wcsColourCodeEnd));

        if (_isItalic)
        {
            OutputHttp( wcsItalicEnd, cwcItalicEnd );
        }
        if (_isBold)
        {
            OutputHttp( wcsBoldEnd, cwcBoldEnd );
        }
    }
    else
    {
        OutputHttp( _pGetEnvVars->GetBeginHiliteTag(), _cwcBeginHiliteTag );
        OutputHttp( pwszBuffer,cwcBuffLength );
        OutputHttp( _pGetEnvVars->GetEndHiliteTag(), _cwcEndHiliteTag );
    }
} //OutputHilite

//+-----------------------------------------------------------------------
//
// Member:    PHttpOutput::OutputLeftTag()
//
// Arguments: [tagParam]   - integer to be used in setting destination tag
//
// Synopsis:  Output the "<<" tag, making it refer to "Tag[tagParam]"
//
//+-----------------------------------------------------------------------


void PHttpOutput::OutputLeftTag(int tagParam)
{

    _cwcOutputBuffer = swprintf(_wcOutputBuffer,L"%s\"%s%d\"%s",
                    L"<a href=",L"#CiTag",tagParam,L">&lt;&lt;</a>");
    OutputHttp(_wcOutputBuffer,_cwcOutputBuffer);
}

//+-----------------------------------------------------------------------
//
// Member:    PHttpOutput::OutputRightTag()
//
// Arguments: [tagParam]    - integer to be used in setting destination tag
//
// Synopsis:  Output the ">>" tag, making it refer to "Tag[tagParam]"
//
//+-----------------------------------------------------------------------


void PHttpOutput::OutputRightTag(int tagParam)
{
    _cwcOutputBuffer = swprintf(_wcOutputBuffer, L"%s\"%s%d\"%s",L"<a href=",
                            L"#CiTag", tagParam, L">&gt;&gt;</a>&nbsp;");
    OutputHttp(_wcOutputBuffer,_cwcOutputBuffer);
}

//+-----------------------------------------------------------------------
//
// Member:    PHttpOutput::OutputEllipsis()
//
// Synopsis:  Output the ellipsis that separates the truncated text between
//            two consecutive positions
//
//+-----------------------------------------------------------------------


void PHttpOutput::OutputEllipsis()
{
    OutputHttp(L" ... ",5);
}

//+-----------------------------------------------------------------------
//
// Member:    PHttpOutput::OutputFullHeader()
//
// Synopsis:  Output the additional header information specific to the
//            full hit-highliting
//
//+-----------------------------------------------------------------------

void PHttpFullOutput::OutputFullHeader()
{
    if ( 0 == _pTemplate || !_pTemplate->DoesHeaderExist() )
    {
        _cwcOutputBuffer = swprintf(_wcOutputBuffer,
                L"%s\"%s\"%s %s %s\"%s\"%s",
                L"<h3><b> <font color=",
                L"#FF0000",
                L">",
                L"&lt;&lt; </font> takes you to the previous hit. ",
                L"<font color=",L"#FF0000",
                L"> &gt;&gt; </font> takes you to the next hit.</b></h3><P>\n");

        OutputHttp(_wcOutputBuffer,_cwcOutputBuffer);

        _cwcOutputBuffer = swprintf(_wcOutputBuffer, L"%s\"%s\"%s %s",
                L"<b>Click <a href=",L"#CiTag0",
                L"> &gt;&gt; </a> to go to the first hit</b>\n", L"<HR>\n" );


        OutputHttp(_wcOutputBuffer, _cwcOutputBuffer);
    }
} //OutputFullHeader

//+---------------------------------------------------------------------------
//
//  Member:     PHttpOutput::WriteToStdout
//
//  Synopsis:
//
//  Arguments:  [pwcsBuffer] - the buffer
//              [cLength]    - count of wide characters
//
//  History:    11-15-96   srikants   Created
//
//----------------------------------------------------------------------------

void PHttpOutput::WriteToStdout( WCHAR const * pwcsBuffer, ULONG cLength )
{
    if ( 0 != cLength )
        _vsResult.StrCat( pwcsBuffer, cLength );
} //WriteToStdout

//+---------------------------------------------------------------------------
//
//  Member:     PHttpOutput::Flush
//
//  Synopsis:   Flushes the buffer to the web server
//
//  History:    10-10-97   dlee   Created
//
//----------------------------------------------------------------------------

void PHttpOutput::Flush()
{
    if ( 0 != _vsResult.StrLen() )
    {
        DWORD cbToWrite = WideCharToXArrayMultiByte(
                            _vsResult.Get(),
                            _vsResult.StrLen(),
                            _langInfo.GetOutputCodePage(),
                            _mbStr );

        if ( 0 != cbToWrite )
            _webServer.RawWriteClient( _mbStr.Get(), cbToWrite );

        _vsResult.Empty();
    }
} //Flush

//+---------------------------------------------------------------------------
//
//  Member:     PHttpOutput::OutputPreformattedTag
//
//  Synopsis:   Outputs the pre-formatted tag if not already emitted.
//
//----------------------------------------------------------------------------


void PHttpOutput::OutputPreformattedTag()
{
    if ( !_isInPreformat )
    {
        static WCHAR wszTag[] = L"<pre>";
        static const len = ( sizeof(wszTag)/sizeof(WCHAR) ) - 1;

        WriteToStdout( wszTag, len );

        _isInPreformat = TRUE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     PHttpOutput::OutputPreFormatRawText
//
//  Synopsis:   Outputs the text for pre-formatted type.
//
//  Arguments:  [pwcsBuffer] -
//              [cLength]    -
//
//  History:    11-15-96   srikants   Created
//
//----------------------------------------------------------------------------

void PHttpOutput::OutputPreFormatRawText( const WCHAR * pwcsBuffer,
                                          ULONG cLength )
{
    Win4Assert( _isInPreformat );

    WCHAR const * pwcsCurrLineBegin = pwcsBuffer;

    for ( ULONG i=0, cwcToWrite = 0;
          i< cLength;
          i++ )
    {
        if ( IsNewLine( pwcsBuffer[i] ) )
        {
            //
            // Empty out the current line - as much as has been
            // accumulated.
            //
            WriteToStdout( pwcsCurrLineBegin, cwcToWrite );
            WriteNewline();


            if ( pwcsBuffer[i] == '\r' && pwcsBuffer[i+1] == '\n' )
                i++;

            _ccCurrLine = cwcToWrite = 0;
            pwcsCurrLineBegin = pwcsBuffer+i+1;  // Position at the next character
        }
        else
        {
            //
            // Include this character in the current line.
            //
            cwcToWrite++;

            //
            // _ccCurrLine is cumulative from multiple invocations.
            //
            _ccCurrLine++;

            if ( _ccCurrLine > _ccMaxLine && iswspace( pwcsBuffer[i] ) )
            {
                //
                // Write out the line and force a line feed.
                //

                WriteToStdout( pwcsCurrLineBegin, cwcToWrite );
                WriteNewline();

                pwcsCurrLineBegin += cwcToWrite;
                Win4Assert( pwcsCurrLineBegin == pwcsBuffer+i+1 );
                _ccCurrLine = cwcToWrite = 0;
            }
        }
    }

    WriteToStdout( pwcsCurrLineBegin, cwcToWrite );
} //OutputPreFormatRawText

void PHttpOutput::WriteNewline()
{
    static WCHAR wcNewLine[] = L"\r\n";
    static const len = (sizeof(wcNewLine)/sizeof(WCHAR))-1;

    WriteToStdout( wcNewLine, len );
}

void PHttpOutput::WriteBreakTag()
{
    static WCHAR wcBreakTag[] = L"<BR>";
    static const len = (sizeof(wcBreakTag)/sizeof(WCHAR)) - 1;

    WriteToStdout( wcBreakTag, len );
}

//+-----------------------------------------------------------------------
//
// Member:  PHttpOutput::OutputHttp
//
// Arguments:   [pwcsBuffer] - pointer to buffer containing text
//              [cLength]    - the number of characters to print
//              [fRawText]   - if TRUE, convert cr, lf and paragraph
//                                  mark to <BR> or newline
//
// Synopsis: Encapsulates the output operation - for now, writes to stdout
//
//+-----------------------------------------------------------------------


void PHttpOutput::OutputHttp( const WCHAR* pwcsBuffer, ULONG cLength,
                              BOOL fRawText )
{
    if ( !fRawText )
    {
        //
        // This is HTML header or footer or formatting. No need to
        // introduce <BR> tags for new-lines and paragraphs.
        //
        WriteToStdout( pwcsBuffer, cLength );
        return;
    }
    else if ( _isInPreformat )
    {
        //
        // We can emit cr-lf as cr-lf. No need to convert to <BR> tags.
        // However, we have to respect the max-line length.
        //
        OutputPreFormatRawText( pwcsBuffer, cLength );
        return;
    }

    //
    // We must output raw text that is not pre-formatted. We have to
    // convert the newlines, paragraph separators to BreakTags.
    //
    WCHAR const * pwcsCurrLineBegin = pwcsBuffer;

    for ( ULONG i=0, cwcToWrite = 0;
          i< cLength;
          i++ )
    {
        if ( IsNewLine( pwcsBuffer[i] ) )
        {
            WriteToStdout( pwcsCurrLineBegin, cwcToWrite );
            WriteBreakTag();

            if ( pwcsBuffer[i] == '\r' && pwcsBuffer[i+1] == '\n' )
                i++;

            cwcToWrite = 0;
            pwcsCurrLineBegin = pwcsBuffer+i+1;
        }
        else
        {
            cwcToWrite++;
        }
    }

    WriteToStdout( pwcsCurrLineBegin, cwcToWrite );
} //OutputHttp

//+-----------------------------------------------------------------------
//
// Member:    PHttpOutput::OutputErrorHeader()
//
// Synopsis:  Output an "ERROR" header
//
//+-----------------------------------------------------------------------

void PHttpOutput::OutputErrorHeader()
{
    static const WCHAR wszHdr[] = L"HTTP/1.0 200 OK \r\nContent-Type: text/html\r\n\r\n<HTML>\n<BODY>\n";
    static const ULONG ccHdr = WCHAR_COUNT( wszHdr );
    OutputHttp( wszHdr, ccHdr  );
}

//+-----------------------------------------------------------------------
//
// Member:    PHttpOutput::OutputErrorMessage
//
// Synopsis:  Send error message to stdout / web page
//
// Arguments: [pwcsBuffer] -- Error message
//            [ccBuffer]   -- Size in characters of [pwcsBuffer]
//
// History:   31-Jul-97    KyleP   Added header
//
//+-----------------------------------------------------------------------

void PHttpOutput::OutputErrorMessage( WCHAR * pwcsBuffer, ULONG ccBuffer )
{
    static const WCHAR wszTag1[] = L"<p><h3><center>";
    static const ULONG ccTag1 = WCHAR_COUNT( wszTag1 );
    OutputHttp( wszTag1, ccTag1 );

    OutputHttpText( pwcsBuffer, ccBuffer );

    static const WCHAR wszTag2[] = L"</center></h3><BR>";
    static const ULONG ccTag2 = WCHAR_COUNT( wszTag2 );
    OutputHttp( wszTag2, ccTag2 );
}

//+-----------------------------------------------------------------------
//
// Member:    PHttpOutput::TagPosition
//
// Arguments: [tagParam] - output a <NAME="Tag[tagParam]"> tag
//
// Synopsis:  Tag the current position
//
//+-----------------------------------------------------------------------


void PHttpOutput::TagPosition(int tagParam)
{
    _cwcOutputBuffer= swprintf(_wcOutputBuffer,L"%s\"%s%d\"%s",
                            L"<a NAME=",L"CiTag",tagParam,L"> </a>");

    OutputHttp(_wcOutputBuffer,_cwcOutputBuffer);
}

//+---------------------------------------------------------------------------
//
//  Member:     PHttpOutput::OutputHttpText
//
//  Synopsis:   Outputs the given data as "text" and not as html formatting.
//
//  Arguments:  [pwcsBuffer] - buffer to be output
//              [cchLength]  - length of pwcsBuffer
//
//  Notes:      Any UNICODE_PARAGRAPH_SEPARATOR characters in the buffer
//              need to be preserved for use by OutputHttp
//
//  History:    9-09-96   srikants   Created
//
//----------------------------------------------------------------------------

void PHttpOutput::OutputHttpText( WCHAR * pwcsBuffer, ULONG cchLength )
{
    if ( cchLength > 0 )
    {
        //
        // NOTE - HTMLEscapeW expects the string to be NULL terminated. It
        // does not accept a length field. HTMLEscapeW is one of the most
        // frequently executed routines in idq.dll and so changing it to
        // optionally take in a length parameter may affect performance.
        // That is why I have chosen to overwrite the current buffer with
        // a NULL at cchLength and restore it after the escaping - srikants.
        //
        const WCHAR wcTemp = pwcsBuffer[cchLength];
        pwcsBuffer[cchLength] = 0;

        WCHAR * pwcsTmpBuf = pwcsBuffer;
        WCHAR * pwcsParaMark = wcschr( pwcsTmpBuf, UNICODE_PARAGRAPH_SEPARATOR );
        while ( 0 != pwcsParaMark )
        {
            _escapedStr.Empty();
            *pwcsParaMark = 0;
            HTMLEscapeW( pwcsTmpBuf, _escapedStr, _langInfo.GetOutputCodePage() );
            _escapedStr.CharCat( UNICODE_PARAGRAPH_SEPARATOR );
            OutputHttp( _escapedStr.Get(), _escapedStr.StrLen(), TRUE );

            *pwcsParaMark = UNICODE_PARAGRAPH_SEPARATOR;
            pwcsTmpBuf = pwcsParaMark + 1;
            pwcsParaMark = wcschr( pwcsTmpBuf, UNICODE_PARAGRAPH_SEPARATOR );
        }

        if (*pwcsTmpBuf)
        {
            _escapedStr.Empty();
            HTMLEscapeW( pwcsTmpBuf, _escapedStr, _langInfo.GetOutputCodePage() );
            OutputHttp( _escapedStr.Get(), _escapedStr.StrLen(), TRUE );
        }
        pwcsBuffer[cchLength] = wcTemp;
    }
} //OutputHttpText

//+---------------------------------------------------------------------------
//
//  Member:     CWebhitsTemplate::CWebhitsTemplate
//
//  Synopsis:   Constructor of the webhits template file. It takes the
//              environment variables object and reads in the htx file,
//              processes it. Also, adds the appropriate replaceable
//              parameters.
//
//  Arguments:  [envVars]  - Environment variables to use
//              [codePage] - Codepage to use for the template
//
//  History:    9-09-96   srikants   Created
//
//----------------------------------------------------------------------------

CWebhitsTemplate::CWebhitsTemplate(
    CGetEnvVars const & envVars,
    ULONG               codePage )
: _wtxFile( envVars.GetTemplateFileVPath(),
            envVars.GetTemplateFilePPath(),
            codePage )
{
    //
    // Add the replacable parameters to the variable set.
    //
    _variableSet.AddParam( wcsParamCiUrl, envVars.GetWebHitsFileVPath() );
    _variableSet.AddParam( wcsParamRestriction, envVars.GetRestriction() );

    if (envVars.GetLocale())
        _variableSet.AddParam( wcsLocale, envVars.GetLocale() );
    if (envVars.GetCodepage())
        _variableSet.AddParam( wcsCodepage, envVars.GetCodepage() );

    //
    // Add user definable parameters.
    //
    for ( ULONG i = 0; i < CGetEnvVars::eMaxUserReplParams; i++ )
    {
        if ( envVars.GetUserParam(i+1) )
        {
            _variableSet.AddParam( awcsUserParamNames[i],
                                   envVars.GetUserParam(i+1) );
        }
    }

    //
    // Parse the htx file.
    //
    _wtxFile.ParseFile( _variableSet );
} //CWebhitsTemplate
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\buketize.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       buketize.cxx
//
//  Classes:    CBuketizeWindows
//
//  History:    2-16-95   srikants   Created
//
//----------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#include <bigtable.hxx>

#include "buketize.hxx"

CBucketizeWindows::CBucketizeWindows( CLargeTable & largeTable,
                                      CTableWindow &srcWindow )
: _largeTable(largeTable),
  _srcWindow( srcWindow ),
  _fFirstBkt(TRUE),
  _cRowsToCopy(0),
  _pBucket(0)
{
}


//+---------------------------------------------------------------------------
//
//  Function:   _AddWorkIds
//
//  Synopsis:   Adds workids from the given window to the bucket.
//
//  Arguments:  [iter] - 
//
//  History:    2-16-95   srikants   Created
//              4-27-95   srikants   Modified to deal with converting 
//                                   single window to multiple buckets.
//
//  Notes:      
//
//----------------------------------------------------------------------------

ULONG CBucketizeWindows::_AddWorkIds( CWindowRowIter & iter )
{

#if CIDBG==1
    ULONG cTotal =  iter.TotalRows();
    Win4Assert( _cRowsToCopy+iter.GetCurrPos() <= cTotal );
#endif  // CIDBG==1

    Win4Assert( 0 != _pBucket );

    ULONG iFirstRow = ULONG_MAX;
    ULONG iLastRow  = ULONG_MAX;

    ULONG cRowsCopied = 0;

    for ( ; !iter.AtEnd() && (cRowsCopied < _cRowsToCopy) ; iter.Next() )
    {
        if ( !iter.IsDeletedRow() )
        {
            iLastRow = iter.GetCurrPos();    
            if ( 0 == cRowsCopied )
                iFirstRow = iter.GetCurrPos();    
            _pBucket->_AddWorkId( iter.Get(), iter.Rank(), iter.HitCount() );
            cRowsCopied++;
        }
    }

    //
    // Initialize the lowest and the highest rows.
    //
    if ( 0 != cRowsCopied )
    {
        _srcWindow.GetSortKey( iFirstRow,
                               _pBucket->GetLowestKey() );

        _srcWindow.GetSortKey( iLastRow,
                               _pBucket->GetHighestKey() );
    }

    return cRowsCopied;
}

//+---------------------------------------------------------------------------
//
//  Function:   LokCreateBuckets
//
//  Synopsis:   Creates buckets from the source window.
//
//  Arguments:  [pSortSet] - The sortset on the table.
//              [colSet]   - Master column set for the table. 
//              [segId]    - Segment Id for the new bucket.
//
//  History:    2-16-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CBucketizeWindows::LokCreateBuckets( const CSortSet & sortSet,
                                          CTableKeyCompare & comparator,
                                          CColumnMasterSet & colSet
                                           )
{

    CWindowRowIter  iter(_srcWindow);

    ULONG cRowsRemaining = iter.TotalRows();
    const cRowsPerBkt = CTableSink::cBucketRowLimit;
    const cRowsMax = cRowsPerBkt * 110 /100;    // allow a 10% fall over

    //
    // While there are more rows in the windows, copy a set to the next
    // bucket.
    //
    while ( !iter.AtEnd() )
    {
        if ( cRowsRemaining <= cRowsMax )
        {
            //
            // This is to prevent a very small last bucket.
            //
            _cRowsToCopy = cRowsRemaining;    
        }
        else
        {
            _cRowsToCopy = cRowsPerBkt;
        }

        ULONG bktSegId;
        if ( _fFirstBkt )
        {
            //
            // For the first bucket, use the same segment id as the original
            // window.
            //
            bktSegId = _srcWindow.GetSegId();
            _fFirstBkt = FALSE;
        }
        else
        {
            bktSegId = _largeTable._AllocSegId();
        }

        //
        // Create a new bucket and append it to the end of bucket list.
        //
        _pBucket =  new CTableBucket( sortSet,
                                      comparator,
                                      colSet,
                                      bktSegId );

        //
        // Add the workids from the _iStart to _iEnd to the bucket.
        //
        ULONG cRowsCopied = _AddWorkIds( iter );
        if ( 0 != cRowsCopied )
        {
            _bktList.Queue( _pBucket );
            _pBucket = 0;
        }
        Win4Assert( iter.GetCurrPos() <= iter.TotalRows() );

        cRowsRemaining = iter.TotalRows() - iter.GetCurrPos();
    }

    Win4Assert( cRowsRemaining == 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\abktize.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       abktize.cxx
//
//  Contents:   Asynchronous Bucket->Window Conversion.
//
//  Classes:
//
//  Functions:
//
//  History:    5-25-95   srikants   Created
//
//----------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop


#include <bigtable.hxx>
#include <execute.hxx>

#include "tblbuket.hxx"
#include "tabledbg.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   CAsyncBucketExploder ~ctor
//
//  Arguments:  [largeTable]   -- LargeTable driving the bucket->window
//                                conversion.
//              [pBucket]      -- The bucket to expand into a window.
//              [widToPin]     -- WORKID to pin.
//              [fDoWidToPath] -- TRUE if table holds 'fake' wids, and bucket
//                                must convert fake wid to path.
//
//  History:    5-25-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CAsyncBucketExploder::CAsyncBucketExploder( CLargeTable &        largeTable,
                                            XPtr<CTableBucket> & xBucket,
                                            WORKID               widToPin,
                                            BOOL                 fDoWidToPath )
                         : PWorkItem(eSigCAsyncBucketExploder),
                           _largeTable(largeTable),
                           _pBucket(0),
                           _widToPin(widToPin),
                           _fDoWidToPath( fDoWidToPath ),
                           _pQueryExecute(0),
                           _refCount(1),
                           _fOnWorkQueue(FALSE),
                           _fOnLTList(FALSE),
                           _status(STATUS_SUCCESS)

{
    Close();        // Initialize the links to point to self.

    _pBucket = xBucket.Acquire();
    Win4Assert( 0 != _pBucket );

    END_CONSTRUCTION( CAsyncBucketExploder );
}


//+---------------------------------------------------------------------------
//
//  Function:   CAsyncBucketExploder
//
//  Synopsis:   ~dtor
//
//  History:    5-25-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CAsyncBucketExploder::~CAsyncBucketExploder()
{
    Win4Assert( 0 == _refCount );
    Win4Assert( IsSingle() );  // Is not linked in the list
    Win4Assert( !_fOnWorkQueue );
    Win4Assert( !_fOnLTList );

    if ( 0 != _pQueryExecute )
    {
        _pQueryExecute->Release();
    }

    delete _pBucket;
}

//+---------------------------------------------------------------------------
//
//  Function:   DoIt
//
//  Synopsis:   The main method called by the worker thread .
//
//  Arguments:  [pThread] -- Thread executing request.
//
//  History:    5-25-95   srikants   Created
//
//  Notes:      At the end, if this object in the LargeTable's list, it will
//              be removed from the large table list. While doing that,
//              DO NOT hold the mutex because there LT can call into this
//              object with its lock held. We don't want to deadlock.
//
//----------------------------------------------------------------------------

void CAsyncBucketExploder::DoIt( CWorkThread * pThread )
{

    {
        CLock   lock(_mutex);
        Win4Assert( 0 != _pBucket );
        Win4Assert( 0 != _pQueryExecute );
        _fOnWorkQueue = FALSE;
    }

    AddRef();

    //
    // None of these calls throw
    //

    CBucketRowIter  bktIter( *_pBucket, _fDoWidToPath );

    _pQueryExecute->Update( bktIter );

    //
    // If it is on the large table queue, remove it from the lt queue.
    //
    if ( _fOnLTList )
    {
        _fOnLTList = FALSE;
        _largeTable._RemoveFromExplodeList(this);
    }

    _evt.Set();

    Release();
}

//+---------------------------------------------------------------------------
//
//  Function:   SetQuery
//
//  Synopsis:   Sets the query object to be used for bucket->window conversion.
//
//  Arguments:  [pQExecute] - The Query object to use for bucket->window
//              conversion.
//
//  History:    5-25-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CAsyncBucketExploder::SetQuery( CQAsyncExecute * pQExecute )
{
    CLock   lock(_mutex);
    Win4Assert( 0 == _pQueryExecute && 0 != pQExecute );
    _pQueryExecute = pQExecute;
    _pQueryExecute->AddRef();
}

//+---------------------------------------------------------------------------
//
//  Function:   SetOnLTList
//
//  Synopsis:   Sets the internal state that it is on the large table's
//              list also.
//
//  History:    5-31-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CAsyncBucketExploder::SetOnLTList()
{
    CLock   lock(_mutex);
    Win4Assert( !_fOnLTList );
    _fOnLTList = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   AddToWorkQueue
//
//  Synopsis:   Adds this item to the work queue.
//
//  History:    5-31-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CAsyncBucketExploder::AddToWorkQueue()
{
    CLock   lock(_mutex);
    Win4Assert( !_fOnWorkQueue );

    _fOnWorkQueue = TRUE;
    TheWorkQueue.Add(this);
}

//+---------------------------------------------------------------------------
//
//  Function:   Abort
//
//  Synopsis:   Aborts the work item by removing it from the work queue
//              (if present). It also releases the query object.
//
//  History:    5-31-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CAsyncBucketExploder::Abort()
{

    CLock   lock(_mutex);

    Win4Assert( IsSingle() );   // Must not be on any list at this stage
    _fOnLTList = FALSE;

    if ( _fOnWorkQueue )
    {
        TheWorkQueue.Remove(this);
        _fOnWorkQueue = FALSE;
    }

    if ( 0 != _pQueryExecute )
    {
        _pQueryExecute->Release();
        _pQueryExecute = 0;
    }

    _evt.Set(); // Wake up any thread waiting on us
}

//+---------------------------------------------------------------------------
//
//  Function:   AddRef
//
//  Synopsis:
//
//  Returns:
//
//  Modifies:
//
//  History:    5-31-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CAsyncBucketExploder::AddRef()
{
    InterlockedIncrement(&_refCount);
}

//+---------------------------------------------------------------------------
//
//  Function:   Release
//
//  Synopsis:
//
//  Returns:
//
//  Modifies:
//
//  History:    5-31-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CAsyncBucketExploder::Release()
{
    Win4Assert( _refCount > 0 );
    if ( InterlockedDecrement(&_refCount) <= 0 )
    {
        delete this;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\colhash.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       colhash.cxx
//
//  Contents:   Hash table compressions for large tables.
//
//  Classes:    CCompressedColHash
//
//  Functions:  GuidHash - Hash function for GUIDs
//
//  History:    13 Apr 1994     AlanW    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <objcur.hxx>
#include <tblvarnt.hxx>

#include "tabledbg.hxx"
#include "colcompr.hxx"


const USHORT MAX_HASH_TABLE_SIZE = 32767;     // Maximum hash table size

//+-------------------------------------------------------------------------
//
//  Function:   GuidHash, public
//
//  Synopsis:   Hash a GUID value for use in a hash table.
//
//  Arguments:  [pbData] - pointer to the value to be hashed.
//              [cbData] - should be sizeof (GUID), unused
//
//  Returns:    ULONG - Hash value for the input GUID
//
//  Notes:      The hash function just xors a few selected fields out
//              of the GUID structure.  It is intended to work well for
//              both generated GUIDs (from UuidCreate) and administratively
//              assigned GUIDs like OLE IIDs and CLSIDs.
//
//--------------------------------------------------------------------------

ULONG GuidHash(
    BYTE *pbData,
    USHORT cbData
) {
    UNALIGNED GUID *pGuid = (GUID *)pbData;
    return (pGuid->Data1 ^
            (pGuid->Data4[0]<<16) ^
            (pGuid->Data4[6]<<8) ^
            (pGuid->Data4[7]));
}


//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHash::DefaultHash, public static
//
//  Synopsis:   Generic hash function
//
//  Arguments:  [pbData] - pointer to the value to be hashed.
//              [cbData] - size of pbData
//
//  Returns:    ULONG - Hash value for the input data
//
//--------------------------------------------------------------------------

//static
ULONG CCompressedColHash::DefaultHash(
    BYTE *pbData,
    USHORT cbData
) {
    ULONG ulRet = cbData;

    while (cbData--)
        ulRet = (ulRet<<1) ^ *pbData++;

    return ulRet;
}


//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHash::CCompressedColHash, public
//
//  Synopsis:   Constructor for a hash compressed column.
//
//  Arguments:  [vtData] - type of each data item
//              [cbDataWidth] - size of each data item
//              [pfnHashFunction] - pointer to hash function
//
//  Returns:    pKey is filled in with the index of the data item in
//              the data array.
//
//  Notes:
//
//--------------------------------------------------------------------------


CCompressedColHash::CCompressedColHash(
    VARTYPE     vtData,
    USHORT      cbDataWidth,
    PFNHASH     pfnHashFunction) :
        CCompressedCol(
            vtData,                     // DataType
            sizeof (HASHKEY),           // _cbKeyWidth
            CCompressedCol::FixedHash   // _CompressionType
        ),

        _cbDataWidth(cbDataWidth),
        _pfnHash(pfnHashFunction),
        _pHashTable(NULL), _cHashEntries(0),
        _pDataItems(NULL), _cDataItems(0),
        _fGrowthInProgress(FALSE),
        _pData(NULL), _cbData(0),
        _ulMemCounter(0)
{

}


CCompressedColHash::~CCompressedColHash( )
{
    if (_pData) {
        TblPageDealloc(_pData, _ulMemCounter);
        _pData = NULL;
        _cbData = 0;
    }
    Win4Assert(_ulMemCounter == 0);
}


//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHash::AddData, public
//
//  Synopsis:   Add a data entry to the hash table if it is not
//              already there.
//
//  Arguments:  [pVarnt] - pointer to data item
//              [pKey] - pointer to lookup key value
//              [reIndicator] - returns an indicator variable for
//                      problems
//
//  Returns:    pKey is filled in with the index of the data item in
//              the data array.  reIndicator is filled with an indication
//              of problems.
//
//  Notes:
//
//--------------------------------------------------------------------------

VOID    CCompressedColHash::AddData(
    PROPVARIANT const * const pVarnt,
    ULONG* pKey,
    GetValueResult& reIndicator
) {
    //
    //  Specially handle the VT_EMPTY case
    //
    if (pVarnt->vt == VT_EMPTY) {
        *pKey = 0;
        reIndicator = GVRSuccess;
        return;
    }

    CTableVariant *pVar = (CTableVariant *)pVarnt;
    Win4Assert(pVarnt->vt == DataType);

    BYTE *pbData ;
    USHORT cbData = (USHORT) pVar->VarDataSize();

    Win4Assert(cbData && cbData == _cbDataWidth);
    if (pVar->VariantPointerInFirstWord( )) {
        pbData = (BYTE *) pVar->pszVal;
    } else {
        Win4Assert(pVar->VariantPointerInSecondWord( ));
        pbData = (BYTE *) pVar->blob.pBlobData;
    }

    _AddData(pbData, cbData, pKey);
    reIndicator = GVRSuccess;
    return;
}


//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHash::_AddData, protected
//
//  Synopsis:   Helper for the public AddData method.  Adds
//              a data entry to the hash table (if it does not already
//              exist).
//
//  Arguments:  [pbData] - pointer to data item
//              [cbDataSize] - size of data item
//              [pKey] - pointer to lookup key value
//
//  Returns:    pKey is filled in with the index of the data item in
//              the data array.
//
//  Notes:
//
//--------------------------------------------------------------------------

VOID    CCompressedColHash::_AddData(
    BYTE *pbData,
    USHORT cbDataSize,
    ULONG* pKey
) {
    Win4Assert(cbDataSize == _cbDataWidth);

    if (_pData == NULL) {
        _GrowHashTable();
    }

    ULONG ulHash = _pfnHash(pbData, cbDataSize);

    ulHash %= _cHashEntries;

    HASHKEY* pusHashChain = &_pHashTable[ulHash];
    HASHKEY* pusNextData;
    USHORT cChainLength = 0;

    while (*pusHashChain != 0) {
        cChainLength++;
        pusNextData = _IndexHashkey( *pusHashChain );

        if (memcmp((BYTE *) (pusNextData+1), pbData, cbDataSize) == 0) {
            //
            //  Found the data item.  Return its index.
            //
            *pKey = *pusHashChain;
            return;
        }
        pusHashChain = pusNextData;
    }
    if (cChainLength > _maxChain)
        _maxChain = cChainLength;

    pusNextData = (HASHKEY *) ((BYTE *)_pDataItems +
                    (_cDataItems) * (sizeof (HASHKEY) + _cbDataWidth));
    if (((BYTE*)pusNextData + (sizeof (HASHKEY) + _cbDataWidth) -
        (BYTE *)_pData) > (int) _cbData ||
        (_cDataItems > (ULONG) ( _cHashEntries * 3 ) &&
         _cHashEntries < MAX_HASH_TABLE_SIZE &&
         !_fGrowthInProgress)) {

        //
        //  The new data will not fit in the table, or the hash chains will
        //  be too long.  Grow the table, then recurse.  The table may be
        //  rehashed, and can be moved when grown, so the lookup we've
        //  already done may be invalid.
        //
        _GrowHashTable();
        _AddData(pbData, cbDataSize, pKey);
        return;
    }

    //
    //  Now add the new data item.  The data item consists of a USHORT
    //  for the hash chain, followed by the buffer for the fixed size
    //  data item.
    //

    *pKey = *pusHashChain = ++_cDataItems;
    Win4Assert(_cDataItems != 0);               // check for overflow
    *pusNextData++ = 0;
    RtlCopyMemory((BYTE *)pusNextData, pbData, _cbDataWidth);
}


//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHash::_Rehash, protected
//
//  Synopsis:   Helper function for the _GrowHashTable method.
//              reinserts an existing item into the hash table.
//
//  Arguments:  [pbData] - pointer to data item
//              [kData] - index to the data item in the table
//
//  Returns:    Nothing
//
//  Notes:
//
//--------------------------------------------------------------------------

VOID    CCompressedColHash::_Rehash(
    HASHKEY kData,
    BYTE *pbData
) {
    Win4Assert(_pData != NULL && kData > 0 && kData <= _cDataItems);

    ULONG ulHash = _pfnHash(pbData, _cbDataWidth);

    ulHash %= _cHashEntries;

    HASHKEY* pusHashChain = &_pHashTable[ulHash];
    HASHKEY* pusNextData;
    USHORT cChainLength = 0;

    while (*pusHashChain != 0) {
        cChainLength++;
        pusNextData = _IndexHashkey( *pusHashChain );
        pusHashChain = pusNextData;
    }
    if (cChainLength > _maxChain)
        _maxChain = cChainLength;

    pusNextData = _IndexHashkey( kData );

    //
    //  Now add the data item to the hash chain.
    //

    *pusHashChain = kData;
    *pusNextData++ = 0;
    Win4Assert((BYTE*)pusNextData == pbData);
    return;
}



//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHash::GetData, public
//
//  Synopsis:   Retrieve a value from the hash table.
//
//  Arguments:  [pVarnt] - pointer to variant in which to return the data
//              [PreferredType] - Peferred data type
//              [ulKey] - the lookup key value
//              [PropId] - (unused) property id being retrieved.
//
//  Returns:    pVarnt is filled with the result of the lookup.
//
//  Notes:      The PreferredType expresses the caller's preference only.
//              This method is free to return whatever type is most
//              convenient.
//
//              The returned data does not conform to any alignment
//              restrictions on the data.
//
//--------------------------------------------------------------------------

GetValueResult  CCompressedColHash::GetData(
    PROPVARIANT * pVarnt,
    VARTYPE PreferredType,
    ULONG ulKey,
    PROPID PropId
) {
    CTableVariant *pVar = (CTableVariant *)pVarnt;
    Win4Assert(PreferredType == DataType && ulKey >= 1 && ulKey <= _cDataItems);

    if (ulKey >= 1 && ulKey <= _cDataItems) {
        pVarnt->vt = DataType;

        BYTE *pbData = ((BYTE *)_pDataItems +
                        (ulKey-1) * (sizeof (HASHKEY) + _cbDataWidth)) +
                        sizeof (HASHKEY);

        if (pVar->VariantPointerInFirstWord( )) {
            pVar->pszVal = (CHAR*)pbData;
        } else {
            Win4Assert(pVar->VariantPointerInSecondWord( ));
            pVar->blob.pBlobData = pbData;
        }
        return GVRSuccess;
    } else {
        pVarnt->vt = VT_EMPTY;
        return GVRNotAvailable;
    }
}

void    CCompressedColHash::FreeVariant(PROPVARIANT * pvarnt) { }



//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHash::_GrowHashTable, protected
//
//  Synopsis:   Grow the space allocated to the hash table and data
//              items.
//
//  Arguments:  - none -
//
//  Returns:    Nothing
//
//  Notes:      Also called to allocate the initial data area.
//
//              The number of hash buckets starts out at a low
//              number, then is increased as the amount of data
//              grows.  Data items must be rehashed when this occurs.
//              Since items are identified by their offset in the
//              data array, this must not change while rehashing.
//
//--------------------------------------------------------------------------

const unsigned MIN_HASH_TABLE_SIZE = 11;        // Minimum hash table size


inline USHORT CCompressedColHash::_NextHashSize(
    HASHKEY cItems,
    USHORT cHash
) {
    do {
        cHash = cHash*2 + 1;
    } while (cHash < _cDataItems);
    return  (cHash < MAX_HASH_TABLE_SIZE) ? cHash : MAX_HASH_TABLE_SIZE;
}


VOID CCompressedColHash::_GrowHashTable( void )
{
    ULONG cbSize;
    USHORT cNewHashEntries;
    int fRehash = FALSE;

    Win4Assert(!_fGrowthInProgress &&
             "Recursive call to CCompressedColHash::_GrowHashTable");

    _fGrowthInProgress = TRUE;
    if (_pData == NULL) {
        cNewHashEntries = MIN_HASH_TABLE_SIZE;
    } else if (_cHashEntries < MAX_HASH_TABLE_SIZE &&
               (_cDataItems > (ULONG) _cHashEntries*2 ||
                (_cDataItems > _cHashEntries && _maxChain > 3))) {
        cNewHashEntries = _NextHashSize(_cDataItems, _cHashEntries);
        fRehash = TRUE;
        tbDebugOut((DEB_ITRACE, "Growing hash table, old,new sizes = %d,%d\n",
                                        _cHashEntries, cNewHashEntries));
    }

    //
    //  Compute the required size of the hash table and data
    //
    cbSize = _cHashEntries * sizeof(HASHKEY);
    cbSize += (_cDataItems + 4) * (_cbDataWidth + sizeof (HASHKEY));
    cbSize = TblPageGrowSize(cbSize, TRUE);
    Win4Assert(cbSize > _cbData || (fRehash && cbSize == _cbData));

    BYTE *pbNewData;

    if (_pData && cbSize < TBL_PAGE_MAX_SEGMENT_SIZE) {
        pbNewData = (BYTE *)
            TblPageRealloc(_pData, _ulMemCounter, cbSize, 0);
    } else {
        pbNewData =
            (BYTE *)TblPageAlloc(cbSize, _ulMemCounter, TBL_SIG_COMPRESSED);
    }

    tbDebugOut((DEB_ITRACE, "New hash table at = %x\n", pbNewData));

    if (_pData != NULL && !fRehash) {
        if (_pData != pbNewData) {
            RtlCopyMemory(pbNewData, _pData, _cbData);
            TblPageDealloc(_pData, _ulMemCounter, _cbData);
            _pData = pbNewData;
        }
        _cbData = cbSize;
        _pHashTable = (HASHKEY *) _pData;
        _pDataItems = (BYTE *) (_pHashTable + _cHashEntries);
    } else {
        BYTE *pOldDataItems = _pDataItems;
        VOID *pOldData = _pData;
        ULONG cbOldSize = _cbData;

        _pData = pbNewData;
        _cbData = cbSize;
        _pHashTable = (HASHKEY *)_pData;
        _cHashEntries = cNewHashEntries;
        _pDataItems = (BYTE *) (_pHashTable + _cHashEntries);
        if (pOldData != NULL)
            RtlMoveMemory(_pDataItems,
                          pOldDataItems,
                          _cDataItems * (sizeof (HASHKEY) + _cbDataWidth));
        RtlZeroMemory(_pHashTable, cNewHashEntries * sizeof (HASHKEY));
        _maxChain = 0;

        //
        //  Now re-add all old data items to the hash table.
        //
        pOldDataItems = _pDataItems;
        for (HASHKEY i=1; i<=_cDataItems; i++) {
            pOldDataItems += sizeof (HASHKEY);  // skip hash chain
            _Rehash(i, pOldDataItems);
            pOldDataItems += _cbDataWidth;      // skip data item
        }
        if (pOldData != NULL && pOldData != _pData)
            TblPageDealloc(pOldData, _ulMemCounter, cbOldSize);
    }

    _fGrowthInProgress = FALSE;
    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   _ClearAll
//
//  Synopsis:   Method clears all the data in the "fixed width" part of the
//              memory buffer.
//
//  Arguments:  (none)
//
//  History:    12-16-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CCompressedColHash::_ClearAll()
{
    RtlZeroMemory(_pHashTable, _cHashEntries * sizeof (HASHKEY));
    RtlZeroMemory(_pDataItems, _cDataItems * _cbDataWidth );
    _cDataItems = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\bmkmap.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       bmkmap.cxx
//
//  Contents:   Book Mark Map Implementation
//
//  Classes:    CBookMarkMap
//
//  Functions:  
//
//  History:    11-22-94   srikants   Created
//
//----------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#include <pidmap.hxx>

#include "bmkmap.hxx"
#include "rowindex.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   AddBookMark
//
//  Synopsis:   Adds a NEW book mark to the mapping.
//
//  Arguments:  [wid]       --  WorkId to be added.
//              [oTableRow] --  Offset of the in the table window for this
//                              bookmark.
//
//  History:    11-23-94   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CBookMarkMap::AddBookMark( WORKID wid, TBL_OFF oTableRow )
{
    Win4Assert( widInvalid != wid );
    CWidBmkHashEntry  entry( wid, oTableRow );
    _widHash.AddEntry( entry );
}

//+---------------------------------------------------------------------------
//
//  Function:   AddReplaceBookMark
//
//  Synopsis:   Adds a NEW book mark to the mapping or replaces one if
//              already present.
//
//  Arguments:  [wid]       --  WorkId to be added.
//              [oTableRow] --  Offset of the in the table window for this
//                              bookmark.
//
//  History:    11-30-94   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CBookMarkMap::AddReplaceBookMark( WORKID wid, TBL_OFF oTableRow )
{
    Win4Assert( widInvalid != wid );
    CWidBmkHashEntry  entry( wid, oTableRow );
    _widHash.ReplaceOrAddEntry( entry );
}


//+---------------------------------------------------------------------------
//
//  Function:   FindBookMark
//
//  Synopsis:   Locates the requested bookmark mapping.
//
//  Arguments:  [wid]        -- WorkId to locate.
//              [obTableRow] -- (Output) Offset of the table row in the
//                              window.
//              [iRowIndex] -- (Output) Index in the sorted permutation
//                              (RowIndex) of the entry.
//
//  Returns:    TRUE if found; FALSE o/w
//
//  History:    11-23-94   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

BOOL CBookMarkMap::FindBookMark(
    WORKID      wid,
    TBL_OFF & obTableRow,
    ULONG &     iRowIndex )
{
    CWidBmkHashEntry  entry( wid );

    BOOL fHash =  _widHash.LookUpWorkId( entry );
    if ( !fHash )
    {
        return FALSE;
    }

    obTableRow = entry.Value();

    //
    // It has been located in the hash table. Now find out the corresponding
    // entry in the row index.
    //
    return _rowIndex.FindRow( obTableRow, iRowIndex );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\categ.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 2000.
//
//  File:       categ.cxx
//
//  Contents:   Unique categorization class
//
//  Classes:    CCategorize
//
//  History:    30 Mar 95   dlee   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <query.hxx>

#include "tabledbg.hxx"

//+---------------------------------------------------------------------------
//
//  Method:     CCategorize, public
//
//  Synopsis:   Constructor for categorization class
//
//  Arguments:  [rCatSpec]  -- categorization specification for this level
//              [iSpec]     -- 1-based categorization level, where smaller
//                             numbers are higher in the hierarchy.
//              [pParent]   -- categorization object that categorizes rows
//                             on this level (or 0 if none)
//              [mutex]     -- CAsyncQuery's mutex for serialization
//
//  History:    6-1-95   dlee   Created
//
//  Notes:      Category identifiers start at 0x40000000 plus 0x1000 times
//              [iSpec].  The 0x40000000 is so it is obvious to the
//              debugger that it is a category.  The 0x1000*[iSpec] is
//              so that it is obvious what level a category falls into.
//
//----------------------------------------------------------------------------

CCategorize::CCategorize(
    CCategorizationSpec & rCatSpec,
    unsigned              iSpec,
    CCategorize *         pParent,
    CMutexSem &           mutex)
    : _iSpec(                 iSpec ),
      _pParent(               pParent ),
      _pChild(                0 ),
      _mutex(                 mutex ),
      _iCategoryGen(          0x40000000 + ( 0x1000 * iSpec ) ),
      _widCurrent(            WORKID_TBLBEFOREFIRST ),
      _fNotificationsEnabled( FALSE ),
      _iFindHint(             0 ),
      _aDynamicCategories(    0 ),
      _aVisibleCategories(    16 )
{
    if (rCatSpec.Type() != CATEGORIZE_UNIQUE)
        THROW(CException( E_INVALIDARG ));
} //CCategorize


//+---------------------------------------------------------------------------
//
//  Method:     CCategorize::GetRows, public
//
//  Arguments:  [widStart]    - WORKID identifying first row to be
//                              transferred.  If WORKID_TBLFIRST is
//                              used, the transfer will start at the first
//                              row in the segment.
//              [chapt]       - Chapter from which to fetch rows (if chaptered)
//              [pOutColumns] - A CTableColumnSet that describes the
//                              output format of the data table.
//              [rGetParams]  - An CGetRowsParams structure which
//                              describes how many rows are to be fetched and
//                              other parameters of the operation.
//              [rwidLastRowTransferred] - On return, the work ID of
//                                         the last row to be transferred
//                                         from this table.  Can be used to
//                                         initialize widStart on next call.
//
//  Returns:    SCODE - status of the operation.  DB_S_ENDOFROWSET if
//                      widStart is WORKID_TBLAFTERLAST at start of
//                      transfer, or if rwidLastRowTransferred is the
//                      last row in the segment at the end of the transfer.
//
//                      STATUS_BUFFER_TOO_SMALL is returned if the available
//                      space in the out-of-line data was exhausted during
//                      the transfer.
//
//  Notes:      To transfer successive rows, as in GetNextRows, the
//              rwidLastRowTransferred must be advanced by one prior
//              to the next transfer.
//
//  History:    6-1-95   dlee   Created
//
//----------------------------------------------------------------------------

SCODE CCategorize::GetRows(
    HWATCHREGION            hRegion,
    WORKID                  widStart,
    CI_TBL_CHAPT            chapt,
    CTableColumnSet const & rOutColumns,
    CGetRowsParams &        rGetParams,
    WORKID &                rwidLastRowTransferred)
{
    SCODE sc = S_OK;

    TRY
    {
        if (WORKID_TBLAFTERLAST == widStart)
        {
            rwidLastRowTransferred = WORKID_TBLAFTERLAST;
            return DB_S_ENDOFROWSET;
        }
        else if (widInvalid == widStart)
        {
            Win4Assert(! "CCategorize::GetRows widStart is widInvalid");
            return E_FAIL;
        }
        else
        {
            CLock lock( _mutex );

            if ( 0 == _aVisibleCategories.Count() )
                sc = DB_S_ENDOFROWSET;
            else
            {
                unsigned iRow;
                if ( widStart != WORKID_TBLFIRST &&
                     widStart != WORKID_TBLBEFOREFIRST )
                    iRow = _FindCategory( widStart );
                else
                    iRow = 0;

                rwidLastRowTransferred = 0;

                while ( 0 != rGetParams.RowsToTransfer() &&
                        iRow < _aVisibleCategories.Count() )
                {
                    // at the end of the chapter when this level is categorized?

                    if ( ( _isCategorized() ) &&
                         ( DB_NULL_HCHAPTER != chapt ) &&
                         ( _aVisibleCategories[ iRow ].catParent != chapt ) )
                        break; // code below will set sc = DB_S_ENDOFROWSET

                    BYTE* pbDst = (BYTE *) rGetParams.GetRowBuffer();

                    for ( unsigned col = 0; col < rOutColumns.Count(); col++ )
                    {
                        CTableColumn const & rDstColumn = *rOutColumns.Get(col);
                        PROPID pid = rDstColumn.GetPropId();

                        if ( pidChapter == pid || pidWorkId  == pid )
                        {
                            if (rDstColumn.GetStoredType() == VT_VARIANT)
                            {
                                Win4Assert( rDstColumn.GetValueSize() == sizeof VARIANT );
                                CTableVariant * pVarnt = (CTableVariant *) ( pbDst +
                                                         rDstColumn.GetValueOffset() );
                                pVarnt->vt = VT_UI4;
                                pVarnt->ulVal = _aVisibleCategories[iRow].catID;
                            }
                            else
                            {
                                Win4Assert( rDstColumn.GetValueSize() == sizeof CI_TBL_CHAPT );
                                RtlCopyMemory( pbDst + rDstColumn.GetValueOffset(),
                                               &( _aVisibleCategories[iRow].catID),
                                               sizeof CI_TBL_CHAPT );
                            }
                            rDstColumn.SetStatus( pbDst, CTableColumn::StoreStatusOK );
                            rDstColumn.SetStatus( pbDst, CTableColumn::StoreStatusOK );
                        }
                        else
                        {
                            _pChild->LokGetOneColumn( _aVisibleCategories[iRow].widFirst,
                                                      rDstColumn,
                                                      pbDst,
                                                      rGetParams.GetVarAllocator() );
                        }
                    }

                    rwidLastRowTransferred = _aVisibleCategories[iRow].catID;
                    rGetParams.IncrementRowCount();

                    if ( rGetParams.GetFwdFetch() )
                        iRow++;
                    else
                    {
                        if (iRow == 0)
                            break;
                        iRow--;
                    }
                }

                // If we didn't transfer as many rows as requested, we must
                // have run into the end of the table or chapter.

                if ( rGetParams.RowsToTransfer() > 0 )
                {
                    if ( 0 == rGetParams.RowsTransferred() )
                        sc = DB_E_BADSTARTPOSITION;
                    else
                        sc = DB_S_ENDOFROWSET;
                }
            }
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        Win4Assert( E_OUTOFMEMORY == sc ||
                    STATUS_BUFFER_TOO_SMALL == sc ); // benign?

        if ( E_OUTOFMEMORY == sc && rGetParams.RowsTransferred() > 0)
            sc = DB_S_BLOCKLIMITEDROWS;
    }
    END_CATCH;

    return sc;
} //GetRows

//+-------------------------------------------------------------------------
//
//  Member:     CCategorize::RestartPosition, public
//
//  Synopsis:   Set next fetch position for the chapter to the start
//
//  Arguments:  [chapt]    - Chapter from which to fetch rows (if chaptered)
//
//  Returns:    SCODE - status of the operation.
//
//--------------------------------------------------------------------------

void       CCategorize::RestartPosition(
    CI_TBL_CHAPT           chapt)
{
    SetCurrentPosition( chapt, WORKID_TBLBEFOREFIRST );
    CTableSource::RestartPosition( chapt );
}


//+---------------------------------------------------------------------------
//
//  Method:     LocateRelativeRow, public
//
//  Synopsis:   Finds a row in the category table.  Since there is only one
//              category segment, we are almost assured of finding the row.
//
//  Arguments:  [widStart]       -- where to start the locate
//              [chapt]          -- parent chapter in which to do the locate
//              [cRowsToMove]    -- rows to skip after [widStart]
//              [rwidRowOut]     -- wid found after locate
//              [rcRowsResidual] -- number of rows left over -- will be 0
//
//  History:    6-1-95   dlee   Created
//
//----------------------------------------------------------------------------

SCODE CCategorize::LocateRelativeRow(
    WORKID          widStart,
    CI_TBL_CHAPT    chapt,
    DBROWOFFSET     cRowsToMove,
    WORKID &        rwidRowOut,
    DBROWOFFSET &   rcRowsResidual)
{
    CLock lock( _mutex );

    if ( widStart == WORKID_TBLBEFOREFIRST && cRowsToMove > 0 )
    {
        widStart = WORKID_TBLFIRST;
        cRowsToMove--;
    }
    else if ( widStart == WORKID_TBLAFTERLAST && cRowsToMove < 0 )
    {
        widStart = WORKID_TBLLAST;
        cRowsToMove++;
    }
    else if ( WORKID_TBLAFTERLAST   == widStart ||
              WORKID_TBLBEFOREFIRST == widStart )
    {
        rwidRowOut = widStart;
        rcRowsResidual = cRowsToMove;
        return S_OK;
    }

    ULONG iRow;

    if ( WORKID_TBLFIRST == widStart )
    {
        if ( _isCategorized() && DB_NULL_HCHAPTER != chapt )
            iRow = _FindCategory( _pParent->GetFirstWorkid( chapt ) );
        else
            iRow = 0;
    }
    else if ( WORKID_TBLLAST == widStart )
    {
        if ( _isCategorized() && DB_NULL_HCHAPTER != chapt )
        {
            iRow = _FindCategory( _pParent->GetFirstWorkid( chapt ) );
            iRow += _pParent->GetRowCount( chapt );
        }
        else
        {
            iRow = _aVisibleCategories.Count();
        }

        iRow--;
    }
    else
    {
        iRow = _FindCategory( widStart );
    }

    rcRowsResidual = cRowsToMove + iRow;

    if (rcRowsResidual < 0)
    {
        rwidRowOut = WORKID_TBLBEFOREFIRST;
        tbDebugOut(( DEB_ITRACE,
                     "category table LocateRelativeRow off beginning of table\n" ));
    }
    else if ( (ULONG) rcRowsResidual >= _aVisibleCategories.Count() )
    {
        rwidRowOut = WORKID_TBLAFTERLAST;
        rcRowsResidual -= _aVisibleCategories.Count();

        tbDebugOut(( DEB_ITRACE,
                     "category table LocateRelativeRow off end of table\n" ));
    }
    else
    {
        rwidRowOut = (WORKID) _aVisibleCategories[ (unsigned) rcRowsResidual ].catID;
        rcRowsResidual = 0;
    }

    return S_OK;
} //LocateRelativeRow

//+---------------------------------------------------------------------------
//
//  Method:     CCategorize::LokAssignCategory, public
//
//  Synopsis:   Assigns a category to a row in a lower level, then calls
//              the parent categorizer to re-categorize the row's category
//              if there is a parent.
//
//  Arguments:  [prm]  -- category parameters.  See tblsink.hxx for more
//                        info about this object.
//
//  History:    6-1-95   dlee   Created
//
//  Notes:      No need to grab the CAsyncQuery lock -- bigtable grabs it
//              up front in PutRow.
//
//----------------------------------------------------------------------------

unsigned CCategorize::LokAssignCategory(
    CCategParams & prm)
{
    unsigned category = chaptInvalid;
    unsigned iEntry = 0xffffffff;

    CDynArrayInPlace<CCategory> & array = _WritableArray();

    if ( widInvalid != prm.widPrev &&
         widInvalid != prm.widNext &&
         prm.catPrev == prm.catNext )
    {
        // new row is between two rows of the same category
        // no need to call parent categorizer -- just return

        _IncrementRowCount( prm.catPrev );
        return prm.catPrev;
    }
    else if ( widInvalid == prm.widPrev &&
              widInvalid == prm.widNext )
    {
        // first row we've ever seen

        Win4Assert( 0 == array.Count() );
        CCategory cat( prm.widRow );
        array[ 0 ] = cat;
        category = _GenCategory();
        array[ 0 ].catID = category;
        iEntry = 0;
    }
    else if ( widInvalid == prm.widPrev )
    {
        // new first row in the next row's category or a new category

        if ( prm.icmpNext > _iSpec )
        {
            // new first row in this (the next row's) category

            category = prm.catNext;
            iEntry = _FindWritableCategory( category );
            array[ iEntry ].widFirst = prm.widRow;
            array[ iEntry ].cRows++;

            return category;
        }
        else
        {
            // insert new category before the next category

            iEntry = _FindWritableCategory( prm.catNext );
            category = _InsertNewCategory( prm.widRow, iEntry );
        }
    }
    else if ( widInvalid == prm.widNext )
    {
        // new category OR
        // new element in previous row's category

        if ( prm.icmpPrev <= _iSpec )
        {
            // new category after previous (may be an insert operation).
            // just because widNext is invalid doesn't mean it doesn't exist.

            iEntry = 1 + _FindWritableCategory( prm.catPrev );
            category = _InsertNewCategory( prm.widRow, iEntry );
        }
        else
        {
            // new element in previous row's category

            _IncrementRowCount( prm.catPrev );
            return prm.catPrev;
        }
    }
    else
    {
        // good rows on either side in different categories, one of either:
        //     new member of previous row's category       OR
        //     new first member of next rows's category    OR
        //     new category

        if ( prm.icmpPrev > _iSpec )
        {
            // new member of previous row's category

            _IncrementRowCount( prm.catPrev );
            return prm.catPrev;
        }
        else if ( prm.icmpNext > _iSpec )
        {
            // new first member of next rows's category

            iEntry = _FindWritableCategory( prm.catNext );

            array[ iEntry ].widFirst = prm.widRow;
            array[ iEntry ].cRows++;

            return prm.catNext;
        }
        else
        {
            // new category

            iEntry = _FindWritableCategory( prm.catNext ) ;
            category = _InsertNewCategory( prm.widRow, iEntry );
        }
    }

    // Not all cases above get to this point.  Several return early if
    // there is no way a parent would care about the operation.

    if ( _isCategorized() )
    {
        Win4Assert( category != chaptInvalid );
        Win4Assert( iEntry != 0xffffffff );

        // Get the parent category.  Use a different CCategParams so original
        // is intact.

        CCategParams prnt = prm;
        prnt.widRow = category;

        if ( 0 == iEntry )
            prnt.widPrev = widInvalid;
        else
        {
            prnt.widPrev = array[ iEntry - 1 ].catID;
            prnt.catPrev = array[ iEntry - 1 ].catParent;
        }

        if ( iEntry < ( array.Count() - 1 ) )
        {
            prnt.widNext = array[ iEntry + 1 ].catID;
            prnt.catNext = array[ iEntry + 1 ].catParent;
        }
        else
            prnt.widNext = widInvalid;

        array[ iEntry ].catParent = _pParent->LokAssignCategory( prnt );
    }

    return category;
} //LokAssignCategory

//+---------------------------------------------------------------------------
//
//  Method:     _FindCategory, private
//
//  Synopsis:   Finds a category in the category array
//
//  Arguments:  [cat]  -- category
//
//  Returns:    index into the category array
//
//  History:    6-1-95   dlee   Created
//
//----------------------------------------------------------------------------

unsigned CCategorize::_FindCategory(
    CI_TBL_CHAPT cat )
{
    unsigned cCategories = _aVisibleCategories.Count();

    // first try the hint and the hint + 1

    if ( _iFindHint < cCategories )
    {
        if ( cat == _aVisibleCategories[ _iFindHint ].catID )
            return _iFindHint;

        unsigned iHintPlus = _iFindHint + 1;

        if ( ( iHintPlus < cCategories ) &&
             ( cat == _aVisibleCategories[ iHintPlus ].catID ) )
        {
            _iFindHint++;
            return _iFindHint;
        }
    }

    // linear search for the category

    for ( unsigned i = 0; i < cCategories; i++ )
    {
        if ( cat == _aVisibleCategories[ i ].catID )
        {
            _iFindHint = i;
            return i;
        }
    }

    THROW( CException( DB_E_BADCHAPTER ) );
    return 0;
} //_FindCategory

//+---------------------------------------------------------------------------
//
//  Method:     _FindWritableCategory, private
//
//  Synopsis:   Finds a category in the updatable category array
//
//  Arguments:  [cat]  -- category
//
//  Returns:    index into the category array
//
//  History:    6-1-95   dlee   Created
//
//  PERFPERF:   Linear search -- we may want to put a hash table over this.
//              How many categories do we expect?
//              Another alternative is to cache the last array entry
//              referenced and use it and the prev/next entries as first
//              guesses.
//
//----------------------------------------------------------------------------

unsigned CCategorize::_FindWritableCategory(
    CI_TBL_CHAPT cat )
{
    CDynArrayInPlace<CCategory> & array = _WritableArray();

    for ( unsigned i = 0; i < array.Count(); i++ )
        if ( cat == array[ i ].catID )
            return i;

    Win4Assert( !"_FindWritableCategory failed" );
    THROW( CException( DB_E_BADCHAPTER ) );
    return 0;
} //_FindWritableCategory

//+---------------------------------------------------------------------------
//
//  Method:     GetRowsAt, public
//
//  Synopsis:   Retrieves rows at a specified location
//
//  Arguments:  [widStart]    -- where to start retrieving rows
//              [chapt]       -- in which rows are retrieved
//              [cRowsToMove] -- offset from widStart
//              [rOutColumns] -- description of output columns
//              [rGetParams]  -- info about the get operation
//              [rwidLastRowTransferred] -- last row retrieved
//
//  Returns:    SCODE
//
//  History:    6-1-95   dlee   Created
//
//----------------------------------------------------------------------------

SCODE CCategorize::GetRowsAt(
    HWATCHREGION     hRegion,
    WORKID           widStart,
    CI_TBL_CHAPT     chapt,
    DBROWOFFSET      cRowsToMove,
    CTableColumnSet  const & rOutColumns,
    CGetRowsParams & rGetParams,
    WORKID &         rwidLastRowTransferred )
{
    CLock lock( _mutex );

    DBROWOFFSET cRowsResidual;

    SCODE scRet = LocateRelativeRow( widStart,
                                     chapt,
                                     cRowsToMove,
                                     widStart,
                                     cRowsResidual);

    Win4Assert( !FAILED( scRet ) );

    if ( cRowsResidual )
    {
        Win4Assert ( WORKID_TBLAFTERLAST   == widStart ||
                     WORKID_TBLBEFOREFIRST == widStart );
        return DB_E_BADSTARTPOSITION;
    }

    scRet = GetRows( hRegion,
                     widStart,
                     chapt,
                     rOutColumns,
                     rGetParams,
                     rwidLastRowTransferred);
    return scRet;
} //GetRowsAt

//+---------------------------------------------------------------------------
//
//  Method:     GetRowsAtRatio, public
//
//  Synopsis:   Retrieves rows at a specified location.  Nothing fuzzy about
//              this -- they're all in memory so be as exact as possible.
//
//  Arguments:  [num]         -- numerator of starting point fraction
//              [denom]       -- denominator of starting point fraction
//              [chapt]       -- in which rows are retrieved
//              [rOutColumns] -- description of output columns
//              [rGetParams]  -- info about the get operation
//              [rwidLastRowTransferred] -- last row retrieved
//
//  Returns:    SCODE
//
//  History:    6-1-95   dlee   Created
//
//----------------------------------------------------------------------------

SCODE CCategorize::GetRowsAtRatio(
    HWATCHREGION            hRegion,
    ULONG                   num,
    ULONG                   denom,
    CI_TBL_CHAPT            chapt,
    CTableColumnSet const & rOutColumns,
    CGetRowsParams &        rGetParams,
    WORKID &                rwidLastRowTransferred )
{
    CLock lock( _mutex );

    if ( 0 == denom || num > denom )
        QUIETTHROW( CException(DB_E_BADRATIO) );

    ULONG cRows;
    if ( _isCategorized() && DB_NULL_HCHAPTER != chapt )
        cRows = _pParent->GetRowCount( chapt );
    else
        cRows = _aVisibleCategories.Count();

    ULONG cRowsFromFront = (ULONG) ( ( (unsigned _int64) num *
                                       (unsigned _int64) cRows ) /
                                     ( unsigned _int64 ) denom );

    if ( cRowsFromFront == cRows )
    {
        // The user is asking to retrieve past the end of table.

        rwidLastRowTransferred = WORKID_TBLAFTERLAST;
        return DB_S_ENDOFROWSET;
    }

    return GetRowsAt( hRegion, WORKID_TBLFIRST, chapt, (LONG) cRowsFromFront,
                      rOutColumns, rGetParams, rwidLastRowTransferred );
} //GetRowsAtRatio

//+---------------------------------------------------------------------------
//
//  Method:     RemoveRow, public
//
//  Synopsis:   Removes a row from the categorization
//
//  Arguments:  [chapt]     -- of row being removed
//              [wid]       -- of removed row in categorized child table
//              [widNext]   -- of row following removed row
//
//  History:    6-1-95   dlee   Created
//
//----------------------------------------------------------------------------

void CCategorize::RemoveRow(
    CI_TBL_CHAPT   chapt,
    WORKID         wid,
    WORKID         widNext )
{
    CLock lock( _mutex );

    CDynArrayInPlace<CCategory> & array = _WritableArray();

    unsigned iEntry = _FindWritableCategory( chapt );
    array[ iEntry ].cRows--;

    if ( 0 == array[ iEntry ].cRows )
    {
        // in case we need parent category later, save it

        unsigned catParent = array[ iEntry ].catParent;

        // last member of category -- remove the category

        array.Remove( iEntry );

        if ( _isCategorized() )
        {
           // notify the parent that a row was deleted

            WORKID widNextCategory;
            if ( ( 0 == array.Count() ) ||
                 ( iEntry >= ( array.Count() - 1) ) )
                widNextCategory = widInvalid;
            else
                widNextCategory = array[ iEntry ].catID;

            _pParent->RemoveRow( catParent,
                                 chapt,
                                 widNextCategory );
        }
    }
    else if ( array[ iEntry ].widFirst == wid )
    {
        // new first member of the category

        array[ iEntry ].widFirst = widNext;

        // removed the GetNextRows() current position row -- fixup

        if ( array[ iEntry ].widGetNextRowsPos == wid )
            array[ iEntry ].widGetNextRowsPos = widNext;
    }
} //RemoveRow

//+---------------------------------------------------------------------------
//
//  Method:     GetApproximatePosition, public
//
//  Synopsis:   Returns the offset of a bookmark in the table/chapter and
//              the number of rows in that table/chapter
//
//  Arguments:  [chapt]   -- of row being queried
//              [bmk]     -- of row being queried
//              [piRow]   -- returns index of row in table/chapter
//              [pcRows]  -- returns count of rows in table/chapter
//
//  History:    6-29-95   dlee   Created
//
//----------------------------------------------------------------------------

SCODE CCategorize::GetApproximatePosition(
    CI_TBL_CHAPT chapt,
    CI_TBL_BMK   bmk,
    DBCOUNTITEM * piRow,
    DBCOUNTITEM * pcRows )
{
    CLock lock( _mutex );

    if (bmk == widInvalid)
        return DB_E_BADBOOKMARK;

    Win4Assert( bmk != WORKID_TBLBEFOREFIRST && bmk != WORKID_TBLAFTERLAST );

    DBCOUNTITEM iBmkPos = ULONG_MAX, cRows = 0;

    if ( _isCategorized() && DB_NULL_HCHAPTER != chapt )
        cRows = _pParent->GetRowCount( chapt );
    else
        cRows = _aVisibleCategories.Count();

    if ( WORKID_TBLFIRST == bmk )
        iBmkPos = cRows ? 1 : 0;
    else if ( WORKID_TBLLAST == bmk )
        iBmkPos = cRows;
    else
    {
        iBmkPos = _FindCategory( bmk ) + 1;

        // position is relative to first member of the category (if any)

        if ( _isCategorized() && DB_NULL_HCHAPTER != chapt )
            iBmkPos -= _FindCategory( _pParent->GetFirstWorkid( chapt ) );
    }

    Win4Assert(iBmkPos <= cRows);

    *piRow = iBmkPos;
    *pcRows = cRows;

    return S_OK;
} //GetApproximatePosition

//+---------------------------------------------------------------------------
//
//  Method:     LokGetOneColumn, public
//
//  Synopsis:   Returns column data for the first item in a category.
//
//  Arguments:  [wid]        -- workid or chapter of the row to be queried
//              [rOutColumn] -- layout of the output data
//              [pbOut]      -- where to write the column data
//              [rVarAlloc]  -- variable data allocator to use
//
//  History:    22-Aug-95   dlee   Created
//
//----------------------------------------------------------------------------

void CCategorize::LokGetOneColumn(
    WORKID                    wid,
    CTableColumn const &      rOutColumn,
    BYTE *                    pbOut,
    PVarAllocator &           rVarAlloc )
{
    unsigned iRow = _FindCategory( wid );

    _pChild->LokGetOneColumn( _aVisibleCategories[iRow].widFirst,
                              rOutColumn,
                              pbOut,
                              rVarAlloc );
} //LokGetOneColumn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\bigtable.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       bigtable.cxx
//
//  Contents:
//
//  Classes:    CLargeTable - top-level class for large tables
//              CTableSegIter - iterator of table segments
//
//  Functions:
//
//  History:    01 Feb 1994     AlanW    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <query.hxx>
#include <srequest.hxx>
#include <cifailte.hxx>
#include <tbrowkey.hxx>

#include "tabledbg.hxx"
#include "tblwindo.hxx"
#include "winsplit.hxx"

#include "buketize.hxx"
#include "tputget.hxx"
#include "regtrans.hxx"

static inline ULONG AbsDiff( ULONG num1, ULONG num2 )
{
    return num1 >= num2 ? num1-num2 : num2-num1;
}

unsigned CTableSink::LokCategorize(
    CCategParams & params )
{
    return _pCategorizer->LokAssignCategory( params );
} //LokCategorize

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::CLargeTable, public
//
//  Synopsis:   Constructor for a large table.  Allocates and fills
//              in the master column description.
//              Allocates initial window to collect data.
//
//  Arguments:  [col]           - A description of initial output column set
//              [sort]          - A description of the initial sort order
//              [cCategorizers] - Total count of categorizers over table
//              [mutex]         - CAsyncQuery's mutex for serialization
//              [fUniqueWorkid] - TRUE if workid (from iterator) is unique
//
//  Notes:
//
//  History:    01-Jan-96   KyleP     Optional unique wid in user-mode.
//
//--------------------------------------------------------------------------

CLargeTable::CLargeTable( XColumnSet & col,
                          XSortSet & sort,
                          unsigned cCategorizers,
                          CMutexSem & mutex,
                          BOOL fUniqueWorkid,
                          CRequestServer * pQuiesce )
        : CTableSink(),
          _sigLargeTable(eSigLargeTable),
          _cbMemoryUsage( 0 ),
          _cbMemoryTarget( DEFAULT_MEM_TARGET ),
          _MasterColumnSet( col.GetPointer() ),
          _fUniqueWorkid( fUniqueWorkid ),
          _segListMgr(cMaxClientEntriesToPin),
          _segList(_segListMgr.GetList()),
          _watchList(_segList),
          _nextSegId(1),
          _pCategorization(0),
          _fAbort(FALSE),
          _pSortSet( 0 ),
          _fProgressNeeded (FALSE),
          _bitNotifyEnabled(0),
          _bitClientNotified(0),
          _bitChangeQuiesced(0),
          _bitRefresh(0),
          _bitIsWatched(0),
          _bitQuiesced(0),
          _pDeferredRows(0),
          _fQuiescent (FALSE),
          _ulProgressNum(0),
          _ulProgressDenom(1),
          _cCategorizersTotal( cCategorizers ),
          _fRankVectorBound( FALSE ),
          _mutex( mutex ),
          _widCurrent( WORKID_TBLBEFOREFIRST ),
          _hNotifyEvent( 0 ),
          _pRequestServer( 0 ),
          _pQExecute(0),
          _pQuiesce( pQuiesce ),
          _fSortDefined( FALSE )
{
    tbDebugOut (( DEB_NOTIFY, "lt: CLargeTable\n" ));

    TRY // use exception generating new
    {
        // Don't bucketize when rank vector is bound

        _fRankVectorBound = ( 0 != _MasterColumnSet.Find( pidRankVector ) );

        //
        //  Be sure the workid column is in the master column set.  The
        //  output column set was added in the constructor above.
        //
        _MasterColumnSet.Add( CColumnMasterDesc(pidWorkId, TYPE_WORKID) );

        //
        // Add the status column, which is used internally and may
        // be bound to at some point.  Status is stored as a byte to save
        // space, and is translated to an HRESULT when passed out to a
        // client.
        //
        CColumnMasterDesc *pRowStatus =
            _MasterColumnSet.Add( CColumnMasterDesc(pidRowStatus, VT_UI1) );
        pRowStatus->SetComputed(TRUE);
        pRowStatus->SetUniform(TRUE);

        //
        // If categorization is turned on, create an I4 category column
        //
        if ( 0 != cCategorizers )
            _MasterColumnSet.Add( CColumnMasterDesc(pidChapter, VT_I4) );

        //
        // Set up file path and name as global, shared compressions with
        // the WorkId as key.  Only needed if it's inconvenient to fetch
        // name and path from workid (e.g. workid isn't unique).
        //

        if ( !_fUniqueWorkid )
        {
            _MasterColumnSet.Add( CColumnMasterDesc(pidPath, TYPE_PATH) );
            _MasterColumnSet.Add( CColumnMasterDesc(pidName, TYPE_NAME) );

            CCompressedCol * pPathCompression = new CPathStore();

            CColumnMasterDesc* pMastCol;

            pMastCol = _MasterColumnSet.Find(pidWorkId);
            Win4Assert(pMastCol != 0);
            pMastCol->SetCompression(pPathCompression);

            pMastCol = _MasterColumnSet.Find(pidPath);
            Win4Assert(pMastCol != 0);
            pMastCol->SetCompression(pPathCompression, pidWorkId);

            pMastCol = _MasterColumnSet.Find(pidName);
            Win4Assert(pMastCol != 0);
            pMastCol->SetCompression(pPathCompression, pidWorkId);
        }

        //
        //  Add the sort keys to the master column set.
        //

        if ( ! sort.IsNull() )
        {
            for ( unsigned iCol = 0; iCol < sort->Count(); iCol++ )
                _MasterColumnSet.Add( CColumnMasterDesc(sort->Get(iCol)) );
            _fSortDefined = TRUE;   // set it to true since sorting is defined
        }

        //
        // Master column set is constructed. Acquire the sortset, but first
        // make sure workid is in the sort set.
        //
        _pSortSet = _CheckAndAddWidToSortSet( sort );

        Win4Assert ( 0 != _pSortSet );

        tbDebugOut(( DEB_ITRACE, "New Big Table with %d columns\n",
                                 _MasterColumnSet.Size() ));
    }
    CATCH(CException, e)
    {
        delete _pSortSet;
        RETHROW();
    }
    END_CATCH;
}


//+---------------------------------------------------------------------------
//
//  Function:   _CheckAndAddWidToSortSet
//
//  Synopsis:   Tests if the sort specification(if any) already had the
//              "pidWorkId" as part of the sort set. If not, it adds one to
//              the end of sort set.
//
//  Arguments:  [sort] -  Input sort set.
//
//  Returns:    The sort set to be used.
//
//  History:    3-22-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CSortSet * CLargeTable::_CheckAndAddWidToSortSet( XSortSet & sort )
{
    //
    // Check if the pidWorkId is already a field in the sortset.
    //

    BOOL fPresent = FALSE;

    if ( sort.IsNull() )
    {
        sort.Set( new CSortSet(1) );
    }
    else
    {
        for ( unsigned i = 0; i < sort->Count(); i++ )
        {
            SSortKey & key = sort->Get(i);

            if ( pidWorkId == key.pidColumn )
            {
                fPresent = TRUE;
                break;
            }
        }
    }

    if ( !fPresent )
    {
        SSortKey keyWid( pidWorkId, QUERY_SORTASCEND, 0 );
        sort->Add( keyWid, sort->Count() );
    }

    //
    // Initialize the variant types array for the sort columns
    //
    _vtInfoSortKey.Init( sort->Count() );
    for ( unsigned i = 0; i < sort->Count(); i++ )
    {
        SSortKey & key = sort->Get(i);
        PROPID pid = key.pidColumn;

        CColumnMasterDesc *pMasterCol = _MasterColumnSet.Find(pid);
        Win4Assert( 0 != pMasterCol );
        _vtInfoSortKey[i] = pMasterCol->DataType;
    }

    _keyCompare.Set( new CTableKeyCompare( sort.GetReference() ) );
    _currRow.Set( new CTableRowKey( sort.GetReference() ) );

    _segListMgr.GetSegmentArray().SetComparator( _keyCompare.GetPointer() );

    return sort.Acquire();
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::~CLargeTable, public
//
//  Synopsis:   Destructor for a large table.
//
//  Notes:      The query execution object along with
//              the worker threads has been already
//              destroyed (see CAsyncQuery) so there
//              is no race condition here.
//
//--------------------------------------------------------------------------

CLargeTable::~CLargeTable( )
{
    //
    // Cancel the notification.  Insure that no notifications will be
    // picked up as the thread leaves.  In almost all cases, this will
    // never be called, because the notification thread will already
    // be killed when the last connection point goes away.
    //

    Win4Assert( 0 == _pQExecute );

    CancelAsyncNotification();

    delete _pSortSet;

    // make sure the waiter wakes up

    if ( 0 != _pQuiesce )
    {
        // only called on failure cases -- success cases quiesce ok

        _pQuiesce->QueryQuiesced( _fQuiescent, _scStatus );
        _pQuiesce = 0;
    }
}



//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::_LokFindTableSegment, private
//
//  Synopsis:   Find the appropriate table segment for a request which
//              operates on only a single table segment.
//
//  Arguments:  [wid] - WORKID which identifies the table segment of interest
//              [fMustExist] - TRUE if wid must exist in some segment
//              [pSegHint] - optional, possible segment in which wid will be
//                      found.
//
//  Returns:    CTableSegment* - the selected table segment, 0 if not found.
//
//  Notes:      The method cannot be used for any of the special workIDs used
//              as sentinels (WORKID_TBLBEFOREFIRST, etc).
//              Use _LokLocateTableSegment instead.
//
//--------------------------------------------------------------------------

CTableSegment *
CLargeTable::_LokFindTableSegment(
    WORKID      wid
)
{
    //
    // Iterate over all the segments and locate the segment in
    // which the given workid is present.
    //
    for ( CFwdTableSegIter iter(_segList); !_segList.AtEnd(iter) ;
          _segList.Advance(iter) )
    {
        CTableSegment & segment = *iter.GetSegment();
        if ( segment.IsRowInSegment( wid ) )
            break;
    }

    CTableSegment * pSeg = 0;
    if ( !_segList.AtEnd(iter) )
    {
        pSeg = iter.GetSegment();
    }

    return pSeg;
}

//+---------------------------------------------------------------------------
//
//  Function:   _LokSplitWindow
//
//  Synopsis:   Splits the given window into two and replaces the source
//              window with two windows.
//
//  Arguments:  [ppWindow]    -   Source window that needs to be split.
//                                If successful, will be set to NULL on
//                                return.
//              [iSplitQuery] -   Offset in the rowIndex that is used by
//                                query as the split point.
//
//  Returns:    Pointer to the "left" window after split.
//
//  History:    2-06-95   srikants   Created
//
//  Notes:      Destroys the source window after split.
//
//----------------------------------------------------------------------------

CTableSegment * CLargeTable::_LokSplitWindow( CTableWindow ** ppWindow,
                                           ULONG iSplitQuery )
{
    Win4Assert( 0 != ppWindow );
    CTableWindow * pWindow = *ppWindow;
    Win4Assert( 0 != pWindow );

    CTableWindow * pLeft = 0;
    CTableWindow * pRight = 0;

    {
        CTableWindowSplit   split( *pWindow,
                                   iSplitQuery,
                                   pWindow->GetSegId(), _AllocSegId(),
                                   _segList.IsLast( *pWindow ) );

        //
        // Create empty target windows.
        //
        split.CreateTargetWindows();

        tbDebugOut(( DEB_WINSPLIT, "CLargeTable::Splitting Window\n" ));
        //
        // Do the actual split.
        //
        split.DoSplit();

        //
        // Take ownership of the newly created windows.
        //
        split.TransferTargetWindows( &pLeft, &pRight );
        Win4Assert( 0 != pLeft && 0 != pRight );

    }

    //
    // Replace the pWindow in the list with the two new ones.
    //
    CTableSegList   windowList;
    windowList.Push( pRight );
    windowList.Push( pLeft );

    _segListMgr.Replace( pWindow, windowList );
    Win4Assert( windowList.IsEmpty() );

    //
    // Update the watch regions from the source window to destination
    // window.
    //
    for ( CWatchIter  iter(_watchList) ;
          !_watchList.AtEnd(iter);
          _watchList.Advance(iter) )
    {
        HWATCHREGION hWatch = iter->Handle();
        CWatchRegion * pRegion = iter.Get();

        if ( pRegion->Segment() == pWindow )
        {
            CTableWindow * pNewStartWindow;

            if ( pLeft->HasWatch(hWatch) )
            {
                pNewStartWindow = pLeft;
            }
            else
            {
                Win4Assert( pRight->HasWatch(hWatch) );
                pNewStartWindow = pRight;
            }

            ULONG iWatch = (ULONG) pNewStartWindow->GetWatchStart(hWatch);
            CI_TBL_BMK bmkNew = pNewStartWindow->GetBookMarkAt( iWatch );
            iter->UpdateSegment( pWindow, pNewStartWindow, bmkNew  );
        }

#if CIDBG==1
        _watchList.CheckRegionConsistency( pRegion );
#endif  // CIDBG==1

    }

    //
    // Destroy the source window.
    //
    delete pWindow;
    *ppWindow = 0;

    //
    // Update the mru cache to reflect the split.
    //
    _segListMgr.UpdateSegsInUse( pLeft );
    _segListMgr.UpdateSegsInUse( pRight );

    return pRight;
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::PathToWorkID, public
//
//  Synopsis:   Convert a file path name to a work ID.  For down-level
//              stores, the file systems do not return a value which
//              can be reliably used as a WorkID, so we use the file
//              path name as the unique identifier of a file.  This
//              method will use the path column compressor to provide
//              a unique ID over the table given the input path name.
//
//  Arguments:  [obj]      -- a reference to an object retriever which can
//                            return object data
//              [eRowType] -- the type of row being added.
//
//  Returns:    WORKID - a unique value over the table for this row.
//
//  Notes:
//
//--------------------------------------------------------------------------

WORKID CLargeTable::PathToWorkID( CRetriever& obj,
                                  CTableSink::ERowType eRowType )
{
    Win4Assert( !_fUniqueWorkid );

    if ( _fUniqueWorkid )
    {
        PROPVARIANT var;
        ULONG   cb = sizeof(var);

        if ( obj.GetPropertyValue( pidWorkId, &var, &cb ) != GVRSuccess )
            return widInvalid;
        else
        {
            Win4Assert( var.vt == VT_I4 );
            return var.lVal;
        }
    }
    else
    {
        WORKID ulRet = 0;
        GetValueResult eGvr;

        CColumnMasterDesc* pMastCol;

        CLock   lock(_mutex);

        pMastCol = _MasterColumnSet.Find( pidPath );
        Win4Assert(pMastCol != NULL && pMastCol->IsCompressedCol());

        struct
        {
            PROPVARIANT v;
            WCHAR awch[512];         // don't force new every time
        } varnt;
        PROPVARIANT* pVarnt = &(varnt.v);
        ULONG cbBuf = sizeof varnt;

        XArray<BYTE>  xByte;

        eGvr = obj.GetPropertyValue(pMastCol->PropId, pVarnt, &cbBuf);

        if (eGvr == GVRNotEnoughSpace)
        {
            Win4Assert(cbBuf <= TBL_MAX_DATA + sizeof (PROPVARIANT));

            pVarnt = (CTableVariant *) new BYTE[cbBuf];
            xByte.Set( cbBuf, (BYTE *)pVarnt );
            Win4Assert (pVarnt != NULL);
            eGvr = obj.GetPropertyValue(pMastCol->PropId,
                                                  pVarnt, &cbBuf);
        }

        if ( GVRSuccess != eGvr )
        {
            THROW( CException(CRetriever::NtStatusFromGVR(eGvr)) );
        }

        BOOL fFound = FALSE;
        if ( CTableSink::eNewRow != eRowType )
        {
            // try to find an existing path before adding it

            fFound = pMastCol->GetCompressor()->FindData( pVarnt, ulRet );
        }

        if ( ! fFound )
            pMastCol->GetCompressor()->AddData(pVarnt, &ulRet, eGvr);

        Win4Assert(eGvr == GVRSuccess && ulRet != 0);

        return ulRet;
    }
} //PathToWorkID

//+---------------------------------------------------------------------------
//
//  Function:   WorkIdToPath
//
//  Synopsis:   Converts a workid to a path.
//
//  Arguments:  [wid]      -   WID whose path is needed
//              [outVarnt] -   on output will have the path as a variant
//              [cbVarnt]  -   in/out max len on input; actual len on
//                             output. If the return value is FALSE, this will
//                             indicate the lenght of variant needed.  If on
//                             output this is 0 and the return value is FALSE,
//                             wid->path operation failed.
//
//  Returns:    TRUE if we succeeded in getting the path.
//              FALSE if we failed.
//
//  History:    3-24-95   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CLargeTable::WorkIdToPath( WORKID wid, CInlineVariant & outVarnt,
                                ULONG & cbVarnt )
{
    Win4Assert( !_fUniqueWorkid );

    if ( _fUniqueWorkid )
        return FALSE;

    CLock   lock( _mutex );

    CColumnMasterDesc* pMastCol = _MasterColumnSet.Find( pidPath );
    Win4Assert( pMastCol );
    CCompressedCol & pathCompressor = *(pMastCol->GetCompressor());

    CTableVariant pathVarnt;
    XCompressFreeVariant xpvarnt;

    BOOL fStatus = FALSE;

    if ( GVRSuccess ==
         pathCompressor.GetData( &pathVarnt, VT_LPWSTR, wid, pidPath ) )
    {
        xpvarnt.Set( &pathCompressor, &pathVarnt );

        //
        // Copy the data from the variant to the buffer.
        //
        const ULONG cbHeader  = sizeof(CInlineVariant);
        ULONG cbVarData = pathVarnt.VarDataSize();
        ULONG cbTotal   = cbVarData + cbHeader;

        if ( cbVarnt >= cbTotal )
        {
            CVarBufferAllocator bufAlloc( outVarnt.GetVarBuffer(), cbVarData );
            bufAlloc.SetBase(0);
            pathVarnt.Copy( &outVarnt, bufAlloc, (USHORT) cbVarData, 0 );
            fStatus = TRUE;
        }

        cbVarnt = cbTotal;
    }
    else
    {
        cbVarnt = 0;
    }

    return fStatus;
} //WorkIdToPath

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::_LokRemoveCategorizedRow, private
//
//  Synopsis:   Removes a row from the categorization.
//
//  Arguments:  [chapt]    -- chapter from which removal is done
//              [wid]      -- wid to remove
//              [widNext]  -- the next wid in the table, can be widInvalid
//              [pSegment] -- segment from which widNext can be computed if
//                            not specified.
//
//  History:    ?             dlee  Created
//
//--------------------------------------------------------------------------

void CLargeTable::_LokRemoveCategorizedRow(
    CI_TBL_CHAPT    chapt,
    WORKID          wid,
    WORKID          widNext,
    CTableSegment * pSegment )
{
    if ( IsCategorized() )
    {
        if ( widInvalid == widNext )
        {
            // sigh.  We need to find the workid of the row after the
            // row just deleted in the case that the deleted row was the
            // first row in a category and not the only row in the category,
            // since the categorizers need to keep track of the first wid
            // in a category.  widNext is widInvalid if the deleted row
            // was the last row in the window.

            for ( CFwdTableSegIter iter( _segList );
                  !_segList.AtEnd( iter );
                  _segList.Advance( iter ) )
            {
                CTableSegment * pNextSeg = iter.GetSegment();
                if ( pNextSeg == pSegment )
                {
                    _segList.Advance( iter );

                    if ( !_segList.AtEnd( iter ) )
                    {
                        CTableWindow * pWindow = iter.GetWindow();

                        widNext = pWindow->GetFirstBookMark();
                    }

                    break;
                }

                _segList.Advance(iter);
            }
        }

        pSegment->GetCategorizer()->RemoveRow( chapt, wid, widNext );
    }
} //_LokRemoveCategorizedRow


//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::PutRow, public
//
//  Synopsis:   Add a row to a large table
//
//  Arguments:  [obj]      -- a reference to an object retriever which can
//                            return object data
//              [eRowType] -- the type of row being added.
//
//  Returns:    TRUE if progress report needed
//
//--------------------------------------------------------------------------

BOOL CLargeTable::PutRow( CRetriever& obj, CTableSink::ERowType eRowType )
{
    CReleasableLock relLock( _mutex, FALSE );

    if ( FALSE == relLock.Try() )
    {
        // Unable to get bigtable lock. Maybe GetRows is holding bigtable
        // lock and is waiting on propstore lock which this thread might
        // be holding. So rlease that and try again.
        obj.Quiesce();
        relLock.Request();  // If we deadlock now, then we need to fix that !
    }

    //
    // The query may be in the process of being deleted if it has been
    // cancelled during query execution.  In this case, the _pQExecute will
    // have been set to 0 by the call to ReleaseQueryExecute() in
    // ~CAsyncQuery.
    //

    if ( 0 == _pQExecute )
        return FALSE;

    TRY
    {
        WORKID widRow = obj.WorkId();

        //
        // Check if it already exists in one of the segments based
        // on its workid.
        //
        CTableSegment *pSegment = 0;

        if ( CTableSink::eNotificationRow == eRowType )
        {
            //
            // If the table is not watched, do not process notifications.
            //
            if ( !_LokIsWatched() )
            {
                return _fProgressNeeded;
            }
            else if ( _LokIsPutRowDeferred( widRow, obj ) )
            {
                _bitRefresh = 1;
                LokCompleteAsyncNotification();
                return _fProgressNeeded;
            }
        }
        else if ( CTableSink::eNewRow != eRowType )
        {
            //
            // NOSUPPORT: This will not work with LINKS. We have to look at
            // table irrespective of whether this is a notification or not.
            // Of course, we don't support links.
            //
            //
            pSegment = _LokFindTableSegment( obj.WorkId() );
        }

        if ( 0 != pSegment )
        {
            //
            // Modifications are to be treated as deletions followed by
            // additions.
            //

            //
            // First delete the current row and then add the new row.
            // If the "key" of this row is different from the one already
            // in the table, the new row may end up in a different bucket
            // than the original.
            //
            PROPVARIANT varWid;
            varWid.lVal = (LONG) obj.WorkId();
            varWid.vt = VT_I4;
            tbDebugOut(( DEB_BOOKMARK, "CLargeTable - Delete And ReAdd WorkId 0x%X\n",
                         varWid.lVal ));
            WORKID widNext;
            CI_TBL_CHAPT chapt;

            //
            // Delete the row and then add a new one.
            //
            pSegment->RemoveRow( varWid, widNext, chapt );
            _LokRemoveCategorizedRow( chapt,
                                      obj.WorkId(),
                                      widNext,
                                      pSegment );

        }
        else
        {
            pSegment = _segListMgr.GetCachedPutRowSeg();
        }

        CTableRowPutter rowPutter( *this, obj );

        pSegment = rowPutter.LokFindSegToInsert( pSegment );
        Win4Assert( 0 != pSegment );

        //
        // If the current segment is getting full, we should either split it
        // or create a new one.
        //
        if ( pSegment->IsGettingFull() )
            pSegment = rowPutter.LokSplitOrAddSegment( pSegment );

        Win4Assert( 0 != pSegment );
        Win4Assert( pSegment->GetLowestKey().IsInitialized() );
        Win4Assert( pSegment->GetHighestKey().IsInitialized() );

        BOOL fRowThrownAway = FALSE;

        // Check for Row limit...

        ULONG cRowLimit = FirstRows();
        tbDebugOut(( DEB_ITRACE, "CLargeTable::PutRow: FirstRows is %d, MaxRows is %d\n", FirstRows(), MaxRows() ));

        BOOL fFirstRows = cRowLimit > 0;

        if (  !fFirstRows )
            cRowLimit = MaxRows();
        
        tbDebugOut(( DEB_ITRACE, "CLargeTable::PutRow: RowCount() is %d\n", RowCount() ));
        tbDebugOut(( DEB_ITRACE, "CLargeTable::PutRow: cRowLimit is %d\n", cRowLimit ));

        if ( 0 == cRowLimit || RowCount() < cRowLimit ) 
        {
            pSegment->PutRow( obj, _currRow.GetReference() );
        }
        else
        {
            // We are here. Therefore it means that:
            // There is a maxrow limit set AND rowcount >= maxrows AND
            // we have at least one segment which has at least one row...

            // Note: The special case of sort by rank descending is handled
            // by CQAsyncExecute::Resolve in which case we only get rows less
            // than equal to MaxRows (in case MaxRows is defined)

            if ( !fFirstRows )
            { 
                if ( !_fSortDefined )
                {
                    // Since not sort order is defined, we can stop processing of 
                    // rows here, since we have all the data that we need
                    _fNoMoreData = fRowThrownAway = TRUE;
                }
                else
                {
                    _currRow->MakeReady();

                    // There is a sort defined. So we need to process all the
                    // rows and put the best results in the maxrow rows

                    CTableSegment* pLastSegment = _segListMgr.GetList().GetLast();
                    Win4Assert( pLastSegment );

                    // Now we need to make sure that the last segment is a window
                    // and it has at least one row in it. This is done because
                    // a bucket does not support the kind of operations that
                    // we are planning to do here on...

                    while ( !pLastSegment->IsWindow() || 0 == pLastSegment->RowCount() )
                    {
                        if ( 0 == pLastSegment->RowCount() )
                        {
                            // delete this segment
                            _segListMgr.RemoveFromList( pLastSegment );
                            delete pLastSegment;
                            pLastSegment = _segListMgr.GetList().GetLast();
                            Win4Assert( pLastSegment );
                            continue;
                        }

                        if ( !pLastSegment->IsWindow() )
                        {
                            // Convert it to a window

                            Win4Assert( pLastSegment->IsBucket() );

                            obj.Quiesce();

                            XPtr<CTableBucket> xBktToExpand( (CTableBucket*)pLastSegment );

                            CDoubleTableSegIter iter( pLastSegment );
                            _LokReplaceWithEmptyWindow( iter );

                            _NoLokBucketToWindows( xBktToExpand, 0, FALSE, FALSE );

                            pLastSegment = _segListMgr.GetList().GetLast();
                            Win4Assert( pLastSegment );

                            // pSegment may no longer exist -- look it up again

                            CTableRowPutter rp( *this, obj );
                            pSegment = rp.LokFindSegToInsert( 0 );
                            Win4Assert( 0 != pSegment );
                        }
                    }

                    if ( ( pLastSegment == pSegment ) &&
                         ( _keyCompare->Compare( _currRow.GetReference(),
                                                 pSegment->GetHighestKey() ) > 0 ) )
                    {
                        // Since the current row is worse than the our worst row,
                        // we can throw it away
                         fRowThrownAway = TRUE;

                        // NEWFEATURE: update counter of thrown rows
                    }   
                    else
                    {
                        // CurrRow is better than (at least) our worst row
                        // Delete the last row in the last segment and insert
                        // the new row. This would keep RowCount == MaxRows

                        PROPVARIANT varWid;
                        varWid.lVal = (LONG) ((CTableWindow*)pLastSegment)->
                            _GetLastWorkId();
                        Win4Assert( widInvalid != varWid.lVal );
                        varWid.vt = VT_I4;

                        WORKID widNext;
                        CI_TBL_CHAPT chapt;

                        pLastSegment->RemoveRow( varWid, widNext, chapt );
                        _LokRemoveCategorizedRow( chapt,
                                                  varWid.lVal,
                                                  widNext,
                                                  pLastSegment );

                        // Insert the new row
                        pSegment->PutRow( obj, _currRow.GetReference() );

                        if ( 0 == pLastSegment->RowCount() )
                        {
                            // remove this segment
                            _segListMgr.RemoveFromList( pLastSegment );
                            delete pLastSegment;
                        }
                    }
                }
            }           
        }     
        
        if ( !fRowThrownAway )
        {
            _segListMgr.SetCachedPutRowSeg( pSegment );
                
            if ( rowPutter.LokIsNewWindowCreated() &&
                 ( ! _fRankVectorBound ) &&
                 ( ! IsCategorized() ) &&
                 ( _fUniqueWorkid ) ) // don't bucketize ::_noindex_:: catalogs
            {
                _LokConvertWindowsToBucket();
            }    

            _bitRefresh = 1;
            LokCompleteAsyncNotification();
        }
    }
    CATCH( CException, e )
    {
        if ( e.GetErrorCode() != STATUS_FILE_DELETED )
        {
            RETHROW();
        }
    }
    END_CATCH

    return _fProgressNeeded;
} //PutRow

//+---------------------------------------------------------------------------
//
//  Member:     CLargeTable::_LokDeferPutRow
//
//  Synopsis:
//
//  Arguments:  [wid] -
//
//  Returns:
//
//  History:    8-01-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
inline
void CLargeTable::_LokDeferPutRow(
    WORKID       wid,
    CRetriever & obj )
{
    Win4Assert( 0 != _pSortSet );

    if ( 0 == _pDeferredRows )
    {
        _pDeferredRows = new CTableBucket( *_pSortSet,
                                           _keyCompare.GetReference(),
                                           _MasterColumnSet,
                                           _AllocSegId() );

    }

    PROPVARIANT vRank;
    ULONG cbRank = sizeof vRank;
    obj.GetPropertyValue( pidRank, &vRank, &cbRank );

    Win4Assert( VT_I4 == vRank.vt );

    PROPVARIANT vHitCount;
    ULONG cbHitCount = sizeof vHitCount;
    obj.GetPropertyValue( pidHitCount, &vHitCount, &cbHitCount );

    Win4Assert( VT_I4 == vHitCount.vt );

    _pDeferredRows->_AddWorkId( wid,
                                vRank.lVal,
                                vHitCount.lVal );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLargeTable::_LokIsPutRowDeferred
//
//  Synopsis:   If the workid given is being watched and the client knows
//              about its existence, then we must defer the addition of
//              this row until later.
//
//  Arguments:  [wid] -
//
//  Returns:
//
//  History:    8-01-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CLargeTable::_LokIsPutRowDeferred( WORKID widRow, CRetriever &obj )
{
    Win4Assert( _LokIsWatched() );

    PROPVARIANT varWid;
    varWid.lVal = (LONG) widRow;
    varWid.vt = VT_I4;

    WORKID widNext;

    BOOL fDeferred = FALSE;

    for ( CFwdTableSegIter iter(_segList); !_segList.AtEnd(iter);
          _segList.Advance(iter) )
    {
        CTableSegment * pSegment = iter.GetSegment();

        WORKID widNext;
        CI_TBL_CHAPT chapt;

        //
        // NEWFEATURE: (windowed notifications)
        // This is not correct. We should remove it only if soft
        // deletions are being done on a window. If it is a hard delete,
        // we  must wait until a refresh is called. May need a different
        // data structure for the case of watch all - a bucket will not
        // suffice.
        //
        if ( pSegment->RemoveRow(varWid, widNext, chapt) )
        {
            _LokRemoveCategorizedRow( chapt,
                                      widRow,
                                      widNext,
                                      pSegment );

            if ( pSegment->IsWindow() )
            {
                CTableWindow * pWindow = iter.GetWindow();
                if ( pWindow->IsPendingDelete( widRow ) )
                {
                    _LokDeferPutRow( widRow, obj );
                    fDeferred = TRUE;
                }
            }

            break;
        }
    }

    return fDeferred;

}

//+---------------------------------------------------------------------------
//
//  Member:     CLargeTable::_LokRemoveIfDeferred
//
//  Synopsis:
//
//  Arguments:  [wid] -
//
//  Returns:
//
//  History:    8-01-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CLargeTable::_LokRemoveIfDeferred( WORKID wid )
{
    BOOL fRemoved = FALSE;

    if ( 0 != _pDeferredRows )
    {

        PROPVARIANT varWid;
        varWid.lVal = (LONG) wid;
        varWid.vt = VT_I4;

        WORKID widNext;
        CI_TBL_CHAPT chapt;

        fRemoved = _pDeferredRows->RemoveRow( varWid, widNext, chapt );
    }

    return fRemoved;
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::_LokCheckQueryStatus, private
//
//  Synopsis:   Fail a request if the query has encountered an error.
//
//  Arguments:  - NONE -
//
//  Returns:    Nothing, throws E_FAIL on error.
//
//--------------------------------------------------------------------------

void       CLargeTable::_LokCheckQueryStatus( )
{
    if (QUERY_FILL_STATUS( Status() ) == STAT_ERROR)
    {
        NTSTATUS sc = GetStatusError();
        Win4Assert( sc != STATUS_SUCCESS );
        tbDebugOut(( DEB_WARN,
                     "Bigtable 0x%x Query failed, sc = %x\n",
                     this, sc));
        if (sc == STATUS_SUCCESS)
            sc = E_FAIL;

        THROW( CException( sc ));
    }
    else if ( _fAbort )
    {
        THROW( CException( STATUS_TOO_LATE ) );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::GetRows, public
//
//  Synopsis:   Retrieve row data from a large table.
//
//  Arguments:  [widStart] - WORKID identifying first row to be
//                      transferred.  If WORKID_TBLFIRST is
//                      used, the transfer will start at the first
//                      row in the segment.
//              [chapt]    - Chapter from which to fetch rows (if chaptered)
//              [rOutColumns] - a CTableColumnSet that describes the
//                      output format of the data table.
//              [rGetParams] - an CGetRowsParams structure which
//                      describes how many rows are to be fetched and
//                      other parameters of the operation.
//              [rwidLastRowTransferred] - on return, the work ID of
//                      the last row to be transferred from this table.
//                      Can be used to initialize widStart on next call.
//
//  Returns:    SCODE - status of the operation.  DB_S_ENDOFROWSET if
//                      widStart is WORKID_TBLAFTERLAST at start of
//                      transfer, or if rwidLastRowTransferred is the
//                      last row in the segment at the end of the transfer.
//
//                      DB_S_BUFFERTOOSMALL is returned if the available
//                      space in the out-of-line data was exhausted during
//                      the transfer.
//
//  Notes:      To transfer successive rows, as in GetNextRows, the
//              rwidLastRowTransferred must be advanced by one prior
//              to the next transfer.
//
//--------------------------------------------------------------------------

SCODE       CLargeTable::GetRows(
    HWATCHREGION            hRegion,
    WORKID                  widStart,
    CI_TBL_CHAPT            chapt,
    CTableColumnSet const & rOutColumns,
    CGetRowsParams &        rGetParams,
    WORKID &                rwidLastRowTransferred
)
{
    return GetRowsAt( hRegion, widStart, chapt, 0, rOutColumns,
                      rGetParams, rwidLastRowTransferred );

}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::RestartPosition, public
//
//  Synopsis:   Set next fetch position for the chapter to the start
//
//  Arguments:  [chapt]    - Chapter from which to fetch rows (if chaptered)
//
//  Returns:    SCODE - status of the operation.
//
//--------------------------------------------------------------------------

void       CLargeTable::RestartPosition(
    CI_TBL_CHAPT           chapt)
{
    SetCurrentPosition( chapt, WORKID_TBLBEFOREFIRST );
    CTableSource::RestartPosition( chapt );
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::RowCount, public
//
//  Synopsis:   Return the total row count in the table
//
//  Returns:    ULONG - row count aggregated over all segments in the
//                      table.
//
//--------------------------------------------------------------------------

DBCOUNTITEM CLargeTable::RowCount()
{
    CLock   lock(_mutex);
    _LokCheckQueryStatus();

    return _LokRowCount();
}


//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::_LokRowCount, public
//
//  Synopsis:   Return the total row count in the table
//
//  Returns:    ULONG - row count aggregated over all segments in the
//                      table.
//
//--------------------------------------------------------------------------

DBCOUNTITEM   CLargeTable::_LokRowCount()
{

    DBCOUNTITEM cRowsTotal = 0;

    for ( CFwdTableSegIter iter(_segList); !_segList.AtEnd(iter); _segList.Advance(iter) )
    {
        cRowsTotal += iter.GetSegment()->RowCount();
    }

    return cRowsTotal;
}


//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::RatioFinished
//
//  Synopsis:   Return query progress
//
//  Arguments:  [ulDeneominator] - on return, denominator of fraction
//              [ulNumerator] - on return, numerator of fraction
//              [cRows] - on return, number of rows in table
//
//  Notes:      For the fQuick case, we could try doing a quick
//              synchronization with the CAsyncExecute to compute
//              a good value for the ratio, but the implementation
//              below is fine for the Gibraltar query since no callers
//              will use the ratio anyway.
//
//              A sketch of the code needed to do the quick synchronization
//              is below:
//                  BOOL CAsyncExecute::QuickRF( ULONG &ulDen, ULONG &ulNum )
//                  {
//                      CLock lock(_mutex);
//                      if (_fRunning)
//                          return FALSE;
//                      else
//                      {
//                          _pCurResolve->RatioFinished( ulDen, ulNum );
//                          return TRUE;
//                      }
//                  }
//
//
//  History:    Mar-20-1995 BartoszM    Created
//
//--------------------------------------------------------------------------

void CLargeTable::RatioFinished (
    DBCOUNTITEM& ulDenominator,
    DBCOUNTITEM& ulNumerator,
    DBCOUNTITEM& cRows )
{
    CLock lock(_mutex);
    _LokCheckQueryStatus();

    if (_fQuiescent)
    {
        cRows = _LokRowCount();
        ulDenominator = ulNumerator = 100;
        return;
    }
    _fProgressNeeded = TRUE;

    ulDenominator = _ulProgressDenom;
    ulNumerator =   _ulProgressNum;
    cRows = _LokRowCount();
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::ProgressDone, public
//
//  Synopsis:   Sets the progress indicators and wakes up
//              the client
//
//  Arguments:  [ulDenominator]
//              [ulNumerator]
//
//  History:    Mar-21-95   BartoszM    Created
//
//--------------------------------------------------------------------------

void  CLargeTable::ProgressDone (ULONG ulDenominator, ULONG ulNumerator)
{
    tbDebugOut(( DEB_ITRACE, "CLargeTable reporting progress %ld / %ld\n",
                ulNumerator, ulDenominator ));
    CLock lock(_mutex);
    _fProgressNeeded = FALSE;
    _ulProgressDenom = ulDenominator;
    _ulProgressNum   = ulNumerator;
}

void CLargeTable::Quiesce ()
{
    TRY
    {
        CLock lock(_mutex);
    
        tbDebugOut(( DEB_NOTIFY, "CLargeTable reached quiescent state\n" ));
    
        Win4Assert( QUERY_FILL_STATUS( Status() ) == STAT_DONE ||
                    QUERY_FILL_STATUS( Status() ) == STAT_ERROR );
        _fProgressNeeded = FALSE;
        _fQuiescent = TRUE;
        _ulProgressDenom = 100;
        _ulProgressNum   = 100;
    
        // don't tell the client we quiesced more than once
    
        tbDebugOut(( DEB_ITRACE, "CLargeTable::Quiesce: _bitQuiesced is %d\n", _bitQuiesced ));
        if ( 0 == _bitQuiesced )
        {
            _bitChangeQuiesced = 1;
            _bitQuiesced = 1;
            LokCompleteAsyncNotification();
        }
    
        // inform the client once that we're complete
    
        if ( 0 != _pQuiesce )
        {
            _pQuiesce->QueryQuiesced( TRUE, _scStatus );
            _pQuiesce = 0;
        }
    }
    CATCH( CException, e )
    {
        // ignore the exception; it may be in a unwind path
    }
    END_CATCH;
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::GetApproximatePosition, public
//
//  Synopsis:   Return the approximate current position as a fraction
//
//  Arguments:  [chapt] -        chapter
//              [bmk] -          bookmark
//              [pulNumerator] - on return, numerator of fraction
//              [pulRowCount] -  on return, denominator of fraction (row count)
//
//  Returns:    SCODE - the status of the operation.
//
//  Notes:      The denominator of the fraction is the approximate
//              row count in the table or chapter.
//
//--------------------------------------------------------------------------

SCODE
CLargeTable::GetApproximatePosition(
    CI_TBL_CHAPT chapt,
    CI_TBL_BMK   bmk,
    DBCOUNTITEM *       pulNumerator,
    DBCOUNTITEM *       pulRowCount
)
{
    CLock   lock(_mutex);
    _LokCheckQueryStatus();

    if (bmk == widInvalid)
        return DB_E_BADBOOKMARK;

    Win4Assert (bmk != WORKID_TBLBEFOREFIRST && bmk != WORKID_TBLAFTERLAST);

    DBCOUNTITEM iBmkPosition = ULONG_MAX;

    DBCOUNTITEM cRows = 0;

    if ( IsCategorized() && DB_NULL_HCHAPTER != chapt )
    {
        cRows = GetCategorizer()->GetRowCount( chapt );

        if ( WORKID_TBLFIRST == bmk )
        {
            iBmkPosition = 1;
            if (cRows == 0)
                iBmkPosition = 0;
        }
        else if ( WORKID_TBLLAST == bmk )
        {
            iBmkPosition = cRows;
        }
        else
        {
            WORKID widFirst = GetCategorizer()->GetFirstWorkid( chapt );

            CFwdTableSegIter iter( _segList );
            DBCOUNTITEM cChaptRows = 0;
            BOOL fFoundFirstYet = FALSE;

            while ( !_segList.AtEnd(iter) )
            {
                ULONG iRow = 0;

                CTableSegment * pSegment = iter.GetSegment();
                if ( pSegment->IsWindow() )
                {
                    CTableWindow * pWindow = iter.GetWindow();

                    ULONG iFirstRow;
                    if ( !fFoundFirstYet &&
                         pWindow->RowOffset( widFirst, iFirstRow ) )
                    {
                        if ( pWindow->RowOffset(bmk, iRow) )
                        {
                            iBmkPosition = iRow - iFirstRow + 1;
                            break;
                        }
                        else
                        {
                            cChaptRows = pSegment->RowCount() - iFirstRow;
                            fFoundFirstYet = TRUE;
                        }
                    }
                    else if ( pWindow->RowOffset(bmk, iRow) )
                    {
                        //  We can't have set the numerator previously.
                        Win4Assert(iBmkPosition == ULONG_MAX);
                        iBmkPosition = cChaptRows + iRow + 1;
                        break;
                    }
                    else if ( fFoundFirstYet )
                    {
                        cChaptRows += pSegment->RowCount();
                    }
                }
                else
                {
                    //  The chapter is in a bucket.  All rows in the
                    //  bucket are in the chapter, and the chapter
                    //  spans no other segments.

                    CTableBucket * pBucket = iter.GetBucket();
                    if ( pBucket->IsRowInSegment(bmk) )
                    {
                        Win4Assert( iBmkPosition == ULONG_MAX );

                        if ( pBucket->RowOffset(bmk, iRow) )
                        {
                            iBmkPosition = iRow + 1;
                        }
                        else
                        {
                            iBmkPosition = ((ULONG)pBucket->RowCount() + 1)/2;
                        }
                    }
                }

                _segList.Advance(iter);
            }
        }
    }
    else
    {
        if (bmk == WORKID_TBLFIRST)
        {
            iBmkPosition = 1;
            cRows = RowCount();
            if (cRows == 0)
                iBmkPosition = 0;
        }
        else if (bmk == WORKID_TBLLAST)
        {
            cRows = RowCount();
            iBmkPosition = cRows;
        }
        else
        {
            //
            // Iterate over all table segments prior to the table seg.
            // in which the bookmark occurs, adding their row counts to
            // iBmkPosition.  Accumulate the total row count at the same
            // time.
            //

            CFwdTableSegIter iter( _segList );
            while ( !_segList.AtEnd(iter) )
            {
                ULONG iRow = 0;

                CTableSegment * pSegment = iter.GetSegment();
                if ( pSegment->IsWindow() )
                {
                    CTableWindow * pWindow = iter.GetWindow();
                    if ( pWindow->RowOffset(bmk, iRow) )
                    {
                        //  We can't have set the numerator previously.
                        Win4Assert(iBmkPosition == ULONG_MAX);
                        iBmkPosition = cRows + iRow + 1;
                    }
                }
                else
                {
                    CTableBucket * pBucket = iter.GetBucket();
                    if ( pBucket->IsRowInSegment(bmk) )
                    {
                        Win4Assert( iBmkPosition == ULONG_MAX );

                        iBmkPosition = cRows;
                        if ( pBucket->RowOffset(bmk, iRow) )
                        {
                            iBmkPosition += iRow + 1;
                        }
                        else
                        {
                            iBmkPosition += ((ULONG)pBucket->RowCount() + 1)/2;
                        }
                    }
                }

                cRows += pSegment->RowCount();
                _segList.Advance(iter);
            }
        }
    }

    if (iBmkPosition == ULONG_MAX)
        return DB_E_BADBOOKMARK;

    Win4Assert(iBmkPosition <= cRows);

    *pulNumerator = iBmkPosition;
    *pulRowCount = cRows;

    return S_OK;
} //GetApproximagePosition

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::IsColumnInTable, public
//
//  Synopsis:   Check whether some column can be added to the table.
//              Used in support of CQuery::SetBindings; added columns
//              may only refeerence columns which already exist in the
//              table.
//
//  Arguments:  [PropId] - the property ID to be added to the table.
//
//  Returns:    BOOL - TRUE if it's okay to add the column.  False
//                      otherwise.
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL
CLargeTable::IsColumnInTable(
    PROPID PropId
) {

    CLock   lock(_mutex);

    //
    //  See if the column already exists in the master column set
    //
    if ( _MasterColumnSet.Find( PropId ) != 0 ) {
        return TRUE;
    } else {
        return FALSE;
    }
}

#if 0
//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::_LokLocateTableSegment, private
//
//  Synopsis:   Position a table segment iterator to the table segment
//              in which some work ID is found.
//
//  Arguments:  [rIter] - An iterator over table segments
//              [chapt] - Chapter in which to search for row
//              [wid]   - value to be searched for
//
//  Returns:    BOOL - TRUE if the work ID was found, FALSE if not.
//
//  Notes:
//
//--------------------------------------------------------------------------

WORKID
CLargeTable::_LokLocateTableSegment(
    CDoubleTableSegIter& rIter,
    CI_TBL_CHAPT         chapt,
    WORKID               wid
)
{
    Win4Assert( !_segList.AtEnd(rIter) );

    if ( IsSpecialWid( wid ) )
    {
        if ( IsCategorized() && DB_NULL_HCHAPTER != chapt )
        {
            if ( WORKID_TBLFIRST       == wid  ||
                 WORKID_TBLBEFOREFIRST == wid )
            {
                wid = GetCategorizer()->GetFirstWorkid( chapt );
            }
            else
            {
                // Heuristic: assume last row of [chapt] is in same window
                // as first row of [ next chapt ]

                wid = GetCategorizer()->GetFirstWorkidOfNextCategory( chapt );

                if ( widInvalid == wid )
                {
                    // chapt was the last chapter -- get the last segment

                    while ( !_segList.IsLast(rIter) )
                        _segList.Advance(rIter);
                    return TRUE;
                }
                else
                {
                    // check if this row (the first of the next chapter) is
                    // the first in the segment.  If so, back up to the prev
                    // segment.

                    Win4Assert( _segList.IsFirst(rIter) );
                    while ( !_segList.AtEnd(rIter) )
                    {
                        if ( rIter.GetSegment()->IsRowInSegment(wid) )
                        {
                            ULONG iRow;
                            CTableWindow * pWindow = rIter.GetWindow();
                            pWindow->RowOffset( wid, iRow );
                            if ( 0 == iRow )
                            {
                                // uh, oh.  Back up a segment.  The first row of
                                // the next category is the first row in the seg,
                                // so the last row of the categ must be in the
                                // prev segment.
                                Win4Assert( !_segList.IsFirst(rIter) );
                               _segList.BackUp(rIter);
                            }

                            return TRUE;
                        }
                       _segList.Advance(rIter);
                    }

                    tbDebugOut((DEB_WARN, "Got confused looking for %x\n", wid));
                    return FALSE;
                }
            }
        }
        else
        {
            //
            //  For the special cases of Beginning and End, just position to the
            //  correct end.
            //
            if (wid == WORKID_TBLBEFOREFIRST || wid == WORKID_TBLFIRST)
            {
                while ( !_segList.IsFirst(rIter) )
                    _segList.BackUp(rIter);
            }
            else
            {
                Win4Assert( wid == WORKID_TBLLAST ||
                            wid == WORKID_TBLAFTERLAST );

                while ( !_segList.IsLast(rIter) )
                    _segList.Advance(rIter);
            }

            return TRUE;
        }
    }

    //
    //  Locate the appropriate segment
    //  NOTE: we assume we start with a fresh iterator, so just go forward
    //

    Win4Assert( _segList.IsFirst(rIter) );
    while ( !_segList.AtEnd(rIter) )
    {
        if ( rIter.GetSegment()->IsRowInSegment(wid) )
        {
            return TRUE;
        }
        _segList.Advance(rIter);
    }
    tbDebugOut((DEB_WARN, "Work ID %x not found in table\n", wid));
    return FALSE;
}

#endif


//
//  Methods which call through to the constituent table segments.
//  These will in general just select one segment to call, or
//  iterate over all segments.
//

//+---------------------------------------------------------------------------
//
//  Function:   IsRowInSegment
//
//  Synopsis:   
//
//  Arguments:  [wid] - Workid of row to be found
//
//  Returns:    BOOL - TRUE if row is found, FALSE otherwise
//
//  History:    3-24-95   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CLargeTable::IsRowInSegment( WORKID wid )
{
    CLock   lock(_mutex);

    return (_LokFindTableSegment(wid) != 0);
}

//+---------------------------------------------------------------------------
//
//  Function:   SortOrder
//
//  Synopsis:
//
//  Returns:
//
//  History:    3-24-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CSortSet const & CLargeTable::SortOrder()
{
    //CLock   lock(_mutex);
    return( *_pSortSet );
}

//+---------------------------------------------------------------------------
//
//  Function:   RemoveRow
//
//  Synopsis:
//
//  Arguments:  [varUnique] -
//
//  Returns:
//
//  History:    3-24-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CLargeTable::RemoveRow( PROPVARIANT const & varUnique )
{

    CLock   lock(_mutex);

    if ( !_LokIsWatched() )
    {
        //
        // Do not process deletions unless the table is watched.
        //
        return;
    }


    WORKID widRow = widInvalid;

    if ( _fUniqueWorkid )
        widRow = varUnique.lVal;
    else
    {
        CColumnMasterDesc* pMastCol = _MasterColumnSet.Find( pidPath );
        Win4Assert(0 != pMastCol && pMastCol->IsCompressedCol());

        //
        // Convert the filename to a wid before deletion.
        //

        BOOL fFound = pMastCol->GetCompressor()->FindData( &varUnique,
                                                           widRow );

        // See if the delete wasn't in the table to begin with

        if ( !fFound )
            return;
    }

    if ( !_LokRemoveIfDeferred( widRow ) )
    {
        //
        // This row was not a deferred update. We must iterate through
        // the segments and remove it.
        //

        PROPVARIANT varWid;
        varWid.lVal = (LONG) widRow;
        varWid.vt = VT_I4;

        for ( CFwdTableSegIter iter(_segList); !_segList.AtEnd(iter);
              _segList.Advance(iter) )
        {
            CTableSegment * pSegment = iter.GetSegment();
            WORKID widNext;
            CI_TBL_CHAPT chapt;

             // No Hard Delete.
            if ( pSegment->RemoveRow( varWid, widNext, chapt ) )
            {
                _LokRemoveCategorizedRow( chapt,
                                          widRow,
                                          widNext,
                                          pSegment );
                break;
            }
        }
    }

    _bitRefresh = 1;
    LokCompleteAsyncNotification();
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::NeedToNotifyReset, private
//
//  Synopsis:   Checks if there is a need to notify the client
//              Resets the changeQuiesced bit if needed
//
//  Arguments:  [changeType] -- out, what change type
//
//  History:    Arp-4-95   BartoszM    Created
//
//--------------------------------------------------------------------------

BOOL CLargeTable::NeedToNotifyReset (DBWATCHNOTIFY& changeType)
{
    CLock lock (_mutex);
    return LokNeedToNotifyReset(changeType);
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::LokNeedToNotifyReset, private
//
//  Synopsis:   Checks if there is a need to notify the client
//              Resets the changeQuiesced bit if needed
//
//  Arguments:  [changeType] -- out, what change type
//
//  History:    Arp-4-95   BartoszM    Created
//
//--------------------------------------------------------------------------

BOOL CLargeTable::LokNeedToNotifyReset(DBWATCHNOTIFY& changeType)
{
    if (_bitRefresh )
    {
        if (!_bitClientNotified)
        {
            changeType = DBWATCHNOTIFY_ROWSCHANGED;
            return TRUE;
        }
    }
    else // no need to run changes
    {
        if (_bitChangeQuiesced)
        {
            changeType = (_bitQuiesced)? DBWATCHNOTIFY_QUERYDONE: DBWATCHNOTIFY_QUERYREEXECUTED;
            tbDebugOut(( DEB_NOTIFY, "changetype set to %d\n", changeType ));
            //
            // Reset the bit!
            //
            _bitChangeQuiesced = 0;
            return TRUE;
        }
    }
    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::NeedToNotify, private
//
//  Synopsis:   Checks if there is a need to notify the client
//
//  History:    29-Aug-95   dlee    Created
//
//--------------------------------------------------------------------------

BOOL CLargeTable::NeedToNotify()
{
    CLock lock (_mutex);
    return LokNeedToNotify();
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::LokNeedToNotify, private
//
//  Synopsis:   Checks if there is a need to notify the client
//
//  History:    29-Aug-95   dlee    Created
//
//--------------------------------------------------------------------------

BOOL CLargeTable::LokNeedToNotify()
{
    if (_bitRefresh )
    {
        if (!_bitClientNotified)
            return TRUE;
    }
    else if (_bitChangeQuiesced)
    {
        return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLargeTable::GetNotifications, private
//
//  Synopsis:   Retrieves the notification info from the query object
//              row data.
//
//  Arguments:  [rSync]    -- notification synchronization info
//              [rParams]  -- notification data info
//
//  Returns:    SCODE
//
//  History:    10-24-94     dlee      created
//
//----------------------------------------------------------------------------

SCODE CLargeTable::GetNotifications(
    CNotificationSync & rSync,
    DBWATCHNOTIFY     & changeType )
{
    tbDebugOut (( DEB_NOTIFY, "lt: GetNotifications\n" ));

    {
        CLock lock(_mutex);
        _bitNotifyEnabled = 1;

        // don't fail if the query failed -- report the notification that
        // the query completed.

        // _LokCheckQueryStatus();
    }

    SCODE sc = S_OK;

    {
        CLock lock(_mutex);

        Win4Assert( 0 == _pRequestServer );
        Win4Assert( 0 == _hNotifyEvent );

        if ( LokNeedToNotifyReset( changeType ) )
        {
            _bitClientNotified = 1;
            tbDebugOut (( DEB_NOTIFY, "complete in getnotify: %d\n",
                          changeType ));
            return S_OK;
        }
        else
        {
            if ( rSync.IsSvcMode() )
            {
                Win4Assert( 0 == _pRequestServer );
                _pRequestServer = rSync.GetRequestServer();
                Win4Assert( 0 != _pRequestServer );
                tbDebugOut (( DEB_NOTIFY, "getnotify returning pending\n" ));
                return STATUS_PENDING;
            }

            // Block on an event until notifications
            // arrive (or the table is going away).  If notifications
            // exist, grab them.  Also block on the notification cancel
            // event and report if that was received.

            Win4Assert( 0 == _hNotifyEvent );

            _hNotifyEvent = CreateEvent( 0, TRUE, FALSE, 0 );

            if ( 0 == _hNotifyEvent )
            {
                tbDebugOut(( DEB_ERROR, "Create event returned 0d\n",
                             GetLastError() ));
                THROW( CException() );
            }
        }
    }

    HANDLE aEvents[2];
    aEvents[0] = _hNotifyEvent;
    aEvents[1] = rSync.GetCancelEvent();

    ULONG wait = WaitForMultipleObjects( 2,
                                         aEvents,
                                         FALSE,
                                         INFINITE );

    CloseHandle( _hNotifyEvent );
    _hNotifyEvent = 0;

    if ( STATUS_WAIT_0 == wait )
    {
        CLock lock(_mutex);
        changeType = _changeType;
    }
    else if ( STATUS_WAIT_1 == wait )
    {
        sc = STATUS_CANCELLED;
    }
    else
    {
        Win4Assert(!"Unexpected return from WaitForMultipleObjects()");
    }

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::CreateWatchRegion
//
//  Synopsis:   Creates a new watch region
//
//  Arguments:  [mode] -- initial mode
//              [phRegion] -- (out) region handle
//
//  History:    Jun-16-95   BartoszM    Created
//
//--------------------------------------------------------------------------

void CLargeTable::CreateWatchRegion (ULONG mode, HWATCHREGION* phRegion)
{
    CLock   lock( _mutex );
    _bitIsWatched = 1;

    *phRegion = _watchList.NewRegion (mode);
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::ChangeWatchMode
//
//  Synopsis:   Changes watch mode of a region
//
//  Arguments:
//              [hRegion] -- region handle
//              [mode] -- new mode
//
//  History:    Jun-16-95   BartoszM    Created
//
//--------------------------------------------------------------------------

void CLargeTable::ChangeWatchMode (  HWATCHREGION hRegion, ULONG mode)
{
    CLock   lock( _mutex );
    _watchList.ChangeMode (hRegion, mode);
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::GetWatchRegionInfo
//
//  Synopsis:   Retrieves watch region information
//
//  Arguments:  [hRegion] -- region handle
//              [pChapter] -- (out) chapter
//              [pBookmark] -- (out) bookmark
//              [pcRows] -- (out) size in rows
//
//  History:    Jun-16-95   BartoszM    Created
//
//--------------------------------------------------------------------------

void CLargeTable::GetWatchRegionInfo ( HWATCHREGION hRegion,
                                      CI_TBL_CHAPT* pChapter,
                                      CI_TBL_BMK* pBookmark,
                                      DBROWCOUNT * pcRows)
{
    CLock   lock( _mutex );
    _watchList.GetInfo (hRegion, pChapter, pBookmark, (DBCOUNTITEM *)pcRows);
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::DeleteWatchRegion
//
//  Synopsis:   Delete watch region
//
//  Arguments:  [hRegion] -- region handle
//
//  History:    Jun-16-95   BartoszM    Created
//
//--------------------------------------------------------------------------

void CLargeTable::DeleteWatchRegion (HWATCHREGION hRegion)
{
    CLock   lock( _mutex );
    _watchList.DeleteRegion (hRegion);
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::ShrinkWatchRegion
//
//  Synopsis:   Shrinks watch region
//
//  Arguments:  [hRegion] -- region handle
//              [chapter] -- new chapter
//              [bookmark] -- new bookmark
//              [cRows] -- new size in rows
//
//  History:    Jun-16-95   BartoszM    Created
//
//--------------------------------------------------------------------------

void CLargeTable::ShrinkWatchRegion (HWATCHREGION hRegion,
                                    CI_TBL_CHAPT   chapter,
                                    CI_TBL_BMK     bookmark,
                                    LONG cRows )
{
    CLock   lock( _mutex );
    _watchList.ShrinkRegion (hRegion, chapter, bookmark, cRows);

#if CIDBG==1
    CWatchRegion * pRegion = _watchList.GetRegion(hRegion);
    _watchList.CheckRegionConsistency( pRegion );
#endif  //CIDBG==1

}



//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::Refresh
//
//  Synopsis:   Stub implementation
//
//  Arguments:  [] --
//
//  History:    Apr-4-95    BartoszM    Created
//              Jul-27-95   BartoszM   Implemented (with no change script)
//
//--------------------------------------------------------------------------

void CLargeTable::Refresh()
{
    CDynStack<CTableBucket>  xBktToConvert(0); // buckets to expand at our leisure

    {
        CLock lock (_mutex);
        _LokCheckQueryStatus();

        _bitClientNotified = 0;
        _bitRefresh = 0;


        // Update the bookmarks before refreshing windows.
        // We need to know where they will be migrating
        // in case rows were deleted.
        // Remove watch regions from windows

        for (CWatchIter iterWatch1 (_watchList);
            !_watchList.AtEnd(iterWatch1);
            _watchList.Advance(iterWatch1))
        {
            CWatchRegion* pRegion = iterWatch1.Get();

            if (pRegion->IsInit())
            {
                CTableWindow * pWindow = (CTableWindow *) pRegion->Segment();

                CI_TBL_BMK bookmark = _FindNearestDynamicBmk (
                    pWindow,
                    pRegion->Chapter(),
                    pRegion->Bookmark());

                pRegion->Set( pRegion->Chapter(),
                              bookmark,
                              pRegion->RowCount() );

                _watchList.ShrinkRegionToZero (pRegion->Handle());
            }
        }

        // Recreate new watch regions in windows
        // Find starting segments using bookmarks

        for (CWatchIter iterWatch3 (_watchList);
            !_watchList.AtEnd(iterWatch3);
            _watchList.Advance(iterWatch3))
        {
            CWatchRegion* pRegion = iterWatch3.Get();

            if ( pRegion->RowCount() > 0 )
            {
                Win4Assert( widInvalid != pRegion->Bookmark() );

                CTableSegment* pSegment = _LokFindTableSegment(pRegion->Bookmark());
                pRegion->SetSegment( pSegment );

                if ( 0 != pSegment )
                {
                    LokStretchWatchRegion (pRegion, xBktToConvert);
                    _watchList. BuildRegion (
                            pRegion->Handle(),
                            pSegment,
                            pRegion->Chapter(),
                            pRegion->Bookmark(),
                            pRegion->RowCount() );
                }
#if CIDBG==1
                _watchList.CheckRegionConsistency( pRegion );
#endif  // CIDBG==1
            }
        }

        //
        // If there are any deferred rows that were not added during the
        // normal "PutRow", we should expand them now.
        //
        if ( 0 != _pDeferredRows )
        {
            xBktToConvert.Push(_pDeferredRows);
            _pDeferredRows = 0;
        }

        if (_bitChangeQuiesced)
            LokCompleteAsyncNotification();
    }

    if ( xBktToConvert.Count() > 0 )
    {
        // Schedule buckets for asynchronous expansion
        _NoLokBucketToWindows( xBktToConvert, widInvalid, TRUE, FALSE );
    }
} //Refresh


void CLargeTable::LokStretchWatchRegion (  CWatchRegion* pRegion,
                                        CDynStack<CTableBucket>&  xBktToConvert)
{
    CTableWindow* pFirstWindow = (CTableWindow*) pRegion->Segment();
    Win4Assert (pFirstWindow->IsWindow());
    //
    // Compute the number of rows that can be retrieved from current window.
    //
    TBL_OFF dummy;
    ULONG     iRow;
    pFirstWindow->FindBookMark(pRegion->Bookmark(), dummy, iRow );

    ULONG cRowsToRetrieve = pRegion->RowCount();
    ULONG cRowsFromCurrWindow = (ULONG)pFirstWindow->RowCount() - iRow;

    if ( cRowsToRetrieve > cRowsFromCurrWindow )
    {
        //
        // We still have more rows to be retrieved.
        //
        cRowsToRetrieve -= cRowsFromCurrWindow;
    }
    else
    {
        //
        // This window can give us all the rows to be fetched.
        //
        return;
    }

    CDoubleTableSegIter iter (pRegion->Segment());

    do
    {
        Win4Assert( !_segList.AtEnd(iter) );

        _segList.Advance( iter );

        if ( _segList.AtEnd(iter) )
        {
            break;
        }

        if ( iter.GetSegment()->IsBucket() )
        {
            CTableBucket * pBucket = _LokReplaceWithEmptyWindow(iter);
            xBktToConvert.Push(pBucket);
        }
        else
        {
            CTableWindow * pWindow = iter.GetWindow();
            cRowsFromCurrWindow = (ULONG)pWindow->RowCount();

            if ( cRowsToRetrieve > cRowsFromCurrWindow )
            {
                cRowsToRetrieve -= cRowsFromCurrWindow;
            }
            else
            {
                cRowsToRetrieve = 0;
            }
        }
    }
    while ( cRowsToRetrieve > 0 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLargeTable::CancelAsyncNotification
//
//  Synopsis:   signals the notification event
//
//  History:    10-24-94     dlee      created
//
//  Notes:      can only be called from the destructor
//
//----------------------------------------------------------------------------

void CLargeTable::CancelAsyncNotification()
{
    if ( 0 != _pRequestServer )
    {
        //_pRequestServer->CompleteNotification( 0 );
        _pRequestServer = 0;
        return;
    }

    if ( 0 != _hNotifyEvent )
        SetEvent( _hNotifyEvent );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLargeTable::LokCompleteAsyncNotification
//
//  Synopsis:   signals the notification event
//
//  History:    10-24-94     dlee      created
//
//----------------------------------------------------------------------------

void CLargeTable::LokCompleteAsyncNotification()
{
    if (_bitClientNotified && !_bitChangeQuiesced)
        return; // no need to keep pinging the client

    Win4Assert( ! ( _pRequestServer && _hNotifyEvent ) );

    if ( 0 != _pRequestServer )
    {
        if ( LokNeedToNotifyReset( _changeType ) )
        {
            if ( DBWATCHNOTIFY_ROWSCHANGED == _changeType )
                _bitClientNotified = 1;

            tbDebugOut (( DEB_NOTIFY, "complete in lcan: %d\n",
                          _changeType ));

            _pRequestServer->CompleteNotification( _changeType );
            _pRequestServer = 0;
        }

        return;
    }

    if ( 0 != _hNotifyEvent )
    {
        if ( LokNeedToNotifyReset( _changeType ) )
        {
            if ( DBWATCHNOTIFY_ROWSCHANGED == _changeType )
                _bitClientNotified = 1;

            SetEvent( _hNotifyEvent );
            // event will be released / zeroed by notify thread.
        }
    }

} //LokCompleteAsyncNotification

//+---------------------------------------------------------------------------
//
//  Function:   _LokConvertToBucket
//
//  Synopsis:   Converts the given window into a bucket and replace the
//              window with a bucket.
//
//  Arguments:  [window] - The window to be converted into a bucket.
//
//  Returns:    The bucket that was created.
//
//  History:    3-24-95   srikants   Created
//
//----------------------------------------------------------------------------

void CLargeTable::_LokConvertToBucket( CTableWindow ** ppWindow )
{

    //
    // Convert the window into a bucket.
    //
    CTableWindow * pWindow = *ppWindow;
    Win4Assert( pWindow->IsWindow() );

    CBucketizeWindows   bucketize( *this, *pWindow );
    tbDebugOut(( DEB_WINSPLIT, "Converting 0x%X window to buckets\n",
                 pWindow->GetSegId() ));
    bucketize. LokCreateBuckets( *_pSortSet,
                                 _keyCompare.GetReference(),
                                 _MasterColumnSet );

    CTableSegList & bktList = bucketize.GetBucketsList();

    for ( CFwdTableSegIter iter2(bktList); !bktList.AtEnd(iter2);
          bktList.Advance(iter2) )
    {
        //
        // This information is needed for doing a wid->path translation
        //
        CTableBucket * pBucket = iter2.GetBucket();
        pBucket->SetLargeTable(this);
    }

    if ( 0 != bktList.GetSegmentsCount() )
    {
        _segListMgr.Replace( pWindow, bktList );
    }
    else
    {
        _segListMgr.RemoveFromList( pWindow );
    }

    *ppWindow = 0;
    delete pWindow;
} //_LokConvertToBucket

//+---------------------------------------------------------------------------
//
//  Function:   _LokConvertWindowsToBucket
//
//  Synopsis:   Uses heuristics to convert some of the windows into buckets
//              to reduce memory usage.
//
//  History:    3-24-95   srikants   Created
//
//  Notes:      This function needs a lot of work. For now, it just tries
//              to avoid converting windows that "were recently used". It
//              also tries to alternate windows and buckets if possible.
//
//              A heuristic used is NOT to convert the "last" window into a
//              bucket. This is because in case of content queries, the
//              results are probably coming sorted and we can use this fact.
//              Since new rows always go to the end, we will win by creating
//              well sorted buckets when windows are converted into buckets.
//
//              Also, don't convert a window to a bucket if it is < 40%
//              capacity.
//
//----------------------------------------------------------------------------

void CLargeTable::_LokConvertWindowsToBucket( WORKID widToPin )
{
    if ( _segList.GetWindowsCount() < cMaxWindows )
        return;

    unsigned cWindows = 0;
    BOOL     fConvert = TRUE;   // used to keep alternated segments as
                                // windows (approx)

    CBackTableSegIter   iter(_segList);

    while( !_segList.AtEnd(iter) )
    {
        CTableSegment * pSegment = iter.GetSegment();

        if ( pSegment->IsWindow() )
        {
            cWindows++;
            CTableWindow * pWindow = iter.GetWindow();
            ULONG cRows = (ULONG)pWindow->RowCount();

            if ( fConvert &&
                 cRows >= cMinRowsToBucketize &&
                 !pWindow->IsWatched() &&
                 !_segListMgr.IsRecentlyUsed(pWindow) &&
                 !_segList.IsLast(iter) &&
                 !_segList.IsFirst(iter) &&
                 ( widInvalid == widToPin || !pWindow->IsRowInSegment( widToPin ) ) )
            {
                //
                // The window may be deleted. So, we must backup the iterator
                // before destroying the window.
                //

                Win4Assert( widInvalid == widToPin ||
                            !pWindow->IsRowInSegment( widToPin ) );

                CTableWindow * pWindow = iter.GetWindow();
                _segList.BackUp(iter);

                _LokConvertToBucket( &pWindow );
                //
                // Don't convert the next segment into a bucket.
                //
                fConvert = FALSE;
            }
            else
            {
                _segList.BackUp(iter);
                //
                // We had a window which we didn't convert into a bucket.
                // If the next one is a window, we can convert it.
                //
                fConvert = TRUE;
            }
        }
        else
        {
            _segList.BackUp(iter);
        }
    }

    Win4Assert( cWindows >= cMaxWindows );
} //_LokConvertWindowsToBucket

//+---------------------------------------------------------------------------
//
//  Function:   _LokReplaceWithEmptyWindow
//
//  Synopsis:   Replaces the given bucket with an empty window in preparation
//              for bucket->window conversion.
//
//  Arguments:  [pBucket] -  The bucket to replace
//
//  History:    4-11-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CTableBucket *
CLargeTable::_LokReplaceWithEmptyWindow( CDoubleTableSegIter & iter )
{

    Win4Assert( iter.GetSegment()->IsBucket() );

    CTableBucket * pBucket = iter.GetBucket();

    tbDebugOut(( DEB_WINSPLIT,
                 "Replacing Bucket 0x%X with Window\n", pBucket->GetSegId() ));

    CTableWindow * pWindow = _CreateNewWindow( pBucket->GetSegId(),
                                               pBucket->GetLowestKey(),
                                               pBucket->GetHighestKey());
    _segListMgr.Replace( iter, pWindow );


    //
    // Make the newly created window preferred place to put the new
    // rows in.
    //
    _segListMgr.SetCachedPutRowSeg( pWindow );

    return pBucket;
}

//+---------------------------------------------------------------------------
//
//  Function:   _NoLokBucketToWindows
//
//  Synopsis:
//
//  Arguments:  [xBktToExpand] -
//              [widToPin]     -
//              [isWatched]    -
//
//  Returns:
//
//  History:    7-07-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CLargeTable::_NoLokBucketToWindows( XPtr<CTableBucket> & xBktToExpand,
                                    WORKID widToPin,
                                    BOOL isWatched,
                                    BOOL fOptimizeBucketization )
{

    CAsyncBucketExploder * pBktExploder =
            new CAsyncBucketExploder( *this,
                                      xBktToExpand,
                                      widToPin,
                                      !_fUniqueWorkid );
    //
    // DO NOT add any code here. pBucket now belongs to pBktExploder and we
    // should acquire it from xBktToExpand before doing anything else.
    //
    Win4Assert( 0 == xBktToExpand.GetPointer() );
    XInterface<CAsyncBucketExploder> xRef(pBktExploder);

    //
    // We don't have to do an AddRef on pBktExploder because it is refcounted
    // in the constructor.
    //
    NTSTATUS  status = STATUS_SUCCESS;

    //
    // Lock the table
    // ============================================================
    //
    {
        CLock   lock(_mutex);

        _LokCheckQueryStatus();

        if ( 0 != _pQExecute )
        {
            pBktExploder->SetQuery( _pQExecute );
        }
        else
        {
            //
            // The query is being destoryed.
            //
            THROW( CException( STATUS_TOO_LATE ) );
        }

        //
        // Convert any excess windows to buckets.
        //

        if ( fOptimizeBucketization )
            _LokConvertWindowsToBucket( widToPin );

        //
        // Add to the bigtable's list of exploding buckets.
        //
        _LokAddToExplodeList( pBktExploder );
        pBktExploder->SetOnLTList();
    }

    //
    // Release the table
    // ============================================================
    //

    if ( isWatched )
    {

        //
        // There can be a failure (like failing to create a worker thread)
        // when we add to the work queue. So, we must be able to deal with
        // it.
        //

        TRY
        {
            ciFAILTEST( STATUS_NO_MEMORY );
            pBktExploder->AddToWorkQueue();
        }
        CATCH( CException, e )
        {
            tbDebugOut(( DEB_ERROR,
                "CLargeTable::_NoLokBucketToWindow "
                "AddToWorkQueue failed with error 0X%X\n",
                e.GetErrorCode() ));

           SetStatus( STAT_ERROR );
           _RemoveFromExplodeList( pBktExploder );
           pBktExploder->Abort();

           RETHROW();
        }
        END_CATCH

        xRef.Acquire();
        pBktExploder->Release();

        //
        // Return to the caller from here and continue fetching the
        // remaining rows.
        //

    }
    else
    {
        //
        // No need of using another thread. Just use the callers
        // thread.
        //
        pBktExploder->DoIt( 0 );
        status = pBktExploder->GetStatus();
        xRef.Acquire();
        pBktExploder->Release();
    }

    if ( STATUS_SUCCESS != status )
    {
        THROW( CException(status) );
    }

    if (!isWatched)
    {
        CLock   lock(_mutex);
        //
        // Give a notification to "kick" the notification thread after the
        // bucket->window conversion.
        //
        LokCompleteAsyncNotification();
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   _NoLokBucketToWindows
//
//  Synopsis:   Converts the given buckets into a windows.
//
//  Arguments:  [bucketRef] -  Safe stack of buckets.
//
//  History:    3-24-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CLargeTable::_NoLokBucketToWindows( CDynStack<CTableBucket> & xSegStack,
                                    WORKID widToPin,
                                    BOOL isWatched,
                                    BOOL fOptimizeBucketization )
{

    //
    // The bucket that must be scheduled for expansion.
    //
    XPtr<CTableBucket> xBktToExpand;

    do
    {

        //
        //=============================================================
        // Lock the table.
        //
        {
            CLock   lock(_mutex);
            CTableBucket * pBucket = (CTableBucket *) xSegStack.Pop();
            Win4Assert( 0 == xBktToExpand.GetPointer() );
            xBktToExpand.Set( pBucket );
        }
        //
        //=============================================================
        // release the lock on table
        //

        //
        // Convert this single bucket to a window.
        //
        _NoLokBucketToWindows( xBktToExpand, widToPin, isWatched, fOptimizeBucketization );

    } while (  0 != xSegStack.Count() );
} //_NoLokBucketToWindows

//+---------------------------------------------------------------------------
//
//  Method:     CLargeTable::GetRowsAt
//
//  Synopsis:   Fetch rows relative to a bookmark
//
//  Arguments:  [hRegion]                - watch region handle
//              [widStart]               -
//              [chapt]    - Chapter from which to fetch rows (if chaptered)
//              [iRowOffset]             -
//              [rOutColumns]            -
//              [rGetParams]             -
//              [rwidLastRowTransferred] -
//
//  Returns:
//
//  History:    3-31-95   srikants   Created
//              6-28-95     BartoszM    Added watch region support
//
//  Notes:
//
//----------------------------------------------------------------------------

SCODE
CLargeTable::GetRowsAt(
        HWATCHREGION            hRegion,
        WORKID                  widStart,
        CI_TBL_CHAPT            chapt,
        DBROWOFFSET             iRowOffset,
        CTableColumnSet const & rOutColumns,
        CGetRowsParams &        rGetParams,
        WORKID &                rwidLastRowTransferred
        )
{

    //
    // DO NOT OBTAIN LOCK HERE.
    // If the row of interest is in an un-sorted bucket, it must be
    // expanded into a window before we can determine the exact wid.
    // For bucket->window expansion, we have to release the lock because
    // the conversion (not now but later) will be done by a worker thread
    // and we will deadlock.
    //

    tbDebugOut(( DEB_REGTRANS,
            " =============== Entering GetRowsAt ========= \n\n " ));

    if ( iRowOffset > 0 )
        rwidLastRowTransferred = WORKID_TBLLAST;
    else
        rwidLastRowTransferred = WORKID_TBLFIRST;

    BOOL fAsync = FALSE;

    if ( WORKID_TBLBEFOREFIRST == widStart )
    {
        if (iRowOffset <= 0)
        {
           widStart = WORKID_TBLLAST;
        }
        else
        {
           widStart = WORKID_TBLFIRST;
           iRowOffset--;
        }
    }
    else if ( WORKID_TBLAFTERLAST == widStart )
    {
        widStart = WORKID_TBLLAST;
        iRowOffset++;
    }

    tbDebugOut(( DEB_REGTRANS, "  widstart 0x%x, offset %d\n", widStart, iRowOffset ));

    ULONG cChaptRows = 0;
    if ( IsCategorized() && DB_NULL_HCHAPTER != chapt )
    {
        CLock   lock(_mutex);

        cChaptRows = GetCategorizer()->GetRowCount( chapt );
        if ( WORKID_TBLFIRST == widStart || WORKID_TBLLAST == widStart )
        {
            BOOL isLastBmk = WORKID_TBLLAST == widStart;
            widStart = GetCategorizer()->GetFirstWorkid( chapt );
            if ( isLastBmk )
            {
                iRowOffset += ( cChaptRows - 1 );
            }

            if ( ( isLastBmk ) &&
                 ( -1 == iRowOffset ) &&
                 ( 1 == cChaptRows ) )
            {
                iRowOffset = 0;
            }
        }
    }

    CTableRowLocator rowLocator( *this, widStart, (LONG) iRowOffset, chapt );
    CTableRowGetter  tableRowGetter( *this, rOutColumns, rGetParams, chapt, hRegion );
    SCODE status = S_OK;

    CWatchRegion* pWatchRegion = 0;
    BOOL fBeyondTable = FALSE;          // flag indicating if we had to go
                                        // beyond the end of the table.

    CDynStack<CTableBucket>  xBktToConvert(0); // buckets to expand at our leisure

    WORKID  widToPin = widInvalid;  // The workid we need to pin.

    for (;;)
    {
        //
        // Loop as long as there are buckets to be sychronously
        // expanded.
        //

        XPtr<CTableBucket>  xBktToExplode(0); // bucket to explode synchronously

        // ============================================================
        {
            CLock   lock(_mutex);

            _LokCheckQueryStatus();
            fAsync = _LokIsWatched() && (0 != hRegion);

            if (!_watchList.IsEmpty())
            {
                _watchList.VerifyRegion (hRegion);
                // valid region or null
                pWatchRegion = _watchList.GetRegion(hRegion);
            }
            else if (hRegion != 0)
            {
                THROW (CException(E_INVALIDARG));
            }

#if CIDBG==1
            if ( 0 != pWatchRegion && pWatchRegion->IsInit() )
            {
                Win4Assert( pWatchRegion->Segment()->IsWindow() );
                CTableWindow * pWindow = (CTableWindow *) pWatchRegion->Segment();
                Win4Assert( pWindow->HasWatch( hRegion ) );
            }
#endif  // CIDBG==1

            CRegionTransformer regionTransformer( pWatchRegion,
                                                  (LONG) iRowOffset,
                                                  rGetParams.RowsToTransfer(),
                                                  rGetParams.GetFwdFetch() );

            CFwdTableSegIter iter( _segList );

            //
            // Locate the bookmark.
            //
            status = rowLocator.LokLocate( hRegion,
                                           fAsync,
                                           iter,
                                           regionTransformer);

            if ( S_OK != status )
            {
                return status;
            }

            // also: calculate the fetch coordinates
            if ( !regionTransformer.Validate() )
                THROW (CException(DB_E_NONCONTIGUOUSRANGE));

            // The iterator is positioned at the fetch bookmark
            // Move it to the actual fetch offset

            rowLocator.LokRelocate ( fAsync,
                                     iter,
                                     regionTransformer,
                                     xBktToExplode,
                                     xBktToConvert );

            if ( xBktToExplode.IsNull() )
            {
                //
                // The first row to be fetched is in a window.
                //

                if ( 0 != rowLocator.GetBeyondTableCount() )
                {
                    tbDebugOut(( DEB_REGTRANS,
                                 "    GetBeyondTableCount: %d\n",
                                 rowLocator.GetBeyondTableCount() ));
                    //
                    // The requested offset is beyond the table. Must update
                    // the row retrieval count based on the residual row
                    // count.
                    //
                    regionTransformer.DecrementFetchCount( rowLocator,
                                                           iter,
                                                           _segList );

                    // to support watch regions, fetches beyond the
                    // end of rowset are expected

                    fBeyondTable = TRUE;

                    // don't read any rows that do fall in the table
                    // if notifications aren't enabled.

                    if ( 0 == _bitNotifyEnabled )
                        break;
                }

                Win4Assert( regionTransformer.GetFetchCount() >= 0 );
                if ( regionTransformer.GetFetchCount() > 0 )
                {
                    Win4Assert( iter.GetSegment()->IsWindow() );
                    if ( 0 != regionTransformer.Region() )
                    {
                        CDoubleTableSegIter fakeIter( iter );

                        //
                        // Simulate a fetch and collect all the buckets to be
                        // asynchronously expanded.
                        //
                        rowLocator.LokSimulateFetch( fakeIter,
                                                     regionTransformer,
                                                     xBktToConvert );
                        regionTransformer.Transform (_segList,
                                                     _watchList );
                    }

                    //
                    // We have located exactly where the starting workid is.
                    // Start fetching rows from here.
                    //
                    widStart = rowLocator.GetWorkIdFound();
                    tableRowGetter.SetRowsToTransfer( (ULONG) regionTransformer.GetFetchCount() );

                    //
                    //  Real Work done here!
                    //
                    CTableWindow * pWindow = iter.GetWindow();
                    status = tableRowGetter.LokGetRowsAtSegment ( pWindow,
                                                                  widStart,
                                                                  fAsync,
                                                                  xBktToExplode );

                    rwidLastRowTransferred = tableRowGetter.GetLastWorkId();

                    if ( !xBktToExplode.IsNull() )
                    {
                        Win4Assert( !fAsync );

                        //
                        // All the requested rows did not get filled in.
                        // We have hit a bucket which must be exploded.
                        // Snapshot the current position and offset (either
                        // +1 if forward fetch or -1 if backwards fetch) so
                        // that we can continue from the snapshotted position
                        // after the bucket has been exploded.
                        //

                        long iOffset;
                        if ( rGetParams.GetFwdFetch() )
                            iOffset = 1;
                        else
                            iOffset = -1;

                        rowLocator.SetLocateInfo( rwidLastRowTransferred, iOffset );
                        widToPin = rwidLastRowTransferred;

                        iRowOffset = iOffset;
                    }
                } // regionTransformer.GetFetchCount() > 0
            }

#if CIDBG==1
        _watchList.CheckRegionConsistency( pWatchRegion );
#endif  // CIDBG==1

        }
        // Lock released
        // ============================================================

        if ( 0 != xBktToExplode.GetPointer() )
        {
            // We need to synchronously convert bucket into windows.
            // and then restart fetching from the top

            if ( widInvalid == widToPin )
                widToPin = widStart;

            _NoLokBucketToWindows( xBktToExplode, widToPin, FALSE, FALSE );
        }
        else
        {
            break;
        }
    } // end of bucket expansion loop

    if ( xBktToConvert.Count() > 0 )
    {
        // Schedule buckets for asynchronous expansion
        _NoLokBucketToWindows ( xBktToConvert, widInvalid, TRUE, TRUE );
    }

    if (SUCCEEDED(status) && fBeyondTable)
    {
       if ( _bitNotifyEnabled )
           status = DB_S_ENDOFROWSET;
       else
           status = DB_E_BADSTARTPOSITION;
    }
    else if ( ( IsCategorized() ) &&
              ( DB_S_ENDOFROWSET == status ) &&
              ( 0 == rGetParams.RowsTransferred() ) &&
              ( 0 != cChaptRows ) )
    {
        status = DB_E_BADSTARTPOSITION;
    }

    //
    // If the query timed out and we're fetching at the end of the
    // rowset, give an appropriate status.
    //

    if ( ( DB_S_ENDOFROWSET == status ) &&
         ( 0 != ( Status() & STAT_TIME_LIMIT_EXCEEDED ) ) )
    {
        status = DB_S_STOPLIMITREACHED;
    }

    return status;
} //GetRowsAt

//+---------------------------------------------------------------------------
//
//  Function:   GetRowsAtRatio
//
//  Synopsis:   An APPROXIMATE retrieval of rows. NOTE that this is not
//              EXACT - use GetRowsAt to retrieve rows at exact position.
//
//  Arguments:  [hRegion]                - watch region handle
//              [ulNum]                  -
//              [ulDenom]                -
//              [chapt]                  - Chapter of rows returned
//              [rOutColumns]            -
//              [rGetParams]             -
//              [rwidLastRowTransferred] -
//
//  Returns:
//
//  History:    4-04-95   srikants   Created
//              6-28-95     BartoszM    Added watch region support
//
//  Notes:
//
//----------------------------------------------------------------------------

SCODE
CLargeTable::GetRowsAtRatio(
        HWATCHREGION hRegion,
        ULONG       ulNum,
        ULONG       ulDenom,
        CI_TBL_CHAPT   chapt,
        CTableColumnSet const & rOutColumns,
        CGetRowsParams & rGetParams,
        WORKID &    rwidLastRowTransferred
        )
{
    if ( 0 == ulDenom || ulNum > ulDenom )
    {
        QUIETTHROW( CException(DB_E_BADRATIO) );
    }

    BOOL  fFarFromWindow = TRUE;
    BOOL  fAsync = FALSE;

    SCODE  scRet = S_OK;
    ULONG cRowsFromFront = 0;

    WORKID  widAnchor = widInvalid; // initialize to an invalid value.
    ULONG cPercentDiff = 0;
    LONG offFetchStart = 0;

    XPtr<CTableBucket>      xBktToExplode(0);

    //
    // ==================================================================
    // Obtain the lock
    {

        CLock   lock(_mutex);
        _LokCheckQueryStatus();

        if ( IsCategorized() && DB_NULL_HCHAPTER != chapt )
        {

            ULONG cRows = GetCategorizer()->GetRowCount( chapt );

            Win4Assert( 0 != cRows && "Chapter is empty" );

            LONGLONG  llcRowsFromFront = ( (LONGLONG) cRows) * ulNum ;
            llcRowsFromFront /= ulDenom;
            Win4Assert( llcRowsFromFront <= cRows && llcRowsFromFront >= 0 );
            cRowsFromFront = lltoul( llcRowsFromFront ) ;
        }
        else
        {
            //
            // Determine the approximate offset from the beginning of the table
            //
            const ULONG cTotalRows = (ULONG) RowCount();

            if ( 0 == cTotalRows )
            {
                rwidLastRowTransferred = WORKID_TBLAFTERLAST;
                return DB_S_ENDOFROWSET;
            }

            LONGLONG  llcRowsFromFront = ( (LONGLONG) cTotalRows) * ulNum ;
            llcRowsFromFront /= ulDenom;
            Win4Assert( llcRowsFromFront <= cTotalRows && llcRowsFromFront >= 0 );
            cRowsFromFront = lltoul( llcRowsFromFront ) ;

            if ( cRowsFromFront == cTotalRows )
            {
                if ( rGetParams.GetFwdFetch() )
                {
                    //
                    // The user is asking to retrieve past the end of table.
                    //
                    rwidLastRowTransferred = WORKID_TBLAFTERLAST;
                    return DB_S_ENDOFROWSET;
                }
                else
                {
                    //
                    // Fetch rows starting with last row in rowset
                    //
                    rwidLastRowTransferred = WORKID_TBLAFTERLAST;

                    SCODE scRet = GetRowsAt( hRegion,
                                             WORKID_TBLAFTERLAST,
                                             chapt,
                                             -1,
                                             rOutColumns,
                                             rGetParams,
                                             rwidLastRowTransferred );
                     return scRet;
                }
            }

            //
            // Locate the closest window at this offset.
            //
            CLinearRange    winRange;   // will be initialized by _LokGetClosestWindow
            CTableWindow * pWindow = _LokGetClosestWindow( cRowsFromFront, winRange );

            if ( 0 == pWindow )
            {
                fFarFromWindow = TRUE;
            }
            else
            {
                //
                // Offset of the first row from the beginning of the table.
                //
                offFetchStart = winRange.GetLow();

                if ( winRange.InRange( cRowsFromFront ) &&
                     rGetParams.RowsToTransfer() <= winRange.GetRange() )
                {
                    //
                    // This window has enough rows.
                    //

                    long cRowsOff;        // offset within the window
                    if ( rGetParams.GetFwdFetch() )
                    {
                        if ( cRowsFromFront + rGetParams.RowsToTransfer() <=
                             winRange.GetHigh() )
                        {
                            //
                            // We hit the exact row that the client requested.
                            //
                            cRowsOff = cRowsFromFront - winRange.GetLow();
                        }
                        else
                        {
                            //
                            // Optimization : We cannot fill the output set with the rows
                            // from this window if we position exactly. So just use a
                            // little from front.
                            //
                            cRowsOff = winRange.GetRange() - rGetParams.RowsToTransfer();
                        }
                    }
                    else
                    {
                        if ( cRowsFromFront >= rGetParams.RowsToTransfer()
                             && cRowsFromFront - rGetParams.RowsToTransfer() >= winRange.GetLow() )
                        {
                            //
                            // We hit the exact row that the client requested
                            //
                             cRowsOff = cRowsFromFront - winRange.GetLow();
                        }
                        else
                        {
                            //
                            // Optimization : We cannot fill the output set with the rows
                            // from this window if we position exactly. So just use a
                            // little from back.
                            //
                            cRowsOff = rGetParams.RowsToTransfer() - 1;
                        }
                    }

                    //
                    // There was no wrap around.
                    //
                    Win4Assert( cRowsOff >= 0 && cRowsOff < (long)pWindow->RowCount());

                    offFetchStart += cRowsOff;
                    widAnchor = pWindow->GetBookMarkAt( cRowsOff );
                }
                else
                {
                    widAnchor = WORKID_TBLFIRST;
                }

                const cMaxApproxPerCent = 10;   // Let us say 10% maximum approximation

                //
                // Determine how accurate is the approximate position.
                //
                cPercentDiff =  AbsDiff( offFetchStart, cRowsFromFront ) * 100;
                cPercentDiff /= cTotalRows;
                if ( cPercentDiff <= cMaxApproxPerCent )
                {
                    Win4Assert( widInvalid != widAnchor );
                    fFarFromWindow = FALSE;
                }
                else
                {
                    tbDebugOut(( DEB_WINSPLIT,
                        " Approximation is too off 0x%X - Requested - Arrived 0x%X\n",
                        cRowsFromFront, offFetchStart ));
                }
            }

            fAsync = _LokIsWatched() && (0 != hRegion);

            if ( 0 != hRegion )
            {
                // Nuke the region first
                _watchList.ShrinkRegionToZero (hRegion);
            }

            //
            // If we are either too far from a window or if the asynchronous
            // mode is on, we have to use GetRowsAt()
            //
            if ( !fFarFromWindow && !fAsync )
            {
                tbDebugOut(( DEB_WINSPLIT,
                    "GetRowsAtRatio - Approximate. Requested 0x%X Actual 0x%X Percent 0x%X\n",
                    cRowsFromFront, offFetchStart, cPercentDiff ));

                CTableRowGetter   rowGetter( *this, rOutColumns, rGetParams, chapt, hRegion );


                //
                // Real work done here!
                //
                Win4Assert( widInvalid != widAnchor );
                Win4Assert( 0 != pWindow->RowCount() );

#if CIDBG==1
                TBL_OFF oRowdummy;
                ULONG     iRowdummy;
                Win4Assert( pWindow->FindBookMark( widAnchor, oRowdummy, iRowdummy ) );
#endif  // CIDBG==1

                scRet = rowGetter.LokGetRowsAtSegment( pWindow,
                                                       widAnchor,
                                                       FALSE,   // synchronous
                                                       xBktToExplode );

                if ( !FAILED(scRet) )
                {
                    rwidLastRowTransferred = rowGetter.GetLastWorkId();

                    Win4Assert( rwidLastRowTransferred != widInvalid &&
                                !IsSpecialWid( rwidLastRowTransferred ) );
                }

                if ( xBktToExplode.IsNull() )
                {
                    return scRet;
                }

                //
                // The bucket to explode is not null.  We will synchronously
                // explode it and continue fetching from there on.
                //
                Win4Assert( !FAILED(scRet) );
            }
        }
    }
    // ==================================================================
    // Release table lock

    //
    // We are either :
    // 1. Far from window or
    // 2. Is being watched or
    // 3. We have a bucket to explode synchronously.
    //
    if ( xBktToExplode.IsNull() )
    {
        //
        // We are either far from a window or we have a watch region.
        //
        widAnchor = WORKID_TBLFIRST;
        offFetchStart = cRowsFromFront;
    }
    else
    {
        widAnchor = rwidLastRowTransferred;
        if ( rGetParams.GetFwdFetch() )
            offFetchStart = 1;
        else
            offFetchStart = -1;

        _NoLokBucketToWindows( xBktToExplode, widAnchor, FALSE, TRUE );   // synchronous
    }

    tbDebugOut(( DEB_WINSPLIT, "GetRowsAtRatio - going to GetRowsAt\n" ));
    Win4Assert( widInvalid != widAnchor );

    // The region is pre-shrunk to zero, so it's okay to start in a bucket.
    scRet = GetRowsAt( hRegion,
                      widAnchor,
                      chapt,
                      offFetchStart,
                      rOutColumns,
                      rGetParams,
                      rwidLastRowTransferred );
    if (DB_E_BADSTARTPOSITION == scRet)
       scRet = DB_S_ENDOFROWSET;

    return scRet;
} //GetRowsAtRatio

//+---------------------------------------------------------------------------
//
//  Class:      CClosestWindow
//
//  Purpose:    Determines the closest window for a given position in the
//              table.
//
//  History:    4-03-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

class CClosestWindow
{

public:

    CClosestWindow( ULONG targetOffset, CTableSegList & list )
    : _targetOffset(targetOffset),
      _list(list),
      _iter(_list),
      _currSegOffset(0),
      _pBest(0), _bestRange(ULONG_MAX,ULONG_MAX),
      _fDone(FALSE)
    {

    }

    void ProcessCurrent();

    BOOL IsDone() { return _fDone || _list.AtEnd(_iter); }

    CTableWindow * GetClosest( CLinearRange & winRange )
    {
        if ( 0 != _pBest )
        {
            winRange.Set( _bestRange.GetLow(), _bestRange.GetHigh() );
        }

        return _pBest;
    }

    void Next()
    {
        Win4Assert( !_list.AtEnd(_iter) );
        _list.Advance(_iter);
    }

private:

    ULONG               _targetOffset;  // Target offset to locate

    CTableSegList &     _list;          // The list of segments
    CFwdTableSegIter    _iter;          // Iterator over the list of segments

    ULONG               _currSegOffset; // Beginning offset of the current
                                        // segment

    CTableWindow *      _pBest;         // Best window so far
    CLinearRange        _bestRange;     // Range of the best window

    BOOL                _fDone;         // Flag set to TRUE if we have already
                                        // found the best possible window.
};

//+---------------------------------------------------------------------------
//
//  Function:   ProcessCurrent
//
//  Synopsis:   Processes the current segment in the iterator and updates
//              the "best" window if applicable.
//
//  History:    4-03-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CClosestWindow::ProcessCurrent( )
{

    CTableSegment * pSegment = _iter.GetSegment();
    Win4Assert( 0 != pSegment );

    Win4Assert( !_fDone );

    ULONG cRowsInSeg = (ULONG)pSegment->RowCount();
    ULONG currEndSeg = _currSegOffset;

    if ( 0 != cRowsInSeg )
    {
        currEndSeg += (cRowsInSeg-1);
    }

    if ( pSegment->IsWindow() && 0 != pSegment->RowCount() )
    {
        if ( _currSegOffset <= _targetOffset )
        {
            //
            // We are still on the left hand side. So, this one MUST be
            // closer than what we had before.
            //

            _pBest = (CTableWindow *) pSegment;
            _bestRange.Set( _currSegOffset, currEndSeg );
            _fDone = _bestRange.InRange( _targetOffset );
        }
        else
        {
            //
            // We are on the right hand side of the target.
            //
            CTableWindow * pRight = (CTableWindow *) pSegment;
            if ( 0 != _pBest )
            {
                if ( AbsDiff( _currSegOffset, _targetOffset ) <
                     AbsDiff( _bestRange.GetLow(), _targetOffset ) )
                {
                    //
                    // We found a closer window on the right hand
                    // side.
                    //
                    _pBest = pRight;
                    _bestRange.Set( _currSegOffset, currEndSeg );
                }
            }
            else
            {
                _pBest = pRight;
                _bestRange.Set( _currSegOffset, currEndSeg );
            }

            _fDone = TRUE;
        }
    }

    _currSegOffset += cRowsInSeg;

}


//+---------------------------------------------------------------------------
//
//  Function:   _LokGetClosestWindow
//
//  Synopsis:   Given a position from the beginning of the table, this
//              method determines the closest window from that position.
//
//  Arguments:  [cRowsFromFront] -  Number of rows from the beginning of
//              the table.
//              [winRange]       -  (output) Range of the window found in
//              the table.
//
//  Returns:    Pointer to the window, if one is found that is closest to
//              the position requested.
//
//  History:    4-03-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CTableWindow * CLargeTable::_LokGetClosestWindow(
    ULONG cRowsFromFront,
    CLinearRange & winRange  )
{
    winRange.Set(0,0);

    for ( CClosestWindow  closest( cRowsFromFront, _segList );
          !closest.IsDone();
          closest.Next() )

    {
        closest.ProcessCurrent();
    }

    return closest.GetClosest( winRange );
}


//+---------------------------------------------------------------------------
//
//  Function:   _CreateNewWindow
//
//  Synopsis:   Creates a new window with the given segment id.
//
//  Arguments:  [segId] - Segment id of the window to create.
//
//  Returns:    Pointer to the newly created window.
//
//  History:    4-19-95   srikants   Created
//
//  Notes:      This is a helper function for "CTableRowPutter" class.
//
//----------------------------------------------------------------------------

CTableWindow * CLargeTable::_CreateNewWindow(
    ULONG segId,
    CTableRowKey &lowKey,
    CTableRowKey &highKey)
{
    XPtr<CTableWindow> xWindow( new CTableWindow( _pSortSet,
                                                  _keyCompare.GetReference(),
                                                  &_MasterColumnSet,
                                                  segId,
                                                  GetCategorizer(),
                                                  _sharedBuf, 
                                                  *_pQExecute ) );

    xWindow->GetLowestKey() = lowKey;
    xWindow->GetHighestKey() = highKey;

    return xWindow.Acquire();
} //_CreateNewWindow

//+---------------------------------------------------------------------------
//
//  Function:   SetQueryExecute
//
//  Synopsis:   Initializes the query executer object to be used during
//              bucket->window conversion.  The query object will be refcounted
//              to co-ordinate destruction order.
//
//  Arguments:  [pQExecute] - Pointer to the query object.
//
//  History:    4-25-95   srikants   Created
//
//  Notes:      Must be called ONCE and only ONCE. Before ~CLargeTable is
//              called, the ReleaseQueryExecute MUST be called.
//
//----------------------------------------------------------------------------

void CLargeTable::SetQueryExecute( CQAsyncExecute * pQExecute )   // virtual
{
    CLock lock(_mutex);
    Win4Assert( 0 == _pQExecute );
    _pQExecute = pQExecute;
    _pQExecute->AddRef();

}

//+---------------------------------------------------------------------------
//
//  Function:   ReleaseQueryExecute
//
//  Synopsis:   Releases the query object. After this, we cannot do any
//              bucket->window conversions.
//
//  History:    4-25-95   srikants   Created
//
//  Notes:      MUST be called once before the destructor is called.
//
//----------------------------------------------------------------------------

void CLargeTable::ReleaseQueryExecute()
{
    CLock lock(_mutex);
    Win4Assert( 0 != _pQExecute );
    _pQExecute->Release();
    _pQExecute = 0;

    //
    // Abort all the bucket->window expansions that are in progress.
    //
    for ( CAsyncBucketExploder * pEntry = _explodeBktsList.RemoveLast();
          0 != pEntry;
          pEntry = _explodeBktsList.RemoveLast() )
    {
        pEntry->Close();
        pEntry->Abort();
        pEntry->Release();
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   _LokAddToExplodeList
//
//  Synopsis:
//
//  Arguments:  [pBktExploder] -
//
//  Returns:
//
//  History:    5-30-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


void CLargeTable::_LokAddToExplodeList( CAsyncBucketExploder * pBktExploder )
{
    Win4Assert( pBktExploder->IsSingle() );
    pBktExploder->AddRef();
    _explodeBktsList.Push( pBktExploder );


    //
    // Pin the workid to be in a window and prevent from being converted
    // into a bucket.
    //
    _segListMgr.SetInUseByBuckets( pBktExploder->GetWorkIdToPin() );
} //_LokAddToExplodeList

//+---------------------------------------------------------------------------
//
//  Function:   _RemoveFromExplodeList
//
//  Synopsis:
//
//  Arguments:  [pBktExploder] -
//
//  Returns:
//
//  History:    5-30-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CLargeTable::_RemoveFromExplodeList( CAsyncBucketExploder * pBktExploder )
{
    {
        CLock   lock(_mutex);
        Win4Assert( 0 != pBktExploder );

        _explodeBktsList.RemoveFromList( pBktExploder );
        pBktExploder->Close();
        _segListMgr.ClearInUseByBuckets( pBktExploder->GetWorkIdToPin() );
    }

    pBktExploder->Release();
}

//+---------------------------------------------------------------------------
//
//  Function:   QueryAbort
//
//  Synopsis:   Processes an abort and wakes up any waiters on the events
//              in the largetable.
//
//  History:    5-31-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CLargeTable::QueryAbort()
{
    CLock lock(_mutex);
    Win4Assert( 0 == _pQExecute );
    Win4Assert( _explodeBktsList.IsEmpty() );

    _fAbort = TRUE;
}  //QueryAbort

//+---------------------------------------------------------------------------
//
//  Method:     GetCurrentPosition, public
//
//  Synopsis:   Gets the current GetNextRows position for the table or
//              chapter.
//
//  Arguments:  [chapt] - gets the current position for this chapter
//
//  History:    6-30-95   dlee   Created
//
//----------------------------------------------------------------------------

WORKID CLargeTable::GetCurrentPosition(
    CI_TBL_CHAPT chapt)
{
    if ( IsCategorized() && DB_NULL_HCHAPTER != chapt )
        return GetCategorizer()->GetCurrentPositionThisLevel( chapt );
    else
        return _widCurrent;
} //GetCurrentPosition

//+---------------------------------------------------------------------------
//
//  Method:     SetCurrentPosition, public
//
//  Synopsis:   Sets the current GetNextRows position for the table or
//              chapter.
//
//  Arguments:  [chapt] - sets the current position for this chapter
//
//  History:    6-30-95   dlee   Created
//
//----------------------------------------------------------------------------

WORKID CLargeTable::SetCurrentPosition(
    CI_TBL_CHAPT chapt,
    WORKID wid)
{
    if ( IsCategorized() && DB_NULL_HCHAPTER != chapt )
        return GetCategorizer()->SetCurrentPositionThisLevel( chapt, wid );
    else
        return ( _widCurrent = wid );
} //SetCurrentPosition

//+---------------------------------------------------------------------------
//
//  Method:     LokGetOneColumn, public
//
//  Synopsis:   Gets data for one column for the given workid.
//
//  Arguments:  [wid]           - for which data is retrieved
//              [rOutColumn]    - column descritption for where data is written
//              [pbOut]         - where data is written
//              [rVarAllocator] - allocator to use for variable-len data
//
//  History:    8-22-95   dlee   Created
//
//----------------------------------------------------------------------------

void CLargeTable::LokGetOneColumn(
    WORKID                    wid,
    CTableColumn const &      rOutColumn,
    BYTE *                    pbOut,
    PVarAllocator &           rVarAllocator )
{
    CTableWindow *pWindow = (CTableWindow *) _LokFindTableSegment( wid );

    pWindow->LokGetOneColumn( wid, rOutColumn, pbOut, rVarAllocator );
} //LokGetOneColumn

CI_TBL_BMK CLargeTable::_FindNearestDynamicBmk( CTableWindow * pWindow,
                                                 CI_TBL_CHAPT chapter,
                                                 CI_TBL_BMK bookmark )
{
    // If the row corresponding to the bookmark exists in the
    // dynamic state, return the original bookmark.
    // If the row has been deleted from the dynamic state
    // return the bookmark of the next available dynamic row.
    // If you hit the end of the table, return the bookmark
    // of the last row in the dynamic state of the table

    CI_TBL_BMK bmkFound = bookmark;

    if ( pWindow->FindNearestDynamicBmk( chapter, bmkFound ) )
    {
        return bmkFound;
    }

    //
    // Find the closest bookmark to the right of this window.
    //
    CDoubleTableSegIter fwdIter( pWindow );

    for ( _segList.Advance(fwdIter); !_segList.AtEnd(fwdIter);
          _segList.Advance(fwdIter) )
    {
        if ( fwdIter.GetSegment()->IsWindow() )
        {
            CTableWindow * pWindow = fwdIter.GetWindow();
            if ( pWindow->FindFirstNonDeleteDynamicBmk(bmkFound) )
                return bmkFound;
        }
    }

    //
    // Couldn't find anything to the right of this window. Find to the
    // left of the window.
    //
    CDoubleTableSegIter backIter( pWindow );

    for ( _segList.BackUp(backIter); !_segList.AtEnd(backIter);
          _segList.BackUp(backIter) )
    {
        if ( backIter.GetSegment()->IsWindow() )
        {
            CTableWindow * pWindow = backIter.GetWindow();
            if ( pWindow->FindFirstNonDeleteDynamicBmk(bmkFound) )
                return bmkFound;
        }
    }

    //
    // The whole table has been deleted. Just use the WORKID_TBLFIRST
    //
    return WORKID_TBLFIRST;
} //_FindNearestDynamicBmk

//+---------------------------------------------------------------------------
//
//  Member:     CTableSink::SetStatus, public
//
//  Synopsis:   Sets the query status.
//
//  Arguments:  [s] -- The new status
//
//  History:    18-Oct-91   KyleP       Created.
//
//----------------------------------------------------------------------------

void CTableSink::SetStatus(ULONG s, NTSTATUS sc)
{
    _status = s;

    if (sc != STATUS_SUCCESS)
    {
        Win4Assert( QUERY_FILL_STATUS(s) == STAT_ERROR &&
                    ! NT_SUCCESS(sc) );
        _scStatus = sc;

        tbDebugOut(( DEB_WARN,
                     "tablesink at 0x%x entering 0x%x ERROR state\n",
                     this, sc ));
    }
    else
    {
        Win4Assert( QUERY_FILL_STATUS(s) != STAT_ERROR );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\apps\webhits\whtmplat.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1996 - 1998, Microsoft Corporation.
//
//  File:   htx.cxx
//
//  Contents:   Parser for a HTX file
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <cgiesc.hxx>
#include <htmlchar.hxx>

#include "whtmplat.hxx"
#include "webdbg.hxx"
#include "whmsg.h"

//+---------------------------------------------------------------------------
//
//  Member:     CWTXScanner::CWTXScanner - public constructor
//
//  Synopsis:   Builds a scanner for a section within a HTX file
//
//  Arguments:  [variableSet] - list of replaceable parameters
//              [wcsPrefix]   - prefix delimiter for replacable parameters
//              [wcsSuffix]   - suffix delimiter for replacable parameters
//
//  Notes:      The wcsPrefix and wcsSuffix are expected to be the same
//              length and either one or two characters.
//
//  History:    96/Jan/03   DwightKr    created
//              96/Sep/07   SrikantS    Copied and adapted to webhits use from
//                                      htx.cxx/htx.hxx
//
//----------------------------------------------------------------------------
CWTXScanner::CWTXScanner( CWHVarSet & variableSet,
                          WCHAR const * wcsPrefix,
                          WCHAR const * wcsSuffix ) :
                                    _wcsPrefix(wcsPrefix),
                                    _wcsSuffix(wcsSuffix),
                                    _variableSet(variableSet),
                                    _type(eNone),
                                    _nextType(eNone),
                                    _wcsString(0),
                                    _wcsPrefixToken(0),
                                    _wcsSuffixToken(0)
{
    Win4Assert( wcslen( _wcsPrefix ) == wcslen( _wcsSuffix ) &&
                wcslen( _wcsPrefix ) <= 2 );

    if ( _wcsPrefix[1] == L'\0' )
        _cchPrefix = _cchSuffix = 1;
    else
        _cchPrefix = _cchSuffix = 2;
}


//+---------------------------------------------------------------------------
//
//  Member:     CWTXScanner::Init - public
//
//  Synopsis:   Saves a pointer to the string to be parsed.
//
//  Arguments:  [wcsString] - the string to be parsed
//
//  History:    96/Jan/03   DwightKr    created
//              96/Sep/07   SrikantS    Copied and adapted to webhits use from
//                                      htx.cxx/htx.hxx
//
//  NOTES:      THIS STRING WILL BE MODIFIED BY SUBSEQUENT CALLS TO MEMBER
//              FUNCTIONS OF THIS CLASS.
//
//----------------------------------------------------------------------------
void CWTXScanner::Init( WCHAR * wcsString )
{
    _wcsString = wcsString;
}


//+---------------------------------------------------------------------------
//
//  Member:     CWTXScanner::IsToken - private
//
//  Synopsis:   Determines if a string is a special token.
//
//  Arguments:  [wcs] - start of string to be tested.
//
//  Notes:      If the string is a token, the members _type, _wcsPrefixToken
//              and _wcsSuffixToken are set appropriately.
//
//  History:    96/Apr/02   AlanW       Created
//              96/May/17   DwightKr    Treat all <%..%> as variables
//              96/Sep/07   SrikantS    Copied and adapted to webhits use from
//                                      htx.cxx/htx.hxx
//
//----------------------------------------------------------------------------

BOOL CWTXScanner::IsToken(WCHAR * wcs)
{
    if ( wcsncmp( _wcsPrefix, wcs, _cchPrefix ) != 0 )
    {
        webDebugOut(( DEB_USER1, "CWTXScanner::IsToken  end of string\n" ));
        return FALSE;
    }

    wcs += _cchPrefix;
    WCHAR * wcsSuffixTok = wcs2chr( wcs, _wcsSuffix );
    if ( 0 == wcsSuffixTok )
    {
        webDebugOut(( DEB_USER1, "CWTXScanner::IsToken  no suffix token\n" ));
        return FALSE;
    }

    *wcsSuffixTok = L'\0';
    _wcsPrefixToken = wcs - _cchPrefix;
    _wcsupr( wcs );

    //
    //  Strip leading spaces before token
    //
    while ( iswspace(*wcs) && (wcs < wcsSuffixTok) )
    {
        wcs++;
    }

    //
    //  Strip trailing spaces after token
    //
    WCHAR * wcsSuffix = wcsSuffixTok - 1;
    while ( iswspace(*wcsSuffix) && (wcsSuffix > wcs) )
    {
        *wcsSuffix = 0;
        wcsSuffix--;
    }

    webDebugOut(( DEB_USER1, "CWTXScanner::IsToken  wcs=%ws\n", wcs ));

    if ( wcsncmp( wcs, L"ESCAPEHTML ", 11 ) == 0 )
    {
        _type = eEscapeHTML;
    }
    else if ( wcsncmp( wcs, L"ESCAPEURL ", 10 ) == 0 )
    {
        _type = eEscapeURL;
    }
    else if ( wcsncmp( wcs, L"ESCAPERAW ", 10 ) == 0 )
    {
        _type = eEscapeRAW;
    }
    else
    {
        //
        //  Find this name in the list of replaceable parameters.  Note that
        //  if we can't find this variable in the list of replaceable
        //  parameters, we've converted some output text to uppercase.  This
        //  is probably OK since the user used <% ... %> to delimit their
        //  output; <% & %> are reserved tokens hence this would be an error.
        //
        WCHAR const *pVariable = _variableSet.Find( wcs );

        _type = eParameter;

        if ( 0 == pVariable )
        {
            webDebugOut(( DEB_IWARN,
                            "Warning: CWTXScanner::IsToken found a unknown variable: '%ws'\n",
                            wcs ));
        }
    }

    *_wcsPrefixToken = L'\0';
    _wcsSuffixToken = wcsSuffixTok;
    _wcsNextToken = wcsSuffixTok + _cchSuffix;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWTXScanner::FindNextToken - public
//
//  Synopsis:   Locates the next token in the string.
//
//  History:    96/Jan/03   DwightKr    created
//              96/Sep/07   SrikantS    Copied and adapted to webhits use from
//                                      htx.cxx/htx.hxx
//
//----------------------------------------------------------------------------

BOOL CWTXScanner::FindNextToken()
{
    if (_nextType != eNone)
    {
        //
        // Found a token on the previous call.  Just return it.
        //
        Win4Assert ( _wcsPrefixToken && _wcsSuffixToken > _wcsPrefixToken );
        _type = _nextType;
        _nextType = eNone;
        _wcsString = _wcsNextToken = _wcsSuffixToken + _cchSuffix;
        return TRUE;
    }

    if ( (0 == _wcsString) || (0 == *_wcsString) )
    {
        _type = eNone;
        _wcsNextToken = 0;

        return FALSE;
    }

    if ( *_wcsString == *_wcsPrefix &&
         IsToken( _wcsString ) )
    {
        _nextType = eNone;
        return TRUE;
    }

    //
    // The string doesn't start with one of our special keywords.
    // Treat it as an ordinary string, and look ahead to the next
    // valid token.
    //

    _wcsPrefixToken = wcs2chr( _wcsString+1, _wcsPrefix );
    while ( _wcsPrefixToken )
    {
        if ( IsToken( _wcsPrefixToken ) )
        {
            _nextType = _type;
            _wcsNextToken = _wcsPrefixToken;
            _type = eString;
            return TRUE;
        }
        _wcsPrefixToken = wcs2chr( _wcsPrefixToken+_cchPrefix, _wcsPrefix );
    }

    _nextType = eNone;
    _type = eString;
    _wcsNextToken = _wcsString + wcslen( _wcsString );
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CWTXScanner::GetToken - public
//
//  Synopsis:   Returns a pointer to the replaceable parameter token found.
//              Prepares the scanner to return the next token.
//
//  History:    96/Jan/03   DwightKr    created
//              96/Mar/13   DwightKr    add support for eEscapeURL &
//                                      eEscapeHTML
//              96/Sep/07   SrikantS    Copied and adapted to webhits use from
//                                      htx.cxx/htx.hxx
//
//----------------------------------------------------------------------------

WCHAR * CWTXScanner::GetToken()
{
    if ( eString == _type )
    {
        if ( 0 != _wcsString )
        {
            WCHAR * wcsString = _wcsString;
            _wcsString = _wcsNextToken;

            return wcsString;
        }
    }
    else if ( eEscapeHTML == _type )
    {
        WCHAR * wcsString = _wcsPrefixToken + _cchPrefix;
        wcsString += 10;                        // Skip 'EscapeHTML'
        *_wcsSuffixToken = 0;                   // Null terminate

        while ( (0 != *wcsString) && iswspace(*wcsString) )
        {
            wcsString++;
        }

        _wcsString = _wcsNextToken;

        return wcsString;
    }
    else if ( eEscapeURL == _type ||
              eEscapeRAW == _type )
    {
        WCHAR * wcsString = _wcsPrefixToken + _cchPrefix;
        wcsString += 9;                         // Skip 'EscapeURL'
        *_wcsSuffixToken = 0;                   // Null terminate

        while ( (0 != *wcsString) && iswspace(*wcsString) )
        {
            wcsString++;
        }

        _wcsString = _wcsNextToken;

        return wcsString;
    }
    else
    {
        if ( 0 != _wcsPrefixToken )
        {
            Win4Assert( 0 != _wcsSuffixToken &&
                        _wcsPrefixToken < _wcsSuffixToken &&
                        _wcsSuffixToken < _wcsNextToken );

            *_wcsPrefixToken = 0;
            *_wcsSuffixToken = 0;

            _wcsString = _wcsNextToken;

            WCHAR * wcsString = _wcsPrefixToken + _cchPrefix;
            while ( (0 != *wcsString) && iswspace(*wcsString) )
            {
                wcsString++;
            }


            return wcsString;
        }
    }

    return 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CWTXFile::CWTXFile - public constructor
//
//  Synopsis:   Builds a CWTXFile object and initializes values.
//
//  History:    96/Jan/03   DwightKr    created
//              96/Sep/07   SrikantS    Copied and adapted to webhits use from
//                                      htx.cxx/htx.hxx
//
//----------------------------------------------------------------------------
CWTXFile::CWTXFile( WCHAR const * wcsTemplate,
                    WCHAR const * wcsPhysicalName,
                    UINT codePage) :
                        _wcsVirtualName( wcsTemplate  ),
                        _wcsPhysicalName( wcsPhysicalName ),
                        _pVarHeader(0),
                        _pVarRowDetails(0),
                        _pVarFooter(0),
                        _wcsFileBuffer(0),
                        _codePage(codePage)
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CWTXFile::~CWTXFile - public destructor
//
//  History:    96/Jan/03   DwightKr    created
//              96/Sep/07   SrikantS    Copied and adapted to webhits use from
//                                      htx.cxx/htx.hxx
//
//----------------------------------------------------------------------------
CWTXFile::~CWTXFile()
{
    delete _pVarHeader;
    delete _pVarRowDetails;
    delete _pVarFooter;
    delete _wcsFileBuffer;
}


//+---------------------------------------------------------------------------
//
//  Member:     CWTXFile::ParseFile - public
//
//  Synopsis:   Parses the HTX file and breaks it up into its sections.
//
//  History:    96/Jan/03   DwightKr    created
//              96/Sep/07   SrikantS    Copied and adapted to webhits use from
//                                      htx.cxx/htx.hxx
//
//----------------------------------------------------------------------------
void CWTXFile::ParseFile( CWHVarSet & variableSet )
{

    //
    //  Read the entire file into a buffer
    //
    _wcsFileBuffer = ReadFile( _wcsPhysicalName );
    Win4Assert( 0 != _wcsFileBuffer );

    //
    //  Break the buffer into the sections; the header, the detail section,
    //  and the footer.  Verify that if there is a <%BeginDetail%>
    //  section, then there MUST be a <%EndDetail%> section AFTER it, not
    //  before.  Neither <%EndDetail%> nor <%BeginDetail%> can appear on
    //  their own.
    //

    //
    //  Find the <%BeginDetail%> and <%EndDetail%> sections
    //
    WCHAR * wcsHeader     = _wcsFileBuffer;             // Assume a header
    WCHAR * wcsRowDetails = wcsipattern(wcsHeader, L"<%BEGINDETAIL%>" );
    WCHAR * wcsFooter     = wcsipattern(wcsHeader, L"<%ENDDETAIL%>" );

    if ( wcsHeader == wcsRowDetails )
    {
        //
        //  No header found in this file; it begins with the detail section.
        //
        wcsHeader = 0;
    }

    const int cwcBeginDetail = 15;
    const int cwcEndDetail   = 13;

    Win4Assert( cwcBeginDetail == wcslen( L"<%BEGINDETAIL%>" ) );
    Win4Assert( cwcEndDetail == wcslen( L"<%ENDDETAIL%>" ) );

    if ( 0 != wcsRowDetails )
    {
        //
        //  A <%BeginDetail%> section was found.  We better also have an
        //  <%EndDetail%> section AFTER the <%BeginDetail%> section.
        //

        *wcsRowDetails = 0;         // Null terminate the header string
        wcsRowDetails += cwcBeginDetail;

        if ( 0 != wcsFooter )
        {
            if ( wcsFooter < wcsRowDetails )
            {
                //
                //  The <%EndDetail%> was found before the <%BeginDetail%>
                //
                WCHAR * wcsHTXFileName;
                LONG    lLineNumber;

                GetFileNameAndLineNumber( CiPtrToInt( wcsFooter - _wcsFileBuffer ),
                                          wcsHTXFileName,
                                          lLineNumber );

                THROW( CWTXException(MSG_WEBHITS_ENDDETAIL_BEFORE_BEGINDETAIL,
                                     wcsHTXFileName,
                                     lLineNumber) );
            }

            *wcsFooter = 0;         // Null terminate the BeginDetail section
            wcsFooter += cwcEndDetail;
        }
        else
        {
            //
            //  Report an error:  <%BeginDetail%> without an <%EndDetail%>
            //

            WCHAR * wcsHTXFileName;
            LONG    lLineNumber;

            GetFileNameAndLineNumber( CiPtrToInt( wcsRowDetails - _wcsFileBuffer ),
                                      wcsHTXFileName,
                                      lLineNumber );

            THROW( CWTXException(MSG_WEBHITS_NO_ENDDETAIL_SECTION,
                                 wcsHTXFileName,
                                 lLineNumber) );
        }
    }
    else if ( 0 != wcsFooter )
    {
        //
        //  A <%BeginDetail%> section could be found.  There should
        //  be no <%EndDetail%> section either.
        //

        WCHAR * wcsHTXFileName;
        LONG    lLineNumber;

        GetFileNameAndLineNumber( CiPtrToInt( wcsFooter - _wcsFileBuffer ),
                                  wcsHTXFileName,
                                  lLineNumber );

        THROW( CWTXException(MSG_WEBHITS_NO_BEGINDETAIL_SECTION,
                             wcsHTXFileName,
                             lLineNumber) );
    }


    if ( 0 != wcsHeader )
    {
        _pVarHeader = new CWHParamReplacer ( wcsHeader,
                                                              L"<%",
                                                              L"%>" );
        _pVarHeader->ParseString( variableSet );
    }

    if ( 0 != wcsRowDetails )
    {
        _pVarRowDetails = new CWHParamReplacer ( wcsRowDetails,
                                                                  L"<%",
                                                                  L"%>" );
        _pVarRowDetails->ParseString( variableSet );
    }

    if ( 0 != wcsFooter )
    {
        _pVarFooter = new CWHParamReplacer ( wcsFooter,
                                                              L"<%",
                                                              L"%>" );
        _pVarFooter->ParseString( variableSet );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWTXFile::ReadFile - public
//
//  Synopsis:   Read the HTX file into a buffer
//
//  Arguments:  [wcsFileName]  - full physical path name of file
//
//  History:    96/Jan/03   DwightKr    created
//              96/Apr/06   DwightKr    add support for unicode files
//              96/Sep/07   SrikantS    Copied and adapted to webhits use from
//                                      htx.cxx/htx.hxx
//
//----------------------------------------------------------------------------
WCHAR * CWTXFile::ReadFile( WCHAR const * wcsFileName )
{
    Win4Assert ( 0 != wcsFileName );

    //
    //  Verify the HTX file exists, and is a file, not a directory.
    //
    WIN32_FIND_DATA ffData;
    if ( !GetFileAttributesEx( wcsFileName, GetFileExInfoStandard, &ffData ) )
    {
        ULONG error = GetLastError();

        webDebugOut(( DEB_IERROR,
                        "Unable to GetFileAttributesEx(%ws) GetLastError=0x%x\n",
                        wcsFileName,
                        error ));

        THROW( CWTXException(MSG_WEBHITS_NO_SUCH_TEMPLATE, _wcsVirtualName, 0) );
    }


    if ( (ffData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0 )
    {
        THROW( CWTXException(MSG_WEBHITS_NO_SUCH_TEMPLATE, _wcsVirtualName, 0) );
    }

    //
    //  Open the file and map its contents
    //
    CFileMapView mapView( wcsFileName );
    mapView.Init();

    int cbBuffer = mapView.GetBufferSize() + 1;
    XArray<WCHAR> pwBuffer(cbBuffer);

    //
    //  If the first two BYTES of the file are 0xFF 0xFE, then this is a
    //  unicode file, and we don't need to convert it.
    //
    if ( mapView.IsUnicode() )
    {
        RtlCopyMemory( pwBuffer.Get(), mapView.GetBuffer()+2, cbBuffer-2 );
        pwBuffer[ ( cbBuffer - 2 ) / sizeof WCHAR ] = 0;

        return pwBuffer.Acquire();
    }

    //
    //  Copy & convert the ASCII buffer to a WCHAR buffer.
    //
    int cwBuffer = mapView.GetBufferSize() + 1;
    int cwConvert;

    do
    {
        cwConvert = MultiByteToWideChar( _codePage,
                                         0,
                          (const char *) mapView.GetBuffer(),    // Ptr to input buf
                                         mapView.GetBufferSize(),// Size of input buf
                                         pwBuffer.Get(), // Ptr to output buf
                                         cwBuffer - 1 ); // Size of output buf

        if ( 0 == cwConvert )
        {
            if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                cwBuffer += (cwBuffer/2);
                delete pwBuffer.Acquire();
                pwBuffer.Init(cwBuffer);
            }
            else
            {
                THROW( CException() );
            }
        }
        else
        {
            pwBuffer[cwConvert] = 0;        // Null terminate the buffer
        }

        Win4Assert( cwConvert < cwBuffer );

    } while ( 0 == cwConvert );

    return pwBuffer.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Member:     CWTXFile::GetFileNameAndLineNumber
//
//  Synopsis:   Determines the filename & line number amoung a group of
//              nested includes for a particular offset into the buffer.
//
//  Arguments:  [offset] - offset of the error in the overall buffer
//              [wcsFileName] - resulting name of file containing error
//              [lineNumber]  - line # containing the error
//
//  History:    96/Jun/25   DwightKr    created
//              96/Sep/07   SrikantS    Copied and adapted to webhits use from
//                                      htx.cxx/htx.hxx
//
//----------------------------------------------------------------------------
void CWTXFile::GetFileNameAndLineNumber( int offset,
                                         WCHAR const *& wcsFileName,
                                         LONG & lineNumber )
{

    //
    //  Save a pointer to the name of the file containing the error
    //
    WCHAR const * pCurrent = _wcsFileBuffer;
    wcsFileName = _wcsVirtualName;


    //
    //  Count the number of lines in this sub-file
    //
    Win4Assert( 0 != _wcsFileBuffer );
    WCHAR const * pEnd = _wcsFileBuffer + offset;

    lineNumber = CountLines( pCurrent, pEnd );
}


//+---------------------------------------------------------------------------
//
//  Member:     CWTXFile::CountLines - private
//
//  Synopsis:   Deterines the number of lines (CR's) between the start
//              of the buffer and the end.
//
//  Arguments:  [wcsStart] - start location of search
//              [wcsEnd]   - end of search
//
//  History:    96/Jun/25   DwightKr    created
//              96/Sep/07   SrikantS    Copied and adapted to webhits use from
//                                      htx.cxx/htx.hxx
//
//----------------------------------------------------------------------------
LONG CWTXFile::CountLines( WCHAR const * wcsStart,
                           WCHAR const * wcsEnd ) const
{
    Win4Assert( 0 != wcsStart );
    Win4Assert( 0 != wcsEnd );

    LONG cLines = 1;

    while ( wcsStart <= wcsEnd )
    {
        if ( L'\n' == *wcsStart )
        {
            cLines++;
        }

        wcsStart++;
    }

    return cLines;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWTXFile::GetHeader - public
//
//  Synopsis:   Appends to a CVirtualString the data in the HTX file BEFORE
//              the <%begindetail%> section.  This may require replacing
//              parameters.
//
//  Arguments:  [string]       - the CVirtualString to append data to
//              [variableSet]  - a list of replaceable parameters
//              [outputFormat] - format for numbers & dates
//
//  History:    96/Jan/03   DwightKr    created
//              96/Sep/07   SrikantS    Copied and adapted to webhits use from
//                                      htx.cxx/htx.hxx
//
//----------------------------------------------------------------------------
void CWTXFile::GetHeader( CVirtualString & string,
                          CWHVarSet & variableSet )
{
    if ( 0 != _pVarHeader )
    {
        _pVarHeader->ReplaceParams( string, variableSet, _codePage );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWTXFile::GetFooter - public
//
//  Synopsis:   Appends to a CVirtualString the data in the HTX file AFTER
//              the <%enddetail%> section.  This may require replacing
//              parameters.
//
//  Arguments:  [string]      - the CVirtualString to append data to
//              [variableSet] - a list of replaceable parameters
//              [outputFormat] - format for numbers & dates
//
//  History:    96/Jan/03   DwightKr    created
//              96/Sep/07   SrikantS    Copied and adapted to webhits use from
//                                      htx.cxx/htx.hxx
//
//----------------------------------------------------------------------------
void CWTXFile::GetFooter( CVirtualString & string,
                          CWHVarSet & variableSet )
{
    if ( 0 != _pVarFooter )
    {
        _pVarFooter->ReplaceParams( string, variableSet, _codePage );
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CWHVarSet::GetStringValueHTML
//
//  Synopsis:   Get variable value formatted as HTML
//
//  Arguments:  [wcsName] - 
//              [str]     - 
//              [ulCodepage] - code page for translation
//
//  History:    9-09-96   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CWHVarSet::GetStringValueHTML( WCHAR const * wcsName,
                                    CVirtualString & str,
                                    ULONG ulCodepage )
{
    WCHAR const * pwcsValue = Find( wcsName );
    if ( pwcsValue )
    {
        HTMLEscapeW( pwcsValue, str, ulCodepage );
        return TRUE;
    }
    else return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWHVarSet::GetStringValueURL
//
//  Synopsis:   Get variable value formatted as for a URL
//
//  Arguments:  [wcsName]    - 
//              [str]        - 
//              [ulCodepage] - code page for translation
//
//  History:    9-09-96   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CWHVarSet::GetStringValueURL( WCHAR const * wcsName,
                                   CVirtualString & str,
                                   ULONG ulCodepage )
{
    WCHAR const * pwcsValue = Find( wcsName );
    if ( pwcsValue )
    {
        URLEscapeW( pwcsValue, str, ulCodepage );
        return TRUE;
    }
    else return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWHParamNode::~CWHParamNode
//
//  Synopsis:   
//
//  History:    9-09-96   srikants   Created
//
//----------------------------------------------------------------------------

CWHParamNode::~CWHParamNode()
{
    if ( 0 != _pNext )
        delete _pNext;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWHParamReplacer::CWHParamReplacer
//
//  Synopsis:   
//
//  Arguments:  [wcsString] - 
//              [wcsPrefix] - 
//              [wcsSuffix] - 
//
//  History:    9-09-96   srikants   Created
//
//----------------------------------------------------------------------------

CWHParamReplacer::CWHParamReplacer( WCHAR const * wcsString,
                                    WCHAR const * wcsPrefix,
                                    WCHAR const * wcsSuffix ) :
_wcsString(0),
_wcsPrefix(wcsPrefix),
_wcsSuffix(wcsSuffix),
_ulFlags(0),
_paramNode(L"Top")
{
        
    Win4Assert( 0 != wcsString );
    Win4Assert( 0 != wcsPrefix );
    Win4Assert( 0 != wcsSuffix );

    ULONG cwcString = wcslen(wcsString) + 1;
    _wcsString = new WCHAR[ cwcString ];
    RtlCopyMemory( _wcsString, wcsString, cwcString * sizeof(WCHAR) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CWHParamReplacer::ParseString
//
//  Synopsis:   
//
//  Arguments:  [variableSet] - 
//
//  History:    9-09-96   srikants   Created
//
//----------------------------------------------------------------------------

void CWHParamReplacer::ParseString( CWHVarSet & variableSet )
{
    CWTXScanner scanner( variableSet, _wcsPrefix, _wcsSuffix );
    scanner.Init( _wcsString );
    BuildList( scanner, &_paramNode );
}


//+---------------------------------------------------------------------------
//
//  Member:     CWHParamReplacer::ReplaceParams - public
//
//  Synopsis:   Generates a new string replacing all %values% in the original
//              string
//
//  Arguments:  [StrResult]   - a safe string to append the new params to
//              [variableSet] - the list of replaceable parameter values
//
//  Notes:      If expressions are handled in the parameter node iterator.
//
//  History:    96/Jan/03   DwightKr    Created.
//              96/Sep/07   SrikantS    Copied and adapted to webhits use from
//                                      htx.cxx/htx.hxx
//
//----------------------------------------------------------------------------
void CWHParamReplacer::ReplaceParams( CVirtualString & StrResult,
                                      CWHVarSet & variableSet, 
                                      ULONG ulCodepage )
{
    for ( CWHParamNodeIter iter(&_paramNode);
          !iter.AtEnd();
           iter.Next() )
    {
        CWHParamNode * pNode = iter.Get();

        ULONG type = pNode->Type() & eJustParamMask;

        switch ( type )
        {

        case eString:
            StrResult.StrCat( pNode->String(), pNode->Length() );
        break;

        case eParameter:
        case eEscapeHTML:
        {
            if (! variableSet.GetStringValueHTML( pNode->String(),
                                                  StrResult, ulCodepage ) )
            {
                webDebugOut(( DEB_IWARN,
                                "Warning: CWHParamReplacer::ReplaceParams GetStringValueHTML returned FALSE for '%ws'\n",
                                pNode->String() ));

                if ( eParameter == type )
                    StrResult.StrCat( _wcsPrefix );
                HTMLEscapeW( pNode->String(), StrResult, ulCodepage );
                if ( eParameter == type )
                    StrResult.StrCat( _wcsSuffix );
            }
        }
        break;

        case eEscapeURL:
        {
            if (! variableSet.GetStringValueURL( pNode->String(),
                                                 StrResult, ulCodepage ) )
            {
                webDebugOut(( DEB_IWARN,
                                "Warning: CWHParamReplacer::ReplaceParams GetStringValueURL returned FALSE for '%ws'\n",
                                pNode->String() ));

                URLEscapeW( pNode->String(), StrResult, ulCodepage );
            }
        }
        break;

        case eEscapeRAW:
        {
            ULONG cwcValue;
            WCHAR const * wcsValue = variableSet.GetStringValueRAW( pNode->String(),
                                                                    cwcValue );


            if ( 0 != wcsValue )
            {
                StrResult.StrCat( wcsValue, cwcValue );
            }
            else
            {
                webDebugOut(( DEB_IWARN,
                                "Warning: CWHParamReplacer::ReplaceParams GetStringValueRAW returned NULL for '%ws'\n",
                                pNode->String() ));

                StrResult.StrCat( pNode->String(), pNode->Length() );
            }
        }
        break;

#if DBG==1
        case eNone :
        break;

        default :
            DbgPrint(" unexpected param type: 0x%lx\n", type );
            Win4Assert( !"unexpected parameter type" );
            break;
#endif // DBG==1

        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWHParamReplacer::BuildList
//
//  Synopsis:   Builds a list of the parameters.
//
//  Arguments:  [scanner] - 
//              [pPrev]   - 
//
//  History:    9-09-96   srikants   Created
//
//----------------------------------------------------------------------------

void CWHParamReplacer::BuildList( CWTXScanner & scanner,
                                  CWHParamNode *pPrev )
{
    CWHParamNode *pNode = 0;

    while ( scanner.FindNextToken() )
    {
        switch ( scanner.TokenType() & eParamMask )
        {
        case eString:
        {
            //
            //  A non-replaceable wcsString was found before any replaceable/
            //  conditional nodes.  Save the wcsString in a node;
            //
            pNode = new CWHParamNode( scanner.GetToken(), eString );
            pPrev->SetNextNode( pNode );
            pPrev = pNode;

            break;
        }

        case eParameter:
        {
            //
            //  We've found a replaceable node.
            //
            WCHAR * wcsParameter = scanner.GetToken();

            pNode = new CWHParamNode( wcsParameter, eParameter );

            pPrev->SetNextNode( pNode );
            pPrev = pNode;

            break;
        }

        case eEscapeHTML:
        {
            WCHAR * wcsParameter = scanner.GetToken();
            pNode = new CWHParamNode( wcsParameter, eEscapeHTML );

            pPrev->SetNextNode( pNode );
            pPrev = pNode;
        }
        break;

        case eEscapeURL:
        {
            WCHAR * wcsParameter = scanner.GetToken();
            pNode = new CWHParamNode( wcsParameter, eEscapeURL );

            pPrev->SetNextNode( pNode );
            pPrev = pNode;
        }
        break;

        case eEscapeRAW:
        {
            WCHAR * wcsParameter = scanner.GetToken();
            pNode = new CWHParamNode( wcsParameter, eEscapeRAW );

            pPrev->SetNextNode( pNode );
            pPrev = pNode;
        }
        break;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\colinfo.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       colinfo.cxx
//
//  Contents:   Column information for rowsets
//
//  Classes:    CColumnsInfo
//
//  Notes:      Designed as an aggregated class of an IRowset or an
//              IQuery implementation.
//
//  History:    04 Feb 1995     AlanW   Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <colinfo.hxx>
#include <query.hxx>
#include <tblvarnt.hxx>

#include "tblrowal.hxx"
#include "tabledbg.hxx"

// Always bind as DBTYPE_VARIANT, so we can use provider-owned memory

#define ALWAYS_USE_VARIANT_BINDING

ULONG CColumnsInfo::_nUnique = 0;

const static GUID guidBmk = DBBMKGUID;

//+-------------------------------------------------------------------------
//
//  Method:     CColumnsInfo::QueryInterface, public
//
//  Synopsis:   Invokes QueryInterface on controlling unknown object
//
//  Arguments:  [riid]        -- interface ID
//              [ppvObject]   -- returned interface pointer
//
//  Returns:    SCODE
//
//  History:    04 Feb 1995     AlanW   Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CColumnsInfo::QueryInterface(
    REFIID riid,
    void **ppvObject)
{
    return _rUnknown.QueryInterface(riid,ppvObject);
} //QueryInterface


//+-------------------------------------------------------------------------
//
//  Method:     CColumnsInfo::AddRef, public
//
//  Synopsis:   Invokes AddRef on controlling unknown object
//
//  Returns:    ULONG
//
//  History:    04 Feb 1995     AlanW   Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CColumnsInfo::AddRef()
{
    return _rUnknown.AddRef();
} //AddRef


//+-------------------------------------------------------------------------
//
//  Method:     CColumnsInfo::Release, public
//
//  Synopsis:   Invokes Release on controlling unknown object
//
//  Returns:    ULONG
//
//  History:    04 Feb 1995     AlanW   Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CColumnsInfo::Release()
{
    return _rUnknown.Release();
} //Release


//+---------------------------------------------------------------------------
//
//  Member:     CColumnsInfo::CColumnsInfo, public
//
//  Synopsis:   Creates a column information class
//
//  Arguments:  [cols]        -- a reference to the output column set, pidmapped
//              [pidmap]      -- property IDs and names for the columns
//              [ErrorObject] -- a reference to enclosing object's error obj.
//              [rUnknown]    -- a reference to the controlling IUnknown
//              [fSequential] -- TRUE if the query is sequential
//
//  Notes:
//
//  History:    04 Feb 1995     AlanW   Created
//
//----------------------------------------------------------------------------

CColumnsInfo::CColumnsInfo(
        CColumnSet const & cols,
        CPidMapperWithNames const & pidmap,
        CCIOleDBError & ErrorObject,
        IUnknown &  rUnknown,
        BOOL        fSequential ) :
        _idUnique(0),
        _rUnknown(rUnknown),
        _fSequential(fSequential),
        _fChaptered(FALSE),
        _cbRowWidth(0),
        _cColumns( cols.Count() ),
        _cBoundColumns(0),
        _iColRowId(pidInvalid),
        _pColumns(0),
        _pidmap( cols.Count()+1 ),
        _ErrorObject( ErrorObject ),
        _fNotPrepared(FALSE)
{
    _SetColumns(cols, pidmap, fSequential);
}


//+---------------------------------------------------------------------------
//
//  Member:     CColumnsInfo::CColumnsInfo, public
//
//  Synopsis:   Creates an empty column information class
//
//  Arguments:  [rUnknown]    -- a reference to the controlling IUnknown
//              [ErrorObject] -- a reference to enclosing object's error obj.
//
//  Notes:      Used in the command object where column information may
//              change, depending upon the command.
//
//  History:    11 Aug 1997     AlanW   Created
//
//----------------------------------------------------------------------------

CColumnsInfo::CColumnsInfo(
        IUnknown &  rUnknown,
        CCIOleDBError & ErrorObject,
        BOOL fNotPrepared) :
        _idUnique(_GetNewId()),
        _rUnknown(rUnknown),
        _fSequential(FALSE),
        _fChaptered(FALSE),
        _cbRowWidth(0),
        _cColumns( 0 ),
        _cBoundColumns(0),
        _iColRowId(pidInvalid),
        _pColumns(0),
        _pidmap( 0 ),
        _ErrorObject( ErrorObject ),
        _fNotPrepared(fNotPrepared)
{

}


//+---------------------------------------------------------------------------
//
//  Member:     CColumnsInfo::~CColumnsInfo, public
//
//  Synopsis:   Destroys a column information class
//
//  Notes:
//
//  History:    12 Feb 1995     AlanW   Created
//
//----------------------------------------------------------------------------

CColumnsInfo::~CColumnsInfo( )
{
    delete _pColumns;
}


//+---------------------------------------------------------------------------
//
//  Member:     CColumnsInfo::InitColumns, public
//
//  Synopsis:   Initializes or reinitializes columns.
//
//  Arguments:  [cols]        -- a reference to the output column set, pidmapped
//              [pidmap]      -- property IDs and names for the columns
//              [fSequential] -- TRUE if the query is sequential
//
//  Notes:
//
//  History:    11 Aug 1997     AlanW   Created
//
//----------------------------------------------------------------------------

void CColumnsInfo::InitColumns (
        CColumnSet const & cols,
        CPidMapperWithNames const & pidmap,
        BOOL        fSequential )
{
    _pidmap.Clear();
    _cColumns = cols.Count();
    _fSequential = fSequential;
    _SetColumns(cols, pidmap, fSequential);
    _fChaptered = FALSE;
    _fNotPrepared = FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CColumnsInfo::InitColumns, public
//
//  Synopsis:   Reinitializes columns to be null.
//
//  Arguments:  [fNotPrepared]  - TRUE if GetColumnInfo and MapColumnIDs should
//                                return DB_E_NOTPREPARED for a command object
//
//  Notes:
//
//  History:    11 Aug 1997     AlanW   Created
//
//----------------------------------------------------------------------------

void CColumnsInfo::InitColumns ( BOOL fNotPrepared )
{
    _pidmap.Clear();
    _cColumns = 0;
    _fSequential = FALSE;
    _fChaptered = FALSE;
    _fNotPrepared = fNotPrepared;
}

//+---------------------------------------------------------------------------
//
//  Member:     CColumnsInfo::_SetColumns, private
//
//  Synopsis:   Initializes or reinitializes columns.
//
//  Arguments:  [cols]        -- a reference to the output column set, pidmapped
//              [pidmap]      -- property IDs and names for the columns
//              [fSequential] -- TRUE if the query is sequential
//
//  Notes:
//
//  History:    11 Aug 1997     AlanW   Created
//
//----------------------------------------------------------------------------

void CColumnsInfo::_SetColumns (
        CColumnSet const & cols,
        CPidMapperWithNames const & pidmap,
        BOOL        fSequential )
{
    Win4Assert( 0 == _pColumns && 0 == _cbRowWidth );
    _idUnique = _GetNewId();

    //
    //  We want the PidMapper to give back 1-based column numbers;
    //  add either a null propspec or the bookmark column as its first element.
    //

    if (fSequential)
    {
        CFullPropSpec nullCol;
        _pidmap.NameToPid( nullCol );
    }
    else
    {
        CFullPropSpec bmkCol( guidBmk, PROPID_DBBMK_BOOKMARK );
        _pidmap.NameToPid( bmkCol );
    }

    for (unsigned i = 0; i < _cColumns; i++)
    {
        PROPID pidTmp = cols.Get(i);
        const CFullPropSpec & ColId = *pidmap.Get(pidTmp);

        if (ColId.IsPropertyPropid() &&
            ColId.GetPropSet() == guidBmk)
        {
            Win4Assert( !fSequential );
            if (ColId.GetPropertyPropid() == PROPID_DBBMK_BOOKMARK)
            {
                if (0 != pidmap.GetFriendlyName(pidTmp))
                {
                    _pidmap.SetFriendlyName( 0, pidmap.GetFriendlyName(pidTmp) );
                }
                continue;
            }
            else if (ColId.GetPropertyPropid() == PROPID_DBBMK_CHAPTER)
            {
                _fChaptered = TRUE;
            }
        }
        PROPID pidNew = _pidmap.NameToPid( ColId );
        if (0 != pidmap.GetFriendlyName(pidTmp))
        {
            _pidmap.SetFriendlyName( pidNew, pidmap.GetFriendlyName(pidTmp) );
        }
    }

    //  In case of duplicate columns, _cColumns needs to be adjusted.
    Win4Assert( _pidmap.Count() > 1 );
    _cColumns = _pidmap.Count() - 1;
}


//+---------------------------------------------------------------------------
//
//  Member:     CColumnsInfo::MapColumnID, private
//
//  Synopsis:   Map a column identifier to its column number in the
//              cursor.
//
//  Arguments:  [pColumnId] - A pointer to the column identifier.
//
//  Returns:    The column number (1-based).  Returns DB_INVALIDCOLUMN
//              on error.
//
//  History:    04 Feb 1995     AlanW   Created
//
//----------------------------------------------------------------------------

ULONG CColumnsInfo::MapColumnID(
    const DBID *      pColumnId
) {
    PROPID pid = pidInvalid;

    if (pColumnId->eKind == DBKIND_PGUID_PROPID ||
        pColumnId->eKind == DBKIND_PGUID_NAME)
    {
        DBID dbcolMapped = *pColumnId;
        dbcolMapped.uGuid.guid = *pColumnId->uGuid.pguid;

        if (pColumnId->eKind == DBKIND_PGUID_PROPID)
            dbcolMapped.eKind = DBKIND_GUID_PROPID;
        else
            dbcolMapped.eKind = DBKIND_GUID_NAME;

        pid = _pidmap.NameToPid(dbcolMapped);
    }
    else
    {
        pid = _pidmap.NameToPid(*pColumnId);
    }

    tbDebugOut(( DEB_ITRACE, "pid: 0x%x, _cColumns: %d\n",
                 pid, _cColumns ));

    if (pid == pidInvalid || pid > _cColumns || (pid == 0 && _fSequential) )
        return (ULONG) DB_INVALIDCOLUMN;

    return pid;
}

//+---------------------------------------------------------------------------
//
//  Member:     CColumnsInfo::MapColumnIDs, public
//
//  Synopsis:   Map a column identifier to its column number in the
//              rowset.
//
//  Arguments:  [cColumnIDs] -- # of elements in the arrays
//              [rgColumnIDs]  -- A pointer to the column identifiers
//              [rgColumns] -- an array in which to return the column numbers.
//
//  Returns:    SCODE - DB_S_ERRORSOCCURRED, an element of rgColumnIDs was
//                      invalid
//
//  Notes:      Column numbers are 1-based.
//
//----------------------------------------------------------------------------

STDMETHODIMP CColumnsInfo::MapColumnIDs(
    DBORDINAL           cColumnIDs,
    const DBID          rgColumnIDs[],
    DBORDINAL           rgColumns[])
{
    _ErrorObject.ClearErrorInfo();

    SCODE sc = S_OK;

    if ((0 != cColumnIDs && 0 == rgColumnIDs) ||
         0 == rgColumns)
        return _ErrorObject.PostHResult(E_INVALIDARG, IID_IColumnsInfo);

    if ( 0 == cColumnIDs )
        return S_OK;

    if ( _fNotPrepared )
        return _ErrorObject.PostHResult(DB_E_NOTPREPARED, IID_IColumnsInfo);

    if ( 0 == _cColumns )
        return _ErrorObject.PostHResult(DB_E_NOCOMMAND, IID_IColumnsInfo);

    unsigned cBadMapping = 0;
    TRY
    {
        for (ULONG i = 0; i < cColumnIDs; i++)
        {
            ULONG ulColID = MapColumnID( &rgColumnIDs[i] );
            rgColumns[i] = ulColID;
            if (ulColID == DB_INVALIDCOLUMN)
                cBadMapping++;
        }
    }
    CATCH( CException, e )
    {
        _ErrorObject.PostHResult(e.GetErrorCode(), IID_IColumnsInfo);
        sc = GetOleError(e);
    }
    END_CATCH;

    if (SUCCEEDED(sc) && cBadMapping)
        sc = (cBadMapping == cColumnIDs) ? DB_E_ERRORSOCCURRED :
                                           DB_S_ERRORSOCCURRED;

    return sc;
} //MapColumnIDs


//+---------------------------------------------------------------------------
//
//  Member:     CColumnsInfo::GetColumnInfo, public
//
//  Synopsis:   Return information about the columns in the rowset.
//
//  Arguments:  [pcColumns] - A pointer to where the number of columns
//                            will be returned.
//              [prgInfo] -   A pointer to where a pointer to an array of
//                            DBCOLUMNINFO structures describing the columns
//                            will be returned.  This must be freed by the
//                            caller.
//              [ppStringsBuffer] - A pointer to where extra data for strings
//                            will be returned.  This must be freed by the
//                            caller if non-null.
//
//  Returns:    SCODE
//
//  Notes:      Some columns are standard columns available for all file
//              stores.  For these columns, full information about data
//              type and sizes can be returned.  For any other columns,
//              we can only say that it has a variant type.
//
//  History:    07 Nov 1994     AlanW   Created
//              04 Feb 1995     AlanW   Moved to CColumnsInfo and rewritten
//
//----------------------------------------------------------------------------

STDMETHODIMP CColumnsInfo::GetColumnInfo(
    DBORDINAL *             pcColumns,
    DBCOLUMNINFO * *    prgInfo,
    WCHAR * *           ppStringsBuffer)
{
    _ErrorObject.ClearErrorInfo();

    SCODE scResult = S_OK;

    //
    // Initialize arguments before returning errors
    //
    if ( pcColumns)
        *pcColumns = 0;
    if ( prgInfo )
        *prgInfo = 0;
    if (ppStringsBuffer )
        *ppStringsBuffer = 0;

    if (0 == pcColumns ||
        0 == prgInfo ||
        0 == ppStringsBuffer)
        return _ErrorObject.PostHResult(E_INVALIDARG, IID_IColumnsInfo);

    if ( _fNotPrepared )
        return _ErrorObject.PostHResult(DB_E_NOTPREPARED, IID_IColumnsInfo);

    if ( 0 == _cColumns )
        return _ErrorObject.PostHResult(DB_E_NOCOMMAND, IID_IColumnsInfo);

    TRY
    {
        unsigned iFirstCol = _fSequential ? 1 : 0;
        unsigned cColumns = GetColumnCount() + 1 - iFirstCol;

        //
        //  The total size required for the output array depends upon
        //  the size of variable data discovered in the column information.
        //  Although we could reallocate the memory we'll be writing into,
        //  we'll just run through the loop twice, once to compute the
        //  needed space, and the second time to copy the data out after
        //  doing our allocation.
        //
        ULONG cchNames = 0;

        for (unsigned iCol = iFirstCol; iCol <= GetColumnCount(); iCol++)
        {
            const CFullPropSpec & ColId = *_pidmap.Get(iCol);

            if (ColId.IsPropertyName())
            {
                cchNames += wcslen(ColId.GetPropertyName()) + 1;
            }

            WCHAR const * pwszColName = _pidmap.GetFriendlyName(iCol);
            if (0 == pwszColName)
                pwszColName = _FindColumnInfo(ColId).pwszName;

            if (pwszColName)
            {
                cchNames += wcslen(pwszColName) + 1;
            }
        }

        XArrayOLE<DBCOLUMNINFO> ColumnInfo( cColumns );
        XArrayOLE<WCHAR> StringBuf( cchNames );

        DBCOLUMNINFO *pColInfo = ColumnInfo.GetPointer();
        WCHAR * pwcNames = StringBuf.GetPointer();

        for (iCol = iFirstCol; iCol <= GetColumnCount(); iCol++, pColInfo++)
        {
            const CFullPropSpec & ColId = *_pidmap.Get(iCol);
            const DBCOLUMNINFO & rColumnInfo = _FindColumnInfo( ColId );

            //
            //  Copy the prototype column information, then update
            //  specific fields in the column info:
            //      column number
            //      column ID
            //      copies of strings
            //
            *pColInfo = rColumnInfo;

            pColInfo->iOrdinal = iCol;

            pColInfo->columnid.uGuid.guid = ColId.GetPropSet();
            if (ColId.IsPropertyName())
            {
                pColInfo->columnid.eKind = DBKIND_GUID_NAME;
                ULONG cch = wcslen(ColId.GetPropertyName()) + 1;
                RtlCopyMemory(pwcNames, ColId.GetPropertyName(),
                                cch * sizeof (WCHAR));
                pColInfo->columnid.uName.pwszName = pwcNames;
                pwcNames += cch;
            }
            else
            {
                Win4Assert(ColId.IsPropertyPropid());
                pColInfo->columnid.eKind = DBKIND_GUID_PROPID;
                pColInfo->columnid.uName.ulPropid = ColId.GetPropertyPropid();
            }

            WCHAR const * pwszColName = _pidmap.GetFriendlyName(iCol);
            if (0 == pwszColName)
                pwszColName = _FindColumnInfo(ColId).pwszName;

            if (pwszColName)
            {
                ULONG cch = wcslen(pwszColName) + 1;
                RtlCopyMemory(pwcNames, pwszColName, cch * sizeof (WCHAR));
                pColInfo->pwszName = pwcNames;
                pwcNames += cch;
            }
        }

        Win4Assert( (unsigned)(pColInfo - ColumnInfo.GetPointer()) == cColumns );

        *prgInfo = ColumnInfo.Acquire();
        if (cchNames > 0)
            *ppStringsBuffer = StringBuf.Acquire();

        *pcColumns = cColumns;
    }
    CATCH( CException, e )
    {
        scResult = e.GetErrorCode();
        _ErrorObject.PostHResult(scResult, IID_IColumnsInfo);
        if (scResult != E_OUTOFMEMORY)
            scResult = E_FAIL;
    }
    END_CATCH;

    return scResult;
}


//+---------------------------------------------------------------------------
//
//  Member:     CColumnsInfo::SetColumnBindings, public
//
//  Synopsis:   Set current column bindings on the cursor.  Save in
//              member variables.  Workid is always added to the
//              bindings for movable rowsets for use with bookmarks
//              and hRows.  Space for a USHORT reserved for row buffer
//              refcounting is always allocated.
//
//  Arguments:  [rpQuery] - a reference to the PQuery for the query
//              [hCursor] - a reference to the hCursor to have column
//                              bindings set on.
//              [obRowRefcount] - on return, offset into the row buffer
//                              where a USHORT reference count can be stored.
//              [obRowId] - on return, offset into the row buffer where
//                              the row identifier is stored.  Not valid for
//                              sequential rowsets.
//
//  Returns:    Nothing.  Throws on errors.
//
//  Notes:      Initializes the private members _cbRowWidth and _pColumns.
//
//  History:    04 Feb 1995     AlanW   Created
//
//----------------------------------------------------------------------------

void    CColumnsInfo::SetColumnBindings(
    PQuery &    rpQuery,
    ULONG       hCursor,
    ULONG       &obRowRefcount,
    ULONG       &obRowId,
    ULONG       &obChaptRefcount,
    ULONG       &obChaptId
) {
    CTableRowAlloc RowMap( 0 );
    USHORT maxAlignment = sizeof (USHORT);

    obRowRefcount = RowMap.AllocOffset( sizeof (USHORT),
                                        sizeof (USHORT),
                                        TRUE );

    if (_fChaptered)
        obChaptRefcount = RowMap.AllocOffset( sizeof (USHORT),
                                              sizeof (USHORT),
                                              TRUE );
    else
        obChaptRefcount = 0xFFFFFFFF;

    obRowId = 0xFFFFFFFF;
    obChaptId = 0xFFFFFFFF;
    BOOL fAddedWorkId = FALSE;
    BOOL fMayDefer = FALSE;

    // +1 In case WorkID or Path is added for rowid

    XPtr<CTableColumnSet> XColumns( new CTableColumnSet( GetColumnCount() + 1 ));

    unsigned cBoundColumns = 0;

    tbDebugOut(( DEB_ITRACE, "original column count: %d\n", GetColumnCount() ));
    for (unsigned iCol = 1; iCol <= GetColumnCount(); iCol++)
    {
        const CFullPropSpec & ColId = *_pidmap.Get( iCol );
        const DBCOLUMNINFO & rColumnInfo = _FindColumnInfo( ColId );

        tbDebugOut(( DEB_ITRACE, "colinfo::set, top of loop, cBoundColumns: %d\n",
                     cBoundColumns ));
        tbDebugOut(( DEB_ITRACE, "adding '%ws'\n", rColumnInfo.pwszName ));

        //
        //  If this is bookmark column, it will be mapped to the row ID
        //  column.  It's only valid for locatable rowsets.
        //
        if ( (rColumnInfo.dwFlags & DBCOLUMNFLAGS_ISBOOKMARK) &&
             ColId.IsPropertyPropid() &&
             ColId.GetPropertyPropid() == PROPID_DBBMK_BOOKMARK)
        {
            tbDebugOut(( DEB_ITRACE, "skipping bookmark column\n" ));

            Win4Assert(! _fSequential );
            if (_fSequential)
                THROW(CException(E_FAIL));
            continue;
        }

        // the self columns is resolved in the accessor -- no binding needed

        if ( ( ColId.IsPropertyPropid() ) &&
             ( ColId.GetPropertyPropid() == PROPID_DBSELF_SELF ) &&
             ( ColId.GetPropSet() == DBCOL_SELFCOLUMNS ) )
        {
            continue;
        }

        //
        //  Create the new column.  Note that its PropID is the
        //  1-based column ID.
        //
        XPtr<CTableColumn> TableCol(new CTableColumn( iCol ));

#ifndef ALWAYS_USE_VARIANT_BINDING
        VARTYPE vt = rColumnInfo.wType;

        switch (vt)
        {
        case DBTYPE_VARIANT:
        {
#endif // ndef ALWAYS_USE_VARIANT_BINDING

            fMayDefer = TRUE;

            TableCol->SetValueField( DBTYPE_VARIANT,
                                     RowMap.AllocOffset( sizeof (PROPVARIANT),
                                                         sizeof (LONGLONG),
                                                         TRUE ),
                                     sizeof (PROPVARIANT));

            // The status column is interesting for all columns

            TableCol->SetStatusField( RowMap.AllocOffset( sizeof (BYTE),
                                                          sizeof (BYTE),
                                                          TRUE ),
                                      sizeof (BYTE));

            // Length is interesting, especially when the value is deferred

            TableCol->SetLengthField( RowMap.AllocOffset( sizeof (ULONG),
                                                          sizeof (ULONG),
                                                          TRUE ),
                                      sizeof (ULONG));

            USHORT cbData, cbAlignment, rgfFlags;
            CTableVariant::VartypeInfo(DBTYPE_VARIANT, cbData, cbAlignment, rgfFlags);

            if ( cbAlignment > maxAlignment)
                maxAlignment = cbAlignment;

#ifndef ALWAYS_USE_VARIANT_BINDING
            break;
        }

        case DBTYPE_DATE:
        case DBTYPE_WSTR:
        case DBTYPE_STR:
            //
            //  Adjust DBTYPEs from the column info into ones that are
            //  better for binding.
            //
            if (vt == DBTYPE_DATE)
                vt = VT_FILETIME;
            else if (vt == DBTYPE_WSTR)
                vt = VT_LPWSTR;
            else if (vt == DBTYPE_STR)
                vt = VT_LPSTR;

            // NOTE: fall through

        default:

            USHORT cbData, cbAlignment, rgfFlags;
            CTableVariant::VartypeInfo(vt, cbData, cbAlignment, rgfFlags);

            if (rgfFlags & CTableVariant::MultiSize)
                cbData = (USHORT) rColumnInfo.ulColumnSize;

            Win4Assert(cbData != 0 || vt == VT_EMPTY);

            if (cbData == 0 && vt != VT_EMPTY)
            {
                tbDebugOut(( DEB_WARN,
                        "CColumnInfo::SetColumnBindings - Unknown variant type %4x\n",
                        vt));
            }

            if (cbAlignment)
            {
                if (cbAlignment > maxAlignment)
                {
                    maxAlignment = cbAlignment;
                }
            }
            else
            {
                cbAlignment = 1;
            }

            if (cbData != 0)
            {
                TableCol->SetValueField( vt,
                                         RowMap.AllocOffset( cbData,
                                                             cbAlignment,
                                                             TRUE ),
                                         cbData);

                Win4Assert( 0 == ( (TableCol->GetValueOffset()) % cbAlignment ) );

                //
                // The status column is interesting for almost all columns,
                // even inline columns, since a summary catalog might have
                // VT_EMPTY data for these columns (eg storage props).
                //
                TableCol->SetStatusField( RowMap.AllocOffset( sizeof (BYTE),
                                                              sizeof (BYTE),
                                                              TRUE ),
                                          sizeof (BYTE));
            }
        }
#endif // ndef ALWAYS_USE_VARIANT_BINDING

        //
        //  If this is the row ID column, save its offset in the row.
        //
        if (rColumnInfo.dwFlags & DBCOLUMNFLAGS_ISROWID)
        {
#ifdef ALWAYS_USE_VARIANT_BINDING
            Win4Assert(TableCol->GetStoredType() == VT_VARIANT &&
                       TableCol->IsValueStored() &&
                       TableCol->GetValueSize() == sizeof (PROPVARIANT));
            PROPVARIANT prop;
            obRowId = TableCol->GetValueOffset() +
                       (DWORD)((BYTE *) &prop.lVal - (BYTE *)&prop);
#else // ndef ALWAYS_USE_VARIANT_BINDING
            Win4Assert(TableCol->GetStoredType() == VT_I4 &&
                       TableCol->IsValueStored() &&
                       TableCol->GetValueSize() == sizeof (ULONG));
            obRowId = TableCol->GetValueOffset();
#endif // ndef ALWAYS_USE_VARIANT_BINDING
            _iColRowId = iCol;
            fAddedWorkId = TRUE;
        }

        //
        //  If this is the chapter column, save its offset in the row.
        //
        if (rColumnInfo.dwFlags & DBCOLUMNFLAGS_ISCHAPTER)
        {
            Win4Assert( _fChaptered );
#ifdef ALWAYS_USE_VARIANT_BINDING
            Win4Assert(TableCol->GetStoredType() == VT_VARIANT &&
                       TableCol->IsValueStored() &&
                       TableCol->GetValueSize() == sizeof (PROPVARIANT));
            PROPVARIANT prop;
            obChaptId = TableCol->GetValueOffset() +
                       (DWORD)((BYTE *) &prop.lVal - (BYTE *)&prop);
#else // ndef ALWAYS_USE_VARIANT_BINDING
            Win4Assert(TableCol->GetStoredType() == VT_I4 &&
                       TableCol->IsValueStored() &&
                       TableCol->GetValueSize() == sizeof (ULONG));
            obChaptId = TableCol->GetValueOffset();
#endif // ndef ALWAYS_USE_VARIANT_BINDING
        }

        XColumns->Add(TableCol.GetPointer(), cBoundColumns++);
        TableCol.Acquire();
    }

    tbDebugOut(( DEB_ITRACE, "colinfo::set, after loop, cBoundColumns: %d\n",
                 cBoundColumns ));

    // Need to add workid for non-sequential queries so that bookmarks
    // work, and either workid or path so that deferred values work.

    if ( ( ( !_fSequential ) ||
           ( fMayDefer && rpQuery.CanDoWorkIdToPath() ) ) &&
         ( !fAddedWorkId ) )
    {
        tbDebugOut(( DEB_ITRACE, "colinfo::set, adding WID column\n" ));

        //
        // Need to add the row ID column to the bindings, so that bookmarks
        // work, and deferred values can be loaded.
        //
        const DBCOLUMNINFO & rColumnInfo = _GetRowIdColumnInfo( );

        unsigned iCol = _pidmap.NameToPid( rColumnInfo.columnid );
        XPtr<CTableColumn> TableCol(new CTableColumn( iCol ));
        _iColRowId = iCol;

        Win4Assert (VT_I4 == rColumnInfo.wType);

        if (sizeof (ULONG) > maxAlignment)
            maxAlignment = sizeof (ULONG);

        TableCol->SetValueField( VT_I4,
                                 RowMap.AllocOffset( sizeof (ULONG),
                                                     sizeof (ULONG),
                                                     TRUE ),
                                 sizeof (ULONG));
        obRowId = TableCol->GetValueOffset();

        TableCol->SetStatusField( RowMap.AllocOffset( sizeof (BYTE),
                                                      sizeof (BYTE),
                                                      TRUE ),
                                  sizeof (BYTE));

        XColumns->Add(TableCol.GetPointer(), cBoundColumns++);
        TableCol.Acquire();
    }

    ULONG rem = RowMap.GetRowWidth() % maxAlignment;

    if ( 0 == rem )
        _cbRowWidth = RowMap.GetRowWidth();
    else
        _cbRowWidth = RowMap.GetRowWidth() + maxAlignment - rem;

    rpQuery.SetBindings( hCursor,
                         _cbRowWidth,
                         XColumns.GetReference(),
                         _pidmap );

    tbDebugOut(( DEB_ITRACE, "colinfo::set, old # cols %d, new # cols %d\n",
                 _cColumns, cBoundColumns ));

    _cBoundColumns = cBoundColumns;
    _pColumns = XColumns.Acquire();
}


//+---------------------------------------------------------------------------
//
//  Member:     CColumnsInfo::Get1ColumnInfo, public
//
//  Synopsis:   Return information about a single column in the rowset.
//
//  Arguments:  [iColumn] - the column number whose column info is to be
//                              returned.
//
//  Returns:    DBCOLUMNINFO & - a pointer to column info for the column
//
//  Notes:
//
//  History:    29 Mar 1995     AlanW   Created
//
//----------------------------------------------------------------------------

const DBCOLUMNINFO & CColumnsInfo::Get1ColumnInfo(
    ULONG iColumn
) /*const*/
{
    const CFullPropSpec & ColId = *_pidmap.Get(iColumn);

    return _FindColumnInfo( ColId );
}


#ifdef  INCLUDE_COLUMNS_ROWSET_IMPLEMENTATION
STDMETHODIMP CRowset::GetColumnsRowset(
    ULONG         cSelections,
    DBID          rgColumnSelection[],
    IRowset **    ppColCursor
) /*const*/ {
    _ErrorObject.ClearErrorInfo();
    return _ErrorObject.PostHResult(E_NOTIMPL, IID_IColumnsRowset);
}

STDMETHODIMP CRowset::GetAvailableColumns(
    ULONG *       pcSelections,
    DBID **       rgColumnSelection
) /*const*/ {
    _ErrorObject.ClearErrorInfo();
    return _ErrorObject.PostHResult(E_NOTIMPL, IID_IColumnsRowset);
}
#endif // INCLUDE_COLUMNS_ROWSET_IMPLEMENTATION



////////////////////////////////////////////////////////////
//
//  Data declarations for _FindColumnInfo
//
//  Notes:      These arrays of structures are prototype column info.
//              structures returned by _FindColumnInfo.
//
////////////////////////////////////////////////////////////

static const DBCOLUMNINFO aStoragePropDescs[] = {
    {   L"FileDirectoryName", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE, MAX_PATH, // storage props are never deferred
        DBTYPE_WSTR, 0xff, 0xff,
      { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PID_STG_DIRECTORY )  }
     },

    {   L"ClassID", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE|DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (GUID),
        DBTYPE_GUID, 0xff, 0xff,
      { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PID_STG_CLASSID ) }
    },

    {   L"FileStorageType", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE|DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (ULONG),
        DBTYPE_UI4, 0xff, 0xff,
      { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PID_STG_STORAGETYPE ) }
    },

    {   L"FileIndex", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE|DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (LONGLONG),
        DBTYPE_I8, 0xff, 0xff,
      { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PID_STG_FILEINDEX ) }
    },

    {   L"FileUSN", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE|DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (LONGLONG),
        DBTYPE_I8, 0xff, 0xff,
      { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PID_STG_LASTCHANGEUSN ) }
    },

    {   L"FileName", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE, MAX_PATH, // storage props are never deferred
        DBTYPE_WSTR, 0xff, 0xff,
      { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PID_STG_NAME ) }
    },

    {   L"FilePathName", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE, MAX_PATH, // storage props are never deferred
        DBTYPE_WSTR, 0xff, 0xff,
      { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PID_STG_PATH ) }
     },

    {   L"FileSize", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE|DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (LONGLONG),
        DBTYPE_I8, 0xff, 0xff,
      { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PID_STG_SIZE ) }
    },

    {   L"FileAttributes", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE|DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (ULONG),
        DBTYPE_UI4, 0xff, 0xff,
      { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PID_STG_ATTRIBUTES ) }
    },

// NOTE:  file times are typed as DBTYPE_DATE, but are bound to the
//          table as VT_FILETIME.
    {   L"FileWriteTime", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE|DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (LONGLONG),
        DBTYPE_DATE, 0xff, 0xff,
      { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PID_STG_WRITETIME ) }
    },

    {   L"FileCreateTime", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE|DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (LONGLONG),
        DBTYPE_DATE, 0xff, 0xff,
      { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PID_STG_CREATETIME ) }
    },

    {   L"FileAccessTime", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE|DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (LONGLONG),
        DBTYPE_DATE, 0xff, 0xff,
      { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PID_STG_ACCESSTIME ) }
    },

    {   L"FileShortName", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE, 13,   // storage props are never deferred
        DBTYPE_WSTR, 0xff, 0xff,
      { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PID_STG_SHORTNAME ) }
    },
};

const ULONG cStoragePropDescs =
                          sizeof aStoragePropDescs /
                          sizeof aStoragePropDescs[0];


//
//  Standard query properties.
//  Does not include pidAll or pidContent, those are used only in restrictions.
//

static const DBCOLUMNINFO aQueryPropDescs[] = {
    {   L"QueryRankvector", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE|DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof(PROPVARIANT),
        DBTYPE_VARIANT, 0xff, 0xff,
      { DBQUERYGUID, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( DISPID_QUERY_RANKVECTOR ) }
    },

    {   L"QueryRank", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE|DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (LONG),
        DBTYPE_I4, 0xff, 0xff,
      { DBQUERYGUID, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( DISPID_QUERY_RANK ) }
    },

    {   L"QueryHitCount", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE|DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (LONG),
        DBTYPE_I4, 0xff, 0xff,
      { DBQUERYGUID, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( DISPID_QUERY_HITCOUNT ) }
    },

    {   L"WorkID", 0, 0,
        DBCOLUMNFLAGS_ISFIXEDLENGTH|DBCOLUMNFLAGS_ISROWID, sizeof (LONG),
        DBTYPE_I4, 0xff, 0xff,
      { DBQUERYGUID, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( DISPID_QUERY_WORKID ) }
    },

    {   L"QueryUnfiltered", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE|DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof(BOOL),
        DBTYPE_BOOL, 0xff, 0xff,
      { DBQUERYGUID, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( DISPID_QUERY_UNFILTERED ) }
    },

    {   L"QueryVirtualPath", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE, MAX_PATH,
        DBTYPE_WSTR, 0xff, 0xff,
      { DBQUERYGUID, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( DISPID_QUERY_VIRTUALPATH ) }
    },

#if defined( DISPID_QUERY_NLIRRANK )
    {   L"NLIRRank", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE|DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (LONG),
        DBTYPE_I4, 0xff, 0xff,
      { DBQUERYGUID, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( DISPID_QUERY_NLIRRANK ) }
    },
#endif // defined( DISPID_QUERY_NLIRRANK )
};

const ULONG cQueryPropDescs =
                          sizeof aQueryPropDescs /
                          sizeof aQueryPropDescs[0];


static DBCOLUMNINFO const aBmkPropDescs[] = {
    {   L"Bookmark", 0, 0,
        DBCOLUMNFLAGS_ISBOOKMARK|DBCOLUMNFLAGS_ISFIXEDLENGTH,
        sizeof (CI_TBL_BMK),
        DBTYPE_BYTES, 0xff, 0xff,
      { DBBMKGUID, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PROPID_DBBMK_BOOKMARK ) }
    },
    {   L"Chapter", 0, 0,
        DBCOLUMNFLAGS_ISCHAPTER|DBCOLUMNFLAGS_ISBOOKMARK|DBCOLUMNFLAGS_ISFIXEDLENGTH,
        sizeof (CI_TBL_CHAPT),
        DBTYPE_BYTES, 0xff, 0xff,
      { DBBMKGUID, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PROPID_DBBMK_CHAPTER ) }
    },
};

const ULONG cBmkPropDescs =
                          sizeof aBmkPropDescs /
                          sizeof aBmkPropDescs[0];


// CLEANCODE: ole-db spec bug #1271 - const GUID init. less than useful

#ifndef DBSELFGUID
#define DBSELFGUID {0xc8b52231,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
#endif // ndef DBSELFGUID

static DBCOLUMNINFO const aSelfPropDescs[] = {
    {   L"Self", 0, 0,
        DBCOLUMNFLAGS_ISFIXEDLENGTH,
        sizeof( int ),
        DBTYPE_I4, 0xff, 0xff,
      { DBSELFGUID, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PROPID_DBSELF_SELF ) }
    },
};

const ULONG cSelfPropDescs =
                          sizeof aSelfPropDescs /
                          sizeof aSelfPropDescs[0];

#ifdef  INCLUDE_COLUMNS_ROWSET_IMPLEMENTATION

static const DBCOLUMNINFO aColInfoPropDescs[] = {

    {   L"ColumnId", 0, 0,
        DBCOLUMNFLAGS_ISFIXEDLENGTH, 3 * sizeof(PROPVARIANT),
        DBTYPE_VARIANT|DBTYPE_VECTOR, 0xff, 0xff,
      { DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)1 }
    },

    {   L"ColumnName", 0, 0,
        0, 20,
        DBTYPE_WSTR, 0xff, 0xff,
      { DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)2 }
    },

    {   L"ColumnNumber", 0, 0,
        DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (LONG),
        DBTYPE_I4, 0xff, 0xff,
      { DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)3 }
    },

    {   L"ColumnType", 0, 0,
        DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof(USHORT),
        DBTYPE_I2, 0xff, 0xff,
      { DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)4 }
    },

    {   L"ColumnLength", 0, 0,
        DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (LONG),
        DBTYPE_I4, 0xff, 0xff,
      { DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)5 }
    },

    {   L"ColumnPrecision", 0, 0,
        DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (LONG),
        DBTYPE_I4, 0xff, 0xff,
      { DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)6 }
    },

    {   L"ColumnScale", 0, 0,
        DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (LONG),
        DBTYPE_I4, 0xff, 0xff,
      { DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)7 }
    },

    {   L"ColumnFlags", 0, 0,
        DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (LONG),
        DBTYPE_I4, 0xff, 0xff,
      { DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)8 }
    },
};

const ULONG cColInfoPropDescs =
                          sizeof aColInfoPropDescs /
                          sizeof aColInfoPropDescs[0];
#endif // INCLUDE_COLUMNS_ROWSET_IMPLEMENTATION

//
//  Array of column descriptions per known propset
//  Each referenced array must have the same Guid for each element in
//  the array.
//

const CColumnsInfo::SPropSetInfo CColumnsInfo::aPropSets [ ] = {
#define IPROPSET_STORAGE        0       // Storage property set index
        { cStoragePropDescs,    aStoragePropDescs },
        { cQueryPropDescs,      aQueryPropDescs },
        { cBmkPropDescs,        aBmkPropDescs },
        { cSelfPropDescs,       aSelfPropDescs },

#ifdef  INCLUDE_COLUMNS_ROWSET_IMPLEMENTATION
        { cColInfoPropDescs,    aColInfoPropDescs },
#endif // INCLUDE_COLUMNS_ROWSET_IMPLEMENTATION
};

const ULONG CColumnsInfo::cPropSets =
                          sizeof CColumnsInfo::aPropSets /
                          sizeof CColumnsInfo::aPropSets[0];

DBCOLUMNINFO const DefaultColumnInfo = {
        0, 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE | DBCOLUMNFLAGS_MAYDEFER | DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (PROPVARIANT),
        DBTYPE_VARIANT, 0xff, 0xff,
      { {0,0,0,{0,0,0,0,0,0,0,0}}, DBKIND_GUID_PROPID, (LPWSTR)0 }
    };

//+---------------------------------------------------------------------------
//
//  Member:     CColumnsInfo::_FindColumnInfo, static
//
//  Synopsis:   Return information about a particular column ID.
//
//  Arguments:  [ColId] -     Column ID to be looked up.
//
//  Returns:    DBCOLUMNINFO - the column information for the row looked up.
//
//  Notes:      Some columns are standard columns available for all file
//              stores.  For these columns, full information about data
//              type and sizes can be returned.  For any other columns,
//              a generic column information structure is returned.
//
//  History:    10 Feb 1995     AlanW   Created
//
//----------------------------------------------------------------------------

DBCOLUMNINFO const & CColumnsInfo::_FindColumnInfo(
    const CFullPropSpec & ColId
) {
    DBCOLUMNINFO const * pColInfo = &DefaultColumnInfo;

    //
    //  All custom information we return has propids, not prop names.
    //  Valid property IDs start at 2
    //

    if (ColId.IsPropertyPropid())
    {
        for (unsigned iPropSet = 0; iPropSet < cPropSets; iPropSet++)
        {
            if (ColId.GetPropSet() ==
                aPropSets[iPropSet].aPropDescs[0].columnid.uGuid.guid)
            {
                //
                //  Found the guid for the propset, now try to find the
                //  propid.
                //
                ULONG ulPropId = ColId.GetPropertyPropid();

                Win4Assert( ulPropId != PID_CODEPAGE &&
                            ulPropId != PID_DICTIONARY);

                for (unsigned iDesc = 0;
                     iDesc < aPropSets[iPropSet].cProps;
                     iDesc++)
                {
                    if (ulPropId ==
                        aPropSets[iPropSet].aPropDescs[iDesc].columnid.uName.ulPropid)
                    {
                        pColInfo = &aPropSets[iPropSet].aPropDescs[iDesc];
                        break;
                    }
                }
                break;
            }
        }
    }
    return *pColInfo;
}


//+---------------------------------------------------------------------------
//
//  Member:     CColumnsInfo::_GetRowIdColumnInfo, static
//
//  Synopsis:   Return information about the row ID column
//
//  Arguments:  - None -
//
//  Returns:    DBCOLUMNINFO - the column information for the row looked up.
//
//  Notes:      It is assumed that there is only one row ID column in the
//              standard column info.  This may need to change for chaptered
//              rowsets.
//
//  History:    15 Mar 1995     AlanW   Created
//
//----------------------------------------------------------------------------

DBCOLUMNINFO const & CColumnsInfo::_GetRowIdColumnInfo(
) {
    DBCOLUMNINFO const * pColInfo = 0;

    for (unsigned iPropSet = 0;
         iPropSet < cPropSets && pColInfo == 0;
         iPropSet++)
    {
        for (unsigned iDesc = 0;
             iDesc < aPropSets[iPropSet].cProps;
             iDesc++)
        {
            if ( aPropSets[iPropSet].aPropDescs[iDesc].dwFlags &
                                     DBCOLUMNFLAGS_ISROWID)
            {
                pColInfo = &aPropSets[iPropSet].aPropDescs[iDesc];
                break;
            }
        }
    }

    Win4Assert(pColInfo != 0);
    return *pColInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\conpt.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       conpt.cxx
//
//  Contents:   connection point / notification code for cursors
//
//  Classes:    CConnectionPointBase, CConnectionPointContainer
//
//  History:      7 Oct 1994    Dlee    Created
//               12 Feb 1998    AlanW   Generalized
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <conpt.hxx>

#include "tabledbg.hxx"

// Max. connections per connection point. Should be enough for any application!
const maxConnections = 20;

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointBase::QueryInterface, public
//
//  Synopsis:   Invokes QueryInterface on container object
//
//  Arguments:  [riid]        -- interface ID
//              [ppvObject]   -- returned interface pointer
//
//  Returns:    SCODE
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

STDMETHODIMP CConnectionPointBase::QueryInterface(
    REFIID riid,
    void **ppvObject)
{
    SCODE sc = S_OK;

    if ( 0 == ppvObject )
        return E_INVALIDARG;

    *ppvObject = 0;

    if ( IID_IConnectionPoint == riid )
    {
        *ppvObject = (void *) (IConnectionPoint *) this;
    }
    else if ( IID_IUnknown == riid )
    {
        *ppvObject = (void *) (IUnknown *) this;
    }
    else
    {
        sc = E_NOINTERFACE;
    }

    if (SUCCEEDED(sc))
        AddRef();

    return sc;
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointBase::AddRef, public
//
//  Synopsis:   Increments ref. count, or delegates to containing object
//
//  Returns:    ULONG
//
//  History:    17 Mar 1998     AlanW
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CConnectionPointBase::AddRef()
{
    if (_pIContrUnk)
        return _pIContrUnk->AddRef( );
    else
    {
        tbDebugOut(( DEB_NOTIFY, "conpt: addref\n" ));
        return InterlockedIncrement( (long *) &_cRefs );
    }
} //AddRef

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointBase::Release, public
//
//  Synopsis:   Decrements ref. count, or delegates to containing object
//
//  Returns:    ULONG
//
//  History:    17 Mar 1998     AlanW
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CConnectionPointBase::Release()
{
    if (_pIContrUnk)
        return _pIContrUnk->Release( );
    else
    {
        long cRefs = InterlockedDecrement((long *) &_cRefs);
    
        tbDebugOut(( DEB_NOTIFY, "conpt: release, new crefs: %lx\n", _cRefs ));
    
        // If no references, make sure container doesn't know about me anymore
    
        if ( 0 == cRefs )
        {
            Win4Assert( 0 == _pContainer );

            #if 0 // Note: no sense trying to avoid an AV for bad client code
                if ( 0 != _pContainer )
                {
                    // need to have been disconnected; must be an excess release
                    // from client
                    Disconnect();
                }
            #endif // 0
            delete this;
        }
    
        return cRefs;
    }
} //Release

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointBase::GetConnectionInterface, public
//
//  Synopsis:   returns the IID of the callback notification object
//
//  Arguments:  [piid]        -- interface ID
//
//  Returns:    SCODE
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

STDMETHODIMP CConnectionPointBase::GetConnectionInterface(IID * piid)
{
    if ( 0 == piid )
        return E_POINTER;

    *piid = _iidSink;
    return S_OK;
} //GetConnectionInterface

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointBase::GetConnectionPointContainer, public
//
//  Synopsis:   returns the container that spawned the connection point
//
//  Arguments:  [ppCPC]        -- returns the container
//
//  Returns:    SCODE
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

STDMETHODIMP CConnectionPointBase::GetConnectionPointContainer(
    IConnectionPointContainer ** ppCPC)
{
    if ( 0 == ppCPC )
        return E_POINTER;

    *ppCPC = 0;
    // if disconnected from container, can't do it.
    if (0 == _pContainer)
        return E_UNEXPECTED;
    
    _pContainer->AddRef();
    *ppCPC = _pContainer;

    return S_OK;
} //GetConnectionPointContainer


//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointBase::Advise, public
//
//  Synopsis:   Passes in the client's notification object
//
//  Arguments:  [pIUnk]        -- client's notification object
//              [pdwCookie]    -- returned pseudo-id for this advise
//
//  Returns:    SCODE
//
//  Notes:      
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

STDMETHODIMP CConnectionPointBase::Advise(
    IUnknown * piunkNotify,
    DWORD * pdwCookie)
{
    SCODE sc = S_OK;

    if ( 0 != pdwCookie )
        *pdwCookie = 0;
    
    if ( 0 == piunkNotify ||
         0 == pdwCookie )
        return E_POINTER;

    XInterface<IUnknown> piSink;

    sc = piunkNotify->QueryInterface( _iidSink, piSink.GetQIPointer() );
    if (! SUCCEEDED(sc))
        return CONNECT_E_CANNOTCONNECT;

    // If disconnected from the container, can't call GetMutex.
    if (0 == _pContainer)
        return CONNECT_E_ADVISELIMIT;

    CLock lock( GetMutex() );
    CConnectionContext * pConnCtx = LokFindConnection( 0 );

    if (0 == pConnCtx && _xaConns.Count() < maxConnections)
        pConnCtx = &_xaConns[_xaConns.Count()];

    if (0 == pConnCtx)
        sc = CONNECT_E_ADVISELIMIT;
    else
    {
        _dwCookieGen++;
        Win4Assert( 0 != _dwCookieGen && 0 == LokFindConnection( _dwCookieGen ) );
        pConnCtx->Set( piSink.Acquire(), _dwCookieGen, _dwDefaultSpare );
        if (_pAdviseHelper)
            (*_pAdviseHelper) (_pAdviseHelperContext, this, pConnCtx);
        *pdwCookie = _dwCookieGen;
    }

    return sc;
} //Advise

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointBase::Unadvise, public
//
//  Synopsis:   Turns off an advise previously turned on with Advise()
//
//  Arguments:  [dwCookie] -- pseudo-id for this advise
//
//  Returns:    SCODE
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

STDMETHODIMP CConnectionPointBase::Unadvise(
    DWORD dwCookie)
{
    SCODE sc = S_OK;
    CConnectionContext * pConnCtx = 0;

    CReleasableLock lock( GetMutex(), ( 0 != _pContainer ) );

    pConnCtx = LokFindConnection( dwCookie );
    if (pConnCtx)
    {
        if (_pUnadviseHelper)
            (*_pUnadviseHelper) ( _pUnadviseHelperContext, this, pConnCtx, lock );
        pConnCtx->Release();
    }


    if (0 == pConnCtx)
    {
        tbDebugOut(( DEB_WARN, "conpt: unknown advise cookie %x\n", dwCookie ));
        sc = CONNECT_E_NOCONNECTION;
    }

    return sc;
} //Unadvise


//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointBase::EnumConnections, public
//
//  Synopsis:   Returns an enumerator of advises open in this connection
//
//  Arguments:  [ppEnum]       -- returned enumerator
//
//  Returns:    SCODE
//
//  Notes:      The spec permits E_NOTIMPL to be returned for this.  If
//              we chose to implement it, it's a straightforward matter of
//              iterating over the _xaConns array.
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

STDMETHODIMP CConnectionPointBase::EnumConnections(
    IEnumConnections ** ppEnum)
{
    if ( 0 == ppEnum )
        return E_POINTER;

    *ppEnum = 0;
    return E_NOTIMPL;
} //EnumConnections


//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointBase::Disconnect, private
//
//  Synopsis:   Disconnect from the connection point container
//
//  Arguments:  [dwCookie]    -- pseudo-id for this advise
//
//  Returns:    CConnectionContext* - a connection matching the [dwCookie] or 0
//
//  Notes:      Should be called with the CPC lock held.  Might be called
//              without the lock for an Unadvise after the CPC is diconnected.
//
//  History:    30 Mar 1998     AlanW      Created
//
//--------------------------------------------------------------------------

void CConnectionPointBase::Disconnect( )
{
    Win4Assert( 0 != _pContainer );
    CLock lock(GetMutex());

    _pContainer->RemoveConnectionPoint( this );
    _pContainer = 0;
}


//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointBase::LokFindConnection, private
//
//  Synopsis:   Find a connection matching an advise cookie
//
//  Arguments:  [dwCookie]    -- pseudo-id for this advise
//
//  Returns:    CConnectionContext* - a connection matching the [dwCookie] or 0
//
//  Notes:      Should be called with the CPC lock held.  Might be called
//              without the lock for an Unadvise after the CPC is diconnected.
//
//  History:    10 Mar 1998     AlanW      Created
//
//--------------------------------------------------------------------------

CConnectionPointBase::CConnectionContext *
   CConnectionPointBase::LokFindConnection( DWORD dwCookie )
{
    for (unsigned i=0; i<_xaConns.Count(); i++)
    {
        CConnectionContext & rConnCtx = _xaConns[i];

        if (rConnCtx._dwAdviseCookie == dwCookie)
            return &rConnCtx;
    }
    return 0;
}

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointBase::LokFindActiveConnection, private
//
//  Synopsis:   Find an active advise by indexing
//
//  Arguments:  [riConn]   -- index into conn. context array, updated on return
//
//  Returns:    CConnectionContext* - pointer to an active connection context,
//                                    or NULL.
//
//  Notes:      Should be called with the CPC lock held.
//
//  History:    10 Mar 1998     AlanW      Created
//
//--------------------------------------------------------------------------

CConnectionPointBase::CConnectionContext *
    CConnectionPointBase::LokFindActiveConnection( unsigned & riConn )
{
    while (riConn < _xaConns.Count())
    {
        CConnectionContext & rCtx = _xaConns[riConn];

        if (rCtx._dwAdviseCookie != 0)
            return &rCtx;

        riConn++;
    }
    return 0;
}

/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointContainer::QueryInterface, public
//
//  Synopsis:   Invokes QueryInterface on cursor object
//
//  Arguments:  [riid]        -- interface ID
//              [ppvObject]   -- returned interface pointer
//
//  Returns:    SCODE
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

STDMETHODIMP CConnectionPointContainer::QueryInterface(
    REFIID riid,
    void **ppvObject)
{
    if ( 0 == ppvObject )
        return E_INVALIDARG;

    return _rControllingUnk.QueryInterface(riid, ppvObject);
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointContainer::AddRef, public
//
//  Synopsis:   Invokes AddRef on cursor object
//
//  Returns:    ULONG
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CConnectionPointContainer::AddRef()
{
    tbDebugOut(( DEB_NOTIFY, "conptcontainer: addref\n" ));
    return _rControllingUnk.AddRef();
} //AddRef

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointContainer::Release, public
//
//  Synopsis:   Invokes Release on cursor object
//
//  Returns:    ULONG
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CConnectionPointContainer::Release()
{
    tbDebugOut(( DEB_NOTIFY, "conptcontainer: release\n" ));
    return _rControllingUnk.Release();
} //Release

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointContainer::CConnectionPointContainer, public
//
//  Synopsis:   Constructor for connection point container class.
//
//  Arguments:  [maxConnPt] -- maximum number of connection points supported
//              [rUnknown]  -- controlling unknown
//              [ErrorObject] -- reference to error object
//
//  Notes:      After construction, use AddConnectionPoint to add a connection
//              point into the container.
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

CConnectionPointContainer::CConnectionPointContainer(
            unsigned maxConnPt,
            IUnknown &rUnknown,
            CCIOleDBError & ErrorObject )
   : _rControllingUnk(rUnknown),
     _ErrorObject( ErrorObject ),
     _cConnPt( 0 )
{
    Win4Assert( maxConnPt <= maxConnectionPoints );
} //CConnectionPointContainer

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointContainer::~CConnectionPointContainer, public
//
//  Synopsis:   Destructor for connection point container class.
//
//  Notes:      It is expected that all connection points are relased by this
//              time.
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

CConnectionPointContainer::~CConnectionPointContainer()
{
    CLock lock( _mutex );

    //
    // Release all connection points
    //

    for (unsigned i = 0; i < _cConnPt; i++)
    {
        IConnectionPoint * pIConnPt = _aConnPt[i]._pIConnPt;
        if ( 0 != pIConnPt )
        {
            _aConnPt[i]._pIConnPt = 0;
            pIConnPt->Release();
        }
    }
} //~CConnectionPointContainer

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointContainer::FindConnectionPoint, public
//
//  Synopsis:   Finds a connection point object that supports the given
//              interface for callback to the client
//
//  Arguments:  [riid]        -- interface ID for proposed callback
//              [ppPoint]     -- returned connection interface pointer
//
//  Returns:    SCODE
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

STDMETHODIMP CConnectionPointContainer::FindConnectionPoint(
    REFIID riid,
    IConnectionPoint ** ppPoint)
{
    _ErrorObject.ClearErrorInfo();

    if ( 0 == ppPoint )
        return E_POINTER;

    *ppPoint = 0;
    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        CLock lock( _mutex );

        for (unsigned i = 0; i < _cConnPt; i++)
        {
            if ( riid == _aConnPt[i]._iidConnPt )
                break;
        }

        if ( i<_cConnPt )
        {
            Win4Assert(_aConnPt[i]._pIConnPt != 0);
            IConnectionPoint * pIConnPt = _aConnPt[i]._pIConnPt;
            *ppPoint = pIConnPt;
            pIConnPt->AddRef();
        }
        else
        {
            sc = CONNECT_E_NOCONNECTION;
        }

        if (FAILED(sc))
            _ErrorObject.PostHResult(sc, IID_IConnectionPointContainer);
    }
    CATCH(CException,e)
    {
        _ErrorObject.PostHResult(e.GetErrorCode(), IID_IConnectionPointContainer);
        sc = E_UNEXPECTED;
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
} //FindConnectionPoint

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointContainer::EnumConnectionPoints, public
//
//  Synopsis:   Enumerates all connection points currently in use
//
//  Arguments:  [ppEnum]      -- returned enumerator
//
//  Returns:    SCODE
//
//  History:    09 Mar 1998     AlanW    Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CConnectionPointContainer::EnumConnectionPoints(
    IEnumConnectionPoints **ppEnum)
{
    _ErrorObject.ClearErrorInfo();

    if ( 0 == ppEnum )
        return E_POINTER;

    *ppEnum = 0;
    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        CLock lock( _mutex );

        XInterface<IEnumConnectionPoints> pEnumCp( new CEnumConnectionPoints( *this ) );
        *ppEnum = pEnumCp.GetPointer();
        pEnumCp.Acquire();
    }
    CATCH(CException,e)
    {
        _ErrorObject.PostHResult(e.GetErrorCode(), IID_IConnectionPointContainer);
        sc = e.GetErrorCode();
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
} //EnumConnectionPoints



//+-------------------------------------------------------------------------
//
//  Method:     CEnumConnectionPoints::QueryInterface, public
//
//  Synopsis:   Invokes QueryInterface on connection point enumerator object
//
//  Arguments:  [riid]        -- interface ID
//              [ppvObject]   -- returned interface pointer
//
//  Returns:    SCODE
//
//  History:    10 Mar 1998     AlanW
//
//--------------------------------------------------------------------------

STDMETHODIMP CEnumConnectionPoints::QueryInterface(
    REFIID riid,
    void **ppvObject)
{
    SCODE sc = S_OK;

    if ( 0 == ppvObject )
        return E_INVALIDARG;

    *ppvObject = 0;

    if ( IID_IEnumConnectionPoints == riid )
    {
        *ppvObject = (void *) (IEnumConnectionPoints *) this;
    }
    else if ( IID_IUnknown == riid )
    {
        *ppvObject = (void *) (IUnknown *) this;
    }
    else
    {
        sc = E_NOINTERFACE;
    }

    if (SUCCEEDED(sc))
        AddRef();

    return sc;
} //QueryInterface


//+-------------------------------------------------------------------------
//
//  Method:     CEnumConnectionPoints::AddRef, public
//
//  Synopsis:   Invokes AddRef on container object
//
//  Returns:    ULONG
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CEnumConnectionPoints::AddRef()
{
    return InterlockedIncrement( (long *) &_cRefs );
} //AddRef

//+-------------------------------------------------------------------------
//
//  Method:     CEnumConnectionPoints::Release, public
//
//  Synopsis:   Invokes Release on container object
//
//  Returns:    ULONG
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CEnumConnectionPoints::Release()
{
    long cRefs = InterlockedDecrement((long *) &_cRefs);

    tbDebugOut(( DEB_NOTIFY, "enumconpt: release, new crefs: %lx\n", _cRefs ));

    // If no references, delete.

    if ( 0 == cRefs )
    {
        delete this;
    }

    return cRefs;
} //Release


//+-------------------------------------------------------------------------
//
//  Method:     CEnumConnectionPoints::Clone, public
//
//  Synopsis:   Clone a connection point enumerator
//
//  Arguments:  [ppEnum]      -- returned enumerator
//
//  Returns:    SCODE
//
//  History:    09 Mar 1998     AlanW    Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CEnumConnectionPoints::Clone (
    IEnumConnectionPoints **ppEnum)
{
    //_ErrorObject.ClearErrorInfo();

    if ( 0 == ppEnum )
        return E_POINTER;

    *ppEnum = 0;
    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        XInterface<CEnumConnectionPoints> pEnumCp( new CEnumConnectionPoints( _rContainer ) );
        pEnumCp->_iConnPt = _iConnPt;
        *ppEnum = pEnumCp.GetPointer();
        pEnumCp.Acquire();
    }
    CATCH(CException,e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
} //Clone

//+-------------------------------------------------------------------------
//
//  Method:     CEnumConnectionPoints::Reset, public
//
//  Synopsis:   Reset a connection point enumerator
//
//  Arguments:  -NONE-
//
//  Returns:    SCODE
//
//  History:    09 Mar 1998     AlanW    Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CEnumConnectionPoints::Reset ( )
{
    _iConnPt = 0;
    return S_OK;
} //Reset

//+-------------------------------------------------------------------------
//
//  Method:     CEnumConnectionPoints::Skip, public
//
//  Synopsis:   Skip some connection points
//
//  Arguments:  [cConnections] - number of connection points to skip
//
//  Returns:    SCODE
//
//  History:    09 Mar 1998     AlanW    Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CEnumConnectionPoints::Skip ( ULONG cConnections )
{
    SCODE sc = S_OK;

    if ( _iConnPt+cConnections < _rContainer._cConnPt )
        _iConnPt += cConnections;
    else
        sc = S_FALSE;
    return sc;
} //Skip

//+-------------------------------------------------------------------------
//
//  Method:     CEnumConnectionPoints::Next, public
//
//  Synopsis:   Return some connection points
//
//  Arguments:  [cConnections] - number of connection points to return, at most
//              [rgpcm]  - array of IConnectionPoint* to be returned
//              [pcFetched] - on return, number of connection points in [rgpcm]
//
//  Returns:    SCODE
//
//  History:    09 Mar 1998     AlanW    Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CEnumConnectionPoints::Next ( ULONG cConnections,
                                           IConnectionPoint **rgpcm,
                                           ULONG * pcFetched )
{
    SCODE sc = S_OK;

    if ( 0 != pcFetched )
        *pcFetched = 0;

    if ( 0 == rgpcm ||
         0 == pcFetched )
        return E_POINTER;

    for (ULONG i=0; i<cConnections; i++)
        rgpcm[i] = 0;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        ULONG cRet = 0;
        CLock lock(_rContainer._mutex);

        // Note: There could be leakage of CP pointers if there are exceptions
        //       generated by the code below.
        while ( _iConnPt < _rContainer._cConnPt &&
                cRet < cConnections )
        {
            XInterface<IConnectionPoint> xCP( _rContainer._aConnPt[_iConnPt]._pIConnPt );
            xCP->AddRef();   
            rgpcm[cRet] = xCP.GetPointer();
            cRet++;
            _iConnPt++;
            *pcFetched = cRet;
            xCP.Acquire();
        }
        sc = (cConnections == cRet) ? S_OK : S_FALSE;
    }
    CATCH(CException,e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
} //Next


//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointContainer::AddConnectionPoint, public
//
//  Synopsis:   Adds a connection point to the container.
//              Called by the connection point itself.
//
//  Arguments:  [riid]    --- IID of notification interface for CP
//              [pConnPt] --- connection point to be removed
//
//  Notes:      The back pointer from the connection point to the connection
//              point container does not contribute to the container's ref.
//              count so that the CPC <-> CP structure is not self-referential
//              and can be deleted when no longer needed.
//
//  History:    10 Mar 1998     AlanW
//
//--------------------------------------------------------------------------

void CConnectionPointContainer::AddConnectionPoint(
    REFIID riid,
    CConnectionPointBase *pConnPt)
{
    Win4Assert( _cConnPt < maxConnectionPoints );

    XInterface<IConnectionPoint> xConnPt;
    SCODE sc = pConnPt->QueryInterface( IID_IConnectionPoint,
                                        xConnPt.GetQIPointer());
    if (!SUCCEEDED(sc))
        THROW( CException(sc) );

    CLock lock(_mutex);

    CConnectionPointContext * pConnPtCtx = &_aConnPt[_cConnPt];
    pConnPtCtx->_pIConnPt = xConnPt.Acquire();
    pConnPtCtx->_iidConnPt = riid;
    _cConnPt++;
} //AddConnectionPoint

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointContainer::RemoveConnectionPoint, public
//
//  Synopsis:   Removes a connection point from the container.
//              Called by the connection point itself.
//
//  Arguments:  [pConnPt]  --- connection point to be removed
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

void CConnectionPointContainer::RemoveConnectionPoint(
    IConnectionPoint *pConnPt)
{
    CLock lock(_mutex);

    for (unsigned i = 0; i < _cConnPt; i++)
    {
        if ( _aConnPt[i]._pIConnPt == pConnPt )
        {
            _aConnPt[i]._pIConnPt = 0;
            pConnPt->Release();
        }
    }
} //RemoveConnectionPoint
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\hraccess.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       hraccess.cxx
//
//  Contents:   OLE DB HRow accessor helper class
//
//  Classes:    CAccessor
//              CRowDataAccessor
//              CRowDataAccessorByRef
//
//  History:    21 Nov 94       dlee   Created from AlanW's tblwindo code
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <rowset.hxx>
#include <query.hxx>
#include "tabledbg.hxx"


//+-------------------------------------------------------------------------
//
//  Member:     CAccessorBag::Destroy, private
//
//  Synopsis:   Removes an accessor from the bag and deletes it
//
//  History:    12 Jan 1995     dlee   Created
//
//--------------------------------------------------------------------------

void CAccessorBag::Destroy(
    CAccessorBase * pAccessor )
{
    pAccessor->SetInvalid();
    Remove(pAccessor);

    TRY
    {
        while (pAccessor->GetRefcount() > 0)
            pAccessor->Release();  // this can throw - we'll toss away error
    }
    CATCH( CException, e )
    {
        SCODE sc = GetOleError(e);
        tbDebugOut(( DEB_ERROR, "CAccessorBase::Release threw 0x%x\n", sc ));
    }
    END_CATCH;

    if (0 == pAccessor->GetInheritorCount() )
        delete pAccessor;
} //Destroy

//+-------------------------------------------------------------------------
//
//  Member:     CAccessorBag::~CAccessorBag, private
//
//  Synopsis:   Removes accessors the user forgot to free
//
//  History:    16 Jan 1997     dlee   Created
//
//--------------------------------------------------------------------------

CAccessorBag::~CAccessorBag()
{
    CAccessorBase *p;
    while ( p = First() )
    {
        tbDebugOut(( DEB_ITRACE,
                     "App bug: Deleting an accessor that wasn't freed\n" ));
        Destroy( p );
    }
} //~CAccessorBag

//+-------------------------------------------------------------------------
//
//  Member:     CAccessorBag::Release, public
//
//  Synopsis:   Dereference an accessor; delete it if refcount goes to 0
//
//  History:    18 Sep 1996    Alanw    Created
//
//--------------------------------------------------------------------------

void CAccessorBag::Release(HACCESSOR hAccessor, ULONG * pcRef)
{
    CAccessorBase *pAccessor = Convert(hAccessor);  // will throw if accessor invalid
                                                    // caught by ReleaseAccessor
    if (0 == pAccessor->Release())
    {
        Destroy(pAccessor);
        if (pcRef)
            *pcRef = 0;
    }
    else
    {
        if (pcRef)
            *pcRef = pAccessor->GetRefcount();
    }
} //Release

//+-------------------------------------------------------------------------
//
//  Member:     CAccessorBag::AddRef, public
//
//  Synopsis:   Adds a reference to an accessor
//
//  History:    18 Sep 1996    Alanw    Created
//
//--------------------------------------------------------------------------

void CAccessorBag::AddRef(HACCESSOR hAccessor, ULONG * pcRef)
{
    CAccessorBase *pAccessor = Convert(hAccessor);

    ULONG cRef = pAccessor->AddRef();
    if (pcRef)
        *pcRef = cRef;
} //AddRef

// This pool has no private data -- it just calls the OLE allocator, so
// it can be static.

CAccessorAllocator CAccessor::_Pool;

//+-------------------------------------------------------------------------
//
//  Function:   isVariableLength
//
//  Synopsis:   TRUE if the type is one of the odd oledb types that can
//              have variable length inline data
//
//  Arguments:  [type]     -- oledb data type
//
//  History:    6 Feb 95       dlee   created
//
//--------------------------------------------------------------------------

static BOOL isVariableLength( DWORD type )
{
    type &= VT_TYPEMASK;

    return type == DBTYPE_STR    ||
           type == DBTYPE_BYTES  ||
           type == DBTYPE_WSTR;
} //isVariableLength

//+-------------------------------------------------------------------------
//
//  Function:   isValidByRef
//
//  Synopsis:   TRUE if the type is one of the odd oledb types that can
//              be combined with DBTYPE_BYREF
//
//  Arguments:  [type]     -- oledb data type
//
//  History:    9 Aug 95       dlee   created
//
//--------------------------------------------------------------------------

static BOOL isValidByRef( DWORD type )
{
    type &= ~DBTYPE_BYREF;

    return type == DBTYPE_STR    ||
           type == DBTYPE_WSTR   ||
           type == DBTYPE_BYTES  ||
           type == DBTYPE_GUID   ||
           type == VT_CF         ||
           type == DBTYPE_VARIANT;
} //isValidByref

//+-------------------------------------------------------------------------
//
//  Function:   isEquivalentType
//
//  Synopsis:   TRUE if the types are interchangable between OLE-DB and
//              PROPVARIANT.  Unfortunately, several of the types are
//              equivalent but have different representations.
//
//  Arguments:  [vtDst]    -- OLE-DB destination type
//              [vtSrc]    -- PROPVARIANT source type
//
//  History:    9 Aug 95       dlee   created
//
//--------------------------------------------------------------------------

static BOOL isEquivalentType( VARTYPE vtDst, VARTYPE vtSrc )
{
    return ( ( vtDst == vtSrc ) ||
             ( ( ( DBTYPE_WSTR | DBTYPE_BYREF ) == vtDst ) &&
               ( VT_LPWSTR == vtSrc ) ) ||
             ( ( ( DBTYPE_STR | DBTYPE_BYREF ) == vtDst ) &&
               ( VT_LPSTR == vtSrc ) ) ||
             ( ( ( DBTYPE_WSTR | DBTYPE_BYREF | DBTYPE_VECTOR ) == vtDst ) &&
               ( ( VT_LPWSTR | VT_VECTOR ) == vtSrc ) ) ||
             ( ( ( DBTYPE_STR | DBTYPE_BYREF | DBTYPE_VECTOR ) == vtDst ) &&
               ( ( VT_LPSTR | VT_VECTOR ) == vtSrc ) ) ||
             ( ( ( DBTYPE_GUID | DBTYPE_BYREF ) == vtDst ) &&
               ( VT_CLSID == vtSrc ) ) ||
             ( ( ( VT_CF | DBTYPE_BYREF ) == vtDst ) &&
               ( VT_CF == vtSrc ) ) );
} //isEquivalentType

//+-------------------------------------------------------------------------
//
//  Function:   NullOrCantConvert, inline
//
//  Synopsis:   Returns DBSTATUS_S_ISNULL if [type] is one of the types which
//              represent null data, DBSTATUS_E_CANTCONVERTVALUE otherwise.
//
//  Arguments:  [type]     -- variant data type
//
//  History:    24 Feb 98      AlanW   created
//
//--------------------------------------------------------------------------

inline DBSTATUS NullOrCantConvert( VARTYPE type )
{
    if ( type == VT_EMPTY || type == VT_NULL )
        return DBSTATUS_S_ISNULL;
    else
        return DBSTATUS_E_CANTCONVERTVALUE;
} //NullOrCantConvert


//+---------------------------------------------------------------------------
//
//  Function:   ConvertBackslashToSlash, inline
//
//  Synopsis:   Converts '\' characters to '/' in a string inplace.
//
//  Arguments:  [pwszPath] -- string to be converted
//
//  History:    24 Feb 98      AlanW   Added header
//
//----------------------------------------------------------------------------

inline void ConvertBackslashToSlash( LPWSTR pwszPath )
{
    Win4Assert( 0 != pwszPath );

    while ( 0 != *pwszPath )
    {
        if ( L'\\' == *pwszPath )
        {
            *pwszPath = L'/';
        }
        pwszPath++;
    }
} //ConvertBackslashToSlash

// DBGP - a debug parameter, only available on checked builds
#ifndef DBGP
    #if DBG == 1
        #define DBGP(a) , a
    #else
        #define DBGP(a)
    #endif // DBG
#endif // ndef DBGP

//+-------------------------------------------------------------------------
//
//  Member:     CAccessor::_BindingFailed, private
//
//  Synopsis:   Stores a binding status for an individual binding error.
//              The caller should continue processing with the next binding.
//
//  Arguments:  [BindStat]        -- what when wrong?
//              [iBinding]        -- which binding was bad?
//              [pBindStatus]     -- where to indicate bad binding
//
//  History:    6 Feb 95       dlee   created
//
//--------------------------------------------------------------------------

void CAccessor::_BindingFailed(
    DBBINDSTATUS  BindStat,
    DBORDINAL     iBinding,
    DBBINDSTATUS* pBindStatus
    DBGP(char*    pszExplanation)
)
{
    tbDebugOut(( DEB_TRACE,
                 "CAccessor: construction failed, bindstatus=%x, binding %d\n",
                 BindStat, iBinding ));
#if DBG == 1
    if (pszExplanation)
    {
        tbDebugOut(( DEB_TRACE|DEB_NOCOMPNAME, "\t%s\n", pszExplanation ));
    }
#endif // DBG

    if (pBindStatus != 0)
    {
        pBindStatus[iBinding] = BindStat;
    }
    _scStatus = DB_E_ERRORSOCCURRED;
} //_BindingFailed

//+-------------------------------------------------------------------------
//
//  Member:     CAccessor::_ConstructorFailed, private
//
//  Synopsis:   Indicate an error with parameters other than an individual
//              binding.  Throw an exception for the error.
//
//  Arguments:  [scFailure]       -- what when wrong?
//
//  History:    16 Sep 1996    AlanW   created
//
//--------------------------------------------------------------------------

void CAccessor::_ConstructorFailed(
    SCODE         scFailure
    DBGP(char*    pszExplanation)
)
{
    tbDebugOut(( DEB_TRACE,
                 "CAccessor: construction failed, sc=%x\n",
                 scFailure ));
#if DBG == 1
    if (pszExplanation)
    {
        tbDebugOut(( DEB_TRACE|DEB_NOCOMPNAME, "\t%s\n", pszExplanation ));
    }
#endif // DBG

    _scStatus = scFailure;

    QUIETTHROW(CException(scFailure));
} //_ConstructorFailed


static const GUID s_guidStorage = PSGUID_STORAGE;
static const GUID s_guidQuery = DBQUERYGUID;
const DBORDINAL colInvalid = -1;

//+---------------------------------------------------------------------------
//
//  Member:     CAccessor::_Initialize
//
//  Synopsis:   Initializes the object without verifying the coercions.
//
//  Arguments:  [dwAccessorFlags] - accessor flags, read/write, etc.
//              [cBindings]     - count of bindings
//              [rgBindings]    - array of binding structures
//              [pBindStat] - on return, pointer to first binding in error
//
//  History:    21 Nov 94       dlee       created
//              11-07-95        srikants   Moved from constructor
//
//  Notes:
//
//----------------------------------------------------------------------------

void CAccessor::_Initialize(
    DBACCESSORFLAGS   dwAccessorFlags,
    DBORDINAL         cBindings,
    const DBBINDING * rgBindings,
    DBBINDSTATUS *    pBindStat)
{
    // Invalid accessor flag?
    if ( dwAccessorFlags & ~ ( DBACCESSOR_PASSBYREF |
                               DBACCESSOR_ROWDATA |
                               DBACCESSOR_PARAMETERDATA |
                               DBACCESSOR_OPTIMIZED) )
        _ConstructorFailed(DB_E_BADACCESSORFLAGS
                           DBGP("bad dwAccessorFlags bits"));

    if ( (dwAccessorFlags & ( DBACCESSOR_ROWDATA | DBACCESSOR_PARAMETERDATA ) )
          == 0)
        _ConstructorFailed(DB_E_BADACCESSORFLAGS
                           DBGP("bad dwAccessorFlags type"));

    if ( dwAccessorFlags & DBACCESSOR_PARAMETERDATA )
        _ConstructorFailed(DB_E_BADACCESSORFLAGS
                           DBGP("parameter accessors are not supported"));

    // byref accessors are not supported
    if ( dwAccessorFlags & ( DBACCESSOR_PASSBYREF) )
        _ConstructorFailed(DB_E_BYREFACCESSORNOTSUPPORTED
                           DBGP("byref accessors are not supported"));

    // null accessors are not supported
    if ( 0 == _cBindings )
        _ConstructorFailed(DB_E_NULLACCESSORNOTSUPPORTED
                           DBGP("null accessors are not supported"));

    // verify each binding is ok and save it
    for (DBORDINAL iBinding = 0; iBinding < _cBindings; iBinding++)
    {
        CDataBinding DataBinding (rgBindings[iBinding]);
        DBPART cp = DataBinding.Binding().dwPart;
        DBTYPE wType = DataBinding.Binding().wType;

        if (0 != pBindStat)
            pBindStat[iBinding] = DBBINDSTATUS_OK;

        // check for invalid bits in the column parts

        if (cp &
            ~(DBPART_VALUE | DBPART_LENGTH | DBPART_STATUS))
             _BindingFailed(DBBINDSTATUS_BADBINDINFO,iBinding,pBindStat
                            DBGP("bad dwPart bits"));

        // at least one of value, length or status flags must be on

        if (0 == (cp & (DBPART_VALUE | DBPART_LENGTH | DBPART_STATUS)))
            _BindingFailed(DBBINDSTATUS_BADBINDINFO,iBinding,pBindStat
                           DBGP("zero dwPart"));

        // we don't support abstract data types

        if (0 != DataBinding.Binding().pTypeInfo)
            _BindingFailed(DBBINDSTATUS_BADBINDINFO,iBinding,pBindStat
                           DBGP("bad pTypeInfo"));

        if (0 != DataBinding.Binding().pBindExt)
            _BindingFailed(DBBINDSTATUS_BADBINDINFO,iBinding,pBindStat
                           DBGP("bad pBindExt"));

        if (0 != (DataBinding.Binding().dwFlags & DBBINDFLAG_HTML))
            _BindingFailed(DBBINDSTATUS_BADBINDINFO,iBinding,pBindStat
                           DBGP("no HTML binding support"));
        else if (0 != DataBinding.Binding().dwFlags)
            _BindingFailed(DBBINDSTATUS_BADBINDINFO,iBinding,pBindStat
                           DBGP("bad dwFlags"));

        //
        // Verify size and alignment of output buffer.  Set cbWidth in local
        // copy of binding to handle length of fixed-width types correctly.
        //
        if ( 0 != ( wType & DBTYPE_BYREF ) )
        {
            if ( ! isValidByRef( wType ) )
                _BindingFailed( DBBINDSTATUS_BADBINDINFO,
                                    iBinding,
                                    pBindStat
                                    DBGP("byref on non-byref type") );

            // byref data: client's cbMaxLen is noise
            DataBinding.SetMaxLen(sizeof LPWSTR);
        }
        else if ( 0 != ( wType & DBTYPE_VECTOR ) )
        {
            USHORT cbWidth = sizeof ( DBVECTOR );
            USHORT cbAlign = sizeof ( DBVECTOR );

            #if CIDBG==1
                tbDebugOut(( DEB_ACCESSOR,
                             "type %d, obValue %d, alignment needed: %d\n",
                             (int) wType,
                             (int) DataBinding.Binding().obValue,
                             (int) cbAlign ));

                //Win4Assert( (0 == (DBPART_VALUE & cp)) ||
                //            ( (0 != cbAlign) &&
                //              (0 == (DataBinding.Binding().obValue % cbAlign)) ) );

                if ( (DBPART_VALUE & cp) &&
                     (0 != (DataBinding.Binding().obValue % cbAlign)) )
                {
                    tbDebugOut(( DEB_ERROR,
                                 "bad value alignment for DBVECTOR, obValue %d, alignment needed: %d\n",
                                 (int) DataBinding.Binding().obValue,
                                 (int) cbAlign ));
                }
            #endif // CIDBG==1

            // Fixed-length data types needn't have their width set, per
            // the Nile spec.  So we set it to the default for the type.

            DataBinding.SetMaxLen( cbWidth );
        }
        else if ( 0 != ( wType & VT_ARRAY ) )
        {
           DataBinding.SetMaxLen( sizeof( SAFEARRAY * ) );
        }
        else
        {
            USHORT cbWidth,cbAlign,gfFlags;

            CTableVariant::VartypeInfo( wType,
                                        cbWidth,
                                        cbAlign,
                                        gfFlags );

            #if CIDBG==1
                tbDebugOut(( DEB_ACCESSOR,
                             "type %d, obValue %d, alignment needed: %d\n",
                             (int) wType,
                             (int) DataBinding.Binding().obValue,
                             (int) cbAlign ));

                //Win4Assert( (0 == (DBPART_VALUE & cp)) ||
                //            ( (0 != cbAlign) &&
                //              (0 == (DataBinding.Binding().obValue % cbAlign)) ) );

                if ( (DBPART_VALUE & cp) &&
                     (0 != (DataBinding.Binding().obValue % cbAlign)) )
                {
                    tbDebugOut(( DEB_ERROR,
                                 "bad value alignment for type %d, obValue %d, alignment needed: %d\n",
                                 (int) wType,
                                 (int) DataBinding.Binding().obValue,
                                 (int) cbAlign ));
                }
            #endif // CIDBG==1
            // Fixed-length data types needn't have their width set, per
            // the Nile spec.  So we set it to the default for the type.

            if (! isVariableLength( wType ) )
                DataBinding.SetMaxLen( cbWidth );
        }

        if (DataBinding.Binding().dwMemOwner & ~(DBMEMOWNER_PROVIDEROWNED))
            _BindingFailed(DBBINDSTATUS_BADBINDINFO,iBinding,pBindStat
                           DBGP("bad dwMemOwner bits"));

        if (DBTYPE_EMPTY == (wType & VT_TYPEMASK) ||
            DBTYPE_NULL  == (wType & VT_TYPEMASK) ||
            0 != (wType & VT_RESERVED))
        {
            _BindingFailed(DBBINDSTATUS_BADBINDINFO,iBinding,pBindStat
                           DBGP("bad wType"));
        }

        if ((wType & ~VT_TYPEMASK) != 0 &&
            (wType & ~VT_TYPEMASK) != DBTYPE_ARRAY &&
            (wType & ~VT_TYPEMASK) != DBTYPE_VECTOR &&
            (wType & ~VT_TYPEMASK) != DBTYPE_BYREF )
        {
            _BindingFailed(DBBINDSTATUS_BADBINDINFO,iBinding,pBindStat
                           DBGP("bad wType modifier combination"));
        }

        // SPECDEVIATION - this is bogus; DBTYPE_VARIANT must be supported!

        if ((DataBinding.Binding().dwMemOwner & DBMEMOWNER_PROVIDEROWNED) &&
            (wType != DBTYPE_BSTR) &&
            !(wType & (DBTYPE_BYREF | DBTYPE_VECTOR | DBTYPE_ARRAY )))
            _BindingFailed(DBBINDSTATUS_BADBINDINFO,iBinding,pBindStat
                           DBGP("bad provider-owned mem type"));

        if ( (DataBinding.Binding().dwMemOwner & DBMEMOWNER_PROVIDEROWNED) &&
             (wType == (DBTYPE_BYREF|DBTYPE_VARIANT)) &&
             ! _fExtendedTypes )
            _BindingFailed(DBBINDSTATUS_BADBINDINFO,iBinding,pBindStat
                           DBGP("provider-owned mem without extended types"));

        _aBindings[ iBinding] = DataBinding;

        if ( DataBinding.Binding().pObject )
        {
            _aBindings[iBinding].Binding().pObject = new DBOBJECT;

            RtlCopyMemory( _aBindings[(unsigned)iBinding].Binding().pObject, 
                           DataBinding.Binding().pObject,
                           sizeof( DBOBJECT ) );
        }
    }

    // Verify that none of the output offsets and lengths overlap with
    // any others.  This must be run after the above loop so cbMaxLength
    // fields are properly initialized.

    if (_scStatus == S_OK)
        _ValidateOffsets( pBindStat );
} //_Initialize


//+---------------------------------------------------------------------------
//
//  Member:     CAccessor::Validate
//
//  Synopsis:   Validates the coercions with respect to the ColumnsInfo.
//
//  Arguments:  [rColumnsInfo] - The column info. for the rowset
//              [pBindStat]    - Binding status array (optional)
//
//  History:    21 Nov 94   dlee        created
//              11-08-95    srikants    Created
//              01-15-98    VikasMan    Removed call to checkcoercion here
//                                      Checking done only in GetData now
//
//----------------------------------------------------------------------------

void CAccessor::Validate(
    CColumnsInfo & rColumnsInfo,
    DBBINDSTATUS * pBindStatus )
{
    _pColumnsInfo = &rColumnsInfo;
    Win4Assert( 0 != _pColumnsInfo );

    for (DBORDINAL iBinding = 0; iBinding < _cBindings; iBinding++)
    {
        CDataBinding & DataBinding = _aBindings[iBinding];
        DBTYPE wType = (DBTYPE) DataBinding.Binding().wType;

        //
        // Make sure the column id is valid.  Remember, column numbers are
        // 1-based.  Map columnid 0 to the row ID column for the bookmark.
        //
        DBORDINAL iColumnId = DataBinding.Binding().iOrdinal;

        if ( ! _pColumnsInfo->IsValidColumnId( (ULONG) iColumnId ) )
        {
            _BindingFailed(DBBINDSTATUS_BADORDINAL, iBinding, pBindStatus
                           DBGP("invalid iOrdinal"));
            continue;
        }

        const DBCOLUMNINFO & rColInfo =
                _pColumnsInfo->Get1ColumnInfo( (ULONG) iColumnId );


        if ( DBTYPE_HCHAPTER == wType &&
             !(rColInfo.dwFlags & DBCOLUMNFLAGS_ISCHAPTER) )
        {
            _BindingFailed(DBBINDSTATUS_UNSUPPORTEDCONVERSION, iBinding, pBindStatus
                           DBGP("Chapter type binding to non-chapter column"));
            continue;
        }

        //
        // The only IUNKNOWN binding we currently support is for the
        // DBCOL_SELFCOLUMNS guid, with propid PROPID_DBSELF_SELF.
        // We don't yet support binding to a particular column, just
        // to the row (file) as a whole, and only if the client is FSCI.
        //

        if ( DBTYPE_IUNKNOWN == wType )
        {
            // Map self to the rowid column

            if ( ( DBCOL_SELFCOLUMNS == rColInfo.columnid.uGuid.guid ) &&
                 ( PROPID_DBSELF_SELF == rColInfo.columnid.uName.ulPropid ) )
                DataBinding.SetDataColumn( _pColumnsInfo->GetRowIdColumn() );
            else
                _BindingFailed(DBBINDSTATUS_BADBINDINFO,iBinding,pBindStatus
                               DBGP("bad IUNKNOWN binding"));
        }

        // If it's the path column, save the column # for possible use later
        // when doing deferred or self loads

        if ( rColInfo.columnid.uGuid.guid == s_guidStorage &&
             rColInfo.columnid.uName.ulPropid == PID_STG_PATH )
            _iPathColumn = DataBinding.GetDataColumn();

        // If it's the vpath column, save the column # for later use.  We
        // need to translate '\' to '/' in the vpath column.

        if ( rColInfo.columnid.uGuid.guid == s_guidQuery &&
             rColInfo.columnid.uName.ulPropid == DISPID_QUERY_VIRTUALPATH )
            _iVpathBinding = iBinding;


        // If it's a bookmark column, map it to the corresponding row ID
        // column for retrieval.

        if ( (rColInfo.dwFlags & DBCOLUMNFLAGS_ISBOOKMARK) &&
             ! ( rColInfo.dwFlags & DBCOLUMNFLAGS_ISCHAPTER ) )
            DataBinding.SetDataColumn( _pColumnsInfo->GetRowIdColumn() );

        // If it's a chapter column, mark it to Addref the chapter on retrieval

        if ( (rColInfo.dwFlags & DBCOLUMNFLAGS_ISCHAPTER) &&
             (DBPART_VALUE & DataBinding.Binding().dwPart) )
            DataBinding.SetChapter( TRUE );
    }

    // look for pathname -- it may be in the rowbuffer columns, but not
    // in the accessor's bindings.

    if ( colInvalid == _iPathColumn )
    {
        for ( ULONG x = 0; x < rColumnsInfo.GetHiddenColumnCount(); x++ )
        {
            CFullPropSpec const &spec = *rColumnsInfo.GetPropSpec( x+1 );

            tbDebugOut(( DEB_ACCESSOR,
                         "spec 0x%x IsPropid %d, propid 0x%x, pathpropid: 0x%x\n",
                         &spec,
                         spec.IsPropertyPropid(),
                         spec.GetPropertyPropid(),
                         PID_STG_PATH ));

            if ( spec.IsPropertyPropid() &&
                 PID_STG_PATH == spec.GetPropertyPropid() &&
                 s_guidStorage == spec.GetPropSet() )
            {
                _iPathColumn = x+1;
                break;
            }
        }
    }

    _idColInfo = _pColumnsInfo->GetId();
} //Validate

//+-------------------------------------------------------------------------
//
//  Member:     CAccessor::CAccessor, public
//
//  Synopsis:   Constructs an accessor object
//
//  Arguments:  [dwAccessorFlags] -- accessor flags
//              [cBindings]       -- # of bindings specified
//              [rgBindings]      -- array of bindings
//              [pBindStat]       -- returns index of bad binding (if any)
//              [fExtTypes]       -- TRUE if extended variants are supported
//              [pColumns]        -- column info for early checking of column
//                                   coercions
//              [type]            -- type of accessor
//              [pCreator]        -- 
//
//  History:    21 Nov 94       dlee   created
//
//--------------------------------------------------------------------------

CAccessor::CAccessor(
    DBACCESSORFLAGS   dwAccessorFlags,
    DBCOUNTITEM       cBindings,
    const DBBINDING * rgBindings,
    DBBINDSTATUS *    pBindStat,
    BOOL              fExtTypes,
    CColumnsInfo *    pColumns,
    EAccessorType     type,
    void *            pCreator
) :
    CAccessorBase(pCreator, type),
    _dwAccessorFlags(dwAccessorFlags),
    _scStatus(S_OK),
    _aBindings( (unsigned) cBindings),
    _cBindings(cBindings),
    _idColInfo(0),
    _pColumnsInfo(0),
    _iPathColumn( colInvalid ),
    _iVpathBinding( colInvalid ),
    _fExtendedTypes( fExtTypes )
{
    _Initialize( dwAccessorFlags, cBindings, rgBindings, pBindStat );

    if ( 0 != pColumns && _scStatus == S_OK )
        Validate( *pColumns, pBindStat );
    if (_scStatus != S_OK)
        QUIETTHROW(CException(_scStatus));
} //CAccessor

//+-------------------------------------------------------------------------
//
//  Member:     CAccessor::~CAccessor, public
//
//  Synopsis:   Destructs an accessor object
//
//  History:    19 Apr 2000       dlee   added header
//
//--------------------------------------------------------------------------

CAccessor::~CAccessor()
{
    // Delete DBOBJECTs

    for ( unsigned iBinding = 0; iBinding < _cBindings; iBinding++ )
    {
        if ( 0 != _aBindings[iBinding].Binding().pObject )
            delete _aBindings[iBinding].Binding().pObject;

        // These are for future use according to OLE-DB 2.0 and should be NULL

        Win4Assert( 0 == _aBindings[iBinding].Binding().pTypeInfo &&
                    0 == _aBindings[iBinding].Binding().pBindExt );
    }

    CAccessorBase * pParent = GetParent();

    if ( 0 != pParent )
    {
       if ( 0 == pParent->DecInheritors() && 0 == pParent->GetRefcount() )
          delete pParent;
    }
} //~CAccessor

//+-------------------------------------------------------------------------
//
//  Member:     CAccessor::_ValidateOffsets, private
//
//  Synopsis:   Checks a binding for overlapping output fields
//
//  Arguments:  [pBindStat] -- where to indicate bad binding
//
//  History:    18 May 1995     dlee   Created
//
//--------------------------------------------------------------------------

void CAccessor::_ValidateOffsets( DBBINDSTATUS * pBindStatus )
{
    for ( DBORDINAL iBinding = 0; iBinding < _cBindings; iBinding++ )
    {
        CDataBinding & DataBinding = _aBindings[ iBinding];

        COffsetLengthPair aPairs[3];
        ULONG cPairs = 0;
        DataBinding.CollectOutputPairs( aPairs, cPairs );

        // Check for overlap with data/length/status in this binding

        for ( DBORDINAL i = 0; i < cPairs; i++ )
        {
            for ( DBORDINAL j = i + 1; j < cPairs; j++)
            {
                if ( aPairs[i].isInConflict( aPairs[j] ) )
                {
                    _BindingFailed( DBBINDSTATUS_BADBINDINFO,
                                    iBinding,
                                    pBindStatus
                                    DBGP("intra-binding field overlap") );
                    continue;
                }
            }
        }

        // Check for overlap with other bindings

        for ( i = iBinding + 1; i < _cBindings; i++ )
        {
            CDataBinding &binding = _aBindings[i];
            COffsetLengthPair aTestPairs[3];
            ULONG cTestPairs = 0;
            binding.CollectOutputPairs( aTestPairs, cTestPairs );

            for (ULONG iPair = 0; iPair < cPairs; iPair++)
            {
                for (ULONG iTestPair = 0; iTestPair < cTestPairs; iTestPair++)
                {
                    if ( aPairs[iPair].isInConflict( aTestPairs[iTestPair] ) )
                    {
                        _BindingFailed( DBBINDSTATUS_BADBINDINFO,
                                        i,
                                        pBindStatus
                                        DBGP("inter-binding field overlap") );
                        continue;
                    }
                }
            }
        }
    }
} //_ValidateOffsets

//+---------------------------------------------------------------------------
//
//  Member:     CAccessor::CanConvertType, static public
//
//  Synopsis:   Indicate whether a type conversion is valid.
//
//  Arguments:  [wFromType]  -- source type
//              [wToType]    -- destination type
//              [fExTypes]   -- TRUE if extended types allowed
//              [xDataConvert] --   OLEDB IDataConvert interface pointer
//
//  Returns:    TRUE if the conversion is available, FALSE otherwise.
//              Throws E_FAIL or E_INVALIDARG on errors.
//
//  History:    20 Nov 96      AlanW    Created
//              14 Jan 98      VikasMan Add xDataConvert parameter
//
//----------------------------------------------------------------------------

BOOL CAccessor::CanConvertType(
    DBTYPE wFromType,
    DBTYPE wToType,
    BOOL   fExTypes,
    XInterface<IDataConvert>& xDataConvert)
{
    USHORT cbData, cbAlignFrom, rgfFlagsFrom;
    CTableVariant::VartypeInfo(wFromType, cbData, cbAlignFrom, rgfFlagsFrom);

    USHORT cbAlignTo, rgfFlagsTo;
    CTableVariant::VartypeInfo(wToType, cbData, cbAlignTo, rgfFlagsTo);

    if (0 == cbAlignFrom || 0 == cbAlignTo)
        QUIETTHROW(CException(E_INVALIDARG));   // bad type

    if ( ((wToType & ~VT_TYPEMASK) != 0 &&
          (wToType & ~VT_TYPEMASK) != DBTYPE_ARRAY &&
          (wToType & ~VT_TYPEMASK) != DBTYPE_VECTOR &&
          (wToType & ~VT_TYPEMASK) != DBTYPE_BYREF ) ||
         0 != (wToType & VT_RESERVED) )
    {
        tbDebugOut(( DEB_IERROR, "CanConvertType: conversion to invalid type"));
        QUIETTHROW(CException(E_INVALIDARG));
    }

    if ( ((wFromType & ~VT_TYPEMASK) != 0 &&
          (wFromType & ~VT_TYPEMASK) != DBTYPE_ARRAY &&
          (wFromType & ~VT_TYPEMASK) != DBTYPE_VECTOR &&
          (wFromType & ~VT_TYPEMASK) != DBTYPE_BYREF ) ||
         0 != (wFromType & VT_RESERVED) )
    {
        tbDebugOut(( DEB_IERROR, "CanConvertType: conversion from invalid type"));
        QUIETTHROW(CException(E_INVALIDARG));
    }


    //
    // check for conversions _Initialize() does not allow
    //
    // check if byref request for "short" type
    if ( (wToType & DBTYPE_BYREF) && !isValidByRef(wToType) )
    {
       tbDebugOut(( DEB_IERROR, "CanConvertType: conversion to byref type for short type"));
       return FALSE;
    }

    if ( DBTYPE_EMPTY == (wToType & VT_TYPEMASK) ||
         DBTYPE_NULL  == (wToType & VT_TYPEMASK) )

    {
       tbDebugOut(( DEB_IERROR, "CanConvertType: conversion to empty or null type"));
       return FALSE;
    }

    //
    // check extended type conversions
    //

    // NEWFEATURE: - vector ==> array conversion?

    if ((wToType & DBTYPE_ARRAY) && (wToType != wFromType))
    {
       tbDebugOut(( DEB_IERROR, "CanConvertType: conversion to array"));
       return FALSE;
    }
    if ((wToType & DBTYPE_VECTOR) &&
             !(isEquivalentType(wToType,wFromType) || wFromType == VT_VARIANT))
    {
       tbDebugOut(( DEB_IERROR, "CanConvertType: conversion to vector"));
       return FALSE;
    }

    //
    // VARIANT conversions depend upon whether extended types are supported
    //
    if (wToType == DBTYPE_VARIANT)
    {
        if (fExTypes)
            return TRUE;

        if ( (wFromType & ~(DBTYPE_BYREF)) == DBTYPE_GUID)
            return FALSE;

        return TRUE;
    }

    //
    //  Anything can coerce into DBTYPE_BYTES
    //
    if (wToType == DBTYPE_BYTES)
       return TRUE;

    // now use OLEDB to check if  conversion is possible
    return COLEDBVariant::CanConvertType( wFromType, wToType, xDataConvert );

} //CanConvertType

//+-------------------------------------------------------------------------
//
//  Member:     CAccessor::GetBindings, public
//
//  Synopsis:   Fetches a copy of the bindings used by the accessor
//
//  Arguments:  [pAccessorFlags]  -- accessor flags
//              [pcBindings]      -- # of bindings returned
//              [ppBindings]      -- array of bindings returned.  the user
//                                   must IMalloc::Free this memory.
//
//  Returns:    SCODE - S_OK.  Return value required by base class
//                             CAccessorBase
//
//  History:    21 Nov 94       dlee   created
//              05 May 97       emilyb switched first 2 params from
//                                     references to pointers so that
//                                     this can be a virtual member of
//                                     CAccessorBase.  (CDistributedAccessor
//                                     cannot use references).
//
//--------------------------------------------------------------------------

SCODE CAccessor::GetBindings(
    DBACCESSORFLAGS * pAccessorFlags,
    DBCOUNTITEM *     pcBindings,
    DBBINDING **      ppBindings)
{
    // in case of an error later, init the count to a good state

    *pcBindings = 0;

    // verify this pointer is good

    *ppBindings = 0;

    // allocate room for the bindings and copy them

    *ppBindings = (DBBINDING *) _Pool.Allocate( (ULONG) _cBindings * sizeof DBBINDING );

    *pAccessorFlags = _dwAccessorFlags;
    *pcBindings = _cBindings;

    for ( DBORDINAL i = 0; i < _cBindings; i++ )
    {
        (*ppBindings)[i] = _aBindings[ i].Binding();

        if ( _aBindings[i].Binding().pObject )
        {
            (*ppBindings)[i].pObject = (DBOBJECT*) _Pool.Allocate( sizeof( DBOBJECT ) );

            RtlCopyMemory( (*ppBindings)[i].pObject, 
                           _aBindings[i].Binding().pObject,
                           sizeof( DBOBJECT ) );
        }

        // These are for future use according to OLE-DB 2.0 and should be NULL
        Win4Assert( 0 == _aBindings[i].Binding().pTypeInfo &&
                    0 == _aBindings[i].Binding().pBindExt );
    }

    return S_OK;
} //GetBindings

//+-------------------------------------------------------------------------
//
//  Member:     CRowDataAccessor::_LoadPath, private
//
//  Synopsis:   Loads the path of the object represented by the row
//
//  Arguments:  [rSrcSet]       -- set of source columns
//              [pbSrc]         -- source row buffer
//              [funnyPath]     -- where to put the path
//
//  History:    30 May 95       dlee   created
//
//--------------------------------------------------------------------------

void CRowDataAccessor::_LoadPath(
    CTableColumnSet & rSrcSet,
    BYTE *            pbSrc,
    CFunnyPath &      funnyPath )
{
    // either path or workid must be available -- it's added by ColInfo
    // when the query is created.

    if ( colInvalid != _iPathColumn )
    {
        // pathname happened to be one of the columns -- this is faster than
        // doing a wid translation

        CTableColumn *pPathCol = rSrcSet.Find( (ULONG) _iPathColumn );

        WCHAR *pwc = 0;
        if (pPathCol->GetStoredType() == VT_LPWSTR)
        {
            pwc = * ( (WCHAR **) (pbSrc + pPathCol->GetValueOffset()) );
        }
        else
        {
            Win4Assert(pPathCol->GetStoredType() == VT_VARIANT);
            CTableVariant & varnt = * ( (CTableVariant *) (pbSrc + pPathCol->GetValueOffset()) );
            if (varnt.vt == VT_LPWSTR)
                pwc = varnt.pwszVal;
        }

        if (pwc)
        {
            funnyPath.SetPath( pwc );
        }
    }
    else
    {
        // translate the wid for the row into a pathname

        Win4Assert( colInvalid != _pColumnsInfo->GetRowIdColumn() );
        _pQuery->WorkIdToPath( _RowWid( rSrcSet, pbSrc ), funnyPath );
    }
} //_LoadPath

//+-------------------------------------------------------------------------
//
//  Member:     CRowDataAccessor::_BindToObject, private
//
//  Synopsis:   Binds to an object and returns an interface pointer
//
//  Arguments:  [pbDst]         -- destination row buffer
//              [rDstBinding]   -- binding for the destination
//              [pbSrc]         -- source row buffer
//              [rSrcColumn]    -- source column description
//              [rSrcSet]       -- set of source columns
//
//  Returns:    DBSTATUS  -- status of the column copy
//
//  History:    10 Apr 95       dlee   created
//
//--------------------------------------------------------------------------

DBSTATUS CRowDataAccessor::_BindToObject(
    BYTE *            pbDst,
    CDataBinding &    rDstBinding,
    BYTE *            pbSrc,
    CTableColumn &    rSrcColumn,
    CTableColumnSet & rSrcSet)
{
    //
    // CLEANCODE: This is all wrong.  StgOpenStorage doesn't belong in
    // framework code!  Though fixing this would be hard -- we'd have to
    // remote the object binding from the server process.  And we only
    // try this for the path column -- if it doesn't exist this code won't
    // be executed.
    //

    DBSTATUS DstStatus = 0;

    // get the pathname for ole to open the storage

    CFunnyPath funnyPath;
    _LoadPath( rSrcSet, pbSrc, funnyPath );

    // bind to the file and return interface pointer requested

    if ( 0 != funnyPath.GetActualLength() )
    {
        // WORKAROUND: StgOpenStorage AVs for paths > MAX_PATH currently
        // So till it is fixed, make sure we do not pass a path > MAX_PATH

        if ( funnyPath.GetLength() < MAX_PATH )
        {
            XInterface<IStorage> xStorage;
            SCODE sc = StgOpenStorage( funnyPath.GetPath(),
                                       0,
                                       rDstBinding.Binding().pObject->dwFlags,
                                       0, 0,
                                       xStorage.GetPPointer() );
    
            if ( SUCCEEDED( sc ) )
                sc = xStorage->QueryInterface( rDstBinding.Binding().pObject->iid,
                                               (void **) pbDst );
    
            if ( FAILED( sc ) )
                DstStatus = DBSTATUS_E_CANTCREATE;
        }
        else
        {
            ciDebugOut(( DEB_WARN, "Not calling StgOpenStorage in CRowDataAccessor::_BindToObject for paths > MAX_PATH: \n(%ws)\n",
                                   funnyPath.GetPath() ));
            DstStatus = DBSTATUS_E_CANTCREATE;
        }
    }
    else
        DstStatus = DBSTATUS_S_ISNULL;

    return DstStatus;
} //_BindToObject

//+-------------------------------------------------------------------------
//
//  Member:     CRowDataAccessor::_LoadDeferred, private
//
//  Synopsis:   Loads a non-storage property value.  Only called if the
//              value is large, hence not already loaded.
//
//  Arguments:  [rSrcVar]    -- where the value is written
//              [pbSrc]      -- pointer to the row data (to get the wid)
//              [iColumn]    -- column being copied
//              [rSrcSet]    -- set of source columns
//
//  Returns:    DBSTATUS  -- status of the load
//
//  History:    1 Jun 95       dlee   created
//
//--------------------------------------------------------------------------

DBSTATUS CRowDataAccessor::_LoadDeferred(
    CTableVariant &                   rSrcVar,
    BYTE *                            pbSrc,
    DBORDINAL                         iColumn,
    CTableColumnSet &                 rSrcSet)
{
    // If the property set storage has not yet been opened for this object,
    // load it now.

    tbDebugOut(( DEB_ACCESSOR, "loading deferred value\n" ));

    rSrcVar.vt = VT_EMPTY; // just in case we can't load anything

    CFullPropSpec const *ps = _pColumnsInfo->GetPropSpec( (ULONG)
                                  _aBindings[iColumn].GetDataColumn() );

    //
    // Try loading from the property cache/docfile if the workid column is
    // available.
    //

    DBORDINAL rowIdCol = _pColumnsInfo->GetRowIdColumn();
    if ( ( colInvalid == rowIdCol ) ||
         ( !_pQuery->FetchDeferredValue( _RowWid( rSrcSet, pbSrc ), *ps, rSrcVar ) ) )
    {
        return DBSTATUS_S_ISNULL;
    }

    tbDebugOut(( DEB_ACCESSOR, "successfully loaded deferred value\n" ));

    return DBSTATUS_S_OK;
} //_LoadDeferred

//+-------------------------------------------------------------------------
//
//  Member:     CRowDataAccessor::_ComplexCopy, private
//
//  Synopsis:   Do a complex copy of the value to the client's buffer
//
//  Arguments:  [rDstBinding]   -- binding for the destination
//              [pbSrc]         -- source row buffer
//              [rSrcColumn]    -- source column description
//              [iColumn]       -- column being copied
//              [vtSrc]         -- type of the source
//              [cbDstLength]   -- on exit, size of destination data
//              [pbSrcData]     -- pointer to source data
//              [vtDst]         -- type of the destination value
//              [pbDstData]     -- where to write the value
//              [rSrcSet]       -- set of source columns
//              [rRowBuffer]    -- row buffer
//              [hrow]          -- hrow being retrieved
//              [xDataConvert]  -- smart pointer to IDataConvert interface.
//                                 this is to be passed along and used finally
//                                 in COLEDBVariant::CopyOrCoerce
//
//  Returns:    DBSTATUS  -- status of the column copy
//
//  History:    01 Jun 1995   dlee        created
//              09 Jan 1998   vikasman    added xDataConvert parameter
//
//--------------------------------------------------------------------------

DBSTATUS CRowDataAccessor::_ComplexCopy(
    CDataBinding &                    rDstBinding,
    BYTE *                            pbSrc,
    CTableColumn &                    rSrcColumn,
    DBORDINAL                         iColumn,
    VARTYPE                           vtSrc,
    DBLENGTH &                        cbDstLength,
    BYTE *                            pbSrcData,
    VARTYPE                           vtDst,
    BYTE *                            pbDstData,
    CTableColumnSet &                 rSrcSet,
    CRowBuffer &                      rRowBuffer,
    HROW                              hrow,
    XInterface<IDataConvert>&         xDataConvert)
{
    DBSTATUS DstStatus = DBSTATUS_S_OK;

    // Convert to a COLEDBVariant, then copy it using the OLEDBConvert
    // method.  This allows coercions and variant to nonvariant, etc.
    // conversions to occur.

    COLEDBVariant SrcVar;
    BOOL fDoCopy = TRUE;
    BOOL fFreeDeferredSrc = FALSE;

    if ( VT_VARIANT == vtSrc )
    {
        Win4Assert(rSrcColumn.GetValueSize() == sizeof PROPVARIANT);

        if ( ( rSrcColumn.IsDeferred( pbSrc ) ) )
        {
            DstStatus = _LoadDeferred( SrcVar,
                                       pbSrc,
                                       iColumn,
                                       rSrcSet );

            if ( DBStatusOK ( DstStatus ) )
            {
                // Attempt to store the data without using OLEDBConvert

                if ( (VT_VARIANT == vtDst && _fExtendedTypes) ||
                     DBTYPE_PROPVARIANT == vtDst )
                {
                    fDoCopy = FALSE;
                    * (PROPVARIANT *) pbDstData = SrcVar;
                    cbDstLength = sizeof (PROPVARIANT);
                }
                else if ( (VT_VARIANT|DBTYPE_BYREF) == vtDst ||
                          (DBTYPE_PROPVARIANT|DBTYPE_BYREF) == vtDst )
                {
                    fDoCopy = FALSE;

                    // Slam the variant into the src data row buffer, then
                    // hand out a pointer to that variant.
                    // We need a home for the variant portion, and that
                    // place should do fine.
                    // The value portion of the variant will still be
                    // owned by the row buffer as a normal deferred value.

                    * (PROPVARIANT *) pbSrcData = SrcVar;
                    * (PROPVARIANT **) pbDstData = (PROPVARIANT *) pbSrcData;
                    cbDstLength = sizeof (PROPVARIANT);
                }
                else if ( isEquivalentType( vtDst, SrcVar.vt ) &&
                          SrcVar.VariantPointerInFirstWord() )
                {
                    // Grab the pointer value out of the variant; any ptr will do
                    fDoCopy = FALSE;
                    * ( (LPWSTR *) pbDstData ) = SrcVar.pwszVal;

                    if ( SrcVar.vt & VT_ARRAY )
                    {
                        cbDstLength = sizeof (SAFEARRAY *);
                    }
                    else
                    {
                        switch (SrcVar.vt )
                        {
                        case VT_LPWSTR:
                            cbDstLength = wcslen(SrcVar.pwszVal) * sizeof (WCHAR);
                            break;
                        case VT_LPSTR:
                            cbDstLength = strlen(SrcVar.pszVal) * sizeof (char);
                            break;
                        case VT_BSTR:
                            cbDstLength = sizeof (BSTR);
                            break;
                        case VT_CLSID:
                            cbDstLength = sizeof (GUID);
                            break;
                        case VT_CF:
                            cbDstLength = sizeof (CLIPDATA);
                            break;
                        default:
                            tbDebugOut(( DEB_ERROR, "SrcVar.vt = 0x%x\n", SrcVar.vt ));
                            Win4Assert( SrcVar.vt != VT_EMPTY &&
                                         !"unexpected variant type!" );
                        }
                    }
                }
                else if ( SrcVar.vt == vtDst )
                {
                    Win4Assert( vtDst & DBTYPE_VECTOR );
                    Win4Assert( vtDst != VT_VARIANT );
                    fDoCopy = FALSE;
                    * (CAL *) pbDstData = SrcVar.cal;
                    cbDstLength = 0;    // vectors defined to be 0 len
                }
                else
                    fFreeDeferredSrc = TRUE;
            }
            else
                fDoCopy = FALSE;
        }
        else
        {
            RtlCopyMemory( &SrcVar, pbSrcData, sizeof SrcVar );
        }
    }
    else
        SrcVar.Init( vtSrc, pbSrcData, rSrcColumn.GetValueSize() );

    if ( fDoCopy )
    {
        DstStatus = SrcVar.OLEDBConvert( pbDstData,
                                         rDstBinding.GetMaxLen(),
                                         vtDst,
                                         _Pool,
                                         cbDstLength,
                                         xDataConvert,
                                         _fExtendedTypes,
                                         ((DBBINDING&)rDstBinding).bPrecision,
                                         ((DBBINDING&)rDstBinding).bScale );

        // Free the deferred value that was in a format that couldn't be
        // used directly (and had to be converted).

        if ( fFreeDeferredSrc )
        {
            PropVariantClear( &SrcVar );
        }
    }

    // If accessor is byref and we had to allocate memory to return a
    // deferred value, we have to tell the row buffer to let go of
    // the memory when the HROW is released.

    if ( ( DBSTATUS_S_OK == DstStatus ) &&
         ( rSrcColumn.IsDeferred( pbSrc ) ) &&
         ( rDstBinding.Binding().dwMemOwner == DBMEMOWNER_PROVIDEROWNED ) &&
         ( ( vtDst & (DBTYPE_BYREF | DBTYPE_ARRAY | DBTYPE_VECTOR) ) ||
           ( vtDst == VT_LPWSTR )  ||
           ( vtDst == VT_LPSTR )  ||
           ( vtDst == DBTYPE_BSTR ) ) )
    {
        PROPVARIANT var;
        var.vt = vtDst;

        if ( ( DBTYPE_VARIANT | DBTYPE_BYREF ) == vtDst ||
             ( DBTYPE_PROPVARIANT | DBTYPE_BYREF ) == vtDst )
            var = ** (PROPVARIANT **) pbDstData;
        else if ( vtDst & DBTYPE_VECTOR )
            RtlCopyMemory( &var.calpwstr,
                           pbDstData,
                           sizeof DBVECTOR );
        else
            var.pwszVal = * (WCHAR **) pbDstData;

        tbDebugOut(( DEB_ITRACE, "save away type %x, val %x\n",
                     (int) vtDst,
                     ( vtDst & DBTYPE_VECTOR ) ?
                           (WCHAR *) var.calpwstr.pElems :
                           var.pwszVal ) );

        CDeferredValue value( hrow, var );
        rRowBuffer.AddDeferredValue( value );
        rRowBuffer.SetByrefData( pbSrc );
    }

    return DstStatus;
} //_ComplexCopy

//+-------------------------------------------------------------------------
//
//  Member:     CRowDataAccessor::_ByRefCopy, private
//
//  Synopsis:   Copy a ByRef value.  This hands out a live pointer into the
//              row buffer's storage that the client can read from but not
//              write to or try to free.
//
//  Arguments:  [rDstBinding]   -- binding for the destination
//              [pbSrc]         -- source row buffer
//              [rSrcColumn]    -- source column description
//              [vtSrc]         -- type of the source
//              [rSrcVar]       -- variant to fill as a copy of the source
//                                 data in variant form if the source data
//                                 is not already a variant (and thus has
//                                 a length column in the row buffer)
//              [pbSrcData]     -- pointer to source data
//              [vtDst]         -- type of the destination value
//              [pbDstData]     -- where to write the value
//
//  Returns:    DBSTATUS  -- status of the column copy
//
//  Notes:      Coercions are not supported.  This makes sense -- if you
//              want slow coercions you shouldn't be binding byref in the
//              first place.
//
//  History:    25 Jul 95       dlee   created
//
//--------------------------------------------------------------------------

DBSTATUS CRowDataAccessor::_ByRefCopy(
    CDataBinding &  rDstBinding,
    BYTE *          pbSrc,
    CTableColumn &  rSrcColumn,
    VARTYPE         vtSrc,
    CTableVariant & rSrcVar,
    BYTE *          pbSrcData,
    VARTYPE         vtDst,
    BYTE *          pbDstData )
{
    DBSTATUS DstStatus = DBSTATUS_S_OK;
    RtlZeroMemory( &rSrcVar, sizeof CTableVariant );

    if ( VT_EMPTY == vtSrc )
        return DBSTATUS_S_ISNULL;

    if ( rDstBinding.Binding().wType & DBTYPE_VECTOR )
    {
        if ( DBTYPE_VARIANT == vtSrc )
        {
            CTableVariant & varnt = * ( (CTableVariant *) pbSrcData );

            tbDebugOut(( DEB_ACCESSOR, "byref copy, vtDst 0x%x varnt.vt 0x%x\n",
                         vtDst, varnt.vt ));

            if ( isEquivalentType( vtDst, varnt.vt ) )
                RtlCopyMemory( pbDstData, &(varnt.caub), sizeof DBVECTOR );
            else
                DstStatus = NullOrCantConvert( varnt.vt );
        }
        else if ( isEquivalentType( vtDst, vtSrc ) )
        {
            RtlCopyMemory( pbDstData, pbSrcData, sizeof DBVECTOR );

            // Make a variant in case length is bound for this column

            rSrcVar.vt = vtSrc;
            RtlCopyMemory( &(rSrcVar.caub), pbSrcData, sizeof DBVECTOR );
        }
        else
        {
            DstStatus = DBSTATUS_E_CANTCONVERTVALUE;
        }
    }
    else if ( rDstBinding.Binding().wType & DBTYPE_ARRAY )
    {
        if ( DBTYPE_VARIANT == vtSrc )
        {
            CTableVariant & varnt = * ( (CTableVariant *) pbSrcData );

            tbDebugOut(( DEB_ACCESSOR, "byref copy, vtDst 0x%x varnt.vt 0x%x\n",
                         vtDst, varnt.vt ));

            if ( isEquivalentType( vtDst, varnt.vt ) )
                RtlCopyMemory( pbDstData, &(varnt.parray), sizeof (SAFEARRAY *) );
            else
                DstStatus = NullOrCantConvert( varnt.vt );
        }
        else if ( isEquivalentType( vtDst, vtSrc ) )
        {
            RtlCopyMemory( pbDstData, pbSrcData, sizeof (SAFEARRAY *) );

            // Make a variant in case length is bound for this column

            rSrcVar.vt = vtSrc;
            RtlCopyMemory( &(rSrcVar.parray), pbSrcData, sizeof (SAFEARRAY *) );
        }
        else
        {
            DstStatus = DBSTATUS_E_CANTCONVERTVALUE;
        }
    }
    else
    {
        Win4Assert( (rDstBinding.Binding().wType & DBTYPE_BYREF) ||
                    (rDstBinding.Binding().wType == DBTYPE_BSTR) );

        if ( DBTYPE_VARIANT == vtSrc )
        {
            CTableVariant & varnt = * ( (CTableVariant *) pbSrcData );

            tbDebugOut(( DEB_ACCESSOR, "byref non-vector copy, vtDst 0x%x, varnt.vt 0x%x\n",
                         vtDst, varnt.vt ));

            if ((rDstBinding.Binding().wType & ~DBTYPE_BYREF) == DBTYPE_VARIANT)
            {
                // Just return a pointer to the stored variant
                * (VARIANT **) pbDstData = (VARIANT *) pbSrcData;
            }
            else if ( ( varnt.VariantPointerInFirstWord() ) &&
                      ( isEquivalentType( vtDst, varnt.vt ) ) )
            {
                // Grab the pointer value out of the variant; any ptr will do

                * ( (LPWSTR *) pbDstData ) = varnt.pwszVal;

                // Make a variant in case length is bound for this column

                rSrcVar.vt = varnt.vt;
                rSrcVar.pwszVal = varnt.pwszVal;
            }
            else
            {
                * ( (LPWSTR *) pbDstData ) = 0;
                DstStatus = NullOrCantConvert( varnt.vt );
            }
        }
        else
        {
            // The constructor verified everything is fine -- copy the ptr

            * (void **) pbDstData = * (void **) pbSrcData;

            // Make a variant in case length is bound for this column

            rSrcVar.vt = vtSrc;
            rSrcVar.pwszVal =  * (WCHAR **) pbSrcData;
        }
    }

    if ( rSrcColumn.IsNull( pbSrc ) )
    {
        tbDebugOut(( DEB_ITRACE, "byref column status IsNull\n" ));
        DstStatus = DBSTATUS_S_ISNULL;
    }
    return DstStatus;
} //_ByRefCopy

//+-------------------------------------------------------------------------
//
//  Member:     CRowDataAccessor::_CopyColumn, private
//
//  Synopsis:   Return a set of row data to the caller
//
//  Arguments:  [pbDst]         -- destination row buffer
//              [rDstBinding]   -- binding for the destination
//              [pbSrc]         -- source row buffer
//              [rSrcColumn]    -- source column description
//              [rSrcSet]       -- set of source columns
//              [iColumn]       -- column being copied
//              [rRowBuffer]    -- row buffer
//              [hrow]          -- hrow being retrieved
//              [xDataConvert]  -- smart pointer to IDataConvert interface.
//                                 this is to be passed along and used finally
//                                 in COLEDBVariant::CopyOrCoerce
//
//  Returns:    DBSTATUS  -- status of the column copy
//
//  History:    21 Nov 1994       dlee        created
//              09 Jan 1998       vikasman    added xDataConvert parameter
//
//--------------------------------------------------------------------------

DBSTATUS CRowDataAccessor::_CopyColumn(
    BYTE *                            pbDst,
    CDataBinding &                    rDstBinding,
    BYTE *                            pbSrc,
    CTableColumn &                    rSrcColumn,
    CTableColumnSet &                 rSrcSet,
    DBORDINAL                         iColumn,
    CRowBuffer &                      rRowBuffer,
    HROW                              hrow,
    XInterface<IDataConvert>&         xDataConvert)
{
    DBSTATUS DstStatus = DBSTATUS_S_OK;
    DBLENGTH cbDstLength = 0;
    CTableVariant varLen;
    BOOL fVariantValid = FALSE;
    BOOL fLengthValid = FALSE;
    BOOL fStatusValid = FALSE;

    // pull out the data types for clarity below

    VARTYPE vtDst = (VARTYPE) rDstBinding.Binding().wType;
    VARTYPE vtSrc = rSrcColumn.GetStoredType();

    if (DBPART_VALUE & rDstBinding.Binding().dwPart)
    {
        // the row buffer promises NOT to set the byref bit for these.
        // we'll break elsewhere if this is not true.

        Win4Assert(vtSrc != ( VT_LPWSTR | VT_BYREF ) );
        Win4Assert(vtSrc != ( VT_LPSTR  | VT_BYREF ) );

        BYTE *pbSrcData = pbSrc + rSrcColumn.GetValueOffset();
        BYTE *pbDstData = pbDst + rDstBinding.Binding().obValue;

        tbDebugOut(( DEB_ACCESSOR, "copying column %d, vtsrc 0x%x, vtdst 0x%x\n",
                     iColumn, vtSrc, vtDst ));

        // vpath can be null if not an IIS root

        if ( ( iColumn == _iVpathBinding ) &&
             ( !rSrcColumn.IsNull( pbSrc ) ) )
        {
            Win4Assert(VT_VARIANT == vtSrc ||
                       VT_LPWSTR == vtSrc ||
                       VT_BSTR == vtSrc);
            LPWSTR pwszPath = (LPWSTR) pbSrcData;
            if (VT_VARIANT == vtSrc)
                pwszPath = ((PROPVARIANT *)pbSrcData)->pwszVal;
            if (pwszPath)
                ConvertBackslashToSlash(pwszPath);
        }

        if ( DBTYPE_IUNKNOWN == vtDst )
        {
            DstStatus = _BindToObject( pbDstData,
                                       rDstBinding,
                                       pbSrc,
                                       rSrcColumn,
                                       rSrcSet );
        }
        else
        {
            // Transfer a data value

            USHORT cbData, cbAlignment, rgfFlags;
            CTableVariant::VartypeInfo(vtSrc, cbData, cbAlignment, rgfFlags);

            if ( rSrcColumn.IsNull( pbSrc ) && (vtDst & DBTYPE_BYREF) == 0 )
            {
                tbDebugOut(( DEB_ITRACE,
                             "column %d status IsNull -> VT_EMPTY\n",
                             iColumn ));

                RtlZeroMemory( pbDstData, rDstBinding.GetMaxLen() );
                DstStatus = DBSTATUS_S_ISNULL;
            }
            else if ( ( vtDst == vtSrc )                          &&
                      ( vtDst != VT_VARIANT )                     &&
                      ( 0 == (rgfFlags & CTableVariant::ByRef ) ) &&
                      ( 0 != (rgfFlags & CTableVariant::StoreDirect ) ) )
            {
                // Data column equivalent and not indirect, so just copy it.
                // Storage props (except filename/path) will do this.

                cbDstLength = rSrcColumn.GetValueSize();
                fLengthValid = TRUE;
                RtlCopyMemory( pbDstData, pbSrcData, cbDstLength );
            }
            else if ( ( rDstBinding.Binding().dwMemOwner ==
                            DBMEMOWNER_PROVIDEROWNED ) &&
                      ( ! rSrcColumn.IsDeferred( pbSrc ) )  &&
                      ( ( vtDst & DBTYPE_BYREF ) ||
                        ( vtDst & DBTYPE_VECTOR ) ||
                        ( vtDst & VT_ARRAY ) ||
                        ( vtDst == DBTYPE_BSTR ) ) )
            {
                // Efficiently bound filename/path, etc. will do this

                DstStatus = _ByRefCopy( rDstBinding,
                                        pbSrc,
                                        rSrcColumn,
                                        vtSrc,
                                        varLen,
                                        pbSrcData,
                                        vtDst,
                                        pbDstData );

                if ( DBSTATUS_S_OK == DstStatus )
                    rRowBuffer.SetByrefData( pbSrc );
                fVariantValid = TRUE;
            }
            else if (vtDst == DBTYPE_BYTES &&
                     rDstBinding.GetMaxLen() > 1 &&
                     CTableVariant::TableIsStoredInline( rgfFlags, vtSrc ))
            {
                // Special case for small fixed-length fields

                DBLENGTH cbCopy = rSrcColumn.GetValueSize();
                if (rDstBinding.GetMaxLen() < cbCopy)
                {
                    cbCopy = rDstBinding.GetMaxLen();
                    DstStatus = DBSTATUS_S_TRUNCATED;
                }

                RtlCopyMemory(pbDstData, pbSrcData, cbCopy);
                cbDstLength = cbCopy;
                fLengthValid = TRUE;
            }
            else if (vtDst == DBTYPE_BYTES &&
                     rDstBinding.GetMaxLen() > 1 &&
                     vtSrc == VT_VARIANT)
            {
                // Special case for small fixed-length fields from a variant
                CTableVariant * pVarnt = (CTableVariant *)pbSrcData;
                pVarnt->VartypeInfo(pVarnt->vt, cbData, cbAlignment, rgfFlags);

                if (rgfFlags & CTableVariant::SimpleType)
                {
                    DBLENGTH cbCopy = cbData;
                    if (rDstBinding.GetMaxLen() < cbCopy)
                    {
                        cbCopy = rDstBinding.GetMaxLen();
                        DstStatus = DBSTATUS_S_TRUNCATED;
                    }
                    RtlCopyMemory(pbDstData, &(pVarnt->lVal), cbCopy);
                    cbDstLength = cbCopy;
                    fLengthValid = TRUE;
                }
                else
                {
                    DstStatus = DBSTATUS_E_CANTCONVERTVALUE;
                }
            }
            else
            {
                // Copying to/from a variant or a coercion is required.

                DstStatus = _ComplexCopy( rDstBinding,
                                          pbSrc,
                                          rSrcColumn,
                                          iColumn,
                                          vtSrc,
                                          cbDstLength,
                                          pbSrcData,
                                          vtDst,
                                          pbDstData,
                                          rSrcSet,
                                          rRowBuffer,
                                          hrow,
                                          xDataConvert);

                fLengthValid = TRUE;
            }
        }

        // indicate status has been validated
        fStatusValid = TRUE;

        // bump the chapter reference count if we successfully transferred
        // a chapter value
        if ( DBSTATUS_S_OK == DstStatus && rDstBinding.IsChapter() )
            rRowBuffer.ReferenceChapter( pbSrc );
    }

    // fill-in the length if the client asked for it

    if (DBPART_LENGTH & rDstBinding.Binding().dwPart)
    {
        DBLENGTH *pcbDst = (DBLENGTH *) (pbDst + rDstBinding.Binding().obLength);

        if ( ( DBSTATUS_S_ISNULL == DstStatus ) ||
             ( DBSTATUS_E_CANTCONVERTVALUE == DstStatus ) ||
             ( 0 != ( vtDst & DBTYPE_VECTOR ) ) )  // ole-db spec says so
        {
            *pcbDst = 0;
        }
        else if ( fLengthValid )
        {
            *pcbDst = cbDstLength;
        }
        else if (! isVariableLength( vtDst ) )
        {
            if ( vtDst & VT_BYREF )
            {
                USHORT cbWidth, cbAlign, fFlags;
                CTableVariant::VartypeInfo( vtDst & ~VT_BYREF, cbWidth, cbAlign, fFlags );

                *pcbDst = cbWidth;
            }
            else
            {
                *pcbDst = rDstBinding.GetMaxLen();
            }
        }
        else
        {
            DBLENGTH cbLen = 0;

            if (fVariantValid)
            {
                Win4Assert ( varLen.vt != VT_EMPTY );
                cbLen = varLen.VarDataSize();
            }
            else
            {
                //
                // DBBINDING doesn't want DBPART_VALUE
                //

                SCODE sc = S_OK;
                ULONG cbDstBufNeeded = 0;
                DBTYPE dbtypeSrc;
                COLEDBVariant SrcVar;

                BYTE *pbSrcData = pbSrc + rSrcColumn.GetValueOffset();
                RtlCopyMemory( &SrcVar, pbSrcData, sizeof SrcVar );
                
                SrcVar.GetDstLength( xDataConvert, 
                                     rDstBinding.Binding().wType,
                                     cbLen );
            }

            // WSTR and STR lengths shouldn't include the terminating NULL
            if ( (vtDst & VT_TYPEMASK) == DBTYPE_WSTR ||
                 vtDst == VT_LPWSTR )
                cbLen -= sizeof (WCHAR);
            else if ( (vtDst & VT_TYPEMASK) == DBTYPE_STR ||
                 vtDst == VT_LPSTR )
                cbLen -= sizeof (char);
            else if (vtDst == DBTYPE_BSTR)
                cbLen = sizeof (BSTR);

            *pcbDst = cbLen;
        }
    }

    if (! fStatusValid)
    {
        if ( rSrcColumn.IsStatusStored() &&
             rSrcColumn.GetStatus( pbSrc ) == CTableColumn::StoreStatusNull )
            DstStatus = DBSTATUS_S_ISNULL;
    }

    if (DBPART_STATUS & rDstBinding.Binding().dwPart)
    {
        * (DBSTATUS *) (pbDst + rDstBinding.Binding().obStatus) = DstStatus;
    }

    return DstStatus;
} //_CopyColumn

//+-------------------------------------------------------------------------
//
//  Member:     CRowDataAccessor::GetData, public
//
//  Synopsis:   Copies data into the buffer as specified when the accessor
//              was created
//
//  Arguments:  [hRow]          -- row whose data is copied
//              [pData]         -- where data is written
//              [rBufferSet]    -- object useful for transforming an HROW
//                                 into a buffer and a column layout
//              [rQuery]        -- query to use for this getdata
//              [colInfo]       -- info about the columns
//              [xDataConvert]  -- smart pointer to IDataConvert interface.
//                                 this is to be passed along and used finally
//                                 in COLEDBVariant::CopyOrCoerce
//
//  History:    21 Nov 1994       dlee        created
//              09 Jan 1998       vikasman    added xDataConvert parameter
//
//--------------------------------------------------------------------------

void CRowDataAccessor::GetData(
    HROW            hRow,
    void *          pData,
    CRowBufferSet & rBufferSet,
    PQuery &        rQuery,
    CColumnsInfo &  colInfo,
    XInterface<IDataConvert>&         xDataConvert)
{

    if ( _idColInfo != colInfo.GetId() )
    {
        // We have a different columnsInfo with which we must validate.

        Validate( colInfo, 0 );
    }

    _pQuery = &rQuery;  // query to be used for this data retrieval

    // first find the source data buffer and its layout

    CLock lock( rBufferSet.GetBufferLock() );

    CTableColumnSet *pRowBufColSet;
    BYTE *pbSrc;

    CRowBuffer &rRowBuffer = rBufferSet.Lookup( hRow,
                                                &pRowBufColSet,
                                                (void **) &pbSrc );

    // now copy the data from the internal buffer to the user's buffer

    ULONG cCopied = 0;

    // We need to determine whether all the conversions failed or
    // all of them succeeded or some failed/some passed
    ULONG cSuccess = 0;

    TRY
    {
        for ( cCopied = 0; cCopied < _cBindings; cCopied++ )
        {
            CTableColumn *pSrcCol = rRowBuffer.Find( (ULONG)
                                      _aBindings[cCopied].GetDataColumn() );

            if ( 0 == pSrcCol )
            {
                // Somehow, the row buffer doesn't have a column that's in
                // the accessor.  This is an internal error.

                Win4Assert(!"CRowDataAccessor::GetData couldn't find column binding");
            }

            DBSTATUS DstStatus = _CopyColumn( (BYTE *) pData,
                                              _aBindings[cCopied],
                                              pbSrc,
                                              *pSrcCol,
                                              *pRowBufColSet,
                                              cCopied,
                                              rRowBuffer,
                                              hRow,
                                              xDataConvert);

            tbDebugOut(( DEB_ITRACE, "GetData column %d, status 0x%x\n",
                         cCopied, DstStatus ));

            // see if we have a coercion error.  any other column status will
            // not result in a special return code from GetData -- it's just
            // reflected in the column status field (if the user asks for it)

            if ( DBStatusOK( DstStatus ) )
            {
                // Success
                cSuccess++;
            }
        }
    }
    CATCH( CException, e )
    {
        // fatal error -- free the data allocated so far for return to the
        // client, then rethrow the error condition

        for ( ULONG i = 0; i < cCopied; i++ )
            if ( _aBindings[i].Binding().dwMemOwner != DBMEMOWNER_PROVIDEROWNED )
                CTableVariant::Free( (BYTE *) pData + _aBindings[i].Binding().obValue,
                                     (VARTYPE) _aBindings[i].Binding().wType,
                                     _Pool );

        RETHROW();
    }
    END_CATCH;

    if ( cSuccess == _cBindings )   // takes care of _cBindings == 0 case
    {
        // AllSuccess
        ; // do nothing
    }
    else if ( cSuccess == 0 )
    {
        // AllFail
        QUIETTHROW( CException( DB_E_ERRORSOCCURRED ) );
    }
    else
    {
        // SomeSuccess/SomeFail
        QUIETTHROW( CException( DB_S_ERRORSOCCURRED ) );
    }

} //GetData

//+-------------------------------------------------------------------------
//
//  Member:     CRowDataAccessorByRef::GetData, public
//
//  Synopsis:   Copies data into the buffer as specified when the accessor
//              was created.  For provider-owned memory with variant byref
//              binding.
//
//  Arguments:  [hRow]          -- row whose data is copied
//              [pData]         -- where data is written
//              [rBufferSet]    -- object useful for transforming an HROW
//                                 into a buffer and a column layout
//              [rQuery]        -- query to use for this getdata
//              [colInfo]       -- info about the columns
//              [xDataConvert]  -- smart pointer to IDataConvert interface.
//                                 this is to be passed along and used finally
//                                 in COLEDBVariant::CopyOrCoerce
//
//  History:    09 Apr 1996       dlee        created
//              09 Jan 1998       vikasman    added xDataConvert parameter
//
//--------------------------------------------------------------------------

void CRowDataAccessorByRef::GetData(
    HROW                       hRow,
    void *                     pData,
    CRowBufferSet &            rBufferSet,
    PQuery &                   rQuery,
    CColumnsInfo &             colInfo,
    XInterface<IDataConvert> & xDataConvert)
{
    // we validated the column info on construction

    Win4Assert ( _idColInfo == colInfo.GetId() );

    // first find the source data buffer and its layout

    CLock lock( rBufferSet.GetBufferLock() );

    CTableColumnSet *pRowBufColSet;
    BYTE *pbSrc;

    CRowBuffer &rRowBuffer = rBufferSet.Lookup( hRow,
                                                &pRowBufColSet,
                                                (void **) &pbSrc );

    // now copy the data from the internal buffer to the user's buffer

    for ( unsigned iCol = 0; iCol < _cBindings; iCol++ )
    {
        CDataBinding & dstDataBinding = _aBindings[ iCol ];
        CTableColumn & rSrcCol = * rRowBuffer.Find( (ULONG)
                                   dstDataBinding.GetDataColumn() );

        Win4Assert( 0 != &rSrcCol &&
                    "CRowDataAccessorByRef::GetData couldn't find column binding");

        BYTE *pbSrcData = pbSrc + rSrcCol.GetValueOffset();
        DBBINDING & DstBinding = dstDataBinding.Binding();

        Win4Assert( (DBTYPE_VARIANT|DBTYPE_BYREF) == DstBinding.wType ||
                    (DBTYPE_PROPVARIANT|DBTYPE_BYREF) == DstBinding.wType );
        Win4Assert( DBPART_VALUE == DstBinding.dwPart );
        Win4Assert( VT_VARIANT == rSrcCol.GetStoredType() );

        PROPVARIANT **ppDstVar = (PROPVARIANT **) ( ( (BYTE*) pData ) +
                                                    DstBinding.obValue );

        if ( !rSrcCol.IsDeferred( pbSrc ) )
        {
            // Convert '\' to '/' if this is the vpath.
            // Vpath can be null if the file is not in an indexed IIS vroot.

            if ( ( iCol == _iVpathBinding ) &&
                 ( !rSrcCol.IsNull( pbSrc ) ) )
            {
                Win4Assert( VT_LPWSTR == ((PROPVARIANT *)pbSrcData)->vt ||
                            VT_BSTR == ((PROPVARIANT *)pbSrcData)->vt );

                LPWSTR pwszPath = ((PROPVARIANT *)pbSrcData)->pwszVal;
                if (pwszPath)
                    ConvertBackslashToSlash(pwszPath);
            }

            *ppDstVar = (PROPVARIANT *) pbSrcData;

            #if CIDBG==1
                if ( rSrcCol.IsNull( pbSrc ) )
                {
                    Win4Assert( VT_EMPTY == (*ppDstVar)->vt );
                }
            #endif // CIDBG==1
        }
        else
        {
            // deferred copies can go through this slow code path

            _pQuery = &rQuery;  // query to be used for this data retrieval

            DBLENGTH cbDstLen;

            _ComplexCopy( _aBindings[iCol],
                          pbSrc,
                          rSrcCol,
                          iCol,
                          rSrcCol.GetStoredType(),
                          cbDstLen,
                          pbSrcData,
                          DBTYPE_PROPVARIANT | DBTYPE_BYREF,
                          (BYTE *) ppDstVar,
                          *pRowBufColSet,
                          rRowBuffer,
                          hRow,
                          xDataConvert);
        }

        // bump the chapter reference count if we transferred
        // a chapter value
        if ( dstDataBinding.IsChapter() )
            rRowBuffer.ReferenceChapter( pbSrc );
    }
    rRowBuffer.SetByrefData( pbSrc );
} //GetData

//+-------------------------------------------------------------------------
//
//  Function:   CreateAnAccessor
//
//  Synopsis:   Creates an accessor object deriving from CAccessor that is
//              best-suited to handling the binding flags.
//
//  Arguments:  [dwAccessorFlags] -- read/write access requested
//              [cBindings]       -- # of bindings in rgBindings
//              [rgBindings]      -- array of bindings
//              [rgBindStatus]    -- array of binding statuses
//              [fExtTypes]       -- TRUE if extended variants are supported
//              [pColumns]        -- column info, may be 0
//
//  History:    9 Apr 96       dlee   created
//
//--------------------------------------------------------------------------

CAccessor * CreateAnAccessor(
    DBACCESSORFLAGS   dwAccessorFlags,
    DBCOUNTITEM       cBindings,
    const DBBINDING * rgBindings,
    DBBINDSTATUS *    rgBindStatus,
    BOOL              fExtTypes,
    void *            pCreator,
    CColumnsInfo *    pColumns )
{
    BOOL fByRefCandidate = TRUE;

    // CRowDataAccessorByRef candidates must:
    //    - have a non-0 pColumns
    //    - allow extended variant types (PROPVARIANT)
    //    - only bind to VALUE, not STATUS or LENGTH
    //    - only bind as DBTYPE_PROPVARIANT or DBTYPE_VARIANT byref
    //    - only bind with DBMEMOWNER_PROVIDEROWNED
    //
    // Accessors that don't meet these criteria go through the slower
    // CRowDataAccessor.

    if ( ( 0 == pColumns ) ||
         ( dwAccessorFlags != DBACCESSOR_ROWDATA ) ||
         ! fExtTypes )
        fByRefCandidate = FALSE;

    for ( DBORDINAL iBinding = 0;
          fByRefCandidate && iBinding < cBindings;
          iBinding++ )
    {
        DBBINDING const & b = rgBindings[ iBinding ];

        if ( b.dwPart != DBPART_VALUE ||
             b.dwMemOwner != DBMEMOWNER_PROVIDEROWNED ||
             (( b.wType != (DBTYPE_PROPVARIANT|DBTYPE_BYREF) ) &&
                (! fExtTypes ||
                   b.wType != (DBTYPE_VARIANT|DBTYPE_BYREF) ) ) )
            fByRefCandidate = FALSE;
    }

    tbDebugOut(( DEB_ITRACE, "accessor can be byref: %d\n", fByRefCandidate ));

    if ( fByRefCandidate )
        return new CRowDataAccessorByRef( dwAccessorFlags,
                                          cBindings,
                                          rgBindings,
                                          rgBindStatus,
                                          TRUE,
                                          pCreator,
                                          pColumns );

    return new CRowDataAccessor( dwAccessorFlags,
                                 cBindings,
                                 rgBindings,
                                 rgBindStatus,
                                 fExtTypes,
                                 pCreator,
                                 pColumns );
} //CreateAnAccessor
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\colmastr.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       colmastr.cxx
//
//  Contents:   Classes dealing with the table master column description.
//
//  Classes:    CColumnMasterDesc - A master column description
//              CColumnMasterArray - A simple array of master columns
//              CColumnMasterSet - An managed set of master columns
//
//  Functions:
//
//  History:    28 Feb 1994     AlanW    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <tablecol.hxx>
#include <coldesc.hxx>

#include "tabledbg.hxx"
#include "colcompr.hxx"
#include "propdata.hxx"

//
//  Generate the implementation of the master set base class
//
IMPL_DYNARRAY( CColumnMasterArray, CColumnMasterDesc )


//+-------------------------------------------------------------------------
//
//  Member:     CColumnMasterSet::CColumnMasterSet, public
//
//  Synopsis:   Constructor for a master column set.
//
//  Arguments:  [pcol] -- A description of the initial output column set
//
//  Notes:
//
//--------------------------------------------------------------------------

CColumnMasterSet::CColumnMasterSet( const CColumnSet * const pcol )
        : _iNextFree( 0 ),
          _aMasterCol( pcol->Size() ),
          _fHasUserProp( FALSE )
{
    for (unsigned iCol = 0; iCol< pcol->Size(); iCol++)
    {
        PROPID pid = pcol->Get(iCol);

        if ( IsUserDefinedPid( pid ) )
            _fHasUserProp = TRUE;

        CColumnMasterDesc MasterCol( pid );

        Add( MasterCol );
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CColumnMasterSet::Find, private
//
//  Synopsis:   Find a master column description in a master column set.
//
//  Arguments:  [propid] -- The property ID of the column to be located
//              [riPos] -- If found, returns the position of the column
//                      description in the dynamic array.
//
//  Returns:    CColumnMasterDesc* - a pointer to the master column
//                      description if found, otherwise NULL
//
//  Notes:
//
//--------------------------------------------------------------------------

inline CColumnMasterDesc *
CColumnMasterSet::Find( const PROPID propid, unsigned& riCol )
{
    Win4Assert(_iNextFree <= Size());

    for (riCol = 0; riCol < _iNextFree; riCol++) {
        if (_aMasterCol.Get(riCol)->PropId  == propid)
            return _aMasterCol.Get(riCol);
    }
    return NULL;
}


//+-------------------------------------------------------------------------
//
//  Member:     CColumnMasterSet::Find, public
//
//  Synopsis:   Find a master column description in a master column set.
//
//  Arguments:  [propid] -- The property ID of the column to be located
//
//  Returns:    CColumnMasterDesc* - a pointer to the master column
//                      description if found, otherwise NULL
//
//  Notes:
//
//--------------------------------------------------------------------------

CColumnMasterDesc*
CColumnMasterSet::Find( const PROPID propid )
{
    unsigned iCol;

    return Find(propid, iCol);
}


//+-------------------------------------------------------------------------
//
//  Member:     CColumnMasterSet::Add, public
//
//  Synopsis:   Add a master column description to a master column set.
//
//  Arguments:  [xpNewCol] -- A reference to the column description to be
//                      added.
//
//  Returns:    CColumnMasterDesc* - a pointer to the master column
//                      description added
//
//  Notes:      If a property description with the same property ID
//              is already in the column set, the new column is not
//              added, but the previous column is used.
//
//--------------------------------------------------------------------------

CColumnMasterDesc*
CColumnMasterSet::Add( XPtr<CColumnMasterDesc> & xpNewCol )
{
    CColumnMasterDesc* pCol = Find(xpNewCol->PropId);

    if ( 0 != pCol )
        return pCol;

    //
    //  Column was not found in the existing set, add it.
    //
    unsigned iCol = _iNextFree++;
    if (iCol >= _aMasterCol.Size())
        _aMasterCol.Add(0, iCol);       // force the array to grow

    _aMasterCol.Add(xpNewCol.Acquire(), iCol);
    return _aMasterCol.Get(iCol);
}


CColumnMasterDesc*
CColumnMasterSet::Add( CColumnMasterDesc const & rColDesc )
{
    CColumnMasterDesc* pCol = Find(rColDesc.PropId);

    if ( 0 != pCol )
        return pCol;

    //
    // Column was not found in the existing set, add it.
    //
    // PERFFIX: to avoid the compression restriction, use the method above.

    Win4Assert(! rColDesc.IsCompressedCol() );

    CColumnMasterDesc* pNewCol = new CColumnMasterDesc;

    XPtr<CColumnMasterDesc> xCol( pNewCol );

    *pNewCol = rColDesc;

    unsigned iCol = _iNextFree++;
    _aMasterCol.Add(pNewCol, iCol);

    xCol.Acquire();

    return _aMasterCol.Get(iCol);
}


//+-------------------------------------------------------------------------
//
//  Member:     CColumnMasterDesc::CColumnMasterDesc, public
//
//  Synopsis:   Constructor for a master column description.
//
//  Arguments:  [PropertyId] -- the PROPID for the column
//              [DataTyp] -- data type of column
//
//  Notes:
//
//--------------------------------------------------------------------------

CColumnMasterDesc::CColumnMasterDesc( PROPID PropertyId,
                                      VARTYPE DataTyp)
        : PropId( PropertyId ),
          DataType( DataTyp ),
          _cbData( 0 ),
          _fComputedProperty( FALSE ),
          _PredominantType( VT_EMPTY ),
          _fUniformType( TRUE ),
          _fNotVariantType (FALSE),
          _pCompression( NULL ),
          _CompressMasterID( 0 )
{
    if ( DataType == VT_EMPTY )
    {
        DataType =  PropIdToType( PropId );
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CColumnMasterDesc::CColumnMasterDesc, public
//
//  Synopsis:   Constructor for a master column description from a
//              sort key description.
//
//  Arguments:  [rSortKey] -- A description of a sort key
//
//  Notes:
//
//--------------------------------------------------------------------------

CColumnMasterDesc::CColumnMasterDesc( SSortKey& rSortKey )
        : PropId( rSortKey.pidColumn ),
          DataType( PropIdToType(rSortKey.pidColumn) ),
          _cbData( 0 ),
          _fComputedProperty( FALSE ),
          _PredominantType( VT_EMPTY ),
          _fUniformType( TRUE ),
          _fNotVariantType (FALSE),
          _pCompression( NULL ),
          _CompressMasterID( 0 )
{
}


//+-------------------------------------------------------------------------
//
//  Member:     CColumnMasterDesc::~CColumnMasterDesc, public
//
//  Synopsis:   Destructor for a master column description.
//
//  Notes:
//
//--------------------------------------------------------------------------

CColumnMasterDesc::~CColumnMasterDesc( )
{
    if (_pCompression && _CompressMasterID == 0)
          delete _pCompression;
}


//+-------------------------------------------------------------------------
//
//  Member:     CColumnMasterDesc::SetCompression, public
//
//  Synopsis:   Install a global compression for a master column.
//
//  Arguments:  [pCompr] -- A pointer to the compressor for the
//                      column
//              [SharedID] -- If non-zero, the master column ID
//                      for a shared compression.
//
//  Notes:
//
//--------------------------------------------------------------------------

VOID
CColumnMasterDesc::SetCompression(
    CCompressedCol* pCompr,
    PROPID SharedID
) {
    if (_pCompression && _CompressMasterID == 0)
          delete _pCompression;

    _pCompression = pCompr;
    _CompressMasterID = SharedID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\query.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       query.cxx
//
//  Contents:   Class encapsulating all the context for a running
//              query, including the query execution context, the
//              cached query results, and all cursors over the
//              results.
//              Dispatches requests to the appropriate subobject.
//
//  Classes:    CAsyncQuery
//              CGetRowsParams
//
//  History:    31 May 94       AlanW   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <query.hxx>
#include <srequest.hxx>
#include <rowseek.hxx>
#include <tbrowkey.hxx>
#include <oleprop.hxx>

#include "tabledbg.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CGetRowsParams::GetRowBuffer, public inline
//
//  Synopsis:   Return a pointer to the row buffer.  If this is the first
//              reference, get it from the fixed allocator.
//
//  Arguments:  - none -
//
//  Returns:    PBYTE - a pointer to the row buffer.
//
//  Notes:      We don't put this in query.hxx since we don't want to
//              have to refer to PFixedVarAllocator there.
//
//--------------------------------------------------------------------------

PBYTE   CGetRowsParams::GetRowBuffer( void )
{
    if (0 == _pData)
        _pData = _rAllocator.AllocFixed();
    return (PBYTE) _pData;
}

PBYTE   CGetRowsParams::GetBuffer( ) const
                    { return _rAllocator.BufferAddr(); }


//+---------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::CAsyncQuery, public
//
//  Synopsis:   Creates a locally accessible Query
//
//  Arguments:  [qopt]         - Query optimizer
//              [col]          - Initial set of columns to return
//              [sort]         - Initial sort
//              [categ]        - Categorization specification
//              [cCursors]     - # of cursors to create
//              [aCursors]     - array of cursors returned
//              [pidremap]     - prop ID mapping
//              [fEnableNotification] - if TRUE, allow watches
//              [pDocStore]    - client doc store
//              [pEvtComplete] - completion event
//
//----------------------------------------------------------------------------

CAsyncQuery::CAsyncQuery( XQueryOptimizer & qopt,
                          XColumnSet & col,
                          XSortSet & sort,
                          XCategorizationSet &categ,
                          unsigned cCursors,
                          ULONG * aCursors,
                          XInterface<CPidRemapper> & pidremap,
                          BOOL fEnableNotification,
                          ICiCDocStore *pDocStore,
                          CRequestServer * pQuiesce
                        )
        : _fCanDoWorkidToPath( !qopt->IsWorkidUnique() ),
          PQuery( ),
          _ref( 1 ),
          _pidremap( pidremap.Acquire() ),
          _Table( col,
                  sort,
                  cCursors - 1,
                  _mutex,
                  !_fCanDoWorkidToPath,
                  pQuiesce ),
          _cRowsLastAsked (0),
          _aCursors( ),
          _aCategorize( cCursors - 1 )

{
    //
    // Get ci manager and translator interfaces
    //
    ICiManager *pCiManager = 0;
    SCODE sc = pDocStore->GetContentIndex( &pCiManager );
    if ( FAILED( sc ) )
    {
        Win4Assert( !"Need to support GetContentIndex interface" );

        THROW( CException( sc ) );
    }
    _xCiManager.Set( pCiManager );

    ICiCDocNameToWorkidTranslator *pNameToWidTranslator;
    sc = pDocStore->QueryInterface( IID_ICiCDocNameToWorkidTranslator,
                                    (void **) &pNameToWidTranslator );
    if ( FAILED( sc ) )
    {
        Win4Assert( !"Need to support translator QI" );

        THROW( CException( sc ) );
    }
    _xNameToWidTranslator.Set( pNameToWidTranslator );

    Win4Assert( 0 != cCursors );

    // make a cursor for the main table and each categorization level

    for (unsigned cursor = 0; cursor < cCursors; cursor++)
        aCursors[cursor] = _CreateRowCursor();

    // the last cursor is associated with the main table

    _aCursors.Lookup(aCursors[cCursors - 1]).SetSource( &_Table );

    if (cCursors > 1)
    {
        //
        //  NOTE:  pidWorkid is always added to the sort set in the table,
        //         so it should always be sorted.  That's why it's sort count-1
        //  SPECDEVIATION - if workid was already in the sort, this test
        //         is incorrect. Who would want to categorize on workid though?
        //
        if ( ! _Table.IsSorted() ||
             cCursors-1 > _Table.GetSortSet()->Count()-1 )
        {
            // CLEANCODE: Should this check be handled in the categorizers?
            //            Is it specific to the unique categorization?

            tbDebugOut(( DEB_WARN, "Query contains too few sort specs "
                                   "for categorization spec\n" ));
            THROW( CException( E_INVALIDARG ) );
        }

        // this is a categorized table, so set up the categorizers

        for ( unsigned cat = 0; cat < (cCursors - 1); cat++ )
        {
            _aCategorize[cat] = new CCategorize( * (categ->Get(cat)),
                                                 cat + 1,
                                                 cat ? _aCategorize[cat-1] : 0,
                                                 _mutex );
            _aCursors.Lookup(aCursors[cat]).SetSource( _aCategorize[cat] );
        }

        _Table.SetCategorizer(_aCategorize[cCursors - 2]);

        // now tell each categorizer what it is categorizing over

        for ( cat = 0; cat < (cCursors - 2); cat++ )
            _aCategorize[cat]->SetChild( _aCategorize[ cat + 1 ] );

        _aCategorize[ cCursors - 2 ]->SetChild( & _Table );
    }

    // Without the lock, the query can be complete and destructed
    // BEFORE the constructor finishes

    CLock lock( _mutex );

    //
    // Since we can be swapping rows, we may need singleton cursor(s)
    //

    qopt->EnableSingletonCursors();

    if ( 0 != pQuiesce )
        pQuiesce->SetPQuery( (PQuery *) this );

    _QExec.Set( new CQAsyncExecute( qopt, fEnableNotification, _Table, pDocStore ) );
    _Table.SetQueryExecute( _QExec.GetPointer() );

    ciDebugOut(( DEB_USER1, "Using an asynchronous cursor.\n" ));

    END_CONSTRUCTION( CAsyncQuery );
}

//+---------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::~CAsyncQuery, public
//
//  Synopsis:   Destroy the query
//
//----------------------------------------------------------------------------

CAsyncQuery::~CAsyncQuery()
{
    CLock lock( _mutex );

    //Win4Assert( _ref == 0 );  This isn't true when queries are aborted

    _Table.ReleaseQueryExecute();
}

//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::AddRef, public
//
//  Synopsis:   Reference the query.
//
//--------------------------------------------------------------------------

ULONG CAsyncQuery::AddRef(void)
{
    return InterlockedIncrement( &_ref );
}


//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::Release, public
//
//  Synopsis:   De-Reference the query.
//
//  Effects:    If the ref count goes to 0 then the query is deleted.
//
//--------------------------------------------------------------------------

ULONG CAsyncQuery::Release(void)
{
    long l = InterlockedDecrement( &_ref );
    if ( l <= 0 )
    {
        tbDebugOut(( DEB_ITRACE, "CAsyncQuery unreferenced.  Deleting.\n" ));
        delete this;
        return 0;
    }

    return l;
}

//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::_CreateRowCursor, private
//
//  Synopsis:   Create a new CTableCursor, return a handle to it.
//
//  Arguments:  - none -
//
//  Returns:    ULONG - handle associated with the new cursor.  Will
//                      be zero if the cursor could not be created.
//
//  Notes:      There needs to be a subsequent call to SetBindings prior
//              to any call to GetRows.
//
//--------------------------------------------------------------------------

ULONG CAsyncQuery::_CreateRowCursor( )
{
    CTableCursor * pCursor = new CTableCursor;

    ULONG hCursor = 0;

    _aCursors.Add(pCursor, hCursor);

    // By default, make the cursor refer to the real table,
    // not categorization

    pCursor->SetSource(&_Table);

    Win4Assert(hCursor != 0);

    return hCursor;
}


//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::FreeCursor, public
//
//  Synopsis:   Free a handle to a CTableCursor
//
//  Arguments:  [hCursor] - handle to the cursor to be freed
//
//  Returns:    # of cursors left
//
//--------------------------------------------------------------------------

unsigned CAsyncQuery::FreeCursor(
    ULONG       hCursor )
{
    Win4Assert( hCursor != 0 );

    _aCursors.Release(hCursor);

    return _aCursors.Count();
}


//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::SetBindings, public
//
//  Synopsis:   Set column bindings into a cursor
//
//  Arguments:  [hCursor] - the handle of the cursor to set bindings on
//              [cbRowLength] - the width of an output row
//              [cols] - a description of column bindings to be set
//              [pids] - a PID mapper which maps fake pids in cols to
//                      column IDs.
//
//  Returns:    nothing
//
//--------------------------------------------------------------------------

void
CAsyncQuery::SetBindings(
    ULONG             hCursor,
    ULONG             cbRowLength,
    CTableColumnSet & cols,
    CPidMapper &      pids )
{
    CTableCursor& rCursor = _aCursors.Lookup(hCursor);

    if (0 == cols.Count() ||
        0 == cbRowLength || cbRowLength >= USHRT_MAX)
        THROW( CException( E_INVALIDARG ));

    XPtr<CTableColumnSet> outset(new CTableColumnSet( cols.Count() ));

    for (unsigned iCol = 0; iCol < cols.Count(); iCol++)
    {
        CTableColumn * pCol = cols.Get( iCol );

        CFullPropSpec * propspec = pids.Get( pCol->PropId );

        //
        //  Convert the DBID to a PROPID
        //
//      Win4Assert( iCol+1 == pCol->PropId );   // therefore pids is useless

        PROPID prop = _pidremap->NameToReal(propspec);

        if ( prop == pidInvalid || _Table.IsColumnInTable(prop) == FALSE )
        {
            tbDebugOut(( DEB_ERROR, "Column unavailable: prop = 0x%x\n", prop ));
            THROW( CException( DB_E_BADCOLUMNID ));
        }

        if (pCol->IsCompressedCol())
            THROW( CException( E_INVALIDARG ));

        XPtr<CTableColumn> xpOutcol ( new CTableColumn( prop, pCol->GetStoredType() ) );

        if (pCol->IsValueStored())
            xpOutcol->SetValueField(pCol->GetStoredType(),
                                    pCol->GetValueOffset(),
                                    pCol->GetValueSize());

        Win4Assert( pCol->IsStatusStored() );
        xpOutcol->SetStatusField(pCol->GetStatusOffset(),
                                 (USHORT)pCol->GetStatusSize());

        if (pCol->IsLengthStored())
            xpOutcol->SetLengthField(pCol->GetLengthOffset(),
                                     (USHORT)pCol->GetLengthSize());

        outset->Add(xpOutcol, iCol);
    }

    SCODE sc = rCursor.SetBindings( cbRowLength, outset );

    if ( FAILED( sc ) )
        THROW( CException( sc ) );
} //SetBindings


//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::GetRows, public
//
//  Synopsis:   Retrieve row data for a table cursor
//
//  Arguments:  [hCursor]      - the handle of the cursor to fetch data for
//              [rSeekDesc]    - row seek operation to be done before fetch
//              [rFetchParams] - row fetch parameters and buffer pointers
//              [pSeekDescOut] - row seek description for restart
//
//  Returns:    SCODE - the status of the operation.  E_HANDLE
//                      is returned if hCursor cannot be looked up,
//                      presumably an internal error.
//
//  History:    24 Jan 1995     Alanw   Created
//
//--------------------------------------------------------------------------

SCODE
CAsyncQuery::GetRows(
    ULONG                       hCursor,
    const CRowSeekDescription & rSeekDesc,
    CGetRowsParams&             rFetchParams,
    XPtr<CRowSeekDescription> & pSeekDescOut)
{
    CTableCursor & rCursor = _aCursors.Lookup(hCursor);
    rCursor.ValidateBindings();

    CTableSource & rSource = rCursor.GetSource();

    Win4Assert(rCursor.GetRowWidth() == rFetchParams.GetRowWidth());

    return rSeekDesc.GetRows( rCursor,
                              rSource,
                              rFetchParams,
                              pSeekDescOut );
} //GetRows

//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::RestartPosition, public
//
//  Synopsis:   Reset fetch position for chapter to the start
//
//  Arguments:  [hCursor]      - the handle of the cursor to restart
//              [chapter]      - the chapter to restart
//
//  Returns:    SCODE - the status of the operation.
//
//  Notes:
//
//  History:    17 Apr 1997     EmilyB    Created
//
//--------------------------------------------------------------------------

void
CAsyncQuery::RestartPosition(
                             ULONG          hCursor,
                             CI_TBL_CHAPT   chapter)
{
   CTableCursor & rCursor = _aCursors.Lookup(hCursor);
   CTableSource & rSource = rCursor.GetSource();

   rSource.RestartPosition ( chapter );
}


//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::RatioFinished, public
//
//  Synopsis:   Return the completion status as a fraction
//
//  Arguments:  [hCursor] - the handle of the cursor to check completion for
//              [rulDenominator] - on return, denominator of fraction
//              [rulNumerator] - on return, numerator of fraction
//              [rcRows] - on return, number of rows in cursor
//              [rfNewRows] - on return, TRUE if new rows available
//
//  Returns:    nothing
//
//  Notes:      A handle of zero can be passed for use with sequential
//              cursors to check completion before a handle exists.
//
//--------------------------------------------------------------------------

void       CAsyncQuery::RatioFinished(
    ULONG         hCursor,
    DBCOUNTITEM & rulDenominator,
    DBCOUNTITEM & rulNumerator,
    DBCOUNTITEM & rcRows,
    BOOL &        rfNewRows
) {
    if (hCursor != 0)
        CTableCursor& rCursor = _aCursors.Lookup(hCursor); // For error check

    rulDenominator = 1;
    rulNumerator = 0;
    rfNewRows = FALSE;

    unsigned status = QUERY_FILL_STATUS(_Table.Status());

    //
    // SPECDEVIATION: should do something more meaningful with STAT_ERROR
    // RatioFinished should probably fail in this case.
    //

    if (STAT_DONE    == status  ||
        STAT_ERROR   == status  ||
        STAT_REFRESH == status)
    {
        rulNumerator = 1;
        rcRows = _Table.RowCount();

        if (rcRows != _cRowsLastAsked)
        {
            _cRowsLastAsked = rcRows;
            rfNewRows = TRUE;
        }
        return;
    }

    _Table.RatioFinished (rulDenominator, rulNumerator, rcRows);

    if (rcRows != _cRowsLastAsked)
    {
        _cRowsLastAsked = rcRows;
        rfNewRows = TRUE;
    }
    Win4Assert( rulDenominator >= rulNumerator );
}


//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::Compare, public
//
//  Synopsis:   Return the approximate current position as a fraction
//
//  Arguments:  [hCursor] - the handle of the cursor to compare bmks from
//              [bmkFirst] - First bookmark to compare
//              [bmkSecond] - Second bookmark to compare
//              [rdwComparison] - on return, comparison value
//
//  Returns:    nothing
//
//--------------------------------------------------------------------------

void       CAsyncQuery::Compare(
    ULONG       hCursor,
    CI_TBL_CHAPT chapt,
    CI_TBL_BMK bmkFirst,
    CI_TBL_BMK bmkSecond,
    DWORD &     rdwComparison
) {
    rdwComparison = DBCOMPARE_NOTCOMPARABLE;
    CTableCursor& rCursor = _aCursors.Lookup(hCursor);
    CTableSource & rSource = rCursor.GetSource();

    DBCOUNTITEM ulNum1, ulDen1;
    SCODE scRet = rSource.GetApproximatePosition( chapt,
                                                  bmkFirst,
                                                  &ulNum1,
                                                  &ulDen1);

    DBCOUNTITEM ulNum2, ulDen2;
    if (SUCCEEDED(scRet))
    {
        scRet = rSource.GetApproximatePosition( chapt,
                                                bmkSecond,
                                                &ulNum2,
                                                &ulDen2);
    }

    if (SUCCEEDED(scRet))
    {
        Win4Assert(ulDen1 == ulDen2);
        if (ulNum1 < ulNum2)
            rdwComparison = DBCOMPARE_LT;
        else if (ulNum1 > ulNum2)
            rdwComparison = DBCOMPARE_GT;
        else // ulNum1 == ulNum2
            rdwComparison = DBCOMPARE_EQ;
    }

    // CLEANCODE - have the source table THROW if errors in GetApproximatePosition
    if (scRet != S_OK)
        THROW(CException(scRet));
}


//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::GetApproximatePosition, public
//
//  Synopsis:   Return the approximate current position as a fraction
//
//  Arguments:  [hCursor] - the handle of the cursor to retrieve info. from
//              [bmk]     - bookmark of row to get position of
//              [pulNumerator] - on return, numerator of fraction
//              [pulDenominator] - on return, denominator of fraction
//
//  Returns:    nothing
//
//--------------------------------------------------------------------------

void
CAsyncQuery::GetApproximatePosition(
    ULONG       hCursor,
    CI_TBL_CHAPT chapt,
    CI_TBL_BMK bmk,
    DBCOUNTITEM * pulNumerator,
    DBCOUNTITEM * pulDenominator 
) {
    CTableCursor& rCursor = _aCursors.Lookup(hCursor);
    CTableSource & rSource = rCursor.GetSource();

    SCODE scRet = rSource.GetApproximatePosition( chapt,
                                           bmk,
                                           pulNumerator,
                                           pulDenominator);

    // CLEANCODE - have the source table THROW if errors in GetApproximatePosition
    if (scRet != S_OK)
        THROW(CException(scRet));
}


//+---------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::GetNotifications, private
//
//  Synopsis:   Retrieves the notification info from the query object
//              row data.
//
//  Arguments:  [rSync]    -- notification synchronization info
//              [rParams]  -- notification data info
//
//  Returns:    SCODE
//
//  History:    10-24-94     dlee      created
//
//----------------------------------------------------------------------------

SCODE
CAsyncQuery::GetNotifications(
    CNotificationSync & rSync,
    DBWATCHNOTIFY     & changeType )
{
    return _Table.GetNotifications(rSync,changeType);
}

//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::SetWatchMode
//
//  Synopsis:   Stub implementation
//
//  Arguments:  [phRegion] -- handle to watch region
//              [mode] -- watch mode
//
//  History:    May-2-95   BartoszM    Created
//
//--------------------------------------------------------------------------

void CAsyncQuery::SetWatchMode (
    HWATCHREGION* phRegion,
    ULONG mode)
{
    if (*phRegion == watchRegionInvalid)
        _Table.CreateWatchRegion (mode, phRegion);
    else
        _Table.ChangeWatchMode (*phRegion, mode);
}

//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::GetWatchInfo
//
//  Synopsis:   Stub implementation
//
//  Arguments:  [hRegion] -- handle to watch region
//              [pMode] -- watch mode
//              [pChapter] -- chapter
//              [pBookmark] -- bookmark
//              [pcRows] -- number of rows
//
//  History:    May-2-95   BartoszM    Created
//
//--------------------------------------------------------------------------

void CAsyncQuery::GetWatchInfo (
    HWATCHREGION hRegion,
    ULONG* pMode,
    CI_TBL_CHAPT*   pChapter,
    CI_TBL_BMK*     pBookmark,
    DBCOUNTITEM*    pcRows)
{
    _Table.GetWatchRegionInfo (hRegion, pChapter, pBookmark, (DBROWCOUNT *)pcRows);
}

//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::ShrinkWatchRegion
//
//  Synopsis:   Stub implementation
//
//  Arguments:  [hRegion] -- handle to watch region
//              [pChapter] -- chapter
//              [pBookmark] -- bookmark
//              [cRows] -- number of rows
//
//  History:    May-2-95   BartoszM    Created
//
//--------------------------------------------------------------------------

void CAsyncQuery::ShrinkWatchRegion (
    HWATCHREGION hRegion,
    CI_TBL_CHAPT   chapter,
    CI_TBL_BMK     bookmark,
    LONG cRows )
{
    if (cRows == 0)
        _Table.DeleteWatchRegion (hRegion);
    else
        _Table.ShrinkWatchRegion (hRegion, chapter, bookmark, cRows);
}

//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::Refresh
//
//  Synopsis:   Stub implementation
//
//  Arguments:  [] --
//
//  History:    Arp-4-95   BartoszM    Created
//
//--------------------------------------------------------------------------

void CAsyncQuery::Refresh()
{
    _Table.Refresh();
}

//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::GetQueryStatus, public
//
//  Synopsis:   Return the query status
//
//  Arguments:  [hCursor] - the handle of the cursor to check completion for
//              [rdwStatus] - on return, the query status
//
//  Returns:    nothing
//
//--------------------------------------------------------------------------

void       CAsyncQuery::GetQueryStatus(
    ULONG           hCursor,
    DWORD &         rdwStatus)
{
    rdwStatus = _Table.Status();
}

//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::GetQueryStatusEx, public
//
//  Synopsis:   Return the query status plus bonus information.  It's kind
//              of an odd assortment of info, but it saves net trips.
//
//  Arguments:  [hCursor] - handle of the cursor to check completion for
//              [rdwStatus] - returns the query status
//              [rcFilteredDocuments] - returns # of filtered docs
//              [rcDocumentsToFilter] - returns # of docs to filter
//              [rdwRatioFinishedDenominator] - ratio finished denom
//              [rdwRatioFinishedNumerator]   - ratio finished num
//              [bmk]                         - bmk to find
//              [riRowBmk]                    - index of bmk row
//              [rcRowsTotal]                 - # of rows in table
//
//  History:    Nov-9-96   dlee    Created
//
//--------------------------------------------------------------------------

void CAsyncQuery::GetQueryStatusEx(
    ULONG         hCursor,
    DWORD       & rdwStatus,
    DWORD       & rcFilteredDocuments,
    DWORD       & rcDocumentsToFilter,
    DBCOUNTITEM & rdwRatioFinishedDenominator,
    DBCOUNTITEM & rdwRatioFinishedNumerator,
    CI_TBL_BMK    bmk,
    DBCOUNTITEM & riRowBmk,
    DBCOUNTITEM & rcRowsTotal )
{
    rdwStatus = _Table.Status();

    CIF_STATE state;
    state.cbStruct = sizeof state;

    SCODE sc = _xCiManager->GetStatus( &state );
    if ( SUCCEEDED( sc ) )
    {
        rcFilteredDocuments = state.cFilteredDocuments;
        rcDocumentsToFilter = state.cDocuments;
    }
    else
    {
        ciDebugOut(( DEB_ERROR, "CAsyncQuery::GetQueryStatusEx, get status failed, 0x%x\n", sc ));

        rcFilteredDocuments = 0;
        rcDocumentsToFilter = 0;
    }

    DBCOUNTITEM cRows;
    BOOL fNewRows;
    RatioFinished( hCursor,
                   rdwRatioFinishedDenominator,
                   rdwRatioFinishedNumerator,
                   cRows,
                   fNewRows );

    GetApproximatePosition( hCursor,
                            0,
                            bmk,
                            & riRowBmk,
                            & rcRowsTotal );
} //GetQueryStatusEx

//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::WorkIdToPath
//
//  Synopsis:   Converts a wid to a path
//
//  Arguments:  [wid]       -- of the file to be translated
//              [funnyPath] -- resulting path
//
//  History:    Jun-1-95   dlee    Created
//
//--------------------------------------------------------------------------

void CAsyncQuery::WorkIdToPath( WORKID wid, CFunnyPath & funnyPath )
{
    if ( _fCanDoWorkidToPath )
    {
        ULONG cbBuf = MAX_PATH * sizeof WCHAR; // first guess -- it may be more
        XArray<BYTE> xBuf( cbBuf );
        CInlineVariant * pVariant = (CInlineVariant *) xBuf.GetPointer();

        if (! _Table.WorkIdToPath( wid, *pVariant, cbBuf ) )
        {
            if ( 0 != cbBuf )
            {
                BYTE *pb = xBuf.Acquire();
                delete [] pb;
                cbBuf += sizeof CInlineVariant;
                xBuf.Init( cbBuf );
                _Table.WorkIdToPath( wid, *pVariant, cbBuf );
            }
        }

        if ( 0 != cbBuf )
        {
            WCHAR *pwc = (WCHAR *) pVariant->GetVarBuffer();
            funnyPath.SetPath( pwc );
        }
    }
    else
    {
        ICiCDocName *pDocName;
        SCODE sc = _xNameToWidTranslator->QueryDocName( &pDocName );
        if ( SUCCEEDED( sc ) )
        {
            XInterface<ICiCDocName> xDocName( pDocName );

            sc = _xNameToWidTranslator->WorkIdToDocName( wid,
                                                         xDocName.GetPointer() );
            if ( SUCCEEDED( sc ) && sc != CI_S_WORKID_DELETED )
            {
                // PERFFIX: Here we are using two buffers XGrowable and CFunnyPath.
                // This can be avoided if xDocName->Get can take in CFunnyPath instead of WCHAR*

                XGrowable<WCHAR> xBuf(MAX_PATH);
                ULONG cb = xBuf.SizeOf();

                sc = xDocName->Get( (BYTE *) xBuf.Get(), &cb );
                if ( CI_E_BUFFERTOOSMALL == sc )
                {
                    xBuf.SetSizeInBytes( cb );
                    sc = xDocName->Get( (BYTE *) xBuf.Get(), &cb );
                }

                if ( SUCCEEDED( sc ) )
                {
                    funnyPath.SetPath( xBuf.Get() );
                }
            }
        }
    }
} //WorkIdToPath

BOOL CAsyncQuery::CanDoWorkIdToPath()
{
    return _fCanDoWorkidToPath;
} //CanDoWorkIdToPath

//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::FetchDeferredValue
//
//  Synopsis:   Fetch deferred value from property cache
//
//  Arguments:  [wid] -- Workid.
//              [ps]  -- Property to be fetched.
//              [var] -- Property returned here.
//
//  History:    Jun-1-95   KyleP   Created
//
//--------------------------------------------------------------------------

BOOL CAsyncQuery::FetchDeferredValue(
    WORKID                wid,
    CFullPropSpec const & ps,
    PROPVARIANT &         var )
{
    //
    // If using a NULL catalog, assume a file system and go get the value.
    // The NULL catalog case is only supported by fsci, anyway, so it's
    // ok to do this hack.
    //

    if ( _fCanDoWorkidToPath )
    {
        CFunnyPath funnyPath;
        WorkIdToPath( wid, funnyPath );

        COLEPropManager propMgr;
        propMgr.Open( funnyPath );
        return propMgr.ReadProperty( ps, var );
    }

    return _QExec->FetchDeferredValue( wid, ps, var );
} //FetchDeferredValue
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\odbvarnt.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 2000.
//
//  File:       odbvarnt.cxx
//
//  Contents:   Helper class for PROPVARIANTs, OLE-DB variant types and
//              Automation variant types in tables
//
//  Classes:    COLEDBVariant - derives from CTableVariant
//
//  Functions:
//
//  History:    09 Jan 1998     VikasMan    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <bigtable.hxx>
#include <odbvarnt.hxx>

#include <initguid.h>
#define DBINITCONSTANTS
#include <msdadc.h>     // oledb data conversion (IDataConvert) interface
#include <msdaguid.h>

#include "tabledbg.hxx"

//+-------------------------------------------------------------------------
//
//  Method:     COLEDBVariant::OLEDBConvert, public.
//
//  Synopsis:   Data conversion routine, which uses the OLEDB data
//              conversion library (MSDADC.DLL) to do the conversion.
//
//  Arguments:  [pbDstBuf]     -- the Destination data buffer
//              [cbDstBuf]     -- the size of Dst. buffer
//              [vtDst]        -- the Destination type.
//              [rPool]        -- pool to use for destination buffers
//              [rcbDstLength] -- size of destination data
//              [xDataConvert] -- the OLEDB IDataConvert interface
//              [bPrecision]   -- The precision of the output data in bytes,
//                                if applicable. This argument is used when 
//                                converting to DBTYPE_NUMERIC data only.
//              [bScale]       -- The scale of the output data in bytes,
//                                if applicable. This argument is used when 
//                                converting to DBTYPE_NUMERIC data only.
//
//  Returns:    DBSTATUS_S_OK if conversion is successful, 
//              else other DBSTATUS values.
//
//  Notes:      pbDstBuf should have (enough) memory allocated, else
//              truncation can happen.
//
//              This routine is subdivided into 3 parts:
//                  - It checks first if we are dealing with Automation Vars.
//                  - Then it calls CTableVaraint::CopyOrCoerce to the job
//                  - If unsuccessful, it uses the OLE-DB library
//
//  History:    09 Jan 1998     VikasMan  Created
//
//--------------------------------------------------------------------------

DBSTATUS COLEDBVariant::OLEDBConvert(
                        BYTE *            pbDstBuf,
                        DBLENGTH          cbDstBuf,
                        VARTYPE           vtDst,
                        PVarAllocator &   rPool,
                        DBLENGTH &        rcbDstLength,
                        XInterface<IDataConvert>& xDataConvert,
                        BOOL             fExtTypes,  /* = TRUE */
                        BYTE             bPrecision, /* = 0 */
                        BYTE             bScale      /* = 0 */ ) const
{
    void* pbSrcBuf;
    ULONG cbSrcSize;
    DBTYPE dbtypeSrc, dbtypeDst;
    DBLENGTH cbDstBufNeeded;
    DBSTATUS DstStatus = DBSTATUS_E_CANTCONVERTVALUE;

    // Check if fExtTypes is false and we are dealing with automation variants
    if ( VT_VARIANT == vtDst || DBTYPE_PROPVARIANT == vtDst )
    {
        Win4Assert(cbDstBuf == sizeof PROPVARIANT);

        rcbDstLength = sizeof (PROPVARIANT);
        if ( ! IsArray( vt) && 
             ( fExtTypes || DBTYPE_PROPVARIANT == vtDst ||
               VT_BSTR == vt || (IsSimpleOAType( vt ) && ! IsVector( vt )) ) )
        {
            Copy( (CTableVariant*) pbDstBuf, rPool, (USHORT) VarDataSize() );
            DstStatus = DBSTATUS_S_OK;
        }
        else
        {
            DstStatus = _CopyToOAVariant( (VARIANT *) pbDstBuf, rPool );
        }

        if ( VT_EMPTY == vt )
            DstStatus = DBSTATUS_S_ISNULL;
    }
    else
    {
        // try converting using CTableVariant's CopyOrCoerce
        DstStatus = CopyOrCoerce( pbDstBuf,
                                cbDstBuf,
                                vtDst,
                                rcbDstLength,
                                rPool );
    }

    if ( DBStatusOK( DstStatus ))
    {
        // we are done here
        return DstStatus;
    }

    if (DBTYPE_HCHAPTER == vtDst)
    {
        if (VT_I4 == vt || VT_UI4 == vt)
        {
            * (ULONG *) pbDstBuf = lVal;
            DstStatus = DBSTATUS_S_OK;
        }

        return DstStatus;
    }

    // WORKAROUND: The following switch stmt is needed only until
    // OLEDB library supports VT_FILETIME. Once it does that,
    // we can get rid of this.

    switch ( vtDst )
    {
    case VT_DATE:
        // allow coercions from I8, UI8, R8, and FILETIME

        if (VT_I8 == vt || VT_UI8 == vt)
        {
            * (LONGLONG *) pbDstBuf = hVal.QuadPart;
        }
        else if (VT_R8 == vt)
        {
            * (DATE *) pbDstBuf = dblVal;
        }
        else
        {
            DstStatus = _StoreDate(pbDstBuf, cbDstBuf, vtDst);
        }
        rcbDstLength = sizeof (DATE);
        break;

    case VT_FILETIME:
        // allow coercions from I8, UI8, and DATE

        if (VT_I8 == vt || VT_UI8 == vt)
        {
            * (LONGLONG *) pbDstBuf = hVal.QuadPart;
        }
        else
        {
            DstStatus = _StoreDate(pbDstBuf, cbDstBuf, vtDst);
        }
        rcbDstLength = sizeof (FILETIME);
        break;

    case DBTYPE_DBDATE:
        DstStatus = _StoreDate(pbDstBuf, cbDstBuf, vtDst);
        rcbDstLength = sizeof (DBDATE);
        break;

    case DBTYPE_DBTIME:
        DstStatus = _StoreDate(pbDstBuf, cbDstBuf, vtDst);
        rcbDstLength = sizeof (DBTIME);
        break;

    case DBTYPE_DBTIMESTAMP:
        DstStatus = _StoreDate(pbDstBuf, cbDstBuf, vtDst);
        rcbDstLength = sizeof (DBTIMESTAMP);
        break;
    }

    if ( DBStatusOK( DstStatus ))
    {
        // we are done here
        return DstStatus;
    }

    tbDebugOut(( DEB_ITRACE, "COLEDBVaraint::OLEDBConvert - Using OLEDB library for conversion\n" ));

    // this looks like a job for ole-db

    // check if we have the IDataConvert interface
    if ( xDataConvert.IsNull( ) )
    {
        // let's get it then
        if ( !_GetIDataConvert( xDataConvert ) )
        {
            // for some reason we could not get the IDataConvert interface
            return DBSTATUS_E_CANTCONVERTVALUE;
        }
    }

    // get the source data pointer
    pbSrcBuf = _GetDataPointer();
    if ( 0 == pbSrcBuf )
    {
        tbDebugOut(( DEB_ERROR, "OLEDBConvert - _GetDataPointer returned NULL\n" ));

        return DBSTATUS_E_CANTCONVERTVALUE;
    }

    // get the source data size
    cbSrcSize = VarDataSize();

    // get the OLEDB source type
    SCODE sc = _GetOLEDBType( vt, dbtypeSrc );
    if ( S_OK != sc )
    {
        // can't use the OLEDB Conversion library
        tbDebugOut(( DEB_ERROR,
                     "OLEDBConvert - _GetOLEDBType returned error 0x%x for type %x\n",
                     sc, vt ));
        return DBSTATUS_E_CANTCONVERTVALUE;
    }


    // the destination type has to be an OLE-DB type
    dbtypeDst = vtDst;

    // get the needed Destination size
    sc = xDataConvert->GetConversionSize( dbtypeSrc,
                                          dbtypeDst,
                                          0,
                                          &cbDstBufNeeded,
                                          pbSrcBuf );

    if ( sc != S_OK )
    {
        tbDebugOut(( DEB_ITRACE,
                     "OLEDBConvert - GetConversionSize returned error 0x%x\n",
                     sc ));
        return DBSTATUS_E_CANTCONVERTVALUE;
    }

    BYTE* pbDest = 0;

    // we need to allocate memory if ...

    if ( ( IsLPWSTR( dbtypeDst ) ) ||
         ( IsLPSTR( dbtypeDst ) ) ||
         ( (DBTYPE_BYREF | DBTYPE_WSTR) == dbtypeDst ) ||
         ( (DBTYPE_BYREF | DBTYPE_STR) == dbtypeDst )
       )
    {
        // If we hit this assert, then we got a few things to think about

        Win4Assert( !(IsLPWSTR( dbtypeDst ) || IsLPSTR( dbtypeDst )) );

        pbDest = (BYTE*) rPool.Allocate( (ULONG) cbDstBufNeeded );
    }
    else if ( DBTYPE_BSTR == dbtypeDst )
    {
        pbDest = (BYTE*) rPool.AllocBSTR( (ULONG) cbDstBufNeeded );
    }
    else
    {
        // bogus assert
        // Win4Assert ( (dbtypeDst & DBTYPE_BYREF) == 0 );

        // memory is already allocated
        // use the size which is less
        // if cbDstBuf is less than cbDstBufNeeded, truncation might happen
        cbDstBufNeeded = ( cbDstBufNeeded < cbDstBuf ? cbDstBufNeeded : cbDstBuf );
    }

    // do the conversion
    sc = xDataConvert->DataConvert( dbtypeSrc,
                                      dbtypeDst,
                                      cbSrcSize,
                                      &rcbDstLength,
                                      pbSrcBuf,
                                      pbDest ? (void*)&pbDest : pbDstBuf,
                                      cbDstBufNeeded,
                                      DstStatus,
                                      &DstStatus,
                                      bPrecision,
                                      bScale,
                                      DBDATACONVERT_DEFAULT); 

    if ( sc != S_OK )
    {
        tbDebugOut(( DEB_ITRACE,
                     "OLEDBConvert - DataConvert returned error 0x%x\n",
                     sc ));
        return DBSTATUS_E_CANTCONVERTVALUE;
    }

    // if memory was allocated, put that ptr in pbDstBuf
    if ( pbDest )
    {
        *((BYTE**)(pbDstBuf)) = pbDest;
    }

    return DstStatus;
}

//+-------------------------------------------------------------------------
//
//  Method:     COLEDBVariant::GetDstLength, public.
//
//  Synopsis:   Returns the length required after the conversion without
//              actually doing the conversion.
//
//  History:    10-12-98        DanLeg      Created
//
//--------------------------------------------------------------------------

DBSTATUS COLEDBVariant::GetDstLength( 
                         XInterface<IDataConvert>& xDataConvert, 
                         DBTYPE                    dbtypeDst,
                         DBLENGTH &                   rcbDstLen )
{
    SCODE sc = S_OK;
    DBTYPE dbtypeSrc;
    DBSTATUS DstStatus = DBSTATUS_S_OK;

    sc = _GetOLEDBType( vt, dbtypeSrc );
    
    if ( S_OK == sc )
    {
        if ( xDataConvert.IsNull( ) )
        {
            if ( !_GetIDataConvert( xDataConvert ) )
                sc = S_FALSE;
        }

        if ( S_OK == sc )
        {
            void * pbSrcBuf = _GetDataPointer();
            sc = xDataConvert->GetConversionSize( dbtypeSrc,
                                                  dbtypeDst, 
                                                  0,
                                                  &rcbDstLen,
                                                  pbSrcBuf );
        }
    }

    if ( S_OK != sc )
    {
        tbDebugOut(( DEB_ITRACE,
                     "OLEDBConvert - GetConversionSize returned error 0x%x\n",
                     sc ));
        DstStatus = DBSTATUS_E_CANTCONVERTVALUE;
    }

    return DstStatus;
}
                                      

//+-------------------------------------------------------------------------
//
//  Method:     COLEDBVariant::_GetOLEDBType, private.
//
//  Synopsis:   Returns the OLEDB type equivalent of Variant type.
//
//  Arguments:  [vt] -- the source varaint type.
//              [dbtype] -- the equivalent oledb type.
//
//  Returns:    S_OK if equivalent OLE DB type exists, 
//              else S_FALSE.
//
//  Notes:      Does not handle vectors
//
//  History:    09 Jan 1998     VikasMan  Created
//
//--------------------------------------------------------------------------

inline SCODE COLEDBVariant::_GetOLEDBType( VARTYPE vt, DBTYPE& dbtype ) const
{
    SCODE sc = S_OK;

    switch ( vt & ~VT_BYREF )
    {
    case VT_I1:
    case VT_UI1:
    case VT_I2:
    case VT_UI2:
    case VT_I4:
    case VT_UI4:
    case VT_I8:
    case VT_UI8:
    case VT_R4:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_BSTR:
    case VT_FILETIME:   // WORKAROUND: Waiting on OLE DB Conv lib to handle this case - 01.12.98
    case VT_BOOL:
    case VT_ERROR:
    case VT_CLSID:
    case VT_VARIANT:
    case VT_DECIMAL:

    case VT_VECTOR | VT_I1:
    case VT_VECTOR | VT_UI1:
    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_BSTR:
    case VT_VECTOR | VT_FILETIME:   // WORKAROUND: Waiting on OLE DB Conv lib to handle this case - 01.12.98
    case VT_VECTOR | VT_BOOL:
    case VT_VECTOR | VT_ERROR:
    case VT_VECTOR | VT_CLSID:
    case VT_VECTOR | VT_VARIANT:

    case VT_ARRAY | VT_I1:
    case VT_ARRAY | VT_UI1:
    case VT_ARRAY | VT_I2:
    case VT_ARRAY | VT_UI2:
    case VT_ARRAY | VT_I4:
    case VT_ARRAY | VT_UI4:
    case VT_ARRAY | VT_I8:
    case VT_ARRAY | VT_UI8:
    case VT_ARRAY | VT_R4:
    case VT_ARRAY | VT_R8:
    case VT_ARRAY | VT_CY:
    case VT_ARRAY | VT_DATE:
    case VT_ARRAY | VT_BSTR:
    case VT_ARRAY | VT_BOOL:
    case VT_ARRAY | VT_VARIANT:
    case VT_ARRAY | VT_DECIMAL:

        // In all the above cases, the DBTYPE has same value as
        // VARIANT type
    case DBTYPE_NUMERIC:
    case DBTYPE_DBDATE:
    case DBTYPE_DBTIME:
    case DBTYPE_DBTIMESTAMP:
    case DBTYPE_HCHAPTER:
    case DBTYPE_BYTES:
    case DBTYPE_VARNUMERIC:
        // The above are OLEDB types only. So no conversion needed.
        dbtype = vt;
        break;

    case VT_LPSTR:
    case DBTYPE_STR:
        dbtype = DBTYPE_STR;
        break;

    case VT_LPWSTR:
    case DBTYPE_WSTR:
        dbtype = DBTYPE_WSTR;
        break;

    case VT_BLOB:
        dbtype = VT_VECTOR | VT_UI1;
        break;

    case VT_INT:
        dbtype = VT_I4;
        break;

    case VT_UINT:
        dbtype = VT_UI4;
        break;

    case VT_ARRAY | VT_INT:
        dbtype = VT_ARRAY | VT_I4;
        break;

    case VT_ARRAY | VT_UINT:
        dbtype = VT_ARRAY | VT_UI4;
        break;

    // SPECDEVIATION: What about VT_CF ??? (handled partially in base class)

    default:
        // default case: all types for which there is no equivalent
        // OLE DB type - VT_CF, VT_BLOBOBJECT,
        // VT_STREAM, VT_STREAMED_OBJECT, VT_STORAGE, VT_STORED_OBJECT,
        // VT_DISPATCH, VT_UNKNOWN,
        sc = S_FALSE;
        break;
    }
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     COLEDBVariant::_GetDataPointer, private
//
//  Synopsis:   Depending on the type of vt, returns the data pointer
//
//  Arguments:  -none-
//
//  Returns:    Returns the pointer to data in the PropVariant
//
//  History:    09 Jan 1998     VikasMan  Created
//
//--------------------------------------------------------------------------
inline void* COLEDBVariant::_GetDataPointer() const
{
    if (vt & VT_VECTOR)
        return (void*)&cal;

    if (vt & VT_ARRAY)
        return (void*) parray;

    void* pDataPtr = 0;

    switch ( vt )
    {
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_CLSID:
    case VT_CF:
        // all pointer values
        pDataPtr = (void*) pszVal;
        break;

    case VT_BSTR:
        // need address of bstr ptr
        pDataPtr = (void*) &bstrVal;
        break;

    case VT_BLOB:
    case VT_BLOB_OBJECT:
        pDataPtr = (void*) &blob;
        break;

    case VT_DECIMAL:
        pDataPtr = (void*) this;
        break;

    // cases which we do not handle
    case VT_EMPTY:
    case VT_NULL:
    case VT_ILLEGAL:
    case VT_STREAM:
    case VT_STREAMED_OBJECT:
    case VT_STORAGE:
    case VT_STORED_OBJECT:
    case VT_DISPATCH:
    case VT_VARIANT:
    case VT_UNKNOWN:
    case VT_VOID:
        pDataPtr = 0;
        break;

    // Rest of the stuff
    default:
        pDataPtr = (void*) &bVal;
        break;
    }

    return pDataPtr;
}


//+-------------------------------------------------------------------------
//
//  Member:     COLEDBVariant::_CopyToOAVariant, private
//
//  Synopsis:   Copy table data between a table variant structure and
//              an Ole automation variant.  Automation variants have a
//              restricted set of usable types and vectors must be converted
//              to safearrays.
//
//  Arguments:  [pDest]    -- pointer to destination variant
//              [rPool]    -- pool to use for destination buffers
//
//  Returns:    status for copy
//
//  History:    09 Jan 1998     VikasMan  Created
//
//--------------------------------------------------------------------------

DBSTATUS COLEDBVariant::_CopyToOAVariant( VARIANT *         pDest,
                                          PVarAllocator &   rPool) const
{
    DBSTATUS DstStatus = DBSTATUS_S_OK;

    switch (vt)
    {
    case VT_LPSTR:
    case VT_LPWSTR:
    {
        DBLENGTH ulTemp;
        pDest->vt = VT_BSTR;
        DstStatus = _StoreString( (BYTE *)&(pDest->bstrVal),
                                  sizeof (BSTR),
                                  VT_BSTR,
                                  ulTemp,
                                  rPool);
        break;
    }

    case VT_I8:
    case VT_UI8:
        DstStatus = _StoreDecimal( &(pDest->decVal) );
        pDest->vt = VT_DECIMAL;
        break;

    case VT_I1:
        DstStatus = _StoreIntegerSignedToUnSigned( VT_UI1, &(pDest->bVal) );
        pDest->vt = VT_UI1;
        break;

    case VT_UI2:
        if (uiVal <= SHRT_MAX)
        {
            DstStatus = _StoreIntegerUnSignedToSigned( VT_I2, (BYTE*)&(pDest->iVal) );
            pDest->vt = VT_I2;
        }
        else
        {
            DstStatus = _StoreIntegerUnSignedToSigned( VT_I4, (BYTE*)&(pDest->lVal) );
            pDest->vt = VT_I4;
        }
        break;

    case VT_UI4:
        if (ulVal <= LONG_MAX)
        {
            DstStatus = _StoreIntegerUnSignedToSigned( VT_I4, (BYTE*)&(pDest->lVal) );
            pDest->vt = VT_I4;
        }
        else
        {
            DstStatus = _StoreDecimal( &(pDest->decVal) );
            pDest->vt = VT_DECIMAL;
        }
        break;

    case VT_FILETIME:
        DstStatus = _StoreDate( (BYTE*)&(pDest->date),
                                sizeof pDest->date,
                                VT_DATE );
        pDest->vt = VT_DATE;
        break;

    case (VT_VECTOR | VT_I2):
    case (VT_VECTOR | VT_I4):
    case (VT_VECTOR | VT_R4):
    case (VT_VECTOR | VT_R8):
    case (VT_VECTOR | VT_CY):
    case (VT_VECTOR | VT_DATE):
    case (VT_VECTOR | VT_ERROR): 
    case (VT_VECTOR | VT_BOOL):
    case (VT_VECTOR | VT_UI1):
    case (VT_VECTOR | VT_DECIMAL):
        Win4Assert( IsSimpleOAType(vt & VT_TYPEMASK));
        Win4Assert( CanBeVectorType(vt & VT_TYPEMASK));
        DstStatus = _StoreSimpleTypeArray( &(pDest->parray));
        pDest->vt = (vt & VT_TYPEMASK) | VT_ARRAY;
        break;

    case (VT_VECTOR | VT_UI4):  // could step thru to see if I4 is big enough
    case (VT_VECTOR | VT_I8):
    case (VT_VECTOR | VT_UI8):
        Win4Assert( !IsOAType(vt & VT_TYPEMASK));
        Win4Assert( CanBeVectorType(vt & VT_TYPEMASK));
        DstStatus = _StoreDecimalArray( &(pDest->parray));
        pDest->vt = VT_DECIMAL | VT_ARRAY;
        break;

    case (VT_VECTOR | VT_UI2):  // could step thru to detect if I2 is big enough
        Win4Assert( !IsOAType(vt & VT_TYPEMASK));
        Win4Assert( CanBeVectorType(vt & VT_TYPEMASK));
        DstStatus = _StoreIntegerArray( VT_I4, &(pDest->parray));
        pDest->vt = VT_I4 | VT_ARRAY;
        break;

    case (VT_VECTOR | VT_I1):  // should step thru to detect if UI1 is big enough
        Win4Assert( !IsOAType(vt & VT_TYPEMASK));
        Win4Assert( CanBeVectorType(vt & VT_TYPEMASK));
        DstStatus = _StoreIntegerArray( VT_UI1, &(pDest->parray));
        pDest->vt = VT_UI1 | VT_ARRAY;
        break;

    case (VT_VECTOR | VT_LPSTR):  // byref/vector mutually exclusive
        Win4Assert( !IsOAType(vt & VT_TYPEMASK));
        Win4Assert( CanBeVectorType(vt & VT_TYPEMASK));
        DstStatus = _StoreLPSTRArray( &(pDest->parray), rPool );
        pDest->vt = VT_BSTR | VT_ARRAY;
        break;

    case (VT_VECTOR | VT_LPWSTR):
        Win4Assert( !IsOAType(vt & VT_TYPEMASK));
        Win4Assert( CanBeVectorType(vt & VT_TYPEMASK));
        DstStatus = _StoreLPWSTRArray( &(pDest->parray), rPool );
        pDest->vt = VT_BSTR | VT_ARRAY;
        break;

    case (VT_VECTOR | VT_BSTR):
        Win4Assert( IsOAType(vt & VT_TYPEMASK));
        Win4Assert( CanBeVectorType(vt & VT_TYPEMASK));
        DstStatus = _StoreBSTRArray( &(pDest->parray), rPool );
        pDest->vt = VT_BSTR | VT_ARRAY;
        break;

    case (VT_VECTOR | VT_VARIANT):
        Win4Assert( IsOAType(vt & VT_TYPEMASK));
        Win4Assert( CanBeVectorType(vt & VT_TYPEMASK));
        DstStatus = _StoreVariantArray( &(pDest->parray), rPool );
        pDest->vt = VT_VARIANT | VT_ARRAY;
        break;

    case (VT_VECTOR | VT_FILETIME):
        Win4Assert( !IsOAType(vt & VT_TYPEMASK));
        Win4Assert( CanBeVectorType(vt & VT_TYPEMASK));
        DstStatus = _StoreDateArray( &(pDest->parray) );
        pDest->vt = VT_DATE | VT_ARRAY;
        break;

    case VT_ARRAY | VT_I1:
    case VT_ARRAY | VT_UI1:
    case VT_ARRAY | VT_I2:
    case VT_ARRAY | VT_UI2:
    case VT_ARRAY | VT_I4:
    case VT_ARRAY | VT_INT:
    case VT_ARRAY | VT_UI4:
    case VT_ARRAY | VT_UINT:
    case VT_ARRAY | VT_ERROR:
    case VT_ARRAY | VT_I8:
    case VT_ARRAY | VT_UI8:
    case VT_ARRAY | VT_R4:
    case VT_ARRAY | VT_R8:
    case VT_ARRAY | VT_CY:
    case VT_ARRAY | VT_DATE:
    case VT_ARRAY | VT_BSTR:
    case VT_ARRAY | VT_BOOL:
    case VT_ARRAY | VT_VARIANT:
    case VT_ARRAY | VT_DECIMAL:
      {
        SAFEARRAY * psa = 0;
        SCODE sc = SafeArrayCopy( parray, &psa );
        Win4Assert( E_INVALIDARG != sc );
        Win4Assert( E_OUTOFMEMORY == sc || psa != 0 );
        if (S_OK != sc)
        {
            THROW(CException(E_OUTOFMEMORY));
        }
        else
        {
            pDest->vt = vt;
            pDest->parray = psa;
        }
      }
        break;

    case VT_CLSID:   // no equivalent in OA variant
    case VT_CF:      // no equivalent in OA variant
    default:
        Win4Assert( !(VT_ARRAY & vt) ); // should be handled elsewhere
        Win4Assert( !IsOAType(vt) );    // should be handled elsewhere
        Win4Assert(CanBeVectorType(vt & VT_TYPEMASK) || !(VT_VECTOR & vt));
        tbDebugOut(( DEB_WARN, "COLEDBVariant::CopyToOAVariant - bad variant type %d \n", vt ));

        DstStatus = DBSTATUS_E_CANTCONVERTVALUE;
    }

    if ( !StatusSuccess(DstStatus) ||
         (DBSTATUS_S_ISNULL == DstStatus && pDest->vt != VT_NULL) )
        pDest->vt = VT_EMPTY;

    return DstStatus;
}


//+-------------------------------------------------------------------------
//
//  Member:     COLEDBVariant::_StoreSimpleTypeArray, private
//
//  Synopsis:   Copy vector of simple OA types to safearray of same type
//
//  Arguments:  [pbDstBuf]      -- destination buffer
//
//  Returns:    status for copy
//
//  Notes:      None of the simple types require memory allocation.
//              Throws if safearray itself cannot be alloc'd
//
//  History:    09 Apr 1997     EmilyB      Created
//              09 Jan 1998     VikasMan    Moved from CTableVariant class 
//                                          to here
//
//--------------------------------------------------------------------------

DBSTATUS COLEDBVariant::_StoreSimpleTypeArray(SAFEARRAY **  pbDstBuf) const
{
    if ( 0 == caul.cElems )
        return DBSTATUS_S_ISNULL;

    // CLEANCODE - add to PVarAllocator?
    SAFEARRAY *sa = SafeArrayCreateVector(vt & VT_TYPEMASK, 0, caul.cElems);
    if (0 == sa)
        THROW(CException(E_OUTOFMEMORY));
    XSafeArray xsa(sa);

    USHORT cbSize, cbAlign, rgFlags;
    VartypeInfo(vt & VT_TYPEMASK, cbSize, cbAlign, rgFlags);
    BYTE * pBase = (BYTE *)&(caul.pElems[0]);
    for (LONG lElem = 0; lElem < (LONG)(caul.cElems); lElem++)
    {
        SCODE sc = SafeArrayPutElement(xsa.Get(), &lElem, pBase + (cbSize * lElem));
        Win4Assert ( SUCCEEDED(sc) );
    }

    *pbDstBuf = xsa.Acquire();

    return DBSTATUS_S_OK;

}

//+-------------------------------------------------------------------------
//
//  Member:     COLEDBVariant::_StoreDecimalArray, private
//
//  Synopsis:   Copy vector to decimal safearray
//
//  Arguments:  [pbDstBuf]      -- destination buffer
//
//  Returns:    status for copy
//
//  Notes:      Expects the 'this' data type to be VT_UI4|VT_VECTOR, 
//              VT_I8|VT_VECTOR, or VT_UI8|VT_VECTOR.
//
//  History:    09 Apr 1997     EmilyB      Created
//              09 Jan 1998     VikasMan    Moved from CTableVariant class 
//                                          to here
//
//--------------------------------------------------------------------------

DBSTATUS COLEDBVariant::_StoreDecimalArray( SAFEARRAY ** pbDstBuf ) const
{
    if ( 0 == caul.cElems )
        return DBSTATUS_S_ISNULL;

    DBSTATUS dbStatus = DBSTATUS_S_OK; // status of last conversion
    DBSTATUS dbStatusRet  = DBSTATUS_S_OK; // error code of last conversion, 
                                           // or if no errors, DBSTATUS_S code
                                           // of last item with any trouble converting.

    // CLEANCODE - add to PVarAllocator?
    SAFEARRAY * sa = SafeArrayCreateVector(VT_DECIMAL, 0, caul.cElems);
    if (0 == sa)
        THROW(CException(E_OUTOFMEMORY));
    XSafeArray xsa(sa);

    for (LONG lElem = 0; lElem < (LONG)caul.cElems && StatusSuccess(dbStatus); lElem++)
    {
        DECIMAL dec;
        dbStatus = _StoreDecimal( &dec, lElem);
        if (DBSTATUS_S_OK != dbStatus)
            dbStatusRet = dbStatus;  // save last non-zero status
        SCODE sc = SafeArrayPutElement(xsa.Get(), &lElem, &dec);
        Win4Assert ( SUCCEEDED(sc) );
    }
    if (StatusSuccess(dbStatus))
    {
        *pbDstBuf = xsa.Acquire();
    }
    return dbStatusRet;
}

//+-------------------------------------------------------------------------
//
//  Member:     COLEDBVariant::_StoreIntegerArray, private
//
//  Synopsis:   Copy vector of integers to safearray of integers
//
//  Arguments:  [vtDst]         -- destination safearray type
//              [pbDstBuf]      -- destination buffer
//
//  Returns:    status for copy
//
//  Notes:      Expects the 'this' data type to be an int type | VT_VECTOR.
//
//  History:    09 Apr 1997     EmilyB      Created
//              09 Jan 1998     VikasMan    Moved from CTableVariant class 
//                                          to here
//
//--------------------------------------------------------------------------
DBSTATUS COLEDBVariant::_StoreIntegerArray(VARTYPE          vtDst,
                                           SAFEARRAY **     pbDstBuf) const
{
    if ( 0 == caul.cElems )
        return DBSTATUS_S_ISNULL;

    DBSTATUS dbStatus = DBSTATUS_S_OK;
    DBSTATUS dbStatusRet  = DBSTATUS_S_OK; // error code of last conversion, 
    // or if no errors, DBSTATUS_S code
    // of last item with any trouble converting.

    // CLEANCODE - add to PVarAllocator?
    SAFEARRAY * sa = SafeArrayCreateVector(vtDst, 0, caul.cElems);
    if (0 == sa)
        THROW(CException(E_OUTOFMEMORY));
    XSafeArray xsa(sa);

    for (LONG lElem = 0; lElem < (LONG)caul.cElems && StatusSuccess(dbStatus); lElem++)
    {
        LONGLONG iInt; // size of longest int - to use as buffer
        dbStatus = _StoreInteger( vtDst, (BYTE *)&iInt, lElem);
        if (DBSTATUS_S_OK != dbStatus)
            dbStatusRet = dbStatus;  // save last non-zero status
        SCODE sc = SafeArrayPutElement(xsa.Get(), &lElem, &iInt); 
        Win4Assert ( SUCCEEDED(sc) );
    }
    if (StatusSuccess(dbStatus))
    {
        *pbDstBuf = xsa.Acquire();
    }
    return dbStatusRet;
}

//+-------------------------------------------------------------------------
//
//  Member:     COLEDBVariant::_StoreLPSTRArray, private
//
//  Synopsis:   Copy LPSTR vector to safearray 
//
//  Arguments:  [pbDstBuf]      -- destination buffer
//              [rPool]    -- pool to use for destination buffers
//
//  Returns:    status for copy
//
//  History:    09 Apr 1997     EmilyB      Created
//              09 Jan 1998     VikasMan    Moved from CTableVariant class 
//                                          to here
//
//--------------------------------------------------------------------------

DBSTATUS COLEDBVariant::_StoreLPSTRArray(
                                        SAFEARRAY **            pbDstBuf,
                                        PVarAllocator &  rPool) const
{
    if ( 0 == calpstr.cElems )
        return DBSTATUS_S_ISNULL;

    DBSTATUS dbStatus = DBSTATUS_S_OK;

    // CLEANCODE - add to PVarAllocator?

    SAFEARRAY * sa = SafeArrayCreateVector(VT_BSTR, 0, calpstr.cElems);
    if (0 == sa)
        THROW(CException(E_OUTOFMEMORY));

    XSafeArray xsa(sa);

    for (LONG lElem = 0; lElem < (LONG)(calpstr).cElems && StatusSuccess(dbStatus); lElem++)
    {
        int cwc = MultiByteToWideChar(ulCoercionCodePage,0,
                                      calpstr.pElems[lElem],-1,0,0);
        if (0 == cwc)
        {
            dbStatus = DBSTATUS_E_CANTCONVERTVALUE; // something odd...
        }
        else
        {
            XArray<WCHAR> wcsDest( cwc );
            MultiByteToWideChar(ulCoercionCodePage, 0,
                                calpstr.pElems[lElem], -1,  wcsDest.Get(), cwc);

            BSTR bstrDest = (BSTR) rPool.CopyBSTR((cwc-1)*sizeof (OLECHAR),
                                                  wcsDest.Get());

            SCODE sc = SafeArrayPutElement(xsa.Get(), &lElem, (void *)rPool.PointerToOffset(bstrDest));
            rPool.FreeBSTR(bstrDest);

            if (E_OUTOFMEMORY == sc)
                THROW(CException(E_OUTOFMEMORY));
            Win4Assert ( SUCCEEDED(sc) );
        }
    }

    if (StatusSuccess(dbStatus))
    {
        *pbDstBuf = xsa.Acquire();
    }


    return dbStatus;
}

//+-------------------------------------------------------------------------
//
//  Member:     COLEDBVariant::_StoreLPWSTRArray, private
//
//  Synopsis:   Copy LPWSTR vector to safearray 
//
//  Arguments:  [pbDstBuf]      -- destination buffer
//              [rPool]    -- pool to use for destination buffers
//
//  Returns:    status for copy
//
//  History:    09 Apr 1997     EmilyB      Created
//              09 Jan 1998     VikasMan    Moved from CTableVariant class 
//                                          to here
//
//--------------------------------------------------------------------------

DBSTATUS COLEDBVariant::_StoreLPWSTRArray(
                                         SAFEARRAY **          pbDstBuf,
                                         PVarAllocator &  rPool) const
{
    if ( 0 == calpwstr.cElems )
        return DBSTATUS_S_ISNULL;

    // CLEANCODE - add to PVarAllocator?
    SAFEARRAY * sa = SafeArrayCreateVector(VT_BSTR, 0, calpwstr.cElems);
    if (0 == sa)
        THROW(CException(E_OUTOFMEMORY));

    XSafeArray xsa(sa);

    for (LONG lElem = 0; lElem < (LONG)(calpwstr.cElems); lElem++)
    {
        BSTR bstrDest = (BSTR) rPool.CopyBSTR( wcslen(calpwstr.pElems[lElem])  * sizeof(WCHAR),
                                               calpwstr.pElems[lElem] );
        SCODE sc = SafeArrayPutElement(xsa.Get(), &lElem, (void *)rPool.PointerToOffset(bstrDest));
        rPool.FreeBSTR(bstrDest);

        if (E_OUTOFMEMORY == sc)
            THROW(CException(E_OUTOFMEMORY));
        Win4Assert ( SUCCEEDED(sc) );
    }

    *pbDstBuf = xsa.Acquire();
    return DBSTATUS_S_OK;
}

//+-------------------------------------------------------------------------
//
//  Member:     COLEDBVariant::_StoreBSTRArray, private
//
//  Synopsis:   Copy BSTR vector to safearray 
//
//  Arguments:  [pbDstBuf]      -- destination buffer
//              [rPool]    -- pool to use for destination buffers
//
//  Returns:    status for copy
//
//  Notes:      Expects the 'this' data type to be VT_BSTR | VT_VECTOR.
//
//  History:    09 Apr 1997     EmilyB      Created
//              09 Jan 1998     VikasMan    Moved from CTableVariant class 
//                                          to here
//
//--------------------------------------------------------------------------

DBSTATUS COLEDBVariant::_StoreBSTRArray(
                                       SAFEARRAY **           pbDstBuf,
                                       PVarAllocator &  rPool) const
{
    if ( 0 == cabstr.cElems )
        return DBSTATUS_S_ISNULL;

    // CLEANCODE - add to PVarAllocator?
    SAFEARRAY * sa = SafeArrayCreateVector(VT_BSTR, 0, cabstr.cElems);
    if (0 == sa)
        THROW(CException(E_OUTOFMEMORY));

    XSafeArray xsa(sa);

    for (LONG lElem = 0; lElem < (LONG)cabstr.cElems; lElem++)
    {
        SCODE sc = SafeArrayPutElement(xsa.Get(), &lElem, cabstr.pElems[lElem]);
        if (E_OUTOFMEMORY == sc)
            THROW(CException(E_OUTOFMEMORY));
        Win4Assert ( SUCCEEDED(sc) );
    }

    *pbDstBuf = xsa.Acquire();

    return DBSTATUS_S_OK;
}

//+-------------------------------------------------------------------------
//
//  Member:     COLEDBVariant::_StoreVariantArray, private
//
//  Synopsis:   Copy variant vector to safearray 
//
//  Arguments:  [pbDstBuf]      -- destination buffer
//              [rPool]    -- pool to use for destination buffers
//
//  Returns:    status for copy
//
//  Notes:      Expects the 'this' data type to be VT_VARIANT | VT_VECTOR.
//
//  History:    09 Apr 1997     EmilyB      Created
//              09 Jan 1998     VikasMan    Moved from CTableVariant class 
//                                          to here
//
//--------------------------------------------------------------------------

DBSTATUS COLEDBVariant::_StoreVariantArray(
                                          SAFEARRAY **           pbDstBuf,
                                          PVarAllocator &  rPool) const
{
    if ( 0 == capropvar.cElems )
        return DBSTATUS_S_ISNULL;

    DBSTATUS dbStatus = DBSTATUS_S_OK;
    DBSTATUS dbStatusRet  = DBSTATUS_S_OK; // error code of last conversion, 
    // or if no errors, DBSTATUS_S code
    // of last item with any trouble converting.

    Win4Assert(vt == (VT_VECTOR | VT_VARIANT));

    // CLEANCODE - add to PVarAllocator?
    SAFEARRAY * sa = SafeArrayCreateVector(VT_VARIANT, 0, capropvar.cElems);
    if (0 == sa)
        THROW(CException(E_OUTOFMEMORY));
    XSafeArray xsa(sa);

    for (LONG lElem = 0; lElem < (LONG)(capropvar.cElems) && StatusSuccess(dbStatus); lElem++)
    {
        COLEDBVariant tblVariant;
        if (IsOAType(capropvar.pElems[lElem].vt))
        {
            ((CTableVariant &)capropvar.pElems[lElem]).Copy(&tblVariant,
                                                            rPool,
                                                            (USHORT)((CTableVariant &)capropvar.pElems[lElem]).VarDataSize(),
                                                            0); 
        }
        else  // convert variant to an OA type
        {
            dbStatus = ((COLEDBVariant &)capropvar.pElems[lElem])._CopyToOAVariant( (VARIANT *)&tblVariant, rPool);
            if (DBSTATUS_S_OK != dbStatus)
                dbStatusRet = dbStatus;  // save last non-zero status

        }
        SCODE sc = SafeArrayPutElement(xsa.Get(), &lElem, (PROPVARIANT *)&tblVariant);
        if (E_OUTOFMEMORY == sc)
            THROW(CException(E_OUTOFMEMORY));
        Win4Assert ( SUCCEEDED(sc) );
    }

    *pbDstBuf = xsa.Acquire();
    return dbStatusRet;
}

//+-------------------------------------------------------------------------
//
//  Member:     COLEDBVariant::_StoreDateArray, private
//
//  Synopsis:   Copy date vector to safearray of dates
//
//  Arguments:  [pbDstBuf]      -- destination buffer
//
//  Returns:    status for copy
//
//  Notes:      Expects the 'this' data type to be VT_DATE | VT_VECTOR.
//
//  History:    09 Apr 1997     EmilyB      Created
//              09 Jan 1998     VikasMan    Moved from CTableVariant class 
//                                          to here
//
//--------------------------------------------------------------------------

DBSTATUS COLEDBVariant::_StoreDateArray(SAFEARRAY **  pbDstBuf) const
{
    if ( 0 == caul.cElems )
        return DBSTATUS_S_ISNULL;

    DBSTATUS dbStatus = DBSTATUS_S_OK;
    DBSTATUS dbStatusRet  = DBSTATUS_S_OK; // error code of last conversion, 
    // or if no errors, DBSTATUS_S code
    // of last item with any trouble converting.

    // CLEANCODE - add to PVarAllocator?
    SAFEARRAY * sa = SafeArrayCreateVector(VT_DATE, 0, caul.cElems);
    if (0 == sa)
        THROW(CException(E_OUTOFMEMORY));
    XSafeArray xsa(sa);


    for (LONG lElem = 0; lElem < (LONG)(caul.cElems) && StatusSuccess(dbStatus); lElem++)
    {
        DATE date;
        dbStatus = _StoreDate( (BYTE *)&date, sizeof(date), VT_DATE, lElem);
        if (DBSTATUS_S_OK != dbStatus)
            dbStatusRet = dbStatus;  // save last non-zero status

        SCODE sc = SafeArrayPutElement(xsa.Get(), &lElem, &date);
        Win4Assert ( SUCCEEDED(sc) );
    }
    if (StatusSuccess(dbStatus))
    {
        *pbDstBuf = xsa.Acquire();
    }
    return dbStatusRet;
}

//+-------------------------------------------------------------------------
//
//  Member:     COLEDBVariant::_StoreDate, private
//
//  Synopsis:   Copy variant date/time data, coerce if possible
//
//  Arguments:  [pbDstBuf]      -- destination buffer
//              [cbDstBuf]      -- size of destination buffer
//              [vtDst]         -- data type of the dest
//              [lElem]         -- element of vector to convert
//
//  Returns:    status for copy
//
//  Notes:      Expects the 'this' data type to be either VT_FILETIME or
//              VT_DATE.  Expects the vtDst to be VT_FILETIME, VT_DATE,
//              DBTYPE_DBDATE, DBTYPE_DBTIME or DBTYPE_DBTIMESTAMP.
//
//  History:    31 Jan 1997     AlanW       Created
//              13 Jan 1998     VikasMan    Moved from CTableVariant class 
//                                          to here
//
//--------------------------------------------------------------------------

DBSTATUS COLEDBVariant::_StoreDate(
                                  BYTE *           pbDstBuf,
                                  DBLENGTH         cbDstBuf,
                                  VARTYPE          vtDst, 
                                  LONG             lElem) const
{
    DBSTATUS DstStatus = DBSTATUS_S_OK;
    SYSTEMTIME stUTC;

    //
    // Convert the input date into a common form: GMT SYSTEMTIME.
    //
    if (VT_DATE == vt)
    {
        if (! VariantTimeToSystemTime(date, &stUTC) )
            return DBSTATUS_E_DATAOVERFLOW;
    }
    else if ((VT_DATE|VT_VECTOR)== vt)
    {
        if (! VariantTimeToSystemTime(cadate.pElems[lElem], &stUTC) )
            return DBSTATUS_E_DATAOVERFLOW;
    }
    else if (VT_FILETIME == vt)
    {
        // do not do local time conversion
        if (! FileTimeToSystemTime((LPFILETIME) &hVal.QuadPart, &stUTC) )
            return DBSTATUS_E_DATAOVERFLOW;
    }
    else if ((VT_FILETIME|VT_VECTOR) == vt)
    {
        // do not do local time conversion
        if (! FileTimeToSystemTime(&cafiletime.pElems[lElem], &stUTC) )
            return DBSTATUS_E_DATAOVERFLOW;
    }
    else
        return DBSTATUS_E_CANTCONVERTVALUE;

    switch (vtDst)
    {
    case VT_DATE:
        DATE dosDate;
        if (! SystemTimeToVariantTime(&stUTC, &dosDate) )
            return DBSTATUS_E_DATAOVERFLOW;

        Win4Assert( cbDstBuf >= sizeof DATE );
        RtlCopyMemory(pbDstBuf, &dosDate, sizeof DATE);
        break;

    case VT_FILETIME:
        FILETIME ftUTC;
        if (! SystemTimeToFileTime(&stUTC, &ftUTC) )
            return DBSTATUS_E_DATAOVERFLOW;

        Win4Assert( cbDstBuf >= sizeof FILETIME );
        RtlCopyMemory(pbDstBuf, &ftUTC, sizeof FILETIME);
        break;

    case DBTYPE_DBTIMESTAMP:
        {
            // does not use local time
            DBTIMESTAMP dbUTC;
            dbUTC.year =  stUTC.wYear;
            dbUTC.month = stUTC.wMonth;
            dbUTC.day =   stUTC.wDay;
            dbUTC.hour =  stUTC.wHour;
            dbUTC.minute = stUTC.wMinute;
            dbUTC.second = stUTC.wSecond;
            dbUTC.fraction = stUTC.wMilliseconds * 1000000;

            Win4Assert( cbDstBuf >= sizeof dbUTC );
            RtlCopyMemory(pbDstBuf, &dbUTC, sizeof dbUTC);
        }
        break;

    case DBTYPE_DBDATE:
        {
            DBDATE dbUTC;
            dbUTC.year =  stUTC.wYear;
            dbUTC.month = stUTC.wMonth;
            dbUTC.day =   stUTC.wDay;

            Win4Assert( cbDstBuf >= sizeof dbUTC );
            RtlCopyMemory(pbDstBuf, &dbUTC, sizeof dbUTC);
        }
        break;

    case DBTYPE_DBTIME:
        {
            DBTIME dbUTC;
            dbUTC.hour =  stUTC.wHour;
            dbUTC.minute = stUTC.wMinute;
            dbUTC.second = stUTC.wSecond;

            Win4Assert( cbDstBuf >= sizeof dbUTC );
            RtlCopyMemory(pbDstBuf, &dbUTC, sizeof dbUTC);
        }
        break;

    default:
        DstStatus = DBSTATUS_E_CANTCONVERTVALUE;
        tbDebugOut(( DEB_WARN,
                     "_StoreDate - Unexpected dest storage type %4x\n",
                     vtDst));
        break;
    }

    return DstStatus;
} //_StoreDate

//+---------------------------------------------------------------------------
//
//  Member:     COLEDBVariant::CanConvertType, static public
//
//  Synopsis:   Indicate whether a type conversion is valid. Uses the OLEDB
//              Data Conversion Library.
//
//  Arguments:  [wFromType]  -- source type
//              [wToType]    -- destination type
//              [xDataConvert] --   OLEDB IDataConvert interface pointer
//
//  Returns:    TRUE if the conversion is available, FALSE otherwise.
//
//  History:    13 Jan 98      VikasMan Created
//
//----------------------------------------------------------------------------

BOOL COLEDBVariant::CanConvertType(
    DBTYPE wFromType,
    DBTYPE wToType,
    XInterface<IDataConvert>& xDataConvert)
{
    if ( xDataConvert.IsNull( ) )
    {
        // use COLEDBVariant's helper function to get the IDataConvert ptr
        if ( !_GetIDataConvert( xDataConvert ) )
        {
            // bail out
            return FALSE;
        }
    }

    SCODE sc = xDataConvert->CanConvert( wFromType, wToType );
    if ( sc != S_OK && sc != S_FALSE )
    {
        QUIETTHROW(CException(sc));   // bad type
    }

    return ( sc == S_OK );
}


//+---------------------------------------------------------------------------
//
//  Member:     COLEDBVariant::_GetIDataConvert, static private
//
//  Synopsis:   Gets the IDataConvert interface
//
//  Arguments:  [xDataConvert] --   OLEDB IDataConvert interface pointer
//
//  Returns:    TRUE if the successful, else FALSE
//
//  Notes:      Make sure thet xDataConvert is null before calling this func.
//
//  History:    13 Jan 98      VikasMan Created
//
//----------------------------------------------------------------------------

inline
BOOL COLEDBVariant::_GetIDataConvert( XInterface<IDataConvert>& xDataConvert )
{
    Win4Assert( xDataConvert.IsNull( ) );

    SCODE sc = CoCreateInstance( CLSID_OLEDB_CONVERSIONLIBRARY,
                                 NULL,
                                 CLSCTX_SERVER,
                                 IID_IDataConvert,
                                 xDataConvert.GetQIPointer( ) );

    if ( FAILED(sc) )
    {
        // for some reason we could not get the IDataConvert interface
        tbDebugOut(( DEB_ERROR,
              "_GetIDataConvert - Couldn't get IDataConvert interface %x\n", sc ));
        return FALSE;
    }

    // Set the OLEDB ver to 2.00

    XInterface<IDCInfo> xIDCInfo;
    DCINFO rgInfo[] = {{DCINFOTYPE_VERSION, {VT_UI4, 0, 0, 0, 0x0200}}};

    sc = xDataConvert->QueryInterface( IID_IDCInfo, xIDCInfo.GetQIPointer( ) );
    if ( SUCCEEDED(sc) )
    {
        sc = xIDCInfo->SetInfo( NUMELEM(rgInfo), rgInfo );
    }

    if ( FAILED(sc) )
    {
        tbDebugOut(( DEB_ERROR,
            "_GetIDataConvert - Can't set OLEDB ver to 2.0. Error: 0x%x\n",
                     sc));
        Win4Assert( ! "Failed to set OLEDB conversion library version!" );
        xDataConvert.Free();
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\dberror.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       DBERROR.CXX
//
//  Contents:   Ole DB Error implementation for CI
//
//  History:    28-Apr-97   KrishnaN  Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <mssql.h>      // parser errors
#include <parserr.h>    // IDS_ values of parser errors (mc generated header)

//#include <initguid.h>
#define DBINITCONSTANTS
#include <msdaguid.h>


#define ERROR_MESSAGE_SIZE 512

extern long           gulcInstances;

// Implementation of CCIOleDBError

//+---------------------------------------------------------------------------
//
//  Member:     CCIOleDBError::CCIOleDBError, public
//
//  Synopsis:   Constructor. Gets the class factory for error object.
//
//  Arguments:  [rUnknown] - Controlling unknown.
//
//  History:    28-Apr-97   KrishnaN   Created
//----------------------------------------------------------------------------
//
CCIOleDBError::CCIOleDBError ( IUnknown & rUnknown, CMutexSem & mutex ) :
    _mutex( mutex ),
    _rUnknown(rUnknown),
    _pErrClassFact (0)
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CCIOleDBError::~CCIOleDBError, public
//
//  Synopsis:   Releases class factory.
//
//  Arguments:
//
//  History:    05-May-97   KrishnaN   Created
//----------------------------------------------------------------------------

CCIOleDBError::~CCIOleDBError()
{
    if ( 0 != _pErrClassFact )
        _pErrClassFact->Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCIOleDBError::QueryInterface, public
//
//  Synopsis:   Supports IID_IUnknown and IID_ISupportErrorInfo
//
//  History:    28-Apr-97   KrishnaN   Created
//----------------------------------------------------------------------------

STDMETHODIMP CCIOleDBError::QueryInterface(REFIID riid, void **ppvObject)
{
    return _rUnknown.QueryInterface(riid, ppvObject);

} //QueryInterface

//+---------------------------------------------------------------------------
//
//  Member:     CCIOleDBError::AddRef, public
//
//  History:    17-Mar-97   KrishnaN   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CCIOleDBError::AddRef()
{
    return _rUnknown.AddRef();
} //AddRef

//+---------------------------------------------------------------------------
//
//  Member:     CCIOleDBError::Release, public
//
//  History:    17-Mar-97   KrishnaN   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CCIOleDBError::Release()
{
    return _rUnknown.Release();

}  //Release

// ISupportErrorInfo method

//+---------------------------------------------------------------------------
//
//  Member:     CCIOleDBError::InterfaceSupportsErrorInfo, public
//
//  Synopsis:   Checks if error reporting on the specified interface is supported
//
//  Arguments:  [riid] - The interface in question
//
//  History:    28-Apr-97   KrishnaN   Created
//----------------------------------------------------------------------------

STDMETHODIMP CCIOleDBError::InterfaceSupportsErrorInfo(REFIID riid)
{
    ULONG ul;

    // See if the interface asked about, actually
    // creates an error object.
    for(ul=0; ul < _cErrInt; ul++)
    {
        if( *(_rgpErrInt[ul]) == riid )
            return S_OK;
    }

    return S_FALSE;
} // InterfaceSupportsErrorInfo


//+---------------------------------------------------------------------------
//
//  Member:     CCIOleDBError::GetErrorInterfaces, private
//
//  Synopsis:   Gets the error interfaces, IErrorInfo and IErrorRecords.
//
//  Arguments:  [ppIErrorInfo]    - Pointer to hold IErrorInfo i/f pointer
//              [ppIErrorRecords] - Pointer to hold IErrorRecords i/f pointer
//
//  History:    28-Apr-97   KrishnaN   Created
//----------------------------------------------------------------------------
//
HRESULT CCIOleDBError::GetErrorInterfaces(IErrorInfo** ppIErrorInfo,
                                          IErrorRecords** ppIErrorRecords)
{
    if (0 == ppIErrorInfo || 0 == ppIErrorRecords)
        return E_INVALIDARG;

    *ppIErrorInfo = 0;
    *ppIErrorRecords = 0;

    if FAILED(_GetErrorClassFact())
        return E_NOINTERFACE;

    //
    // Do we have a class factory on CLSID_EXTENDEDERROR ?
    //
    if (0 == _pErrClassFact)
        return E_NOINTERFACE;

    HRESULT hr = S_OK;

    //
    // Obtain the error object or create a new one if none exists
    //

    GetErrorInfo(0, ppIErrorInfo);
    if ( !*ppIErrorInfo )
    {
        if( FAILED(hr = _pErrClassFact->CreateInstance(NULL,
                        IID_IErrorInfo, (LPVOID*)ppIErrorInfo)) )
            return hr;
    }

    //
    // Obtain the IErrorRecord Interface
    //

    hr = (*ppIErrorInfo)->QueryInterface(IID_IErrorRecords,
                                         (LPVOID*)ppIErrorRecords);

    //
    // On a failure retrieving IErrorRecords, we need to release
    // the IErrorInfo interface
    //

    if( FAILED(hr) && *ppIErrorInfo )
    {
        (*ppIErrorInfo)->Release();
        *ppIErrorInfo = NULL;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCIOleDBError::PostHResult, public
//
//  Synopsis:   Post an HRESULT to be looked up in ole-db sdk's error
//              collection OR CI provided error lookup service.
//
//  Arguments:  [hrErr] - Code returned by the method that caused the error.
//              [piid]  - Interface where the error occurred.
//
//  Returns:    The incoming hrErr is echoed back to simplify error reporting
//              in the calling code. So the caller can simply say something like
//              "return PostHResult(E_INVALIDARG, &IID_ICommand);" instead of:
//              "PostHResult(E_INVALIDARG, &IID_ICommand); return E_INVALIDARG;".
//
//  History:    28-Apr-97   KrishnaN   Created
//----------------------------------------------------------------------------

HRESULT CCIOleDBError::PostHResult(HRESULT hrErr, const IID & refiid)
{
    SCODE hr = S_OK;
    ERRORINFO ErrorInfo;

    //
    // Obtain the error object or create a new one if none exists
    //

    XInterface<IErrorInfo> xErrorInfo;
    XInterface<IErrorRecords> xErrorRecords;
    hr = GetErrorInterfaces((IErrorInfo **)xErrorInfo.GetQIPointer(),
                            (IErrorRecords **)xErrorRecords.GetQIPointer());
    if (FAILED(hr))
        return hrErr;

    //
    // Content Index methods sometimes throw NTSTATUS errors. So check for
    // those and translate them to HRESULTs, just as is done in GetOleError()
    //

    switch (hrErr)
    {
    case STATUS_NO_MEMORY:
    case HRESULT_FROM_WIN32( ERROR_COMMITMENT_LIMIT ):
    case HRESULT_FROM_WIN32( ERROR_NO_SYSTEM_RESOURCES ):
    case STG_E_TOOMANYOPENFILES:
    case STG_E_INSUFFICIENTMEMORY:
    case STATUS_INSUFFICIENT_RESOURCES:
        hrErr = E_OUTOFMEMORY;
        break;

    case HRESULT_FROM_WIN32( ERROR_SEM_TIMEOUT ):
    case HRESULT_FROM_WIN32( ERROR_PIPE_BUSY ):
        hrErr = CI_E_TIMEOUT;
        break;

    case HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ):
        hrErr = CI_E_NOT_RUNNING;
        break;

    case STATUS_NOT_FOUND:
        hrErr = CI_E_NOT_FOUND;
        break;

    case STATUS_INVALID_PARAMETER:
        hrErr = E_INVALIDARG;
        break;

    case STATUS_ACCESS_DENIED:
        hrErr = E_ACCESSDENIED;
        break;

    case STATUS_INVALID_PARAMETER_MIX:
    default:
        break;
    }

    //
    // Check to see if we have already posted this error
    //

    if ( NeedToSetError(hrErr, xErrorInfo.GetPointer(), xErrorRecords.GetPointer()) )
    {
        //
        // Assign static information across each error record added
        //

        ErrorInfo.clsid = CLSID_CI_PROVIDER;
        ErrorInfo.dispid = NULL;
        ErrorInfo.hrError = hrErr;
        ErrorInfo.iid = refiid;
        ErrorInfo.dwMinor = 0;

        //
        // If this is a CI error, then add it with the lookup code IDENTIFIER_CI_ERROR
        // If not, then it must be a Ole DB error or a Windows error. In either
        // case, the default Ole DB sdk error lookup service will handle it. So
        // post non-CI errors with IDENTIFIER_SDK_ERROR lookup id.
        //

        DWORD dwLookupId = IsCIError(hrErr) ? IDENTIFIER_CI_ERROR : IDENTIFIER_SDK_ERROR;

        //
        // Add the record to the Error Service Object
        //

        hr = xErrorRecords->AddErrorRecord(&ErrorInfo, dwLookupId, NULL, NULL, 0);

        //
        // Pass the error object to the Ole Automation DLL
        //

        if (SUCCEEDED(hr))
        {
            hr = SetErrorInfo(0, xErrorInfo.GetPointer());
        }
    }

    //
    // Release the interfaces to transfer ownership to
    // the Ole Automation DLL. This will happen when
    // xErrorInfo and xErrorRecords destruct, at the
    // exit point of this method.
    //

    return hrErr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCIOleDBError::PostHResult, public
//
//  Synopsis:   Post an HRESULT to be looked up in ole-db sdk's error
//              collection OR CI provided error lookup service.
//
//  Arguments:  [e]     - CException object containing error code.
//              [piid]  - Interface where the error occurred.
//
//  Returns:    The incoming hrErr is echoed back to simplify error reporting
//              in the calling code. So the caller can simply say something like
//              "return PostHResult(E_INVALIDARG, &IID_ICommand);" instead of:
//              "PostHResult(E_INVALIDARG, &IID_ICommand); return E_INVALIDARG;".
//
//              This override allows for posting two error records in the case
//              where the SCODE is converted into a less informative error code
//              such as E_FAIL.
//
//  History:    01-04-97    DanLeg      Created
//----------------------------------------------------------------------------

HRESULT CCIOleDBError::PostHResult(CException &e, const IID & refiid)
{
    SCODE sc = e.GetErrorCode();
    SCODE scOLE = GetOleError(e);

    if ( sc != scOLE )
    {
        PostHResult( sc, refiid );
        sc = scOLE;
    }

    PostHResult( sc, refiid );

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCIOleDBError::PostParserError, public
//
//  Synopsis:   This method is used to post static strings and DISPPARAMS to
//              the error objects. The static strings are stored in the resource
//              fork, and thus an id needs to be specified. This method receives
//              in dwIds Monarch's error ids. Needs to change them to our
//              resource ids (dwIdPostError). dwIdPost error is marked with flag
//              (ERR_MONARCH_STATIC), so that GetErrorDescription may take the
//              proper parameters.
//
//              NOTE: If the error object is not our implementation of IID_IErrorInfo,
//              we will not be able to load IErrorRecord and add our records.
//
//  Arguments:  [hrErr]         - HRESULT to associate
//              [dwIds]         - string ID
//              [ppdispparams]  - dispatch params
//
//  Returns:    HResult indicating status
//              S_OK    | Success
//              E_FAIL  | OLE DB Error service object missing
//
//
//  History:    11-03-97    danleg      Created from Monarch
//----------------------------------------------------------------------------

HRESULT CCIOleDBError::PostParserError
    (
    HRESULT hrErr,              //@parm IN | HResult to associate
    DWORD dwIds,                //@parm IN | String id
    DISPPARAMS **ppdispparams   //@parm IN/OUT | Dispatch Params
    )
{
    SCODE               sc = S_OK;
    DWORD               dwIdPostError;

// Translation array from MONSQL values to IDS values
static const UINT s_rgTranslate[] = {
    IDS_MON_PARSE_ERR_2_PARAM,          // MONSQL_PARSE_ERROR w/ 2 parameter
    IDS_MON_PARSE_ERR_1_PARAM,          // MONSQL_PARSE_ERROR w/ 1 parameter
    IDS_MON_ILLEGAL_PASSTHROUGH,        // MONSQL_CITEXTTOSELECTTREE_FAILED
    IDS_MON_DEFAULT_ERROR,              // MONSQL_PARSE_STACK_OVERFLOW
    IDS_MON_DEFAULT_ERROR,              // MONSQL_CANNOT_BACKUP_PARSER
    IDS_MON_SEMI_COLON,                 // MONSQL_SEMI_COLON
    IDS_MON_ORDINAL_OUT_OF_RANGE,       // MONSQL_ORDINAL_OUT_OF_RANGE
    IDS_MON_VIEW_NOT_DEFINED,           // MONSQL_VIEW_NOT_DEFINED
    IDS_MON_BUILTIN_VIEW,               // MONSQL_BUILTIN_VIEW
    IDS_MON_COLUMN_NOT_DEFINED,         // MONSQL_COLUMN_NOT_DEFINED
    IDS_MON_OUT_OF_MEMORY,              // MONSQL_OUT_OF_MEMORY
    IDS_MON_SELECT_STAR,                // MONSQL_SELECT_STAR
    IDS_MON_OR_NOT,                     // MONSQL_OR_NOT
    IDS_MON_CANNOT_CONVERT,             // MONSQL_CANNOT_CONVERT
    IDS_MON_OUT_OF_RANGE,               // MONSQL_OUT_OF_RANGE
    IDS_MON_RELATIVE_INTERVAL,          // MONSQL_RELATIVE_INTERVAL
    IDS_MON_NOT_COLUMN_OF_VIEW,         // MONSQL_NOT_COLUMN_OF_VIEW
    IDS_MON_BUILTIN_PROPERTY,           // MONSQL_BUILTIN_PROPERTY
    IDS_MON_WEIGHT_OUT_OF_RANGE,        // MONSQL_WEIGHT_OUT_OF_RANGE
    IDS_MON_MATCH_STRING,               // MONSQL_MATCH_STRING
    IDS_MON_PROPERTY_NAME_IN_VIEW,      // MONSQL_PROPERTY_NAME_IN_VIEW
    IDS_MON_VIEW_ALREADY_DEFINED,       // MONSQL_VIEW_ALREADY_DEFINED
    IDS_MON_INVALID_CATALOG,            // MONSQL_INVALID_CATALOG
    };


    Win4Assert( ppdispparams );

    // special fixup for MONSQL_PARSE_ERROR
    if ( dwIds == MONSQL_PARSE_ERROR )
    {
        Win4Assert( *ppdispparams && (((*ppdispparams)->cArgs == 1) || ((*ppdispparams)->cArgs == 2)) );

        if ( ((*ppdispparams) != NULL) &&
             ((*ppdispparams)->cArgs == 2) )
        {
            dwIds = 0;  //Change to point to index of 2 parameter parse error
        }
    }

    if ( dwIds < NUMELEM( s_rgTranslate ) )
        dwIdPostError = s_rgTranslate[dwIds];
    else
        dwIdPostError= IDS_MON_DEFAULT_ERROR;

    sc = PostError(hrErr, IID_ICommandText, dwIdPostError, *ppdispparams);

    // free dispparams in case of error
    if ( (*ppdispparams) != NULL )
    {
        if ( ((*ppdispparams)->cArgs > 0) &&
             ((*ppdispparams)->rgvarg!= NULL) )
        {
            for (ULONG ul=0; ul<(*ppdispparams)->cArgs; ul++)
                VariantClear(&((*ppdispparams)->rgvarg[ul]));

            CoTaskMemFree(((*ppdispparams)->rgvarg));
            (*ppdispparams)->rgvarg= NULL;
            (*ppdispparams)->cArgs = 0;
        };

        CoTaskMemFree((*ppdispparams));
        *ppdispparams = NULL;
    }

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CCIOleDBError::PostError, public
//
//  Synopsis:   This method is used to post static strings to the error objects.
//              The static strings are stored in the resource fork, and thus an
//              id needs to be specified.
//
//              @devnote If the error object is not our implementation of
//              IID_IErrorInfo, we will not be able to load IErrorRecord and add
//              our records.
//
//
//  Arguments:  [hrErr]         - HRESULT to associate
//              [refiid]        - IID of interface with error.
//              [dwIds]         - String id
//              [pdispparams]   - Parameters for the static string
//
//  Returns:    HResult indicating status
//              S_OK    | Success
//              E_FAIL  | OLE DB Error service object missing
//
//
//  History:    11-03-97    danleg      Created from Monarch
//----------------------------------------------------------------------------//-----------------------------------------------------------------------------
//
// @mfunc
// @rdesc HResult indicating status
//      @flags S_OK | Success
//      @flags E_FAIL | OLE DB Error service object missing
//
HRESULT CCIOleDBError::PostError
    (
    HRESULT     hrErr,
    const IID & refiid,
    DWORD       dwIds,
    DISPPARAMS* pdispparams
    )
{
    SCODE               sc = S_OK;
    ERRORINFO           ErrorInfo;
    IErrorInfo*         pIErrorInfo = NULL;
    IErrorRecords*      pIErrorRecords = NULL;

    // Obtain the error object or create a new one if none exists
    sc = GetErrorInterfaces( &pIErrorInfo, &pIErrorRecords );
    if ( FAILED(sc) )
        goto EXIT_PROCESS_ERRORS;

    // Assign static information across each error record added
    ErrorInfo.clsid = CLSID_CI_PROVIDER;
    ErrorInfo.hrError = hrErr;
    ErrorInfo.iid = refiid;
    ErrorInfo.dispid = NULL;
    ErrorInfo.dwMinor = 0;

    // Add the record to the Error Service Object
    sc = pIErrorRecords->AddErrorRecord( &ErrorInfo,
                                         dwIds,
                                         pdispparams,
                                         NULL,
                                         0 );
    if ( FAILED(sc) )
        goto EXIT_PROCESS_ERRORS;

    // Pass the error object to the Ole Automation DLL
    sc = SetErrorInfo(0, pIErrorInfo);

    // Release the interfaces to transfer ownership to
    // the Ole Automation DLL
EXIT_PROCESS_ERRORS:
    if ( pIErrorRecords )
        pIErrorRecords->Release();
    if ( pIErrorInfo )
        pIErrorInfo->Release();
    return sc;
}

//-----------------------------------------------------------------------------
//
//  Member:     CCIOleDBError::NeedToSetError - private
//
//  Synopsis:   Determine if error needs to be set.
//
//  Arguments:  [scError]         - Error code to look for
//
//  Returns:    TRUE if the error needs to be set. FALSE, if it already
//              exists and has a valid description string.
//
//  Notes:
//
//  History:    15 Jan 1998     KrishnaN    Created
//              03-01-98        danleg      adopted from ixsso with few changes
//
//-----------------------------------------------------------------------------

BOOL CCIOleDBError::NeedToSetError
    (
    SCODE           scError,
    IErrorInfo *    pErrorInfo,
    IErrorRecords * pErrorRecords
    )
{
    BOOL fFound = FALSE;

    if ( 0 == pErrorInfo )
        return TRUE;

    XBStr xDescription;
    BSTR pDescription = xDescription.GetPointer();

    if (0 == pErrorRecords)
    {
        // No error records. Do we at least have the top level description set?
        // If so, that indicates an automation client called SetErrorInfo before us
        // and we should not overwrite them.
        pErrorInfo->GetDescription(&pDescription);
        fFound = (BOOL)(pDescription != 0);
    }
    else
    {
        ULONG cErrRecords;
        SCODE sc = pErrorRecords->GetRecordCount(&cErrRecords);
        Win4Assert(!fFound);

        // look for the target error code. stop when one is found
        ERRORINFO ErrorInfo;
        for (ULONG i = 0; i < cErrRecords; i++)
        {
            sc = pErrorRecords->GetBasicErrorInfo(i, &ErrorInfo);
            Win4Assert(S_OK == sc);

            if (scError == ErrorInfo.hrError)
            {
                pErrorInfo->GetDescription(&pDescription);
                fFound = (BOOL)(pDescription != 0);
                break;
            }
        }
    }

    if (!fFound)
        return TRUE;

    // we found the error code and it has a description.
    // no need to set this error again, but we have to
    // put this error info back so the client can find it.
    SetErrorInfo(0, pErrorInfo);
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCIOleDBError::_GetErrorClassFact, private
//
//  Synopsis:   Initializes error class factory.
//
//  Returns:    Success code.
//
//  History:    28-Apr-97   KrishnaN   Created
//----------------------------------------------------------------------------

SCODE CCIOleDBError::_GetErrorClassFact()
{
    SCODE sc = S_OK;

    CLock lck( _mutex );
    //
    // If we have failed once, we should not be
    // attempting again. No point in doing that.
    //

    if ( 0 == _pErrClassFact )
    {
        //
        // We don't have an error class factory.
        //

        sc = CoGetClassObject(CLSID_EXTENDEDERRORINFO,
                              CLSCTX_INPROC_SERVER,
                              NULL,
                              IID_IClassFactory,
                              (void **) &_pErrClassFact);

        if (FAILED(sc))
        {
            vqDebugOut((DEB_ITRACE, "No class factory is available "
                                    " for CLSID_EXTENDEDERROR.\n"));
        }
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CErrorLookup::QueryInterface, public
//
//  Synopsis:   Supports IID_IUnknown and IID_IErrorLookup
//
//  History:    28-Apr-97   KrishnaN    Created
//              01-30-98    danleg      E_INVALIDARG if ppvObject is bad
//----------------------------------------------------------------------------

STDMETHODIMP CErrorLookup::QueryInterface(REFIID riid, void **ppvObject)
{
    if ( !ppvObject )
        return E_INVALIDARG;

    if (IID_IUnknown == riid)
    {
        *ppvObject = (void *)((IUnknown *)this);
        AddRef();
        return S_OK;
    }
    else if (IID_IErrorLookup == riid)
    {
        *ppvObject = (void *)((IErrorLookup *)this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

} //QueryInterface

//+---------------------------------------------------------------------------
//
//  Member:     CErrorLookup::AddRef, public
//
//  History:    17-Mar-97   KrishnaN   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CErrorLookup::AddRef()
{
    InterlockedIncrement(&_cRefs);

    return _cRefs;
} //AddRef

//+---------------------------------------------------------------------------
//
//  Member:     CErrorLookup::Release, public
//
//  History:    17-Mar-97   KrishnaN   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CErrorLookup::Release()
{
    Win4Assert(_cRefs > 0);
    LONG refCount = InterlockedDecrement(&_cRefs);

    if ( refCount <= 0 )
        delete this;

    return refCount;

}  //Release

// IErrorLookup methods

//+---------------------------------------------------------------------------
//
//  Member:     CErrorLookup::GetErrorDescription, public
//
//  Synopsis:   Composes the error description for the specifed error.
//
//  Arguments:  [hrError]         - Code returned by the method that caused
//                                  the error.
//              [dwLookupId]      - Provider-specific number of the error.
//              [pdispparams]     - Params of the error. If there are no
//                                  params, this is a NULL pointer.
//              [lcid]            - Locale ID for which to return the
//                                  description and the sources.
//              [pbstrSource]     - Pointer to memory in which to return a
//                                  pointer to the name of the component
//                                  that generated the error.
//              [pbstrDescription]- Pointer to memory in which to return a
//                                  string that describes the error.
//
//  History:    28-Apr-97   KrishnaN   Created
//----------------------------------------------------------------------------

STDMETHODIMP CErrorLookup::GetErrorDescription (HRESULT hrError,
                                                DWORD dwLookupId,
                                                DISPPARAMS* pdispparams,
                                                LCID lcid,
                                                BSTR* pbstrSource,
                                                BSTR* pbstrDescription)
{
    SCODE sc = S_OK;

    // Check the Arguments
    if( 0 == pbstrSource || 0 == pbstrDescription )
        return E_INVALIDARG;

    *pbstrSource = *pbstrDescription = 0;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        //
        // If we encounter IDENTIFIER_SDK_ERROR, make sure we return S_OK;
        //
        BOOL fGetDescription = (IDENTIFIER_SDK_ERROR != dwLookupId);
        BOOL fGetSource = TRUE;

        XBStr xbstrDescription;
        XBStr xbstrSource;


        // We only support lookup of CI generated errors and those handled
        // by the default error lookup service!

        if ( (IDENTIFIER_SDK_ERROR != dwLookupId) && !IsCIError(hrError) )
        {
            if( IsParserError(dwLookupId) )
            {
                hrError = dwLookupId;
            }
            else
            {
                fGetDescription = fGetSource = FALSE;
                sc = DB_E_BADHRESULT;
            }
        }

        if (fGetSource)
        {

            // Fix for bug# 83593: Set source string even when the default
            // lookup service is providing the description

            xbstrSource.SetText( L"Microsoft OLE DB Provider for Indexing Service" );
        }


        if (fGetDescription)
        {
            DWORD_PTR rgdwArguments[2];
            DWORD dwFlags = FORMAT_MESSAGE_FROM_HMODULE;

            if (pdispparams)
            {
                dwFlags |= FORMAT_MESSAGE_ARGUMENT_ARRAY;
                Win4Assert(pdispparams->cArgs == 2 || pdispparams->cArgs == 1 || pdispparams->cArgs == 0);
                for (UINT c=0; c < pdispparams->cArgs; c++)
                {
                    rgdwArguments[c] = (DWORD_PTR)(LPWSTR)pdispparams->rgvarg[c].bstrVal;
                }
            }
            else
            {
                RtlZeroMemory( rgdwArguments, sizeof(rgdwArguments) );
            }

            //
            // Load the error string from the appropriate DLL
            //

            WCHAR wszBuffer[ERROR_MESSAGE_SIZE];

            //
            // Don't pass a specific lang id to FormatMessage since it will
            // fail if there's no message in that language. Instead set
            // the thread locale, which will get FormatMessage to use a search
            // algorithm to find a message of the appropriate language or
            // use a reasonable fallback msg if there's none.
            //

            LCID SaveLCID = GetThreadLocale();
            SetThreadLocale(lcid);

            // CLEANCODE: Since we could have differently named dlls (query.dll
            // or oquery.dll) we should be able to look up in the registry
            // and determine which one to get.  Or just get the module name.

            // All messages are in querymsg.mc, which is in query.dll.

            HMODULE hModule = GetModuleHandle(L"query.dll");

            if (! FormatMessage( dwFlags | FORMAT_MESSAGE_MAX_WIDTH_MASK,
                                 hModule,
                                 hrError,
                                 0,
                                 wszBuffer,
                                 ERROR_MESSAGE_SIZE,
                                 (va_list*) rgdwArguments ) )
            {
                vqDebugOut(( DEB_ERROR, "Format message failed with error 0x%x\n", GetLastError() ));

                swprintf( wszBuffer,
                          L"Unable to format message for error 0x%X caught in Indexing Service.\n",
                          hrError );
            }

            SetThreadLocale(SaveLCID);

            //
            // Convert the loaded string to a BSTR
            //

            xbstrDescription.SetText(wszBuffer);
        }

        *pbstrSource = xbstrSource.GetPointer();
        *pbstrDescription = xbstrDescription.GetPointer();

        xbstrSource.Acquire();
        xbstrDescription.Acquire();
    }
    CATCH( CException, e )
    {
        vqDebugOut(( DEB_ERROR, "Exception %08x in CCIOleDBError::GetErrorDescription \n",
                     e.GetErrorCode() ));
        sc = GetOleError(e);
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CErrorLookup::GetHelpInfo, public
//
//  Synopsis:   Composes the error description for the specifed error.
//
//  Arguments:  [hrError]       - Code returned by the method that caused
//                                the error.
//              [dwLookupId]    - Provider-specific number of the error.
//              [lcid]          - Locale Id for which to return the Help
//                                file path and Context ID.
//              [pbstrHelpFile] - Pointer to memory in which to return a
//                                pointer the fully path of the Help file.
//
//              [pdwHelpContext]- Pointer to memory in which to return the
//                                Help Context ID for the error.
//
//  History:    28-Apr-97   KrishnaN   Created
//----------------------------------------------------------------------------

STDMETHODIMP CErrorLookup::GetHelpInfo (HRESULT hrError,
                                        DWORD dwLookupId,
                                        LCID lcid,
                                        BSTR* pbstrHelpFile,
                                        DWORD* pdwHelpContext)
{
    if ( 0 == pbstrHelpFile || 0 == pdwHelpContext )
        return E_INVALIDARG;

    *pbstrHelpFile = 0;
    *pdwHelpContext = 0;

    //
    // Currently we do not return any help file
    // context or names, so we will just return S_OK
    //

    // NEWFEATURE: We can, if we choose to, return help file
    // and context for the query project.

    if ( lcid != GetUserDefaultLCID() )
        return DB_E_NOLOCALE;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CErrorLookup::ReleaseErrors, public
//
//  Synopsis:   Releases dynamic errors.
//
//  Arguments:  [dwDynamicErrorId] - ID of the dynamic error info to release.
//
//  History:    28-Apr-97   KrishnaN   Created
//----------------------------------------------------------------------------

STDMETHODIMP CErrorLookup::ReleaseErrors (const DWORD dwDynamicErrorId)
{
    Win4Assert(!"Currently we don't support dynamic errors.");

    if (0 == dwDynamicErrorId)
        return E_INVALIDARG;

    //
    // We don't support dynamic errors, so nothing to do.
    //

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CErrorLookupCF::CErrorLookupCF, public
//
//  Synopsis:   CErrorLookup class factory constructor
//
//  History:    25-Mar-1997     KrishnaN   Created
//
//--------------------------------------------------------------------------

CErrorLookupCF::CErrorLookupCF()
        : _cRefs( 1 )
{
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CErrorLookupCF::~CErrorLookupCF
//
//  Synopsis:   Text IFilter class factory constructor
//
//  History:    25-Mar-1997     KrishnaN   Created
//
//--------------------------------------------------------------------------

CErrorLookupCF::~CErrorLookupCF()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CErrorLookupCF::QueryInterface, public
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    25-Mar-1997     KrishnaN    Created
//              01-31-98        danleg      E_INVALIDARG for bad ppvObject
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CErrorLookupCF::QueryInterface( REFIID riid,
                                                    void  ** ppvObject )
{
    if ( 0 == ppvObject )
        return E_INVALIDARG;

    *ppvObject = 0;

    SCODE sc = S_OK;

    if ( IID_IClassFactory == riid )
        *ppvObject = (IUnknown *)(IClassFactory *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)this;
    else if ( IID_ITypeLib == riid )
        sc = E_NOINTERFACE;
    else
        sc = E_NOINTERFACE;

    if ( SUCCEEDED( sc ) )
        AddRef();

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CErrorLookupCF::AddRef, public
//
//  Synopsis:   Increments refcount
//
//  History:    25-Mar-1997     KrishnaN   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CErrorLookupCF::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CErrorLookupCF::Release, public
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    25-Mar-1997     KrishnaN   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CErrorLookupCF::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


//+-------------------------------------------------------------------------
//
//  Method:     CErrorLookupCF::CreateInstance, public
//
//  Synopsis:   Creates new CIndexer object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//  History:    25-Mar-1997     KrishnaN   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CErrorLookupCF::CreateInstance( IUnknown * pUnkOuter,
                                                        REFIID riid,
                                                        void  * * ppvObject )
{
    CErrorLookup *  pIUnk = 0;
    SCODE sc = S_OK;

    TRY
    {
        pIUnk = new CErrorLookup();
        sc = pIUnk->QueryInterface( riid , ppvObject );

        pIUnk->Release();  // Release extra refcount from QueryInterface
    }
    CATCH( CException, e )
    {
        Win4Assert( 0 == pIUnk );
        sc = GetOleError(e);
    }
    END_CATCH

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CErrorLookupCF::LockServer, public
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//  History:    25-Mar-1997     KrishnaN   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CErrorLookupCF::LockServer(BOOL fLock)
{
    if(fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\propdata.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       propdata.cxx
//
//  Contents:   Declaration of static data about property types.
//
//  Classes:    VARNT_DATA - size and allignment constraints of variant types
//              CTableVariant - Wrapper around PROPVARIANT
//
//  Functions:
//
//  History:    25 Jan 1994     AlanW    Created
//
//--------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#include <bigtable.hxx>

#include "propdata.hxx"

//
//  Standard properties known to Query and whose type cannot vary.
//

const PROP_TYPE aPropType [] = {
    { pidWorkId, TYPE_WORKID },
    { pidInvalid, VT_EMPTY },

    // Standard storage properties
    { pidDirectory,     VT_LPWSTR },
    { pidClassId,       VT_CLSID },
    { pidStorageType,   VT_UI4 },
    { pidFileIndex,     VT_UI8 },
    { pidLastChangeUsn, VT_I8 },
    { pidName,          VT_LPWSTR },
    { pidPath,          VT_LPWSTR },
    { pidSize,          VT_I8 },
    { pidAttrib,        VT_UI4 },
    { pidWriteTime,     VT_FILETIME },
    { pidCreateTime,    VT_FILETIME },
    { pidAccessTime,    VT_FILETIME },
//  { pidContents,      ??? },          // No point
    { pidShortName,     VT_LPWSTR },

    // Standard query properties
    { pidRank,          VT_I4 },
//    { pidRankVector,    VT_VECTOR|VT_UI4 },  // no point
    { pidHitCount,      VT_I4 },

    // Special columns for OLE-DB
    { pidBookmark,      VT_EMPTY },     // maps to pidWorkid
    { pidChapter,       VT_I4 },

    { pidRowStatus,     VT_I1 },
    { pidSelf,          VT_EMPTY },     // maps to pidWorkid

    // web-server-specific pids
    { pidVirtualPath,   VT_LPWSTR },
};

const unsigned cPropType = sizeof aPropType / sizeof aPropType[0];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\pathstor.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 2000.
//
//  File:       pathstor.cxx
//
//  Classes:    CSplitPath, CSplitPathCompare, CPathStore
//
//  Functions:
//
//  History:    5-02-95   srikants   Created
//
//----------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#include "pathstor.hxx"
#include "pathcomp.hxx"
#include "tabledbg.hxx"


const WCHAR CSplitPath::_awszPathSep[] = L"\\";

//+---------------------------------------------------------------------------
//
//  Function:   CSplitPath
//
//  Synopsis:   ~ctor for CSplitPath which can be initialized given the
//              "pathId".
//
//  Arguments:  [pathStore] - Reference to the path store.
//              [pathid]    - PathId to be used for initialization.
//
//  History:    5-09-95   srikants   Created
//
//----------------------------------------------------------------------------

CSplitPath::CSplitPath( CPathStore & pathStore, PATHID pathid )
{
    const CShortPath & path = pathStore.GetShortPath( pathid );

    CStringStore & strStore = pathStore.GetStringStore();

    if ( stridInvalid != path.GetParent() )
    {
        _pParent =  strStore.GetCountedWStr( path.GetParent(), _cwcParent );
    }
    else
    {
        _pParent = 0;
        _cwcParent = 0;
    }

    if ( stridInvalid != path.GetFileName() )
    {
        _pFile = strStore.GetCountedWStr( path.GetFileName(), _cwcFile );
    }
    else
    {
        _pFile = 0;
        _cwcParent = 0;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CSplitPath
//
//  Synopsis:   ~ctor - initialized using a NULL terminated path.
//
//  Arguments:  [pwszPath] - The null terminated path.
//
//  History:    5-09-95   srikants   Created
//
//----------------------------------------------------------------------------

CSplitPath::CSplitPath( const WCHAR * pwszPath )
{
    const ULONG cwcPath = wcslen( pwszPath );
    Win4Assert( 0 != cwcPath );

    const WCHAR * pwszFinalComponent = wcsrchr(pwszPath, wchPathSep);

    if ( 0 == pwszFinalComponent )
    {
        _pParent = 0;
        _cwcParent = 0;

        _pFile = pwszPath;
        _cwcFile = cwcPath;
    }
    else
    {
        _pParent = pwszPath;
        _cwcParent = (DWORD)(pwszFinalComponent - pwszPath);

        _cwcFile = cwcPath - ( _cwcParent + 1 );    // skip over the path separator

        if ( 0 != _cwcFile )
        {
            _pFile = pwszPath + ( _cwcParent + 1 );
        }
        else
        {
            //
            // There is a path separator at the end of the string.
            //
            _pFile = 0;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Advance
//
//  Synopsis:   Advances the current pointer by "cwc" characters during
//              comparison of split paths.
//
//  Arguments:  [cwc] - Number of characters to advance by.
//
//  History:    5-09-95   srikants   Created
//
//----------------------------------------------------------------------------

inline void CSplitPath::Advance( ULONG cwc )
{
    Win4Assert( cwc <= _cwcCurr );
    Win4Assert( !IsDone() );

    _cwcCurr -= cwc;

    if ( 0 == _cwcCurr )
    {
        //
        // We must go to the next step.
        //
        switch ( _step )
        {
            case eUseParent:

                if ( 0 != _pParent )
                {
                    _SetUsePathSep();
                }
                else
                {
                    if ( 0 != _pFile )
                    {
                        _SetUseFile();
                    }
                    else
                    {
                        _SetUsePathSep();
                    }
                }

                break;

            case eUsePathSep:

                if ( 0 == _pFile )
                {
                    _SetDone();
                }
                else
                {
                    _SetUseFile();
                }

                break;

            case eUseFile:

                _SetDone();
                break;

            default:
                Win4Assert( !"Impossible Case Condition" );
                break;
        }
    }
    else
    {
        _pCurr += cwc;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetFullPathLen
//
//  Synopsis:   Determines the length of the fully path (in characters)
//              INCLUDING the NULL terminator.
//
//  History:    5-10-95   srikants   Created
//
//----------------------------------------------------------------------------

ULONG CSplitPath::GetFullPathLen() const
{
    ULONG cwcTotal = 0;

    if ( 0 != _cwcParent )
    {
        cwcTotal += (_cwcParent+1); // extra 1 is for the path separator
    }

    cwcTotal += GetFileNameLen();
    Win4Assert( cwcTotal > 1 );

    return cwcTotal;
}

//+---------------------------------------------------------------------------
//
//  Function:   FormFullPath
//
//  Synopsis:   Forms the full path and copies it to pwszPath. It will
//              be NULL terminated.
//
//  Arguments:  [pwszPath] -  OUTPUT buffer for the path
//              [cwcPath]  -  INPUT  max. length of the buffer
//
//  History:    5-10-95   srikants   Created
//
//----------------------------------------------------------------------------

void CSplitPath::FormFullPath( WCHAR * pwszPath, ULONG cwcPath ) const
{
    ULONG cwcParent;

    Win4Assert( cwcPath >= GetFullPathLen() );

    if ( 0 != _pParent )
    {
        cwcParent = _cwcParent;
        RtlCopyMemory( pwszPath, _pParent, cwcParent * sizeof(WCHAR) );
        //
        // Append a backslash after the parent's part.
        //
        Win4Assert( cwcParent < cwcPath );
        pwszPath[cwcParent++] = wchPathSep;  // Append a backslash
        pwszPath += cwcParent;
    }

    ULONG cwcFileName = _cwcFile;
    if ( 0 != _pFile )
    {
        Win4Assert( 0 != _cwcFile );
        RtlCopyMemory( pwszPath, _pFile, _cwcFile * sizeof(WCHAR) );
    }

    pwszPath[cwcFileName] = L'\0';
}

//+---------------------------------------------------------------------------
//
//  Function:   FormFileName
//
//  Synopsis:   Fills just the "FileName" component of the path in the
//              given buffer.
//
//  Arguments:  [pwszPath]    -  OUTPUT buffer - will contain the NULL
//                               terminated filename.
//              [cwcFileName] -  MAXLEN of pwszPath
//
//  History:    5-10-95   srikants   Created
//
//----------------------------------------------------------------------------
inline
void CSplitPath::FormFileName( WCHAR * pwszPath, ULONG cwcFileName ) const
{
    Win4Assert( cwcFileName >= GetFileNameLen() );

    if ( 0 != _pFile )
    {
        RtlCopyMemory( pwszPath, _pFile, sizeof(WCHAR)*_cwcFile );
    }

    pwszPath[_cwcFile] = L'\0';
    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   _Compare
//
//  Synopsis:   Compars the lhs and rhs split paths.
//
//  Returns:    -1, 0, +1 depending on whether lhs <, =, > rhs
//
//  History:    5-23-95   srikants   Created
//
//----------------------------------------------------------------------------

int CSplitPathCompare::_Compare()
{
    int iComp = 0;
    while ( !_IsDone() )
    {
        iComp = _lhs.CompareCurr( _rhs );
        if ( 0 != iComp )
        {
            return iComp;
        }

        ULONG cwcMin = min ( _lhs.GetCurrLen(), _rhs.GetCurrLen() );
        _lhs.Advance( cwcMin );
        _rhs.Advance( cwcMin );
    }

    iComp = _rhs.GetStep() - _lhs.GetStep();
    if ( iComp > 0 )
    {
        iComp = 1;
    }
    else if ( iComp < 0 )
    {
        iComp = -1;
    }

    return iComp;

}

//+---------------------------------------------------------------------------
//
//  Function:   ComparePaths
//
//  Synopsis:   Compares the two paths.
//
//  Returns:    0  if equal
//              -1 if lhs < rhs
//              +1 if lhs > rhs
//
//  History:    5-09-95   srikants   Created
//
//----------------------------------------------------------------------------

int CSplitPathCompare::ComparePaths()
{
    _lhs.InitForPathCompare();
    _rhs.InitForPathCompare();

    return _Compare();

}

//+---------------------------------------------------------------------------
//
//  Function:   CompareNames
//
//  Synopsis:   Compares the "Name" component of two paths.
//
//  Returns:    0  if equal
//              -1 if lhs < rhs
//              +1 if lhs > rhs
//
//  History:    5-11-95   srikants   Created
//
//----------------------------------------------------------------------------

int CSplitPathCompare::CompareNames()
{
    _lhs.InitForNameCompare();
    _rhs.InitForNameCompare();

    return _Compare();
}

//+---------------------------------------------------------------------------
//
//  Function:  Constructor for the CStringStore
//
//  History:    5-03-95   srikants   Created
//
//----------------------------------------------------------------------------

CStringStore::CStringStore() : _pStrHash(0)
{
    _pStrHash = new CCompressedColHashString( FALSE );
                                                // Don't optimize for ascii
    END_CONSTRUCTION( CStringStore );
}

//+---------------------------------------------------------------------------
//
//  Function:   CStringStore
//
//  Synopsis:   Destructor for CStringStore.
//
//  History:    5-03-95   srikants   Created
//
//----------------------------------------------------------------------------

CStringStore::~CStringStore()
{
    delete _pStrHash;
}

//+---------------------------------------------------------------------------
//
//  Function:   Add
//
//  Synopsis:   Adds the NULL terminated pwszStr to the string store.
//
//  Arguments:  [pwszStr] - NULL terminated string to be added.
//
//  Returns:    The STRINGID of the string in the store.
//
//  History:    5-03-95   srikants   Created
//
//----------------------------------------------------------------------------

STRINGID CStringStore::Add( const WCHAR * pwszStr )
{

   ULONG    strId;
   GetValueResult   gvr;
   _pStrHash->AddData( pwszStr, strId, gvr );
    Win4Assert( GVRSuccess == gvr );

    return strId;
}


//+---------------------------------------------------------------------------
//
//  Function:   AddCountedWStr
//
//  Synopsis:   Adds a "counted" string to the store.
//
//  Arguments:  [pwszStr] - Pointer to the string to be added.
//              [cwcStr]  - Number of WCHARS in the string.
//
//  Returns:    The ID of the string.
//
//  History:    5-09-95   srikants   Created
//
//----------------------------------------------------------------------------

STRINGID CStringStore::AddCountedWStr( const WCHAR * pwszStr, ULONG cwcStr )
{

   ULONG    strId;
   GetValueResult   gvr;
   _pStrHash->AddCountedWStr( pwszStr, cwcStr, strId, gvr );
    Win4Assert( GVRSuccess == gvr );

    return strId;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindCountedWStr
//
//  Synopsis:   Finds a "counted" string in the store.
//
//  Arguments:  [pwszStr] - Pointer to the string to be added.
//              [cwcStr]  - Number of WCHARS in the string.
//
//  Returns:    The ID of the string.
//
//  History:    7-17-95   dlee   Created
//
//----------------------------------------------------------------------------

STRINGID CStringStore::FindCountedWStr( const WCHAR * pwszStr, ULONG cwcStr )
{

   if ( 0 != pwszStr )
       return _pStrHash->FindCountedWStr( pwszStr, cwcStr );
   else
       return stridInvalid;
}

//+---------------------------------------------------------------------------
//
//  Function:   StrLen
//
//  Synopsis:   Length of the String associated with strId EXCLUDING the
//              terminating NULL.
//
//  Arguments:  [strId] -  Id of the string whose length is needed.
//
//  Returns:
//
//  History:    5-09-95   srikants   Created
//
//----------------------------------------------------------------------------

ULONG CStringStore::StrLen( STRINGID strId )
{
    return _pStrHash->DataLength( strId )-1;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetCountedWStr
//
//  Synopsis:   Gets the string identified by the "strId.
//
//  Arguments:  [strId]  -  The id of the string to lookup.
//              [cwcStr] -  On output, will have the count of the chars
//                          in the string.
//
//
//  Returns:    Pointer to the string - NOT NULL terminated.
//
//  History:    5-03-95   srikants   Created
//
//----------------------------------------------------------------------------

const WCHAR * CStringStore::GetCountedWStr( STRINGID strId, ULONG & cwcStr )
{
    return _pStrHash->GetCountedWStr( strId, cwcStr );
}

//+---------------------------------------------------------------------------
//
//  Function:   GetString
//
//  Synopsis:   Returns the string identified by the strId.
//
//  Arguments:  [strId]    -  ID of the string to retrieve
//              [pwszPath] -  Pointer to the buffer to hold the string
//              [cwcPath]  -  On input, the max capacity of pwszPath. On
//                            output, it will have the count of the chars
//                            in the string, excluding the terminating NULL.
//
//  Returns:
//
//  Modifies:
//
//  History:    5-09-95   srikants   Created
//
//----------------------------------------------------------------------------

GetValueResult
CStringStore::GetString( STRINGID strId, WCHAR * pwszPath, ULONG & cwcPath )
{
    return _pStrHash->GetData( strId, pwszPath, cwcPath );
}



CPathStore::~CPathStore()
{
}

//+---------------------------------------------------------------------------
//
//  Function:   FindData
//
//  Synopsis:   Finds the given data (pidPath/pidName) in the path store.
//
//  Arguments:  [pVarnt]      - string to look for
//              [rKey]        - returns key
//
//  Returns:    TRUE if found, FALSE otherwise
//
//  History:    7-3-95   dlee   Created
//
//----------------------------------------------------------------------------

BOOL CPathStore::FindData(
    PROPVARIANT const * const pvarnt,
    ULONG &                   rKey )
{
    Win4Assert(pvarnt->vt == VT_LPWSTR);
    WCHAR * pwszData = pvarnt->pwszVal;

    CSplitPath  path( pwszData );

    STRINGID idParent = _strStore.FindCountedWStr( path._pParent, path._cwcParent );
    STRINGID idName = _strStore.FindCountedWStr( path._pFile, path._cwcFile );

    CShortPath shortPath( idParent, idName );

    for ( unsigned i = 0; i < _aShortPath.Count(); i++ )
    {
        if ( shortPath.IsSame( _aShortPath[ i ] ) )
        {
            rKey = i + 1;  // keys are 1-based
            return TRUE;
        }
    }

    return FALSE;
} //FindData

//+---------------------------------------------------------------------------
//
//  Function:   AddData
//
//  Synopsis:   Adds the given data (pidPath/pidName) to the path store.
//
//  Arguments:  [pVarnt]      -
//              [pKey]        -
//              [reIndicator] -
//
//  History:    5-09-95   srikants   Created
//
//----------------------------------------------------------------------------

void CPathStore::AddData( PROPVARIANT const * const pVarnt,
                          ULONG* pKey,
                          GetValueResult& reIndicator
                        )
{
    //
    //  Specially handle the VT_EMPTY case
    //
    if (pVarnt->vt == VT_EMPTY)
    {
        *pKey = 0;
        reIndicator = GVRSuccess;
        return;
    }

    Win4Assert(pVarnt->vt == VT_LPWSTR);
    WCHAR * pwszData = pVarnt->pwszVal;

    *pKey = AddPath( pwszData );
    reIndicator = GVRSuccess;
    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetData
//
//  Synopsis:
//
//  Arguments:  [pVarnt]        -   OUTPUT- Variant to hold the data.
//              [PreferredType] -   UNUSED
//              [ulKey]         -   The "Key" (PathId) of the path to be
//                                  retrieved.
//              [PropId]        -   pidPath/pidWorkId/pidName
//
//  Returns:    GVRSuccess if successful.
//              a GVR* failure code o/w.
//
//  History:    5-09-95   srikants   Created
//
//  Notes:      FreeVariant MUST be called.
//
//----------------------------------------------------------------------------

GetValueResult
CPathStore::GetData( PROPVARIANT * pVarnt,
                     VARTYPE PreferredType,
                     ULONG ulKey,
                     PROPID PropId )
{
    if (ulKey == 0)
    {
        pVarnt->vt = VT_EMPTY;
        return GVRNotAvailable;
    }

    Win4Assert( _IsValid( ulKey ) );

    if ( pidWorkId == PropId )
    {
        pVarnt->vt = VT_I4;
        pVarnt->lVal = (LONG) ulKey;
        return GVRSuccess;
    }

    CSplitPath path( *this, ulKey );

    if ( pidName == PropId )
    {
        ULONG cwcFileName = path.GetFileNameLen();
        Win4Assert( cwcFileName > 0 );

        WCHAR * pwszFileName = _GetPathBuffer( cwcFileName );
        path.FormFileName( pwszFileName, cwcFileName );

        pVarnt->vt = VT_LPWSTR;
        pVarnt->pwszVal = pwszFileName;

        return GVRSuccess;
    }
    else
    {
        Win4Assert( pidPath == PropId );

        //
        //  Retrieve entire path name.
        //
        //  First, compute the required size of the return buffer.
        //
        ULONG  cwcPathLen = path.GetFullPathLen( );
        WCHAR * pwszDest = _GetPathBuffer( cwcPathLen );

        pVarnt->vt = VT_LPWSTR;
        pVarnt->pwszVal = pwszDest;

        path.FormFullPath( pwszDest, cwcPathLen );
        return GVRSuccess;
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   FreeVariant
//
//  Synopsis:   Frees the variant created in the "GetData" call.
//
//  Arguments:  [pVarnt] -  Pointer to the variant to be freed.
//
//  History:    5-09-95   srikants   Created
//
//----------------------------------------------------------------------------

void CPathStore::FreeVariant(PROPVARIANT * pVarnt)
{
    if ( pVarnt->vt != VT_EMPTY && pVarnt->vt != VT_I4 )
    {
        Win4Assert(pVarnt->vt == VT_LPWSTR);
        _strStore.FreeVariant( pVarnt );
        pVarnt->pwszVal = 0;            // To prevent accidental re-use
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   _AddPath
//
//  Synopsis:   Adds the given path to the store.
//
//  Arguments:  [path] -
//
//  Returns:    ID of the path.
//
//  History:    5-23-95   srikants   Created
//
//----------------------------------------------------------------------------

PATHID CPathStore::_AddPath( CSplitPath & path )
{

    STRINGID    idParent = stridInvalid;
    STRINGID    idName = stridInvalid;

    if ( 0 != path._pParent )
    {
        idParent = _strStore.AddCountedWStr( path._pParent, path._cwcParent );
    }

    if ( 0 != path._pFile )
    {
        idName = _strStore.AddCountedWStr( path._pFile, path._cwcFile );
    }

    return _AddEntry( idParent, idName );

}

//+---------------------------------------------------------------------------
//
//  Function:   AddPath
//
//  Synopsis:   Adds the given path to the path store.
//
//  Arguments:  [pwszPath] - Pointer to the path to be added.
//
//  Returns:    An ID for the path.
//
//  History:    5-03-95   srikants   Created
//
//  Notes:      There is NO duplicate detection for paths. A new ID is given
//              everytime this method is called.
//
//----------------------------------------------------------------------------

PATHID CPathStore::AddPath( WCHAR * pwszPath )
{
    Win4Assert( 0 != pwszPath );
    CSplitPath  path( pwszPath );
    PATHID pathId = _AddPath( path );

    tbDebugOut(( DEB_BOOKMARK,
                 "WorkId=0x%8X  Path=%ws\n", pathId, pwszPath ));

    return pathId;
}


//+---------------------------------------------------------------------------
//
//  Function:   AddPath
//
//  Synopsis:   Given a source path store and an id in the source pathstore,
//              this method adds the path from the source pathstore to this
//              store.
//
//  Arguments:  [srcStore]  - Reference to the source path store.
//              [srcPathId] - Id in the source path store.
//
//  Returns:    PATHID for the path added.
//
//  History:    5-23-95   srikants   Created
//
//----------------------------------------------------------------------------

PATHID CPathStore::AddPath( CPathStore & srcStore, PATHID srcPathId )
{

    CSplitPath  srcPath( srcStore, srcPathId );
    return _AddPath( srcPath );
}

//+---------------------------------------------------------------------------
//
//  Function:   PathLen
//
//  Synopsis:   Length of the path (INCLUDING terminating NULL) given the
//              pathid.
//
//  Arguments:  [pathId] -  Id of the path whose length is requested.
//
//  Returns:    Length of the path including terminating null.
//
//  History:    5-03-95   srikants   Created
//
//----------------------------------------------------------------------------

ULONG CPathStore::PathLen( PATHID pathId )
{

    CSplitPath  path( *this, pathId );
    return path.GetFullPathLen();
}

//+---------------------------------------------------------------------------
//
//  Function:   GetPath
//
//  Synopsis:   Given a pathId, it returns the path for that pathid.
//
//  Arguments:  [pathId]  - Id of the path to be retrieved
//              [vtPath]  - Variant to hold the output
//              [cbVarnt] - On Input, the maximum length of the variant.
//                          On output, the actual length of the variant.
//
//  Returns:    GVRSuccess if successful
//              GVRNotEnoughSpace if the length of the variant is less
//              than needed.
//
//  History:    5-08-95   srikants   Created
//
//----------------------------------------------------------------------------

GetValueResult
CPathStore::GetPath( PATHID pathId, PROPVARIANT & vtPath, ULONG & cbVarnt )
{
    CSplitPath  splitPath( *this, pathId );

    const ULONG cbPath = splitPath.GetFullPathLen() * sizeof(WCHAR);
    const ULONG cbHeader = sizeof(PROPVARIANT);
    const ULONG cbTotal = cbHeader + cbPath;

    if ( cbVarnt < cbTotal )
    {
        cbVarnt = cbTotal;
        return GVRNotEnoughSpace;
    }

    const ULONG cwcPath = (cbTotal-cbHeader)/sizeof(WCHAR);

    WCHAR * pwszPath = (WCHAR *) ( ((BYTE*) &vtPath) + cbHeader );
    splitPath.FormFullPath( pwszPath, cwcPath );

    vtPath.vt = VT_LPWSTR;
    vtPath.pwszVal = pwszPath;

    cbVarnt = cbTotal;
    return GVRSuccess;
}

//+---------------------------------------------------------------------------
//
//  Function:   Get
//
//  Synopsis:   Retrieves the path specified by the pathId into a buffer
//              allocated from the dstPool.
//
//  Arguments:  [pathId]  -   Id of the path to be retrieved.
//              [propId]  -   pidName/pidPath
//              [dstPool] -   Pool from which to allocate memory.
//
//  Returns:    Pointer to a WCHAR * containing the requested data
//              (NULL Terminated).
//
//  History:    5-23-95   srikants   Created
//
//----------------------------------------------------------------------------

WCHAR *
CPathStore::Get( PATHID pathId, PROPID propId, PVarAllocator & dstPool )
{
    // summary catalogs can have empty paths

    if ( 0 == pathId )
        return 0;

    CSplitPath  path( *this, pathId );

    WCHAR * pwszDest = 0;

    if ( pidName == propId )
    {
        ULONG cwcFileName = path.GetFileNameLen();
        ULONG cbDst = cwcFileName * sizeof(WCHAR);
        Win4Assert( cwcFileName > 0 );
        pwszDest = (WCHAR *) dstPool.Allocate( cbDst );
        path.FormFileName( pwszDest, cwcFileName );
    }
    else
    {
        Win4Assert( pidPath == propId );

        //
        //  Retrieve entire path name.
        //
        //  First, compute the required size of the return buffer.
        //
        ULONG  cwcPathLen = path.GetFullPathLen();
        Win4Assert( cwcPathLen > 0 );
        ULONG cbDst = cwcPathLen * sizeof(WCHAR);
        pwszDest = (WCHAR *) dstPool.Allocate( cbDst );
        path.FormFullPath( pwszDest, cwcPathLen );
    }

    return pwszDest;
}

//+---------------------------------------------------------------------------
//
//  Function:   _AddEntry
//
//  Synopsis:   Adds an entry consisting of a ParentId and a FileId to the
//              store and returns a PATHID representing this short path.
//
//  Arguments:  [idParent]   - Id of the parent in the path
//              [idFileName] - Id of the file in the path.
//
//  History:    5-10-95   srikants   Created
//
//----------------------------------------------------------------------------

PATHID CPathStore::_AddEntry( STRINGID idParent, STRINGID idFileName )
{
    CShortPath  path( idParent, idFileName );
    _aShortPath.Add( path, _aShortPath.Count() );
    return _aShortPath.Count();
}

//+---------------------------------------------------------------------------
//
//  Function:   Compare
//
//  Synopsis:   Compares two paths given their pathids.
//
//  Arguments:  [pathid1] -
//              [pathid2] -
//              [propId]  -  pidName/pidFile
//
//  History:    5-11-95   srikants   Created
//
//----------------------------------------------------------------------------

int CPathStore::Compare( PATHID pathid1, PATHID pathid2,
                         PROPID propId
                         )
{
    // summary catalogs can have empty paths

    if ( 0 == pathid1 || 0 == pathid2 )
        return pathid1 - pathid2;

    Win4Assert( pidName == propId || pidPath == propId );

    CSplitPath  path1( *this, pathid1 );
    CSplitPath  path2( *this, pathid2 );

    CSplitPathCompare   comp( path1, path2 );

    if ( pidName == propId )
    {
        return comp.CompareNames();
    }
    else
    {
        return comp.ComparePaths();
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   Compare
//
//  Synopsis:   Compares a NULL terminated path with a pathid.
//
//  Arguments:  [pwszPath1] - NULL terminated path.
//              [pathid2]   - Id of the second path.
//              [propId]    - pidName/pidPath
//
//  History:    5-11-95   srikants   Created
//
//----------------------------------------------------------------------------

int CPathStore::Compare( const WCHAR * pwszPath1, PATHID pathid2,
                         PROPID propId )
{
    if ( 0 == pathid2 )
        return 0;

    Win4Assert( pidName == propId || pidPath == propId );

    CSplitPath  path1( pwszPath1 );
    CSplitPath  path2( *this, pathid2 );

    CSplitPathCompare   comp( path1, path2 );

    if ( pidName == propId )
    {
        return comp.CompareNames();
    }
    else
    {
        return comp.ComparePaths();
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Compare
//
//  Synopsis:   Compares a path in the variant form to a pathId.
//
//  Arguments:  [varnt]   -
//              [pathid2] -
//              [propId]  -
//
//  History:    5-11-95   srikants   Created
//
//----------------------------------------------------------------------------

int CPathStore::Compare( PROPVARIANT &varnt, PATHID pathid2,
                         PROPID propId )
{
    Win4Assert( pidName == propId || pidPath == propId );

    Win4Assert( varnt.vt == VT_LPWSTR );
    const WCHAR * pwszPath1 = varnt.pwszVal;

    return Compare( pwszPath1, pathid2, propId );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\regtrans.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       regtrans.cxx
//
//  Contents:   Watch Region Transformer
//
//  Classes:    CRegionTransformer
//
//  History:    20-Jul-95   BartoszM    Created
//
//--------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

#include <seglist.hxx>
#include <wregion.hxx>

#include "tabledbg.hxx"
#include "regtrans.hxx"
#include "tblwindo.hxx"
#include "tputget.hxx"


BOOL CRegionTransformer::Validate()
{

    tbDebugOut(( DEB_REGTRANS, "CRegionTransformer::Validate\n" ));
    DumpState();

    _iFetch = _iFetchBmk + _offFetch;
    if (_cFetch < 0)
    {
        // for negative row count, we swap the start
        // of the fetch region with its end
        _iFetch += _cFetch + 1;
        _cFetch = - _cFetch;
    }

    if  (_pRegion != 0)
    {
        _cWatch = _pRegion->RowCount();

        if (_iFetch < _iWatch)
        {
            _isExtendBackward = TRUE;
        }
        if (_iFetch + _cFetch > _iWatch + _cWatch)
        {
            _isExtendForward = TRUE;
        }

        if ( !_pRegion->IsInit() )
        {
            //
            // BootStrap - creating a watch region for the first time.
            //
            _iWatchNew = _iFetch;
            _cWatchNew = _cFetch;
            _isContiguous = FALSE;
            return TRUE;
        }
        else if (_pRegion->Mode() & DBWATCHMODE_EXTEND)
        {
            return ValidateExtend();
        }
        else if (_pRegion->Mode() & DBWATCHMODE_MOVE)
        {
            return ValidateMove();
        }
        else
        {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL CRegionTransformer::ValidateMove ()
{

    tbDebugOut(( DEB_REGTRANS,
        "CRegionTransformer::ValidateMove\n" ));

    Win4Assert( 0 != _pRegion );

    if (_isExtendForward && _isExtendBackward)
        return FALSE;


    _cWatchNew = _cWatch;

    if (_isExtendForward)
    {
        _iWatchNew = _iFetch + _cFetch - _cWatchNew;
    }
    else
    {
        _iWatchNew = _iFetch;
    }

    // For the new region to be contiguous with the
    // old region we require that the fetch bookmark
    // be within the old region and that there be overlap
    // between the old and the new regions. In any other case
    // the client cannot be sure of contiguity and we are
    // free to skip any buckets between the two regions.

    // Is the Fetch Bookmark inside the watch region?
    if (_iFetchBmk >= _iWatch && _iFetchBmk < _iWatch + _cWatch)
    {
        // Do the regions overlap?
        if  ( _isExtendBackward  && _iWatchNew + _cWatchNew > _iWatch
         ||  !_isExtendBackward  && _iWatchNew < _iWatch + _cWatch )
        {
            _isContiguous = TRUE;
        }
    }

    DumpState();


    if (!_isContiguous && _cFetch != _cWatchNew)
        return FALSE;

//    if ( !_isContiguous && _cFetch > _cWatchNew )
//        return FALSE;

    return TRUE;
}

BOOL CRegionTransformer::ValidateExtend ()
{

    tbDebugOut(( DEB_REGTRANS,
        "CRegionTransformer::ValidateExtend\n" ));

    _iWatchNew = _iWatch;
    _cWatchNew = _cWatch;

    if (_isExtendBackward)
    {
        // is there a gap?
        if (_iFetch + _cFetch < _iWatch)
            return FALSE;

        _iWatchNew = _iFetch;
        _cWatchNew += _iWatch - _iFetch;
    }

    if (_isExtendForward)
    {
        // is there a gap?
        if (_iFetch > _iWatch + _cWatch)
            return FALSE;

        _cWatchNew += _iFetch + _cFetch - (_iWatch + _cWatch);
    }

    _isContiguous = TRUE;

    return TRUE;
}

void CRegionTransformer::Transform (CTableSegList& segList, CWatchList& watchList)
{

    tbDebugOut(( DEB_REGTRANS, "++++++ CRegionTransformer::Transform - Entering \n" ));

    if (!_isContiguous)
    {

        tbDebugOut(( DEB_REGTRANS | DEB_NOCOMPNAME, "Not Contiguous\n" ));

        // Delete old region, create new region
        watchList.ShrinkRegionToZero (_pRegion->Handle());
        watchList.BuildRegion (  _pRegion->Handle(),
                        _pSegmentLowFetch,
                        0,  // NEWFEATURE: no watch regions for chapters
                        ((CTableWindow*)_pSegmentLowFetch)->GetBookMarkAt((ULONG)_offLowFetchInSegment),
                        (LONG) _cWatchNew );
        return;
    }

    tbDebugOut(( DEB_REGTRANS | DEB_NOCOMPNAME,
                    "   Chapter=0x%X \tBookMark=0x%X \tcRows=%d \tSegment=0x%X \n",
                    _pRegion->Chapter(), _pRegion->Bookmark(),
                    _pRegion->RowCount(), _pRegion->Segment() ));
    DumpState();

    Win4Assert( _iWatch >= 0 && _iWatchNew >= 0 );

    CTableSegment* pSegment;
    if (_isExtendBackward)
    {
        pSegment = _pSegmentLowFetch;
    }
    else
    {
        pSegment = _pRegion->Segment();
    }

    // Create a state machine that will transform
    // watch regions window by window

    CDoubleTableSegIter iter (pSegment);

    enum State
    {
        stStart, stInOld, stInNew, stInBoth, stEnd
    };

    State state = stStart;
    CTableWindow* pWindow = iter.GetWindow();
    DBROWCOUNT cRowsInWindow  = pWindow->RowCount();
    BOOL isLast = segList.IsLast(iter);
    DBROWCOUNT  offset = 0;

    DBROWCOUNT  cWatchLeft = _cWatchNew;

    Win4Assert( _cWatchNew >= _cWatch );
    DBROWCOUNT  iBeginInWindow = 0;

    tbDebugOut(( DEB_REGTRANS | DEB_NOCOMPNAME, "Doing State Change\n" ));

    do
    {
        BOOL fAdvance = FALSE;
        switch (state)
        {
            case stStart:

                tbDebugOut(( DEB_REGTRANS | DEB_NOCOMPNAME, "stStart\n" ));

                if (HasNewRegion( offset, cRowsInWindow))
                {
                    iBeginInWindow = _iWatchNew - offset;

                    // NEWFEATURE no watches for chaptered tables
                    _pRegion->Set (0, pWindow->GetBookMarkAt((ULONG) iBeginInWindow), (LONG) _cWatchNew);
                    _pRegion->SetSegment (pWindow);

                    //Win4Assert( pWindow->HasWatch( _pRegion->Handle() ) );

                    state = stInNew;
                }

                if (HasOldRegion( (long) offset, (long) cRowsInWindow))
                {
                    if (state == stInNew)
                        state = stInBoth;
                    else
                        state = stInOld;
                }

                break;
            case stInOld:

                tbDebugOut(( DEB_REGTRANS | DEB_NOCOMPNAME, "stInOld\n" ));

                if (HasNewRegion( offset, cRowsInWindow))
                {
                    iBeginInWindow = _iWatchNew - offset;
                    // NEWFEATURE no watches for chaptered tables
                    _pRegion->Set (0, pWindow->GetBookMarkAt((ULONG)iBeginInWindow), (LONG)_cWatchNew);
                    _pRegion->SetSegment (pWindow);
                    Win4Assert( pWindow->HasWatch( _pRegion->Handle() ) );
                    state = stInBoth;
                }
                else if (HasEndOldRegion(offset, cRowsInWindow))
                {
                    pWindow->DeleteWatch (_pRegion->Handle());
                    state = stEnd;
                }   
                else
                {
                    pWindow->DeleteWatch (_pRegion->Handle());
                    fAdvance = !isLast;
                }

                break;

            case stInNew:
                tbDebugOut(( DEB_REGTRANS | DEB_NOCOMPNAME, "stInNew\n" ));

                if (HasOldRegion(offset, cRowsInWindow))
                {
                    state = stInBoth;
                }
                else if (HasEndNewRegion(offset, cRowsInWindow))
                {
                    cWatchLeft -= pWindow->AddWatch (
                                        _pRegion->Handle(),
                                        (LONG) iBeginInWindow,
                                        (LONG) cWatchLeft,
                                        isLast );
                    // in all subsequent windows the watch
                    // will start at offset zero
                    iBeginInWindow = 0;
                    state = stEnd;
                }
                else
                {
                    Win4Assert( cWatchLeft > 0 );

                    cWatchLeft -= pWindow->AddWatch (
                                        _pRegion->Handle(),
                                        (LONG) iBeginInWindow,
                                        (LONG) cWatchLeft,
                                        isLast );
                    // in all subsequent windows the watch
                    // will start at offset zero
                    iBeginInWindow = 0;
                    fAdvance = !isLast;
                }
                break;
            case stInBoth:

                tbDebugOut(( DEB_REGTRANS | DEB_NOCOMPNAME, "stInBoth\n" ));

                cWatchLeft -= pWindow->ModifyWatch (
                                    _pRegion->Handle(),
                                    (LONG) iBeginInWindow,
                                    (LONG) cWatchLeft,
                                    isLast );

                if ( !isLast )
                {
                    // in all subsequent windows the watch
                    // will start at offset zero
                    iBeginInWindow = 0;
                    fAdvance = TRUE;
                    if (HasEndNewRegion(offset, cRowsInWindow))
                    {
                        state = stInOld;
                    }
                    else
                    {
                        Win4Assert( cWatchLeft > 0 || isLast );
                    }
    
                    if (HasEndOldRegion(offset, cRowsInWindow))
                    {
                        if (state == stInOld)
                        {
                            fAdvance = FALSE;
                            state = stEnd;
                        }
                        else
                        {
                            state = stInNew;
                        }
                    }                    
                }
                else
                {
                    state = stEnd;
                }


                break;
            case stEnd:
                break;
        }

        if ( fAdvance)
        {

            tbDebugOut(( DEB_REGTRANS | DEB_NOCOMPNAME,
                "--- BEFORE ADVANCING offset=%d cRowsInWindow=%d isLast=%d\n",
                offset, cRowsInWindow, isLast ));

            Win4Assert (!isLast);

            offset += cRowsInWindow;

            segList.Advance(iter);
            Win4Assert( iter.GetSegment()->IsWindow() );
            
            pWindow = iter.GetWindow();
            cRowsInWindow  = pWindow->RowCount();

            isLast = segList.IsLast(iter);

            tbDebugOut(( DEB_REGTRANS | DEB_NOCOMPNAME,
                "--- AFTER ADVANCING offset=%d cRowsInWindow=%d isLast=%d\n",
                offset, cRowsInWindow, isLast ));
        }

    } while ( state != stEnd && !segList.AtEnd(iter) );

    tbDebugOut(( DEB_REGTRANS, "------ CRegionTransformer::Transform - Leaving \n" ));

    tbDebugOut(( DEB_REGTRANS | DEB_NOCOMPNAME,
                    "   Chapter=0x%X \tBookMark=0x%X \tcRows=%d \tSegment=0x%X \n",
                    _pRegion->Chapter(), _pRegion->Bookmark(),
                    _pRegion->RowCount(), _pRegion->Segment() ));

    DumpState();

}


//+---------------------------------------------------------------------------
//
//  Function:   MoveOrigin
//
//  Synopsis:   The co-ordinate origin is WRT to the lower of the two:
//              a. Watch Segment
//              b. The "anchor" segment.
//
//              When the "fetch" segment is before this origin, then some of
//              the co-ordinates like the _iWatchNew and _iFetch will be < 0.
//              In-order to have all our co-ordinates always postive, we will
//              the origin to the "fetch" segment.
//
//  Arguments:  [cDelta] - The number of rows to move the origin by.
//              This MUST be -ve.
//
//  History:    9-05-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CRegionTransformer::MoveOrigin( DBROWCOUNT cDelta )
{

    Win4Assert( cDelta < 0 );
    Win4Assert( _iFetch < 0 );
    Win4Assert( _iWatchNew < 0 );

    cDelta = -cDelta;

    Win4Assert( cDelta >= -_iFetch );

    _iWatchNew += cDelta;
    _iWatch += cDelta;
    _iFetch += cDelta;

    Win4Assert( _iWatchNew >= 0 && _iWatch >= 0 && _iFetch >= 0 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegionTransformer::DecrementFetchCount
//
//  Synopsis:
//
//  Arguments:  [rowLocator] -
//              [iter]       -
//              [list]       -
//
//  Returns:
//
//  Modifies:
//
//  History:    7-26-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CRegionTransformer::DecrementFetchCount( CTableRowLocator & rowLocator,
                                              CFwdTableSegIter & iter,
                                              CTableSegList & list )
{

    Win4Assert( list.AtEnd(iter) );

    DBROWCOUNT cDiff = rowLocator.GetBeyondTableCount();

    tbDebugOut(( DEB_REGTRANS,
             "CRegionTransformer::DecrementFetchCount - cDiff %d\n", cDiff ));

    if ( (_cFetch <= 0 && cDiff <= 0) || (_cFetch >= 0  && cDiff >= 0) )
    {
        tbDebugOut(( DEB_REGTRANS, "Beyond End of Table\n" ));
        _cFetch = 0;
    }
    else if ( _cFetch < 0 )
    {
        //
        // We are doing a reverse retrieval of rows. We must decrease the
        // number of rows to be retrieved by the amount we overshot.
        //

        Win4Assert( cDiff > 0 );
        _cFetch += cDiff;

        if ( _cFetch >= 0 )
        {
            _cFetch = 0;
            _cWatchNew = 0;
        }
        else
        {

            Win4Assert( _cWatchNew >= _cFetch );

            Win4Assert( !"The logic here is not clear. Check it properly" );

            rowLocator.SeekAndSetFetchBmk( WORKID_TBLLAST, iter );
            DBROWCOUNT iOffset = (DBROWCOUNT) iter.GetSegment()->RowCount();

            if ( iOffset > 0 )
            {
                iOffset--;
            }
            _iFetch = iOffset;
        }

    }
    else
    {

        Win4Assert( cDiff < 0 );
        Win4Assert( !IsWatched() || _iWatchNew <= 0 );

        _cFetch += cDiff;
        _iWatchNew = 0;

        if ( _cFetch <= 0 )
        {
            _cFetch = 0;
            _cWatchNew = 0;
        }
        else
        {
            Win4Assert( !IsWatched() || _cWatchNew >= _cFetch );
            rowLocator.SeekAndSetFetchBmk( WORKID_TBLFIRST, iter );
        }
    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\rowcomp.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       rowcomp.cxx
//
//  Contents:   Implementation of CRowIndex
//
//  Classes:    CRowCompareVariant
//
//  History:    23 Aug 1994     dlee    Created
//
//  Notes:      All of these routines assume the caller (in this case the
//              table window) is locked, so they don't do their own locking
//              to protect data.
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <bigtable.hxx>
#include <tblalloc.hxx>         // for CFixedVarAllocator
#include <objcur.hxx>
#include <compare.hxx>

#include "tabledbg.hxx"
#include "rowindex.hxx"
#include "rowcomp.hxx"
#include "tblwindo.hxx"
#include "colcompr.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CRowCompareVariant::CRowCompareVariant, public
//
//  Synopsis:   Constructor for comparator object.  Basically just
//              invokes the PropSet comparator.
//
//  Arguments:  [TableWindow]  -- table window object
//
//  History:    29 Aug 1994     dlee   Created
//
//--------------------------------------------------------------------------

CRowCompareVariant::CRowCompareVariant(CTableWindow &TableWindow)
    : _TableWindow(TableWindow),
      _cProps(TableWindow.SortOrder().Count()),
      _aComparator(_cProps),
      _aVar1(_cProps),
      _aVar2(_cProps),
      _apVar1(_cProps),
      _apVar2(_cProps),
      _apColumn(_cProps),
      _aVarFlags1(_cProps),
      _aVarFlags2(_cProps),
      _pPathStore(0),
      _sharedBuf(TableWindow._sharedBuf),
      _xBuffer(),
      _widCached(widInvalid)
{
    //
    // Initialize an array of pointers to the variants, which is what
    // the comparison routine wants (and needs because some variants are
    // larger than a variant -- their out of line data is in the same
    // block after the variant-proper data).
    //
    // Also make an array of sort column data
    //

    for (unsigned i = 0; i < _cProps; i++)
    {
        _aVarFlags1[i] = eNone;
        _aVarFlags2[i] = eNone;

        _apVar1[i] = &(_aVar1[i]);
        _apVar2[i] = &(_aVar2[i]);

        BOOL fFound = FALSE;
        SSortKey Key = _TableWindow.SortOrder().Get( i );
        _apColumn[i] = _TableWindow._Columns.Find( Key.pidColumn, fFound );
        Win4Assert(fFound);
    }

    _InitComparators( _TableWindow.SortOrder() );
} //CRowCompareVariant

//+-------------------------------------------------------------------------
//
//  Member:     CRowCompareVariant::~CRowCompareVariant, public
//
//  Synopsis:   Destructor for comparator object.  Frees allocated variants
//              left around after an exception or those that are buffered
//              for variant set 1.
//
//  History:    12 Sep 1994     dlee   Created
//
//--------------------------------------------------------------------------

CRowCompareVariant::~CRowCompareVariant()
{
    _Cleanup1();
    _Cleanup2();
} //~CRowCompareVariant

//+-------------------------------------------------------------------------
//
//  Member:     CRowCompareVariant::_FreeVariant, private
//
//  Synopsis:   Frees allocated variant depending on its source
//
//  Arguments:  [pColumn]  -- column needed to get compressor
//              [pVar]     -- variant to free
//              [eSource]  -- source of the variant allocation
//
//  History:    12 Sep 1994     dlee   Created
//
//--------------------------------------------------------------------------

inline void CRowCompareVariant::_FreeVariant(
    CTableColumn *  pColumn,
    CTableVariant * pVar,
    EVariantSource  eSource)
{
    switch (eSource)
    {
        case eCompressor :
            (pColumn->GetCompressor())->FreeVariant( pVar );
            break;
        case eNewx :
            delete pVar;
            break;
        case eBuffer:
            _xBuffer.Release();
            break;
        default :
            Win4Assert(! "CRowCompareVariant::_FreeVariant() bad");
            break;
    }
} //_FreeVariant

//+-------------------------------------------------------------------------
//
//  Member:     CRowCompareVariant::_Cleanup1, private
//
//  Synopsis:   Frees allocated variants
//
//  History:    12 Sep 1994     dlee   Created
//
//--------------------------------------------------------------------------

inline void CRowCompareVariant::_Cleanup1()
{
    for (unsigned i = 0; i < _cProps; i++)
    {
        if (eNone != _aVarFlags1[i])
        {
            _FreeVariant( _apColumn[i], _apVar1[i], _aVarFlags1[i] );
            _aVarFlags1[i] = eNone;
            _apVar1[i] = &(_aVar1[i]);
        }
    }
} //_Cleanup1

//+-------------------------------------------------------------------------
//
//  Member:     CRowCompareVariant::_Cleanup2, private
//
//  Synopsis:   Frees allocated variants
//
//  History:    12 Sep 1994     dlee   Created
//
//--------------------------------------------------------------------------

inline void CRowCompareVariant::_Cleanup2()
{
    for (unsigned i = 0; i < _cProps; i++)
    {
        if (eNone != _aVarFlags2[i])
        {
            _FreeVariant( _apColumn[i], _apVar2[i], _aVarFlags2[i] );
            _aVarFlags2[i] = eNone;

            // Don't have to restore this pointer -- never changes for 2

            Win4Assert( _apVar2[i] == &(_aVar2[i]) );
            //_apVar2[i] = &(_aVar2[i]);
        }
    }
} //_Cleanup2

//+-------------------------------------------------------------------------
//
//  Member:     CRowCompareVariant::_MakeVariant, private
//
//  Synopsis:   Makes variants from raw row data.  Variants are needed
//              by the comparator.
//
//  Arguments:  [pColumn] -- column description
//              [pbRow]   -- pointer to raw row data for row (source)
//              [pVar]    -- variant pointer (destination)
//              [rSource] -- source of the variant's allocation,
//                           only touched if not eNone
//
//  History:    1 Sep 1994     dlee   Created
//
//--------------------------------------------------------------------------

void CRowCompareVariant::_MakeVariant(
    CTableColumn *   pColumn,
    BYTE *           pbRow,
    CTableVariant *  pVar,
    EVariantSource & rSource)
{
    pbRow += pColumn->GetValueOffset();

    if (pColumn->IsCompressedCol())
    {
        //
        // Get the compressed data into a variant.  Ignore the return
        // code.  Assume that if GetData() is unable to find data it sets
        // the variant to VT_EMPTY, which the comparator is expecting.
        //

        (pColumn->GetCompressor())->GetData( pVar,
                                             pColumn->GetStoredType(),
                                             pColumn->GetValueSize() ?
                                                 * ((ULONG *) pbRow) : 0,
                                             pColumn->PropId );
        rSource = eCompressor;
    }
    else
    {
        // Create variants from non-compressed data

        Win4Assert( pColumn->IsValueStored() );

        pVar->Init( pColumn->GetStoredType(),
                    pbRow,
                    pColumn->GetValueSize() );

        // Convert out of line data from offset to pointer

        pVar->OffsetsToPointers( _TableWindow._DataAllocator );
    }
} //_MakeVariant

//+-------------------------------------------------------------------------
//
//  Member:     CRowCompareVariant::_MakeVariant, private
//
//  Synopsis:   Makes variants from raw row data.  Variants are needed
//              by the comparator.  Always puts variants in Var1, never
//              in Var2.
//
//  Arguments:  [pColumn]       -- column description
//              [rObject] -- object accessor for variant construction
//              [iProp]         -- index of variant to which data is written
//
//  Notes:      inline -- only called once
//
//  History:    1 Sep 1994     dlee   Created
//
//--------------------------------------------------------------------------

inline void CRowCompareVariant::_MakeVariant(
    CTableColumn *  pColumn,
    CRetriever & rObject,
    unsigned        iProp)
{
    ULONG cbBuf = sizeof CTableVariant;

    GetValueResult eGvr = rObject.GetPropertyValue( pColumn->PropId,
                                                    _apVar1[iProp],
                                                    &cbBuf );

    //
    // If the data won't fit in a normal variant, either use the built-in
    // buffer or allocate a large one which will be freed after the
    // comparison.
    //

    if (eGvr == GVRNotEnoughSpace)
    {
        CTableVariant *pvar;

        if (!_xBuffer.InUse() && maxcbBuffer >= cbBuf)
        {
            if (0 == _xBuffer.GetPointer())
                _xBuffer.Init(maxcbBuffer);
            else
                _xBuffer.AddRef();

            pvar = (CTableVariant *) _xBuffer.GetPointer();
            _aVarFlags1[iProp] = eBuffer;
        }
        else
        {
            pvar = (CTableVariant*) new BYTE[cbBuf];
            _aVarFlags1[iProp] = eNewx;
        }

        eGvr = rObject.GetPropertyValue( pColumn->PropId, pvar, &cbBuf );
        _apVar1[iProp] = pvar;
    }

    if ( GVRNotAvailable == eGvr ||
         GVRSharingViolation == eGvr )
    {
        // No value for this property -- make an empty variant
        _apVar1[iProp]->vt = VT_EMPTY;
    }

    else if ( GVRSuccess != eGvr )
    {
        THROW( CException( CRetriever::NtStatusFromGVR(eGvr)) );
    }

} //_MakeVariant

//+---------------------------------------------------------------------------
//
//  Function:   _InitComparators
//
//  Synopsis:   Initializes the comparators methods for each of the columns
//              which need to be compared.
//
//  Arguments:  [sortSet] - The columns that need to be sorted on.
//
//  History:    5-11-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CRowCompareVariant::_InitComparators( CSortSet const & sortSet )
{
    for ( unsigned i = 0; i < _cProps; i++ )
    {
        _aComparator[i].Init( sortSet.Get(i).dwOrder );

        if ( 0 == _pPathStore && 0 != _apColumn[i]->GetCompressor() )
        {
            _pPathStore = _apColumn[i]->GetCompressor()->GetPathStore();
            if ( 0 != _pPathStore )
            {
                Win4Assert( _apColumn[i]->PropId == pidName ||
                            _apColumn[i]->PropId == pidPath ||
                            _apColumn[i]->PropId == pidWorkId );
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   _GetPathId
//
//  Synopsis:   Returns the "pathId" stored in the row that the path compressor
//              can understand.
//
//  Arguments:  [col]   - The column description.
//              [pbRow] - Row in the window.
//
//  Returns:    PATHID in the row.
//
//  History:    5-11-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

PATHID CRowCompareVariant::_GetPathId( const CTableColumn & col , BYTE * pbRow )
{
    return _TableWindow.RowWorkid( pbRow );
}

//+---------------------------------------------------------------------------
//
//  Function:   _MakeVariant
//
//  Synopsis:   Creates a variant and is optimized to use the sharedBuf
//              if possible.
//
//  Arguments:  [iCol]      -  Index of the column
//              [sharedBuf] -  Global shared buffer
//              [obj]       -  The object retriever
//
//  Returns:    A pointer to the variant (if successful)
//
//  History:    5-22-95   srikants   Created
//
//  Notes:      This is optimized to avoid doing a memory allocation in
//              case the column is bigger than a simple variant. It
//              will use the global shared memory (sharedBuf) if it has
//              been acquired by the caller.
//
//----------------------------------------------------------------------------

// inline
PROPVARIANT * CRowCompareVariant::_MakeVariant( unsigned iCol,
                                            XUseSharedBuffer &sharedBuf,
                                            CRetriever & obj )
{
    PROPVARIANT * pVarnt = 0;

    if ( sharedBuf.IsAcquired() )
    {
        //
        // The shared buffer has been acquired by the caller and so we
        // can use it to get the variant.
        //
        pVarnt = (PROPVARIANT *) sharedBuf.LokGetBuffer();
        ULONG cbBuf = sharedBuf.LokGetSize();
        ULONG propId = _apColumn[iCol]->PropId;

        GetValueResult gvr = obj.GetPropertyValue( propId,
                                                   pVarnt,
                                                   &cbBuf );
        if ( GVRNotEnoughSpace == gvr )
        {
            pVarnt = 0;
        }
        else if ( GVRNotAvailable == gvr ||
                  GVRSharingViolation == gvr )
        {
            // No value for this property -- make an empty variant

            _apVar1[iCol]->vt = VT_EMPTY;
            pVarnt = _apVar1[iCol];
        }
        else if ( GVRSuccess != gvr )
        {
            THROW( CException( CRetriever::NtStatusFromGVR(gvr) ) );
        }
    }

    if ( 0 == pVarnt )
    {
        //
        // Either the sharedBuf was not acquired by the caller or the
        // buffer is not enough to hold the data.
        //
        if ( eNone == _aVarFlags1[iCol] )
        {
            _MakeVariant( _apColumn[iCol], obj, iCol );
        }
        pVarnt = _apVar1[iCol];
    }

    Win4Assert( 0 != pVarnt );
    return pVarnt;
}

//+---------------------------------------------------------------------------
//
//  Function:   _FastCompare
//
//  Synopsis:   A fast comparator for two rows in the window. It does a
//              quick compare on pidWorkId, pidPath and pidName.
//
//  Arguments:  [iCol]   -  Index of the column to be compared.
//              [pbRow1] -  Pointer to the window row 1
//              [pbRow2] -  Pointer to the window row 2
//              [iComp]  -  (OUTPUT) result of comparison.
//
//               0  - if equal
//              +1  - if row1 > row2
//              -1 - if row1 < row2
//
//  Returns:    TRUE if a fast compare was done. FALSE o/w
//
//  History:    5-11-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

// inline
BOOL CRowCompareVariant::_FastCompare( unsigned iCol,
                                       BYTE *pbRow1, BYTE *pbRow2,
                                       int & iComp )
{
    ULONG propId = _apColumn[iCol]->PropId;


    switch ( propId )
    {
        case pidWorkId:
            {
                WORKID widRow1 = _TableWindow.RowWorkid( pbRow1 );
                WORKID widRow2 = _TableWindow.RowWorkid( pbRow2 );
                iComp = widRow1 - widRow2;
            }
            break;

        case pidName:
        case pidPath:

            if ( 0 == _apColumn[iCol]->GetCompressor() )
                return FALSE;

            Win4Assert( _apColumn[iCol]->GetValueSize() == sizeof(PATHID) );

            {
                PATHID pathid1 =  _GetPathId( *_apColumn[iCol], pbRow1 );
                PATHID pathid2 =  _GetPathId( *_apColumn[iCol], pbRow2 );
                iComp = _pPathStore->Compare( pathid1, pathid2, propId );
            }

            break;

        default:
            return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   _FastCompare
//
//  Synopsis:   Same as above except that it compares an object retriever to
//              a row in the window.
//
//  Arguments:  [iCol]   -
//              [obj]    -
//              [pbRow2] -
//              [iComp]  -
//
//  Returns:    TRUE if a fast compare was done; FALSE o/w
//
//  Modifies:
//
//  History:    5-11-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
// inline
BOOL CRowCompareVariant::_FastCompare( unsigned iCol,
                                       CRetriever & obj,
                                       XUseSharedBuffer & sharedBuf,
                                       BYTE * pbRow2,
                                       int & iComp )
{
    ULONG propId = _apColumn[iCol]->PropId;

    switch ( propId )
    {
        case pidWorkId:
            {
                WORKID widRow1 = obj.WorkId();
                WORKID widRow2 = _TableWindow.RowWorkid( pbRow2 );
                iComp = widRow1 - widRow2;
            }
            break;

        case pidName:
        case pidPath:

            if ( 0 == _apColumn[iCol]->GetCompressor() )
                return FALSE;

            Win4Assert( _apColumn[iCol]->GetValueSize() == sizeof(PATHID) );

            {
                PATHID pathid2 =  _GetPathId( *_apColumn[iCol], pbRow2 );
                PROPVARIANT * pVarnt = _MakeVariant( iCol, sharedBuf, obj );
                iComp = _pPathStore->Compare( *pVarnt, pathid2, propId );
            }

            break;

        default:
            return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   Compare
//
//  Synopsis:   Compares two rows in the window.
//
//  Arguments:  [oRow1] -  Offset of row1
//              [oRow2] -  Offset of row2
//
//  Returns:    0 if the rows are the same,
//              positive column # of first column of row1 greater than row2
//              negative column # of first column of row1 less than row2
//
//  History:    5-11-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

int CRowCompareVariant::Compare( TBL_OFF oRow1, TBL_OFF oRow2 )
{

    BYTE *pbRow1 = (BYTE *) _TableWindow.
                            _DataAllocator.FixedPointer( oRow1 );

    BYTE *pbRow2 = (BYTE *) _TableWindow.
                            _DataAllocator.FixedPointer( oRow2 );


    WORKID widRow1 = _TableWindow.RowWorkid( pbRow1 );
    WORKID widRow2 = _TableWindow.RowWorkid( pbRow2 );

    if ( widRow1 != _widCached )
    {
        _Cleanup1();
        _widCached = widRow1;
    }

    int iComp = 0 ;

    for ( unsigned i = 0;  ( 0 == iComp ) && (i < _cProps) ; i++ )
    {
        if ( _FastCompare( i, pbRow1, pbRow2, iComp ) )
        {
            iComp *= _aComparator[i].GetDirMult();
        }
        else
        {
            if ( eNone == _aVarFlags1[i] )
            {
                _MakeVariant( _apColumn[i], pbRow1, _apVar1[i], _aVarFlags1[i] );
            }

            _MakeVariant( _apColumn[i], pbRow2, _apVar2[i], _aVarFlags2[i] );
            iComp = _aComparator[i].Compare( _apVar1[i], _apVar2[i] );
        }
    }

    _Cleanup2();

    if ( 0 == iComp )
        return 0;
    else if ( iComp > 0 )
        return i;
    else
        return - (int) i;
} //Compare

//+---------------------------------------------------------------------------
//
//  Function:   CompareObject
//
//  Synopsis:   Compares an object retriever to a row in the window.
//
//  Arguments:  [obj]   -
//              [oRow2] -
//
//  Returns:
//
//  History:    5-11-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

int CRowCompareVariant::CompareObject( CRetriever & obj , TBL_OFF oRow2 )
{

    BYTE *pbRow2 = (BYTE *) _TableWindow.
                            _DataAllocator.FixedPointer( oRow2 );

    WORKID widRow1 = obj.WorkId();

    if ( widRow1 != _widCached )
    {
        _Cleanup1();
        _widCached = widRow1;
    }

    XUseSharedBuffer    xSharedBuf(_sharedBuf, FALSE);
    if ( !_sharedBuf.IsInUse() )
    {
        xSharedBuf.LokAcquire();
    }

    int iComp = 0;
    for ( unsigned i = 0;  ( 0 == iComp ) && (i < _cProps) ; i++ )
    {
        if ( _FastCompare( i, obj, xSharedBuf, pbRow2, iComp ) )
        {
            iComp *= _aComparator[i].GetDirMult();
        }
        else
        {
            if ( eNone == _aVarFlags1[i] )
            {
                _MakeVariant( _apColumn[i], obj, i );
            }

            _MakeVariant( _apColumn[i], pbRow2, _apVar2[i], _aVarFlags2[i] );
            iComp = _aComparator[i].Compare( _apVar1[i], _apVar2[i] );
        }
    }

    _Cleanup2();

    if ( 0 == iComp )
        return 0;
    else if ( iComp > 0 )
        return i;
    else
        return - (int) i;
} //CompareObject
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\rowbuf.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999.
//
//  File:       rowbuf.cxx
//
//  Contents:   Declaration of the row buffer classes, used for HROW
//              buffering at the interface level.
//
//  Classes:    CRowBuffer
//              CRowBufferSet
//              CDeferredValue
//
//  History:    22 Nov 1994     AlanW   Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <hraccess.hxx>

#include "tabledbg.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CRowBufferSet constructor, public
//
//  Synopsis:   Create a row buffer set
//
//  Arguments:  [fSequential] - if TRUE, sequential rowset; obRowId
//                      is not required.
//              [obRowRefcount] - offset in row data reserved for a
//                      USHORT reference count.
//              [obRowId] - offset in row data of a ULONG row
//                      identifier field, used for bookmarks and HROW
//                      identity tests.
//              [obChaptRefcount] - offset in row data reserved for a
//                      USHORT reference count for chapters.
//              [obChaptId] - offset in row data of a ULONG chapter
//                      identifier field.  0xFFFFFFFF if the rowset is not
//                      chaptered.
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------

CRowBufferSet::CRowBufferSet(
    BOOL        fSequential,
    ULONG       obRowRefcount,
    ULONG       obRowId,
    ULONG       obChaptRefcount,
    ULONG       obChaptId
) :
    _mutex( ),
    _fSequential( fSequential ),
    _obRowRefcount( obRowRefcount ),
    _obRowId( obRowId ),
    _obChaptRefcount( obChaptRefcount ),
    _obChaptId( obChaptId ),
    _cRowBufs( 0 ),
    _iBufHint( 0 ),
    _iRowHint( 0 )
#ifdef _WIN64
    , _ArrayAlloc (FALSE, FALSE, sizeof (void *), 0)
#endif
    #if CIDBG
    , _cHintHits( 0 ),
      _cHintMisses( 0 )
    #endif
{
    // Lots of code in this file assumes the refcount is at offset 0, and
    // occupies a USHORT
    Win4Assert( _obRowRefcount == 0 &&
                sizeof (CRBRefCount) == sizeof (USHORT));

    Win4Assert( _obRowId != 0xFFFFFFFF || fSequential );
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBufferSet::~CRowBufferSet, public
//
//  Synopsis:   Destroy a row buffer set
//
//  Returns:    - nothing -
//
//--------------------------------------------------------------------------


CRowBufferSet::~CRowBufferSet( )
{
    CLock   lock(_mutex);

    #if CIDBG
        tbDebugOut(( DEB_ROWBUF,
                     " hint hits / misses: %d %d\n",
                     _cHintHits,
                     _cHintMisses ));
    #endif

    for (unsigned i = 0; i < Size(); i++) {
        if (Get(i) != 0)
        {
            tbDebugOut(( DEB_WARN,
                "CRowBufferSet::~CRowBufferSet, unreleased row buffer %x\n",
                        Get(i) ));

            delete Acquire(i);
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBufferSet::_FindRowBuffer, private
//
//  Synopsis:   Find a row buffer given an HROW
//
//  Arguments:  [hRow]        - the row to be looked up
//              [riBuf]       - index to the buffer in the buffer set
//              [riRow]       - index to the row in the buffer
//
//  Returns:    CRowBuffer* - pointer to the row buffer if found, 0 otherwise
//
//  Notes:
//
//--------------------------------------------------------------------------

CRowBuffer* CRowBufferSet::_FindRowBuffer(
    HROW        hRow,
    unsigned &  riBuf,
    unsigned &  riRow )
{
    CRowBuffer* pBuffer = 0;
    if (IsHrowRowId())
    {
        // Check the hints.  This assumes that most hrow lookups
        // will be either the same as the last requested hrow, one after the
        // last requested hrow, or one before the last requested row

        if ( _iBufHint < Size() && 0 != ( pBuffer = Get(_iBufHint) ) )
        {
            if ( pBuffer->IsRowOkAndHRow( _iRowHint, hRow ) )
            {
                #if CIDBG
                    _cHintHits++;
                #endif

                riBuf = _iBufHint;
                riRow = _iRowHint;
                return pBuffer;
            }
            else if ( pBuffer->IsRowOkAndHRow( _iRowHint + 1, hRow ) )
            {
                #if CIDBG
                    _cHintHits++;
                #endif

                _iRowHint++;
                riBuf = _iBufHint;
                riRow = _iRowHint;
                return pBuffer;
            }
            else if ( ( _iRowHint > 0 ) &&
                      ( pBuffer->IsRowOkAndHRow( _iRowHint - 1, hRow ) ) )
            {
                #if CIDBG
                    _cHintHits++;
                #endif

                _iRowHint--;
                riBuf = _iBufHint;
                riRow = _iRowHint;
                return pBuffer;
            }
        }

        //  Lookup HROW by row id via a linear search.

        for (riBuf = 0; riBuf < Size(); riBuf++)
        {
            pBuffer = Get(riBuf);

            if ( ( 0 != pBuffer ) &&
                 ( pBuffer->FindHRow( riRow, hRow ) ) )
            {
                #if CIDBG
                    _cHintMisses++;
                #endif

                _iBufHint = riBuf;
                _iRowHint = riRow;
                return pBuffer;
            }
        }

        pBuffer = 0;    // Buffer not found
    }
    else
    {
        //
        //  Row handle contains the buffer and row indices.  Just unpack
        //  them.
        //
        riBuf = ((ULONG) hRow >> 20 & 0xFFF) - 1;        // get buffer index
        riRow = ((ULONG) hRow & 0xFFFFF) - 1;            // get row index
        pBuffer = Get(riBuf);
    }

    return pBuffer;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBufferSet::_FindRowBufferByChapter, private
//
//  Synopsis:   Find a row buffer given an HCHAPTER
//
//  Arguments:  [hChapter] - the chapter to be looked up
//              [riBuf]    - index to the buffer in the buffer set
//              [riRow]    - index to the row in the buffer
//
//  Returns:    CRowBuffer* - pointer to the row buffer if found, 0 otherwise
//
//  Notes:
//
//--------------------------------------------------------------------------

CRowBuffer* CRowBufferSet::_FindRowBufferByChapter(
    HCHAPTER    hChapter,
    unsigned &  riBuf,
    unsigned &  riRow )
{
    CRowBuffer* pBuffer = 0;

    Win4Assert( IsHrowRowId() && _obChaptId != 0xFFFFFFFF );
    Win4Assert( DB_NULL_HCHAPTER != hChapter );

    // Check the hints.  This assumes that most HCHAPTER lookups
    // will be either the same as the last requested HROW, one after the
    // last requested HROW, or one before the last requested HROW.

    if ( _iBufHint < Size() && 0 != ( pBuffer = Get(_iBufHint) ) )
    {
        if ( pBuffer->IsRowOkAndHChapt( _iRowHint, hChapter ) )
        {
            #if CIDBG
                _cHintHits++;
            #endif

            riBuf = _iBufHint;
            riRow = _iRowHint;
            return pBuffer;
        }
        else if ( pBuffer->IsRowOkAndHChapt( _iRowHint + 1, hChapter ) )
        {
            #if CIDBG
                _cHintHits++;
            #endif

            _iRowHint++;
            riBuf = _iBufHint;
            riRow = _iRowHint;
            return pBuffer;
        }
        else if ( ( _iRowHint > 0 ) &&
                  ( pBuffer->IsRowOkAndHChapt( _iRowHint - 1, hChapter ) ) )
        {
            #if CIDBG
                _cHintHits++;
            #endif

            _iRowHint--;
            riBuf = _iBufHint;
            riRow = _iRowHint;
            return pBuffer;
        }
    }

    //  Lookup HCHAPTER via a linear search.

    for (riBuf = 0; riBuf < Size(); riBuf++)
    {
        pBuffer = Get(riBuf);

        if ( ( 0 != pBuffer ) &&
             ( pBuffer->FindHChapter( riRow, hChapter ) ) )
        {
            #if CIDBG
                _cHintMisses++;
            #endif

            // NOTE: row hint not updated for this chapter lookup
            //_iBufHint = riBuf;
            //_iRowHint = riRow;
            return pBuffer;
        }
    }

    return 0;    // Buffer not found
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBufferSet::Add, public
//
//  Synopsis:   Add a row buffer to the set
//
//  Arguments:  [pBuf]    - a smart pointer to the buffer to be added.
//              [fPossibleDuplicateHRows] - TRUE if some of the hrows may be
//                                          duplicated in this buffer
//              [pahRows] - optional pointer to array of row handles to
//                          be returned.
//
//  Returns:    Nothing, thows on error.
//
//  Notes:      Acquires the row buffer if successful
//
//--------------------------------------------------------------------------

VOID CRowBufferSet::Add(
    XPtr<CRowBuffer> & pBuf,
    BOOL               fPossibleDuplicateHRows,
    HROW *             pahRows
) {
    CLock   lock(_mutex);

    tbDebugOut(( DEB_ROWBUF,
            "CRowBufferSet::Add - new row buffer = %x\n",
            pBuf.GetPointer() ));

    unsigned iRowBuf;
    if ( _cRowBufs == Size() )
        iRowBuf = Size();          // There is no free element
    else
    {
        for (iRowBuf = 0; iRowBuf < Size(); iRowBuf++)
        {
            if (Get(iRowBuf) == 0)
                break;              // found a free array element.
        }
    }

#if CIDBG
    if ( iRowBuf == Size() )
    {
        tbDebugOut(( DEB_ROWBUF,
                "CRowBufferSet::Add, growing row buffer array, new entry = %d\n",
                iRowBuf ));
    }
#endif // CIDBG

    pBuf->SetRowIdOffset( _obRowId );
    if ( IsChaptered() )
        pBuf->SetChapterVars( _obChaptId, _obChaptRefcount );

    //
    //  Refcount the rows in the buffer.  If there is no row identifier
    //  in the buffer, generate the HROW from a combination of the
    //  buffer number and the row index within the buffer.
    //  Otherwise, dereference any other occurance of the row, and
    //  collapse the references to the newly fetched row.  Generate
    //  the HROW from the row identifier.
    //
    ULONG hRowGen = (iRowBuf+1) << 20;
    for (unsigned iRow = 0; iRow < pBuf->GetRowCount(); iRow++)
    {
        if (IsHrowRowId())
        {
            HROW hRowId = pBuf->GetRowId(iRow);

            CRBRefCount RowRefCount(0);
            CRBRefCount ChapterRefCount(0);

            if ( _cRowBufs != 0 )
            {
                unsigned iOldBuf = 0, iOldRow = 0;
                CRowBuffer * pOldRowBuf = _FindRowBuffer( hRowId,
                                                          iOldBuf,
                                                          iOldRow );
                
                if (pOldRowBuf)
                {
                    CRBRefCount OldRowRefCount;
                    OldRowRefCount = pOldRowBuf->DereferenceRow( iOldRow );
                    RowRefCount.AddRefs( OldRowRefCount );

                    if ( IsChaptered() )
                    {
                        CRBRefCount & OldChaptRefCount =
                            pOldRowBuf->_GetChaptRefCount(iOldRow);
                        ChapterRefCount.AddRefs( OldChaptRefCount );
                    }

                    if (pOldRowBuf->RefCount() <= 0)
                    {
                        //
                        //  Deleted the last reference to the buffer.  Now free
                        //  it and its location in the array.
                        //
                        pOldRowBuf = Acquire( iOldBuf );
                        delete pOldRowBuf;
                        _cRowBufs--;
                    }
                }
            }

            //
            //  Search for the row handle in the portion of the buffer
            //  already processed.  This should only occur for rows which
            //  were fetched with GetRowsByBookmark.
            //
            //  Chapter refcounts doen't need to be updated in this loop
            //  because the duplicate rows don't add to their ref. counts.
            //
            if ( fPossibleDuplicateHRows )
            {
                for (unsigned iOldRow = 0; iOldRow < iRow; iOldRow++)
                {
                    if ( pBuf->IsRowHRow( iOldRow, hRowId ) )
                    {
                        tbDebugOut(( DEB_ROWBUF,
                                "CRowBufferSet::Add - duplicate row: %x\n",
                                hRowId ));

                        CRBRefCount OldRowRefCount;
                        OldRowRefCount = pBuf->DereferenceRow( iOldRow );
                        RowRefCount.AddRefs( OldRowRefCount );
                        break;
                    }
                }
            }

            pBuf->InitRowRefcount(iRow, RowRefCount);
            if (IsChaptered())
                pBuf->_GetChaptRefCount(iRow).SetRefCount( ChapterRefCount );

            if (pahRows)
            {
                *pahRows++ = hRowId;
            }
        }
        else
        {
            CRBRefCount RowRefCount(0);
            pBuf->InitRowRefcount(iRow, RowRefCount);
            if (pahRows)
            {
                *pahRows++ = (HROW) (++hRowGen);
            }
        }
    }

    CRowBufferArray::Add(pBuf.GetPointer(), iRowBuf);
    pBuf.Acquire();

    _cRowBufs++;       // A row buffer has been added

    return;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBufferSet::Lookup, public
//
//  Synopsis:   Lookup a row by its HROW.  Return data about it.
//
//  Arguments:  [hRow] - handle of row to be looked up
//              [ppColumns] - on return, a description of the row columns
//              [ppbRowData] - on return, points to row data
//
//  Returns:    Reference to the row buffer in which row was found.
//
//  Notes:      THROWs on errors.
//              The row buffer set is locked only while doing the
//              lookup.  According to the spec, it is the responsibility
//              of the consumer to ensure that only one thread will be
//              using any one HROW at any one time.
//
//--------------------------------------------------------------------------

CRowBuffer & CRowBufferSet::Lookup(
    HROW                hRow,
    CTableColumnSet **  ppColumns,
    void **             ppbRowData )
{
    CLock   lock(_mutex);

    unsigned iBuffer, iRow;
    CRowBuffer* pRowBuf = _FindRowBuffer(hRow, iBuffer, iRow);

    if (pRowBuf == 0)
        QUIETTHROW( CException(DB_E_BADROWHANDLE) );

    SCODE sc = pRowBuf->Lookup(iRow, ppColumns, ppbRowData );
    if (FAILED(sc))
        THROW( CException(sc) );

    return *pRowBuf;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBufferSet::_LokAddRefRow, private
//
//  Synopsis:   Reference an individual HROW.
//
//  Arguments:  [hRow] - the handle of the row to be ref. counted
//              [rRefCount] - reference to location where remaining ref.
//                      count will be stored.
//              [rRowStatus] - reference to DBROWSTATUS where status will be
//                      stored.
//
//  Returns:    Nothing
//
//  History:    21 Nov 1995     Alanw       Created
//
//--------------------------------------------------------------------------

void CRowBufferSet::_LokAddRefRow(
    HROW            hRow,
    ULONG &         rRefCount,
    DBROWSTATUS &   rRowStatus
) {
    unsigned iBuffer, iRow;

    rRowStatus = DBROWSTATUS_S_OK;
    rRefCount = 0; 

    CRowBuffer* pRowBuf = _FindRowBuffer(hRow, iBuffer, iRow);

    if (pRowBuf == 0)
    {
        rRowStatus = DBROWSTATUS_E_INVALID;
        return;
    }

    pRowBuf->AddRefRow( hRow, iRow, rRefCount, rRowStatus );
    Win4Assert (pRowBuf->RefCount() > 0);

    return;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBufferSet::AddRefRows, public
//
//  Synopsis:   De-reference an array of HROWs.
//
//  Arguments:  [cRows]   - the number of rows to be ref. counted
//              [rghRows] - the handle of the row to be ref. counted
//              [rgRefCounts] - optional array where remaining row ref.
//                      counts will be stored.
//              [rgRowStatus] -- optional array for status of each row 
//
//  Returns:    Nothing - throws on error
//
//  History:    21 Nov 1995     Alanw       Created
//
//--------------------------------------------------------------------------

void CRowBufferSet::AddRefRows(
    DBCOUNTITEM         cRows,
    const HROW          rghRows [],
    DBREFCOUNT          rgRefCounts[],
    DBROWSTATUS         rgRowStatus[]
) {
    CLock   lock(_mutex);

    ULONG cError = 0;

    if (rghRows == 0 && cRows != 0)
        THROW( CException( E_INVALIDARG ));

    for (unsigned i=0; i<cRows; i++)
    {
        TRY
        {

            ULONG ulRefCount;
            DBROWSTATUS RowStatus;

            _LokAddRefRow(rghRows[i], ulRefCount, RowStatus);
            if (rgRefCounts)
                rgRefCounts[i] = ulRefCount;

            if (rgRowStatus)
                rgRowStatus[i] = RowStatus;

            if (DBROWSTATUS_S_OK != RowStatus)
                cError++;
        }
        CATCH( CException, e )
        {
           if (DB_E_BADROWHANDLE == e.GetErrorCode()) 
           {
              if (rgRowStatus)
                  rgRowStatus[i] = DBROWSTATUS_E_INVALID;

              if (rgRefCounts)
                  rgRefCounts[i] = 0;

              cError++;
           }
           else
           {
              RETHROW();
           }  
        }
        END_CATCH;



    }
    if (cError)
        THROW( CException( (cError==cRows) ? DB_E_ERRORSOCCURRED :
                                             DB_S_ERRORSOCCURRED ));

    return;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBufferSet::_LokReleaseRow, private
//
//  Synopsis:   De-reference an individual HROW.
//
//  Arguments:  [hRow] - the handle of the row to be released
//              [rRefCount] - reference to location where remaining ref.
//                      count will be stored.
//              [rRowStatus] - reference to DBROWSTATUS where status will be
//                      stored.
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------

void CRowBufferSet::_LokReleaseRow(
    HROW            hRow,
    ULONG &         rRefCount,
    DBROWSTATUS &   rRowStatus
) {
    unsigned iBuffer, iRow;
    CRowBuffer* pRowBuf = _FindRowBuffer(hRow, iBuffer, iRow);

    rRowStatus = DBROWSTATUS_S_OK;
    rRefCount = 0;

    if (pRowBuf == 0)
    {
        rRowStatus = DBROWSTATUS_E_INVALID;
        return;
    }

    BOOL fRemoveCopies =
            pRowBuf->ReleaseRow( hRow, iRow, rRefCount, rRowStatus );

    if (pRowBuf->RefCount() <= 0)
    {
        //
        //  Deleted the last reference to the buffer.  Now free it
        //  and its location in the array.
        //
        Win4Assert( pRowBuf == Get( iBuffer ) );
        pRowBuf = Acquire( iBuffer );
        Win4Assert( 0 == Get( iBuffer ) );
        delete pRowBuf;

        _cRowBufs--;      // A row buffer has been removed
    }

    if (fRemoveCopies)
    {
        //
        //  The last reference to a row which also exists in other row
        //  buffers was released.  Finally get rid of the row in the
        //  other buffer(s).
        //
        Win4Assert(IsHrowRowId());

        //  Lookup HROW by row id via a linear search.

        for (unsigned iBuf = Size(); iBuf > 0; iBuf--)
        {
            unsigned iRow;
            CRowBuffer* pBuffer = Get(iBuf-1);

            if ( ( 0 != pBuffer ) &&
                 ( pBuffer->FindHRow( iRow, hRow, TRUE ) ) )
            {
                ULONG cRefs;
                DBROWSTATUS RowStat;

                pBuffer->ReleaseRow( hRow, iRow, cRefs, RowStat );
                if (pBuffer->RefCount() <= 0)
                {
                    //
                    //  Deleted the last reference to the buffer.  Now free it
                    //  and its location in the array.
                    //
                    pBuffer = Acquire( iBuf-1);
                    delete pBuffer;
            
                    _cRowBufs--;      // A row buffer has been removed

                    //
                    // Start scanning buffers again
                    //
                    iBuf = Size() + 1;
                }
            }
        }
    }
    return;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRowBufferSet::ReleaseRows, public
//
//  Synopsis:   De-reference an array of HROWs.
//
//  Arguments:  [cRows]   - the number of rows to be released
//              [rghRows] - the handle of the row to be released
//              [rgRefCounts] - optional array where remaining row ref.
//                      counts will be stored.
//              [rgRowStatus] -- optional array for status of each row 
//
//  Returns:    SCODE - result status, usually one of S_OK,
//                      DB_S_ERRORSOCCURRED, or DB_E_ERRORSOCCURRED
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CRowBufferSet::ReleaseRows(
    DBCOUNTITEM         cRows,
    const HROW          rghRows [],
    DBREFCOUNT          rgRefCounts[],
    DBROWSTATUS         rgRowStatus[]
) {
    CLock   lock(_mutex);

    ULONG cError = 0;

    if (rghRows == 0 && cRows != 0)
        THROW( CException( E_INVALIDARG ));

    for (unsigned i=0; i<cRows; i++)
    {
        TRY
        {
            ULONG ulRefCount;
            DBROWSTATUS RowStatus;

            _LokReleaseRow(rghRows[i], ulRefCount, RowStatus);

            if (rgRefCounts)
                rgRefCounts[i] = ulRefCount;

            if (rgRowStatus)
                rgRowStatus[i] = RowStatus;

            if (DBROWSTATUS_S_OK != RowStatus)
                cError++;
            }
        CATCH( CException, e )
        {
           if (DB_E_BADROWHANDLE == e.GetErrorCode()) 
           {
              if (rgRowStatus)
                  rgRowStatus[i] = DBROWSTATUS_E_INVALID;

              if (rgRefCounts)
                  rgRefCounts[i] = 0;

              cError++;
           }
           else
           {
              RETHROW();
           }  
        }
        END_CATCH;
    }

    SCODE scResult = cError ?
                     ( (cError==cRows) ? DB_E_ERRORSOCCURRED :
                                         DB_S_ERRORSOCCURRED ) :
                     S_OK;

    return scResult;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBufferSet::CheckAllHrowsReleased, public
//
//  Synopsis:   Check that there are no outstanding HROWs.  Used by
//              the sequential rowset to check its strict sequential
//              semantics.
//
//  Arguments:  - none -
//
//  Returns:    Nothing
//
//  Notes:      THROWs DB_E_ROWSNOTRELEASED if any row buffers are
//              still held.
//
//--------------------------------------------------------------------------

VOID CRowBufferSet::CheckAllHrowsReleased( )
{
    CLock   lock(_mutex);

    if ( _cRowBufs != 0 )
    {
        tbDebugOut(( DEB_WARN,
                     "CRowBufferSet::CheckAllHrowsReleased, unreleased row buffer(s)\n" ));

        QUIETTHROW( CException(DB_E_ROWSNOTRELEASED) );
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBufferSet::AddRefChapter, private
//
//  Synopsis:   Reference an individual HCHAPTER.
//
//  Arguments:  [hChapter] - the handle of the Chapter to be ref. counted
//              [pcRefCount] - optional pointer where remaining ref.
//                      count will be stored.
//
//  Returns:    Nothing - throws on error
//
//  History:    16 Mar 1999     Alanw       Created
//
//--------------------------------------------------------------------------

void CRowBufferSet::AddRefChapter(
    HCHAPTER        hChapter,
    ULONG *         pcRefCount
) {
    CLock   lock(_mutex);

    Win4Assert( _obChaptRefcount != 0xFFFFFFFF );
    unsigned iBuffer, iRow;

    CRowBuffer* pRowBuf = _FindRowBufferByChapter(hChapter, iBuffer, iRow);

    if (pRowBuf == 0)
    {
        THROW(CException( DB_E_BADCHAPTER ));
        return;
    }

    ULONG cRefCount = 0; 

    pRowBuf->AddRefChapter( iRow, cRefCount );
    if ( 0 != pcRefCount )
        *pcRefCount = cRefCount;

    return;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBufferSet::ReleaseChapter, private
//
//  Synopsis:   Release an individual HCHAPTER.
//
//  Arguments:  [hChapter] - the handle of the Chapter to be released
//              [pcRefCount] - optional pointer where remaining ref.
//                      count will be stored.
//
//  Returns:    Nothing - throws on error
//
//  History:    16 Mar 1999     Alanw       Created
//
//--------------------------------------------------------------------------

void CRowBufferSet::ReleaseChapter(
    HCHAPTER        hChapter,
    ULONG *         pcRefCount
) {
    CLock   lock(_mutex);

    Win4Assert( _obChaptRefcount != 0xFFFFFFFF );
    unsigned iBuffer, iRow;

    CRowBuffer* pRowBuf = _FindRowBufferByChapter(hChapter, iBuffer, iRow);

    if (pRowBuf == 0)
    {
        THROW(CException( DB_E_BADCHAPTER ));
        return;
    }

    ULONG cRefCount = 0; 

    pRowBuf->ReleaseChapter( iRow, cRefCount );
    if ( 0 != pcRefCount )
        *pcRefCount = cRefCount;

    return;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer constructor, public
//
//  Synopsis:   Create a row buffer
//
//  Arguments:  [rColumns]   - a description of the row columns
//              [cbRowWidth] - row data length per row
//              [cRows]      - number of rows represented in the row data
//              [rAlloc]     - allocator xptr to be acquired
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------

CRowBuffer::CRowBuffer(
    CTableColumnSet& rColumns,
    ULONG cbRowWidth,
    ULONG cRows,
    XPtr<CFixedVarAllocator> & rAlloc
) :
        _cRows( cRows ),
        _cReferences( 0 ),
        _cbRowWidth( cbRowWidth ),
        _Columns( rColumns ),
        _fQuickPROPID(TRUE),
        _pbRowData( rAlloc->FirstRow() ),
        _obRowId( 0 ),
        _Alloc( rAlloc.Acquire() ),
        _aDeferredValues( 0 )
{
    //
    // OPTIMIZATION - See if we can support a quick lookup of PROPIDs.
    //
    for ( unsigned i = 0; i < _Columns.Count(); i++ )
    {
        CTableColumn * pCol = _Columns.Get(i);
        if ( pCol && i != pCol->GetPropId()-1 )
        {
            _fQuickPROPID = FALSE;
            break;
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer destructor, public
//
//  Synopsis:   Destroy a row buffer
//
//+-------------------------------------------------------------------------

CRowBuffer::~CRowBuffer( )
{
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer::_IndexRow, private
//
//  Synopsis:   Find a row in a row buffer given its index
//
//  Arguments:  [iRow] - the index of the row to be looked up
//              [fVerifyRefcnt] - if TRUE, the row's refcount will be
//                      checked for non-zero.
//
//  Returns:    BYTE* - the address of the row's data
//
//  Notes:      Throws DB_E_BADROWHANDLE if the row index is out of
//              range, or if the row is not referenced.
//
//--------------------------------------------------------------------------

BYTE* CRowBuffer::_IndexRow(
    unsigned    iRow,
    int         fVerifyRefcnt ) const
{
    if (iRow >= _cRows)
        QUIETTHROW( CException( DB_E_BADROWHANDLE ) );

    BYTE* pbRow = _pbRowData + (iRow * _cbRowWidth);

    //  Is the row still referenced?
    if ( fVerifyRefcnt &&
         ((CRBRefCount *) (pbRow))->GetRefCount() == 0)
        QUIETTHROW( CException( DB_E_BADROWHANDLE ) );

    return pbRow;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer::_GetRowRefCount, private
//
//  Synopsis:   Return a reference to the refcount of a row.
//
//  Arguments:  [iRow] - the index of the row to be looked up
//
//  Returns:    CRBRefCount& - the address of the row's refcount
//
//  Notes:      Throws DB_E_BADROWHANDLE if the row index is out of
//              range.
//
//--------------------------------------------------------------------------

inline CRBRefCount & CRowBuffer::_GetRowRefCount( unsigned iRow ) const
{
    CRBRefCount * pbRowRefCount = (CRBRefCount *)_IndexRow( iRow, FALSE );

    return *pbRowRefCount;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer::_GetChaptRefCount, private
//
//  Synopsis:   Return a reference to the refcount of a row.
//
//  Arguments:  [iRow] - the index of the row to be looked up
//
//  Returns:    CRBRefCount& - the address of the row's refcount
//
//  Notes:      Throws DB_E_BADROWHANDLE if the row index is out of
//              range.
//
//--------------------------------------------------------------------------

inline CRBRefCount & CRowBuffer::_GetChaptRefCount( unsigned iRow ) const
{
    Win4Assert( _obChaptRefcount != 0xFFFFFFFF );
    CRBRefCount * pbRowRefCount =
        (CRBRefCount *) (_IndexRow( iRow, FALSE ) + _obChaptRefcount);

    return *pbRowRefCount;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer::GetRowId, public
//
//  Synopsis:   Lookup a row's ID.
//
//  Arguments:  [iRow] - index of row to be looked up
//
//  Returns:    HROW - the row's Row ID.
//
//  Notes:      _IndexRow is called without ref. count verification
//              for the case of CRowBufferSet::Add where new buffer
//              has its ref. counts initialized.
//
//--------------------------------------------------------------------------

inline HROW CRowBuffer::GetRowId( unsigned iRow ) const
{
    Win4Assert( _obRowId <= _cbRowWidth - sizeof (ULONG) );
    HROW* phRowId = (HROW *) ( _IndexRow(iRow, FALSE) + _obRowId );
    return *(HROW UNALIGNED *) phRowId;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer::Lookup, public
//
//  Synopsis:   Lookup a row by its HROW.  Return data about it.
//
//  Arguments:  [iRow] - index of row to be looked up
//              [ppColumns] - on return, a description of the row columns
//              [ppbRowData] - on return, points to row data
//              [fValidate] - whether IndexRow should validate the refcount
//
//  Returns:    SCODE - status of lookup, DB_E_BADROWHANDLE for
//                      an HROW that could not be found in the buffer
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CRowBuffer::Lookup(
    unsigned            iRow,
    CTableColumnSet **  ppColumns,
    void **             ppbRowData,
    BOOL                fValidate ) const
{
    *ppbRowData = _IndexRow( iRow, fValidate );
    *ppColumns = &_Columns;

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer::AddRefRow, public
//
//  Synopsis:   Reference an HROW.
//
//  Arguments:  [hRow]       - hrow of row to be ref. counted
//              [iRow]       - the index of the row to be ref. counted
//              [rcRef]      - on return, remaining ref. count
//                             of the row.
//              [rRowStatus] - reference to DBROWSTATUS where status will be
//                             stored.
//
//  Returns:    Nothing - throws DB_E_BADROWHANDLE if row couldn't be
//                      found.
//
//  History:    21 Nov 1995     Alanw       Created
//
//--------------------------------------------------------------------------

void CRowBuffer::AddRefRow(
    HROW            hRow,
    unsigned        iRow,
    ULONG &         rcRef,
    DBROWSTATUS &   rRowStatus
)
{
    CRBRefCount & rRefCount = _GetRowRefCount(iRow);

    if (rRefCount.GetRefCount() == 0)
    {
        rRowStatus = DBROWSTATUS_E_INVALID;
        rcRef = 0;
    }
    else
    {
        rRefCount.IncRefCount();
        rcRef = rRefCount.GetRefCount();
    }
    return;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer::ReleaseRow, public
//
//  Synopsis:   De-reference an HROW.
//
//  Arguments:  [hRow]       - hrow of row to be released
//              [iRow]       - the index of the row to be released
//              [rcRef]      - on return, remaining ref. count
//                             of the row.
//              [rRowStatus] - reference to DBROWSTATUS where status will be
//                             stored.
//
//  Returns:    BOOL -  if TRUE on return, there are copies of the HROW
//                      with byref data.  Delete those as well
//                      since this is the last reference to the HROW.
//
//  Notes:
//
//  History:    20 Feb 1995     Alanw       Added individual row refcounts
//
//--------------------------------------------------------------------------

BOOL CRowBuffer::ReleaseRow(
    HROW            hRow,
    unsigned        iRow,
    ULONG &         rcRef,
    DBROWSTATUS &   rRowStatus
)
{
    BOOL fRemoveCopies = FALSE;
    CRBRefCount & rRefCount = _GetRowRefCount(iRow);

    if ( rRefCount.GetRefCount() == 0 &&
         ! rRefCount.HasByrefData() )
    {
        rRowStatus = DBROWSTATUS_E_INVALID;
        rcRef = 0;
    }
    else
    {
        //
        // This might be a zero ref-count row with the ByrefData bit set.
        //
        if (rRefCount.GetRefCount() > 0)
        {
            rRefCount.DecRefCount();
        }

        if (rRefCount.GetRefCount() == 0)
        {
            if (rRefCount.HasByrefCopy())
                fRemoveCopies = TRUE;

            // Free any deferred values hanging around for this row.
            // Better now than at row buffer destruction time.

            for ( unsigned x = 0; x < _aDeferredValues.Count(); x++ )
            {
                if ( hRow == _aDeferredValues[ x ].GetHRow() )
                {
                    Win4Assert(rRefCount.HasByrefData());
                    _aDeferredValues[ x ].Release();
                }
            }

            _cReferences--;
            CRBRefCount ZeroRefCount(0);
            rRefCount = ZeroRefCount;
        }
        rcRef = rRefCount.GetRefCount();
    }
    return fRemoveCopies;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer::ReferenceChapter, public
//
//  Synopsis:   Reference a chapter handle.  Used by accessors.
//
//  Arguments:  [pbRow] - pointer to the row within the row buffer
//
//  Returns:    Nothing
//
//  History:    17 Mar 1999     Alanw       Created
//
//--------------------------------------------------------------------------

void CRowBuffer::ReferenceChapter(
    BYTE *          pbRow
)
{
    Win4Assert( _obChaptRefcount != 0xFFFFFFFF );
    CRBRefCount & rRefCount = *(CRBRefCount *) (pbRow + _obChaptRefcount);

    Win4Assert( ! rRefCount.HasByrefCopy() &&
                ! rRefCount.HasByrefData() );

    rRefCount.IncRefCount();
    return;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer::AddRefChapter, public
//
//  Synopsis:   Reference a chapter handle
//
//  Arguments:  [iRow]  - the index of the row with chapter to be released
//              [rcRef] - on return, remaining ref. count of the chapter.
//
//  Returns:    Nothing
//
//  History:    17 Mar 1999     Alanw       Created
//
//--------------------------------------------------------------------------

void CRowBuffer::AddRefChapter(
    unsigned        iRow,
    ULONG &         rcRef
)
{
    CRBRefCount & rRefCount = _GetChaptRefCount(iRow);

    Win4Assert( rRefCount.GetRefCount() > 0 &&
                ! rRefCount.HasByrefCopy() &&
                ! rRefCount.HasByrefData() );
    if (rRefCount.GetRefCount() == 0)
    {
        rcRef = 0;
    }
    else
    {
        rRefCount.IncRefCount();
        rcRef = rRefCount.GetRefCount();
    }
    return;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer::ReleaseChapter, public
//
//  Synopsis:   De-reference a chapter handle
//
//  Arguments:  [iRow]  - the index of the row with chapter to be released
//              [rcRef] - on return, remaining ref. count of the chapter.
//
//  Returns:    Nothing
//
//  History:    17 Mar 1999     Alanw       Created
//
//--------------------------------------------------------------------------

void CRowBuffer::ReleaseChapter(
    unsigned        iRow,
    ULONG &         rcRef
)
{
    CRBRefCount & rRefCount = _GetChaptRefCount(iRow);

    if ( rRefCount.GetRefCount() == 0 )
    {
        rcRef = 0;
        THROW( CException( DB_E_BADCHAPTER ) );
    }
    else
    {
        rRefCount.DecRefCount();
        rcRef = rRefCount.GetRefCount();
    }
    return;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer::InitRowRefcount, public
//
//  Synopsis:   Set initial reference count on an HROW.
//
//  Arguments:  [iRow] - the index of the row within the buffer
//              [OtherRefs] - reference count transferred from
//                      another row.
//
//  Returns:    Nothing
//
//  Notes:
//
//  History:    20 Feb 1995     Alanw       Created
//
//--------------------------------------------------------------------------

void CRowBuffer::InitRowRefcount(
    unsigned        iRow,
    CRBRefCount &  OtherRefs
)
{
    CRBRefCount RefCount( OtherRefs.GetRefCount() );
    RefCount.IncRefCount();

    if ( OtherRefs.HasByrefData() || OtherRefs.HasByrefCopy() )
        RefCount.SetByrefCopy();

    CRBRefCount & rRef = _GetRowRefCount(iRow);

    rRef = RefCount;
    _cReferences++;
    return;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer::DereferenceRow, public
//
//  Synopsis:   Remove all references from a row
//
//  Arguments:  [iRow] - the index of the row within the buffer
//
//  Returns:    CRBRefCount - reference count of row
//
//  Notes:      If the client had retrieved a pointer into the rowbuffer,
//              the row stays around with a zero ref. count and will
//              be finally dereferenced when all references to all copies
//              of the row are released.
//
//  History:    22 Mar 1995     Alanw       Created
//
//--------------------------------------------------------------------------

CRBRefCount CRowBuffer::DereferenceRow(
    unsigned        iRow
)
{
    CRBRefCount & rRef = _GetRowRefCount(iRow);
    CRBRefCount OldRef = rRef;
    CRBRefCount NewRef(0);

    Win4Assert(OldRef.GetRefCount() != 0 && _cReferences > 0);

    if ( OldRef.HasByrefData() )
        NewRef.SetByrefData();
    else
        _cReferences--;

    rRef = NewRef;
    return OldRef;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer::FindHRow, public
//
//  Synopsis:   Looks for an hrow in the row buffer and returns its index
//
//  Arguments:  [riRow] - returns the index of hRow's row if found
//              [hRow]  - HROW to be found
//              [fFindByrefData] - if TRUE, zero ref. rows with byref data
//                        are found.
//
//  Returns:    BOOL    - TRUE if found, FALSE otherwise
//
//  History:    16 Aug 1995     dlee       Created
//
//--------------------------------------------------------------------------

BOOL CRowBuffer::FindHRow(
    unsigned & riRow,
    HROW       hRow,
    BOOL       fFindByrefData ) const
{
    BYTE* pbRow = _pbRowData;

    for ( unsigned iRow = 0;
          iRow < GetRowCount();
          iRow++, pbRow += _cbRowWidth )
    {
        // refcount is the first USHORT in each row
        CRBRefCount * pRefCount = (CRBRefCount *) pbRow;

        //
        // HROW == 64 bits on Sundown, but we know HROWs are just
        // workids that fit in a ULONG.
        //

        if ( (ULONG) hRow == ( * (ULONG *) ( pbRow + _obRowId ) ) )
        {
            if ( ( 0 != pRefCount->GetRefCount() ) ||
                 (fFindByrefData && pRefCount->HasByrefData()) )
            {
                riRow = iRow;
                return TRUE;
            }
        }
    }

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer::FindHChapter, public
//
//  Synopsis:   Looks for an HCHAPTER in the row buffer and returns its index
//
//  Arguments:  [riRow] - returns the index of hChapter's row if found
//              [hChapter]  - HCHAPTER to be found
//
//  Returns:    BOOL    - TRUE if found, FALSE otherwise
//
//  History:    17 Mar 1999     AlanW      Created
//              10 Nov 1999     KLam       Changed HCHAPTER cast to CI_TBL_CHAPT
//
//--------------------------------------------------------------------------

BOOL CRowBuffer::FindHChapter( unsigned & riRow, HCHAPTER   hChapter ) const
{
    BYTE* pbRow = _pbRowData;

    Win4Assert( IsChaptered() );
    for ( unsigned iRow = 0;
          iRow < GetRowCount();
          iRow++, pbRow += _cbRowWidth )
    {
        // refcount is the first USHORT in each row
        CRBRefCount * pRefCount = (CRBRefCount *) pbRow;

        if ( hChapter == ( * (CI_TBL_CHAPT *) ( pbRow + _obChaptId ) ) )
        {
            if ( ( 0 != pRefCount->GetRefCount() )
//               || (fFindByrefData && pRefCount->HasByrefData()) 
                )
            {
                riRow = iRow;
                return TRUE;
            }
        }
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDeferredValue::Release, public
//
//  Synopsis:   Frees a deferred value
//
//  History:    4 Aug 1995     dlee       Created
//
//--------------------------------------------------------------------------

void CDeferredValue::Release()
{
    if ( 0 != _hrow )
    {
        PropVariantClear( &_var );
        _hrow = 0;
    }
} //Release
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\rowseek.cxx ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1994-1997, Microsoft Corporation.
//
//  File:       rowseek.cxx
//
//  Contents:   Classes which encapsulate a positioning operation
//              for a table.
//
//  Classes:    CRowSeekDescription
//              CRowSeekNext
//              CRowSeekAt
//              CRowSeekAtRatio
//              CRowSeekByBookmark
//
//  History:    06 Apr 1995     AlanW   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <query.hxx>
#include <sizeser.hxx>

#include "tabledbg.hxx"
#include "rowseek.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CRowSeekDescription::MarshalledSize, public
//
//  Synopsis:   Return Serialized size of a CRowSeekDescription structure
//
//  Arguments:  - none -
//
//  Returns:    unsigned - size in bytes of serialized structure.
//
//  Notes:      The returned size should be the maximum of the serialized
//              size on input and output.  None of the seek descriptions
//              grow on output, so the input size may be larger than the
//              output size.
//
//  History:    02 May 1995     AlanW   Created
//
//----------------------------------------------------------------------------

unsigned
CRowSeekDescription::MarshalledSize(
) const {
    //
    //  Determine the size of the serialized seek description
    //
    CSizeSerStream stmSize;
    Marshall(stmSize);

    return stmSize.Size();
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowSeekDescription::MarshallBase, public
//
//  Synopsis:   Serialize the base CRowSeekDescription structure
//
//  Arguments:  [stm]  -- stream structure is serialized into
//              [eType] -- type descriminator for derived class
//
//  Returns:    nothing
//
//  History:    29 Jan 1995     AlanW   Created
//
//----------------------------------------------------------------------------

void
CRowSeekDescription::MarshallBase(
    PSerStream & stm,
    DWORD eType
) const {
    stm.PutULong(eType);
    stm.PutULong(GetChapter());
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowSeekNext::Marshall, public
//
//  Synopsis:   Serialize a CRowSeekNext structure
//
//  Arguments:  [stm]  -- stream structure is serialized into
//
//  Returns:    nothing
//
//  History:    29 Jan 1995     AlanW   Created
//
//----------------------------------------------------------------------------

void
CRowSeekNext::Marshall(
    PSerStream & stm
) const {
    CRowSeekDescription::MarshallBase( stm, eRowSeekCurrent );
    stm.PutULong(GetSkip());
}


//+---------------------------------------------------------------------------
//
//  Member:     CRowSeekAt::Marshall, public
//
//  Synopsis:   Serialize a CRowSeekAt structure
//
//  Arguments:  [stm]  -- stream structure is serialized into
//
//  Returns:    nothing
//
//  History:    29 Jan 1995     AlanW   Created
//
//----------------------------------------------------------------------------

void
CRowSeekAt::Marshall(
    PSerStream & stm
) const {
    CRowSeekDescription::MarshallBase( stm, eRowSeekAt );

    stm.PutULong(Bmk());
    stm.PutLong(Offset());
    stm.PutULong(ULONG(_hRegion));
}


//+---------------------------------------------------------------------------
//
//  Member:     CRowSeekAtRatio::Marshall, public
//
//  Synopsis:   Serialize a CRowSeekAtRatio structure
//
//  Arguments:  [stm]  -- stream structure is serialized into
//
//  Returns:    nothing
//
//  History:    29 Jan 1995     AlanW   Created
//
//----------------------------------------------------------------------------

void CRowSeekAtRatio::Marshall( PSerStream & stm) const
{
    CRowSeekDescription::MarshallBase( stm, eRowSeekAtRatio );
    stm.PutULong(RatioNumerator());
    stm.PutULong(RatioDenominator());
    stm.PutULong(ULONG(_hRegion));
}


//+---------------------------------------------------------------------------
//
//  Member:     CRowSeekByBookmark::Marshall, public
//
//  Synopsis:   Serialize a CRowSeekByBookmark structure
//
//  Arguments:  [stm]  -- stream structure is serialized into
//
//  Returns:    nothing
//
//  Notes:      When serializing ByBookmarks, we only do bookmarks
//              or statuses, not both.  Only one must exist in the structure.
//
//  History:    29 Jan 1995     AlanW   Created
//
//----------------------------------------------------------------------------

void CRowSeekByBookmark::Marshall(PSerStream & stm) const
{
    Win4Assert(_cBookmarks == 0 || _cValidRet == 0);

    CRowSeekDescription::MarshallBase( stm, eRowSeekByBookmark );

    stm.PutULong(_cBookmarks);
    for (unsigned i = 0; i < _cBookmarks; i++)
        stm.PutULong(_aBookmarks[i]);

    stm.PutULong(_cValidRet);
    for (i = 0; i < _cValidRet; i++)
        stm.PutULong(_ascRet[i]);
}


//+---------------------------------------------------------------------------
//
//  Member:     CRowSeekNext::CRowSeekNext, public
//
//  Synopsis:   DeSerialize a CRowSeekNext structure
//
//  Arguments:  [stm]  -- input stream structure is read from
//              [iVersion]  -- input stream version
//
//  Returns:    nothing
//
//  History:    06 Apr 1995     AlanW   Created
//
//----------------------------------------------------------------------------

CRowSeekNext::CRowSeekNext( PDeSerStream & stm, int iVersion ) :
    CRowSeekDescription( eRowSeekCurrent, 0 )
{
    SetChapter( stm.GetULong() );
    SetSkip( stm.GetULong() );
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowSeekAt::CRowSeekAt, public
//
//  Synopsis:   DeSerialize a CRowSeekAt structure
//
//  Arguments:  [stm]  -- input stream structure is read from
//
//  Returns:    nothing
//
//  History:    06 Apr 1995     AlanW   Created
//
//----------------------------------------------------------------------------

CRowSeekAt::CRowSeekAt( PDeSerStream & stm, int iVersion ) :
    CRowSeekDescription( eRowSeekAt, 0 )
{
    SetChapter( stm.GetULong() );
    _bmkOffset = stm.GetULong();
    _cRowsOffset = stm.GetLong();
    _hRegion = (HWATCHREGION) stm.GetULong();
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowSeekAtRatio::CRowSeekAtRatio, public
//
//  Synopsis:   DeSerialize a CRowSeekAtRatio structure
//
//  Arguments:  [stm]  -- input stream structure is read from
//
//  Returns:    nothing
//
//  History:    06 Apr 1995     AlanW   Created
//
//----------------------------------------------------------------------------

CRowSeekAtRatio::CRowSeekAtRatio( PDeSerStream & stm, int iVersion ) :
    CRowSeekDescription( eRowSeekAtRatio, 0 )
{
    SetChapter( stm.GetULong() );
    _ulNumerator = stm.GetULong();
    _ulDenominator = stm.GetULong();
    _hRegion = (HWATCHREGION) stm.GetULong();
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowSeekByBookmark::CRowSeekByBookmark, public
//
//  Synopsis:   DeSerialize a CRowSeekByBookmark structure
//
//  Arguments:  [stm]  -- input stream structure is read from
//
//  Returns:    nothing
//
//  History:    06 Apr 1995     AlanW   Created
//
//----------------------------------------------------------------------------

CRowSeekByBookmark::CRowSeekByBookmark( PDeSerStream & stm, int iVersion ) :
    CRowSeekDescription( eRowSeekByBookmark, 0 ),
    _aBookmarks( 0 ),
    _ascRet( 0 )
{
    SetChapter( stm.GetULong() );

    _cBookmarks = stm.GetULong();
    if (_cBookmarks)
    {
        // Protect agains unreasonable requests, which probably are attacks

        if ( _cBookmarks >= 65536 )
            THROW( CException( E_INVALIDARG ) );

        _aBookmarks = new CI_TBL_BMK [ _cBookmarks ];

        for (unsigned i = 0; i < _cBookmarks; i++)
            _aBookmarks[i] = stm.GetULong();
    }

    _maxRet = _cValidRet = stm.GetULong();

    if (_cValidRet)
    {
        // Protect against unreasonable requests, which probably are attacks

        if ( _cValidRet >= 65536 )
            THROW( CException( E_INVALIDARG ) );

        _ascRet = new SCODE [ _cValidRet ];

        for (unsigned i = 0; i < _cValidRet; i++)
            _ascRet[i] = stm.GetULong();
    }

    //
    // We don't expect both bookmarks and statuses.
    //
    Win4Assert(_cBookmarks == 0 || _cValidRet == 0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowSeekByBookmark::~CRowSeekByBookmark, public
//
//  Synopsis:   Destroy a CRowSeekByBookmark structure
//
//  Returns:    nothing
//
//  History:    29 Jan 1995     AlanW   Created
//
//----------------------------------------------------------------------------

CRowSeekByBookmark::~CRowSeekByBookmark( )
{
    delete _aBookmarks;
    delete _ascRet;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowSeekNext::GetRows, public
//
//  Synopsis:   Retrieve row data for a table cursor
//
//  Arguments:  [rCursor] - the cursor to fetch data for
//              [rTable] - the table from which data is fetched
//              [rFetchParams] - row fetch parameters and buffer pointers
//              [pSeekDescOut] - pointer to seek description for restart
//
//  Returns:    SCODE - the status of the operation.
//
//  Notes:
//
//  History:    07 Apr 1995     Alanw   Created
//
//--------------------------------------------------------------------------

SCODE
CRowSeekNext::GetRows(
    CTableCursor& rCursor,
    CTableSource& rTable,
    CGetRowsParams& rFetchParams,
    XPtr<CRowSeekDescription>& pSeekDescOut) const
{
    LONG cRowsToSkip = GetSkip();

    if (cRowsToSkip)
    {
        tbDebugOut(( DEB_IWARN, "CRowSeekNext::GetRows - non-zero skip count %d\n",
                            cRowsToSkip ));
    }

    WORKID widStart;
    if ( rTable.IsFirstGetNextRows() )
    {
        //
        // For the first GetNextRows call, the start position is
        // beginning of table if cRowsToSkip is positive, and end
        // of table if its negative. For subsequent calls, the
        // current position is the start position.
        //

        if ( cRowsToSkip >= 0 )
            widStart = WORKID_TBLBEFOREFIRST;
        else
            widStart = WORKID_TBLAFTERLAST;
    }
    else
        widStart = rTable.GetCurrentPosition( GetChapter() );

    WORKID widEnd = widStart;

    //
    // OffsetSameDirFetch implements the skip of one row that
    // Oledb::GetNextRows requires on the first fetch
    // when scrolling and fetching are in the same direction,
    // and for subsequent fetches when the fetch is in the
    // same direction as previous fetch. When the direction is
    // reversed the first wid fetched is same as the last wid
    // returned from the previous call, and offsetSameDirFetch
    // is 0 in this case.
    //
    LONG offsetSameDirFetch = 0;
    if ( rTable.IsFirstGetNextRows() )
    {
        if ( cRowsToSkip >= 0 && rFetchParams.GetFwdFetch() )
            offsetSameDirFetch = 1;
        else if ( cRowsToSkip < 0 && !rFetchParams.GetFwdFetch() )
            offsetSameDirFetch = -1;
    }
    else
    {
        if ( rFetchParams.GetFwdFetch() == rTable.GetFwdFetchPrev() )
        {
            if ( rFetchParams.GetFwdFetch() )
                offsetSameDirFetch = 1;
            else
                offsetSameDirFetch = -1;
        }
    }

    SCODE scRet = rTable.GetRowsAt( 0,  // no watch region
                                    widStart,
                                    GetChapter(),
                                    cRowsToSkip + offsetSameDirFetch,
                                    rCursor.GetBindings(),
                                    rFetchParams,
                                    widEnd );

    //
    //  Don't attempt to save the widEnd if the positioning
    //  operation got us past the end of the table.  Storing
    //  widEnd in rCursor will cause us to be stuck at the
    //  end, with no way to get any more rows.  In this situation,
    //  we don't expect to have successfully transferred any rows.
    //
    // NOTE: don't throw, the error may need to be seen by caller
    //      in CRowset::_FetchRows
    //
    if ( WORKID_TBLAFTERLAST == widEnd ||
         WORKID_TBLBEFOREFIRST == widEnd ||
         ( scRet == DB_E_BADSTARTPOSITION && cRowsToSkip == 0 ) )
    {
        Win4Assert(rFetchParams.RowsTransferred() == 0);
        return DB_S_ENDOFROWSET;
    }

    if (SUCCEEDED(scRet))
    {
        rTable.SetCurrentPosition( GetChapter(), widEnd );
        rTable.SetFwdFetchPrev( rFetchParams.GetFwdFetch() );
        rTable.ResetFirstGetNextRows();
    }
    else
    {
        tbDebugOut(( DEB_WARN, "CRowSeekNext::GetRows failed, sc=%x\n",
                               scRet ));
    }


    if (DB_S_BLOCKLIMITEDROWS == scRet)
    {
        Win4Assert(rFetchParams.RowsTransferred() > 0);
        pSeekDescOut.Set(new CRowSeekNext(GetChapter(), 0) );
    }

    return scRet;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowSeekAt::GetRows, public
//
//  Synopsis:   Retrieve row data for a table cursor
//
//  Arguments:  [rCursor] - the cursor to fetch data for
//              [rTable] - the table from which data is fetched
//              [rFetchParams] - row fetch parameters and buffer pointers
//              [pSeekDescOut] - pointer to seek description for restart
//
//  Returns:    SCODE - the status of the operation.
//
//  Notes:
//
//  History:    07 Apr 1995     Alanw   Created
//
//--------------------------------------------------------------------------

SCODE
CRowSeekAt::GetRows(
    CTableCursor& rCursor,
    CTableSource& rTable,
    CGetRowsParams& rFetchParams,
    XPtr<CRowSeekDescription>& pSeekDescOut) const
{
    WORKID widStart = Bmk();
    LONG iRowOffset = Offset();

    SCODE scRet = rTable.GetRowsAt( _hRegion,
                                    widStart,
                                    GetChapter(),
                                    iRowOffset,
                                    rCursor.GetBindings(),
                                    rFetchParams,
                                    widStart );

    // The first fetch took care of the hRegion manipulation
    // set the new seek descriptor's hRegion to 0
    if (DB_S_BLOCKLIMITEDROWS == scRet)
    {
        Win4Assert(rFetchParams.RowsTransferred() > 0);
        pSeekDescOut.Set(new CRowSeekAt(0,
                                        GetChapter(),
                                        rFetchParams.GetFwdFetch() ? 1 : -1,
                                        widStart) );
    }

    return scRet;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowSeekAtRatio::GetRows, public
//
//  Synopsis:   Retrieve row data for a table cursor
//
//  Arguments:  [rCursor] - the cursor to fetch data for
//              [rTable] - the table from which data is fetched
//              [rFetchParams] - row fetch parameters and buffer pointers
//              [pSeekDescOut] - pointer to seek description for restart
//
//  Returns:    SCODE - the status of the operation.
//
//  Notes:
//
//  History:    07 Apr 1995     Alanw   Created
//
//--------------------------------------------------------------------------

SCODE
CRowSeekAtRatio::GetRows(
    CTableCursor& rCursor,
    CTableSource& rTable,
    CGetRowsParams& rFetchParams,
    XPtr<CRowSeekDescription>& pSeekDescOut) const
{
    WORKID widRestart = widInvalid;
    SCODE scRet = rTable.GetRowsAtRatio( _hRegion,
                                         RatioNumerator(),
                                         RatioDenominator(),
                                         GetChapter(),
                                         rCursor.GetBindings(),
                                         rFetchParams,
                                         widRestart );

    // The first fetch took care of the hRegion manipulation
    // set the new seek descriptor's hRegion to 0
    if (DB_S_BLOCKLIMITEDROWS == scRet)
    {
        Win4Assert(rFetchParams.RowsTransferred() > 0);
        pSeekDescOut.Set(new CRowSeekAt(0, GetChapter(), 1, widRestart) );
    }

    return scRet;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowSeekByBookmark::GetRows, public
//
//  Synopsis:   Retrieve row data for a table cursor
//
//  Arguments:  [rCursor] - the cursor to fetch data for
//              [rTable] - the table from which data is fetched
//              [rFetchParams] - row fetch parameters and buffer pointers
//              [pSeekDescOut] - pointer to seek description for restart
//
//  Returns:    SCODE - the status of the operation.
//
//
//  History:    07 Apr 1995     Alanw   Created
//
//--------------------------------------------------------------------------

SCODE
CRowSeekByBookmark::GetRows(
    CTableCursor& rCursor,
    CTableSource& rTable,
    CGetRowsParams& rFetchParams,
    XPtr<CRowSeekDescription>& pSeekDescOut) const
{
    unsigned cFailed = 0;
    ULONG cSavedRowsReq = rFetchParams.RowsToTransfer();

    Win4Assert(_cBookmarks > 0);
    Win4Assert(cSavedRowsReq <= _cBookmarks);
    Win4Assert(0 == rFetchParams.RowsTransferred() && cSavedRowsReq > 0);

    rFetchParams.SetRowsRequested(0);

    SCODE scRet = S_OK;

    TRY
    {
        XPtr<CRowSeekByBookmark> pSeekOut(
                    new CRowSeekByBookmark(GetChapter(), _cBookmarks) );

        BOOL fFailed = FALSE;
        // Iterate over bookmarks, calling rTable.GetRowsAt for each
        for (unsigned i = 0; i < cSavedRowsReq; i++)
        {
            if (! fFailed)
                rFetchParams.IncrementRowsRequested( );

            WORKID widNext = _aBookmarks[i];
            if (widNext == widInvalid)
            {
                scRet = DB_E_BADBOOKMARK;
            }
            else
            {
                TRY
                {
                    scRet = rTable.GetRowsAt( 0,   // no watch region
                                              widNext,
                                              GetChapter(),
                                              0,
                                              rCursor.GetBindings(),
                                              rFetchParams,
                                              widNext );
                }
                CATCH( CException, e )
                {
                    scRet = e.GetErrorCode();
                    Win4Assert( scRet != STATUS_ACCESS_VIOLATION &&
                                scRet != STATUS_NO_MEMORY );
                }
                END_CATCH;

                if (! SUCCEEDED(scRet) && scRet != STATUS_BUFFER_TOO_SMALL )
                    scRet = DB_E_BOOKMARKSKIPPED;
            }

            if (scRet == DB_S_ENDOFROWSET)
                scRet = S_OK;

            if ( STATUS_BUFFER_TOO_SMALL == scRet ||
                 DB_S_BLOCKLIMITEDROWS == scRet )
            {
                scRet = DB_S_BLOCKLIMITEDROWS;
                break;
            }

            //
            // set per-row error status
            //
            pSeekOut->_SetStatus(i, scRet);
            if (FAILED(scRet))
            {
                cFailed++;
                fFailed = TRUE;
            }
            else
                fFailed = FALSE;
        }
        pSeekDescOut.Set( pSeekOut.Acquire() );
    }
    CATCH( CException, e )
    {
        scRet = e.GetErrorCode();
    }
    END_CATCH;

    if (cFailed)
        return DB_S_ERRORSOCCURRED;
    else if (0 == rFetchParams.RowsTransferred())
        return STATUS_BUFFER_TOO_SMALL;
    else
        return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowSeekByBookmark::_SetStatus, private
//
//  Synopsis:   Set row status for a bookmark lookup
//
//  Arguments:  [iBmk] - index of bookmark to set status for
//              [scRet] - the status to be saved
//
//  Returns:    Nothing
//
//  History:    12 Apr 1995     Alanw   Created
//
//--------------------------------------------------------------------------

void
CRowSeekByBookmark::_SetStatus(
    unsigned    iBmk,
    SCODE       scRet
) {
    Win4Assert( iBmk < _maxRet );

    if (_ascRet == 0)
        _ascRet = new SCODE[_maxRet];

    _ascRet[iBmk] = scRet;
    if (iBmk >= _cValidRet)
    {
        Win4Assert( iBmk == _cValidRet );
        _cValidRet = iBmk + 1;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CRowSeekDescription::MergeResults, public
//
//  Synopsis:   Update seek description state after a transfer
//
//  Arguments:  [pRowSeek] - row seek description after transfer
//
//  Returns:    Nothing
//
//  Notes:      Used only in user mode.  Does nothing for CRowSeekNext,
//              CRowSeekAt and CRowSeekAtRatio.
//
//  History:    02 May 1995     Alanw   Created
//
//--------------------------------------------------------------------------

void
CRowSeekDescription::MergeResults(
    CRowSeekDescription * pRowSeek )
{
    return;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRowSeekByBookmark::MergeResults, public
//
//  Synopsis:   Update seek description state after a transfer
//
//  Arguments:  [pRowSeek] - row seek description after transfer
//
//  Returns:    Nothing
//
//  Notes:      Used only in user mode.  Transfers statuses into
//              original rowseek and bookmarks from original to
//              result rowseek.
//
//  History:    02 May 1995     Alanw   Created
//
//--------------------------------------------------------------------------

void
CRowSeekByBookmark::MergeResults(
    CRowSeekDescription * pRowSeekDesc)
{
    Win4Assert(pRowSeekDesc->IsByBmkRowSeek());

    CRowSeekByBookmark* pRowSeek = (CRowSeekByBookmark*) pRowSeekDesc;

    Win4Assert(_cBookmarks > 0 &&
               pRowSeek->_cValidRet > 0 && pRowSeek->_cBookmarks == 0);

    //
    // Transfer return statuses to this object from the other
    //
    unsigned iBaseRet = _cValidRet;

    for (unsigned i=0; i < pRowSeek->_cValidRet; i++)
    {
        _SetStatus( i+iBaseRet, pRowSeek->_ascRet[i] );
    }

    delete [] pRowSeek->_ascRet;
    pRowSeek->_ascRet = 0;
    pRowSeek->_cValidRet = pRowSeek->_maxRet = 0;

    //
    //  Transfer bookmarks from this object to the other.
    //
    if (_cBookmarks - _cValidRet > 0)
    {
        pRowSeek->_cBookmarks = _cBookmarks - _cValidRet;
        pRowSeek->_aBookmarks = new CI_TBL_BMK[ pRowSeek->_cBookmarks ];

        for (unsigned i=0; i<pRowSeek->_cBookmarks; i++)
        {
            pRowSeek->_aBookmarks[i] = _aBookmarks[ i+_cValidRet ];
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\rowindex.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       rowindex.cxx
//
//  Contents:   Implementation of CRowIndex
//
//  Classes:    CRowIndex
//
//  History:    23 Aug 1994     dlee    Created
//              30 Nov 1996     dlee    Converted to use dynarrayinplace
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "rowindex.hxx"
#include "tabledbg.hxx"

inline BOOL isOdd(ULONG x) { return 0 != (x & 1); }

//+-------------------------------------------------------------------------
//
//  Member:     CRowIndex::_FindInsertionPoint, private
//
//  Synopsis:   Binary search to find insertion point for a row.
//              Returns one past the last row or the first row >=
//              to the given row
//
//  Arguments:  [Value] -- value of the row -- internally an offset
//
//  History:    23 Aug 1994     dlee   Created
//
//--------------------------------------------------------------------------

ULONG CRowIndex::_FindInsertionPoint(
    TBL_OFF Value ) const
{
    ULONG cRows = _aRows.Count();
    ULONG iLo = 0;
    ULONG iHi = cRows - 1;

    do
    {
        ULONG cHalf = cRows / 2;

        if (0 != cHalf)
        {
            ULONG iMid = isOdd(cRows) ? cHalf : (cHalf - 1);
            iMid += iLo;
            int i = _pRowCompare->Compare( Value, _aRows[iMid] );

            if (0 == i)
            {
                return iMid;
            }
            else if (i < 0)
            {
                iHi = iMid - 1;
                cRows = isOdd(cRows) ? cHalf : (cHalf - 1);
            }
            else
            {
                iLo = iMid + 1;
                cRows = cHalf;
            }
        }
        else if (0 != cRows)
        {
            int i = _pRowCompare->Compare( Value, _aRows[iLo] );

            if (i <= 0)
                return iLo;
            else
                return iLo + 1;
        }
        else return iLo;
    }
    while (TRUE);

    Win4Assert(! "Invalid CRowIndex::_Find function exit point");
    return 0;
} //_FindInsertionPoint

//+---------------------------------------------------------------------------
//
//  Function:   _FindRowByLinearSearch, private
//
//  Synopsis:   Given the offset of a row in the table window, this method
//              searches for the entry in the row index which points to that
//              row.
//
//  Arguments:  [oTableRow] -- Offset of the row in the table window.
//              [iRowIndex] -- On output, will have the index of the entry
//              in the row index which points to oTableRow.
//
//  Returns:    TRUE if found; FALSE o/w
//
//  History:    11-22-94   srikants   Created
//
//  Notes:      The row index is searched linearly. This must be used only
//              if there is no row comparator.
//
//----------------------------------------------------------------------------

inline BOOL CRowIndex::_FindRowByLinearSearch(
    TBL_OFF oTableRow,
    ULONG &   iRowIndex ) const
{
    for ( ULONG iCurr = 0; iCurr < _aRows.Count(); iCurr++ )
    {
        if ( _aRows[iCurr] == oTableRow )
        {
            iRowIndex = iCurr;
            return TRUE;
        }
    }

    return FALSE;
} // _FindRowByLinearSearch

#if 0

//+---------------------------------------------------------------------------
//
//  Function:   _FindRowByBinarySearch, private
//
//  Synopsis:   Using a binary search, this method locates the entry in the
//              row index which is same as the row indicated by oTableRow.
//              As duplicates are allowed, it is possible that there is more
//              than one entry in the row index, which will match the row in
//              the table window indicated by the oTableRow.
//
//  Arguments:  [oTableRow] -- Offset of the row in the table window.
//              [iRowIndex] -- On output, will contain the index of the entry
//              in the row index which has the same key as the "oTableRow"
//
//  Returns:    TRUE if found successfully. FALSE o/w
//
//  History:    11-22-94   srikants   Created
//
//  Notes:      NOT TESTED OR REVIEWED
//
//----------------------------------------------------------------------------

inline BOOL CRowIndex::_FindRowByBinarySearch(
    TBL_OFF oTableRow,
    ULONG &   iRowIndex ) const
{

    Win4Assert( 0 != _pRowCompare );

    ULONG *pBase = _Base();

    ULONG cRows = _aRows.Count();
    ULONG iLo = 0;
    ULONG iHi = _aRows.Count() - 1;

    ULONG cHalf = 0;

    do
    {
        cHalf = cRows / 2;

        if (0 != cHalf)
        {
            ULONG iMid = isOdd(cRows) ? cHalf : (cHalf - 1);
            iMid += iLo;

            int i = _pRowCompare->Compare(oTableRow, pBase[iMid]);

            if (0 == i)
            {
                iRowIndex = iMid;
                return TRUE;
            }
            else if (i < 0)
            {
                iHi = iMid - 1;
                cRows = isOdd(cRows) ? cHalf : (cHalf - 1);
            }
            else
            {
                iLo = iMid + 1;
                cRows = cHalf;
            }
        }
        else if (0 != cRows)
        {
            Win4Assert( 1 == cRows );
            int i = _pRowCompare->Compare(oTableRow, pBase[iLo]);

            if ( 0 == i )
            {
                iRowIndex = iLo;
                return TRUE;
            }
        }
    }
    while ( 0 != cHalf );

    Win4Assert( !_FindRowByLinearSearch( oTableRow, iRowIndex ) );
    return FALSE;

} // FindRowByBinarySearch

#endif


//+---------------------------------------------------------------------------
//
//  Function:   FindRow, public
//
//  Synopsis:   Given an offset of a row in the table window, this method
//              locates the entry in the row index, which points to the
//              row in the table window.
//
//  Arguments:  [oTableRow] -- (IN) The offset of the row in the table window.
//              [iRowIndex] --  (OUT) The index of the entry in the row index
//              which points to the oTableRow.
//
//  Returns:    TRUE if search successful; FALSE O/W
//
//  History:    11-22-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL  CRowIndex::FindRow( TBL_OFF oTableRow, ULONG &iRowIndex ) const
{
    return _FindRowByLinearSearch( oTableRow, iRowIndex );
}

//+-------------------------------------------------------------------------
//
//  Member:     CRowIndex::AddRow, public
//
//  Synopsis:   Adds a row in sort order to the index
//
//  Arguments:  [Value] -- Value to insert in the index, represents a row
//
//  Returns:    Index of the newly added row
//
//  History:    23 Aug 1994     dlee   Created
//
//--------------------------------------------------------------------------

ULONG CRowIndex::AddRow(TBL_OFF Value)
{
    Win4Assert( 0 != _pRowCompare );

    ULONG cRows = _aRows.Count();

    // Find the insertion point for the new row.

    if ( 0 == cRows )
    {
        // No rows yet

        _aRows[0] = Value;
        return 0;
    }
    else if ( ( _pRowCompare->Compare( _aRows[cRows - 1], Value ) ) <= 0 )
    {
        // append a row to the end

        _aRows[ cRows ] = Value;
        return cRows;
    }

    // insert a row.

    ULONG iInsertionPoint = _FindInsertionPoint( Value );

    _aRows.Insert( Value, iInsertionPoint );

    return iInsertionPoint;
} //AddRow

//+-------------------------------------------------------------------------
//
//  Member:     CRowIndex::DeleteRow, public
//
//  Synopsis:   Deletes a row from the index and moves the following rows
//              up a notch in the array.
//
//  Arguments:  [iRow] -- row to be deleted
//
//  History:    29 Aug 1994     dlee   Created
//
//--------------------------------------------------------------------------

void CRowIndex::DeleteRow(ULONG iRow)
{
    Win4Assert( iRow < _aRows.Count() );

    _aRows.Remove( iRow );
} //DeleteRow

//+-------------------------------------------------------------------------
//
//  Member:     CRowIndex::ResortRow, public
//
//  Synopsis:   Bubbles the given row up or down based on the sort key.
//              Useful for when a file property is updated after being
//              added to the table.
//
//  Arguments:  [iRow] -- row to be resorted
//
//  Returns:    ULONG - new index of the row
//
//  PERFFIX:    should probably do a binary search, not a linear one
//
//  History:    29 Aug 1994     dlee   Created
//
//--------------------------------------------------------------------------

ULONG CRowIndex::ResortRow(ULONG iRow)
{
    Win4Assert(iRow < _aRows.Count());

    Win4Assert( 0 != _pRowCompare );

    // Get the start of the array of offsets

    TBL_OFF *pBase = _Base();
    Win4Assert(0 != pBase);

    // Bubble toward row 0
    
    while ((iRow > 0) &&
           (_pRowCompare->Compare(pBase[iRow], pBase[iRow - 1]) < 0))
    {
        TBL_OFF iTmp = pBase[iRow];
        pBase[iRow] = pBase[iRow - 1];
        iRow--;
        pBase[iRow] = iTmp;
    }
    
    // Bubble toward the last row
    
    while ((iRow < (_aRows.Count() - 1)) &&
           (_pRowCompare->Compare(pBase[iRow], pBase[iRow + 1]) > 0))
    {
        TBL_OFF iTmp = pBase[iRow];
        pBase[iRow] = pBase[iRow + 1];
        iRow++;
        pBase[iRow] = iTmp;
    }

    return iRow;
} //ResortRow


//+---------------------------------------------------------------------------
//
//  Member:     CRowIndex::ResizeAndInit
//
//  Synopsis:   Resizes the current row index to be the same size as
//              specified.
//
//  Arguments:  [cNewRows] -  Number of rows in the new row index.
//
//  History:    7-31-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CRowIndex::ResizeAndInit( ULONG cNewRows )
{
    _aRows.Clear();
}

//+---------------------------------------------------------------------------
//
//  Function:   SyncUp
//
//  Synopsis:   Synchronizes the permutation (rowindex contents) with that
//              of the new index.
//
//  Arguments:  [newIndex] -- The newIndex whose permutation must be copied
//              to our permutation.
//
//  History:    11-29-94   srikants   Created
//              11-30-96   dlee       converted to dynarrayinplace
//
//  Notes:      The implementation is optimized by doing a block copy of the
//              contents of the source row index. That is much faster than
//              adding individual entries from the source row index.
//
//----------------------------------------------------------------------------

void CRowIndex::SyncUp( CRowIndex & newIndex )
{
    _aRows.Duplicate( newIndex._aRows );
}

//+---------------------------------------------------------------------------
//
//  Function:   FindSplitPoint
//
//  Synopsis:   Given a row whose offset in the table is "oTableRow", this
//              method finds out the highest row in the rowIndex which is <=
//              "oTableRow".  This method is used during a window split to
//              determine the split-position of a rowIndex.
//
//  Arguments:  [oTableRow] - Offset of the row to compare with.
//
//  Returns:    The first row that belongs to the RHS.
//
//  History:    1-08-95   srikants   Created
//
//  Notes:      This method is used to find a split point in the client
//              row index during a window split. After determining the split
//              point in the query row index, we have to find a point in the
//              client row index which will split the client row index also
//              in the same manner as the query row index.
//
//----------------------------------------------------------------------------

LONG CRowIndex::FindSplitPoint( TBL_OFF oTableRow ) const
{

#if DBG==1
//    CheckSortOrder();
#endif  // DBG==1

    // Get the start of the array of offsets

    LONG iSplitRow = LONG_MAX;

    int iComp = 0;

    if ( 0 == _pRowCompare || 0 == _aRows.Count() )
    {
        iSplitRow = 0;
    }
    else if ( _pRowCompare->Compare( oTableRow, _aRows[0] ) < 0 )
    {
        //
        // The given row is < the smallest row in the row index.
        //
        iSplitRow = 0;
    }
    else if ( (iComp =
              _pRowCompare->Compare( oTableRow, _aRows[_aRows.Count()-1] )) >= 0  )
    {
        //
        // The given row is >= the biggest row in the row index.
        //
        iSplitRow = _aRows.Count();
    }
    else
    {

        ULONG oSplitRow = _FindInsertionPoint( oTableRow );
        Win4Assert( oSplitRow < _aRows.Count() );

        iSplitRow = (LONG) _aRows.Count();
        for ( unsigned i = oSplitRow; i < _aRows.Count(); i++ )
        {
            int iComp = _pRowCompare->Compare( oTableRow, _aRows[i] );
            Win4Assert( iComp <= 0 );
            if ( iComp < 0 )
            {
                iSplitRow = (LONG) i;
                break;
            }
        }
    }

    Win4Assert( LONG_MAX != iSplitRow );
    return iSplitRow;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindMidSplitPoint
//
//  Synopsis:   Finds out a point in the row index which can serve as a split
//              point during a window split. The split point is such that
//              all rows in the rowindex from 0..SplitPoint are <= the row
//              in the SplitPoint and all rows SplitPoint+1.._aRows.Count()-1 are
//              > the row in the SplitPoint.
//
//  Arguments:  [riSplitPoint] - (output) The split point, if one exists.
//
//  Returns:    TRUE if a split point satisfying the above requirement is
//              found. FALSE o/w
//
//  History:    1-25-95   srikants   Created
//
//  Notes:      This method is used during a window split to determine a
//              split point in the query row index (if one exists).
//
//----------------------------------------------------------------------------

BOOL CRowIndex::FindMidSplitPoint( ULONG & riSplitPoint ) const
{

#if DBG==1
//    CheckSortOrder();
#endif  // DBG==1

    BOOL fFound = FALSE;

    if ( 0 != _aRows.Count() && 0 != _pRowCompare )
    {
        ULONG oMidPoint = _aRows.Count()/2;

        //
        // Find the first row to the RHS which is > the middle row.
        //
        for ( ULONG j =  oMidPoint+1; j < _aRows.Count(); j++ )
        {
            int iComp;
            if ( 0 != ( iComp =
                        _pRowCompare->Compare( _aRows[oMidPoint],
                                               _aRows[j]) ) )
            {
                Win4Assert( iComp < 0 );
                fFound = TRUE;
                riSplitPoint = j-1;
                break;
            }
        }

        if ( !fFound )
        {
            //
            // All rows to the right of oMidPoint are equal. We should now
            // try the LHS.
            //
            for ( int i = (int) oMidPoint-1; i >= 0; i-- )
            {
                int iComp;
                if ( 0 != (iComp = _pRowCompare->Compare( _aRows[i], _aRows[oMidPoint] )) )
                {
                    Win4Assert( iComp < 0 );
                    fFound = TRUE;
                    riSplitPoint = (ULONG) i;
                    break;
                }
            }
        }

        //
        // PERFFIX - this algorithm can be modified to find the split point
        // which is as close to the mid point as possible. That would mean
        // looking the LHS even if we find a split point in the RHS and the
        // split point != the oMidPoint. That will involve more comparisons.
        //
    }

    return fFound;
}

#if CIDBG==1 || DBG==1

void CRowIndex::CheckSortOrder() const
{
    if ( _aRows.Count() <= 1 || 0 == _pRowCompare )
    {
        return;    
    }

    for ( unsigned i = 0; i < _aRows.Count()-1 ; i++ )
    {
        int iComp = _pRowCompare->Compare( _aRows[i], _aRows[i+1] );
        Win4Assert( iComp <= 0 );
    }
}

#endif  // CIDBG==1 || DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\rownotfy.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000
//
//  File:        rownotfy.cxx
//
//  Contents:    Rowset notification connection points
//
//  Classes:     CRowsetNotification
//               CRowsetAsynchNotification
//
//  History:     16 Feb 1998    AlanW   Created from conpt.cxx
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <rownotfy.hxx>
#include <query.hxx>

#include "tabledbg.hxx"


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
//////////////// CRowsetAsynchNotification methods ///////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////


//+-------------------------------------------------------------------------
//
//  Method:     CRowsetAsynchNotification::CRowsetAsynchNotification, public
//
//  Synopsis:   Constructor for connection point container class.
//
//  Arguments:  [query]       -- query object with notify info
//              [pRowset]     -- Rowset pointer
//              [ErrorObject] -- OLE-DB error object
//              [fWatch]      -- TRUE if watch notification to be done
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

CRowsetAsynchNotification::CRowsetAsynchNotification(
            PQuery & query,
            ULONG hCursor,
            IRowset * pRowset,
            CCIOleDBError & ErrorObject,
            BOOL fWatch)
   : _query(query),
     _hCursor(hCursor),
     CRowsetNotification( ),
     _AsynchConnectionPoint ( IID_IDBAsynchNotify ),
     _WatchConnectionPoint ( IID_IRowsetWatchNotify ),
     _fDoWatch (fWatch),
     _fPopulationComplete (FALSE),
     _cAdvise( 0 ),
     _pRowset(pRowset),
     _threadNotify(0),
     _threadNotifyId( 0 )
{
     _AsynchConnectionPoint.SetContrUnk( (IUnknown *)this );
     if (_fDoWatch)
     {
         _WatchConnectionPoint.SetContrUnk( (IUnknown *)this );
     }
} //CRowsetAsynchNotification

//+-------------------------------------------------------------------------
//
//  Method:     CRowsetAsynchNotification::~CRowsetAsynchNotification, public
//
//  Synopsis:   Destructor for rowset watch notification class
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

CRowsetAsynchNotification::~CRowsetAsynchNotification()
{
    Win4Assert( _cRefs == 0 && _pContainer == 0 );
    Win4Assert( _cAdvise == 0 );

    if ( 0 != _pContainer )
        StopNotifications();

} //~CRowsetAsynchNotification


//+-------------------------------------------------------------------------
//
//  Method:     CRowsetAsynchNotification::AddRef, public
//
//  Synopsis:   Increments aggregated object ref. count.
//
//  Returns:    ULONG
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CRowsetAsynchNotification::AddRef()
{
    return InterlockedIncrement( (long *) &_cRefs );
} //AddRef

//+-------------------------------------------------------------------------
//
//  Method:     CRowsetAsynchNotification::Release, public
//
//  Synopsis:   Decrements aggregated obj. ref. count, deletes on final release.
//
//  Returns:    ULONG
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CRowsetAsynchNotification::Release()
{
    long cRefs = InterlockedDecrement((long *) &_cRefs);

    tbDebugOut(( DEB_NOTIFY, "conpt: release, new crefs: %lx\n", _cRefs ));

    // If no references, make sure container doesn't know about me anymore
    if ( 0 == cRefs )
    {
        Win4Assert( 0 == _pContainer );

        if ( 0 != _pContainer )
        {
            // must have gotten here through excess client release
            StopNotifications();
        }

        delete this;
    }

    return cRefs;
} //Release


//+-------------------------------------------------------------------------
//
//  Method:     CRowsetAsynchNotification::StopNotifications
//
//  Synopsis:   Shuts down the notification thread (if any)
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

void CRowsetAsynchNotification::StopNotifications()
{
    if ( GetCurrentThreadId() == _threadNotifyId )
    {
        Win4Assert( !"Notification thread used illegally" );
        return;
    }

    _EndNotifyThread();

    Disconnect();
    _AsynchConnectionPoint.Disconnect( );

    if (_fDoWatch)
        _WatchConnectionPoint.Disconnect( );
}


//+-------------------------------------------------------------------------
//
//  Method:     CRowsetAsynchNotification::_EndNotifyThread
//
//  Synopsis:   Shuts down the notification thread (if any)
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

void CRowsetAsynchNotification::_EndNotifyThread()
{
    //
    // Is there a thread out there to close?
    //

    if (0 != _threadNotify)
    {
        // Signal the thread to die and wait for it to do so, or just kill
        // the thread if it looks like it might be lost in client code.

        tbDebugOut(( DEB_NOTIFY,
                     "set notify thread die event %lx\n",
                     _evtEndNotifyThread.GetHandle() ));

        _evtEndNotifyThread.Set();

        DWORD dw = WaitForSingleObject( _threadNotify, INFINITE );

        BOOL fCloseWorked = CloseHandle( _threadNotify );

        Win4Assert( fCloseWorked && "CloseHandle of notify thread failed" );

        _threadNotify = 0;

        tbDebugOut(( DEB_NOTIFY, "notify thread is history \n"));
    }
} //_EndNotifyThread

//+-------------------------------------------------------------------------
//
//  Method:     CRowsetAsynchNotification::_StartNotifyThread
//
//  Synopsis:   Starts the notification thread
//
//  History:    17 Mar 1998     AlanW
//
//--------------------------------------------------------------------------

inline void CRowsetAsynchNotification::_StartNotifyThread()
{
    tbDebugOut(( DEB_NOTIFY, "starting rowset notify thread\n" ));

    // First advise, create the thread
    Win4Assert(0 == _threadNotify);
    _threadNotify = CreateThread( 0, 65536,
                                  (LPTHREAD_START_ROUTINE) _NotifyThread,
                                  this, 0, & _threadNotifyId );

    if (0 == _threadNotify)
        THROW( CException() );
}

//+-------------------------------------------------------------------------
//
//  Method:     CRowsetAsynchNotification::_NotifyThread, private
//
//  Synopsis:   Entry point for notification thread
//
//  Arguments:  [self]             -- a container to call to do the work
//
//  Returns:    Thread exit code
//
//  Notes:      this function is "static"
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

DWORD CRowsetAsynchNotification::_NotifyThread(
    CRowsetAsynchNotification *self)
{
    TRANSLATE_EXCEPTIONS;

    DWORD dw = self->_DoNotifications();

    UNTRANSLATE_EXCEPTIONS;

    return dw;
} //_NotifyThread

//+-------------------------------------------------------------------------
//
//  Method:     CRowsetAsynchNotification::_DoNotifications, private
//
//  Synopsis:   Collects notifications and passes them out to clients.
//              Loops sending notifications until event to end thread
//              arrives.
//
//  Returns:    Thread exit code
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

DWORD CRowsetAsynchNotification::_DoNotifications()
{
    BOOL fContinue = TRUE;

    do
    {
        TRY
        {
            if (fContinue && _AsynchConnectionPoint.GetAdviseCount() )
                fContinue = _DoAsynchNotification();

            if (fContinue && _fDoWatch &&
                _WatchConnectionPoint.GetAdviseCount() )
                fContinue = _DoWatchNotification();

            if (_fPopulationComplete && !_fDoWatch)
                fContinue = FALSE;
        }
        CATCH( CException, e )
        {
            // don't want to 'break' out of a catch block, use variable

            fContinue = FALSE;
        }
        END_CATCH;

        // Sleep for a bit, but wake up if the thread is to go away,

        ULONG x = _evtEndNotifyThread.Wait( defNotificationSleepDuration,
                                            FALSE );

        if ( STATUS_WAIT_0 == x )
            fContinue = FALSE;
    } while ( fContinue );

    return 0;
} //_DoNotifications

//+-------------------------------------------------------------------------
//
//  Function:   IsLowResources
//
//  Synopsis:   Returns TRUE if it looks like the error is resource related.
//
//  Returns:    BOOL - TRUE if low on resources
//
//  History:    9  May 1999   dlee
//
//--------------------------------------------------------------------------

BOOL IsLowResources( SCODE sc )
{
    return E_OUTOFMEMORY == sc ||
           STATUS_NO_MEMORY == sc ||
           STATUS_COMMITMENT_LIMIT == sc ||
           STATUS_INSUFFICIENT_RESOURCES == sc ||
           HRESULT_FROM_WIN32( ERROR_COMMITMENT_LIMIT ) == sc ||
           HRESULT_FROM_WIN32( ERROR_NO_SYSTEM_RESOURCES ) == sc ||
           STG_E_INSUFFICIENTMEMORY == sc;
} //IsLowResources

//+-------------------------------------------------------------------------
//
//  Method:     CRowsetAsynchNotification::_DoAsynchNotification, private
//
//  Synopsis:   Collects asynch notifications and passes them out to clients.
//              Tracks whether rowset population is completed, after which
//              no more notifications are given (except for completion
//              notifications for new advises).
//
//  Returns:    BOOL - TRUE if notification thread should continue
//
//  History:    18 Mar 1998     AlanW
//
//--------------------------------------------------------------------------

inline DWORD MapAsynchPhaseAndOp( ULONG op, ULONG phase )
{
    Win4Assert( op == 0 && phase < 4 );
    return (((op+1) << 4) | (1 << phase));
}

#define ASYNC_PHASE_MASK 0x0F
#define ASYNC_OP_MASK    0xF0

BOOL CRowsetAsynchNotification::_DoAsynchNotification()
{
    DBCOUNTITEM ulDenominator = 0, ulNumerator = 0;
    DBCOUNTITEM cRows = 0;
    BOOL fNewRows = FALSE;
    SCODE sc = S_OK;

    TRY
    {
        CNotificationSync Sync( _evtEndNotifyThread.GetHandle() );
        sc = _query.RatioFinished( Sync,
                                   _hCursor,
                                   ulDenominator,
                                   ulNumerator,
                                   cRows,
                                   fNewRows );
    
        // Did the main thread tell this thread to go away?
    
        if ( SUCCEEDED( sc ) )
        {
            Win4Assert( ulDenominator > 0 && ulNumerator <= ulDenominator );
    
            if (fNewRows)
                OnRowChange( _pRowset, 0, 0, DBREASON_ROW_ASYNCHINSERT,
                             DBEVENTPHASE_DIDEVENT, TRUE );
    
            if (!_fPopulationComplete && (ulNumerator == ulDenominator))
            {
                OnRowsetChange( _pRowset, DBREASON_ROWSET_POPULATIONCOMPLETE,
                                DBEVENTPHASE_DIDEVENT, TRUE );
    
                _fPopulationComplete = TRUE;
            }
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH;

    if ( STATUS_CANCELLED == sc )
        return FALSE;

    BOOL fLowResources = IsLowResources( sc );

    if ( !fLowResources && !SUCCEEDED( sc ) )
        return FALSE;

    // Give notice to all active advises.
    // Need to be careful here to avoid deadlock.  The enumerator
    // grabs the CPC's mutex.  This limits what the client can do.

    ULONG ulAsynchPhase = DBASYNCHPHASE_POPULATION;
    if (_fPopulationComplete)
        ulAsynchPhase = DBASYNCHPHASE_COMPLETE;
    ULONG dwOpMask = MapAsynchPhaseAndOp( DBASYNCHOP_OPEN, ulAsynchPhase );

    CEnumConnectionsLite Enum( _AsynchConnectionPoint );
    CConnectionPointBase::CConnectionContext *pConnCtx = Enum.First();

    while ( 0 != pConnCtx )
    {
        IDBAsynchNotify *pNotifyAsynch = (IDBAsynchNotify *)(pConnCtx->_pIUnk);
        tbDebugOut(( DEB_NOTIFY, "rownotfy: pinging asynch client %x\n", pNotifyAsynch ));
        SCODE sc = S_OK;

        if ( fLowResources )
        {
            //
            // Let the client know we're really wedged and they might not
            // get more notifications consistently.
            //

            sc = pNotifyAsynch->OnLowResource( 0 );
        }
        else
        {
            if ( 0 == (pConnCtx->_dwSpare & dwOpMask) )
            {
                sc = pNotifyAsynch->OnProgress( DB_NULL_HCHAPTER,
                                                DBASYNCHOP_OPEN,
                                                ulNumerator, ulDenominator,
                                                ulAsynchPhase, 0);
            }

            BOOL fOnStop = FALSE;
            if ( _fPopulationComplete && S_OK == sc )
            {
                sc = DB_S_UNWANTEDPHASE;
                fOnStop = TRUE;
            }
    
            if (DB_S_UNWANTEDPHASE == sc)
                pConnCtx->_dwSpare |= (dwOpMask & ASYNC_PHASE_MASK);
            else if (DB_S_UNWANTEDOPERATION == sc)
                pConnCtx->_dwSpare |= (dwOpMask & ASYNC_OP_MASK);
            else if (E_NOTIMPL == sc)
                pConnCtx->_dwSpare |= (ASYNC_PHASE_MASK | ASYNC_OP_MASK);

            if ( fOnStop )
                pNotifyAsynch->OnStop( DB_NULL_HCHAPTER,
                                       DBASYNCHOP_OPEN,
                                       S_OK,
                                       0 );
        }

        tbDebugOut(( DEB_NOTIFY, "rownotfy:(end) pinging asynch client\n" ));
        pConnCtx = Enum.Next();
    }

    // Keep trying to get notifications even if fLowResources is TRUE

    return TRUE;
} //_DoAsynchNotification

//+-------------------------------------------------------------------------
//
//  Method:     CRowsetAsynchNotification::_DoWatchNotification, private
//
//  Synopsis:   Collects watch notifications and passes them out to clients.
//
//  Returns:    BOOL - TRUE if notification thread should continue
//
//  History:    18 Mar 1998     AlanW
//
//--------------------------------------------------------------------------

BOOL CRowsetAsynchNotification::_DoWatchNotification()
{
    // get notification information from the cursor

    CNotificationSync Sync( _evtEndNotifyThread.GetHandle() );
    DBWATCHNOTIFY changeType;

    SCODE sc = _query.GetNotifications( Sync, changeType );

    // Did the main thread tell this thread to go away?

    if (STATUS_CANCELLED == sc)
        return FALSE;

    if (!SUCCEEDED(sc))
        return FALSE;

    // got some, give them to all active advises
    // Need to be careful here to avoid deadlock.  The enumerator
    // grabs the CPC's mutex.  We need to break out of the loop
    // if the notify thread needs to go away...

    tbDebugOut(( DEB_NOTIFY, "rownotfy: watch type %d\n", changeType ));
    CEnumConnectionsLite Enum( _WatchConnectionPoint );
    CConnectionPointBase::CConnectionContext *pConnCtx = Enum.First();

    while ( pConnCtx )
    {
        IRowsetWatchNotify *pNotifyWatch =
                (IRowsetWatchNotify *)(pConnCtx->_pIUnk);
        tbDebugOut(( DEB_NOTIFY, "rownotfy: pinging watch client %x\n", pNotifyWatch ));
        pNotifyWatch->OnChange( _pRowset, changeType);
        tbDebugOut(( DEB_NOTIFY, "rownotfy:(end) pinging watch client\n" ));
        pConnCtx = Enum.Next();
    }

    return TRUE;
} //_DoWatchNotification

//+-------------------------------------------------------------------------
//
//  Method:     CRowsetAsynchNotification::AdviseHelper, private static
//
//  Synopsis:   Starts the notification thread if this is the first advise.
//
//  Arguments:  [pHelperContext] - "this" pointer
//              [pConnPt] - the connection point, either Async or Watch CP
//              [pConnCtx] - pointer to connection context
//
//  Notes:      CPC critical section is assumed to be held.
//
//  History:    17 Mar 1998     AlanW
//
//--------------------------------------------------------------------------

void CRowsetAsynchNotification::AdviseHelper( PVOID pHelperContext,
                                             CConnectionPointBase * pConnPt,
                                             CConnectionContext * pConnCtx )
{
    CRowsetAsynchNotification * pSelf =
        (CRowsetAsynchNotification *) pHelperContext;

    pSelf->_cAdvise++;
    if (1 == pSelf->_cAdvise)
    {
        // First advise, create the notification thread
        pSelf->_StartNotifyThread();
        Win4Assert(0 != pSelf->_threadNotify);
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CRowsetAsynchNotification::UnadviseHelper, private static
//
//  Synopsis:   Stops the notification thread if this is the last active advise.
//
//  Arguments:  [pHelperContext] -- "this" pointer
//              [pConnPt]        -- the connection point, either Async or
//                                  Watch CP
//              [pConnCtx]       -- pointer to connection context
//              [lock]           -- CPC lock
//
//  Notes:      CPC critical section is assumed to be held.
//
//  History:    17 Mar 1998     AlanW
//
//--------------------------------------------------------------------------

void CRowsetAsynchNotification::UnadviseHelper(
    PVOID pHelperContext,
    CConnectionPointBase * pConnPt,
    CConnectionContext * pConnCtx,
    CReleasableLock & lock )
{
    CRowsetAsynchNotification * pSelf =
        (CRowsetAsynchNotification *) pHelperContext;

    Win4Assert( pSelf->_cAdvise > 0 );
    if ( --pSelf->_cAdvise == 0 )
    {
        // Release the lock so the notify thread has a change to end
        // when we tell it to end.

        lock.Release();

        pSelf->_EndNotifyThread();
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   MapPhaseAndReason, inline local
//
//  Synopsis:   Encode IRowsetNotify phase and reason into a bit mask
//              for supported phases and reasons.  Luckily, most supported
//              reasons have only a single phase.  Multi-phase reasons take
//              5 bits.
//
//  Returns:    DWORD - bit mask for the reason/phase combination
//
//  History:    18 Mar 1998     AlanW
//
//--------------------------------------------------------------------------

const maxSinglePhaseReasons = 8;
const maxMultiPhaseReasons = 4;
const maxPhases = 5;
const bitDidNotifyVote = 0x80000000;

inline DWORD MapPhaseAndReason( ULONG phase, ULONG reason )
{
    Win4Assert( reason <= 21 && phase <= 4 );

    BOOL fSinglePhase = TRUE;
    DWORD dwMappedReason = 0;

    switch (reason)
    {
    // single-phase reasons
    case DBREASON_ROW_ASYNCHINSERT:
        dwMappedReason = 0;     break;
    case DBREASON_ROWSET_RELEASE:
        dwMappedReason = 1;     break;
    case DBREASON_ROW_ACTIVATE:
        dwMappedReason = 2;     break;
    case DBREASON_ROW_RELEASE:
        dwMappedReason = 3;     break;
    case DBREASON_ROWSET_POPULATIONCOMPLETE:
        dwMappedReason = 4;     break;
    case DBREASON_ROWSET_POPULATIONSTOPPED:
        dwMappedReason = 5;     break;

    // multi-phase reasons
    case DBREASON_ROWSET_FETCHPOSITIONCHANGE:
        dwMappedReason = 0;     fSinglePhase = FALSE;   break;

    default:
        tbDebugOut(( DEB_ERROR, "MapPhaseAndReason - reason: %d phase: %d\n",
                     reason, phase ));
        Win4Assert( !"MapPhaseAndReason: unhandled reason" );
    }

    Win4Assert( FALSE == fSinglePhase || phase == DBEVENTPHASE_DIDEVENT );
    if (fSinglePhase)
    {
        Win4Assert( dwMappedReason < maxSinglePhaseReasons );
        dwMappedReason = (1 << dwMappedReason);
    }
    else
    {
        dwMappedReason = dwMappedReason*maxPhases + phase + maxSinglePhaseReasons;
        Win4Assert( dwMappedReason <= 30 );
        dwMappedReason = (1 << dwMappedReason);
    }

    return dwMappedReason;
}

//+-------------------------------------------------------------------------
//
//  Function:   MapAllPhases, inline local
//
//  Synopsis:   Return a bit mask that includes all bits for all supported
//              phases of the encoded reason.
//
//  Arguments:  [dwMappedReasonAndPhase] - a bit mask returned by
//                                         MapPhaseAndReason.
//
//  Returns:    DWORD - bit mask for all phases
//
//  History:    18 Mar 1998     AlanW
//
//--------------------------------------------------------------------------

inline DWORD MapAllPhases( DWORD dwMappedReasonAndPhase )
{
    Win4Assert( dwMappedReasonAndPhase != 0 );

    if (dwMappedReasonAndPhase < (1<<maxSinglePhaseReasons))
        return dwMappedReasonAndPhase;

    // dwMask == 0x00001F00
    DWORD dwMask = (((1<<maxPhases)-1) << maxSinglePhaseReasons);
    for (unsigned i=0; i<maxMultiPhaseReasons; i++)
    {
        if (dwMask & dwMappedReasonAndPhase)
            return (dwMappedReasonAndPhase | dwMask);

        dwMask = dwMask << maxPhases;
    }
    Win4Assert(! "MapAllPhases - fell out of loop!" );
    return 0;
}

//+-------------------------------------------------------------------------
//
//  Method:     IRowsetNotify::OnXxxxChange
//
//  Synopsis:   Dispatches CRowsetNotification notifications to clients.
//
//  Returns:    SCODE
//
//  History:    11 Mar 1998     AlanW
//
//--------------------------------------------------------------------------

SCODE CRowsetNotification::OnFieldChange (
    IRowset *    pRowset,
    HROW         hRow,
    DBORDINAL    cColumns,
    DBORDINAL    rgColumns[],
    DBREASON     eReason,
    DBEVENTPHASE ePhase,
    BOOL         fCantDeny )
{
    SCODE sc = S_OK;

    //  NOTE:  OnFieldChange is not generated by our rowsets.  This code
    //         doesn't handle unwanted phases or reasons.

    CEnumConnectionsLite Enum( *this );
    CConnectionPointBase::CConnectionContext *pConnCtx = Enum.First();

    while ( pConnCtx )
    {
        IRowsetNotify *pNotify = (IRowsetNotify *)(pConnCtx->_pIUnk);
        tbDebugOut(( DEB_NOTIFY, "rownotfy: pinging notify client %x\n", pNotify ));
        SCODE sc1 = pNotify->OnFieldChange( pRowset,
                                             hRow,
                                             cColumns,
                                             rgColumns,
                                             eReason,
                                             ePhase,
                                             fCantDeny );
        tbDebugOut(( DEB_NOTIFY, "rownotfy:(end) pinging notify client\n" ));
        pConnCtx = Enum.Next();
    }
    return sc;
}

SCODE CRowsetNotification::OnRowChange (
    IRowset *    pRowset,
    DBCOUNTITEM  cRows,
    const HROW   rghRows[],
    DBREASON     eReason,
    DBEVENTPHASE ePhase,
    BOOL         fCantDeny )
{
    // Note:  we don't generate any row notifications which can be denied.
    Win4Assert( fCantDeny && DBEVENTPHASE_DIDEVENT == ePhase );

    DWORD dwMask = MapPhaseAndReason( ePhase, eReason );
    CEnumConnectionsLite Enum( *this );
    CConnectionPointBase::CConnectionContext *pConnCtx = Enum.First();

    while ( pConnCtx )
    {
        if (0 == (pConnCtx->_dwSpare & dwMask))
        {
            IRowsetNotify *pNotify = (IRowsetNotify *)(pConnCtx->_pIUnk);
            tbDebugOut(( DEB_NOTIFY, "rownotfy: pinging notify client %x\n", pNotify ));
            SCODE sc1 = pNotify->OnRowChange( pRowset,
                                              cRows,
                                              rghRows,
                                              eReason,
                                              ePhase,
                                              fCantDeny );
            tbDebugOut(( DEB_NOTIFY, "rownotfy:(end) pinging notify client\n" ));
            if (DB_S_UNWANTEDPHASE == sc1)
                pConnCtx->_dwSpare |= dwMask;
            else if (DB_S_UNWANTEDREASON == sc1)
                pConnCtx->_dwSpare |= MapAllPhases(dwMask);
        }
        pConnCtx = Enum.Next();
    }
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CRowsetNotification::DoRowsetChangeCallout, private
//
//  Synopsis:   Issues an OnRowsetChange notification to all active
//              advises.  If [fCantDeny] is FALSE, tracks which advises
//              were successfully notified and checks the votes.
//
//  Arguments:  [Enum]      - a connection context enumeration
//              [pRowset]   - the rowset issuing the notification
//              [eReason]   - the notification reason
//              [ePhase]    - the notification phase
//              [fCantDeny] - if TRUE, notification can't be denied
//
//  Notes:      CPC critical section is assumed to be held.
//
//  History:    08 Apr 1998     AlanW
//
//--------------------------------------------------------------------------

BOOL CRowsetNotification::DoRowsetChangeCallout (
    CEnumConnectionsLite & Enum,
    IRowset *    pRowset,
    DBREASON     eReason,
    DBEVENTPHASE ePhase,
    BOOL         fCantDeny )
{
    DWORD dwMask = MapPhaseAndReason( ePhase, eReason );
    CConnectionPointBase::CConnectionContext *pConnCtx;
    BOOL fVeto = FALSE;

    for ( pConnCtx = Enum.First(); pConnCtx; pConnCtx = Enum.Next() )
    {
        if ( 0 == (pConnCtx->_dwSpare & dwMask) )
        {
            IRowsetNotify *pNotify = (IRowsetNotify *)(pConnCtx->_pIUnk);
            tbDebugOut(( DEB_NOTIFY, "rownotfy: pinging notify client %x\n", pNotify ));
            SCODE sc1 = pNotify->OnRowsetChange( pRowset,
                                                 eReason,
                                                 ePhase,
                                                 fCantDeny );

            if ( !fCantDeny )
            {
                if (S_FALSE == sc1)
                {
                    tbDebugOut(( DEB_NOTIFY, "rownotfy: notify client veto'ed\n" ));
                    fVeto = TRUE;
                    break;
                }
                pConnCtx->_dwSpare |= bitDidNotifyVote;
            }
            if (DB_S_UNWANTEDPHASE == sc1)
                pConnCtx->_dwSpare |= dwMask;
            else if (DB_S_UNWANTEDREASON == sc1)
                pConnCtx->_dwSpare |= MapAllPhases(dwMask);

            tbDebugOut(( DEB_NOTIFY, "rownotfy:(end) pinging notify client\n" ));
        }
    }
    return fVeto;
}


SCODE CRowsetNotification::OnRowsetChange (
    IRowset *    pRowset,
    DBREASON     eReason,
    DBEVENTPHASE ePhase,
    BOOL         fCantDeny )
{
    // Note: we don't use SYNCHAFTER, and ABOUTTODO is done here after voting
    Win4Assert( DBEVENTPHASE_ABOUTTODO != ePhase &&
                DBEVENTPHASE_SYNCHAFTER != ePhase );

    BOOL fVeto = FALSE;
    CEnumConnectionsLite Enum( *this );

    if ( DBEVENTPHASE_OKTODO == ePhase )
    {
        Win4Assert( !fCantDeny );

        fVeto = DoRowsetChangeCallout( Enum, pRowset, eReason,
                                            DBEVENTPHASE_OKTODO, FALSE );
        if ( ! fVeto )
            fVeto = DoRowsetChangeCallout( Enum, pRowset, eReason,
                                                DBEVENTPHASE_ABOUTTODO, FALSE );

        DWORD dwMask = MapPhaseAndReason( DBEVENTPHASE_FAILEDTODO, eReason );
        CConnectionPointBase::CConnectionContext *pConnCtx;

        for ( pConnCtx = Enum.First(); pConnCtx; pConnCtx = Enum.Next() )
        {
            if (fVeto &&
                0 == (pConnCtx->_dwSpare & dwMask) &&
                0 != (pConnCtx->_dwSpare & bitDidNotifyVote) )
            {
                IRowsetNotify *pNotify = (IRowsetNotify *)(pConnCtx->_pIUnk);
                tbDebugOut(( DEB_NOTIFY, "rownotfy: pinging notify client %x for FAIL\n", pNotify ));
                SCODE sc1 = pNotify->OnRowsetChange( pRowset,
                                                     eReason,
                                                     DBEVENTPHASE_FAILEDTODO,
                                                     TRUE );
                tbDebugOut(( DEB_NOTIFY, "rownotfy:(end) pinging notify client for FAIL\n" ));

                if (DB_S_UNWANTEDPHASE == sc1)
                    pConnCtx->_dwSpare |= dwMask;
                else if (DB_S_UNWANTEDREASON == sc1)
                    pConnCtx->_dwSpare |= MapAllPhases(dwMask);
            }
            pConnCtx->_dwSpare &= ~bitDidNotifyVote;
        }
    }
    else
    {
        // a non-vetoable notification; just send the notifies
        Win4Assert( fCantDeny );
        DoRowsetChangeCallout( Enum, pRowset, eReason, ePhase, TRUE );
    }
    return fVeto ? S_FALSE : S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\seqquery.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       seqquery.cxx
//
//  Contents:   Declarations of classes which implement sequential ICursor
//              and related OLE DB interfaces over file stores.
//
//  Classes:    CSeqQuery - container of table/query for a set of seq cursors
//
//  History:    09-Jan-95       DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <tblalloc.hxx>
#include <rowseek.hxx>
#include <tblvarnt.hxx>

#include "tabledbg.hxx"
#include "seqquery.hxx"

//+---------------------------------------------------------------------------
//
//  Class:      CSeqQuery
//
//  Purpose:    Encapsulates a sequential query execution context, and PID
//              mapper for use by a row cursor.
//
//  Arguments:  [qopt]         - Query optimizer
//              [col]          - Initial set of columns to return
//              [pulCursors]   - cursor returned
//              [pidremap]     - prop ID mapping
//              [pDocStore]    - client doc store
//
//  History:    09 Jan 95       DwightKr    Created
//
//----------------------------------------------------------------------------

CSeqQuery::CSeqQuery( XQueryOptimizer & qopt,
                      XColumnSet & col,
                      ULONG *pulCursor,
                      XInterface<CPidRemapper> & pidremap,
                      ICiCDocStore *pDocStore
                    )
        : PQuery( ),
          _ref( 1 ),
          _pidremap( pidremap.Acquire() ),
          _QExec( 0 )
{
    //
    // Get ci manager and translator interfaces
    //
    ICiManager *pCiManager = 0;
    SCODE sc = pDocStore->GetContentIndex( &pCiManager );
    if ( FAILED( sc ) )
    {
        Win4Assert( !"Need to support GetContentIndex interface" );

        THROW( CException( sc ) );
    }
    _xCiManager.Set( pCiManager );

    ICiCDocNameToWorkidTranslator *pNameToWidTranslator;
    sc = pDocStore->QueryInterface( IID_ICiCDocNameToWorkidTranslator,
                                    (void **) &pNameToWidTranslator );
    if ( FAILED( sc ) )
    {
        Win4Assert( !"Need to support translator QI" );

        THROW( CException( sc ) );
    }
    _xNameToWidTranslator.Set( pNameToWidTranslator );

    _QExec.Set( new CQSeqExecute( qopt ) );
    *pulCursor = _CreateRowCursor();

    ciDebugOut(( DEB_USER1, "Using a sequential cursor.\n" ));
}

//+---------------------------------------------------------------------------
//
//  Member:     CSeqQuery::AddRef, public
//
//  Synopsis:   Reference the query.
//
//  History:    19-Jan-95   DwightKr    Created
//
//----------------------------------------------------------------------------
ULONG CSeqQuery::AddRef(void)
{
    return InterlockedIncrement( &_ref );
}


//+---------------------------------------------------------------------------
//
//  Member:     CSeqQuery::Release, public
//
//  Synopsis:   De-Reference the query.
//
//  Effects:    If the ref count goes to 0 then the query is deleted.
//
//  History:    19-Jan-95   DwightKr    Created
//
//----------------------------------------------------------------------------
ULONG CSeqQuery::Release(void)
{
    long l = InterlockedDecrement( &_ref );
    if ( l <= 0 )
    {
        tbDebugOut(( DEB_ITRACE, "CSeqQuery unreferenced.  Deleting.\n" ));
        delete this;
        return 0;
    }

    return l;
}

//+-------------------------------------------------------------------------
//
//  Member:     CSeqQuery::FetchDeferredValue
//
//  Synopsis:   Fetch value from property cache
//
//  Arguments:  [wid] -- Workid.
//              [ps]  -- Property to be fetched.
//              [var] -- Property returned here.
//
//  History:    Jun-1-95   KyleP   Created
//
//--------------------------------------------------------------------------

BOOL CSeqQuery::FetchDeferredValue( WORKID wid,
                                    CFullPropSpec const & ps,
                                    PROPVARIANT & var )
{
    return _QExec->FetchDeferredValue( wid, ps, var );
}

//
//  Methods supporting IRowset
//
//+---------------------------------------------------------------------------
//
//  Member:     CSeqQuery::SetBindings, public
//
//  Synopsis:   Set column bindings into a cursor
//
//  Arguments:  [hCursor] - the handle of the cursor to set bindings on
//              [cbRowLength] - the width of an output row
//              [cols] - a description of column bindings to be set
//              [pids] - a PID mapper which maps fake pids in cols to
//                      column IDs.
//
//  Returns:    nothing - failures are thrown.  E_FAIL
//                      is thrown if hCursor cannot be looked up,
//                      presumably an internal error.
//
//  History:    19-Jan-95   DwightKr    Created
//
//----------------------------------------------------------------------------
void CSeqQuery::SetBindings(
    ULONG             hCursor,
    ULONG             cbRowLength,
    CTableColumnSet & cols,
    CPidMapper &      pids )
{
    _VerifyHandle(hCursor);

    if (0 == cols.Count() ||
        0 == cbRowLength || cbRowLength >= USHRT_MAX)
        THROW( CException( E_INVALIDARG ));

    XPtr<CTableColumnSet> outset(new CTableColumnSet( cols.Count() ));

    for (unsigned iCol = 0; iCol < cols.Count(); iCol++)
    {
        CTableColumn * pCol = cols.Get( iCol );

        CFullPropSpec * propspec = pids.Get( pCol->PropId );

        //
        //  Convert the DBID to a PROPID
        //

//      Win4Assert( iCol+1 == pCol->PropId );   // Therefore pids is useless

        PROPID prop = _pidremap->NameToReal(propspec);

        if ( prop == pidInvalid )
            THROW( CException( DB_E_BADCOLUMNID ));

        if (pCol->IsCompressedCol())
            THROW( CException( E_INVALIDARG ));

        XPtr<CTableColumn> xpOutcol ( new CTableColumn( prop, pCol->GetStoredType() ) );

        if (pCol->IsValueStored())
            xpOutcol->SetValueField(pCol->GetStoredType(),
                                    pCol->GetValueOffset(),
                                    pCol->GetValueSize());

        Win4Assert( pCol->IsStatusStored() );
        xpOutcol->SetStatusField(pCol->GetStatusOffset(),
                                 (USHORT)pCol->GetStatusSize());

        if (pCol->IsLengthStored())
            xpOutcol->SetLengthField(pCol->GetLengthOffset(),
                                     (USHORT)pCol->GetLengthSize());

        outset->Add(xpOutcol, iCol);
    }

    SCODE sc = _cursor.SetBindings( cbRowLength, outset );

    if ( FAILED( sc ) )
        THROW( CException( sc ) );
} //SetBindings


//+-------------------------------------------------------------------------
//
//  Member:     CSeqQuery::RatioFinished, public
//
//  Synopsis:   Return the completion status as a fraction
//
//  Arguments:  [hCursor] - the handle of the cursor to check completion for
//              [rulDenominator] - on return, denominator of fraction
//              [rulNumerator] - on return, numerator of fraction
//              [rcRows] - on return, number of rows in cursor
//              [rfNewRows] - on return, TRUE if new rows available
//
//  Returns:    nothing
//
//  Notes:      A value of 0 for hCursor is allowed so that completion
//              can be checked before a handle exists.
//
//--------------------------------------------------------------------------

void  CSeqQuery::RatioFinished(
                                ULONG   hCursor,
                                DBCOUNTITEM & rulDenominator,
                                DBCOUNTITEM & rulNumerator,
                                DBCOUNTITEM & rcRows,
                                BOOL &  rfNewRows
                               )
{
    if ( 0 != hCursor )
        _VerifyHandle(hCursor);

    rulDenominator = 1;
    rulNumerator   = 1;
    rcRows = 0;                 // we don't know how many there are...
    rfNewRows      = FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSeqQuery::GetRows, public
//
//  Synopsis:   Retrieve row data for a table cursor
//
//  Arguments:  [hCursor] - the handle of the cursor to fetch data for
//              [rSeekDesc] - row seek operation to be done before fetch
//              [rFetchParams] - row fetch parameters and buffer pointers
//
//  Returns:    SCODE - the status of the operation.  E_FAIL
//                      is thrown if hCursor cannot be looked up,
//                      presumably an internal error.
//
//  History:    19-Jan-95   DwightKr    Created
//
//----------------------------------------------------------------------------
SCODE CSeqQuery::GetRows(
                         ULONG hCursor,
                         const CRowSeekDescription& rSeekDesc,
                         CGetRowsParams& rFetchParams,
                         XPtr<CRowSeekDescription>& pSeekDescOut
                        )
{
    _VerifyHandle( hCursor );

    if ( ! rSeekDesc.IsCurrentRowSeek() )
        THROW( CException( E_FAIL ) );

    CRowSeekNext* pRowSeek = (CRowSeekNext*) &rSeekDesc;

    unsigned cRowsToSkip = pRowSeek->GetSkip();
    _cursor.ValidateBindings();

    SCODE scRet = _QExec->GetRows( _cursor.GetBindings(),
                                   cRowsToSkip,
                                   rFetchParams );

    if (FAILED(scRet))
    {
        tbDebugOut(( DEB_WARN, "CSeqQuery::GetRows got sc=%x\n",
                           scRet ));
    }

    if (DB_S_BLOCKLIMITEDROWS == scRet)
        pSeekDescOut.Set( new CRowSeekNext(pRowSeek->GetChapter(), 0) );

    return scRet;
} //GetRows


//+-------------------------------------------------------------------------
//
//  Member:     CSeqQuery::GetQueryStatus, public
//
//  Synopsis:   Return the query status
//
//  Arguments:  [hCursor] - the handle of the cursor to check completion for
//              [rdwStatus] - on return, the query status
//
//  Returns:    nothing
//
//--------------------------------------------------------------------------

void        CSeqQuery::GetQueryStatus(
    ULONG           hCursor,
    DWORD &         rdwStatus)
{
    _VerifyHandle( hCursor );

    rdwStatus = _QExec->Status();
}

//+-------------------------------------------------------------------------
//
//  Member:     CSeqQuery::GetQueryStatusEx, public
//
//  Synopsis:   Return the query status plus bonus information.  It's kind
//              of an odd assortment of info, but it saves net trips.
//
//  Arguments:  [hCursor] - handle of the cursor to check completion for
//              [rdwStatus] - returns the query status
//              [rcFilteredDocuments] - returns # of filtered docs
//              [rcDocumentsToFilter] - returns # of docs to filter
//              [rdwRatioFinishedDenominator] - ratio finished denom
//              [rdwRatioFinishedNumerator]   - ratio finished num
//              [bmk]                         - bmk to find
//              [riRowBmk]                    - index of bmk row
//              [rcRowsTotal]                 - # of rows in table
//
//  History:    Nov-9-96   dlee    Created
//
//--------------------------------------------------------------------------

void CSeqQuery::GetQueryStatusEx(
     ULONG           hCursor,
     DWORD &         rdwStatus,
     DWORD &         rcFilteredDocuments,
     DWORD &         rcDocumentsToFilter,
     DBCOUNTITEM &   rdwRatioFinishedDenominator,
     DBCOUNTITEM &   rdwRatioFinishedNumerator,
     CI_TBL_BMK      bmk,
     DBCOUNTITEM &   riRowBmk,
     DBCOUNTITEM &   rcRowsTotal )
{
    GetQueryStatus( hCursor, rdwStatus );

    CIF_STATE state;
    state.cbStruct = sizeof state;
    SCODE sc = _xCiManager->GetStatus( &state );
    if ( SUCCEEDED( sc ) )
    {
        rcFilteredDocuments = state.cFilteredDocuments;
        rcDocumentsToFilter = state.cDocuments;
    }
    else
    {
        ciDebugOut(( DEB_ERROR,
                     "CSeqQuery::GetQueryStatusEx, get status failed, 0x%x\n", sc ));

        rcFilteredDocuments = 0;
        rcDocumentsToFilter = 0;
    }

    // sequential query -- it's done

    rdwRatioFinishedDenominator = 1;
    rdwRatioFinishedNumerator = 1;

    // sequential query -- this info isn't available

    riRowBmk = 0;
    rcRowsTotal = 0;
} //GetQueryStatusEx

//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::WorkIdToPath
//
//  Synopsis:   Converts a wid to a path
//
//  Arguments:  [wid]       -- of the file to be translated
//              [funnyPath] -- resulting path
//
//  History:    Oct-5-96   dlee    Created
//
//--------------------------------------------------------------------------

void CSeqQuery::WorkIdToPath(
    WORKID          wid,
    CFunnyPath & funnyPath )
{
    ICiCDocName *pDocName;
    SCODE sc = _xNameToWidTranslator->QueryDocName( &pDocName );
    if ( SUCCEEDED( sc ) )
    {
        XInterface<ICiCDocName> xDocName( pDocName );

        sc = _xNameToWidTranslator->WorkIdToDocName( wid,
                                                     xDocName.GetPointer() );
        if ( SUCCEEDED( sc ) && sc != CI_S_WORKID_DELETED )
        {

            // PERFFIX: Here we are using two buffers XGrowable and
            // CFunnyPath.  This can be avoided if xDocName->Get can take
            // in CFunnyPath instead of WCHAR*

            XGrowable<WCHAR> xBuf(MAX_PATH);
            ULONG cb = xBuf.SizeOf();

            sc = xDocName->Get( (BYTE *) xBuf.Get(), &cb );
            if ( CI_E_BUFFERTOOSMALL == sc )
            {
                xBuf.SetSizeInBytes( cb );
                sc = xDocName->Get( (BYTE *) xBuf.Get(), &cb );
            }

            if ( SUCCEEDED( sc ) )
                funnyPath.SetPath( xBuf.Get() );
        }
    }
} //WorkIdToPath
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\rowset.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       rowset.cxx
//
//  Contents:   OLE DB IRowset implementation for file stores.
//              Runs entirely in user space at the client machine.
//
//  Classes:    CRowset
//
//  History:    07 Nov 94       AlanW      Created
//              07 May 97       KrishnaN   Added Ole-DB error support
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <initguid.h>       // needed for IServiceProperties
#include <rowset.hxx>
#include <query.hxx>
#include <rownotfy.hxx>
#include <tgrow.hxx>

#include "tabledbg.hxx"

const unsigned MAX_ROW_FETCH = 1000;

inline DBROWSTATUS ScodeToRowstatus( SCODE sc )
{
    switch (sc)
    {
    case S_OK:
        return DBROWSTATUS_S_OK;

    case E_INVALIDARG:
    case DB_E_BADBOOKMARK:
        return DBROWSTATUS_E_INVALID;

    case E_OUTOFMEMORY:
        return DBROWSTATUS_E_OUTOFMEMORY;

    default:
        tbDebugOut(( DEB_ERROR, "ScodeToRowStatus: missing conversion for %x\n", sc ));
        Win4Assert( FAILED( sc ) );
        return DBROWSTATUS_E_INVALID;
    }
}

// Rowset object Interfaces that support Ole DB error objects
static const IID * apRowsetErrorIFs[] =
{
        &IID_IAccessor,
        &IID_IChapteredRowset,
        &IID_IColumnsInfo,
        &IID_IColumnsRowset,
        &IID_IConnectionPointContainer,
        &IID_IConvertType,
        &IID_IDBAsynchStatus,
        &IID_IRowset,
        //&IID_IRowsetAsynch,
        &IID_IRowsetIdentity,
        &IID_IRowsetInfo,
        &IID_IRowsetLocate,
        &IID_IRowsetQueryStatus,
        //&IID_IRowsetResynch,
        &IID_IRowsetScroll,
        //&IID_IRowsetUpdate,
        &IID_IRowsetWatchAll,
        &IID_IRowsetWatchRegion,
        //&IID_ISupportErrorInfo,
        &IID_IServiceProperties,
};

static const ULONG cRowsetErrorIFs  = sizeof(apRowsetErrorIFs)/sizeof(apRowsetErrorIFs[0]);

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::CRowset, public
//
//  Synopsis:   Creates a locally accessible Table
//
//  Arguments:  [pUnkOuter] - Outer unknown
//              [ppMyUnk] - OUT:  filled in with pointer to non-delegated
//                          IUnknown on return
//              [cols]    - A reference to the output column set
//              [pidmap]  - a pid mapper for column IDs and names in cols
//              [rQuery]  - A reference to an instantiated query
//              [rControllingQuery] - OLE controlling unknown (IQuery)
//              [fIsCategorized]  - TRUE if not the highest-level rowset
//              [xProps]  - Rowset properties, indicates special semantics,
//                          such as sequential cursor, use CI for prop
//                          queries.
//              [hCursor] - table cursor handle.
//              [aAccessors]   -- Bag of accessors which rowsets need to inherit
//
//  Notes:      Ownership of the output column set may be transferred to
//              the table cursor.
//
//----------------------------------------------------------------------------

CRowset::CRowset(
    IUnknown *            pUnkOuter,
    IUnknown **           ppMyUnk,
    CColumnSet const &    cols,
    CPidMapperWithNames   const & pidmap,
    PQuery &              rQuery,
    IUnknown &            rControllingQuery,
    BOOL                  fIsCategorized,
    XPtr<CMRowsetProps> & xProps,
    ULONG                 hCursor,
    CAccessorBag &        aAccessors,
    IUnknown *            pUnkCreator )
        :_rQuery( rQuery ),
         _xProperties( xProps.Acquire() ),
         _hCursor( hCursor ),
         _pRowBufs(0),
         _pConnectionPointContainer( 0 ),
         _pRowsetNotification( 0 ),
         _pAsynchNotification( 0 ),
         _fForwardOnly( (_xProperties->GetPropertyFlags() & eLocatable) == 0),
#pragma warning(disable : 4355) // 'this' in a constructor
         _ColumnsInfo( cols,
                       pidmap,
                       _DBErrorObj,
                       * ((IUnknown *) (IRowsetScroll *) this),
                       _fForwardOnly ),
         _aAccessors( (IUnknown *) (IRowset *)this ),
         _DBErrorObj( * ((IUnknown *) (IRowset *) this), _mutex ),
         _impIUnknown(rControllingQuery, this),
#pragma warning(default : 4355)    // 'this' in a constructor
         _PropInfo(),
         _fIsCategorized( fIsCategorized ),
         _fExtendedTypes( (_xProperties->GetPropertyFlags() & eExtendedTypes) != 0 ),
         _fHoldRows( (_xProperties->GetPropertyFlags() & eHoldRows) != 0 ),
         _fAsynchronous( (_xProperties->GetPropertyFlags() & eAsynchronous) != 0),
         _pRelatedRowset( 0 ),
         _pChapterRowbufs( 0 )
{
    Win4Assert(_hCursor != 0);
    if (_hCursor == 0)
        THROW(CException(E_NOINTERFACE));

    if (pUnkOuter)
        _pControllingUnknown = pUnkOuter;
    else
        _pControllingUnknown = (IUnknown * )&_impIUnknown;

    _DBErrorObj.SetInterfaceArray(cRowsetErrorIFs, apRowsetErrorIFs);

    ULONG obRowRefcount, obRowWorkId;
    ULONG obChaptRefcount, obChaptId;
    _ColumnsInfo.SetColumnBindings( rQuery, _hCursor,
                                    obRowRefcount, obRowWorkId,
                                    obChaptRefcount, obChaptId );

    //
    // GetBindings for each accessor in bag, and use them to create accessor
    // in IRowset
    //
    // only CAccessors can be used by commands

    CAccessorBase * pAccBase = (CAccessorBase *)aAccessors.First();
    while ( 0 != pAccBase )
    {
        DBCOUNTITEM cBindings;
        DBBINDING * rgBindings;
        DBACCESSORFLAGS dwAccessorFlags;
        SCODE sc = pAccBase->GetBindings( &dwAccessorFlags, &cBindings, &rgBindings);

        if ( FAILED( sc ) )
            THROW( CException( sc ) );
  
        HACCESSOR hAccessor;
        sc = CreateAccessor(dwAccessorFlags, cBindings, rgBindings, 0, &hAccessor, 0);
        CoTaskMemFree(rgBindings); //cleanup from GetBindings
        if (FAILED(sc))
            THROW( CException( sc ) );
  
        //
        // inherited accessors are accessed through same hAccessor as original.
        // Set parent of newly created accessor so that we can link the 2 copies.
        // Client never knows the direct HACESSOR for the inherited accessor.
        // All accessor methods check bag for an accessor with a match on
        // the parent or the creator.
        //
        ((CAccessorBase *)hAccessor)->SetParent(pAccBase);
  
        //
        // Increment inheritor count for parent accessor
        //
        pAccBase->IncInheritors();
  
        pAccBase = (CAccessor *)aAccessors.Next();
    }

    _pRowBufs = new CRowBufferSet( _fForwardOnly,
                                   obRowRefcount,
                                   obRowWorkId,
                                   obChaptRefcount,
                                   obChaptId );

    *ppMyUnk = ((IUnknown *)&_impIUnknown);

    // can't fail after this or _pRowBufs will leak

    (*ppMyUnk)->AddRef();
    rQuery.AddRef();

    if ( 0 != pUnkCreator )
    {
        _xUnkCreator.Set( pUnkCreator );        
        _xUnkCreator->AddRef();
    }

} //CRowset


//+---------------------------------------------------------------------------
//
//  Member:     CRowset::~CRowset, public
//
//  Synopsis:   Destroy the rowset and its component objects
//
//----------------------------------------------------------------------------

CRowset::~CRowset()
{
    Win4Assert( _impIUnknown._ref == 0 );
    Win4Assert( _hCursor != 0 );

    delete _pRowBufs;

    // free cursor will fail if the pipe is broken

    TRY
    {
        if ( !_pRowsetNotification.IsNull() )
            _pRowsetNotification->OnRowsetChange( this,
                                                  DBREASON_ROWSET_RELEASE,
                                                  DBEVENTPHASE_DIDEVENT,
                                                  TRUE);
        _rQuery.FreeCursor( _hCursor );
    }
    CATCH( CException, e )
    {
    }
    END_CATCH;

    if ( !_pRowsetNotification.IsNull() )
        _pRowsetNotification->StopNotifications();
    delete _pConnectionPointContainer;

    _rQuery.Release();
} //~CRowset

//+-------------------------------------------------------------------------
//
//  Member:     CRowset::RealQueryInterface, public
//
//  Synopsis:   Get a reference to another interface on the cursor
//
//  Notes:      ref count is incremented inside QueryInterface
//
//--------------------------------------------------------------------------

SCODE CRowset::RealQueryInterface(
    REFIID ifid,
    void * *ppiuk )
{
    SCODE sc = S_OK;

    *ppiuk = 0;

    // note -- IID_IUnknown covered in QueryInterface

    if ( IID_IRowset == ifid )
    {
        *ppiuk = (void *) (IRowset *) this;
    }
    else if ( IID_IAccessor == ifid )
    {
        *ppiuk = (void *) (IAccessor *) this;
    }
    else if ( IID_IRowsetInfo == ifid )
    {
        *ppiuk = (void *) (IRowsetInfo *) this;
    }
    else if ( IID_IColumnsInfo == ifid )
    {
        *ppiuk = (void *) (IColumnsInfo *) &_ColumnsInfo;
    }
    else if (IID_ISupportErrorInfo == ifid)
    {
        *ppiuk = (void *) ((IUnknown *) (ISupportErrorInfo *) &_DBErrorObj);
    }
    else if ( IID_IConvertType == ifid )
    {
        *ppiuk = (void *) (IConvertType *) this;
    }
#if 0   // NEWFEATURE - not implemented now.
    else if ( IID_IColumnsRowset == ifid )
    {
        *ppiuk = (void *) (IColumnsRowset *) &_ColumnsInfo;
    }
#endif // 0     // NEWFEATURE - not implemented now.
    else if ( IID_IRowsetQueryStatus == ifid )
    {
        *ppiuk = (void *) (IRowsetQueryStatus *) this;
    }
    else if ( IID_IServiceProperties == ifid )
    {
        *ppiuk = (void *) (IServiceProperties *) this;
    }
    else if ( IID_IConnectionPointContainer == ifid )
    {
        // Watch notifications are only supported over the
        // bottom-most of a hierarchical rowset (the one with real rows)

        BOOL fWatchable = ! _pRowBufs->IsChaptered() &&
                          (_xProperties->GetPropertyFlags() & eWatchable) != 0;

        if ( 0 == _pConnectionPointContainer )
        {
            TRY
            {
                XPtr<CConnectionPointContainer> xCPC(
                    new CConnectionPointContainer(
                        _fAsynchronous ? 3 : 1,
                        * ((IUnknown *) (IRowsetScroll *) this),
                        _DBErrorObj) );

                if (_fAsynchronous)
                {
                    _pAsynchNotification =
                        new CRowsetAsynchNotification(
                            _rQuery, _hCursor, this, _DBErrorObj, 
                            fWatchable );
                    _pRowsetNotification.Set( _pAsynchNotification );
                }
                else
                {
                    _pRowsetNotification.Set ( new CRowsetNotification( ) );
                }

                _pRowsetNotification->AddConnectionPoints( xCPC.GetPointer() );
                _pConnectionPointContainer = xCPC.Acquire();
            }
            CATCH( CException, e )
            {
                sc = GetOleError( e );
            }
            END_CATCH;
        }

        if ( S_OK == sc )
        {
            Win4Assert( 0 != _pConnectionPointContainer );
            *ppiuk = (void *) (IConnectionPointContainer *)
                     _pConnectionPointContainer;
        }
    }
    else if (! _fForwardOnly)
    {
        if ( IID_IRowsetScroll == ifid )
        {
            *ppiuk = (void *) (IRowsetScroll *) this;
        }
        else if ( IID_IRowsetExactScroll == ifid )
        {
            *ppiuk = (void *) (IRowsetExactScroll *) this;
        }
        else if ( IID_IRowsetLocate == ifid )
        {
            *ppiuk = (void *) (IRowsetLocate *) this;
        }
        else if ( IID_IRowsetIdentity == ifid )
        {
            *ppiuk = (void *) (IRowsetIdentity *) this;
        }
        else if ( IID_IChapteredRowset == ifid )
        {
            Win4Assert( (_pChapterRowbufs != 0) == _fIsCategorized );
            if (_pChapterRowbufs)
            {
                *ppiuk = (void *) (IChapteredRowset *) this;
            }
        }
        else if ( _fAsynchronous )
        {
            if ( IID_IDBAsynchStatus == ifid )
            {
                *ppiuk = (void *) (IDBAsynchStatus *) this;
            }
            else if ( IID_IRowsetAsynch == ifid )
            {
                *ppiuk = (void *) (IRowsetAsynch *) this;
            }
            else if (IID_IRowsetWatchRegion == ifid)
            {
                *ppiuk = (void *) (IRowsetWatchRegion *) this;
            }
            else if (IID_IRowsetWatchAll == ifid)
            {
                *ppiuk = (void *) (IRowsetWatchAll *) this;
            }
        }
    }

    if ( 0 == *ppiuk )
    {
        sc = E_NOINTERFACE;
    }

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRowset::CImpIUnknown::AddRef, public
//
//  Synopsis:   Reference the cursor.
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CRowset::CImpIUnknown::AddRef(void)
{
    long ref = InterlockedIncrement( &_ref );

    if ( ref > 0 )
        _rControllingQuery.AddRef();

    return ref ;
} //AddRef

//+-------------------------------------------------------------------------
//
//  Member:     CRowset::CImpIUnknown::Release, public
//
//  Synopsis:   De-Reference the cursor.
//
//  Effects:    If the ref count goes to 0 then the cursor is deleted.
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CRowset::CImpIUnknown::Release(void)
{
    long ref = InterlockedDecrement( &_ref );

    if ( ref >= 0 )
        _rControllingQuery.Release(); // may cause a delete of the rowset

    return ref;
} //Release


//+---------------------------------------------------------------------------
//
//  Member:     CRowset::GetProperties, public
//
//  Synopsis:   Return information about the capabilities of the rowset
//
//  Arguments:  [cPropertyIDSets]  - number of property ID sets or zero
//              [rgPropertyIDSets] - array of desired property ID sets or NULL
//              [pcPropertySets]   - number of DBPROPSET structures returned
//              [prgPropertySets]  - array of returned DBPROPSET structures
//
//
//  Returns:    SCODE
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::GetProperties(
    const ULONG         cPropertyIDSets,
    const DBPROPIDSET   rgPropertyIDSets[],
    ULONG *             pcPropertySets,
    DBPROPSET **        prgPropertySets)
{
    _DBErrorObj.ClearErrorInfo();

    if ( (0 != cPropertyIDSets && 0 == rgPropertyIDSets) ||
         0 == pcPropertySets ||
         0 == prgPropertySets )
    {
        if (pcPropertySets)
           *pcPropertySets = 0;
        if (prgPropertySets)
           *prgPropertySets = 0;
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowsetInfo);
    }


    SCODE scResult = S_OK;
    *pcPropertySets = 0;
    *prgPropertySets = 0;


    TRY
    {
        //
        // Update ROWSETQUERYSTATUS property
        //
        DWORD dwStatus;
        _rQuery.GetQueryStatus( _hCursor, dwStatus );

        _xProperties->SetValLong( CMRowsetProps::eid_DBPROPSET_MSIDXS_ROWSET_EXT,
                                  CMRowsetProps::eid_MSIDXSPROPVAL_ROWSETQUERYSTATUS,
                                  dwStatus );

        scResult = _xProperties->GetProperties( cPropertyIDSets,
                                                rgPropertyIDSets,
                                                pcPropertySets,
                                                prgPropertySets );
        if (FAILED(scResult))
            _DBErrorObj.PostHResult(scResult, IID_IRowsetInfo);
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetInfo);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}


//+---------------------------------------------------------------------------
//
// Member:      CRowset::RatioFinished, public
//
// Synopsis:    Returns the completion status of the query.
//
// Arguments:   [pulDenominator] - on return, denominator of fraction
//              [pulNumerator]   - on return, numerator of fraction
//              [pcRows]         - on return, number of rows
//              [pfNewRows]      - on return, TRUE if new rows in the table
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::RatioFinished(
    DBCOUNTITEM *     pulDenominator,
    DBCOUNTITEM *     pulNumerator,
    DBCOUNTITEM *     pcRows,
    BOOL *      pfNewRows) /*const*/
{
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;

    if (0 == pulDenominator ||
        0 == pulNumerator ||
        0 == pcRows ||
        0 == pfNewRows)
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowsetAsynch);

    TRY
    {
        *pcRows = 0;
        _rQuery.RatioFinished( _hCursor,
                               *pulDenominator,
                               *pulNumerator,
                               *pcRows,
                               *pfNewRows );

#if CIDBG
        if ( _fForwardOnly )
            Win4Assert( *pulDenominator == *pulNumerator );
        else
            Win4Assert( *pulDenominator >= *pulNumerator );
#endif // CIDBG
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetAsynch);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}


//+---------------------------------------------------------------------------
//
//  Member:     CRowset::AddRefRows, public
//
//  Synopsis:   Increment the ref. count of a set of row handles
//
//  Arguments:  [cRows]       -- Number of row handles in rghRows
//              [rghRows]     -- Array of HROWs to be ref. counted
//              [rgRefCounts] -- Remaining reference counts on rows (optional)
//              [rgRowStatus] -- Status for each row (optional)
//
//  Returns:    SCODE, DB_E_BADROWHANDLE if a bad row handle is passed in.
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CRowset::AddRefRows(
    DBCOUNTITEM         cRows,
    const HROW          rghRows [],
    DBREFCOUNT          rgRefCounts[],
    DBROWSTATUS         rgRowStatus[])
{
    _DBErrorObj.ClearErrorInfo();

    if (0 == _pRowBufs)
        return _DBErrorObj.PostHResult(E_FAIL, IID_IRowset);

    SCODE scResult = S_OK;
    TRY
    {
        _pRowBufs->AddRefRows(cRows, rghRows, rgRefCounts, rgRowStatus);
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowset);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}


//+---------------------------------------------------------------------------
//
//  Member:     CRowset::ReleaseRows, public
//
//  Synopsis:   Release a set of row handles
//
//  Arguments:  [cRows] -- Number of row handles in rghRows
//              [rghRows] -- Array of HROWs to be released
//              [rgRowOptions] -- Reserved for future use (optional)
//              [rgRefCounts] -- Remaining reference counts on rows (optional)
//              [rgRowStatus] -- Status for each row (optional)
//
//  Returns:    SCODE, DB_E_BADROWHANDLE if a bad row handle is passed in.
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CRowset::ReleaseRows(
    DBCOUNTITEM         cRows,
    const HROW          rghRows [],
    DBROWOPTIONS        rgRowOptions[],
    DBREFCOUNT          rgRefCounts[],
    DBROWSTATUS         rgRowStatus[])
{
    _DBErrorObj.ClearErrorInfo();

    if (0 == _pRowBufs)
        return _DBErrorObj.PostHResult(E_FAIL, IID_IRowset);

//    if (0 != rgRowOptions)
//        return E_FAIL;

    SCODE scResult = S_OK;
    TRY
    {
        BOOL fNotify = FALSE;
        ULONG * pRefCounts = rgRefCounts;
        DBROWSTATUS * pRowStatus = rgRowStatus;

        XArray<ULONG> xrgRefCounts;
        XArray<DBROWSTATUS> xrgRowStatus;

        if ( !_pRowsetNotification.IsNull() &&
             _pRowsetNotification->IsNotifyActive() )
        {
            fNotify = TRUE;
            if ( 0 == pRefCounts )
            {
                xrgRefCounts.Init( (unsigned) cRows);
                pRefCounts = xrgRefCounts.GetPointer();
            }
            if ( 0 == pRowStatus )
            {
                xrgRowStatus.Init( (unsigned) cRows);
                pRowStatus = xrgRowStatus.GetPointer();
            }
        }

        scResult = _pRowBufs->ReleaseRows(cRows, rghRows, pRefCounts, pRowStatus);

        if ( fNotify )
        {
            ULONG cRowsToNotify = 0;
            for (ULONG i=0; i<cRows; i++)
                if ( 0 == pRefCounts[i] && DBROWSTATUS_S_OK == pRowStatus[i] )
                    cRowsToNotify++;

            if (cRowsToNotify)
            {
                XGrowable<HROW,20> xrghRows(cRowsToNotify);

                for (cRowsToNotify=0, i=0; i<cRows; i++)
                    if ( 0 == pRefCounts[i] && DBROWSTATUS_S_OK == pRowStatus[i] )
                    {
                        xrghRows[cRowsToNotify] = rghRows[i];
                        cRowsToNotify++;
                    }

                _pRowsetNotification->OnRowChange( this,
                                                   cRowsToNotify,
                                                   xrghRows.Get(),
                                                   DBREASON_ROW_RELEASE,
                                                   DBEVENTPHASE_DIDEVENT,
                                                   TRUE);
            }
        }
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowset);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}


//+---------------------------------------------------------------------------
//
//  Macro:      CheckCrowsArgs
//
//  Synopsis:   Check common error conditions on cRows and pcRowsObtained
//              for GetRowsXxxx methods.
//
//  Arguments:  [cRows]          -- Number of rows to return
//              [pcRowsObtained] -- On return, number of rows actually
//                                  fetched
//
//  Returns:    SCODE
//
//  Notes:      Needs to be a macro instead of an inline function because
//              it returns from the calling method.
//
//--------------------------------------------------------------------------

#define CheckCrowsArgs(cRows, pcRowsObtained)  \
    if (0 == pcRowsObtained)                   \
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowset);  \
    *pcRowsObtained = 0;                       \
    if (cRows == 0)                            \
        return S_OK;


//+---------------------------------------------------------------------------
//
//  Member:     CRowset::GetRowsAt, public
//
//  Synopsis:   Fetch data starting at some starting bookmark
//
//  Arguments:  [hRegion]        -- handle to watch region
//              [hChapter]       -- Chapter in a multiset cursor
//              [cbBookmark]     -- Size of bookmark for starting position
//              [pBookmark]      -- Pointer to bookmark for starting position
//              [lRowsOffset]    -- Number of row handles in rghRows
//              [cRows]          -- Number of rows to return
//              [pcRowsObtained] -- On return, number of rows actually
//                                  fetched
//              [prghRows]       -- Array of HROWs to be returned
//
//  Returns:    SCODE, E_INVALIDARG for bad parameters, DB_E_BADBOOKMARK
//              if the starting bookmark is invalid
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CRowset::GetRowsAt(
    HWATCHREGION        hRegion,
    HCHAPTER            hChapter,
    DBBKMARK            cbBookmark,
    const BYTE*         pBookmark,
    DBROWOFFSET         lRowsOffset,
    DBROWCOUNT          cRows,
    DBCOUNTITEM *       pcRowsObtained,
    HROW * *            prghRows
) {
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;

    CheckCrowsArgs( cRows, pcRowsObtained );

    TRY
    {
        CI_TBL_BMK bmk = _MapBookmark(cbBookmark, pBookmark);
        CI_TBL_CHAPT chapt = _MapChapter(hChapter);

        CRowSeekAt rowSeek( hRegion, chapt, (LONG) lRowsOffset, bmk );

        scResult = _FetchRows(rowSeek, cRows, pcRowsObtained, prghRows);
        if (FAILED(scResult))
            _DBErrorObj.PostHResult(scResult, IID_IRowsetLocate);
        else if ( !_pRowsetNotification.IsNull() &&
                  *pcRowsObtained != 0 &&
                  _pRowsetNotification->IsNotifyActive() )
        {
            _pRowsetNotification->OnRowChange( this,
                                               *pcRowsObtained,
                                               *prghRows,
                                               DBREASON_ROW_ACTIVATE,
                                               DBEVENTPHASE_DIDEVENT,
                                               TRUE);
        }
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetLocate);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}



//+---------------------------------------------------------------------------
//
//  Member:     CRowset::GetRowsByBookmark, public
//
//  Synopsis:   Fetch data from a set of bookmarks
//
//  Arguments:  [hChapter]       -- Chapter in a multiset cursor
//              [cRows]          -- Number of input bookmarks and rows to return
//              [rgcbBookmark]   -- Array of bookmark sizes
//              [ppBookmarks]    -- Array of pointers to bookmarks
//              [rghRows]        -- Array of HROWs returned
//              [rgRowStatus]    -- Array for per-row status (optional)
//
//  Returns:    SCODE, E_INVALIDARG for bad parameters, DB_E_BADBOOKMARK
//              if the starting bookmark is invalid
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CRowset::GetRowsByBookmark(
    HCHAPTER            hChapter,
    DBCOUNTITEM         cRows,
    const DBBKMARK      rgcbBookmark[],
    const BYTE *        ppBookmarks[],
    HROW                rghRows[],
    DBROWSTATUS         rgRowStatus[]
) {
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;

    if (0 == ppBookmarks ||
        0 == rgcbBookmark ||
        0 == rghRows)
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowsetLocate);

    if (cRows == 0)
        return scResult;

    TRY
    {
        //
        //  Map the input bookmarks to work IDs.  If we see an invalid
        //  bookmark, it will get turned into widInvalid, and its lookup
        //  will fail.
        //
        XArray<CI_TBL_BMK> paBmk( (unsigned) cRows );

        for (unsigned i=0; i < cRows; i++)
        {
            DBROWSTATUS sc = _MapBookmarkNoThrow( rgcbBookmark[i],
                                                  ppBookmarks[i],
                                                  paBmk[i] );
        }

        CI_TBL_CHAPT chapt = _MapChapter(hChapter);

        CRowSeekByBookmark rowSeek( chapt, (ULONG) cRows, paBmk.Acquire() );

        DBCOUNTITEM cRowsObtained;
        TRY
        {
            scResult = _FetchRows(rowSeek, cRows, &cRowsObtained, &rghRows);
        }
        CATCH( CException, e )
        {
            scResult = e.GetErrorCode();
        }
        END_CATCH

        //
        // Return the array of row statuses
        //
        unsigned cErrors = 0;
        for (i=0; i < rowSeek.GetValidStatuses(); i++)
        {
            SCODE scTemp = rowSeek.GetStatus(i);
            if (0 != rgRowStatus)
                rgRowStatus[i] = ScodeToRowstatus( scTemp );

            if (S_OK != scTemp)
            {
                //
                //  The HROW array returned by _FetchRows is compressed,
                //  skipping entries for rows that had errors.  Insert
                //  a DB_NULL_HROW entry for this row.
                //
                if ( i != cRows-1 )
                {
                    memmove( &rghRows[i+1], &rghRows[i], (unsigned) ((cRows-i)-1) * sizeof (HROW));
                }
                rghRows[i] = DB_NULL_HROW;

                //
                //  If the returned error is DB_E_BADBOOKMARK,
                //  call MapBookmarkNoThrow again to distinguish
                //  E_INVALIDARG cases.
                //
                if (DB_E_BADBOOKMARK == scTemp && 0 != rgRowStatus)
                {
                    CI_TBL_BMK bmkTemp;
                    DBROWSTATUS rsTemp = _MapBookmarkNoThrow(rgcbBookmark[i],
                                                             ppBookmarks[i],
                                                             bmkTemp);
                    if (rsTemp != DBROWSTATUS_S_OK)
                    {
                        rgRowStatus[i] = rsTemp;
                    }
                }
                cErrors++;
            }
        }
        Win4Assert( rowSeek.GetValidStatuses() == cRows );

        if (SUCCEEDED(scResult) && cErrors > 0)
            scResult = (cErrors == cRows) ? DB_E_ERRORSOCCURRED :
                                            DB_S_ERRORSOCCURRED;

        if (FAILED(scResult))
            _DBErrorObj.PostHResult(scResult, IID_IRowsetLocate);
        else if ( !_pRowsetNotification.IsNull() &&
                  _pRowsetNotification->IsNotifyActive() )
            _pRowsetNotification->OnRowChange( this,
                                               cRows,
                                               rghRows,
                                               DBREASON_ROW_ACTIVATE,
                                               DBEVENTPHASE_DIDEVENT,
                                               TRUE);
    }

    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetLocate);
        scResult = GetOleError(e);
        Win4Assert(FAILED(scResult));
    }
    END_CATCH;

    return scResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::Compare, public
//
//  Synopsis:   Compare two bookmarks
//
//  Arguments:  [hChapter]   -- chapter
//              [cbBookmark1] -- Size of first bookmark
//              [pBookmark1] -- Pointer to first bookmark
//              [cbBookmark2] -- Size of second bookmark
//              [pBookmark2] -- Pointer to second bookmark
//              [pdwComparison] - on return, hased value of bookmark
//
//  Returns:    SCODE, E_INVALIDARG if cbBookmark is zero or if pBookmark or
//              pdwComparison is NULL, DB_E_BADBOOKMARK for other invalid
//              bookmarks.
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CRowset::Compare(
    HCHAPTER            hChapter,
    DBBKMARK            cbBookmark1,
    const BYTE*         pBookmark1,
    DBBKMARK            cbBookmark2,
    const BYTE*         pBookmark2,
    DBCOMPARE *         pdwComparison) /*const*/
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;

    if (0 == pdwComparison)
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowsetLocate);

    TRY
    {
        ULONG dwHash1 = _MapBookmark(cbBookmark1, pBookmark1);
        ULONG dwHash2 = _MapBookmark(cbBookmark2, pBookmark2);

        //
        //  Set to non-comparable.  This is used later to see if we've
        //  successfully determined the relative order.
        //
        *pdwComparison = DBCOMPARE_NOTCOMPARABLE;

        if (dwHash1 == dwHash2)
        {
            *pdwComparison = DBCOMPARE_EQ;
        }
        else if ( 1 == cbBookmark1 || 1 == cbBookmark2 )
        {
            *pdwComparison = DBCOMPARE_NE;
        }
        else
        {
            CI_TBL_CHAPT chapt = _MapChapter(hChapter);
            _rQuery.Compare( _hCursor,
                             chapt,
                             dwHash1,
                             dwHash2,
                             (DWORD) (*pdwComparison) );
        }
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetLocate);
        sc = GetOleError(e);
    }
    END_CATCH;

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CRowset::_MapChapter, private
//
//  Synopsis:   Map a chapter mark to a ULONG internal chapter mark.
//
//  Arguments:  [hChapter] -- handle of chapter
//
//  Returns:    Chapter as an I4
//
//  Notes:      A null chapter on a categorized rowset means to operate
//              over the entire rowset, not an individual chapter.
//
//--------------------------------------------------------------------------

CI_TBL_CHAPT CRowset::_MapChapter(
    HCHAPTER            hChapter
) const
{
    CI_TBL_CHAPT chapt = (CI_TBL_CHAPT) hChapter;
    Win4Assert (DB_NULL_HCHAPTER == 0);

    if ( !_fIsCategorized && DB_NULL_HCHAPTER != hChapter )
    {
        THROW( CException( DB_E_BADCHAPTER ));
    }

    return chapt;
} //_MapChapter


//+---------------------------------------------------------------------------
//
//  Member:     CRowset::_MapBookmarkNoThrow, private
//
//  Synopsis:   Return a 32 bit hash value for a particular bookmark.
//              Don't throw on errors.
//
//  Arguments:  [cbBookmark] -- Size of bookmark
//              [pBookmark] -- Pointer to bookmark
//
//  Notes:      For IRowsetLocate::Hash and IRowsetLocate::GetRowsByBookmark
//              which want to continue processing on bookmark errors.  Unlike
//              _MapBookmark, DBBMK_FIRST and DBBMK_LAST are invalid.
//
//  Returns:    DBROWSTATUS, hash value (identity function, also the workid
//                      value for the table) is returned in rBmk
//
//--------------------------------------------------------------------------

DBROWSTATUS CRowset::_MapBookmarkNoThrow(
    DBBKMARK            cbBookmark,
    const BYTE*         pBookmark,
    CI_TBL_BMK &        rBmk) const
{
    Win4Assert( !_fForwardOnly );

    rBmk = widInvalid;

    if (0 == cbBookmark || 0 == pBookmark)
        return DBROWSTATUS_E_INVALID;

    if (cbBookmark == 1)
    {
        if (*(BYTE *)pBookmark == DBBMK_FIRST ||
            *(BYTE *)pBookmark == DBBMK_LAST ||
            *(BYTE *)pBookmark == DBBMK_INVALID)
            return DBROWSTATUS_E_INVALID;
        else
            return DBROWSTATUS_E_INVALID; //DB_E_BADBOOKMARK ???
    }
    else if (cbBookmark == sizeof (CI_TBL_BMK))
    {
        rBmk = *(UNALIGNED CI_TBL_BMK *) pBookmark;

        if (rBmk == WORKID_TBLFIRST || rBmk == WORKID_TBLLAST)
            return DBROWSTATUS_E_INVALID;
        return DBROWSTATUS_S_OK;
    }

    return DBROWSTATUS_E_INVALID; //DB_E_BADBOOKMARK ???
} //_MapBookmarkNoThrow

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::_MapBookmark, private
//
//  Synopsis:   Convert a bookmark into an internal form.
//
//  Arguments:  [cbBookmark] -- Size of bookmark
//              [pBookmark] -- Pointer to bookmark
//
//  Returns:    ULONG, hash value (identity function, also the workid
//                      value for the table)
//
//--------------------------------------------------------------------------

CI_TBL_BMK CRowset::_MapBookmark(
    DBBKMARK            cbBookmark,
    const BYTE*         pBookmark) const
{
    Win4Assert( !_fForwardOnly );

    WORKID WorkID = widInvalid;
    Win4Assert( sizeof WORKID == sizeof CI_TBL_BMK );

    if (0 == cbBookmark || 0 == pBookmark)
        THROW(CException(E_INVALIDARG));

    if (cbBookmark == 1)
    {
        if (*(BYTE *)pBookmark == DBBMK_FIRST)
            WorkID = WORKID_TBLFIRST;

        else if (*(BYTE *)pBookmark == DBBMK_LAST)
            WorkID = WORKID_TBLLAST;
    }
    else if (cbBookmark == sizeof (CI_TBL_BMK))
    {
        WorkID = *(UNALIGNED CI_TBL_BMK *) pBookmark;
    }

    if (WorkID == widInvalid)
        THROW(CException(DB_E_BADBOOKMARK));

    return WorkID;
} //_MapBookmark

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::Hash, public
//
//  Synopsis:   Returns an array of 32 bit hash values for bookmarks
//
//  Arguments:  [hChapter]       -- chapter
//              [cBookmarks]     -- # of bmks to hash
//              [rgcbBM]         -- Sizes of each bookmark
//              [ppBM]           -- Pointers to each bookmark
//              [rgHashedValues] -- on return, hashed values of bookmarks
//              [rgBookmarkStatus] -- per-bookmark status (optional)
//
//  Returns:    SCODE, E_INVALIDARG if any cbBookmark is zero,
//              DB_E_BADBOOKMARK for other invalid bookmarks.
//
//--------------------------------------------------------------------------

STDMETHODIMP CRowset::Hash(
    HCHAPTER            hChapter,
    DBBKMARK            cBookmarks,
    const DBBKMARK      rgcbBM[],
    const BYTE *        ppBM[],
    DBHASHVALUE         rgHashedValues[],
    DBROWSTATUS         rgBookmarkStatus[]
    )
{
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;
    ULONG cErrors = 0;

    if (0 == rgcbBM || 0 == ppBM || 0 == rgHashedValues)
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowsetLocate);

    TRY
    {
        CI_TBL_CHAPT chapt = _MapChapter(hChapter);

        for (ULONG i = 0; i < cBookmarks; i++)
        {
            CI_TBL_BMK bmk;
            DBROWSTATUS rs = _MapBookmarkNoThrow( rgcbBM[i], ppBM[i], bmk );
            rgHashedValues[i] = bmk;

            if (rs != DBROWSTATUS_S_OK)
            {
                rgHashedValues[i] = 0;
                cErrors++;
            }
            if (0 != rgBookmarkStatus)
                rgBookmarkStatus[i] = rs;
        }

        if (cErrors)
            scResult = (cErrors == cBookmarks) ? DB_E_ERRORSOCCURRED :
                                                 DB_S_ERRORSOCCURRED;

        if (FAILED(scResult))
            _DBErrorObj.PostHResult(scResult, IID_IRowsetLocate);
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetLocate);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
} //Hash


//+---------------------------------------------------------------------------
//
//  Member:     CRowset::GetApproximatePosition, public
//
//  Synopsis:   Returns the approximate position of a bookmark
//
//  Arguments:  [hChapter]    -- chapter
//              [cbBookmark]  -- size of bookmark
//              [pBookmark]   -- bookmark
//              [pulPosition] -- return approx row number of bookmark
//              [pulRows]     -- returns approx # of rows in cursor or
//                               1 + approx rows if not at quiescence
//
//  Returns:    SCODE - the status of the operation.
//
//--------------------------------------------------------------------------

STDMETHODIMP CRowset::GetApproximatePosition(
    HCHAPTER      hChapter,
    DBBKMARK      cbBookmark,
    const BYTE *  pBookmark,
    DBCOUNTITEM * pulPosition,
    DBCOUNTITEM * pulRows) /*const*/
{
    _DBErrorObj.ClearErrorInfo();

    Win4Assert( !_fForwardOnly );

    SCODE sc = S_OK;

    TRY
    {
        DBCOUNTITEM ulNumerator, ulDenominator;

        CI_TBL_BMK bmk = WORKID_TBLFIRST;

        if (cbBookmark != 0)
            bmk = _MapBookmark(cbBookmark, pBookmark);

        CI_TBL_CHAPT chapt = _MapChapter(hChapter);
        _rQuery.GetApproximatePosition( _hCursor,
                                        chapt,
                                        bmk,
                                        &ulNumerator,
                                        &ulDenominator );

        if (cbBookmark)
            *pulPosition = ulNumerator;
        if (pulRows)
            *pulRows = ulDenominator;
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetScroll);
        sc = GetOleError(e);
    }
    END_CATCH;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::GetExactPosition, public
//
//  Synopsis:   Returns the exact position of a bookmark
//
//  Arguments:  [hChapter]    -- chapter
//              [cbBookmark]  -- size of bookmark
//              [pBookmark]   -- bookmark
//              [pulPosition] -- return approx row number of bookmark
//              [pulRows]     -- returns approx # of rows in cursor or
//                               1 + approx rows if not at quiescence
//
//  Returns:    SCODE - the status of the operation.
//
//  Notes:      We don't distinguish between exact and approximate position.
//              IRowsetExactScroll is implemented only because ADO 1.5
//              started QI'ing for it.
//
//--------------------------------------------------------------------------

STDMETHODIMP CRowset::GetExactPosition(
    HCHAPTER      hChapter,
    DBBKMARK      cbBookmark,
    const BYTE *  pBookmark,
    DBCOUNTITEM * pulPosition,
    DBCOUNTITEM * pulRows) /*const*/
{
    _DBErrorObj.ClearErrorInfo();

    Win4Assert( !_fForwardOnly );

    SCODE sc = S_OK;

    TRY
    {
        DBCOUNTITEM ulNumerator, ulDenominator;

        CI_TBL_BMK bmk = WORKID_TBLFIRST;

        if (cbBookmark != 0)
            bmk = _MapBookmark(cbBookmark, pBookmark);

        CI_TBL_CHAPT chapt = _MapChapter(hChapter);
        _rQuery.GetApproximatePosition( _hCursor,
                                        chapt,
                                        bmk,
                                        &ulNumerator,
                                        &ulDenominator );

        if (cbBookmark)
            *pulPosition = ulNumerator;
        if (pulRows)
            *pulRows = ulDenominator;
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetScroll);
        sc = GetOleError(e);
    }
    END_CATCH;

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CRowset::GetRowsAtRatio, public
//
//  Synopsis:   Fetch data starting at some ratio in the cursor.
//
//  Arguments:  [hRegion]   -- handle to watch region
//              [hChapter]  -- Chapter in a multiset cursor
//              [ulNumerator] -- numerator or ratio fraction
//              [ulDenominator] -- denominator or ratio fraction
//              [cRows] -- Number of rows to return
//              [pcRowsObtained] -- On return, number of rows actually
//                      fetched.
//              [prghRows] -- Array of HROWs to be released
//
//  Returns:    SCODE, E_INVALIDARG for bad parameters, DB_E_BADBOOKMARK
//              if the starting bookmark is invalid
//
//  Notes:
//
//  History:    14 Dec 1994     Alanw   Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CRowset::GetRowsAtRatio(
    HWATCHREGION        hRegion,
    HCHAPTER            hChapter,
    DBCOUNTITEM         ulNumerator,
    DBCOUNTITEM         ulDenominator,
    DBROWCOUNT          cRows,
    DBCOUNTITEM *       pcRowsObtained,
    HROW * *            prghRows
) {
    _DBErrorObj.ClearErrorInfo();

    CheckCrowsArgs( cRows, pcRowsObtained );

    SCODE scResult = S_OK;

    TRY
    {
        CI_TBL_CHAPT chapt = _MapChapter(hChapter);

        CRowSeekAtRatio rowSeek( hRegion, chapt, (ULONG) ulNumerator, (ULONG) ulDenominator );
        scResult = _FetchRows(rowSeek, cRows, pcRowsObtained, prghRows);
        if (FAILED(scResult))
            _DBErrorObj.PostHResult(scResult, IID_IRowsetScroll);
        else if ( !_pRowsetNotification.IsNull() &&
                  *pcRowsObtained != 0 &&
                  _pRowsetNotification->IsNotifyActive() )
        {
            _pRowsetNotification->OnRowChange( this,
                                               *pcRowsObtained,
                                               *prghRows,
                                               DBREASON_ROW_ACTIVATE,
                                               DBEVENTPHASE_DIDEVENT,
                                               TRUE);
        }
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetScroll);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}

#ifdef _WIN64

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::_ConvertOffsetsToPointers, private
//
//  Synopsis:   Runs through a row buffer converting offsets to pointers
//
//  Arguments:  [pbRows]  -- Buffer with row data
//              [pbBias]  -- Bias for offsets to pointers
//              [cRows]   -- Number of rows in the buffer
//              [pArrayAlloc] -- buffer to hold extra array pointers
//
//  History:    2 Aug 95     dlee       created
//              1 Sep 99     KLam       Reinstated
//
//----------------------------------------------------------------------------

void CRowset::_ConvertOffsetsToPointers(
    BYTE *   pbRows,
    BYTE *   pbBias,
    unsigned cRows,
    CFixedVarAllocator *pArrayAlloc )
{
    if ( !_fPossibleOffsetConversions )
        return;

    BOOL fAnyOffsets = FALSE;

    CTableColumnSet const & rCols = _ColumnsInfo.GetColumnBindings();
    unsigned cbRowWidth = _ColumnsInfo.GetRowWidth();

    for ( unsigned col = 0; col < rCols.Count(); col++ )
    {
        CTableColumn const & rColumn = *rCols.Get( col );

        // if this assert isn't true someday, add an if on this condition

        Win4Assert( rColumn.IsValueStored() );

        VARTYPE vt = rColumn.GetStoredType();

        if ( ( CTableVariant::IsByRef( vt ) ) && ( VT_CLSID != vt ) )
        {
            fAnyOffsets = TRUE;
            BYTE *pbRow = pbRows;
            BYTE *pbData = pbRow + rColumn.GetValueOffset();

            for ( unsigned row = 0;
                  row < cRows;
                  row++, pbData += cbRowWidth, pbRow += cbRowWidth )
            {
                // Even stat props can be null if they came from a
                // summary catalog.

                tbDebugOut(( DEB_TRACE, 
                             "CRowset::_ConvertOffsetsToPointer, Bias: 0x%I64x Row: 0x%I64x Data: 0x%I64x Type: %d New Alloc: 0x%I64x\n",
                             pbBias, pbRow, pbData, vt, pArrayAlloc ));

                if (! rColumn.IsNull( pbRow ) )
                {
                    if ( VT_VARIANT == vt )
                    {
                        if (! rColumn.IsDeferred( pbRow ) )
                            ((CTableVariant *) pbData)->FixDataPointers( pbBias, pArrayAlloc );
                    }
                    else
                    {
                        Win4Assert( 0 == ( vt & VT_VECTOR ) );
                        * (BYTE **) pbData = pbBias + (* (ULONG *) pbData );
                    }
                }
            }
        }
    }

    _fPossibleOffsetConversions = fAnyOffsets;
} //_ConvertOffsetsToPointers

#endif // _WIN64

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::_FetchRows, private
//
//  Synopsis:   Return handles to rows in the table
//
//  Effects:    Rows are read from the table and buffered locally.  An
//              array of handles to the rows is returned.
//
//  Arguments:  [rSeekDesc] - seek method and parameters
//              [cRows] - number of rows desired
//              [pcRowsReturned] - pointer to where number of rows is returned
//              [prghRows] - pointer to pointer to where row handles are
//                              returned, or pointer to zero if row handle
//                              array should be allocated
//
//  Returns:    error code
//
//  Notes:
//
//----------------------------------------------------------------------------

SCODE CRowset::_FetchRows(
    CRowSeekDescription & rSeekDesc,
    DBROWCOUNT            cRows,
    DBCOUNTITEM *         pcRowsReturned,
    HROW * *              prghRows
) {
    SCODE scResult = S_OK;

    Win4Assert( 0 != pcRowsReturned );

    if (0 == prghRows)
    {
        THROW(CException(E_INVALIDARG));
    }

    if (0 == cRows)
    {
        *pcRowsReturned = 0;
        return scResult;
    }

    BOOL fFwdFetch = TRUE;
    if ( cRows < 0 )
    {
        fFwdFetch = FALSE;
        cRows = -cRows;    // cRows now has its absolute value
    }

    Win4Assert( cRows > 0 );

    BOOL fRowCountTrimmed = FALSE;

    if (cRows > MAX_ROW_FETCH)
    {
        cRows = MAX_ROW_FETCH;
        fRowCountTrimmed = TRUE;
    }

    XArrayOLE<HROW> ahRows;
    HROW *pHRows;
    if ( 0 == *prghRows )
    {
        ahRows.Init( (unsigned) cRows );
        pHRows = ahRows.GetPointer();
    }
    else
    {
        pHRows = *prghRows;
    }

    DBCOUNTITEM cRowsSoFar = 0;       // number of rows successfully transferred.
    CRowSeekDescription * pNextSeek = &rSeekDesc;

    TRY
    {
        XPtr<CRowSeekDescription> pRowSeekPrevious(0);
        ULONG cbRowWidth = _ColumnsInfo.GetRowWidth();

        do
        {
            XPtr<CFixedVarAllocator> xAlloc( new
                                     CFixedVarAllocator( FALSE,
                                                         FALSE,
                                                         cbRowWidth,
                                                         0 ));

            CGetRowsParams FetchParams( (ULONG) (cRows - cRowsSoFar),
                                        fFwdFetch,
                                        cbRowWidth,
                                        xAlloc.GetReference() );

            // Get the row data

            XPtr<CRowSeekDescription> xRowSeekOut(0);
            scResult = _rQuery.GetRows( _hCursor,
                                        *pNextSeek,
                                        FetchParams,
                                        xRowSeekOut );
            if (FAILED(scResult))
            {
#if CIDBG
                if (E_FAIL == scResult)
                    tbDebugOut((DEB_WARN,
                         "CRowset::_FetchRows - E_FAIL ret'd by GetRows\n"));
#endif // CIDBG
                break;
            }

            if ( 0 != FetchParams.RowsTransferred() )
            {
                Win4Assert( !xAlloc->IsBasedMemory() );

                XPtr<CRowBuffer> xRowBuf ( new
                                 CRowBuffer( _ColumnsInfo.GetColumnBindings(),
                                             cbRowWidth,
                                             FetchParams.RowsTransferred(),
                                             xAlloc ));

#ifdef _WIN64
                // if this is a Win64 client talking with a Win32 server
                // then we need to fix the row buffer since we passed in 0
                // as the base address.
                if ( FetchParams.GetReplyBase() != 0 )
                {
                    _fPossibleOffsetConversions = TRUE;
                    void *pvRows;
                    CTableColumnSet *pCol;
                    SCODE sc = xRowBuf->Lookup( (unsigned)cRowsSoFar, 
                                                &pCol, 
                                                &pvRows,
                                                FALSE );

                    _ConvertOffsetsToPointers ( (BYTE *)pvRows,
                                                FetchParams.GetReplyBase(),
                                                FetchParams.RowsTransferred(),
                                                _pRowBufs->GetArrayAlloc() );
                }
#endif

                _pRowBufs->Add( xRowBuf,
                                rSeekDesc.IsByBmkRowSeek(),
                                pHRows + cRowsSoFar );

                cRowsSoFar += FetchParams.RowsTransferred();
            }
            else
            {
                // One row didn't fit into an fsctl buffer.

                if (! ( scResult == DB_S_ENDOFROWSET ||
                        scResult == DB_S_STOPLIMITREACHED ||
                        ( scResult == DB_S_ERRORSOCCURRED &&
                          rSeekDesc.IsByBmkRowSeek() ) ) )
                {
                    tbDebugOut(( DEB_WARN,
                                 "CRowset::_FetchRows, 0 rows, sc 0x%x\n",
                                  scResult ));
                }

                Win4Assert( scResult == DB_S_ENDOFROWSET ||
                            scResult == DB_S_STOPLIMITREACHED ||
                            ( scResult == DB_S_ERRORSOCCURRED &&
                              rSeekDesc.IsByBmkRowSeek() ) );
            }

            if ( 0 != xRowSeekOut.GetPointer() )
            {
                //
                //  Transfer results from the returned seek description
                //  (for the ByBookmark case), and update for the next
                //  transfer.
                //

                rSeekDesc.MergeResults( xRowSeekOut.GetPointer() );
                delete pRowSeekPrevious.Acquire();
                pRowSeekPrevious.Set( xRowSeekOut.Acquire() );
                pNextSeek = pRowSeekPrevious.GetPointer();
            }

            Win4Assert( cRows >= 0 );

        } while ( (DBCOUNTITEM) cRows > cRowsSoFar &&
                  0 != pNextSeek &&
                  !pNextSeek->IsDone() &&
                  (S_OK == scResult || DB_S_BLOCKLIMITEDROWS == scResult ) );
    }
    CATCH( CException, e )
    {
        scResult = e.GetErrorCode();
#if CIDBG
        if (E_FAIL == scResult)
            tbDebugOut((DEB_WARN, "CRowset::_FetchRows - E_FAIL from exception\n"));
#endif // CIDBG
    }
    END_CATCH;

    if (DB_E_BADSTARTPOSITION == scResult)
        scResult = DB_S_ENDOFROWSET;

    if ( fRowCountTrimmed && scResult == S_OK )
         scResult = DB_S_ROWLIMITEXCEEDED;

    if ( FAILED(scResult))
    {
        ReleaseRows(cRowsSoFar, pHRows, 0, 0, 0);
        *pcRowsReturned = 0;

        tbDebugOut((DEB_ITRACE, "CRowset::_FetchRows - error %x thrown\n", scResult));
        QUIETTHROW( CException( scResult ) );
    }
    else
    {
        if ( ( cRowsSoFar > 0 ) && ( 0 == *prghRows ) )
            *prghRows = ahRows.Acquire();

        *pcRowsReturned = cRowsSoFar;
    }

    return( scResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::CreateAccessor, public
//
//  Synopsis:   Makes an accessor that a client can use to get data.
//
//  Arguments:  [dwAccessorFlags]  -- read/write access requested
//              [cBindings]    -- # of bindings in rgBindings
//              [rgBindings]   -- array of bindings for the accessor to support
//              [cbRowSize]    -- ignored for IRowset
//              [phAccessor]   -- returns created accessor if all is ok
//              [rgBindStatus] -- array of binding statuses
//
//  Returns:    SCODE error code
//
//  History:    14 Dec 94       dlee   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::CreateAccessor(
    DBACCESSORFLAGS     dwAccessorFlags,
    DBCOUNTITEM         cBindings,
    const DBBINDING     rgBindings[],
    DBLENGTH            cbRowSize,
    HACCESSOR *         phAccessor,
    DBBINDSTATUS        rgBindStatus[])
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;

    if (0 == phAccessor || (0 != cBindings && 0 == rgBindings))
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IAccessor);

    // Make sure pointer is good while zeroing in case of a later error

    *phAccessor = 0;

    TRY
    {
        XPtr<CAccessor> Accessor( CreateAnAccessor( dwAccessorFlags,
                                                    cBindings,
                                                    rgBindings,
                                                    rgBindStatus,
                                                    _fExtendedTypes,
                                                    (IUnknown *) (IRowset *)this,
                                                    &_ColumnsInfo ) );

        CLock lock( _mutex );

        _aAccessors.Add( Accessor.GetPointer() );

        *phAccessor = (Accessor.Acquire())->Cast();
    }
    CATCH(CException, e)
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IAccessor);
        sc = GetOleError(e);
    }
    END_CATCH;

    return sc;
} //CreateAccessor

//+---------------------------------------------------------------------------
//
//  Member:     IsValidFromVariantType
//
//  Synopsis:   If DBCONVERTFLAGS_FROMVARIANT is requested, the source type
//              has to be a valid VARIANT type.
//
//  Arguments:  [wTypeIn] -- the source type
//
//  Returns:    TRUE  -- the type is a valid VARIANT type
//              FALSE -- otherwise
//
//----------------------------------------------------------------------------

inline BOOL IsValidFromVariantType( DBTYPE wTypeIn )
{
    DBTYPE wType = wTypeIn & VT_TYPEMASK;

    return (! ((wType > VT_DECIMAL && wType < VT_I1) ||
               (wType > VT_LPWSTR && wType < VT_FILETIME && wType != VT_RECORD) ||
               (wType > VT_CLSID)) );
}

//+---------------------------------------------------------------------------
//
//  Member:     IsVariableLengthType
//
//  Synopsis:   checks to see DBCONVERTFLAGS_ISLONG is appropriate
//
//  Arguments:  [wTypeIn] -- the source type
//
//  Returns:    TRUE  -- the type is variable length
//              FALSE -- otherwise
//
//----------------------------------------------------------------------------

inline BOOL IsVariableLengthType( DBTYPE  wTypeIn )
{
    DBTYPE wType = wTypeIn & VT_TYPEMASK;

    return wType == DBTYPE_STR       ||
           wType == DBTYPE_BYTES     ||
           wType == DBTYPE_WSTR      ||
           wType == DBTYPE_VARNUMERIC;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::CanConvert, public
//
//  Synopsis:   Indicate whether a type conversion is valid.
//
//  Arguments:  [wFromType]      -- source type
//              [wToType]        -- destination type
//              [dwConvertFlags] -- read/write access requested
//
//  Returns:    S_OK if the conversion is available, S_FALSE otherwise.
//              E_FAIL, E_INVALIDARG or DB_E_BADCONVERTFLAG on errors.
//
//  History:    20 Nov 96      AlanW   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::CanConvert(
    DBTYPE wFromType,
    DBTYPE wToType,
    DBCONVERTFLAGS dwConvertFlags )
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;

    TRY
    {
        if (((dwConvertFlags & DBCONVERTFLAGS_COLUMN) &&
             (dwConvertFlags & DBCONVERTFLAGS_PARAMETER)) ||
            (dwConvertFlags & ~(DBCONVERTFLAGS_COLUMN |
                                DBCONVERTFLAGS_PARAMETER |
                                DBCONVERTFLAGS_ISFIXEDLENGTH |
                                DBCONVERTFLAGS_ISLONG |
                                DBCONVERTFLAGS_FROMVARIANT)))
        {
            sc = DB_E_BADCONVERTFLAG;
        }
        else if ( dwConvertFlags & DBCONVERTFLAGS_FROMVARIANT &&
                   !IsValidFromVariantType(wFromType) )
        {
            sc = DB_E_BADTYPE;
        }
        else
        {
            BOOL fOk = CAccessor::CanConvertType( wFromType,
                                                  wToType,
                                                  _fExtendedTypes, _xDataConvert );
            sc = fOk ? S_OK : S_FALSE;
        }
        if (FAILED(sc))
            _DBErrorObj.PostHResult(sc, IID_IConvertType);
    }
    CATCH(CException, e)
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IConvertType);
        sc = GetOleError(e);
    }
    END_CATCH;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::GetBindings, public
//
//  Synopsis:   Returns an accessor's bindings
//
//  Arguments:  [hAccessor]   -- accessor being queried
//              [dwBindIO]    -- returns read/write access of accessor
//              [pcBindings]  -- returns # of bindings in rgBindings
//              [prgBindings] -- returns array of bindings
//
//  Returns:    SCODE error code
//
//  History:    14 Dec 94       dlee   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::GetBindings(
    HACCESSOR         hAccessor,
    DBACCESSORFLAGS * pdwBindIO,
    DBCOUNTITEM *     pcBindings,
    DBBINDING * *     prgBindings) /*const*/
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;

    if (0 == pdwBindIO ||
        0 == pcBindings ||
        0 == prgBindings)
    {
        // fill in error values where possible
        if (pdwBindIO)
           *pdwBindIO = DBACCESSOR_INVALID;
        if (pcBindings)
           *pcBindings = 0;
        if (prgBindings)
           *prgBindings = 0;

        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IAccessor);
    }

    *pdwBindIO = DBACCESSOR_INVALID;
    *pcBindings = 0;
    *prgBindings = 0;

    TRY
    {
        CLock lock( _mutex );
        CAccessor * pAccessor = (CAccessor *)_aAccessors.Convert( hAccessor );
        pAccessor->GetBindings(pdwBindIO, pcBindings, prgBindings);
    }
    CATCH(CException, e)
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IAccessor);
        sc = GetOleError(e);
    }
    END_CATCH;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::AddRefAccessor, public
//
//  Synopsis:   Frees an accessor
//
//  Arguments:  [hAccessor]   -- accessor being freed
//              [pcRefCount]  -- pointer to residual refcount (optional)
//
//  Returns:    SCODE error code
//
//  History:    14 Dec 94       dlee   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::AddRefAccessor(
    HACCESSOR   hAccessor,
    ULONG *     pcRefCount
) {
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;

    TRY
    {
        CLock lock( _mutex );
        _aAccessors.AddRef( hAccessor, pcRefCount );
    }
    CATCH(CException, e)
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IAccessor);
        sc = GetOleError(e);
    }
    END_CATCH;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::ReleaseAccessor, public
//
//  Synopsis:   Frees an accessor
//
//  Arguments:  [hAccessor]   -- accessor being freed
//              [pcRefCount]  -- pointer to residual refcount (optional)
//
//  Returns:    SCODE error code
//
//  History:    14 Dec 94       dlee   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::ReleaseAccessor(
    HACCESSOR   hAccessor,
    ULONG *     pcRefCount )
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;

    TRY
    {
        CLock lock( _mutex );
        _aAccessors.Release( hAccessor, pcRefCount );
    }
    CATCH(CException, e)
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IAccessor);
        sc = GetOleError(e);
    }
    END_CATCH;

    return sc;
} //ReleaseAccessor

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::GetData, public
//
//  Synopsis:   Returns row data using an accessor
//
//  Arguments:  [hRow]        -- handle of row whose data is returned
//              [hAccessor]   -- accessor used to retrieve the data
//              [pData]       -- where the data is written
//
//  Returns:    SCODE error code
//
//  History:    14 Dec 94       dlee   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::GetData(
    HROW                hRow,
    HACCESSOR           hAccessor,
    void*               pData) /*const*/
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;

    // NOTE: Null accessors are not supported, so don't need to worry about
    //       special casing for that.
    if ( 0 == pData )
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowset);

    TRY
    {
        CLock lock( _mutex );
        CAccessor * pAccessor = (CAccessor *)_aAccessors.Convert( hAccessor );

        Win4Assert( pAccessor->IsRowDataAccessor() );
        pAccessor->GetData(hRow, pData, *_pRowBufs, _rQuery, _ColumnsInfo, _xDataConvert );
    }
    CATCH(CException, e)
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowset);
        sc = GetOleError(e);
    }
    END_CATCH;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::GetNextRows, public
//
//  Synopsis:   Return row data from the table
//
//  Arguments:  [hChapter]       -- chapter to start at
//              [cRowsToSkip]    -- # of rows to skip
//              [cRows]          -- # of rows to try to return
//              [pcRowsObtained] -- returns # of rows obtained
//              [prghRows]       -- returns array of rows
//
//  Returns:    SCODE error code
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::GetNextRows(
    HCHAPTER       hChapter,
    DBROWOFFSET    cRowsToSkip,
    DBROWCOUNT     cRows,
    DBCOUNTITEM *  pcRowsObtained,
    HROW * *       prghRows
)
{
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;
    BOOL fNotified = FALSE;

    CheckCrowsArgs( cRows, pcRowsObtained );

    if (_fForwardOnly && cRowsToSkip < 0)
        return _DBErrorObj.PostHResult(DB_E_CANTSCROLLBACKWARDS, IID_IRowset);
    if (_fForwardOnly && cRows < 0 )
        return _DBErrorObj.PostHResult(DB_E_CANTFETCHBACKWARDS, IID_IRowset);

    TRY
    {
        if (! _fHoldRows)
            _pRowBufs->CheckAllHrowsReleased();

        CI_TBL_CHAPT chapt = _MapChapter(hChapter);

        if ( !_pRowsetNotification.IsNull() &&
             _pRowsetNotification->IsNotifyActive() )
        {
            scResult = _pRowsetNotification->OnRowsetChange(
                                         this,
                                         DBREASON_ROWSET_FETCHPOSITIONCHANGE,
                                         DBEVENTPHASE_OKTODO,
                                         FALSE);

            if ( S_FALSE == scResult )
                THROW(CException(DB_E_CANCELED));
            fNotified = TRUE;
        }

        CRowSeekNext rowSeek( chapt, (LONG) cRowsToSkip );

        scResult = _FetchRows(rowSeek, cRows, pcRowsObtained, prghRows);

        if ( fNotified )
        {
            if (SUCCEEDED(scResult))
            {
                if ( *pcRowsObtained != 0 )
                    _pRowsetNotification->OnRowChange( this,
                                                       *pcRowsObtained,
                                                       *prghRows,
                                                       DBREASON_ROW_ACTIVATE,
                                                       DBEVENTPHASE_DIDEVENT,
                                                       TRUE);
                _pRowsetNotification->OnRowsetChange( this,
                                                      DBREASON_ROWSET_FETCHPOSITIONCHANGE,
                                                      DBEVENTPHASE_DIDEVENT,
                                                      TRUE);
            }
        }
        if (FAILED(scResult))
            _DBErrorObj.PostHResult(scResult, IID_IRowset);
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowset);
        scResult = GetOleError(e);
    }
    END_CATCH;

    if ( fNotified && FAILED(scResult) )
        _pRowsetNotification->OnRowsetChange( this,
                                              DBREASON_ROWSET_FETCHPOSITIONCHANGE,
                                              DBEVENTPHASE_FAILEDTODO,
                                              TRUE);

    Win4Assert( cRowsToSkip != 0 ||
                DB_E_BADSTARTPOSITION != scResult );
    return scResult;
}


//
// IRowsetIdentity methods
//

SCODE CRowset::IsSameRow ( HROW hThisRow, HROW hThatRow )
{
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;
    TRY
    {
        CTableColumnSet *pRowBufferColumns;
        BYTE *pbSrc;

        //
        // Lookup the HROWs to validate them
        //

        _pRowBufs->Lookup( hThisRow,
                           &pRowBufferColumns,
                           (void **) &pbSrc );

        _pRowBufs->Lookup( hThatRow,
                           &pRowBufferColumns,
                           (void **) &pbSrc );

        if (hThisRow != hThatRow)
           scResult = S_FALSE;

    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetIdentity);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}


//
// IRowsetWatchAll methods
//

SCODE CRowset::Acknowledge ( )
{
    _DBErrorObj.ClearErrorInfo();
    SCODE scResult = S_OK;
    TRY
    {
        // Just use Refresh to acknowledge the notification.
        _rQuery.Refresh();
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetWatchAll);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}

SCODE CRowset::Start ( )
{
    _DBErrorObj.ClearErrorInfo();
    SCODE scResult = S_OK;
    TRY
    {
        _rQuery.StartWatching(_hCursor);
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetWatchAll);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}

SCODE CRowset::StopWatching ( )
{
    _DBErrorObj.ClearErrorInfo();
    SCODE scResult = S_OK;
    TRY
    {
        _rQuery.StopWatching(_hCursor);
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetWatchAll);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;

}


//
// IRowsetWatchRegion methods
//

SCODE CRowset::ChangeWatchMode (
    HWATCHREGION hRegion,
    DBWATCHMODE mode)
{
    _DBErrorObj.ClearErrorInfo();

    if (hRegion == watchRegionInvalid)
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowsetWatchRegion);;

    SCODE scResult = S_OK;
    TRY
    {
        _rQuery.SetWatchMode(&hRegion, mode);
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetWatchRegion);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}

SCODE CRowset::CreateWatchRegion (
    DBWATCHMODE mode,
    HWATCHREGION* phRegion)
{
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;
    *phRegion = watchRegionInvalid;
    TRY
    {
        _rQuery.SetWatchMode(phRegion, mode);
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetWatchRegion);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}

SCODE CRowset::DeleteWatchRegion (
    HWATCHREGION hRegion)
{
    _DBErrorObj.ClearErrorInfo();

    if (hRegion == watchRegionInvalid)
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowsetWatchRegion);

    SCODE scResult = S_OK;
    TRY
    {
        _rQuery.ShrinkWatchRegion (hRegion, 0, 0, 0);
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetWatchRegion);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}


SCODE CRowset::GetWatchRegionInfo (
    HWATCHREGION hRegion,
    DBWATCHMODE * pMode,
    HCHAPTER * phChapter,
    DBBKMARK * pcbBookmark,
    BYTE ** ppBookmark,
    DBROWCOUNT * pcRows)
{
    _DBErrorObj.ClearErrorInfo();

    if (hRegion == watchRegionInvalid)
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowsetWatchRegion);;

    SCODE scResult = S_OK;
    // test pointers and prepare for failure
    *phChapter = 0;
    *pcbBookmark = 0;
    *ppBookmark = 0;
    *pcRows = 0;

    TRY
    {
        CI_TBL_CHAPT chapter;
        CI_TBL_BMK   bookmark;

        _rQuery.GetWatchInfo( hRegion, pMode, &chapter, &bookmark, (DBCOUNTITEM *)pcRows);

        if (chapter != 0)
        {
            *phChapter = (HCHAPTER)chapter;
        }
        if (bookmark != 0)
        {
            XArrayOLE<CI_TBL_BMK> pOutBookmark (1);
            *pcbBookmark = sizeof CI_TBL_BMK;
            memcpy ( pOutBookmark.GetPointer(), &bookmark, sizeof CI_TBL_BMK);
            *ppBookmark = (BYTE*) pOutBookmark.Acquire();
        }

    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetWatchRegion);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}


SCODE CRowset::ShrinkWatchRegion (
    HWATCHREGION hRegion,
    HCHAPTER     hChapter,
    DBBKMARK cbBookmark,
    BYTE * pBookmark,
    DBROWCOUNT cRows )
{
    _DBErrorObj.ClearErrorInfo();

    if (hRegion == watchRegionInvalid)
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowsetWatchRegion);;

    SCODE scResult = S_OK;

    TRY
    {

        CI_TBL_BMK bookmark = _MapBookmark(cbBookmark, pBookmark);
        CI_TBL_CHAPT chapter = _MapChapter(hChapter);

        _rQuery.ShrinkWatchRegion ( hRegion, chapter, bookmark, (LONG) cRows);
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetWatchRegion);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}



SCODE CRowset::Refresh (
    DBCOUNTITEM* pCount,
    DBROWWATCHCHANGE** ppRowChange )
{
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;
    TRY
    {
        // prepare the buffers
        // fetch the script and
        // a bunch of rows.
        // If not all rows fit in
        // the buffer, call again.
        _rQuery.Refresh();
        *pCount = 0;
        scResult = DB_S_TOOMANYCHANGES;
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetWatchRegion);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}


//+---------------------------------------------------------------------------
//
//  Member:     CRowset::GetStatus, public
//
//  Synopsis:   Return query status
//
//  Arguments:  [pdwStatus]      -- pointer to where query status is returned
//
//  Returns:    SCODE error code
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::GetStatus(
    DWORD *        pdwStatus
) {
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;
    TRY
    {
        *pdwStatus = 0;

        _rQuery.GetQueryStatus( _hCursor, *pdwStatus );
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetQueryStatus);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}


//+---------------------------------------------------------------------------
//
//  Member:     CRowset::GetStatusEx, public
//
//  Synopsis:   Return query status
//
//  Arguments:  [pdwStatus]           - returns query status
//              [pcFilteredDocuments] - # of documents filtered
//              [pcDocumentsToFilter] - # of docsuments yet to filter
//              [pdwRatioFinishedDenominator] - ratio finished denominator
//              [pdwRatioFinishedNumerator]   - ratio finished numerator
//              [cbBmk]               - # of bytes in pBmk
//              [pBmk]                - bookmark for piRowBmk
//              [piRowBmk]            - returns index of bookmark in table
//              [pcRowsTotal]         - current # of rows in table
//
//  Returns:    SCODE error code
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::GetStatusEx(
    DWORD * pdwStatus,
    DWORD * pcFilteredDocuments,
    DWORD * pcDocumentsToFilter,
    DBCOUNTITEM * pdwRatioFinishedDenominator,
    DBCOUNTITEM * pdwRatioFinishedNumerator,
    DBBKMARK      cbBmk,
    const BYTE *  pBmk,
    DBCOUNTITEM * piRowBmk,
    DBCOUNTITEM * pcRowsTotal )
{
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;
    TRY
    {
        *pdwStatus = 0;

        CI_TBL_BMK bmk = WORKID_TBLFIRST;

        if ( cbBmk != 0 )
            bmk = _MapBookmark( cbBmk, pBmk );
        _rQuery.GetQueryStatusEx( _hCursor,
                                  *pdwStatus,
                                  *pcFilteredDocuments,
                                  *pcDocumentsToFilter,
                                  *pdwRatioFinishedDenominator,
                                  *pdwRatioFinishedNumerator,
                                  bmk,
                                  *piRowBmk,
                                  *pcRowsTotal );
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetQueryStatus);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}


//+---------------------------------------------------------------------------
//
//  Member:     CRowset::GetReferencedRowset, public
//
//  Synopsis:   Return the related rowset for a hierarchical query.
//
//  Arguments:  [iOrdinal]           -- ordinal of column for bookmark
//              [riid]               -- IID of desired interface
//              [ppReferencedRowset] -- interface pointer returned here
//
//  Returns:    SCODE error code
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::GetReferencedRowset(
    DBORDINAL iOrdinal,
    REFIID riid,
    IUnknown ** ppReferencedRowset
) /*const*/ {
    _DBErrorObj.ClearErrorInfo();

    if (0 == ppReferencedRowset)
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowsetInfo);

    *ppReferencedRowset = 0;

    if ( iOrdinal > _ColumnsInfo.GetColumnCount() ||
         (0 == _pRelatedRowset && 0 == iOrdinal && _fForwardOnly))
        return _DBErrorObj.PostHResult(DB_E_BADORDINAL, IID_IRowsetInfo);

    if ( 0 == _pRelatedRowset && 0 != iOrdinal )
        return _DBErrorObj.PostHResult(DB_E_NOTAREFERENCECOLUMN, IID_IRowsetInfo);

    //
    //  If it's the bookmark column, it's like a QI on this rowset.
    //
    if (0 == iOrdinal)
        return QueryInterface( riid, (void **)ppReferencedRowset );

    //
    // Make sure the column is a valid chapter column.
    //
    const DBCOLUMNINFO & rColInfo = _ColumnsInfo.Get1ColumnInfo( (ULONG) iOrdinal );

    if ( (rColInfo.dwFlags & DBCOLUMNFLAGS_ISBOOKMARK) == 0 ||
         (rColInfo.dwFlags & DBCOLUMNFLAGS_ISROWID) != 0 )
        return _DBErrorObj.PostHResult(DB_E_NOTAREFERENCECOLUMN, IID_IRowsetInfo);

    return _pRelatedRowset->QueryInterface( riid, (void **)ppReferencedRowset );
}


//+---------------------------------------------------------------------------
//
//  Member:     CRowset::RestartPosition, public
//
//  Synopsis:   Set up CRowset so next GetNextRows will restart from beginning
//
//  Arguments:  [hChapter]           -- chapter which should restart
//
//  Returns:    SCODE error code
//
//  Notes:
//
//  History:    16-Apr-97  emilyb   wrote
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::RestartPosition(
    HCHAPTER            hChapter
) {
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;
    BOOL fNotified = FALSE;

    TRY
    {
        if (! _fHoldRows)
            _pRowBufs->CheckAllHrowsReleased();

        CI_TBL_CHAPT chapter = _MapChapter(hChapter); // is chapter valid?

        if ( !_pRowsetNotification.IsNull() &&
             _pRowsetNotification->IsNotifyActive() )
        {
            scResult = _pRowsetNotification->OnRowsetChange(
                                         this,
                                         DBREASON_ROWSET_FETCHPOSITIONCHANGE,
                                         DBEVENTPHASE_OKTODO,
                                         FALSE);

            if ( S_FALSE == scResult )
                THROW(CException(DB_E_CANCELED));
            fNotified = TRUE;
        }

        _rQuery.RestartPosition(_hCursor, chapter);

        if ( fNotified )
            _pRowsetNotification->OnRowsetChange( this,
                                                  DBREASON_ROWSET_FETCHPOSITIONCHANGE,
                                                  DBEVENTPHASE_DIDEVENT,
                                                  TRUE);
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowset);
        scResult = GetOleError(e);

        if (E_NOTIMPL == scResult)
        {
           scResult = DB_E_CANNOTRESTART;
        }
    }
    END_CATCH;

    if ( fNotified && FAILED(scResult) )
        _pRowsetNotification->OnRowsetChange( this,
                                              DBREASON_ROWSET_FETCHPOSITIONCHANGE,
                                              DBEVENTPHASE_FAILEDTODO,
                                              TRUE);
    return scResult;
}


//
//  IDbAsynchStatus methods
//

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::Abort, public
//
//  Synopsis:   Cancels an asynchronously executing operation.
//
//  Arguments:  [hChapter]    -- chapter which should restart
//              [ulOperation] -- operation for which status is being requested
//
//  Returns:    SCODE error code
//
//  Notes:
//
//  History:    09 Feb 1998    AlanW    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::Abort(
    HCHAPTER            hChapter,
    ULONG               ulOperation
) {
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;

    if ( DBASYNCHOP_OPEN != ulOperation )
    {
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IDBAsynchStatus);
    }

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        CI_TBL_CHAPT chapter = _MapChapter(hChapter); // is chapter valid?
        _rQuery.StopAsynch(_hCursor);
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IDBAsynchStatus);
        scResult = GetOleError(e);

        if (E_NOTIMPL == scResult)
        {
           scResult = DB_E_CANTCANCEL;
           _DBErrorObj.PostHResult(scResult, IID_IDBAsynchStatus);
        }
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return scResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::GetStatus, public
//
//  Synopsis:   Returns the status of an asynchronously executing operation.
//
//  Arguments:  [hChapter]    -- chapter which should restart
//              [ulOperation] -- operation for which status is being requested
//
//  Returns:    SCODE error code
//
//  Notes:
//
//  History:    09 Feb 1998    AlanW    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::GetStatus(
    HCHAPTER          hChapter,
    DBASYNCHOP        ulOperation,
    DBCOUNTITEM *     pulProgress,
    DBCOUNTITEM *     pulProgressMax,
    DBASYNCHPHASE *   pulAsynchPhase,
    LPOLESTR *        ppwszStatusText
) {
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;

    if ( DBASYNCHOP_OPEN != ulOperation )
    {
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IDBAsynchStatus);
    }

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        // NOTE: we don't support getting the status of chapters
        //       independently.
         
        // CI_TBL_CHAPT chapter = _MapChapter(hChapter); // is chapter valid?
        if (DB_NULL_HCHAPTER != hChapter)
            THROW( CException( DB_E_BADCHAPTER ));

        DBCOUNTITEM ulNumerator = 0;
        DBCOUNTITEM ulDenominator = 0;
        DBCOUNTITEM cRows;
        BOOL fNewRows;

        _rQuery.RatioFinished( _hCursor,
                               ulDenominator,
                               ulNumerator,
                               cRows,
                               fNewRows );

        if (pulProgress)
            *pulProgress = ulNumerator;
        if (pulProgressMax)
            *pulProgressMax = ulDenominator;
        if (pulAsynchPhase)
            *pulAsynchPhase = (ulDenominator == ulNumerator) ?
                                  DBASYNCHPHASE_COMPLETE :
                                  DBASYNCHPHASE_POPULATION;
        if (ppwszStatusText)
            *ppwszStatusText = 0;

#if CIDBG
        if ( _fForwardOnly )
            Win4Assert( ulDenominator == ulNumerator );
        else
            Win4Assert( ulDenominator >= ulNumerator );
#endif // CIDBG
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IDBAsynchStatus);
        scResult = GetOleError(e);
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return scResult;
}


//+---------------------------------------------------------------------------
//
//  Member:     CRowset::GetSpecification, public
//
//  Synopsis:   Return the session or command object used to create this rowset
//
//  Arguments:  [hChapter]           -- chapter which should restart
//
//  Notes:
//
//  History:    01-28-98    danleg      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::GetSpecification(
    REFIID riid,
    IUnknown ** ppvSpecification
) {
    _DBErrorObj.ClearErrorInfo();

    if  ( 0 == ppvSpecification )
        return _DBErrorObj.PostHResult( E_INVALIDARG, IID_IRowsetInfo );
        
    SCODE sc = S_OK;
    TRANSLATE_EXCEPTIONS;
    TRY 
    {
        *ppvSpecification = 0;

        if ( _xUnkCreator.IsNull() )
            return S_FALSE;

        sc = _xUnkCreator->QueryInterface( riid, (void ** )ppvSpecification );
        if ( FAILED(sc) )
            THROW( CException(sc) );

    }
    CATCH( CException, e )
    {
        sc = _DBErrorObj.PostHResult( e, IID_IRowsetInfo );
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;
    
    return sc;
}


//
//  IServiceProperties methods
//

//+---------------------------------------------------------------------------
//
//  Method:     CRowset::GetPropertyInfo, public
//
//  Synopsis:   Get rowset properties
//
//  Arguments:  [cPropertySetIDs]    - number of desired properties or 0
//              [rgPropertySetIDs]   - array of desired properties or NULL
//              [pcPropertySets]     - number of property sets returned
//              [prgPropertySets]    - array of returned property sets
//              [ppwszDesc]          - if non-zero, property descriptions are
//                                     returneed
//
//  History:     16 Nov 95   AlanW       Created
//
//----------------------------------------------------------------------------

SCODE CRowset::GetPropertyInfo(
    const ULONG            cPropertySetIDs,
    const DBPROPIDSET      rgPropertySetIDs[],
    ULONG *                pcPropertySets,
    DBPROPINFOSET **       prgPropertySets,
    WCHAR **               ppwszDesc)
{
    _DBErrorObj.ClearErrorInfo();

    if ( (0 != cPropertySetIDs && 0 == rgPropertySetIDs) ||
          0 == pcPropertySets ||
          0 == prgPropertySets )
    {
        if (pcPropertySets)
           *pcPropertySets = 0;
        if (prgPropertySets)
           *prgPropertySets = 0;
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IServiceProperties);
    }

    SCODE sc = S_OK;
    *pcPropertySets = 0;
    *prgPropertySets = 0;
    if (ppwszDesc)
       *ppwszDesc = 0;


    TRANSLATE_EXCEPTIONS;
    TRY
    {
        sc = _PropInfo.GetPropertyInfo( cPropertySetIDs,
                                        rgPropertySetIDs,
                                        pcPropertySets,
                                        prgPropertySets,
                                        ppwszDesc );

        // Don't PostHResult here -- it's a good chance it's a scope
        // property that we're expecting to fail.  Spare the expense.
        // The child object will post the error for us.
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IServiceProperties);
        sc = GetOleError(e);

    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Method:     CRowset::SetRequestedProperties, public
//
//  Synopsis:   Set rowset properties via IServiceProperties (not supported)
//
//  Arguments:  [cPropertySets]  - number of property sets
//              [rgProperties]   - array of property sets to be set
//
//  History:     16 Nov 95   AlanW       Created
//
//----------------------------------------------------------------------------

SCODE CRowset::SetRequestedProperties(
    ULONG                  cPropertySets,
    DBPROPSET              rgPropertySets[])
{
    _DBErrorObj.ClearErrorInfo();

    if ( 0 != cPropertySets && 0 == rgPropertySets)
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IServiceProperties);;

    return _DBErrorObj.PostHResult(E_NOTIMPL, IID_IServiceProperties);;
}

//+---------------------------------------------------------------------------
//
//  Method:     CRowset::SetSuppliedProperties, public
//
//  Synopsis:   Set rowset properties via IServiceProperties (not supported)
//
//  Arguments:  [cPropertySets]  - number of property sets
//              [rgProperties]   - array of property sets to be set
//
//  History:     16 Nov 95   AlanW       Created
//
//----------------------------------------------------------------------------

SCODE CRowset::SetSuppliedProperties(
    ULONG                  cPropertySets,
    DBPROPSET              rgPropertySets[])
{
    _DBErrorObj.ClearErrorInfo();

    if ( 0 != cPropertySets && 0 == rgPropertySets)
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IServiceProperties);;

    return _DBErrorObj.PostHResult(E_NOTIMPL, IID_IServiceProperties);;
}


//+---------------------------------------------------------------------------
//
//  Method:     CRowset::AddRefChapter, public
//
//  Synopsis:   Increment the ref. count to a chapter
//
//  Arguments:  [hChapter]   - handle to chapter
//              [pcRefCount] - pointer to chapter ref. count
//
//  Notes:      Chapter references are obtained via an accessor from the
//              parent rowset, but they are addref'ed in the child rowset.
//
//  History:    15 Mar 99   AlanW       Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::AddRefChapter(
    HCHAPTER            hChapter,
    ULONG *             pcRefCount
) {
    tbDebugOut(( DEB_TRACE, "CRowset::AddRefChapter called!\n" ));
    _DBErrorObj.ClearErrorInfo();

    if (0 == _pChapterRowbufs)
        return _DBErrorObj.PostHResult(E_FAIL, IID_IChapteredRowset);

    if (DB_NULL_HCHAPTER == hChapter)
        return _DBErrorObj.PostHResult(DB_E_BADCHAPTER, IID_IChapteredRowset);

    SCODE scResult = S_OK;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        _pChapterRowbufs->AddRefChapter(hChapter, pcRefCount);
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IChapteredRowset);
        scResult = GetOleError(e);
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return scResult;
}


//+---------------------------------------------------------------------------
//
//  Method:     CRowset::ReleaseChapter, public
//
//  Synopsis:   Decrement the ref. count to a chapter
//
//  Arguments:  [hChapter]   - handle to chapter
//              [pcRefCount] - pointer to chapter ref. count
//
//  Notes:      Chapter references are obtained via an accessor from the
//              parent rowset, but they are released in the child rowset.
//
//  History:    15 Mar 99   AlanW       Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::ReleaseChapter(
    HCHAPTER            hChapter,
    ULONG *             pcRefCount
) {
    tbDebugOut(( DEB_TRACE, "CRowset::ReleaseChapter called!\n" ));
    _DBErrorObj.ClearErrorInfo();

    if (0 == _pChapterRowbufs)
        return _DBErrorObj.PostHResult(E_FAIL, IID_IChapteredRowset);

    if (DB_NULL_HCHAPTER == hChapter)
        return _DBErrorObj.PostHResult(DB_E_BADCHAPTER, IID_IChapteredRowset);

    SCODE scResult = S_OK;
    TRANSLATE_EXCEPTIONS;
    TRY
    {
        _pChapterRowbufs->ReleaseChapter(hChapter, pcRefCount);
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IChapteredRowset);
        scResult = GetOleError(e);
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return scResult;
}


STDMETHODIMP CRowset::Stop( )
{
   SCODE scResult = S_OK;
   TRY
   {
       _rQuery.StopAsynch(_hCursor);
   }
   CATCH( CException, e )
   {
       scResult = GetOleError(e);
   }
   END_CATCH;

   return scResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\seglist.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       seglist.cxx
//
//  Contents:   List of CTableSegment objects
//
//  Classes:    CTableSegList
//
//  History:    1-15-95   srikants   Created
//
//----------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#include <seglist.hxx>

#include "tblwindo.hxx"
#include "tblbuket.hxx"

CTableSegList::~CTableSegList()
{
    for ( CTableSegment * pSegment = RemoveTop();
          0 != pSegment;
          pSegment = RemoveTop() )
    {
        delete pSegment;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   RemoveTop
//
//  Synopsis:   Removes the top most element from the list and returns it.
//
//  Returns:    A pointer to the top most element from the list.
//
//  History:    1-16-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CTableSegment * CTableSegList::RemoveTop()
{
    // tbDebugOut (( DEB_ITRACE, "TableSegList::RemoveTop\n" ));

    CTableSegment* pSegment = (CTableSegment*) _Pop();
    if ( pSegment )
        _DecrementCount( *pSegment );
    return pSegment;
}

//+---------------------------------------------------------------------------
//
//  Function:   RemoveFromList
//
//  Synopsis:   Removes the indicated node from the list.
//
//  Arguments:  [pNodeToRemove] -
//
//  History:    1-16-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CTableSegList::RemoveFromList( CTableSegment * pNodeToRemove )
{
    Win4Assert( _IsNodeInList( pNodeToRemove ) &&
                "CTableSegList::pNodeToRemove not is list" );

    pNodeToRemove->Unlink();
    _DecrementCount( *pNodeToRemove );
}

//+---------------------------------------------------------------------------
//
//  Function:   InsertAfter
//
//  Synopsis:   Inserts "pNew" node after "pBefore" node.
//
//  Arguments:  [pBefore] -  The node already in list.
//              [pNew]    -  The new node to be inserted.
//
//  History:    1-16-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CTableSegList::InsertAfter( CTableSegment * pBefore, CTableSegment * pNew )
{
    Win4Assert( 0 != pBefore && 0 != pNew );
    pNew->InsertAfter( pBefore );
    _IncrementCount( *pNew );
}

//+---------------------------------------------------------------------------
//
//  Function:   InsertBefore
//
//  Synopsis:   Inserts "pNew" node before "pAfter" node.
//
//  Arguments:  [pAfter] - The node already in the list.
//              [pNew]   - The new node to be inserted.
//
//  History:    1-16-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CTableSegList::InsertBefore( CTableSegment * pAfter, CTableSegment * pNew )
{
    Win4Assert( 0 != pAfter && 0 != pNew );
    pNew->InsertBefore( pAfter );
    _IncrementCount( *pNew );
}

//+---------------------------------------------------------------------------
//
//  Function:   Replace
//
//  Synopsis:   Replaces the current entry in the iterator with the new
//              entry. It also replaces it in the list.
//
//  Arguments:  [it]   - Iterator
//              [pNew] - The new entry that replaces the entry in the
//              iterator.
//
//  Returns:    The old segment that was replaced in the list.
//
//  History:    4-10-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CTableSegment* CTableSegList::Replace( CDoubleIter & it, CTableSegment * pNew )
{
    Win4Assert( 0 != pNew );
    CTableSegment * pCurr = (CTableSegment *) _Replace( it, pNew );

    _DecrementCount( *pCurr );
    _IncrementCount( *pNew );

    return pCurr;
}


//+---------------------------------------------------------------------------
//
//  Function:   _IncrementCount
//
//  Synopsis:   Increments the appropriate count depending upon the type of the
//              segment (node)
//
//  Arguments:  [node] -
//
//  History:    1-16-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CTableSegList::_IncrementCount( const CTableSegment & node )
{
    switch( node.GetSegmentType() )
    {
    case CTableSegment::eWindow :
        _cWindows++;
        break;

    case CTableSegment::eBucket :
        _cBuckets++;
        break;
    };
}

//+---------------------------------------------------------------------------
//
//  Function:   _DecrementCount
//
//  Synopsis:   Decrements the count of the given node type.
//
//  Arguments:  [node] -
//
//  History:    1-16-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CTableSegList::_DecrementCount( const CTableSegment & node )
{
    switch( node.GetSegmentType() )
    {
        case CTableSegment::eWindow :
         Win4Assert( _cWindows > 0 );
        _cWindows--;
        break;

        case CTableSegment::eBucket :
         Win4Assert( _cBuckets > 0 );
        _cBuckets--;
        break;
    };

}

//+---------------------------------------------------------------------------
//
//  Function:   _IsNodeInList
//
//  Synopsis:   Determines if a given node is in the list.
//
//  Arguments:  [pNode] -  Node whose existence in the list is being tested.
//
//  Returns:    TRUE if found; FALSE o/w
//
//  History:    1-16-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CTableSegList::_IsNodeInList( CTableSegment * pNode )
{
    for (  CFwdTableSegIter iter(*this); !AtEnd(iter); Advance(iter) )
    {
        if ( iter.GetSegment() == pNode )
        {
            return TRUE;
        }
    }

    return FALSE;
}

CTableWindow * CDoubleTableSegIter::GetWindow()
{
    Win4Assert( GetSegment()->GetSegmentType() == CTableSegment::eWindow );
    return (CTableWindow *) _pLinkCur;
}

CTableBucket * CDoubleTableSegIter::GetBucket()
{
    Win4Assert( GetSegment()->GetSegmentType() == CTableSegment::eBucket );
    return (CTableBucket *) _pLinkCur;
}


//+---------------------------------------------------------------------------
//
//  Function:   ~CSegListMgr
//
//  Synopsis:   Destroys all the segments in the list.
//
//  History:    4-11-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CSegListMgr::~CSegListMgr()
{
    for ( CTableSegment * pSegment = _list.RemoveTop();
          0 != pSegment;
          pSegment = _list.RemoveTop() )
    {
        delete pSegment;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   _InvalidateIfCached
//
//  Synopsis:   If the given segment's pointer is cached, invalidate it.
//
//  Arguments:  [pSeg] -  The segment which is going to go away and so must
//              be invalidated.
//
//  History:    4-11-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CSegListMgr::_InvalidateIfCached( const CTableSegment * const pSeg )
{
    Win4Assert( 0 != pSeg );

    if ( _pCachedPutRowSeg == pSeg )
    {
        _pCachedPutRowSeg = 0;
    }

    _clientSegs.Invalidate( pSeg );
    _bucketSegs.Invalidate( pSeg );
}

//+---------------------------------------------------------------------------
//
//  Function:   _UpdateSegsInUse
//
//  Synopsis:   Updates the wid->Segment mapping for wids that are cached.
//              For such wids, if they are present in the new segment, the
//              mapping is updated.
//
//  Arguments:  [list] - The list to update in.
//              [pSeg] - Pointer to the segment which is the new segment
//
//  History:    5-30-95   srikants   Created
//
//  Notes:      Helper function for UpdateSegsInUse()
//
//----------------------------------------------------------------------------

void CSegListMgr::_UpdateSegsInUse( CWidSegMapList & list,
                                    CTableSegment * pSeg )
{
    for ( CFwdWidSegMapIter iter(list); !list.AtEnd(iter);
          list.Advance(iter) )
    {
        WORKID  wid = iter->GetWorkId();
        if ( widInvalid != wid &&
             pSeg->IsRowInSegment( wid ) )
        {
            Win4Assert( 0 == iter->GetSegment() );
            iter->Set( pSeg );
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   UpdateSegsInUse
//
//  Synopsis:   Updates the wid->Segment mapping for wids that are cached.
//              For such wids, if they are present in the new segment, the
//              mapping is updated.
//
//  Arguments:  [pSeg] - Pointer to a new segment that is coming into
//              existence.
//
//  History:    4-11-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CSegListMgr::UpdateSegsInUse( CTableSegment * pSeg )
{
    Win4Assert( 0 != pSeg );

    CWidSegMapList & clientList = _clientSegs.GetList();
    _UpdateSegsInUse( clientList, pSeg );


    if ( !_bucketSegs.IsEmpty() )
    {
        CWidSegMapList & bktList = _bucketSegs.GetList();
        _UpdateSegsInUse( bktList, pSeg );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CSegListMgr::Replace
//
//  Synopsis:   Replaces the given segment in the _list with the new segments
//              passed in the list.
//
//  Arguments:  [pSeg] -  The segment to replace 
//              [list] -  The new list of segments.
//
//  History:    10-20-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CTableSegment * CSegListMgr::Replace( CTableSegment * pSeg, CTableSegList & list )
{

    _lookupArray.Replace( pSeg, list );

    CTableSegment * pCurr = pSeg;
    CTableSegment * pFirst = list.RemoveTop();

    while ( 0 != pFirst )
    {
        _list.InsertAfter( pCurr, pFirst );
        pCurr = pFirst;
        pFirst = list.RemoveTop();
    }

    _list.RemoveFromList( pSeg );
    _InvalidateIfCached( pSeg );

    _lookupArray.TestInSync( _list );

    return pSeg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\sglookup.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       sglookup.cxx
//
//  Contents:   A class for doing a quick lookup of a segment based on the
//              key. It will do a binary search and locate the segment.
//              This is useful for doing row insertions into a large table
//              when keys are not coming in any specific order.
//
//  Classes:    CSegmentArrray
//
//  History:    10-20-95   srikants   Created
//
//----------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#include <sglookup.hxx>
#include <seglist.hxx>

#include "tabledbg.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CSegmentArray consructor 
//
//  Synopsis:   Initializes the segment array 
//
//  History:    10-20-95   srikants   Created
//
//----------------------------------------------------------------------------

CSegmentArray::CSegmentArray()
: CDynArrayInPlace<CTableSegment *>(eMinSegments),
  _pComparator(0),
  _iHint(0)
{
}


//+---------------------------------------------------------------------------
//
//  Member:     CSegmentArray::_FindSegment
//
//  Synopsis:   Given a segment pointer, it searches for the segment in the
//              array and returns the index in the array.
//
//  Arguments:  [pSeg] - Segment to look for.
//
//  Returns:    Index in the array if the segment is located.
//              -1 otherwise.
//
//  History:    10-25-95   srikants   Created
//
//----------------------------------------------------------------------------

int CSegmentArray::_FindSegment( const CTableSegment * pSeg )
{
    Win4Assert( 0 != pSeg );

    //
    // Optimization - use the last returned segment index as a hint
    //

    if ( _iHint < Count() && Get(_iHint) == pSeg )
        return (int) _iHint;    

    for ( unsigned i = 0; i < Count(); i++ )
    {
        if ( Get(i) == pSeg )
        {
            _iHint = i;
            return (int) i;
        }
    }

    //
    // The segment could not be located.
    //
    _iHint = 0;
    return -1;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSegmentArray::LookUp
//
//  Synopsis:   Looks up the segment which is likely to contain the given
//              key or is a candidate to insert the given key.
//
//  Arguments:  [key] -  Key to look up.
//
//  Returns:    The segment pointer where to look for/insert the given key.
//              0 if there are no segments
//
//  History:    10-20-95   srikants   Created
//
//  Notes:      Please note that each segment has only the "smallest" key in
//              that segment. We don't know anything about the highest key in
//              that segment. if we two adjacent segments with lowest keys
//              k1 and k3 and a new key if k1 < k2 < k3,
//              k2 will end up in segment 1
//
//----------------------------------------------------------------------------

CTableSegment * CSegmentArray::LookUp( CTableRowKey & key )
{

    Win4Assert( 0 != _pComparator );

    int cSegs = (int) Count();

    if ( 0 == cSegs )
        return 0;    

    int iLow = 0;
    int iHigh = cSegs - 1;
    int iMid = iHigh/2;

    int iComp = 0;

    while ( iLow <= iHigh )
    {
        iMid = (iLow + iHigh)/2;

        CTableSegment * pCurrSeg = Get( (unsigned) iMid );

        iComp = _pComparator->Compare( key, pCurrSeg->GetLowestKey() );

        if ( 0 == iComp )
            return pCurrSeg;    

        if ( iComp > 0 )    // key is bigger than the smallest key in the seg
            iLow = iMid+1;
        else                // key is < the smallest key in the seg
            iHigh = iMid-1;
    }

    Win4Assert( iLow > iHigh );

    int iGet = 0;

    if ( iMid > iHigh )
    {
        Win4Assert( iLow == iMid );
        Win4Assert( iComp < 0 );

        iGet = iHigh >= 0 ? iHigh : 0;
    }
    else
    {
        Win4Assert( iMid == iHigh );
        Win4Assert( iMid < iLow && iMid < cSegs );
        iGet = iMid;
    }

    return Get( (unsigned) iGet );

}

//+---------------------------------------------------------------------------
//
//  Member:     CSegmentArray::Append
//
//  Synopsis:   Adds the given segment to the end of the array.
//
//  Arguments:  [pSeg] -  Segment to be appended.
//
//  History:    10-20-95   srikants   Created
//
//----------------------------------------------------------------------------

void CSegmentArray::Append( CTableSegment * pSeg )
{
    Win4Assert( 0 != pSeg );
    Win4Assert( !IsFound(pSeg) );

    Add( pSeg, Count() );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSegmentArray::InsertAfter
//
//  Synopsis:   Inserts the given segment after the marker segment
//
//  Arguments:  [pMarker] -  Segment already present in the array.
//              [pSeg]    -  New segment to be inserted.
//
//  History:    10-20-95   srikants   Created
//
//----------------------------------------------------------------------------

void CSegmentArray::InsertAfter( const CTableSegment * pMarker,
                                 CTableSegment * pSeg )
{

    Win4Assert( 0 != pSeg );
    Win4Assert( !IsFound(pSeg) );
    Win4Assert( 0 != pMarker );

    int iMarker = _FindSegment( pMarker );
    Win4Assert( iMarker >= 0 );
    Insert( pSeg, (unsigned)iMarker+1 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSegmentArray::InsertBefore
//
//  Synopsis:   Inserts the given segment "before" the marker segment
//
//  Arguments:  [pMarker] - The segment before which the new segment must
//              be inserted. If NULL, the given segment will be added as
//              the first segment in the array.
//
//              [pSeg]    - The new segment
//
//  History:    10-20-95   srikants   Created
//
//----------------------------------------------------------------------------

void CSegmentArray::InsertBefore( const CTableSegment * pMarker,
                                  CTableSegment * pSeg )
{
    Win4Assert( 0 != pSeg );
    Win4Assert( !IsFound(pSeg) );

    if ( 0 != pMarker )
    {
        int iPos = _FindSegment( pMarker );
        Win4Assert( iPos >= 0 );
        Insert( pSeg, (unsigned) iPos );
    }
    else
    {
        Insert( pSeg, 0 );  // make this the first in the array
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CSegmentArray::Replace
//
//  Synopsis:   Replaces the old segment with the new segment
//
//  Arguments:  [pOld] - 
//              [pNew] - 
//
//  History:    10-20-95   srikants   Created
//
//----------------------------------------------------------------------------

void CSegmentArray::Replace( const CTableSegment * pOld, CTableSegment * pNew )
{
    Win4Assert( 0 != pOld && 0 != pNew );
    int iPos = _FindSegment( pOld );
    Win4Assert( iPos >= 0 );

    Win4Assert( !IsFound( pNew ) );

    Add( pNew, (unsigned) iPos );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSegmentArray::_MoveEntries
//
//  Synopsis:   Moves entries from the specified offset by the given number
//              of entries..
//
//  Arguments:  [iStart]   -  Starting offset to move
//              [cEntries] -  Number of entries to move by.
//
//  History:    10-20-95   srikants   Created
//
//----------------------------------------------------------------------------

void CSegmentArray::_MoveEntries( unsigned iStart, unsigned cEntries )
{
    Win4Assert( iStart < _count );

    if ( 0 == cEntries )
        return;

    Win4Assert( cEntries + _count <= Size() );

    unsigned iNewPos = iStart + cEntries;

    memmove( _aItem + iNewPos, _aItem + iStart,
             (_count - iStart) * sizeof(CTableSegment *) );

    _count += cEntries;

#if CIDBG==1
    //
    // The caller can asser that the moved entries are all NULL.
    //
    for ( unsigned i = iStart; i < iNewPos; i++ )
    {
        _aItem[i] = 0;    
    }
#endif  // CIDBG==1

}

//+---------------------------------------------------------------------------
//
//  Member:     CSegmentArray::Replace
//
//  Synopsis:   Removes "pOld" from the list and inserts the new list of
//              segments in its place.
//
//  Arguments:  [pOld]    - 
//              [segList] - 
//
//  History:    10-20-95   srikants   Created
//
//----------------------------------------------------------------------------

void CSegmentArray::Replace( const CTableSegment * pOld,
                             CTableSegList & segList )
{
    unsigned cSegsToInsert = segList.GetSegmentsCount();

    if ( cSegsToInsert == 0 )
    {
        RemoveEntry( pOld );
        return;
    }

    int iSeg = _FindSegment( pOld );
    Win4Assert( iSeg >= 0 );

    unsigned iInsert = (unsigned) iSeg;

    //
    // Replace the current segment with the first one in the list
    //
    CFwdTableSegIter iter( segList );

    Win4Assert ( !segList.AtEnd(iter) );

    _aItem[iInsert++] = iter.GetSegment();
    segList.Advance(iter);
    cSegsToInsert--;

    if ( !segList.AtEnd(iter) )
    {
        Win4Assert( cSegsToInsert > 0 );

        //
        // There is more than one segment to replace with. We should
        // iterate and move them.
        //

        unsigned cTotalSegs = _count + cSegsToInsert;

        //
        // Grow the array if necessary.
        //
        if ( (cTotalSegs-1) >= _size )
            _GrowToSize( cTotalSegs-1 );

        if ( iInsert != _count )
        {
            Win4Assert( iInsert < _count );
            _MoveEntries( iInsert, cSegsToInsert );
        }
        else
        {
            //
            // We are just appending at the end. No need to move anything
            //
#if CIDBG==1
            for ( unsigned i = _count; i < cTotalSegs; i++ )
            {
                _aItem[i] = 0;    
            }
#endif  // CIDBG==1

            _count +=cSegsToInsert;
            Win4Assert( _count == cTotalSegs );
        }

        for ( ; !segList.AtEnd(iter); segList.Advance(iter) )
        {

#if CIDBG==1
            //
            // We are either appending to the end or the entries got moved
            // and nullified.
            //
            Win4Assert( 0 == _aItem[iInsert]  );
#endif  // CIDBG==1

            Win4Assert( !IsFound(iter.GetSegment()) );
            _aItem[iInsert++] = iter.GetSegment();
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CSegmentArray::RemoveEntry
//
//  Synopsis:   Removes the specified segment from the array.
//
//  Arguments:  [pSeg] - 
//
//  History:    10-20-95   srikants   Created
//
//----------------------------------------------------------------------------

void CSegmentArray::RemoveEntry( const CTableSegment * pSeg )
{
    int iSeg = _FindSegment( pSeg );
    Win4Assert( iSeg >= 0 );

    Remove( (unsigned) iSeg );
}

#if CIDBG==1

//+---------------------------------------------------------------------------
//
//  Member:     CSegmentArray::TestInSync
//
//  Synopsis:   Tests that the list and the array are fully in sync.
//
//  Arguments:  [list] - The global list of segments
//
//  History:    10-25-95   srikants   Created
//
//----------------------------------------------------------------------------

void CSegmentArray::TestInSync( CTableSegList & list )
{
    if ( Count() != list.GetSegmentsCount() )
    {
        tbDebugOut(( DEB_ERROR, "Array Count = 0x%X ListCount = 0x%X \n",
                     Count(), list.GetSegmentsCount() ));
        Win4Assert( !"Array Count and List Count Not In Sync" );
        return;
    }

    unsigned i = 0;
    for ( CFwdTableSegIter iter(list); !list.AtEnd(iter); list.Advance(iter) )
    {
        if ( iter.GetSegment() != Get(i) )
        {
            tbDebugOut(( DEB_ERROR, "iter.GetSegment() = 0x%X : i = 0x%X : Array[i] = 0x%X\n",
                         iter.GetSegment(), i, Get(i) ));
            Win4Assert( !"List and Array are not in sync" );
        }
        i++;
    }
}

#endif  // CIDBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\seqexec.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 2000.
//
// File:        SeqExec.cxx
//
// Contents:    Sequential Query execution class
//
// Classes:     CQSeqExecute
//
// History:     22-Jan-95       DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <query.hxx>

#include "seqexec.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CQSeqExecute::CQSeqExecute, public
//
//  Synopsis:   Start a query
//
//  Arguments:  [qopt]  -- Query optimizer
//
//  History:    20-Jan-95   DwightKr    Created
//
//----------------------------------------------------------------------------

CQSeqExecute::CQSeqExecute( XQueryOptimizer & xOpt )
    : _status(STAT_BUSY),
      _fCursorOnNewObject( TRUE ),
      _fAbort( FALSE ),
      _TimeLimit( xOpt->GetTimeLimit() ),
      _cRowsToReturnMax( xOpt->MaxResults() ),
      _xOpt( xOpt )
{
    Win4Assert( !_xOpt->IsMultiCursor() && _xOpt->IsFullySorted() );

    if ( 0 != _xOpt->FirstRows() )
        _cRowsToReturnMax = _xOpt->FirstRows();

    if (_cRowsToReturnMax == 0)
        _cRowsToReturnMax = 0xFFFFFFFF;

    TRY
    {
        _objs.Set( _xOpt->QueryNextCursor( _status, _fAbort ) );
    }
    CATCH(CException, e)
    {
        if ( e.GetErrorCode() == QUERY_E_TIMEDOUT )
        {
            //
            // Execution time limit has been exceeded, not a catastrophic error
            //
            _status = ( STAT_DONE |
                        QUERY_RELIABILITY_STATUS( Status() ) |
                        STAT_TIME_LIMIT_EXCEEDED );

            //
            // Update local copy of execution time
            //
            _TimeLimit.SetExecutionTime( 0 );
        }
        else
            RETHROW();
    }
    END_CATCH

    if ( !_objs.IsNull() )
    {
        _objs->Quiesce();
        _objs->SwapOutWorker();
    }
} //CQSeqExecute

//+---------------------------------------------------------------------------
//
//  Member:     CQSeqExecute::GetRows, public
//
//  Synopsis:   Get the next set of rows from a query
//
//  History:    20-Jan-95   DwightKr    Created.
//
//----------------------------------------------------------------------------

SCODE CQSeqExecute::GetRows( CTableColumnSet const & OutColumns,
                             unsigned &cRowsToSkip,
                             CGetRowsParams & GetParams )
{
    if ( _TimeLimit.IsTimedOut() )
        return DB_S_STOPLIMITREACHED;

    if ( ( STAT_DONE == QUERY_FILL_STATUS( _status ) ) ||
         _objs.IsNull() )
        return DB_S_ENDOFROWSET;

    _TimeLimit.SetBaselineTime( );
    SCODE scResult = S_OK;

    TRY
    {
        //
        // If this is not the first call to GetRows, then advance to the
        // next object.  We've already seen the current object.
        //

        if ( !_fCursorOnNewObject )
            _objs->NextWorkId();

        //
        //  Skip the # of rows specified
        //

        for ( WORKID widEnd = _objs->WorkId();
              cRowsToSkip > 0 && widEnd != widInvalid;
              widEnd = _objs->NextWorkId() )
        {
            cRowsToSkip--;

            if (_cRowsToReturnMax == 0)
            {
                vqDebugOut(( DEB_IWARN,
                             "Query row limit exceeded for %08x\n",
                             this ));

                scResult = DB_S_ENDOFROWSET;
                widEnd = widInvalid;
                break;
            }
            _cRowsToReturnMax--;

            if ( CheckExecutionTime() )
            {
                scResult = DB_S_STOPLIMITREACHED;
                widEnd = widInvalid;
                break;
            }
        }

        //
        //  Get the # of rows requested
        //

        BYTE * pbBuf = 0;

        while ( widEnd != widInvalid )
        {
            if ( _cRowsToReturnMax == 0 )
            {
                vqDebugOut(( DEB_IWARN,
                             "Query row limit exceeded for %08x\n",
                             this ));

                scResult = DB_S_ENDOFROWSET;
                break;
            }
            if ( ( 0 == ( GetParams.RowsTransferred() % 5 ) ) &&
                 ( CheckExecutionTime() ) )
            {
                scResult = DB_S_STOPLIMITREACHED;
                break;
            }

            if ( 0 == pbBuf )
                pbBuf = (BYTE *) GetParams.GetFixedVarAllocator().AllocFixed();

            scResult = GetRowInfo( OutColumns, GetParams, pbBuf );

            //
            //  If object is deleted, just skip to the next one and re-use
            //  the row buffer space from the GetParam's allocator.
            //

            if (scResult == S_OK)
            {
                // fetched a row -- record that fact

                GetParams.IncrementRowCount();
                Win4Assert(_cRowsToReturnMax != 0);
                _cRowsToReturnMax--;
                pbBuf = 0;
            }
            else
            {
                if ( scResult == STATUS_FILE_DELETED )
                    scResult = S_OK;
                else
                    break;
            }

            // Do we need to get another?

            if ( 0 == GetParams.RowsToTransfer() )
                break;

            widEnd = _objs->NextWorkId();
        }

        if ( widEnd == widInvalid )
        {
            scResult = cRowsToSkip ? DB_E_BADSTARTPOSITION : DB_S_ENDOFROWSET;
            _status = STAT_DONE | QUERY_RELIABILITY_STATUS(_status);
        }
    }
    CATCH( CException, e )
    {
        _fCursorOnNewObject = TRUE;

        //
        //  A common error returned here is E_OUTOFMEMORY.  This needs
        //  to be translated and passed back to the caller to be
        //  handled appropriately.  It is a non-fatal error.
        //

        if ( STATUS_BUFFER_TOO_SMALL == e.GetErrorCode() )
        {
            if ( GetParams.RowsTransferred() > 0 )
                scResult = DB_S_BLOCKLIMITEDROWS;
            else
                scResult = STATUS_BUFFER_TOO_SMALL;
        }
        else if ( QUERY_E_TIMEDOUT == e.GetErrorCode() )
        {
            //
            // Execution time limit has been exceeded, not a catastrophic error
            //
            _status = ( STAT_DONE |
                        QUERY_RELIABILITY_STATUS( Status() ) |
                        STAT_TIME_LIMIT_EXCEEDED );
            scResult = DB_S_STOPLIMITREACHED;

            //
            // Update local copy of execution time
            //
            _TimeLimit.SetExecutionTime( 0 );
        }
        else
        {
            vqDebugOut(( DEB_ERROR,
                         "Exception 0x%x caught in CQSeqExecute::GetRows\n",
                         e.GetErrorCode() ));

            scResult = e.GetErrorCode();
        }
    }
    END_CATCH

    _objs->Quiesce();

    _objs->SwapOutWorker();

    if ( S_OK == scResult )
        _fCursorOnNewObject = FALSE;

    return scResult;
} //GetRows

//+---------------------------------------------------------------------------
//
//  Member:     CQSeqExecute::GetRowInfo, private
//
//  Synopsis:   Get the next row from a query without advancing the cursor
//
//  History:    20-Jan-95   DwightKr    Created.
//
//----------------------------------------------------------------------------
SCODE CQSeqExecute::GetRowInfo(
    CTableColumnSet const & OutColumns,
    CGetRowsParams &        GetParams,
    BYTE *                  pbBuf )
{
    SCODE scResult = S_OK;

    //
    //  Get the current row from the cursor
    //

    Win4Assert( !_objs.IsNull() );
    CRetriever & obj = _objs.GetReference();

    //
    //  Transfer each of the columns to the output buffer
    //
    for ( unsigned iColumn=0;
          iColumn < OutColumns.Size();
          iColumn++ )
    {
        CTableColumn & rColumn = *OutColumns.Get(iColumn);

        Win4Assert( VT_EMPTY != rColumn.GetStoredType() );

        ULONG cbBuf = sizeof _abValueBuf;
        CTableVariant* pVarnt = (CTableVariant *) &_abValueBuf;
        RtlZeroMemory( pVarnt, sizeof CTableVariant );

        GetValueResult eGvr = obj.GetPropertyValue( rColumn.PropId,
                                                    pVarnt,
                                                    &cbBuf );

        CTableColumn::StoreStatus stat = CTableColumn::StoreStatusOK;
        XPtr<CTableVariant> sVarnt(0);

        // Really large values must be deferred in cisvc due to the limit on
        // the size of named pipe buffers.
    
        if ( ( GVRNotEnoughSpace == eGvr ) &&
             ( cbBuf <= cbMaxNonDeferredValueSize ) )
        {
            sVarnt.Set( (CTableVariant *) new BYTE[cbBuf] ); // Smart pointer
            pVarnt = sVarnt.GetPointer();
            eGvr = obj.GetPropertyValue( rColumn.PropId, pVarnt, &cbBuf );
        }
    
        if ( GVRSuccess != eGvr )
        {
            if ( GVRNotAvailable == eGvr )
            {
                pVarnt->vt = VT_EMPTY;
                stat = CTableColumn::StoreStatusNull;
            }
            else if ( GVRSharingViolation == eGvr )
            {
                pVarnt->vt = VT_EMPTY;
                stat = CTableColumn::StoreStatusNull;
    
                // don't set this until it's implemented everywhere
                //_status |= STAT_SHARING_VIOLATION;
            }
            else if ( GVRNotEnoughSpace == eGvr )
            {
                stat = CTableColumn::StoreStatusDeferred;
            }
        }

        if ( rColumn.IsLengthStored() )
            rColumn.SetLength( pbBuf, cbBuf );

        Win4Assert( rColumn.IsValueStored() );

        if ( ( GVRSuccess == eGvr ) ||
             ( GVRNotAvailable == eGvr ) ||
             ( GVRSharingViolation == eGvr ) )
        {
            BYTE *pRowColDataBuf = pbBuf + rColumn.GetValueOffset();
            DBLENGTH ulTemp;

            DBSTATUS dbStatus = pVarnt->CopyOrCoerce(
                                          pRowColDataBuf,
                                          rColumn.GetValueSize(),
                                          rColumn.GetStoredType(),
                                          ulTemp,
                                          GetParams.GetVarAllocator() );

            if ( DBSTATUS_S_OK != dbStatus )
            {
                vqDebugOut(( DEB_ITRACE,
                             "Sequential query column 0x%x copy failed "
                             "srcvt 0x%x, workid 0x%x, dbstat 0x%x\n",
                             iColumn,
                             pVarnt->vt,
                             _objs->WorkId(),
                             dbStatus ));

                stat = CTableColumn::StoreStatusNull;
            }
        }
        else if ( GVRNotEnoughSpace != eGvr ) // deferred
        {
            vqDebugOut(( DEB_WARN,
                         "Sequential fetch of property for row (wid = 0x%x) failed %d\n",
                         _objs->WorkId(), eGvr ));
            scResult = E_FAIL;
            break;
        }

        Win4Assert( rColumn.IsStatusStored() );
        rColumn.SetStatus( pbBuf, stat );
    }

    return scResult;
} //GetRowInfo

//+-------------------------------------------------------------------------
//
//  Member:     CQSeqExecute::CheckExecutionTime, private
//
//  Synopsis:   Check for CPU time limit exceeded
//
//  Arguments:  NONE
//
//  Returns:    TRUE if execution time limit exceeded.
//
//  Notes:      The CPU time spent executing a query since the last
//              check is computed and compared with the remaining time
//              in the CPU time limit.  If the time limit is exceeded,
//              the query is aborted and a status bit is set indicating
//              that.  Otherwise, the remaining time and the input time
//              snapshots are updated.
//
//  History:    08 Apr 96    AlanW        Created
//
//--------------------------------------------------------------------------

BOOL CQSeqExecute::CheckExecutionTime( void )
{
    if ( _TimeLimit.CheckExecutionTime() )
    {
        vqDebugOut(( DEB_IWARN,
                     "Execution time limit exceeded for %08x\n",
                     this ));

        _status = ( STAT_DONE |
                    QUERY_RELIABILITY_STATUS( Status() ) |
                    STAT_TIME_LIMIT_EXCEEDED );

        return TRUE;
    }

    return FALSE;
}



//+-------------------------------------------------------------------------
//
//  Member:     CQSeqExecute::FetchDeferredValue
//
//  Synopsis:   Checks if read access is permitted
//
//  Arguments:  [wid] - Workid
//              [ps]  -- Property to be fetched
//              [var] -- Property returned here
//
//  History:    12-Jan-97    SitaramR        Created
//
//--------------------------------------------------------------------------

BOOL CQSeqExecute::FetchDeferredValue( WORKID wid,
                                       CFullPropSpec const & ps,
                                       PROPVARIANT & var )
{
    return _xOpt->FetchDeferredValue( wid, ps, var );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\svcproxy.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       svcproxy.cxx
//
//  Contents:   Proxy to cisvc encapsulating all the context for a
//              running query, including the query execution context, the
//              cached query results, and all cursors over the results.
//
//  Classes:    CSvcQueryProxy
//
//  History:    13 Sept 96  dlee created (mostly copied) from queryprx.cxx
//              22 Aug  99  KLam Win64->Win32 support
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <query.hxx>
#include <pickle.hxx>
#include <memser.hxx>
#include <sizeser.hxx>
#include <propvar.h>
#include <proxymsg.hxx>
#include <tblvarnt.hxx>
#include <tgrow.hxx>
#include <pmalloc.hxx>

#include "tabledbg.hxx"
#include "rowseek.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::CSvcQueryProxy, public
//
//  Synopsis:   Creates a locally accessible Query
//
//  Arguments:  [client]     - Proxy for talking to remote process
//              [cols]       - Columns that may be bound to
//              [rst]        - Query restriction
//              [pso]        - Sort order of the query
//              [pcateg]     - Categorization specification
//              [RstProp]    - Rowset properties for rowset(s) created
//              [pidmap]     - Property ID mapper
//              [cCursors]   - count of cursors expected to be created
//              [aCursors]   - returns handles to cursors created
//
//  History:    13 Sept 96  dlee created
//
//----------------------------------------------------------------------------

CSvcQueryProxy::CSvcQueryProxy(
    CRequestClient &           client,
    CColumnSet const &         cols,
    CRestriction const &       rst,
    CSortSet const *           pso,
    CCategorizationSet const * pcateg,
    CRowsetProperties const &  RstProp,
    CPidMapper const &         pidmap ,
    ULONG                      cCursors,
    ULONG *                    aCursors )
        : _ref( 0 ),
          _client( client ),
          _fTrueSequential( FALSE ),
          _fWorkIdUnique( FALSE ),
          _xQuery( ),
          _xBindings( )
{
    tbDebugOut(( DEB_PROXY, "CSvcQueryProxy\n" ));

    // DSO property IDs change with version 5

    if ( _client.GetServerVersion() < 5 )
       THROW( CException( STATUS_INVALID_PARAMETER_MIX ) );

    _aCursors.Init( cCursors );

    ULONG cbIn = PickledSize( _client.GetServerVersion(),
                              &cols,
                              &rst,
                              pso,
                              pcateg,
                              &RstProp,
                              &pidmap );
    cbIn = AlignBlock( cbIn, sizeof ULONG );
    XArray<BYTE> xQuery( cbIn + sizeof CPMCreateQueryIn );
    BYTE * pbPickledQuery = xQuery.GetPointer() + sizeof CPMCreateQueryIn;
    Pickle( _client.GetServerVersion(),
            &cols,
            &rst,
            pso,
            pcateg,
            &RstProp,
            &pidmap,
            pbPickledQuery,
            cbIn );

    CPMCreateQueryIn & request = * ( new( xQuery.Get() ) CPMCreateQueryIn );

    request.SetCheckSum( xQuery.SizeOf() );

    const unsigned cbCursors = sizeof ULONG * cCursors;
    const unsigned cbReply = sizeof CPMCreateQueryOut + cbCursors;
    XGrowable<BYTE, 200> xReply( cbReply );
    CPMCreateQueryOut * pReply = new( xReply.Get() ) CPMCreateQueryOut();

    ULONG cbRead;
    _client.DataWriteRead( &request,
                           xQuery.SizeOf(),
                           pReply,
                           cbReply,
                           cbRead );

    // DataWriteRead throws both connection problems and request problems

    Win4Assert( SUCCEEDED( pReply->GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || cbReply == cbRead );

    _fTrueSequential = pReply->IsTrueSequential();
    _fWorkIdUnique = pReply->IsWorkIdUnique();
    _ulServerCookie = pReply->GetServerCookie();

    RtlCopyMemory( aCursors, pReply->GetCursors(), cbCursors );

    //
    // Preserve xQuery for RestartPosition on sequential queries
    //
    if ( _fTrueSequential )
    {
        unsigned cElems = xQuery.Count();
        _xQuery.Set( cElems, xQuery.Acquire() );

        // The assumption here is that for a seq query the cursor does not
        // change.  If this becomes different at a later date, the rowset
        // will have an old cursor after RestartPosition.

        RtlCopyMemory( _aCursors.Get(), aCursors, cbCursors );
    }

    #if CIDBG == 1
        for ( ULONG i = 0; i < cCursors; i++ )
            Win4Assert( 0 != aCursors[i] );
    #endif // CIDBG == 1

    AddRef();
} //CSvcQueryProxy

//+---------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::~CSvcQueryProxy, public
//
//  Synopsis:   Destroy the query.  Nothing to do -- all of the cursors
//              have been freed by now.
//
//  History:    13 Sept 96  dlee created
//
//----------------------------------------------------------------------------

CSvcQueryProxy::~CSvcQueryProxy()
{
    tbDebugOut(( DEB_PROXY, "~CSvcQueryProxy\n\n" ));
    Win4Assert( 0 == _ref );

    // don't _client.Disconnect() here -- keep it open for more queries

} //~CSvcQueryProxy

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::AddRef, public
//
//  Synopsis:   Reference the query.
//
//  History:    13 Sept 96  dlee created
//
//--------------------------------------------------------------------------

ULONG CSvcQueryProxy::AddRef()
{
    return InterlockedIncrement( & _ref );
} //AddRef

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::Release, public
//
//  Synopsis:   De-Reference the query.
//
//  Effects:    If the ref count goes to 0 then the query is deleted.
//
//  History:    13 Sept 96  dlee created
//
//--------------------------------------------------------------------------

ULONG CSvcQueryProxy::Release()
{
    long l = InterlockedDecrement( & _ref );

    if ( l <= 0 )
    {
        tbDebugOut(( DEB_PROXY, "CSvcQueryProxy unreferenced.  Deleting.\n" ));
        delete this;
        return 0;
    }

    return l;
} //Release

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::FreeCursor, public
//
//  Synopsis:   Free a handle to a CTableCursor
//
//  Arguments:  [hCursor] - handle to the cursor to be freed
//
//  Returns:    # of cursors remaining
//
//  History:    13 Sept 96  dlee created
//
//--------------------------------------------------------------------------

unsigned CSvcQueryProxy::FreeCursor(
    ULONG hCursor )
{
    tbDebugOut(( DEB_PROXY, "FreeCursor\n" ));
    Win4Assert( 0 != hCursor );

    // If FreeCursor fails (likely because the system is out of memory),
    // terminate the connection with cisvc so query resources are freed.

    TRY
    {
        CPMFreeCursorIn request( hCursor );
        CPMFreeCursorOut reply;
        ULONG cbRead;
        _client.DataWriteRead( &request,
                               sizeof request,
                               &reply,
                               sizeof reply,
                               cbRead );

        Win4Assert( SUCCEEDED( reply.GetStatus() ) );
        Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );

        return reply.CursorsRemaining();
    }
    CATCH( CException, e )
    {
        prxDebugOut(( DEB_IWARN,
                      "freecursor failed 0x%x, rudely terminating connection\n",
                      e.GetErrorCode() ));

        _client.TerminateRudelyNoThrow();

        RETHROW();
    }
    END_CATCH

    return 0;
} //FreeCursor

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::GetRows, public
//
//  Synopsis:   Retrieve row data for a table cursor
//
//  Arguments:  [hCursor] - the handle of the cursor to fetch data for
//              [rSeekDesc] - row seek operation to be done before fetch
//              [pGetRowsParams] - row fetch parameters and buffer pointers
//              [pSeekDescOut] - row seek description for restart
//
//  Returns:    SCODE - the status of the operation.
//
//  History:    13 Sept 96  dlee created
//
//--------------------------------------------------------------------------

SCODE CSvcQueryProxy::GetRows(
    ULONG                       hCursor,
    const CRowSeekDescription & rSeekDesc,
    CGetRowsParams &            rGetRowsParams,
    XPtr<CRowSeekDescription> & pSeekDescOut)
{
    tbDebugOut(( DEB_PROXY,
                 "GetRows 0x%x\n",
                 rGetRowsParams.RowsToTransfer() ));

    unsigned cbSeek = rSeekDesc.MarshalledSize();
    unsigned cbInput = sizeof CPMGetRowsIn + cbSeek;
    unsigned cbReserved = AlignBlock( sizeof CPMGetRowsOut + cbSeek,
                                      sizeof LONGLONG );
    XArray<BYTE> xIn( cbInput );
    CPMGetRowsIn *pRequest = new( xIn.Get() )
                             CPMGetRowsIn( hCursor,
                                           rGetRowsParams.RowsToTransfer(),
                                           rGetRowsParams.GetFwdFetch(),
                                           rGetRowsParams.GetRowWidth(),
                                           cbSeek,
                                           cbReserved );
    // serialize the seek description

    CMemSerStream stmMem( pRequest->GetDesc(), cbSeek );
    rSeekDesc.Marshall( stmMem );

    // Make an allocator for the output.  Scale the buffer size based
    // on the # of rows to be retrieved (just a heuristic).  Large buffers
    // are more expensive since the entire buffer must be sent over the
    // pipe (since var data grows down from the end of the buffer).

    // For 10 rows in a typical web query, it takes about 7-10k.  Any way
    // to squeeze it so it always fits in 8k?  Eg:
    // filename,size,characterization,vpath,doctitle,write
    // filename -- 20
    // abstract -- 640
    // props+variants -- 16*6
    // vpath -- 100
    // title -- 80
    // total: 936 * 10 rows = 9360 bytes

    const unsigned cbGetRowsGranularity = 512;
    const unsigned cbBigRow = 1000;
    const unsigned cbNormalRow = 300;
    unsigned cbOut = rGetRowsParams.RowsToTransfer() * cbBigRow;
    cbOut = __max( rGetRowsParams.GetRowWidth(), cbOut );
    cbOut = __min( cbOut, cbMaxProxyBuffer );
    XArray<BYTE> xOut;

    // loop until at least 1 row fits in a buffer

    CPMGetRowsOut *pReply = 0;
    NTSTATUS Status = 0;
    DWORD cbRead;
    do
    {
        cbOut = AlignBlock( cbOut, cbGetRowsGranularity );
        Win4Assert( cbOut <= cbMaxProxyBuffer );
        xOut.ReSize( cbOut );

        pReply = (CPMGetRowsOut *) xOut.GetPointer();
        pRequest->SetReadBufferSize( cbOut );

#ifdef _WIN64
        //
        // If a Win64 client is talking to a Win32 server set the base in the sent
        // buffer to 0 so that the values returned are offsets and remember what the
        // real pointer is.
        // Otherwise, be sure to set the reply base pointer to zero to indicate to the
        // rowset that no munging has to be done.
        //
       if ( !_client.IsServer64() )
       {
            pRequest->SetClientBase ( 0 );
            rGetRowsParams.SetReplyBase ( (BYTE *) pReply );
       }
       else
       {
            pRequest->SetClientBase( (ULONG_PTR) pReply );
       }
#else 
        pRequest->SetClientBase( (ULONG_PTR) pReply );
#endif

        pRequest->SetCheckSum( cbInput );

        TRY
        {
            _client.DataWriteRead( pRequest,
                                   cbInput,
                                   pReply,
                                   cbOut,
                                   cbRead );

            Status = pReply->GetStatus();
        }
        CATCH( CException, e )
        {
            Status = e.GetErrorCode();
        }
        END_CATCH;
    } while ( ( Status == STATUS_BUFFER_TOO_SMALL ) &&
              ( cbOut++ < cbMaxProxyBuffer ) );

    prxDebugOut(( DEB_ITRACE, "Status at end of getrows: 0x%x\n", Status ));
    Win4Assert( pReply == (CPMGetRowsOut *) xOut.GetPointer() );

    SCODE scResult = 0;

    if ( NT_SUCCESS( Status ) )
    {
        rGetRowsParams.SetRowsTransferred( pReply->RowsReturned() );

        CMemDeSerStream stmDeser( pReply->GetSeekDesc(), cbReserved );
        UnmarshallRowSeekDescription( stmDeser,
                                      _client.GetServerVersion(),
                                      pSeekDescOut,
                                      TRUE );

        // Hand off the block to the allocator made in CRowset

        Win4Assert( pReply == (CPMGetRowsOut *) xOut.GetPointer() );
        PFixedVarAllocator & rAlloc = rGetRowsParams.GetFixedVarAllocator();
        rAlloc.ReInit( TRUE, cbReserved, xOut.Acquire(), cbOut );

        // we have pointers already, not offsets

        rAlloc.SetBase( 0 );

        scResult = Status;  // ok, endOfRowset, blockLimitedRows, etc.
    }
    else
    {
        if ( DB_E_BADRATIO != Status && DB_E_BADSTARTPOSITION != Status) {
            prxDebugOut(( DEB_ERROR, "GetRows returned 0x%x\n", Status ));
        }

        if ( NT_WARNING( Status ) )
            scResult = Status;      // presumably, status is an SCODE
        else
            scResult = E_FAIL;
    }

    return scResult;
} //GetRows

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::ReExecuteSequentialQuery, private
//
//  Synopsis:   Simulates re-execution of a sequential query by shutting down
//              the query object on the server, recreating it and setting up
//              the bindings from cached values
//
//  Arguments:
//
//  History:    02-28-98    danleg      Created
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::ReExecuteSequentialQuery()
{
    tbDebugOut(( DEB_PROXY, "ReExecuteSequentialQuery\n" ));

    // SPECDEVIATION: if we have heirarchical rowsets, all current positions
    // will be reset.

    //
    // Shutdown the existing PQuery on the server first
    //

    for ( unsigned i=0; i<_aCursors.Count(); i++ )
        FreeCursor( _aCursors[i] );

    //
    // Recreate PQuery on the server
    //

    CPMCreateQueryIn * pCreateReq =  (CPMCreateQueryIn *) _xQuery.Get();

    const unsigned cbCursors = sizeof ULONG * _aCursors.Count();
    const unsigned cbReply = sizeof CPMCreateQueryOut + cbCursors;

    XGrowable<BYTE, 200> xReply( cbReply );
    CPMCreateQueryOut * pReply = new( xReply.Get() ) CPMCreateQueryOut();

    ULONG cbRead;
    _client.DataWriteRead( pCreateReq,
                           _xQuery.SizeOf(),
                           pReply,
                           cbReply,
                           cbRead );

    // DataWriteRead throws both connection problems and request problems

    Win4Assert( SUCCEEDED( pReply->GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || cbReply == cbRead );

    _fTrueSequential = pReply->IsTrueSequential();
    _fWorkIdUnique = pReply->IsWorkIdUnique();
    _ulServerCookie = pReply->GetServerCookie();

    RtlCopyMemory( _aCursors.Get(), pReply->GetCursors(), cbCursors );

    //
    // Recreate bindings
    //

    CProxyMessage reply;
    CPMSetBindingsIn *pBindReq = (CPMSetBindingsIn *) _xBindings.Get();

    ULONG cbRequest = sizeof CPMSetBindingsIn + pBindReq->GetBindingDescLength();
    cbRequest = AlignBlock( cbRequest, sizeof ULONG );

    _client.DataWriteRead( pBindReq,
                           cbRequest,
                           &reply,
                           sizeof reply,
                           cbRead );

    Win4Assert( SUCCEEDED( reply.GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );

} // ReExecuteSequentialQuery

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::RestartPosition, public
//
//  Synopsis:   Reset the fetch position for the chapter back to the start
//
//  Arguments:  [hCursor]       - handle of the cursor
//              [chapt]         - chapter
//
//  History:    17 Apr 97   emilyb      created
//              02-01-98    danleg      restart for seq queries
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::RestartPosition(
    ULONG        hCursor,
    CI_TBL_CHAPT chapt )
{
    tbDebugOut(( DEB_PROXY, "RestartPosition\n" ));

    //
    // If sequential, re-execute the query
    //
    if ( _fTrueSequential )
        ReExecuteSequentialQuery();
    else
    {
        CPMRestartPositionIn request( hCursor, chapt );
        CProxyMessage reply;
        DWORD cbRead;
        _client.DataWriteRead( &request,
                               sizeof request,
                               &reply,
                               sizeof reply,
                               cbRead );

        Win4Assert( SUCCEEDED( reply.GetStatus() ) );
        Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );
    }
} //RestartPosition

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::StopAsync, public
//
//  Synopsis:   Stop processing of async rowset
//
//  Arguments:  [hCursor]       - handle of the cursor
//
//  History:    17 Apr 97  emilyb   created
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::StopAsynch(
    ULONG        hCursor )
{
    tbDebugOut(( DEB_PROXY, "Stop\n" ));

    CPMStopAsynchIn request( hCursor );
    CProxyMessage reply;
    DWORD cbRead;
    _client.DataWriteRead( &request,
                           sizeof request,
                           &reply,
                           sizeof reply,
                           cbRead );

    Win4Assert( SUCCEEDED( reply.GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );
} //StopAsynch

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::StartWatching, public
//
//  Synopsis:   Start watch all behavior for rowset
//
//  Arguments:  [hCursor]       - handle of the cursor
//
//  History:    17 Apr 97  emilyb   created
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::StartWatching(
    ULONG        hCursor )
{
    tbDebugOut(( DEB_PROXY, "StartWatching\n" ));

    CPMStartWatchingIn request( hCursor );
    CProxyMessage reply;
    DWORD cbRead;
    _client.DataWriteRead( &request,
                           sizeof request,
                           &reply,
                           sizeof reply,
                           cbRead );

    Win4Assert( SUCCEEDED( reply.GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );
} //StartWatching

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::StopWatching, public
//
//  Synopsis:   Stop watch all behavior for rowset
//
//  Arguments:  [hCursor]       - handle of the cursor
//
//  History:    17 Apr 97  emilyb   created
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::StopWatching(
    ULONG        hCursor )
{
    tbDebugOut(( DEB_PROXY, "StopWatching\n" ));

    CPMStopWatchingIn request( hCursor );
    CProxyMessage reply;
    DWORD cbRead;
    _client.DataWriteRead( &request,
                           sizeof request,
                           &reply,
                           sizeof reply,
                           cbRead );

    Win4Assert( SUCCEEDED( reply.GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );
} //StopWatching

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::RatioFinished, public
//
//  Synopsis:   Return the completion status as a fraction
//
//  Arguments:  [hCursor]        - handle of the cursor to check
//              [rulDenominator] - on return, denominator of fraction
//              [rulNumerator]   - on return, numerator of fraction
//              [rcRows]         - on return, number of rows in cursor
//              [rfNewRows]      - on return, TRUE if new rows available
//
//  History:    13 Sept 96  dlee created
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::RatioFinished(
    ULONG   hCursor,
    DBCOUNTITEM & rulDenominator,
    DBCOUNTITEM & rulNumerator,
    DBCOUNTITEM & rcRows,
    BOOL &  rfNewRows )
{
    tbDebugOut(( DEB_PROXY, "RatioFinished\n" ));
    SCODE sc = S_OK;

    CPMRatioFinishedIn request( hCursor, TRUE );
    CPMRatioFinishedOut reply;
    DWORD cbReply;
    _client.DataWriteRead( &request,
                           sizeof request,
                           &reply,
                           sizeof reply,
                           cbReply );

    Win4Assert( SUCCEEDED( reply.GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbReply );

    rulDenominator = reply.Denominator();
    rulNumerator = reply.Numerator();
    rcRows = reply.RowCount();
    rfNewRows = reply.NewRows();

    // the values must be good by now or we would have thrown

    Win4Assert( 0 != rulDenominator );
    Win4Assert( rulDenominator >= rulNumerator );
} //RatioFinished

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::RatioFinished, public
//
//  Synopsis:   Return the completion status as a fraction
//
//  Arguments:  [rSync]          - notification synchronization info
//              [hCursor]        - handle of the cursor to check
//              [rulDenominator] - on return, denominator of fraction
//              [rulNumerator]   - on return, numerator of fraction
//              [rcRows]         - on return, number of rows in cursor
//              [rfNewRows]      - on return, TRUE if new rows available
//
//  Returns:    S_OK or STATUS_CANCELLED if rSync's cancel event signalled.
//
//  History:    13 Sept 96  dlee created
//
//--------------------------------------------------------------------------

SCODE CSvcQueryProxy::RatioFinished(
    CNotificationSync & rSync,
    ULONG   hCursor,
    DBCOUNTITEM & rulDenominator,
    DBCOUNTITEM & rulNumerator,
    DBCOUNTITEM & rcRows,
    BOOL &  rfNewRows )
{
    tbDebugOut(( DEB_PROXY, "RatioFinished\n" ));
    SCODE sc = S_OK;

    CPMRatioFinishedIn request( hCursor, TRUE );
    CPMRatioFinishedOut reply;
    DWORD cbReply;
    if ( _client.NotifyWriteRead( rSync.GetCancelEvent(),
                                  &request,
                                  sizeof request,
                                  &reply,
                                  sizeof reply,
                                  cbReply ) )
        sc = STATUS_CANCELLED;
    else
    {
        Win4Assert( SUCCEEDED( reply.GetStatus() ) );
        Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbReply );

        rulDenominator = reply.Denominator();
        rulNumerator = reply.Numerator();
        rcRows = reply.RowCount();
        rfNewRows = reply.NewRows();

        // the values must be good by now or we would have thrown

        Win4Assert( 0 != rulDenominator );
        Win4Assert( rulDenominator >= rulNumerator );
    }
    return sc;
} //RatioFinished (notify version)

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::Compare, public
//
//  Synopsis:   Return the approximate current position as a fraction
//
//  Arguments:  [hCursor]       - handle of the cursor used to compare
//              [chapt]         - chapter of bookmarks
//              [bmkFirst]      - First bookmark to compare
//              [bmkSecond]     - Second bookmark to compare
//              [rdwComparison] - on return, comparison value
//
//  History:    13 Sept 96  dlee created
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::Compare(
    ULONG        hCursor,
    CI_TBL_CHAPT chapt,
    CI_TBL_BMK   bmkFirst,
    CI_TBL_BMK   bmkSecond,
    DWORD &      rdwComparison )
{
    tbDebugOut(( DEB_PROXY, "Compare\n" ));

    CPMCompareBmkIn request( hCursor, chapt, bmkFirst, bmkSecond );
    CPMCompareBmkOut reply;

    DWORD cbRead;
    _client.DataWriteRead( &request,
                           sizeof request,
                           &reply,
                           sizeof reply,
                           cbRead );

    Win4Assert( SUCCEEDED( reply.GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );

    rdwComparison = reply.Comparison();
} //Compare

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::GetApproximatePosition, public
//
//  Synopsis:   Return the approximate current position as a fraction
//
//  Arguments:  [hCursor]        - cursor handle used to retrieve info
//              [chapt]          - chapter requested
//              [bmk]            - table bookmark for position
//              [pulNumerator]   - on return, numerator of fraction
//              [pulDenominator] - on return, denominator of fraction
//
//  History:    13 Sept 96  dlee created
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::GetApproximatePosition(
    ULONG        hCursor,
    CI_TBL_CHAPT chapt,
    CI_TBL_BMK   bmk,
    DBCOUNTITEM * pulNumerator,
    DBCOUNTITEM * pulDenominator )
{
    tbDebugOut(( DEB_PROXY, "GAP\n" ));

    CPMGetApproximatePositionIn request( hCursor, chapt, bmk );
    CPMGetApproximatePositionOut reply;

    DWORD cbRead;
    _client.DataWriteRead( &request,
                           sizeof request,
                           &reply,
                           sizeof reply,
                           cbRead );

    Win4Assert( SUCCEEDED( reply.GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );

    *pulNumerator = reply.Numerator();
    *pulDenominator = reply.Denominator();
} //GetApproximatePosition

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::SetBindings, public
//
//  Synopsis:   Set column bindings into a cursor
//
//  Arguments:  [hCursor]     - handle of the cursor to set bindings on
//              [cbRowLength] - the width of an output row
//              [cols]        - a description of column bindings to be set
//              [pids]        - a PID mapper which maps fake pids in cols to
//                              column IDs.
//
//  History:    13 Sept 96  dlee created
//              22 Aug 99   klam Win64 client -> Win32 server
//              09 Feb 2000 KLam Win64: Reset variant size when done
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::SetBindings(
    ULONG             hCursor,
    ULONG             cbRowLength,
    CTableColumnSet & cols,
    CPidMapper &      pids )
{
    tbDebugOut(( DEB_PROXY, "SetBindings\n" ));

#ifdef _WIN64

    // WIN64 client and servers mark the low bit of the hi-word of the
    // version to indicate it is a 64 bit machine.

    if ( !_client.IsServer64() )
    {
        tbDebugOut(( DEB_PROXY, "64bit client querying 32bit server!\n" ));

        // If there is a PROPVARIANT stored, adjust its size
      
        for (unsigned i = 0; i < cols.Count(); i++)
        {
            CTableColumn *pColumn = cols.Get(i);
            tbDebugOut(( DEB_PROXY, "\tFound type: %d width: %d\n",pColumn->GetStoredType(), pColumn->GetValueSize())); 
            if ( VT_VARIANT == pColumn->GetStoredType() )
            {
                pColumn->SetValueField( VT_VARIANT,
                                        pColumn->GetValueOffset(),
                                        SizeOfWin32PROPVARIANT );

                tbDebugOut(( DEB_PROXY, "\tReplacing variant with size %d and offset 0x%x \n", 
                             SizeOfWin32PROPVARIANT, pColumn->GetValueOffset() ));
            }
        }
    }

#endif

    // determine the size of the serialized column set

    CSizeSerStream stmSize;
    cols.Marshall( stmSize, pids );
    ULONG cbRequest = sizeof CPMSetBindingsIn + stmSize.Size();
    cbRequest = AlignBlock( cbRequest, sizeof ULONG );

    XArray<BYTE> xIn( cbRequest );
    CPMSetBindingsIn *pRequest = new( xIn.Get() )
                                 CPMSetBindingsIn( hCursor,
                                                   cbRowLength,
                                                   stmSize.Size() );

    // serialize the column set

    CMemSerStream stmMem( pRequest->GetDescription(), stmSize.Size() );
    cols.Marshall( stmMem, pids );

    pRequest->SetCheckSum( cbRequest );

    CProxyMessage reply;
    DWORD cbRead;

    _client.DataWriteRead( pRequest,
                           cbRequest,
                           &reply,
                           sizeof reply,
                           cbRead );

    Win4Assert( SUCCEEDED( reply.GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );

#ifdef _WIN64

    if ( !IsCi64(_client.GetServerVersion()) )
    {
        tbDebugOut(( DEB_PROXY, "...64bit client finished querying 32bit server.\n" ));

        //
        // If there is a PROPVARIANT stored, readjust its size back to its original size
        //
        for (unsigned i = 0; i < cols.Count(); i++)
        {
            CTableColumn *pColumn = cols.Get(i);
            tbDebugOut(( DEB_PROXY, "\tFound type: %d width: %d\n",pColumn->GetStoredType(), pColumn->GetValueSize())); 
            if ( VT_VARIANT == pColumn->GetStoredType() )
            {
                pColumn->SetValueField( VT_VARIANT,
                                        pColumn->GetValueOffset(),
                                        sizeof ( PROPVARIANT ) );

                tbDebugOut(( DEB_PROXY, "\tReseting variant with size %d and offset 0x%x \n", 
                             sizeof ( PROPVARIANT ), pColumn->GetValueOffset() ));
            }
        }
    }

#endif

    //
    // Preserve binding stream if sequential for RestartPosition
    //
    if ( _fTrueSequential )
    {
        unsigned cElems = xIn.Count();
        _xBindings.Set( cElems, xIn.Acquire() );
    }

} //SetBindings

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::GetNotifications, public
//
//  Synopsis:   Gets notification information, when available.
//
//  Arguments:  [rSync]      -- notification synchronization info
//              [changeType] -- returns notification data info
//
//  Returns:    S_OK or STATUS_CANCELLED if rSync's cancel event signalled.
//
//  History:    13 Sept 96  dlee created
//
//--------------------------------------------------------------------------

SCODE CSvcQueryProxy::GetNotifications(
    CNotificationSync & rSync,
    DBWATCHNOTIFY     & changeType)
{
    tbDebugOut(( DEB_PROXY, "GetNotifications\n" ));
    SCODE sc = S_OK;

    CProxyMessage request( pmGetNotify );
    CPMSendNotifyOut reply(0);
    DWORD cbReply;

    if ( _client.NotifyWriteRead( rSync.GetCancelEvent(),
                                  &request,
                                  sizeof request,
                                  &reply,
                                  sizeof reply,
                                  cbReply ) )
        sc = STATUS_CANCELLED;
    else
        changeType = reply.WatchNotify();

    tbDebugOut(( DEB_PROXY, "GetNotifications %d, sc %lx\n", changeType, sc ));
    return sc;
} //GetNotifications

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::SetWatchMode
//
//  Synopsis:   Stub implementation
//
//  Arguments:  [phRegion] - in/out region handle
//              [mode]     - watch mode
//
//  History:    13 Sept 96  dlee created
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::SetWatchMode(
    HWATCHREGION * phRegion,
    ULONG          mode )
{
    tbDebugOut (( DEB_PROXY, "Calling SetWatchMode\n" ));

    CPMSetWatchModeIn request( *phRegion, mode );
    CPMSetWatchModeOut reply;
    DWORD cbRead;

    _client.DataWriteRead( &request,
                           sizeof request,
                           &reply,
                           sizeof reply,
                           cbRead );

    Win4Assert( SUCCEEDED( reply.GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );

    *phRegion = reply.Region();
} //SetWatchMode

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::GetWatchInfo
//
//  Synopsis:   Stub implementation
//
//  Arguments:  [hRegion]   -- handle to watch region
//              [pMode]     -- watch mode
//              [pChapter]  -- chapter
//              [pBookmark] -- bookmark
//              [pcRows]    -- number of rows
//
//  History:    13 Sept 96  dlee created
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::GetWatchInfo (
    HWATCHREGION   hRegion,
    ULONG *        pMode,
    CI_TBL_CHAPT * pChapter,
    CI_TBL_BMK *   pBookmark,
    DBCOUNTITEM *  pcRows)
{
    tbDebugOut (( DEB_PROXY, "Calling GetWatchInfo\n" ));

    // prepare for failure

    *pBookmark = 0;
    *pChapter = 0;
    *pMode = 0;
    *pcRows = 0;

    CPMGetWatchInfoIn request( hRegion );
    CPMGetWatchInfoOut reply;
    DWORD cbRead;

    _client.DataWriteRead( &request,
                           sizeof request,
                           &reply,
                           sizeof reply,
                           cbRead );

    Win4Assert( SUCCEEDED( reply.GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );

    *pMode = reply.Mode();
    *pChapter = reply.Chapter();
    *pBookmark = reply.Bookmark();
    *pcRows = reply.RowCount();
} //GetWatchInfo

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::ShrinkWatchRegion
//
//  Synopsis:   Stub implementation
//
//  Arguments:  [hRegion]  -- handle to watch region
//              [chapter]  -- chapter
//              [bookmark] -- size of bookmark
//              [cRows]    -- number of rows
//
//  History:    13 Sept 96  dlee created
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::ShrinkWatchRegion (
    HWATCHREGION hRegion,
    CI_TBL_CHAPT chapter,
    CI_TBL_BMK   bookmark,
    LONG         cRows )
{
    tbDebugOut (( DEB_PROXY, " Calling ShrinkWatchRegion\n" ));

    CPMShrinkWatchRegionIn request( hRegion, chapter, bookmark, cRows );
    CProxyMessage reply;
    DWORD cbRead;

    _client.DataWriteRead( &request,
                           sizeof request,
                           &reply,
                           sizeof reply,
                           cbRead );

    Win4Assert( SUCCEEDED( reply.GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );
} //ShrinkWatchRegion

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::Refresh
//
//  Synopsis:   Stub implementation
//
//  History:    13 Sept 96  dlee created
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::Refresh()
{
    tbDebugOut(( DEB_PROXY, "Refresh\n" ));

    CProxyMessage request( pmRefresh );
    CProxyMessage reply;
    DWORD cbRead;

    _client.DataWriteRead( &request,
                           sizeof request,
                           &reply,
                           sizeof reply,
                           cbRead );

    Win4Assert( SUCCEEDED( reply.GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );
    tbDebugOut(( DEB_PROXY, "Refresh (end)\n" ));
} //Refresh

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::GetQueryStatus, public
//
//  Synopsis:   Return the query status
//
//  Arguments:  [hCursor]   - handle of the cursor to check
//              [rdwStatus] - on return, the query status
//
//  History:    13 Sept 96  dlee created
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::GetQueryStatus(
    ULONG   hCursor,
    DWORD & rdwStatus )
{
    tbDebugOut(( DEB_PROXY, "GetQueryStatus\n" ));

    CPMGetQueryStatusIn request( hCursor );
    CPMGetQueryStatusOut reply;
    DWORD cbRead;

    _client.DataWriteRead( &request,
                           sizeof request,
                           &reply,
                           sizeof reply,
                           cbRead );

    Win4Assert( SUCCEEDED( reply.GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );

    rdwStatus = reply.QueryStatus();
} //GetQueryStatus

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::GetQueryStatusEx, public
//
//  Synopsis:   Return the query status plus bonus information.  It's kind
//              of an odd assortment of info, but it saves net trips.
//
//  Arguments:  [hCursor] - handle of the cursor to check completion for
//              [rdwStatus] - returns the query status
//              [rcFilteredDocuments] - returns # of filtered docs
//              [rcDocumentsToFilter] - returns # of docs to filter
//              [rdwRatioFinishedDenominator] - ratio finished denom
//              [rdwRatioFinishedNumerator]   - ratio finished num
//              [bmk]                         - bmk to find
//              [riRowBmk]                    - index of bmk row
//              [rcRowsTotal]                 - # of rows in table
//
//  History:    Nov-9-96   dlee    Created
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::GetQueryStatusEx(
    ULONG            hCursor,
    DWORD &          rdwStatus,
    DWORD &          rcFilteredDocuments,
    DWORD &          rcDocumentsToFilter,
    DBCOUNTITEM &    rdwRatioFinishedDenominator,
    DBCOUNTITEM &    rdwRatioFinishedNumerator,
    CI_TBL_BMK       bmk,
    DBCOUNTITEM &    riRowBmk,
    DBCOUNTITEM &    rcRowsTotal )
{
    tbDebugOut(( DEB_PROXY, "GetQueryStatusEx\n" ));

    CPMGetQueryStatusExIn request( hCursor, bmk );
    CPMGetQueryStatusExOut reply;
    DWORD cbRead;

    _client.DataWriteRead( &request,
                           sizeof request,
                           &reply,
                           sizeof reply,
                           cbRead );

    Win4Assert( SUCCEEDED( reply.GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );

    rdwStatus = reply.QueryStatus();
    rcFilteredDocuments = reply.FilteredDocuments();
    rcDocumentsToFilter = reply.DocumentsToFilter();
    rdwRatioFinishedDenominator = reply.RatioFinishedDenominator();
    rdwRatioFinishedNumerator = reply.RatioFinishedNumerator();
    riRowBmk = reply.RowBmk();
    rcRowsTotal = reply.RowsTotal();
} //GetQueryStatusEx

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::FetchDeferredValue, public
//
//  Synopsis:   Returns a property value for a workid from the property cache
//
//  Arguments:  [wid] - workid for which property value is retrieved
//              [ps]] - prop spec identifying value to be retrieved
//              [var] - returns the value if available
//
//  Returns:    TRUE if a value was retrieved or FALSE otherwise
//
//  History:    30 Sept 96  dlee created
//
//--------------------------------------------------------------------------

BOOL CSvcQueryProxy::FetchDeferredValue(
    WORKID                wid,
    CFullPropSpec const & ps,
    PROPVARIANT &         var )
{
    tbDebugOut(( DEB_PROXY, "FetchValue\n" ));
    CLock lock( _mutexFetchValue );

    XArray<BYTE> xValue;
    XArray<BYTE> xResult( cbMaxProxyBuffer );

    // cbChunk is the size of the output buffer including CPMFetchValueOut

    const DWORD cbChunk = cbMaxProxyBuffer;

    // Since the value might be large and each proxy buffer is limited to
    // cbMaxProxyBuffer, iterate until the entire value is retrieved.

    do
    {
        // only send the propspec once

        DWORD cbPropSpec = 0;
        if ( 0 == xValue.SizeOf() )
        {
            CSizeSerStream stmSize;
            ps.Marshall( stmSize );
            cbPropSpec = stmSize.Size();
        }

        ULONG cbRequest = AlignBlock( sizeof CPMFetchValueIn + cbPropSpec,
                                      sizeof ULONG );
        XArray<BYTE> xRequest( cbRequest );
        CPMFetchValueIn *pRequest = new( xRequest.Get() )
            CPMFetchValueIn( wid, xValue.SizeOf(), cbPropSpec, cbChunk );

        if ( 0 == xValue.SizeOf() )
        {
            CMemSerStream stmMem( pRequest->GetPS(), cbPropSpec );
            ps.Marshall( stmMem );
        }

        pRequest->SetCheckSum( xRequest.SizeOf() );

        DWORD cbReply;
        _client.DataWriteRead( pRequest,
                               xRequest.SizeOf(),
                               xResult.Get(),
                               xResult.SizeOf(),
                               cbReply );
        CPMFetchValueOut &result = * (CPMFetchValueOut *) xResult.Get();

        if ( !result.ValueExists() )
            return FALSE;

        // append the next portion of the value

        DWORD cbOld = xValue.SizeOf();
        Win4Assert( 0 != result.ValueSize() );
        xValue.ReSize( cbOld + result.ValueSize() );
        RtlCopyMemory( xValue.Get() + cbOld,
                       result.Value(),
                       result.ValueSize() );

        // all done?

        if ( !result.MoreExists() )
            break;
    } while ( TRUE );

    CCoTaskMemAllocator tbaAlloc;

    StgConvertPropertyToVariant( (SERIALIZEDPROPERTYVALUE *) xValue.Get(),
                                 CP_WINUNICODE,
                                 &var,
                                 &tbaAlloc );
    Win4Assert( (var.vt & 0x0fff) <= VT_CLSID );

    return TRUE;
} //FetchValue

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::WorkIdToPath, public
//
//  Synopsis:   Converts a wid to a path
//
//  Arguments:  [wid]       -- wid to convert
//              [funnyPath] -- resulting path
//
//  History:    30 Sept 96  dlee created
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::WorkIdToPath(
    WORKID          wid,
    CFunnyPath & funnyPath )
{
    tbDebugOut(( DEB_PROXY, "WorkIdToPath\n" ));

    CPMWorkIdToPathIn request( wid );
    XArray<WCHAR> xReply( cbMaxProxyBuffer );
    CPMWorkIdToPathOut &reply = * (CPMWorkIdToPathOut *) xReply.Get();

    DWORD cbRead;
    _client.DataWriteRead( &request,
                           sizeof request,
                           &reply,
                           cbMaxProxyBuffer,
                           cbRead );
    Win4Assert( SUCCEEDED( reply.GetStatus() ) );

    if ( reply.Any() )
    {
        funnyPath.SetPath( reply.Path() );
    }
} //WorkIdToPath
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\segmru.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       segmru.cxx
//
//  Contents:   Most Recently Used segments management.
//
//  Classes:    CMRUSegments
//
//  History:    4-11-95   srikants   Created
//
//
//  Notes  :    All methods in this are assumed to be under a larger
//              lock (like the bigtable lock).
//
//----------------------------------------------------------------------------



#include "pch.cxx"
#pragma hdrstop

#include <segmru.hxx>
#include <tableseg.hxx>


//+---------------------------------------------------------------------------
//
//  Function:   CMRUSegments
//
//  Synopsis:   Destructor for the most recently used segments list.
//
//  History:    4-11-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CMRUSegments::~CMRUSegments()
{
    for ( CWidSegmentMap * pEntry = _list.RemoveLast();
          0 != pEntry;
          pEntry = _list.RemoveLast() )
    {
        delete pEntry;    
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   IsSegmentInUse
//
//  Synopsis:   Tests if the given segment is currently in use or not.
//
//  Arguments:  [pSegment] - Segment to test.
//
//  Returns:    TRUE if the segment is in use. FALSE o/w
//
//  History:    4-11-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

BOOL CMRUSegments::IsSegmentInUse( CTableSegment * pSegment )
{
    Win4Assert( 0 != pSegment );

    for ( CFwdWidSegMapIter iter(_list); !_list.AtEnd(iter);
          _list.Advance(iter) )
    {
        if ( iter->GetWorkId() != widInvalid )
        {
            if ( iter->GetSegment() == pSegment ||
                 pSegment->IsRowInSegment( iter->GetWorkId()) )
            {
                return TRUE;    
            }
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   AddReplace
//
//  Synopsis:   Add/Replaces the wid/segment mapping entry in the MRU list.
//
//  Arguments:  [wid]  - Workid of the new entry
//              [pSeg] - Pointer to the segment in which the wid is present.
//                       If it is set to NULL, it just means that the wid
//                       is going to be used but we don't know in which segment
//                       it is present (during Bucket->Window conversion)
//
//  History:    4-11-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CMRUSegments::AddReplace( WORKID wid, CTableSegment * pSeg )
{
    Win4Assert( widInvalid != wid );

    //
    // Determine if the workid already exists in the list of MRU wids.
    // If so, just move it to the top of the list.
    //
    for ( CFwdWidSegMapIter iter(_list); !_list.AtEnd(iter);
          _list.Advance(iter) )
    {
        if ( wid == iter->GetWorkId() )
        {
            CWidSegmentMap * pCurrent = iter.GetEntry();
            _list.MoveToFront( pCurrent );
            pCurrent->Set( pSeg );
            return;
        }
    }

    //
    // We either need to remove an entry from the end or create a new one
    // and add
    //
    CWidSegmentMap * pEntry = 0;
    if ( _list.Count() < _nMaxEntries )
    {
        pEntry = new CWidSegmentMap( wid, pSeg );
    }
    else
    {
        //
        // Remove the last entry from the list and re-use it for
        // the new entry.
        //
        pEntry = _list.RemoveLast();
    }

    Win4Assert( 0 != pEntry );

    pEntry->Set( wid, pSeg );
    _list.Push(pEntry);

    return;
    
}

//+---------------------------------------------------------------------------
//
//  Function:   Invalidate
//
//  Synopsis:   Invalidate all cached pointers that are same as the given
//              one.
//
//  Arguments:  [pSegment] - The segment that is going to be invalid.
//
//  History:    4-11-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CMRUSegments::Invalidate( const CTableSegment * const pSegment )
{
    Win4Assert( 0 != pSegment );

    for ( CFwdWidSegMapIter iter(_list); !_list.AtEnd(iter);
          _list.Advance(iter) )
    {
        if ( iter->GetSegment() == pSegment )
        {
            iter->Set(0);    
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Remove
//
//  Synopsis:   
//
//  Arguments:  [wid] - 
//
//  Returns:    
//
//  Modifies:   
//
//  History:    5-30-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CMRUSegments::Remove( WORKID wid )
{
    Win4Assert( widInvalid != wid );

    //
    // Determine if the workid already exists in the list of MRU wids.
    // If so, just move it to the top of the list.
    //
    CFwdWidSegMapIter iter(_list);
    while ( !_list.AtEnd(iter) )
    {
        CWidSegmentMap * pCurrent = iter.GetEntry();
        //
        // Because we may destroy the current node, we must skip ahead
        // before destorying it.
        //
        _list.Advance(iter);

        if ( wid == pCurrent->GetWorkId() )
        {
            _list.RemoveFromList( pCurrent );
            delete pCurrent;
        }
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\strhash.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       strhash.cxx
//
//  Contents:   Hash table compressions of strings for large tables.
//
//  Classes:    CCompressedColHashString
//
//  Functions:
//
//  History:    03 May 1994     AlanW    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <tblvarnt.hxx>

#include "strhash.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   HashWSTR
//
//  Synopsis:   Hashes a WSTR and returns a value according to the format
//              explained in the HashString call.
//
//  Arguments:  [pwszStr] -  Pointer to the string.
//              [nChar]   -  Number of characters in the string.
//
//  Returns:    A HashValue (formatted according to notes in HashString)
//
//  History:    5-19-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
inline
ULONG CCompressedColHashString::HashWSTR( WCHAR const * pwszStr,
                                          USHORT nChar )
{
    ULONG ulRet = 0;

    for ( ULONG i = 0; i < nChar ; i++)
    {
        WCHAR wch = pwszStr[i];
        ulRet = (ulRet << 1) ^ wch;
    }

    ulRet = (ulRet >> 16) ^ ulRet;
    ulRet = (ulRet & 0xFFFF) | (i << 17);
    return ulRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   HashSTR
//
//  Synopsis:   Hashes an ASCII string.
//
//  Arguments:  [pszStr] -
//              [nChar]  -
//
//  Returns:    (Same as HashWSTR)
//
//  History:    5-19-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
inline
ULONG CCompressedColHashString::HashSTR( CHAR const * pszStr, USHORT nChar )
{
    ULONG ulRet = 0;

    for ( ULONG i = 0; i < nChar ; i++)
    {
        BYTE ch = (BYTE) pszStr[i];
        ulRet = (ulRet << 1) ^ ch;
    }

    ulRet = (ulRet >> 16) ^ ulRet;
    ulRet = (ulRet & 0xFFFF) | (i << 17) | (1 << 16);  // is an ascii string
    return ulRet;
}

//const ULONG CCompressedColHashString::_cbDataWidth = sizeof (HashEntry);

//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHashString::HashString, public static
//
//  Synopsis:   Generic hash function for strings
//
//  Arguments:  [pbData] - pointer to the value to be hashed.
//              [cbData] - size of pbData (may be some arbitrary large
//                      value if string is NUL terminated.
//              [vtDataType] - type of string, VT_LPWSTR, or VT__LPSTR
//              [fNullTerminated ] - Set to TRUE if the string is a NULL
//              terminted string. FALSE o/w.
//
//  Returns:    ULONG - Hash value for the input data
//
//  Notes:      The returned hash value encodes the string length in
//              characters and string format in the upper half of the
//              returned DWORD.  The format of the returned value is:
//
//              +15                                           00+
//              +-----------------------------------------------+
//              |      hash value (xor,shift of char values)    |
//              +--------------------------------------------+--+
//              |      character count                       | F|
//              +--------------------------------------------+--+
//               31                                        17+16+
//
//              where F = 0 if Unicode string, F = 1 if ASCII string
//
//              As a side-effect, the string is copied to local storage,
//              and a key to that storage is returned in rulCopyKey.
//
//--------------------------------------------------------------------------

ULONG CCompressedColHashString::HashString(
    BYTE *pbData,
    USHORT cbData,
    VARTYPE vtDataType,
    BOOL   fNullTerminated
)
{

    ULONG ulRet = 0;

    switch (vtDataType)
    {

    case VT_LPWSTR:


        {
            UNICODE_STRING ustr;

            if ( fNullTerminated )
            {
                RtlInitUnicodeString(&ustr, (PWSTR)pbData);
            }
            else
            {
                Win4Assert( ( cbData & (USHORT) 0x1 ) == 0 );    // must be an even number
                ustr.Buffer = (PWSTR) pbData;
                ustr.MaximumLength = ustr.Length = cbData;
            }

            ulRet = HashWSTR( ustr.Buffer, ustr.Length/sizeof(WCHAR) );
        }

        break;

    case VT_LPSTR:

        {
            ANSI_STRING astr;

            if ( fNullTerminated )
            {
                RtlInitAnsiString(&astr, (PSZ)pbData);
            }
            else
            {
                astr.Buffer = (CHAR *) pbData;
                astr.MaximumLength = astr.Length = cbData;
            }

            ulRet = HashSTR( astr.Buffer, astr.Length );
        }

        break;

    default:    // PERFFIX - need to support VT_BSTR also?
        Win4Assert(!"CCompressedColHashString::HashString called with bad type");
        THROW( CException( STATUS_INVALID_PARAMETER ) );
    }

    return ulRet;
}

//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHashString::AddData, public
//
//  Synopsis:   Add a data entry to the hash table if it is not
//              already there.
//
//  Arguments:  [pVarnt] - pointer to data item
//              [pKey] - pointer to lookup key value
//              [reIndicator] - returns an indicator variable for
//                      problems
//
//  Returns:    pKey is filled in with the index of the data item in
//              the data array.  reIndicator is filled with an indication
//              of problems.
//
//  Notes:
//
//--------------------------------------------------------------------------

VOID    CCompressedColHashString::AddData(
    PROPVARIANT const * const pVarnt,
    ULONG* pKey,
    GetValueResult& reIndicator
)
{
    //
    //  Specially handle the VT_EMPTY case
    //
    if (pVarnt->vt == VT_EMPTY) {
        *pKey = 0;
        reIndicator = GVRSuccess;
        return;
    }

    CTableVariant *pVar = (CTableVariant *)pVarnt;
    Win4Assert((pVar->vt == VT_LPWSTR || pVar->vt == VT_LPSTR) &&
             pVar->VariantPointerInFirstWord( ));

    BYTE *pbData ;
    USHORT cbData = (USHORT) pVar->VarDataSize();
    pbData = (BYTE *) pVar->pwszVal;

    Win4Assert(cbData != 0 && pbData != NULL);

    _AddData( pbData, cbData, pVar->vt, pKey, TRUE );  // NULL Terminated
    reIndicator = GVRSuccess;
    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindCountedWStr
//
//  Synopsis:   Findss the given string to the string store. It is assumed
//              that there is no terminating NULL in the string. Instead,
//              its length is passed.
//
//  Arguments:  [pwszStr]     - Pointer to the string to be added.
//              [cwcStr]      - Count of the characters in the string.
//
//  Returns:    ULONG key or stridInvalid
//
//  History:    7-17-95   dlee   Created
//
//----------------------------------------------------------------------------

ULONG CCompressedColHashString::FindCountedWStr(
    WCHAR const *pwszStr,
    ULONG cwcStr )
{
    Win4Assert( !_fOptimizeAscii );

    BYTE *pbData = (BYTE *) pwszStr ;
    USHORT cbData = (USHORT) cwcStr * sizeof(WCHAR);

    Win4Assert(cbData != 0 && pbData != NULL);

    return _FindData( pbData, cbData, VT_LPWSTR, FALSE );
} //FindCountedWStr

//+---------------------------------------------------------------------------
//
//  Function:   AddCountedWStr
//
//  Synopsis:   Adds the given string to the string store. It is assumed
//              that there is no terminating NULL in the string. Instead,
//              its length is passed.
//
//  Arguments:  [pwszStr]     - Pointer to the string to be added.
//              [cwcStr]      - Count of the characters in the string.
//              [key]         - OUTPUT - Id of the string
//              [reIndicator] - GVRSuccess if successful. Failure code o/w
//
//  History:    5-19-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID CCompressedColHashString::AddCountedWStr(
    WCHAR const *pwszStr,
    ULONG cwcStr,
    ULONG & key,
    GetValueResult & reIndicator
)
{

    Win4Assert( !_fOptimizeAscii );

    BYTE *pbData = (BYTE *) pwszStr ;
    USHORT cbData = (USHORT) cwcStr * sizeof(WCHAR);

    Win4Assert(cbData != 0 && pbData != NULL);

    _AddData( pbData, cbData, VT_LPWSTR, &key, FALSE );
    reIndicator = GVRSuccess;
    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   AddData
//
//  Synopsis:   Adds a NULL terminated string to the string store.
//
//  Arguments:  [pwszStr]     -  Pointer to a NULL terminated string.
//              [key]         -  OUTPUT - key of the added string.
//              [reIndicator] -  Status indicator.
//
//  History:    5-19-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID    CCompressedColHashString::AddData(
    WCHAR const *pwszStr,
    ULONG & key,
    GetValueResult & reIndicator
)
{
    ULONG cwcStr = wcslen( pwszStr );
    AddCountedWStr( pwszStr, cwcStr, key, reIndicator );
    return;
}

//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHashString::_AddData, private
//
//  Synopsis:   Private helper for the public AddData method.  Adds
//              a data entry to the hash table (if it does not already
//              exist).
//
//  Arguments:  [pbData] - pointer to data item
//              [cbDataSize] - size of data item
//              [pKey] - pointer to lookup key value
//
//  Returns:    pKey is filled in with the index of the data item in
//              the data array.
//
//  Notes:
//
//--------------------------------------------------------------------------

VOID    CCompressedColHashString::_AddData(
    BYTE *pbData,
    USHORT cbDataSize,
    VARTYPE vt,
    ULONG* pKey,
    BOOL   fNullTerminated
) {
    if ( 0 == _cDataItems )
    {
        _GrowHashTable();
    }

    ULONG ulHash = HashString( pbData, cbDataSize, vt, fNullTerminated );
    USHORT usSizeFmt = (USHORT) (ulHash >> 16);
    ULONG cbString = usSizeFmt & 1? usSizeFmt >> 1 : usSizeFmt;

    ulHash %= _cHashEntries;

    HASHKEY* pulHashChain = &(((HASHKEY *)_pAlloc->BufferAddr())[ulHash]);
    HashEntry* pNextData;
    USHORT cChainLength = 0;

    while (*pulHashChain != 0)
    {
        cChainLength++;
        pNextData = _IndexHashkey( *pulHashChain );

        if (usSizeFmt == pNextData->usSizeFmt)
        {
            BYTE* pbNextString = (BYTE*)_pAlloc->OffsetToPointer(pNextData->ulStringKey);
            if (memcmp(pbNextString, pbData, cbString) == 0)
            {

                //
                //  Found the data item.  Return its index.
                //
                *pKey = *pulHashChain;
                return;
            }
        }
        pulHashChain = &pNextData->ulHashChain;
    }

    //
    // Allocate memory for the new string and copy the contents from
    // the source buffer.
    //
    BYTE * pbNewData = (BYTE *) _pAlloc->Allocate( cbString );
    TBL_OFF ulKey = _pAlloc->PointerToOffset(pbNewData);
    RtlCopyMemory( pbNewData, pbData, cbString );

    //  The table may move in memory when we call AllocFixed.
    //  Be sure we can address pulHashChain after that.
    //
    ULONG ulHashChainBase = (ULONG)((BYTE*)pulHashChain - _pAlloc->BufferAddr());
    pNextData = (struct HashEntry*) _pAlloc->AllocFixed();
    pulHashChain = (HASHKEY *) (_pAlloc->BufferAddr() + ulHashChainBase);

    //
    //  NOTE:  The fixed hash table at this point decides if it wants
    //          to grow the fixed area, with a possible rehash of the
    //          table to grow the number of buckets.  With the code
    //          below, the string hash table has no opportunity to
    //          grow the number of hash buckets.
    //

    //
    //  Now add the new data item.  The data item consists of a HASHKEY
    //  for the hash chain, followed by the size and format indicator,
    //  and the key for the string in the variable data.
    //

    *pKey = *pulHashChain = ++_cDataItems;
    Win4Assert(_cDataItems != 0);               // check for overflow
    pNextData->ulHashChain = 0;
    pNextData->usSizeFmt = usSizeFmt;
    pNextData->ulStringKey = ulKey;
}


//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHashString::_FindData, private
//
//  Synopsis:   Finds a data entry in the hash table.
//
//  Arguments:  [pbData] - pointer to data item
//              [cbDataSize] - size of data item
//              [pKey] - pointer to lookup key value
//
//  Returns:    The key of the string or stridInvalid
//
//  History:    7-17-95   dlee   Created
//
//--------------------------------------------------------------------------

ULONG CCompressedColHashString::_FindData(
    BYTE *   pbData,
    USHORT   cbDataSize,
    VARTYPE  vt,
    BOOL     fNullTerminated )
{
    if ( 0 == _pAlloc )
        _GrowHashTable();

    ULONG ulHash = HashString( pbData, cbDataSize, vt, fNullTerminated );
    USHORT usSizeFmt = (USHORT) (ulHash >> 16);
    ULONG cbString = usSizeFmt & 1? usSizeFmt >> 1 : usSizeFmt;
    ulHash %= _cHashEntries;

    HASHKEY* pulHashChain = &(((HASHKEY *)_pAlloc->BufferAddr())[ulHash]);

    while ( 0 != *pulHashChain )
    {
        HashEntry* pNextData = _IndexHashkey( *pulHashChain );

        if ( usSizeFmt == pNextData->usSizeFmt )
        {
            BYTE* pbNext = (BYTE*)_pAlloc->OffsetToPointer(pNextData->ulStringKey);
            if ( memcmp( pbNext, pbData, cbString ) == 0 )
            {
                // Found the data item.  Return its index.

                return *pulHashChain;
            }
        }
        pulHashChain = &pNextData->ulHashChain;
    }

    // couldn't find the string in the table

    return stridInvalid;
} //_FindData


//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHashString::GetData, public
//
//  Synopsis:   Retrieve a data value from the hash table.
//
//  Arguments:  [pVarnt] - pointer to a variant structure in which to
//                      return a pointer to the data
//              [PreferredType] - preferred type of the result.
//              [ulKey] - the lookup key value
//              [PropId] - (unused) property id being retrieved.
//
//  Returns:    pVarnt is filled in with the data item from the hash table.
//
//  Notes:      The FreeVariant method must be called with the pVarnt
//              structure as an argument when it is no longer needed.
//
//--------------------------------------------------------------------------


GetValueResult  CCompressedColHashString::GetData(
    PROPVARIANT * pVarnt,
    VARTYPE PreferredType,
    ULONG ulKey,
    PROPID PropId
    )
{
    Win4Assert(ulKey <= _cDataItems);

    if (ulKey == 0) {
        pVarnt->vt = VT_EMPTY;
        return GVRNotAvailable;
    }

    HashEntry* pData = ((HashEntry*) _pAlloc->FirstRow()) + ulKey - 1;
    BOOL fAscii = (pData->usSizeFmt & 1) != 0;
    ULONG cchSize = (pData->usSizeFmt >> 1) + 1;
    ULONG cbSize = PreferredType == VT_LPWSTR ? cchSize * sizeof (WCHAR) :
                        !fAscii ?               cchSize * sizeof (WCHAR) :
                                                cchSize;
    BYTE* pbBuf = (BYTE*)_GetStringBuffer((cbSize+1) / sizeof (WCHAR));
    BYTE* pbSource = (BYTE*)_pAlloc->OffsetToPointer(pData->ulStringKey);

    //
    //  Give out the data as an LPSTR only if that's what the caller
    //  desires, and it's in the ascii range.
    //

    if (PreferredType == VT_LPSTR && fAscii)
    {
        RtlCopyMemory(pbBuf, pbSource, cbSize - 1);
        ((CHAR *)pbBuf)[cchSize - 1] = '\0';
        pVarnt->vt = VT_LPSTR;
        pVarnt->pszVal = (PSZ)pbBuf;
    }
    else
    {
        if (!fAscii) {
            RtlCopyMemory(pbBuf, pbSource, cbSize - sizeof(WCHAR));
        } else {
            for (unsigned i=0; i<cchSize-1; i++) {
                ((WCHAR*)pbBuf)[i] = ((CHAR*)pbSource)[i];
            }
        }
        ((WCHAR *)pbBuf)[cchSize - 1] = L'\0';
        pVarnt->vt = VT_LPWSTR;
        pVarnt->pwszVal = (PWSTR)pbBuf;
    }
    return GVRSuccess;

}

//+---------------------------------------------------------------------------
//
//  Function:   GetData
//
//  Synopsis:   Copies a NULL terminated string into the pwszStr by looking
//              up the string identified by "ulKey".
//
//  Arguments:  [ulKey]   - Key of the string to lookup.
//              [pwszStr] - Pointer to the buffer to copy to.
//              [cwcStr]  - On input, it contains the length of the buffer in
//                          WCHARs. On output, it has the length of the string
//                          copied INCLUDING the terminating NULL.
//
//  Returns:    GVR* code
//
//  History:    5-19-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
GetValueResult
CCompressedColHashString::GetData( ULONG ulKey,
                                   WCHAR * pwszStr,
                                   ULONG & cwcStr
                                 )
{
    Win4Assert(ulKey <= _cDataItems);

    if (ulKey == 0)
    {
        return GVRNotAvailable;
    }

    HashEntry* pData = ((HashEntry*) _pAlloc->FirstRow()) + ulKey - 1;
    BOOL fAscii = (pData->usSizeFmt & 1) != 0;
    Win4Assert( !fAscii );
    ULONG cchSize = (pData->usSizeFmt >> 1) + 1;
    ULONG cbSize =  cchSize * sizeof (WCHAR);

    if ( cwcStr < cchSize )
    {
        return GVRNotEnoughSpace;
    }

    BYTE* pbSource = (BYTE*)_pAlloc->OffsetToPointer(pData->ulStringKey);
    RtlCopyMemory( pwszStr, pbSource, cbSize - sizeof(WCHAR) );
    pwszStr[cchSize - 1] = L'\0';
    cwcStr = cchSize;

    return GVRSuccess;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetCountedWStr
//
//  Synopsis:   Returns a pointer to a string which is NOT null terminated.
//              The length of the string (in characters) is returned in
//              cwcStr.
//
//  Arguments:  [ulKey]  -  String to lookup
//              [cwcStr] -  OUTPUT - length of the string in WCHARs.
//
//  History:    5-19-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

const WCHAR *
CCompressedColHashString::GetCountedWStr( ULONG ulKey,
                                          ULONG & cwcStr
                                        )
{
    Win4Assert(ulKey <= _cDataItems);

    if (ulKey == 0)
        return 0;

    HashEntry* pData = ((HashEntry*) _pAlloc->FirstRow()) + ulKey - 1;
    BOOL fAscii = (pData->usSizeFmt & 1) != 0;
    Win4Assert( !fAscii );
    ULONG cchSize = (pData->usSizeFmt >> 1);

    BYTE* pbSource = (BYTE*)_pAlloc->OffsetToPointer(pData->ulStringKey);
    Win4Assert( ( (TBL_OFF)pbSource & (TBL_OFF) 0x1 ) == 0 );    // properly aligned on word.

    cwcStr = cchSize;

    return (const WCHAR *) pbSource;
}

//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHashStr::_GetStringBuffer, private
//
//  Synopsis:   Private helper for the public GetData method.  Gets
//              a string buffer of sufficient size to accomodate the
//              request.
//
//  Arguments:  [cchString] - number of characters required in buffer
//
//  Returns:    pointer to a buffer of sufficient size
//
//  Notes:
//
//  History:    03 Mar 1995     Alanw   Created
//
//--------------------------------------------------------------------------

PWSTR   CCompressedColHashString::_GetStringBuffer( unsigned cchString )
{
    if (! _Buf1.InUse())
        return _Buf1.Alloc(cchString);
    else if (! _Buf2.InUse())
        return _Buf2.Alloc(cchString);
    else
        return new WCHAR [ cchString ];
}

//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHashString::FreeVariant, public
//
//  Synopsis:   Free private data associated with a variant which had
//              been filled in by the GetData method.
//
//  Arguments:  [pVarnt] - pointer to the variant
//
//  Returns:    Nothing
//
//  Notes:
//
//--------------------------------------------------------------------------

void    CCompressedColHashString::FreeVariant(PROPVARIANT * pVarnt)
{
    if (pVarnt->vt != VT_EMPTY) {

        Win4Assert(pVarnt->vt == VT_LPWSTR || pVarnt->vt == VT_LPSTR);

        if (! _Buf1.FreeConditionally( pVarnt->pwszVal ) &&
            ! _Buf2.FreeConditionally( pVarnt->pwszVal ) )
        {
            delete [] pVarnt->pwszVal;
        }

        pVarnt->pwszVal = 0;            // To prevent accidental re-use
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHashString::DataLength, public
//
//  Synopsis:   Free private data associated with a variant which had
//              been filled in by the GetData method.
//
//  Arguments:  [kData] - key to the data
//
//  Returns:    USHORT number of characters in the data item.  Includes
//                      space for a terminating character.  Scale
//                      this by the size of a character for byte count.
//
//  Notes:
//
//--------------------------------------------------------------------------

USHORT  CCompressedColHashString::DataLength(ULONG kData)
{
    if (kData == 0)
        return 0;
    else
    {
        HashEntry* pData = ((HashEntry*) _pAlloc->FirstRow()) + kData - 1;
        return (pData->usSizeFmt >> 1) + 1;
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHashString::_GrowHashTable, private
//
//  Synopsis:   Grow the space allocated to the hash table and data
//              items.
//
//  Arguments:  - none -
//
//  Returns:    Nothing
//
//  Notes:      Called to allocate the initial data area.  Unlike the
//              like-named method in the fixed hash table, this is
//              called only for the initial allocation of data.  Data
//              Items are not re-hashed after being added to the table.
//
//--------------------------------------------------------------------------

const unsigned HASH_TABLE_SIZE = 174;   // Minimum hash table size
                                        // avg. chain length is about
                                        // 3 for a one-page table.
                                        //  NOTE: should be even to
                                        //      assure DWORD allignment of
                                        //      fixed data.

VOID CCompressedColHashString::_GrowHashTable( void )
{
    int fRehash = FALSE;

    _cHashEntries = HASH_TABLE_SIZE;

    Win4Assert(_cDataItems == 0 && _pAlloc == NULL); // only called to initialize.
    Win4Assert(_cbDataWidth == sizeof (HashEntry));
    _pAlloc = new CFixedVarAllocator( TRUE,
                                      TRUE,
                                      _cbDataWidth,
                                      HASH_TABLE_SIZE*sizeof (HASHKEY) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\bigtable\tblvarnt.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       tblvarnt.cxx
//
//  Contents:   Class to aid in dealing with PROPVARIANTs in the result table.
//
//  Classes:    VARNT_DATA - size and allignment constraints of variant types
//              CTableVariant - Wrapper around PROPVARIANT
//
//  History:    25 Jan 1994     AlanW    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <bigtable.hxx>
#include <tblvarnt.hxx>
#include <pmalloc.hxx>

#include "tabledbg.hxx"

//--------------------------------------------------------------------------
//
//  The following structure gives the size and allignment requirements
//  to store a bare variant type (without the variant overhead) in window
//  row data.  For variable length data, information about the location
//  of pointers in the structure is given.
//
//  Flags information is given as follows:
//      01 (CanBeVector) - base type can be in a vector
//      02 (ByRef)       - includes pointer in first word of data part
//      04 (CntRef)      - includes pointer in second word of data part
//      08 (StoreDirect) - variant form includes pointer; store direct in table
//      10 (MultiSize)   - for data like BYTES that is inline in client output
//      20 (SimpleType)  - simple inline datatype, like VT_I4
//      40 (OAType)      - valid in OLE Automation variants (older style)
//
//  NOTE:  This table includes all valid types in PROPVARIANT;
//         it is not limited to types in OLE-DB's appendix A.
//  NOTE:  Some types are listed in wtypes.h as being valid in automation
//         variants, but we can't mark them as OAType until the language
//         interpreters catch up and recognize those types.
//
//--------------------------------------------------------------------------

const CTableVariant::VARNT_DATA CTableVariant::varntData [] = {
    // DBTYPE_VECTOR 0x1000
    // DBTYPE_BYREF  0x4000

    /* 0  0  VT_EMPTY   */ { 0, 0, SimpleType|OAType},
    /* 1  1  VT_NULL    */ { 0, 0, SimpleType},
    /* 2  2  VT_I2      */ { sizeof (short), sizeof (short), CanBeVector|SimpleType|OAType},
    /* 3  3  VT_I4      */ { sizeof (long), sizeof (long), CanBeVector|SimpleType|OAType},
    /* 4  4  VT_R4      */ { sizeof (float), sizeof (float), CanBeVector|SimpleType|OAType},
    /* 5  5  VT_R8      */ { sizeof (double), sizeof (double), CanBeVector|SimpleType|OAType},
    /* 6  6  VT_CY      */ { sizeof (CY), sizeof (CY), CanBeVector|SimpleType|OAType},
    /* 7  7  VT_DATE    */ { sizeof (DATE), sizeof (DATE), CanBeVector|SimpleType|OAType},
    /* 8  8  VT_BSTR    */ { sizeof (void*), sizeof (void*), CanBeVector|ByRef|OAType},
    /* 9  9  VT_DISPATCH*/ { sizeof (void *), sizeof (void *), 0},
    /* a  10 VT_ERROR   */ { sizeof(SCODE), sizeof(SCODE), CanBeVector|SimpleType|OAType},
    /* b  11 VT_BOOL    */ { sizeof (VARIANT_BOOL), sizeof (VARIANT_BOOL), CanBeVector|SimpleType|OAType},
    /* c  12 VT_VARIANT */ { sizeof (PROPVARIANT), sizeof (double), ByRef|StoreDirect|CanBeVector|OAType},
    /* d  13 VT_UNKNOWN */ { sizeof (void *), sizeof (void *), 0},
    /* e  14 VT_DECIMAL */ { sizeof (DECIMAL), sizeof (LARGE_INTEGER), SimpleType|OAType},
    /* f  15            */ { 0, 0, 0},
    /* 10 16 VT_I1      */ { sizeof(char), sizeof(char), CanBeVector|SimpleType},
    /* 11 17 VT_UI1     */ { sizeof(UCHAR), sizeof(UCHAR), CanBeVector|SimpleType|OAType},
    /* 12 18 VT_UI2     */ { sizeof(unsigned short), sizeof(unsigned short), CanBeVector|SimpleType},
    /* 13 19 VT_UI4     */ { sizeof(unsigned long), sizeof(unsigned long),   CanBeVector|SimpleType},
    /* 14 20 VT_I8      */ { sizeof (LARGE_INTEGER), sizeof (LARGE_INTEGER), CanBeVector|SimpleType},
    /* 15 21 VT_UI8     */ { sizeof (LARGE_INTEGER), sizeof (LARGE_INTEGER), CanBeVector|SimpleType},

    /* 16 22 VT_INT     */ { sizeof (INT), sizeof (INT), SimpleType},
    /* 17 23 VT_UINT    */ { sizeof (UINT), sizeof (UINT), SimpleType},
    // Codes 24-29 are valid for typelibs only
    /* 18 24            */ { 0, 0, 0},
    {0,0,0}, {0,0,0}, {0,0,0},  {0,0,0}, {0,0,0},       //     25-29, unused
    /* 1e 30 VT_LPSTR   */ { sizeof (LPSTR), sizeof (LPSTR), CanBeVector|ByRef},
    /* 1f 31 VT_LPWSTR  */ { sizeof (LPWSTR), sizeof (LPWSTR), CanBeVector|ByRef},
    /* 20 32            */ { 0, 0, 0},
    /* 21 33            */ { 0, 0, 0},
    /* 22 34            */ { 0, 0, 0},
    /* 23 35            */ { 0, 0, 0},
    /* 24 36 VT_RECORD? */ { 0, 0, 0},          // SPECDEVIATION - what is it?
                      {0,0,0},  {0,0,0}, {0,0,0},       //     37-39, unused
    {0,0,0}, {0,0,0}, {0,0,0},  {0,0,0}, {0,0,0},       //     40-44, unused
    {0,0,0}, {0,0,0}, {0,0,0},  {0,0,0}, {0,0,0},       //     45-49, unused
    {0,0,0}, {0,0,0}, {0,0,0},  {0,0,0}, {0,0,0},       //     50-54, unused
    {0,0,0}, {0,0,0}, {0,0,0},  {0,0,0}, {0,0,0},       //     55-59, unused
    /* 3c 60            */ { 0, 0, 0},
    /* 3d 61            */ { 0, 0, 0},
    /* 3e 62            */ { 0, 0, 0},
    /* 3f 63            */ { 0, 0, 0},
    /* 40 64 VT_FILETIME*/ { sizeof (FILETIME), sizeof (FILETIME), CanBeVector|SimpleType},
    /* 41 65 VT_BLOB    */ { sizeof (BLOB), sizeof (void*), CntRef},

    // Can these really occur in properties???  varnt.idl says they
    //          are interface pointers
    /* 42 66 VT_STREAM  */ { sizeof (LPWSTR), sizeof (LPWSTR), ByRef},
    /* 43 67 VT_STORAGE */ { sizeof (LPWSTR), sizeof (LPWSTR), ByRef},

    // NOTE:  object-valued properties must be retrieved as Entry IDs
    //          (workid, propid)

    // Can these really occur in properties???  varnt.idl says they
    // are interface pointers.  Even if so, is the definition
    // below appropriate?

    /* 44 68 VT_STREAMED_OBJECT */ { 2*sizeof (ULONG), sizeof (ULONG), 0},
    /* 45 69 VT_STORED_OBJECT */ { 2*sizeof (ULONG), sizeof (ULONG), 0},
    /* 46 70 VT_BLOB_OBJECT   */ { 2*sizeof (ULONG), sizeof (ULONG), 0},
    /* 47 71 VT_CF      */ { sizeof (CLIPDATA*), sizeof (CLIPDATA*), CanBeVector|ByRef},
    /* 48 72 VT_CLSID   */ { sizeof (GUID), sizeof DWORD, StoreDirect|ByRef|CanBeVector},
};

const unsigned CTableVariant::cVarntData = sizeof CTableVariant::varntData /
                                           sizeof CTableVariant::varntData[0];

//--------------------------------------------------------------------------
//
//  This table is like the table above, but is for DBVARIANT extensions,
//  i.e., those whose variant type values are 128 and above.
//
//--------------------------------------------------------------------------

const CTableVariant::VARNT_DATA CTableVariant::varntExtData [] = {
    //
    //  Additional type definitions above those in PROPVARIANT.
    //  Some cannot be used for variant binding.
    //
    { 0, sizeof BYTE, MultiSize},               // DBTYPE_BYTES   = x80 128,
    { 0, sizeof CHAR, MultiSize},               // DBTYPE_STR     = x81 129,
    { 0, sizeof WCHAR, MultiSize},              // DBTYPE_WSTR    = x82 130,
    { sizeof LONGLONG, sizeof LONGLONG, 0},     // DBTYPE_NUMERIC = x83 131,
    { 0, 0, 0},                                 // DBTYPE_UDT     = x84 132,
    { sizeof DBDATE, sizeof USHORT, 0},         // DBTYPE_DBDATE  = x85 133,
    { sizeof DBTIME, sizeof USHORT, 0},         // DBTYPE_DBTIME  = x86 134,
    { sizeof DBTIMESTAMP, sizeof ULONG, 0},     // DBTYPE_DBTIMESTAMP= x87 135,
    { sizeof HCHAPTER, sizeof ULONG, 0},        // DBTYPE_HCHAPTER   = x88 136,
    { 0, 0, 0},                                 // was DBTYPE_DBFILETIME
    { sizeof PROPVARIANT, sizeof(double), 0},   // DBTYPE_PROPVARIANT = X8a 138,
    { sizeof DB_VARNUMERIC, sizeof BYTE, 0},    // DBTYPE_VARNUMERIC = x8b 139,
};

const unsigned CTableVariant::cVarntExtData =
    sizeof CTableVariant::varntExtData / sizeof CTableVariant::varntExtData[0];

#ifdef _WIN64
//
// VARIANT DATA for Win32 clients on a Win64 server
//  Pointer references must be 32 bits in length (sizeof ULONG)
//  See '+' for changed entries
//

const CTableVariant::VARNT_DATA CTableVariant::varntData32 [] = {
    // DBTYPE_VECTOR 0x1000
    // DBTYPE_BYREF  0x4000

    /* 0  0  VT_EMPTY   */ { 0, 0, SimpleType|OAType},
    /* 1  1  VT_NULL    */ { 0, 0, SimpleType},
    /* 2  2  VT_I2      */ { sizeof (short), sizeof (short), CanBeVector|SimpleType|OAType},
    /* 3  3  VT_I4      */ { sizeof (long), sizeof (long), CanBeVector|SimpleType|OAType},
    /* 4  4  VT_R4      */ { sizeof (float), sizeof (float), CanBeVector|SimpleType|OAType},
    /* 5  5  VT_R8      */ { sizeof (double), sizeof (double), CanBeVector|SimpleType|OAType},
    /* 6  6  VT_CY      */ { sizeof (CY), sizeof (CY), CanBeVector|SimpleType|OAType},
    /* 7  7  VT_DATE    */ { sizeof (DATE), sizeof (DATE), CanBeVector|SimpleType|OAType},
    /*+8  8  VT_BSTR    */ { sizeof (ULONG), sizeof (ULONG), CanBeVector|ByRef|OAType},
    /*+9  9  VT_DISPATCH*/ { sizeof (ULONG), sizeof (ULONG), 0},
    /* a  10 VT_ERROR   */ { sizeof (SCODE), sizeof(SCODE), CanBeVector|SimpleType|OAType},
    /* b  11 VT_BOOL    */ { sizeof (VARIANT_BOOL), sizeof (VARIANT_BOOL), CanBeVector|SimpleType|OAType},
    /*+c  12 VT_VARIANT */ { sizeof (PROPVARIANT32), sizeof (double), ByRef|StoreDirect|CanBeVector|OAType},
    /* d  13 VT_UNKNOWN */ { sizeof (ULONG), sizeof (ULONG), 0},
    /* e  14 VT_DECIMAL */ { sizeof (DECIMAL), sizeof (LARGE_INTEGER), SimpleType|OAType},
    /* f  15            */ { 0, 0, 0},
    /* 10 16 VT_I1      */ { sizeof(char), sizeof(char), CanBeVector|SimpleType},
    /* 11 17 VT_UI1     */ { sizeof(UCHAR), sizeof(UCHAR), CanBeVector|SimpleType|OAType},
    /* 12 18 VT_UI2     */ { sizeof(unsigned short), sizeof(unsigned short), CanBeVector|SimpleType},
    /* 13 19 VT_UI4     */ { sizeof(unsigned long), sizeof(unsigned long),   CanBeVector|SimpleType},
    /* 14 20 VT_I8      */ { sizeof (LARGE_INTEGER), sizeof (LARGE_INTEGER), CanBeVector|SimpleType},
    /* 15 21 VT_UI8     */ { sizeof (LARGE_INTEGER), sizeof (LARGE_INTEGER), CanBeVector|SimpleType},

    /* 16 22 VT_INT     */ { sizeof (INT), sizeof (INT), SimpleType},
    /* 17 23 VT_UINT    */ { sizeof (UINT), sizeof (UINT), SimpleType},
    // Codes 24-29 are valid for typelibs only
    /* 18 24            */ { 0, 0, 0},
                           {0,0,0}, {0,0,0}, {0,0,0},  {0,0,0}, {0,0,0},       //     25-29, unused
    /*+1e 30 VT_LPSTR   */ { sizeof (ULONG), sizeof (ULONG), CanBeVector|ByRef},
    /* 1f 31 VT_LPWSTR  */ { sizeof (ULONG), sizeof (ULONG), CanBeVector|ByRef},
    /* 20 32            */ { 0, 0, 0},
    /* 21 33            */ { 0, 0, 0},
    /* 22 34            */ { 0, 0, 0},
    /* 23 35            */ { 0, 0, 0},
    /* 24 36 VT_RECORD? */ { 0, 0, 0},          // SPECDEVIATION - what is it?
                      {0,0,0},  {0,0,0}, {0,0,0},       //     37-39, unused
    {0,0,0}, {0,0,0}, {0,0,0},  {0,0,0}, {0,0,0},       //     40-44, unused
    {0,0,0}, {0,0,0}, {0,0,0},  {0,0,0}, {0,0,0},       //     45-49, unused
    {0,0,0}, {0,0,0}, {0,0,0},  {0,0,0}, {0,0,0},       //     50-54, unused
    {0,0,0}, {0,0,0}, {0,0,0},  {0,0,0}, {0,0,0},       //     55-59, unused
    /* 3c 60            */ { 0, 0, 0},
    /* 3d 61            */ { 0, 0, 0},
    /* 3e 62            */ { 0, 0, 0},
    /* 3f 63            */ { 0, 0, 0},
    /* 40 64 VT_FILETIME*/ { sizeof (FILETIME), sizeof (FILETIME), CanBeVector|SimpleType},
    /*+41 65 VT_BLOB    */ { sizeof (BLOB32), sizeof (ULONG), CntRef},

    // Can these really occur in properties???  varnt.idl says they
    //          are interface pointers
    /*+42 66 VT_STREAM  */ { sizeof (ULONG), sizeof (ULONG), ByRef},
    /*+43 67 VT_STORAGE */ { sizeof (ULONG), sizeof (ULONG), ByRef},

    // NOTE:  object-valued properties must be retrieved as Entry IDs
    //          (workid, propid)

    // Can these really occur in properties???  varnt.idl says they
    // are interface pointers.  Even if so, is the definition
    // below appropriate?

    /* 44 68 VT_STREAMED_OBJECT */ { 2*sizeof (ULONG), sizeof (ULONG), 0},
    /* 45 69 VT_STORED_OBJECT */ { 2*sizeof (ULONG), sizeof (ULONG), 0},
    /* 46 70 VT_BLOB_OBJECT   */ { 2*sizeof (ULONG), sizeof (ULONG), 0},
    /*+47 71 VT_CF      */ { sizeof (ULONG), sizeof (ULONG), CanBeVector|ByRef},
    /* 48 72 VT_CLSID   */ { sizeof (GUID), sizeof DWORD, StoreDirect|ByRef|CanBeVector},
};

//--------------------------------------------------------------------------
//
//  This table is like the table above, but is for DBVARIANT extensions,
//  i.e., those whose variant type values are 128 and above.
//  
//  This one is also for 64 bit servers talking to 32 bit clients
//--------------------------------------------------------------------------

const CTableVariant::VARNT_DATA CTableVariant::varntExtData32 [] = {
    //
    //  Additional type definitions above those in PROPVARIANT.
    //  Some cannot be used for variant binding.
    //
    { 0, sizeof BYTE, MultiSize},               // DBTYPE_BYTES   = x80 128,
    { 0, sizeof CHAR, MultiSize},               // DBTYPE_STR     = x81 129,
    { 0, sizeof WCHAR, MultiSize},              // DBTYPE_WSTR    = x82 130,
    { sizeof LONGLONG, sizeof LONGLONG, 0},     // DBTYPE_NUMERIC = x83 131,
    { 0, 0, 0},                                 // DBTYPE_UDT     = x84 132,
    { sizeof DBDATE, sizeof USHORT, 0},         // DBTYPE_DBDATE  = x85 133,
    { sizeof DBTIME, sizeof USHORT, 0},         // DBTYPE_DBTIME  = x86 134,
    { sizeof DBTIMESTAMP, sizeof ULONG, 0},     // DBTYPE_DBTIMESTAMP= x87 135,
    { sizeof ULONG, sizeof ULONG, 0},           // DBTYPE_HCHAPTER   = x88 136,
    { 0, 0, 0},                                 // was DBTYPE_DBFILETIME
    { sizeof PROPVARIANT32, sizeof(double), 0}, // DBTYPE_PROPVARIANT = X8a 138,
    { sizeof DB_VARNUMERIC, sizeof BYTE, 0},    // DBTYPE_VARNUMERIC = x8b 139,
};

#endif // _WIN64


//
//      Variant helper methods
//


//+-------------------------------------------------------------------------
//
//  Method:     CTableVariant::Copy, public
//              CTableVariant::CopyData, private
//
//  Synopsis:   Copy the data of a variant.  One method copies the variant
//              and its data, the other copies the variant only.
//
//  Arguments:  [pvarntDest] - pointer to destination variant (Copy method only)
//              [rVarAllocator] - pointer to variable allocator for dest. data
//              [cbDest] - expected size in bytes of variable data
//              [pbBias] - base address of variable data if offset stored in
//                              variant
//
//  Returns:    VOID* - the address to which the data was copied
//
//  Notes:      If the variant is an internal form, double indirect
//              data will use offsets, not pointers.  The input
//              variant from external callers will generally have
//              pointers, not offsets even for internal form variants.
//
//--------------------------------------------------------------------------

void CTableVariant::Copy(
                        CTableVariant *pvarntDest,
                        PVarAllocator &rVarAllocator,
                        USHORT cbDest,
                        BYTE* pbBias) const
{
    // Copy into a temp variant so if copy fails the output variant
    // isn't affected.  Clients don't always check return codes.

    CTableVariant tmp = *this;

    BOOL fBased = rVarAllocator.IsBasedMemory();
    if ( fBased )
    {
        tmp.SetDataSize((USHORT) cbDest);
    }
    else
    {
        tmp.ResetDataSize( );
    }

    if (cbDest != 0)
    {
        BYTE* pbDest = (BYTE *) CopyData(rVarAllocator, cbDest, pbBias);

        if ( fBased )
            pbDest = (BYTE*) rVarAllocator.PointerToOffset(pbDest);

        if ( tmp.VariantPointerInFirstWord() )
        {
            tmp.pszVal = (LPSTR)pbDest;
        }
        else
        {
            Win4Assert( tmp.VariantPointerInSecondWord() );

            tmp.blob.pBlobData = pbDest;
        }
    }

    *pvarntDest = tmp;
}


VOID* CTableVariant::CopyData(
                             PVarAllocator &rVarAllocator,
                             USHORT cbDest, BYTE* pbBias ) const
{
    BYTE* pbSrc = VariantPointerInFirstWord() ?
                  (BYTE*)pszVal : blob.pBlobData;
    pbSrc += (ULONG_PTR)pbBias;

    Win4Assert( cbDest != 0 );

    // optimize this most typical path
    if ( VT_LPWSTR == vt )
    {
        return (BYTE*) rVarAllocator.CopyTo( cbDest, pbSrc );
    }

    if (vt == VT_BSTR)
    {
        //  Need to allow for byte count before the string
        return rVarAllocator.CopyBSTR(cbDest -
                                     (sizeof (DWORD) + sizeof (OLECHAR)),
                                     (WCHAR *)pbSrc );
    }

    //
    //  Determine if offsets or pointers are used in the source data.  If
    //  offsets are used, and offsets will be used in the destination, the
    //  data can simply be block copied.  Otherwise, vectors of strings and
    //  vectors of variants must have pointers translated to offsets or
    //  vice-versa.
    //

    if ( _IsInternalVariant() && rVarAllocator.IsBasedMemory() )
    {
        Win4Assert( vt != VT_VARIANT && vt != VT_BSTR );
        //
        //  We're copying with offsets to a destination with offsets.
        //  Just copy.
        //
        return rVarAllocator.CopyTo(cbDest, pbSrc);
    }

    BYTE* pbDest = 0;

    switch (vt)
    {
    case VT_LPSTR:
    case VT_CLSID:
    case VT_BLOB:
    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_ERROR:
    case VT_VECTOR | VT_BOOL:
    case VT_VECTOR | VT_I1:
    case VT_VECTOR | VT_UI1:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_FILETIME:
    case VT_VECTOR | VT_CLSID:
        //
        //  There are no embedded pointers.  Just copy.
        //
        pbDest = (BYTE*) rVarAllocator.CopyTo(cbDest, pbSrc);
        break;

    case VT_VECTOR | VT_BSTR:
        pbDest = (BYTE*) rVarAllocator.Allocate( calpstr.cElems * sizeof (BSTR) );

        if (pbDest != 0)
        {
            BSTR* paStr = (BSTR*) pbDest;
            CABSTR caStr = cabstr;
            caStr.pElems = (BSTR*)pbSrc;

            for (unsigned i = 0; i < caStr.cElems; i++)
            {
                pbSrc = pbBias + (ULONG_PTR) caStr.pElems[i];

                ULONG cb = BSTRLEN((BSTR)pbSrc);

                BYTE *pbTmp = (BYTE *) rVarAllocator.PointerToOffset(
                                          rVarAllocator.CopyBSTR(cb, (WCHAR*)pbSrc));

                paStr[i] = (BSTR) pbTmp;
            }
        }
        break;

    case VT_VECTOR | VT_LPWSTR:
    case VT_VECTOR | VT_LPSTR:
        pbDest = (BYTE*) rVarAllocator.Allocate( calpstr.cElems * sizeof (LPSTR) );

        if (pbDest != 0)
        {
            LPSTR* paStr = (LPSTR*) pbDest;
            CALPSTR caStr = calpstr;
            caStr.pElems = (LPSTR*)pbSrc;

            for (unsigned i = 0; i < caStr.cElems; i++)
            {
                ULONG cb;
                pbSrc = pbBias + (ULONG_PTR) caStr.pElems[i];

                if ( ( VT_LPWSTR | VT_VECTOR ) == vt )
                    cb = (wcslen((LPWSTR)pbSrc) + 1) * sizeof (WCHAR);
                else
                    cb = (strlen((LPSTR)pbSrc) + 1) * sizeof (CHAR);

                paStr[i] = (LPSTR) rVarAllocator.PointerToOffset(
                                             rVarAllocator.CopyTo(cb, pbSrc));
            }
        }
        break;

    case VT_CF:
    {
        pbDest = (BYTE *) rVarAllocator.Allocate( sizeof CLIPDATA );
        CLIPDATA *pClipData = (CLIPDATA *) pbDest;
        pClipData->cbSize = pclipdata->cbSize;
        pClipData->ulClipFmt = pclipdata->ulClipFmt;

        ULONG cbData = CBPCLIPDATA( *pclipdata );
        pClipData->pClipData = 0;
        pClipData->pClipData = (BYTE *) rVarAllocator.Allocate( cbData );
        RtlCopyMemory( pClipData->pClipData, pclipdata->pClipData, cbData );
        pClipData->pClipData = (BYTE *) rVarAllocator.PointerToOffset( pClipData->pClipData );
    }
        break;

    case VT_VECTOR | VT_CF:
    {
        // allocate the array of pointers to clip format elements

        ULONG cbArray = caclipdata.cElems * sizeof caclipdata.pElems[0];
        pbDest = (BYTE *) rVarAllocator.Allocate( cbArray );

        if ( 0 != pbDest )
        {
            CLIPDATA * aData = (CLIPDATA *) pbDest;
            RtlZeroMemory( aData, cbArray );

            for ( unsigned i = 0; i < caclipdata.cElems; i++ )
            {
                aData[i].cbSize = caclipdata.pElems[i].cbSize;
                aData[i].ulClipFmt = caclipdata.pElems[i].ulClipFmt;
                ULONG cbData = CBPCLIPDATA( caclipdata.pElems[ i ] );
                aData[i].pClipData = (BYTE *) rVarAllocator.Allocate( cbData );
                RtlCopyMemory( aData[i].pClipData,
                               caclipdata.pElems[i].pClipData,
                               cbData );
                aData[i].pClipData = (BYTE *) rVarAllocator.PointerToOffset( aData[i].pClipData );
            }
        }
    }
        break;

    case VT_VECTOR | VT_VARIANT:
        //
        //  Copy vector of variant.  Recurses for any element of the
        //  vector that has variable data.  Special handling is needed
        //  for the case of pVarAllocator being a size allocator, which
        //  is indicated by an allocation return being zero (the allocators
        //  throw an exception if out of memory).
        //

        pbDest = (BYTE*) rVarAllocator.Allocate( capropvar.cElems *
                                                 sizeof CTableVariant );

        if (pbDest != 0)
        {
            CTableVariant* paVarnt = (CTableVariant*) pbDest;

            CTableVariant* paSrcVarnt = (CTableVariant*)
                                        (pbBias + (ULONG_PTR) capropvar.pElems);
            for (unsigned i = 0; i < capropvar.cElems; i++)
            {
                ULONG cbVarData = paSrcVarnt->VarDataSize();
                Win4Assert( cbVarData <= USHRT_MAX );

                paSrcVarnt->Copy(paVarnt, rVarAllocator, (USHORT)cbVarData,
                                 _IsInternalVariant() ? (BYTE *)paSrcVarnt : 0);

                paSrcVarnt++;
            }
        }
        break;

    case VT_ARRAY | VT_I2:
    case VT_ARRAY | VT_I4:
    case VT_ARRAY | VT_R4:
    case VT_ARRAY | VT_R8:
    case VT_ARRAY | VT_CY:
    case VT_ARRAY | VT_DATE:
    case VT_ARRAY | VT_BSTR:
    case VT_ARRAY | VT_ERROR:
    case VT_ARRAY | VT_BOOL:
    case VT_ARRAY | VT_VARIANT:
    case VT_ARRAY | VT_DECIMAL:
    case VT_ARRAY | VT_I1:
    case VT_ARRAY | VT_UI1:
    case VT_ARRAY | VT_UI2:
    case VT_ARRAY | VT_UI4:
    case VT_ARRAY | VT_INT:
    case VT_ARRAY | VT_UINT:
        {
            SAFEARRAY * pSaSrc  = parray;
            SAFEARRAY * pSaDest = 0;

            if ( SaCreateAndCopy( rVarAllocator, pSaSrc, &pSaDest ) &&
                 0 != pSaDest )
                SaCreateData( rVarAllocator,
                              vt & ~VT_ARRAY,
                              *pSaSrc,
                              *pSaDest,
                              TRUE );

            pbDest = (BYTE*)pSaDest;
        }
        break;

    default:
        tbDebugOut(( DEB_WARN, "Unsupported variant type %4x\n", (int) vt ));
        Win4Assert(! "Unsupported variant type in CTableVariant::CopyData");
    }

    //
    //  NOTE:  pbDest can be null if the allocator we were passed is a
    //          size allocator.
    //
    //Win4Assert(pbDest != 0);
    return pbDest;
}

#ifdef _WIN64

//+-------------------------------------------------------------------------
//
//  Method:     CTableVariant::FixDataPointers, public
//
//  Synopsis:   Adjust offsets to be pointers for variable data
//
//  Arguments:  [pbBias] - adjustment base for variable data pointer
//              [pArrayAlloc] - Pointer to an allocator
//
//  Returns:    -Nothing-
//
//  History:    22 Sep 1999     KLam    Reinstated and added code
//
//  Notes:      This routine can be recursive when operating on variants
//              which contain vectors of variants.  As a side-effect, the
//              signature which indicates an internal form of variant is
//              cleared.
//
//              This routine is only be used for communication between a 32
//              bit server and 64 bit client.  So the pointers found in the
//              rows are always 32 bits.  Note the casting.
//              Arrays of of pointers are stored in the pArrayAlloc buffer.
//
//--------------------------------------------------------------------------

void CTableVariant::FixDataPointers(BYTE* pbBias, CFixedVarAllocator *pArrayAlloc)
{
    PROPVARIANT32 *pThis32 = (PROPVARIANT32 *)this;

    USHORT flags = _FindVarType( pThis32->vt ).flags;
    BOOL fVectorOrArray = ( 0 != ( (VT_ARRAY|VT_VECTOR) & pThis32->vt ) );
    USHORT vtBase = pThis32->vt & VT_TYPEMASK;
    BOOL fSafeArray = ( (0 != ( VT_ARRAY & pThis32->vt )) || (VT_SAFEARRAY == vtBase) );

    // If a simple type and not a vector, just return

    tbDebugOut(( DEB_TRACE, "CTableVariant::FixDataPointers [this:0x%I64x] (Bias: 0x%I64x) pThis32->vt:0x%x\n",
                 this, pbBias, vt ));

    if ( ( 0 != ( flags & SimpleType ) ) &&
         ( ! fVectorOrArray ) )
        return;

    Win4Assert( _IsInternalVariant() );

    //  Clear internal reserved fields

    ResetDataSize();

    BYTE* pbVarData;

    if ( ( ! fVectorOrArray ) &&
         ( 0 != ( flags & ByRef ) ) )
    {
        pszVal = (LPSTR) ( pbBias + pThis32->p );

        tbDebugOut(( DEB_TRACE, "CTableVariant::FixDataPointers setting string to 0x%I64x\n", pszVal ));
        return;
    }
    else if ( fSafeArray )
    {
        pbVarData = pbVal = pbBias + pThis32->p;
        tbDebugOut(( DEB_TRACE, "CTableVariant::FixDataPointers setting SafeArray to 0x%I64x\n", pszVal ));
    }
    else
    {
        Win4Assert( VariantPointerInSecondWord() );
        blob.pBlobData = pbVarData = pbBias + pThis32->blob.pBlob;
        blob.cbSize = pThis32->blob.cbSize;
        tbDebugOut(( DEB_TRACE, "CTableVariant::FixDataPointers setting value to 0x%I64x\n", pbVarData ));
    }

    //
    //  Adjust offsets to pointers in vectors with pointers
    //
    if (vt == (VT_LPWSTR|VT_VECTOR) ||
        vt == (VT_LPSTR|VT_VECTOR) ||
        vt == (VT_BSTR|VT_VECTOR))
    {
        LPSTR * paNewArray = (LPSTR *)pArrayAlloc->Allocate( calpstr.cElems * (sizeof (void *)) );
        ULONG * puStr = (ULONG *) pbVarData;
        for (unsigned i = 0; i < calpstr.cElems; i++)
            paNewArray[i] = (LPSTR) (puStr[i] + pbBias);
        // Point to the new bigger array
        blob.pBlobData = pbVarData = (BYTE *)paNewArray;
        tbDebugOut(( DEB_TRACE, "CTableVariant::FixDataPointers setting vector to 0x%I64x\n", paNewArray ));
    }
    // VECTOR of VARIANTS aren't currently supported
    // This branch is untested
    else if (vt == (VT_VARIANT|VT_VECTOR))
    {
        CTableVariant* pVarnt = (CTableVariant*) pbVarData;

        tbDebugOut(( DEB_TRACE, "CTableVariant::FixDataPointers recursively setting variant vector!\n" ));
        for (unsigned i = 0; i < capropvar.cElems; i++)
        {
            pVarnt->FixDataPointers(pbBias, pArrayAlloc);
            pVarnt++;
        }
    }
    else if ( fSafeArray )
    {
        SAFEARRAY32 *pSafeArray32 = (SAFEARRAY32 *) pbVarData;
        // Get the size of the safearray
        unsigned cbSASize = sizeof (SAFEARRAY) + ( (pSafeArray32->cDims - 1 ) * sizeof (SAFEARRAYBOUND) );

        