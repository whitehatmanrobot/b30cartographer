// Reference to the notification handle helper device.  A notification
      // helper device is only opened on demand.
#if 0
      // Thread list not used due to race conditions.
      // Lock is still used.
  LIST_ENTRY  m_thread_list;
#endif
  CRITICAL_SECTION  m_thread_list_lock;
  
};  // class DPROCESS



inline 
PDPROCESS
DPROCESS::GetCurrentDProcess(
    )
/*++

Routine Description:

    Retrieves  a reference to the current DPROCESS object.  Note that this is a
    "static" function with global scope instead of object-instance scope.

Arguments:

    None
Return Value:
    Returns pointer to current DPROCESS object or NULL if process has not been
    initialized yet

--*/
{
    return sm_current_dprocess;
} //GetCurrentDProcess


inline VOID
DPROCESS::IncrementRefCount(
    VOID
    )
/*++

Routine Description:

    This function increases the reference count on this object.

Arguments:

Return Value:

    NONE
--*/
{
    InterlockedIncrement(&m_reference_count);
}



inline DWORD
DPROCESS::DecrementRefCount(
    VOID
    )
/*++

Routine Description:

    This function decreases the reference count on this object.

Arguments:

Return Value:

    Returns the new value of the reference count
--*/
{
    return(InterlockedDecrement(&m_reference_count));
}



inline
BYTE
DPROCESS::GetMajorVersion()
/*++

Routine Description:

    This function returns the major WinSock version number negotiated
    at WSAStartup() time.

Arguments:

    None.

Return Value:

    Returns the major WinSock version number.

--*/
{
    assert(m_version != 0);
    return LOBYTE(m_version);
} // GetMajorVersion



inline
BYTE
DPROCESS::GetMinorVersion()
/*++

Routine Description:

    This function returns the minor WinSock version number negotiated
    at WSAStartup() time.

Arguments:

    None.

Return Value:

    Returns the minor WinSock version number.

--*/
{
    assert(m_version != 0);
    return HIBYTE(m_version);
} // GetMinorVersion



inline
WORD
DPROCESS::GetVersion()
/*++

Routine Description:

    This function returns the WinSock version number negotiated
    at WSAStartup() time.

Arguments:

    None.

Return Value:

    Returns the WinSock version number.

--*/
{
    assert(m_version != 0);
    return m_version;
} // GetVersion



inline VOID
DPROCESS::LockDThreadList()
/*++

  Routine Description:

  This  function  acquires  mutually  exclusive access to the list of DTHREAD
  objects   attached  to  the  DPROCESS  object.   The  companion  procedures
  LockDThreadList  and  UnLockDThreadList  are  used  internally  to  bracket
  operations that add and remove items from the DTHREAD list.

  NOTE:

  Use  a  Critical  Section object for best performance.  Create the Critical
  Section  object  at  DPROCESS  object initialization time and destroy it at
  DPROCESS object destruction time.

  Arguments:

  None

  Return Value:

  None
  --*/
{
    EnterCriticalSection(&m_thread_list_lock);
}


inline VOID
DPROCESS::UnLockDThreadList()
/*++

  Routine Description:

  This  function  releases  mutually  exclusive access to the list of DTHREAD
  objects   attached  to  the  DPROCESS  object.   The  companion  procedures
  LockDThreadList  and  UnLockDThreadList  are  used  internally  to  bracket
  operations that add and remove items from the DTHREAD list.

  NOTE:

  Use  a  Critical  Section object for best performance.  Create the Critical
  Section  object  at  DPROCESS  object initialization time and destroy it at
  DPROCESS object destruction time.

  Arguments:

  None

  Return Value:

  None
  --*/
{
    LeaveCriticalSection(&m_thread_list_lock);
}



inline INT
DPROCESS::GetAsyncHelperDeviceID(
    OUT LPHANDLE HelperHandle
    )
/*++

Routine Description:

    Retrieves  the  opened  Async  Helper  device  ID  required  for processing
    callbacks  in  the  overlapped  I/O  model.   The operation opens the Async
    Helper device if necessary.

Arguments:

    HelperHandle - Returns the requested Async Helper device ID.

Return Value:

    The  function  returns ERROR_SUCESS if successful, otherwise it
    returns an appropriate WinSock error code.
--*/
{
    if (m_ApcHelper) {
        *HelperHandle = m_ApcHelper;
        return ERROR_SUCCESS;
        } //if
    else {
        return OpenAsyncHelperDevice (HelperHandle);
    }
}


inline INT
DPROCESS::GetHandleHelperDeviceID(
    OUT LPHANDLE HelperHandle
    )
/*++

Routine Description:

    Retrieves  the  opened  Handle  Helper  device  ID  required  for allocation
    of socket handles for non-IFS providers.   The operation opens the Handle
    Helper device if necessary.

Arguments:

    HelperHandle - Returns the requested Handle Helper device ID.

Return Value:

    The  function  returns ERROR_SUCESS if successful, otherwise it
    returns an appropriate WinSock error code.
--*/
{
    if (m_HandleHelper) {
        *HelperHandle = m_HandleHelper;
        return ERROR_SUCCESS;
        } //if
    else {
        return OpenHandleHelperDevice (HelperHandle);
    }
}



inline INT
DPROCESS::GetNotificationHelperDeviceID(
    OUT LPHANDLE HelperHandle
    )
/*++

Routine Description:

    Retrieves  the  opened  Async  Helper  device  ID  required  for processing
    callbacks  in  the  overlapped  I/O  model.   The operation opens the Async
    Helper device if necessary.

Arguments:

    HelperHandle - Returns the requested Async Helper device ID.

Return Value:

    The  function  returns ERROR_SUCESS if successful, otherwise it
    returns an appropriate WinSock error code.
--*/
{
    if (m_NotificationHelper) {
        *HelperHandle = m_NotificationHelper;
        return ERROR_SUCCESS;
        } //if
    else {
        return OpenNotificationHelperDevice (HelperHandle);
    }
}

#endif // _DPROCESS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\inc\dprovide.h ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

        dprovide.h

Abstract:

        This module defines the WinSock2 class dprovder along with its methods.

Author:

        Mark Hamilton (mark_hamilton@ccm.jf.intel.com) 7-July-1995

Revision History:

    23-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Changed names of private data
        members. Moved single line functions into this header.

    25-July-1995 dirk@mink.intel.com
        Removed process linage data member.

    7-July-1995     mark_hamilton

                Genesis
--*/
#ifndef _DPROVIDER_
#define _DPROVIDER_

#include <winsock2.h>
#include <ws2spi.h>
#include "dthook.h"


class DPROVIDER {

  public:

    DPROVIDER();

    INT
    Initialize(
        IN LPWSTR lpszLibFile,
        IN LPWSAPROTOCOL_INFOW lpProtocolInfo);

    SOCKET
    WSPAccept(
        IN SOCKET s,
        OUT struct sockaddr FAR *addr,
        OUT INT FAR *addrlen,
        IN LPCONDITIONPROC lpfnCondition,
        IN DWORD_PTR dwCallbackData,
        OUT INT FAR *lpErrno);

    INT
    WSPAddressToString(
        IN     LPSOCKADDR lpsaAddress,
        IN     DWORD dwAddressLength,
        IN     LPWSAPROTOCOL_INFOW lpProtocolInfo,
        OUT    LPWSTR lpszAddressString,
        IN OUT LPDWORD lpdwAddressStringLength,
        OUT    LPINT lpErrno );

    INT
    WSPAsyncSelect(
        IN SOCKET s,
        IN HWND hWnd,
        IN unsigned int wMsg,
        IN long lEvent,
        OUT INT FAR *lpErrno);

    INT
    WSPBind(
        IN SOCKET s,
        IN const struct sockaddr FAR *name,
        IN INT namelen,
        OUT INT FAR *lpErrno);

    INT
    WSPCancelBlockingCall(
        OUT INT FAR *lpErrno);

    INT
    WSPCleanup(
        OUT INT FAR *lpErrno);

    INT
    WSPCloseSocket(
        IN SOCKET s,
        OUT INT FAR *lpErrno);

    INT
    WSPConnect(
        IN SOCKET s,
        IN const struct sockaddr FAR *name,
        IN INT namelen,
        IN LPWSABUF lpCallerData,
        IN LPWSABUF lpCalleeData,
        IN LPQOS lpSQOS,
        IN LPQOS lpGQOS,
        OUT INT FAR *lpErrno);

    INT
    WSPDuplicateSocket(
        IN SOCKET s,
        IN DWORD dwProcessID,
        IN LPWSAPROTOCOL_INFOW lpProtocolInfo,
        OUT INT FAR *lpErrno);

    INT
    WSPEnumNetworkEvents(
        IN SOCKET s,
        OUT WSAEVENT hEventObject,
        OUT LPWSANETWORKEVENTS lpNetworkEvents,
        OUT INT FAR *lpErrno);

    INT
    WSPEventSelect(
        IN SOCKET s,
        IN OUT WSAEVENT hEventObject,
        IN long lNetworkEvents,
        OUT INT FAR *lpErrno);

    INT
    WSPGetOverlappedResult(
        IN SOCKET s,
        IN LPWSAOVERLAPPED lpOverlapped,
        IN LPDWORD lpcbTransfer,
        IN BOOL fWait,
        OUT LPDWORD lpdwFlags,
        OUT INT FAR *lpErrno);

    INT
    WSPGetPeerName(
        IN SOCKET s,
        OUT struct sockaddr FAR *name,
        OUT INT FAR *namelen,
        OUT INT FAR *lpErrno);

    INT
    WSPGetQOSByName(
        IN SOCKET s,
        IN LPWSABUF lpQOSName,
        IN LPQOS lpQOS,
        OUT INT FAR *lpErrno);

    INT
    WSPGetSockName(
        IN SOCKET s,
        OUT struct sockaddr FAR *name,
        OUT INT FAR *namelen,
        OUT INT FAR *lpErrno);

    INT
    WSPGetSockOpt(
        IN SOCKET s,
        IN INT level,
        IN INT optname,
        OUT char FAR *optval,
        OUT INT FAR *optlen,
        OUT INT FAR *lpErrno);

    INT
    WSPIoctl(
        IN SOCKET s,
        IN DWORD dwIoControlCode,
        IN LPVOID lpvInBuffer,
        IN DWORD cbInBuffer,
        IN LPVOID lpvOutBuffer,
        IN DWORD cbOutBuffer,
        IN LPDWORD lpcbBytesReturned,
        IN LPWSAOVERLAPPED lpOverlapped,
        IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
        IN LPWSATHREADID lpThreadId,
        OUT INT FAR *lpErrno);

    SOCKET
    WSPJoinLeaf(
        IN SOCKET s,
        IN const struct sockaddr FAR *name,
        IN INT namelen,
        IN LPWSABUF lpCallerData,
        IN LPWSABUF lpCalleeData,
        IN LPQOS lpSQOS,
        IN LPQOS lpGQOS,
        IN DWORD dwFlags,
        OUT INT FAR *lpErrno);

    INT
    WSPListen(
        IN SOCKET s,
        IN INT backlog,
        OUT INT FAR *lpErrno);


    INT
    WSPRecv(
        IN SOCKET s,
        IN LPWSABUF lpBuffers,
        IN DWORD dwBufferCount,
        IN LPDWORD lpNumberOfBytesRecvd,
        IN OUT LPDWORD lpFlags,
        IN LPWSAOVERLAPPED lpOverlapped,
        IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
        IN LPWSATHREADID lpThreadId,
        OUT INT FAR *lpErrno);


    INT
    WSPRecvDisconnect(
        IN SOCKET s,
        IN LPWSABUF lpInboundDisconnectData,
        OUT INT FAR *lpErrno);


    INT
    WSPRecvFrom(
        IN SOCKET s,
        IN LPWSABUF lpBuffers,
        IN DWORD dwBufferCount,
        IN LPDWORD lpNumberOfBytesRecvd,
        IN OUT LPDWORD lpFlags,
        OUT  struct sockaddr FAR *  lpFrom,
        IN LPINT lpFromlen,
        IN LPWSAOVERLAPPED lpOverlapped,
        IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
        IN LPWSATHREADID lpThreadId,
        OUT INT FAR *lpErrno);


    INT
    WSPSelect(
        IN INT nfds,
        IN OUT fd_set FAR *readfds,
        IN OUT fd_set FAR *writefds,
        IN OUT fd_set FAR *exceptfds,
        IN const struct timeval FAR *timeout,
        OUT INT FAR *lpErrno);


    INT
    WSPSend(
        IN SOCKET s,
        IN LPWSABUF lpBuffers,
        IN DWORD dwBufferCount,
        OUT LPDWORD lpNumberOfBytesSent,
        IN DWORD dwFlags,
        IN LPWSAOVERLAPPED lpOverlapped,
        IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
        IN LPWSATHREADID lpThreadId,
        OUT INT FAR *lpErrno);

    INT
    WSPSendDisconnect(
        IN SOCKET s,
        IN LPWSABUF lpOutboundDisconnectData,
        OUT INT FAR *lpErrno);

    INT
    WSPSendTo(
        IN SOCKET s,
        IN LPWSABUF lpBuffers,
        IN DWORD dbBufferCount,
        IN LPDWORD lpNumberOfBytesSent,
        IN DWORD dwFlags,
        IN const struct sockaddr FAR * lpTo,
        IN INT iTolen,
        IN LPWSAOVERLAPPED lpOverlapped,
        IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
        IN LPWSATHREADID lpThreadId,
        OUT INT FAR *lpErrno);

    INT
    WSPSetSockOpt(
        IN SOCKET s,
        IN INT level,
        IN INT optname,
        IN const char FAR *optval,
        IN INT optlen,
        OUT INT FAR *lpErrno);

    INT
    WSPShutdown(
        IN SOCKET s,
        IN INT how,
        OUT INT FAR *lpErrno);

    SOCKET
    WSPSocket(
        IN int af,
        IN int type,
        IN int protocol,
        IN LPWSAPROTOCOL_INFOW lpProtocolInfo,
        IN GROUP g,
        IN DWORD dwFlags,
        OUT INT FAR *lpErrno);

    INT
    WSPStringToAddress(
        IN     LPWSTR AddressString,
        IN     INT AddressFamily,
        IN     LPWSAPROTOCOL_INFOW lpProtocolInfo,
        OUT    LPSOCKADDR lpAddress,
        IN OUT LPINT lpAddressLength,
        IN OUT LPINT lpErrno );

    DWORD_PTR
    GetCancelCallPtr();

    VOID
    Reference ();

    VOID
    Dereference ();

private:
    // Destruction should be done using dereferencing
    ~DPROVIDER();

    // Variables
    LONG             m_reference_count;
    HINSTANCE        m_library_handle;
    WSPPROC_TABLE    m_proctable;
#ifdef DEBUG_TRACING
    LPSTR            m_lib_name;
#endif
};

inline
VOID
DPROVIDER::Reference () {
    //
    // Object is created with reference count of 1
    // and is destroyed whenever it gets back to 0.
    //
    assert (m_reference_count>0);
    InterlockedIncrement (&m_reference_count);
}


inline
VOID
DPROVIDER::Dereference () {
    assert (m_reference_count>0);
    if (InterlockedDecrement (&m_reference_count)==0)
        delete this;
}

inline
DWORD_PTR
DPROVIDER::GetCancelCallPtr()
{
    return((DWORD_PTR)m_proctable.lpWSPCancelBlockingCall);
}



inline SOCKET
DPROVIDER::WSPAccept(
    IN SOCKET s,
    OUT struct sockaddr FAR *addr,
    OUT INT FAR *addrlen,
    IN LPCONDITIONPROC lpfnCondition,
    IN DWORD_PTR dwCallbackData,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Conditionally  accept a connection based on the return value of a condition
    function, and optionally create and/or join a socket group.

Arguments:

    s              - A  descriptor  identiying  a socket which is listening for
                     connections after a WSPListen().

    addr           - An optional pointer to a buffer which receives the address
                     of   the  connecting  entity,  as  known  to  the  service
                     provider.   The  exact  format  of  the  addr arguement is
                     determined  by  the  address  family  established when the
                     socket was created.

    addrlen        - An  optional  pointer  to  an  integer  which contains the
                     length of the address addr.

    lpfnCondition  - The  procedure  instance address of an optional, WinSock 2
                     client  supplied  condition  function  which  will make an
                     accept/reject  decision  based  on  the caller information
                     passed  in  as  parameters,  and optionally creaetd and/or
                     join  a  socket group by assigning an appropriate value to
                     the result parameter of this function.

    dwCallbackData - Callback data to be passed back to the WinSock 2 client as
                     a  condition  function  parameter.   This parameter is not
                     interpreted by the service provider.

    lpErrno        - A pointer to the error code.

Return Value:

    If  no  error occurs, WSPAccept() returns a value of type SOCKET which is a
    descriptor  for  the accepted socket.  Otherwise, a value of INVALID_SOCKET
    is returned, and a specific error code is available in lpErrno.

--*/
{
    SOCKET ReturnValue=INVALID_SOCKET;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPAccept,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &addr,
                       &addrlen,
                       &lpfnCondition,
                       &dwCallbackData,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPAccept(
        s,
        addr,
        addrlen,
        lpfnCondition,
        dwCallbackData,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPAccept,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &addr,
                    &addrlen,
                    &lpfnCondition,
                    &dwCallbackData,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);

}




inline INT
DPROVIDER::WSPAddressToString(
    IN     LPSOCKADDR lpsaAddress,
    IN     DWORD dwAddressLength,
    IN     LPWSAPROTOCOL_INFOW lpProtocolInfo,
    OUT    LPWSTR lpszAddressString,
    IN OUT LPDWORD lpdwAddressStringLength,
    OUT    LPINT lpErrno )
/*++

Routine Description:

    WSPAddressToString() converts a SOCKADDR structure into a human-readable
    string representation of the address.  This is intended to be used mainly
    for display purposes. If the caller wishes the translation to be done by a
    particular provider, it should supply the corresponding WSAPROTOCOL_INFOW
    struct in the lpProtocolInfo parameter.

Arguments:

    lpsaAddress - points to a SOCKADDR structure to translate into a string.

    dwAddressLength - the length of the Address SOCKADDR.

    lpProtocolInfo - (optional) the WSAPROTOCOL_INFOW struct for a particular
                     provider.

    lpszAddressString - a buffer which receives the human-readable address
                        string.

    lpdwAddressStringLength - on input, the length of the AddressString buffer.
                              On output, returns the length of  the string
                              actually copied into the buffer.

Return Value:

    The return value is 0 if the operation was successful.  Otherwise the value
    SOCKET_ERROR is returned
--*/
{
     INT ReturnValue=SOCKET_ERROR;

     assert (m_reference_count>0);
     if (PREAPINOTIFY(( DTCODE_WSPAddressToString,
                        &ReturnValue,
                        m_lib_name,
                        &lpsaAddress,
                        &dwAddressLength,
                        &lpProtocolInfo,
                        &lpszAddressString,
                        &lpdwAddressStringLength,
                        &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPAddressToString(
        lpsaAddress,
        dwAddressLength,
        lpProtocolInfo,
        lpszAddressString,
        lpdwAddressStringLength,
        lpErrno);


    POSTAPINOTIFY(( DTCODE_WSPAddressToString,
                    &ReturnValue,
                    m_lib_name,
                    &lpsaAddress,
                    &dwAddressLength,
                    &lpProtocolInfo,
                    &lpszAddressString,
                    &lpdwAddressStringLength,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}





inline INT
DPROVIDER::WSPAsyncSelect(
    IN SOCKET s,
    IN HWND hWnd,
    IN unsigned int wMsg,
    IN long lEvent,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Request  Windows  message-based  event notification of network events for a
    socket.

Arguments:

    s       - A  descriptor identiying a socket for which event notification is
              required.

    hWnd    - A  handle  identifying  the window which should receive a message
              when a network event occurs.

    wMsg    - The message to be sent when a network event occurs.

    lEvent  - bitmask  which specifies a combination of network events in which
              the WinSock client is interested.

    lpErrno - A pointer to the error code.

Return Value:

    The  return  value  is 0 if the WinSock client's declaration of interest in
    the  netowrk event set was successful.  Otherwise the value SOCKET_ERROR is
    returned, and a specific error code is available in lpErrno.

--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPAsyncSelect,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &hWnd,
                       &wMsg,
                       &lEvent,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPAsyncSelect(
        s,
        hWnd,
        wMsg,
        lEvent,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPAsyncSelect,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &hWnd,
                    &wMsg,
                    &lEvent,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);

}



inline INT
DPROVIDER::WSPBind(
    IN SOCKET s,
    IN const struct sockaddr FAR *name,
    IN INT namelen,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Associate a local address (i.e. name) with a socket.

Arguments:

    s       - A descriptor identifying an unbound socket.

    name    - The  address  to assign to the socket.  The sockaddr structure is
              defined as follows:

              struct sockaddr {
                  u_short sa_family;
                  char    sa_data[14];
              };

              Except  for  the sa_family field,
sockaddr contents are epxressed
              in network byte order.

    namelen - The length of the name.

    lpErrno - A pointer to the error code.

Return Value:

    If   no   erro   occurs,  WSPBind()  returns  0.   Otherwise, it  returns
    SOCKET_ERROR, and a specific error code is available in lpErrno.

--*/
{
    INT ReturnValue=SOCKET_ERROR;
    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPBind,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &name,
                       &namelen,
                       &lpErrno)) ) {

        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPBind(
        s,
        name,
        namelen,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPBind,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &name,
                    &namelen,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);

}



inline INT
DPROVIDER::WSPCancelBlockingCall(OUT INT FAR *lpErrno)
/*++
Routine Description:

    Cancel a blocking call which is currently in progress.

Arguments:

    lpErrno - A pointer to the error code.

Return Value:

    The  value  returned  by  WSPCancelBlockingCall() is 0 if the operation was
    successfully canceled.  Otherwise the value SOCKET_ERROR is returned,
and a
    specific error code is available in lpErrno.

--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPCancelBlockingCall,
                       &ReturnValue,
                       m_lib_name,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPCancelBlockingCall(
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPCancelBlockingCall,
                    &ReturnValue,
                    m_lib_name,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);

}



inline INT
DPROVIDER::WSPCloseSocket(
    IN SOCKET s,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Close a socket.

Arguments:

    s       - A descriptor identifying a socket.

    lpErrno - A pointer to the error code.

Return Value:

    If  no  erro  occurs, WSPCloseSocket()  returns  0.  Otherwise, a value of
    SOCKET_ERROR  is  returned,  and  a  specific  error  code  is available in
    lpErrno.

--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPCloseSocket,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPCloseSocket(
        s,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPCloseSocket,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);

}



inline INT
DPROVIDER::WSPConnect(
    IN SOCKET s,
    IN const struct sockaddr FAR *name,
    IN INT namelen,
    IN LPWSABUF lpCallerData,
    IN LPWSABUF lpCalleeData,
    IN LPQOS lpSQOS,
    IN LPQOS lpGQOS,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Establish a connection to a peer,
exchange connect data,
and specify needed
    quality of service based on the supplied flow spec.

Arguments:

    s            - A descriptor identifying an unconnected socket.

    name         - The name of the peer to which the socket is to be connected.

    namelen      - The length of the name.

    lpCallerData - A  pointer to the user data that is to be transferred to the
                   peer during connection established.

    lpCalleeData - A pointer to a buffer into which may be copied any user data
                   received from the peer during connection establishment.

    lpSQOS       - A  pointer  to  the  flow  specs  for socket s, one for each
                   direction.

    lpGQOS       - A  pointer  to  the  flow  specs  for  the  socket group (if
                   applicable).

    lpErrno      - A pointer to the error code.

Return Value:

    If  no  error  occurs, WSPConnect()  returns ERROR_SUCCESS.  Otherwise, it
    returns SOCKET_ERROR, and a specific erro rcode is available in lpErrno.

--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPConnect,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &name,
                       &namelen,
                       &lpCallerData,
                       &lpCalleeData,
                       &lpSQOS,
                       &lpGQOS,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPConnect(
        s,
        name,
        namelen,
        lpCallerData,
        lpCalleeData,
        lpSQOS,
        lpGQOS,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPConnect,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &name,
                    &namelen,
                    &lpCallerData,
                    &lpCalleeData,
                    &lpSQOS,
                    &lpGQOS,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);

}



inline INT
DPROVIDER::WSPDuplicateSocket(
    IN SOCKET s,
    IN DWORD dwProcessID,
    IN LPWSAPROTOCOL_INFOW lpProtocolInfo,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    descriptor for a shared socket.


Arguments:

    s              - Specifies the local socket descriptor.

    dwProcessID    - Specifies  the  ID  of  the  target  process for which the
                     shared socket will be used.

    lpProtocolInfo - A  pointer  to  a  buffer  allocated by the client that is
                     large enough to contain a WSAPROTOCOL_INFOW struct.  The
                     service  provider copies the protocol info struct contents
                     to this buffer.

    lpErrno        - A pointer to the error code

Return Value:

    If  no  error  occurs, WPSDuplicateSocket()  returns zero.  Otherwise, the
    value of SOCKET_ERROR is returned, and a specific error number is available
    in lpErrno.

--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPDuplicateSocket,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &dwProcessID,
                       &lpProtocolInfo,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPDuplicateSocket(
        s,
        dwProcessID,
        lpProtocolInfo,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPDuplicateSocket,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &dwProcessID,
                    &lpProtocolInfo,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);

}



inline INT
DPROVIDER::WSPEnumNetworkEvents(
    IN SOCKET s,
    OUT WSAEVENT hEventObject,
    OUT LPWSANETWORKEVENTS lpNetworkEvents,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Report occurrences of network events for the indicated socket.

Arguments:

    s               - A descriptor identifying the socket.

    hEventObject    - An optional handle identifying an associated event object
                      to be reset.

    lpNetworkEvents - A  pointer  to  a WSANETWORKEVENTS struct which is filled
                      with   a  record  of  occurred  network  events  and  any
                      associated error codes.

    lpErrno         - A pointer to the error code.

Return Value:

    The  return  value  is  ERROR_SUCCESS  if  the  operation  was  successful.
    Otherwise  the  value SOCKET_ERROR is returned, and a specific error number
    is available in lpErrno.

--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPEnumNetworkEvents,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &hEventObject,
                       &lpNetworkEvents,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPEnumNetworkEvents(
        s,
        hEventObject,
        lpNetworkEvents,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPEnumNetworkEvents,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &hEventObject,
                    &lpNetworkEvents,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);

}



inline INT
DPROVIDER::WSPEventSelect(
    IN SOCKET s,
    IN OUT WSAEVENT hEventObject,
    IN long lNetworkEvents,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Specify  an  event object to be associated with the supplied set of network
    events.

Arguments:

    s              - A descriptor identifying the socket.

    hEventObject   - A  handle  identifying  the  event object to be associated
                     with the supplied set of network events.

    lNetworkEvents - A  bitmask  which  specifies  the  combination  of network
                     events in which the WinSock client has interest.

    lpErrno        - A pointer to the error code.

Return Value:

    The return value is 0 if the WinSock client's specification of the network
    events and the associated event object was successful. Otherwise the value
    SOCKET_ERROR is returned, and a specific error number is available in
    lpErrno

--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPEventSelect,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &hEventObject,
                       &lNetworkEvents,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPEventSelect(
        s,
        hEventObject,
        lNetworkEvents,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPEventSelect,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &hEventObject,
                    &lNetworkEvents,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);

}



inline INT
DPROVIDER::WSPGetOverlappedResult(
    IN SOCKET s,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPDWORD lpcbTransfer,
    IN BOOL fWait,
    OUT LPDWORD lpdwFlags,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Returns the results of an overlapped operation on the specified socket.

Arguments:

    s            - Identifies  the  socket.   This  is the same socket that was
                   specified  when  the  overlapped  operation was started by a
                   call to WSPRecv(), WSPRecvFrom(), WSPSend(), WSPSendTo(), or
                   WSPIoctl().

    lpOverlapped - Points to a WSAOVERLAPPED structure that was specified
                   when the overlapped operation was started.

    lpcbTransfer - Points to a 32-bit variable that receives the number of
                   bytes that were actually transferred by a send or receive
                   operation, or by WSPIoctl().

    fWait        - Specifies  whether  the function should wait for the pending
                   overlapped  operation  to  complete.   If TRUE, the function
                   does  not return until the operation has been completed.  If
                   FALSE  and  the  operation  is  still  pending, the function
                   returns FALSE and lperrno is WSA_IO_INCOMPLETE.

    lpdwFlags    - Points  to  a  32-bit variable that will receive one or more
                   flags   that  supplement  the  completion  status.   If  the
                   overlapped   operation   was   initiated  via  WSPRecv()  or
                   WSPRecvFrom(), this parameter will contain the results value
                   for lpFlags parameter.

    lpErrno      - A pointer to the error code.

Return Value:

    If WSPGetOverlappedResult() succeeds,the return value is TRUE.  This means
    that the overlapped operation has completed successfully and that the value
    pointed  to  by lpcbTransfer has been updated.  If WSPGetOverlappedResult()
    returns  FALSE,  this  means  that  either the overlapped operation has not
    completed  or  the  overlapped operation completed but with errors, or that
    completion  status  could  not  be  determined due to errors in one or more
    parameters  to  WSPGetOverlappedResult().  On failure, the value pointed to
    by  lpcbTransfer  will  not be updated.  lpErrno indicates the cause of the
    failure (either of WSPGetOverlappedResult() or of the associated overlapped
    operation).

--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPGetOverlappedResult,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &lpOverlapped,
                       &lpcbTransfer,
                       &fWait,
                       &lpdwFlags,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPGetOverlappedResult(
        s,
        lpOverlapped,
        lpcbTransfer,
        fWait,
        lpdwFlags,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPGetOverlappedResult,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &lpOverlapped,
                    &lpcbTransfer,
                    &fWait,
                    &lpdwFlags,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}



inline INT
DPROVIDER::WSPGetPeerName(
    IN SOCKET s,
    OUT struct sockaddr FAR *name,
    OUT INT FAR *namelen,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Get the address of the peer to which a socket is connected.

Arguments:

    s       - A descriptor identifying a connected socket.

    name    - A  pointer  to  the structure which is to receive the name of the
              peer.

    namelen - A  pointer  to  an integer which, on input, indicates the size of
              the  structure  pointed  to  by name, and on output indicates the
              size of the returned name.

    lpErrno - A pointer to the error code.

Return Value:

    If  no  error occurs, WSPGetPeerName() returns ERROR_SUCCESS.  Otherwise, a
    value  of  SOCKET_ERROR is returned, and a specific error code is available
    in lpErrno

--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPGetPeerName,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &name,
                       &namelen,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPGetPeerName(
        s,
        name,
        namelen,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPGetPeerName,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &name,
                    &namelen,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}



inline INT
DPROVIDER::WSPGetQOSByName(
    IN SOCKET s,
    IN LPWSABUF lpQOSName,
    IN LPQOS lpQOS,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Initializes a QOS structure based on a named template.

Arguments:

    s         - A descriptor identifying a socket.

    lpQOSName - Specifies the QOS template name.

    lpQOS     - A pointer to the QOS structure to be filled.

    lpErrno   - A pointer to the error code.

Return Value:

    If the function succeeds, the return value is TRUE.  If the function fails,
    the  return  value  is  FALSE, and  a  specific error code is available in
    lpErrno.

--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPGetQOSByName,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &lpQOSName,
                       &lpQOS,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPGetQOSByName(
        s,
        lpQOSName,
        lpQOS,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPGetQOSByName,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &lpQOSName,
                    &lpQOS,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}



inline INT
DPROVIDER::WSPGetSockName(
    IN SOCKET s,
    OUT struct sockaddr FAR *name,
    OUT INT FAR *namelen,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Get the local name for a socket.

Arguments:

    s       - A descriptor identifying a bound socket.

    name    - A pointer to a structure used to supply the address (name) of the
              socket.

    namelen - A  pointer  to  an integer which, on input, indicates the size of
              the  structure  pointed  to  by name, and on output indicates the
              size of the returned name

    lpErrno - A Pointer to the error code.

Return Value:

    If  no  error occurs, WSPGetSockName() returns ERROR_SUCCESS.  Otherwise, a
    value  of  SOCKET_ERROR is returned, and a specific error code is available
    in lpErrno.

--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPGetSockName,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &name,
                       &namelen,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPGetSockName(
        s,
        name,
        namelen,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPGetSockName,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &name,
                    &namelen,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}



inline INT
DPROVIDER::WSPGetSockOpt(
    IN SOCKET s,
    IN INT level,
    IN INT optname,
    OUT char FAR *optval,
    OUT INT FAR *optlen,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Retrieve a socket option.

Arguments:

    s       - A descriptor identifying a socket.

    level   - The  level  at  which the option is defined; the supported levels
              include SOL_SOCKET (See annex for more protocol-specific levels.)

    optname - The socket option for which the value is to be retrieved.

    optval  - A  pointer  to  the  buffer  in which the value for the requested
              option is to be returned.

    optlen  - A pointer to the size of the optval buffer.

    lpErrno - A pointer to the error code.

Return Value:

    If  no  error  occurs,  WSPGetSockOpt()  returns  0.  Otherwise, a value of
    SOCKET_ERROR  is  returned,  and  a  specific  error  code  is available in
    lpErrno.

--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPGetSockOpt,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &level,
                       &optname,
                       &optval,
                       &optlen,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPGetSockOpt(
        s,
        level,
        optname,
        optval,
        optlen,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPGetSockOpt,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &level,
                    &optname,
                    &optval,
                    &optlen,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}


inline INT
DPROVIDER::WSPIoctl(
    IN SOCKET s,
    IN DWORD dwIoControlCode,
    IN LPVOID lpvInBuffer,
    IN DWORD cbInBuffer,
    IN LPVOID lpvOutBuffer,
    IN DWORD cbOutBuffer,
    IN LPDWORD lpcbBytesReturned,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
    IN LPWSATHREADID lpThreadId,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Control the mode of a socket.

Arguments:

    s                   - Handle to a socket

    dwIoControlCode     - Control code of operation to perform

    lpvInBuffer         - Address of input buffer

    cbInBuffer          - Size of input buffer

    lpvOutBuffer        - Address of output buffer

    cbOutBuffer         - Size of output buffer

    lpcbBytesReturned   - A pointer to the size of output buffer's contents.

    lpOverlapped        - Address of WSAOVERLAPPED structure

    lpCompletionRoutine - A  pointer  to the completion routine called when the
                          operation has been completed.

    lpThreadId          - A  pointer to a thread ID structure to be used by the
                          provider

    lpErrno             - A pointer to the error code.

Return Value:

    If  no error occurs and the operation has completed immediately, WSPIoctl()
    returns  0.   Note  that in this case the completion routine, if specified,
    will  have  already  been  queued.   Otherwise, a value of SOCKET_ERROR is
    returned, and  a  specific  error code is available in lpErrno.  The error
    code  WSA_IO_PENDING  indicates  that  an  overlapped  operation  has  been
    successfully  initiated  and  that  conpletion will be indicated at a later
    time.   Any  other  error  code  indicates that no overlapped operation was
    initiated and no completion indication will occur.

--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPIoctl,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &dwIoControlCode,
                       &lpvInBuffer,
                       &cbInBuffer,
                       &lpvOutBuffer,
                       &cbOutBuffer,
                       &lpcbBytesReturned,
                       &lpOverlapped,
                       &lpCompletionRoutine,
                       &lpThreadId,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPIoctl(
        s,
        dwIoControlCode,
        lpvInBuffer,
        cbInBuffer,
        lpvOutBuffer,
        cbOutBuffer,
        lpcbBytesReturned,
        lpOverlapped,
        lpCompletionRoutine,
        lpThreadId,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPIoctl,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &dwIoControlCode,
                    &lpvInBuffer,
                    &cbInBuffer,
                    &lpvOutBuffer,
                    &cbOutBuffer,
                    &lpcbBytesReturned,
                    &lpOverlapped,
                    &lpCompletionRoutine,
                    &lpThreadId,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}



inline SOCKET
DPROVIDER::WSPJoinLeaf(
    IN SOCKET s,
    IN const struct sockaddr FAR *name,
    IN INT namelen,
    IN LPWSABUF lpCallerData,
    IN LPWSABUF lpCalleeData,
    IN LPQOS lpSQOS,
    IN LPQOS lpGQOS,
    IN DWORD dwFlags,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Join  a  leaf  node  into  a multipoint session, exchange connect data, and
    specify needed quality of service based on the supplied flow specs.

Arguments:

    s            - A descriptor identifying a multipoint socket.

    name         - The name of the peer to which the socket is to be joined.

    namelen      - The length of the name.

    lpCallerData - A  pointer to the user data that is to be transferred to the
                   peer during multipoint session establishment.

    lpCalleeData - A  pointer  to  the user data that is to be transferred back
                   from the peer during multipoint session establishment.

    lpSQOS       - A  pointer  to  the  flow  specs  for socket s, one for each
                   direction.

    lpGQOS       - A  pointer  to  the  flow  specs  for  the  socket group (if
                   applicable).

    dwFlags      - Flags  to  indicate  that  the socket is acting as a sender,
                   receiver, or both.

    lpErrno      - A pointer to the error code.

Return Value:

    If no error occurs,
WSPJoinLeaf() returns a value of type SOCKET which is a
    descriptor  for the newly created multipoint socket.  Otherwise,a value of
    INVALID_SOCKET  is  returned, and  a  specific  error code is available in
    lpErrno.

--*/
{
    SOCKET ReturnValue=INVALID_SOCKET;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPJoinLeaf,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &name,
                       &namelen,
                       &lpCallerData,
                       &lpCalleeData,
                       &lpSQOS,
                       &lpGQOS,
                       &dwFlags,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPJoinLeaf(
        s,
        name,
        namelen,
        lpCallerData,
        lpCalleeData,
        lpSQOS,
        lpGQOS,
        dwFlags,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPJoinLeaf,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &name,
                    &namelen,
                    &lpCallerData,
                    &lpCalleeData,
                    &lpSQOS,
                    &lpGQOS,
                    &dwFlags,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);

}



inline INT
DPROVIDER::WSPListen(
    IN SOCKET s,
    IN INT backlog,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Establish a socket to listen for incoming connections.

Arguments:

    s       - A descriptor identifying a bound,
unconnected socket.

    backlog - The  maximum length to which the queue of pending connections may
              grow.   If  this  value  is  SOMAXCONN,
then the service provider
              should set the backlog to a maximum "reasonable" value.

    lpErrno - A pointer to the error code.

Return Value:

    If  no  error  occurs, WSPListen()  returns  0.   Otherwise, a  value  of
    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in
    lpErrno.

--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPListen,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &backlog,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPListen(
        s,
        backlog,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPListen,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &backlog,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);

}



inline INT
DPROVIDER::WSPRecv(
    IN SOCKET s,
    IN LPWSABUF lpBuffers,
    IN DWORD dwBufferCount,
    IN LPDWORD lpNumberOfBytesRecvd,
    IN OUT LPDWORD lpFlags,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
    IN LPWSATHREADID lpThreadId,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Receive data on a socket.

Arguments:

    s                    - A descriptor identifying a connected socket.

    lpBuffers            - A  pointer  to  an array of WSABUF structures.  Each
                           WSABUF  structure contains a pointer to a buffer and
                           the length of the buffer.

    dwBufferCount        - The  number  of  WSABUF  structures in the lpBuffers
                           array.

    lpNumberOfBytesRecvd - A  pointer  to  the number of bytes received by this
                           call.

    lpFlags              - A pointer to flags.

    lpOverlapped         - A pointer to a WSAOVERLAPPED structure.

    lpCompletionRoutine  - A  pointer to the completion routine called when the
                           receive operation has been completed.

    lpThreadId           - A pointer to a thread ID structure to be used by the
                           provider in a subsequent call to WPUQueueApc().

    lpErrno              - A pointer to the error code.

Return Value:

    If  no  error  occurs  and the receive operation has completed immediately,
    WSPRecv() returns the number of bytes received.  If the connection has been
    closed, it  returns  0.  Note that in this case the completion routine, if
    specified,  will   have  already  been  queued.   Otherwise, a  value  of
    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in
    lpErrno.   The  error  code WSA_IO_PENDING indicates that the overlapped an
    operation  has  been  successfully  initiated  and  that completion will be
    indicated  at  a  later  time.   Any  other  error  code  indicates that no
    overlapped  operations  was  initiated  and  no  completion indication will
    occur.
--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPRecv,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &lpBuffers,
                       &dwBufferCount,
                       &lpNumberOfBytesRecvd,
                       &lpFlags,
                       &lpOverlapped,
                       &lpCompletionRoutine,
                       &lpThreadId,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPRecv(
        s,
        lpBuffers,
        dwBufferCount,
        lpNumberOfBytesRecvd,
        lpFlags,
        lpOverlapped,
        lpCompletionRoutine,
        lpThreadId,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPRecv,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &lpBuffers,
                    &dwBufferCount,
                    &lpNumberOfBytesRecvd,
                    &lpFlags,
                    &lpOverlapped,
                    &lpCompletionRoutine,
                    &lpThreadId,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}



inline INT
DPROVIDER::WSPRecvDisconnect(
    IN SOCKET s,
    IN LPWSABUF lpInboundDisconnectData,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Terminate  reception  on  a socket, and retrieve the disconnect data if the
    socket is connection-oriented.

Arguments:

    s                       - A descriptor identifying a socket.

    lpInboundDisconnectData - A  pointer to a buffer into which disconnect data
                              is to be copied.

    lpErrno                 - A pointer to the error code.

Return Value:

    If  no error occurs, WSPRecvDisconnect() returns ERROR_SUCCESS.  Otherwise,
    a value of SOCKET_ERROR is returned, and a specific error code is available
    in lpErrno.

--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPRecvDisconnect,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &lpInboundDisconnectData,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPRecvDisconnect(
        s,
        lpInboundDisconnectData,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPRecvDisconnect,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &lpInboundDisconnectData,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);

}



inline INT
DPROVIDER::WSPRecvFrom(
    IN  SOCKET s,
    IN  LPWSABUF lpBuffers,
    IN  DWORD dwBufferCount,
    IN  LPDWORD lpNumberOfBytesRecvd,
    IN  OUT LPDWORD lpFlags,
    OUT struct sockaddr FAR *  lpFrom,
    IN  LPINT lpFromlen,
    IN  LPWSAOVERLAPPED lpOverlapped,
    IN  LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
    IN LPWSATHREADID lpThreadId,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Receive a datagram and store the source address.

Arguments:

    s                    - A descriptor identifying a socket.

    lpBuffers            - A  pointer  to  an array of WSABUF structures.  Each
                           WSABUF  structure contains a pointer to a buffer and
                           the length of the buffer.

    dwBufferCount        - The  number  of  WSABUF  structures in the lpBuffers
                           array.

    lpNumberOfBytesRecvd - A  pointer  to  the number of bytes received by this
                           call.

    lpFlags              - A pointer to flags.

    lpFrom               - An  optional pointer to a buffer which will hold the
                           source address upon the completion of the overlapped
                           operation.

    lpFromlen            - A  pointer  to the size of the from buffer, required
                           only if lpFrom is specified.

    lpOverlapped         - A pointer to a WSAOVERLAPPED structure.

    CompletionRoutine    - A  pointer to the completion routine called when the
                           receive operation has been completed.

    lpThreadId           - A pointer to a thread ID structure to be used by the
                           provider in a subsequent call to WPUQueueApc().

    lpErrno              - A pointer to the error code.

Return Value:

    If  no  error  occurs  and the receive operation has completed immediately,
    WSPRecvFrom()  returns the number of bytes received.  If the connection has
    been  closed, it returns 0.  Note that in this case the completion routine,
    if  specified  will  have  already  been  queued.   Otherwise,  a  value of
    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in
    lpErrno.   The  error  code  WSA_IO_PENDING  indicates  that the overlapped
    operation  has  been  successfully  initiated  and  that completion will be
    indicated  at  a  later  time.   Any  other  error  code  indicates that no
    overlapped  operations  was  initiated  and  no  completion indication will
    occur.

--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPRecvFrom,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &lpBuffers,
                       &dwBufferCount,
                       &lpNumberOfBytesRecvd,
                       &lpFlags,
                       &lpFrom,
                       &lpFromlen,
                       &lpOverlapped,
                       &lpCompletionRoutine,
                       &lpThreadId,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPRecvFrom(
        s,
        lpBuffers,
        dwBufferCount,
        lpNumberOfBytesRecvd,
        lpFlags,
        lpFrom,
        lpFromlen,
        lpOverlapped,
        lpCompletionRoutine,
        lpThreadId,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPRecvFrom,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &lpBuffers,
                    &dwBufferCount,
                    &lpNumberOfBytesRecvd,
                    &lpFlags,
                    &lpFrom,
                    &lpFromlen,
                    &lpOverlapped,
                    &lpCompletionRoutine,
                    &lpThreadId,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}



inline INT
DPROVIDER::WSPSelect(
    IN INT nfds,
    IN OUT fd_set FAR *readfds,
    IN OUT fd_set FAR *writefds,
    IN OUT fd_set FAR *exceptfds,
    IN const struct timeval FAR *timeout,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Determine the status of one or more sockets.

Arguments:

    nfds      - This  argument  is  ignored  and  included only for the sake of
                compatibility.

    readfds   - An  optional  pointer  to  a  set  of sockets to be checked for
                readability.

    writefds  - An  optional  pointer  to  a  set  of sockets to be checked for
                writability

    exceptfds - An  optional  pointer  to  a  set  of sockets to be checked for
                errors.

    timeout   - The  maximum  time  for  WSPSelect()  to  wait, or  NULL for a
                blocking operation.

    lpErrno   - A pointer to the error code.

Return Value:

    WSPSelect()  returns  the  total  number of descriptors which are ready and
    contained  in  the  fd_set  structures, 0  if  the  time limit expired, or
    SOCKET_ERROR  if an error occurred.  If the return value is SOCKET_ERROR, a
    specific error code is available in lpErrno.

--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPSelect,
                       &ReturnValue,
                       m_lib_name,
                       &nfds,
                       &readfds,
                       &writefds,
                       &exceptfds,
                       &timeout,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPSelect(
        nfds,
        readfds,
        writefds,
        exceptfds,
        timeout,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPSelect,
                    &ReturnValue,
                    m_lib_name,
                    &nfds,
                    &readfds,
                    &writefds,
                    &exceptfds,
                    &timeout,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}




inline INT
DPROVIDER::WSPSend(
    IN SOCKET s,
    IN LPWSABUF lpBuffers,
    IN DWORD dwBufferCount,
    IN LPDWORD lpNumberOfBytesSent,
    IN DWORD dwFlags,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
    IN LPWSATHREADID lpThreadId,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Send data on a connected socket.

Arguments:

    s                   - A descriptor identifying a connected socket.

    lpBuffers           - A  pointer  to  an  array of WSABUF structures.  Each
                          WSABUF  structure  contains a pointer to a buffer and
                          the length of the buffer.

    dwBufferCount       - The  number  of  WSABUF  structures  in the lpBuffers
                          array.

    lpNumberOfBytesSent - A pointer to the number of bytes sent by this call.

    dwFlags             - Flags.

    lpOverlapped        - A pointer to a WSAOVERLAPPED structure.

    lpCompletionRoutine - A  pointer  to the completion routine called when the
                          send operation has been completed.

    lpThreadId          - A  pointer to a thread ID structure to be used by the
                          provider in a subsequent call to WPUQueueApc().

    lpErrno             - A pointer to the error code.

Return Value:

    If  no  error  occurs  and  the  send  operation has completed immediately,
    WSPSend() returns the number of bytes received.  If the connection has been
    closed,  it  returns  0.  Note that in this case the completion routine, if
    specified, will   have  already  been  queued.   Otherwise, a  value  of
    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in
    lpErrno.   The  error  code  WSA_IO_PENDING  indicates  that the overlapped
    operation  has  been  successfully  initiated  and  that completion will be
    indicated  at  a  later  time.   Any  other  error  code  indicates that no
    overlapped operation was initiated and no completion indication will occur.

--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPSend,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &lpBuffers,
                       &dwBufferCount,
                       &lpNumberOfBytesSent,
                       &dwFlags,
                       &lpOverlapped,
                       &lpCompletionRoutine,
                       &lpThreadId,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPSend(
        s,
        lpBuffers,
        dwBufferCount,
        lpNumberOfBytesSent,
        dwFlags,
        lpOverlapped,
        lpCompletionRoutine,
        lpThreadId,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPSend,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &lpBuffers,
                    &dwBufferCount,
                    &lpNumberOfBytesSent,
                    &dwFlags,
                    &lpOverlapped,
                    &lpCompletionRoutine,
                    &lpThreadId,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}



inline INT
DPROVIDER::WSPSendDisconnect(
    IN SOCKET s,
    IN LPWSABUF lpOutboundDisconnectData,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Initiate  termination  of the connection for the socket and send disconnect
    data.

Arguments:

    s                        - A descriptor identifying a socket.

    lpOutboundDisconnectData - A pointer to the outgoing disconnect data.

    lpErrno                  - A pointer to the error code.

Return Value:

    If  no  error occurs, WSPSendDisconnect() returns 0.  Otherwise, a value of
    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in
    lpErrno.

--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPSendDisconnect,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &lpOutboundDisconnectData,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPSendDisconnect(
        s,
        lpOutboundDisconnectData,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPSendDisconnect,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &lpOutboundDisconnectData,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);

}



inline INT
DPROVIDER::WSPSendTo(
    IN SOCKET s,
    IN LPWSABUF lpBuffers,
    IN DWORD dwBufferCount,
    IN LPDWORD lpNumberOfBytesSent,
    IN DWORD dwFlags,
    IN const struct sockaddr FAR *  lpTo,
    IN INT iTolen,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
    IN LPWSATHREADID lpThreadId,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Send data to a specific destination using overlapped I/O.

Arguments:

    s                   - A descriptor identifying a socket.

    lpBuffers           - A  pointer  to  an  array of WSABUF structures.  Each
                          WSABUF  structure  contains a pointer to a buffer and
                          the length of the buffer.

    dwBufferCount       - The  number  of  WSABUF  structures  in the lpBuffers
                          array.

    lpNumberOfBytesSent - A pointer to the number of bytes sent by this call.

    dwFlags             - Flags.

    lpTo                - An  optional  pointer  to  the  address of the target
                          socket.

    iTolen              - The size of the address in lpTo.

    lpOverlapped        - A pointer to a WSAOVERLAPPED structure.

    lpCompletionRoutine - A  pointer  to the completion routine called when the
                          send operation has been completed.

    lpThreadId          - A  pointer to a thread ID structure to be used by the
                          provider in a subsequent call to WPUQueueApc().

    lpErrno             - A pointer to the error code.

Return Value:

    If  no  error  occurs  and the receive operation has completed immediately,
    WSPSendTo()  returns  the  number of bytes received.  If the connection has
    been  closed,it returns 0.  Note that in this case the completion routine,
    if  specified, will  have  already  been  queued.   Otherwise, a value of
    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in
    lpErrno.   The  error  code  WSA_IO_PENDING  indicates  that the overlapped
    operation  has  been  successfully  initiated  and  that completion will be
    indicated  at  a  later  time.   Any  other  error  code  indicates that no
    overlapped operation was initiated and no completion indication will occur.

--*/


{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPSendTo,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &lpBuffers,
                       &dwBufferCount,
                       &lpNumberOfBytesSent,
                       &dwFlags,
                       &lpTo,
                       &iTolen,
                       &lpOverlapped,
                       &lpCompletionRoutine,
                       &lpThreadId,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPSendTo(
        s,
        lpBuffers,
        dwBufferCount,
        lpNumberOfBytesSent,
        dwFlags,
        lpTo,
        iTolen,
        lpOverlapped,
        lpCompletionRoutine,
        lpThreadId,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPSendTo,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &lpBuffers,
                    &dwBufferCount,
                    &lpNumberOfBytesSent,
                    &dwFlags,
                    &lpTo,
                    &iTolen,
                    &lpOverlapped,
                    &lpCompletionRoutine,
                    &lpThreadId,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}


inline INT
DPROVIDER::WSPSetSockOpt(
    IN SOCKET s,
    IN INT level,
    IN INT optname,
    IN const char FAR *optval,
    IN INT optlen,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Set a socket option.

Arguments:

    s       - A descriptor identifying a socket.

    level   - The  level  at  which the option is defined; the supported levels
              include   SOL_SOCKET.   (See  annex  for  more  protocol-specific
              levels.)

    optname - The socket option for which the value is to be set.

    optval  - A  pointer  to  the  buffer  in which the value for the requested
              option is supplied.

    optlen  - The size of the optval buffer.

    lpErrno - A pointer to the error code.

Return Value:

    If  no  error  occurs, WSPSetSockOpt()  returns  0.  Otherwise, a value of
    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in
    lpErrno.

--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPSetSockOpt,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &level,
                       &optname,
                       &optval,
                       &optlen,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPSetSockOpt(
        s,
        level,
        optname,
        optval,
        optlen,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPSetSockOpt,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &level,
                    &optname,
                    &optval,
                    &optlen,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);

}



inline INT
DPROVIDER::WSPShutdown(
    IN SOCKET s,
    IN INT how,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Disable sends and/or receives on a socket.

Arguments:

    s       - A descriptor identifying a socket.

    how     - A  flag  that describes what types of operation will no longer be
              allowed.

    lpErrno - A pointer to the error code.

Return Value:

    If  no  error  occurs, WSPShutdown()  returns  0.   Otherwise, a value of
    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in
    lpErrno.

--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPShutdown,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &how,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPShutdown(
        s,
        how,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPShutdown,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &how,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}



inline SOCKET
DPROVIDER::WSPSocket(
    IN int af,
    IN int type,
    IN int protocol,
    IN LPWSAPROTOCOL_INFOW lpProtocolInfo,
    IN GROUP g,
    IN DWORD dwFlags,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Initialize  internal  data  and  prepare sockets for usage.  Must be called
    before any other socket routine.

Arguments:

    lpProtocolInfo - Supplies  a pointer to a WSAPROTOCOL_INFOW struct that
                     defines  the characteristics of the socket to be created.

    g              - Supplies  the identifier of the socket group which the new
                     socket is to join.

    dwFlags        - Supplies the socket attribute specification.

    lpErrno        - Returns the error code

Return Value:

    WSPSocket() returns zero if successful.  Otherwise it returns an error code
    as outlined in the SPI.

--*/
{
    SOCKET ReturnValue=INVALID_SOCKET;

    assert (m_reference_count>0);
    // Debug/Trace stuff
    if (PREAPINOTIFY(( DTCODE_WSPSocket,
                       &ReturnValue,
                       m_lib_name,
                       &af,
                       &type,
                       &protocol,
                       &lpProtocolInfo,
                       &g,
                       &dwFlags,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    // Actual code...
    ReturnValue = m_proctable.lpWSPSocket(
        af,
        type,
        protocol,
        lpProtocolInfo,
        g,
        dwFlags,
        lpErrno);


    // Debug/Trace stuff
    POSTAPINOTIFY(( DTCODE_WSPSocket,
                    &ReturnValue,
                    m_lib_name,
                    &af,
                    &type,
                    &protocol,
                    &lpProtocolInfo,
                    &g,
                    &dwFlags,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}




inline INT
DPROVIDER::WSPStringToAddress(
    IN     LPWSTR AddressString,
    IN     INT AddressFamily,
    IN     LPWSAPROTOCOL_INFOW lpProtocolInfo,
    OUT    LPSOCKADDR lpAddress,
    IN OUT LPINT lpAddressLength,
    IN OUT LPINT lpErrno )
/*++

Routine Description:

    WSPStringToAddress() converts a human-readable string to a socket address
    structure (SOCKADDR) suitable for pass to Windows Sockets routines which
    take such a structure.  If the caller wishes the translation to be done by
    a particular provider, it should supply the corresponding WSAPROTOCOL_INFOW
    struct in the lpProtocolInfo parameter.

Arguments:

    AddressString - points to the zero-terminated human-readable string to
                    convert.

    AddressFamily - the address family to which the string belongs.

    lpProtocolInfo - (optional) the WSAPROTOCOL_INFOW struct for a particular
                     provider.

    Address - a buffer which is filled with a single SOCKADDR structure.

    lpAddressLength - The length of the Address buffer.  Returns the size of
                      the resultant SOCKADDR structure.

Return Value:

    The return value is 0 if the operation was successful.  Otherwise the value
    SOCKET_ERROR is returned.

--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPStringToAddress,
                        &ReturnValue,
                        m_lib_name,
                        &AddressString,
                        &AddressFamily,
                        &lpProtocolInfo,
                        &lpAddress,
                        &lpAddressLength,
                        &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPStringToAddress(
        AddressString,
        AddressFamily,
        lpProtocolInfo,
        lpAddress,
        lpAddressLength,
        lpErrno);


    POSTAPINOTIFY(( DTCODE_WSPStringToAddress,
                    &ReturnValue,
                    m_lib_name,
                    &AddressString,
                    &AddressFamily,
                    &lpProtocolInfo,
                    &lpAddress,
                    &lpAddressLength,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\inc\dthook.h ===
/*++

  Copyright (c) 1995 Intel Corp

  Module Name:

    dthook.h

  Abstract:

    Header file containing definitions, function prototypes, and other
    stuff for the Debug/Trace hooks in WinSock 2.

  Author:

    Michael A. Grafton

--*/

#ifndef DTHOOK_H
#define DTHOOK_H

#include <windows.h>
#include "dt_dll.h"


//
// Function Declarations
//

LPFNWSANOTIFY
GetPreApiNotifyFP(void);

LPFNWSANOTIFY
GetPostApiNotifyFP(void);

void
DTHookInitialize(void);

void
DTHookShutdown(void);



#ifdef DEBUG_TRACING

#define PREAPINOTIFY(x) \
    ( GetPreApiNotifyFP()  ? ( (*(GetPreApiNotifyFP())) x ) : FALSE)
#define POSTAPINOTIFY(x) \
    if ( GetPostApiNotifyFP() ) { \
         (VOID) ( (*(GetPostApiNotifyFP())) x ); \
    } else

#else

#define PREAPINOTIFY(x) FALSE
#define POSTAPINOTIFY(x)

#endif  // DEBUG_TRACING


#ifdef DEBUG_TRACING
// In  this  case we need function prototypes for the DTHOOK_ prefaced versions
// of  all  the upcall functions.  Alas, the task of keeping these identical to
// the normal WPU function prototypes is an error-prone manual process.

#ifdef __cplusplus
extern "C" {
#endif

BOOL WSPAPI DTHOOK_WPUCloseEvent( WSAEVENT hEvent,
                           LPINT lpErrno );

int WSPAPI DTHOOK_WPUCloseSocketHandle( SOCKET s,
                                 LPINT lpErrno );

WSAEVENT WSPAPI DTHOOK_WPUCreateEvent( LPINT lpErrno );

SOCKET WSPAPI DTHOOK_WPUCreateSocketHandle( DWORD dwCatalogEntryId,
                                     DWORD_PTR dwContext,
                                     LPINT lpErrno );

int WSPAPI DTHOOK_WPUFDIsSet ( SOCKET s,
                        fd_set FAR * set );

int WSPAPI DTHOOK_WPUGetProviderPath( LPGUID lpProviderId,
                               WCHAR FAR * lpszProviderDllPath,
                               LPINT lpProviderDllPathLen,
                               LPINT lpErrno );

SOCKET WSPAPI DTHOOK_WPUModifyIFSHandle( DWORD dwCatalogEntryId,
                                  SOCKET ProposedHandle,
                                  LPINT lpErrno );

BOOL WSPAPI DTHOOK_WPUPostMessage( HWND hWnd,
                            UINT Msg,
                            WPARAM wParam,
                            LPARAM lParam );

int WSPAPI DTHOOK_WPUQueryBlockingCallback( DWORD dwCatalogEntryId,
                                     LPBLOCKINGCALLBACK FAR * lplpfnCallback,
                                     PDWORD_PTR lpdwContext,
                                     LPINT lpErrno );

int WSPAPI DTHOOK_WPUQuerySocketHandleContext( SOCKET s,
                                        PDWORD_PTR lpContext,
                                        LPINT lpErrno );

int WSPAPI DTHOOK_WPUQueueApc( LPWSATHREADID lpThreadId,
                        LPWSAUSERAPC lpfnUserApc,
                        DWORD_PTR dwContext,
                        LPINT lpErrno );

BOOL WSPAPI DTHOOK_WPUResetEvent( WSAEVENT hEvent,
                           LPINT lpErrno );

BOOL WSPAPI DTHOOK_WPUSetEvent( WSAEVENT hEvent,
                         LPINT lpErrno );

int WSPAPI DTHOOK_WPUOpenCurrentThread( OUT LPWSATHREADID lpThreadId,
                        OUT LPINT lpErrno );

int WSPAPI DTHOOK_WPUCloseThread( IN LPWSATHREADID lpThreadId,
                        OUT LPINT lpErrno );

#ifdef __cplusplus
}
#endif

#endif  // DEBUG_TRACING


#endif  // DTHOOK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\inc\nscatent.h ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    nscatent.h

Abstract:

    This  file  contains the class definition for the NSCATALOGENTRY class.
    This  class  defines the interface to the entries that can be installed and
    retrieved in the namespace provider catalog.

Author:
    Dirk Brandewie (dirk@mink.intel.com)  09-Nov-1995

Notes:

    $Revision:   1.9  $

    $Modtime:   15 Feb 1996 16:13:18  $

Revision History:

    09-Nov-1995  dirk@mink.intel.com
        Initial Revision

--*/

#ifndef _NSCATENT_
#define _NSCATENT_

#include "winsock2.h"
#include <windows.h>


class NSCATALOGENTRY {
public:

    NSCATALOGENTRY();

    INT
    InitializeFromRegistry(
        IN  HKEY  ParentKey,
        IN  INT   SequenceNum
        );

    INT
    InitializeFromValues(
        IN  LPWSTR            LibraryPath,
        IN  LPWSTR            DisplayString,
        IN  LPGUID            ProviderId,
        IN  DWORD             NameSpaceId,
        IN  DWORD             Version
        );

    PNSPROVIDER
    GetProvider();

    LPGUID
    GetProviderId();

    DWORD
    GetNamespaceId();

    LONG
    GetAddressFamily();

    LPWSTR
    GetLibraryPath();

    VOID
    SetVersion(
        IN DWORD Version
        );

    DWORD
    GetVersion();

    BOOL
    GetEnabledState();

    BOOL
    StoresServiceClassInfo();

    LPWSTR
    GetProviderDisplayString();

    INT
    WriteToRegistry(
        IN  HKEY  ParentKey,
        IN  INT   SequenceNum
        );

    VOID
    Enable(
        IN BOOLEAN EnableValue
        );

    VOID
    Reference (
        );
    VOID
    Dereference (
        );
private:

    // Should never be called directly but through dereferencing
    ~NSCATALOGENTRY();

friend class NSCATALOG; // So it can access some of the private
                        // fields and methods below.

    VOID
    SetProvider (
        IN PNSPROVIDER  Provider
        );

    INT
    IoRegistry(
        IN  HKEY  EntryKey,
        IN  BOOL  IsRead);

    LIST_ENTRY     m_CatalogLinkage;
    // Used  to  link  items  in  catalog.   Note  that  this particular member
    // variable  is in the public section to make it available for manipulation
    // by the catalog object.

    LONG        m_reference_count;
    // How many time this structure was referenced

    PNSPROVIDER  m_provider;
    // Pointer to the dprovider object attached to this catalog entry.

    DWORD m_namespace_id;
    // The name space supported by this provider

    LONG m_address_family;
    // the address family it supports

    DWORD m_version;
    // The version supported by this provider

    BOOLEAN m_enabled;
    // Is this provider enabled / should it be returned by
    // WSAEnumNameSpaceProviders

    BOOLEAN m_stores_service_class_info;
    // Does this provider store service class info information

    LPWSTR m_providerDisplayString;
    // The human readable string describing this provider

    GUID m_providerId;
    // The GUID for this provider

    WCHAR m_LibraryPath[MAX_PATH];
    // Fully qualified path to the provider's DLL image.

};  // class NSCATALOGENTRY


inline
VOID
NSCATALOGENTRY::Reference () {
    //
    // Object is created with reference count of 1
    // and is destroyed whenever it gets back to 0.
    //
    assert (m_reference_count>0);
    InterlockedIncrement (&m_reference_count);
}


inline
VOID
NSCATALOGENTRY::Dereference () {
    assert (m_reference_count>0);
    if (InterlockedDecrement (&m_reference_count)==0)
        delete this;
}


inline
PNSPROVIDER
NSCATALOGENTRY::GetProvider()
/*++

Routine Description:

    This  procedure  retrieves  a reference to the NSPROVIDER associated with a
    catalog  entry. 

Arguments:

    None

Return Value:

    Returns  the  current  provider  reference,  or  NULL if provider is not
    loaded yet
--*/
{
    return(m_provider);
}  // GetProvider


inline LPGUID
NSCATALOGENTRY::GetProviderId(
    )
/*++

Routine Description:

    This function returns a pointer to the provider ID sored in this object.

Arguments:

    NONE

Return Value:

    The address of m_providerId.

--*/
{
    return(&m_providerId);
}



inline LONG
NSCATALOGENTRY::GetAddressFamily(
    )
/*++

Routine Description:

    Returns the Address family of the namespace supported by this provider.

Arguments:

    NONE

Return Value:

    The value of m_address_family.

--*/
{
    return(m_address_family);
}



inline DWORD
NSCATALOGENTRY::GetNamespaceId(
    )
/*++

Routine Description:

    Returns the ID of the namespace supported by this provider.

Arguments:

    NONE

Return Value:

    The value of m_namespace_id.

--*/
{
    return(m_namespace_id);
}



inline DWORD
NSCATALOGENTRY::GetVersion()
/*++

Routine Description:

    Returns the version supported by this namespace provider.

Arguments:

    NONE

Return Value:

    The value of m_version.

--*/
{
    return(m_version);
}


inline LPWSTR
NSCATALOGENTRY::GetLibraryPath()
/*++

Routine Description:

    Returns library path of the provider

Arguments:

    NONE

Return Value:

    The value of m_LibraryPath.

--*/
{
    return(m_LibraryPath);
}


inline BOOL
NSCATALOGENTRY::GetEnabledState(
    )
/*++

Routine Description:

    Returns the enabled state of the provider.

Arguments:

    NONE

Return Value:

    The value of m_enabled.

--*/
{
    return(m_enabled);
}


inline LPWSTR
NSCATALOGENTRY::GetProviderDisplayString(
    )
/*++

Routine Description:

    Returns the display string of the provider.

Arguments:

    NONE

Return Value:

    The value of m_providerDisplayString;

--*/
{
    return(m_providerDisplayString);
}


inline BOOL
NSCATALOGENTRY::StoresServiceClassInfo()
/*++

Routine Description:

    Returns whether the provider stores service class infomation.

Arguments:

    NONE

Return Value:

   The value of m_stores_service_class_info.

--*/
{
    return(m_stores_service_class_info);
}


#endif // _NSCATENT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\inc\dsocket.h ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

dsocket.h

Abstract:

This  header  defines the "DSOCKET" class.  The DSOCKET class defines state
variables  and  operations for DSOCKET objects within the WinSock 2 DLL.  A
DSOCKET  object  represents  all  of the information that the WinSock 2 DLL
knows about a socket created using the Windows Sockets API.

Author:

Paul Drews (drewsxpa@ashland.intel.com) 30-June-1995

Notes:

$Revision:   1.12  $

$Modtime:   08 Mar 1996 00:07:38  $

Revision History:

most-recent-revision-date email-name
description

07-14-1995  dirk@mink.intel.com
    Moved member function descriptions to the implementation file
    dsocket.cpp

07-09-1995  drewsxpa@ashland.intel.com
    Completed  first  complete  version with clean compile and released for
    subsequent implementation.

07-08-95  drewsxpa@ashland.intel.com
Original version

--*/

#ifndef _DSOCKET_
#define _DSOCKET_

#include "winsock2.h"
#include <windows.h>
#include "classfwd.h"
#include "ws2help.h"

class DSOCKET: private WSHANDLE_CONTEXT
{
  public:

    static
    INT
    DSocketClassInitialize();

    static
    INT
    DSocketClassCleanup();

    static
    INT
    AddSpecialApiReference(
        IN SOCKET SocketHandle
        );

    static
    PDSOCKET
    GetCountedDSocketFromSocket(
        IN  SOCKET     SocketHandle
        );

    static
    PDSOCKET
    GetCountedDSocketFromSocketNoExport(
        IN  SOCKET     SocketHandle
        );

    DSOCKET();

    INT
    Initialize(
        IN PPROTO_CATALOG_ITEM  CatalogEntry
        );

    ~DSOCKET();

    SOCKET
    GetSocketHandle();

    PDPROVIDER
    GetDProvider();

    DWORD_PTR
    GetContext();

    VOID
    SetContext(
        IN DWORD_PTR Context
        );

    PPROTO_CATALOG_ITEM
    GetCatalogItem();

    INT
    AssociateSocketHandle(
        IN  SOCKET  SocketHandle,
        IN  BOOLEAN ProviderSocket
        );

    INT
    DisassociateSocketHandle( );

    VOID
    AddDSocketReference(
        );

    VOID
    DropDSocketReference(
        );

    VOID
    DestroyDSocket(
        );

    BOOL
    IsProviderSocket(
        );

    BOOL
    IsApiSocket (
        );

    BOOL
    IsOverlappedSocket (
        );

#ifndef WS2_DEBUGGER_EXTENSION
//
// Give debugger extension access to all fields
//
  private:
#endif

    static
    PDSOCKET
    FindIFSSocket (
        IN  SOCKET     SocketHandle
        );

    friend class DPROCESS;

    static LPCONTEXT_TABLE  sm_context_table;
    // Context tables

//#define m_reference_count   RefCount
//#define m_socket_handle     Handle
    DWORD_PTR   m_handle_context;
    // The  uninterpreted  socket  handle  context  value  that  was  set  by
    // SetContext at the time of WPUCreateSocketHandle.

    PDPROVIDER  m_provider;
    // Reference  to  the  DPROVIDER object representing the service provider
    // that controls this socket.

    PPROTO_CATALOG_ITEM m_catalog_item;
    // The protocol catalog item used to create this socket

    BOOLEAN m_pvd_socket;
    // TRUE if this socket comes from the provider and not created by
    // helper DLL on provider request (WPUCreateSocketHandle).

    BOOLEAN m_api_socket;
    // TRUE if socket was returned via socket/WSASocketA/WSASocketW call,
    //      or imported from IFS provider in other API calls
    // FALSE for sockets that are used only at SPI level (created on
    //      request from layered provider and never exposed to the
    //      application)

    BOOLEAN m_overlapped_socket;
    // To support the hack of creations of non-overlapped handles
    // during Accept and JoinLeaf by handle helper.

#if defined(DEBUG_TRACING) || defined(WS2_DEBUGGER_EXTENSION)
#define SOCKET_STACK_BACKTRACE_DEPTH 2
  public:
	PVOID	m_CreatorBackTrace[SOCKET_STACK_BACKTRACE_DEPTH];
    // Socket creator information
#endif


};   // class DSOCKET



inline SOCKET
DSOCKET::GetSocketHandle()
/*++

Routine Description:

    Retrieves  the  external socket-handle value corresponding to this internal
    DSOCKET object.

Arguments:

    None

Return Value:

    The corresponding external socket-handle value.
--*/
{
    return((SOCKET)Handle);
}




inline PDPROVIDER
DSOCKET::GetDProvider()
/*++

Routine Description:

    Retrieves  a reference to the DPROVIDER object associated with this DSOCKET
    object.

Arguments:

    None

Return Value:

    The reference to the DPROVIDER object associated with this DSOCKET object.
--*/
{
    return(m_provider);
}


inline DWORD_PTR
DSOCKET::GetContext()
/*++

Routine Description:

    This  function  retrieves  the  socket  handle  context  value set with the
    SetContext  operation.   This  function  is typically called at the time of
    WPUQuerySocketHandleContext.  The return value is unspecified if SetContext
    has not been called.

Arguments:

    None

Return Value:

    Returns  the  context  value  that  was  set  by SetContext.  This value is
    uninterpreted by the WinSock 2 DLL.
--*/
{
    return(m_handle_context);
}




inline VOID
DSOCKET::SetContext(
    IN  DWORD_PTR Context
    )
/*++

Routine Description:

    This  function  sets  the  socket  handle  context value.  This function is
    typically called at the time of WPUCreateSocketHandle.

Arguments:

    lpContext - Supplies  the  uninterpreted  socket handle context value to be
                associated with this socket.

Return Value:

    None
--*/
{
    m_handle_context = Context;
}



inline PPROTO_CATALOG_ITEM
DSOCKET::GetCatalogItem()
/*++

Routine Description:

    Retreives the pointer to the catalog item associated with this socket.

Arguments:

Return Value:

    The pointer to the catalog item associated with this socket.
--*/
{
    return(m_catalog_item);
}






inline
BOOL
DSOCKET::IsProviderSocket(
    )
/*++
Routine Description:

    This function returns a boolean indicating whether the object is
    for the socket created by the provider (presumably IFS).

Arguments:

    None

Return Value:

    TRUE  - The object is for the socket created by the provider.

    FALSE - The object is for the socket created by helper DLL.
--*/
{
    return m_pvd_socket;

} // IsProviderSocket



inline
BOOL
DSOCKET::IsApiSocket(
    )
/*++
Routine Description:

    This function returns a boolean indicating whether the object represents
    socket used by API client.

Arguments:

    None

Return Value:

    TRUE  - The socket is used by API client .

    FALSE - The object is used by SPI client.
--*/
{
    return m_api_socket;

} // IsApiSocket


inline
BOOL
DSOCKET::IsOverlappedSocket(
    )
/*++
Routine Description:

    This function returns a boolean indicating whether the object represents
    overlapped socket.

Arguments:

    None

Return Value:

    TRUE  - The socket is overlapped.

    FALSE - The object is non-overlapped.
--*/
{
    return m_overlapped_socket;

} // IsOverlappedSocket





inline VOID
DSOCKET::AddDSocketReference(
    )
/*++
Routine Description:

    Adds a reference to the DSOCKET.

Arguments:

    None

Return Value:

    None
--*/
{

    WahReferenceHandleContext(this);

} // AddDSocketReference


inline VOID
DSOCKET::DropDSocketReference(
    )
/*++
Routine Description:

    Drops the DSOCKET reference and destroys the object
    if reference count is 0.

Arguments:

    None

Return Value:

    None
--*/
{

    if (WahDereferenceHandleContext(this)==0)
        DestroyDSocket ();
} // DropDSocketReference

inline
PDSOCKET
DSOCKET::GetCountedDSocketFromSocket(
    IN  SOCKET     SocketHandle
    )
/*++
Routine Description

    This procedure takes a client socket handle and maps it to a DSOCKET object
    reference.  The reference is counted.

    If socket object corresponding to the handle cannot be found in the table
    this function queires all IFS providers to see if one of the recognizes
    the handle.

    Whenever  this procedure successfuly returns a counted reference, it is the
    responsibility of the caller to eventually call DropDSocketReference.

    Note  that  this  procedure  assumes that the caller has already checked to
    make sure that WinSock is initialized.

Arguments:

    SocketHandle   - Supplies the client-level socket handle to be mapped.


Return Value:
    DSOCKET object or NULL in case the object cannot be found
--*/
{
    PDSOCKET    Socket;
    Socket = static_cast<PDSOCKET>(WahReferenceContextByHandle (
                                        sm_context_table,
                                        (HANDLE)SocketHandle));
    if (Socket!=NULL)
        return Socket;
    else
        return FindIFSSocket (SocketHandle);
}

inline
PDSOCKET
DSOCKET::GetCountedDSocketFromSocketNoExport(
    IN  SOCKET     SocketHandle
    )
/*++
Routine Description

    This procedure takes a client socket handle and maps it to a DSOCKET object
    reference.  The reference is counted.

    No attempt is made to find IFS provider for the socket if it cannot be found
    in the table.  This function is intented for calls from non-IFS providers
    such as in context of WPUQuerySocketHandleContext.

    Whenever  this procedure successfuly returns a counted reference, it is the
    responsibility of the caller to eventually call DropDSocketReference.

    Note  that  this  procedure  assumes that the caller has already checked to
    make sure that WinSock is initialized.

Arguments:

    SocketHandle   - Supplies the client-level socket handle to be mapped.


Return Value:
    DSOCKET object or NULL in case the object cannot be found
--*/
{
    return static_cast<PDSOCKET>(WahReferenceContextByHandle (
                                    sm_context_table,
                                    (HANDLE)SocketHandle));
}

#endif // _DSOCKET_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\inc\dthread.h ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

dthread.h

Abstract:

This  header  defines the "DTHREAD" class.  The DTHREAD class defines state
variables  and  operations for DTHREAD objects within the WinSock 2 DLL.  A
DTHREAD object represents all of the information known about a thread using
the Windows Sockets API.

Author:

Paul Drews (drewsxpa@ashland.intel.com) 9-July-1995

Notes:

$Revision:   1.19  $

$Modtime:   20 Feb 1996 14:19:04  $

Revision History:

most-recent-revision-date email-name
description

    23-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Moved single line functions to be inlines.

    07-17-1995  dirk@mink.intel.com
        Moved function descriptions to implementation file. Added member
        variable to hold the handle of the Async Helper device.

    07-09-1995  drewsxpa@ashland.intel.com
        Completed  first  complete  version with clean compile and released for
        subsequent implementation.

    9-July-1995 drewsxpa@ashland.intel.com
        Original version

--*/


#ifndef _DTHREAD_
#define _DTHREAD_

#include "winsock2.h"
#include <windows.h>
#include "ws2help.h"
#include "classfwd.h"


#define RESULT_BUFFER_SIZE 32

#define MAX_PROTO_TEXT_LINE 511
#define MAX_PROTO_ALIASES   35

typedef struct _GETPROTO_INFO {

    struct protoent Proto;
    CHAR * Aliases[MAX_PROTO_ALIASES];
    CHAR TextLine[MAX_PROTO_TEXT_LINE+1];

} GETPROTO_INFO, *PGETPROTO_INFO;


class DTHREAD
{
  public:


    static
    INT
    DThreadClassInitialize(
        VOID);

    static
    VOID
    DThreadClassCleanup(
        VOID);

    static
    PDTHREAD
    GetCurrentDThread(
        VOID);

    static
    LPWSATHREADID
    GetCurrentDThreadID(
        IN  PDPROCESS  Process
        );

    static
    INT
    CreateDThreadForCurrentThread(
        IN  PDPROCESS  Process,
        OUT PDTHREAD FAR * CurrentThread
        );

    static
    VOID
    DestroyCurrentThread(
        VOID);

    DTHREAD(
        VOID);

    INT
    Initialize(
        IN PDPROCESS  Process
        );

    ~DTHREAD();


    PCHAR
    GetResultBuffer();

    PCHAR
    CopyHostEnt(LPBLOB pBlob);

    PCHAR
    CopyServEnt(LPBLOB pBlob);

    LPWSATHREADID
    GetWahThreadID();

    LPBLOCKINGCALLBACK
    GetBlockingCallback();

    BOOL
    IsBlocking();

    INT
    CancelBlockingCall();

    FARPROC
    SetBlockingHook(
        FARPROC lpBlockFunc
        );

    INT
    UnhookBlockingHook();

    VOID
    SetOpenType(
        INT OpenType
        );

    INT
    GetOpenType();

    PGETPROTO_INFO
    GetProtoInfo();
#if 0
    //Data member
    LIST_ENTRY  m_dprocess_linkage;

    // Provides the linkage space for a list of DTHREAD objects maintained by
    // the  DPROCESS  object  associated with this DTHREAD object.  Note that
    // this member variable must be public so that the linked-list macros can
    // maniplate the list linkage from within the DPROCESS object's methods.
#endif 
  private:

    static
    INT
    WINAPI
    DefaultBlockingHook();

    static
    BOOL
    CALLBACK
    BlockingCallback(
        DWORD_PTR dwContext
        );

    static DWORD  sm_tls_index;
    // The  class-scope  index  in  thread-local  storage  where  the DTHREAD
    // reference for the thread is stored.

    WSATHREADID  m_wah_thread_id;
    // The  thread  id  used  by  the  WinSock  Async  Helper  mechanism  for
    // processing IO completion callbacks.

    LPBLOCKINGCALLBACK m_blocking_callback;
    FARPROC m_blocking_hook;
    // The  pointer  to  the current client-level blocking hook procedure for
    // the thread.

    HANDLE  m_wah_helper_handle;
    // Handle to the APC helper device

    CHAR  m_result_buffer[RESULT_BUFFER_SIZE];

    //
    // m_hostent_buffer is used to construct a hostent for calls
    // such as gethostbyname. It also contains space for the
    // WSALookupServiceNext results structure.
    //

    PCHAR  m_hostent_buffer;
    PCHAR  m_servent_buffer;
    WORD   m_hostent_size;
    WORD   m_servent_size;

    PDPROCESS  m_process;
    // Reference to the DPROCESS object with which this thread is associated.

    BOOL m_is_blocking;
    // TRUE if this thread is currently in a blocking API.

    BOOL m_io_cancelled;
    // TRUE if current I/O has been cancelled.

    LPWSPCANCELBLOCKINGCALL m_cancel_blocking_call;
    // Pointer to current provider's cancel routine.

    INT m_open_type;
    // Current default socket() open type.

    PGETPROTO_INFO m_proto_info;
    // State for getprotobyXxx().

};  // class DTHREAD


inline PCHAR
DTHREAD::GetResultBuffer()
/*++

Routine Description:

    This function retrieves the pointer to the thread specific result buffer.

Arguments:

Return Value:

    The pointer to the thread specific buffer.

--*/
{
    return(&m_result_buffer[0]);
} //GetResultBuffer

inline PCHAR
DTHREAD::CopyHostEnt(LPBLOB pBlob)
/*++

Routine Description:

    This function copies the hostent in the blob and returns a pointer
    to the per-thread buffer

Arguments:

Return Value:

    The pointer to the thread specific buffer.

--*/
{
    if(m_hostent_size < pBlob->cbSize)
    {
        delete m_hostent_buffer;
        m_hostent_buffer = new CHAR[pBlob->cbSize];
        m_hostent_size = (WORD)pBlob->cbSize;
    }
    if(m_hostent_buffer)
    {
        memcpy(m_hostent_buffer, pBlob->pBlobData, pBlob->cbSize);
    }
    else
    {
        m_hostent_size = 0;
        SetLastError(WSA_NOT_ENOUGH_MEMORY);
    }
    return(m_hostent_buffer);
}

inline PCHAR
DTHREAD::CopyServEnt(LPBLOB pBlob)
/*++

Routine Description:

    This function copies the servent in the blob and returns a pointer
    to the per-thread buffer

Arguments:

Return Value:

    The pointer to the thread specific buffer.

--*/
{
    if(m_servent_size < pBlob->cbSize)
    {
        delete m_servent_buffer;
        m_servent_buffer = new CHAR[pBlob->cbSize];
        m_servent_size = (WORD)pBlob->cbSize;
    }
    if(m_servent_buffer)
    {
        memcpy(m_servent_buffer, pBlob->pBlobData, pBlob->cbSize);
    }
    else
    {
        m_servent_size = 0;
        SetLastError(WSA_NOT_ENOUGH_MEMORY);
    }
    return(m_servent_buffer);
}



inline LPWSATHREADID
DTHREAD::GetWahThreadID()
/*++

Routine Description:

    This  procedure  retrieves  the  per-thread "Thread ID" used by the WinSock
    Asynchronous  Helper  Thread  ID  mechanism  during  the  delivery  of a IO
    completion callback to the client's thread context.

Arguments:

    None

Return Value:

    Returns  the  WinSock  Asynchronous  Helper  Thread ID corresponding to the
    current thread.

Notes:

    // The WahThreadID is created during Initialize, because otherwise we could
    // encounter  an  error  while  trying to complete an overlapped operation,
    // even though the SP part succeeded.
    //
    // There  is  no special benefit in having the DPROCESS object postpone its
    // Wah-related  initialization  until  demanded,  since it will be demanded
    // essentially right away as a parameter added to each IO function.  If the
    // SPI  semantics were changed to only include the thread ID in cases where
    // async  callbacks  are  really  required,  there  could  be  a benefit in
    // postponing  creation of the WahThreadID until we were sure it was really
    // needed.
--*/
{
    return(& m_wah_thread_id);
} //GetWahThreadID



inline
LPBLOCKINGCALLBACK
DTHREAD::GetBlockingCallback()
/*++

Routine Description:

    Returns the blocking callback function pointer for this thread.

Arguments:

    None.

Return Value:

    The pointer to blocking callback function. Note that this may be NULL.

--*/
{
    return m_blocking_callback;
} // GetBlockingCallback



inline
BOOL
DTHREAD::IsBlocking()
/*++

Routine Description:

    Determines if the current thread is currently in a blocking operation.

Arguments:

    None.

Return Value:

    TRUE if the thread is blocking, FALSE otherwise.

--*/
{
    return m_is_blocking;
} // IsBlocking



inline
VOID
DTHREAD::SetOpenType(
    INT OpenType
    )
/*++

Routine Description:

    Sets the "open type" for this thread, as set by the SO_OPENTYPE socket
    option.

Arguments:

    OpenType - The new open type.

Return Value:

    None.

--*/
{
    m_open_type = OpenType;
} // SetOpenType



inline
INT
DTHREAD::GetOpenType()
/*++

Routine Description:

    Returns "open type" for this thread.

Arguments:

    None.

Return Value:

    The open type for this thread.

--*/
{
    return m_open_type;
} // GetOpenType


inline 
LPWSATHREADID
DTHREAD::GetCurrentDThreadID(
    IN  PDPROCESS  Process
    )
{
    PDTHREAD    Thread;
    UNREFERENCED_PARAMETER (Process);
    Thread = (DTHREAD*)TlsGetValue(sm_tls_index);
    if (Thread!=NULL) {
        return Thread->GetWahThreadID ();
    }
    else
        return NULL;
}

inline
PDTHREAD
DTHREAD::GetCurrentDThread()
/*++

Routine Description:

    This  procedure  retrieves a reference to a DTHREAD object corresponding to
    the  current  thread.

Arguments:

Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it
    returns an appropriate WinSock error code.
--*/
{
    return (DTHREAD*)TlsGetValue(sm_tls_index);
}

#endif // _DTHREAD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\inc\scihlpr.h ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    scihelpr.h

Abstract:

    This  file contains the definitions of the procedures exported by the
    service class info helper module for internal use within the WinSock 2
    DLL. 

Author:

    Dirk Brandewie (dirk@mink.intel.com)  25-Jan-1996

Notes:

    $Revision:   1.0  $

    $Modtime:   25 Jan 1996 11:08:36  $

Revision History:

    most-recent-revision-date email-name
        description

    25-Jan-1996 dirk@mink.intel.com
        Created original version

--*/

#ifndef _SCIHELPR_
#define _SCIHELPR_

#include "winsock2.h"
#include <windows.h>

INT
MapAnsiServiceClassInfoToUnicode(
    IN     LPWSASERVICECLASSINFOA Source,
    IN OUT LPDWORD                lpTargetSize,
    IN     LPWSASERVICECLASSINFOW Target
    );

INT
MapUnicodeServiceClassInfoToAnsi(
    IN     LPWSASERVICECLASSINFOW Source,
    IN OUT LPDWORD                lpTargetSize,
    IN     LPWSASERVICECLASSINFOA Target
    );

#endif // _SCIHELPR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\inc\nsprovid.h ===
/*++


  Intel Corporation Proprietary Information
  Copyright (c) 1995 Intel Corporation

  This listing is supplied under the terms of a license agreement with
  Intel Corporation and may not be used, copied, nor disclosed except in
  accordance with the terms of that agreeement.


  Module Name:

      nsprovid.h

  Abstract:

      This module defines the WinSock2 class NSPROVIDER along with its
      methods.

  Author:

      Dirk Brandewie (dirk@mink.intel.com)  05-Dec-1995

  Revision History:

      09-Nov-1995 dirk@mink.intel.com
      Initial Revision
  --*/
#ifndef _NSPROVIDER_
#define _NSPROVIDER_

#include <winsock2.h>
#include <ws2spi.h>
#include "classfwd.h"
#include "dthook.h"
#include "wsautil.h"
#include "dprocess.h"
#include "dthread.h"


class NSPROVIDER {

  public:

    NSPROVIDER();

    INT
    Initialize(
        IN LPWSTR  lpszLibFile,
        IN LPGUID  lpProviderId
        );


    INT WSAAPI
    NSPUnInstallNameSpace (
        );

//
// Client Query APIs
//

    INT WSAAPI
    NSPLookupServiceBegin(
        IN  LPWSAQUERYSETW           lpqsRestrictions,
        IN  LPWSASERVICECLASSINFOW   lpServiceClassInfo,
        IN  DWORD                    dwControlFlags,
        OUT LPHANDLE                 lphLookup
        );

    INT WINAPI
    SupportsIoctl(
        );

    INT WSAAPI
    NSPIoctl(
        IN  HANDLE           hLookup,
        IN  DWORD            dwControlCode,
        IN  LPVOID           lpvInBuffer,
        IN  DWORD            cbInBuffer,
        OUT LPVOID           lpvOutBuffer,
        IN  DWORD            cbOutBuffer,
        OUT LPDWORD          lpcbBytesReturned,
        IN  LPWSACOMPLETION  lpCompletion,
        IN  LPWSATHREADID    lpThreadId
        );

    INT WSAAPI
    NSPLookupServiceNext(
        IN     HANDLE           hLookup,
        IN     DWORD            dwcontrolFlags,
        IN OUT LPDWORD          lpdwBufferLength,
        OUT    LPWSAQUERYSETW   lpqsResults
        );

    INT WSAAPI
    NSPLookupServiceEnd(
        IN HANDLE  hLookup
        );

//
// Service Address Registration and Deregistration APIs and Data Types.
//

    INT WSAAPI
    NSPSetService(
        IN  LPWSASERVICECLASSINFOW   lpServiceClassInfo,
        IN  LPWSAQUERYSETW           lpqsRegInfo,
        IN  WSAESETSERVICEOP         essOperation,
        IN  DWORD                    dwControlFlags
        );


//
// Service Installation/Removal APIs and Data Types.
//

    INT WSAAPI
    NSPInstallServiceClass(
        IN  LPWSASERVICECLASSINFOW   lpServiceClassInfo
        );

    INT WSAAPI
    NSPRemoveServiceClass(
        IN  LPGUID  lpServiceClassId
        );

    INT WSAAPI
    NSPGetServiceClassInfo(
        IN OUT  LPDWORD                 lpdwBufSize,
        IN OUT  LPWSASERVICECLASSINFOW  lpServiceClassInfo
        );


    // Provider cleanup
    INT WSAAPI
    NSPCleanup (
        );

    VOID
    Reference (
        );

    VOID
    Dereference (
        );

  private:

    // Should never be called directly, but through dereferencing.
    ~NSPROVIDER();

    LONG             m_reference_count;
    // How many time this structure was referenced

    DWORD            m_namespace_id;
    // The identifier of the namespace supported by the service provider.

    HINSTANCE        m_library_handle;
    // The handle to the service provider DLL.

    NSP_ROUTINE      m_proctable;
    // Structure containing the fuction pointers to the entry points of the
    // service provider DLL.

    GUID             m_provider_id;
    // The GUID associated with an interface in the service provider DLL.

#ifdef DEBUG_TRACING
    LPSTR            m_library_name;
    // The name of the service provider DLL.
#endif

};

inline
VOID
NSPROVIDER::Reference () {
    //
    // Object is created with reference count of 1
    // and is destroyed whenever it gets back to 0.
    //
    assert (m_reference_count>0);
    InterlockedIncrement (&m_reference_count);
}

inline
VOID
NSPROVIDER::Dereference () {
    assert (m_reference_count>0);
    if (InterlockedDecrement (&m_reference_count)==0)
        delete this;
}

//
// Client Query APIs
//


inline INT WSAAPI
NSPROVIDER::NSPLookupServiceBegin(
    IN  LPWSAQUERYSETW          lpqsRestrictions,
    IN  LPWSASERVICECLASSINFOW  lpServiceClassInfo,
    IN  DWORD                   dwControlFlags,
    OUT LPHANDLE                lphLookup
    )
/*++

Routine Description:

    NSPLookupServiceBegin() is used to initiate a client query that is
    constrained by the information contained within a WSAQUERYSET
    structure. WSALookupServiceBegin() only returns a handle, which should be
    used by subsequent calls to NSPLookupServiceNext() to get the actual
    results.



Arguments:

    lpProviderId - Contains the specific provider ID that should be used for
                   the query.

    lpqsRestrictions - contains the search criteria.

    lpServiceClassInfo - A WSASERVICECLASSINFOW structure which contains all of
                         the schema information for the service.

    dwControlFlags - controls the depth of the search:

    lphLookup - Handle to be used in subsequent calls to NSPLookupServiceNext
                in order to retrieve the results set.

Return Value:

    The function should return NO_ERROR (0) if the routine succeeds.  It should
    return SOCKET_ERROR (-1) if the routine fails
--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_NSPLookupServiceBegin,
                       &ReturnValue,
                       (LPSTR) m_library_name,
                       &m_provider_id,
                       &lpqsRestrictions,
                       &lpServiceClassInfo,
                       &dwControlFlags,
                       &lphLookup )) ) {
        return(ReturnValue);
    }

    ReturnValue =   ReturnValue = m_proctable.NSPLookupServiceBegin(
        &m_provider_id,
        lpqsRestrictions,
        lpServiceClassInfo,
        dwControlFlags,
        lphLookup
        );

    POSTAPINOTIFY((DTCODE_NSPLookupServiceBegin,
                   &ReturnValue,
                   m_library_name,
                   &m_provider_id,
                   &lpqsRestrictions,
                   &lpServiceClassInfo,
                   &dwControlFlags,
                   &lphLookup ));

    assert (m_reference_count>0);
    return(ReturnValue);


}

inline INT WSAAPI
NSPROVIDER::NSPLookupServiceNext(
    IN     HANDLE           hLookup,
    IN     DWORD            dwControlFlags,
    IN OUT LPDWORD          lpdwBufferLength,
    OUT    LPWSAQUERYSETW   lpqsResults
    )
/*++

Routine Description:

    NSPLookupServiceNext() is called after obtaining a Handle from a previous
    call to NSPLookupServiceBegin() in order to retrieve the requested service
    information.  The provider will pass back a WSAQUERYSET structure in the
    lpqsResults buffer.  The client should continue to call this API until it
    returns WSA_E_NOMORE, indicating that all of the WSAQUERYSET have been
    returned.

Arguments:

    hLookup - Handle returned from the previous call to
              NSPLookupServiceBegin().

    dwControlFlags - Flags to control the next operation.  This is currently
                     used  to indicate to the provider what to do if the result
                     set is too big for the buffer.  If on the previous call to
                     NSPLookupServiceNext() the result set was too large for
                     the buffer, the client can choose to do one of two things
                     on this call.  First, it can choose to pass a bigger
                     buffer and try again.  Second, if it cannot or is
                     unwilling to allocate a larger buffer, it can pass
                     LUP_FLUSHPREVIOUS to tell the provider to throw away the
                     last result set - which was too large - and move on to the
                     next set for this call.

    lpdwBufferLength - on input, the number of bytes contained in the buffer
                       pointed  to by lpresResults.  On output - if the API
                       fails, and the error is WSAEFAULT, then it contains the
                       minimum number of bytes to pass for the lpqsResults to
                       retrieve the record.

    lpqsResults - a pointer to a block of memory, which will contain one result
                  set  in a WSAQUERYSET structure on return.

Return Value:

    The function should return NO_ERROR (0) if the routine succeeds.  It should
    return SOCKET_ERROR (-1) if the routine fails.
--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_NSPLookupServiceNext,
                       &ReturnValue,
                       m_library_name,
                       &hLookup,
                       &dwControlFlags,
                       &lpdwBufferLength,
                       &lpqsResults )) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.NSPLookupServiceNext(
        hLookup,
        dwControlFlags,
        lpdwBufferLength,
        lpqsResults
        );

    POSTAPINOTIFY((DTCODE_NSPLookupServiceNext,
                   &ReturnValue,
                   m_library_name,
                   &hLookup,
                   &dwControlFlags,
                   &lpdwBufferLength,
                   &lpqsResults  ));

    assert (m_reference_count>0);
    return(ReturnValue);
}


inline INT WINAPI
NSPROVIDER::SupportsIoctl(
    )
{
    if (m_proctable.NSPIoctl != NULL)
        return (TRUE);
    else
        return (FALSE);
}


inline INT WSAAPI
NSPROVIDER::NSPIoctl(
    IN  HANDLE           hLookup,
    IN  DWORD            dwControlCode,
    IN  LPVOID           lpvInBuffer,
    IN  DWORD            cbInBuffer,
    OUT LPVOID           lpvOutBuffer,
    IN  DWORD            cbOutBuffer,
    OUT LPDWORD          lpcbBytesReturned,
    IN  LPWSACOMPLETION  lpCompletion,
    IN  LPWSATHREADID    lpThreadId
    )
/*++

Routine Description:

    The NSPIoctl function is used to set or retrieve operating parameters
    associated with a namespace query handle.

    Any IOCTL may block indefinitely, depending upon the relevant namespace's
    implementation.  If an application cannot tolerate blocking in a
    NSPIoctl call, overlapped I/O would be advised.  For these operations,
    which cannot be completed immediately, completion is indicated later
    through the mechanism specified in the pCompletion parameter.
    If pCompletion is NULL, this is a blocking call.  To make this call
    non-blocking and return immediately, set WSACOMPLETION::Type to
    LUP_NOTIFY_IMMEDIATELY.

Arguments:

    hLookup - Lookup handle returned from a call to WSALookupServiceBegin.

    dwControlCode - The control code of the operation to perform.

    pvInBuffer - A pointer to the input buffer for the operation.

    cbInBuffer - The size of the input buffer for the operation.

    pvOutBuffer - A pointer to the output buffer for the operation.

    pcbOutBuffer - A pointer to an integral value for the size of the output
                   buffer.

    pCompletion - A pointer to a WSACOMPLETION structure.

Return Value:

    Upon successful completion, WSANSIoctl returns NO_ERROR (0).  Otherwise,
    a value of SOCKET_ERROR (-1) is returned, and a specific error code can
    be retrieved by calling WSAGetLastError.
--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert(m_reference_count > 0);
    if (PREAPINOTIFY((DTCODE_NSPIoctl,
                      &ReturnValue,
                      m_library_name,
                      &hLookup,
                      &dwControlCode,
                      &lpvInBuffer,
                      &cbInBuffer,
                      &lpvOutBuffer,
                      &lpcbBytesReturned,
                      &cbOutBuffer,
                      &lpCompletion,
                      &lpThreadId)) ) {
        return (ReturnValue);
    }

    ReturnValue = m_proctable.NSPIoctl(
        hLookup,
        dwControlCode,
        lpvInBuffer,
        cbInBuffer,
        lpvOutBuffer,
        cbOutBuffer,
        lpcbBytesReturned,
        lpCompletion,
        lpThreadId
        );

    POSTAPINOTIFY((DTCODE_NSPIoctl,
                   &ReturnValue,
                   m_library_name,
                   &hLookup,
                   &dwControlCode,
                   &lpvInBuffer,
                   &cbInBuffer,
                   &lpvOutBuffer,
                   &lpcbBytesReturned,
                   &cbOutBuffer,
                   &lpCompletion,
                   &lpThreadId));

    assert(m_reference_count > 0);
    return (ReturnValue);
}


inline INT WSAAPI
NSPROVIDER::NSPLookupServiceEnd(
    IN HANDLE  hLookup
    )
/*++

Routine Description:

    NSPLookupServiceEnd() is called to free the handle after previous calls to
    NSPLookupServiceBegin() and NSPLookupServiceNext().  It is possible to
    receive a NSPLookupServiceEnd() call on another thread while processing a
    NSPLookupServiceNext().  This indicates that the client has cancelled the
    request, and the provider should close the handle and return from the
    NSPLookupServiceNext() call as well, setting the last error to
    WSA_E_CANCELLED.


Arguments:

    hLookup - Handle previously obtained by calling NSPLookupServiceBegin().


Return Value:

    The function should return NO_ERROR (0) if the routine succeeds.  It should
    return SOCKET_ERROR (-1) if the routine fails.
--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_NSPLookupServiceEnd,
                       &ReturnValue,
                       m_library_name,
                       &hLookup )) ) {
        return(ReturnValue);
    }

    ReturnValue =m_proctable.NSPLookupServiceEnd(
        hLookup );

    POSTAPINOTIFY((DTCODE_NSPLookupServiceEnd,
                   &ReturnValue,
                   m_library_name,
                   &hLookup ));

    assert (m_reference_count>0);
    return(ReturnValue);
}


//
// Service Address Registration and Deregistration APIs and Data Types.
//

inline INT WSAAPI
NSPROVIDER::NSPSetService(
    IN  LPWSASERVICECLASSINFOW   lpServiceClassInfo,
    IN  LPWSAQUERYSETW           lpqsRegInfo,
    IN  WSAESETSERVICEOP         essOperation,
    IN  DWORD                    dwControlFlags
    )
/*++

Routine Description:

    NSPSetService() is used to register or deregister a service instance within
    a name space.

Arguments:

    lpProviderId - Pointer to the GUID of the specific name space provider that
                   this service is being registered in.

    lpServiceClasslnfo - contains service class schema information.

    lpqsRegInfo - specifies property information to be updated upon
                  registration.

    essOperation - an enumeration.

    dwControlFlags - ControlFlags.

Return Value:

    The function should return NO_ERROR (0) if the routine succeeds.  It should
    return SOCKET_ERROR (-1) if the routine fails.
--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_NSPSetService
                       &ReturnValue,
                       m_library_name,
                       (PCHAR) &m_provider_id,
                       &lpServiceClassInfo,
                       &lpqsRegInfo,
                       &essOperation,
                       &dwControlFlags )) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.NSPSetService(
        &m_provider_id,
        lpServiceClassInfo,
        lpqsRegInfo,
        essOperation,
        dwControlFlags);

    POSTAPINOTIFY((DTCODE_NSPSetService,
                   &ReturnValue,
                   m_library_name,
                   &m_provider_id,
                   &lpServiceClassInfo,
                   &lpqsRegInfo,
                   &essOperation,
                   &dwControlFlags ));

    assert (m_reference_count>0);
    return(ReturnValue);
}



//
// Service Installation/Removal APIs and Data Types.
//

inline INT WSAAPI
NSPROVIDER::NSPInstallServiceClass(
    IN  LPWSASERVICECLASSINFOW   lpServiceClassInfo
    )
/*++

Routine Description:

    NSPInstallServiceClass() is used to register service class schema within
    the name space providers.  The schema includes the class name, class id,
    and any name space specific type information that is common to all
    instances of the service, such as SAP ID or object ID.  A name space
    provider is expected to store any class info associated with that
    namespace.

Arguments:

    lpProviderId - Pointer to the GUID of the specific name space provider that
                   this  service class schema is being registered in.

    lpServiceClasslnfo - contains service class schema information.

Return Value:

    The function should return NO_ERROR (0) if the routine succeeds.  It should
    return SOCKET_ERROR (-1) if the routine fails.
--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_NSPInstallServiceClass,
                       &ReturnValue,
                       m_library_name,
                       &m_provider_id,
                       &lpServiceClassInfo )) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.NSPInstallServiceClass(
        &m_provider_id,
        lpServiceClassInfo);

    POSTAPINOTIFY(( DTCODE_NSPInstallServiceClass,
                    &ReturnValue,
                    m_library_name,
                    &m_provider_id,
                    &lpServiceClassInfo ));

    assert (m_reference_count>0);
    return(ReturnValue);
}


inline INT WSAAPI
NSPROVIDER::NSPRemoveServiceClass(
    IN  LPGUID  lpServiceClassId
    )
/*++

Routine Description:

    NSPRemoveServiceClass() is used to permanently remove a specified service
    class from the name space.

Arguments:

    lpServiceClassId    Pointer to the service class ID that is to be removed.

Return Value:

    The function should return NO_ERROR (0) if the routine succeeds.  It should
    return SOCKET_ERROR (-1) if the routine fails.
--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_NSPRemoveServiceClass,
                       &ReturnValue,
                       m_library_name,
                       &m_provider_id,
                       &lpServiceClassId )) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.NSPRemoveServiceClass(
        &m_provider_id,
        lpServiceClassId);

    POSTAPINOTIFY((DTCODE_NSPRemoveServiceClass,
                   &ReturnValue,
                   m_library_name,
                   &m_provider_id,
                   &lpServiceClassId ));

    assert (m_reference_count>0);
    return(ReturnValue);
}


inline INT WSAAPI
NSPROVIDER::NSPGetServiceClassInfo(
    IN OUT  LPDWORD                 lpdwBufSize,
    IN OUT  LPWSASERVICECLASSINFOW  lpServiceClassInfo
    )
/*++

Routine Description:

    NSPGetServiceClassInfo() is used to retrieve all of the class information
    (schema) pertaining to the service from the name space providers.  This
    call retrieves any name space specific information that is common to all
    instances of the service, including connection information for SAP, or port
    information for SAP or TCP.

Arguments:

    lpdwBufferLength - on input, the number of bytes contained in the buffer
                       pointed to by lpServiceClassInfos.  On output - if the
                       API fails, and the error is WSAEFAULT, then it contains
                       the minimum number of bytes to pass for the
                       lpServiceClassInfo to retrieve the record.

    lpServiceClasslnfo - returns service class to name space specific mapping
                         information.  The lpServiceClassId field must be
                         filled in to indicate which SERVICECLASSINFOW record
                         should be returned.

Return Value:

    The function should return NO_ERROR (0) if the routine succeeds.  It should
    return SOCKET_ERROR (-1) if the routine fails.
--*/
{
    INT ReturnValue=SOCKET_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_NSPGetServiceClassInfo,
                       &ReturnValue,
                       m_library_name,
                       &m_provider_id,
                       &lpdwBufSize,
                       &lpServiceClassInfo )) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.NSPGetServiceClassInfo(
        &m_provider_id,
        lpdwBufSize,
        lpServiceClassInfo);

    POSTAPINOTIFY((DTCODE_NSPGetServiceClassInfo,
                   &ReturnValue,
                   m_library_name,
                   &m_provider_id,
                   &lpdwBufSize,
                   &lpServiceClassInfo ));

    assert (m_reference_count>0);
    return(ReturnValue);
}

#endif // _NSPROVIDER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\inc\nspstate.h ===
/*++


  Intel Corporation Proprietary Information
  Copyright (c) 1995 Intel Corporation

  This listing is supplied under the terms of a license agreement with
  Intel Corporation and may not be used, copied, nor disclosed except in
  accordance with the terms of that agreeement.


Module Name:

    nsstate.h

Abstract:

    This  module  gives  the class definition for the NSPROVIDERSTATE object
    type.  The NSPROVIDERSTATE object holds the pointer to the provider object
    and the handle for a WSALookup{Begin/Next/End} series.

Author:

    Dirk Brandewie (dirk@mink.intel.com)  04-12-1995

Notes:

$Revision:   1.10  $

$Modtime:   15 Feb 1996 16:50:42  $


Revision History:

    04-Dec-1995 dirk@mink.intel.com
    created

--*/

#ifndef _NSPROVIDERSTATE_
#define _NSPROVIDERSTATE_

#include "classfwd.h"
#include "nsprovid.h"

class NSPROVIDERSTATE
{
  public:

    NSPROVIDERSTATE();

    INT
    Initialize(
        PNSPROVIDER  pNamespaceProvider
        );

    INT
    WINAPI
    LookupServiceBegin(
        IN  LPWSAQUERYSETW          lpqsRestrictions,
        IN  LPWSASERVICECLASSINFOW  lpServiceClassInfo,
        IN  DWORD                   dwControlFlags
        );

    INT
    WINAPI
    LookupServiceNext(
        IN     DWORD           dwContolFlags,
        IN OUT LPDWORD         lpdwBufferLength,
        OUT    LPWSAQUERYSETW  lpqsResults
        );

    INT
    WINAPI
    SupportsIoctl(
        );

    INT
    WINAPI
    Ioctl(
        IN  DWORD            dwControlCode,
        IN  LPVOID           lpvInBuffer,
        IN  DWORD            cbInBuffer,
        OUT LPVOID           lpvOutBuffer,
        IN  DWORD            cbOutBuffer,
        OUT LPDWORD          lpcbBytesReturned,
        IN  LPWSACOMPLETION  lpCompletion,
        IN  LPWSATHREADID    lpThreadId
        );

    INT
    WINAPI
    LookupServiceEnd();

    INT 
    WINAPI
    SetService(
        IN  LPWSASERVICECLASSINFOW   lpServiceClassInfo,
        IN  LPWSAQUERYSETW           lpqsRegInfo,
        IN  WSAESETSERVICEOP         essOperation,
        IN  DWORD                    dwControlFlags
        );

    INT
    WINAPI
    InstallServiceClass(
        IN  LPWSASERVICECLASSINFOW   lpServiceClassInfo
        );

    INT 
    WINAPI
    RemoveServiceClass(
        IN  LPGUID  lpServiceClassId
        );

    INT
    WINAPI
    GetServiceClassInfo(
        IN OUT  LPDWORD                 lpdwBufSize,
        IN OUT  LPWSASERVICECLASSINFOW  lpServiceClassInfo
        );


    ~NSPROVIDERSTATE();

    LIST_ENTRY   m_query_linkage;
    //Public data member to support putting this object on a linked list

  private:

    PNSPROVIDER  m_provider;
    // Pointer to the NSPROVIDER object associated with this object.

    HANDLE       m_provider_query_handle;
    // The handle returned from NSPLookupServiceBegin() to be passed to
    // NSPlookupServiceNext and NSPLookupSeviceEnd.

};  // class NSPROVIDERSTATE

inline
NSPROVIDERSTATE::NSPROVIDERSTATE()
/*++

Routine Description:

    Constructor for the NSPROVIDERSTATE object.  The first member function
    called after this must be Initialize.

Arguments:

    None

Return Value:

    Returns a pointer to a NSPROVIDERSTATE object.
--*/
{
    m_provider = NULL;
    m_provider_query_handle = NULL;
}



inline
INT
NSPROVIDERSTATE::Initialize(
    PNSPROVIDER  pNamespaceProvider
    )
/*++

Routine Description:

    This  procedure  performs  all initialization for the NSPROVIDERSTATE
    object.  This function  must  be  invoked  after the constructor, before
    any other member function is invoked.

Arguments:

    pNamespaceProvider - A pointer to a namespace provider object.

    ProviderQueryHandle - A handle to used in calls to Lookup
Return Value:

    If  the  function  is  successful,  it  returns ERROR_SUCCESS, otherwise it
    returns an appropriate WinSock 2 error code.
--*/
{
    assert (m_provider==NULL);
    pNamespaceProvider->Reference ();
    m_provider = pNamespaceProvider;
    return(ERROR_SUCCESS);
}





inline
INT
WINAPI
NSPROVIDERSTATE::LookupServiceBegin(
    IN  LPWSAQUERYSETW          lpqsRestrictions,
    IN  LPWSASERVICECLASSINFOW   lpServiceClassInfo,
    IN  DWORD                   dwControlFlags
    )
/*++

Routine Description:

    See description in NSPROVID.H

Arguments:

    None

Return Value:

    None
--*/
{
    return( m_provider->NSPLookupServiceBegin(
        lpqsRestrictions,
        lpServiceClassInfo,
        dwControlFlags,
        &m_provider_query_handle
        ));
}



inline
INT
WINAPI
NSPROVIDERSTATE::LookupServiceNext(
    IN     DWORD           dwContolFlags,
    IN OUT LPDWORD        lpdwBufferLength,
    OUT    LPWSAQUERYSETW  lpqsResults
    )
/*++

Routine Description:

    See description in NSPROVID.H

Arguments:

    None

Return Value:

    None
--*/
{
    return(m_provider->NSPLookupServiceNext(
        m_provider_query_handle,
        dwContolFlags,
        lpdwBufferLength,
        lpqsResults
        ));
}



inline
INT
WINAPI
NSPROVIDERSTATE::SupportsIoctl(
    )
{
    return (m_provider->SupportsIoctl());
}



inline
INT
WINAPI
NSPROVIDERSTATE::Ioctl(
    IN  DWORD            dwControlCode,
    IN  LPVOID           lpvInBuffer,
    IN  DWORD            cbInBuffer,
    OUT LPVOID           lpvOutBuffer,
    IN  DWORD            cbOutBuffer,
    OUT LPDWORD          lpcbBytesReturned,
    IN  LPWSACOMPLETION  lpCompletion,
    IN  LPWSATHREADID    lpThreadId
    )
{
    return (m_provider->NSPIoctl(
        m_provider_query_handle,
        dwControlCode,
        lpvInBuffer,
        cbInBuffer,
        lpvOutBuffer,
        cbOutBuffer,
        lpcbBytesReturned,
        lpCompletion,
        lpThreadId
        ));
}



inline
INT
WINAPI
NSPROVIDERSTATE::LookupServiceEnd()
/*++

Routine Description:

    See description in NSPROVID.H

Arguments:

    None

Return Value:

    None
--*/
{
    return(m_provider->NSPLookupServiceEnd(m_provider_query_handle));
}

inline
NSPROVIDERSTATE::~NSPROVIDERSTATE()
/*++

Routine Description:

    Denstructor for the NSPROVIDERSTATE object. 

Arguments:

    None

Return Value:

    None
--*/
{
    if (m_provider!=NULL) {
        m_provider->Dereference ();
        m_provider = NULL;
    }
}


#endif // _NSPROVIDERSTATE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\inc\startup.h ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    startup.h

Abstract:

    This  module  defines  procedures  to  be called at the time of loading and
    unloading  the  WinSock  2  DLL (typically from DllMain).  These procedures
    create and destroy the Startup/Cleanup synchronization mechanism.

Author:

    Paul Drews (drewsxpa@ashland.intel.com) 31-Aug-1995

Notes:

    $Revision:   1.4  $

    $Modtime:   12 Jan 1996 15:09:00  $

Revision History:

    1995-11-04 keithmo@microsoft.com
        Added support for WPUPostMessage() upcall.

    1995-08-31 drewsxpa@ashland.intel.com
        created

--*/

#ifndef _STARTUP_
#define _STARTUP_

#include <windows.h>



extern
#if defined(__cplusplus)
"C"
#endif  // defined(__cplusplus)
VOID
CreateStartupSynchronization();

typedef
BOOL
(WINAPI *PWINSOCK_POST_ROUTINE)(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    );

extern PWINSOCK_POST_ROUTINE SockPostRoutine;

PWINSOCK_POST_ROUTINE
GetSockPostRoutine(
    VOID
    );

#define GET_SOCK_POST_ROUTINE()      \
    (SockPostRoutine ? SockPostRoutine : GetSockPostRoutine())


extern
#if defined(__cplusplus)
"C"
#endif  // defined(__cplusplus)
VOID
DestroyStartupSynchronization();

#endif // _STARTUP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\inc\qshelpr.h ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    qshelpr.h

Abstract:

    This  file contains the definitions of the procedures exported by the query
    set helper module for internal use within the WinSock 2 DLL.

Author:

    Paul Drews (drewsxpa@ashland.intel.com) 11-Jan-1996

Notes:

    $Revision:   1.2  $

    $Modtime:   18 Jan 1996 11:22:32  $

Revision History:

    most-recent-revision-date email-name
        description

    11-Jan-1996 drewsxpa@ashland.intel.com
        Created original version

--*/

#ifndef _QSHELPR_
#define _QSHELPR_

#include "winsock2.h"
#include <windows.h>


INT
MapAnsiQuerySetToUnicode(
    IN     LPWSAQUERYSETA  Source,
    IN OUT LPDWORD         lpTargetSize,
    OUT    LPWSAQUERYSETW  Target
    );


INT
MapUnicodeQuerySetToAnsi(
    IN     LPWSAQUERYSETW  Source,
    IN OUT LPDWORD         lpTargetSize,
    OUT    LPWSAQUERYSETA  Target
    );

INT
CopyQuerySetA(
    IN LPWSAQUERYSETA  Source,
    OUT LPWSAQUERYSETA *Target
    );


CopyQuerySetW(
    IN LPWSAQUERYSETW  Source,
    OUT LPWSAQUERYSETW *Target
    );

LPWSTR
wcs_dup_from_ansi(
    IN LPSTR  Source
    );

LPSTR
ansi_dup_from_wcs(
    IN LPWSTR  Source
    );


#endif // _QSHELPR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\inc\trace.h ===
//////////////////////////////////////////////////////////////////////////
//
// INTEL Corporation Proprietary Information
// Copyright (c) Intel Corporation
//
// This listing is supplied under the terms of a license aggreement
// with INTEL Corporation and may not be used, copied nor disclosed
// except in accordance with that agreement.
//
//////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// $Workfile:   TRACE.H  $
// $Revision:   1.5  $
// $Modtime:   12 Jan 1996 15:09:00  $
//
// DESCRIPTION:
//
// this file defines a macros for tracing and the function prototypes
// for the actual output functions. If the symbol TRACING is not
// defined  all the macros expands to ((void)0).
//
// There are three global variables that control the behavior of the
// tracing macros/functions.  debugLevel is a 32 bit bitmask that
// determine controls what level of debug messages is output.
// iTraceDestination controls whether the debug output goes to a file or
// to the aux device. if iTraceDestination == TRACE_TO_FILE szTraceFile
// must contain the filename
//
/////////////////////////////////////////////////////////////////////

#ifndef __TRACE_H__
#define __TRACE_H__

extern
#if defined(__cplusplus)
"C"
#endif  // defined(__cplusplus)
VOID __cdecl PrintDebugString(char *format, ...);

extern 
#if defined(__cplusplus)
"C"
#endif  // defined(__cplusplus)
VOID 
TraceCleanup ();

extern
#if defined(__cplusplus)
"C"
#endif  // defined(__cplusplus)
LONG
Ws2ExceptionFilter(
    LPEXCEPTION_POINTERS ExceptionPointers,
    LPSTR SourceFile,
    LONG LineNumber
    );

extern
#if defined(__cplusplus)
"C"
#endif  // defined(__cplusplus)
LONG
Ws2ProviderExceptionFilter(
    LPEXCEPTION_POINTERS ExceptionPointers,
    LPSTR pFunc,
    LPWSTR pDll,
    LPWSTR pName,
    LPGUID pGuid
    );
//
// defines for where the debug output should go
//
#define TRACE_TO_FILE    0
#define TRACE_TO_AUX     1

// the size of the string buffers used as arg to wsprintf
// in trace.c
#define TRACE_OUTPUT_BUFFER_SIZE  1024

// Debug level masks
#define DBG_TRACE       0x00000001
#define DBG_WARN        0x00000002
#define DBG_ERR         0x00000004
#define DBG_MEMORY      0x00000008
#define DBG_LIST        0x00000010
#define DBG_FUNCTION    0x00000020

#if defined(TRACING)

extern
#if defined(__cplusplus)
"C"
#endif  // defined(__cplusplus)
DWORD debugLevel;

//
// This macro creates debug output depending on the debug mask "sev" and
// calls PrintDebugString output function. PrintDebugString makes the
// descision on whether the output goes into a file or to the aux device.
//
#define  DEBUGF(sev, var_args)                                                  \
{                                                                               \
   if ((sev) & debugLevel) {                                                    \
      switch (sev) {                                                            \
         case DBG_TRACE:                                                        \
            PrintDebugString("WS2_32 TRACE  :: %s:%d\n", __FILE__, __LINE__ );  \
            PrintDebugString var_args ;                                         \
            break;                                                                 \
         case DBG_WARN:                                                         \
            PrintDebugString("WS2_32 WARNING:: %s : %d\n", __FILE__, __LINE__ );\
            PrintDebugString var_args ;                                         \
            break;                                                              \
         case DBG_ERR:                                                          \
            PrintDebugString("WS2_32 ERROR  :: %s : %d\n", __FILE__, __LINE__ );\
            PrintDebugString var_args;                                          \
            break;                                                              \
        case DBG_MEMORY:                                                        \
            PrintDebugString("WS2_32 MEMORY :: %s : %d\n", __FILE__, __LINE__ );\
            PrintDebugString var_args ;                                         \
            break;                                                              \
        case DBG_LIST:                                                          \
            PrintDebugString("WS2_32 LIST   :: %s : %d\n", __FILE__, __LINE__ );\
            PrintDebugString var_args ;                                         \
            break;                                                              \
        case DBG_FUNCTION:                                                      \
            PrintDebugString var_args;                                          \
            break;                                                              \
      }                                                                         \
   }                                                                            \
}                                                                               \



#define ALLOC_LOG( pointer, size)                                             \
    DEBUGF( DBG_MEMORY ,("MEMORY %lX size %X Allocated \n",                   \
                         (pointer),(size)))                                   \

#define DEALLOC_LOG(pointer, size)                                            \
DEBUGF( DBG_MEMORY ,("MEMORY %lX size %X Deallocated \n",                     \
                         (pointer),(size)))                                   \


#define LIST_ADD_LOG(list, element)                                           \
    DEBUGF( DBG_LIST ,("LIST %lX element %lX Added \n",                       \
                       (list),(element)))                                     \

#define LIST_DEL_LOG(list, element)                                           \
    DEBUGF( DBG_LIST ,("LIST %lX element %lX Deleted \n",                     \
                       (list),(element)))                                     \

#define ENTER_FUNCTION(name)                                                  \
DEBUGF( DBG_FUNCTION,name)                                \


#define EXIT_FUNCTION(name)                               \
DEBUGF( DBG_FUNCTION,name)                                \

#define WS2_EXCEPTION_FILTER()                            \
            Ws2ExceptionFilter(                           \
                GetExceptionInformation(),                \
                (LPSTR)__FILE__,                          \
                (LONG)__LINE__                            \
                )

#define WS2_PROVIDER_EXCEPTION_FILTER(_pFunc,_pDll,_pName,_pGuid)   \
            Ws2ProviderExceptionFilter(                             \
                GetExceptionInformation(),                          \
                _pFunc,                                             \
                _pDll,                                              \
                _pName,                                             \
                _pGuid                                              \
                )

#else // TRACING
     // make sure that these are defined if tracing is turned off
#define DEBUGF(sev, va)                     ((void)0)
#define LIST_ADD_LOG(list, element)         ((void)0)
#define LIST_DEL_LOG(list, element)         ((void)0)
#define ENTER_FUNCTION(name)                ((void)0)
#define EXIT_FUNCTION(name)                 ((void)0)
#define WS2_EXCEPTION_FILTER()              EXCEPTION_EXECUTE_HANDLER
#define WS2_PROVIDER_EXCEPTION_FILTER(_pFunc,_pDll,_pName,_pGuid)             \
                                            EXCEPTION_EXECUTE_HANDLER
#define ALLOC_LOG( pointer, size)                                             \
    DEBUGF( DBG_MEMORY ,("",                                                  \
                         (pointer),(size)))                                   \

#define DEALLOC_LOG(pointer, size)\
    DEBUGF( DBG_MEMORY ,("",\
                         (pointer),(size)))  \

#endif // TRACING

#endif // __TRACE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\inc\nsquery.h ===
/*++


  Intel Corporation Proprietary Information
  Copyright (c) 1995 Intel Corporation

  This listing is supplied under the terms of a license agreement with
  Intel Corporation and may not be used, copied, nor disclosed except in
  accordance with the terms of that agreeement.


Module Name:

    nsquery.h

Abstract:

    This  module  gives  the class definition for the NSQUERY object type.  The
    NSQUERY    object   holds   all   the   state   information   regarding   a
    WSALookup{Begin/Next/End}   series   of  operations.   It  supplies  member
    functions that implement the API-level operations in terms of the SPI-level
    operations.

Author:

    Paul Drews (drewsxpa@ashland.intel.com) 09-November-1995

Notes:

    $Revision:   1.8  $

    $Modtime:   15 Feb 1996 16:54:32  $

Revision History:

    most-recent-revision-date email-name
        description

    09-November-1995 drewsxpa@ashland.intel.com
        created

--*/

#ifndef _NSQUERY_
#define _NSQUERY_


#include "winsock2.h"
#include <windows.h>
#include "classfwd.h"


#define QUERYSIGNATURE 0xbeadface
// A signature bit pattern used to validate an object of this type is still
// valid.

class NSQUERY
{
  public:

    NSQUERY();

    INT
    Initialize(
        );
    BOOL
    ValidateAndReference();


    ~NSQUERY();

    INT
    WINAPI
    LookupServiceBegin(
        IN  LPWSAQUERYSETW  lpqsRestrictions,
        IN  DWORD           dwControlFlags,
        IN PNSCATALOG       NsCatalog
        );

    INT
    WINAPI
    LookupServiceNext(
        IN     DWORD           dwControlFlags,
        IN OUT LPDWORD         lpdwBufferLength,
        IN OUT LPWSAQUERYSETW  lpqsResults
        );

    INT
    WINAPI
    Ioctl(
        IN  DWORD            dwControlCode,
        IN  LPVOID           lpvInBuffer,
        IN  DWORD            cbInBuffer,
        OUT LPVOID           lpvOutBuffer,
        IN  DWORD            cbOutBuffer,
        OUT LPDWORD          lpcbBytesReturned,
        IN  LPWSACOMPLETION  lpCompletion,
        IN  LPWSATHREADID    lpThreadId
        );
    
    INT
    WINAPI
    LookupServiceEnd();

    VOID
    WINAPI
    Dereference();


    BOOL
    RemoveProvider(
        PNSPROVIDER  pNamespaceProvider
        );

    BOOL
    AddProvider(
        PNSPROVIDER  pNamespaceProvider
        );



  private:

    PNSPROVIDERSTATE
    NextProvider(
        PNSPROVIDERSTATE Provider
        );

    PNSPROVIDERSTATE
    PreviousProvider(
        PNSPROVIDERSTATE Provider
        );


    volatile DWORD m_signature;
    // The signature of the object.

    volatile LONG  m_reference_count;
    // The number of threads currently using the object.  Used to determine
    // when the object can be deleted.

    volatile BOOL  m_shutting_down;
    // True when LookupEnd has been called.  Tells other thread that may
    // still be enumerating to get out ASAP.

    LIST_ENTRY  m_provider_list;
    // The  ordered  list  of  remaining  providers to which the LookupNext
    // operation  can be directed.  A provider is deleted from the front of
    // the  list  as  WSA_E_NOMORE  is first encountered from the provider.
    // The   actual   type   of   the   list  entries  is  private  to  the
    // implementation.

    PNSPROVIDERSTATE  m_current_provider;
    // This  keeps  track  of  the  sequence  number  of  the current first
    // provider  in  the  provider  list.   When  a  LookupNext  encounters
    // WSA_E_NOMORE, this number is compared against the number that was at
    // the  start  of  the operation.  The provider list is updated only if
    // these  two  numbers  are  equal.  This covers the case where several
    // threads are doing concurrent LookupNext operations.

    CRITICAL_SECTION  m_members_guard;
    // This  critical  section  must be entered when updating the values of
    // any  of  the member variables of the NSQUERY object.  This keeps the
    // values  consistent even though there may be concurrent threads using
    // the  object  with  LookupServiceNext or LookupServiceEnd operations.
    // Do not keep this critical section entered while calling through to a
    // service provider.

    BOOL m_change_ioctl_succeeded;
    // For providers which support Ioctl, after a change notification the
    // list of providers can be reset so that further calls to
    // LookupServiceNext will succeed with change information.

#ifdef RASAUTODIAL
    LPWSAQUERYSETW m_query_set;
    // The LPWSAQUERYSET structure passed in to LookupServiceBegin, in case
    // we need to restart the query (call LookupServiceBegin).

    DWORD m_control_flags;
    // The control flags of the query, in case we have to restart the query
    // (call LookupServiceBegin) due to an autodial attempt.

    PNSCATALOG m_catalog;
    // The catalog of the original query, in case we have to restart the
    // query (call LookupServiceBegin), due to an autodial attempt.

    BOOL m_restartable;
    // TRUE if no results have been returned for this query; FALSE
    // otherwise.
#endif // RASAUTODIAL

};  // class NSQUERY

#endif // _NSQUERY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\inc\trycatch.h ===
/*++

****COPYRIGHT NOTICE*****

Module Name:

    trycatch.h

Abstract:

    This  module  provides macros to support a lexical-scope exception-handling
    mechanism.  A brief comparison between this mechanism and the C++ exception
    mechanism is as follows:

    macro exception mechamism:

        extremely low run-time overhead

        catches exceptions only in lexical scope

        no value passed to exception handler

        explicitly thrown exceptions only

        exception regions can be nested and named

        usable by older compilers

    C++ exception mechanism:

        handles  all  types  of  exceptions  including  C  exceptions implicity
        thrown.

        catches exceptions thrown in dynamic scope

        involves some setup and teardown run-time overhead

        requires an up-to-date C++ compiler version

    These  macros  are  written  and  used  in  such a fashion that they can be
    transformed back into the C++ exception mechanism if needed.

Author:

    Paul Drews (drewsxpa@ashland.intel.com) 31-October-1995

Notes:

    $Revision:   1.2  $

    $Modtime:   12 Jan 1996 15:09:02  $

Revision History:

    most-recent-revision-date email-name
        description

    31-October-1995 drewsxpa@ashland.intel.com
        created

--*/

#ifndef _TRYCATCH_
#define _TRYCATCH_


// The TRY_START macro starts a guarded region

#define TRY_START(block_label) \
    /* nothing to do */


// The  TRY_THROW  macro  is  used  inside a guarded region to exit the guarded
// region immediately and enter the exception-recovery region.

#define TRY_THROW(block_label) \
    goto catch_##block_label


// The  TRY_CATCH  macro  marks  the  end  of the guarded region and starts the
// beginning  of  the  exception-recovery  region.   If  the TRY_CATCH macro is
// encountered in normal execution, the exception-recovery region is skipped.

#define TRY_CATCH(block_label) \
    goto end_##block_label; \
    catch_##block_label:


// The TRY_END macro marks the end of the exception-recovery region.  Execution
// resumes  here after completing execution of either the guarded region or the
// exception-recovery region.

#define TRY_END(block_label) \
    end_##block_label:



// A typical usage example of these macros is as follows:
//
// char *  buf1 = NULL;
// char *  buf2 = NULL;
// BOOL    return_value;
//
// TRY_START(mem_guard) {
//     buf1 = (char *) malloc(1000);
//     if (buf1 == NULL) {
//         TRY_THROW(mem_guard);
//     }
//     buf2 = (char *) malloc(1000);
//     if (buf2 == NULL) {
//         TRY_THROW(mem_guard);
//     }
//     return_value = TRUE;
// } TRY_CATCH(mem_guard) {
//     if (buf1 != NULL) {
//         free(buf1);
//         buf1 = NULL;
//     }
//     return_value = FALSE;
// } TRY_END(mem_guard);
//
// return return_value;


#endif // _TRYCATCH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\inc\wsassert.h ===
#ifndef _WSASSERT_
#define _WSASSERT_


//
// Define an assert that actually works.
//

#if DBG

#ifdef __cplusplus
extern "C" {
#endif

VOID
WsAssert(
    LPVOID FailedAssertion,
    LPVOID FileName,
    ULONG LineNumber
    );

#ifdef __cplusplus
}
#endif

#define WS_ASSERT(exp)      if( !(exp) )                                \
                                WsAssert( #exp, __FILE__, __LINE__ );   \
                            else

#define WS_REQUIRE(exp)     WS_ASSERT(exp)

#else

#define WS_ASSERT(exp)
#define WS_REQUIRE(exp)     ((VOID)(exp))

#endif


//
// Map CRT assert to our manly assert.
//

#undef assert
#define assert WS_ASSERT


#endif  // _WSASSERT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\inc\wsautil.h ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    util.h

Abstract:

    This module contains utility MACRO'S and definitions used for
    WINSOCK2 DLL

Author:

    Dirk Brandewie dirk@mink.intel.com  11-JUL-1995

Revision History:


--*/
#include <windows.h>
#include "classfwd.h"


//
// The highest WinSock versions supported by this DLL.
//

#define WINSOCK_HIGH_API_VERSION MAKEWORD(2,2)
#define WINSOCK_HIGH_SPI_VERSION MAKEWORD(2,2)


//
// The maximum allowed length for a catalog name such as "Protocol_Catalog9"
// or "NameSpace_Catalog5". This makes ValidateCurrentCatalogName() a bit
// simpler.
//

#define MAX_CATALOG_NAME_LENGTH 32

//
// Special value that keeps serial number of the registry catalog
// and helps synchronize access to registry without "public"
// mutex object
//
#define SERIAL_NUMBER_NAME      "Serial_Access_Num"


//
// API prolog. Note that Prolog_v1 is always used for WinSock 1.1 apps,
// and Prolog_v2 is always used for WinSock 2.x apps.
//
// Code within this DLL should call the prolog through the PROLOG macro.
// This will make life a bit simpler if we decide to change it yet again
// in the future.
//

INT
WINAPI
Prolog_v1(
    OUT PDPROCESS FAR * Process,
    OUT PDTHREAD FAR * Thread
    );

INT
WINAPI
Prolog_v2(
    OUT PDPROCESS FAR * Process,
    OUT PDTHREAD FAR * Thread
    );

INT
WINAPI
Prolog_Detached(
    OUT PDPROCESS FAR * Process,
    OUT PDTHREAD FAR * Thread
    );

typedef
INT
(WINAPI * LPFN_PROLOG)(
    OUT PDPROCESS FAR * Process,
    OUT PDTHREAD FAR * Thread
    );


extern LPFN_PROLOG PrologPointer;
extern HANDLE gHeap;
extern HINSTANCE    gDllHandle;

#define PROLOG(p,t)   (PrologPointer)( (p), (t) )
//
// Optimized inline version for V2 apps to be used
// on sensitive performance paths.
//

INT
WINAPI
SlowPrologOvlp (
	OUT	PDTHREAD FAR *	Thread
	);

INT
WINAPI
SlowProlog (
	VOID
	);

#define TURBO_PROLOG()												\
    (((PrologPointer==Prolog_v2) &&                                 \
            (DPROCESS::GetCurrentDProcess()!=NULL))					\
		? ERROR_SUCCESS												\
		: SlowProlog())

#define TURBO_PROLOG_OVLP(t)										\
    (((PrologPointer==Prolog_v2) &&                                 \
            (DPROCESS::GetCurrentDProcess()!=NULL) &&               \
			((*(t)=DTHREAD::GetCurrentDThread())!=NULL))		    \
		? ERROR_SUCCESS												\
        : SlowPrologOvlp(t))



//
// NT WOW Support.
//

typedef
BOOL
(WINAPI * LPFN_POSTMESSAGE)(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    );

//
// Registry manipulation.
//

BOOL
WriteRegistryEntry(
    IN HKEY     EntryKey,
    IN LPCTSTR  EntryName,
    IN PVOID    Data,
    IN DWORD    TypeFlag
    );

BOOL
ReadRegistryEntry(
    IN  HKEY    EntryKey,
    IN  LPTSTR  EntryName,
    OUT PVOID   Data,
    IN  DWORD   MaxBytes,
    IN  DWORD   TypeFlag
    );

LONG
RegDeleteKeyRecursive(
    IN HKEY  hkey,
    IN LPCTSTR  lpszSubKey
    );

LONG
RegDeleteSubkeys(
    IN HKEY  hkey
    );

HKEY
OpenWinSockRegistryRoot();

VOID
CloseWinSockRegistryRoot(
    HKEY  RootKey
    );

VOID
ValidateCurrentCatalogName(
    HKEY RootKey,
    LPSTR ValueName,
    LPSTR ExpectedName
    );

INT
AcquireExclusiveCatalogAccess (
	IN	HKEY	CatalogKey,
	IN	DWORD	ExpextedSerialNum,
    OUT PHKEY   AccessKey
    );

VOID
ReleaseExclusiveCatalogAccess (
	IN	HKEY	CatalogKey,
	IN  DWORD	CurrentSerialNum,
    IN  HKEY    access_key
    );

INT
SynchronizeSharedCatalogAccess (
	IN	HKEY	CatalogKey,
	IN	HANDLE	ChangeEvent,
	OUT	LPDWORD	CurrentSerialNum
	);

BOOL
HasCatalogChanged (
	IN	HANDLE	ChangeEvent
	);

//
// Ansi/Unicode conversions.
//

INT
MapUnicodeProtocolInfoToAnsi(
    IN  LPWSAPROTOCOL_INFOW UnicodeProtocolInfo,
    OUT LPWSAPROTOCOL_INFOA AnsiProtocolInfo
    );

INT
MapAnsiProtocolInfoToUnicode(
    IN  LPWSAPROTOCOL_INFOA AnsiProtocolInfo,
    OUT LPWSAPROTOCOL_INFOW UnicodeProtocolInfo
    );

BOOL
CompareMemory(
    LPBYTE  p1,
    LPBYTE  p2,
    DWORD   dwSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\addrinfo.cpp ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    addrinfo.c

Abstract:

    Forward & reverse name resolution library routines
    and related helper functions.

    Could be improved if necessary:
    QueryDNSforA could use WSALookupService instead of gethostbyname.
    gethostbyname will return success on some weird strings.
    Similarly, inet_addr is very loose (octal digits, etc).
    Could support multiple h_aliases.
    Could support hosts.txt file entries.

Author:

Revision History:

--*/

#include "precomp.h"
#include <svcguid.h>
#include <windns.h>

#ifdef _WIN64
#pragma warning (push)
#pragma warning (disable:4267)
#endif

#define NUM_ADDRESS_FAMILIES 2
#define MAX_SERVICE_NAME_LENGTH     (256)

#define L_A              0x1
#define L_AAAA           0x2
#define L_BOTH           0x3
#define L_AAAA_PREFERRED 0x6
#define L_A_PREFERRED    0x9  // Not used, but code would support it.

#define T_A     1
#define T_CNAME 5
#define T_AAAA  28
#define T_PTR   12
#define T_ALL   255

#define C_IN    1

void * __cdecl 
renew(void *p, size_t sz);


//
//  ASSERT() not defined
//

#ifndef ASSERT
#define ASSERT(c)
#endif

//
//  DCR:  fix up winsock2.h
//

typedef LPSOCKET_ADDRESS_LIST   PSOCKET_ADDRESS_LIST;
typedef LPADDRINFO              PADDRINFO;


//
//  Turn static off until solid
//  otherwise we get bad symbols
//

#define STATIC
//#define STATIC  static


//
//  Currently IP4 stack is always installed.
//
//  But code with check so we can easily handle when IP4
//  stack becomes optional.
//

#define IsIp4Running()  (TRUE)




//
//  DNS Utilities
//
//  Note this code is lifted directly from dnslib.lib.
//  Unfortunately i can't link this in as linker complains about
//  inet_addr() (ie winsock function) which dnslib.lib references.
//  Why it can't figure this out ... don't know.
//
//  If i ever get this sorted out ... then these will need to be pulled.
//  

//
//  UPNP IP6 literal hack
//

WCHAR   g_Ip6LiteralDomain[]    = L".ipv6-literal.net";
DWORD   g_Ip6LiteralDomainSize  = sizeof(g_Ip6LiteralDomain);

CHAR    g_Ip6LiteralDomainA[]   = ".ipv6-literal.net";
DWORD   g_Ip6LiteralDomainSizeA = sizeof(g_Ip6LiteralDomainA);

#define DNSDBG( a, b )



DWORD
String_ReplaceCharW(
    IN OUT  PWSTR           pString,
    IN      WCHAR           TargetChar,
    IN      WCHAR           ReplaceChar
    )
/*++

Routine Description:

    Replace a characater in the string with another character.

Arguments:

    pString -- string

    TargetChar -- character to replace

    ReplaceChar -- character that replaces TargetChar

Return Value:

    Count of replacements.

--*/
{
    PWCHAR  pch;
    WCHAR   ch;
    DWORD   countReplace= 0;

    //
    //  loop matching and replacing TargetChar
    //

    pch = pString - 1;

    while ( ch = *++pch )
    {
        if ( ch == TargetChar )
        {
            *pch = ReplaceChar;
            countReplace++;
        }
    }

    return  countReplace;
}



DWORD
String_ReplaceCharA(
    IN OUT  PSTR            pString,
    IN      CHAR            TargetChar,
    IN      CHAR            ReplaceChar
    )
/*++

Routine Description:

    Replace a characater in the string with another character.

Arguments:

    pString -- string

    TargetChar -- character to replace

    ReplaceChar -- character that replaces TargetChar

Return Value:

    Count of replacements.

--*/
{
    PCHAR   pch;
    CHAR    ch;
    DWORD   countReplace= 0;

    //
    //  loop matching and replacing TargetChar
    //

    pch = pString - 1;

    while ( ch = *++pch )
    {
        if ( ch == TargetChar )
        {
            *pch = ReplaceChar;
            countReplace++;
        }
    }

    return  countReplace;
}



BOOL
Dns_Ip6LiteralNameToAddressW(
    OUT     PSOCKADDR_IN6   pSockAddr,
    IN      PCWSTR          pwsString
    )
/*++

Routine Description:

    IP6 literal to IP6 sockaddr.

Arguments:

    pSock6Addr -- address to fill with IP6 corresponding to literal

    pwsString -- literal string

Return Value:

    TRUE if IP6 literal found and convert.
    FALSE if not IP6 literal.

--*/
{
    WCHAR       nameBuf[ DNS_MAX_NAME_LENGTH ];
    DWORD       length;
    DWORD       size;
    PWSTR       pdomain;
    DNS_STATUS  status;


    DNSDBG( TRACE, (
        "Dns_Ip6LiteralNameToAddressW( %S )\n",
        pwsString ));

    //
    //  test for literal
    //      - test undotted
    //      - test as FQDN
    //      note that even FQDN test is safe, as we insist
    //      that string size is GREATER than literal size
    //  

    length = wcslen( pwsString );
    size = (length+1) * sizeof(WCHAR);

    if ( size <= g_Ip6LiteralDomainSize )
    {
        DNSDBG( INIT2, (
            "Stopped UPNP parse -- short string.\n" ));
        return  FALSE;
    }

    pdomain = (PWSTR) ((PBYTE)pwsString + size - g_Ip6LiteralDomainSize);

    if ( ! RtlEqualMemory(
                pdomain,
                g_Ip6LiteralDomain,
                g_Ip6LiteralDomainSize-sizeof(WCHAR) ) )
    {
        pdomain--;

        if ( pwsString[length-1] != L'.'
                ||
             ! RtlEqualMemory(
                    pdomain,
                    g_Ip6LiteralDomain,
                    g_Ip6LiteralDomainSize-sizeof(WCHAR) ) )
        {
            DNSDBG( INIT2, (
                "Stopped UPNP parse -- no tag match.\n" ));
            return  FALSE;
        }
    }

    //
    //  copy literal to buffer
    //

    if ( length >= DNS_MAX_NAME_LENGTH )
    {
        DNSDBG( INIT2, (
            "Stopped UPNP parse -- big string.\n" ));
        return  FALSE;
    }

    length = (DWORD) ((PWSTR)pdomain - pwsString);

    RtlCopyMemory(
        nameBuf,
        pwsString,
        length*sizeof(WCHAR) );

    nameBuf[ length ] = 0;

    //
    //  replace dashes with colons
    //  replace 's' with % for scope
    //

    String_ReplaceCharW(
        nameBuf,
        L'-',
        L':' );

    String_ReplaceCharW(
        nameBuf,
        L's',
        L'%' );

    DNSDBG( INIT2, (
        "Reconverted IP6 literal %S\n",
        nameBuf ));

    //
    //  convert to IP6 address
    //

    status = RtlIpv6StringToAddressExW(
                nameBuf,
                & pSockAddr->sin6_addr,
                & pSockAddr->sin6_scope_id,
                & pSockAddr->sin6_port
                );

    if ( status == NO_ERROR )
    {
        if ( IN6_IS_ADDR_LINKLOCAL( &pSockAddr->sin6_addr )
                ||
             IN6_IS_ADDR_SITELOCAL( &pSockAddr->sin6_addr ) )
        {
            pSockAddr->sin6_flowinfo = 0;
            pSockAddr->sin6_family = AF_INET6;
        }
        else
        {
            status = ERROR_INVALID_PARAMETER;
        }
    }
    return( status == NO_ERROR );
}



PWCHAR
Dns_Ip4AddressToReverseName_W(
    OUT     PWCHAR          pBuffer,
    IN      IP4_ADDRESS     IpAddress
    )
/*++

Routine Description:

    Write reverse lookup name, given corresponding IP

Arguments:

    pBuffer -- ptr to buffer for reverse lookup name;
        MUST contain at least DNS_MAX_REVERSE_NAME_BUFFER_LENGTH wide chars

    IpAddress -- IP address to create

Return Value:

    Ptr to next location in buffer.

--*/
{
    DNSDBG( TRACE, ( "Dns_Ip4AddressToReverseName_W()\n" ));

    //
    //  write digits for each octect in IP address
    //      - note, it is in net order so lowest octect, is in highest memory
    //

    pBuffer += wsprintfW(
                    pBuffer,
                    L"%u.%u.%u.%u.in-addr.arpa.",
                    (UCHAR) ((IpAddress & 0xff000000) >> 24),
                    (UCHAR) ((IpAddress & 0x00ff0000) >> 16),
                    (UCHAR) ((IpAddress & 0x0000ff00) >> 8),
                    (UCHAR) (IpAddress & 0x000000ff) );

    return( pBuffer );
}



PCHAR
Dns_Ip4AddressToReverseName_A(
    OUT     PCHAR           pBuffer,
    IN      IP4_ADDRESS     IpAddress
    )
/*++

Routine Description:

    Write reverse lookup name, given corresponding IP

Arguments:

    pBuffer -- ptr to buffer for reverse lookup name;
        MUST contain at least DNS_MAX_REVERSE_NAME_BUFFER_LENGTH bytes

    IpAddress -- IP address to create

Return Value:

    Ptr to next location in buffer.

--*/
{
    DNSDBG( TRACE, ( "Dns_Ip4AddressToReverseName_A()\n" ));

    //
    //  write digits for each octect in IP address
    //      - note, it is in net order so lowest octect, is in highest memory
    //

    pBuffer += sprintf(
                    pBuffer,
                    "%u.%u.%u.%u.in-addr.arpa.",
                    (UCHAR) ((IpAddress & 0xff000000) >> 24),
                    (UCHAR) ((IpAddress & 0x00ff0000) >> 16),
                    (UCHAR) ((IpAddress & 0x0000ff00) >> 8),
                    (UCHAR) (IpAddress & 0x000000ff) );

    return( pBuffer );
}



PWCHAR
Dns_Ip6AddressToReverseName_W(
    OUT     PWCHAR          pBuffer,
    IN      IP6_ADDRESS     Ip6Addr
    )
/*++

Routine Description:

    Write reverse lookup name, given corresponding IP6 address

Arguments:

    pBuffer -- ptr to buffer for reverse lookup name;
        MUST contain at least DNS_MAX_IP6_REVERSE_NAME_BUFFER_LENGTH wide chars

    Ip6Addr -- IP6 address to create reverse string for

Return Value:

    Ptr to next location in buffer.

--*/
{
    DWORD   i;

    DNSDBG( TRACE, ( "Dns_Ip6AddressToReverseName_W()\n" ));

    //
    //  write digit for each nibble in IP6 address
    //      - in net order so lowest nibble is in highest memory
    //

    i = 16;

    while ( i-- )
    {
        BYTE thisByte = Ip6Addr.IP6Byte[i];

        pBuffer += wsprintfW(
                        pBuffer,
                        L"%x.%x.",
                        (thisByte & 0x0f),
                        (thisByte & 0xf0) >> 4
                        );
    }

    pBuffer += wsprintfW(
                    pBuffer,
                    DNS_IP6_REVERSE_DOMAIN_STRING_W );

    return( pBuffer );
}



PCHAR
Dns_Ip6AddressToReverseName_A(
    OUT     PCHAR           pBuffer,
    IN      IP6_ADDRESS     Ip6Addr
    )
/*++

Routine Description:

    Write reverse lookup name, given corresponding IP6 address

Arguments:

    pBuffer -- ptr to buffer for reverse lookup name;
        MUST contain at least DNS_MAX_IP6_REVERSE_NAME_BUFFER_LENGTH bytes

    Ip6Addr -- IP6 address to create reverse string for

Return Value:

    Ptr to next location in buffer.

--*/
{
    DWORD   i;

    DNSDBG( TRACE, ( "Dns_Ip6AddressToReverseName_A()\n" ));

    //
    //  write digit for each nibble in IP6 address
    //
    //  note we are reversing net order here
    //      since address is in net order and we are filling
    //      in least to most significant order
    //      - go DOWN through DWORDS
    //      - go DOWN through the BYTES
    //      - but we must put the lowest (least significant) nibble
    //          first as our bits are not in "bit net order"
    //          which is sending the highest bit in the byte first
    //

    i = 16;

    while ( i-- )
    {
        BYTE thisByte = Ip6Addr.IP6Byte[i];

        pBuffer += sprintf(
                        pBuffer,
                        "%x.%x.",
                        (thisByte & 0x0f),
                        (thisByte & 0xf0) >> 4
                        );
    }

    pBuffer += sprintf(
                    pBuffer,
                    DNS_IP6_REVERSE_DOMAIN_STRING );

    return( pBuffer );
}



PWSTR
_fastcall
Dns_GetDomainNameW(
    IN      PCWSTR          pwsName
    )
{
    PWSTR  pdomain;

    //
    //  find next "." in name, then return ptr to next character
    //

    pdomain = wcschr( pwsName, L'.' );

    if ( pdomain && *(++pdomain) )
    {
        return( pdomain );
    }
    return  NULL;
}



PWSTR
Dns_SplitHostFromDomainNameW(
    IN      PWSTR           pszName
    )
{
    PWSTR   pnameDomain;

    //
    //  get domain name
    //  if exists, NULL terminate host name part
    //

    pnameDomain = Dns_GetDomainNameW( (PCWSTR)pszName );
    if ( pnameDomain )
    {
        if ( pnameDomain <= pszName )
        {
            return  NULL;
        }
        *(pnameDomain-1) = 0;
    }

    return  pnameDomain;
}



//
//  Unicode copy\conversion routines
//

STATIC
PWSTR
CreateStringCopy_W(
    IN      PCWSTR          pString
    )
/*++

Routine Description:

    Create (allocate) copy of existing string.

Arguments:

    pString -- existing string

Return Value:

    Ptr to string copy -- if successful.
    NULL on allocation error.

--*/
{
    UINT    length;
    PWSTR   pnew;

    //
    //  get existing string buffer length
    //  allocate
    //  copy existing string to new
    //

    length = wcslen( pString ) + 1;

    pnew = (PWSTR) new WCHAR[ length ];

    if ( pnew )
    {
        RtlCopyMemory(
            pnew,
            pString,
            length * sizeof(WCHAR) );
    }

    return  pnew;
}



PSTR
CreateStringCopy_UnicodeToAnsi(
    IN      PCWSTR          pString
    )
/*++

Routine Description:

    Create (allocate) copy of existing string.

Arguments:

    pString -- existing string

Return Value:

    Ptr to string copy -- if successful.
    NULL on allocation error.

--*/
{
    INT     length;
    PSTR    pnew;
    DWORD   lastError = NO_ERROR;

    //
    //  NULL handling
    //

    if ( !pString )
    {
        return NULL;
    }

    //
    //  get required ANSI length
    //

    length = WideCharToMultiByte(
                CP_ACP,
                0,          // no flags
                pString,
                (-1),       // NULL terminated
                NULL,
                0,          // call determines required buffer length
                NULL,
                NULL
                );
    if ( length == 0 )
    {
        lastError = ERROR_INVALID_PARAMETER;
        goto Failed;
    }
    length++;       // safety

    //
    //  allocate
    //

    pnew = (PSTR) new CHAR[ length ];
    if ( !pnew )
    {
        lastError = EAI_MEMORY;
        goto Failed;
    }

    //
    //  convert to ANSI
    //

    length = WideCharToMultiByte(
                CP_ACP,
                0,          // no flags
                pString,
                (-1),       // NULL terminated
                pnew,       // buffer
                length,     // buffer length
                NULL,
                NULL
                );
    if ( length == 0 )
    {
        lastError = GetLastError();
        delete pnew;
        goto Failed;
    }

    return  pnew;

Failed:

    SetLastError( lastError );
    return  NULL;
}



PWSTR
CreateStringCopy_AnsiToUnicode(
    IN      PCSTR           pString
    )
/*++

Routine Description:

    Create (allocate) copy of existing string.

Arguments:

    pString -- existing ANSI string

Return Value:

    Ptr to unicode string copy -- if successful.
    NULL on allocation error.

--*/
{
    INT     length;
    PWSTR   pnew;
    DWORD   lastError = NO_ERROR;

    //
    //  NULL handling
    //

    if ( !pString )
    {
        return NULL;
    }

    //
    //  get required unicode length
    //

    length = MultiByteToWideChar(
                CP_ACP,
                0,          // no flags
                pString,
                (-1),       // NULL terminated
                NULL,
                0           // call determines required buffer length
                );
    if ( length == 0 )
    {
        lastError = GetLastError();
        goto Failed;
    }
    length++;       // safety

    //
    //  allocate
    //

    pnew = (PWSTR) new WCHAR[ length ];
    if ( !pnew )
    {
        lastError = EAI_MEMORY;
        goto Failed;
    }

    //
    //  convert to unicode
    //

    length = MultiByteToWideChar(
                CP_ACP,
                0,          // no flags
                pString,
                (-1),       // NULL terminated
                pnew,       // buffer
                length      // buffer length
                );
    if ( length == 0 )
    {
        lastError = GetLastError();
        delete pnew;
        goto Failed;
    }

    return  pnew;

Failed:

    SetLastError( lastError );
    return  NULL;
}



INT
ConvertAddrinfoFromUnicodeToAnsi(
    IN OUT  PADDRINFOW      pAddrInfo
    )
/*++

Routine Description:

    Convert addrinfo from unicode to ANSI.

    Conversion is done in place.

Arguments:

    pAddrInfo -- existing unicode verion.

Return Value:

    NO_ERROR if successful.
    ErrorCode on conversion\allocation failure.

--*/
{
    PADDRINFOW  pnext = pAddrInfo;
    PADDRINFOW  pcur;
    PWSTR       pname;
    PSTR        pnew;

    //
    //  convert canonname string in addrinfos
    //

    while ( pcur = pnext )
    {
        pnext = pcur->ai_next;

        pname = pcur->ai_canonname;
        if ( pname )
        {
            pnew = CreateStringCopy_UnicodeToAnsi( pname );
            if ( !pnew )
            {
                return  GetLastError();
            }
            delete pname;
            pcur->ai_canonname = (PWSTR) pnew;
        }
    }

    return  NO_ERROR;
}


//
//* SortIPAddrs - sort addresses of the same family.
//
//  A wrapper around a sort Ioctl.  If the Ioctl isn't implemented, 
//  the sort is a no-op.
//

int
SortIPAddrs(
    IN      int                     af,
    OUT     LPVOID                  Addrs,
    IN OUT  u_int *                 pNumAddrs,
    IN      u_int                   width,
    OUT     SOCKET_ADDRESS_LIST **  pAddrlist
    )
{
    DWORD           status = NO_ERROR;
    SOCKET          s = 0;
    DWORD           bytesReturned;
    DWORD           size;
    DWORD           i;
    PSOCKADDR       paddr;
    UINT            countAddrs = *pNumAddrs;

    PSOCKET_ADDRESS_LIST    paddrlist = NULL;

    //
    //  open a socket in the specified address family.
    //
    //  DCR:  SortIpAddrs dumps addresses if not supported by stack
    //
    //      this makes some sense at one level but is still silly
    //      in implementation, because by the time this is called we
    //      can't go back and query for the other protocol;
    //
    //      in fact, the way this was first implemented:  if no
    //      hint is given you query for AAAA then A;  and since
    //      you stop as soon as you get results -- you're done
    //      and stuck with AAAA which you then dump here if you
    //      don't have the stack!  hello
    //
    //      it strikes me that you test for the stack FIRST before
    //      the query, then live with whatever results you get
    //

#if 0
    s = socket( af, SOCK_DGRAM, 0 );
    if ( s == INVALID_SOCKET )
    {
        status = WSAGetLastError();

        if (status == WSAEAFNOSUPPORT) {
            // Address family is not supported by the stack.
            // Remove all addresses in this address family from the list.
            *pNumAddrs = 0;
            return 0;
        }
        return status;
    }
#endif

#if 0
    // Ok, stack is installed, but is it running?
    //
    // We do not care if stack is installed but is not running.
    // Whoever stopped it, must know better what he/she was doing.
    //
    // Binding even to wildcard address consumes valueable machine-global
    // resource (UDP port) and may have unexpected side effects on
    // other applications running on the same machine (e.g. an application
    // running frequent getaddrinfo queries would adversly imact
    // (compete with) application(s) on the same machine trying to send
    // datagrams from wildcard ports).
    //
    // If someone really really wants to have this code check if the
    // stack is actually running, he/she should do it inside of WSAIoctl
    // call below and return a well-defined error code to single-out
    // the specific case of stack not running.
    //

    memset(&TestSA, 0, sizeof(TestSA));
    TestSA.ss_family = (short)af;
    status = bind(s, (LPSOCKADDR)&TestSA, sizeof(TestSA));
    if (status == SOCKET_ERROR)
    {
        // Address family is not currently supported by the stack.
        // Remove all addresses in this address family from the list.
        closesocket(s);
        return 0;
    }
#endif

    //
    //  build SOCKET_ADDRESS_LIST
    //      - allocate
    //      - fill in with pointers into SOCKADDR array
    //

    size = FIELD_OFFSET( SOCKET_ADDRESS_LIST, Address[countAddrs] );
    paddrlist = (SOCKET_ADDRESS_LIST *)new BYTE[size];

    if ( !paddrlist )
    {
        status = WSA_NOT_ENOUGH_MEMORY;
        goto Done;
    }

    for ( i=0; i<countAddrs; i++ )
    {
        paddr = (PSOCKADDR) (((PBYTE)Addrs) + i * width);
        paddrlist->Address[i].lpSockaddr      = paddr;
        paddrlist->Address[i].iSockaddrLength = width;
    }
    paddrlist->iAddressCount = countAddrs;

    //
    //  sort if multiple addresses and able to open socket
    //      - open socket of desired type for sort
    //      - sort, if sort fails just return unsorted
    //

    if ( countAddrs > 1 )
    {
        s = socket( af, SOCK_DGRAM, 0 );
        if ( s == INVALID_SOCKET )
        {
            s = 0;
            goto Done;
        }

        status = WSAIoctl(
                    s,
                    SIO_ADDRESS_LIST_SORT,
                    (LPVOID)paddrlist,
                    size,
                    (LPVOID)paddrlist,
                    size,
                    & bytesReturned,
                    NULL,
                    NULL );

        if ( status == SOCKET_ERROR )
        {
            status = NO_ERROR;
#if 0
            status = WSAGetLastError();
            if (status==WSAEINVAL) {
                // Address family does not support this IOCTL
                // Addresses are valid but no sort is done.
                status = NO_ERROR;
            }
#endif
        }
    }

Done:

    if ( status == NO_ERROR )
    {
        *pNumAddrs = paddrlist->iAddressCount;
        *pAddrlist = paddrlist;
    }

    if ( s != 0 )
    {
        closesocket(s);
    }

    return status;
}


STATIC
LPADDRINFO
NewAddrInfo(
    IN      int             ProtocolFamily,
    IN      int             SocketType,     OPTIONAL
    IN      int             Protocol,       OPTIONAL
    IN OUT  PADDRINFO **    ppPrev
    )
/*++

Routine Description:

    Creates (allocates) new ADDRINFO struct, including sockaddr.

    Internal helper function.

Arguments:

    ProtocolFamily -- must be either PF_INET or PF_INET6

    SockType -- type, optional

    Protocol -- protocol, optional

    ppPrev -- addrinfo list (ptr to previous entries next field)

Return Value:

    Ptr to new ADDRINFO if successful.
    NULL on error.

--*/
{
    LPADDRINFO  pnew;
    DWORD       sockaddrLength;

    //
    //  DCR:  standard length (and other params) for family function
    //
    //  note:  assuming we're here with valid family
    //

    if ( ProtocolFamily == PF_INET6 )
    {
        sockaddrLength = sizeof(SOCKADDR_IN6);
    }
    else if ( ProtocolFamily == PF_INET )
    {
        sockaddrLength = sizeof(SOCKADDR_IN);
    }
    else
    {
        ASSERT( FALSE );
        return  NULL;
    }

    //
    //  allocate a new addrinfo struct
    //

    pnew = (LPADDRINFO) new BYTE[sizeof(ADDRINFO)];
    if ( !pnew )
    {
        return NULL;
    }

    //
    //  fill struct
    //

    pnew->ai_next        = NULL;
    pnew->ai_flags       = 0;
    pnew->ai_family      = ProtocolFamily;
    pnew->ai_socktype    = SocketType;
    pnew->ai_protocol    = Protocol;
    pnew->ai_addrlen     = sockaddrLength;
    pnew->ai_canonname   = NULL;
    
    pnew->ai_addr = (PSOCKADDR) new BYTE[sockaddrLength];
    if ( !pnew->ai_addr )
    {
        delete pnew;
        return NULL;
    }

    //
    //  link to tail of addrinfo list
    //      - ppPrevTail points at previous entry's next field
    //      - set it to new
    //      - then repoint at new addrinfo's next field
    //

    **ppPrev = pnew;
    *ppPrev = &pnew->ai_next;

    return pnew;
}


INT
AppendAddrInfo(
    IN      PSOCKADDR       pAddr, 
    IN      INT             SocketType,     OPTIONAL
    IN      INT             Protocol,       OPTIONAL
    IN OUT  PADDRINFO **    ppPrev
    )
/*++

Routine Description:

    Create ADDRINFO for sockaddr and append to list.

Arguments:

    pAddr -- sockaddr to create ADDRINFO for

    SockType -- type, optional

    Protocol -- protocol, optional

    ppPrev -- addrinfo list (ptr to previous entries next field)

Return Value:

    NO_ERROR if successful.
    EAI_MEMORY on failure.

--*/
{
    INT         family = pAddr->sa_family;
    LPADDRINFO  pnew;

    pnew = NewAddrInfo(
                family,
                SocketType,
                Protocol,
                ppPrev );
    if ( !pnew )
    {
        return EAI_MEMORY;
    }

    RtlCopyMemory(
        pnew->ai_addr,
        pAddr,
        pnew->ai_addrlen );

    return NO_ERROR;
}


VOID
UnmapV4Address(
    OUT     LPSOCKADDR_IN   pV4Addr, 
    IN      LPSOCKADDR_IN6  pV6Addr
    )
/*++

Routine Description:

    Map IP6 sockaddr with IP4 mapped address into IP4 sockaddr.

    Note:  no checked that address IP4 mapped\compatible.

Arguments:

    pV4Addr -- ptr to IP4 sockaddr to write

    pV6Addr -- ptr to IP6 sockaddr with mapped-IP4 address

Return Value:

    None

--*/
{
    pV4Addr->sin_family = AF_INET;
    pV4Addr->sin_port   = pV6Addr->sin6_port;

    memcpy(
        &pV4Addr->sin_addr,
        &pV6Addr->sin6_addr.s6_addr[12],
        sizeof(struct in_addr) );

    memset(
        &pV4Addr->sin_zero,
        0,
        sizeof(pV4Addr->sin_zero) );
}


BOOL
IsIp6Running(
    VOID
    )
/*++

Routine Description:

    Is IP6 running?

Arguments:

    None

Return Value:

    TRUE if IP6 stack is up.
    FALSE if down.

--*/
{
    SOCKET  s;

    //
    //  test is IP6 up by openning IP6 socket
    //

    s = socket(
            AF_INET6,
            SOCK_DGRAM,
            0
            );
    if ( s != INVALID_SOCKET )
    {
        closesocket( s );
        return( TRUE );
    }
    return( FALSE );
}



INT
QueryDnsForFamily(
    IN      PCWSTR          pwsName,
    IN      DWORD           Family,
    IN OUT  PSOCKADDR *     ppAddrArray,
    IN OUT  PUINT           pAddrCount,
    IN OUT  PWSTR *         ppAlias,
    IN      USHORT          ServicePort
    )
/*++

Routine Description:

    Make the DNS query for desired family.

    Helper routine for getaddrinfo().

Arguments:

    pwsName -- name to query

    Family -- address family

    ppAddrArray -- address of ptr to sockaddr array
        (caller must free)

    pAddrCount -- addr to recv sockaddr count returned

    ppAlias -- addr to recv alias ptr (if any)
        (caller must free)

    ServicePort -- service port (will be stamped in sockaddrs)


Return Value:

    NO_ERROR if successful.
    Win32 error on failure.

--*/
{
    //STATIC GUID     DnsAGuid = SVCID_DNS(T_A);
    STATIC GUID     DnsAGuid = SVCID_INET_HOSTADDRBYNAME;
    STATIC GUID     DnsAAAAGuid = SVCID_DNS(T_AAAA);
    CHAR            buffer[sizeof(WSAQUERYSETW) + 2048];
    DWORD           bufSize;
    PWSAQUERYSETW   pquery = (PWSAQUERYSETW) buffer;
    HANDLE          handle = NULL;
    INT             err;
    PBYTE           pallocBuffer = NULL;
    LPGUID          pguid;
    DWORD           familySockaddrLength;

    //
    //  currently support only IP4 and IP6
    //

    if ( Family == AF_INET )
    {
        //pguid = g_ARecordGuid;
        pguid = &DnsAGuid;
        familySockaddrLength = sizeof(SOCKADDR_IN);
    }
    else if ( Family == AF_INET6 )
    {
        //pguid = g_AAAARecordGuid;
        pguid = &DnsAAAAGuid;
        familySockaddrLength = sizeof(SOCKADDR_IN6);
    }
    else
    {
        return  EAI_FAMILY;
    }

    //
    //  build winsock DNS query for desired type
    //

    memset( pquery, 0, sizeof(*pquery) );

    pquery->dwSize = sizeof(*pquery);
    pquery->lpszServiceInstanceName = (PWSTR)pwsName;
    pquery->dwNameSpace = NS_DNS;
    pquery->lpServiceClassId = pguid;

    //
    //  initiate DNS query
    //

    err = WSALookupServiceBeginW(
                pquery,
                LUP_RETURN_ADDR | LUP_RETURN_NAME,
                & handle
                );
    if ( err )
    {
        err = WSAGetLastError();
        if ( err == 0 || err == WSASERVICE_NOT_FOUND )
        {
            err = WSAHOST_NOT_FOUND;
        }
        return err;
    }

    //
    //  get the data
    //  in loop to
    //      - requery if buffer is too small
    //      - get all the aliases
    //
    // REVIEW: It's not clear to me that this is implemented
    // REVIEW: right, shouldn't we be checking for a WSAEFAULT and
    // REVIEW: then either increase the pqueryset buffer size or
    // REVIEW: set LUP_FLUSHPREVIOUS to move on for the next call?
    // REVIEW: Right now we just bail in that case.
    //

    bufSize = sizeof( buffer );

    for (;;)
    {
        DWORD   bufSizeQuery = bufSize;

        err = WSALookupServiceNextW(
                    handle,
                    0,
                    & bufSizeQuery,
                    pquery );
        if ( err )
        {
            err = WSAGetLastError();
            if ( err == WSAEFAULT )
            {
                if ( !pallocBuffer )
                {
                    pallocBuffer = new BYTE[ bufSizeQuery ];
                    if ( pallocBuffer )
                    {
                        bufSize = bufSizeQuery;
                        pquery = (PWSAQUERYSETW) pallocBuffer;
                        continue;
                    }
                    err = WSA_NOT_ENOUGH_MEMORY;
                }
                //  else ASSERT on WSAEFAULT if alloc'd buf
                goto Cleanup;
            }
            break;
        }

        //
        //  collect returned addresses
        //      - check correct family, sockaddr length
        //
        //  note:  there's no good common screen on CSADDR protocol
        //  and socktype fields;  for IP6 (PF_INET6 and SOCK_RAW)
        //  for IP4 (IPPROTO_TCP\UDP and SOCK_STREAM\DGRAM)
        //  

        if ( pquery->dwNumberOfCsAddrs != 0 )
        {
            DWORD       iter;
            DWORD       count;
            PSOCKADDR   psaArray;
            PSOCKADDR   pwriteSa;

            //
            //  allocate sockaddr array
            //
            //  note the approach here;  everything is treated as sockaddr_in6
            //  as it subsumes the V4 -- same adequate space, good alignment,
            //  port in same location
            //
            //  alternatively we could allocate based on familySockaddrLength
            //  and reference into the array either explicitly (alignment!) or
            //  by casting, then do setting for individual families
            //

            psaArray = (PSOCKADDR) new BYTE[ familySockaddrLength *
                                                 pquery->dwNumberOfCsAddrs ];
            if ( !psaArray )
            {
                err = WSA_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            //
            //  fill sockaddr array from CSADDRs
            //      - sockaddr is preserved except for port overwritten
            //

            count = 0;
            pwriteSa = psaArray;

            for (iter = 0; iter < pquery->dwNumberOfCsAddrs; iter++)
            {
                PCSADDR_INFO    pcsaddr = &pquery->lpcsaBuffer[iter];
                PSOCKADDR       psa = pcsaddr->RemoteAddr.lpSockaddr;

                if ( pcsaddr->RemoteAddr.iSockaddrLength == (INT)familySockaddrLength  &&
                     psa &&
                     psa->sa_family == Family )
                {
                    RtlCopyMemory(
                        pwriteSa,
                        psa,
                        familySockaddrLength );

                    ((PSOCKADDR_IN6)pwriteSa)->sin6_port = ServicePort;

                    pwriteSa = (PSOCKADDR) ((PBYTE)pwriteSa + familySockaddrLength);
                    count++;
                }
            }
            
            //
            //  jwesth - Feb 15/2003
            //
            //  If we allocated an address array in the last iteration it
            //  will be stomped on and leaked when we pass through the loop
            //  again. I'm not sure what the right thing to do with the
            //  array is, but since currently we are just dropping it on
            //  the floor it seems good to free it and forget about it.
            //

            if ( *ppAddrArray )
            {
                delete *ppAddrArray;
            }
            
            //
            //  If we didn't write out any addresses, free the address array.
            //

            if ( count == 0 )
            {
                delete psaArray;
                psaArray = NULL;
            }
            
            *pAddrCount = count;
            *ppAddrArray = psaArray;
        }

        //
        //  get the canonical name
        //      - this is either the service name OR
        //      the name back on repeated query
        //

        if ( pquery->lpszServiceInstanceName != NULL )
        {
            DWORD   length;
            PWSTR   palias;

            length = (wcslen(pquery->lpszServiceInstanceName) + 1) * sizeof(WCHAR);
            palias = *ppAlias;

            if ( !palias )
            {
                palias = (PWSTR) new BYTE[length];
            }
            else
            {
                palias = (PWSTR) renew( palias, length );
            }
            if ( !palias )
            {
                err = WSA_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            RtlCopyMemory(
                palias,
                pquery->lpszServiceInstanceName,
                length );

            *ppAlias = palias;
        }
    }

    err = 0;

Cleanup:

    //
    //  close out NSP pquery
    //  free buffer allocated to hold pquery results
    //

    if ( handle )
    {
        WSALookupServiceEnd(handle);
    }
    if ( pallocBuffer )
    {
        delete pallocBuffer;
    }

    return err;
}



//* QueryDNS
//
//  Helper routine for getaddrinfo
//  that performs name resolution by querying the DNS.
//
//  This helper function always initializes
//  *pAddrs, *pNumAddrs, and *pAlias
//  and may return memory that must be freed,
//  even if it returns an error code.
//
//  Return values are WSA error codes, 0 means success.
//
//  The NT4 DNS name space resolver (rnr20.dll) does not
//  cache replies when you request a specific RR type.
//  This means that every call to getaddrinfo
//  results in DNS message traffic. There is no caching!
//  On NT5 there is caching because the resolver understands AAAA.
//

STATIC
INT
QueryDns(
    IN      PCWSTR          pName,
    IN      UINT            LookupType,
    OUT     PSOCKADDR_IN *  pAddrs4,
    OUT     PUINT           pNumAddrs4,
    OUT     PSOCKADDR_IN6 * pAddrs6,
    OUT     PUINT           pNumAddrs6,
    OUT     PWSTR *         ppAlias,
    IN      USHORT          ServicePort
    )
/*++

Routine Description:

    Make the DNS query for desired family.

    Helper routine for getaddrinfo().

Arguments:

    ppAddrArray -- address of ptr to sockaddrs

Return Value:

    None

--*/
{
    UINT    aliasCount = 0;
    PWSTR   pname = (PWSTR) pName;
    INT     err;

    //
    //  init -- zero address and alias lists
    //

    *pAddrs4 = NULL;
    *pNumAddrs4 = 0;
    *pAddrs6 = NULL;
    *pNumAddrs6 = 0;
    *ppAlias = NULL;

    //
    //  query DNS provider
    //
    //  querying in a loop to allow us to chase alias chain
    //  if DNS server fails (not configured) to do so
    //

    while ( 1 )
    {
        //
        //  query separately for IP4 and IP6
        //

        if ( LookupType & L_AAAA )
        {
            err = QueryDnsForFamily(
                        pname,
                        AF_INET6,
                        (PSOCKADDR *) pAddrs6,
                        pNumAddrs6,
                        ppAlias,
                        ServicePort );

            if ( err != NO_ERROR )
            {
                break;
            }
        }

        if ( LookupType & L_A )
        {
            err = QueryDnsForFamily(
                        pname,
                        AF_INET,
                        (PSOCKADDR *) pAddrs4,
                        pNumAddrs4,
                        ppAlias,
                        ServicePort );

            if ( err != NO_ERROR )
            {
                break;
            }
        }

        //
        //  If we found addresses, then we are done.
        //

        if ( (*pNumAddrs4 != 0) || (*pNumAddrs6 != 0) )
        {
            err = 0;
            break;
        }

        //
        //  if no addresses but alias -- follow CNAME chain
        //
        //  DCR:  CNAME chain chasing resolver
        //      DNS server generally should do this -- our push into resolver itself
        //

        if ( (*ppAlias != NULL) &&
             (wcscmp(pname, *ppAlias) != 0) )
        {
            PWSTR   palias;

            //
            // Stop infinite loops due to DNS misconfiguration.
            // There appears to be no particular recommended
            // limit in RFCs 1034 and 1035.
            //
            //  DCR:  use standard CNAME limit #define here
            //

            if ( ++aliasCount > 8 )
            {
                err = WSANO_RECOVERY;
                break;
            }

            //
            // If there was a new CNAME, then look again.
            // We need to copy *ppAlias because *ppAlias
            // could be deleted during the next iteration.
            //

            palias = CreateStringCopy_W( *ppAlias );
            if ( !palias )
            {
                err = WSA_NOT_ENOUGH_MEMORY;
                break;
            }

            //
            //  do query again, with using this alias as name
            //

            if ( pname != pName )
            {
                delete pname;
            }
            pname = palias;
        }

        else if (LookupType >> NUM_ADDRESS_FAMILIES)
        {
            //
            // Or we were looking for one type and are willing to take another.
            // Switch to secondary lookup type.
            //
            LookupType >>= NUM_ADDRESS_FAMILIES;  
        }
        else
        {
            //
            // This name does not resolve to any addresses.
            //
            err = WSAHOST_NOT_FOUND;
            break;
        }
    }

    //
    //  cleanup any internal alias allocation
    //

    if ( pname != pName )
    {
        delete pname;
    }
    return err;
}



//* LookupNode - Resolve a nodename and add any addresses found to the list.
//
//  Internal function, not exported.  Expects to be called with valid
//  arguments, does no checking.
//
//  Note that if AI_CANONNAME is requested, then **Prev should be NULL
//  because the canonical name should be returned in the first addrinfo
//  that the user gets.
//
//  Returns 0 on success, an EAI_* style error value otherwise.
//
//  DCR:  extra memory allocation
//      the whole paradigm here
//          - query DNS
//          - alloc\realloc SOCKADDR for each address building array
//          - build SOCKET_ADDRESS_LIST to sort
//          - build ADDRINFO for each SOCKADDR
//      seems to have an unnecessary step -- creating the first SOCKADDR
//      we could just build the ADDRINFO blobs we want from the CSADDR
//      WHEN NECESSARY build the SOCKET_ADDRESS_LIST to do the sort
//          and rearrange the ADDRINFOs to match
//
//      OR (if that's complicated)
//          just build one big SOCKADDR array and SOCKET_ADDRESS_LIST
//          array from CSADDR count
//

INT
LookupAddressForName(            
    IN      PCWSTR          pNodeName,      // Name of node to resolve.
    IN      INT             ProtocolFamily, // Must be zero, PF_INET, or PF_INET6.
    IN      INT             SocketType,     // SOCK_*.  Can be wildcarded (zero).
    IN      INT             Protocol,       // IPPROTO_*.  Can be wildcarded (zero).
    IN      USHORT          ServicePort,    // Port number of service.
    IN      INT             Flags,          // Flags.
    IN OUT  ADDRINFOW ***   ppPrev          // In/out param for accessing previous ai_next.
    )
{
    UINT                    lookupFlag;
    UINT                    numAddr6;
    UINT                    numAddr4;
    PSOCKADDR_IN            paddr4 = NULL;
    PSOCKADDR_IN6           paddr6 = NULL;
    PWSTR                   palias = NULL;
    INT                     status;
    UINT                    i;
    SOCKET_ADDRESS_LIST *   paddrList4 = NULL;
    SOCKET_ADDRESS_LIST *   paddrList6 = NULL;
    PADDRINFOW  *           pfirstAddr = *ppPrev;

    //
    //  set query types based on family hint
    //
    //      - if no family query for IP4 and
    //      IP6 ONLY if IP6 stack is installed
    //
    //  DCR:  in future releases change this so select protocols
    //      of all stacks running
    //

    switch (ProtocolFamily)
    {
    case 0:

        lookupFlag = 0;
        if ( IsIp4Running() )
        {
            lookupFlag |= L_A;
        }
        if ( IsIp6Running() )
        {
            lookupFlag |= L_AAAA;
        }
        break;

    case PF_INET:
        lookupFlag = L_A;
        break;

    case PF_INET6:
        lookupFlag = L_AAAA;
        break;

    default:
        return EAI_FAMILY;
    }

    //
    //  query
    //

    status = QueryDns(
                pNodeName,
                lookupFlag,
                & paddr4,
                & numAddr4,
                & paddr6,
                & numAddr6,
                & palias,
                ServicePort
                );

    if ( status != NO_ERROR )
    {
        if ( status == WSANO_DATA )
        {
            status = EAI_NODATA;
        }
        else if ( status == WSAHOST_NOT_FOUND )
        {
            status = EAI_NONAME;
        }
        else
        {
            status = EAI_FAIL;
        }
        goto Done;
    }

    //
    //  sort addresses to best order
    //

    if ( numAddr6 > 0 )
    {
        status = SortIPAddrs(
                    AF_INET6,
                    (LPVOID)paddr6,
                    &numAddr6,
                    sizeof(SOCKADDR_IN6),
                    &paddrList6 );

        if ( status != NO_ERROR )
        {
            status = EAI_FAIL;
            goto Done;
        }
    }

    if ( numAddr4 > 0 )
    {
        status = SortIPAddrs(
                    AF_INET,
                    (LPVOID)paddr4,
                    &numAddr4,
                    sizeof(SOCKADDR_IN),
                    &paddrList4 );

        if ( status != NO_ERROR )
        {
            status = EAI_FAIL;
            goto Done;
        }
    }

    //
    //  build addrinfo structure for each address returned
    //
    //  for IP6 v4 mapped addresses
    //      - if querying EXPLICITLY for IP6 => dump
    //      - if querying for anything => turn into IP4 addrinfo
    //

    for ( i = 0;  !status && (i < numAddr6); i++)
    {
        PSOCKADDR_IN6   psa = (PSOCKADDR_IN6) paddrList6->Address[i].lpSockaddr;

        if ( IN6_IS_ADDR_V4MAPPED( &psa->sin6_addr ) )
        {
            if ( ProtocolFamily != PF_INET6 )
            {
                SOCKADDR_IN sockAddr4;

                UnmapV4Address(
                    &sockAddr4,
                    psa );
    
                status = AppendAddrInfo(
                            (PSOCKADDR) &sockAddr4,
                            SocketType,
                            Protocol,
                            (LPADDRINFO **) ppPrev );
            }
        }
        else
        {
            status = AppendAddrInfo(
                        (PSOCKADDR) psa,
                        SocketType,
                        Protocol,
                        (LPADDRINFO **) ppPrev );
        }
    }

    for ( i = 0;  !status && (i < numAddr4);  i++ )
    {
        status = AppendAddrInfo(
                    paddrList4->Address[i].lpSockaddr,
                    SocketType,
                    Protocol,
                    (LPADDRINFO **) ppPrev );
    }

    //
    //  fill in canonname of first addrinfo
    //      - only if CANNONNAME flag set
    //
    //  canon name is
    //      - actual name of address record if went through CNAME (chain)
    //      - otherwise the passed in name we looked up
    //
    //  DCR:  should canon name be the APPENDED name we queried for?
    //


    if ( *pfirstAddr && (Flags & AI_CANONNAME) )
    {
        if ( palias )
        {
            //  alias is the canonical name

            (*pfirstAddr)->ai_canonname = palias;
            palias = NULL;
        }
        else
        {
            if ( ! ((*pfirstAddr)->ai_canonname = CreateStringCopy_W( pNodeName ) ) )
            {
                status = EAI_MEMORY;
                goto Done;
            }
        }

        // Turn off flag so we only do this once.
        Flags &= ~AI_CANONNAME;
    }

Done:

    if ( paddrList4 )
    {
        delete paddrList4;
    }
    if ( paddrList6 )
    {
        delete paddrList6;
    }
    if ( paddr4 )
    {
        delete paddr4;
    }
    if ( paddr6 )
    {
        delete paddr6;
    }
    if ( palias )
    {
        delete palias;
    }

    return status;
}



//* ParseV4Address
//
//  Helper function for parsing a literal v4 address, because
//  WSAStringToAddress is too liberal in what it accepts.
//  Returns FALSE if there is an error, TRUE for success.
//
//  The syntax is a.b.c.d, where each number is between 0 - 255.
//
//  DCR:  inet_addr() with test for 255.255.255.255 and three dots does the trick
//

#if 0
BOOL
ParseV4AddressW(
    IN      PCWSTR          String,
    OUT     PIN_ADDR        pInAddr
    )
{
    INT i;

    for ( i = 0; i < 4; i++ )
    {
        UINT    number = 0;
        UINT    numChars = 0;
        WCHAR   ch;

        for (;;)
        {
            ch = *String++;

            //  string termination

            if (ch == L'\0')
            {
                if ((numChars > 0) && (i == 3))
                    break;
                else
                    return FALSE;
            }

            //  separating dot

            else if (ch == L'.')
            {
                if ((numChars > 0) && (i < 3))
                    break;
                else
                    return FALSE;
            }

            //  another digit

            else if ((L'0' <= ch) && (ch <= L'9'))
            {
                if ((numChars != 0) && (number == 0))
                    return FALSE;
                else if (++numChars <= 3)
                    number = 10*number + (ch - L'0');
                else
                    return FALSE;
            }

            //  bogus char for IP string

            else
            {
                return FALSE;
            }
        }

        if ( number > 255 )
        {
            return FALSE;
        }

        ((PBYTE)pInAddr)[i] = (BYTE)number;
    }

    return TRUE;
}
#endif



#if 0
IP4_ADDRESS
WSAAPI
inet_addrW(
    IN      PCWSTR          pString
    )
/*++
Routine Description:

    Convert unicode string to IP4 address.

Arguments:

    pString -- string to convert

Returns:

    If no error occurs, inet_addr() returns an unsigned long containing a
    suitable binary representation of the Internet address given.  If the
    passed-in string does not contain a legitimate Internet address, for
    example if a portion of an "a.b.c.d" address exceeds 255, inet_addr()
    returns the value INADDR_NONE.

--*/
{
    IN_ADDR     value;      // value to return to the user
    PCWSTR      pnext = NULL;
    NTSTATUS    status;
   
#if 0
    __try
    {
        //
        //  Special case: we need to make " " return 0.0.0.0 because MSDN
        //  says it does.
        //

        if ( (pString[0] == ' ') && (pString[1] == '\0') )
        {
            return( INADDR_ANY );
        }
#endif
        status = RtlIpv4StringToAddressW(
                    pString,
                    FALSE,
                    & pnext,
                    & value );

        if ( !NT_SUCCESS(status) )
        {
            return( INADDR_NONE );
        }
#if 0
        //
        //  Check for trailing characters. A valid address can end with
        //  NULL or whitespace.  
        //
        //  N.B. To avoid bugs where the caller hasn't done setlocale()
        //  and passes us a DBCS string, we only allow ASCII whitespace.
        //
        if (*cp && !(isascii(*cp) && isspace(*cp))) {
            return( INADDR_NONE );
        }
#endif
        //
        //  any trailing character, nullifies conversion
        //

        if ( pnext && *pnext )
        {
            return( INADDR_NONE );
        }
#if 0
    }
    __except (WS2_EXCEPTION_FILTER())
    {
        SetLastError (WSAEFAULT);
        return (INADDR_NONE);
    }
#endif

    return( value.s_addr );
}
#endif



BOOL
GetIp4Address(
    IN      PCWSTR          pString,
    IN      BOOL            fStrict,
    OUT     PIP4_ADDRESS    pAddr
    )
{
    DNS_STATUS  status;
    IP4_ADDRESS ip;
    PCWSTR      pnext = NULL;

    //
    //  try conversion
    //

    status = RtlIpv4StringToAddressW(
                pString,
                FALSE,
                & pnext,
                (PIN_ADDR) &ip );

    if ( !NT_SUCCESS(status) )
    {
        return  FALSE;
    }

    //
    //  any trailing character, nullifies conversion
    //

    if ( pnext && *pnext )
    {
        return  FALSE;
    }

    //
    //  if strict verify three dot notation
    //

    if ( fStrict )
    {
        PWSTR   pdot = (PWSTR) pString;
        DWORD   count = 3;

        while ( count-- )
        {
            pdot = wcschr( pdot, L'.' );
            if ( !pdot++ )
            {
                return  FALSE;
            }
        }
    }

    *pAddr = ip;
    return  TRUE;
}



INT
WSAAPI
ServiceNameLookup(
    IN      PCWSTR          pServiceName,
    IN      PINT            pSockType,
    IN      PWORD           pPort
    )
/*++

Routine Description:

    Service lookup for getaddrinfo().

Arguments:

    pServiceName    - service to lookup

    pSockType       - addr of socket type

    pPort           - addr to receive port

Return Value:

    NO_ERROR if successful.
    Winsock error code on failure.

--*/
{
    INT         sockType;
    WORD        port = 0;
    WORD        portUdp;
    WORD        portTcp;
    INT         err = NO_ERROR;
    PCHAR       pend;
    PSERVENT    pservent;
    CHAR        nameAnsi[ MAX_SERVICE_NAME_LENGTH ];

#if 0
    //
    //  service name check
    //

    if ( !pServiceName )
    {
        ASSERT( FALSE );
        *pPort = 0;
        return  NO_ERROR;
    }
#endif

    //  unpack socket type

    sockType = *pSockType;

    //
    //  convert service name to ANSI
    //
    
    if ( ! WideCharToMultiByte(
                CP_ACP,                 // convert to ANSI
                0,                      // no flags
                pServiceName,
                (INT) (-1),             // NULL terminated service name
                nameAnsi,
                MAX_SERVICE_NAME_LENGTH,
                NULL,                   // no default char
                NULL                    // no default char check
                ) )
    {
        err = EAI_SERVICE;
        goto Done;
    }

    //
    //  check of name as port number
    //

    port = htons( (USHORT)strtoul( nameAnsi, &pend, 10) );
    if ( *pend == 0 )
    {
        goto Done;
    }

    //
    //  service name lookup
    //
    //  we try both TCP and UDP unless locked down to specific lookup
    //
    //  We have to look up the service name.  Since it may be
    //  socktype/protocol specific, we have to do multiple lookups
    //  unless our caller limits us to one.
    //  
    //  Spec doesn't say whether we should use the pHints' ai_protocol
    //  or ai_socktype when doing this lookup.  But the latter is more
    //  commonly used in practice, and is what the spec implies anyhow.
    //

    portTcp = 0;
    portUdp = 0;

    //
    //  TCP lookup
    //

    if ( sockType != SOCK_DGRAM )
    {
        pservent = getservbyname( nameAnsi, "tcp");
        if ( pservent != NULL )
        {
            portTcp = pservent->s_port;
        }
        else
        {
            err = WSAGetLastError();
            if ( err == WSANO_DATA )
            {
                err = EAI_SERVICE;
            }
            else
            {
                err = EAI_FAIL;
            }
        }
    }

    //
    //  UDP lookup
    //

    if ( sockType != SOCK_STREAM )
    {
        pservent = getservbyname( nameAnsi, "udp" );
        if ( pservent != NULL )
        {
            portUdp = pservent->s_port;
        }
        else
        {
            err = WSAGetLastError();
            if ( err == WSANO_DATA )
            {
                err = EAI_SERVICE;
            }
            else
            {
                err = EAI_FAIL;
            }
        }
    }

    //
    //  adjudicate both TCP and UDP successful
    //      - TCP takes precendence
    //      - lockdown sockType to match successful protocol

    port = portTcp;

    if ( portTcp != portUdp )
    {
        if ( portTcp != 0 )
        {
            ASSERT( sockType != SOCK_DGRAM );

            sockType = SOCK_STREAM;
            port = portTcp;
        }
        else
        {
            ASSERT( sockType != SOCK_STREAM );
            ASSERT( portUdp != 0 );

            sockType = SOCK_DGRAM;
            port = portUdp;
        }
    }

    //  if one lookup is successful, that's good enough

    if ( port != 0 )
    {
        err = NO_ERROR;
    }
    
Done:

    *pPort = port;
    *pSockType = sockType;

    return err;
}


#define NewAddrInfoW(a,b,c,d)   \
        (PADDRINFOW) NewAddrInfo( (a), (b), (c), (PADDRINFO**)(d) )


INT
WSAAPI
GetAddrInfoW(
    IN      PCWSTR              pNodeName,
    IN      PCWSTR              pServiceName,
    IN      const ADDRINFOW *   pHints,
    OUT     PADDRINFOW *        ppResult
    )
/*++

Routine Description:

    Protocol independent name to address translation routine.

    Spec'd in RFC 2553, section 6.4.

Arguments:

    pNodeName       - name to lookup

    pServiceName    - service to lookup

    pHints          - address info providing hints to guide lookup

    ppResult        - addr to receive ptr to resulting buffer

Return Value:

    ERROR_SUCCESS if successful.
    Winsock error code on failure.

--*/
{
    PADDRINFOW      pcurrent;
    PADDRINFOW *    ppnext;
    INT             protocol = 0;
    USHORT          family = PF_UNSPEC;
    USHORT          servicePort = 0;
    INT             socketType = 0;
    INT             flags = 0;
    INT             err;
    PSOCKADDR_IN    psin;
    PSOCKADDR_IN6   psin6;
    WCHAR           addressString[ INET6_ADDRSTRLEN ];
    

    err = TURBO_PROLOG();
    if ( err != NO_ERROR )
    {
        return err;
    }

    //
    //  init OUT param for error paths
    //

    *ppResult = NULL;
    ppnext = ppResult;

    //
    //  node name and service name can't both be NULL.
    //

    if ( !pNodeName && !pServiceName )
    {
        err = EAI_NONAME;
        goto Bail;
    }

    //
    //  validate\enforce hints
    //

    if ( pHints != NULL )
    {
        //
        //  only valid hints:  ai_flags, ai_family, ai_socktype, ai_protocol
        //  the rest must be zero\null
        //

        if ( (pHints->ai_addrlen != 0) ||
             (pHints->ai_canonname != NULL) ||
             (pHints->ai_addr != NULL) ||
             (pHints->ai_next != NULL))
        {
            // REVIEW: Not clear what error to return here.

            err = EAI_FAIL;
            goto Bail;
        }

        //
        //  validate flags
        //      - don't validate known flags to allow forward compatiblity
        //      with flag additions
        //      - must have node name, if AI_CANONNAME
        //

        flags = pHints->ai_flags;

        if ((flags & AI_CANONNAME) && !pNodeName)
        {
            err = EAI_BADFLAGS;
            goto Bail;
        }

        //
        //  validate family
        //

        family = (USHORT)pHints->ai_family;

        if ( (family != PF_UNSPEC)  &&
             (family != PF_INET6)   &&
             (family != PF_INET) )
        {
            err = EAI_FAMILY;
            goto Bail;
        }

        //
        //  validate socket type
        //

        socketType = pHints->ai_socktype;

        if ( (socketType != 0) &&
             (socketType != SOCK_STREAM) &&
             (socketType != SOCK_DGRAM) &&
             (socketType != SOCK_RAW) )
        {
            err = EAI_SOCKTYPE;
            goto Bail;
        }

        //
        // REVIEW: What if ai_socktype and ai_protocol are at odds?
        // REVIEW: Should we enforce the mapping triples here?
        //
        protocol = pHints->ai_protocol;
    }

    //
    //  lookup port for service name
    //

    if ( pServiceName != NULL )
    {
        err = ServiceNameLookup(
                pServiceName,
                & socketType,
                & servicePort );

        if ( err != NO_ERROR )
        {
            goto Bail;
        }
    }

    //
    //  Empty node name => return local sockaddr
    //
    //  if AI_PASSIVE => INADDR_ANY
    //      address can be used of local binding
    //  otherwise => loopback
    //

    if ( pNodeName == NULL )
    {
        //
        //  note:  specifically checking unspecified family for
        //  What address to return depends upon the protocol family and
        //  whether or not the AI_PASSIVE flag is set.
        //

        //
        //  Unspecified protocol family -- determine if IP6 is running
        //

        if ( ( family == PF_INET6 ) ||
             ( family == PF_UNSPEC && IsIp6Running() ) )
        {
            //
            // Return an IPv6 address.
            //
            pcurrent = NewAddrInfoW(
                                PF_INET6,
                                socketType,
                                protocol,
                                (PADDRINFO **) &ppnext );
            if ( pcurrent == NULL )
            {
                err = EAI_MEMORY;
                goto Bail;
            }
            psin6 = (struct sockaddr_in6 *)pcurrent->ai_addr;
            psin6->sin6_family = AF_INET6;
            psin6->sin6_port = servicePort;
            psin6->sin6_flowinfo = 0;
            psin6->sin6_scope_id = 0;
            if (flags & AI_PASSIVE)
            {
                psin6->sin6_addr = in6addr_any;
            }
            else
            {
                psin6->sin6_addr = in6addr_loopback;
            }
        }

        //
        //  IP4
        //

        if ( ( family == PF_INET ) ||
             ( family == PF_UNSPEC && IsIp4Running() ) )
        {
            pcurrent = NewAddrInfoW(
                                PF_INET,
                                socketType,
                                protocol,
                                (PADDRINFO **) &ppnext );
            if ( !pcurrent )
            {
                err = EAI_MEMORY;
                goto Bail;
            }
            psin = (struct sockaddr_in *)pcurrent->ai_addr;
            psin->sin_family = AF_INET;
            psin->sin_port = servicePort;
            if (flags & AI_PASSIVE)
            {
                psin->sin_addr.s_addr = htonl(INADDR_ANY);
            }
            else
            {
                psin->sin_addr.s_addr = htonl(INADDR_LOOPBACK);
            }
            memset(psin->sin_zero, 0, sizeof(psin->sin_zero) );
        }
        goto Success;
    }

    //
    //  have a node name (either alpha or numeric) to look up
    //

    //
    //  first check if name is numeric address (v4 or v6)
    //
    //  note:  shouldn't have to set the sa_family field prior to calling
    //         WSAStringToAddress, but it appears we do.
    //
    //  check if IPv6 address first
    //
    //
    //  DCR:  WSAStringToAddress() may not work if IP6 stack not installed
    //      can directly call my dnslib.lib routines
    //

    if ( (family == PF_UNSPEC) ||
         (family == PF_INET6))
    {
        SOCKADDR_IN6    tempSockAddr;
        INT             tempSockAddrLen = sizeof(tempSockAddr);
        BOOL            ffound = FALSE;

        tempSockAddr.sin6_family = AF_INET6;

        if ( WSAStringToAddressW(
                    (PWSTR) pNodeName,
                    AF_INET6,
                    NULL,
                    (PSOCKADDR) &tempSockAddr,
                    &tempSockAddrLen ) != SOCKET_ERROR )
        {
            ffound = TRUE;
        }

        //
        //  check for UPNP IP6 literal
        //

        else if ( Dns_Ip6LiteralNameToAddressW(
                    &tempSockAddr,
                    (PWSTR) pNodeName ) )
        {
            ffound = TRUE;
        }

        if ( ffound )
        {
            pcurrent = NewAddrInfoW(
                            PF_INET6,
                            socketType,
                            protocol,
                            &ppnext );
            if ( pcurrent == NULL )
            {
                err = EAI_MEMORY;
                goto Bail;
            }
            psin6 = (struct sockaddr_in6 *)pcurrent->ai_addr;
            RtlCopyMemory( psin6, &tempSockAddr, tempSockAddrLen );
            psin6->sin6_port = servicePort;

            //
            // Implementation specific behavior: set AI_NUMERICHOST
            // to indicate that we got a numeric host address string.
            //
            pcurrent->ai_flags |= AI_NUMERICHOST;

            if ( flags & AI_CANONNAME )
            {
                goto CanonicalizeAddress;
            }
            goto Success;
        }
    }

    //
    //  check if IPv4 address
    //      - strict "three dot" conversion if not numeric
    //

    if ( (family == PF_UNSPEC) ||
         (family == PF_INET) )
    {
        IP4_ADDRESS ip4;

        if ( GetIp4Address(
                pNodeName,
                ! (flags & AI_NUMERICHOST ),
                &ip4 ) )
        {
            PSOCKADDR_IN    psin;
    
            //
            //  create addrinfo struct to hold IP4 address
            //
    
            pcurrent = NewAddrInfoW(
                                PF_INET,
                                socketType,
                                protocol,
                                &ppnext );
            if ( !pcurrent )
            {
                err = EAI_MEMORY;
                goto Bail;
            }
            psin = (struct sockaddr_in *)pcurrent->ai_addr;
            psin->sin_family        = AF_INET;
            psin->sin_addr.s_addr   = ip4;
            psin->sin_port          = servicePort;
            memset( psin->sin_zero, 0, sizeof(psin->sin_zero) );
    
            //
            //  set AI_NUMERICHOST to indicate numeric host string
            //      - note this is NON-RFC implementation specific
            
            pcurrent->ai_flags |= AI_NUMERICHOST;
    
            if (flags & AI_CANONNAME)
            {
                goto CanonicalizeAddress;
            }
            goto Success;
        }
    }

    //
    //  not a numeric address
    //      - bail if only wanted numeric conversion
    //

    if ( flags & AI_NUMERICHOST )
    {
        err = EAI_NONAME;
        goto Bail;
    }

    //
    //  do name lookup
    //

    err = LookupAddressForName(
                pNodeName,
                family,
                socketType,
                protocol,
                servicePort,
                flags,
                &ppnext );

    if ( err == NO_ERROR )
    {
        goto Success;
    }

#if 0
    //
    //  last chance "liberal" IP4 conversion
    //
    //  DCR:  could do final "liberal" test
    //

    if ( (family == PF_UNSPEC) ||
         (family == PF_INET) )
    {
        if ( ParseV4AddressLiberal( pNodeName, &ip4 ) )
        {
            goto Ip4Address;
        }
    }
#endif
    goto Bail;



CanonicalizeAddress:

    {
        DWORD   bufLen = INET6_ADDRSTRLEN;

        if ( WSAAddressToStringW(
                    (*ppResult)->ai_addr,
                    (*ppResult)->ai_addrlen,
                    NULL,
                    addressString,
                    & bufLen
                    ) == SOCKET_ERROR )
        {
            err = WSAGetLastError();
            goto Bail;
        }
        else
        {
            if ( (*ppResult)->ai_canonname = CreateStringCopy_W( addressString ) )
            {
                return  NO_ERROR;
            }
            err = EAI_MEMORY;
            goto Bail;
        }
    }

    //
    // Fall through and bail...
    //
    
Bail:

    //
    //  failed
    //      - delete any addrinfo built
    //      - set last error AND return it
    //

    if ( *ppResult != NULL )
    {
        freeaddrinfo( (LPADDRINFO)*ppResult );
        *ppResult = NULL;
    }

    WSASetLastError( err );
    return err;

Success:

    WSASetLastError( NO_ERROR );
    return NO_ERROR;
}



INT
WSAAPI
getaddrinfo(
    IN      PCSTR               pNodeName,
    IN      PCSTR               pServiceName,
    IN      const ADDRINFOA *   pHints,
    OUT     PADDRINFOA *        ppResult
    )
/*++

Routine Description:

    ANSI version of GetAddrInfo().

    Protocol independent name to address translation routine.

    Spec'd in RFC 2553, section 6.4.

Arguments:

    pNodeName       - name to lookup

    pServiceName    - service to lookup

    pHints          - address info providing hints to guide lookup

    ppResult        - addr to receive ptr to resulting buffer

Return Value:

    ERROR_SUCCESS if successful.
    Winsock error code on failure.

--*/
{
    INT     err = NO_ERROR;
    PWSTR   pnodeW = NULL;
    PWSTR   pserviceW = NULL;

    //
    //  startup
    //

    err = TURBO_PROLOG();
    if ( err != NO_ERROR )
    {
        return err;
    }

    //
    //  init OUT param for error paths
    //

    *ppResult = NULL;

    //
    //  convert names
    //

    if ( pNodeName )
    {
        pnodeW = CreateStringCopy_AnsiToUnicode( pNodeName );
        if ( !pnodeW )
        {
            err = GetLastError();
            goto Failed;
        }
    }
    if ( pServiceName )
    {
        pserviceW = CreateStringCopy_AnsiToUnicode( pServiceName );
        if ( !pserviceW )
        {
            err = GetLastError();
            goto Failed;
        }
    }

    //
    //  call in unicode
    //

    err = GetAddrInfoW(
                pnodeW,
                pserviceW,
                (const ADDRINFOW *) pHints,
                (PADDRINFOW *) ppResult
                );

    if ( err == NO_ERROR )
    {
        err = ConvertAddrinfoFromUnicodeToAnsi( (PADDRINFOW) *ppResult );
    }

Failed:

    if ( pnodeW )
    {
        delete pnodeW;
    }
    if ( pserviceW )
    {
        delete pserviceW;
    }

    if ( err != NO_ERROR )
    {
        freeaddrinfo( *ppResult );
        *ppResult = NULL;
    }

    WSASetLastError( err );
    return err;
}



void
WSAAPI
freeaddrinfo(
    IN OUT  PADDRINFOA      pAddrInfo
    )
/*++

Routine Description:

    Free addrinfo list.

    Frees results of getaddrinfo(), GetAddrInfoW().

    Spec'd in RFC 2553, section 6.4.

Arguments:

    pAddrInfo   - addrinfo blob to free

Return Value:

    None

--*/
{
    PADDRINFOA  pnext = pAddrInfo;
    PADDRINFOA  pcur;

    //
    //  free each addrinfo struct in chain
    //

    while ( pcur = pnext )
    {
        pnext = pcur->ai_next;

        if ( pcur->ai_canonname )
        {
            delete pcur->ai_canonname;
        }
        if ( pcur->ai_addr )
        {
            delete pcur->ai_addr;
        }
        delete pcur;
    }
}



//
//  getnameinfo routines
//

DWORD
WSAAPI
LookupNodeByAddr(
    IN      PWCHAR          pNodeBuffer,
    IN      DWORD           NodeBufferSize,
    IN      BOOL            fShortName,
    IN      PBYTE           pAddress,
    IN      int             AddressLength,
    IN      int             AddressFamily
    )
/*++

Routine Description:

    Do reverse lookup.

    This is guts of getnameinfo() routine.

Arguments:

    pNodeBuffer     - buffer to recv node name

    NodeBufferSize  - buffer size

    fShortName      - want only short name

    pAddress        - address (IN_ADDR, IN6_ADDR)

    AddressLength   - address length

    AddressFamily   - family

Return Value:

    ERROR_SUCCESS if successful.
    Winsock error code on failure.

--*/
{
    PBYTE           plookupAddr = (PBYTE) pAddress;
    int             lookupFamily = AddressFamily;
    WCHAR           lookupString[ DNS_MAX_REVERSE_NAME_BUFFER_LENGTH ];
    GUID            PtrGuid =  SVCID_DNS(T_PTR);
    HANDLE          hlookup = NULL;
    CHAR            buffer[sizeof(WSAQUERYSETW) + 2048];
    PWSAQUERYSETW   pquery = (PWSAQUERYSETW) buffer;
    ULONG           querySize;
    INT             status;
    PWSTR           pname = NULL;
    DWORD           reqLength;

    //
    //  verify args
    //

    if ( !plookupAddr )
    {
        status = WSAEFAULT;
        goto Return;
    }

    //
    //  verify address family
    //      - for mapped addresses, set to treat as IP4
    //

    if ( lookupFamily == AF_INET6 )
    {
        if ( AddressLength != sizeof(IP6_ADDRESS) )
        {
            status = WSAEFAULT;
            goto Return;
        }

        //  if V4 mapped, change to V4 for lookup

        if ( (IN6_IS_ADDR_V4MAPPED((struct in6_addr *)pAddress)) ||
             (IN6_IS_ADDR_V4COMPAT((struct in6_addr *)pAddress)) )
        {
            plookupAddr = &plookupAddr[12];
            lookupFamily = AF_INET;
        }
    }
    else if ( lookupFamily == AF_INET )
    {
        if ( AddressLength != sizeof(IP4_ADDRESS) )
        {
            status = WSAEFAULT;
            goto Return;
        }
    }
    else    // unsupported family
    {
        status = WSAEAFNOSUPPORT;
        goto Return;
    }

    //
    //  create reverse lookup string
    //

    if ( lookupFamily == AF_INET6 )
    {
        Dns_Ip6AddressToReverseName_W(
            lookupString,
            * (PIP6_ADDRESS) plookupAddr );
    }
    else
    {
        Dns_Ip4AddressToReverseName_W(
            lookupString,
            * (PIP4_ADDRESS) plookupAddr );
    }

    //
    //  make PTR pquery
    //

    RtlZeroMemory( pquery, sizeof(*pquery) );

    pquery->dwSize                   = sizeof(*pquery);
    pquery->lpszServiceInstanceName  = lookupString;
    pquery->dwNameSpace              = NS_DNS;
    pquery->lpServiceClassId         = &PtrGuid;

    status = WSALookupServiceBeginW(
                pquery,
                LUP_RETURN_NAME,
                &hlookup
                );

    if ( status != NO_ERROR )
    {
        status = WSAGetLastError();
        if ( status == WSASERVICE_NOT_FOUND ||
             status == NO_ERROR )
        {
            status = WSAHOST_NOT_FOUND;
        }
        goto Return;
    }

    querySize = sizeof(buffer);
    status = WSALookupServiceNextW(
                hlookup,
                0,
                &querySize,
                pquery );

    if ( status != NO_ERROR )
    {
        status = WSAGetLastError();
        if ( status == WSASERVICE_NOT_FOUND ||
             status == NO_ERROR )
        {
            status = WSAHOST_NOT_FOUND;
        }
        goto Return;
    }

    //
    //  if successful -- copy name
    //

    pname = pquery->lpszServiceInstanceName;
    if ( pname )
    {
        if ( fShortName )
        {
            Dns_SplitHostFromDomainNameW( pname );
        }

        reqLength = wcslen( pname ) + 1;

        if ( reqLength > NodeBufferSize )
        {
            status = WSAEFAULT;
            goto Return;
        }
        wcscpy( pNodeBuffer, pname );
    }
    else
    {
        status = WSAHOST_NOT_FOUND;
    }


Return:

    if ( hlookup )
    {
        WSALookupServiceEnd( hlookup );
    }
    return  status;
}



INT
WSAAPI
GetServiceNameForPort(
    OUT     PWCHAR          pServiceBuffer,
    IN      DWORD           ServiceBufferSize,
    IN      WORD            Port,
    IN      INT             Flags
    )
/*++

Routine Description:

    Get service for a port.

Arguments:

    pServiceBuffer      - ptr to buffer to recv the service name.

    ServiceBufferSize   - size of pServiceBuffer buffer

    Port                - port

    Flags               - flags of type NI_*.

Return Value:

    ERROR_SUCCESS if successful.
    Winsock error code on failure.

--*/
{
    DWORD   status = NO_ERROR;
    DWORD   length;
    CHAR    tempBuffer[ NI_MAXSERV ];
    PSTR    pansi = NULL;


    //
    //  translate the port number as numeric string
    //

    if ( Flags & NI_NUMERICSERV )
    {
        sprintf( tempBuffer, "%u", ntohs(Port) );
        pansi = tempBuffer;
    }

    //
    //  lookup service for port
    //

    else
    {
        PSERVENT pservent;

        pservent = getservbyport(
                        Port,
                        (Flags & NI_DGRAM) ? "udp" : "tcp" );
        if ( !pservent )
        {
            return WSAGetLastError();
        }
        pansi = pservent->s_name;
    }

    //
    //  convert to unicode
    //

    length = MultiByteToWideChar(
                CP_ACP,
                0,                      // no flags
                pansi,
                (-1),                   // NULL terminated
                pServiceBuffer,         // buffer
                ServiceBufferSize       // buffer length
                );
    if ( length == 0 )
    {
        status = GetLastError();
        if ( status == NO_ERROR )
        {
            status = WSAEFAULT;
        }
    }

    return  status;
}



INT
WSAAPI
GetNameInfoW(
    IN      const SOCKADDR *    pSockaddr,
    IN      socklen_t           SockaddrLength,
    OUT     PWCHAR              pNodeBuffer,
    IN      DWORD               NodeBufferSize,
    OUT     PWCHAR              pServiceBuffer,
    IN      DWORD               ServiceBufferSize,
    IN      INT                 Flags
    )
/*++

Routine Description:

    Protocol independent address-to-name translation routine.

    Spec'd in RFC 2553, section 6.5.

Arguments:

    pSockaddr           - socket address to translate
    SockaddrLength      - length of socket address
    pNodeBuffer         - ptr to buffer to recv node name
    NodeBufferSize      - size of pNodeBuffer buffer
    pServiceBuffer      - ptr to buffer to recv the service name.
    ServiceBufferSize   - size of pServiceBuffer buffer
    Flags               - flags of type NI_*.

Return Value:

    ERROR_SUCCESS if successful.
    Winsock error code on failure.

--*/
{
    INT     err;
    INT     sockaddrLength;
    WORD    port;
    PVOID   paddr;
    INT     addrLength;


    err = TURBO_PROLOG();
    if ( err != NO_ERROR )
    {
        goto Fail;
    }

    //
    //  validity check
    //  extract info for family
    //

    if ( pSockaddr == NULL )
    {
        goto Fault;
    }

    //
    //  extract family info
    //
    //  DCR:  sockaddr length check should be here
    //      it is useless in getipnodebyaddr() as we set lengths here
    //

    switch ( pSockaddr->sa_family )
    {
    case AF_INET:
        sockaddrLength  = sizeof(SOCKADDR_IN);
        port            = ((struct sockaddr_in *)pSockaddr)->sin_port;
        paddr           = &((struct sockaddr_in *)pSockaddr)->sin_addr;
        addrLength      = sizeof(struct in_addr);
        break;

    case AF_INET6:
        sockaddrLength  = sizeof(SOCKADDR_IN6);
        port            = ((struct sockaddr_in6 *)pSockaddr)->sin6_port;
        paddr           = &((struct sockaddr_in6 *)pSockaddr)->sin6_addr;
        addrLength      = sizeof(struct in6_addr);
        break;

    default:
        err = WSAEAFNOSUPPORT;
        goto Fail;
    }

    if ( SockaddrLength < sockaddrLength )
    {
        goto Fault;
    }
    SockaddrLength = sockaddrLength;

    //
    // Translate the address to a node name (if requested).
    //
    //  DCR:  backward jumping goto -- shoot the developer
    //     simple replacement
    //      - not specifically numeric -- do lookup
    //      - success => out
    //      - otherwise do numeric lookup
    //
    //  DCR:  use DNS string\address conversion that doesn't require stack to be up
    //      
    //

    if ( pNodeBuffer != NULL )
    {
        //
        //  if not specifically numeric, do reverse lookup
        //

        if ( !(Flags & NI_NUMERICHOST) )
        {
            err = LookupNodeByAddr(
                        pNodeBuffer,
                        NodeBufferSize,
                        (Flags & NI_NOFQDN),    // short name
                        (PBYTE) paddr,
                        addrLength,
                        pSockaddr->sa_family
                        );

            if ( err == NO_ERROR )
            {
                goto ServiceLookup;
            }

            //  if name required -- we're toast
            //  otherwise can fall through and try numeric lookup

            if ( Flags & NI_NAMEREQD )
            {
                goto Fail;
            }
        }

        //
        //  try numeric
        //      - specifically numeric
        //      - or node lookup above failed
        //

        {
            SOCKADDR_STORAGE    tempSockaddr;  // Guaranteed big enough.

            //
            //  make sockaddr copy to zero the port
            //      - note that for both support type (V4, V6) port is in the
            //      same place
            //

            RtlCopyMemory(
                &tempSockaddr,
                pSockaddr,
                SockaddrLength );

            ((PSOCKADDR_IN6)&tempSockaddr)->sin6_port = 0;

            if ( WSAAddressToStringW(
                    (PSOCKADDR) &tempSockaddr,
                    SockaddrLength,
                    NULL,
                    pNodeBuffer,
                    &NodeBufferSize) == SOCKET_ERROR )
            {
                return WSAGetLastError();
            }
        }
    }

ServiceLookup:

    //
    //  translate port number to service name
    //

    if ( pServiceBuffer != NULL )
    {
        err = GetServiceNameForPort(
                    pServiceBuffer,
                    ServiceBufferSize,
                    port,
                    Flags );
    }

    //
    //  jump down for return
    //      - we'll SetLastError() either way
    //

    goto Fail;

Fault:

    err = WSAEFAULT;

Fail:

    WSASetLastError( err );
    return err;
}



INT
WSAAPI
getnameinfo(
    IN      const SOCKADDR *    pSockaddr,
    IN      socklen_t           SockaddrLength,
    OUT     PCHAR               pNodeBuffer,
    IN      DWORD               NodeBufferSize,
    OUT     PCHAR               pServiceBuffer,
    IN      DWORD               ServiceBufferSize,
    IN      INT                 Flags
    )
/*++

Routine Description:

    Protocol independent address-to-name translation routine.

    Spec'd in RFC 2553, section 6.5.

Arguments:

    pSockaddr           - socket address to translate
    SockaddrLength      - length of socket address
    pNodeBuffer         - ptr to buffer to recv node name
    NodeBufferSize      - size of pNodeBuffer buffer
    pServiceBuffer      - ptr to buffer to recv the service name.
    ServiceBufferSize   - size of pServiceBuffer buffer
    Flags               - flags of type NI_*.

Return Value:

    ERROR_SUCCESS if successful.
    Winsock error code on failure.

--*/
{
    INT     err;
    PWCHAR  pnodeUnicode = NULL;
    PWCHAR  pserviceUnicode = NULL;
    DWORD   serviceBufLength = 0;
    DWORD   nodeBufLength = 0;
    WCHAR   serviceBufUnicode[ NI_MAXSERV+1 ];
    WCHAR   nodeBufUnicode[ DNS_MAX_NAME_BUFFER_LENGTH ];
    DWORD   length;


    err = TURBO_PROLOG();
    if ( err != NO_ERROR )
    {
        goto Failed;
    }

    //
    //  setup unicode buffers
    //

    if ( pNodeBuffer )
    {
        pnodeUnicode = nodeBufUnicode;
        nodeBufLength = sizeof(nodeBufUnicode) / sizeof(WCHAR);
    }
    if ( pServiceBuffer )
    {
        pserviceUnicode = serviceBufUnicode;
        serviceBufLength = sizeof(serviceBufUnicode) / sizeof(WCHAR);
    }

    //
    //  call through unicode version
    //

    err = GetNameInfoW(
                pSockaddr,
                SockaddrLength,
                pnodeUnicode,
                nodeBufLength,
                pserviceUnicode,
                serviceBufLength,
                Flags );

    if ( err != NO_ERROR )
    {
        goto Failed;
    }

    //
    //  convert results to ANSI
    //

    if ( pnodeUnicode )
    {
        length = WideCharToMultiByte(
                    CP_ACP,
                    0,                  // no flags
                    pnodeUnicode,
                    (-1),               // NULL terminated
                    pNodeBuffer,        // buffer
                    NodeBufferSize,     // buffer length
                    NULL,
                    NULL
                    );
        if ( length == 0 )
        {
            err = GetLastError();
            goto Failed;
        }
    }

    if ( pserviceUnicode )
    {
        length = WideCharToMultiByte(
                    CP_ACP,
                    0,                  // no flags
                    pserviceUnicode,
                    (-1),               // NULL terminated
                    pServiceBuffer,     // buffer
                    ServiceBufferSize,  // buffer length
                    NULL,
                    NULL
                    );
        if ( length == 0 )
        {
            err = GetLastError();
            goto Failed;
        }
    }

    return  NO_ERROR;


Failed:

    if ( err == NO_ERROR )
    {
        err = WSAEFAULT;
    }
    WSASetLastError( err );
    return err;
}

#ifdef _WIN64
#pragma warning (pop)
#endif

//
//  End addrinfo.cpp
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\addrconv.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    addrconv.c

Abstract:

    This module contains the address conversion routines from the
    winsock2 API. This module contains the following functions.

    htonl()
    htons()
    ntohl()
    ntohs()
    inet_addr()
    inet_ntoa()
    WSAHtonl()
    WSAHtons()
    WSANtohl()
    WSANtohs()


Author:

    Dirk Brandewie dirk@mink.intel.com  14-06-1995

[Environment:]

[Notes:]

Revision History:

    22-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Moved includes to precomp.h

--*/

#include "precomp.h"

// these defines are used to check if address parts are in range
#define MAX_EIGHT_BIT_VALUE       0xff
#define MAX_SIXTEEN_BIT_VALUE     0xffff
#define MAX_TWENTY_FOUR_BIT_VALUE 0xffffff

// Defines for different based numbers in an address
#define BASE_TEN     10
#define BASE_EIGHT   8
#define BASE_SIXTEEN 16

//
// Macros for swapping the bytes in a long and a short.
//

#define SWAP_LONG(l)                                \
            ( ( ((l) >> 24) & 0x000000FFL ) |       \
              ( ((l) >>  8) & 0x0000FF00L ) |       \
              ( ((l) <<  8) & 0x00FF0000L ) |       \
              ( ((l) << 24) & 0xFF000000L ) )

#define WS_SWAP_SHORT(s)                            \
            ( ( ((s) >> 8) & 0x00FF ) |             \
              ( ((s) << 8) & 0xFF00 ) )

//
// This preinitialized array defines the strings to be used for
// inet_ntoa.  The index of each row corresponds to the value for a byte
// in an IP address.  The first three bytes of each row are the
// char/string value for the byte, and the fourth byte in each row is
// the length of the string required for the byte.  This approach
// allows a fast implementation with no jumps.
//

BYTE NToACharStrings[][4] = {
    '0', 'x', 'x', 1,
    '1', 'x', 'x', 1,
    '2', 'x', 'x', 1,
    '3', 'x', 'x', 1,
    '4', 'x', 'x', 1,
    '5', 'x', 'x', 1,
    '6', 'x', 'x', 1,
    '7', 'x', 'x', 1,
    '8', 'x', 'x', 1,
    '9', 'x', 'x', 1,
    '1', '0', 'x', 2,
    '1', '1', 'x', 2,
    '1', '2', 'x', 2,
    '1', '3', 'x', 2,
    '1', '4', 'x', 2,
    '1', '5', 'x', 2,
    '1', '6', 'x', 2,
    '1', '7', 'x', 2,
    '1', '8', 'x', 2,
    '1', '9', 'x', 2,
    '2', '0', 'x', 2,
    '2', '1', 'x', 2,
    '2', '2', 'x', 2,
    '2', '3', 'x', 2,
    '2', '4', 'x', 2,
    '2', '5', 'x', 2,
    '2', '6', 'x', 2,
    '2', '7', 'x', 2,
    '2', '8', 'x', 2,
    '2', '9', 'x', 2,
    '3', '0', 'x', 2,
    '3', '1', 'x', 2,
    '3', '2', 'x', 2,
    '3', '3', 'x', 2,
    '3', '4', 'x', 2,
    '3', '5', 'x', 2,
    '3', '6', 'x', 2,
    '3', '7', 'x', 2,
    '3', '8', 'x', 2,
    '3', '9', 'x', 2,
    '4', '0', 'x', 2,
    '4', '1', 'x', 2,
    '4', '2', 'x', 2,
    '4', '3', 'x', 2,
    '4', '4', 'x', 2,
    '4', '5', 'x', 2,
    '4', '6', 'x', 2,
    '4', '7', 'x', 2,
    '4', '8', 'x', 2,
    '4', '9', 'x', 2,
    '5', '0', 'x', 2,
    '5', '1', 'x', 2,
    '5', '2', 'x', 2,
    '5', '3', 'x', 2,
    '5', '4', 'x', 2,
    '5', '5', 'x', 2,
    '5', '6', 'x', 2,
    '5', '7', 'x', 2,
    '5', '8', 'x', 2,
    '5', '9', 'x', 2,
    '6', '0', 'x', 2,
    '6', '1', 'x', 2,
    '6', '2', 'x', 2,
    '6', '3', 'x', 2,
    '6', '4', 'x', 2,
    '6', '5', 'x', 2,
    '6', '6', 'x', 2,
    '6', '7', 'x', 2,
    '6', '8', 'x', 2,
    '6', '9', 'x', 2,
    '7', '0', 'x', 2,
    '7', '1', 'x', 2,
    '7', '2', 'x', 2,
    '7', '3', 'x', 2,
    '7', '4', 'x', 2,
    '7', '5', 'x', 2,
    '7', '6', 'x', 2,
    '7', '7', 'x', 2,
    '7', '8', 'x', 2,
    '7', '9', 'x', 2,
    '8', '0', 'x', 2,
    '8', '1', 'x', 2,
    '8', '2', 'x', 2,
    '8', '3', 'x', 2,
    '8', '4', 'x', 2,
    '8', '5', 'x', 2,
    '8', '6', 'x', 2,
    '8', '7', 'x', 2,
    '8', '8', 'x', 2,
    '8', '9', 'x', 2,
    '9', '0', 'x', 2,
    '9', '1', 'x', 2,
    '9', '2', 'x', 2,
    '9', '3', 'x', 2,
    '9', '4', 'x', 2,
    '9', '5', 'x', 2,
    '9', '6', 'x', 2,
    '9', '7', 'x', 2,
    '9', '8', 'x', 2,
    '9', '9', 'x', 2,
    '1', '0', '0', 3,
    '1', '0', '1', 3,
    '1', '0', '2', 3,
    '1', '0', '3', 3,
    '1', '0', '4', 3,
    '1', '0', '5', 3,
    '1', '0', '6', 3,
    '1', '0', '7', 3,
    '1', '0', '8', 3,
    '1', '0', '9', 3,
    '1', '1', '0', 3,
    '1', '1', '1', 3,
    '1', '1', '2', 3,
    '1', '1', '3', 3,
    '1', '1', '4', 3,
    '1', '1', '5', 3,
    '1', '1', '6', 3,
    '1', '1', '7', 3,
    '1', '1', '8', 3,
    '1', '1', '9', 3,
    '1', '2', '0', 3,
    '1', '2', '1', 3,
    '1', '2', '2', 3,
    '1', '2', '3', 3,
    '1', '2', '4', 3,
    '1', '2', '5', 3,
    '1', '2', '6', 3,
    '1', '2', '7', 3,
    '1', '2', '8', 3,
    '1', '2', '9', 3,
    '1', '3', '0', 3,
    '1', '3', '1', 3,
    '1', '3', '2', 3,
    '1', '3', '3', 3,
    '1', '3', '4', 3,
    '1', '3', '5', 3,
    '1', '3', '6', 3,
    '1', '3', '7', 3,
    '1', '3', '8', 3,
    '1', '3', '9', 3,
    '1', '4', '0', 3,
    '1', '4', '1', 3,
    '1', '4', '2', 3,
    '1', '4', '3', 3,
    '1', '4', '4', 3,
    '1', '4', '5', 3,
    '1', '4', '6', 3,
    '1', '4', '7', 3,
    '1', '4', '8', 3,
    '1', '4', '9', 3,
    '1', '5', '0', 3,
    '1', '5', '1', 3,
    '1', '5', '2', 3,
    '1', '5', '3', 3,
    '1', '5', '4', 3,
    '1', '5', '5', 3,
    '1', '5', '6', 3,
    '1', '5', '7', 3,
    '1', '5', '8', 3,
    '1', '5', '9', 3,
    '1', '6', '0', 3,
    '1', '6', '1', 3,
    '1', '6', '2', 3,
    '1', '6', '3', 3,
    '1', '6', '4', 3,
    '1', '6', '5', 3,
    '1', '6', '6', 3,
    '1', '6', '7', 3,
    '1', '6', '8', 3,
    '1', '6', '9', 3,
    '1', '7', '0', 3,
    '1', '7', '1', 3,
    '1', '7', '2', 3,
    '1', '7', '3', 3,
    '1', '7', '4', 3,
    '1', '7', '5', 3,
    '1', '7', '6', 3,
    '1', '7', '7', 3,
    '1', '7', '8', 3,
    '1', '7', '9', 3,
    '1', '8', '0', 3,
    '1', '8', '1', 3,
    '1', '8', '2', 3,
    '1', '8', '3', 3,
    '1', '8', '4', 3,
    '1', '8', '5', 3,
    '1', '8', '6', 3,
    '1', '8', '7', 3,
    '1', '8', '8', 3,
    '1', '8', '9', 3,
    '1', '9', '0', 3,
    '1', '9', '1', 3,
    '1', '9', '2', 3,
    '1', '9', '3', 3,
    '1', '9', '4', 3,
    '1', '9', '5', 3,
    '1', '9', '6', 3,
    '1', '9', '7', 3,
    '1', '9', '8', 3,
    '1', '9', '9', 3,
    '2', '0', '0', 3,
    '2', '0', '1', 3,
    '2', '0', '2', 3,
    '2', '0', '3', 3,
    '2', '0', '4', 3,
    '2', '0', '5', 3,
    '2', '0', '6', 3,
    '2', '0', '7', 3,
    '2', '0', '8', 3,
    '2', '0', '9', 3,
    '2', '1', '0', 3,
    '2', '1', '1', 3,
    '2', '1', '2', 3,
    '2', '1', '3', 3,
    '2', '1', '4', 3,
    '2', '1', '5', 3,
    '2', '1', '6', 3,
    '2', '1', '7', 3,
    '2', '1', '8', 3,
    '2', '1', '9', 3,
    '2', '2', '0', 3,
    '2', '2', '1', 3,
    '2', '2', '2', 3,
    '2', '2', '3', 3,
    '2', '2', '4', 3,
    '2', '2', '5', 3,
    '2', '2', '6', 3,
    '2', '2', '7', 3,
    '2', '2', '8', 3,
    '2', '2', '9', 3,
    '2', '3', '0', 3,
    '2', '3', '1', 3,
    '2', '3', '2', 3,
    '2', '3', '3', 3,
    '2', '3', '4', 3,
    '2', '3', '5', 3,
    '2', '3', '6', 3,
    '2', '3', '7', 3,
    '2', '3', '8', 3,
    '2', '3', '9', 3,
    '2', '4', '0', 3,
    '2', '4', '1', 3,
    '2', '4', '2', 3,
    '2', '4', '3', 3,
    '2', '4', '4', 3,
    '2', '4', '5', 3,
    '2', '4', '6', 3,
    '2', '4', '7', 3,
    '2', '4', '8', 3,
    '2', '4', '9', 3,
    '2', '5', '0', 3,
    '2', '5', '1', 3,
    '2', '5', '2', 3,
    '2', '5', '3', 3,
    '2', '5', '4', 3,
    '2', '5', '5', 3
};



u_long WSAAPI
htonl (
    IN u_long hostlong
    )
/*++
Routine Description:

    Convert a u_long from host to TCP/IP network byte order.

Arguments:

    hostlong - A 32-bit number in host byte order.

Returns:
    htonl() returns the value in TCP/IP network byte order.
--*/
{

    return SWAP_LONG( hostlong );

}



u_short WSAAPI
htons (
    IN u_short hostshort
    )
/*++
Routine Description:

    Convert a u_short from host to TCP/IP network byte order.

Arguments:

    hostshort - A 16-bit number in host byte order.

Returns:
    htons() returns the value in TCP/IP network byte order.
--*/
{

    return WS_SWAP_SHORT( hostshort );

}




u_long WSAAPI
ntohl (
    IN u_long netlong
    )
/*++
Routine Description:

    Convert a u_long from TCP/IP network order to host byte order.

Arguments:

    netlong   A 32-bit number in TCP/IP network byte order.

Returns:
    ntohl() returns the value in host byte order.
--*/
{

    return SWAP_LONG( netlong );

}


u_short WSAAPI
ntohs (
    IN u_short netshort
    )
/*++
Routine Description:

    Convert a u_short from TCP/IP network byte order to host byte order.

Arguments:

    netshort  A 16-bit number in TCP/IP network byte order.

Returns:
    ntohs() returns the value in host byte order.
--*/
{

    return WS_SWAP_SHORT( netshort );

}



unsigned long WSAAPI
inet_addr (
           IN const char FAR * cp
           )
/*++
Routine Description:

    Convert a string containing an Internet Protocol dotted address into an
    in_addr.

Arguments:

    cp - A null terminated character string representing a number expressed in
         the Internet standard ".'' notation.

Returns:

    If no error occurs, inet_addr() returns an unsigned long containing a
    suitable binary representation of the Internet address given.  If the
    passed-in string does not contain a legitimate Internet address, for
    example if a portion of an "a.b.c.d" address exceeds 255, inet_addr()
    returns the value INADDR_NONE.

--*/
{
    IN_ADDR value;                // value to return to the user
    NTSTATUS status;
   
    __try {
        //
        // Special case: we need to make " " return 0.0.0.0 because MSDN
        // says it does.
        //
        if ((cp[0] == ' ') && (cp[1] == '\0')) {
            return (INADDR_ANY);
        }

        status = RtlIpv4StringToAddressA(cp, FALSE, &cp, &value);
        if (!NT_SUCCESS(status)) {
            return (INADDR_NONE);
        }

        //
        //  Check for trailing characters. A valid address can end with
        //  NULL or whitespace.  
        //
        //  N.B. To avoid bugs where the caller hasn't done setlocale()
        //  and passes us a DBCS string, we only allow ASCII whitespace.
        //
        if (*cp && !(isascii(*cp) && isspace(*cp))) {
            return (INADDR_NONE);
        }
    }
    __except (WS2_EXCEPTION_FILTER()) {
        SetLastError (WSAEFAULT);
        return (INADDR_NONE);
    }

    return (value.s_addr);
}




char FAR * WSAAPI
inet_ntoa (
    IN struct in_addr in
    )
/*++
Routine Description:

    Convert a network address into a string in dotted format.

Arguments:

        in - A structure which represents an Internet host address.

Returns:
    If no error occurs, inet_ntoa() returns a char pointer to a static buffer
    containing the text address in standard ".'' notation.  Otherwise, it
    returns NULL.  The data should be copied before another WinSock call is
    made.
--*/
{
    PDTHREAD  Thread;
    INT       ErrorCode;
    PCHAR     Buffer=NULL;
    BOOL      AddedArtificialStartup = FALSE;
    WSADATA   wsaData;
    PUCHAR p;
    PUCHAR b;

    ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if (ERROR_SUCCESS != ErrorCode) {

        if( ErrorCode != WSANOTINITIALISED ) {
            SetLastError(ErrorCode);
            return(NULL);
        }

        //
        // PROLOG failed with WSANOTINITIALIZED, meaning the app has not
        // yet called WSAStartup(). For historical (hysterical?) reasons,
        // inet_ntoa() must be functional before WSAStartup() is called.
        // So, we'll add an artificial WSAStartup() and press on.
        //

        ErrorCode = WSAStartup( WINSOCK_HIGH_API_VERSION, &wsaData );

        if( ErrorCode != NO_ERROR ) {
            SetLastError( ErrorCode );
            return NULL;
        }

        AddedArtificialStartup = TRUE;

        //
        // Retry the PROLOG.
        //

        ErrorCode = TURBO_PROLOG_OVLP(&Thread);
        if (ErrorCode!=ERROR_SUCCESS) {
            WSACleanup();
            SetLastError(ErrorCode);
            return NULL;
        }

    } //if

    Buffer = Thread->GetResultBuffer();
    b = (PUCHAR)Buffer;

    //
    // In an unrolled loop, calculate the string value for each of the four
    // bytes in an IP address.  Note that for values less than 100 we will
    // do one or two extra assignments, but we save a test/jump with this
    // algorithm.
    //

    p = (PUCHAR)&in;

    *b = NToACharStrings[*p][0];
    *(b+1) = NToACharStrings[*p][1];
    *(b+2) = NToACharStrings[*p][2];
    b += NToACharStrings[*p][3];
    *b++ = '.';

    p++;
    *b = NToACharStrings[*p][0];
    *(b+1) = NToACharStrings[*p][1];
    *(b+2) = NToACharStrings[*p][2];
    b += NToACharStrings[*p][3];
    *b++ = '.';

    p++;
    *b = NToACharStrings[*p][0];
    *(b+1) = NToACharStrings[*p][1];
    *(b+2) = NToACharStrings[*p][2];
    b += NToACharStrings[*p][3];
    *b++ = '.';

    p++;
    *b = NToACharStrings[*p][0];
    *(b+1) = NToACharStrings[*p][1];
    *(b+2) = NToACharStrings[*p][2];
    b += NToACharStrings[*p][3];
    *b = '\0';

    if( AddedArtificialStartup ) {
        WSACleanup();
    }

    return(Buffer);
}





int WSAAPI
WSAHtonl (
    IN SOCKET s,
    IN u_long hostlong,
    OUT u_long FAR * lpnetlong
    )
/*++
Routine Description:

    Convert a u_long from a specified host byte order to network byte
    order.

Arguments:

    s - A descriptor identifying a socket.

    hostlong - A 32-bit number in host byte order.

    lpnetlong - A pointer to a 32-bit number in network byte order.


Returns:
    If no error occurs, WSAHtonl() returns 0. Otherwise, a value of
    SOCKET_ERROR is returned.

--*/
{
    PDSOCKET            Socket;
    INT                 ErrorCode;
    PPROTO_CATALOG_ITEM CatalogEntry;
    LPWSAPROTOCOL_INFOW ProtocolInfo;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode==ERROR_SUCCESS) {

		if( lpnetlong == NULL ) {
			SetLastError( WSAEFAULT );
			return(SOCKET_ERROR);
		}

		Socket = DSOCKET::GetCountedDSocketFromSocket(s);
		if(Socket != NULL){
			CatalogEntry = Socket->GetCatalogItem();
			ProtocolInfo = CatalogEntry->GetProtocolInfo();

            __try {
			    if (LITTLEENDIAN == ProtocolInfo->iNetworkByteOrder) {
				    *lpnetlong = hostlong;
			    } //if
			    else {
				    *lpnetlong = SWAP_LONG( hostlong );
			    } //else
                ErrorCode = ERROR_SUCCESS;
            }
            __except (WS2_EXCEPTION_FILTER()) {
                ErrorCode = WSAEFAULT;
            }

			Socket->DropDSocketReference();
            if (ErrorCode==ERROR_SUCCESS)
                return ErrorCode;
		} //if
		else
			ErrorCode = WSAENOTSOCK;
	}


    SetLastError(ErrorCode);
    return (SOCKET_ERROR);
}




int WSAAPI
WSAHtons(
    IN SOCKET s,
    IN u_short hostshort,
    OUT u_short FAR * lpnetshort )
/*++
Routine Description:

    Convert a u_short from a specified host byte order to network byte
    order.

Arguments:

    s - A descriptor identifying a socket.

    netshort - A 16-bit number in network byte order.

    lphostshort - A pointer to a 16-bit number in host byte order.

Returns:
     If no error occurs, WSANtohs() returns 0. Otherwise, a value of
     SOCKET_ERROR is returned.

--*/
{
    PDSOCKET            Socket;
    INT                 ErrorCode;
    PPROTO_CATALOG_ITEM CatalogEntry;
    LPWSAPROTOCOL_INFOW ProtocolInfo;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode==ERROR_SUCCESS) {

		if( lpnetshort == NULL ) {
			SetLastError( WSAEFAULT );
			return(SOCKET_ERROR);
		}

		Socket = DSOCKET::GetCountedDSocketFromSocket(s);
		if(Socket != NULL){
			CatalogEntry = Socket->GetCatalogItem();
			ProtocolInfo = CatalogEntry->GetProtocolInfo();
            __try {
			    if (LITTLEENDIAN == ProtocolInfo->iNetworkByteOrder) {
				    *lpnetshort = hostshort;
			    } //if
			    else {
				    *lpnetshort = WS_SWAP_SHORT( hostshort );
			    } //else

			    ErrorCode = ERROR_SUCCESS;
            }
            __except (WS2_EXCEPTION_FILTER()) {
                ErrorCode = WSAEFAULT;
            }
			Socket->DropDSocketReference();
            if (ErrorCode==ERROR_SUCCESS)
                return ErrorCode;
		} //if
		else
			ErrorCode = WSAENOTSOCK;
	}

    SetLastError(ErrorCode);
    return (SOCKET_ERROR);
}




int WSAAPI
WSANtohl (
    IN SOCKET s,
    IN u_long netlong,
    OUT u_long FAR * lphostlong
    )
/*++
Routine Description:

    Convert a u_long from network byte order to host byte order.

Arguments:
    s - A descriptor identifying a socket.

    netlong - A 32-bit number in network byte order.

    lphostlong - A pointer to a 32-bit number in host byte order.

Returns:
     If no error occurs, WSANtohs() returns 0. Otherwise, a value of
     SOCKET_ERROR is returned.
--*/
{
    PDSOCKET            Socket;
    INT                 ErrorCode;
    PPROTO_CATALOG_ITEM CatalogEntry;
    LPWSAPROTOCOL_INFOW ProtocolInfo;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode==ERROR_SUCCESS) {

		if( lphostlong == NULL ) {
			SetLastError( WSAEFAULT );
			return(SOCKET_ERROR);
		}


		Socket = DSOCKET::GetCountedDSocketFromSocket(s);
		if(Socket != NULL){
			CatalogEntry = Socket->GetCatalogItem();
			ProtocolInfo = CatalogEntry->GetProtocolInfo();

            __try {
			    if (LITTLEENDIAN == ProtocolInfo->iNetworkByteOrder) {
				    *lphostlong = netlong;
			    } //if
			    else {
				    *lphostlong = SWAP_LONG( netlong );
			    } //else
			    ErrorCode = ERROR_SUCCESS;
            }
            __except (WS2_EXCEPTION_FILTER()) {
                ErrorCode = WSAEFAULT;
            }
			Socket->DropDSocketReference();
            if (ErrorCode==ERROR_SUCCESS)
                return ErrorCode;
		} //if
		else
			ErrorCode = WSAENOTSOCK;
	}

    SetLastError(ErrorCode);
    return (SOCKET_ERROR);
}


int WSAAPI
WSANtohs (
    IN SOCKET s,
    IN u_short netshort,
    OUT u_short FAR * lphostshort
    )
/*++
Routine Description:


Arguments:

Returns:
    Zero on success else SOCKET_ERROR. The error code is stored with
    SetErrorCode().
--*/
{
    PDSOCKET            Socket;
    INT                 ErrorCode;
    PPROTO_CATALOG_ITEM CatalogEntry;
    LPWSAPROTOCOL_INFOW ProtocolInfo;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode==ERROR_SUCCESS) {

		if( lphostshort == NULL ) {
			SetLastError( WSAEFAULT );
			return(SOCKET_ERROR);
		}


		Socket = DSOCKET::GetCountedDSocketFromSocket(s);
		if(Socket != NULL){
			CatalogEntry = Socket->GetCatalogItem();
			ProtocolInfo = CatalogEntry->GetProtocolInfo();

            __try {
			    if (LITTLEENDIAN == ProtocolInfo->iNetworkByteOrder) {
				    *lphostshort = netshort;
			    } //if
			    else {
				    *lphostshort = WS_SWAP_SHORT( netshort );
			    } //else
			    ErrorCode = ERROR_SUCCESS;
            }
            __except (WS2_EXCEPTION_FILTER()) {
                ErrorCode = WSAEFAULT;
            }
			Socket->DropDSocketReference();
            if (ErrorCode==ERROR_SUCCESS)
                return ErrorCode;
		} //if
		else
			ErrorCode = WSAENOTSOCK;
	}

    SetLastError(ErrorCode);
    return (SOCKET_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\autodial.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    autodial.c

Abstract:

    This module contains Autodial support for Winsock.

Author:

    Anthony Discolo (adiscolo)    15-May-1996

Revision History:

--*/

#include "precomp.h"

#ifdef RASAUTODIAL

//
// Registry value under the Winsock
// registry root that contains the
// path of the Autodial DLL.
//
#define REGVAL_AUTODIAL_DLL    "AutodialDLL"

//
// The default Autodial DLL if one
// isn't defined in the registry.
//
#define AUTODIAL_DLL            "rasadhlp.dll"

//
// The well-known entry points in the
// Autodial DLL that we call to
// invoke an Autodial attempt.
//
#define WSATTEMPTAUTODIALADDR       "WSAttemptAutodialAddr"
#define WSATTEMPTAUTODIALNAME       "WSAttemptAutodialName"
#define WSNOTESUCCESSFULHOSTENTLOOKUP  "WSNoteSuccessfulHostentLookup"

//
// Definition of the Autodial APIs.
//
typedef int (*WSAttemptAutodialAddrProc)(
    IN const struct sockaddr FAR *name,
    IN int namelen
    );

typedef int (*WSAttemptAutodialNameProc)(
    IN const LPWSAQUERYSETW lpqsRestrictions
    );

typedef void (*WSNoteSuccessfulHostentLookupProc)(
    IN const char FAR *name,
    IN const ULONG ipaddr
    );

CRITICAL_SECTION AutodialHelperLockG;
BOOLEAN fAutodialHelperInitG;
HINSTANCE hAutodialHelperDllG;
WSAttemptAutodialAddrProc lpfnWSAttemptAutodialAddrG;
WSAttemptAutodialNameProc lpfnWSAttemptAutodialNameG;
WSNoteSuccessfulHostentLookupProc lpfnWSNoteSuccessfulHostentLookupG;



VOID
InitializeAutodial(VOID)

/*++

Routine Description:
    Initialize the resources necessary for loading
    the Autodial helper DLL.

Arguments:
    None.

Return Value:
    None.

--*/

{
    InitializeCriticalSection(&AutodialHelperLockG);
} // InitializeAutodial



VOID
UninitializeAutodial(VOID)

/*++

Routine Description:
    Free the Autodial helper DLL if it has been loaded.

Arguments:
    None.

Return Value:
    None.

--*/

{
    EnterCriticalSection(&AutodialHelperLockG);
    if (hAutodialHelperDllG != NULL) {
        FreeLibrary(hAutodialHelperDllG);
        hAutodialHelperDllG = NULL;
    }
    LeaveCriticalSection(&AutodialHelperLockG);
    DeleteCriticalSection (&AutodialHelperLockG);
} // UninitializeAutodial



BOOL
LoadAutodialHelperDll(void)

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    HKEY hKey;
    BOOL bSuccess;

    EnterCriticalSection(&AutodialHelperLockG);
    if (!fAutodialHelperInitG) {
        PCHAR pszPath;
        //
        // Bail out if we were unable to allocate
        // the path string.
        //
        pszPath = new char[MAX_PATH];
        if (pszPath == NULL) {
            LeaveCriticalSection(&AutodialHelperLockG);
            return FALSE;
        }

        //
        // Read the registry to determine the
        // location of the Autodial helper DLL.
        //
        hKey = OpenWinSockRegistryRoot();
        if (hKey != NULL) {
            bSuccess = ReadRegistryEntry(
                         hKey,
                         REGVAL_AUTODIAL_DLL,
                         (PVOID)pszPath,
                         MAX_PATH,
                         REG_SZ);
            CloseWinSockRegistryRoot(hKey);
            if (bSuccess)
                hAutodialHelperDllG = LoadLibrary(pszPath);
        }
        delete pszPath;

        //
        // If the registry key doesn't exist, then
        // try to load the default helper DLL.
        //
        if (hAutodialHelperDllG == NULL)
            hAutodialHelperDllG = LoadLibrary(AUTODIAL_DLL);
        if (hAutodialHelperDllG != NULL) {
            lpfnWSAttemptAutodialAddrG = (WSAttemptAutodialAddrProc)
              GetProcAddress(hAutodialHelperDllG, WSATTEMPTAUTODIALADDR);
            lpfnWSAttemptAutodialNameG = (WSAttemptAutodialNameProc)
              GetProcAddress(hAutodialHelperDllG, WSATTEMPTAUTODIALNAME);
            lpfnWSNoteSuccessfulHostentLookupG = (WSNoteSuccessfulHostentLookupProc)
              GetProcAddress(hAutodialHelperDllG, WSNOTESUCCESSFULHOSTENTLOOKUP);
        }
        fAutodialHelperInitG = TRUE;
    }
    LeaveCriticalSection(&AutodialHelperLockG);

    return (hAutodialHelperDllG != NULL);
} // LoadAutodialHelperDll



BOOL
WSAttemptAutodialAddr(
    IN const struct sockaddr FAR *name,
    IN int namelen
    )

/*++

Routine Description:
    Attempt an Autodial connection given the parameters
    to an unsuccessful call to connect().

Arguments:
    name: a pointer to the sockaddr structure used in
        the call to connect().

    namelen: the length of the name parameter.

Return Value:
    TRUE if the connection was made successfully,
    FALSE otherwise.

--*/

{
    //
    // Load helper DLL, if necessary.
    //
    if (!LoadAutodialHelperDll() || lpfnWSAttemptAutodialAddrG == NULL)
        return FALSE;
    //
    // Call the Autodial DLL.  It will return
    // TRUE if a new connection was made, and
    // FALSE otherwise.
    //
    return (*lpfnWSAttemptAutodialAddrG)(name, namelen);
} // WSAttemptAutoDialAddr



BOOL
WSAttemptAutodialName(
    IN const LPWSAQUERYSETW lpqsRestrictions
    )

/*++

Routine Description:
    Attempt an autodial connection given the parameters
    to an unsuccessful to WSALookupServiceNext().

Arguments:
    lpqsRestrictions: a pointer to the WSAQUERYSETW
        structure used in the call to
        WSALookupServiceBegin().

Return Value:
    TRUE if the connection was made successfully,
    FALSE otherwise.

--*/

{
    //
    // Load helper DLL, if necessary.
    //
    if (!LoadAutodialHelperDll() || lpfnWSAttemptAutodialNameG == NULL)
        return FALSE;
    //
    // Call the Autodial DLL.  It will return
    // TRUE if a new connection was made, and
    // FALSE otherwise.
    //
    return (*lpfnWSAttemptAutodialNameG)(lpqsRestrictions);
} // WSAttemptAutoDialName



VOID
WSNoteSuccessfulHostentLookup(
    IN const char FAR *name,
    IN const ULONG ipaddr
    )

/*++

Routine Description:
    Give Autodial information about successful name
    resolutions via gethostbyname().  This is
    useful for resolvers like DNS where it is impossible
    to get complete alias information about aliases via a
    low-level address.

    Ultimately, this should be called from WSLookupServiceNext(),
    but it's impossible at that level to determine what format
    the results are in.

Arguments:
    name: a pointer to the DNS name

    ipaddr: the IP address

Return Value:
    None.

--*/

{
    //
    // Load helper DLL, if necessary.
    //
    if (!LoadAutodialHelperDll() || lpfnWSNoteSuccessfulHostentLookupG == NULL)
        return;
    //
    // Call the Autodial DLL.
    //
    (*lpfnWSNoteSuccessfulHostentLookupG)(name, ipaddr);
} // WSNoteSuccessulNameLookup

#endif // RASAUTODIAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\async.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    Async.c

Abstract:

    This module contains code for the WinSock asynchronous processing
    thread.

Author:

    David Treadwell (davidtr)    25-May-1992

Revision History:

    Keith Moore (keithmo)        18-Jun-1996
        Moved it over to WS2_32.DLL.

--*/


#include "precomp.h"

#ifdef _WIN64
#pragma warning (push)
#pragma warning (disable:4267)
#endif

//
// Private types
//

typedef struct _SOCK_ASYNC_THREAD_PARAMS
{
      LIST_ENTRY    SockAsyncQueueHead;
      HANDLE        SockAsyncQueueEvent;
      LIST_ENTRY    SocketList;
      HMODULE       SockAsyncModuleHandle;

} SOCK_ASYNC_THREAD_PARAMS, *PSOCK_ASYNC_THREAD_PARAMS;

//
// Private globals.
//

PSOCK_ASYNC_THREAD_PARAMS SockAsyncThreadParams;
CRITICAL_SECTION SockAsyncLock;
HANDLE SockAsyncCurrentTaskHandle;
HANDLE SockAsyncCancelledTaskHandle;
LONG SockAsyncTaskHandleCounter;

//
// Private prototypes.
//

DWORD
WINAPI
SockAsyncThread(
    IN PSOCK_ASYNC_THREAD_PARAMS pThreadParams
    );

BOOL
WINAPI
SockAsyncThreadBlockingHook(
    VOID
    );

VOID
SockProcessAsyncGetHost (
    IN HANDLE TaskHandle,
    IN DWORD OpCode,
    IN HWND hWnd,
    IN unsigned int wMsg,
    IN char FAR *Filter,
    IN int Length,
    IN int Type,
    IN char FAR *Buffer,
    IN int BufferLength
    );

VOID
SockProcessAsyncGetProto (
    IN HANDLE TaskHandle,
    IN DWORD OpCode,
    IN HWND hWnd,
    IN unsigned int wMsg,
    IN char FAR *Filter,
    IN char FAR *Buffer,
    IN int BufferLength
    );

VOID
SockProcessAsyncGetServ (
    IN HANDLE TaskHandle,
    IN DWORD OpCode,
    IN HWND hWnd,
    IN unsigned int wMsg,
    IN char FAR *Filter,
    IN char FAR *Protocol,
    IN char FAR *Buffer,
    IN int BufferLength
    );

DWORD
CopyHostentToBuffer(
    IN char FAR * Buffer,
    IN int BufferLength,
    IN PHOSTENT Hostent
    );

DWORD
CopyServentToBuffer(
    IN char FAR *Buffer,
    IN int BufferLength,
    IN PSERVENT Servent
    );

DWORD
CopyProtoentToBuffer(
    IN char FAR *Buffer,
    IN int BufferLength,
    IN PPROTOENT Protoent
    );

DWORD
BytesInHostent(
    PHOSTENT Hostent
    );

DWORD
BytesInServent(
    PSERVENT Servent
    );

DWORD
BytesInProtoent(
    IN PPROTOENT Protoent
    );

#define SockAcquireGlobalLock() EnterCriticalSection( &SockAsyncLock )
#define SockReleaseGlobalLock() LeaveCriticalSection( &SockAsyncLock )


//
// Public functions.
//


BOOL
SockAsyncGlobalInitialize(
    )
{
    
    assert (gDllHandle!=NULL);
    __try {
        InitializeCriticalSection( &SockAsyncLock );
        return TRUE;
    }
    __except (WS2_EXCEPTION_FILTER ()) {
        return FALSE;
    }
}   // SockAsyncGlobalInitialize

VOID
SockAsyncGlobalTerminate(
    VOID
    )
{

    DeleteCriticalSection( &SockAsyncLock );

}   // SockAsyncGlobalTerminate

BOOL
SockIsAsyncThreadInitialized (
    VOID
    )
{
    return SockAsyncThreadParams!=NULL;
}


BOOL
SockCheckAndInitAsyncThread(
    VOID
    )
{

    HANDLE threadHandle;
    DWORD threadId;
    BOOL  startup_done;
    PSOCK_ASYNC_THREAD_PARAMS pThreadParams;
    WSADATA WSAData;


    //
    // If the async thread is already initialized, return.
    //

    if( SockAsyncThreadParams!=NULL ) {
        return TRUE;
    }

    //
    // Acquire the global lock to synchronize the thread startup.
    //

    SockAcquireGlobalLock();


    //
    // Check again, in case another thread has already initialized
    // the async thread.
    //

    if( SockAsyncThreadParams==NULL ) {

        pThreadParams = NULL;
        startup_done = FALSE;

        TRY_START (guard_lock) {
            //
            // Initialize globals for the async thread
            //

            pThreadParams = new SOCK_ASYNC_THREAD_PARAMS;
            if (pThreadParams==NULL) {
                DEBUGF (DBG_ERR,
                    ("Allocating async thread parameter block.\n"));
                TRY_THROW(guard_lock);
            }


            pThreadParams->SockAsyncModuleHandle = NULL;
            InitializeListHead( &pThreadParams->SockAsyncQueueHead );

            pThreadParams->SockAsyncQueueEvent = CreateEvent(
                                      NULL,
                                      FALSE,
                                      FALSE,
                                      NULL
                                      );

            if( pThreadParams->SockAsyncQueueEvent == NULL ) {
                DEBUGF (DBG_ERR,
                    ("Creating async queue event.\n"));
                TRY_THROW (guard_lock);
            }


            //
            // Add an artificial reference to WS2_32.DLL so that it doesn't
            // go away unexpectedly. We'll remove this reference when we shut
            // down the async thread.
            //

            if( !GetModuleHandleEx(
                        GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,
                        (LPCTSTR)WSAStartup,
                        &pThreadParams->SockAsyncModuleHandle)) {

                DEBUGF (DBG_ERR,
                    ("Referencing ws2_32.dll.\n"));
                TRY_THROW (guard_lock);
            }

            //
            // Add an artificial reference to the startup count so that we
            // won't clean up this dll while the SockAsyncThread is still
            // processing a request
            //

            if ( WSAStartup( 0x202, &WSAData ) != 0 ) {
                DEBUGF (DBG_ERR,
                    ("Starting up ws2_32.dll.\n"));
                TRY_THROW (guard_lock);
            }
            startup_done = TRUE;

            //
            // Create the async thread itself.
            //

            threadHandle = CreateThread(
                               NULL,
                               0,
                               (LPTHREAD_START_ROUTINE) SockAsyncThread,
                               pThreadParams,
                               0,
                               &threadId
                               );

            if( threadHandle == NULL ) {
                DEBUGF (DBG_ERR,
                    ("Creating async thread.\n"));
                TRY_THROW (guard_lock);
            }
            //
            // Close the thread handle, indicate a successful result,
            // and jump down to the right cleanup step
            //

            CloseHandle( threadHandle );

            SockAsyncThreadParams = pThreadParams;
        }
        TRY_CATCH (guard_lock) {
            if (startup_done)
                WSACleanup ();

            if (pThreadParams!=NULL) {

                if (pThreadParams->SockAsyncModuleHandle!=NULL) {
                    FreeLibrary (pThreadParams->SockAsyncModuleHandle);
                }

                if (pThreadParams->SockAsyncQueueEvent!=NULL) {
                    CloseHandle( pThreadParams->SockAsyncQueueEvent );
                }

                delete pThreadParams;
            }
        } TRY_END(guard_lock);

    }


    SockReleaseGlobalLock();

    return SockAsyncThreadParams!=NULL;

} // SockCheckAndInitializeAsyncThread


VOID
SockTerminateAsyncThread(
    VOID
    )
{
    SockAcquireGlobalLock();

    //
    // If the thread's not running, there's not much to do.
    //

    if( SockAsyncThreadParams!=NULL ) {
        BOOL    result;
        PSOCK_ASYNC_THREAD_PARAMS pThreadParams = SockAsyncThreadParams;

        //
        // Set the params to NULL so thread knows in longer in control.
        //
        SockAsyncThreadParams = NULL;

        //
        // Set the queue event so that the async thread wakes up to service
        // this request.
        //
        result = SetEvent( pThreadParams->SockAsyncQueueEvent );
        assert( result );
    }

    //
    // Release the resource and return.
    //

    SockReleaseGlobalLock();

} // SockTerminateAsyncThread


PWINSOCK_CONTEXT_BLOCK
SockAllocateContextBlock(
    DWORD AdditionalSpace
    )
{

    PWINSOCK_CONTEXT_BLOCK contextBlock;

    //
    // Allocate memory for the context block plus any additional
    // space requested.
    //

    AdditionalSpace += sizeof(*contextBlock);

    contextBlock = (PWINSOCK_CONTEXT_BLOCK)new BYTE[AdditionalSpace];

    if( contextBlock == NULL ) {

        return NULL;

    }

    //
    // Get a task handle for this context block.
    //

    do {
        contextBlock->TaskHandle = LongToHandle (
                                    InterlockedIncrement(
                                        &SockAsyncTaskHandleCounter
                                        ));
    }
    while ( contextBlock->TaskHandle == NULL );

    //
    // Return the task handle we allocated.
    //

    return contextBlock;

} // SockAllocateContextBlock


VOID
SockFreeContextBlock(
    IN PWINSOCK_CONTEXT_BLOCK ContextBlock
    )
{
    //
    // Just free the block to process heap.
    //

    delete ContextBlock;

} // SockFreeContextBlock


VOID
SockQueueRequestToAsyncThread(
    IN PWINSOCK_CONTEXT_BLOCK ContextBlock
    )
{
    BOOL result;

    //
    // Acquire the lock that protects the async queue list.
    //

    SockAcquireGlobalLock();

    //
    // Insert the context block at the end of the queue.
    //

    InsertTailList(
        &SockAsyncThreadParams->SockAsyncQueueHead,
        &ContextBlock->AsyncThreadQueueListEntry
        );

    //
    // Set the queue event so that the async thread wakes up to service
    // this request.
    //

    result = SetEvent( SockAsyncThreadParams->SockAsyncQueueEvent );
    assert( result );

    //
    // Release the resource and return.
    //

    SockReleaseGlobalLock();
    return;

} // SockQueueRequestToAsyncThread

INT
SockCancelAsyncRequest(
    IN HANDLE TaskHandle
    )
{

    PLIST_ENTRY entry;
    PWINSOCK_CONTEXT_BLOCK contextBlock;

    //
    // If the async thread has not been initialized, then this must
    // be an invalid context handle.
    //

    if( SockAsyncThreadParams==NULL ) {

        return WSAEINVAL;

    }

    //
    // Hold the lock that protects the async thread context block queue
    // while we do this.  This prevents the async thread from starting
    // new requests while we determine how to execute this cancel.
    //

    SockAcquireGlobalLock();

    //
    // If the specified task handle is currently being processed by the
    // async thread, just set this task handle as the cancelled async
    // thread task handle.  The async thread's blocking hook routine
    // will cancel the request, and the handler routine will not
    // post the message for completion of the request.
    //
    // *** Note that it is possible to complete this request with a
    //     WSAEINVAL while an async request completion message is
    //     about to be posted to the application.  Does this matter?
    //     There is no way an app can distinguish this case from
    //     where the post occurs just before the call to this routine.

    if( TaskHandle == SockAsyncCurrentTaskHandle ) {

        SockAsyncCancelledTaskHandle = TaskHandle;
        SockReleaseGlobalLock();

        return NO_ERROR;

    }

    //
    // Attempt to find the task handle in the queue of context blocks to
    // the async thread.
    //

    for( entry = SockAsyncThreadParams->SockAsyncQueueHead.Flink;
         entry != &SockAsyncThreadParams->SockAsyncQueueHead;
         entry = entry->Flink ) {

        contextBlock = CONTAINING_RECORD(
                           entry,
                           WINSOCK_CONTEXT_BLOCK,
                           AsyncThreadQueueListEntry
                           );

        if( TaskHandle == contextBlock->TaskHandle ) {

            //
            // We found the correct task handle.  Remove it from the list.
            //

            RemoveEntryList( entry );

            //
            // Release the lock, free the context block, and return.
            //

            SockReleaseGlobalLock( );
            SockFreeContextBlock( contextBlock );

            return NO_ERROR;

        }

    }

    //
    // The task handle was not found on the list.  Either the request
    // was already completed or the task handle was just plain bogus.
    // In either case, fail the request.
    //

    SockReleaseGlobalLock();
    return WSAEINVAL;

}   // SockCancelAsyncRequest


DWORD
WINAPI
SockAsyncThread(
    IN PSOCK_ASYNC_THREAD_PARAMS    pThreadParams
    )
{

    PWINSOCK_CONTEXT_BLOCK contextBlock;
    PLIST_ENTRY listEntry;
    FARPROC previousHook;

    //
    // Set up our blocking hook routine.  We'll use it to handle
    // cancelling async requests.
    //

    previousHook = WSASetBlockingHook(
                       (FARPROC)SockAsyncThreadBlockingHook
                       );

    //
    // Loop forever dispatching actions.
    //

    while( TRUE ) {

        //
        // Wait for the async queue event to indicate that there is
        // something on the queue.
        //

        WaitForSingleObject(
            pThreadParams->SockAsyncQueueEvent,
            INFINITE
            );

        //
        // Acquire the lock that protects the async queue.
        //

        SockAcquireGlobalLock();

        //
        // As long as there are items to process, process them.
        //

        while( !IsListEmpty( &pThreadParams->SockAsyncQueueHead ) ) {

            if (pThreadParams!=SockAsyncThreadParams) {
                //
                // We no longer in control
                // Exit.
                goto Exit;
            }
            //
            // Remove the first item from the queue.
            //

            listEntry = RemoveHeadList( &pThreadParams->SockAsyncQueueHead );

            contextBlock = CONTAINING_RECORD(
                               listEntry,
                               WINSOCK_CONTEXT_BLOCK,
                               AsyncThreadQueueListEntry
                               );

            //
            // Remember the task handle that we're processing.  This
            // is necessary in order to support WSACancelAsyncRequest.
            //

            SockAsyncCurrentTaskHandle = contextBlock->TaskHandle;

            //
            // Release the list lock while we're processing the request.
            //

            SockReleaseGlobalLock();

            //
            // Act based on the opcode in the context block.
            //

            switch( contextBlock->OpCode ) {

            case WS_OPCODE_GET_HOST_BY_ADDR:
            case WS_OPCODE_GET_HOST_BY_NAME:

                SockProcessAsyncGetHost(
                    contextBlock->TaskHandle,
                    contextBlock->OpCode,
                    contextBlock->Overlay.AsyncGetHost.hWnd,
                    contextBlock->Overlay.AsyncGetHost.wMsg,
                    contextBlock->Overlay.AsyncGetHost.Filter,
                    contextBlock->Overlay.AsyncGetHost.Length,
                    contextBlock->Overlay.AsyncGetHost.Type,
                    contextBlock->Overlay.AsyncGetHost.Buffer,
                    contextBlock->Overlay.AsyncGetHost.BufferLength
                    );

                break;

            case WS_OPCODE_GET_PROTO_BY_NUMBER:
            case WS_OPCODE_GET_PROTO_BY_NAME:

                SockProcessAsyncGetProto(
                    contextBlock->TaskHandle,
                    contextBlock->OpCode,
                    contextBlock->Overlay.AsyncGetProto.hWnd,
                    contextBlock->Overlay.AsyncGetProto.wMsg,
                    contextBlock->Overlay.AsyncGetProto.Filter,
                    contextBlock->Overlay.AsyncGetProto.Buffer,
                    contextBlock->Overlay.AsyncGetProto.BufferLength
                    );

                break;

            case WS_OPCODE_GET_SERV_BY_PORT:
            case WS_OPCODE_GET_SERV_BY_NAME:

                SockProcessAsyncGetServ(
                    contextBlock->TaskHandle,
                    contextBlock->OpCode,
                    contextBlock->Overlay.AsyncGetServ.hWnd,
                    contextBlock->Overlay.AsyncGetServ.wMsg,
                    contextBlock->Overlay.AsyncGetServ.Filter,
                    contextBlock->Overlay.AsyncGetServ.Protocol,
                    contextBlock->Overlay.AsyncGetServ.Buffer,
                    contextBlock->Overlay.AsyncGetServ.BufferLength
                    );

                break;

            default:

                //
                // We got a bogus opcode.
                //

                assert( !"Bogus async opcode" );
                __assume (0);
            }

            //
            // Set the variable that holds the task handle that we're
            // currently processing to 0, since we're not actually
            // processing a task handle right now.
            //

            SockAsyncCurrentTaskHandle = NULL;

            //
            // Free the context block, reacquire the list lock, and
            // continue.
            //

            SockFreeContextBlock( contextBlock );
            SockAcquireGlobalLock();

        }

        //
        // Release the list lock and redo the wait.
        //

        SockReleaseGlobalLock();

    }

Exit:
    while( !IsListEmpty( &pThreadParams->SockAsyncQueueHead ) ) {

        listEntry = RemoveHeadList( &pThreadParams->SockAsyncQueueHead );

        contextBlock = CONTAINING_RECORD(
                           listEntry,
                           WINSOCK_CONTEXT_BLOCK,
                           AsyncThreadQueueListEntry
                           );

        SockFreeContextBlock( contextBlock );

    }

    SockReleaseGlobalLock();

    //
    // Decrement our init ref count (can safely clean up now)
    //

    WSACleanup();

    //
    // Clean up thread-specific resources
    //

    CloseHandle( pThreadParams->SockAsyncQueueEvent );

    //
    // Save module handle before destroying heap block.
    //
    HMODULE h = pThreadParams->SockAsyncModuleHandle;

    delete pThreadParams;

    //
    // Remove the artifical reference we added in
    // SockCheckAndInitAsyncThread() and exit this thread.
    //

    FreeLibraryAndExitThread(
        h,
        0
        );

    //
    // We should never get here, but just in case...
    //

    // return 0;

} // SockAsyncThread


BOOL
WINAPI
SockAsyncThreadBlockingHook(
    VOID
    )
{

    //
    // If the current async request is being cancelled, blow away
    // the current blocking call.
    //

    if( SockAsyncCurrentTaskHandle == SockAsyncCancelledTaskHandle ) {

        int error;

        error = WSACancelBlockingCall();
        assert( error == NO_ERROR );
    }

    return FALSE;

} // SockAsyncThreadBlockingHook


VOID
SockProcessAsyncGetHost(
    IN HANDLE TaskHandle,
    IN DWORD OpCode,
    IN HWND hWnd,
    IN unsigned int wMsg,
    IN char FAR *Filter,
    IN int Length,
    IN int Type,
    IN char FAR *Buffer,
    IN int BufferLength
    )
{

    PHOSTENT returnHost;
    DWORD requiredBufferLength = 0;
    LPARAM lParam;
    INT error;
    PWINSOCK_POST_ROUTINE   sockPostRoutine;

    assert( OpCode == WS_OPCODE_GET_HOST_BY_ADDR ||
            OpCode == WS_OPCODE_GET_HOST_BY_NAME );

    //
    // Get the necessary information.
    //

    if( OpCode == WS_OPCODE_GET_HOST_BY_ADDR ) {

        returnHost = gethostbyaddr(
                          Filter,
                          Length,
                          Type
                          );

    } else {

        returnHost = gethostbyname(
                          Filter
                          );

    }

    if( returnHost == NULL ) {

        error = WSAGetLastError();

    }
    else {
        WS2_32_W4_INIT error = NO_ERROR;
    }

    //
    // Hold the lock that protects the async thread context block queue
    // while we do this.  This prevents a race between this thread and
    // any thread invoking WSACancelAsyncRequest().
    //

    SockAcquireGlobalLock();

    //
    // If this request was cancelled, just return.
    //

    if( TaskHandle == SockAsyncCancelledTaskHandle ) {

        SockReleaseGlobalLock();
        return;

    }

    //
    // Copy the hostent structure to the output buffer.
    //

    if( returnHost != NULL ) {

        requiredBufferLength = CopyHostentToBuffer(
                                   Buffer,
                                   BufferLength,
                                   returnHost
                                   );

        if( requiredBufferLength > (DWORD)BufferLength ) {

            error = WSAENOBUFS;

        } else {

            error = NO_ERROR;

        }

    }

    //
    // Set the current async thread task handle to 0 so that if a cancel
    // request comes in after this point it is failed properly.
    //

    SockAsyncCurrentTaskHandle = NULL;

    //
    // Release the global lock.
    //

    SockReleaseGlobalLock();

    //
    // Build lParam for the message we'll post to the application.
    // The high 16 bits are the error code, the low 16 bits are
    // the minimum buffer size required for the operation.
    //

    lParam = WSAMAKEASYNCREPLY( requiredBufferLength, error );

    //
    // Post a message to the application indication that the data it
    // requested is available.
    //

    assert( sizeof(TaskHandle) == sizeof(HANDLE) );

    sockPostRoutine = GET_SOCK_POST_ROUTINE ();

    //
    // !!! Need a mechanism to repost if the post failed!
    //

    if (!sockPostRoutine || !sockPostRoutine(
                 hWnd,
                 wMsg,
                 (WPARAM)TaskHandle,
                 lParam
                 )) {


        // Rem assert, since this might be an "orphaned" SockAsyncThread
        // in the process of tearing itself down
        //
        //assert( !"SockPostRoutine failed" );

    }

}   // SockProcessAsyncGetHost


VOID
SockProcessAsyncGetProto(
    IN HANDLE TaskHandle,
    IN DWORD OpCode,
    IN HWND hWnd,
    IN unsigned int wMsg,
    IN char FAR *Filter,
    IN char FAR *Buffer,
    IN int BufferLength
    )
{

    PPROTOENT returnProto;
    DWORD requiredBufferLength = 0;
    LPARAM lParam;
    INT error;
    PWINSOCK_POST_ROUTINE   sockPostRoutine;

    assert( OpCode == WS_OPCODE_GET_PROTO_BY_NAME ||
            OpCode == WS_OPCODE_GET_PROTO_BY_NUMBER );

    //
    // Get the necessary information.
    //

    if( OpCode == WS_OPCODE_GET_PROTO_BY_NAME ) {

        returnProto = getprotobyname( Filter );

    } else {

        returnProto = getprotobynumber( (int)(LONG_PTR)Filter );

    }

    if( returnProto == NULL ) {

        error = WSAGetLastError();

    }
    else {
        WS2_32_W4_INIT error = NO_ERROR;
    }

    //
    // Hold the lock that protects the async thread context block queue
    // while we do this.  This prevents a race between this thread and
    // any thread invoking WSACancelAsyncRequest().
    //

    SockAcquireGlobalLock();

    //
    // If this request was cancelled, just return.
    //

    if( TaskHandle == SockAsyncCancelledTaskHandle ) {

        SockReleaseGlobalLock();
        return;

    }

    //
    // Copy the protoent structure to the output buffer.
    //

    if( returnProto != NULL ) {

        requiredBufferLength = CopyProtoentToBuffer(
                                   Buffer,
                                   BufferLength,
                                   returnProto
                                   );

        if( requiredBufferLength > (DWORD)BufferLength ) {

            error = WSAENOBUFS;

        } else {

            error = NO_ERROR;

        }

    }

    //
    // Set the current async thread task handle to 0 so that if a cancel
    // request comes in after this point it is failed properly.
    //

    SockAsyncCurrentTaskHandle = NULL;

    //
    // Release the global lock.
    //

    SockReleaseGlobalLock();

    //
    // Build lParam for the message we'll post to the application.
    // The high 16 bits are the error code, the low 16 bits are
    // the minimum buffer size required for the operation.
    //

    lParam = WSAMAKEASYNCREPLY( requiredBufferLength, error );

    //
    // Post a message to the application indication that the data it
    // requested is available.
    //

    assert( sizeof(TaskHandle) == sizeof(HANDLE) );

    sockPostRoutine = GET_SOCK_POST_ROUTINE ();
    //
    // !!! Need a mechanism to repost if the post failed!
    //

    if (!sockPostRoutine || !sockPostRoutine(
                 hWnd,
                 wMsg,
                 (WPARAM)TaskHandle,
                 lParam
                 )) {


        // Rem assert, since this might be an "orphaned" SockAsyncThread
        // in the process of tearing itself down
        //
        //assert( !"SockPostRoutine failed" );

    }

}   // SockProcessAsyncGetProto


VOID
SockProcessAsyncGetServ(
    IN HANDLE TaskHandle,
    IN DWORD OpCode,
    IN HWND hWnd,
    IN unsigned int wMsg,
    IN char FAR *Filter,
    IN char FAR *Protocol,
    IN char FAR *Buffer,
    IN int BufferLength
    )
{

    PSERVENT returnServ;
    DWORD requiredBufferLength = 0;
    LPARAM lParam;
    INT error;
    PWINSOCK_POST_ROUTINE   sockPostRoutine;

    assert( OpCode == WS_OPCODE_GET_SERV_BY_NAME ||
            OpCode == WS_OPCODE_GET_SERV_BY_PORT );

    //
    // Get the necessary information.
    //

    if( OpCode == WS_OPCODE_GET_SERV_BY_NAME ) {

        returnServ = getservbyname(
                         Filter,
                         Protocol
                         );

    } else {

        returnServ = getservbyport(
                         (int)(LONG_PTR)Filter,
                         Protocol
                         );

    }

    if( returnServ == NULL ) {

        error = GetLastError();

    }
    else {
        WS2_32_W4_INIT error = NO_ERROR;
    }

    //
    // Hold the lock that protects the async thread context block queue
    // while we do this.  This prevents a race between this thread and
    // any thread invoking WSACancelAsyncRequest().
    //

    SockAcquireGlobalLock();

    //
    // If this request was cancelled, just return.
    //

    if( TaskHandle == SockAsyncCancelledTaskHandle ) {

        SockReleaseGlobalLock();
        return;

    }

    //
    // Copy the servent structure to the output buffer.
    //

    if( returnServ != NULL ) {

        requiredBufferLength = CopyServentToBuffer(
                                   Buffer,
                                   BufferLength,
                                   returnServ
                                   );

        if( requiredBufferLength > (DWORD)BufferLength ) {

            error = WSAENOBUFS;

        } else {

            error = NO_ERROR;

        }

    }

    //
    // Set the current async thread task handle to 0 so that if a cancel
    // request comes in after this point it is failed properly.
    //

    SockAsyncCurrentTaskHandle = NULL;

    //
    // Release the global lock.
    //

    SockReleaseGlobalLock();

    //
    // Build lParam for the message we'll post to the application.
    // The high 16 bits are the error code, the low 16 bits are
    // the minimum buffer size required for the operation.
    //

    lParam = WSAMAKEASYNCREPLY( requiredBufferLength, error );

    //
    // Post a message to the application indication that the data it
    // requested is available.
    //

    assert( sizeof(TaskHandle) == sizeof(HANDLE) );


    sockPostRoutine = GET_SOCK_POST_ROUTINE ();
    //
    // !!! Need a mechanism to repost if the post failed!
    //

    if (!sockPostRoutine || !sockPostRoutine(
                 hWnd,
                 wMsg,
                 (WPARAM)TaskHandle,
                 lParam
                 )) {


        // Rem assert, since this might be an "orphaned" SockAsyncThread
        // in the process of tearing itself down
        //
        //assert( !"SockPostRoutine failed" );

    }
}   // SockProcessAsyncGetServ



DWORD
CopyHostentToBuffer(
    char FAR *Buffer,
    int BufferLength,
    PHOSTENT Hostent
    )
{
    DWORD requiredBufferLength;
    DWORD bytesFilled;
    PCHAR currentLocation = Buffer;
    DWORD aliasCount;
    DWORD addressCount;
    DWORD i;
    PHOSTENT outputHostent = (PHOSTENT)Buffer;

    //
    // Determine how many bytes are needed to fully copy the structure.
    //

    requiredBufferLength = BytesInHostent( Hostent );

    //
    // Zero the user buffer.
    //

    if ( (DWORD)BufferLength > requiredBufferLength ) {
        ZeroMemory( Buffer, requiredBufferLength );
    } else {
        ZeroMemory( Buffer, BufferLength );
    }

    //
    // Copy over the hostent structure if it fits.
    //

    bytesFilled = sizeof(*Hostent);

    if ( bytesFilled > (DWORD)BufferLength ) {
        return requiredBufferLength;
    }

    CopyMemory( currentLocation, Hostent, sizeof(*Hostent) );
    currentLocation = Buffer + bytesFilled;

    outputHostent->h_name = NULL;
    outputHostent->h_aliases = NULL;
    outputHostent->h_addr_list = NULL;

    //
    // Count the host's aliases and set up an array to hold pointers to
    // them.
    //

    for ( aliasCount = 0;
          Hostent->h_aliases[aliasCount] != NULL;
          aliasCount++ );

    bytesFilled += (aliasCount+1) * sizeof(char FAR *);

    if ( bytesFilled > (DWORD)BufferLength ) {
        Hostent->h_aliases = NULL;
        return requiredBufferLength;
    }

    outputHostent->h_aliases = (char FAR * FAR *)currentLocation;
    currentLocation = Buffer + bytesFilled;

    //
    // Count the host's addresses and set up an array to hold pointers to
    // them.
    //

    for ( addressCount = 0;
          Hostent->h_addr_list[addressCount] != NULL;
          addressCount++ );

    bytesFilled += (addressCount+1) * sizeof(void FAR *);

    if ( bytesFilled > (DWORD)BufferLength ) {
        Hostent->h_addr_list = NULL;
        return requiredBufferLength;
    }

    outputHostent->h_addr_list = (char FAR * FAR *)currentLocation;
    currentLocation = Buffer + bytesFilled;

    //
    // Start filling in addresses.  Do addresses before filling in the
    // host name and aliases in order to avoid alignment problems.
    //

    for ( i = 0; i < addressCount; i++ ) {

        bytesFilled += Hostent->h_length;

        if ( bytesFilled > (DWORD)BufferLength ) {
            outputHostent->h_addr_list[i] = NULL;
            return requiredBufferLength;
        }

        outputHostent->h_addr_list[i] = currentLocation;

        CopyMemory(
            currentLocation,
            Hostent->h_addr_list[i],
            Hostent->h_length
            );

        currentLocation = Buffer + bytesFilled;
    }

    outputHostent->h_addr_list[i] = NULL;

    //
    // Copy the host name if it fits.
    //

    bytesFilled += strlen( Hostent->h_name ) + 1;

    if ( bytesFilled > (DWORD)BufferLength ) {
        return requiredBufferLength;
    }

    outputHostent->h_name = currentLocation;

    CopyMemory( currentLocation, Hostent->h_name, strlen( Hostent->h_name ) + 1 );
    currentLocation = Buffer + bytesFilled;

    //
    // Start filling in aliases.
    //

    for ( i = 0; i < aliasCount; i++ ) {

        bytesFilled += strlen( Hostent->h_aliases[i] ) + 1;

        if ( bytesFilled > (DWORD)BufferLength ) {
            outputHostent->h_aliases[i] = NULL;
            return requiredBufferLength;
        }

        outputHostent->h_aliases[i] = currentLocation;

        CopyMemory(
            currentLocation,
            Hostent->h_aliases[i],
            strlen( Hostent->h_aliases[i] ) + 1
            );

        currentLocation = Buffer + bytesFilled;
    }

    outputHostent->h_aliases[i] = NULL;

    return requiredBufferLength;

}   // CopyHostentToBuffer



DWORD
CopyServentToBuffer(
    IN char FAR *Buffer,
    IN int BufferLength,
    IN PSERVENT Servent
    )
{
    DWORD requiredBufferLength;
    DWORD bytesFilled;
    PCHAR currentLocation = Buffer;
    DWORD aliasCount;
    DWORD i;
    PSERVENT outputServent = (PSERVENT)Buffer;

    //
    // Determine how many bytes are needed to fully copy the structure.
    //

    requiredBufferLength = BytesInServent( Servent );

    //
    // Zero the user buffer.
    //

    if ( (DWORD)BufferLength > requiredBufferLength ) {
        ZeroMemory( Buffer, requiredBufferLength );
    } else {
        ZeroMemory( Buffer, BufferLength );
    }

    //
    // Copy over the servent structure if it fits.
    //

    bytesFilled = sizeof(*Servent);

    if ( bytesFilled > (DWORD)BufferLength ) {
        return requiredBufferLength;
    }

    CopyMemory( currentLocation, Servent, sizeof(*Servent) );
    currentLocation = Buffer + bytesFilled;

    outputServent->s_name = NULL;
    outputServent->s_aliases = NULL;
    outputServent->s_proto = NULL;

    //
    // Count the service's aliases and set up an array to hold pointers to
    // them.
    //

    for ( aliasCount = 0;
          Servent->s_aliases[aliasCount] != NULL;
          aliasCount++ );

    bytesFilled += (aliasCount+1) * sizeof(char FAR *);

    if ( bytesFilled > (DWORD)BufferLength ) {
        Servent->s_aliases = NULL;
        return requiredBufferLength;
    }

    outputServent->s_aliases = (char FAR * FAR *)currentLocation;
    currentLocation = Buffer + bytesFilled;

    //
    // Copy the service name if it fits.
    //

    bytesFilled += strlen( Servent->s_name ) + 1;

    if ( bytesFilled > (DWORD)BufferLength ) {
        return requiredBufferLength;
    }

    outputServent->s_name = currentLocation;

    CopyMemory( currentLocation, Servent->s_name, strlen( Servent->s_name ) + 1 );
    currentLocation = Buffer + bytesFilled;

    //
    // Copy the protocol name if it fits.
    //

    bytesFilled += strlen( Servent->s_proto ) + 1;

    if ( bytesFilled > (DWORD)BufferLength ) {
        return requiredBufferLength;
    }

    outputServent->s_proto = currentLocation;

    CopyMemory( currentLocation, Servent->s_proto, strlen( Servent->s_proto ) + 1 );
    currentLocation = Buffer + bytesFilled;

    //
    // Start filling in aliases.
    //

    for ( i = 0; i < aliasCount; i++ ) {

        bytesFilled += strlen( Servent->s_aliases[i] ) + 1;

        if ( bytesFilled > (DWORD)BufferLength ) {
            outputServent->s_aliases[i] = NULL;
            return requiredBufferLength;
        }

        outputServent->s_aliases[i] = currentLocation;

        CopyMemory(
            currentLocation,
            Servent->s_aliases[i],
            strlen( Servent->s_aliases[i] ) + 1
            );

        currentLocation = Buffer + bytesFilled;
    }

    outputServent->s_aliases[i] = NULL;

    return requiredBufferLength;

}   // CopyServentToBuffer



DWORD
CopyProtoentToBuffer(
    IN char FAR *Buffer,
    IN int BufferLength,
    IN PPROTOENT Protoent
    )
{
    DWORD requiredBufferLength;
    DWORD bytesFilled;
    PCHAR currentLocation = Buffer;
    DWORD aliasCount;
    DWORD i;
    PPROTOENT outputProtoent = (PPROTOENT)Buffer;

    //
    // Determine how many bytes are needed to fully copy the structure.
    //

    requiredBufferLength = BytesInProtoent( Protoent );

    //
    // Zero the user buffer.
    //

    if ( (DWORD)BufferLength > requiredBufferLength ) {
        ZeroMemory( Buffer, requiredBufferLength );
    } else {
        ZeroMemory( Buffer, BufferLength );
    }

    //
    // Copy over the protoent structure if it fits.
    //

    bytesFilled = sizeof(*Protoent);

    if ( bytesFilled > (DWORD)BufferLength ) {
        return requiredBufferLength;
    }

    CopyMemory( currentLocation, Protoent, sizeof(*Protoent) );
    currentLocation = Buffer + bytesFilled;

    outputProtoent->p_name = NULL;
    outputProtoent->p_aliases = NULL;

    //
    // Count the protocol's aliases and set up an array to hold pointers to
    // them.
    //

    for ( aliasCount = 0;
          Protoent->p_aliases[aliasCount] != NULL;
          aliasCount++ );

    bytesFilled += (aliasCount+1) * sizeof(char FAR *);

    if ( bytesFilled > (DWORD)BufferLength ) {
        Protoent->p_aliases = NULL;
        return requiredBufferLength;
    }

    outputProtoent->p_aliases = (char FAR * FAR *)currentLocation;
    currentLocation = Buffer + bytesFilled;

    //
    // Copy the protocol name if it fits.
    //

    bytesFilled += strlen( Protoent->p_name ) + 1;

    if ( bytesFilled > (DWORD)BufferLength ) {
        return requiredBufferLength;
    }

    outputProtoent->p_name = currentLocation;

    CopyMemory( currentLocation, Protoent->p_name, strlen( Protoent->p_name ) + 1 );
    currentLocation = Buffer + bytesFilled;

    //
    // Start filling in aliases.
    //

    for ( i = 0; i < aliasCount; i++ ) {

        bytesFilled += strlen( Protoent->p_aliases[i] ) + 1;

        if ( bytesFilled > (DWORD)BufferLength ) {
            outputProtoent->p_aliases[i] = NULL;
            return requiredBufferLength;
        }

        outputProtoent->p_aliases[i] = currentLocation;

        CopyMemory(
            currentLocation,
            Protoent->p_aliases[i],
            strlen( Protoent->p_aliases[i] ) + 1
            );

        currentLocation = Buffer + bytesFilled;
    }

    outputProtoent->p_aliases[i] = NULL;

    return requiredBufferLength;

}   // CopyProtoentToBuffer



DWORD
BytesInHostent(
    PHOSTENT Hostent
    )
{
    DWORD total;
    int i;

    total = sizeof(HOSTENT);
    total += strlen( Hostent->h_name ) + 1;

    //
    // Account for the NULL terminator pointers at the end of the
    // alias and address arrays.
    //

    total += sizeof(char *) + sizeof(char *);

    for ( i = 0; Hostent->h_aliases[i] != NULL; i++ ) {
        total += strlen( Hostent->h_aliases[i] ) + 1 + sizeof(char *);
    }

    for ( i = 0; Hostent->h_addr_list[i] != NULL; i++ ) {
        total += Hostent->h_length + sizeof(char *);
    }

    //
    // Pad the answer to an eight-byte boundary.
    //

    return (total + 7) & ~7;

}   // BytesInHostent



DWORD
BytesInServent(
    IN PSERVENT Servent
    )
{
    DWORD total;
    int i;

    total = sizeof(SERVENT);
    total += strlen( Servent->s_name ) + 1;
    total += strlen( Servent->s_proto ) + 1;
    total += sizeof(char *);

    for ( i = 0; Servent->s_aliases[i] != NULL; i++ ) {
        total += strlen( Servent->s_aliases[i] ) + 1 + sizeof(char *);
    }

    return total;

}   // BytesInServent



DWORD
BytesInProtoent(
    IN PPROTOENT Protoent
    )
{
    DWORD total;
    int i;

    total = sizeof(PROTOENT);
    total += strlen( Protoent->p_name ) + 1;
    total += sizeof(char *);

    for ( i = 0; Protoent->p_aliases[i] != NULL; i++ ) {
        total += strlen( Protoent->p_aliases[i] ) + 1 + sizeof(char *);
    }

    return total;

}   // BytesInProtoent

#ifdef _WIN64
#pragma warning (pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\bhook.cpp ===
/*++

    Copyright (c) 1996 Microsoft Corporation

Module Name:

    bhook.cpp

Abstract:

    This module contains the winsock API entrypoints for manipulating
    blocking hooks for WinSock 1.x applications.

    The following functions are exported by this module:

        WSACancelBlockingCall()
        WSAIsBlocking()
        WSASetBlockingHook()
        WSAUnhookBlockingHook()

Author:

    Keith Moore keithmo@microsoft.com 10-May-1996

Revision History:

--*/

#include "precomp.h"



int
WSAAPI
WSACancelBlockingCall(
    VOID
    )

/*++

Routine Description:

    This function cancels any outstanding blocking operation for this
    task.  It is normally used in two situations:

        (1) An application is processing a message which has been
          received while a blocking call is in progress.  In this case,
          WSAIsBlocking() will be true.

        (2) A blocking call is in progress, and Windows Sockets has
          called back to the application's "blocking hook" function (as
          established by WSASetBlockingHook()).

    In each case, the original blocking call will terminate as soon as
    possible with the error WSAEINTR.  (In (1), the termination will not
    take place until Windows message scheduling has caused control to
    revert to the blocking routine in Windows Sockets.  In (2), the
    blocking call will be terminated as soon as the blocking hook
    function completes.)

    In the case of a blocking connect() operation, the Windows Sockets
    implementation will terminate the blocking call as soon as possible,
    but it may not be possible for the socket resources to be released
    until the connection has completed (and then been reset) or timed
    out.  This is likely to be noticeable only if the application
    immediately tries to open a new socket (if no sockets are
    available), or to connect() to the same peer.

Arguments:

    None.

Return Value:

    The value returned by WSACancelBlockingCall() is 0 if the operation
    was successfully canceled.  Otherwise the value SOCKET_ERROR is
    returned, and a specific error number may be retrieved by calling
    WSAGetLastError().

--*/

{
    PDPROCESS Process;
    PDTHREAD  Thread;
    INT       ErrorCode;

    ErrorCode = PROLOG(&Process,&Thread);

    if (ErrorCode!=ERROR_SUCCESS)
    {
        if( ErrorCode != WSAEINPROGRESS ) {
            SetLastError(ErrorCode);
            return SOCKET_ERROR;
        }
    } //if

    //
    // Verify this isn't a WinSock 2.x app trying to do something.
    //

    if( Process->GetMajorVersion() >= 2 ) {
        SetLastError( WSAEOPNOTSUPP );
        return SOCKET_ERROR;
    }

    //
    // Let the DTHREAD object cancel the socket I/O initiated in
    // this thread.
    //

    ErrorCode = Thread->CancelBlockingCall();

    if (ErrorCode == ERROR_SUCCESS) {
        return (ERROR_SUCCESS);
    }
    else {
        SetLastError(ErrorCode);
        return (SOCKET_ERROR);
    }

} // WSACancelBlockingCall


BOOL
WSAAPI
WSAIsBlocking(
    VOID
    )

/*++

Routine Description:

    This function allows a task to determine if it is executing while
    waiting for a previous blocking call to complete.

Arguments:

    None.

Return Value:

    The return value is TRUE if there is an outstanding blocking
    function awaiting completion.  Otherwise, it is FALSE.

--*/

{
    PDTHREAD  Thread;
    INT       ErrorCode;

    ErrorCode = TURBO_PROLOG_OVLP(&Thread);

    if (ErrorCode!=ERROR_SUCCESS)
    {
        if( ErrorCode != WSAEINPROGRESS ) {
            return FALSE;
        }
    } //if

    return Thread->IsBlocking();

} // WSAIsBlocking


FARPROC
WSAAPI
WSASetBlockingHook (
    FARPROC lpBlockFunc
    )

/*++

Routine Description:

    This function installs a new function which a Windows Sockets
    implementation should use to implement blocking socket function
    calls.

    A Windows Sockets implementation includes a default mechanism by
    which blocking socket functions are implemented.  The function
    WSASetBlockingHook() gives the application the ability to execute
    its own function at "blocking" time in place of the default
    function.

    When an application invokes a blocking Windows Sockets API
    operation, the Windows Sockets implementation initiates the
    operation and then enters a loop which is equivalent to the
    following pseudocode:

        for(;;) {
             // flush messages for good user response
             while(BlockingHook())
                  ;
             // check for WSACancelBlockingCall()
             if(operation_cancelled())
                  break;
             // check to see if operation completed
             if(operation_complete())
                  break;     // normal completion
        }

    The default BlockingHook() function is equivalent to:

        BOOL DefaultBlockingHook(void) {
             MSG msg;
             BOOL ret;
             // get the next message if any
             ret = (BOOL)PeekMessage(&msg,0,0,PM_REMOVE);
             // if we got one, process it
             if (ret) {
                  TranslateMessage(&msg);
                  DispatchMessage(&msg);
             }
             // TRUE if we got a message
             return ret;
        }

    The WSASetBlockingHook() function is provided to support those
    applications which require more complex message processing - for
    example, those employing the MDI (multiple document interface)
    model.  It is not intended as a mechanism for performing general
    applications functions.  In particular, the only Windows Sockets API
    function which may be issued from a custom blocking hook function is
    WSACancelBlockingCall(), which will cause the blocking loop to
    terminate.

Arguments:

    lpBlockFunc - A pointer to the procedure instance address of the
        blocking function to be installed.

Return Value:

    The return value is a pointer to the procedure-instance of the
    previously installed blocking function.  The application or library
    that calls the WSASetBlockingHook () function should save this
    return value so that it can be restored if necessary.  (If "nesting"
    is not important, the application may simply discard the value
    returned by WSASetBlockingHook() and eventually use
    WSAUnhookBlockingHook() to restore the default mechanism.) If the
    operation fails, a NULL pointer is returned, and a specific error
    number may be retrieved by calling WSAGetLastError().

--*/

{
    PDPROCESS          Process;
    PDTHREAD           Thread;
    INT                ErrorCode;
    FARPROC            PreviousHook;

    ErrorCode = PROLOG(&Process,&Thread);

    if (ErrorCode!=ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return NULL;
    } //if

    //
    // Verify this isn't a WinSock 2.x app trying to do something.
    //

    if( Process->GetMajorVersion() >= 2 ) {
        SetLastError( WSAEOPNOTSUPP );
        return NULL;
    }

    //
    // Validate the blocking hook parameter.
    //

    if( IsBadCodePtr( lpBlockFunc ) ) {
        SetLastError( WSAEFAULT );
        return NULL;
    }

    //
    // Let the DTHREAD object set the blocking hook & return the previous
    // hook.
    //

    PreviousHook = Thread->SetBlockingHook( lpBlockFunc );
    assert( PreviousHook != NULL );

    return PreviousHook;

} // WSASetBlockingHook


int
WSAAPI
WSAUnhookBlockingHook(
    VOID
    )

/*++

Routine Description:

    This function removes any previous blocking hook that has been
    installed and reinstalls the default blocking mechanism.

    WSAUnhookBlockingHook() will always install the default mechanism,
    not the previous mechanism.  If an application wish to nest blocking
    hooks - i.e.  to establish a temporary blocking hook function and
    then revert to the previous mechanism (whether the default or one
    established by an earlier WSASetBlockingHook()) - it must save and
    restore the value returned by WSASetBlockingHook(); it cannot use
    WSAUnhookBlockingHook().

Arguments:

    None.

Return Value:

    The return value is 0 if the operation was successful.  Otherwise
    the value SOCKET_ERROR is returned, and a specific error number may
    be retrieved by calling WSAGetLastError().

--*/

{
    PDPROCESS          Process;
    PDTHREAD           Thread;
    INT                ErrorCode;

    ErrorCode = PROLOG(&Process,&Thread);

    if (ErrorCode!=ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return SOCKET_ERROR;
    } //if

    //
    // Verify this isn't a WinSock 2.x app trying to do something.
    //

    if( Process->GetMajorVersion() >= 2 ) {
        SetLastError( WSAEOPNOTSUPP );
        return SOCKET_ERROR;
    }

    //
    // Let the DTHREAD object unhook the blocking hook.
    //

    ErrorCode = Thread->UnhookBlockingHook();

    if (ErrorCode == ERROR_SUCCESS) {
        return (ERROR_SUCCESS);
    }
    else {
        SetLastError(ErrorCode);
        return (SOCKET_ERROR);
    }
} // WSAUnhookBlockingHook
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\dcatitem.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    dcatitem.cpp

Abstract:

    This  file  contains  the  class  implementation for the PROTO_CATALOG_ITEM
    class.   This  class  defines  the  interface  to  the  entries that can be
    installed and retrieved in the protocol catalog.

Author:

    Paul Drews (drewsxpa@ashland.intel.com) 31-July-1995

Notes:

    $Revision:   1.16  $

    $Modtime:   08 Mar 1996 13:16:44  $

Revision History:

    most-recent-revision-date email-name
        description

    23-Aug-1995 dirk@mink.intel.com
        Moved includes into precomp.h

    31-July-1995 drewsxpa@ashland.intel.com
        Original created from code separated out from dcatalog module.

--*/


#include "precomp.h"



PROTO_CATALOG_ITEM::PROTO_CATALOG_ITEM()
/*++

Routine Description:

    This  procedure  constructs  an empty PROTO_CATALOG_ITEM object.  The first
    method  invoked  after  this  constructor must be InitializeFromRegistry or
    InitializeFromValues.

Arguments:

    None

Return Value:

    Implicitly  returns  a pointer to a newly created PROTO_CATALOG_ITEM object
    or NULL if there is a memory allocation failure.
--*/
{
    DEBUGF(
        DBG_TRACE,
        ("PROTO_CATALOG_ITEM constructor\n"));

    // Simply initialize embedded pointer values for safety.
    m_LibraryPath[0] = '\0';
    m_Provider = NULL;
    m_reference_count = 1;
#if defined(DEBUG_TRACING)
    InitializeListHead (&m_CatalogLinkage);
#endif
}  // PROTO_CATALOG_ITEM



// The   following   two   defines  determine  the  number  of  digits  in  the
// sequence-numbered  name  of  each  catalog  entry key.  The two defines must
// include  the  same  number.   If there is a way to cause the preprocessor to
// derive both a quoted and unquoted character sequence from the same sequence,
// I don't know what it is.
#define SEQUENCE_KEY_DIGITS 12
#define SEQUENCE_KEY_DIGITS_STRING "12"




INT
PROTO_CATALOG_ITEM::InitializeFromRegistry(
    IN  HKEY  ParentKey,
    IN  INT   SequenceNum
    )
/*++

Routine Description:

    This  procedure initializes the protocol info part of the catalog item from
    information  retrieved  from  the  catalog  portion of the registry.  It is
    assumed that the catalog portion is locked against competing I/O attempts.

Arguments:

    ParentKey   - Supplies  an open registry key for the registry entry that is
                  the  parent  of  the registry item defining the catalog item,
                  i.e., the catalog entry list key.

    SequenceNum - Supplies  the  sequence  number  within the entry list of the
                  target registry entry.

Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it returns an
    appropriate WinSock error code.

--*/
{
    char  keyname[SEQUENCE_KEY_DIGITS + 1];
    HKEY  thiskey;
    LONG  result;
    INT   ReturnCode;

    sprintf(keyname, "%0"SEQUENCE_KEY_DIGITS_STRING"i", SequenceNum);
    result = RegOpenKeyEx(
        ParentKey,     // hkey
        keyname,       // lpszSubKey
        0,             // dwReserved
        KEY_READ,      // samDesired
        & thiskey      // phkResult
        );
    if (result != ERROR_SUCCESS) {
        DEBUGF(
            DBG_ERR,
            ("Opening catalog entry key '%s', error = %lu\n",
            keyname,
            result));
        return(WSASYSCALLFAILURE);
    }

    ReturnCode = IoRegistry(
        thiskey,  // EntryKey
        TRUE      // IsRead
        );

    result = RegCloseKey(
        thiskey  // hkey
        );
    if (result != ERROR_SUCCESS) {
        DEBUGF(
            DBG_ERR,
            ("Closing catalog entry, error = %lu\n",
            result));
        return(WSASYSCALLFAILURE);
    }

    return ReturnCode;

}  // InitializeFromRegistry




INT
PROTO_CATALOG_ITEM::InitializeFromValues(
    IN  LPWSTR              LibraryPath,
    IN  LPWSAPROTOCOL_INFOW ProtoInfo
    )
/*++

Routine Description:

    This  procedure initializes the protocol info part of the catalog item from
    the  values  supplied.  Values are copied from the structures passed by the
    caller,  so  the  caller  is  free  to  deallocate the passed structures on
    return.

Arguments:

    LibraryPath  - Supplies    a    reference   to   a   buffer   holding   the
                   zero-terminated,   fully-qualified   path  of  the  provider
                   library that implements this protocol.  The path may include
                   expandable environment references of the form '%variable%'.

    ProviderName - Supplies a reference to a buffer holding the zero-terminated
                   locally unique name of this provider.

    ProtoInfo    - Supplies  a reference to the fully initialized protocol info
                   structure describing this protocol.

return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it returns an
    appropriate WinSock error code.

--*/
{
    size_t  len_needed;
    INT ReturnValue = ERROR_SUCCESS;

    // Copy LibraryPath
    len_needed = lstrlenW(LibraryPath) + 1;
    if (len_needed > sizeof(m_LibraryPath)/sizeof (m_LibraryPath[0])) {
        DEBUGF(
            DBG_ERR,
            ("Library Path Too long (%u) '%ls'\n",
            len_needed,
            LibraryPath));
        return(WSAEINVAL);
    }
    lstrcpyW(
        m_LibraryPath,
        LibraryPath);

    // Copy ProtoInfo
    m_ProtoInfo = *ProtoInfo;

    return (ReturnValue);

}  // InitializeFromValues




PROTO_CATALOG_ITEM::~PROTO_CATALOG_ITEM()
/*++

Routine Description:

    This  procedure  destroys  a  protocol catalog item, deallocating memory it
    owns.   It  is the caller's responsibility to remove the item from the list
    it  occupies  before  calling  this  procedure.   It  is  also the caller's
    responsibility  to unload and/or destroy any dprovider associated with this
    catalog item if appropriate.

Arguments:

    None

Return Value:

    None
--*/
{
    if (m_Provider!=NULL) {
        m_Provider->Dereference ();
        m_Provider = NULL;
    }
    assert(IsListEmpty (&m_CatalogLinkage));
}  // ~PROTO_CATALOG_ITEM





VOID
PROTO_CATALOG_ITEM::SetProvider(
    IN  PDPROVIDER  Provider
    )
/*++

Routine Description:

    This procedure sets the DPROVIDER associated with a catalog entry.

Arguments:

    Provider - Supplies the new DPROVIDER reference.

Return Value:

    None
--*/
{
    assert (m_Provider==NULL);
    Provider->Reference ();
    m_Provider = Provider;
}  // SetProvider



INT
PROTO_CATALOG_ITEM::WriteToRegistry(
    IN  HKEY  ParentKey,
    IN  INT   SequenceNum
    )
/*++

Routine Description:

    This  procedure  writes  the fully-initialized protocol info portion of the
    catalog  entry  out  to the catalog portion of the registry.  It is assumed
    that  the  catalog  portion of the registry is locked against competing I/O
    attempts.

Arguments:

    ParentKey -   Supplies  the  open registry key of the parent registry entry
                  in which this catalog entry will be written as a subkey.

    Sequencenum - Supplies the sequence number of this catalog entry within the
                  entire set of catalog entries.

Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it returns an
    appropriate WINSOCK error code.
--*/
{
    char  keyname[SEQUENCE_KEY_DIGITS + 1];
    HKEY  thiskey;
    LONG  result;
    INT   ReturnCode;
    DWORD key_disposition;


    sprintf(keyname, "%0"SEQUENCE_KEY_DIGITS_STRING"i", SequenceNum);
    result = RegCreateKeyEx(
        ParentKey,                // hkey
        keyname,                  // lpszSubKey
        0,                        // dwReserved
        NULL,                     // lpszClass
        REG_OPTION_NON_VOLATILE,  // fdwOptions
        KEY_READ|KEY_WRITE,        // samDesired
        NULL,                     // lpSecurityAttributes
        & thiskey,                // phkResult
        & key_disposition         // lpdwDisposition
        );
    if (result != ERROR_SUCCESS) {
        DEBUGF(
            DBG_ERR,
            ("Creating catalog entry key %s (%lu)\n",
            keyname, result));
        return(WSASYSCALLFAILURE);
    }
    if (key_disposition == REG_OPENED_EXISTING_KEY) {
        DEBUGF(
            DBG_WARN,
            ("Overwriting a catalog entry key '%s'\n",
            keyname));
    }

    ReturnCode = IoRegistry(
        thiskey,  // EntryKey
        FALSE     // IsRead
        );

    result = RegCloseKey(
        thiskey  // hkey
        );
    if (result != ERROR_SUCCESS) {
        DEBUGF(
            DBG_ERR,
            ("Closing catalog entry key %s, error = %lu\n",
            keyname, result));
        return(WSASYSCALLFAILURE);
    }

    return ReturnCode;

}  // WriteToRegistry



// The following typedef is used in packing and unpacking catalog item data for
// reading and writing in the registry.

typedef struct {
    char            LibraryPath[MAX_PATH];
        // The unexpanded path where the provider DLL is found.

    WSAPROTOCOL_INFOW   ProtoInfo;
        // The  protocol information.  Note that if the WSAPROTOCOL_INFOW structure
        // is  ever changed to a non-flat structure (i.e., containing pointers)
        // then  this  type  definition  will  have  to  be changed, since this
        // structure must be strictly flat.
} PACKED_CAT_ITEM;

typedef PACKED_CAT_ITEM * PPACKED_CAT_ITEM;


#define PACKED_ITEM_NAME "PackedCatalogItem"



INT
PROTO_CATALOG_ITEM::IoRegistry(
    IN  HKEY  EntryKey,
    IN  BOOL  IsRead)
/*++

Routine Description:

    This  procedure  performs  the  actual  input  or  output  of catalog entry
    information  from  or  to  the  registry.   It  is assumed that the catalog
    portion of the registry is locked against competing I/O attempts.

Arguments:

    EntryKey - Supplies  the open registry key where the catalog entry is to be
               read or written.

    IsRead   - Supplies  a  BOOL  determining  disposition.  TRUE indicates the
               entry  is  to  be  read  into  memory  from the registry.  FALSE
               indicates  the  entry  is  to  be written out from memory to the
               registry.

Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it returns an
    appropriate WINSOCK error code.

Implementation Notes:

    An  early  implementation represented the catalog item as a single registry
    key  with multiple named values.  Each named value corresponded to a single
    member  variable  of  the  catalog  entry  or  field  of  the protocol info
    structure.   Thus each catalog item consisted of about 20 named values in a
    registry key.  Unfortunately, the registry has very poor performance for so
    many values.

    Therefore  the  implementation  has been changed to pack the entire catalog
    item  into  a single REG_BINARY value.  Each catalog item then has a single
    key  with  a  single  large  REG_BINARY value.  This mitigates the registry
    performance problem.
--*/
{
    DWORD             packed_size;
    PPACKED_CAT_ITEM  packed_buf = NULL;
    INT               return_value;

    return_value = ERROR_SUCCESS;


    TRY_START(guard_memalloc) {
        // Determine required size of packed structure
        if (IsRead) {
            LONG lresult;

            lresult = RegQueryValueEx(
                EntryKey,          // hkey
                PACKED_ITEM_NAME,  // lpszValueName
                0,                 // lpdwReserved
                NULL,              // lpdwType
                NULL,              // lpbData
                & packed_size      // lpcbData
                );
            if (lresult != ERROR_SUCCESS || packed_size<sizeof (PACKED_CAT_ITEM)) {
                DEBUGF(
                    DBG_ERR,
                    ("Querying length of %s entry\n", PACKED_ITEM_NAME));
                return_value = WSASYSCALLFAILURE;
                TRY_THROW(guard_memalloc);
            }
        } // if IsRead
        else { // not IsRead
            packed_size = sizeof(PACKED_CAT_ITEM);
        } // else not IsRead


        // Allocate memory for packed structure
        packed_buf = (PPACKED_CAT_ITEM) new char[packed_size];
        if (packed_buf == NULL) {
            DEBUGF(
                DBG_ERR,
                ("Allocating space for packed entry\n"));
            return_value = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(guard_memalloc);
        }


        // If writing, then initialize the packed structure
        if (! IsRead) {
            if (WideCharToMultiByte(
                    CP_ACP,
                    0,
                    m_LibraryPath,
                    -1,
                    packed_buf->LibraryPath,
                    sizeof (packed_buf->LibraryPath),
                    NULL, NULL)<=0) {
                return_value = WSASYSCALLFAILURE;
                TRY_THROW(guard_memalloc);
            }
            packed_buf->ProtoInfo = m_ProtoInfo;
        } // if ! IsRead


        // Read or write the structure
        { // declaration block
            BOOL io_result;
            WSABUF  io_descr;

            io_descr.len = packed_size;
            io_descr.buf = (char FAR *) packed_buf;
            if (IsRead) {
                io_result = ReadRegistryEntry(
                    EntryKey,             // EntryKey
                    PACKED_ITEM_NAME,     // EntryName
                    (PVOID) & io_descr,   // Data
                    packed_size,          // MaxBytes
                    REG_BINARY            // TypeFlag
                    );
            } // if IsRead
            else { // not IsRead
                io_result = WriteRegistryEntry(
                    EntryKey,             // EntryKey
                    PACKED_ITEM_NAME,     // EntryName
                    (PVOID) & io_descr,   // Data
                    REG_BINARY            // TypeFlag
                    );
            } // else not IsRead
            if (! io_result) {
                DEBUGF(
                    DBG_ERR,
                    ("%s registry entry\n",
                    IsRead ? "reading" : "writing"));
                return_value = WSASYSCALLFAILURE;
                TRY_THROW(guard_memalloc);
            }
            if (io_descr.len != packed_size) {
                DEBUGF(
                    DBG_ERR,
                    ("Registry entry size expected (%lu), got (%lu)\n",
                    packed_size,
                    io_descr.len));
                return_value = WSASYSCALLFAILURE;
                TRY_THROW(guard_memalloc);
            }
        } // declaration block


        // If reading, extract data from the packed structure
        if (IsRead) {
            if (MultiByteToWideChar (
                    CP_ACP,
                    MB_ERR_INVALID_CHARS,
                    packed_buf->LibraryPath,
                    -1,
                    m_LibraryPath,
                    sizeof (m_LibraryPath)/sizeof (m_LibraryPath[0]))<=0) {
                return_value = WSASYSCALLFAILURE;
                TRY_THROW(guard_memalloc);
            }
            m_ProtoInfo = packed_buf->ProtoInfo;
        } // if IsRead


        // deallocate the packed structure
        delete packed_buf;

    } TRY_CATCH(guard_memalloc) {
        if (return_value == ERROR_SUCCESS) {
            return_value = WSASYSCALLFAILURE;
        }
        if (packed_buf!=NULL)
            delete packed_buf;
    } TRY_END(guard_memalloc);

    return(return_value);

}  // IoRegistry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\dllmain.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    dllmain.cpp

Abstract:
    This module contains the DllMain entry point for winsock2 dll to
    control the global init and shutdown of the DLL.

Author:

    Dirk Brandewie dirk@mink.intel.com  14-06-1995

[Environment:]

[Notes:]

Revision History:

    22-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Moved includes to precomp.h

--*/

#include "precomp.h"

#if defined(DEBUG_TRACING)
#include "dthook.h"
#endif // defined(DEBUG_TRACING)

DWORD gdwTlsIndex = TLS_OUT_OF_INDEXES;
HINSTANCE gDllHandle = NULL;


BOOL WINAPI DllMain(
    IN HINSTANCE hinstDll,
    IN DWORD fdwReason,
    LPVOID lpvReserved
    )
{
    switch (fdwReason) {

    case DLL_PROCESS_ATTACH:
        // DLL is attaching to the address
        // space of the current process.

        // Save DLL handle
        gDllHandle = hinstDll;

        gdwTlsIndex = TlsAlloc();
        if (gdwTlsIndex==TLS_OUT_OF_INDEXES) {
            return FALSE;
        }

        // Use private heap on MP machines to
        // avoid lock contention with other DLLs
        {
            SYSTEM_INFO sysInfo;
            GetSystemInfo (&sysInfo);

            if (sysInfo.dwNumberOfProcessors>1) {
                gHeap = HeapCreate (0, 0, 0);
                if (gHeap==NULL) {
                    gHeap = GetProcessHeap ();
                }
            }
            else
                gHeap = GetProcessHeap ();
        }


        {
            BOOLEAN startup = FALSE
#ifdef RASAUTODIAL
                    , autodial = FALSE
#endif
#if defined(DEBUG_TRACING)
                    , dthook = FALSE
#endif // defined(DEBUG_TRACING)
                    ;

                    

            __try {
                CreateStartupSynchronization();
                startup = TRUE;
#ifdef RASAUTODIAL
                InitializeAutodial();
                autodial = TRUE;
#endif // RASAUTODIAL

#if defined(DEBUG_TRACING)
                DTHookInitialize();
                dthook = TRUE;
#endif // defined(DEBUG_TRACING)

            }
            __except (WS2_EXCEPTION_FILTER ()) {
                goto cleanup;
            }
            if (!SockAsyncGlobalInitialize())
                goto cleanup;
            break;

        cleanup:
#if defined(DEBUG_TRACING)
            if (dthook) {
                DTHookShutdown();
            }
#endif // defined(DEBUG_TRACING)
#ifdef RASAUTODIAL
            if (autodial) {
                UninitializeAutodial();
            }
#endif // RASAUTODIAL
            if (startup) {
                DestroyStartupSynchronization();
            }

            TlsFree (gdwTlsIndex);
            gdwTlsIndex = TLS_OUT_OF_INDEXES;
            gDllHandle = NULL;

            return FALSE;
        }

   case DLL_THREAD_ATTACH:
        // A new thread is being created in the current process.
        break;

   case DLL_THREAD_DETACH:
        // A thread is exiting cleanly.
        DTHREAD::DestroyCurrentThread();
        break;

   case DLL_PROCESS_DETACH:
        //
        // Check if we were initialized.
        //
        if (gDllHandle==NULL)
            break;

        // The calling process is detaching
        // the DLL from its address space.
        //
        // Note that lpvReserved will be NULL if the detach is due to
        // a FreeLibrary() call, and non-NULL if the detach is due to
        // process cleanup.
        //

        if( lpvReserved == NULL ) {
            PDPROCESS  CurrentProcess;

            // A thread is exiting cleanly (if we do not get a separate 
            // DLL_THREAD_DETACH).
            DTHREAD::DestroyCurrentThread();

            CurrentProcess = DPROCESS::GetCurrentDProcess();
            if (CurrentProcess!=NULL) {
                delete CurrentProcess;
            }

            DTHREAD::DThreadClassCleanup();
            DSOCKET::DSocketClassCleanup();
            SockAsyncGlobalTerminate();
            DestroyStartupSynchronization();
            if ((gHeap!=NULL) && (gHeap!=GetProcessHeap ())) {
                HeapDestroy (gHeap);
            }
            TlsFree (gdwTlsIndex);

#ifdef RASAUTODIAL
            UninitializeAutodial();
#endif // RASAUTODIAL
#if defined(DEBUG_TRACING)
            DTHookShutdown();
            TraceCleanup ();
#endif // defined(DEBUG_TRACING)

        }

        //
        // Set the function prolog pointer to point to Prolog_Detached just
        // in case some DLL trys to invoke one of our entrypoints
        // *after* we've been detached...
        //

        PrologPointer = &Prolog_Detached;

        gDllHandle = NULL;
        break;
    }


    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\dcatalog.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    dcatalog.cpp

Abstract:

    This module contains the implementation of the dcatalog class.

Author:

    Dirk Brandewie dirk@mink.intel.com  25-JUL-1995

Revision History:

    23-Aug-1995 dirk@mink.intel.com
        Moved includes into precomp.h.

    27-Jan-1998 vadime@miscrosoft.com
        Implemented dynamic catalog

--*/

#include "precomp.h"

#define CATALOG_NAME            "Protocol_Catalog9"
#define NEXT_CATALOG_ENTRY_NAME "Next_Catalog_Entry_ID"
#ifdef _WIN64
#define CATALOG_ENTRIES_NAME    "Catalog_Entries64"
#define NUM_ENTRIES_NAME        "Num_Catalog_Entries64"
#define CATALOG_ENTRIES_NAME32  "Catalog_Entries"
#define NUM_ENTRIES_NAME32      "Num_Catalog_Entries"
LPCSTR DCATALOG::sm_entries_name32 = CATALOG_ENTRIES_NAME32;
#else
#define CATALOG_ENTRIES_NAME    "Catalog_Entries"
#define NUM_ENTRIES_NAME        "Num_Catalog_Entries"
#endif

#define FIRST_SERIAL_NUMBER 1
    // The first access serial number to be assigned on a given system.
#define FIRST_CATALOG_ENTRY_ID 1001
    // The first catalog entry ID to be assigned on a given system.




DCATALOG::DCATALOG()
/*++

Routine Description:

    Destructor for the DCATALOG object.

Arguments:

    NONE.

Return Value:

    NONE.

--*/
{
    // Initialize members
    m_num_items = 0;
    m_reg_key = NULL;
    m_serial_num = FIRST_SERIAL_NUMBER-1;
    m_next_id = FIRST_CATALOG_ENTRY_ID-1;
    m_protocol_list.Flink = NULL;
#ifdef _WIN64
    m_items32 = NULL;
    assert (m_entries_name32==NULL); // Part of the union.
#endif
}




BOOL
DCATALOG::OpenCatalog(
    IN  HKEY   ParentKey
    )
/*++

Routine Description:

    This  procedure  opens the catalog portion of the registry.  If the catalog
    is  not  yet  present,  it  also  initializes  new  first-level  values and
    first-level  subkeys  for  the  catalog.  It is assumed that the catalog is
    locked against competing registry I/O attempts.

Arguments:

    ParentKey  - Supplies  the open registry key representing the parent key of
                 the catalog.

Return Value:

    The function returns TRUE if successful, otherwise it returns FALSE.

--*/
{
    LONG   lresult;
    HKEY   new_key;
    DWORD  key_disposition;

    assert(ParentKey != NULL);

    assert (m_protocol_list.Flink == NULL);
    __try {
        InitializeCriticalSection(&m_catalog_lock);
    }
    __except (WS2_EXCEPTION_FILTER ()) {
        return FALSE;
    }
    InitializeListHead (&m_protocol_list);

    //
    // We must first try to open the key before trying to create it.
    // RegCreateKeyEx() will fail with ERROR_ACCESS_DENIED if the current
    // user has insufficient privilege to create the target registry key,
    // even if that key already exists.
    //

    lresult = RegOpenKeyEx(
        ParentKey,                              // hkey
        DCATALOG::GetCurrentCatalogName(),      // lpszSubKey
        0,                                      // dwReserved
        MAXIMUM_ALLOWED,                        // samDesired
        & new_key                               // phkResult
        );

    if( lresult == ERROR_SUCCESS ) {
        key_disposition = REG_OPENED_EXISTING_KEY;

    } else if( lresult != ERROR_FILE_NOT_FOUND ||
                (lresult = RegCreateKeyEx(
                    ParentKey,                          // hkey
                    DCATALOG::GetCurrentCatalogName(),  // lpszSubKey
                    0,                                  // dwReserved
                    NULL,                               // lpszClass
                    REG_OPTION_NON_VOLATILE,            // fdwOptions
                    KEY_READ|KEY_WRITE,                 // samDesired
                    NULL,                               // lpSecurityAttributes
                    & new_key,                          // phkResult
                    & key_disposition                   // lpdwDisposition
                    )) != ERROR_SUCCESS) {
        DEBUGF (DBG_ERR,
            ("Opening/Creating catalog key %s (%ld)\n",
                DCATALOG::GetCurrentCatalogName(), lresult));
        return FALSE;
    }

    TRY_START(guard_open) {
        BOOL	bresult;
        DWORD	dwData;
		if (key_disposition == REG_CREATED_NEW_KEY) {
            HKEY	entries_key;
            DWORD	dont_care;

			DEBUGF(
				DBG_TRACE,
				("Creating empty catalog in registry.\n"));

            dwData = 0;
            bresult = WriteRegistryEntry(
                new_key,           // EntryKey
                NUM_ENTRIES_NAME,  // EntryName
                (PVOID) & dwData,  // Data
                REG_DWORD          // TypeFlag
                );
            if (! bresult) {
                DEBUGF(
                    DBG_ERR,
                    ("Writing %s\n", NUM_ENTRIES_NAME));
                TRY_THROW(guard_open);
            }

#ifdef _WIN64
            bresult = WriteRegistryEntry(
                new_key,           // EntryKey
                NUM_ENTRIES_NAME32,// EntryName
                (PVOID) & dwData,  // Data
                REG_DWORD          // TypeFlag
                );
            if (! bresult) {
                DEBUGF(
                    DBG_ERR,
                    ("Writing %s\n", NUM_ENTRIES_NAME32));
                TRY_THROW(guard_open);
            }
#endif

            dwData = FIRST_CATALOG_ENTRY_ID;
            bresult = WriteRegistryEntry(
                new_key,                  // EntryKey
                NEXT_CATALOG_ENTRY_NAME,  // EntryName
                (PVOID) & dwData,         // Data
                REG_DWORD                 // TypeFlag
                );
            if (! bresult) {
                DEBUGF(
                    DBG_ERR,
                    ("Writing %s\n",
                    NEXT_CATALOG_ENTRY_NAME));
                TRY_THROW(guard_open);
            }

            dwData = FIRST_SERIAL_NUMBER;
            bresult = WriteRegistryEntry(
                new_key,                  // EntryKey
                SERIAL_NUMBER_NAME,       // EntryName
                (PVOID) & dwData,         // Data
                REG_DWORD                 // TypeFlag
                );
            if (! bresult) {
                DEBUGF(
                    DBG_ERR,
                    ("Writing %s\n",
                    SERIAL_NUMBER_NAME));
                TRY_THROW(guard_open);
            }

            lresult = RegCreateKeyEx(
                new_key,                  // hkey
                CATALOG_ENTRIES_NAME,     // lpszSubKey
                0,                        // dwReserved
                NULL,                     // lpszClass
                REG_OPTION_NON_VOLATILE,  // fdwOptions
                KEY_READ|KEY_WRITE,       // samDesired
                NULL,                     // lpSecurityAttributes
                & entries_key,            // phkResult
                & dont_care               // lpdwDisposition
                );
            if (lresult != ERROR_SUCCESS) {
                DEBUGF(
                    DBG_ERR,
                    ("Creating entries subkey %s\n",
                    CATALOG_ENTRIES_NAME));
                TRY_THROW(guard_open);
            }
            lresult = RegCloseKey(
                entries_key  // hkey
                );
            if (lresult != ERROR_SUCCESS) {
                DEBUGF(
                    DBG_ERR,
                    ("Closing entries subkey %s\n", CATALOG_ENTRIES_NAME));
                TRY_THROW(guard_open);
            }

#ifdef _WIN64
            lresult = RegCreateKeyEx(
                new_key,                  // hkey
                CATALOG_ENTRIES_NAME32,   // lpszSubKey
                0,                        // dwReserved
                NULL,                     // lpszClass
                REG_OPTION_NON_VOLATILE,  // fdwOptions
                KEY_READ|KEY_WRITE,       // samDesired
                NULL,                     // lpSecurityAttributes
                & entries_key,            // phkResult
                & dont_care               // lpdwDisposition
                );
            if (lresult != ERROR_SUCCESS) {
                DEBUGF(
                    DBG_ERR,
                    ("Creating entries subkey %s\n",
                    CATALOG_ENTRIES_NAME32));
                TRY_THROW(guard_open);
            }
            lresult = RegCloseKey(
                entries_key  // hkey
                );
            if (lresult != ERROR_SUCCESS) {
                DEBUGF(
                    DBG_ERR,
                    ("Closing entries subkey %s\n", CATALOG_ENTRIES_NAME32));
                TRY_THROW(guard_open);
            }
#endif

        }  // if REG_CREATED_NEW_KEY
        else {
            bresult = ReadRegistryEntry (
                        new_key,                // EntryKey
                        SERIAL_NUMBER_NAME,     // EntryName
                        (PVOID) &dwData,		// Data
                        sizeof (DWORD),         // MaxBytes
                        REG_DWORD               // TypeFlag
                        );
            if (!bresult) {
                // This must be the first time this version of ws2_32.dll
                // is being run.  We need to update catalog to have this
                // new entry or fail initialization.
            
			    dwData = FIRST_SERIAL_NUMBER;
                bresult = WriteRegistryEntry (
                            new_key,                // EntryKey
                            SERIAL_NUMBER_NAME,     // EntryName
                            (PVOID) &dwData,		// Data
                            REG_DWORD               // TypeFlag
                            );
                if (!bresult) {
                    DEBUGF (DBG_ERR,
                        ("Writing %s value.\n", SERIAL_NUMBER_NAME));
				    TRY_THROW (guard_open);
			    }
            }
        } // else

		m_reg_key = new_key;
		return TRUE;

    } TRY_CATCH(guard_open) {
        LONG close_result;

        close_result = RegCloseKey(
            new_key  // hkey
            );
        if (close_result != ERROR_SUCCESS) {
            DEBUGF(
                DBG_ERR,
                ("Closing catalog key %s, err: %ld\n",
                DCATALOG::GetCurrentCatalogName(), close_result));
        }

        return FALSE;
    } TRY_END(guard_open);


}  // OpenCatalog


#ifdef _WIN64
INT
DCATALOG::InitializeFromRegistry64_32(
    IN  HKEY    ParentKey
    )
/*++

Routine Description:

    This  procedure takes care of initializing a newly-created protocol catalog
    from  the  registry.  If the registry does not currently contain a protocol
    catalog,  an  empty catalog is created and the registry is initialized with
    the new empty catalog.

Arguments:

    ParentKey - Supplies  an  open registry key under which the catalog is read
                or  created  as  a  subkey.   The  key may be closed after this
                procedure returns.
    ChangeEvent - if event handle is specified it is associated with changes to
                the catalog.

Return Value:

    The  function  returns  ERROR_SUCESS if successful, otherwise it returns an
    appropriate WinSock error code.

Implementation Notes:

    lock the catalog
    open catalog, creating empty if required
    read the catalog
    unlock the catalog
--*/
{
    INT return_value;
    BOOL bresult;

    assert(ParentKey != NULL);
    assert(m_reg_key==NULL);


    bresult = OpenCatalog(
        ParentKey
        );
    // Opening  the catalog has the side-effect of creating an empty catalog if
    // needed.
    if (bresult) {
        m_items32 = new DCATALOG_ITEMS;
        if (m_items32!=NULL) {
            assert (m_entries_name32!=sm_entries_name32); // Part of the union
            m_items32->m_num_items = 0;
            InitializeListHead (&m_items32->m_protocol_list);
            return_value =  RefreshFromRegistry (NULL);
        }
        else {
            DEBUGF(
                DBG_ERR,
                ("Allocating 32bit item list\n"));
            return_value = WSA_NOT_ENOUGH_MEMORY;
            return return_value;
        }
    }
    else {
        return_value = WSASYSCALLFAILURE;
    }
    return return_value;

}  // InitializeFromRegistry64_32

INT
DCATALOG::InitializeFromRegistry32(
    IN  HKEY    ParentKey
    )
/*++

Routine Description:

    This  procedure takes care of initializing a newly-created protocol catalog
    from  the  registry.  If the registry does not currently contain a protocol
    catalog,  an  empty catalog is created and the registry is initialized with
    the new empty catalog.

Arguments:

    ParentKey - Supplies  an  open registry key under which the catalog is read
                or  created  as  a  subkey.   The  key may be closed after this
                procedure returns.
    ChangeEvent - if event handle is specified it is associated with changes to
                the catalog.

Return Value:

    The  function  returns  ERROR_SUCESS if successful, otherwise it returns an
    appropriate WinSock error code.

Implementation Notes:

    lock the catalog
    open catalog, creating empty if required
    read the catalog
    unlock the catalog
--*/
{
    INT return_value;
    BOOL bresult;

    assert(ParentKey != NULL);
    assert(m_reg_key==NULL);


    bresult = OpenCatalog(
        ParentKey
        );
    // Opening  the catalog has the side-effect of creating an empty catalog if
    // needed.
    if (bresult) {
        m_entries_name32 = sm_entries_name32;
        return_value =  RefreshFromRegistry (NULL);
    }
    else {
        return_value = WSASYSCALLFAILURE;
    }
    return return_value;

}  // InitializeFromRegistry64
#endif


INT
DCATALOG::InitializeFromRegistry(
    IN  HKEY    ParentKey,
    IN  HANDLE  ChangeEvent OPTIONAL
    )
/*++

Routine Description:

    This  procedure takes care of initializing a newly-created protocol catalog
    from  the  registry.  If the registry does not currently contain a protocol
    catalog,  an  empty catalog is created and the registry is initialized with
    the new empty catalog.

Arguments:

    ParentKey - Supplies  an  open registry key under which the catalog is read
                or  created  as  a  subkey.   The  key may be closed after this
                procedure returns.
    ChangeEvent - if event handle is specified it is associated with changes to
                the catalog.

Return Value:

    The  function  returns  ERROR_SUCESS if successful, otherwise it returns an
    appropriate WinSock error code.

Implementation Notes:

    lock the catalog
    open catalog, creating empty if required
    read the catalog
    unlock the catalog
--*/
{
    INT return_value;
    BOOL bresult;

    assert(ParentKey != NULL);
    assert(m_reg_key==NULL);


    bresult = OpenCatalog(
        ParentKey
        );
    // Opening  the catalog has the side-effect of creating an empty catalog if
    // needed.
    if (bresult) {
        return_value =  RefreshFromRegistry (ChangeEvent);
    }
    else {
        return_value = WSASYSCALLFAILURE;
    }
    return return_value;

}  // InitializeFromRegistry


INT
DCATALOG::RefreshFromRegistry(
    IN  HANDLE  ChangeEvent OPTIONAL
    )
/*++

Routine Description:

    This  procedure takes care of initializing a newly-created protocol catalog
    from  the  registry.  If the registry does not currently contain a protocol
    catalog,  an  empty catalog is created and the registry is initialized with
    the new empty catalog.

Arguments:

    ChangeEvent - if event handle is specified it is associated with changes to
                the catalog.

Return Value:

    The  function  returns  ERROR_SUCESS if successful, otherwise it returns an
    appropriate WinSock error code.

Implementation Notes:

    lock the catalog
    do
		establish event notification for any registry catalog modifications
		RegOpenKey(... entries, entries_key)
		ReadRegistryEntry(... next_id)
		ReadRegistryEntry(... num_items)
		for i in (1 .. num_items)
			item = new catalog item
			item->InitializeFromRegistry(entries_key, i)
			add item to temp list
		end for
		RegCloseKey(... entries_key)
    while registry catalog has changed during read.
    update the catalog
    unlock the catalog

--*/
{
    INT			return_value;
    BOOLEAN		created_event = FALSE;
    DWORD       serial_num;
	LONG        lresult;
	HKEY        entries_key;
	LIST_ENTRY  temp_list;
	PPROTO_CATALOG_ITEM  item;
	DWORD       num_entries, next_id;
    BOOL        catalog_changed = TRUE;
#ifdef _WIN64
    LIST_ENTRY  temp_list32;
	DWORD       num_entries32;
    BOOLEAN     saveCatalog64 = FALSE;
#ifdef DEBUG_TRACING
                WS2_32_W4_INIT  num_entries32 = 0;
#endif
#endif

    //
    // Create the event if caller did not provide one
    //
    if (ChangeEvent==NULL) {
        ChangeEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
        if (ChangeEvent==NULL) {
            return WSASYSCALLFAILURE;
        }
        created_event = TRUE;
    }

    // Lock this catalog object
    AcquireCatalogLock ();

    assert(m_reg_key != NULL);

	// Initialize locals to known defaults
	InitializeListHead (&temp_list);

#ifdef _WIN64
	InitializeListHead (&temp_list32);
#endif

    do {
    	BOOL        bresult;
        // Synchronize with writers
        return_value = SynchronizeSharedCatalogAccess (
								m_reg_key,
								ChangeEvent,
								&serial_num);
        if (return_value != ERROR_SUCCESS) {
            // Non-recoverable
            break;
        }

        // Check if catalog has changed.
        if (m_serial_num == serial_num) {
            return_value = ERROR_SUCCESS;
            break;
        }

		// Read id of next catalog entry
		bresult = ReadRegistryEntry(
			m_reg_key,              // EntryKey
			NEXT_CATALOG_ENTRY_NAME,// EntryName
			(PVOID) & next_id,      // Data
			sizeof(DWORD),          // MaxBytes
			REG_DWORD               // TypeFlag
			);

		if (! bresult) {
			DEBUGF(
				DBG_ERR,
				("Reading %s from registry\n",
				NUM_ENTRIES_NAME));
            return_value = WSASYSCALLFAILURE;
            break;
		}

		// read number of items in the catalog
		bresult = ReadRegistryEntry(
			m_reg_key,              // EntryKey
#ifdef _WIN64
            m_entries_name32==sm_entries_name32
                ? NUM_ENTRIES_NAME32 :
#endif
			NUM_ENTRIES_NAME,       // EntryName
			(PVOID) & num_entries,  // Data
			sizeof(DWORD),          // MaxBytes
			REG_DWORD               // TypeFlag
			);

#ifdef _WIN64
        if (! bresult  &&
            m_entries_name32!=sm_entries_name32) {
            //
            // We may be upgrading 64 bit installation with
            // only one catalog (prior to catalog separation
            // being implemented on WIN64).
            // Read 32 bit catalog instead and remeber to save
            // it as 64 bit catalog.
            //
            DEBUGF(
				DBG_ERR,
				("Reading %s from registry, trying %s...\n",
				NUM_ENTRIES_NAME, NUM_ENTRIES_NAME32));            
            saveCatalog64 = TRUE;
		    bresult = ReadRegistryEntry(
			    m_reg_key,              // EntryKey
			    NUM_ENTRIES_NAME32,     // EntryName
			    (PVOID) & num_entries,  // Data
			    sizeof(DWORD),          // MaxBytes
			    REG_DWORD               // TypeFlag
			    );
        }
#endif

		if (! bresult) {
			DEBUGF(
				DBG_ERR,
				("Reading %s from registry\n",
				NUM_ENTRIES_NAME));
            return_value = WSASYSCALLFAILURE;
			break;
		}

		// Open entry key
		lresult = RegOpenKeyEx(
			m_reg_key,             // hkey
#ifdef _WIN64
            m_entries_name32==sm_entries_name32
                ? CATALOG_ENTRIES_NAME32 :
#endif
			CATALOG_ENTRIES_NAME,  // lpszSubKey
			0,                     // dwReserved
			MAXIMUM_ALLOWED,       // samDesired
			& entries_key          // phkResult
			);

#ifdef _WIN64
        if (lresult == ERROR_FILE_NOT_FOUND &&
                m_entries_name32!=sm_entries_name32) {
            //
            // We may be upgrading 64 bit installation with
            // only one catalog (prior to catalog separation
            // being implemented on WIN64).
            // Read 32 bit catalog instead and remeber to save
            // it as 64 bit catalog.
            //
			DEBUGF(
				DBG_ERR,
				("Opening protocol entries key of registry, trying entries32...\n"));
            saveCatalog64 = TRUE;
		    lresult = RegOpenKeyEx(
			    m_reg_key,             // hkey
			    CATALOG_ENTRIES_NAME32,// lpszSubKey
			    0,                     // dwReserved
			    MAXIMUM_ALLOWED,       // samDesired
			    & entries_key          // phkResult
			    );
        }
#endif
        if (lresult != ERROR_SUCCESS) {
            // Non-recoverable
			DEBUGF(
				DBG_ERR,
				("Opening entries key of registry\n"));
			return_value = WSASYSCALLFAILURE;
            break;
        }

		TRY_START(guard_open) {
			DWORD                seq_num;

            assert (IsListEmpty (&temp_list));
			// read the items and place on temp list
			for (seq_num = 1; seq_num <= num_entries; seq_num++) {
				item = new PROTO_CATALOG_ITEM();
				if (item == NULL) {
					return_value = WSA_NOT_ENOUGH_MEMORY;
					DEBUGF(
						DBG_ERR,
						("Allocating new proto catalog item\n"));
					TRY_THROW(guard_open);
				}
				return_value = item->InitializeFromRegistry(
					entries_key,  // ParentKey
					(INT)seq_num  // SequenceNum
					);
				if (return_value != ERROR_SUCCESS) {
    				item->Dereference ();
					DEBUGF(
						DBG_ERR,
						("Initializing new proto catalog item\n"));
					TRY_THROW(guard_open);
				}
				InsertTailList (&temp_list, &item->m_CatalogLinkage);
			}  // for seq_num


#ifdef _WIN64
            if (m_items32!=NULL && m_entries_name32!=sm_entries_name32) {
                HKEY    entries_key32;

			    // read number of items in the catalog
			    bresult = ReadRegistryEntry(
				    m_reg_key,              // EntryKey
				    NUM_ENTRIES_NAME32,     // EntryName
				    (PVOID) & num_entries32,// Data
				    sizeof(DWORD),          // MaxBytes
				    REG_DWORD               // TypeFlag
				    );
			    if (! bresult) {
				    DEBUGF(
					    DBG_ERR,
					    ("Reading %s from registry\n",
					    NUM_ENTRIES_NAME32));
                    return_value = WSASYSCALLFAILURE;
				    TRY_THROW(guard_open);
			    }

		        // Open entry key
		        lresult = RegOpenKeyEx(
			        m_reg_key,             // hkey
			        CATALOG_ENTRIES_NAME32,// lpszSubKey
			        0,                     // dwReserved
			        MAXIMUM_ALLOWED,       // samDesired
			        & entries_key32        // phkResult
			        );

                if (lresult != ERROR_SUCCESS) {
                    // Non-recoverable
			        DEBUGF(
				        DBG_ERR,
				        ("Opening entries key of registry\n"));
			        return_value = WSASYSCALLFAILURE;
				    TRY_THROW(guard_open);
                }

        		TRY_START(guard_open32) {
                    assert (IsListEmpty (&temp_list32));
			        // read the items and place on temp list
			        for (seq_num = 1; seq_num <= num_entries32; seq_num++) {
				        item = new PROTO_CATALOG_ITEM();
				        if (item == NULL) {
					        return_value = WSA_NOT_ENOUGH_MEMORY;
					        DEBUGF(
						        DBG_ERR,
						        ("Allocating new proto catalog item\n"));
					        TRY_THROW(guard_open32);
				        }
				        return_value = item->InitializeFromRegistry(
					        entries_key,  // ParentKey
					        (INT)seq_num  // SequenceNum
					        );
				        if (return_value != ERROR_SUCCESS) {
    				        item->Dereference ();
					        DEBUGF(
						        DBG_ERR,
						        ("Initializing new proto catalog item\n"));
					        TRY_THROW(guard_open32);
				        }
				        InsertTailList (&temp_list32, &item->m_CatalogLinkage);
			        }  // for seq_num
                }
                TRY_CATCH(guard_open32) {
                    assert (return_value!=ERROR_SUCCESS);
		        } TRY_END(guard_open32);

                // close catalog
		        lresult = RegCloseKey(
			        entries_key32  // hkey
			        );
		        if (lresult != ERROR_SUCCESS) {
			        DEBUGF(
				        DBG_ERR,
				        ("Closing entries key of registry\n"));
			        // non-fatal
		        }
            }
#endif
        }
        TRY_CATCH(guard_open) {
            assert (return_value!=ERROR_SUCCESS);
		} TRY_END(guard_open);

        // close catalog
		lresult = RegCloseKey(
			entries_key  // hkey
			);
		if (lresult != ERROR_SUCCESS) {
			DEBUGF(
				DBG_ERR,
				("Closing entries key of registry\n"));
			// non-fatal
		}

        //
        // Check if catalog has changed while we were reading it
        // If so, we'll have to retry even though we succeeded
        // in reading it to ensure consistent view of the whole
        // catalog.
        //

        catalog_changed = HasCatalogChanged (ChangeEvent);
        
        if ((return_value==ERROR_SUCCESS) && !catalog_changed) {
            UpdateProtocolList (&temp_list);
#ifdef _WIN64
            if (m_items32!=NULL && m_entries_name32!=sm_entries_name32) {
                m_items32->UpdateProtocolList (&temp_list32);
	            assert (m_items32->m_num_items == num_entries32);
            }
#endif
	        
            // Store new catalog parameters
	        assert (m_num_items == num_entries);
	        m_next_id = next_id;
            m_serial_num = serial_num;

            break;
        }
            
        //
        // Free the entries we might have read
        //

        while (!IsListEmpty (&temp_list)) {
        	PLIST_ENTRY     list_member;
			list_member = RemoveHeadList (&temp_list);
			item = CONTAINING_RECORD (list_member,
										PROTO_CATALOG_ITEM,
										m_CatalogLinkage);
#if defined(DEBUG_TRACING)
            InitializeListHead (&item->m_CatalogLinkage);
#endif
			item->Dereference ();
		}
#ifdef _WIN64
        if (m_items32!=NULL && m_entries_name32!=sm_entries_name32) {
            while (!IsListEmpty (&temp_list32)) {
        	    PLIST_ENTRY     list_member;
			    list_member = RemoveHeadList (&temp_list32);
			    item = CONTAINING_RECORD (list_member,
										PROTO_CATALOG_ITEM,
										m_CatalogLinkage);
#if defined(DEBUG_TRACING)
                InitializeListHead (&item->m_CatalogLinkage);
#endif
			    item->Dereference ();
    		}
        }
        else {
            assert (IsListEmpty (&temp_list32));
        }
#endif
    }
    while (catalog_changed); // Retry while catalog is being written over

    //
    // We should have freed or consumed all the items we
    // might have read.
    //
    assert (IsListEmpty (&temp_list));

#ifdef _WIN64
    if (saveCatalog64 && return_value==ERROR_SUCCESS) {
		DEBUGF(
			DBG_ERR,
			("Duplicating 32 bit protocol catalog to 64 bit...\n"));
        WriteToRegistry ();
    }
#endif

    ReleaseCatalogLock ();

    // Close the event if we created one.
    if (created_event)
        CloseHandle (ChangeEvent);

    return return_value;

}  // RefreshFromRegistry

VOID
DCATALOG_ITEMS::UpdateProtocolList (
    PLIST_ENTRY     new_list
    ) 
/*++

Routine Description:

    This procedure carefully updates the catalog to match the one
    just read from the registry.  It takes care of moving item
    that did not change, removing itmes that no longer exists,
    adding new items, as well as establishing new item order.

Arguments:

    new_list    - list of the items just read form the registry

Return Value:

    None.

Implementation Notes:

    move all items from current catalog to old list
	for all items in new list
		if same item exist in old list
			add old item to current catalog and destroy new one
		else
			add new item to current catalog
	end for
	dereference all remaining items in the old list

--*/
{
    LIST_ENTRY          old_list;
    PPROTO_CATALOG_ITEM item;
    PLIST_ENTRY         list_member;

	// Move items from current list to old list
	InsertHeadList (&m_protocol_list, &old_list);
	RemoveEntryList (&m_protocol_list);
	InitializeListHead (&m_protocol_list);

	// for all loaded items
	while (!IsListEmpty (new_list)) {
		list_member = RemoveHeadList (new_list);
		item = CONTAINING_RECORD (list_member,
									PROTO_CATALOG_ITEM,
									m_CatalogLinkage);

		// check if the same item is in the old list
		list_member = old_list.Flink;
		while (list_member!=&old_list) {
			PPROTO_CATALOG_ITEM old_item;
			old_item = CONTAINING_RECORD (list_member,
									PROTO_CATALOG_ITEM,
									m_CatalogLinkage);
            list_member = list_member->Flink;
            if (*item==*old_item) {
				// it is, use the old one and get rid of the new
				assert (*(item->GetProviderId ()) == *(old_item->GetProviderId()));
#if defined(DEBUG_TRACING)
                InitializeListHead (&item->m_CatalogLinkage);
#endif
				item->Dereference ();

				item = old_item;
				RemoveEntryList (&item->m_CatalogLinkage);
#if defined(DEBUG_TRACING)
                InitializeListHead (&item->m_CatalogLinkage);
#endif
                m_num_items -= 1;
				break;
			}
		}
		// add item to the current list
		InsertTailList (&m_protocol_list, &item->m_CatalogLinkage);
        m_num_items += 1;
	}

	// destroy all remaining items on the old list
	while (!IsListEmpty (&old_list)) {
		list_member = RemoveHeadList (&old_list);
		item = CONTAINING_RECORD (list_member,
									PROTO_CATALOG_ITEM,
									m_CatalogLinkage);
#if defined(DEBUG_TRACING)
        InitializeListHead (&item->m_CatalogLinkage);
#endif
        m_num_items -= 1;
		item->Dereference ();
	}
}


INT
DCATALOG::WriteToRegistry(
    )
/*++

Routine Description:

    This procedure writes the "entries" and "numentries" portion of the catalog
    out  to  the  registry.

Arguments:

Return Value:

    If  the  function  is  successful,  it  returns ERROR_SUCCESS, otherwise it
    returns an appropriate WinSock error code.

Implementation Notes:
	lock catalog object
	acquire registry catalog lock (exclusive)
    RegCreateKeyEx(... entries, entries_key)
    RegDeleteSubkeys (... entries_key)
    while (get item from catalog)
        num_items++;
        item->WriteToRegistry(entries_key, num_items)
    end while
    RegCloseKey(... entries_key)
    WriteRegistryEntry(... num_items)
	WriteRegistryEntry(... nex_id)
	release registry catalog
	unlock catalog object
--*/
{
    LONG lresult;
    HKEY access_key, entries_key;
    DWORD dont_care;
    INT return_value;
    BOOL bresult;

	// lock the catalog object
    AcquireCatalogLock ();
    assert (m_reg_key!=NULL);
    assert (m_serial_num!=0);

	// Get exclusive access to the registry
	// This also verifies that registry has not change since
	// it was last read
    return_value = AcquireExclusiveCatalogAccess (
							m_reg_key,
							m_serial_num,
							&access_key);
    if (return_value == ERROR_SUCCESS) {
		// Create or open existing entries key
        lresult = RegCreateKeyEx(
            m_reg_key,                // hkey
#ifdef _WIN64
            m_entries_name32==sm_entries_name32
                ? CATALOG_ENTRIES_NAME32 :
#endif
            CATALOG_ENTRIES_NAME,     // lpszSubKey
            0,                        // dwReserved
            NULL,                     // lpszClass
            REG_OPTION_NON_VOLATILE,  // fdwOptions
            KEY_READ|KEY_WRITE,       // samDesired
            NULL,                     // lpSecurityAttributes
            & entries_key,            // phkResult
            & dont_care               // lpdwDisposition
            );
        if (lresult == ERROR_SUCCESS) {
            PLIST_ENTRY          ListMember;
            PPROTO_CATALOG_ITEM  item;
            DWORD                num_items = 0;

            lresult = RegDeleteSubkeys (entries_key);

            TRY_START(any_failure) {

#ifdef _WIN64
                if (m_items32!=NULL && m_entries_name32!=sm_entries_name32) {
                    HKEY entries_key32;
                    DWORD num_items32 = 0;


		            // Create or open existing entries key
                    lresult = RegCreateKeyEx(
                        m_reg_key,                // hkey
                        CATALOG_ENTRIES_NAME32,   // lpszSubKey
                        0,                        // dwReserved
                        NULL,                     // lpszClass
                        REG_OPTION_NON_VOLATILE,  // fdwOptions
                        KEY_READ|KEY_WRITE,       // samDesired
                        NULL,                     // lpSecurityAttributes
                        & entries_key32,          // phkResult
                        & dont_care               // lpdwDisposition
                        );
                    if (lresult != ERROR_SUCCESS) {
                        TRY_THROW(any_failure);
                    }

                    lresult = RegDeleteSubkeys (entries_key32);

                    TRY_START(any_failure32) {
				        // Write catalog items to registry
                        ListMember = m_items32->m_protocol_list.Flink;
                        while (ListMember != & m_items32->m_protocol_list) {
                            item = CONTAINING_RECORD(
                                ListMember,
                                PROTO_CATALOG_ITEM,
                                m_CatalogLinkage);
                            ListMember = ListMember->Flink;
                            num_items32 += 1;
                            return_value = item->WriteToRegistry(
                                entries_key32,  // ParentKey
                                num_items32     // SequenceNum
                                );
                            if (return_value != ERROR_SUCCESS) {
                                DEBUGF(
                                    DBG_ERR,
                                    ("Writing item (%lu) to registry\n",
                                    num_items32));
                                TRY_THROW(any_failure32);
                            }
                        }  // while get item

                        assert (m_items32->m_num_items == num_items32);
				        // Write number of items
                        bresult = WriteRegistryEntry(
                            m_reg_key,             // EntryKey
                            NUM_ENTRIES_NAME32,    // EntryName
                            (PVOID) & m_items32->m_num_items,// Data
                            REG_DWORD             // TypeFlag
                            );
                        if (! bresult) {
                            DEBUGF(
                                DBG_ERR,
                                ("Writing %s value\n",
                                NUM_ENTRIES_NAME32));
                            return_value = WSASYSCALLFAILURE;
                            TRY_THROW(any_failure32);
                        }
                    } TRY_CATCH(any_failure32) {
                        assert (return_value != ERROR_SUCCESS);
                    } TRY_END(any_failure32);

			        // Close entries key
                    lresult = RegCloseKey(
                        entries_key32  // hkey
                        );
                    if (lresult != ERROR_SUCCESS) {
                        DEBUGF(
                            DBG_ERR,
                            ("Closing entries key of registry\n"));
				        // Non-fatal
                    }
                }
#endif _WIN64


				// Write catalog items to registry
                ListMember = m_protocol_list.Flink;
                while (ListMember != & m_protocol_list) {
                    item = CONTAINING_RECORD(
                        ListMember,
                        PROTO_CATALOG_ITEM,
                        m_CatalogLinkage);
                    ListMember = ListMember->Flink;
                    num_items += 1;
                    return_value = item->WriteToRegistry(
                        entries_key,  // ParentKey
                        num_items     // SequenceNum
                        );
                    if (return_value != ERROR_SUCCESS) {
                        DEBUGF(
                            DBG_ERR,
                            ("Writing item (%lu) to registry\n",
                            num_items));
                        TRY_THROW(any_failure);
                    }
                }  // while get item

                assert (m_num_items == num_items);
				// Write number of items
                bresult = WriteRegistryEntry(
                    m_reg_key,             // EntryKey
#ifdef _WIN64
                    m_entries_name32==sm_entries_name32
                        ? NUM_ENTRIES_NAME32 :
#endif
                    NUM_ENTRIES_NAME,     // EntryName
                    (PVOID) & m_num_items,// Data
                    REG_DWORD             // TypeFlag
                    );
                if (! bresult) {
                    DEBUGF(
                        DBG_ERR,
                        ("Writing %s value\n",
                        NUM_ENTRIES_NAME));
                    return_value = WSASYSCALLFAILURE;
                    TRY_THROW(any_failure);
                }

				// Write next catalog id
                bresult = WriteRegistryEntry(
                    m_reg_key,               // EntryKey
                    NEXT_CATALOG_ENTRY_NAME,// EntryName
                    (PVOID) & m_next_id,    // Data
                    REG_DWORD               // TypeFlag
                    );
                if (! bresult) {
                    DEBUGF(
                        DBG_ERR,
                        ("Writing %s value\n",
                        NUM_ENTRIES_NAME));
                    return_value = WSASYSCALLFAILURE;
                    TRY_THROW(any_failure);
                }

            } TRY_CATCH(any_failure) {
                if (return_value == ERROR_SUCCESS) {
                    return_value = WSASYSCALLFAILURE;
                }
            } TRY_END(any_failure);

			// Close entries key
            lresult = RegCloseKey(
                entries_key  // hkey
                );
            if (lresult != ERROR_SUCCESS) {
                DEBUGF(
                    DBG_ERR,
                    ("Closing entries key of registry\n"));
				// Non-fatal
            }
        }
        else {
            return_value = WSASYSCALLFAILURE;
        }

		// Release registry
        ReleaseExclusiveCatalogAccess (
							m_reg_key,
							m_serial_num, 
							access_key);
    }

	// Unlock catalog object
	ReleaseCatalogLock();
    return return_value;

}  // WriteToRegistry



DCATALOG::~DCATALOG()
/*++

Routine Description:

    This  function  destroys the catalog object.  It takes care of removing and
    dereferecing  all  of  the  catalog  entries  in  the catalog.  This includes
    dereferencing  all  of the DPROVIDER objects referenced by the catalog.  

Arguments:

    None

Return Value:

    None

Implementation Notes:

    lock the catalog
    for each catalog entry
        remove the entry
        dereference the entry
    end for
    close registry key
    unlock the catalog
    delete catalog lock
--*/
{
    PLIST_ENTRY this_linkage;
    PPROTO_CATALOG_ITEM  this_item;
    LONG        lresult;

    DEBUGF(
        DBG_TRACE,
        ("Catalog destructor\n"));

    //
    // Check if we were fully initialized.
    //
    if (m_protocol_list.Flink==NULL) {
        return;
    }
    AcquireCatalogLock();

    while ((this_linkage = m_protocol_list.Flink) != & m_protocol_list) {
        this_item = CONTAINING_RECORD(
            this_linkage,        // address
            PROTO_CATALOG_ITEM,  // type
            m_CatalogLinkage     // field
            );
        RemoveCatalogItem(
            this_item  // CatalogItem
            );
        this_item->Dereference ();
    }  // while (get entry linkage)

#ifdef _WIN64
    if (m_items32!=NULL && m_entries_name32!=sm_entries_name32) {
        while ((this_linkage = m_items32->m_protocol_list.Flink) != & m_items32->m_protocol_list) {
            this_item = CONTAINING_RECORD(
                this_linkage,        // address
                PROTO_CATALOG_ITEM,  // type
                m_CatalogLinkage     // field
                );
            RemoveCatalogItem32(
                this_item  // CatalogItem
                );
            this_item->Dereference ();
        }  // while (get entry linkage)
    }
#endif

    assert( m_num_items == 0 );
    if (m_reg_key!=NULL) {
        lresult = RegCloseKey (m_reg_key);
        if (lresult != ERROR_SUCCESS) {
            DEBUGF (DBG_ERR,
                ("Closing catalog registry key, err: %ld.\n", lresult));
        }
        m_reg_key = NULL;
    }

    ReleaseCatalogLock();
    DeleteCriticalSection( &m_catalog_lock );

}  // ~DCATALOG




VOID
DCATALOG::EnumerateCatalogItems(
    IN CATALOGITERATION  Iteration,
    IN PVOID             PassBack
    )
/*++

Routine Description:

    This  procedure enumerates all of the DPROTO_CATALOG_ITEM structures in the
    catalog  by  calling  the indicated iteration procedure once for each item.
    The called procedure can stop the iteration early by returning FALSE.

    Note  that  the DPROVIDER associated with an enumerated DPROTO_CATALOG_ITEM
    may  be  NULL.   To retrieve DPROTO_CATALOG_ITEM structure that has had its
    DPROVIDER      loaded      and      initialized,      you      can      use
    GetCatalogItemFromCatalogEntryId.

Arguments:

    Iteration - Supplies   a  reference  to  the  catalog  iteration  procedure
                supplied by the client.

    PassBack  - Supplies  a  value uninterpreted by this procedure.  This value
                is  passed  unmodified to the catalog iteration procedure.  The
                client can use this value to carry context between the original
                call site and the iteration procedure.

Return Value:

    None
--*/
{
    PLIST_ENTRY         ListMember;
    PPROTO_CATALOG_ITEM CatalogEntry;
    BOOL                enumerate_more;

    assert(Iteration != NULL);

    enumerate_more = TRUE;

    AcquireCatalogLock();

    ListMember = m_protocol_list.Flink;

    while (enumerate_more && (ListMember != & m_protocol_list)) {
        CatalogEntry = CONTAINING_RECORD(
            ListMember,
            PROTO_CATALOG_ITEM,
            m_CatalogLinkage);
        ListMember = ListMember->Flink;
        enumerate_more = (* Iteration) (
            PassBack,     // PassBack
            CatalogEntry  // CatalogEntry
            );
    } //while

#ifdef _WIN64
    if (m_items32!=NULL && m_entries_name32!=sm_entries_name32) {
        ListMember = m_items32->m_protocol_list.Flink;

        while (enumerate_more && (ListMember != & m_items32->m_protocol_list)) {
            CatalogEntry = CONTAINING_RECORD(
                ListMember,
                PROTO_CATALOG_ITEM,
                m_CatalogLinkage);
            ListMember = ListMember->Flink;
            enumerate_more = (* Iteration) (
                PassBack,     // PassBack
                CatalogEntry  // CatalogEntry
                );
        } //while
    }
#endif

    ReleaseCatalogLock();

}  // EnumerateCatalogItems




INT
DCATALOG::GetCountedCatalogItemFromCatalogEntryId(
    IN  DWORD                     CatalogEntryId,
    OUT PPROTO_CATALOG_ITEM FAR * CatalogItem
    )
/*++

Routine Description:

    This  procedure  retrieves  a  reference  to a catalog item given a catalog
    entry ID to search for.

    The operation takes care of creating, initializing, and setting a DPROVIDER
    object  for the retrieved catalog item if necessary. 

Arguments:

    CatalogEntryId  - Supplies The ID of a catalog entry to be searched for.

    CatalogItem     - Returns a reference to the catalog item with the matching
                      catalog entry ID if it is found, otherwise returns NULL.

Return Value:

  The  function  returns  ERROR_SUCESS  if  successful, otherwise it returns an
  appropriate WinSock error code.
--*/
{
    PLIST_ENTRY         ListMember;
    INT                 ReturnCode;
    PPROTO_CATALOG_ITEM CatalogEntry;

    assert(CatalogItem != NULL);

    // Prepare for early error return
    * CatalogItem = NULL;
    ReturnCode = WSAEINVAL;

    AcquireCatalogLock();

    ListMember = m_protocol_list.Flink;

    while (ListMember != & m_protocol_list) {
        CatalogEntry = CONTAINING_RECORD(
            ListMember,
            PROTO_CATALOG_ITEM,
            m_CatalogLinkage);
        ListMember = ListMember->Flink;
        if (CatalogEntry->GetProtocolInfo()->dwCatalogEntryId==CatalogEntryId) {
            if (CatalogEntry->GetProvider() == NULL) {
                ReturnCode = LoadProvider(
                    CatalogEntry    // CatalogEntry
                    );
                if (ReturnCode != ERROR_SUCCESS) {
                    break;
                }
            }  // if provider is NULL
            CatalogEntry->Reference ();
            *CatalogItem = CatalogEntry;
            ReturnCode = ERROR_SUCCESS;
            break;
        } //if
    } //while

    ReleaseCatalogLock();
    return(ReturnCode);
}  // GetCatalogItemFromCatalogEntryId

INT
DCATALOG::GetCountedCatalogItemFromAddressFamily(
    IN  INT af,
    OUT PPROTO_CATALOG_ITEM FAR * CatalogItem
    )
/*++

Routine Description:

    This  procedure  retrieves  a  reference  to a catalog item given an
    address  to search for.

    The operation takes care of creating, initializing, and setting a DPROVIDER
    object  for the retrieved catalog item if necessary.  This includes setting
    the DPROVIDER object in all catalog entries for the same provider.

Arguments:

    af  - Supplies The address family to be searched for.

    CatalogItem     - Returns a reference to the catalog item with the matching
                      catalog entry ID if it is found, otherwise returns NULL.

Return Value:

  The  function  returns  ERROR_SUCESS  if  successful, otherwise it returns an
  appropriate WinSock error code.
--*/
{
    PLIST_ENTRY         ListMember;
    INT                 ReturnCode;
    PPROTO_CATALOG_ITEM CatalogEntry;

    assert(CatalogItem != NULL);

    // Prepare for early error return
    * CatalogItem = NULL;
    ReturnCode = WSAEINVAL;

    AcquireCatalogLock();

    ListMember = m_protocol_list.Flink;

    while (ListMember != & m_protocol_list) {
        CatalogEntry = CONTAINING_RECORD(
            ListMember,
            PROTO_CATALOG_ITEM,
            m_CatalogLinkage);
        ListMember = ListMember->Flink;

        if (CatalogEntry->GetProtocolInfo()->ProtocolChain.ChainLen != LAYERED_PROTOCOL &&
            CatalogEntry->GetProtocolInfo()->iAddressFamily == af) {
            if (CatalogEntry->GetProvider() == NULL) {
                ReturnCode = LoadProvider(
                    CatalogEntry    // CatalogEntry
                    );
                if (ReturnCode != ERROR_SUCCESS) {
                    break;
                }
            }  // if provider is NULL
            CatalogEntry->Reference ();
            * CatalogItem = CatalogEntry;
            ReturnCode = ERROR_SUCCESS;
            //
            // Found something, break out.
            //
            break;
        } //if
    } //while

    ReleaseCatalogLock();
    return(ReturnCode);
}



INT
DCATALOG::GetCountedCatalogItemFromAttributes(
    IN  INT     af,
    IN  INT     type,
    IN  INT     protocol,
    IN  DWORD   StartAfterId OPTIONAL,
    OUT PPROTO_CATALOG_ITEM FAR * CatalogItem
    )
/*++

Routine Description:

    Retrieves a PROTO_CATALOG_ITEM reference, choosing an item from the catalog
    based  on  three parameters (af, type, protocol) to determine which service
    provider  is used.  The procedure selects the first transport provider able
    to support the stipulated address family, socket type, and protocol values.
    If "protocol" is not specifieid (i.e., equal to zero).  the default for the
    specified socket type is used.  However, the address family may be given as
    AF_UNSPEC  (unspecified),  in  which  case the "protocol" parameter must be
    specified.   The protocol number to use is particular to the "communication
    domain" in which communication is to take place.

    The operation takes care of creating, initializing, and setting a DPROVIDER
    object  for the retrieved catalog item if necessary. 

Arguments:

    af          - Supplies an address family specification

    type        - Supplies a socket type specification

    protocol    - Supplies  an  address  family  specific  identification  of a
                  protocol  to  be  used with a socket, or 0 if the caller does
                  not wish to specify a protocol.

    StartAfterId - Optionally (non 0) supplies the catalog id of the item 
                    after which to begin enumeration.

    CatalogItem - Returns  a reference to the catalog item that was found to be
                  a suitable match or NULL if no suitable match was found.


Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it returns an
    appropriate WinSock error code.

Implementation Notes:

    For  each  protocol  item  to  test,  match  first  type, then family, then
    protocol.   Keep  track of the "strongest" match found.  If there was not a
    complete  match,  the  strength of the strongest match determines the error
    code returned.
--*/
{
#define MATCHED_NONE 0
#define MATCHED_TYPE 1
#define MATCHED_TYPE_FAMILY 2
#define MATCHED_TYPE_FAMILY_PROTOCOL 3
#define LARGER_OF(a,b) (((a) > (b)) ? (a) : (b))

    PLIST_ENTRY ListMember;
    INT         ReturnCode;
    PPROTO_CATALOG_ITEM CatalogEntry;
    LPWSAPROTOCOL_INFOW ProtoInfo;
    INT match_strength = MATCHED_NONE;

    assert(CatalogItem != NULL);

    // Prepare for early error returns
    * CatalogItem = NULL;
    WS2_32_W4_INIT  CatalogEntry = NULL;

    // Parameter consistency check:
    if (af == 0) {
        if( protocol == 0 ) {
            //
            // These cannot both be zero.
            //

            return WSAEINVAL;
        }

        DEBUGF(
            DBG_WARN,
            ("Use of AF_UNSPEC is discouraged\n"));
        // Unfortunately we cannot treat this as an error case.
    }

    AcquireCatalogLock();

    ListMember = m_protocol_list.Flink;

    // Find the place to start if asked
    if( StartAfterId != 0 ) {
        while (ListMember != & m_protocol_list) {
            CatalogEntry = CONTAINING_RECORD(
                ListMember,
                PROTO_CATALOG_ITEM,
                m_CatalogLinkage);
            ListMember = ListMember->Flink;
            if (CatalogEntry->GetProtocolInfo()->dwCatalogEntryId==StartAfterId)
                break;
        }
    }


    while ((ListMember != & m_protocol_list) &&
        (match_strength < MATCHED_TYPE_FAMILY_PROTOCOL))
    {
        CatalogEntry = CONTAINING_RECORD(
            ListMember,
            PROTO_CATALOG_ITEM,
            m_CatalogLinkage);
        ListMember = ListMember->Flink;
        ProtoInfo = CatalogEntry->GetProtocolInfo();
        if (ProtoInfo->ProtocolChain.ChainLen != LAYERED_PROTOCOL) {
#define TYPE_WILDCARD_VALUE 0
            // Can  this  entry  support  the  requested  socket  type?   Or is the
            // wildcard type specified?
            if ((ProtoInfo->iSocketType == type) ||
                (type == TYPE_WILDCARD_VALUE)) {
                match_strength = LARGER_OF(
                    match_strength,
                    MATCHED_TYPE);

#define FAMILY_WILDCARD_VALUE AF_UNSPEC
                // Can it support the requested address family?  Or is the wildcard
                // family specified?
                if ((ProtoInfo->iAddressFamily == af) ||
                    (af == FAMILY_WILDCARD_VALUE)) {
                    match_strength = LARGER_OF(
                        match_strength,
                        MATCHED_TYPE_FAMILY);

#define PROTO_IN_RANGE(proto,lo,hi) (((proto) >= (lo)) && ((proto) <= (hi)))
#define IS_BIT_SET(test_val,bitmask) (((test_val) & (bitmask)) == (bitmask))
                    // Is  the  requested  protcol  in  range?  Or is the requested
                    // protocol zero and entry supports protocol zero?
                    {  // declare block
                        int range_lo = ProtoInfo->iProtocol;
                        int range_hi = range_lo + ProtoInfo->iProtocolMaxOffset;
                        if (PROTO_IN_RANGE(protocol, range_lo, range_hi) ||
                            ((protocol == 0) &&
                             IS_BIT_SET(
                                 ProtoInfo->dwProviderFlags,
                                 PFL_MATCHES_PROTOCOL_ZERO))) {
                            match_strength = LARGER_OF(
                                match_strength,
                                MATCHED_TYPE_FAMILY_PROTOCOL);
                        } // if protocol supported
                    } // declare block
                } //if address family supported
            } //if type supported
        } //if not layered protocol
    }  // while


    // Select  an  appropriate error code for "no match" cases, or success code
    // to proceed.
    switch (match_strength) {
        case MATCHED_NONE:
            ReturnCode = WSAESOCKTNOSUPPORT;
            break;

        case MATCHED_TYPE:
            ReturnCode = WSAEAFNOSUPPORT;
            break;

        case MATCHED_TYPE_FAMILY:
            ReturnCode = WSAEPROTONOSUPPORT;
            break;

        case MATCHED_TYPE_FAMILY_PROTOCOL:
            // A full match found, continue
            if (CatalogEntry->GetProvider() != NULL) {
                ReturnCode = ERROR_SUCCESS;
            }
            else {
                ReturnCode = LoadProvider(
                    CatalogEntry
                    );
                if (ReturnCode != ERROR_SUCCESS) {
                    DEBUGF(
                        DBG_ERR,
                        ("Error (%lu) loading chosen provider\n",
                        ReturnCode));
                    break;
                } // else
            }  // if provider is NULL

            CatalogEntry->Reference ();
            * CatalogItem = CatalogEntry;
            break;

        default:
            DEBUGF(
                DBG_ERR,
                ("Should not get here\n"));
            ReturnCode = WSASYSCALLFAILURE;

    }  // switch (match_strength)

    ReleaseCatalogLock();

    return ReturnCode;

}  // GetCountedCatalogItemFromAttributes


INT
DCATALOG::FindIFSProviderForSocket(
    SOCKET Socket
    )

/*++

Routine Description:

    This procedure searches the installed providers that support IFS handles
    for one that recognizes the given socket. If one is found, then the
    necessary internal infrastructure is established for supporting the
    socket.

Arguments:

    Socket - The socket.

Return Value:

    If  the  function  is  successful,  it  returns ERROR_SUCCESS, otherwise it
    returns an appropriate WinSock error code.

--*/

{

    INT result;
    INT error;
    INT optionLength;
    PLIST_ENTRY listEntry;
    PPROTO_CATALOG_ITEM catalogItem;
    PDPROVIDER provider;
    WSAPROTOCOL_INFOW protocolInfo;
    SOCKET modifiedSocket;
    DWORD  serial_num;

    //
    // Scan the installed providers.
    //

    AcquireCatalogLock();

Restart:
    for( listEntry = m_protocol_list.Flink ;
         listEntry != &m_protocol_list ;
         listEntry = listEntry->Flink ) {

        catalogItem = CONTAINING_RECORD(
                          listEntry,
                          PROTO_CATALOG_ITEM,
                          m_CatalogLinkage
                          );

        //
        // Skip non-IFS providers.
        //

        if( ( catalogItem->GetProtocolInfo()->dwServiceFlags1 &
                XP1_IFS_HANDLES ) == 0 ) {

            continue;

        }

        //
        // Load the provider if necessary.
        //

        provider = catalogItem->GetProvider();

        if( provider == NULL ) {

            result = LoadProvider(
                         catalogItem
                         );

            if( result != NO_ERROR ) {

                //
                // Could not load the provider. Press on regardless.
                //

                continue;

            }
            provider = catalogItem->GetProvider ();

            assert( provider != NULL );
        }

        //
        // Reference catalog item, remeber current catalog serial
        // number, and release the lock to prevent a deadlock
        // in case provider waits in another thread on catalog lock
        // while holding on of its locks which it may need to acquire
        // while we are calling into it.
        //
        catalogItem->Reference ();
        serial_num = m_serial_num;
        ReleaseCatalogLock ();

        //
        // Try a getsockopt( SO_PROTOCOL_INFOW ) on the socket to determine
        // if the current provider recognizes it. This has the added benefit
        // of returning the dwCatalogEntryId for the socket, which we can
        // use to call WPUModifyIFSHandle().
        //

        optionLength = sizeof(protocolInfo);

        result = provider->WSPGetSockOpt(
                     Socket,
                     SOL_SOCKET,
                     SO_PROTOCOL_INFOW,
                     (char FAR *)&protocolInfo,
                     &optionLength,
                     &error
                     );

        // Do not need catalog item any longer
        catalogItem->Dereference ();
        if( result != ERROR_SUCCESS) {
            
            //
            // It is possible that while we were talking to the provider
            // application has called WSACleanup in another thread.
            // Do this check, which although is not fool-proof
            // but should prevent AV's in most cases.
            // Yes, it is possible to create fool-proof code by
            // implementing ref-counting of the process object,
            // but it is expensive and does not solve the real problem:
            //   IF APPLICATION TRIES TO CLOSE THE SOCKET HANDLE OR
            //   CLEANUP WINSOCK (which closes all socket handles)
            //   IT HAS TO ACCEPT THE FACT THAT IT MAY ENCOUNTER AN
            //   EXCEPTION (e.g. INVALID_HANDLE).
            //
            if (DPROCESS::GetCurrentDProcess ()==NULL) {
                break;
            }

            //
            // WPUGetSockOpt() failed, probably because the socket is
            // not recognized. Continue on and try another provider.
            //

            AcquireCatalogLock ();
            //
            // Check if catalog has changed while we are calling
            // into the provider, if so, restart the lookup
            // otherwise, press on.
            //
            if (serial_num==m_serial_num)
                continue;
            else
                goto Restart;

        }

        //
        // Call WPUModifyIFSHandle(). The current implementation doesn't
        // actually modify the handle, but it does setup the necessary
        // internal infrastructure for the socket.
        //
        // Note that provider might have already called this function,
        // in which case our call will have no effect (because we support
        // layered providers that reuse base provider sockets which
        // employ the same method.
        //
        //
        // !!! We should move the "create the DSocket object and setup
        //     all of the internal stuff" from WPUModifyIFSHandle() into
        //     a common function shared with this function.
        //

        modifiedSocket = WPUModifyIFSHandle(
                             protocolInfo.dwCatalogEntryId,
                             Socket,
                             &error
                             );

        if( modifiedSocket == INVALID_SOCKET ) {

            //
            // This error is not continuable, as the provider has
            // recognized the socket, but for some reason we cannot
            // create the necessary internal infrastructure for the
            // socket. We have no choice here except to just bail out
            // and fail the request.
            //
            // !!! The provider may have established internal state for
            //     this socket. Should we invoke provider->WSPCloseSocket()
            //     on it now to remove any such state?
            //

            return WSAENOTSOCK;

        }

        //
        // Success!
        //

        assert( modifiedSocket == Socket );
        return ERROR_SUCCESS;

    }

    //
    // If we made it this far, then no provider recognized the socket.
    //

    ReleaseCatalogLock();
    return WSAENOTSOCK;

} // FindIFSProviderForSocket


DWORD
DCATALOG::AllocateCatalogEntryId (
    VOID
    )
{
    DWORD   id;
    AcquireCatalogLock ();
    assert (m_reg_key!=NULL);

    if (m_next_id!=0)
        id = m_next_id++;
    else
        id = 0;

    ReleaseCatalogLock ();
    return id;
}



VOID
DCATALOG::AppendCatalogItem(
    IN  PPROTO_CATALOG_ITEM  CatalogItem
    )
/*++

Routine Description:

    This procedure appends a catalog item to the end of the (in-memory) catalog
    object.   It becomes the last item in the catalog.  The catalog information
    in the registry is NOT updated.

Arguments:

    CatalogItem - Supplies a reference to the catalog item to be added.

Return Value:

    None
--*/
{
    assert(CatalogItem != NULL);
    assert (IsListEmpty (&CatalogItem->m_CatalogLinkage));

    InsertTailList(
        & m_protocol_list,               // ListHead
        & CatalogItem->m_CatalogLinkage  // Entry
       );
    m_num_items++;
}  // AppendCatalogItem


#ifdef _WIN64
VOID
DCATALOG::AppendCatalogItem32(
    IN  PPROTO_CATALOG_ITEM  CatalogItem
    )
/*++

Routine Description:

    This procedure appends a catalog item to the end of the (in-memory) catalog
    object.   It becomes the last item in the catalog.  The catalog information
    in the registry is NOT updated.

Arguments:

    CatalogItem - Supplies a reference to the catalog item to be added.

Return Value:

    None
--*/
{
    assert(CatalogItem != NULL);
    assert(IsListEmpty (&CatalogItem->m_CatalogLinkage));
    assert(m_items32!=NULL && m_entries_name32!=sm_entries_name32);

    InsertTailList(
        & m_items32->m_protocol_list,               // ListHead
        & CatalogItem->m_CatalogLinkage  // Entry
       );
    m_items32->m_num_items++;
}  // AppendCatalogItem32
#endif


VOID
DCATALOG::RemoveCatalogItem(
    IN  PPROTO_CATALOG_ITEM  CatalogItem
    )
/*++

Routine Description:

    This  procedure removes a catalog item from the (in-memory) catalog object.
    The catalog information in the registry is NOT updated.

Arguments:

    CatalogItem - Supplies a reference to the catalog item to be removed.

Return Value:

    None
--*/
{
    assert(CatalogItem != NULL);
    assert(!IsListEmpty (&CatalogItem->m_CatalogLinkage));

    RemoveEntryList(
        & CatalogItem->m_CatalogLinkage  // Entry
        );
#if defined(DEBUG_TRACING)
    InitializeListHead (&CatalogItem->m_CatalogLinkage);
#endif
    assert(m_num_items > 0);
    m_num_items--;
}  // RemoveCatalogItem


#ifdef _WIN64
VOID
DCATALOG::RemoveCatalogItem32(
    IN  PPROTO_CATALOG_ITEM  CatalogItem
    )
/*++

Routine Description:

    This  procedure removes a catalog item from the (in-memory) catalog object.
    The catalog information in the registry is NOT updated.

Arguments:

    CatalogItem - Supplies a reference to the catalog item to be removed.

Return Value:

    None
--*/
{
    assert(CatalogItem != NULL);
    assert(!IsListEmpty (&CatalogItem->m_CatalogLinkage));

    RemoveEntryList(
        & CatalogItem->m_CatalogLinkage  // Entry
        );
#if defined(DEBUG_TRACING)
    InitializeListHead (&CatalogItem->m_CatalogLinkage);
#endif
    assert(m_items32->m_num_items > 0);
    m_items32->m_num_items--;
}  // RemoveCatalogItem32
#endif

LPSTR
DCATALOG::GetCurrentCatalogName()
{
    return CATALOG_NAME;

} // GetCurrentCatalogName


INT
DCATALOG::LoadProvider(
    IN PPROTO_CATALOG_ITEM CatalogEntry
    )
/*++

Routine Description:

    Load   the   provider  described  by  CatalogEntry and set it into
    catalog entry

Arguments:

    CatalogEntry - Supplies  a reference to a protocol catalog entry describing
                   the provider to load.


Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it returns an
    appropriate WinSock error code.
--*/
{
    INT ReturnCode = ERROR_SUCCESS;
    PDPROVIDER LocalProvider;

    assert(CatalogEntry != NULL);

    // Serialize provider loading/unloading
    AcquireCatalogLock ();

    // Check if provider is loaded under the lock
    if (CatalogEntry->GetProvider ()==NULL) {

        // First attempt to find another instance of the provider
        LocalProvider = FindAnotherProviderInstance (
                                CatalogEntry->GetProviderId ());
        if (LocalProvider != NULL) {
            // Success, just set it
            CatalogEntry->SetProvider (LocalProvider);
            ReturnCode = ERROR_SUCCESS;
        }
        else {
            // Create and attempt to load provider object
            LocalProvider = new(DPROVIDER);
            if (LocalProvider !=NULL ) {

                ReturnCode = LocalProvider->Initialize(
                    CatalogEntry->GetLibraryPath(),
                    CatalogEntry->GetProtocolInfo()
                    );
                if (ERROR_SUCCESS == ReturnCode) {
                    CatalogEntry->SetProvider (LocalProvider);
                } //if

                LocalProvider->Dereference ();
            } //if
            else {
                DEBUGF(
                    DBG_ERR,
                    ("Allocating a DPROVIDER object\n"));
                ReturnCode = WSA_NOT_ENOUGH_MEMORY;
            }
        } // else
    } // if provider not loaded
  
    // Serialize provider loading/unloading
    ReleaseCatalogLock ();
    return(ReturnCode);
}  // LoadProvider




PDPROVIDER
DCATALOG::FindAnotherProviderInstance(
    IN LPGUID ProviderId
    )
/*++

Routine Description:

    Check  all catalog enteries for a provider with the pointer to the provider
    object for the provider.

Arguments:

    ProviderId - Supplies the Provider ID for the catalog enteries to check in.


Return Value:

    Pointer to provider object if found

Implementation notes:

--*/
{
    PLIST_ENTRY ListMember;
    PPROTO_CATALOG_ITEM CatalogEntry;
    PDPROVIDER   LocalProvider;

    ListMember = m_protocol_list.Flink;

    while (ListMember != & m_protocol_list)
    {
        CatalogEntry = CONTAINING_RECORD(
            ListMember,
            PROTO_CATALOG_ITEM,
            m_CatalogLinkage);
        ListMember = ListMember->Flink;
        LocalProvider = CatalogEntry->GetProvider ();
        if( (LocalProvider!=NULL) // This check is much less expensive
                && (*(CatalogEntry->GetProviderId()) == *ProviderId)) {
            return LocalProvider;
        } //if
    } //while

    return NULL;
}  // FindAnotherProviderInstance
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\dprovide.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    dprovide.cpp

Abstract:

    This module defines the WinSock2 class dprovder along with its methods.

Author:

    Mark Hamilton (mark_hamilton@jf2.intel.com) 7-July-1995

Revision History:

    21-Aug-1995 dirk@mink.intel.com
        Clean up from code review. Moved single line functions to inlines in
        header file. Added debug traceing code. Rewrote destructor. Removed
        ProviderID from the class.

    7-July-1995 mark_hamilton
      Genesis
--*/

#include "precomp.h"


DPROVIDER::DPROVIDER()
/*++
Routine Description:

    Creates any internal state.

Arguments:

    None

Return Value:

    None

--*/

{
    m_library_handle = NULL;
    m_reference_count = 1;
#ifdef DEBUG_TRACING
    m_lib_name = NULL;
#endif
}


INT
DPROVIDER::WSPCleanup(
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Terminate use of the WinSock service provider.

Arguments:

    lpErrno - A pointer to the error code.

Return Value:

    The  return  value  is  0 if the operation has been successfully initiated.
    Otherwise  the  value SOCKET_ERROR is returned,
and a specific error number
    is available in lpErrno.

--*/
{
    INT ReturnValue = NO_ERROR;

    if (m_library_handle) {
        LPWSPCLEANUP    lpWSPCleanup;

        lpWSPCleanup =
            (LPWSPCLEANUP)InterlockedExchangePointer (
                            (PVOID *)&m_proctable.lpWSPCleanup,
                            NULL
                            );
        if (lpWSPCleanup!=NULL) {

            DEBUGF( DBG_TRACE,
                    ("Calling WSPCleanup for provider %s @ %p\n", m_lib_name, this));

            if (!PREAPINOTIFY(( DTCODE_WSPCleanup,
                               &ReturnValue,
                               m_lib_name,
                               &lpErrno)) ) {

                ReturnValue = lpWSPCleanup(lpErrno);

                POSTAPINOTIFY(( DTCODE_WSPCleanup,
                                &ReturnValue,
                                m_lib_name,
                                &lpErrno));
            }
        }
    }
    return ReturnValue;
}


DPROVIDER::~DPROVIDER()
/*++
Routine Description:

    destroys any internal state.

Arguments:

    None

Return Value:

    None

--*/
{

    if (m_library_handle)
    {
        INT ErrorCode;
#ifdef DEBUG_TRACING
        assert (m_lib_name);
#endif

        // Cleanup service provider DLL if not already done so
        WSPCleanup (&ErrorCode);
        // Free the service provider DLL
        FreeLibrary(m_library_handle);

#ifdef DEBUG_TRACING
        delete m_lib_name;
#endif
    } //if
    DEBUGF( DBG_TRACE,
            ("Destroying provider %X\n", this));
}



INT
DPROVIDER::Initialize(
    IN LPWSTR lpszLibFile,
    IN LPWSAPROTOCOL_INFOW lpProtocolInfo
    )
/*++
Routine Description:

    Initializes the DPROVIDER object.

Arguments:

    lpszLibFile - A  Null  terminating  string  that  points to the .DLL of the
                  service to load.

    lpProtocolInfo - A pointer to a WSAPROTOCOL_INFOW struct to hand to the
                     provider startup routine.

Return Value:

    If no error occurs, Initialize() returns ERROR_SUCEES.  Otherwise the value
    SOCKET_ERROR  is  returned,  and  a  specific  error  code  is available in
    lpErrno.

--*/
{
    LPWSPSTARTUP        WSPStartupFunc          = NULL;
    WORD                wVersionRequested       = WINSOCK_HIGH_SPI_VERSION;
    INT                 error_code              = 0;
    WSPDATA             WSPData;
    WSPUPCALLTABLE      UpCallTable;
    WCHAR               LibraryPath[MAX_PATH];

    DEBUGF( DBG_TRACE,
            ("Initializing provider %ls @%p\n", lpszLibFile, this));

    TRY_START(guard_memalloc) {
        // Zero out contents of m_proctable
        ZeroMemory(
            (PVOID) &m_proctable,     // Destination
            sizeof(m_proctable));   // Length

        //
        // Fill  the  upcall  table  we  will hand to the service provider with the
        // address  of  our  upcall entry points.  We will also pre-fill this thing
        // with  zeros,  mainly  to  help  with  consistency  checks  if we add new
        // functions to the upcall table in the future.
        //
        ZeroMemory(
            (PVOID) & UpCallTable,  // Destination
            sizeof(UpCallTable));   // Length

    #if !defined(DEBUG_TRACING)
        UpCallTable.lpWPUCloseEvent = WPUCloseEvent;
        UpCallTable.lpWPUCloseSocketHandle = WPUCloseSocketHandle;
        UpCallTable.lpWPUCreateEvent = WPUCreateEvent;
        UpCallTable.lpWPUCreateSocketHandle = WPUCreateSocketHandle;
        UpCallTable.lpWPUModifyIFSHandle = WPUModifyIFSHandle;
        UpCallTable.lpWPUQueryBlockingCallback = WPUQueryBlockingCallback;
        UpCallTable.lpWPUQuerySocketHandleContext = WPUQuerySocketHandleContext;
        UpCallTable.lpWPUQueueApc = WPUQueueApc;
        UpCallTable.lpWPUResetEvent = WPUResetEvent;
        UpCallTable.lpWPUSetEvent = WPUSetEvent;
        UpCallTable.lpWPUPostMessage = WPUPostMessage;
        UpCallTable.lpWPUGetProviderPath = WPUGetProviderPath;
        UpCallTable.lpWPUFDIsSet = WPUFDIsSet;
        UpCallTable.lpWPUOpenCurrentThread = WPUOpenCurrentThread;
        UpCallTable.lpWPUCloseThread = WPUCloseThread;
    #else
        UpCallTable.lpWPUCloseEvent = DTHOOK_WPUCloseEvent;
        UpCallTable.lpWPUCloseSocketHandle = DTHOOK_WPUCloseSocketHandle;
        UpCallTable.lpWPUCreateEvent = DTHOOK_WPUCreateEvent;
        UpCallTable.lpWPUCreateSocketHandle = DTHOOK_WPUCreateSocketHandle;
        UpCallTable.lpWPUModifyIFSHandle = DTHOOK_WPUModifyIFSHandle;
        UpCallTable.lpWPUQueryBlockingCallback = DTHOOK_WPUQueryBlockingCallback;
        UpCallTable.lpWPUQuerySocketHandleContext = DTHOOK_WPUQuerySocketHandleContext;
        UpCallTable.lpWPUQueueApc = DTHOOK_WPUQueueApc;
        UpCallTable.lpWPUResetEvent = DTHOOK_WPUResetEvent;
        UpCallTable.lpWPUSetEvent = DTHOOK_WPUSetEvent;
        UpCallTable.lpWPUPostMessage = DTHOOK_WPUPostMessage;
        UpCallTable.lpWPUGetProviderPath = DTHOOK_WPUGetProviderPath;
        UpCallTable.lpWPUFDIsSet = DTHOOK_WPUFDIsSet;
        UpCallTable.lpWPUOpenCurrentThread = DTHOOK_WPUOpenCurrentThread;
        UpCallTable.lpWPUCloseThread = DTHOOK_WPUCloseThread;
    #endif  // !defined(DEBUG_TRACING)

        //
        // Expand the library name to pickup environment/registry variables
        //
        if (!( ExpandEnvironmentStringsW(lpszLibFile,
                                        LibraryPath,
                                        MAX_PATH))){
            DEBUGF(
                DBG_ERR,
                ("Expanding environment variable %ls\n", lpszLibFile));
            error_code = WSASYSCALLFAILURE;
            TRY_THROW(guard_memalloc);
        } //if

#ifdef DEBUG_TRACING
        m_lib_name = ansi_dup_from_wcs(lpszLibFile);
        if (m_lib_name == NULL) {
            DEBUGF(
                DBG_ERR,
                ("Allocating m_lib_name\n"));
            error_code = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(guard_memalloc);
        }
#endif DEBUG_TRACING
        //
        // First load the DLL for the service provider. Then get two functions that
        // init the service provider structures.
        //
        m_library_handle = LoadLibraryW(LibraryPath);
        if(!m_library_handle){
            error_code = GetLastError ();
            DEBUGF(
                DBG_ERR,
                ("Loading DLL %ls, err: %ld\n",LibraryPath, error_code));
            switch (error_code) {
            case ERROR_NOT_ENOUGH_MEMORY:
            case ERROR_COMMITMENT_LIMIT:
                error_code = WSA_NOT_ENOUGH_MEMORY;
                break;
            default:
                error_code = WSAEPROVIDERFAILEDINIT;
                break;
            }
            TRY_THROW(guard_memalloc);
        }

        WSPStartupFunc = (LPWSPSTARTUP)GetProcAddress(
            m_library_handle,
            "WSPStartup"
            );

        if(!(WSPStartupFunc)){

            DEBUGF( DBG_ERR,("Getting startup entry point for %ls-%ls\n",
                             lpProtocolInfo->szProtocol, lpszLibFile));
            error_code = WSAEPROVIDERFAILEDINIT;
            TRY_THROW(guard_memalloc);
        }

        //
        // Set exception handler around this call since we
        // hold critical section (catalog lock).
        //
        __try {
#if !defined(DEBUG_TRACING)
            error_code = (*WSPStartupFunc)(
                wVersionRequested,
                & WSPData,
                lpProtocolInfo,
                UpCallTable,
                &m_proctable);
#else
            { // declaration block
                LPWSPDATA  pWSPData = & WSPData;
                BOOL       bypassing_call;

                bypassing_call = PREAPINOTIFY((
                    DTCODE_WSPStartup,
                    & error_code,
                    m_lib_name,
                    & wVersionRequested,
                    & pWSPData,
                    & lpProtocolInfo,
                    & UpCallTable,
                    & m_proctable));
                if (! bypassing_call) {
                    error_code = (*WSPStartupFunc)(
                        wVersionRequested,
                        & WSPData,
                        lpProtocolInfo,
                        UpCallTable,
                        &m_proctable);
                    POSTAPINOTIFY((
                        DTCODE_WSPStartup,
                        & error_code,
                        m_lib_name,
                        & wVersionRequested,
                        & pWSPData,
                        & lpProtocolInfo,
                        & UpCallTable,
                        & m_proctable));
                } // if ! bypassing_call
            } // declaration block
#endif // !defined(DEBUG_TRACING)
        }
        __except (WS2_PROVIDER_EXCEPTION_FILTER ("WSPStartup",
                                                 LibraryPath,
                                                 lpProtocolInfo->szProtocol,
                                                 &lpProtocolInfo->ProviderId)) {
            error_code = WSAEPROVIDERFAILEDINIT;
            TRY_THROW(guard_memalloc);
        }

        if(ERROR_SUCCESS != error_code){
            DEBUGF(DBG_ERR, ("Calling WSPStartup for %ls %ls, err:%ld\n",
                    lpProtocolInfo->szProtocol, lpszLibFile, error_code));
            TRY_THROW(guard_memalloc);
        }

        //
        // Make sure that all of the procedures at least have a non null pointer.
        //
        if( !m_proctable.lpWSPAccept              ||
            !m_proctable.lpWSPAddressToString     ||
            !m_proctable.lpWSPAsyncSelect         ||
            !m_proctable.lpWSPBind                ||
            !m_proctable.lpWSPCancelBlockingCall  ||
            !m_proctable.lpWSPCleanup             ||
            !m_proctable.lpWSPCloseSocket         ||
            !m_proctable.lpWSPConnect             ||
            !m_proctable.lpWSPDuplicateSocket     ||
            !m_proctable.lpWSPEnumNetworkEvents   ||
            !m_proctable.lpWSPEventSelect         ||
            !m_proctable.lpWSPGetOverlappedResult ||
            !m_proctable.lpWSPGetPeerName         ||
            !m_proctable.lpWSPGetSockName         ||
            !m_proctable.lpWSPGetSockOpt          ||
            !m_proctable.lpWSPGetQOSByName        ||
            !m_proctable.lpWSPIoctl               ||
            !m_proctable.lpWSPJoinLeaf            ||
            !m_proctable.lpWSPListen              ||
            !m_proctable.lpWSPRecv                ||
            !m_proctable.lpWSPRecvDisconnect      ||
            !m_proctable.lpWSPRecvFrom            ||
            !m_proctable.lpWSPSelect              ||
            !m_proctable.lpWSPSend                ||
            !m_proctable.lpWSPSendDisconnect      ||
            !m_proctable.lpWSPSendTo              ||
            !m_proctable.lpWSPSetSockOpt          ||
            !m_proctable.lpWSPShutdown            ||
            !m_proctable.lpWSPSocket              ||
            !m_proctable.lpWSPStringToAddress ){

            DEBUGF(DBG_ERR,
                   ("Service provider %ls %ls returned an invalid procedure table\n",
                    lpProtocolInfo->szProtocol,lpszLibFile));
            error_code = WSAEINVALIDPROCTABLE;
            TRY_THROW(guard_memalloc);
        }

        //
        // Confirm that the WinSock service provider supports 2.2. If it supports a
        // version greater then 2.2 it will still return 2.2 since this is the
        // version  we requested.
        //
        if( WSPData.wVersion != WINSOCK_HIGH_SPI_VERSION ) {
            WSPCleanup (&error_code);
            DEBUGF( DBG_ERR,
                    ("Service Provider %ls %ls does not support version 2.2\n",
                     lpProtocolInfo->szProtocol,lpszLibFile));
            error_code = WSAVERNOTSUPPORTED;
            TRY_THROW(guard_memalloc);
        }
    } TRY_CATCH(guard_memalloc) {
        if (m_library_handle!=NULL) {
            FreeLibrary (m_library_handle);
            m_library_handle = NULL;
        }


#ifdef DEBUG_TRACING
        if (m_lib_name!=NULL) {
            delete m_lib_name;
            m_lib_name = NULL;
        }
#endif
    } TRY_END(guard_memalloc);

    return error_code;
} //Initailize
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\dprocess.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    dprocess.cpp

Abstract:

    This module contains the implementation of the dprocess class.

Author:

    Dirk Brandewie dirk@mink.intel.com  11-JUL-1995

Revision History:

    21-Aug-1995 dirk@mink.intel.com
       Cleanup after code review. Moved single line functions to header file as
       inlines. Added debug/trace code. Changed LIST_ENTRY's and
       CRITICAL_SECTION's from pointers to being embedded in the dprocess
       object.

--*/

#include "precomp.h"

// This is a static class member. It contains a pointer to the dprocess object
// for the current process.
PDPROCESS DPROCESS::sm_current_dprocess=NULL;



DPROCESS::DPROCESS(
    )
/*++

Routine Description:

    DPROCESS  object constructor.  Creates and returns a DPROCESS object.  Note
    that  the DPROCESS object has not been fully initialized.  The "Initialize"
    member  function  must  be  the  first  member  function  called on the new
    DPROCESS object.

    In  the Win32 environment, only one DPROCESS object may be in existence for
    a  process.   It  is  the  caller's  responsibility  to  ensure  that  this
    restriction is met.

Arguments:

    None

Return Value:

    Returns a pointer to the new DPROCESS object or NULL if a memory allocation
    failed.

--*/
{
    //
    // Initialize the list objects
    //
#if 0
    // Not used because of inherent race conditions.
    InitializeListHead(&m_thread_list);
#endif

    // Set our data members to known values.
    m_reference_count   = 0;
    m_ApcHelper         = NULL;
    m_HandleHelper      = NULL;
    m_NotificationHelper = NULL;
    m_protocol_catalog  = NULL;
    m_proto_catalog_change_event = NULL;
    m_namespace_catalog = NULL;
    m_ns_catalog_change_event = NULL;
    m_version           = WINSOCK_HIGH_API_VERSION; // until proven otherwise...
    m_lock_initialized = FALSE;
} //DPROCESS




INT
DPROCESS::Initialize(
    )
/*++

Routine Description:

    Completes  the  initialization  of  the DPROCESS object.  This must be the
    first  member  function  called  for  the DPROCESS object.  This procedure
    should be called only once for the object.

Arguments:

  None

Return Value:

  The  function returns 0 if successful.  Otherwise it returns an appropriate
  WinSock error code if the initialization cannot be completed.

--*/
{
    INT ReturnCode = WSAEFAULT;  // user return value
    HKEY RegistryKey = NULL;

    TRY_START(mem_guard){

        //
        // Initialize our critical sections
        //
        __try {
            InitializeCriticalSection( &m_thread_list_lock );
        }
        __except (WS2_EXCEPTION_FILTER ()) {
            ReturnCode = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(mem_guard);
        }
        m_lock_initialized = TRUE;


        RegistryKey = OpenWinSockRegistryRoot();
        if (!RegistryKey) {
            DEBUGF(
                DBG_ERR,
                ("Opening Winsock Registry Root\n"));
            ReturnCode = WSASYSCALLFAILURE;
            TRY_THROW(mem_guard);
        } //if

        m_proto_catalog_change_event = CreateEvent(
                    (LPSECURITY_ATTRIBUTES) NULL,
                    TRUE,       // manual reset
                    FALSE,      // initially non-signaled
                    NULL        // unnamed
                    );
        if (m_proto_catalog_change_event==NULL) {
			ReturnCode = GetLastError ();
            DEBUGF(
                DBG_ERR,
                ("Creating protocol catalog change event, err:%ld\n",
                ReturnCode));
            TRY_THROW(mem_guard);
        }

        //
        // Build the protocol catalog
        //

        m_protocol_catalog = new(DCATALOG);
        if (!m_protocol_catalog) {
            DEBUGF(
                DBG_ERR,
                ("Allocating dcatalog object\n"));
            ReturnCode = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(mem_guard);
        } //if

        ReturnCode = m_protocol_catalog->InitializeFromRegistry(
                            RegistryKey,
                            m_proto_catalog_change_event);
        if (ERROR_SUCCESS != ReturnCode) {
            DEBUGF(
                DBG_ERR,
                ("Initializing protocol catalog from registry\n"));
            TRY_THROW(mem_guard);
        } //if


        m_ns_catalog_change_event = CreateEvent(
                    (LPSECURITY_ATTRIBUTES) NULL,
                    TRUE,       // manual reset
                    FALSE,      // initially non-signaled
                    NULL        // unnamed
                    );
        if (m_ns_catalog_change_event==NULL) {
			ReturnCode = GetLastError ();
            DEBUGF(
                DBG_ERR,
                ("Creating ns catalog change event, err:%ld\n",
                ReturnCode));
            TRY_THROW(mem_guard);
        }

        //
        // Build the namespace catalog
        //

        m_namespace_catalog = new(NSCATALOG);
        if (!m_namespace_catalog) {
            DEBUGF(
                DBG_ERR,
                ("Allocating nscatalog object\n"));
            ReturnCode = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(mem_guard);
        } //if

        ReturnCode = m_namespace_catalog->InitializeFromRegistry (
                            RegistryKey,                // ParentKey
                            m_ns_catalog_change_event   // ChangeEvent
                            );
        if (ERROR_SUCCESS != ReturnCode) {
            DEBUGF(
                DBG_ERR,
                ("Initializing name space catalog from registry\n"));
            TRY_THROW(mem_guard);
        } //if


        // Set helper object pointers to null
        m_ApcHelper = NULL;
        m_HandleHelper = NULL;
        m_NotificationHelper = NULL;

    } TRY_CATCH(mem_guard) {
		assert (ReturnCode!=ERROR_SUCCESS);
        if (m_protocol_catalog!=NULL) {
            delete(m_protocol_catalog);
            m_protocol_catalog = NULL;
        }

        if (m_proto_catalog_change_event!=NULL) {
            CloseHandle (m_proto_catalog_change_event);
            m_proto_catalog_change_event = NULL;
        }

        if (m_namespace_catalog!=NULL) {
            delete(m_namespace_catalog);
            m_namespace_catalog = NULL;
        }

        if (m_ns_catalog_change_event!=NULL) {
            CloseHandle (m_ns_catalog_change_event);
            m_ns_catalog_change_event = NULL;
        }

    } TRY_END(mem_guard);

    { // declaration block
        LONG close_result;
        if (RegistryKey) {
            close_result = RegCloseKey(
                RegistryKey);  // hkey
            assert(close_result == ERROR_SUCCESS);
        } // if
    } // declaration block

    return (ReturnCode);
} //Initialize

BOOL  
DeleteSockets(
    LPVOID              EnumCtx,
    LPWSHANDLE_CONTEXT  HContext
    ) {
    return ((PDPROCESS)EnumCtx)->DSocketDetach (HContext);
}

BOOL
DPROCESS::DSocketDetach (
    IN LPWSHANDLE_CONTEXT   HContext
    )
{
    PDSOCKET    Socket = static_cast<PDSOCKET>(HContext);
    //
    // Remove socket from the table, so no-one can find and reference
    // it again
    //
    Socket->DisassociateSocketHandle ();

    //
    // For non-IFS provider we force socket closure because provider
    // won't be able to find this socket anymore
    //
    if (!Socket->IsProviderSocket ()) {
        if (m_HandleHelper) {
            WahCloseSocketHandle (m_HandleHelper, Socket->GetSocketHandle ());
        }
    }

    //
    // Drop active reference on the socket.
    // No-one can find it anymore and thus no-one can call closesocket 
    // or WPUCloseSocket handle on it to remove active reference.
    //
    Socket->DropDSocketReference ();
    return TRUE;
}


BOOL
CleanupProtocolProviders (
    IN PVOID                PassBack,
    IN PPROTO_CATALOG_ITEM  CatalogEntry
    )
{
	PDPROVIDER		Provider;
    UNREFERENCED_PARAMETER (PassBack);

	Provider = CatalogEntry->GetProvider ();
	if (Provider!=NULL) {
		INT	ErrorCode, ReturnValue;
        //
        // Set exception handler around this call since we
        // hold critical section (catalog lock).
        //
        __try {
		    ReturnValue = Provider->WSPCleanup (&ErrorCode);
		    if (ReturnValue!=NO_ERROR) {
			    DEBUGF (DBG_WARN,
				    ("Calling provider %ls cleanup function, ret: %ld, err: %ld.\n",
				    CatalogEntry->GetProtocolInfo()->szProtocol,
				    ReturnValue,
				    ErrorCode));
		    }
        }
        __except (WS2_PROVIDER_EXCEPTION_FILTER ("WSPCleanup",
                                                 CatalogEntry->GetLibraryPath (),
                                                 CatalogEntry->GetProtocolInfo ()->szProtocol,
                                                 CatalogEntry->GetProviderId ())) {
        }
	}

	return TRUE;
}


BOOL
CleanupNamespaceProviders (
    IN PVOID                PassBack,
    IN PNSCATALOGENTRY      CatalogEntry
    )
{
	PNSPROVIDER		Provider;
    UNREFERENCED_PARAMETER (PassBack);

	Provider = CatalogEntry->GetProvider ();
	if (Provider!=NULL) {
		INT	ReturnValue;
        //
        // Set exception handler around this call since we
        // hold critical section (catalog lock).
        //
        __try {
    		ReturnValue = Provider->NSPCleanup ();
		    if (ReturnValue!=NO_ERROR) {
			    DEBUGF (DBG_WARN,
				    ("Calling provider %ls cleanup function, ret: %ld, err: %ld.\n",
				    CatalogEntry->GetProviderDisplayString (),
				    ReturnValue,
				    GetLastError ()));
		    }
        }
        __except (WS2_PROVIDER_EXCEPTION_FILTER ("NSPCleanup",
                                                 CatalogEntry->GetLibraryPath (),
                                                 CatalogEntry->GetProviderDisplayString (),
                                                 CatalogEntry->GetProviderId ())) {
        }
	}

	return TRUE;
}


DPROCESS::~DPROCESS()
/*++

Routine Description:

    DPROCESS  object  destructor.   This  procedure  has  the responsibility to
    perfrom any required shutdown operations for the DPROCESS object before the
    object  memory  is  deallocated.   The caller is required to do removal and
    destruction  of  all explicitly-attached objects (e.g., DPROVIDER, DSOCKET,
    DTHREAD).   Removal  or  shutdown  for  implicitly-attached  objects is the
    responsibility of this function.

Arguments:

    None

Return Value:

    None

--*/
{

    //
    // Check if initialization succeeded
    //
    if (!m_lock_initialized)
        return;

    sm_current_dprocess = NULL;

    //
    // Walk the list of sockets removing each socket from the list and
    // deleting the socket
    //

    if (DSOCKET::sm_context_table)
    {
        WahEnumerateHandleContexts (DSOCKET::sm_context_table,
                                    DeleteSockets,
                                    this
                                    );
    }


    //
    // this has been removed to eliminate the race with the thread
    // detach code  which also tries to delete the thread. It is
    // impossibe to use a mutex since holding up the thread detach
    // code ties up the PEB mutex.
    // Doing this delete is desirable as it cleans up
    // memory ASAP. The only trouble is it doesn't work -- do you
    // want it fast or do you want it right?
    //
#if 0
    while (!IsListEmpty(&m_thread_list)) {
        Thread = CONTAINING_RECORD(
            m_thread_list.Flink,
            DTHREAD,
            m_dprocess_linkage);
        DEBUGF(DBG_TRACE, ("Deleting thread\n"));
        DThreadDetach(Thread);
        delete(Thread);
    } //while
#endif

    // If we opened the async helper close it now
    if (m_ApcHelper) {
        DEBUGF(DBG_TRACE, ("Closing APC helper\n"));
        WahCloseApcHelper(m_ApcHelper);
    } //if

    // If we opened the handle helper close it now
    if (m_HandleHelper) {
        DEBUGF(DBG_TRACE, ("Closing Handle helper\n"));
        WahCloseHandleHelper(m_HandleHelper);
    } //if

    // If we opened the notification helper close it now
    if (m_NotificationHelper) {
        DEBUGF(DBG_TRACE, ("Closing Notification helper\n"));
        WahCloseNotificationHandleHelper(m_NotificationHelper);
    } //if

    // delete the protocol catalog and its change event if any. 
    if (m_protocol_catalog!=NULL) {
		// First call cleanup procedures of all loaded providers.
		m_protocol_catalog->EnumerateCatalogItems (
								CleanupProtocolProviders,	// Iteration
								NULL				        // Passback
								);
        //
        // Let other threads execute before removing catalog object
        // from under them. This is not fool-proof, but should
        // be sufficient in most normal cases - races of WSACleanup
        // against other winsock calls are not handled here, application
        // that excercises this should be prepared to handle invalid handle
        // exception anyway.
        //
        SwitchToThread ();
        delete(m_protocol_catalog);
        m_protocol_catalog = NULL;
    }

    if (m_proto_catalog_change_event != NULL) {

        CloseHandle (m_proto_catalog_change_event);
        m_proto_catalog_change_event = NULL;
    }

    // delete the name space catalog and its change event if any. 
    if (m_namespace_catalog!=NULL) {
		// First call cleanup procedures of all loaded providers.
		m_namespace_catalog->EnumerateCatalogItems (
								CleanupNamespaceProviders,	// Iteration
								NULL				        // Passback
								);
        //
        // Let other threads execute before removing catalog object
        // from under them. This is not fool-proof, but should
        // be sufficient in most normal cases - races of WSACleanup
        // against other winsock calls are not handled here, application
        // that excercises this should be prepared to handle invalid handle
        // exception anyway.
        //
        SwitchToThread ();
        delete(m_namespace_catalog);
        m_namespace_catalog = NULL;
    }

    if (m_ns_catalog_change_event != NULL) {

        CloseHandle (m_ns_catalog_change_event);
        m_ns_catalog_change_event = NULL;
    }

    // Clean up critical sections
    DeleteCriticalSection( &m_thread_list_lock );

} //~DPROCESS





INT
DPROCESS::DProcessClassInitialize(
    IN VOID
    )
/*++

Routine Description:

    Performs  global  initialization for the DPROCESS class.  In particular, it
    creates  the  global  DPROCESS  object  and  stores  it  in a static member
    variable.

Arguments:

    None

Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it returns an
    appropriate WinSock error code.

--*/
{
    INT ReturnCode=WSAEFAULT;
    PDPROCESS   process;

    assert( sm_current_dprocess == NULL );

    process = new(DPROCESS);
    if (process) {
        ReturnCode = process->Initialize();
        if (ReturnCode == ERROR_SUCCESS) {
            sm_current_dprocess = process;
        }
        else {
            DEBUGF( DBG_ERR,
                    ("Initializing dprocess object\n"));
            delete(process);
        }
    } //if
    else {
        DEBUGF( DBG_ERR,
                ("Allocating dprocess object\n"));
        ReturnCode = WSA_NOT_ENOUGH_MEMORY;
    } //else
    return(ReturnCode);
} //DProcessClassInitialize




INT
DPROCESS::OpenAsyncHelperDevice(
    OUT LPHANDLE HelperHandle
    )
/*++

Routine Description:

    Retrieves  the  opened  Async  Helper  device  ID  required  for processing
    callbacks  in  the  overlapped  I/O  model.   The operation opens the Async
    Helper device if necessary.

Arguments:

    HelperHandle - Returns the requested Async Helper device ID.

Return Value:

    The  function  returns ERROR_SUCESS if successful, otherwise it
    returns an appropriate WinSock error code.
--*/
{
    INT ReturnCode;

    // Protect from multiple opens
    LockDThreadList ();
    // If the helper device has not been opened yet for this process
    // lets go out and open it.
    if (m_ApcHelper || (WahOpenApcHelper(&m_ApcHelper) == 0)) {
        *HelperHandle = m_ApcHelper;
        ReturnCode = ERROR_SUCCESS;
    } //if
    else {
        DEBUGF( DBG_ERR, ("Opening APC helper\n"));
        ReturnCode = WSASYSCALLFAILURE;
    } //else
    UnLockDThreadList ();
    return(ReturnCode);
} //OpenAsyncHelperDevice



INT
DPROCESS::OpenHandleHelperDevice(
    OUT LPHANDLE HelperHandle
    )
/*++

Routine Description:

    Retrieves  the  opened  Handle  Helper  device  ID  required  for allocation
    of socket handles for non-IFS providers.   The operation opens the Handle
    Helper device if necessary.

Arguments:

    HelperHandle - Returns the requested Handle Helper device ID.

Return Value:

    The  function  returns ERROR_SUCESS if successful, otherwise it
    returns an appropriate WinSock error code.
--*/
{
    INT ReturnCode;

    // Protect from double opens
    LockDThreadList ();

    // If the helper device has not been opened yet for this process
    // lets go out and open it.
    if (m_HandleHelper || (WahOpenHandleHelper(&m_HandleHelper) == 0)) {
        *HelperHandle = m_HandleHelper;
        ReturnCode = ERROR_SUCCESS;
    } //if
    else {
        DEBUGF( DBG_ERR, ("Opening Handle helper\n"));
        ReturnCode = WSASYSCALLFAILURE;
    } //else
    UnLockDThreadList ();
    return(ReturnCode);
} //GetHandleHelperDeviceID


INT
DPROCESS::OpenNotificationHelperDevice(
    OUT LPHANDLE HelperHandle
    )
/*++

Routine Description:

    Retrieves  the  opened  Notification  Helper  device  ID  required  for allocation
    of notification handles for catalog change notification. 
    The operation opens the Notification Helper device if necessary.

Arguments:

    HelperHandle - Returns the requested Notification Helper device ID.

Return Value:

    The  function  returns ERROR_SUCESS if successful, otherwise it
    returns an appropriate WinSock error code.
--*/
{
    INT ReturnCode;

    // Protect from double opens
    LockDThreadList ();

    // If the helper device has not been opened yet for this process
    // lets go out and open it.
    if (m_NotificationHelper || (WahOpenNotificationHandleHelper(&m_NotificationHelper) == 0)) {
        *HelperHandle = m_NotificationHelper;
        ReturnCode = ERROR_SUCCESS;
    } //if
    else {
        DEBUGF( DBG_ERR, ("Opening Notification helper\n"));
        ReturnCode = WSASYSCALLFAILURE;
    } //else
    UnLockDThreadList ();
    return(ReturnCode);
} //OpenNotificationHelperDevice


VOID
DPROCESS::SetVersion( WORD Version )
/*++

Routine Description:

    This function sets the WinSock version number for this process.

Arguments:

    Version - The WinSock version number.

Return Value:

    None.

--*/
{

    WORD newMajor;
    WORD newMinor;

    assert(Version != 0);

    newMajor = LOBYTE( Version );
    newMinor = HIBYTE( Version );

    //
    // If the version number is getting downgraded from a previous
    // setting, save the new (updated) number.
    //

    if( newMajor < GetMajorVersion() ||
        ( newMajor == GetMajorVersion() &&
          newMinor < GetMinorVersion() ) ) {

        m_version = Version;

    }

} // SetVersion


PDCATALOG
DPROCESS::GetProtocolCatalog()
/*++

Routine Description:
    Returns the protocol catalog associated with the process object.

Arguments:

    None

Return Value:

    The value of m_protocol_catalog
--*/
{
    if (HasCatalogChanged (m_proto_catalog_change_event))
        m_protocol_catalog->RefreshFromRegistry (m_proto_catalog_change_event);
    return(m_protocol_catalog);
}


PNSCATALOG
DPROCESS::GetNamespaceCatalog()
/*++

Routine Description:
    Returns the namespace catalog associated with the process object.

Arguments:

    None

Return Value:

    The value of m_namespace_catalog
--*/
{
    if (HasCatalogChanged (m_ns_catalog_change_event))
        m_namespace_catalog->RefreshFromRegistry (m_ns_catalog_change_event);
    return(m_namespace_catalog);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\dthook.cpp ===
/*++

  Copyright (c) 1995 Intel Corp

  Module Name:

    dthook.cpp

  Abstract:

    This module contains the hooks that allow specially-compiled
    versions of the WinSock 2 DLL call into the debug/trace DLL.

    For each function in the WinSock 2 API, this module has a hook
    function called DT_<function>, which, if WinSock 2 is compiled
    with the DEBUG_TRACING symbol defined, is exported under the name
    of the original function.  The hook function calls into the
    debug/trace DLL through the two entry points,
    WSA[Pre|Post]ApiNotify, which are wrapped around the real call to
    the API function.  Please see the debug/trace documentation for
    more details.

  Author:

    Michael A. Grafton

--*/

#include "precomp.h"

#if defined(DEBUG_TRACING)

//
// Static Globals
//

// Function pointers to the Debug/Trace DLL entry points
static LPFNWSANOTIFY PreApiNotifyFP = NULL;
static LPFNWSANOTIFY PostApiNotifyFP = NULL;
static LPFNWSAEXCEPTIONNOTIFY ExceptionNotifyFP = NULL;

// Handle to the Debug/Trace DLL module
static HMODULE       DTDll = NULL;
// Lock that facilitates module initialization on demand
// instead of doing this inside of DLLMain
static CRITICAL_SECTION DTHookSynchronization;
static BOOL          DTHookInitialized = FALSE;

// Static string to pass to Debug/Trace notification functions --
// The value of this variable should never be changed; however, the
// keyword 'const' causes bizarre compilation errors...
static char LibName[] = "WinSock2";


//
// Goodies to make it easier to catch exceptions in WS2_32.DLL and the
// service providers.
//

extern "C" {

LONG
DtExceptionFilter(
    LPEXCEPTION_POINTERS ExceptionPointers,
    LPSTR Routine
    );

} // extern "C"

// From ntrtl.h
extern "C" {

typedef USHORT (WINAPI * LPFNRTLCAPTURESTACKBACKTRACE) (
   IN ULONG FramesToSkip,
   IN ULONG FramesToCapture,
   OUT PVOID *BackTrace,
   OUT PULONG BackTraceHash OPTIONAL
   );


// Stack backtrace function pointer available on NT
LPFNRTLCAPTURESTACKBACKTRACE pRtlCaptureStackBackTrace = NULL;

#define RECORD_SOCKET_CREATOR(s)                                            \
    if ((s!=INVALID_SOCKET) &&                                              \
            (pRtlCaptureStackBackTrace!=NULL)) {                            \
        PDSOCKET    socket;                                                 \
        socket = DSOCKET::GetCountedDSocketFromSocketNoExport(s);           \
        if (socket!=NULL) {                                                 \
            for (INT _i=0; _i <sizeof (socket->m_CreatorBackTrace)/         \
                               sizeof (socket->m_CreatorBackTrace[0]); _i++)\
                socket->m_CreatorBackTrace[_i] = NULL;                      \
            pRtlCaptureStackBackTrace(                                      \
                        1,                                                  \
                        sizeof (socket->m_CreatorBackTrace) /               \
                            sizeof (socket->m_CreatorBackTrace[0]),         \
                        &socket->m_CreatorBackTrace[0],                     \
                        NULL);                                              \
            socket->DropDSocketReference ();                                \
        }                                                                   \
    }
} // extern "C"


VOID
DoDTHookInitialization (
    VOID
    );

#ifndef NOTHING
#define NOTHING
#endif

#define INVOKE_ROUTINE(routine)                                         \
            __try {                                                     \
                routine                                                 \
            } __except( DtExceptionFilter(                              \
                        GetExceptionInformation (),                     \
                        #routine                                        \
                        ) ) {                                           \
                NOTHING;                                                \
            }


//
// Functions
//


LPFNWSANOTIFY
GetPreApiNotifyFP(void)
/*++

  Function Description:

      Returns a pointer to the WSAPreApiNotify function exported by
      the Debug/Trace DLL.  This variable is global to this file only,
      and is initialized during DT_Initialize().

  Arguments:

      None.

  Return Value:

      Returns whatever is stored in PreApiNotifyFP.

--*/
{
    if (!DTHookInitialized) {
        DoDTHookInitialization ();
    }
    return(PreApiNotifyFP);
}





LPFNWSANOTIFY
GetPostApiNotifyFP(void)
/*++

  Function Description:

      Returns a pointer to the WSAPreApiNotify function exported by
      the Debug/Trace DLL.  This variable is global to this file only,
      and is initialized during DT_Initialize().

  Arguments:

      None.

  Return Value:

      Returns whatever is stored in PreApiNotifyFP.

--*/
{
    if (!DTHookInitialized) {
        DoDTHookInitialization ();
    }
    return(PostApiNotifyFP);
}





void
DTHookInitialize(void)
/*++

  Function Description:

      This function must be called from DLLMain to let
      this module initialize its critical section that protects
      the initialization below.

  Arguments:

      None.

  Return Value:

      None.

--*/
{
    InitializeCriticalSection (&DTHookSynchronization);
}

VOID
DoDTHookInitialization (
    VOID
    )
/*++

  Function Description:

      Intializes this hook module.  Loads the Debug/Trace DLL, if
      possible, and sets the global function pointers to point to the
      entry points exported by that DLL.  If the DLL can't be loaded,
      the function just returns and the function pointers are left at
      NULL.

      This function MUST be called before any of the hook functions
      are called, or the hook functions will not work.

  Arguments:

      None.

  Return Value:

      None.

--*/
{
    EnterCriticalSection (&DTHookSynchronization);
    if (!DTHookInitialized) {
        //
        // If we are running on NT, get pointer to stack back
        // trace recording function and keep record of socket creators
        //
        HMODULE hNtDll;

        hNtDll = GetModuleHandle (TEXT("ntdll.dll"));
        if (hNtDll!=NULL) {
            pRtlCaptureStackBackTrace = 
                (LPFNRTLCAPTURESTACKBACKTRACE)GetProcAddress (
                                                hNtDll,
                                                "RtlCaptureStackBackTrace");
        }


        DTDll = (HMODULE)LoadLibrary("dt_dll");

        if (DTDll != NULL) {

            PreApiNotifyFP = (LPFNWSANOTIFY)GetProcAddress(
                DTDll,
                "WSAPreApiNotify");

            PostApiNotifyFP = (LPFNWSANOTIFY)GetProcAddress(
                DTDll,
                "WSAPostApiNotify");

            ExceptionNotifyFP = (LPFNWSAEXCEPTIONNOTIFY)GetProcAddress(
                DTDll,
                "WSAExceptionNotify");
        }
        DTHookInitialized = TRUE;
    }
    LeaveCriticalSection (&DTHookSynchronization);
}



void
DTHookShutdown(void)
/*++

  Function Description:

      Should be called to shutdown Debug/Tracing.  The function
      pointers are set to NULL, and the DLL is unloaded from memory.

  Arguments:

      None.

  Return Value:

      None.

--*/
{
    if ((DTDll != NULL && DTDll!=INVALID_HANDLE_VALUE)) {
        FreeLibrary(DTDll);
    }

    PreApiNotifyFP = NULL;
    PostApiNotifyFP = NULL;
    DTHookInitialized = FALSE;
    DeleteCriticalSection (&DTHookSynchronization);
}


//
// Hook Functions for WinSock2 API.
//

// This comment serves as a function comment for all the hook
// functions.  There  is  one hook function for each function exported
// by the WinSock 2 API.  Each hook  function has the exact same
// parameter profile of the corresponding API function.   Each one
// calls PREAPINOTIFY and POSTAPINOTIFY macros, which call into   the
// Debug/Trace   DLL,   if  it  was  loaded  successfully.   After
// PREAPINOTIFY,  the  hook  functions  call  the  real WS2 functions.
// See the Debug/Trace documentation for more information.
//
// Note  that  all of the debug-hook functions must be declared with C
// language binding, while the internally-used initialization and
// utility functions must not be.

extern "C" {


#ifdef _X86_
#pragma optimize("y", off)  // Make sure we can at least get the caller.
#endif

SOCKET WSAAPI
DTHOOK_accept (
    SOCKET s,
    struct sockaddr FAR *addr,
    int FAR *addrlen)
{
    SOCKET ReturnValue=INVALID_SOCKET;

    if (PREAPINOTIFY((DTCODE_accept,
                       &ReturnValue,
                       LibName,
                       &s,
                       &addr,
                       &addrlen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = accept(s, addr, addrlen);
        );

    RECORD_SOCKET_CREATOR(ReturnValue);

    POSTAPINOTIFY((DTCODE_accept,
                    &ReturnValue,
                    LibName,
                    &s,
                    &addr,
                    &addrlen));

    return(ReturnValue);
}
#ifdef _X86_
#pragma optimize("", on)
#endif



int WSAAPI
DTHOOK_bind (
    SOCKET s,
    const struct sockaddr FAR *name,
    int namelen)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_bind,
                       &ReturnValue,
                       LibName,
                       &s,
                       &name,
                       &namelen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = bind(s, name, namelen);
        );

    POSTAPINOTIFY((DTCODE_bind,
                    &ReturnValue,
                    LibName,
                    &s,
                    &name,
                    &namelen));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_closesocket (
    SOCKET s)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_closesocket,
                       &ReturnValue,
                       LibName,
                       &s))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = closesocket(s);
        );

    POSTAPINOTIFY((DTCODE_closesocket,
                    &ReturnValue,
                    LibName,
                    &s));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_connect (
    SOCKET s,
    const struct sockaddr FAR *name,
    int namelen)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_connect,
                       &ReturnValue,
                       LibName,
                       &s,
                       &name,
                       &namelen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = connect(s, name, namelen);
        );

    POSTAPINOTIFY((DTCODE_connect,
                    &ReturnValue,
                    LibName,
                    &s,
                    &name,
                    &namelen));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_ioctlsocket (
    SOCKET s,
    long cmd,
    u_long FAR *argp)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_ioctlsocket,
                       &ReturnValue,
                       LibName,
                       &s,
                       &cmd,
                       &argp))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = ioctlsocket(s, cmd, argp);
        );

    POSTAPINOTIFY((DTCODE_ioctlsocket,
                    &ReturnValue,
                    LibName,
                    &s,
                    &cmd,
                    &argp));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_getpeername (
    SOCKET s,
    struct sockaddr FAR *name,
    int FAR * namelen)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_getpeername,
                       &ReturnValue,
                       LibName,
                       &s,
                       &name,
                       &namelen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = getpeername(s, name, namelen);
        );

    POSTAPINOTIFY((DTCODE_getpeername,
                    &ReturnValue,
                    LibName,
                    &s,
                    &name,
                    &namelen));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_getsockname (
    SOCKET s,
    struct sockaddr FAR *name,
    int FAR * namelen)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_getsockname,
                       &ReturnValue,
                       LibName,
                       &s,
                       &name,
                       &namelen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = getsockname(s, name, namelen);
        );

    POSTAPINOTIFY((DTCODE_getsockname,
                    &ReturnValue,
                    LibName,
                    &s,
                    &name,
                    &namelen));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_getsockopt (
    SOCKET s,
    int level,
    int optname,
    char FAR * optval,
    int FAR *optlen)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_getsockopt,
                       &ReturnValue,
                       LibName,
                       &s,
                       &level,
                       &optname,
                       &optval,
                       &optlen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = getsockopt(s, level, optname, optval, optlen);
        );

    POSTAPINOTIFY((DTCODE_getsockopt,
                    &ReturnValue,
                    LibName,
                    &s,
                    &level,
                    &optname,
                    &optval,
                    &optlen));

    return(ReturnValue);
}




u_long WSAAPI
DTHOOK_htonl (
    u_long hostlong)
{
    u_long ReturnValue=0;

    if (PREAPINOTIFY((DTCODE_htonl,
                       &ReturnValue,
                       LibName,
                       &hostlong))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = htonl(hostlong);
        );

    POSTAPINOTIFY((DTCODE_htonl,
                    &ReturnValue,
                    LibName,
                    &hostlong));

    return(ReturnValue);
}




u_short WSAAPI
DTHOOK_htons (
    u_short hostshort)
{
    u_short ReturnValue=0;

    if (PREAPINOTIFY((DTCODE_htons,
                       &ReturnValue,
                       LibName,
                       &hostshort))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = htons(hostshort);
        );

    POSTAPINOTIFY((DTCODE_htons,
                    &ReturnValue,
                    LibName,
                    &hostshort));

    return(ReturnValue);
}




unsigned long WSAAPI
DTHOOK_inet_addr (
    const char FAR * cp)
{
    unsigned long ReturnValue=INADDR_NONE;

    if (PREAPINOTIFY((DTCODE_inet_addr,
                       &ReturnValue,
                       LibName,
                       &cp))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = inet_addr(cp);
        );

    POSTAPINOTIFY((DTCODE_inet_addr,
                    &ReturnValue,
                    LibName,
                    &cp));

    return(ReturnValue);
}




char FAR * WSAAPI
DTHOOK_inet_ntoa (
    struct in_addr in)
{
    char FAR *ReturnValue=NULL;

    if (PREAPINOTIFY((DTCODE_inet_ntoa,
                       &ReturnValue,
                       LibName,
                       &in))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = inet_ntoa(in);
        );

    POSTAPINOTIFY((DTCODE_inet_ntoa,
                    &ReturnValue,
                    LibName,
                    &in));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_listen (
    SOCKET s,
    int backlog)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_listen,
                       &ReturnValue,
                       LibName,
                       &s,
                       &backlog))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = listen(s, backlog);
        );

    POSTAPINOTIFY((DTCODE_listen,
                    &ReturnValue,
                    LibName,
                    &s,
                    &backlog));

    return(ReturnValue);
}




u_long WSAAPI
DTHOOK_ntohl (
    u_long netlong)
{
    u_long ReturnValue=0;

    if (PREAPINOTIFY((DTCODE_ntohl,
                       &ReturnValue,
                       LibName,
                       &netlong))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = ntohl(netlong);
        );

    POSTAPINOTIFY((DTCODE_ntohl,
                    &ReturnValue,
                    LibName,
                    &netlong));

    return(ReturnValue);
}




u_short WSAAPI
DTHOOK_ntohs (
    u_short netshort)
{
    u_short ReturnValue=0;

    if (PREAPINOTIFY((DTCODE_ntohs,
                       &ReturnValue,
                       LibName,
                       &netshort))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = ntohs(netshort);
        );

    POSTAPINOTIFY((DTCODE_ntohs,
                    &ReturnValue,
                    LibName,
                    &netshort));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_recv (
    SOCKET s,
    char FAR * buf,
    int len,
    int flags)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_recv,
                       &ReturnValue,
                       LibName,
                       &s,
                       &buf,
                       &len,
                       &flags))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = recv(s, buf, len, flags);
        );

    POSTAPINOTIFY((DTCODE_recv,
                    &ReturnValue,
                    LibName,
                    &s,
                    &buf,
                    &len,
                    &flags));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_recvfrom (
    SOCKET s,
    char FAR * buf,
    int len,
    int flags,
    struct sockaddr FAR *from,
    int FAR * fromlen)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_recvfrom,
                       &ReturnValue,
                       LibName,
                       &s,
                       &buf,
                       &len,
                       &flags,
                       &from,
                       &fromlen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = recvfrom(s, buf, len, flags, from, fromlen);
        );

    POSTAPINOTIFY((DTCODE_recvfrom,
                    &ReturnValue,
                    LibName,
                    &s,
                    &buf,
                    &len,
                    &flags,
                    &from,
                    &fromlen));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_select (
    int nfds,
    fd_set FAR *readfds,
    fd_set FAR *writefds,
    fd_set FAR *exceptfds,
    const struct timeval FAR *timeout)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_select,
                       &ReturnValue,
                       LibName,
                       &nfds,
                       &readfds,
                       &writefds,
                       &exceptfds,
                       &timeout))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = select(nfds, readfds, writefds, exceptfds, timeout);
        );

    POSTAPINOTIFY((DTCODE_select,
                    &ReturnValue,
                    LibName,
                    &nfds,
                    &readfds,
                    &writefds,
                    &exceptfds,
                    &timeout));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_send (
    SOCKET s,
    const char FAR * buf,
    int len,
    int flags)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_send,
                       &ReturnValue,
                       LibName,
                       &s,
                       &buf,
                       &len,
                       &flags))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = send(s, buf, len, flags);
        );

    POSTAPINOTIFY((DTCODE_send,
                    &ReturnValue,
                    LibName,
                    &s,
                    &buf,
                    &len,
                    &flags));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_sendto (
    SOCKET s,
    const char FAR * buf,
    int len,
    int flags,
    const struct sockaddr FAR *to,
    int tolen)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_sendto,
                       &ReturnValue,
                       LibName,
                       &s,
                       &buf,
                       &len,
                       &flags,
                       &to,
                       &tolen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = sendto(s, buf, len, flags, to, tolen);
        );

    POSTAPINOTIFY((DTCODE_sendto,
                    &ReturnValue,
                    LibName,
                    &s,
                    &buf,
                    &len,
                    &flags,
                    &to,
                    &tolen));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_setsockopt (
    SOCKET s,
    int level,
    int optname,
    const char FAR * optval,
    int optlen)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_setsockopt,
                       &ReturnValue,
                       LibName,
                       &s,
                       &level,
                       &optname,
                       &optval,
                       &optlen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = setsockopt(s, level, optname, optval, optlen);
        );

    POSTAPINOTIFY((DTCODE_setsockopt,
                    &ReturnValue,
                    LibName,
                    &s,
                    &level,
                    &optname,
                    &optval,
                    &optlen));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_shutdown (
    SOCKET s,
    int how)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_shutdown,
                       &ReturnValue,
                       LibName,
                       &s,
                       &how))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = shutdown(s, how);
        );

    POSTAPINOTIFY((DTCODE_shutdown,
                    &ReturnValue,
                    LibName,
                    &s,
                    &how));

    return(ReturnValue);
}




#ifdef _X86_
#pragma optimize("y", off)  // Make sure we can at least get the caller.
#endif

SOCKET WSAAPI
DTHOOK_socket (
    int af,
    int type,
    int protocol)
{
    SOCKET ReturnValue=INVALID_SOCKET;

    if (PREAPINOTIFY((DTCODE_socket,
                       &ReturnValue,
                       LibName,
                       &af,
                       &type,
                       &protocol))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = socket(af, type, protocol);
        );

    RECORD_SOCKET_CREATOR(ReturnValue);

    POSTAPINOTIFY((DTCODE_socket,
                    &ReturnValue,
                    LibName,
                    &af,
                    &type,
                    &protocol));

    return(ReturnValue);
}
#ifdef _X86_
#pragma optimize("", on)
#endif



#ifdef _X86_
#pragma optimize("y", off)  // Make sure we can at least get the caller.
#endif

SOCKET WSAAPI
DTHOOK_WSAAccept (
    SOCKET s,
    struct sockaddr FAR *addr,
    LPINT addrlen,
    LPCONDITIONPROC lpfnCondition,
    DWORD dwCallbackData)
{
    SOCKET ReturnValue=INVALID_SOCKET;

    if (PREAPINOTIFY((DTCODE_WSAAccept,
                       &ReturnValue,
                       LibName,
                       &s,
                       &addr,
                       &addrlen,
                       &lpfnCondition,
                       &dwCallbackData))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAAccept(s, addr, addrlen, lpfnCondition,
                                dwCallbackData);
        );

    RECORD_SOCKET_CREATOR(ReturnValue);

    POSTAPINOTIFY((DTCODE_WSAAccept,
                    &ReturnValue,
                    LibName,
                    &s,
                    &addr,
                    &addrlen,
                    &lpfnCondition,
                    &dwCallbackData));

    return(ReturnValue);
}
#ifdef _X86_
#pragma optimize("", on)
#endif



int WSAAPI
DTHOOK_WSAAsyncSelect(
    SOCKET s,
    HWND hWnd,
    u_int wMsg,
    long lEvent)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSAAsyncSelect,
                       &ReturnValue,
                       LibName,
                       &s,
                       &hWnd,
                       &wMsg,
                       &lEvent))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAAsyncSelect(s, hWnd, wMsg, lEvent);
        );

    POSTAPINOTIFY((DTCODE_WSAAsyncSelect,
                    &ReturnValue,
                    LibName,
                    &s,
                    &hWnd,
                    &wMsg,
                    &lEvent));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSACleanup(
    void)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSACleanup,
                       &ReturnValue,
                       LibName))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSACleanup();
        );

    POSTAPINOTIFY((DTCODE_WSACleanup,
                    &ReturnValue,
                    LibName));

    return(ReturnValue);
}




BOOL WSAAPI
DTHOOK_WSACloseEvent (
    WSAEVENT hEvent)
{
    BOOL ReturnValue=FALSE;

    if (PREAPINOTIFY((DTCODE_WSACloseEvent,
                       &ReturnValue,
                       LibName,
                       &hEvent))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSACloseEvent(hEvent);
        );

    POSTAPINOTIFY((DTCODE_WSACloseEvent,
                    &ReturnValue,
                    LibName,
                    &hEvent));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSAConnect (
    SOCKET s,
    const struct sockaddr FAR *name,
    int namelen,
    LPWSABUF lpCallerData,
    LPWSABUF lpCalleeData,
    LPQOS lpSQOS,
    LPQOS lpGQOS)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSAConnect,
                       &ReturnValue,
                       LibName,
                       &s,
                       &name,
                       &namelen,
                       &lpCallerData,
                       &lpCalleeData,
                       &lpSQOS,
                       &lpGQOS))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAConnect(s, name, namelen, lpCallerData, lpCalleeData,
                                 lpSQOS, lpGQOS);
        );

    POSTAPINOTIFY((DTCODE_WSAConnect,
                    &ReturnValue,
                    LibName,
                    &s,
                    &name,
                    &namelen,
                    &lpCallerData,
                    &lpCalleeData,
                    &lpSQOS,
                    &lpGQOS));

    return(ReturnValue);
}




WSAEVENT WSAAPI
DTHOOK_WSACreateEvent (
    void)
{
    WSAEVENT ReturnValue=WSA_INVALID_EVENT;

    if (PREAPINOTIFY((DTCODE_WSACreateEvent,
                       &ReturnValue,
                       LibName))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSACreateEvent();
        );

    POSTAPINOTIFY((DTCODE_WSACreateEvent,
                    &ReturnValue,
                    LibName));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSADuplicateSocketA (
    SOCKET s,
    DWORD dwProcessId,
    LPWSAPROTOCOL_INFOA lpProtocolInfo)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSADuplicateSocketA,
                       &ReturnValue,
                       LibName,
                       &s,
                       &dwProcessId,
                       &lpProtocolInfo))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSADuplicateSocketA(s, dwProcessId, lpProtocolInfo);
        );

    POSTAPINOTIFY((DTCODE_WSADuplicateSocketA,
                    &ReturnValue,
                    LibName,
                    &s,
                    &dwProcessId,
                    &lpProtocolInfo));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSADuplicateSocketW (
    SOCKET s,
    DWORD dwProcessId,
    LPWSAPROTOCOL_INFOW lpProtocolInfo)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSADuplicateSocketW,
                       &ReturnValue,
                       LibName,
                       &s,
                       &dwProcessId,
                       &lpProtocolInfo))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSADuplicateSocketW(s, dwProcessId, lpProtocolInfo);
        );

    POSTAPINOTIFY((DTCODE_WSADuplicateSocketW,
                    &ReturnValue,
                    LibName,
                    &s,
                    &dwProcessId,
                    &lpProtocolInfo));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSAEnumNetworkEvents (
    SOCKET s,
    WSAEVENT hEventObject,
    LPWSANETWORKEVENTS lpNetworkEvents)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSAEnumNetworkEvents,
                       &ReturnValue,
                       LibName,
                       &s,
                       &hEventObject,
                       &lpNetworkEvents))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAEnumNetworkEvents(s, hEventObject, lpNetworkEvents);
        );

    POSTAPINOTIFY((DTCODE_WSAEnumNetworkEvents,
                    &ReturnValue,
                    LibName,
                    &s,
                    &hEventObject,
                    &lpNetworkEvents));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSAEnumProtocolsA (
    LPINT lpiProtocols,
    LPWSAPROTOCOL_INFOA lpProtocolBuffer,
    LPDWORD lpdwBufferLength)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSAEnumProtocolsA,
                       &ReturnValue,
                       LibName,
                       &lpiProtocols,
                       &lpProtocolBuffer,
                       &lpdwBufferLength))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAEnumProtocolsA(lpiProtocols, lpProtocolBuffer,
                                        lpdwBufferLength);
        );

    POSTAPINOTIFY((DTCODE_WSAEnumProtocolsA,
                    &ReturnValue,
                    LibName,
                    &lpiProtocols,
                    &lpProtocolBuffer,
                    &lpdwBufferLength));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSAEnumProtocolsW (
    LPINT lpiProtocols,
    LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    LPDWORD lpdwBufferLength)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSAEnumProtocolsW,
                       &ReturnValue,
                       LibName,
                       &lpiProtocols,
                       &lpProtocolBuffer,
                       &lpdwBufferLength))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAEnumProtocolsW(lpiProtocols, lpProtocolBuffer,
                                        lpdwBufferLength);
        );

    POSTAPINOTIFY((DTCODE_WSAEnumProtocolsW,
                    &ReturnValue,
                    LibName,
                    &lpiProtocols,
                    &lpProtocolBuffer,
                    &lpdwBufferLength));

    return(ReturnValue);
}





int WSPAPI
DTHOOK_WSCEnumProtocols (
    LPINT lpiProtocols,
    LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    LPDWORD lpdwBufferLength,
    LPINT  lpErrno)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSCEnumProtocols,
                       &ReturnValue,
                       LibName,
                       &lpiProtocols,
                       &lpProtocolBuffer,
                       &lpdwBufferLength,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCEnumProtocols(lpiProtocols, lpProtocolBuffer,
                                       lpdwBufferLength, lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WSCEnumProtocols,
                    &ReturnValue,
                    LibName,
                    &lpiProtocols,
                    &lpProtocolBuffer,
                    &lpdwBufferLength,
                    &lpErrno));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSAEventSelect (
    SOCKET s,
    WSAEVENT hEventObject,
    long lNetworkEvents)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSAEventSelect,
                       &ReturnValue,
                       LibName,
                       &s,
                       &hEventObject,
                       &lNetworkEvents))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAEventSelect(s, hEventObject, lNetworkEvents);
        );

    POSTAPINOTIFY((DTCODE_WSAEventSelect,
                    &ReturnValue,
                    LibName,
                    &s,
                    &hEventObject,
                    &lNetworkEvents));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSAGetLastError(
    void)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSAGetLastError,
                       &ReturnValue,
                       LibName))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAGetLastError();
        );

    POSTAPINOTIFY((DTCODE_WSAGetLastError,
                    &ReturnValue,
                    LibName));

    return(ReturnValue);
}




BOOL WSAAPI
DTHOOK_WSAGetOverlappedResult (
    SOCKET s,
    LPWSAOVERLAPPED lpOverlapped,
    LPDWORD lpcbTransfer,
    BOOL fWait,
    LPDWORD lpdwFlags)
{
    BOOL ReturnValue=FALSE;

    if (PREAPINOTIFY((DTCODE_WSAGetOverlappedResult,
                       &ReturnValue,
                       LibName,
                       &s,
                       &lpOverlapped,
                       &lpcbTransfer,
                       &fWait,
                       &lpdwFlags))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAGetOverlappedResult(s, lpOverlapped, lpcbTransfer,
                                             fWait, lpdwFlags);
        );

    POSTAPINOTIFY((DTCODE_WSAGetOverlappedResult,
                    &ReturnValue,
                    LibName,
                    &s,
                    &lpOverlapped,
                    &lpcbTransfer,
                    &fWait,
                    &lpdwFlags));

    return(ReturnValue);
}




BOOL WSAAPI
DTHOOK_WSAGetQOSByName (
    SOCKET s,
    LPWSABUF lpQOSName,
    LPQOS lpQOS)
{
    BOOL ReturnValue=FALSE;

    if (PREAPINOTIFY((DTCODE_WSAGetQOSByName,
                       &ReturnValue,
                       LibName,
                       &s,
                       &lpQOSName,
                       &lpQOS))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAGetQOSByName(s, lpQOSName, lpQOS);
        );

    POSTAPINOTIFY((DTCODE_WSAGetQOSByName,
                    &ReturnValue,
                    LibName,
                    &s,
                    &lpQOSName,
                    &lpQOS));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSAHtonl (
    SOCKET s,
    u_long hostlong,
    u_long FAR * lpnetlong)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSAHtonl,
                       &ReturnValue,
                       LibName,
                       &s,
                       &hostlong,
                       &lpnetlong))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAHtonl(s, hostlong, lpnetlong);
        );

    POSTAPINOTIFY((DTCODE_WSAHtonl,
                    &ReturnValue,
                    LibName,
                    &s,
                    &hostlong,
                    &lpnetlong));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSAHtons (
    SOCKET s,
    u_short hostshort,
    u_short FAR * lpnetshort)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSAHtons,
                       &ReturnValue,
                       LibName,
                       &s,
                       &hostshort,
                       &lpnetshort))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAHtons(s, hostshort, lpnetshort);
        );

    POSTAPINOTIFY((DTCODE_WSAHtons,
                    &ReturnValue,
                    LibName,
                    &s,
                    &hostshort,
                    &lpnetshort));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSAIoctl (
    SOCKET s,
    DWORD dwIoControlCode,
    LPVOID lpvInBuffer,
    DWORD cbInBuffer,
    LPVOID lpvOutBuffer,
    DWORD cbOutBuffer,
    LPDWORD lpcbBytesReturned,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSAIoctl,
                       &ReturnValue,
                       LibName,
                       &s,
                       &dwIoControlCode,
                       &lpvInBuffer,
                       &cbInBuffer,
                       &lpvOutBuffer,
                       &cbOutBuffer,
                       &lpcbBytesReturned,
                       &lpOverlapped,
                       &lpCompletionRoutine))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAIoctl(s, dwIoControlCode, lpvInBuffer, cbInBuffer,
                               lpvOutBuffer, cbOutBuffer, lpcbBytesReturned,
                               lpOverlapped, lpCompletionRoutine);
        );

    POSTAPINOTIFY((DTCODE_WSAIoctl,
                    &ReturnValue,
                    LibName,
                    &s,
                    &dwIoControlCode,
                    &lpvInBuffer,
                    &cbInBuffer,
                    &lpvOutBuffer,
                    &cbOutBuffer,
                    &lpcbBytesReturned,
                    &lpOverlapped,
                    &lpCompletionRoutine));

    return(ReturnValue);
}




#ifdef _X86_
#pragma optimize("y", off)  // Make sure we can at least get the caller.
#endif

SOCKET WSAAPI
DTHOOK_WSAJoinLeaf (
    SOCKET s,
    const struct sockaddr FAR * name,
    int namelen,
    LPWSABUF lpCallerData,
    LPWSABUF lpCalleeData,
    LPQOS lpSQOS,
    LPQOS lpGQOS,
    DWORD dwFlags)
{
    SOCKET ReturnValue=INVALID_SOCKET;

    if (PREAPINOTIFY((DTCODE_WSAJoinLeaf,
                       &ReturnValue,
                       LibName,
                       &s,
                       &name,
                       &namelen,
                       &lpCallerData,
                       &lpCalleeData,
                       &lpSQOS,
                       &lpGQOS,
                       &dwFlags))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAJoinLeaf(s, name, namelen, lpCallerData, lpCalleeData,
                                  lpSQOS, lpGQOS, dwFlags);
        );

    if (ReturnValue!=s) {
        RECORD_SOCKET_CREATOR(ReturnValue);
    }

    POSTAPINOTIFY((DTCODE_WSAJoinLeaf,
                    &ReturnValue,
                    LibName,
                    &s,
                    &name,
                    &namelen,
                    &lpCallerData,
                    &lpCalleeData,
                    &lpSQOS,
                    &lpGQOS,
                    &dwFlags));

    return(ReturnValue);
}
#ifdef _X86_
#pragma optimize("", on)
#endif



int WSAAPI
DTHOOK_WSANtohl (
    SOCKET s,
    u_long netlong,
    u_long FAR * lphostlong)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSANtohl,
                       &ReturnValue,
                       LibName,
                       &s,
                       &netlong,
                       &lphostlong))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSANtohl(s, netlong, lphostlong);
        );

    POSTAPINOTIFY((DTCODE_WSANtohl,
                    &ReturnValue,
                    LibName,
                    &s,
                    &netlong,
                    &lphostlong));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSANtohs (
    SOCKET s,
    u_short netshort,
    u_short FAR * lphostshort)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSANtohs,
                       &ReturnValue,
                       LibName,
                       &s,
                       &netshort,
                       &lphostshort))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSANtohs(s, netshort, lphostshort);
        );

    POSTAPINOTIFY((DTCODE_WSANtohs,
                    &ReturnValue,
                    LibName,
                    &s,
                    &netshort,
                    &lphostshort));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSARecv (
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesRecvd,
    LPDWORD lpFlags,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSARecv,
                       &ReturnValue,
                       LibName,
                       &s,
                       &lpBuffers,
                       &dwBufferCount,
                       &lpNumberOfBytesRecvd,
                       &lpFlags,
                       &lpOverlapped,
                       &lpCompletionRoutine))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSARecv(s, lpBuffers, dwBufferCount, lpNumberOfBytesRecvd,
                              lpFlags, lpOverlapped, lpCompletionRoutine);
        );

    POSTAPINOTIFY((DTCODE_WSARecv,
                    &ReturnValue,
                    LibName,
                    &s,
                    &lpBuffers,
                    &dwBufferCount,
                    &lpNumberOfBytesRecvd,
                    &lpFlags,
                    &lpOverlapped,
                    &lpCompletionRoutine));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSARecvDisconnect (
    SOCKET s,
    LPWSABUF lpInboundDisconnectData)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSARecvDisconnect,
                       &ReturnValue,
                       LibName,
                       &s,
                       &lpInboundDisconnectData))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSARecvDisconnect(s, lpInboundDisconnectData);
        );

    POSTAPINOTIFY((DTCODE_WSARecvDisconnect,
                    &ReturnValue,
                    LibName,
                    &s,
                    &lpInboundDisconnectData));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSARecvFrom (
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesRecvd,
    LPDWORD lpFlags,
    struct sockaddr FAR * lpFrom,
    LPINT lpFromlen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSARecvFrom,
                       &ReturnValue,
                       LibName,
                       &s,
                       &lpBuffers,
                       &dwBufferCount,
                       &lpNumberOfBytesRecvd,
                       &lpFlags,
                       &lpFrom,
                       &lpFromlen,
                       &lpOverlapped,
                       &lpCompletionRoutine))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSARecvFrom(s, lpBuffers, dwBufferCount,
                                  lpNumberOfBytesRecvd, lpFlags, lpFrom,
                                  lpFromlen, lpOverlapped,
                                  lpCompletionRoutine);
        );

    POSTAPINOTIFY((DTCODE_WSARecvFrom,
                    &ReturnValue,
                    LibName,
                    &s,
                    &lpBuffers,
                    &dwBufferCount,
                    &lpNumberOfBytesRecvd,
                    &lpFlags,
                    &lpFrom,
                    &lpFromlen,
                    &lpOverlapped,
                    &lpCompletionRoutine));

    return(ReturnValue);
}




BOOL WSAAPI
DTHOOK_WSAResetEvent (
    WSAEVENT hEvent)
{
    BOOL ReturnValue=FALSE;

    if (PREAPINOTIFY((DTCODE_WSAResetEvent,
                       &ReturnValue,
                       LibName,
                       &hEvent))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAResetEvent(hEvent);
        );

    POSTAPINOTIFY((DTCODE_WSAResetEvent,
                    &ReturnValue,
                    LibName,
                    &hEvent));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSASend (
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesSent,
    DWORD dwFlags,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSASend,
                       &ReturnValue,
                       LibName,
                       &s,
                       &lpBuffers,
                       &dwBufferCount,
                       &lpNumberOfBytesSent,
                       &dwFlags,
                       &lpOverlapped,
                       &lpCompletionRoutine))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSASend(s, lpBuffers, dwBufferCount, lpNumberOfBytesSent,
                              dwFlags, lpOverlapped, lpCompletionRoutine);
        );

    POSTAPINOTIFY((DTCODE_WSASend,
                    &ReturnValue,
                    LibName,
                    &s,
                    &lpBuffers,
                    &dwBufferCount,
                    &lpNumberOfBytesSent,
                    &dwFlags,
                    &lpOverlapped,
                    &lpCompletionRoutine));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSASendDisconnect (
    SOCKET s,
    LPWSABUF lpOutboundDisconnectData)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSASendDisconnect,
                       &ReturnValue,
                       LibName,
                       &s,
                       &lpOutboundDisconnectData))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSASendDisconnect(s, lpOutboundDisconnectData);
        );

    POSTAPINOTIFY((DTCODE_WSASendDisconnect,
                    &ReturnValue,
                    LibName,
                    &s,
                    &lpOutboundDisconnectData));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSASendTo (
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesSent,
    DWORD dwFlags,
    const struct sockaddr FAR * lpTo,
    int iTolen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSASendTo,
                       &ReturnValue,
                       LibName,
                       &s,
                       &lpBuffers,
                       &dwBufferCount,
                       &lpNumberOfBytesSent,
                       &dwFlags,
                       &lpTo,
                       &iTolen,
                       &lpOverlapped,
                       &lpCompletionRoutine))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSASendTo(s, lpBuffers, dwBufferCount,
                                lpNumberOfBytesSent, dwFlags, lpTo, iTolen,
                                lpOverlapped, lpCompletionRoutine);
        );

    POSTAPINOTIFY((DTCODE_WSASendTo,
                    &ReturnValue,
                    LibName,
                    &s,
                    &lpBuffers,
                    &dwBufferCount,
                    &lpNumberOfBytesSent,
                    &dwFlags,
                    &lpTo,
                    &iTolen,
                    &lpOverlapped,
                    &lpCompletionRoutine));

    return(ReturnValue);
}




BOOL WSAAPI
DTHOOK_WSASetEvent(
    WSAEVENT hEvent)
{
    BOOL ReturnValue=FALSE;

    if (PREAPINOTIFY((DTCODE_WSASetEvent,
                       &ReturnValue,
                       LibName,
                       &hEvent))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSASetEvent(hEvent);
        );

    POSTAPINOTIFY((DTCODE_WSASetEvent,
                    &ReturnValue,
                    LibName,
                    &hEvent));

    return(ReturnValue);
}




void WSAAPI
DTHOOK_WSASetLastError(
    int iError)
{
    if (PREAPINOTIFY((DTCODE_WSASetLastError,
                       NULL,
                       LibName,
                       &iError))) {

        return;
    }

    WSASetLastError(iError);

    POSTAPINOTIFY((DTCODE_WSASetLastError,
                    NULL,
                    LibName,
                    &iError));

    return;
}




#ifdef _X86_
#pragma optimize("y", off)  // Make sure we can at least get the caller.
#endif

SOCKET WSAAPI
DTHOOK_WSASocketA(
    int af,
    int type,
    int protocol,
    LPWSAPROTOCOL_INFOA lpProtocolInfo,
    GROUP g,
    DWORD dwFlags)
{

    SOCKET ReturnValue=INVALID_SOCKET;

    if (PREAPINOTIFY((DTCODE_WSASocketA,
                       &ReturnValue,
                       LibName,
                       &af,
                       &type,
                       &protocol,
                       &lpProtocolInfo,
                       &g,
                       &dwFlags))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSASocketA(af, type, protocol, lpProtocolInfo, g,
                                 dwFlags);
        );

    RECORD_SOCKET_CREATOR(ReturnValue);

    POSTAPINOTIFY((DTCODE_WSASocketA,
                    &ReturnValue,
                    LibName,
                    &af,
                    &type,
                    &protocol,
                    &lpProtocolInfo,
                    &g,
                    &dwFlags));

    return(ReturnValue);
}
#ifdef _X86_
#pragma optimize("", on)
#endif



#ifdef _X86_
#pragma optimize("y", off)  // Make sure we can at least get the caller.
#endif

SOCKET WSAAPI
DTHOOK_WSASocketW(
    int af,
    int type,
    int protocol,
    LPWSAPROTOCOL_INFOW lpProtocolInfo,
    GROUP g,
    DWORD dwFlags)
{

    SOCKET ReturnValue=INVALID_SOCKET;

    if (PREAPINOTIFY((DTCODE_WSASocketW,
                       &ReturnValue,
                       LibName,
                       &af,
                       &type,
                       &protocol,
                       &lpProtocolInfo,
                       &g,
                       &dwFlags))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSASocketW(af, type, protocol, lpProtocolInfo, g,
                                 dwFlags);
        );

   RECORD_SOCKET_CREATOR(ReturnValue);

   POSTAPINOTIFY((DTCODE_WSASocketW,
                    &ReturnValue,
                    LibName,
                    &af,
                    &type,
                    &protocol,
                    &lpProtocolInfo,
                    &g,
                    &dwFlags));

    return(ReturnValue);
}
#ifdef _X86_
#pragma optimize("", on)
#endif



int WSAAPI
DTHOOK_WSAStartup(
    WORD wVersionRequested,
    LPWSADATA lpWSAData)
{

    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSAStartup,
                       &ReturnValue,
                       LibName,
                       &wVersionRequested,
                       &lpWSAData))) {
        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAStartup(wVersionRequested, lpWSAData);
        );

    POSTAPINOTIFY((DTCODE_WSAStartup,
                    &ReturnValue,
                    LibName,
                    &wVersionRequested,
                    &lpWSAData));

    return(ReturnValue);
}




DWORD WSAAPI
DTHOOK_WSAWaitForMultipleEvents(
    DWORD cEvents,
    const WSAEVENT FAR * lphEvents,
    BOOL fWaitAll,
    DWORD dwTimeout,
    BOOL fAlertable)
{

    DWORD ReturnValue=WAIT_FAILED;

    if (PREAPINOTIFY((DTCODE_WSAWaitForMultipleEvents,
                       &ReturnValue,
                       LibName,
                       &cEvents,
                       &lphEvents,
                       &fWaitAll,
                       &dwTimeout,
                       &fAlertable))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAWaitForMultipleEvents(cEvents, lphEvents, fWaitAll,
                                               dwTimeout, fAlertable);
        );

    POSTAPINOTIFY((DTCODE_WSAWaitForMultipleEvents,
                    &ReturnValue,
                    LibName,
                    &cEvents,
                    &lphEvents,
                    &fWaitAll,
                    &dwTimeout,
                    &fAlertable));

    return(ReturnValue);
}




struct hostent FAR * WSAAPI
DTHOOK_gethostbyaddr(
    const char FAR * addr,
    int len,
    int type)
{

    struct hostent FAR *ReturnValue=NULL;

    if (PREAPINOTIFY((DTCODE_gethostbyaddr,
                       &ReturnValue,
                       LibName,
                       &addr,
                       &len,
                       &type))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = gethostbyaddr(addr, len, type);
        );

    POSTAPINOTIFY((DTCODE_gethostbyaddr,
                    &ReturnValue,
                    LibName,
                    &addr,
                    &len,
                    &type));

    return(ReturnValue);
}




struct hostent FAR * WSAAPI
DTHOOK_gethostbyname(
    const char FAR * name)
{

    struct hostent FAR *ReturnValue=NULL;

    if (PREAPINOTIFY((DTCODE_gethostbyname,
                       &ReturnValue,
                       LibName,
                       &name))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = gethostbyname(name);
        );

    POSTAPINOTIFY((DTCODE_gethostbyname,
                    &ReturnValue,
                    LibName,
                    &name));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_gethostname (
    char FAR * name,
    int namelen)
{

    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_gethostname,
                       &ReturnValue,
                       LibName,
                       &name,
                       &namelen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = gethostname(name, namelen);
        );

    POSTAPINOTIFY((DTCODE_gethostname,
                    &ReturnValue,
                    LibName,
                    &name,
                    &namelen));

    return(ReturnValue);
}




struct protoent FAR * WSAAPI
DTHOOK_getprotobyname(
    const char FAR * name)
{

    struct protoent FAR *ReturnValue=NULL;

    if (PREAPINOTIFY((DTCODE_getprotobyname,
                       &ReturnValue,
                       LibName,
                       &name))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = getprotobyname(name);
        );

    POSTAPINOTIFY((DTCODE_getprotobyname,
                    &ReturnValue,
                    LibName,
                    &name));

    return(ReturnValue);
}




struct protoent FAR * WSAAPI
DTHOOK_getprotobynumber(
    int number)
{

    struct protoent FAR *ReturnValue=NULL;

    if (PREAPINOTIFY((DTCODE_getprotobynumber,
                       &ReturnValue,
                       LibName,
                       &number))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = getprotobynumber(number);
        );

    POSTAPINOTIFY((DTCODE_getprotobynumber,
                    &ReturnValue,
                    LibName,
                    &number));

    return(ReturnValue);
}




struct servent FAR * WSAAPI
DTHOOK_getservbyname(
    const char FAR * name,
    const char FAR * proto)
{

    struct servent FAR *ReturnValue=NULL;

    if (PREAPINOTIFY((DTCODE_getservbyname,
                       &ReturnValue,
                       LibName,
                       &name,
                       &proto))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = getservbyname(name, proto);
        );

    POSTAPINOTIFY((DTCODE_getservbyname,
                    &ReturnValue,
                    LibName,
                    &name,
                    &proto));

    return(ReturnValue);
}




struct servent FAR * WSAAPI
DTHOOK_getservbyport(
    int port,
    const char FAR * proto)
{

    struct servent FAR *ReturnValue=NULL;

    if (PREAPINOTIFY((DTCODE_getservbyport,
                       &ReturnValue,
                       LibName,
                       &port,
                       &proto))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = getservbyport(port, proto);
        );

    POSTAPINOTIFY((DTCODE_getservbyport,
                    &ReturnValue,
                    LibName,
                    &port,
                    &proto));

    return(ReturnValue);
}




HANDLE WSAAPI
DTHOOK_WSAAsyncGetHostByAddr(
    HWND hWnd,
    u_int wMsg,
    const char FAR * addr,
    int len,
    int type,
    char FAR * buf,
    int buflen)
{

    HANDLE ReturnValue=NULL;

    if (PREAPINOTIFY((DTCODE_WSAAsyncGetHostByAddr,
                       &ReturnValue,
                       LibName,
                       &hWnd,
                       &wMsg,
                       &addr,
                       &len,
                       &type,
                       &buf,
                       &buflen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAAsyncGetHostByAddr(hWnd, wMsg, addr, len, type, buf,
                                            buflen);
        );

    POSTAPINOTIFY((DTCODE_WSAAsyncGetHostByAddr,
                    &ReturnValue,
                    LibName,
                    &hWnd,
                    &wMsg,
                    &addr,
                    &len,
                    &type,
                    &buf,
                    &buflen));

    return(ReturnValue);
}




HANDLE WSAAPI
DTHOOK_WSAAsyncGetHostByName(
    HWND hWnd,
    u_int wMsg,
    const char FAR * name,
    char FAR * buf,
    int buflen)
{

    HANDLE ReturnValue=NULL;

    if (PREAPINOTIFY((DTCODE_WSAAsyncGetHostByName,
                       &ReturnValue,
                       LibName,
                       &hWnd,
                       &wMsg,
                       &name,
                       &buf,
                       &buflen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAAsyncGetHostByName(hWnd, wMsg, name, buf, buflen);
        );

    POSTAPINOTIFY((DTCODE_WSAAsyncGetHostByName,
                    &ReturnValue,
                    LibName,
                    &hWnd,
                    &wMsg,
                    &name,
                    &buf,
                    &buflen));

    return(ReturnValue);
}




HANDLE WSAAPI
DTHOOK_WSAAsyncGetProtoByName(
    HWND hWnd,
    u_int wMsg,
    const char FAR * name,
    char FAR * buf,
    int buflen)
{

    HANDLE ReturnValue=NULL;

    if (PREAPINOTIFY((DTCODE_WSAAsyncGetProtoByName,
                       &ReturnValue,
                       LibName,
                       &hWnd,
                       &wMsg,
                       &name,
                       &buf,
                       &buflen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAAsyncGetProtoByName(hWnd, wMsg, name, buf, buflen);
        );

    POSTAPINOTIFY((DTCODE_WSAAsyncGetProtoByName,
                    &ReturnValue,
                    LibName,
                    &hWnd,
                    &wMsg,
                    &name,
                    &buf,
                    &buflen));

    return(ReturnValue);
}




HANDLE WSAAPI
DTHOOK_WSAAsyncGetProtoByNumber(
    HWND hWnd,
    u_int wMsg,
    int number,
    char FAR * buf,
    int buflen)
{

    HANDLE ReturnValue=NULL;

    if (PREAPINOTIFY((DTCODE_WSAAsyncGetProtoByNumber,
                       &ReturnValue,
                       LibName,
                       &hWnd,
                       &wMsg,
                       &number,
                       &buf,
                       &buflen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAAsyncGetProtoByNumber(hWnd, wMsg, number, buf,
                                               buflen);
        );

    POSTAPINOTIFY((DTCODE_WSAAsyncGetProtoByNumber,
                    &ReturnValue,
                    LibName,
                    &hWnd,
                    &wMsg,
                    &number,
                    &buf,
                    &buflen));

    return(ReturnValue);
}




HANDLE WSAAPI
DTHOOK_WSAAsyncGetServByName(
    HWND hWnd,
    u_int wMsg,
    const char FAR * name,
    const char FAR * proto,
    char FAR * buf,
    int buflen)
{

    HANDLE ReturnValue=NULL;

    if (PREAPINOTIFY((DTCODE_WSAAsyncGetServByName,
                       &ReturnValue,
                       LibName,
                       &hWnd,
                       &wMsg,
                       &name,
                       &proto,
                       &buf,
                       &buflen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAAsyncGetServByName(hWnd, wMsg, name, proto, buf,
                                            buflen);
        );

    POSTAPINOTIFY((DTCODE_WSAAsyncGetServByName,
                    &ReturnValue,
                    LibName,
                    &hWnd,
                    &wMsg,
                    &name,
                    &proto,
                    &buf,
                    &buflen));

    return(ReturnValue);
}




HANDLE WSAAPI
DTHOOK_WSAAsyncGetServByPort(
    HWND hWnd,
    u_int wMsg,
    int port,
    const char FAR * proto,
    char FAR * buf,
    int buflen)
{

    HANDLE ReturnValue=NULL;

    if (PREAPINOTIFY((DTCODE_WSAAsyncGetServByPort,
                       &ReturnValue,
                       LibName,
                       &hWnd,
                       &wMsg,
                       &port,
                       &proto,
                       &buf,
                       &buflen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAAsyncGetServByPort(hWnd, wMsg, port, proto, buf,
                                            buflen);
        );

    POSTAPINOTIFY((DTCODE_WSAAsyncGetServByPort,
                    &ReturnValue,
                    LibName,
                    &hWnd,
                    &wMsg,
                    &port,
                    &proto,
                    &buf,
                    &buflen));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSACancelAsyncRequest(
    HANDLE hAsyncTaskHandle)
{

    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSACancelAsyncRequest,
                       &ReturnValue,
                       LibName,
                       &hAsyncTaskHandle))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSACancelAsyncRequest(hAsyncTaskHandle);
        );

    POSTAPINOTIFY((DTCODE_WSACancelAsyncRequest,
                    &ReturnValue,
                    LibName,
                    &hAsyncTaskHandle));

    return(ReturnValue);
}




BOOL WSPAPI
DTHOOK_WPUCloseEvent(
    WSAEVENT hEvent,
    LPINT lpErrno )
{

    BOOL ReturnValue=FALSE;

    if (PREAPINOTIFY((DTCODE_WPUCloseEvent,
                       &ReturnValue,
                       LibName,
                       &hEvent,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUCloseEvent(hEvent, lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WPUCloseEvent,
                    &ReturnValue,
                    LibName,
                    &hEvent,
                    &lpErrno));

    return(ReturnValue);
}




int WSPAPI
DTHOOK_WPUCloseSocketHandle(
    SOCKET s,
    LPINT lpErrno )
{

    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WPUCloseSocketHandle,
                       &ReturnValue,
                       LibName,
                       &s,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUCloseSocketHandle(s, lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WPUCloseSocketHandle,
                    &ReturnValue,
                    LibName,
                    &s,
                    &lpErrno));

    return(ReturnValue);
}




WSAEVENT WSPAPI
DTHOOK_WPUCreateEvent(
    LPINT lpErrno )
{

    WSAEVENT ReturnValue=WSA_INVALID_EVENT;

    if (PREAPINOTIFY((DTCODE_WPUCreateEvent,
                       &ReturnValue,
                       LibName,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUCreateEvent(lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WPUCreateEvent,
                    &ReturnValue,
                    LibName,
                    &lpErrno));

    return(ReturnValue);
}




#ifdef _X86_
#pragma optimize("y", off)  // Make sure we can at least get the caller.
#endif

SOCKET WSPAPI
DTHOOK_WPUCreateSocketHandle(
    DWORD dwCatalogEntryId,
    DWORD_PTR dwContext,
    LPINT lpErrno)
{

    SOCKET ReturnValue=INVALID_SOCKET;

    if (PREAPINOTIFY((DTCODE_WPUCreateSocketHandle,
                       &ReturnValue,
                       LibName,
                       &dwCatalogEntryId,
                       &dwContext,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUCreateSocketHandle(dwCatalogEntryId, dwContext,
                                            lpErrno);
        );

    RECORD_SOCKET_CREATOR (ReturnValue);
    POSTAPINOTIFY((DTCODE_WPUCreateSocketHandle,
                    &ReturnValue,
                    LibName,
                    &dwCatalogEntryId,
                    &dwContext,
                    &lpErrno));

    return(ReturnValue);
}
#ifdef _X86_
#pragma optimize("", on)
#endif



#ifdef _X86_
#pragma optimize("y", off)  // Make sure we can at least get the caller.
#endif

SOCKET WSPAPI
DTHOOK_WPUModifyIFSHandle(
    DWORD dwCatalogEntryId,
    SOCKET ProposedHandle,
    LPINT lpErrno)
{

    SOCKET ReturnValue=INVALID_SOCKET;

    if (PREAPINOTIFY((DTCODE_WPUModifyIFSHandle,
                       &ReturnValue,
                       LibName,
                       &dwCatalogEntryId,
                       &ProposedHandle,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUModifyIFSHandle(dwCatalogEntryId, ProposedHandle,
                                         lpErrno);
        );

    RECORD_SOCKET_CREATOR (ReturnValue);
    POSTAPINOTIFY((DTCODE_WPUModifyIFSHandle,
                    &ReturnValue,
                    LibName,
                    &dwCatalogEntryId,
                    &ProposedHandle,
                    &lpErrno));

    return(ReturnValue);
}
#ifdef _X86_
#pragma optimize("", on)
#endif




int WSPAPI
DTHOOK_WPUQueryBlockingCallback(
    DWORD dwCatalogEntryId,
    LPBLOCKINGCALLBACK FAR * lplpfnCallback,
    PDWORD_PTR lpdwContext,
    LPINT lpErrno)
{

    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WPUQueryBlockingCallback,
                       &ReturnValue,
                       LibName,
                       &dwCatalogEntryId,
                       &lplpfnCallback,
                       &lpdwContext,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUQueryBlockingCallback(dwCatalogEntryId, lplpfnCallback,
                                               lpdwContext, lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WPUQueryBlockingCallback,
                    &ReturnValue,
                    LibName,
                    &dwCatalogEntryId,
                    &lplpfnCallback,
                    &lpdwContext,
                    &lpErrno));

    return(ReturnValue);
}




int WSPAPI
DTHOOK_WPUQuerySocketHandleContext(
    SOCKET s,
    PDWORD_PTR lpContext,
    LPINT lpErrno )
{

    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WPUQuerySocketHandleContext,
                       &ReturnValue,
                       LibName,
                       &s,
                       &lpContext,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUQuerySocketHandleContext(s, lpContext, lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WPUQuerySocketHandleContext,
                    &ReturnValue,
                    LibName,
                    &s,
                    &lpContext,
                    &lpErrno));

    return(ReturnValue);
}




int WSPAPI
DTHOOK_WPUQueueApc(
    LPWSATHREADID lpThreadId,
    LPWSAUSERAPC lpfnUserApc,
    DWORD_PTR dwContext,
    LPINT lpErrno)
{

    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WPUQueueApc,
                       &ReturnValue,
                       LibName,
                       &lpThreadId,
                       &lpfnUserApc,
                       &dwContext,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUQueueApc(lpThreadId, lpfnUserApc, dwContext, lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WPUQueueApc,
                    &ReturnValue,
                    LibName,
                    &lpThreadId,
                    &lpfnUserApc,
                    &dwContext,
                    &lpErrno));

    return(ReturnValue);
}




BOOL WSPAPI
DTHOOK_WPUResetEvent(
    WSAEVENT hEvent,
    LPINT lpErrno)
{

    BOOL ReturnValue=FALSE;

    if (PREAPINOTIFY((DTCODE_WPUResetEvent,
                       &ReturnValue,
                       LibName,
                       &hEvent,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUResetEvent(hEvent, lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WPUResetEvent,
                    &ReturnValue,
                    LibName,
                    &hEvent,
                    &lpErrno));

    return(ReturnValue);
}




BOOL WSPAPI
DTHOOK_WPUSetEvent(
    WSAEVENT hEvent,
    LPINT lpErrno)
{

    BOOL ReturnValue=FALSE;

    if (PREAPINOTIFY((DTCODE_WPUSetEvent,
                       &ReturnValue,
                       LibName,
                       &hEvent,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUSetEvent(hEvent, lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WPUSetEvent,
                    &ReturnValue,
                    LibName,
                    &hEvent,
                    &lpErrno));

    return(ReturnValue);
}




int WSPAPI
DTHOOK_WSCDeinstallProvider(
    LPGUID lpProviderId,
    LPINT lpErrno)
{

    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSCDeinstallProvider,
                       &ReturnValue,
                       LibName,
                       &lpProviderId,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCDeinstallProvider(lpProviderId, lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WSCDeinstallProvider,
                    &ReturnValue,
                    LibName,
                    &lpProviderId,
                    &lpErrno));

    return(ReturnValue);
}




int WSPAPI
DTHOOK_WSCInstallProvider(
    LPGUID lpProviderId,
    const WCHAR FAR * lpszProviderDllPath,
    const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    DWORD dwNumberOfEntries,
    LPINT lpErrno)
{

    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSCInstallProvider,
                       &ReturnValue,
                       LibName,
                       &lpProviderId,
                       &lpszProviderDllPath,
                       &lpProtocolInfoList,
                       &dwNumberOfEntries,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCInstallProvider(lpProviderId, lpszProviderDllPath,
                                         lpProtocolInfoList, dwNumberOfEntries,
                                         lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WSCInstallProvider,
                    &ReturnValue,
                    LibName,
                    &lpProviderId,
                    &lpszProviderDllPath,
                    &lpProtocolInfoList,
                    &dwNumberOfEntries,
                    &lpErrno));

    return(ReturnValue);
}




int WSPAPI
DTHOOK_WPUGetProviderPath(
    IN     LPGUID     lpProviderId,
    OUT    WCHAR FAR * lpszProviderDllPath,
    IN OUT LPINT      lpProviderDllPathLen,
    OUT    LPINT      lpErrno
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WPUGetProviderPath,
                       &ReturnValue,
                       LibName,
                       &lpProviderId,
                       &lpszProviderDllPath,
                       &lpProviderDllPathLen,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUGetProviderPath(lpProviderId, lpszProviderDllPath,
                                         lpProviderDllPathLen, lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WPUGetProviderPath,
                       &ReturnValue,
                       LibName,
                       &lpProviderId,
                       &lpszProviderDllPath,
                       &lpProviderDllPathLen,
                       &lpErrno));

    return(ReturnValue);
} // DTHOOK_WPUGetProviderPath




BOOL WSPAPI
DTHOOK_WPUPostMessage(
    HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    BOOL ReturnValue=FALSE;

    if (PREAPINOTIFY((DTCODE_WPUPostMessage,
                       &ReturnValue,
                       LibName,
                       &hWnd,
                       &Msg,
                       &wParam,
                       &lParam
                       ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUPostMessage(hWnd, Msg, wParam, lParam);
        );

    POSTAPINOTIFY((DTCODE_WPUPostMessage,
                       &ReturnValue,
                       LibName,
                       &hWnd,
                       &Msg,
                       &wParam,
                       &lParam
                       ));

    return(ReturnValue);
} // DTHOOK_WPUPostMessage




int WSPAPI
DTHOOK_WPUFDIsSet(
    SOCKET       s,
    fd_set FAR * set
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WPUFDIsSet,
                       &ReturnValue,
                       LibName,
                       &s,
                       &set
                       ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUFDIsSet(s, set);
        );

    POSTAPINOTIFY((DTCODE_WPUFDIsSet,
                       &ReturnValue,
                       LibName,
                       &s,
                       &set
                       ));

    return(ReturnValue);
} // DTHOOK_WPUFDIsSet




int WSPAPI
DTHOOK___WSAFDIsSet(
    SOCKET       s,
    fd_set FAR * set
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE___WSAFDIsSet,
                       &ReturnValue,
                       LibName,
                       &s,
                       &set
                       ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = __WSAFDIsSet(s, set);
        );

    POSTAPINOTIFY((DTCODE___WSAFDIsSet,
                       &ReturnValue,
                       LibName,
                       &s,
                       &set
                       ));

    return(ReturnValue);
} // DTHOOK___WSAFDIsSet

INT
WSPAPI
DTHOOK_WSAAddressToStringA(
    IN     LPSOCKADDR          lpsaAddress,
    IN     DWORD               dwAddressLength,
    IN     LPWSAPROTOCOL_INFOA lpProtocolInfo,
    IN OUT LPSTR               lpszAddressString,
    IN OUT LPDWORD             lpdwAddressStringLength
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSAAddressToStringA,
                      &ReturnValue,
                      LibName,
                      &lpsaAddress,
                      &dwAddressLength,
                      &lpProtocolInfo,
                      &lpszAddressString,
                      &lpdwAddressStringLength))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAAddressToStringA(lpsaAddress, dwAddressLength,
                                          lpProtocolInfo, lpszAddressString,
                                          lpdwAddressStringLength);
        );

    POSTAPINOTIFY( (DTCODE_WSAAddressToStringA,
                   &ReturnValue,
                   LibName,
                   &lpsaAddress,
                   &dwAddressLength,
                   &lpProtocolInfo,
                   &lpszAddressString,
                   &lpdwAddressStringLength
                   ) );

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSAAddressToStringW(
    IN     LPSOCKADDR          lpsaAddress,
    IN     DWORD               dwAddressLength,
    IN     LPWSAPROTOCOL_INFOW lpProtocolInfo,
    IN OUT LPWSTR              lpszAddressString,
    IN OUT LPDWORD             lpdwAddressStringLength
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSAAddressToStringW,
                      &ReturnValue,
                      LibName,
                      &lpsaAddress,
                      &dwAddressLength,
                      &lpProtocolInfo,
                      &lpszAddressString,
                      &lpdwAddressStringLength))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAAddressToStringW(lpsaAddress, dwAddressLength,
                                          lpProtocolInfo, lpszAddressString,
                                          lpdwAddressStringLength);
        );

    POSTAPINOTIFY( (DTCODE_WSAAddressToStringW,
                   &ReturnValue,
                   LibName,
                   &lpsaAddress,
                   &dwAddressLength,
                   &lpProtocolInfo,
                   &lpszAddressString,
                   &lpdwAddressStringLength
                   ) );

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSAStringToAddressA(
    IN     LPSTR               AddressString,
    IN     INT                 AddressFamily,
    IN     LPWSAPROTOCOL_INFOA  lpProtocolInfo,
    IN OUT LPSOCKADDR          lpAddress,
    IN OUT LPINT               lpAddressLength
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSAStringToAddressA,
                      &ReturnValue,
                      LibName,
                      &AddressString,
                      &AddressFamily,
                      &lpProtocolInfo,
                      &lpAddress,
                      &lpAddressLength
                      ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAStringToAddressA(AddressString, AddressFamily,
                                          lpProtocolInfo, lpAddress,
                                          lpAddressLength);
        );

    POSTAPINOTIFY((DTCODE_WSAStringToAddressA,
                   &ReturnValue,
                   LibName,
                   &AddressString,
                   &AddressFamily,
                   &lpProtocolInfo,
                   &lpAddress,
                   &lpAddressLength));
    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSAStringToAddressW(
    IN     LPWSTR              AddressString,
    IN     INT                 AddressFamily,
    IN     LPWSAPROTOCOL_INFOW lpProtocolInfo,
    IN OUT LPSOCKADDR          lpAddress,
    IN OUT LPINT               lpAddressLength
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSAStringToAddressW,
                      &ReturnValue,
                      LibName,
                      &AddressString,
                      &AddressFamily,
                      &lpProtocolInfo,
                      &lpAddress,
                      &lpAddressLength
                      ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAStringToAddressW(AddressString, AddressFamily,
                                          lpProtocolInfo, lpAddress,
                                          lpAddressLength);
        );

    POSTAPINOTIFY((DTCODE_WSAStringToAddressW,
                   &ReturnValue,
                   LibName,
                   &AddressString,
                   &AddressFamily,
                   &lpProtocolInfo,
                   &lpAddress,
                   &lpAddressLength));
    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSALookupServiceBeginA(
    IN  LPWSAQUERYSETA lpqsRestrictions,
    IN  DWORD          dwControlFlags,
    OUT LPHANDLE       lphLookup
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSALookupServiceBeginA,
                      &ReturnValue,
                      LibName,
                      &lpqsRestrictions,
                      &dwControlFlags,
                      &lphLookup
                      ))) {
        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSALookupServiceBeginA(lpqsRestrictions, dwControlFlags,
                                             lphLookup);
        );

    POSTAPINOTIFY((DTCODE_WSALookupServiceBeginA,
                   &ReturnValue,
                   LibName,
                   &lpqsRestrictions,
                   &dwControlFlags,
                   &lphLookup));

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSALookupServiceBeginW(
    IN  LPWSAQUERYSETW lpqsRestrictions,
    IN  DWORD          dwControlFlags,
    OUT LPHANDLE       lphLookup
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSALookupServiceBeginW,
                      &ReturnValue,
                      LibName,
                      &lpqsRestrictions,
                      &dwControlFlags,
                      &lphLookup
                      ))) {
        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSALookupServiceBeginW(lpqsRestrictions, dwControlFlags,
                                             lphLookup);
        );

    POSTAPINOTIFY((DTCODE_WSALookupServiceBeginW,
                   &ReturnValue,
                   LibName,
                   &lpqsRestrictions,
                   &dwControlFlags,
                   &lphLookup));

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSALookupServiceNextA(
    IN     HANDLE           hLookup,
    IN     DWORD            dwControlFlags,
    IN OUT LPDWORD          lpdwBufferLength,
    OUT    LPWSAQUERYSETA   lpqsResults
    )
{
       int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSALookupServiceNextA,
                      &ReturnValue,
                      LibName,
                      &hLookup,
                      &dwControlFlags,
                      &lpdwBufferLength,
                      &lpqsResults
                      ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSALookupServiceNextA(hLookup, dwControlFlags,
                                            lpdwBufferLength, lpqsResults);
        );

    POSTAPINOTIFY((DTCODE_WSALookupServiceNextA,
                   &ReturnValue,
                   LibName,
                   &hLookup,
                   &dwControlFlags,
                   &lpdwBufferLength,
                   &lpqsResults
                   ));

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSALookupServiceNextW(
    IN     HANDLE           hLookup,
    IN     DWORD            dwControlFlags,
    IN OUT LPDWORD          lpdwBufferLength,
    OUT    LPWSAQUERYSETW   lpqsResults
    )
{
       int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSALookupServiceNextW,
                      &ReturnValue,
                      LibName,
                      &hLookup,
                      &dwControlFlags,
                      &lpdwBufferLength,
                      &lpqsResults
                      ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSALookupServiceNextW(hLookup, dwControlFlags,
                                            lpdwBufferLength, lpqsResults);
        );

    POSTAPINOTIFY((DTCODE_WSALookupServiceNextW,
                   &ReturnValue,
                   LibName,
                   &hLookup,
                   &dwControlFlags,
                   &lpdwBufferLength,
                   &lpqsResults
                   ));

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSANSPIoctl(
    IN  HANDLE           hLookup,
    IN  DWORD            dwControlCode,
    IN  LPVOID           lpvInBuffer,
    IN  DWORD            cbInBuffer,
    OUT LPVOID           lpvOutBuffer,
    IN  DWORD            cbOutBuffer,
    OUT LPDWORD          lpcbBytesReturned,
    IN  LPWSACOMPLETION  lpCompletion
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSANSPIoctl,
                      &ReturnValue,
                      LibName,
                      &hLookup,
                      &dwControlCode,
                      &lpvInBuffer,
                      &cbInBuffer,
                      &lpvOutBuffer,
                      &cbOutBuffer,
                      &lpcbBytesReturned,
                      &lpCompletion
                      ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSANSPIoctl(hLookup, dwControlCode,
                                  lpvInBuffer, cbInBuffer,
                                  lpvOutBuffer, cbOutBuffer,
                                  lpcbBytesReturned, lpCompletion);
        );

    POSTAPINOTIFY((DTCODE_WSANSPIoctl,
                   &ReturnValue,
                   LibName,
                   &hLookup,
                   &dwControlCode,
                   &lpvInBuffer,
                   &cbInBuffer,
                   &lpvOutBuffer,
                   &cbOutBuffer,
                   &lpcbBytesReturned,
                   &lpCompletion
                   ));

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSALookupServiceEnd(
    IN HANDLE  hLookup
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSALookupServiceEnd,
                      &ReturnValue,
                      LibName,
                      &hLookup
                      ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSALookupServiceEnd(hLookup);
        );

    POSTAPINOTIFY((DTCODE_WSALookupServiceEnd,
                   &ReturnValue,
                   LibName,
                   &hLookup
                   ));

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSAInstallServiceClassA(
    IN  LPWSASERVICECLASSINFOA   lpServiceClassInfo
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSAInstallServiceClassA,
                      &ReturnValue,
                      LibName,
                      &lpServiceClassInfo
                      ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAInstallServiceClassA(lpServiceClassInfo);
        );

    POSTAPINOTIFY((DTCODE_WSAInstallServiceClassA,
                   &ReturnValue,
                   LibName,
                   &lpServiceClassInfo));

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSAInstallServiceClassW(
    IN  LPWSASERVICECLASSINFOW   lpServiceClassInfo
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSAInstallServiceClassW,
                      &ReturnValue,
                      LibName,
                      &lpServiceClassInfo
                      ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAInstallServiceClassW(lpServiceClassInfo);
        );

    POSTAPINOTIFY((DTCODE_WSAInstallServiceClassW,
                   &ReturnValue,
                   LibName,
                   &lpServiceClassInfo));

    return(ReturnValue);
}



INT WSPAPI
DTHOOK_WSASetServiceA(
    IN  LPWSAQUERYSETA    lpqsRegInfo,
    IN  WSAESETSERVICEOP  essOperation,
    IN  DWORD             dwControlFlags
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSASetServiceA,
                      &ReturnValue,
                      LibName,
                      &lpqsRegInfo,
                      &essOperation,
                      &dwControlFlags
                      ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSASetServiceA(lpqsRegInfo, essOperation,
                                     dwControlFlags);
        );

    POSTAPINOTIFY((DTCODE_WSASetServiceA,
                   &ReturnValue,
                   LibName,
                   &lpqsRegInfo,
                   &essOperation,
                   &dwControlFlags));

    return(ReturnValue);
}


INT WSPAPI
DTHOOK_WSASetServiceW(
    IN  LPWSAQUERYSETW    lpqsRegInfo,
    IN  WSAESETSERVICEOP  essOperation,
    IN  DWORD             dwControlFlags
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSASetServiceW,
                      &ReturnValue,
                      LibName,
                      &lpqsRegInfo,
                      &essOperation,
                      &dwControlFlags
                      ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSASetServiceW(lpqsRegInfo, essOperation,
                                     dwControlFlags);
        );

    POSTAPINOTIFY((DTCODE_WSASetServiceW,
                   &ReturnValue,
                   LibName,
                   &lpqsRegInfo,
                   &essOperation,
                   &dwControlFlags));

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSARemoveServiceClass(
    IN  LPGUID  lpServiceClassId
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSARemoveServiceClass,
                      &ReturnValue,
                      LibName,
                      &lpServiceClassId))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSARemoveServiceClass(lpServiceClassId);
        );

    POSTAPINOTIFY((DTCODE_WSARemoveServiceClass,
                   &ReturnValue,
                   LibName,
                   &lpServiceClassId));

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSAGetServiceClassInfoA(
    IN     LPGUID                  lpProviderId,
    IN     LPGUID                  lpServiceClassId,
    IN OUT LPDWORD                 lpdwBufSize,
    OUT    LPWSASERVICECLASSINFOA   lpServiceClassInfo
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSAGetServiceClassInfoA,
                      &ReturnValue,
                      LibName,
                      &lpProviderId,
                      &lpServiceClassId,
                      &lpdwBufSize,
                      &lpServiceClassInfo
                      ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAGetServiceClassInfoA(lpProviderId, lpServiceClassId,
                                              lpdwBufSize, lpServiceClassInfo);
        );

    POSTAPINOTIFY((DTCODE_WSAGetServiceClassInfoA,
                   &ReturnValue,
                   LibName,
                   &lpProviderId,
                   &lpServiceClassId,
                   &lpdwBufSize,
                   &lpServiceClassInfo));

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSAGetServiceClassInfoW(
    IN     LPGUID                  lpProviderId,
    IN     LPGUID                  lpServiceClassId,
    IN OUT LPDWORD                 lpdwBufSize,
    OUT    LPWSASERVICECLASSINFOW   lpServiceClassInfo
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSAGetServiceClassInfoW,
                      &ReturnValue,
                      LibName,
                      &lpProviderId,
                      &lpServiceClassId,
                      &lpdwBufSize,
                      &lpServiceClassInfo
                      ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAGetServiceClassInfoW(lpProviderId, lpServiceClassId,
                                              lpdwBufSize, lpServiceClassInfo);
        );

    POSTAPINOTIFY((DTCODE_WSAGetServiceClassInfoW,
                   &ReturnValue,
                   LibName,
                   &lpProviderId,
                   &lpServiceClassId,
                   &lpdwBufSize,
                   &lpServiceClassInfo));

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSAEnumNameSpaceProvidersA(
    IN OUT LPDWORD              lpdwBufferLength,
    IN     LPWSANAMESPACE_INFOA  Lpnspbuffer
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSAEnumNameSpaceProvidersA,
                      &ReturnValue,
                      LibName,
                      &lpdwBufferLength,
                      &Lpnspbuffer))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAEnumNameSpaceProvidersA(lpdwBufferLength, Lpnspbuffer);
        );

    POSTAPINOTIFY((DTCODE_WSAEnumNameSpaceProvidersA,
                   &ReturnValue,
                   LibName,
                   &lpdwBufferLength,
                   &Lpnspbuffer));

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSAEnumNameSpaceProvidersW(
    IN OUT LPDWORD              lpdwBufferLength,
    IN     LPWSANAMESPACE_INFOW  Lpnspbuffer
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSAEnumNameSpaceProvidersW,
                      &ReturnValue,
                      LibName,
                      &lpdwBufferLength,
                      &Lpnspbuffer))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAEnumNameSpaceProvidersW(lpdwBufferLength, Lpnspbuffer);
        );

    POSTAPINOTIFY((DTCODE_WSAEnumNameSpaceProvidersW,
                   &ReturnValue,
                   LibName,
                   &lpdwBufferLength,
                   &Lpnspbuffer));

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSAGetServiceClassNameByClassIdA(
    IN      LPGUID  lpServiceClassId,
    OUT     LPSTR   lpszServiceClassName,
    IN OUT  LPDWORD lpdwBufferLength
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSAGetServiceClassNameByClassIdA,
                      &ReturnValue,
                      LibName,
                      &lpServiceClassId,
                      &lpszServiceClassName,
                      &lpdwBufferLength
                      ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAGetServiceClassNameByClassIdA(lpServiceClassId,
                                                       lpszServiceClassName,
                                                       lpdwBufferLength);
        );

    POSTAPINOTIFY((DTCODE_WSAGetServiceClassNameByClassIdA,
                   &ReturnValue,
                   LibName,
                   &lpServiceClassId,
                   &lpszServiceClassName,
                   &lpdwBufferLength ));

    return(ReturnValue);
}

INT
WSPAPI
DTHOOK_WSAGetServiceClassNameByClassIdW(
    IN      LPGUID  lpServiceClassId,
    OUT     LPWSTR   lpszServiceClassName,
    IN OUT  LPDWORD lpdwBufferLength
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSAGetServiceClassNameByClassIdW,
                      &ReturnValue,
                      LibName,
                      &lpServiceClassId,
                      &lpszServiceClassName,
                      &lpdwBufferLength
                      ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAGetServiceClassNameByClassIdW(lpServiceClassId,
                                                       lpszServiceClassName,
                                                       lpdwBufferLength);
        );

    POSTAPINOTIFY((DTCODE_WSAGetServiceClassNameByClassIdW,
                   &ReturnValue,
                   LibName,
                   &lpServiceClassId,
                   &lpszServiceClassName,
                   &lpdwBufferLength ));

    return(ReturnValue);
}

INT
WSAAPI
DTHOOK_WSACancelBlockingCall(
    VOID
    )
{
    int ReturnValue=SOCKET_ERROR;

    if( PREAPINOTIFY((
            DTCODE_WSACancelBlockingCall,
            &ReturnValue,
            LibName
            )) ) {
        return ReturnValue;
    }

    INVOKE_ROUTINE(
        ReturnValue = WSACancelBlockingCall();
        );

    POSTAPINOTIFY((
        DTCODE_WSACancelBlockingCall,
        &ReturnValue,
        LibName
        ));

    return ReturnValue;
}

FARPROC
WSAAPI
DTHOOK_WSASetBlockingHook(
    FARPROC lpBlockFunc
    )
{
    FARPROC ReturnValue=NULL;

    if( PREAPINOTIFY((
            DTCODE_WSASetBlockingHook,
            &ReturnValue,
            LibName,
            &lpBlockFunc
            )) ) {
        return ReturnValue;
    }

    INVOKE_ROUTINE(
        ReturnValue = WSASetBlockingHook( lpBlockFunc );
        );

    POSTAPINOTIFY((
        DTCODE_WSASetBlockingHook,
        &ReturnValue,
        LibName,
        &lpBlockFunc
        ));

    return ReturnValue;
}

INT
WSAAPI
DTHOOK_WSAUnhookBlockingHook(
    VOID
    )
{
    int ReturnValue=SOCKET_ERROR;

    if( PREAPINOTIFY((
            DTCODE_WSAUnhookBlockingHook,
            &ReturnValue,
            LibName
            )) ) {
        return ReturnValue;
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAUnhookBlockingHook();
        );

    POSTAPINOTIFY((
        DTCODE_WSAUnhookBlockingHook,
        &ReturnValue,
        LibName
        ));

    return ReturnValue;
}

BOOL
WSAAPI
DTHOOK_WSAIsBlocking(
    VOID
    )
{
    BOOL ReturnValue=FALSE;

    if( PREAPINOTIFY((
            DTCODE_WSAIsBlocking,
            &ReturnValue,
            LibName
            )) ) {
        return ReturnValue;
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAIsBlocking();
        );

    POSTAPINOTIFY((
        DTCODE_WSAIsBlocking,
        &ReturnValue,
        LibName
        ));

    return ReturnValue;
}


int WSPAPI
DTHOOK_WSCGetProviderPath(
    LPGUID lpProviderId,
    WCHAR FAR * lpszProviderDllPath,
    LPINT lpProviderDllPathLen,
    LPINT lpErrno)
{

    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSCGetProviderPath,
                       &ReturnValue,
                       LibName,
                       &lpProviderId,
                       &lpszProviderDllPath,
                       &lpProviderDllPathLen,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCGetProviderPath(lpProviderId, lpszProviderDllPath,
                                         lpProviderDllPathLen, lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WSCGetProviderPath,
                    &ReturnValue,
                    LibName,
                    &lpProviderId,
                    &lpszProviderDllPath,
                    &lpProviderDllPathLen,
                    &lpErrno));

    return(ReturnValue);
}


int WSPAPI
DTHOOK_WSCInstallNameSpace(
    LPWSTR lpszIdentifier,
    LPWSTR lpszPathName,
    DWORD dwNameSpace,
    DWORD dwVersion,
    LPGUID lpProviderId)
{

    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSCInstallNameSpace,
                       &ReturnValue,
                       LibName,
                       &lpszIdentifier,
                       &lpszPathName,
                       &dwNameSpace,
                       &dwVersion,
                       &lpProviderId))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCInstallNameSpace(lpszIdentifier, lpszPathName,
                                          dwNameSpace, dwVersion, lpProviderId);
        );

    POSTAPINOTIFY((DTCODE_WSCInstallNameSpace,
                    &ReturnValue,
                    LibName,
                    &lpszIdentifier,
                    &lpszPathName,
                    &dwNameSpace,
                    &dwVersion,
                    &lpProviderId));

    return(ReturnValue);
}


int WSPAPI
DTHOOK_WSCUnInstallNameSpace(
    LPGUID lpProviderId
    )
{

    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSCUnInstallNameSpace,
                       &ReturnValue,
                       LibName,
                       &lpProviderId))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCUnInstallNameSpace(lpProviderId);
        );

    POSTAPINOTIFY((DTCODE_WSCUnInstallNameSpace,
                    &ReturnValue,
                    LibName,
                    &lpProviderId));

    return(ReturnValue);
}


int WSPAPI
DTHOOK_WSCEnableNSProvider(
    LPGUID lpProviderId,
    BOOL fEnable
    )
{

    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSCEnableNSProvider,
                       &ReturnValue,
                       LibName,
                       &lpProviderId,
                       &fEnable))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCEnableNSProvider(lpProviderId, fEnable);
        );

    POSTAPINOTIFY((DTCODE_WSCEnableNSProvider,
                    &ReturnValue,
                    LibName,
                    &lpProviderId,
                    &fEnable));

    return(ReturnValue);
}

int
WSPAPI
DTHOOK_WPUCompleteOverlappedRequest (
    SOCKET s,   
    LPWSAOVERLAPPED lpOverlapped,       
    DWORD dwError,      
    DWORD cbTransferred,        
    LPINT lpErrno
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WPUCompleteOverlappedRequest,
                       &ReturnValue,
                       LibName,
                       &s,
                       &lpOverlapped,
                       &dwError,
                       &cbTransferred,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUCompleteOverlappedRequest(
                       s,
                       lpOverlapped,
                       dwError,
                       cbTransferred,
                       lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WPUCompleteOverlappedRequest,
                    &ReturnValue,
                    LibName,
                    &s,
                    &lpOverlapped,
                    &dwError,
                    &cbTransferred,
                    &lpErrno));

    return(ReturnValue);

}

int WSAAPI
DTHOOK_WSAProviderConfigChange(
    IN OUT LPHANDLE lpNotificationHandle,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSAProviderConfigChange,
                       &ReturnValue,
                       LibName,
                       &lpNotificationHandle,
                       &lpOverlapped,
                       &lpCompletionRoutine))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAProviderConfigChange(
                       lpNotificationHandle,
                       lpOverlapped,
                       lpCompletionRoutine);
        );

    POSTAPINOTIFY((DTCODE_WSAProviderConfigChange,
                    &ReturnValue,
                    LibName,
                    &lpNotificationHandle,
                    &lpOverlapped,
                    &lpCompletionRoutine));

    return(ReturnValue);

}
int
WSPAPI
DTHOOK_WSCWriteProviderOrder (
    IN LPDWORD lpwdCatalogEntryId,
    IN DWORD dwNumberOfEntries
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSCWriteProviderOrder,
                       &ReturnValue,
                       LibName,
                       &lpwdCatalogEntryId,
                       &dwNumberOfEntries))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCWriteProviderOrder(
                       lpwdCatalogEntryId,
                       dwNumberOfEntries);
        );

    POSTAPINOTIFY((DTCODE_WSCWriteProviderOrder,
                    &ReturnValue,
                    LibName,
                    &lpwdCatalogEntryId,
                    &dwNumberOfEntries));

    return(ReturnValue);

}

int
WSPAPI
DTHOOK_WSCWriteNameSpaceOrder (
    IN LPGUID lpProviderId,
    IN DWORD dwNumberOfEntries
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSCWriteNameSpaceOrder,
                       &ReturnValue,
                       LibName,
                       &lpProviderId,
                       &dwNumberOfEntries))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCWriteNameSpaceOrder(
                       lpProviderId,
                       dwNumberOfEntries);
        );

    POSTAPINOTIFY((DTCODE_WSCWriteNameSpaceOrder,
                    &ReturnValue,
                    LibName,
                    &lpProviderId,
                    &dwNumberOfEntries));

    return(ReturnValue);
}

int
WSPAPI
DTHOOK_WSCUpdateProvider(
    IN  LPGUID lpProviderId,
    IN  const WCHAR FAR * lpszProviderDllPath,
    IN  const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN  DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSCUpdateProvider,
                       &ReturnValue,
                       LibName,
                       &lpProviderId,
                       &lpszProviderDllPath,
                       &lpProtocolInfoList,
                       &dwNumberOfEntries,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCUpdateProvider(
                       lpProviderId,
                       lpszProviderDllPath,
                       lpProtocolInfoList,
                       dwNumberOfEntries,
                       lpErrno
                       );
        );

    POSTAPINOTIFY((DTCODE_WSCUpdateProvider,
                    &ReturnValue,
                    LibName,
                    &lpProviderId,
                    &lpszProviderDllPath,
                    &lpProtocolInfoList,
                    &dwNumberOfEntries,
                    &lpErrno));

    return(ReturnValue);
}

int WSAAPI
DTHOOK_getaddrinfo(
    const char FAR *NodeName,
    const char FAR *ServiceName,
    const struct addrinfo FAR *Hints,
    struct addrinfo FAR * FAR *Result
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_getaddrinfo,
                       &ReturnValue,
                       LibName,
                       &NodeName,
                       &ServiceName,
                       &Hints,
                       &Result))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = getaddrinfo(
                       NodeName,
                       ServiceName,
                       Hints,
                       Result
                       );
        );

    POSTAPINOTIFY((DTCODE_getaddrinfo,
                    &ReturnValue,
                    LibName,
                    &NodeName,
                    &ServiceName,
                    &Hints,
                    &Result));

    return(ReturnValue);
}


int WSAAPI
DTHOOK_GetAddrInfoW(
    IN      PCWSTR                      pNodeName,
    IN      PCWSTR                      pServiceName,
    IN      const struct addrinfoW *    pHints,
    OUT     PADDRINFOW *                ppResult
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY(( DTCODE_GetAddrInfoW,
                       &ReturnValue,
                       LibName,
                       &pNodeName,
                       &pServiceName,
                       &pHints,
                       &ppResult))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = GetAddrInfoW(
                       pNodeName,
                       pServiceName,
                       pHints,
                       ppResult
                       );
        );

    POSTAPINOTIFY(( DTCODE_GetAddrInfoW,
                    &ReturnValue,
                    LibName,
                    &pNodeName,
                    &pServiceName,
                    &pHints,
                    &ppResult));

    return(ReturnValue);
}


int WSAAPI
DTHOOK_getnameinfo(
    const struct sockaddr *SocketAddress,
    socklen_t SocketAddressLength,
    char *NodeName,
    DWORD NodeBufferSize,
    char *ServiceName,
    DWORD ServiceBufferSize,
    int Flags
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_getnameinfo,
                       &ReturnValue,
                       LibName,
                       &SocketAddress,
                       &SocketAddressLength,
                       &NodeName,
                       &NodeBufferSize,
                       &ServiceName,
                       &ServiceBufferSize,
                       &Flags))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = getnameinfo(
                       SocketAddress,
                       SocketAddressLength,
                       NodeName,
                       NodeBufferSize,
                       ServiceName,
                       ServiceBufferSize,
                       Flags
                       );
        );

    POSTAPINOTIFY((DTCODE_getnameinfo,
                    &ReturnValue,
                    LibName,
                    &SocketAddress,
                    &SocketAddressLength,
                    &NodeName,
                    &NodeBufferSize,
                    &ServiceName,
                    &ServiceBufferSize,
                    &Flags));

    return(ReturnValue);
}

INT
WSAAPI
DTHOOK_GetNameInfoW(
    IN      const SOCKADDR *    pSockaddr,
    IN      socklen_t           SockaddrLength,
    OUT     PWCHAR              pNodeBuffer,
    IN      DWORD               NodeBufferSize,
    OUT     PWCHAR              pServiceBuffer,
    IN      DWORD               ServiceBufferSize,
    IN      INT                 Flags
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_GetNameInfoW,
                       &ReturnValue,
                       LibName,
                       &pSockaddr,
                       &SockaddrLength,
                       &pNodeBuffer,
                       &NodeBufferSize,
                       &pServiceBuffer,
                       &ServiceBufferSize,
                       &Flags))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = GetNameInfoW(
                       pSockaddr,
                       SockaddrLength,
                       pNodeBuffer,
                       NodeBufferSize,
                       pServiceBuffer,
                       ServiceBufferSize,
                       Flags
                       );
        );

    POSTAPINOTIFY((DTCODE_GetNameInfoW,
                    &ReturnValue,
                    LibName,
                    &pSockaddr,
                    &SockaddrLength,
                    &pNodeBuffer,
                    &NodeBufferSize,
                    &pServiceBuffer,
                    &ServiceBufferSize,
                    &Flags));

    return(ReturnValue);
}


void WSAAPI
DTHOOK_freeaddrinfo(
    struct addrinfo *Free
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_freeaddrinfo,
                       &ReturnValue,
                       LibName,
                       &Free))) {

        return;
    }

    INVOKE_ROUTINE(
        freeaddrinfo(Free);
        );

    POSTAPINOTIFY((DTCODE_freeaddrinfo,
                    &ReturnValue,
                    LibName,
                    &Free));

    return;
}

int WSPAPI
DTHOOK_WPUOpenCurrentThread(
    OUT LPWSATHREADID lpThreadId,
    OUT LPINT lpErrno
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WPUOpenCurrentThread,
                       &ReturnValue,
                       LibName,
                       &lpThreadId,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUOpenCurrentThread(
                       lpThreadId,
                       lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WPUOpenCurrentThread,
                    &ReturnValue,
                    LibName,
                    &lpThreadId,
                    &lpErrno));

    return(ReturnValue);
}

int WSPAPI
DTHOOK_WPUCloseThread(
    IN LPWSATHREADID lpThreadId,
    OUT LPINT lpErrno
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WPUCloseThread,
                       &ReturnValue,
                       LibName,
                       &lpThreadId,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUCloseThread(
                       lpThreadId,
                       lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WPUCloseThread,
                    &ReturnValue,
                    LibName,
                    &lpThreadId,
                    &lpErrno));

    return(ReturnValue);
}

#ifdef _WIN64

int 
WSPAPI
DTHOOK_WSCEnumProtocols32(
    IN LPINT                lpiProtocols,
    OUT LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    IN OUT LPDWORD          lpdwBufferLength,
    LPINT                   lpErrno
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSCEnumProtocols32,
                        &ReturnValue,
                        LibName,
                        lpiProtocols,
                        lpProtocolBuffer,
                        lpdwBufferLength,
                        &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCEnumProtocols32(
                        lpiProtocols,
                        lpProtocolBuffer,
                        lpdwBufferLength,
                        lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WSCEnumProtocols32,
                        &ReturnValue,
                        LibName,
                        lpiProtocols,
                        lpProtocolBuffer,
                        lpdwBufferLength,
                        &lpErrno));

    return(ReturnValue);
}

int
WSPAPI
DTHOOK_WSCInstallProvider64_32(
    IN  LPGUID lpProviderId,
    IN  const WCHAR FAR * lpszProviderDllPath,
    IN  const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN  DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSCInstallProvider64_32,
                        &ReturnValue,
                        LibName,
                        lpProviderId,
                        lpszProviderDllPath,
                        lpProtocolInfoList,
                        dwNumberOfEntries,
                        &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCInstallProvider64_32(
                        lpProviderId,
                        lpszProviderDllPath,
                        lpProtocolInfoList,
                        dwNumberOfEntries,
                        lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WSCInstallProvider64_32,
                        &ReturnValue,
                        LibName,
                        lpProviderId,
                        lpszProviderDllPath,
                        lpProtocolInfoList,
                        dwNumberOfEntries,
                        &lpErrno));

    return(ReturnValue);
}

int
WSPAPI
DTHOOK_WSCDeinstallProvider32(
    IN  LPGUID lpProviderId,
    OUT LPINT lpErrno
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSCDeinstallProvider32,
                        &ReturnValue,
                        LibName,
                        lpProviderId,
                        &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCDeinstallProvider32(
                        lpProviderId,
                        lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WSCDeinstallProvider32,
                        &ReturnValue,
                        LibName,
                        lpProviderId,
                        &lpErrno));

    return(ReturnValue);
}

int
WSPAPI
DTHOOK_WSCGetProviderPath32 (
    IN LPGUID lpProviderId,
    OUT WCHAR FAR * lpszProviderDllPath,
    IN OUT LPINT ProviderDLLPathLen,
    OUT LPINT lpErrno
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSCGetProviderPath32,
                        &ReturnValue,
                        LibName,
                        lpProviderId,
                        lpszProviderDllPath,
                        ProviderDLLPathLen,
                        &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCGetProviderPath32(
                        lpProviderId,
                        lpszProviderDllPath,
                        ProviderDLLPathLen,
                        lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WSCGetProviderPath32,
                        &ReturnValue,
                        LibName,
                        lpProviderId,
                        lpszProviderDllPath,
                        ProviderDLLPathLen,
                        &lpErrno));

    return(ReturnValue);
}

int
WSPAPI
DTHOOK_WSCUpdateProvider32(
    IN  LPGUID lpProviderId,
    IN  const WCHAR FAR * lpszProviderDllPath,
    IN  const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN  DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSCUpdateProvider32,
                        &ReturnValue,
                        LibName,
                        lpProviderId,
                        lpszProviderDllPath,
                        lpProtocolInfoList,
                        dwNumberOfEntries,
                        &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCUpdateProvider32(
                        lpProviderId,
                        lpszProviderDllPath,
                        lpProtocolInfoList,
                        dwNumberOfEntries,
                        lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WSCUpdateProvider32,
                        &ReturnValue,
                        LibName,
                        lpProviderId,
                        lpszProviderDllPath,
                        lpProtocolInfoList,
                        dwNumberOfEntries,
                        &lpErrno));

    return(ReturnValue);
}

int
WSPAPI
DTHOOK_WSCWriteProviderOrder32 (
    IN LPDWORD lpwdCatalogEntryId,
    IN DWORD dwNumberOfEntries
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSCWriteProviderOrder32,
                        &ReturnValue,
                        LibName,
                        lpwdCatalogEntryId,
                        dwNumberOfEntries))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCWriteProviderOrder32(
                        lpwdCatalogEntryId,
                        dwNumberOfEntries);
        );

    POSTAPINOTIFY((DTCODE_WSCWriteProviderOrder32,
                        &ReturnValue,
                        LibName,
                        lpwdCatalogEntryId,
                        dwNumberOfEntries));

    return(ReturnValue);
}

INT 
WSAAPI
DTHOOK_WSCEnumNameSpaceProviders32(
    IN OUT LPDWORD              lpdwBufferLength,
    IN OUT LPWSANAMESPACE_INFOW lpnspBuffer
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSCEnumNameSpaceProviders32,
                        &ReturnValue,
                        LibName,
                        lpdwBufferLength,
                        lpnspBuffer))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCEnumNameSpaceProviders32(
                        lpdwBufferLength,
                        lpnspBuffer);
        );

    POSTAPINOTIFY((DTCODE_WSCEnumNameSpaceProviders32,
                        &ReturnValue,
                        LibName,
                        lpdwBufferLength,
                        lpnspBuffer));

    return(ReturnValue);
}

INT 
WSAAPI
DTHOOK_WSCInstallNameSpace32 (
    IN  LPWSTR  lpszIdentifier,
    IN  LPWSTR  lpszPathName,
    IN  DWORD   dwNameSpace,
    IN  DWORD   dwVersion,
    IN  LPGUID  lpProviderId
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSCInstallNameSpace32,
                        &ReturnValue,
                        LibName,
                        lpszIdentifier,
                        lpszPathName,
                        dwNameSpace,
                        dwVersion,
                        lpProviderId))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCInstallNameSpace32(
                        lpszIdentifier,
                        lpszPathName,
                        dwNameSpace,
                        dwVersion,
                        lpProviderId);
        );

    POSTAPINOTIFY((DTCODE_WSCInstallNameSpace32,
                        &ReturnValue,
                        LibName,
                        lpszIdentifier,
                        lpszPathName,
                        dwNameSpace,
                        dwVersion,
                        lpProviderId));

    return(ReturnValue);
}

INT
WSAAPI
DTHOOK_WSCUnInstallNameSpace32 (
    IN  LPGUID  lpProviderId
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSCUnInstallNameSpace32,
                        &ReturnValue,
                        LibName,
                        lpProviderId))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCUnInstallNameSpace32(
                        lpProviderId);
        );

    POSTAPINOTIFY((DTCODE_WSCUnInstallNameSpace32,
                        &ReturnValue,
                        LibName,
                        lpProviderId));

    return(ReturnValue);
}

INT
WSAAPI
DTHOOK_WSCEnableNSProvider32 (
    IN  LPGUID  lpProviderId,
    IN  BOOL    fEnable
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSCEnableNSProvider32,
                        &ReturnValue,
                        LibName,
                        lpProviderId,
                        fEnable))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCEnableNSProvider32(
                        lpProviderId,
                        fEnable);
        );

    POSTAPINOTIFY((DTCODE_WSCEnableNSProvider32,
                        &ReturnValue,
                        LibName,
                        lpProviderId,
                        fEnable));

    return(ReturnValue);
}

int
WSPAPI
DTHOOK_WSCWriteNameSpaceOrder32 (
    IN LPGUID lpProviderId,
    IN DWORD dwNumberOfEntries
    )
{
    int ReturnValue=SOCKET_ERROR;

    if (PREAPINOTIFY((DTCODE_WSCWriteNameSpaceOrder32,
                        &ReturnValue,
                        LibName,
                        lpProviderId,
                        dwNumberOfEntries))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCWriteNameSpaceOrder32(
                        lpProviderId,
                        dwNumberOfEntries);
        );

    POSTAPINOTIFY((DTCODE_WSCWriteNameSpaceOrder32,
                        &ReturnValue,
                        LibName,
                        lpProviderId,
                        dwNumberOfEntries));

    return(ReturnValue);
}

#endif // _WIN64

LONG
DtExceptionFilter(
    LPEXCEPTION_POINTERS ExceptionPointers,
    LPSTR                Routine
    )
{

    //
    // Protect ourselves in case the process is messed up.
    //

    __try {

        //
        // Whine about the exception.
        //

        PrintDebugString(
            "Exception: %08lx @ %08lx, caught in %s\n",
            ExceptionPointers->ExceptionRecord->ExceptionCode,
            ExceptionPointers->ExceptionRecord->ExceptionAddress,
            Routine
            );

        //
        // Call the debug/trace exception routine if installed.
        //

        if( ExceptionNotifyFP != NULL ) {

            (ExceptionNotifyFP)( ExceptionPointers );

        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        //
        // Not much we can do here...
        //

        NOTHING;

    }

    //
    // We don't actually want to suppress exceptions, just whine about them.
    // So, we return EXCEPTION_CONTINUE_SEARCH here so that the exception will
    // be seen by the app/debugger/whatever.
    //

    return EXCEPTION_CONTINUE_SEARCH;

}   // DtExceptionFilter

} // extern "C"

#endif  // DEBUG_TRACING
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\dsocket.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

dsocket.cpp

Abstract:

This module contains the implemetation of the dsocket object used
by winsock2.dll

Author:

Dirk Brandewie  dirk@mink.intel.com  14-JUL-1995

Notes:

$Revision:   1.15  $

$Modtime:   08 Mar 1996 05:15:30  $

Revision History:
    21-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Moved single line functions to
        inlines in header file. Added debug/trace code.
--*/

#include "precomp.h"

#define m_reference_count   RefCount
#define m_socket_handle     Handle

LPCONTEXT_TABLE DSOCKET::sm_context_table=NULL;


INT
DSOCKET::DSocketClassInitialize(
    )
/*++
Routine Description:

    DSOCKET  class initializer.  This funtion must be called before any DSOCKET
    objects  are  created.   It  takes  care  of initializing the socket handle
    mapping table that maps socket handles to DSOCKET object references.

Arguments:

    None

Return Value:

    If  the function succeeds, it returns ERROR_SUCCESS, otherwise it returns a
    WinSock specific error code.
--*/
{
    if (sm_context_table==NULL) {
        return WahCreateHandleContextTable (&sm_context_table);
    }
    else
        return NO_ERROR;

} // DSocketClassInitialize




INT
DSOCKET::DSocketClassCleanup(
    )
/*++
Routine Description:

    DSOCKET  class  cleanup  function.   This function must be called after all
    DSOCKET  objects  have  been  destroyed.   It  takes care of destroying the
    socket  handle  mapping  table  that  maps socket handles to DSOCKET object
    references.

Arguments:

    None

Return Value:

    If  the function succeeds, it returns ERROR_SUCCESS, otherwise it returns a
    WinSock specific error code.
--*/
{
    DWORD   rc = NO_ERROR;
    if (sm_context_table!=NULL) {
        rc = WahDestroyHandleContextTable (sm_context_table);
        sm_context_table = NULL;
    }

    return rc;
} // DSocketClassCleanup




DSOCKET::DSOCKET(
    )
/*++

Routine Description:

    DSOCKET  object  constructor.   Creates and returns a DSOCKET object.  Note
    that  the  DSOCKET object has not been fully initialized.  The "Initialize"
    member function must be the first member function called on the new DSOCKET
    object.

Arguments:

    None

Return Value:

    None
--*/
{
    // Set our data members to known values
    m_reference_count   = 2;
    m_provider          = NULL;
    m_handle_context    = NULL;
    m_socket_handle     = (HANDLE)INVALID_SOCKET;
    m_catalog_item      = NULL;
    m_pvd_socket        = FALSE;
    m_api_socket        = FALSE;
    m_overlapped_socket = TRUE;     // This is the default for socket call.
}




INT
DSOCKET::Initialize(
    IN PPROTO_CATALOG_ITEM  CatalogEntry
    )
/*++

Routine Description:

    Completes  the  initialization  of  the  DSOCKET object.  This must be the
    first  member  function  called  for  the  DSOCKET object.  

Arguments:

    CatalogEntry - Supplies  a  reference  to  the catalog item object associated with
               this DSOCKET object.

Return Value:

    The  function returns ERROR_SUCCESS if successful.  Otherwise it
    returns an appropriate WinSock error code if the initialization
    cannot be completed.
--*/
{
    PDTHREAD    currentThread;

    // Store the provider, catalog, and process object.
    CatalogEntry->Reference ();
    m_catalog_item = CatalogEntry;
    m_provider = CatalogEntry->GetProvider ();

    currentThread = DTHREAD::GetCurrentDThread ();
    if (currentThread!=NULL) {
        m_overlapped_socket = (currentThread->GetOpenType ()==0);
    }

    //else The thread must have never been used by the application
    // No API call was made, only SPI.  Thus leave the overlapped attribute
    // at its default.


    DEBUGF( DBG_TRACE,
            ("Initializing socket %p\n",this));
    return(ERROR_SUCCESS);
}



DSOCKET::~DSOCKET()
/*++

Routine Description:

    DSOCKET  object  destructor.   This  procedure  has  the  responsibility to
    perform  any required shutdown operations for the DSOCKET object before the
    object  memory  is  deallocated.  The caller is reponsible for removing the
    object  from its list in the DPROCESS object and removing the object/handle
    association  from  the  socket handle association manager before destroying
    the DSOCKET object.

Arguments:

    None

Return Value:

    None
--*/
{
    DEBUGF( DBG_TRACE,
            ("Destroying socket %p\n",this));
    if (m_catalog_item) {
        m_catalog_item->Dereference ();
        m_catalog_item = NULL;
    }
#ifdef DEBUG_TRACING
    {
        PDSOCKET Socket;
        if (sm_context_table!=NULL) {
            Socket = GetCountedDSocketFromSocketNoExport ((SOCKET)m_socket_handle);
            if (Socket!=NULL) {
                assert (Socket!=this);
                Socket->DropDSocketReference ();
            }
        }
    }
#endif
}

VOID
DSOCKET::DestroyDSocket()
/*++

Routine Description:

    Destroy DSocket object
Arguments:

    None

Return Value:

    None
--*/
{
    delete this;
}



INT
DSOCKET::AssociateSocketHandle(
    IN  SOCKET SocketHandle,
    IN  BOOLEAN ProviderSocket
    )
/*++
Routine Description:

    This  procedure  takes  the  socket  handle  that will be given to external
    clients  and  stores  it in the DSOCKET object.  It also enters this handle
    into  the  association table so that the client socket handle can be mapped
    to  a  DSOCKET  reference.  Note that this procedure must be called at some
    point for both IFS and non-IFS sockets.

Arguments:

    SocketHandle - Supplies  the  client  socket  handle  to  be  stored in and
                   associated with the DSOCKET object.
    ProviderSocket  - TRUE if socket is created by the provider

Return Value:

    If  the function succeeds, it returns ERROR_SUCCESS, otherwise it returns a
    WinSock specific error code.
--*/
{
    INT					return_code;
    PDSOCKET            oldSocket;

    return_code = ERROR_SUCCESS;
	m_socket_handle = (HANDLE)SocketHandle;
    m_pvd_socket = ProviderSocket;

    oldSocket = static_cast<PDSOCKET>(WahInsertHandleContext(
                                        sm_context_table,
                                        this));
    if (oldSocket==this) {
        //
        // We managed to insert new socket object into the table, done
        //
        ;
    }
    else if (oldSocket!=NULL) {
        //
        // There was another socket object associated with the same
        // handle. This could happen in three cases:
        //  1) the socket was closed via CloseHandle and we never
        //      have had a chance to free it.
        //  2) the layered provider is reusing socket created by
        //      the base provider
        //  3) the socket was used by layered service provider
        //      which also never calls closesocket on it (just
        //      WSPCloseSocket which we never see -> yet another bug
        //      in the spec).
        // Of course, there could be a fourth case where the provider
        // gives us a bogus handle value, but we can't check for it
        // 
        // Wah call replaces the context in the table, so we just
        // need to dereference the old one, to account to refernce
        // we add when we create the object
        //

        oldSocket->DropDSocketReference();

    }
    else
        return_code = WSAENOBUFS;

    return return_code;
} // AssociateSocketHandle



INT
DSOCKET::DisassociateSocketHandle(
    )
/*++
Routine Description:

    This  procedure  removes  the (handle, DSOCKET) pair from the handle table.
    It also optionally destroys the handle.

Arguments:

    None
Return Value:

    None
--*/
{
    return WahRemoveHandleContext (sm_context_table, this);
}




PDSOCKET
DSOCKET::FindIFSSocket(
    IN  SOCKET     SocketHandle
    )
/*++
Routine Description

    This routine queries all IFS provider for the socket handle.
    If provider recognizes the socket, DSOCKET object for it
    is read from the table

Arguments:

    SocketHandle   - Supplies the client-level socket handle to be mapped.


Return Value:

    DSOCKET object or NULL in case the object cannot be found
--*/
{
    DWORD     flags;
    INT       result;
    PDPROCESS process = NULL;
    PDCATALOG catalog = NULL;
    PDSOCKET  temp_dsocket;

    //
    // Cannot find an association for the socket. Find the current
    // protocol catalog, and ask it to search the installed IFS providers
    // for one recognizing the socket.  Make sure the handle is valid
    //

    temp_dsocket = NULL;  // until proven otherwise

    if ( SocketHandle!=INVALID_SOCKET && // (NtCurrentProcess==(HANDLE)-1)
            GetHandleInformation( (HANDLE)SocketHandle, &flags ) ) {

        process = DPROCESS::GetCurrentDProcess();

        if( process!=NULL ) {

            catalog = process->GetProtocolCatalog();
            assert( catalog != NULL );

            result = catalog->FindIFSProviderForSocket( SocketHandle );

            if( result == ERROR_SUCCESS ) {
                //
                // One of the installed IFS providers recognized the socket.
                // Requery the context. If this fails, we'll just give up.
                //
                temp_dsocket = GetCountedDSocketFromSocketNoExport (SocketHandle);

                //
                // If we successed, mark socket as API socket because
                // we are going to return it from some API call.
                //
                if (temp_dsocket!=NULL)
                    temp_dsocket->m_api_socket = TRUE;
            }
        }
    }
   

    return(temp_dsocket);
} // FindIFSSocket


INT
DSOCKET::AddSpecialApiReference(
    IN SOCKET SocketHandle
    )
/*++

Routine Description:

    Mark socket so that we know that it was returned via API call to the
    application

Arguments:

    SocketHandle - The handle to reference.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/
{
    PDSOCKET Socket;

    //
    // First, get a pointer to the (newly created) socket.
    // No need to do export in this case.
    //

    Socket = GetCountedDSocketFromSocketNoExport(
              SocketHandle
              );

    if( Socket!=NULL ) {
        // The app may start using handle before it event sees it
        // which causes as to import it from the provider and set
        // this flag.
        // At least one java test app does this.
        //assert (Socket->m_api_socket==FALSE);
        Socket->m_api_socket = TRUE;
        Socket->DropDSocketReference();
        return NO_ERROR;
    }
    else {
        //
        // This can only happen if we are being cleaned up
        //
        assert (DPROCESS::GetCurrentDProcess()==NULL);
        return WSASYSCALLFAILURE;
    }

} // AddSpecialApiReference
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\dupsock.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    dupsock.cpp

Abstract:

    This   module   contains   the   winsock   API   functions   dealing   with
    duplicating/sharing sockets.  The following functions are contained in this
    module.

    WSADuplicateSocketA()
    WSADuplicateSocketW()

Author:

    Dirk Brandewie dirk@mink.intel.com  14-06-1995


Revision History:

    09-19-95  drewsxpa@ashland.intel.com
        Changed over to C++, actually implemented the function

--*/


#include "precomp.h"




int WSAAPI
WSADuplicateSocketW(
    IN  SOCKET          s,
    IN  DWORD           dwProcessId,
    OUT LPWSAPROTOCOL_INFOW lpProtocolInfo
    )
/*++

Routine Description:

    Return a WSAPROTOCOL_INFOW structure that can be used to create a new socket
    descriptor for a shared socket.

Arguments:

    s              - Supplies the local socket descriptor.

    dwProcessId    - Supplies the ID of the target process for which the shared
                     socket will be used.

    lpProtocolInfo - Returns a WSAPROTOCOL_INFOW struct identifying the socket
                     in the target process.

Return Value:

    If  the  function  is  successful,  it  returns ERROR_SUCCESS, otherwise it
    returns  SOCKET_ERROR,  and  a specific error message can be retrieved with
    WSAGetLastError().
--*/
{
    INT        ErrorCode, ReturnValue;
    PDPROVIDER Provider;
    PDSOCKET   Socket;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode == ERROR_SUCCESS) {

        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPDuplicateSocket(
                s,
                dwProcessId,
                lpProtocolInfo,
                & ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
} // WSADuplicateSocketW




int WSAAPI
WSADuplicateSocketA(
    IN  SOCKET          s,
    IN  DWORD           dwProcessId,
    OUT LPWSAPROTOCOL_INFOA lpProtocolInfo
    )
/*++

Routine Description:

    ANSI thunk to WSADuplicateSocketW.

Arguments:

    s              - Supplies the local socket descriptor.

    dwProcessId    - Supplies the ID of the target process for which the shared
                     socket will be used.

    lpProtocolInfo - Returns a WSAPROTOCOL_INFOA struct identifying the socket
                     in the target process.

Return Value:

    If  the  function  is  successful,  it  returns ERROR_SUCCESS, otherwise it
    returns  SOCKET_ERROR,  and  a specific error message can be retrieved with
    WSAGetLastError().
--*/
{

    INT               result;
    INT               error;
    WSAPROTOCOL_INFOW ProtocolInfoW;

    //
    // Call through to the UNICODE version.
    //

    result = WSADuplicateSocketW(
                 s,
                 dwProcessId,
                 &ProtocolInfoW
                 );

    if( result == ERROR_SUCCESS ) {

        //
        // Map the UNICODE WSAPROTOCOL_INFOW to ANSI.
        //

        if( lpProtocolInfo == NULL ) {

            error = WSAEFAULT;

        } else {

            error = MapUnicodeProtocolInfoToAnsi(
                        &ProtocolInfoW,
                        lpProtocolInfo
                        );

        }

        if( error != ERROR_SUCCESS ) {

            SetLastError( error );
            result = SOCKET_ERROR;

        }

    }

    return result;

} // WSADuplicateSocketA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\enumprot.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    enumprot.cpp

Abstract:

    This module contains the WSAEnumProtocol entrypoint for the
    winsock API.


Author:

    Dirk Brandewie dirk@mink.intel.com  14-06-1995

[Environment:]

[Notes:]

Revision History:

    22-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Moved includes to precomp.h


--*/

#include "precomp.h"

#define END_PROTOCOL_LIST_MARKER 0

// The  following  structure is passed as a passback value to the provider path
// iterator.   The  user  arguments  are  copied to ProviderId, PathBuffer, and
// PathBufferLength.   If  the  provider  is found then ProviderFound is set to
// TRUE  and  the  actual  number  of bytes needed for the path is written into
// CharsNeeded.   The  path is copied into the buffer if there is enough space,
// otherwise the buffer is not used.
typedef struct
{
    GUID   ProviderId;
    LPWSTR PathBuffer;
    INT    PathBufferLength;
    INT    CharsNeeded;
    BOOL   ProviderFound;
    INT    ErrorCode;
} PATH_ENUMERATION_CONTEXT,  *PPATH_ENUMERATION_CONTEXT;


//
// Stucture to be used as a passback value to the catalog iterator. The user
// arguments to WSAEnumProtocols are copied into "Protocols", "ProtocolBuffer"
// and BufferLength. BytesUsed and ProtocolCount are used for bookkeeping in
// the enumeration procedure ProtocolIterationProc() and the functions it calls
// to do its work.
//
typedef struct
{
    LPINT               Protocols;
    LPWSAPROTOCOL_INFOW ProtocolBuffer;
    DWORD               BufferLength;
    DWORD               BytesUsed;
    DWORD               ProtocolCount;
    INT                 ErrorCode;
} PROTOCOL_ENUMERATION_CONTEXT, *PPROTOCOL_ENUMERATION_CONTEXT;

//Return whether there is enough room in the application buffer to
//hold another WSAPROTOCOL_INFOW struct
#define OK_TO_COPY_PROTOCOL(p_context)\
(((p_context)->BytesUsed + sizeof(WSAPROTOCOL_INFOW)) <=\
((p_context)->BufferLength)?TRUE:FALSE)

#define NEXT_BUFFER_LOCATION(p_context)\
((char*)(p_context)->ProtocolBuffer + (p_context)->BytesUsed)



static
VOID
CopyProtocolInfo(
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    IN PPROTOCOL_ENUMERATION_CONTEXT Context
    )
/*++
Routine Description:

    Copies a protocol info struct onto the end of a user buffer is enough room
    exists in the user buffer.

Arguments:

    ProtocolInfo - A Pointer to a WSAPROTOCOL_INFOW struct to be copied.

    Context - A Pointer to an enumeration context structure. This structure
              contians all the infomation about the user buffer.

Returns:

--*/
{
    if (OK_TO_COPY_PROTOCOL(Context)) {
        CopyMemory(
            NEXT_BUFFER_LOCATION(Context),
            ProtocolInfo,
            sizeof(WSAPROTOCOL_INFOW));

        // So we can tell the user how many WSAPROTOCOL_INFOW struct
        // we copied into their buffer
        Context->ProtocolCount++;
    } //if
}


static
BOOL
IsProtocolInSet(
    IN LPINT Set,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo
    )
/*++
Routine Description:

    This function returns whether the protocol described by ProtocolInfo is a
    member of the set of protocols pointed to by Set.

Arguments:

    Set - Apointer to an array of protocol ID's

    ProtocolInfo - A Pointer to a WSAPROTOCOL_INFOW struct.

Returns:

--*/
{
    BOOL ReturnCode  =FALSE;
    INT   SetIndex   =0;
    INT   ProtocolID =0;

    if (Set) {
        ProtocolID = Set[SetIndex];
        while (ProtocolID != END_PROTOCOL_LIST_MARKER) {
            if ((ProtocolID >= ProtocolInfo->iProtocol) &&
                (ProtocolID <= (ProtocolInfo->iProtocol +
                               ProtocolInfo->iProtocolMaxOffset))
                ) {
                ReturnCode = TRUE;
                break;
            } //if
            SetIndex++;
            ProtocolID = Set[SetIndex];
        } //while
    } //if
    else {
        // If the set pointer is null all protocols are in the set.
        ReturnCode = TRUE;
    } //else
    return(ReturnCode);
}




static
BOOL
ProtocolIterationProcAPI(
    IN OUT PVOID IterationContext,
    IN PPROTO_CATALOG_ITEM  CatalogEntry
    )
/*++
Routine Description:

    This  function  is the enumeration procedure passed to the protocol catalog
    enumeration  function.   It  adds  the  protocol  to  the list if (1) it is
    allowed  by the protocol list restriction set, (2) if it is not hidden, and
    (3) it is not a non-chained layer.  "Adding to the list" only has effect if
    there is room in the buffer.

    The  procedure  updates  the  number  of  bytes "used" for each protocol it
    accepts regardless of whether it actually found room in the buffer or not.

Arguments:

    IterationContext - Passback value from call to
                       DCATALOG::EnumerateCatalogItems();

    CatalofEntry - A pointer to a PROTO_CATALOG_ITEM.

Returns:
    TRUE to continue the enumeration of the protocol catalog

--*/
{
    PPROTOCOL_ENUMERATION_CONTEXT Context;
    LPWSAPROTOCOL_INFOW ProtocolInfo;

    Context = (PPROTOCOL_ENUMERATION_CONTEXT)IterationContext;
    ProtocolInfo = CatalogEntry->GetProtocolInfo();

    __try {
        // If the protocol meets acceptance criteria, then add it
        if (IsProtocolInSet(Context->Protocols, ProtocolInfo)) {
            if (! ((ProtocolInfo->dwProviderFlags) & PFL_HIDDEN)) {
                if (ProtocolInfo->ProtocolChain.ChainLen != LAYERED_PROTOCOL) {
                    CopyProtocolInfo(ProtocolInfo, Context);
                    Context->BytesUsed += sizeof(WSAPROTOCOL_INFOW);
                } // if non-layered
            } //if non-hidden
        } //if is in set
        return(TRUE); //Continue enumeration
    }
    __except (WS2_EXCEPTION_FILTER()) {
        Context->ErrorCode = WSAEFAULT;
        return FALSE;
    }

}




static
BOOL
ProtocolIterationProcSPI(
    IN OUT PVOID IterationContext,
    IN PPROTO_CATALOG_ITEM  CatalogEntry
    )
/*++
Routine Description:

    This  function  is the enumeration procedure passed to the protocol catalog
    enumeration function.  It adds the protocol to the list if it is allowed by
    the protocol list restriction set.  "Adding to the list" only has effect if
    there is room in the buffer.

    The  procedure  updates  the  number  of  bytes "used" for each protocol it
    accepts regardless of whether it actually found room in the buffer or not.

Arguments:

    IterationContext - Passback value from call to
                       DCATALOG::EnumerateCatalogItems();

    CatalofEntry - A pointer to a PROTO_CATALOG_ITEM.

Returns:
    TRUE to continue the enumeration of the protocol catalog

--*/
{
    PPROTOCOL_ENUMERATION_CONTEXT Context;
    LPWSAPROTOCOL_INFOW ProtocolInfo;

    Context = (PPROTOCOL_ENUMERATION_CONTEXT)IterationContext;
    ProtocolInfo = CatalogEntry->GetProtocolInfo();

    __try {
        // If the protocol meets acceptance criteria, then add it.
        if (IsProtocolInSet(Context->Protocols, ProtocolInfo)) {
            CopyProtocolInfo(ProtocolInfo, Context);
            Context->BytesUsed += sizeof(WSAPROTOCOL_INFOW);
        } //if
        return(TRUE); //Continue enumeration
    }
    __except (WS2_EXCEPTION_FILTER()) {
        Context->ErrorCode = WSAEFAULT;
        return FALSE;
    }
}


int WSAAPI
WSAEnumProtocolsW(
    IN LPINT                lpiProtocols,
    OUT LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    IN OUT LPDWORD          lpdwBufferLength
    )
/*++
Routine Description:

    Retrieve information about available transport protocols.

Arguments:

    lpiProtocols     - A NULL-terminated array of protocol ids.  This parameter
                       is optional; if lpiProtocols is NULL, information on all
                       available  protocols  is returned, otherwise information
                       is  retrieved  only  for  those  protocols listed in the
                       array.

    lpProtocolBuffer - A buffer which is filled with WSAPROTOCOL_INFOW
                       structures.  See below for a detailed description of the
                       contents of the WSAPROTOCOL_INFOW structure.

    lpdwBufferLength - On input, the count of bytes in the lpProtocolBuffer
                       buffer passed to WSAEnumProtocols().  On output, the
                       minimum buffer size that can be passed to
                       WSAEnumProtocols() to retrieve all the requested
                       information.  This routine has no ability to enumerate
                       over multiple calls; the passed-in buffer must be large
                       enough to hold all entries in order for the routine to
                       succeed.  This reduces the complexity of the API and
                       should not pose a problem because the number of
                       protocols loaded on a machine is typically small.

Returns:
    The number of protocols to be reported on. Otherwise a value of
    SOCKET_ERROR is returned and a specific  stored with SetLastError().
--*/
{
    INT                          ReturnCode;
    PDPROCESS                    Process;
    PDTHREAD                     Thread;
    INT                          ErrorCode;
    PDCATALOG                    Catalog;
    PROTOCOL_ENUMERATION_CONTEXT EnumerationContext;


    ErrorCode = PROLOG(&Process, &Thread);

    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    } //if

    // Setup the enumeration context structure to hand the the
    // protocol catalog iterator.
    EnumerationContext.Protocols = lpiProtocols;
    EnumerationContext.ProtocolBuffer = lpProtocolBuffer;
    if (lpProtocolBuffer) {
        __try {
            EnumerationContext.BufferLength = *lpdwBufferLength;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            SetLastError (WSAEFAULT);
            return SOCKET_ERROR;
        }
    }
    else {
        EnumerationContext.BufferLength = 0;
    }

    EnumerationContext.BytesUsed = 0;
    EnumerationContext.ProtocolCount= 0;
    EnumerationContext.ErrorCode = ERROR_SUCCESS;

    Catalog = Process->GetProtocolCatalog();
    assert(Catalog);

    // Start the iteration through the catalog. All the real work is
    // done in ProtocolIterationProc
    Catalog->EnumerateCatalogItems(ProtocolIterationProcAPI,
                                   &EnumerationContext);
    if (EnumerationContext.ErrorCode==ERROR_SUCCESS) {
        ReturnCode = EnumerationContext.ProtocolCount;

        __try {
            if ( EnumerationContext.BufferLength < EnumerationContext.BytesUsed) {
                *lpdwBufferLength = EnumerationContext.BytesUsed;
                SetLastError(WSAENOBUFS);
                ReturnCode = SOCKET_ERROR;
            } //if
        }
        __except (WS2_EXCEPTION_FILTER()) {
            SetLastError (WSAEFAULT);
            ReturnCode = SOCKET_ERROR;
        }
    }
    else {
        SetLastError (EnumerationContext.ErrorCode);
        ReturnCode = SOCKET_ERROR;
    }

    return(ReturnCode);
}



PDCATALOG
OpenInitializedCatalog()
{
    INT ReturnCode;
    PDCATALOG protocol_catalog;
    HKEY RegistryKey = 0;

    //
    // Build the protocol catalog
    //
    protocol_catalog = new(DCATALOG);
    if (protocol_catalog) {
        TRY_START(mem_guard){
            RegistryKey = OpenWinSockRegistryRoot();
            if (!RegistryKey) {
                DEBUGF(
                    DBG_ERR,
                    ("OpenWinSockRegistryRoot Failed \n"));
                TRY_THROW(mem_guard);
            } //if

            ReturnCode = protocol_catalog->InitializeFromRegistry(
                                RegistryKey,        // ParentKey
                                NULL                // ChangeEvent
                                );
            if (ERROR_SUCCESS != ReturnCode) {
                DEBUGF(
                    DBG_ERR,
                    ("Initializing from registry\n"));
                TRY_THROW(mem_guard);
            } //if

        }TRY_CATCH(mem_guard) {

            delete(protocol_catalog);
            protocol_catalog = NULL;
        }TRY_END(mem_guard);

        if (RegistryKey) {
            LONG close_result;
            close_result = RegCloseKey(
                RegistryKey);  // hkey
            assert(close_result == ERROR_SUCCESS);
        } // if
    }
    else {
        DEBUGF(
            DBG_ERR,
            ("Allocating dcatalog object\n"));
    } //if

    return(protocol_catalog);
}



int WSPAPI
WSCEnumProtocols(
    IN LPINT                lpiProtocols,
    OUT LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    IN OUT LPDWORD          lpdwBufferLength,
    LPINT lpErrno
    )
/*++
Routine Description:

    Retrieve information about available transport protocols.

Arguments:

    lpiProtocols     - A NULL-terminated array of protocol ids.  This parameter
                       is optional; if lpiProtocols is NULL, information on all
                       available  protocols  is returned, otherwise information
                       is  retrieved  only  for  those  protocols listed in the
                       array.

    lpProtocolBuffer - A buffer which is filled with WSAPROTOCOL_INFOW
                       structures.  See below for a detailed description of the
                       contents of the WSAPROTOCOL_INFOW structure.

    lpdwBufferLength - On input, the count of bytes in the lpProtocolBuffer
                       buffer passed to WSAEnumProtocols().  On output, the
                       minimum buffer size that can be passed to
                       WSAEnumProtocols() to retrieve all the requested
                       information.  This routine has no ability to enumerate
                       over multiple calls; the passed-in buffer must be large
                       enough to hold all entries in order for the routine to
                       succeed.  This reduces the complexity of the API and
                       should not pose a problem because the number of
                       protocols loaded on a machine is typically small.

Returns:
    The number of protocols to be reported on. Otherwise a value of
    SOCKET_ERROR is returned and a specific error code is returned in lpErrno
--*/
{
    BOOL                         delete_catalog=FALSE;
    PDPROCESS                    Process;
    PDTHREAD                     Thread;
    INT                          ErrorCode;
    PDCATALOG                    Catalog;
    PROTOCOL_ENUMERATION_CONTEXT EnumerationContext;

    ErrorCode = PROLOG(&Process,&Thread);

    if (ErrorCode == ERROR_SUCCESS) {

        Catalog = Process->GetProtocolCatalog();
        assert(Catalog);
    }
    else if (ErrorCode == WSANOTINITIALISED) {

        // Take care of case when called with a prior WSAStartup()
        // as when called from WSCGetProviderPath

        Catalog = OpenInitializedCatalog();
        if (Catalog==NULL) {
            ErrorCode = WSA_NOT_ENOUGH_MEMORY;
            goto ExitNoCatalog;
        }
        delete_catalog = TRUE;
        ErrorCode = ERROR_SUCCESS;
    }
    else {
        goto ExitNoCatalog;
    }

    // Setup the enumeration context structure to hand the the
    // protocol catalog iterator.
    EnumerationContext.Protocols = lpiProtocols;
    EnumerationContext.ProtocolBuffer = lpProtocolBuffer;
    if (lpProtocolBuffer) {
        __try {
            EnumerationContext.BufferLength = *lpdwBufferLength;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            ErrorCode = WSAEFAULT;
            WS2_32_W4_INIT EnumerationContext.ProtocolCount = 0;
            goto Exit;
        }
    }
    else {
        EnumerationContext.BufferLength = 0;
    }
    EnumerationContext.BytesUsed = 0;
    EnumerationContext.ProtocolCount= 0;
    EnumerationContext.ErrorCode = ERROR_SUCCESS;

    Catalog->EnumerateCatalogItems(ProtocolIterationProcSPI,
                                   &EnumerationContext);
    if (EnumerationContext.ErrorCode==ERROR_SUCCESS) {
        if ( EnumerationContext.BufferLength >= EnumerationContext.BytesUsed) {
            assert (ErrorCode == ERROR_SUCCESS);
        }
        else {
            __try {
                *lpdwBufferLength = EnumerationContext.BytesUsed;
                ErrorCode = WSAENOBUFS;
            }
            __except (WS2_EXCEPTION_FILTER()) {
                ErrorCode = WSAEFAULT;
            }
        } //if
    }
    else {
        ErrorCode = EnumerationContext.ErrorCode;
    }

Exit:
    if (delete_catalog) {

        delete Catalog;
    }

    if (ErrorCode==ERROR_SUCCESS) {
        return EnumerationContext.ProtocolCount;
    }

ExitNoCatalog:
    __try {
        *lpErrno = ErrorCode;
    }
    __except (WS2_EXCEPTION_FILTER ()) {
        ;
    }
    return SOCKET_ERROR;
}


#ifdef _WIN64
int WSPAPI
WSCEnumProtocols32(
    IN LPINT                lpiProtocols,
    OUT LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    IN OUT LPDWORD          lpdwBufferLength,
    LPINT                   lpErrno
    )
/*++
Routine Description:

    Retrieve information about available transport protocols.

Arguments:

    lpiProtocols     - A NULL-terminated array of protocol ids.  This parameter
                       is optional; if lpiProtocols is NULL, information on all
                       available  protocols  is returned, otherwise information
                       is  retrieved  only  for  those  protocols listed in the
                       array.

    lpProtocolBuffer - A buffer which is filled with WSAPROTOCOL_INFOW
                       structures.  See below for a detailed description of the
                       contents of the WSAPROTOCOL_INFOW structure.

    lpdwBufferLength - On input, the count of bytes in the lpProtocolBuffer
                       buffer passed to WSAEnumProtocols().  On output, the
                       minimum buffer size that can be passed to
                       WSAEnumProtocols() to retrieve all the requested
                       information.  This routine has no ability to enumerate
                       over multiple calls; the passed-in buffer must be large
                       enough to hold all entries in order for the routine to
                       succeed.  This reduces the complexity of the API and
                       should not pose a problem because the number of
                       protocols loaded on a machine is typically small.

Returns:
    The number of protocols to be reported on. Otherwise a value of
    SOCKET_ERROR is returned and a specific error code is returned in lpErrno
--*/
{
    INT                          ErrorCode;
    PDCATALOG                    Catalog = NULL;
    PROTOCOL_ENUMERATION_CONTEXT EnumerationContext;
    HKEY registry_root;

    registry_root = OpenWinSockRegistryRoot();
    if (registry_root == NULL) {
        DEBUGF(
            DBG_ERR,
            ("Opening registry root\n"));
        ErrorCode = WSANO_RECOVERY;
        WS2_32_W4_INIT EnumerationContext.ProtocolCount = 0;
        goto Exit;
    }

    //
    // Build the protocol catalog
    //
    Catalog = new(DCATALOG);

    if (Catalog!=NULL) {
        
        ErrorCode = Catalog->InitializeFromRegistry32(
                            registry_root
                            );
    }
    else {
        ErrorCode = WSA_NOT_ENOUGH_MEMORY;
        DEBUGF(
            DBG_ERR,
            ("Allocating dcatalog object\n"));
    }


    {
        LONG close_result;
        close_result = RegCloseKey(
            registry_root);  // hkey
        assert(close_result == ERROR_SUCCESS);
    }


    if (ErrorCode!=ERROR_SUCCESS) {
        WS2_32_W4_INIT EnumerationContext.ProtocolCount = 0;
        goto Exit;
    }

    assert (Catalog!=NULL);

    // Setup the enumeration context structure to hand the the
    // protocol catalog iterator.
    EnumerationContext.Protocols = lpiProtocols;
    EnumerationContext.ProtocolBuffer = lpProtocolBuffer;
    if (lpProtocolBuffer) {
        __try {
            EnumerationContext.BufferLength = *lpdwBufferLength;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            ErrorCode = WSAEFAULT;
            WS2_32_W4_INIT EnumerationContext.ProtocolCount = 0;
            goto Exit;
        }
    }
    else {
        EnumerationContext.BufferLength = 0;
    }
    EnumerationContext.BytesUsed = 0;
    EnumerationContext.ProtocolCount= 0;
    EnumerationContext.ErrorCode = ERROR_SUCCESS;

    Catalog->EnumerateCatalogItems(ProtocolIterationProcSPI,
                                   &EnumerationContext);
    if (EnumerationContext.ErrorCode==ERROR_SUCCESS) {
        if ( EnumerationContext.BufferLength >= EnumerationContext.BytesUsed) {
            assert (ErrorCode == ERROR_SUCCESS);
        }
        else {
            __try {
                *lpdwBufferLength = EnumerationContext.BytesUsed;
                ErrorCode = WSAENOBUFS;
            }
            __except (WS2_EXCEPTION_FILTER()) {
                ErrorCode = WSAEFAULT;
            }
        } //if
    }
    else {
        ErrorCode = EnumerationContext.ErrorCode;
    }

Exit:
    if (Catalog!=NULL) {

        delete Catalog;
    }

    if (ErrorCode==ERROR_SUCCESS) {
        return EnumerationContext.ProtocolCount;
    }
    else {
        __try {
            *lpErrno = ErrorCode;
        }
        __except (WS2_EXCEPTION_FILTER ()) {
            ;
        }
        return SOCKET_ERROR;
    }
}
#endif


static
BOOL
PathIterationProc(
    IN OUT PVOID IterationContext,
    IN PPROTO_CATALOG_ITEM  CatalogEntry
    )
/*++
Routine Description:

    This function is the enumeration procedure passed to the protocol catalog
    enumeration function.

Arguments:

    IterationContext - Passback value from call to
                       DCATALOG::EnumerateCatalogItems();

    CatalofEntry - A pointer to a PROTO_CATALOG_ITEM.

Returns:
    TRUE to continue the enumeration of the protocol catalog

--*/
{
    PPATH_ENUMERATION_CONTEXT Context;
    LPWSAPROTOCOL_INFOW ProtocolInfo;

    Context = (PPATH_ENUMERATION_CONTEXT)IterationContext;
    ProtocolInfo = CatalogEntry->GetProtocolInfo();

    // If  the  entry  is  the  correct  one,  update  the context and stop the
    // enumeration.
    if( ProtocolInfo->ProviderId == Context->ProviderId ) {
        LPWSTR Path;
        INT   PathLen;

        Path =  CatalogEntry->GetLibraryPath();
        PathLen = lstrlenW(Path) + 1;
        Context->CharsNeeded = PathLen;
        Context->ProviderFound = TRUE;
        if (PathLen <= Context->PathBufferLength)
        {
            __try {
                lstrcpyW (Context->PathBuffer, Path);
            }
            __except (WS2_EXCEPTION_FILTER()) {
                Context->ErrorCode = WSAEFAULT;
            }
        } //if
        return(FALSE); //Discontinue enumeration
    } //if
    return(TRUE); //Continue enumeration
}

int WSPAPI WPUGetProviderPath(
    IN LPGUID lpProviderId,
    OUT WCHAR FAR * lpszProviderDllPath,
    IN OUT LPINT ProviderDLLPathLen,
    OUT LPINT lpErrno )
/*++
Routine Description:

    Returns the path to the provider DLL associated with a specific providerId

Arguments:

    lpProviderId - The ID of the provider to look up.

    lpszProviderDllPath - A pointer to a buffer to hold the path to the
                          provider DLL

    ProviderDLLPathLen - On input the size of lpszProviderDllPath, on output
                         the number of chars used.

    lpErrno - A pointer to the error value of the function.

Returns:
    WSCGetProviderPath() returns 0. Otherwise, it returns SOCKET_ERROR, and a
    specific error code is available in lpErrno.
--*/
{
    BOOL                      delete_catalog=FALSE;
    PDPROCESS                 Process;
    PDTHREAD                  Thread;
    INT                       ErrorCode;
    PDCATALOG                 Catalog;
    PATH_ENUMERATION_CONTEXT  EnumerationContext;

    ErrorCode = PROLOG(&Process,&Thread);


    if (ErrorCode == ERROR_SUCCESS) {

        Catalog = Process->GetProtocolCatalog();
        assert(Catalog);
    }
    else if (ErrorCode == WSANOTINITIALISED) {

        // Take care of case when called with a prior WSAStartup()
        // as when called from WSCGetProviderPath

        Catalog = OpenInitializedCatalog();
        if (Catalog==NULL) {
            ErrorCode = WSAENOBUFS;
            goto ExitNoCatalog;
        }
        delete_catalog = TRUE;
    }
    else {
        goto ExitNoCatalog;
    }

    __try {
        // Setup the enumeration context structure to hand to the
        // protocol catalog iterator.
        EnumerationContext.ProviderId       = *lpProviderId;
        EnumerationContext.PathBuffer       = lpszProviderDllPath;
        EnumerationContext.PathBufferLength = *ProviderDLLPathLen;
        EnumerationContext.CharsNeeded      = 0;
        EnumerationContext.ProviderFound    = FALSE;
        EnumerationContext.ErrorCode        = ERROR_SUCCESS;
    }
    __except (WS2_EXCEPTION_FILTER()) {
        ErrorCode = WSAEFAULT;
        goto Exit;
    }


    // Start the iteration through the catalog. All the real work is
    // done in ProtocolIterationProc
    Catalog->EnumerateCatalogItems(PathIterationProc,
                                   &EnumerationContext);

    if (EnumerationContext.ErrorCode==ERROR_SUCCESS) {
        __try {
            if (EnumerationContext.ProviderFound) {
                if (EnumerationContext.CharsNeeded > * ProviderDLLPathLen) {
                    ErrorCode = WSAEFAULT;
                    *ProviderDLLPathLen = EnumerationContext.CharsNeeded;
                } //if
                else
                    *ProviderDLLPathLen = EnumerationContext.CharsNeeded - 1;
            } // if found
            else {
                ErrorCode = WSAEINVAL;
            }
        }
        __except (WS2_EXCEPTION_FILTER()) {
            ErrorCode = WSAEFAULT;
        }
    }
    else {
        ErrorCode = EnumerationContext.ErrorCode;
    }

Exit:
    if (delete_catalog) {

        delete Catalog;
    }

    if (ErrorCode==ERROR_SUCCESS)
        return ERROR_SUCCESS;

ExitNoCatalog:
    __try {
        *lpErrno = ErrorCode;
    }
    __except (WS2_EXCEPTION_FILTER ()) {
        ;
    }
    return SOCKET_ERROR;
}


int
WSPAPI
WSCGetProviderPath(
    IN LPGUID lpProviderId,
    OUT WCHAR FAR * lpszProviderDllPath,
    IN OUT LPINT ProviderDLLPathLen,
    OUT LPINT lpErrno )
{
    return WPUGetProviderPath(
               lpProviderId,
               lpszProviderDllPath,
               ProviderDLLPathLen,
               lpErrno
               );
}


#ifdef _WIN64
int
WSPAPI
WSCGetProviderPath32 (
    IN LPGUID lpProviderId,
    OUT WCHAR FAR * lpszProviderDllPath,
    IN OUT LPINT ProviderDLLPathLen,
    OUT LPINT lpErrno )
{
    INT                          ErrorCode;
    PDCATALOG                    Catalog = NULL;
    PATH_ENUMERATION_CONTEXT  EnumerationContext;
    HKEY registry_root;

    registry_root = OpenWinSockRegistryRoot();
    if (registry_root == NULL) {
        DEBUGF(
            DBG_ERR,
            ("Opening registry root\n"));
        ErrorCode = WSANO_RECOVERY;
        goto Exit;
    }

    //
    // Build the protocol catalog
    //
    Catalog = new(DCATALOG);

    if (Catalog!=NULL) {
        
        ErrorCode = Catalog->InitializeFromRegistry32(
                            registry_root
                            );
    }
    else {
        ErrorCode = WSA_NOT_ENOUGH_MEMORY;
        DEBUGF(
            DBG_ERR,
            ("Allocating dcatalog object\n"));
    }


    {
        LONG close_result;
        close_result = RegCloseKey(
            registry_root);  // hkey
        assert(close_result == ERROR_SUCCESS);
    }


    if (ErrorCode!=ERROR_SUCCESS) {
        goto Exit;
    }

    assert (Catalog!=NULL);

    __try {
        // Setup the enumeration context structure to hand to the
        // protocol catalog iterator.
        EnumerationContext.ProviderId       = *lpProviderId;
        EnumerationContext.PathBuffer       = lpszProviderDllPath;
        EnumerationContext.PathBufferLength = *ProviderDLLPathLen;
        EnumerationContext.CharsNeeded      = 0;
        EnumerationContext.ProviderFound    = FALSE;
        EnumerationContext.ErrorCode        = ERROR_SUCCESS;
    }
    __except (WS2_EXCEPTION_FILTER()) {
        ErrorCode = WSAEFAULT;
        goto Exit;
    }


    // Start the iteration through the catalog. All the real work is
    // done in ProtocolIterationProc
    Catalog->EnumerateCatalogItems(PathIterationProc,
                                   &EnumerationContext);

    if (EnumerationContext.ErrorCode==ERROR_SUCCESS) {
        __try {
            if (EnumerationContext.ProviderFound) {
                if (EnumerationContext.CharsNeeded > * ProviderDLLPathLen) {
                    ErrorCode = WSAEFAULT;
                    *ProviderDLLPathLen = EnumerationContext.CharsNeeded;
                } //if
                else
                    *ProviderDLLPathLen = EnumerationContext.CharsNeeded - 1;
            } // if found
            else {
                ErrorCode = WSAEINVAL;
            }
        }
        __except (WS2_EXCEPTION_FILTER()) {
            ErrorCode = WSAEFAULT;
        }
    }
    else {
        ErrorCode = EnumerationContext.ErrorCode;
    }

Exit:
    if (Catalog!=NULL) {

        delete Catalog;
    }

    if (ErrorCode==ERROR_SUCCESS)
        return ERROR_SUCCESS;
    else {
        __try {
            *lpErrno = ErrorCode;
        }
        __except (WS2_EXCEPTION_FILTER ()) {
            ;
        }
        return SOCKET_ERROR;
    }
}
#endif


int WSAAPI
WSAEnumProtocolsA(
    IN LPINT                lpiProtocols,
    OUT LPWSAPROTOCOL_INFOA lpProtocolBuffer,
    IN OUT LPDWORD          lpdwBufferLength
    )
/*++
Routine Description:

    ANSI thunk to WSAEnumProtocolsW.

Arguments:

    lpiProtocols     - A NULL-terminated array of protocol ids.  This parameter
                       is optional; if lpiProtocols is NULL, information on all
                       available  protocols  is returned, otherwise information
                       is  retrieved  only  for  those  protocols listed in the
                       array.

    lpProtocolBuffer - A buffer which is filled with WSAPROTOCOL_INFOA
                       structures.  See below for a detailed description of the
                       contents of the WSAPROTOCOL_INFOA structure.

    lpdwBufferLength - On input, the count of bytes in the lpProtocolBuffer
                       buffer passed to WSAEnumProtocols().  On output, the
                       minimum buffer size that can be passed to
                       WSAEnumProtocols() to retrieve all the requested
                       information.  This routine has no ability to enumerate
                       over multiple calls; the passed-in buffer must be large
                       enough to hold all entries in order for the routine to
                       succeed.  This reduces the complexity of the API and
                       should not pose a problem because the number of
                       protocols loaded on a machine is typically small.

Returns:
    The number of protocols to be reported on. Otherwise a value of
    SOCKET_ERROR is returned and a specific  stored with SetLastError().
--*/
{

    LPWSAPROTOCOL_INFOW ProtocolInfoW;
    DWORD NumProtocolEntries;
    DWORD ProtocolInfoALength, ProtocolInfoWLength;
    INT result;
    INT error;
    INT i;

    __try {
        ProtocolInfoALength = *lpdwBufferLength;
    }
    __except (WS2_EXCEPTION_FILTER()) {
        SetLastError (WSAEFAULT);
        return SOCKET_ERROR;
    }

    if( ProtocolInfoALength > 0 && lpProtocolBuffer!=NULL) {

        //
        // Since all of the structures are of fixed size (no embedded
        // pointers to variable-sized data) we can calculate the required
        // size of the UNICODE buffer by dividing the buffer size by the size
        // of the ANSI structure, then multiplying by the size of the
        // UNICODE structure.
        //

        NumProtocolEntries  = ProtocolInfoALength / sizeof(WSAPROTOCOL_INFOA);
        ProtocolInfoWLength = NumProtocolEntries * sizeof(WSAPROTOCOL_INFOW);

        //
        // Try to allocate the UNICODE buffer.
        //

        ProtocolInfoW = new WSAPROTOCOL_INFOW[NumProtocolEntries];

        if( ProtocolInfoW == NULL ) {

            SetLastError( WSA_NOT_ENOUGH_MEMORY );
            return SOCKET_ERROR;

        }

    } 
    else {

        ProtocolInfoW = NULL;
        ProtocolInfoWLength = 0;

    }

    //
    // Call through to the UNICODE version.
    //

    result = WSAEnumProtocolsW(
                 lpiProtocols,
                 ProtocolInfoW,
                 &ProtocolInfoWLength
                 );

    //
    // Map the size back to ANSI.
    //

    __try {
        *lpdwBufferLength = ( ProtocolInfoWLength / sizeof(WSAPROTOCOL_INFOW) ) *
            sizeof(WSAPROTOCOL_INFOA);
    }
    __except (WS2_EXCEPTION_FILTER()) {
        result = SOCKET_ERROR;
        SetLastError (WSAEFAULT);
    }

    if( result == SOCKET_ERROR ) {

        //
        // Could not store the data, probably because the supplied buffer
        // was too small.
        //

        if (ProtocolInfoW!=NULL) {
            delete ProtocolInfoW;
        }
        return result;
    }

    //
    // OK, we've got the UNICODE data now, and we know the user's buffer
    // is sufficient to hold the ANSI structures. Map them in.
    //

    for( i = 0 ; i < result ; i++ ) {

        error = MapUnicodeProtocolInfoToAnsi(
                    ProtocolInfoW + i,
                    lpProtocolBuffer + i
                    );

        if( error != ERROR_SUCCESS ) {

            if (ProtocolInfoW!=NULL) {
                delete ProtocolInfoW;
            }
            SetLastError( error );
            return SOCKET_ERROR;

        }

    }

    //
    // Success!
    //

    if (ProtocolInfoW!=NULL) {
        delete ProtocolInfoW;
    }
    return result;

}   // WSAEnumProtocolsA




int WSAAPI
WSAProviderConfigChange(
    IN OUT LPHANDLE lpNotificationHandle,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
/*++
Routine Description:



Arguments:

    lpNotificationHandle -

    lpOverlapped         -

    lpCompletionRoutine  -

Returns:

--*/
{
    INT                          ErrorCode;
    PDPROCESS                    Process;
    PDTHREAD                     Thread;
    HANDLE                       HelperHandle = NULL, Handle;

    __try {
        Handle = *lpNotificationHandle;
    }
    __except (WS2_EXCEPTION_FILTER()) {
        SetLastError (WSAEFAULT);
        return SOCKET_ERROR;
    }

    ErrorCode = PROLOG(&Process,&Thread);

    if (ErrorCode==ERROR_SUCCESS) {
        ErrorCode = Process->GetNotificationHelperDeviceID(&HelperHandle);
        if (ErrorCode==ERROR_SUCCESS) {
            if (Handle == NULL)
            {
                ErrorCode = WahCreateNotificationHandle(
                    HelperHandle,
                    &Handle
                    );
                if (ErrorCode==ERROR_SUCCESS) {
                    __try {
                        *lpNotificationHandle = Handle;
                    }
                    __except (WS2_EXCEPTION_FILTER()) {
                        ErrorCode = WSAEFAULT;
                    }
                }
            }
            else
            {
                ErrorCode = WahWaitForNotification(
                    HelperHandle,
                    Handle,
                    lpOverlapped,
                    lpCompletionRoutine
                    );
            }
        }
    }


    if (ErrorCode == ERROR_SUCCESS) {
        return (ERROR_SUCCESS);
    }
    else {
        SetLastError(ErrorCode);
        return (SOCKET_ERROR);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\dthread.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    dthread.cpp

Abstract:

    This  module  contains  the  implementation  of  the  DTHREAD class used in
    winsock2 DLL.

Author:

    Dirk Brandewie (dirk@mink.intel.com)   14-July-1995

Notes:

    $Revision:   1.27  $

    $Modtime:   08 Mar 1996 14:59:46  $

Revision History:

    most-recent-revision-date email-name
        description
    23-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Moved includes into precomp.h. Added
        debug/trace code.

--*/
#include "precomp.h"

extern DWORD gdwTlsIndex;

DWORD DTHREAD::sm_tls_index = TLS_OUT_OF_INDEXES;
// Initialize the static member to a known variable



INT
DTHREAD::DThreadClassInitialize()
/*++

Routine Description:

    This  function  performs  global  initialization  required  for the DTHREAD
    class.   This  function  must  be  called  before  any  DTHREAD objects are
    created.  In particular, this function reserves a thread-local storage slot
    for  the thread-local storage used by the WinSock 2 DLL.  Note that this is
    a "static" function with global scope instead of object-instance scope.

Arguments:

    None

Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it
    returns an appropriate WinSock error code.
--*/
{
    INT ReturnCode = WSASYSCALLFAILURE; // the user return code

    if (sm_tls_index == TLS_OUT_OF_INDEXES) {
        DEBUGF( DBG_TRACE,
                ("Initializing dthread class\n"));
        sm_tls_index = gdwTlsIndex;
        if (sm_tls_index != TLS_OUT_OF_INDEXES) {
            ReturnCode = ERROR_SUCCESS;
        } //if
    } //if
    else {
         ReturnCode = ERROR_SUCCESS;
    } //else

    return(ReturnCode);
} //DThreadClassInitialize




VOID
DTHREAD::DThreadClassCleanup()
/*++

Routine Description:

    This  routine  de-inits the thread class.  The thread local storage slot is
    freed.   Note that this is a "static" function with global scope instead of
    object-instance scope.

Arguments:

    None

Return Value:

    None
--*/
{
    //
    // NOTE: The following is bogus, as it means the tls index will never
    // get freed.  Have since taken care of things by alloc'ing/free'ing
    // tls index in DllMain (process attach/detach handlers)
    //

    //
    // This code is elided. We retain the tls index so that thread terminating
    // after the WSACleanup can free the per-thread storage. Since this
    // operation is done only when the thread actually detaches, there's
    // a race between deleting this tls index and the thread completing.
    // So, keep it around. Note that if another WSAStartup is done, the
    // code will simply use this index.
    //

    //
    // Resurected this code but now calling from DllMain (DLL_PROCESS_DETACH)
    // VadimE.
    //
    DEBUGF( DBG_TRACE,
            ("Cleaning up dthread class\n"));
    // Killing it again
    // taking care of it directly in DLLMain
    // VadimE
    if (sm_tls_index != TLS_OUT_OF_INDEXES)
        {
        // TlsFree(sm_tls_index); // Free the TLS slot
        sm_tls_index = TLS_OUT_OF_INDEXES;
    } //if

} //DThreadClassCleanup



INT
DTHREAD::CreateDThreadForCurrentThread(
    IN  PDPROCESS  Process,
    OUT PDTHREAD FAR * CurrentThread
    )
/*++

Routine Description:

    This  procedure  retrieves a reference to a DTHREAD object corresponding to
    the  current  thread.  It takes care of creating and initializing a DTHREAD
    object and installing it into the thread's thread-local storage if there is
    not already a DTHREAD object for this thread.  Note that this is a "static"
    function with global scope instead of object-instance scope.

    Note  that  this  is  the  ONLY  procedure  that should be used to create a
    DTHREAD   object  outside  of  the  DTHREAD  class.   The  constructor  and
    Initialize  function  should  only  be  used  internally within the DTHREAD
    class.

Arguments:

    Process       - Supplies a reference to the DPROCESS object associated with
                    this DTHREAD object.

    CurrentThread - Returns  the  DTHREAD  object  corresponding to the current
                    thread.

Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it
    returns an appropriate WinSock error code.
--*/
{
    INT ReturnCode = WSASYSCALLFAILURE;  // Return Code
    PDTHREAD LocalThread=NULL;            // Temp thread object pointer

    if (sm_tls_index != TLS_OUT_OF_INDEXES){
        // No thread object for the current thread so create one
        // and initialize the new object
        LocalThread = new(DTHREAD);
        if (LocalThread) {
            if (LocalThread->Initialize(Process) == ERROR_SUCCESS) {
                if (TlsSetValue(sm_tls_index, LocalThread)) {
                    *CurrentThread = LocalThread;
                    ReturnCode = ERROR_SUCCESS;
                } //if
            } //if

            if (ERROR_SUCCESS != ReturnCode){
                delete(LocalThread);
            } //if
        } //if
    } //if
    return(ReturnCode);
} //CreateDThreadForCurrentThread

VOID
DTHREAD::DestroyCurrentThread()
/*++

Routine Description:

    This routine destroys the thread object associated with the
    currently running thread.

Arguments:

Return Value:

    The  function  returns TRUE if the thread was sucessfully
    destroyed else FALSE
--*/
{
    PDTHREAD  Thread;

    // Is Thread local Storage been inited
    if (sm_tls_index != TLS_OUT_OF_INDEXES)
        {
        Thread = (DTHREAD*)TlsGetValue(sm_tls_index);
        if (Thread)
        {
            delete(Thread);
        } //if
    } //if
}



DTHREAD::DTHREAD()
/*++

Routine Description:

    DTHREAD  object  constructor.   Creates and returns a DTHREAD object.  Note
    that  the  DTHREAD object has not been fully initialized.  The "Initialize"
    member function must be the first member function called on the new DTHREAD
    object.

    Note  that  this  procedure  should  not be used to create a DTHREAD object
    outside  of  the  DTHREAD  class.   This procedure is only for internal use
    within  the DTHREAD class.  The static "GetCurrentDThread" procedure should
    be  used  to  retrieve  a reference to a DTHREAD object outside the DTHREAD
    class.

Arguments:

    None

Return Value:

--*/
{
    // Set data member to known values
    m_blocking_hook        = (FARPROC)&DTHREAD::DefaultBlockingHook;
    m_blocking_callback    = NULL;
    m_process              = NULL;
    m_hostent_buffer       = NULL;
    m_servent_buffer       = NULL;
    m_hostent_size         = 0;
    m_servent_size         = 0;
    m_is_blocking          = FALSE;
    m_io_cancelled         = FALSE;
    m_cancel_blocking_call = NULL;
    m_open_type            = 0;
    m_proto_info           = NULL;

} //DTHREAD




INT
DTHREAD::Initialize(
    IN PDPROCESS  Process
    )
/*++

Routine Description:

    Completes the initialization of the DTHREAD object.  This must be the first
    member  function  called  for the DTHREAD object.  This procedure should be
    called only once for the object.

    Note  that  this  procedure  should  only  be  called internally within the
    DTHREAD  class.   Outside  of  the class, the "GetCurrentDThread" procedure
    should  be  used  to  retrieve  a  reference to a fully initialized DTHREAD
    object.

Arguments:

    Process - Supplies  a reference to the DPROCESS object associated with this
              DTHREAD object.

Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it
    returns an appropriate WinSock error code.
--*/
{
    INT ReturnCode= WSASYSCALLFAILURE;

    m_process = Process; // Store process pointer

    DEBUGF( DBG_TRACE,
            ("Initializing dthread %p\n", this));

    // Init WAH thread:
    // Open the helper device
    if (Process->GetAsyncHelperDeviceID(&m_wah_helper_handle) ==
        ERROR_SUCCESS) {
        //Initialize helper thread ID structure
        if (WahOpenCurrentThread(m_wah_helper_handle,
                                 & m_wah_thread_id) == ERROR_SUCCESS) {
                ReturnCode = ERROR_SUCCESS;
        } //if
    } //if

    return(ReturnCode);
} //Initialize




DTHREAD::~DTHREAD()
/*++

Routine Description:

    DTHREAD  object  destructor.   This  procedure  has  the  responsibility to
    perform  any required shutdown operations for the DTHREAD object before the
    object  memory  is  deallocated.  The caller is reponsible for removing the
    object  from  its list in the DPROCESS object before destroying the DTHREAD
    object.

    This  procedure takes care of removing the DTHREAD object from thread-local
    storage.

Arguments:

    None

Return Value:

    None
--*/
{
    BOOL bresult;

    DEBUGF( DBG_TRACE,
            ("Freeing dthread %p\n", this));

    assert(sm_tls_index != TLS_OUT_OF_INDEXES);

    m_blocking_hook = NULL;

    delete m_hostent_buffer;
    delete m_servent_buffer;
    delete m_proto_info;

    bresult = TlsSetValue(
        sm_tls_index,  // dwTlsIndex
        (LPVOID) NULL  // lpvTlsValue
        );
    if (! bresult) {
        DEBUGF(
            DBG_WARN,
            ("Resetting thread-local storage for this thread\n"));
    }

    WahCloseThread(
        m_wah_helper_handle,
        & m_wah_thread_id);
    m_wah_helper_handle = NULL;

    m_process = NULL;
} //~DTHREAD


INT
DTHREAD::CancelBlockingCall()
{
    INT result;
    INT err;

    //
    // Bail if the thread is not blocking.
    //

    if( !m_is_blocking ) {

        return WSAEINVAL;

    }

    //
    // Verify we've got the blocking pointers setup correctly.
    //

    assert( m_blocking_callback != NULL );
    assert( m_cancel_blocking_call != NULL );

    //
    // If the IO request has not already been cancelled, call the
    // cancellation routine.
    //

    if( !m_io_cancelled ) {

        result = (m_cancel_blocking_call)( &err );

        if( result != ERROR_SUCCESS ) {
            return err;
        }

        m_io_cancelled = TRUE;

    }

    return ERROR_SUCCESS;

}   // DTHREAD::CancelBlockingCall


FARPROC
DTHREAD::SetBlockingHook(
    FARPROC lpBlockFunc
    )
{
    FARPROC PreviousHook;

    //
    // Snag the current hook so we can return it as the previous hook.
    //

    PreviousHook = m_blocking_hook;

    //
    // Set the current hook & the appropriate blocking callback.
    //

    if( lpBlockFunc == (FARPROC)&DTHREAD::DefaultBlockingHook ) {
        m_blocking_callback = NULL;
    } else {
        m_blocking_callback = &DTHREAD::BlockingCallback;
    }

    m_blocking_hook = lpBlockFunc;

    return PreviousHook;

}   // DTHREAD::SetBlockingHook


INT
DTHREAD::UnhookBlockingHook()
{

    //
    // Just reset everything back to defaults.
    //

    m_blocking_hook = (FARPROC)DTHREAD::DefaultBlockingHook;
    m_blocking_callback = NULL;

    return ERROR_SUCCESS;

}   // DTHREAD::UnhookBlockingHook


INT
WINAPI
DTHREAD::DefaultBlockingHook()
{

    MSG msg;
    BOOL retrievedMessage;

    //
    // Get the next message for this thread, if any.
    //

    retrievedMessage = PeekMessage( &msg, NULL, 0, 0, PM_REMOVE );

    //
    // Process the message if we got one.
    //

    if ( retrievedMessage ) {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }

    //
    // If we got a message, indicate that we want to be called again.
    //

    return retrievedMessage;

}   // DTHREAD::DefaultBlockingHook


BOOL
CALLBACK
DTHREAD::BlockingCallback(
    DWORD_PTR dwContext
    )
{
    PDTHREAD Thread;

    assert( dwContext != 0 );

    //
    // Just grab the DTHREAD pointer directly out of the thread local
    // storage. Since we came in through a blocking hook, we must have
    // already setup this stuff.
    //

    Thread = (DTHREAD *)TlsGetValue( sm_tls_index );
    assert( Thread != NULL );

    //
    // Set the blocking flag and the pointer to the cancel function
    // and clear the i/o cancelled flag.
    //

    Thread->m_is_blocking = TRUE;
    Thread->m_cancel_blocking_call = (LPWSPCANCELBLOCKINGCALL)dwContext;
    Thread->m_io_cancelled = FALSE;

    //
    // Call the user's blocking hook.
    //

    assert( Thread->m_blocking_hook != NULL );
    assert( Thread->m_blocking_hook != (FARPROC)&DTHREAD::DefaultBlockingHook );

    while( (Thread->m_blocking_hook)() ) {

        //
        // This space intentionally left blank.
        //

    }

    //
    // Reset the blocking flag and return TRUE if everything was OK,
    // FALSE if the operation was cancelled.
    //

    Thread->m_is_blocking = FALSE;

    return !Thread->m_io_cancelled;

}   // DTHREAD::BlockingCallback





PGETPROTO_INFO
DTHREAD::GetProtoInfo()
/*++

Routine Description:

    Returns a pointer to the state structure used for the
    getprotobyXxx() APIs.

Arguments:

    None.

Return Value:

    Pointer to the state structure.

--*/
{

    //
    // Allocate the buffer if necessary.
    //

    if( m_proto_info == NULL ) {

        m_proto_info = new GETPROTO_INFO;

    }

    return m_proto_info;

} // GetProtoInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\getproto.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    getproto.cpp

Abstract:

    This module handles the getprotobyX() functions.

    The following functions are exported by this module:

    getprotobyname()
    getprotobynumber()

Author:

    Keith Moore (keithmo)        18-Jun-1996

Revision History:

--*/


#include "precomp.h"
#include "strsafe.h"

//
// Private contants.
//

#define DATABASE_PATH_REGISTRY_KEY \
            "System\\CurrentControlSet\\Services\\Tcpip\\Parameters"

#define DATABASE_PATH_REGISTRY_VALUE "DataBasePath"

#define PROTOCOL_DATABASE_FILENAME "protocol"


//
// Private prototypes.
//

FILE *
GetProtoOpenNetworkDatabase(
    VOID
    );

CHAR *
GetProtoPatternMatch(
    CHAR * Scan,
    CHAR * Match
    );

PPROTOENT
GetProtoGetNextEnt(
    FILE * DbFile,
    PGETPROTO_INFO ProtoInfo
    );


//
// Public functions.
//


struct protoent FAR *
WSAAPI
getprotobynumber(
    IN int number
    )
/*++
Routine Description:

    Get protocol information corresponding to a protocol number.

Arguments:

    number - Supplies a protocol number, in host byte order

Returns:

    If  no  error  occurs, getprotobynumber() returns a pointer to the protoent
    structure  described  above.   Otherwise  it  returns  a NULL pointer and a
    specific error r code is stored with SetErrorCode().
--*/
{

    PDTHREAD Thread;
    INT ErrorCode;
    PGETPROTO_INFO protoInfo;
    PPROTOENT pent;
    FILE * dbFile;

    ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if(ErrorCode != ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return(NULL);
    }

    //
    // Get the per-thread buffer.
    //

    protoInfo = Thread->GetProtoInfo();

    if( protoInfo == NULL ) {

        SetLastError( WSANO_DATA );
        return NULL;

    }

    //
    // Open the database file.
    //

    dbFile = GetProtoOpenNetworkDatabase();

    if( dbFile == NULL ) {

        SetLastError( WSANO_DATA );
        return NULL;

    }

    //
    // Scan it.
    //

    while( TRUE ) {

        pent = GetProtoGetNextEnt(
                   dbFile,
                   protoInfo
                   );

        if( pent == NULL ) {

            break;

        }

        if( (int)pent->p_proto == number ) {

            break;

        }

    }

    //
    // Close the database.
    //

    fclose( dbFile );

    if( pent == NULL ) {

        SetLastError( WSANO_DATA );

    }

    return pent;

}  // getprotobynumber


struct protoent FAR *
WSAAPI
getprotobyname(
    IN const char FAR * name
    )
/*++
Routine Description:

    Get protocol information corresponding to a protocol name.

Arguments:

    name - A pointer to a null terminated protocol name.

Returns:

    If  no  error  occurs,  getprotobyname()  returns a pointer to the protoent
    structure  described  above.   Otherwise  it  returns  a NULL pointer and a
    specific error code is stored with SetErrorCode().
--*/
{

    PDTHREAD Thread;
    INT ErrorCode;
    PGETPROTO_INFO protoInfo;
    PPROTOENT pent;
    FILE * dbFile;

    ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if(ErrorCode != ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return(NULL);
    }

    if ( !name ) // Bug fix for #112420
    {
        SetLastError(WSAEINVAL);
        return(NULL);
    }

    //
    // Get the per-thread buffer.
    //

    protoInfo = Thread->GetProtoInfo();

    if( protoInfo == NULL ) {

        SetLastError( WSANO_DATA );
        return NULL;

    }

    //
    // Open the database file.
    //

    dbFile = GetProtoOpenNetworkDatabase();

    if( dbFile == NULL ) {

        SetLastError( WSANO_DATA );
        return NULL;

    }

    //
    // Scan it.
    //

    while( TRUE ) {

        pent = GetProtoGetNextEnt(
                   dbFile,
                   protoInfo
                   );

        if( pent == NULL ) {

            break;

        }

        __try {
            if( _stricmp( pent->p_name, name ) == 0 ) {

                break;

            }

        }
        __except (WS2_EXCEPTION_FILTER()) {
            fclose (dbFile);
            SetLastError (WSAEFAULT);
            return NULL;
        }
    }

    //
    // Close the database.
    //

    fclose( dbFile );

    if( pent == NULL ) {

        SetLastError( WSANO_DATA );

    }

    return pent;

}  // getprotobyname


//
// Private functions.
//


FILE *
GetProtoOpenNetworkDatabase(
    VOID
    )

/*++

Routine Description:

    Opens a stream to the protocol database file.

Arguments:

    None
Return Value:

    FILE * - Pointer to the open stream if successful, NULL if not.

--*/

{

    CHAR path[MAX_PATH];
    CHAR unexpanded[MAX_PATH];
    CHAR * suffix;
    OSVERSIONINFO version;
    LONG err;
    HKEY key;
    DWORD type;
    DWORD length;

    //
    // Determine the directory for the database file.
    //
    // Under Win95, the database files live under the Windows directory
    // (i.e. C:\WINDOWS).
    //
    // Under WinNT, the path to the database files is configurable in
    // the registry, but the default is in the Drivers\Etc directory
    // (i.e. C:\WINDOWS\SYSTEM32\DRIVERS\ETC).
    //

    version.dwOSVersionInfoSize = sizeof(version);

    if( !GetVersionEx( &version ) ) {

        return NULL;

    }

    suffix = "";

    if( version.dwPlatformId == VER_PLATFORM_WIN32_NT ) {

        //
        // We're running under NT, so try to get the path from the
        // registry.
        //

        err = RegOpenKeyEx(
                  HKEY_LOCAL_MACHINE,
                  DATABASE_PATH_REGISTRY_KEY,
                  0,
                  KEY_READ,
                  &key
                  );

        if( err == NO_ERROR ) {

            length = sizeof(unexpanded);

            err = RegQueryValueEx(
                      key,
                      DATABASE_PATH_REGISTRY_VALUE,
                      NULL,
                      &type,
                      (LPBYTE)unexpanded,
                      &length
                      );
            //
            // Make sure it is NULL terminated (in case
            // data type is not string).  This lets us 
            // get away with not validating the type.
            //
            unexpanded[sizeof(unexpanded)-1] = 0;

            RegCloseKey( key );

        }

        if( err == NO_ERROR ) {

            length = ExpandEnvironmentStrings(
                    unexpanded,
                    path,
                    sizeof(path)
                    );

            if (length == 0 ) {

                err = WSASYSCALLFAILURE;

            }

        }

        if( err != NO_ERROR ) {

            //
            // Couldn't get it from the registry, just use the default.
            //

            if( GetSystemDirectory(
                    path,
                    sizeof(path)
                    ) == 0 ) {

                return NULL;

            }

            suffix = "DRIVERS\\ETC\\";

        }

    } else {

        //
        // We're running under Win95, so just get the Windows directory.
        //

        if( GetWindowsDirectory(
                path,
                sizeof(path)
                ) == 0 ) {

            return NULL;

        }

    }

    //
    // Ensure the path has a trailing backslash, then tack on any suffix
    // needed, then tack on the filename.
    //

    if( path[strlen( path ) - 1] != '\\' ) {

        if(StringCchCat( path, sizeof (path), "\\" ) != S_OK)
        	return NULL;

    }

    if(StringCchCat( path, sizeof (path), suffix ) != S_OK)
    	return NULL;
    if(StringCchCat( path, sizeof (path), PROTOCOL_DATABASE_FILENAME ) != S_OK)
    	return NULL;

    //
    // Open the file, return the result.
    //

    return fopen( path, "rt" );

}   // GetProtoOpenNetworkDatabase


CHAR *
GetProtoPatternMatch(
    CHAR * Scan,
    CHAR * Match
    )

/*++

Routine Description:

    Finds the first character in Scan that matches any character in Match.

Arguments:

    Scan - The string to scan.

    Match - The list of characters to match against.

Return Value:

    CHAR * - Pointer to the first occurrance in Scan if successful,
        NULL if not.

--*/

{

    CHAR ch;

    while( ( ch = *Scan ) != '\0' ) {

        if( strchr( Match, ch ) != NULL ) {

            return Scan;

        }

        Scan++;

    }

    return NULL;

}   // GetProtoPatternMatch



PPROTOENT
GetProtoGetNextEnt(
    FILE * DbFile,
    PGETPROTO_INFO ProtoInfo
    )
{
    CHAR * ptr;
    CHAR * token;
    CHAR ** aliases;
    PPROTOENT result = NULL;

    while( TRUE ) {

        //
        // Get the next line, bail if EOF.
        //

        ptr = fgets(
                  ProtoInfo->TextLine,
                  MAX_PROTO_TEXT_LINE,
                  DbFile
                  );

        if( ptr == NULL ) {

            break;

        }

        //
        // Skip comments.
        //

        if( *ptr == '#' ) {

            continue;

        }

        token = GetProtoPatternMatch ( ptr, "#\n" );

        if( token == NULL ) {

            continue;

        }

        *token = '\0';

        //
        // Start building the entry.
        //

        ProtoInfo->Proto.p_name = ptr;

        token = GetProtoPatternMatch( ptr, " \t" );

        if( token == NULL ) {

            continue;

        }

        *token++ = '\0';

        while( *token == ' ' || *token == '\t' ) {

            token++;

        }

        ptr = GetProtoPatternMatch( token, " \t" );

        if( ptr != NULL ) {

            *ptr++ = '\0';

        }

        ProtoInfo->Proto.p_proto = (short)atoi( token );

        //
        // Build the alias list.
        //

        ProtoInfo->Proto.p_aliases = ProtoInfo->Aliases;
        aliases = ProtoInfo->Proto.p_aliases;

        if( ptr != NULL ) {

            token = ptr;

            while( token && *token ) {

                if( *token == ' ' || *token == '\t' ) {

                    token++;
                    continue;

                }

                if( aliases < &ProtoInfo->Proto.p_aliases[MAX_PROTO_ALIASES - 1] ) {

                    *aliases++ = token;

                }

                token = GetProtoPatternMatch( token, " \t" );

                if( token != NULL ) {

                    *token++ = '\0';

                }

            }

        }

        *aliases = NULL;
        result = &ProtoInfo->Proto;
        break;

    }

    return result;

}   // GetProtoGetNextEnt
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\getxbyy.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    getxbyy.cpp

Abstract:

    This  module takes care of forwarding the "getxbyy" family of operations to
    the  correct getxbyy provider.  The preferred getxbyy provider is found via
    a  DLL  path  stored  in the registry.  If this registry entry is found, an
    attempt  is  made  to  load the DLL and retrieve entry points from it.  Any
    failures  cause  entry  points to be taken from the WSOCK32.DLL instead.  A
    getxbyy provider does not have to export all of the getxbyy functions since
    any it does not export are taken from WSOCK32.DLL.

    The  getxbyy  functions  handled  by  this module that can be replaced by a
    getxyy provider are the following:

    gethostbyaddr()
    gethostbyname()
    gethostname()
    getservbyname()
    getservbyport()
    WSAAsyncGetServByName()
    WSAAsyncGetServByPort()
    WSAAsyncGetProtoByName()
    WSAAsyncGetProtoByNumber()
    WSAAsyncGetHostByName()
    WSAAsyncGetHostByAddr()
    WSACancelAsyncRequest()

    The   actual  entry  points  supplied  by  the  getxbyy  provider  (or  the
    WSOCK32.DLL) are prefixed with a special string.  This prefix is defined by
    the manifest constant GETXBYYPREFIX.

Author:

    Paul Drews  drewsxpa@ashland.intel.com 12-19-1995

Revision History:

    12-19-1995 drewsxpa@ashland.intel.com
        Initial implementation
--*/



#include "precomp.h"
#include "svcguid.h"
#include <windns.h>
#include <dnslib.h>

#ifdef _WIN64
#pragma warning (push)
#pragma warning (disable:4267)
#endif

//
//  Address to string conversion for gethostbyaddr()
//

PCHAR
Local_Ip6AddressToString_A(
    OUT     PCHAR           pBuffer,
    IN      PIP6_ADDRESS    pIp6Addr
    );

PCHAR
Local_Ip4AddressToString_A(
    OUT     PCHAR           pBuffer,
    IN      PIP4_ADDRESS    pIp4Addr
    );


//
// This is the initial buffer size passed by getxbyy functions
// to WSALookupServiceNext.  If it is insuffucient for the query,
// the amount specified by the provider is allocated and call is
// repeated.
// The initial buffer is allocated from stack, so we try to keep it
// relatively small, but still for performance reasons we want to be able
//  to satisfy most of the calls with just this amount
//
#define RNR_BUFFER_SIZE (sizeof(WSAQUERYSET) + 256)


LPBLOB
getxyDataEnt(
    IN OUT PCHAR *pResults,
    IN     DWORD dwLength,
    IN     LPSTR lpszName,
    IN     LPGUID lpType,
    OUT    LPSTR *  lppName OPTIONAL
    );

VOID
FixList(PCHAR ** List, PCHAR Base);

VOID
UnpackHostEnt(struct hostent * hostent);

VOID
UnpackServEnt(struct servent * servent);

GUID HostAddrByNameGuid = SVCID_INET_HOSTADDRBYNAME;
GUID HostNameGuid = SVCID_HOSTNAME;
GUID AddressGuid =  SVCID_INET_HOSTADDRBYINETSTRING;
GUID IANAGuid    =  SVCID_INET_SERVICEBYNAME;

//
// Utility to turn a list of offsets into a list of addresses. Used
// to convert structures returned as BLOBs.
//

VOID
FixList(PCHAR ** List, PCHAR Base)
{
    if(*List)
    {
        PCHAR * Addr;

        Addr = *List = (PCHAR *)( ((ULONG_PTR)*List + Base) );
        while(*Addr)
        {
            *Addr = (PCHAR)(((ULONG_PTR)*Addr + Base));
            Addr++;
        }
    }
}


//
// Routine to convert a hostent returned in a BLOB to one with
// usable pointers. The structure is converted in-place.
//
VOID
UnpackHostEnt(struct hostent * hostent)
{
     PCHAR pch;

     pch = (PCHAR)hostent;

     if(hostent->h_name)
     {
         hostent->h_name = (PCHAR)((ULONG_PTR)hostent->h_name + pch);
     }
     FixList(&hostent->h_aliases, pch);
     FixList(&hostent->h_addr_list, pch);
}

//
// Routine to unpack a servent returned in a BLOB to one with
// usable pointers. The structure is converted in-place
//

VOID
UnpackServEnt(struct servent * servent)
{
    PCHAR pch;

    pch = (PCHAR)servent;

    FixList(&servent->s_aliases, pch);
    servent->s_name = (PCHAR)(ULONG_PTR(servent->s_name) + pch);
    servent->s_proto = (PCHAR)(ULONG_PTR(servent->s_proto) + pch);
}





struct hostent FAR *
WSAAPI
gethostbyaddr(
    IN  const char FAR *    addr,
    IN  int                 len,
    IN  int                 type
    )
/*++
Routine Description:

    Get host information corresponding to an address.

Arguments:

    addr - A pointer to an address in network byte order.

    len  - The length of the address, which must be 4 for PF_INET addresses.

    type - The type of the address, which must be PF_INET.

Returns:

    If  no  error  occurs,  gethostbyaddr()  returns  a  pointer to the hostent
    structure  described  above.   Otherwise  it  returns  a NULL pointer and a
    specific error code is stored with SetErrorCode().
--*/
{
    CHAR        qbuf[ DNS_MAX_NAME_BUFFER_LENGTH ];
    PHOSTENT    ph;
    LPBLOB      pBlob;
    PCHAR       pResults;
    CHAR        localResults[RNR_BUFFER_SIZE];
    INT         ErrorCode;
    PDTHREAD    Thread;

    ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if(ErrorCode != ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return(NULL);
    }

    if ( !addr )
    {
        SetLastError(WSAEINVAL);
        return(NULL);
    }

    pResults = localResults;

    //
    //  build name from address
    //      - try IP6
    //      - but default to IP4
    //
    //  note, not testing for IP4 address family and length
    //  because historically this API didn't check and i don't
    //  want to now break sloppy apps
    //

    if ( type == AF_INET6 )
    {
        if ( len != sizeof(IN6_ADDR) )
        {
            SetLastError( WSAEINVAL );
            return( NULL );
        }
        Local_Ip6AddressToString_A(
            qbuf,
            (PIP6_ADDRESS) addr );
    }
    else
    {
        Local_Ip4AddressToString_A(
            qbuf,
            (PIP4_ADDRESS) addr );
    }

    pBlob = getxyDataEnt(
                    & pResults,
                    RNR_BUFFER_SIZE,
                    qbuf,
                    &AddressGuid,
                    0 );
    if(pBlob)
    {
        ph = (struct hostent *)Thread->CopyHostEnt(pBlob);
        if(ph)
        {
            UnpackHostEnt(ph);
        }
    }
    else
    {
        ph = 0;
        if(GetLastError() == WSASERVICE_NOT_FOUND)
        {
            SetLastError(WSANO_ADDRESS);
        }
    }
    if (pResults!=localResults)
        delete pResults;

    return(ph);
}  // gethostbyaddr




struct hostent FAR *
WSAAPI
gethostbyname(
    IN  const char FAR *    name
    )
/*++

Routine Description:

    Get host information corresponding to a hostname.

Arguments:

    name - A pointer to the null terminated name of the host.

Returns:

    If  no  error  occurs,  gethostbyname()  returns  a  pointer to the hostent
    structure  described  above.   Otherwise  it  returns  a NULL pointer and a
    specific errorr code is stored with SetErrorCode().

--*/
{
    struct hostent * hent;
    LPBLOB pBlob;
    PCHAR pResults;
    CHAR localResults[RNR_BUFFER_SIZE];
    INT ErrorCode;
    PDTHREAD Thread;
    CHAR  szLocalName[200];   // for storing the local name. This
                              // is simply a big number assumed
                              // to be large enough. This is used
                              // only when the caller chooses not to
                              // provide a name. Very lazy.
    PCHAR pszName;

    ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if(ErrorCode != ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return(NULL);
    }

    //
    // A NULL input name means look for the local name. So,
    // get it.
    //
    if(!name || !*name)
    {
        if(gethostname(szLocalName, 200) != NO_ERROR)
        {
            return(NULL);
        }
        pszName = szLocalName;
    }
    else
    {
        pszName = (PCHAR)name;
    }

    pResults = localResults;

    pBlob = getxyDataEnt( &pResults,
                          RNR_BUFFER_SIZE,
                          pszName,
                          &HostAddrByNameGuid,
                          0);

    if ( !pBlob &&
         ( !name || !*name ) )
    {
        pBlob = getxyDataEnt( &pResults,
                              RNR_BUFFER_SIZE,
                              NULL,
                              &HostAddrByNameGuid,
                              0);
    }

    if(pBlob)
    {
        hent = (struct hostent *)Thread->CopyHostEnt(pBlob);
        if(hent)
        {
            UnpackHostEnt(hent);
        }
    }
    else
    {
        hent = 0;

        if(GetLastError() == WSASERVICE_NOT_FOUND)
        {
            SetLastError(WSAHOST_NOT_FOUND);
        }
    }

    if (pResults!=localResults)
        delete pResults;
#ifdef RASAUTODIAL
    //
    // Inform Autodial of a successful name lookup.
    // This is important with DNS, since reverse lookups
    // do not provide complete information about name
    // aliases.
    //
    if (hent && hent->h_addr)
        WSNoteSuccessfulHostentLookup(name, *(PULONG)hent->h_addr);
#endif // RASAUTODIAL
    return(hent);
}  // gethostbyname




int
WSAAPI
gethostname(
    OUT     char FAR *  pName,
    IN      int         NameLen
    )
/*++
Routine Description:

    Return the standard host name for the local machine.

Arguments:

    pName    - A pointer to a buffer that will receive the host name.

    NameLen - The length of the buffer.

Returns:

    Zero  on  success  else  SOCKET_ERROR.   The  error  code  is  stored  with
    SetErrorCode().
--*/
{
    PCHAR       presultName = NULL;
    INT         errorCode;
    PDTHREAD    thread;
    CHAR        localBuffer[ RNR_BUFFER_SIZE ];
    PCHAR       pbuffer = localBuffer;
    int         resultLength;


    errorCode = TURBO_PROLOG_OVLP(&thread);
    if ( errorCode != NO_ERROR )
    {
        goto Cleanup;
    }

    if ( !pName || IsBadWritePtr(pName, NameLen) )
    {
        errorCode = WSAEFAULT;
        goto Cleanup;
    }

    //
    //  cluster name check  (fix for bug #94978)
    //
    //  check to see if the cluster computername variable is set.
    //      - if set it overrides the actual gethostname, so application can
    //      work when network name and computer name are different
    //

    resultLength = GetEnvironmentVariableA(
                        "_CLUSTER_NETWORK_NAME_",
                        pName,
                        NameLen );

    if ( resultLength != 0 )
    {
        if ( resultLength > NameLen )
        {
            errorCode = WSAEFAULT;
        }
        goto Cleanup;
    }

    //
    //  do normal lookup through NSP
    //

    getxyDataEnt(
         & pbuffer,
         RNR_BUFFER_SIZE,
         NULL,
         & HostNameGuid,
         & presultName );

    if ( presultName )
    {
        resultLength = strlen(presultName) + 1;

        if ( resultLength <= NameLen )
        {
            memcpy( pName, presultName, resultLength );
        }
        else
        {
            errorCode = WSAEFAULT;
        }
        goto Cleanup;
    }

    //
    //  fallback on NSP lookup failure 
    //      - use basic system API for computer name
    //

    resultLength = NameLen;

    if ( !GetComputerNameA( pName, (PDWORD)&resultLength) )
    {
        errorCode = WSAENETDOWN;
        if ( resultLength >= NameLen )
        {
            errorCode = WSAEFAULT;
        }
    }
    

Cleanup:

    if ( pbuffer!=localBuffer )
    {
        delete pbuffer;
    }

    if ( errorCode == NO_ERROR )
    {
        return  NO_ERROR;
    }

    SetLastError( errorCode );
    return( SOCKET_ERROR );

}  // gethostname




struct servent FAR * WSAAPI
getservbyport(
    IN int port,
    IN const char FAR * proto
    )
/*++
Routine Description:

    Get service information corresponding to a port and protocol.

Arguments:

    port  - The port for a service, in network byte order.

    proto - An  optional  pointer  to  a  protocol  name.   If  this  is  NULL,
            getservbyport()  returns the first service entry for which the port
            matches  the  s_port.   Otherwise  getservbyport() matches both the
            port and the proto.

Returns:

    If  no  error  occurs,  getservbyport()  returns  a  pointer to the servent
    structure  described  above.   Otherwise  it  returns  a NULL pointer and a
    specific error code is stored with SetErrorCode().
--*/
{
    PCHAR pszTemp;
    struct servent * sent;
    INT  ErrorCode;
    PDTHREAD Thread;
    LPBLOB pBlob;
    PCHAR pResults;
    CHAR localResults[RNR_BUFFER_SIZE];


    ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if(ErrorCode != ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return(NULL);
    }

    pResults = localResults;

    if(!proto)
    {
        proto = "";
    }

    //
    // the 5 is the max number of digits in a port
    //
    pszTemp = new CHAR[strlen(proto) + 1 + 1 + 5];
    if (pszTemp==NULL) {
        SetLastError(WSA_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    sprintf(pszTemp, "%d/%s", (port & 0xffff), proto);
    pBlob =  getxyDataEnt(&pResults, RNR_BUFFER_SIZE, pszTemp, &IANAGuid, 0);
    delete pszTemp;

    if(!pBlob)
    {
        sent = NULL;
        if(GetLastError() == WSATYPE_NOT_FOUND)
        {
            SetLastError(WSANO_DATA);
        }
    }
    else
    {
        sent = (struct servent *)Thread->CopyServEnt(pBlob);
        if(sent)
        {
            UnpackServEnt(sent);
        }
    }
    if (pResults!=localResults)
        delete pResults;
    return(sent);
}  // getservbyport




struct servent FAR * WSAAPI
getservbyname(
    IN const char FAR * name,
    IN const char FAR * proto
    )
/*++
Routine Description:

     Get service information corresponding to a service name and protocol.

Arguments:

     name  - A pointer to a null terminated service name.

     proto - An  optional  pointer to a null terminated protocol name.  If this
             pointer  is  NULL, getservbyname() returns the first service entry
             for  which  the  name  matches the s_name or one of the s_aliases.
             Otherwise getservbyname() matches both the name and the proto.

Returns:

     If  no  error  occurs,  getservbyname()  returns  a pointer to the servent
     structure  described  above.   Otherwise  it  returns a NULL pointer and a
     specific error code is stored with SetErrorCode().
--*/
{
    PCHAR pszTemp;
    struct servent * sent;
    INT ErrorCode;
    PDTHREAD Thread;
    LPBLOB pBlob;
    PCHAR pResults;
    CHAR localResults[RNR_BUFFER_SIZE];

    ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if(ErrorCode != ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return(NULL);
    }

    if ( !name ) // Bug fix for #112969
    {
        SetLastError(WSAEINVAL);
        return(NULL);
    }

    pResults = localResults;

    if(!proto)
    {
        proto = "";
    }
    pszTemp = new CHAR[strlen(name) + strlen(proto) + 1 + 1];
    if (pszTemp==NULL) {
        SetLastError(WSA_NOT_ENOUGH_MEMORY);
        return(NULL);
    }
    sprintf(pszTemp, "%s/%s", name, proto);
    pBlob = getxyDataEnt(&pResults, RNR_BUFFER_SIZE, pszTemp, &IANAGuid, 0);
    delete pszTemp;
    if(!pBlob)
    {
        sent = NULL;
        if(GetLastError() == WSATYPE_NOT_FOUND)
        {
            SetLastError(WSANO_DATA);
        }
    }
    else
    {
        sent = (struct servent *)Thread->CopyServEnt(pBlob);
        if(sent)
        {
            UnpackServEnt(sent);
        }
    }
    if (pResults!=localResults)
        delete pResults;
    return(sent);
}  // getservbyname


//
// Common routine for obtaining a xxxent buffer. Input is used to
// execute the WSALookup series of APIs.
//
// Args:
//   pResults -- a pointer to a buffer supplied by the caller to be used in
//               the WASLookup calls. If the buffer is not large enough
//               this routine allocates a new one and modifies the value
//               in pResults.  The new buffer should be freed by the caller
//               using delete.
//   dwLength -- number of bytes in pResults (originally).
//   lpszName -- pointer to the service name. May by NULL
//   lpType   -- pointer to the service type . This should be one of
//               the SVCID_INET_xxxxx types. It may be anything
//               that produces a BLOB.
//   lppName  -- pointer to pointer where the resulting name pointer
//               is stored. May be NULL if the name is not needed.
//
// Returns:
//   0  --  No BLOB data was returned. In general, this means the operation
//          failed. Evev if the WSALookupNext succeeded and returned a
//          name, the name will not be returned.
//   else -- a pointer to the BLOB.
//
//


//
// The protocol restrictions list for all emulation operations. This should
// limit the invoked providers to the set that know about hostents and
// servents. If not, then the special SVCID_INET GUIDs should take care
// of the remainder.
//
AFPROTOCOLS afp[2] = {
                      {AF_INET, IPPROTO_UDP},
                      {AF_INET, IPPROTO_TCP}
                     };

LPBLOB
getxyDataEnt(
    IN OUT  PCHAR *         pResults,
    IN      DWORD           dwLength,
    IN      LPSTR           lpszName,
    IN      LPGUID          lpType,
    OUT     LPSTR *         lppName     OPTIONAL
    )
{

/*++
Routine Description:
   See comment above for details
--*/

    PWSAQUERYSETA   pwsaq = (PWSAQUERYSETA)*pResults;
    int             err;
    HANDLE          hRnR;
    LPBLOB          pvRet = 0;
    DWORD           origLength = dwLength;  // save length of original buffer
                                            // in case we need to reallocate it

    if ( lppName )
    {
        *lppName = NULL;
    }

    //
    //  create the query
    //

    memset(pwsaq, 0, sizeof(*pwsaq));

    pwsaq->dwSize                   = sizeof(*pwsaq);
    pwsaq->lpszServiceInstanceName  = lpszName;
    pwsaq->lpServiceClassId         = lpType;
    pwsaq->dwNameSpace              = NS_ALL;
    pwsaq->dwNumberOfProtocols      = 2;
    pwsaq->lpafpProtocols           = &afp[0];

    err = WSALookupServiceBeginA(
                pwsaq,
                LUP_RETURN_BLOB | LUP_RETURN_NAME,
                &hRnR );

    if(err == NO_ERROR)
    {

        //
        // If the original buffer is small to contain the results
        // will allocate new one and retry the call.
        //
    Retry:

        //
        // The query was accepted, so execute it via the Next call.
        //
        err = WSALookupServiceNextA(
                                hRnR,
                                0,
                                &dwLength,
                                pwsaq);
        //
        // if NO_ERROR was returned and a BLOB is present, this
        // worked, just return the requested information. Otherwise,
        // invent an error or capture the transmitted one.
        //

        if(err == NO_ERROR)
        {
            if(pvRet = pwsaq->lpBlob)
            {
                if(lppName)
                {
                    *lppName = pwsaq->lpszServiceInstanceName;
                }
            }
            else
            {
                if ( lpType == &HostNameGuid )
                {
                    if(lppName)
                    {
                        *lppName = pwsaq->lpszServiceInstanceName;
                    }
                }
                else
                {
                    err = WSANO_DATA;
                }
            }
        }
        else
        {
            //
            // WSALookupServiceEnd clobbers LastError so save
            // it before closing the handle.
            //

            err = GetLastError();

            //
            // The provider returns WSAEFAULT if the result buffer
            // is not large enough (to make sure that this is not
            // just a random error or a result AV when accessing the
            // the buffer content, we check the returned buffer size
            // against the value that we initially supplied).
            //
            if ((err==WSAEFAULT) && (dwLength>origLength))
            {
                PCHAR   newBuffer = new CHAR[dwLength];
                if (newBuffer)
                {
                    //
                    // Remeber the new length, so that provider cannot
                    // force us to loop indefinitely (well if it keeps
                    // increasing required buffer size, we'll run into
                    // out of memory error sometimes).
                    // 
                    origLength = dwLength;

                    //
                    // Replace the callers pointer to the buffer, so
                    // it knows to free it
                    //
                    *pResults = newBuffer;

                    //
                    // Repoint results to new buffer.
                    //
                    pwsaq = (PWSAQUERYSETA)newBuffer;
                    
                    //
                    // Try the Next call again.
                    //
                    goto Retry;
                }
                else 
                {
                    err = WSA_NOT_ENOUGH_MEMORY;
                }
            }
        }
        WSALookupServiceEnd(hRnR);

        //
        // if an error happened, stash the value in LastError
        //

        if(err != NO_ERROR)
        {
            SetLastError(err);
        }
    }


    return(pvRet);
}



HANDLE
WSAAPI
WSAAsyncGetServByName(
    IN HWND hWnd,
    IN unsigned int wMsg,
    IN const char FAR * Name,
    IN const char FAR * Protocol,
    IN char FAR * Buffer,
    IN int BufferLength
    )

/*++

Routine Description:

    This function is an asynchronous version of getservbyname(), and is
    used to retrieve service information corresponding to a service
    name.  The Windows Sockets implementation initiates the operation
    and returns to the caller immediately, passing back an asynchronous
    task handle which the application may use to identify the operation.
    When the operation is completed, the results (if any) are copied
    into the buffer provided by the caller and a message is sent to the
    application's window.

    When the asynchronous operation is complete the application's window
    hWnd receives message wMsg.  The wParam argument contains the
    asynchronous task handle as returned by the original function call.
    The high 16 bits of lParam contain any error code.  The error code
    may be any error as defined in winsock.h.  An error code of zero
    indicates successful completion of the asynchronous operation.  On
    successful completion, the buffer supplied to the original function
    call contains a hostent structure.  To access the elements of this
    structure, the original buffer address should be cast to a hostent
    structure pointer and accessed as appropriate.

    Note that if the error code is WSAENOBUFS, it indicates that the
    size of the buffer specified by buflen in the original call was too
    small to contain all the resultant information.  In this case, the
    low 16 bits of lParam contain the size of buffer required to supply
    ALL the requisite information.  If the application decides that the
    partial data is inadequate, it may reissue the
    WSAAsyncGetHostByAddr() function call with a buffer large enough to
    receive all the desired information (i.e.  no smaller than the low
    16 bits of lParam).

    The error code and buffer length should be extracted from the lParam
    using the macros WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in
    winsock.h as:

        #define WSAGETASYNCERROR(lParam) HIWORD(lParam)
        #define WSAGETASYNCBUFLEN(lParam) LOWORD(lParam)

    The use of these macros will maximize the portability of the source
    code for the application.

    The buffer supplied to this function is used by the Windows Sockets
    implementation to construct a hostent structure together with the
    contents of data areas referenced by members of the same hostent
    structure.  To avoid the WSAENOBUFS error noted above, the
    application should provide a buffer of at least MAXGETHOSTSTRUCT
    bytes (as defined in winsock.h).

Arguments:

    hWnd - The handle of the window which should receive a message when
       the asynchronous request completes.

    wMsg - The message to be received when the asynchronous request
       completes.

    name - A pointer to a service name.

    proto - A pointer to a protocol name.  This may be NULL, in which
        case WSAAsyncGetServByName() will search for the first service
        entry for which s_name or one of the s_aliases matches the given
        name.  Otherwise WSAAsyncGetServByName() matches both name and
        proto.

    buf - A pointer to the data area to receive the servent data.  Note
       that this must be larger than the size of a servent structure.
       This is because the data area supplied is used by the Windows
       Sockets implementation to contain not only a servent structure
       but any and all of the data which is referenced by members of the
       servent structure.  It is recommended that you supply a buffer of
       MAXGETHOSTSTRUCT bytes.

    buflen    The size of data area buf above.

Return Value:

    The return value specifies whether or not the asynchronous operation
    was successfully initiated.  Note that it does not imply success or
    failure of the operation itself.

    If the operation was successfully initiated, WSAAsyncGetHostByAddr()
    returns a nonzero value of type HANDLE which is the asynchronous
    task handle for the request.  This value can be used in two ways.
    It can be used to cancel the operation using
    WSACancelAsyncRequest().  It can also be used to match up
    asynchronous operations and completion messages, by examining the
    wParam message argument.

    If the asynchronous operation could not be initiated,
    WSAAsyncGetHostByAddr() returns a zero value, and a specific error
    number may be retrieved by calling WSAGetLastError().

--*/

{

    INT                    ErrorCode;
    PWINSOCK_CONTEXT_BLOCK contextBlock;
    HANDLE                 taskHandle;
    PCHAR                  localName;

    ErrorCode = TURBO_PROLOG();

    if (ErrorCode!=ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return NULL;
    } //if

    //
    // Initialize the async thread if it hasn't already been started.
    //

    if( !SockCheckAndInitAsyncThread() ) {

        // !!! better error code?
        SetLastError( WSAENOBUFS );
        return NULL;

    }

    //
    // Get an async context block with enough extra space for
    // the name.  We must preserve the name until we're done using
    // it, since the application may reuse the buffer.
    //

    contextBlock = SockAllocateContextBlock( strlen(Name) + 1 );

    if( contextBlock == NULL ) {

        SetLastError( WSAENOBUFS );
        return NULL;

    }

    localName = (PCHAR)( contextBlock + 1 );

    strcpy( localName, Name );

    //
    // Initialize the context block for this operation.
    //

    contextBlock->OpCode = WS_OPCODE_GET_SERV_BY_NAME;
    contextBlock->Overlay.AsyncGetServ.hWnd = hWnd;
    contextBlock->Overlay.AsyncGetServ.wMsg = wMsg;
    contextBlock->Overlay.AsyncGetServ.Filter = localName;
    contextBlock->Overlay.AsyncGetServ.Protocol = (PCHAR)Protocol;;
    contextBlock->Overlay.AsyncGetServ.Buffer = Buffer;
    contextBlock->Overlay.AsyncGetServ.BufferLength = BufferLength;

    //
    // Save the task handle so that we can return it to the caller.
    // After we post the context block, we're not allowed to access
    // it in any way.
    //

    taskHandle = contextBlock->TaskHandle;

    //
    // Queue the request to the async thread.
    //

    SockQueueRequestToAsyncThread( contextBlock );

    return taskHandle;

}   // WSAAsyncGetServByName



HANDLE
WSAAPI
WSAAsyncGetServByPort(
    IN HWND hWnd,
    IN unsigned int wMsg,
    IN int Port,
    IN const char FAR * Protocol,
    IN char FAR * Buffer,
    IN int BufferLength
    )

/*++

Routine Description:

    This function is an asynchronous version of getservbyport(), and is
    used to retrieve service information corresponding to a port number.
    The Windows Sockets implementation initiates the operation and
    returns to the caller immediately, passing back an asynchronous task
    handle which the application may use to identify the operation.
    When the operation is completed, the results (if any) are copied
    into the buffer provided by the caller and a message is sent to the
    application's window.

    When the asynchronous operation is complete the application's window
    hWnd receives message wMsg.  The wParam argument contains the
    asynchronous task handle as returned by the original function call.
    The high 16 bits of lParam contain any error code.  The error code
    may be any error as defined in winsock.h.  An error code of zero
    indicates successful completion of the asynchronous operation.  On
    successful completion, the buffer supplied to the original function
    call contains a servent structure.  To access the elements of this
    structure, the original buffer address should be cast to a servent
    structure pointer and accessed as appropriate.

    Note that if the error code is WSAENOBUFS, it indicates that the
    size of the buffer specified by buflen in the original call was too
    small to contain all the resultant information.  In this case, the
    low 16 bits of lParam contain the size of buffer required to supply
    ALL the requisite information.  If the application decides that the
    partial data is inadequate, it may reissue the
    WSAAsyncGetServByPort() function call with a buffer large enough to
    receive all the desired information (i.e.  no smaller than the low
    16 bits of lParam).

    The error code and buffer length should be extracted from the lParam
    using the macros WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in
    winsock.h as:

        #define WSAGETASYNCERROR(lParam) HIWORD(lParam)
        #define WSAGETASYNCBUFLEN(lParam) LOWORD(lParam)

    The use of these macros will maximize the portability of the source
    code for the application.


    The buffer supplied to this function is used by the Windows Sockets
    implementation to construct a servent structure together with the
    contents of data areas referenced by members of the same servent
    structure.  To avoid the WSAENOBUFS error noted above, the
    application should provide a buffer of at least MAXGETHOSTSTRUCT
    bytes (as defined in winsock.h).

Arguments:

    hWnd - The handle of the window which should receive a message when
       the asynchronous request completes.

    wMsg - The message to be received when the asynchronous request
       completes.

    port - The port for the service, in network byte order.

    proto - A pointer to a protocol name.  This may be NULL, in which
        case WSAAsyncGetServByPort() will search for the first service
        entry for which s_port match the given port.  Otherwise
        WSAAsyncGetServByPort() matches both port and proto.

    buf - A pointer to the data area to receive the servent data.  Note
       that this must be larger than the size of a servent structure.
       This is because the data area supplied is used by the Windows
       Sockets implementation to contain not only a servent structure
       but any and all of the data which is referenced by members of the
       servent structure.  It is recommended that you supply a buffer of
       MAXGETHOSTSTRUCT bytes.

    buflen    The size of data area buf above.

Return Value:

    The return value specifies whether or not the asynchronous operation
    was successfully initiated.  Note that it does not imply success or
    failure of the operation itself.

    If the operation was successfully initiated, WSAAsyncGetServByPort()
    returns a nonzero value of type HANDLE which is the asynchronous
    task handle for the request.  This value can be used in two ways.
    It can be used to cancel the operation using
    WSACancelAsyncRequest().  It can also be used to match up
    asynchronous operations and completion messages, by examining the
    wParam message argument.

    If the asynchronous operation could not be initiated,
    WSAAsyncGetServByPort() returns a zero value, and a specific error
    number may be retrieved by calling WSAGetLastError().

--*/

{

    INT                    ErrorCode;
    PWINSOCK_CONTEXT_BLOCK contextBlock;
    HANDLE                 taskHandle;

    ErrorCode = TURBO_PROLOG();

    if (ErrorCode!=ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return NULL;
    } //if

    //
    // Initialize the async thread if it hasn't already been started.
    //

    if( !SockCheckAndInitAsyncThread() ) {

        // !!! better error code?
        SetLastError( WSAENOBUFS );
        return NULL;

    }

    //
    // Get an async context block.
    //

    contextBlock = SockAllocateContextBlock( 0 );

    if ( contextBlock == NULL ) {

        SetLastError( WSAENOBUFS );
        return NULL;

    }

    //
    // Initialize the context block for this operation.
    //

    contextBlock->OpCode = WS_OPCODE_GET_SERV_BY_PORT;
    contextBlock->Overlay.AsyncGetServ.hWnd = hWnd;
    contextBlock->Overlay.AsyncGetServ.wMsg = wMsg;
    contextBlock->Overlay.AsyncGetServ.Filter = (PCHAR)IntToPtr(Port);
    contextBlock->Overlay.AsyncGetServ.Protocol = (PCHAR)Protocol;
    contextBlock->Overlay.AsyncGetServ.Buffer = Buffer;
    contextBlock->Overlay.AsyncGetServ.BufferLength = BufferLength;

    //
    // Save the task handle so that we can return it to the caller.
    // After we post the context block, we're not allowed to access
    // it in any way.
    //

    taskHandle = contextBlock->TaskHandle;

    //
    // Queue the request to the async thread.
    //

    SockQueueRequestToAsyncThread( contextBlock );

    return taskHandle;

}   // WSAAsyncGetServByPort



HANDLE
WSAAPI
WSAAsyncGetHostByName(
    HWND hWnd,
    unsigned int wMsg,
    const char FAR * Name,
    char FAR * Buffer,
    int BufferLength
    )

/*++

Routine Description:

    This function is an asynchronous version of gethostbyname(), and is
    used to retrieve host name and address information corresponding to
    a hostname.  The Windows Sockets implementation initiates the
    operation and returns to the caller immediately, passing back an
    asynchronous task handle which the application may use to identify
    the operation.  When the operation is completed, the results (if
    any) are copied into the buffer provided by the caller and a message
    is sent to the application's window.

    When the asynchronous operation is complete the application's window
    hWnd receives message wMsg.  The wParam argument contains the
    asynchronous task handle as returned by the original function call.
    The high 16 bits of lParam contain any error code.  The error code
    may be any error as defined in winsock.h.  An error code of zero
    indicates successful completion of the asynchronous operation.  On
    successful completion, the buffer supplied to the original function
    call contains a hostent structure.  To access the elements of this
    structure, the original buffer address should be cast to a hostent
    structure pointer and accessed as appropriate.

    Note that if the error code is WSAENOBUFS, it indicates that the
    size of the buffer specified by buflen in the original call was too
    small to contain all the resultant information.  In this case, the
    low 16 bits of lParam contain the size of buffer required to supply
    ALL the requisite information.  If the application decides that the
    partial data is inadequate, it may reissue the
    WSAAsyncGetHostByName() function call with a buffer large enough to
    receive all the desired information (i.e.  no smaller than the low
    16 bits of lParam).

    The error code and buffer length should be extracted from the lParam
    using the macros WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in
    winsock.h as:

        #define WSAGETASYNCERROR(lParam) HIWORD(lParam)
        #define WSAGETASYNCBUFLEN(lParam) LOWORD(lParam)

    The use of these macros will maximize the portability of the source
    code for the application.

    The buffer supplied to this function is used by the Windows Sockets
    implementation to construct a hostent structure together with the
    contents of data areas referenced by members of the same hostent
    structure.  To avoid the WSAENOBUFS error noted above, the
    application should provide a buffer of at least MAXGETHOSTSTRUCT
    bytes (as defined in winsock.h).

Arguments:

    hWnd - The handle of the window which should receive a message when
       the asynchronous request completes.

    wMsg - The message to be received when the asynchronous request
       completes.

    name - A pointer to the name of the host.

    buf - A pointer to the data area to receive the hostent data.  Note
       that this must be larger than the size of a hostent structure.
       This is because the data area supplied is used by the Windows
       Sockets implementation to contain not only a hostent structure
       but any and all of the data which is referenced by members of the
       hostent structure.  It is recommended that you supply a buffer of
       MAXGETHOSTSTRUCT bytes.

    buflen - The size of data area buf above.

Return Value:

    The return value specifies whether or not the asynchronous operation
    was successfully initiated.  Note that it does not imply success or
    failure of the operation itself.

    If the operation was successfully initiated, WSAAsyncGetHostByName()
    returns a nonzero value of type HANDLE which is the asynchronous
    task handle for the request.  This value can be used in two ways.
    It can be used to cancel the operation using
    WSACancelAsyncRequest().  It can also be used to match up
    asynchronous operations and completion messages, by examining the
    wParam message argument.

    If the asynchronous operation could not be initiated,
    WSAAsyncGetHostByName() returns a zero value, and a specific error
    number may be retrieved by calling WSAGetLastError().

--*/

{

    INT                    ErrorCode;
    PWINSOCK_CONTEXT_BLOCK contextBlock;
    HANDLE                 taskHandle;
    PCHAR                  localName;

    ErrorCode = TURBO_PROLOG();

    if (ErrorCode!=ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return NULL;
    } //if

    //
    // Initialize the async thread if it hasn't already been started.
    //

    if( !SockCheckAndInitAsyncThread() ) {

        // !!! better error code?
        SetLastError( WSAENOBUFS );
        return NULL;

    }

    //
    // Get an async context block with enough extra space for
    // the name.  We must preserve the name until we're done using
    // it, since the application may reuse the buffer.
    //

    contextBlock = SockAllocateContextBlock( strlen(Name) + 1 );

    if( contextBlock == NULL ) {

        SetLastError( WSAENOBUFS );
        return NULL;

    }

    localName = (PCHAR)( contextBlock + 1 );

    strcpy( localName, Name );

    //
    // Initialize the context block for this operation.
    //

    contextBlock->OpCode = WS_OPCODE_GET_HOST_BY_NAME;
    contextBlock->Overlay.AsyncGetHost.hWnd = hWnd;
    contextBlock->Overlay.AsyncGetHost.wMsg = wMsg;
    contextBlock->Overlay.AsyncGetHost.Filter = localName;
    contextBlock->Overlay.AsyncGetHost.Buffer = Buffer;
    contextBlock->Overlay.AsyncGetHost.BufferLength = BufferLength;

    //
    // Save the task handle so that we can return it to the caller.
    // After we post the context block, we're not allowed to access
    // it in any way.
    //

    taskHandle = contextBlock->TaskHandle;

    //
    // Queue the request to the async thread.
    //

    SockQueueRequestToAsyncThread( contextBlock );

    return taskHandle;

}   // WSAAsyncGetHostByName


HANDLE
WSAAPI
WSAAsyncGetHostByAddr(
    HWND hWnd,
    unsigned int wMsg,
    const char FAR * Address,
    int Length,
    int Type,
    char FAR * Buffer,
    int BufferLength
    )

/*++

Routine Description:

    This function is an asynchronous version of gethostbyaddr(), and is
    used to retrieve host name and address information corresponding to
    a network address.  The Windows Sockets implementation initiates the
    operation and returns to the caller immediately, passing back an
    asynchronous task handle which the application may use to identify
    the operation.  When the operation is completed, the results (if
    any) are copied into the buffer provided by the caller and a message
    is sent to the application's window.

    When the asynchronous operation is complete the application's window
    hWnd receives message wMsg.  The wParam argument contains the
    asynchronous task handle as returned by the original function call.
    The high 16 bits of lParam contain any error code.  The error code
    may be any error as defined in winsock.h.  An error code of zero
    indicates successful completion of the asynchronous operation.  On
    successful completion, the buffer supplied to the original function
    call contains a hostent structure.  To access the elements of this
    structure, the original buffer address should be cast to a hostent
    structure pointer and accessed as appropriate.

    Note that if the error code is WSAENOBUFS, it indicates that the
    size of the buffer specified by buflen in the original call was too
    small to contain all the resultant information.  In this case, the
    low 16 bits of lParam contain the size of buffer required to supply
    ALL the requisite information.  If the application decides that the
    partial data is inadequate, it may reissue the
    WSAAsyncGetHostByAddr() function call with a buffer large enough to
    receive all the desired information (i.e.  no smaller than the low
    16 bits of lParam).

    The error code and buffer length should be extracted from the lParam
    using the macros WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in
    winsock.h as:

        #define WSAGETASYNCERROR(lParam) HIWORD(lParam)
        #define WSAGETASYNCBUFLEN(lParam) LOWORD(lParam)

    The use of these macros will maximize the portability of the source
    code for the application.

    The buffer supplied to this function is used by the Windows Sockets
    implementation to construct a hostent structure together with the
    contents of data areas referenced by members of the same hostent
    structure.  To avoid the WSAENOBUFS error noted above, the
    application should provide a buffer of at least MAXGETHOSTSTRUCT
    bytes (as defined in winsock.h).

Arguments:

    hWnd - The handle of the window which should receive a message when
       the asynchronous request completes.

    wMsg - The message to be received when the asynchronous request
       completes.

    addr - A pointer to the network address for the host.  Host
       addresses are stored in network byte order.

    len - The length of the address, which must be 4 for PF_INET.

    type - The type of the address, which must be PF_INET.

    buf - A pointer to the data area to receive the hostent data.  Note
       that this must be larger than the size of a hostent structure.
       This is because the data area supplied is used by the Windows
       Sockets implementation to contain not only a hostent structure
       but any and all of the data which is referenced by members of the
       hostent structure.  It is recommended that you supply a buffer of
       MAXGETHOSTSTRUCT bytes.

    buflen - The size of data area buf above.

Return Value:

    The return value specifies whether or not the asynchronous operation
    was successfully initiated.  Note that it does not imply success or
    failure of the operation itself.

    If the operation was successfully initiated, WSAAsyncGetHostByAddr()
    returns a nonzero value of type HANDLE which is the asynchronous
    task handle for the request.  This value can be used in two ways.
    It can be used to cancel the operation using
    WSACancelAsyncRequest().  It can also be used to match up
    asynchronous operations and completion messages, by examining the
    wParam message argument.

    If the asynchronous operation could not be initiated,
    WSAAsyncGetHostByAddr() returns a zero value, and a specific error
    number may be retrieved by calling WSAGetLastError().

--*/

{

    INT                    ErrorCode;
    PWINSOCK_CONTEXT_BLOCK contextBlock;
    HANDLE                 taskHandle;
    PCHAR                  localAddress;

    ErrorCode = TURBO_PROLOG();

    if (ErrorCode!=ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return NULL;
    } //if

    //
    // Initialize the async thread if it hasn't already been started.
    //

    if( !SockCheckAndInitAsyncThread() ) {

        // !!! better error code?
        SetLastError( WSAENOBUFS );
        return NULL;

    }

    //
    // Get an async context block with enough extra space for
    // the address.  We must preserve the address until we're done
    // using it, since the application may reuse the buffer.
    //

    contextBlock = SockAllocateContextBlock( Length );

    if( contextBlock == NULL ) {

        SetLastError( WSAENOBUFS );
        return NULL;

    }

    localAddress = (PCHAR)( contextBlock + 1 );

    CopyMemory(
        localAddress,
        Address,
        Length
        );

    //
    // Initialize the context block for this operation.
    //

    contextBlock->OpCode = WS_OPCODE_GET_HOST_BY_ADDR;
    contextBlock->Overlay.AsyncGetHost.hWnd = hWnd;
    contextBlock->Overlay.AsyncGetHost.wMsg = wMsg;
    contextBlock->Overlay.AsyncGetHost.Filter = localAddress;
    contextBlock->Overlay.AsyncGetHost.Length = Length;
    contextBlock->Overlay.AsyncGetHost.Type = Type;
    contextBlock->Overlay.AsyncGetHost.Buffer = Buffer;
    contextBlock->Overlay.AsyncGetHost.BufferLength = BufferLength;

    //
    // Save the task handle so that we can return it to the caller.
    // After we post the context block, we're not allowed to access
    // it in any way.
    //

    taskHandle = contextBlock->TaskHandle;

    //
    // Queue the request to the async thread.
    //

    SockQueueRequestToAsyncThread( contextBlock );

    return taskHandle;

}   // WSAAsyncGetHostByAddr


HANDLE
WSAAPI
WSAAsyncGetProtoByName (
    IN HWND hWnd,
    IN unsigned int wMsg,
    IN const char FAR *Name,
    IN char FAR *Buffer,
    IN int BufferLength
    )

/*++

Routine Description:

    This function is an asynchronous version of getprotobyname(), and is
    used to retrieve the protocol name and number corresponding to a
    protocol name.  The Windows Sockets implementation initiates the
    operation and returns to the caller immediately, passing back an
    asynchronous task handle which the application may use to identify
    the operation.  When the operation is completed, the results (if
    any) are copied into the buffer provided by the caller and a message
    is sent to the application's window.

    When the asynchronous operation is complete the application's window
    hWnd receives message wMsg.  The wParam argument contains the
    asynchronous task handle as returned by the original function call.
    The high 16 bits of lParam contain any error code.  The error code
    may be any error as defined in winsock.h.  An error code of zero
    indicates successful completion of the asynchronous operation.  On
    successful completion, the buffer supplied to the original function
    call contains a protoent structure.  To access the elements of this
    structure, the original buffer address should be cast to a protoent
    structure pointer and accessed as appropriate.

    Note that if the error code is WSAENOBUFS, it indicates that the
    size of the buffer specified by buflen in the original call was too
    small to contain all the resultant information.  In this case, the
    low 16 bits of lParam contain the size of buffer required to supply
    ALL the requisite information.  If the application decides that the
    partial data is inadequate, it may reissue the
    WSAAsyncGetProtoByName() function call with a buffer large enough to
    receive all the desired information (i.e.  no smaller than the low
    16 bits of lParam).

    The error code and buffer length should be extracted from the lParam
    using the macros WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in
    winsock.h as:

        #define WSAGETASYNCERROR(lParam) HIWORD(lParam)
        #define WSAGETASYNCBUFLEN(lParam) LOWORD(lParam)

    The use of these macros will maximize the portability of the source
    code for the application.

    The buffer supplied to this function is used by the Windows Sockets
    implementation to construct a protoent structure together with the
    contents of data areas referenced by members of the same protoent
    structure.  To avoid the WSAENOBUFS error noted above, the
    application should provide a buffer of at least MAXGETHOSTSTRUCT
    bytes (as defined in winsock.h).

Arguments:

    hWnd - The handle of the window which should receive a message when
       the asynchronous request completes.

    wMsg - The message to be received when the asynchronous request
       completes.

    name - A pointer to the protocol name to be resolved.

    buf - A pointer to the data area to receive the protoent data.  Note
       that this must be larger than the size of a protoent structure.
       This is because the data area supplied is used by the Windows
       Sockets implementation to contain not only a protoent structure
       but any and all of the data which is referenced by members of the
       protoent structure.  It is recommended that you supply a buffer
       of MAXGETHOSTSTRUCT bytes.

    buflen - The size of data area buf above.

Return Value:

    The return value specifies whether or not the asynchronous operation
    was successfully initiated.  Note that it does not imply success or
    failure of the operation itself.

    If the operation was successfully initiated,
    WSAAsyncGetProtoByName() returns a nonzero value of type HANDLE
    which is the asynchronous task handle for the request.  This value
    can be used in two ways.  It can be used to cancel the operation
    using WSACancelAsyncRequest().  It can also be used to match up
    asynchronous operations and completion messages, by examining the
    wParam message argument.

    If the asynchronous operation could not be initiated,
    WSAAsyncGetProtoByName() returns a zero value, and a specific error
    number may be retrieved by calling WSAGetLastError().

--*/

{

    INT                    ErrorCode;
    PWINSOCK_CONTEXT_BLOCK contextBlock;
    HANDLE                 taskHandle;
    PCHAR                  localName;

    ErrorCode = TURBO_PROLOG();

    if (ErrorCode!=ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return NULL;
    } //if

    //
    // Initialize the async thread if it hasn't already been started.
    //

    if( !SockCheckAndInitAsyncThread() ) {

        // !!! better error code?
        SetLastError( WSAENOBUFS );
        return NULL;

    }

    //
    // Get an async context block with enough extra space for
    // the name.  We must preserve the name until we're done using
    // it, since the application may reuse the buffer.
    //

    contextBlock = SockAllocateContextBlock( strlen(Name) + 1 );

    if( contextBlock == NULL ) {

        SetLastError( WSAENOBUFS );
        return NULL;

    }

    localName = (PCHAR)( contextBlock + 1 );

    strcpy( localName, Name );

    //
    // Initialize the context block for this operation.
    //

    contextBlock->OpCode = WS_OPCODE_GET_PROTO_BY_NAME;
    contextBlock->Overlay.AsyncGetProto.hWnd = hWnd;
    contextBlock->Overlay.AsyncGetProto.wMsg = wMsg;
    contextBlock->Overlay.AsyncGetProto.Filter = localName;
    contextBlock->Overlay.AsyncGetProto.Buffer = Buffer;
    contextBlock->Overlay.AsyncGetProto.BufferLength = BufferLength;

    //
    // Save the task handle so that we can return it to the caller.
    // After we post the context block, we're not allowed to access
    // it in any way.
    //

    taskHandle = contextBlock->TaskHandle;

    //
    // Queue the request to the async thread.
    //

    SockQueueRequestToAsyncThread( contextBlock );

    return taskHandle;

}   // WSAAsyncGetProtoByName


HANDLE
WSAAPI
WSAAsyncGetProtoByNumber (
    HWND hWnd,
    unsigned int wMsg,
    int Number,
    char FAR * Buffer,
    int BufferLength
    )

/*++

Routine Description:

    This function is an asynchronous version of getprotobynumber(), and
    is used to retrieve the protocol name and number corresponding to a
    protocol number.  The Windows Sockets implementation initiates the
    operation and returns to the caller immediately, passing back an
    asynchronous task handle which the application may use to identify
    the operation.  When the operation is completed, the results (if
    any) are copied into the buffer provided by the caller and a message
    is sent to the application's window.

    When the asynchronous operation is complete the application's window
    hWnd receives message wMsg.  The wParam argument contains the
    asynchronous task handle as returned by the original function call.
    The high 16 bits of lParam contain any error code.  The error code
    may be any error as defined in winsock.h.  An error code of zero
    indicates successful completion of the asynchronous operation.  On
    successful completion, the buffer supplied to the original function
    call contains a protoent structure.  To access the elements of this
    structure, the original buffer address should be cast to a protoent
    structure pointer and accessed as appropriate.

    Note that if the error code is WSAENOBUFS, it indicates that the
    size of the buffer specified by buflen in the original call was too
    small to contain all the resultant information.  In this case, the
    low 16 bits of lParam contain the size of buffer required to supply
    ALL the requisite information.  If the application decides that the
    partial data is inadequate, it may reissue the
    WSAAsyncGetProtoByNumber() function call with a buffer large enough
    to receive all the desired information (i.e.  no smaller than the
    low 16 bits of lParam).

    The error code and buffer length should be extracted from the lParam
    using the macros WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in
    winsock.h as:

        #define WSAGETASYNCERROR(lParam) HIWORD(lParam)
        #define WSAGETASYNCBUFLEN(lParam) LOWORD(lParam)

    The use of these macros will maximize the portability of the source
    code for the application.

    The buffer supplied to this function is used by the Windows Sockets
    implementation to construct a protoent structure together with the
    contents of data areas referenced by members of the same protoent
    structure.  To avoid the WSAENOBUFS error noted above, the
    application should provide a buffer of at least MAXGETHOSTSTRUCT
    bytes (as defined in winsock.h).

Arguments:

    hWnd - The handle of the window which should receive a message when
       the asynchronous request completes.

    wMsg - The message to be received when the asynchronous request
       completes.

    number - The protocol number to be resolved, in host byte order.

    buf - A pointer to the data area to receive the protoent data.  Note
       that this must be larger than the size of a protoent structure.
       This is because the data area supplied is used by the Windows
       Sockets implementation to contain not only a protoent structure
       but any and all of the data which is referenced by members of the
       protoent structure.  It is recommended that you supply a buffer
       of MAXGETHOSTSTRUCT bytes.

    buflen - The size of data area buf above.

Return Value:

    The return value specifies whether or not the asynchronous operation
    was successfully initiated.  Note that it does not imply success or
    failure of the operation itself.

    If the operation was successfully initiated,
    WSAAsyncGetProtoByNumber() returns a nonzero value of type HANDLE
    which is the asynchronous task handle for the request.  This value
    can be used in two ways.  It can be used to cancel the operation
    using WSACancelAsyncRequest().  It can also be used to match up
    asynchronous operations and completion messages, by examining the
    wParam message argument.

    If the asynchronous operation could not be initiated,
    WSAAsyncGetProtoByNumber() returns a zero value, and a specific
    error number may be retrieved by calling WSAGetLastError().

--*/

{

    INT                    ErrorCode;
    PWINSOCK_CONTEXT_BLOCK contextBlock;
    HANDLE                 taskHandle;

    ErrorCode = TURBO_PROLOG();

    if (ErrorCode!=ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return NULL;
    } //if

    //
    // Initialize the async thread if it hasn't already been started.
    //

    if( !SockCheckAndInitAsyncThread() ) {

        // !!! better error code?
        SetLastError( WSAENOBUFS );
        return NULL;

    }

    //
    // Get an async context block.
    //

    contextBlock = SockAllocateContextBlock( 0 );

    if( contextBlock == NULL ) {

        SetLastError( WSAENOBUFS );
        return NULL;

    }

    //
    // Initialize the context block for this operation.
    //

    contextBlock->OpCode = WS_OPCODE_GET_PROTO_BY_NUMBER;
    contextBlock->Overlay.AsyncGetProto.hWnd = hWnd;
    contextBlock->Overlay.AsyncGetProto.wMsg = wMsg;
    contextBlock->Overlay.AsyncGetProto.Filter = (PCHAR)IntToPtr(Number);
    contextBlock->Overlay.AsyncGetProto.Buffer = Buffer;
    contextBlock->Overlay.AsyncGetProto.BufferLength = BufferLength;

    //
    // Save the task handle so that we can return it to the caller.
    // After we post the context block, we're not allowed to access
    // it in any way.
    //

    taskHandle = contextBlock->TaskHandle;

    //
    // Queue the request to the async thread.
    //

    SockQueueRequestToAsyncThread( contextBlock );

    return taskHandle;

}   // WSAAsyncGetProtoByNumber



int
WSAAPI
WSACancelAsyncRequest (
    HANDLE hAsyncTaskHandle
    )

/*++

Routine Description:

    The WSACancelAsyncRequest() function is used to cancel an
    asynchronous operation which was initiated by one of the
    WSAAsyncGetXByY() functions such as WSAAsyncGetHostByName().  The
    operation to be canceled is identified by the hAsyncTaskHandle
    parameter, which should be set to the asynchronous task handle as
    returned by the initiating function.

Arguments:

    hAsyncTaskHandle - Specifies the asynchronous operation to be
        canceled.

Return Value:

    The value returned by WSACancelAsyncRequest() is 0 if the operation
    was successfully canceled.  Otherwise the value SOCKET_ERROR is
    returned, and a specific error number may be retrieved by calling
    WSAGetLastError().

--*/

{

    INT       ErrorCode;

    ErrorCode = TURBO_PROLOG();

    if (ErrorCode!=ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return SOCKET_ERROR;
    } //if

    //
    // Let the async code do the grunt work.
    //

    ErrorCode = SockCancelAsyncRequest( hAsyncTaskHandle );

    if (ErrorCode == ERROR_SUCCESS) {
        return (ERROR_SUCCESS);
    }
    else {
        SetLastError(ErrorCode);
        return (SOCKET_ERROR);
    }

}   // WSACancelAsyncRequest



//
//  Address to string routines for gethostbyaddr()
//
//  Linking in the dnslib.lib routines causes multiple defintion
//  problems for the linker on every winsock routine it hits
//  in the dnslib.lib modules brought in.
//
//  These simple conversion routines get the job done.
//

PCHAR
Local_Ip6AddressToString_A(
    OUT     PCHAR           pBuffer,
    IN      PIP6_ADDRESS    pIp6Addr
    )
/*++

Routine Description:

    Convert IP6 address to string format.

Arguments:

    pBuffer -- buffer to hold string;  MUST be at least
        IPV6_ADDRESS_STRING_LENGTH+1 in length

    pIp6Addr -- IP6 address to convert to string

Return Value:

    Ptr to next location in buffer (the terminating NULL).

--*/
{
    INT i;

    //
    //  write the address in colon separated words
    //

    for (i = 0; i < 8; i++)
    {
        WORD    thisWord;

        //  write address word
        //
        //  note:  not using ntohs() here so that this function can
        //      be used in winsock code without symbol confusion

        thisWord = inline_ntohs( pIp6Addr->IP6Word[i] );

        pBuffer += sprintf(
                        pBuffer,
                        "%x:",
                        thisWord );
    }

    //  whack off last ":"

    * (--pBuffer) = 0;

    return( pBuffer );
}



PCHAR
Local_Ip4AddressToString_A(
    OUT     PCHAR           pBuffer,
    IN      PIP4_ADDRESS    pIp4Addr
    )
/*++

Routine Description:

    Convert IP4 address to string format.

Arguments:

    pBuffer -- buffer to hold string;  MUST be at least
        IPV6_ADDRESS_STRING_LENGTH+1 in length

    pIp4Addr -- IP4 address to convert to string

Return Value:

    Ptr to next location in buffer (the terminating NULL).

--*/
{
    IP4_ADDRESS ip = *pIp4Addr;

    //
    //  convert IP4 address to string
    //      - address is in net order, lead byte in low memory
    //

    pBuffer += sprintf(
                    pBuffer,
                    "%u.%u.%u.%u",
                    (UCHAR) (ip & 0x000000ff),
                    (UCHAR) ((ip & 0x0000ff00) >> 8),
                    (UCHAR) ((ip & 0x00ff0000) >> 16),
                    (UCHAR) ((ip & 0xff000000) >> 24)
                    );

    return( pBuffer );
}



PCHAR
Local_AddressToString_A(
    OUT     PCHAR           pBuffer,
    IN OUT  PDWORD          pBufferLength,
    IN      PBYTE           pAddr,
    IN      DWORD           AddrLength,
    IN      DWORD           AddrFamily
    )
/*++

Routine Description:

    Convert address to string format.

Arguments:

    pBuffer -- buffer to hold string;  MUST be at least
        IPV6_ADDRESS_STRING_LENGTH+1 in length

    pBufferLength -- string buffer length

    pAddr -- ptr to address

    AddrLength -- address length

    AddrFamily -- address family (AF_INET, AF_INET6)

Return Value:

    Ptr to next location in buffer (the terminating NULL).
    NULL if no conversion.

--*/
{
    DWORD   length = *pBufferLength;
    UNREFERENCED_PARAMETER (AddrLength);

    //  dispatch to conversion routine for this type

    if ( AddrFamily == AF_INET )
    {
        if ( length < IP_ADDRESS_STRING_LENGTH+1 )
        {
            length = IP_ADDRESS_STRING_LENGTH+1;
            goto Failed;
        }
        return  Local_Ip4AddressToString_A(
                    pBuffer,
                    (PIP4_ADDRESS) pAddr );
    }

    if ( AddrFamily == AF_INET6 )
    {
        if ( length < IP6_ADDRESS_STRING_LENGTH+1 )
        {
            length = IP6_ADDRESS_STRING_LENGTH+1;
            goto Failed;
        }
        return  Local_Ip6AddressToString_A(
                    pBuffer,
                    (PIP6_ADDRESS) pAddr );
    }

Failed:

    *pBufferLength = length;

    return  NULL;
}

#ifdef _WIN64
#pragma warning (pop)
#endif
//
//  End getxbyy.cpp
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\event.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    event.cpp

Abstract:

    This module contains the event handling functions from the winsock
    API.  This module contains the following entry points.

    WSACloseEvent()
    WSACreateEvent()
    WSAResetEvent()
    WSASetEvent()
    WSAWaintForMultipleEvents()

Author:

    Dirk Brandewie dirk@mink.intel.com  14-06-1995

Revision History:

    22-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Moved includes to precomp.h

    dirk@mink.intel.com  21-Jul-1995
        Added warnoff.h to includes

    Mark Hamilton mark_hamilton@ccm.jf.intel.com 19-07-1995

        Implemented all of the functions.

--*/
#include "precomp.h"



BOOL WSAAPI
WSACloseEvent(
              IN WSAEVENT hEvent
              )
/*++
Routine Description:

    Closes an open event object handle.

Arguments:

    hEvent - Identifies an open event object handle.

Returns:

    TRUE on success else FALSE. The error code is stored with
    SetLastError().

--*/
{

    BOOL result;

    //
    // NT will throw an exception if a stale handle is closed,
    // so protect ourselves in try/except so we can return the
    // correct error code.
    //

    __try {

        result = CloseHandle( hEvent );

    } __except( WS2_EXCEPTION_FILTER() ) {

        result = FALSE;

    }

    if( !result ) {

        SetLastError( WSA_INVALID_HANDLE );

    }

    return result;

}



WSAEVENT WSAAPI
WSACreateEvent (
                void
                )
/*++
Routine Description:

    Creates a new event object.

Arguments:

    NONE

Returns:

    The return value is the handle of the event object. If the
    function fails, the return value is WSA_INVALID_EVENT.

--*/
{
    return(CreateEvent(NULL,TRUE,FALSE,NULL));
}




BOOL WSAAPI
WSAResetEvent(
              IN WSAEVENT hEvent
              )
/*++
Routine Description:

    Resets the state of the specified event object to nonsignaled.

Arguments:

    hEvent - Identifies an open event object handle.

Returns:
    TRUE on success else FALSE. The error code is stored with
    SetErrorCode().
--*/
{
    return(ResetEvent(hEvent));
}




BOOL WSAAPI
WSASetEvent(
            IN WSAEVENT hEvent
            )
/*++
Routine Description:

    Sets the state of the specified event object to signaled.

Arguments:

     hEvent - Identifies an open event object handle.

Returns:

    TRUE on success else FALSE. The error code is stored with
    SetErrorCode().

--*/

{
  return( SetEvent(hEvent));
}





DWORD WSAAPI
WSAWaitForMultipleEvents(
                         IN DWORD cEvents,
                         IN const WSAEVENT FAR * lphEvents,
                         IN BOOL fWaitAll,
                         IN DWORD dwTimeout,
                         IN BOOL fAlertable
                         )
/*++
Routine Description:

    Returns  either when any one or when all of the specified event objects are
    in the signaled state, or when the time-out interval expires.

Arguments:

    cEvents    - Specifies  the  number  of  event  object handles in the array
                 pointed  to  by lphEvents.  The maximum number of event object
                 handles is WSA_MAXIMUM_WAIT_EVENTS.

    lphEvents  - Points to an array of event object handles.

    fWaitAll   - Specifies  the  wait type.  If TRUE, the function returns when
                 all  event  objects in the lphEvents array are signaled at the
                 same time.  If FALSE, the function returns when any one of the
                 event  objects  is  signaled.   In the latter case, the return
                 value  indicates  the  event  object  whose  state  caused the
                 function to return.

    dwTimeout  - Specifies   the   time-out  interval,  in  milliseconds.   The
                 function  returns  if the interval expires, even if conditions
                 specified  by  the  fWaitAll  parameter are not satisfied.  If
                 dwTimeout  is  zero,  the  function  tests  the  state  of the
                 specified event objects and returns immediately.  If dwTimeout
                 is   WSA_INFINITE,  the  function's  time-out  interval  never
                 expires.

    fAlertable - Specifies  whether the function returns when the system queues
                 an I/O completion routine for execution by the calling thread.
                 If  TRUE,  the  function returns and the completion routine is
                 executed.   If  FALSE,  the  function  does not return and the
                 completion  routine is not executed.  Note that this parameter
                 is ignored in Win16.

Returns:

     If the function succeeds, the return value indicates the event
     object that caused the function to return. If the function fails,
     the return value is WSA_WAIT_FAILED.
--*/
{
    return(WaitForMultipleObjectsEx(
        cEvents,
        lphEvents,
        fWaitAll,
        dwTimeout,
        fAlertable));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\ipconst.c ===
// Copyright (c) 2000 Microsoft Corporation
//
// Abstract:
//
//    Exported const structures declared in ws2tcpip.h.

// Force constants to use dllexport linkage so we can use the safe DATA
// keyword in the .def file, rather than the unsafe CONSTANT.
#define WINSOCK_API_LINKAGE __declspec(dllexport)

#include <winsock2.h>
#include <ws2tcpip.h>

const struct in6_addr in6addr_any = IN6ADDR_ANY_INIT;
const struct in6_addr in6addr_loopback = IN6ADDR_LOOPBACK_INIT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\ioctl.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    ioctl.c

Abstract:

    This module contains the socket I/O control calls of the winsock
    API.  The following functions are contained in ths module.

    ioctlsocket()
    WSAIoctl()

Author:

    Dirk Brandewie dirk@mink.intel.com  14-06-1995

Revision History:

    22-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Moved includes to precomp.h

--*/

#include "precomp.h"



int WSAAPI
ioctlsocket (
    IN SOCKET s,
    IN long cmd,
    IN OUT u_long FAR *argp
    )
/*++
Routine Description:

    Control the mode of a socket.

Arguments:

    s - A descriptor identifying a socket.

    cmd - The command to perform on the socket s.

    argp - A pointer to a parameter for cmd.

Returns:
   Upon successful completion, the ioctlsocket() returns 0.
   Otherwise, a value of SOCKET_ERROR is returned, and a specific
   error code is stored with SetErrorCode().

--*/
{
    DWORD DontCare;

    return(WSAIoctl(
        s,                     // Socket handle
        cmd,                   //Command
        argp,                  // Input buffer
        sizeof(unsigned long), // Input buffer size
        argp,                  // Output buffer
        sizeof(unsigned long), // Output buffer size
        &DontCare,             // bytes returned
        NULL,                  // Overlapped struct
        NULL                   // Completion Routine
        ));
}




int WSAAPI
WSAIoctl(
    IN SOCKET s,
    IN DWORD dwIoControlCode,
    IN LPVOID lpvInBuffer,
    IN DWORD cbInBuffer,
    OUT LPVOID lpvOutBuffer,
    OUT DWORD cbOutBuffer,
    OUT LPDWORD lpcbBytesReturned,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
/*++
Routine Description:

    Control the mode of a socket.

Arguments:

    s - Handle to a socket

    dwIoControlCode - Control code of operation to perform

    lpvInBuffer - Address of input buffer

    cbInBuffer - Size of input buffer

    lpvOutBuffer - Address of output buffer

    cbOutBuffer - Size of output buffer

    lpcbBytesReturned - Address of actual bytes of output

    lpOverlapped - Address of WSAOVERLAPPED structure

    lpCompletionRoutine - A pointer to the completion routine called
                          when the operation  has been completed.

Returns:
    Zero on success else SOCKET_ERROR. The error code is stored with
    SetErrorCode().
--*/
{
    PDTHREAD           Thread;
    INT                ErrorCode, ReturnValue = ERROR_SUCCESS;
    PDPROVIDER         Provider;
    PDSOCKET           Socket;

	ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if (ErrorCode==ERROR_SUCCESS)
	{
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPIoctl(
                s,
                dwIoControlCode,
                lpvInBuffer,
                cbInBuffer,
                lpvOutBuffer,
                cbOutBuffer,
                lpcbBytesReturned,
                lpOverlapped,
                lpCompletionRoutine,
                Thread->GetWahThreadID(),
                &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;

            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        } //if
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return(SOCKET_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\makefile.inc ===
!if defined(LINK_TIME_CODE_GENERATION)
$(O)\ipconst.obj: ipconst.c
       @type <<$(ECHO_RSP)
$(ECHO_MSG_P:/GL=)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" $(USE_FC) $(USECXX_FLAG)
$(EX_C_COMPILER_FLAGS:/GL=)
$**
<<NOKEEP
!else
$(O)\ipconst.obj: ipconst.c
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\nspins64.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    64_32.cpp

Abstract:


Author:

Revision History:

--*/

#include "precomp.h"
#ifdef _WIN64
#define _WIN64_32
#include "nspinstl.cpp"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\nscatent.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    nscatitem.cpp

Abstract:

    This  file  contains  the  class  implementation for the NSCATALOGENTRY
    class.   This  class  defines  the  interface  to  the  entries that can be
    installed and retrieved in the namespace provider catalog.

Author:

    Dirk Brandewie (dirk@mink.intel.com) 09-Nov-1995

Notes:

    $Revision:   1.16  $

    $Modtime:   08 Mar 1996 15:36:46  $

Revision History:

    most-recent-revision-date email-name
        description
    09-Nov-1995 dirk@mink.intel.com
        Initial Revision

--*/


#include "precomp.h"



NSCATALOGENTRY::NSCATALOGENTRY()
/*++

Routine Description:

    This  procedure  constructs  an empty NSCATALOGENTRY object.  The first
    method  invoked  after  this  constructor must be InitializeFromRegistry or
    InitializeFromValues.

Arguments:

    None

Return Value:

    Implicitly  returns  a pointer to a newly created NSCATALOGENTRY object
    or NULL if there is a memory allocation failure.
--*/
{
    DEBUGF(
        DBG_TRACE,
        ("NSCATALOGENTRY constructor\n"));

    m_reference_count = 1;
    // Simply initialize embedded pointer values for safety.
#if defined(DEBUG_TRACING)
    InitializeListHead (&m_CatalogLinkage);
#endif
    m_LibraryPath[0] = '\0';
    m_providerDisplayString = NULL;
    m_namespace_id = 0;
    m_provider = NULL;
    m_enabled = TRUE;
    m_version = NULL;
    m_address_family = -1;        // all by default
}  // NSCATALOGENTRY



// The   following   two   defines  determine  the  number  of  digits  in  the
// sequence-numbered  name  of  each  catalog  entry key.  The two defines must
// include  the  same  number.   If there is a way to cause the preprocessor to
// derive both a quoted and unquoted character sequence from the same sequence,
// I don't know what it is.
#define SEQUENCE_KEY_DIGITS 12
#define SEQUENCE_KEY_DIGITS_STRING "12"




INT
NSCATALOGENTRY::InitializeFromRegistry(
    IN  HKEY  ParentKey,
    IN  INT   SequenceNum
    )
/*++

Routine Description:

    This  procedure initializes the protocol info part of the catalog item from
    information  retrieved  from  the  catalog  portion of the registry.  It is
    assumed that the catalog portion is locked against competing I/O attempts.

Arguments:

    ParentKey   - Supplies  an open registry key for the registry entry that is
                  the  parent  of  the registry item defining the catalog item,
                  i.e., the catalog entry list key.

    SequenceNum - Supplies  the  sequence  number  within the entry list of the
                  target registry entry.

Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it returns an
    appropriate WinSock error code.

--*/
{
    char  keyname[SEQUENCE_KEY_DIGITS + 1];
    HKEY  thiskey;
    LONG  result;
    INT   sock_result;

    sprintf(keyname, "%0"SEQUENCE_KEY_DIGITS_STRING"i", SequenceNum);
    result = RegOpenKeyEx(
        ParentKey,     // hkey
        keyname,       // lpszSubKey
        0,             // dwReserved
        KEY_READ,      // samDesired
        & thiskey      // phkResult
        );
    if (result != ERROR_SUCCESS) {
        DEBUGF(
            DBG_ERR,
            ("Opening catalog entry key %s, error = %lu\n",
            keyname,
            result));
        return(WSANO_RECOVERY);
    }

    sock_result = IoRegistry(
        thiskey,  // EntryKey
        TRUE      // IsRead
        );

    result = RegCloseKey(
        thiskey  // hkey
        );
    if (result != ERROR_SUCCESS) {
        DEBUGF(
            DBG_ERR,
            ("Close catalog entry key %s, error = %lu\n",
            keyname, result));
        return(WSANO_RECOVERY);
    }

    return sock_result;

}  // InitializeFromRegistry




INT
NSCATALOGENTRY::InitializeFromValues(
    IN  LPWSTR           LibraryPath,
    IN  LPWSTR           DisplayString,
    IN  LPGUID           ProviderId,
    IN  DWORD            NameSpaceId,
    IN  DWORD            Version
    )
/*++

Routine Description:

    This  procedure initializes the protocol info part of the catalog item from
    the  values  supplied.  Values are copied from the structures passed by the
    caller,  so  the  caller  is  free  to  deallocate the passed structures on
    return.

Arguments:

    LibraryPath  - Supplies    a    reference   to   a   buffer   holding   the
                   zero-terminated,   fully-qualified   path  of  the  provider
                   library that implements this protocol.  The path may include
                   expandable environment references of the form '%variable%'.

    DisplayString  - Supplies a reference to a buffer holding a
                     zero-terminated display string for this namespace
                     privider.

    ProviderId - A pointer to the GUID for this provider.

    NameSpaceId - The ID of the namespace this provider serves.

Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it returns an
    appropriate WinSock error code.

--*/
{
    size_t  len_needed;
    INT ReturnValue = ERROR_SUCCESS;

    // Copy LibraryPath
    len_needed = wcslen(LibraryPath) + 1;
    if (len_needed > sizeof(m_LibraryPath)) {
        DEBUGF(
            DBG_ERR,
            ("Library Path Too long (%u) '%S'\n",
            len_needed,
            LibraryPath));
        return(WSAEINVAL);
    }
    wcscpy(
        m_LibraryPath,
        LibraryPath);

    // Copy DisplayString
    len_needed = wcslen(DisplayString) + 1;
    if (len_needed>MAX_PATH) {
        DEBUGF(
            DBG_ERR,
            ("Display String Too long (%u) '%S'\n",
            len_needed,
            DisplayString));
        return(WSAEINVAL);
    }

    m_providerDisplayString =  new WCHAR[len_needed];
    if (m_providerDisplayString != NULL) {
        (void) wcscpy(
            m_providerDisplayString,
            DisplayString);
    } else {
        ReturnValue = WSAENOBUFS;
    }


    m_providerId = *ProviderId;
    m_namespace_id = NameSpaceId;
    m_version = Version;
    m_address_family = -1;

    return (ReturnValue);

}  // InitializeFromValues




NSCATALOGENTRY::~NSCATALOGENTRY()
/*++

Routine Description:

    This  procedure  destroys  a  protocol catalog item, deallocating memory it
    owns.   It  is the caller's responsibility to remove the item from the list
    it  occupies  before  calling  this  procedure.   It  is  also the caller's
    responsibility  to unload and/or destroy any dprovider associated with this
    catalog item if appropriate.

Arguments:

    None

Return Value:

    None
--*/
{
    assert (IsListEmpty (&m_CatalogLinkage));
    if (m_providerDisplayString != NULL) {
        delete m_providerDisplayString;
        m_providerDisplayString = NULL;
    } else {
        DEBUGF(
            DBG_WARN,
            ("Destructing uninitialized protocol catalog item\n"));
    }
    if (m_provider!=NULL)
    {
        m_provider->Dereference ();
        m_provider = NULL;
    } //if

}  // ~NSCATALOGENTRY





VOID
NSCATALOGENTRY::SetProvider(
    IN  PNSPROVIDER  Provider
    )
/*++

Routine Description:

    This procedure sets the NSPROVIDER associated with a catalog entry.

Arguments:

    Provider - Supplies the new NSPROVIDER reference.

Return Value:

    None
--*/
{
    assert (m_provider==NULL);
    Provider->Reference ();
    m_provider = Provider;
}  // SetProvider



INT
NSCATALOGENTRY::WriteToRegistry(
    IN  HKEY  ParentKey,
    IN  INT   SequenceNum
    )
/*++

Routine Description:

    This  procedure  writes  the fully-initialized protocol info portion of the
    catalog  entry  out  to the catalog portion of the registry.  It is assumed
    that  the  catalog  portion of the registry is locked against competing I/O
    attempts.

Arguments:

    ParentKey -   Supplies  the  open registry key of the parent registry entry
                  in which this catalog entry will be written as a subkey.

    Sequencenum - Supplies the sequence number of this catalog entry within the
                  entire set of catalog entries.

Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it returns an
    appropriate WINSOCK error code.
--*/
{
    char  keyname[SEQUENCE_KEY_DIGITS + 1];
    HKEY  thiskey;
    LONG  result;
    INT   sock_result;
    DWORD key_disposition;


    sprintf(keyname, "%0"SEQUENCE_KEY_DIGITS_STRING"i", SequenceNum);
    result = RegCreateKeyEx(
        ParentKey,                // hkey
        keyname,                  // lpszSubKey
        0,                        // dwReserved
        NULL,                     // lpszClass
        REG_OPTION_NON_VOLATILE,  // fdwOptions
        KEY_READ|KEY_WRITE,       // samDesired
        NULL,                     // lpSecurityAttributes
        & thiskey,                // phkResult
        & key_disposition         // lpdwDisposition
        );
    if (result != ERROR_SUCCESS) {
        DEBUGF(
            DBG_ERR,
            ("Creating catalog entry key %s (%lu)\n",
            keyname, result));
        return(WSANO_RECOVERY);
    }
    if (key_disposition == REG_OPENED_EXISTING_KEY) {
        DEBUGF(
            DBG_WARN,
            ("Overwriting a catalog entry key '%s'\n",
            keyname));
    }

    sock_result = IoRegistry(
        thiskey,  // EntryKey
        FALSE     // IsRead
        );

    result = RegCloseKey(
        thiskey  // hkey
        );
    if (result != ERROR_SUCCESS) {
        DEBUGF(
            DBG_ERR,
            ("Closing catalog entry %s, error = %lu\n",
            keyname, result));
        return(WSANO_RECOVERY);
    }

    return sock_result;

}  // WriteToRegistry




VOID
NSCATALOGENTRY::Enable(
    IN BOOLEAN EnableValue
    )
/*++

Routine Description:

    Sets the enabled state of this catalog entry

Arguments:

    EnableValue - The new state value.

Return Value:

    NONE

--*/
{
    m_enabled = EnableValue;
}





INT
NSCATALOGENTRY::IoRegistry(
    IN  HKEY  EntryKey,
    IN  BOOL  IsRead)
/*++

Routine Description:

    This  procedure  performs  the  actual  input  or  output  of catalog entry
    information  from  or  to  the  registry.   It  is assumed that the catalog
    portion of the registry is locked against competing I/O attempts.

Arguments:

    EntryKey - Supplies  the open registry key where the catalog entry is to be
               read or written.

    IsRead   - Supplies  a  BOOL  determining  disposition.  TRUE indicates the
               entry  is  to  be  read  into  memory  from the registry.  FALSE
               indicates  the  entry  is  to  be written out from memory to the
               registry.

Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it returns an
    appropriate WINSOCK error code.
--*/
{
    BOOL io_result;
    DWORD  val;
    WSABUF carrier;
    INT pathLength;
    CHAR ansiPath[MAX_PATH];

    // The  library pathnames are expandable against environment variables.  So
    // technically they should be REG_EXPAND_SZ instead of REG_SZ.  However, as
    // of  09-14-1995,  the  registry  editor does not display REG_EXPAND_SZ as
    // strings.   So  to  ease debugging and diagnostics, the library pathnames
    // are written into the registry as REG_SZ instead.

    // char m_LibraryPath[MAX_PATH];
    if (IsRead) {
        io_result = ReadRegistryEntry(
            EntryKey,                                     // EntryKey
            "LibraryPath",                                // EntryName
            ansiPath,                                     // Data
            sizeof(ansiPath),                             // MaxBytes
            REG_SZ                                        // TypeFlag
            );

        if( io_result ) {
            pathLength = MultiByteToWideChar(
                CP_ACP,                                   // CodePage
                0,                                        // dwFlags
                ansiPath,                                 // lpMultiByteStr
                -1,                                       // cchMultiByte
                m_LibraryPath,                            // lpWideCharStr
                sizeof(m_LibraryPath) / sizeof(WCHAR)     // cchWideChar
                );

            io_result = ( pathLength > 0 );
        }
    } else {
        pathLength = WideCharToMultiByte(
            CP_ACP,                                       // CodePage
            0,                                            // dwFlags
            m_LibraryPath,                                // lpWideCharStr
            -1,                                           // cchWideChar
            ansiPath,                                     // lpMultiByteStr
            sizeof(ansiPath),                             // cchMultiByte
            NULL,
            NULL
            );

        if( pathLength == 0 ) {

            io_result = FALSE;

        } else {

            io_result = WriteRegistryEntry(
                EntryKey,                                     // EntryKey
                "LibraryPath",                                // EntryName
                ansiPath,                                     // Data
                REG_SZ                                        // TypeFlag
                );

        }

    }

    if (! io_result) {
        DEBUGF(
            DBG_ERR,
            ("%s registry entry\n",
            IsRead ? "Reading" : "Writing"));
        return WSANO_RECOVERY;
    }

    // PCHAR m_providerDisplayString
    if (IsRead) {
        // Determine size and allocate space for dynamically allocated parts.
        LONG lresult;

        // RegQueryValueEx  includes  the  null  terminator  when returning the
        // length of a string.
        lresult = RegQueryValueEx(
            EntryKey,            // hkey
            "DisplayString",      // lpszValueName
            0,                   // lpdwReserved
            NULL,                // lpdwType
            NULL,                // lpbData
            & val                // lpcbData
            );
        if (lresult != ERROR_SUCCESS) {
            DEBUGF(
                DBG_ERR,
                ("Querying length of ProviderName entry\n"));
            return WSANO_RECOVERY;
        }
        if (m_providerDisplayString != NULL) {
            DEBUGF(
                DBG_ERR,
                ("should never be re-reading a catalog entry\n"));
            return WSANO_RECOVERY;
        }
        if (val >= MAX_PATH) {
            DEBUGF(
                DBG_ERR,
                ("cannot handle provider names > MAX_PATH\n"));
            return WSANO_RECOVERY;
        }
        m_providerDisplayString =  new WCHAR[val];
        if (m_providerDisplayString == NULL) {
            return WSANO_RECOVERY;
        }

        io_result = ReadRegistryEntry(
            EntryKey,                                     // EntryKey
            "DisplayString",                              // EntryName
            ansiPath,                                     // Data
            sizeof(ansiPath),                             // MaxBytes
            REG_SZ                                            // TypeFlag
            );

        if( io_result ) {
            pathLength = MultiByteToWideChar(
                CP_ACP,                                   // CodePage
                0,                                        // dwFlags
                ansiPath,                                 // lpMultiByteStr
                -1,                                       // cchMultiByte
                m_providerDisplayString,                  // lpWideCharStr
                val                                       // cchWideChar
                );

            io_result = ( pathLength > 0 );
        }
    } else {
        pathLength = WideCharToMultiByte(
            CP_ACP,                                       // CodePage
            0,                                            // dwFlags
            m_providerDisplayString,                      // lpWideCharStr
            -1,                                           // cchWideChar
            ansiPath,                                     // lpMultiByteStr
            sizeof(ansiPath),                             // cchMultiByte
            NULL,
            NULL
            );

        if( pathLength == 0 ) {

            io_result = FALSE;

        } else {

            io_result = WriteRegistryEntry(
                EntryKey,                                     // EntryKey
                "DisplayString",                              // EntryName
                ansiPath,                                     // Data
                REG_SZ                                        // TypeFlag
                );

        }
    }
    if (! io_result) {
        DEBUGF(
            DBG_ERR,
            ("%s registry entry\n",
            IsRead ? "Reading" : "Writing"));
        return WSANO_RECOVERY;
    }

    // GUID ProviderId;
    if (IsRead) {
        carrier.len = sizeof(GUID);
        carrier.buf = (char*)& m_providerId;

        io_result = ReadRegistryEntry(
            EntryKey,                                  // EntryKey
            "ProviderId",                              // EntryName
            (PVOID) & (carrier),                       // Data
            sizeof(GUID),                              // MaxBytes
            REG_BINARY                                 // TypeFlag
            );
    } else {
        carrier.len = sizeof(GUID);
        carrier.buf = (char*) &m_providerId;
        io_result = WriteRegistryEntry(
            EntryKey,                                     // EntryKey
            "ProviderId",                                 // EntryName
            (PVOID) & (carrier),                          // Data
            REG_BINARY                                    // TypeFlag
            );
    }
    if (! io_result) {
        DEBUGF(
            DBG_ERR,
            ("%s registry entry\n",
            IsRead ? "Reading" : "Writing"));
        return WSANO_RECOVERY;
    }


    // DWORD m_address_family;
    if (IsRead) {
        io_result = ReadRegistryEntry(
            EntryKey,                                     // EntryKey
            "AddressFamily",                              // EntryName
            (PVOID) & (m_address_family),                 // Data
            sizeof(DWORD),                                // MaxBytes
            REG_DWORD                                     // TypeFlag
            );
        if(!io_result)
        {
            //
            // since this key may not exist, treat an error
            // as an acceptable case and simply store the
            // default value.
            //
            m_address_family = -1;
            io_result = TRUE;
        }
    } else {
       //
       // only do this if a value has been set
       //
       if(m_address_family != -1)
       {
           io_result = WriteRegistryEntry(
                EntryKey,                                     // EntryKey
                "AddressFamily",                              // EntryName
                (PVOID) & (m_address_family),                 // Data
                REG_DWORD                                     // TypeFlag
                );
        }
        else
        {
           io_result = TRUE;
        }
    }
    if (! io_result) {
        DEBUGF(
            DBG_ERR,
            ("%s registry entry\n",
            IsRead ? "Reading" : "Writing"));
        return WSANO_RECOVERY;
    }

    // DWORD m_namespace_id;
    if (IsRead) {
        io_result = ReadRegistryEntry(
            EntryKey,                                     // EntryKey
            "SupportedNameSpace",                         // EntryName
            (PVOID) & (m_namespace_id),                   // Data
            sizeof(DWORD),                                // MaxBytes
            REG_DWORD                                     // TypeFlag
            );
    } else {
       io_result = WriteRegistryEntry(
            EntryKey,                                     // EntryKey
            "SupportedNameSpace",                         // EntryName
            (PVOID) & (m_namespace_id),                   // Data
            REG_DWORD                                     // TypeFlag
            );
    }
    if (! io_result) {
        DEBUGF(
            DBG_ERR,
            ("%s registry entry\n",
            IsRead ? "Reading" : "Writing"));
        return WSANO_RECOVERY;
    }

    // BOOLEAN m_enabled;
    if (IsRead) {
        io_result = ReadRegistryEntry(
            EntryKey,                                     // EntryKey
            "Enabled",                                    // EntryName
            &val,                                         // Data
            sizeof(DWORD),                                // MaxBytes
            REG_DWORD                                     // TypeFlag
            );
        if (io_result)
            m_enabled = (val!=0);
    } else {
       val = m_enabled ? 1 : 0;
       io_result = WriteRegistryEntry(
            EntryKey,                                     // EntryKey
            "Enabled",                                    // EntryName
            &val,                                         // Data
            REG_DWORD                                     // TypeFlag
            );
    }
    if (! io_result) {
        DEBUGF(
            DBG_ERR,
            ("%s registry entry\n",
            IsRead ? "Reading" : "Writing"));
        return WSANO_RECOVERY;
    }

        // DWORD m_version;
    if (IsRead) {
        io_result = ReadRegistryEntry(
            EntryKey,                                     // EntryKey
            "Version",                                    // EntryName
            (PVOID) & (m_version),                        // Data
            sizeof(DWORD),                                // MaxBytes
            REG_DWORD                                     // TypeFlag
            );
    } else {
       io_result = WriteRegistryEntry(
            EntryKey,                                     // EntryKey
            "Version",                                    // EntryName
            (PVOID) & (m_version),                        // Data
            REG_DWORD                                     // TypeFlag
            );
    }
    if (! io_result) {
        DEBUGF(
            DBG_ERR,
            ("%s registry entry\n",
            IsRead ? "Reading" : "Rriting"));
        return WSANO_RECOVERY;
    }

    // BOOLEAN m_stores_service_class_info;
    if (IsRead) {
        io_result = ReadRegistryEntry(
            EntryKey,                                     // EntryKey
            "StoresServiceClassInfo",                     // EntryName
            &val,                                         // Data
            sizeof(DWORD),                                // MaxBytes
            REG_DWORD                                     // TypeFlag
            );
        if (io_result)
            m_stores_service_class_info = (val!=0);
    } else {
       val = m_stores_service_class_info ? 1 : 0;
       io_result = WriteRegistryEntry(
            EntryKey,                                     // EntryKey
            "StoresServiceClassInfo",                     // EntryName
            &val,                                         // Data
            REG_DWORD                                     // TypeFlag
            );
    }
    if (! io_result) {
        DEBUGF(
            DBG_ERR,
            ("%s registry entry\n",
            IsRead ? "Reading" : "Writing"));
        return WSANO_RECOVERY;
    }

    return(ERROR_SUCCESS);
}  // IoRegistry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\nscatalo.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    nscatalo.cpp

Abstract:

    This module contains the implementation of the dcatalog class.

Author:

    Dirk Brandewie dirk@mink.intel.com  25-JUL-1995

Revision History:

    23-Aug-1995 dirk@mink.intel.com
        Moved includes into precomp.h.

--*/

#include "precomp.h"

#define CATALOG_NAME            "NameSpace_Catalog5"
#ifdef _WIN64
#define CATALOG_ENTRIES_NAME    "Catalog_Entries64"
#define NUM_ENTRIES_NAME        "Num_Catalog_Entries64"

#define CATALOG_ENTRIES_NAME32  "Catalog_Entries"
#define NUM_ENTRIES_NAME32      "Num_Catalog_Entries"
#else
#define CATALOG_ENTRIES_NAME    "Catalog_Entries"
#define NUM_ENTRIES_NAME        "Num_Catalog_Entries"
#endif

#define FIRST_SERIAL_NUMBER 1
    // The first access serial number to be assigned on a given system.


NSCATALOG::NSCATALOG()
/*++

Routine Description:

    Constructor for the NSCATALOG object

Arguments:

    NONE

Return Value:

    NONE

--*/
{
    // Initialize members
    m_num_items = 0;
    m_reg_key = NULL;
    m_serial_num = FIRST_SERIAL_NUMBER-1;
    m_namespace_list.Flink = NULL;
    m_classinfo_provider = NULL;
#ifdef _WIN64
    m_entries32 = FALSE;
#endif
}




BOOL
NSCATALOG::OpenCatalog(
    IN  HKEY   ParentKey
    )
/*++

Routine Description:

    This  procedure  opens the catalog portion of the registry.  If the catalog
    is  not  yet  present,  it  also  initializes  new  first-level  values and
    first-level  subkeys  for  the  catalog.  It is assumed that the catalog is
    locked against competing registry I/O attempts.

Arguments:

    ParentKey  - Supplies  the open registry key representing the parent key of
                 the catalog.


Return Value:

    The function returns TRUE if successful, otherwise it returns FALSE.

--*/
{
    LONG   lresult;
    HKEY   new_key;
    DWORD  key_disposition;

    assert(ParentKey != NULL);

    __try {
        InitializeCriticalSection(&m_nscatalog_lock);
    }
    __except (WS2_EXCEPTION_FILTER ()) {
        return FALSE;
    }
    InitializeListHead(&m_namespace_list);

    //
    // We must first try to open the key before trying to create it.
    // RegCreateKeyEx() will fail with ERROR_ACCESS_DENIED if the current
    // user has insufficient privilege to create the target registry key,
    // even if that key already exists.
    //

    lresult = RegOpenKeyEx(
        ParentKey,                              // hkey
        NSCATALOG::GetCurrentCatalogName(),     // lpszSubKey
        0,                                      // dwReserved
        MAXIMUM_ALLOWED,                        // samDesired
        & new_key                               // phkResult
        );

    if( lresult == ERROR_SUCCESS ) {
        key_disposition = REG_OPENED_EXISTING_KEY;
    } else if( lresult != ERROR_FILE_NOT_FOUND  ||
            (lresult = RegCreateKeyEx(
                ParentKey,                          // hkey
                NSCATALOG::GetCurrentCatalogName(), // lpszSubKey
                0,                                  // dwReserved
                NULL,                               // lpszClass
                REG_OPTION_NON_VOLATILE,            // fdwOptions
                KEY_READ|KEY_WRITE,                 // samDesired
                NULL,                               // lpSecurityAttributes
                & new_key,                          // phkResult
                & key_disposition                   // lpdwDisposition
                ))!=ERROR_SUCCESS) {
        return FALSE;
    }

    TRY_START(guard_open) {
        BOOL	bresult;
        DWORD	dwData;
        if (key_disposition == REG_CREATED_NEW_KEY) {
            HKEY	entries_key;
            DWORD	dont_care;

            DEBUGF(
                DBG_TRACE,
                ("Creating empty ns catalog in registry\n"));


            dwData = 0;
            bresult = WriteRegistryEntry(
                new_key,           // EntryKey
                NUM_ENTRIES_NAME,  // EntryName
                (PVOID) & dwData,  // Data
                REG_DWORD          // TypeFlag
                );
            if (! bresult) {
                DEBUGF(
                    DBG_ERR,
                    ("Writing %s\n", NUM_ENTRIES_NAME));
                TRY_THROW(guard_open);
            }

#ifdef _WIN64
            bresult = WriteRegistryEntry(
                new_key,           // EntryKey
                NUM_ENTRIES_NAME32,// EntryName
                (PVOID) & dwData,  // Data
                REG_DWORD          // TypeFlag
                );
            if (! bresult) {
                DEBUGF(
                    DBG_ERR,
                    ("Writing %s\n", NUM_ENTRIES_NAME32));
                TRY_THROW(guard_open);
            }
#endif

            dwData = FIRST_SERIAL_NUMBER;
            bresult = WriteRegistryEntry(
                new_key,                  // EntryKey
                SERIAL_NUMBER_NAME,       // EntryName
                (PVOID) & dwData,         // Data
                REG_DWORD                 // TypeFlag
                );
            if (! bresult) {
                DEBUGF(
                    DBG_ERR,
                    ("Writing %s\n",
                    SERIAL_NUMBER_NAME));
                TRY_THROW(guard_open);
            }

            lresult = RegCreateKeyEx(
                new_key,                  // hkey
                CATALOG_ENTRIES_NAME,     // lpszSubKey
                0,                        // dwReserved
                NULL,                     // lpszClass
                REG_OPTION_NON_VOLATILE,  // fdwOptions
                KEY_READ|KEY_WRITE,       // samDesired
                NULL,                     // lpSecurityAttributes
                & entries_key,            // phkResult
                & dont_care               // lpdwDisposition
                );
            if (lresult != ERROR_SUCCESS) {
                DEBUGF(
                    DBG_ERR,
                    ("Creating entries subkey %s\n",
                    CATALOG_ENTRIES_NAME));
                TRY_THROW(guard_open);
            }
            lresult = RegCloseKey(
                entries_key  // hkey
                );
            if (lresult != ERROR_SUCCESS) {
                DEBUGF(
                    DBG_ERR,
                    ("Closing entries subkey\n"));
                TRY_THROW(guard_open);
            }

#ifdef _WIN64
            lresult = RegCreateKeyEx(
                new_key,                  // hkey
                CATALOG_ENTRIES_NAME32,   // lpszSubKey
                0,                        // dwReserved
                NULL,                     // lpszClass
                REG_OPTION_NON_VOLATILE,  // fdwOptions
                KEY_READ|KEY_WRITE,       // samDesired
                NULL,                     // lpSecurityAttributes
                & entries_key,            // phkResult
                & dont_care               // lpdwDisposition
                );
            if (lresult != ERROR_SUCCESS) {
                DEBUGF(
                    DBG_ERR,
                    ("Creating entries subkey %s\n",
                    CATALOG_ENTRIES_NAME32));
                TRY_THROW(guard_open);
            }
            lresult = RegCloseKey(
                entries_key  // hkey
                );
            if (lresult != ERROR_SUCCESS) {
                DEBUGF(
                    DBG_ERR,
                    ("Closing %s subkey\n", CATALOG_ENTRIES_NAME32));
                TRY_THROW(guard_open);
            }
#endif

        }  // if REG_CREATED_NEW_KEY
        else {
            bresult = ReadRegistryEntry (
                        new_key,                // EntryKey
                        SERIAL_NUMBER_NAME,     // EntryName
                        (PVOID) &dwData,		// Data
                        sizeof (DWORD),         // MaxBytes
                        REG_DWORD               // TypeFlag
                        );
            if (!bresult) {
                // This must be the first time this version of ws2_32.dll
                // is being run.  We need to update catalog to have this
                // new entry or fail initialization.
            
			    dwData = FIRST_SERIAL_NUMBER;
                bresult = WriteRegistryEntry (
                            new_key,                // EntryKey
                            SERIAL_NUMBER_NAME,     // EntryName
                            (PVOID) &dwData,		// Data
                            REG_DWORD               // TypeFlag
                            );
                if (!bresult) {
                    DEBUGF (DBG_ERR,
                        ("Writing %s value.\n", SERIAL_NUMBER_NAME));
				    TRY_THROW (guard_open);
			    }
            }
        } // else

		m_reg_key = new_key;
		return TRUE;

    } TRY_CATCH(guard_open) {
        LONG close_result;

        close_result = RegCloseKey(
            new_key  // hkey
            );
        if (close_result != ERROR_SUCCESS) {
            DEBUGF(
                DBG_ERR,
                ("Closing catalog key\n"));
        }

        return FALSE;
    } TRY_END(guard_open);

}  // OpenCatalog




INT
NSCATALOG::InitializeFromRegistry(
    IN  HKEY    ParentKey,
    IN  HANDLE  ChangeEvent OPTIONAL
    )
/*++

Routine Description:

    This  procedure takes care of initializing a newly-created name space catalog
    from  the  registry.  If the registry does not currently contain a name space
    catalog,  an  empty catalog is created and the registry is initialized with
    the new empty catalog.

Arguments:

    ParentKey - Supplies  an  open registry key under which the catalog is read
                or  created  as  a  subkey.   The  key may be closed after this
                procedure returns.

Return Value:

    The  function  returns  ERROR_SUCESS if successful, otherwise it returns an
    appropriate WinSock error code.

Implementation Notes:

    lock the catalog
    open catalog, creating empty if required
    read the catalog
    unlock the catalog
--*/
{
    INT return_value;
    BOOL bresult;


    assert(ParentKey != NULL);
    assert(m_reg_key==NULL);

    bresult = OpenCatalog(
        ParentKey
        );
    // Opening  the catalog has the side-effect of creating an empty catalog if
    // needed.
    if (bresult) {
        return_value =  RefreshFromRegistry (ChangeEvent);
    }
    else {
        return_value = WSASYSCALLFAILURE;
    }
    return return_value;

}  // InitializeFromRegistry


#ifdef _WIN64
INT
NSCATALOG::InitializeFromRegistry32(
    IN  HKEY    ParentKey
    )
/*++

Routine Description:

    This  procedure takes care of initializing a newly-created name space catalog
    from  the  registry.  If the registry does not currently contain a name space
    catalog,  an  empty catalog is created and the registry is initialized with
    the new empty catalog.

Arguments:

    ParentKey - Supplies  an  open registry key under which the catalog is read
                or  created  as  a  subkey.   The  key may be closed after this
                procedure returns.

Return Value:

    The  function  returns  ERROR_SUCESS if successful, otherwise it returns an
    appropriate WinSock error code.

Implementation Notes:

    lock the catalog
    open catalog, creating empty if required
    read the catalog
    unlock the catalog
--*/
{
    INT return_value;
    BOOL bresult;


    assert(ParentKey != NULL);
    assert(m_reg_key==NULL);
    assert(m_entries32==FALSE);

    m_entries32 = TRUE;

    bresult = OpenCatalog(
        ParentKey
        );
    // Opening  the catalog has the side-effect of creating an empty catalog if
    // needed.
    if (bresult) {
        return_value =  RefreshFromRegistry (NULL);
    }
    else {
        return_value = WSASYSCALLFAILURE;
    }
    return return_value;

}  // InitializeFromRegistry32
#endif



INT
NSCATALOG::RefreshFromRegistry(
    IN  HANDLE  ChangeEvent OPTIONAL
    )
/*++

Routine Description:

    This  procedure takes care of initializing a newly-created name space catalog
    from  the  registry.  If the registry does not currently contain a protocol
    catalog,  an  empty catalog is created and the registry is initialized with
    the new empty catalog.

Arguments:

    ParentKey - Supplies  an  open registry key under which the catalog is read
                or  created  as  a  subkey.   The  key may be closed after this
                procedure returns.

Return Value:

    The  function  returns  ERROR_SUCESS if successful, otherwise it returns an
    appropriate WinSock error code.

Implementation Notes:

    lock the catalog
    do
		establish event notification for any registry catalog modifications
		RegOpenKey(... entries, entries_key)
		ReadRegistryEntry(... next_id)
		ReadRegistryEntry(... num_items)
		for i in (1 .. num_items)
			item = new catalog item
			item->InitializeFromRegistry(entries_key, i)
			add item to temp list
		end for
		RegCloseKey(... entries_key)
    while registry catalog has changed during read.
    update the catalog
    unlock the catalog

--*/
{
    INT			return_value;
    BOOLEAN		created_event = FALSE;
    DWORD       serial_num;
	LONG        lresult;
	HKEY        entries_key;
	LIST_ENTRY  temp_list;
	PNSCATALOGENTRY  item;
	DWORD       num_entries;
    BOOL        catalog_changed;
	BOOL                 bresult;
#ifdef _WIN64
    BOOLEAN     saveCatalog64 = FALSE;
#endif

    //
    // Create the event if caller did not provide one
    //
    if (ChangeEvent==NULL) {
        ChangeEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
        if (ChangeEvent==NULL) {
            return WSASYSCALLFAILURE;
        }
        created_event = TRUE;
    }

    // Lock this catalog object
    AcquireCatalogLock ();

    assert(m_reg_key != NULL);

	// Initialize locals to known defaults
	item = NULL;
	InitializeListHead (&temp_list);

    do {
        // Synchronize with writers
        return_value = SynchronizeSharedCatalogAccess (
								m_reg_key,
								ChangeEvent,
								&serial_num);
        if (return_value != ERROR_SUCCESS) {
            // Non-recoverable;
            break;
        }

        // Check if catalog has changed.
        if (m_serial_num == serial_num) {
            return_value = ERROR_SUCCESS;
            break;
        }

		// read number of items in the catalog
		bresult = ReadRegistryEntry(
			m_reg_key,              // EntryKey
#ifdef _WIN64
            m_entries32
                ? NUM_ENTRIES_NAME32 :
#endif
			NUM_ENTRIES_NAME,       // EntryName
			(PVOID) & num_entries,  // Data
			sizeof(DWORD),          // MaxBytes
			REG_DWORD               // TypeFlag
			);

#ifdef _WIN64
        if (! bresult  && !m_entries32) {
            //
            // We may be upgrading 64 bit installation with
            // only one catalog (prior to catalog separation
            // being implemented on WIN64).
            // Read 32 bit catalog instead and remeber to save
            // it as 64 bit catalog.
            //
            saveCatalog64 = TRUE;
			DEBUGF(
				DBG_ERR,
				("Reading %s from registry, trying %s...\n",
				NUM_ENTRIES_NAME, NUM_ENTRIES_NAME32));
		    bresult = ReadRegistryEntry(
			    m_reg_key,              // EntryKey
			    NUM_ENTRIES_NAME32,     // EntryName
			    (PVOID) & num_entries,  // Data
			    sizeof(DWORD),          // MaxBytes
			    REG_DWORD               // TypeFlag
			    );
        }
#endif
		if (! bresult) {
			DEBUGF(
				DBG_ERR,
				("Reading %s from registry\n",
				NUM_ENTRIES_NAME));
            return_value = WSASYSCALLFAILURE;
			break;
		}

		// Open entry key
		lresult = RegOpenKeyEx(
			m_reg_key,             // hkey
#ifdef _WIN64
            m_entries32
                ? CATALOG_ENTRIES_NAME32 :
#endif
			CATALOG_ENTRIES_NAME,  // lpszSubKey
			0,                     // dwReserved
			MAXIMUM_ALLOWED,       // samDesired
			& entries_key          // phkResult
			);

#ifdef _WIN64
        if (lresult == ERROR_FILE_NOT_FOUND && !m_entries32) {
            //
            // We may be upgrading 64 bit installation with
            // only one catalog (prior to catalog separation
            // being implemented on WIN64).
            // Read 32 bit catalog instead and remeber to save
            // it as 64 bit catalog.
            //
			DEBUGF(
				DBG_ERR,
				("Opening name space entries key of registry, trying entries32...\n"));
            saveCatalog64 = TRUE;
		    lresult = RegOpenKeyEx(
			    m_reg_key,             // hkey
			    CATALOG_ENTRIES_NAME32,// lpszSubKey
			    0,                     // dwReserved
			    MAXIMUM_ALLOWED,       // samDesired
			    & entries_key          // phkResult
			    );
        }
#endif
		if (lresult != ERROR_SUCCESS) {
            // Non-recoverable
			DEBUGF(
				DBG_ERR,
				("Opening entries key of registry\n"));
			return_value = WSASYSCALLFAILURE;
            break;
        }

		TRY_START(guard_open) {
			DWORD                seq_num;

			// read the items and place on temp list
            InitializeListHead (&temp_list);
			for (seq_num = 1; seq_num <= num_entries; seq_num++) {
				item = new NSCATALOGENTRY();
				if (item == NULL) {
					return_value = WSA_NOT_ENOUGH_MEMORY;
					DEBUGF(
						DBG_ERR,
						("Allocating new proto catalog item\n"));
					TRY_THROW(guard_open);
				}
				return_value = item->InitializeFromRegistry(
					entries_key,  // ParentKey
					(INT)seq_num  // SequenceNum
					);
				if (return_value != ERROR_SUCCESS) {
					item->Dereference ();
					DEBUGF(
						DBG_ERR,
						("Initializing new proto catalog item\n"));
					TRY_THROW(guard_open);
				}
				InsertTailList (&temp_list, &item->m_CatalogLinkage);
			}  // for seq_num

		} TRY_CATCH(guard_open) {

		    assert (return_value!=ERROR_SUCCESS);

		} TRY_END(guard_open);

		// close catalog
		lresult = RegCloseKey(
			entries_key  // hkey
			);
		if (lresult != ERROR_SUCCESS) {
			DEBUGF(
				DBG_ERR,
				("Closing entries key of registry\n"));
			// non-fatal
		}

        //
        // Check if catalog has changed while we were reading it
        // If so, we'll have to retry even though we succeeded
        // in reading it to ensure consistent view of the whole
        // catalog.
        //

        catalog_changed = HasCatalogChanged (ChangeEvent);
        
        if ((return_value==ERROR_SUCCESS) && !catalog_changed) {
            UpdateNamespaceList (&temp_list);

            // Store new catalog parameters
            assert (m_num_items == num_entries);
            m_serial_num = serial_num;
            break;
        }

        //
        // Free the entries we might have read
        //

        while (!IsListEmpty (&temp_list)) {
            PLIST_ENTRY list_member;
			list_member = RemoveHeadList (&temp_list);
			item = CONTAINING_RECORD (list_member,
										NSCATALOGENTRY,
										m_CatalogLinkage);
#if defined(DEBUG_TRACING)
            InitializeListHead (&item->m_CatalogLinkage);
#endif
			item->Dereference ();
		}
    }
    while (catalog_changed); // Retry while catalog is being written over

    //
    // We should have freed or consumed all the items we
    // might have read.
    //
    assert (IsListEmpty (&temp_list));
    
#ifdef _WIN64
    if (saveCatalog64 && return_value==ERROR_SUCCESS) {
		DEBUGF(
			DBG_ERR,
			("Duplicating 32 bit namespace catalog to 64 bit...\n"));
        WriteToRegistry ();
    }
#endif
    ReleaseCatalogLock ();

    // Close the event if we created one.
    if (created_event)
        CloseHandle (ChangeEvent);

    return return_value;

}  // RefreshFromRegistry



VOID
NSCATALOG::UpdateNamespaceList (
    PLIST_ENTRY     new_list
    ) 
/*++

Routine Description:

    This procedure carefully updates the catalog to match the one
    just read from the registry.  It takes care of moving item
    that did not change, removing itmes that no longer exists,
    adding new items, as well as establishing new item order.

Arguments:

    new_list    - list of the items just read form the registry

Return Value:

    None.

Implementation Notes:

    move all items from current catalog to old list
	for all items in new list
		if same item exist in old list
			add old item to current catalog and destroy new one
		else
			add new item to current catalog
	end for
	dereference all remaining items in the old list

--*/
{
    LIST_ENTRY      old_list;
    PNSCATALOGENTRY item;
    PLIST_ENTRY     list_member;

    // Move items from current list to old list
	InsertHeadList (&m_namespace_list, &old_list);
	RemoveEntryList (&m_namespace_list);
	InitializeListHead (&m_namespace_list);

	// for all loaded items
	while (!IsListEmpty (new_list)) {
		list_member = RemoveHeadList (new_list);
		item = CONTAINING_RECORD (list_member,
									NSCATALOGENTRY,
									m_CatalogLinkage);

		// check if the same item is in the old list
		list_member = old_list.Flink;
		while (list_member!=&old_list) {
			PNSCATALOGENTRY     old_item;
			old_item = CONTAINING_RECORD (list_member,
									NSCATALOGENTRY,
									m_CatalogLinkage);
            list_member = list_member->Flink;
			if (*(item->GetProviderId()) == *(old_item->GetProviderId())) {
				// it is, use the old one and get rid of the new
				assert (item->GetNamespaceId () == old_item->GetNamespaceId());
#if defined(DEBUG_TRACING)
                InitializeListHead (&item->m_CatalogLinkage);
#endif
				item->Dereference ();

                item = old_item;
				RemoveEntryList (&item->m_CatalogLinkage);
                m_num_items -= 1;
				break;
			}
		}
		// add item to the current list
		InsertTailList (&m_namespace_list, &item->m_CatalogLinkage);
        m_num_items += 1;
	}

	// destroy all remaining items on the old list
	while (!IsListEmpty (&old_list)) {
		list_member = RemoveHeadList (&old_list);
		item = CONTAINING_RECORD (list_member,
									NSCATALOGENTRY,
									m_CatalogLinkage);
#if defined(DEBUG_TRACING)
        InitializeListHead (&item->m_CatalogLinkage);
#endif
        m_num_items -= 1;
		item->Dereference ();
	}

}


INT
NSCATALOG::WriteToRegistry(
    )
/*++

Routine Description:

    This procedure writes the "entries" and "numentries" portion of the catalog
    out  to  the  registry.  

Arguments:

Return Value:

    If  the  function  is  successful,  it  returns ERROR_SUCCESS, otherwise it
    returns an appropriate WinSock error code.

Implementation Notes:
	lock catalog object
	acquire registry catalog lock (exclusive)
    RegCreateKeyEx(... entries, entries_key)
    RegDeleteSubkeys (... entries_key)
    while (get item from catalog)
        num_items++;
        item->WriteToRegistry(entries_key, num_items)
    end while
    RegCloseKey(... entries_key)
    WriteRegistryEntry(... num_items)
	WriteRegistryEntry(... nex_id)
	release registry catalog
	unlock catalog object
--*/
{
    LONG lresult;
    HKEY access_key, entries_key;
    DWORD dont_care;
    INT return_value;
    BOOL bresult;

	// lock the catalog object
    AcquireCatalogLock ();
    assert (m_reg_key!=NULL);
    assert (m_serial_num!=0);

	// Get exclusive access to the registry
	// This also verifies that registry has not change since
	// it was last read
    return_value = AcquireExclusiveCatalogAccess (
							m_reg_key,
							m_serial_num,
							&access_key);
    if (return_value == ERROR_SUCCESS) {
		// Create or open existing entries key
        lresult = RegCreateKeyEx(
            m_reg_key,                // hkey
#ifdef _WIN64
            m_entries32
                ? CATALOG_ENTRIES_NAME32 :
#endif
            CATALOG_ENTRIES_NAME,     // lpszSubKey
            0,                        // dwReserved
            NULL,                     // lpszClass
            REG_OPTION_NON_VOLATILE,  // fdwOptions
            KEY_READ|KEY_WRITE,       // samDesired
            NULL,                     // lpSecurityAttributes
            & entries_key,            // phkResult
            & dont_care               // lpdwDisposition
            );
        if (lresult == ERROR_SUCCESS) {
            TRY_START(any_failure) {
                PLIST_ENTRY          ListMember;
                PNSCATALOGENTRY     item;
                DWORD               num_items = 0;

                lresult = RegDeleteSubkeys (entries_key);

				// Write catalog items to registry
                ListMember = m_namespace_list.Flink;
                while (ListMember != & m_namespace_list) {
                    item = CONTAINING_RECORD(
                        ListMember,
                        NSCATALOGENTRY,
                        m_CatalogLinkage);
                    ListMember = ListMember->Flink;
                    num_items += 1;
                    return_value = item->WriteToRegistry(
                        entries_key,  // ParentKey
                        num_items     // SequenceNum
                        );
                    if (return_value != ERROR_SUCCESS) {
                        DEBUGF(
                            DBG_ERR,
                            ("Writing item (%lu) to registry\n",
                            num_items));
                        TRY_THROW(any_write_failure);
                    }
                }  // while get item

                assert (m_num_items == num_items);
				// Write number of items
                bresult = WriteRegistryEntry(
                    m_reg_key,             // EntryKey
#ifdef _WIN64
                    m_entries32
                        ? NUM_ENTRIES_NAME32 :
#endif
                    NUM_ENTRIES_NAME,     // EntryName
                    (PVOID) & m_num_items,// Data
                    REG_DWORD             // TypeFlag
                    );
                if (! bresult) {
                    DEBUGF(
                        DBG_ERR,
                        ("Writing %s value\n",
                        NUM_ENTRIES_NAME));
                    return_value = WSASYSCALLFAILURE;
                    TRY_THROW(any_write_failure);
                }

            } TRY_CATCH(any_write_failure) {
                if (return_value == ERROR_SUCCESS) {
                    return_value = WSASYSCALLFAILURE;
                }
            } TRY_END(any_write_failure);

			// Close entries key
            lresult = RegCloseKey(
                entries_key  // hkey
                );
            if (lresult != ERROR_SUCCESS) {
                DEBUGF(
                    DBG_ERR,
                    ("Closing entries key of registry\n"));
				// Non-fatal
            }
        }

		// Release registry
        ReleaseExclusiveCatalogAccess (
							m_reg_key,
							m_serial_num, 
							access_key);
    }

	// Unlock catalog object
	ReleaseCatalogLock();
    return return_value;

}  // WriteToRegistry


NSCATALOG::~NSCATALOG()
/*++

Routine Description:

    This  function  destroys the catalog object.  It takes care of removing and
    dereferencing  all  of  the  catalog  entries  in  the catalog.  This includes
    dereferencing  all  of the NSPROVIDER objects referenced by the catalog. 

Arguments:

    None

Return Value:

    None

Implementation Notes:

    lock the catalog
    for each catalog entry
        remove the entry
        dereference the entry
    end for
    close registry key
    unlock the catalog
    delete catalog lock
--*/
{
    PLIST_ENTRY  this_linkage;
    PNSCATALOGENTRY  this_item;
    LONG        lresult;

    DEBUGF(
        DBG_TRACE,
        ("Catalog destructor\n"));

    //
    // Check if we were fully initialized.
    //
    if (m_namespace_list.Flink==NULL) {
        return;
    }
    AcquireCatalogLock();
    while ((this_linkage = m_namespace_list.Flink) != & m_namespace_list) {
        this_item = CONTAINING_RECORD(
            this_linkage,        // address
            NSCATALOGENTRY,      // type
            m_CatalogLinkage     // field
            );
        RemoveCatalogItem(
            this_item  // CatalogItem
            );
        this_item->Dereference ();
    }  // while (get entry linkage)

    if (m_reg_key!=NULL) {
        lresult = RegCloseKey (m_reg_key);
        if (lresult != ERROR_SUCCESS) {
            DEBUGF (DBG_ERR,
                ("Closing catalog registry key, err: %ld.\n", lresult));
        }
        m_reg_key = NULL;
    }
    ReleaseCatalogLock();
    DeleteCriticalSection(&m_nscatalog_lock);
}  // ~NSCATALOG




VOID
NSCATALOG::EnumerateCatalogItems(
    IN NSCATALOGITERATION  IterationProc,
    IN PVOID               PassBack
    )
/*++

Routine Description:

    This  procedure enumerates all of the NSCATALOGENTRY structures in the
    catalog  by  calling  the indicated iteration procedure once for each item.
    The called procedure can stop the iteration early by returning FALSE.

    Note  that  the DPROVIDER associated with an enumerated NSCATALOGENTRY
    may  be  NULL.   To retrieve NSCATALOGENTRY structure that has had its
    DPROVIDER      loaded      and      initialized,      you      can      use
    GetCatalogItemFromCatalogEntryId.

Arguments:

    IterationProc - Supplies   a  reference  to  the  catalog  iteration
                    procedure supplied by the client.

    PassBack  - Supplies  a  value uninterpreted by this procedure.  This value
                is  passed  unmodified to the catalog iteration procedure.  The
                client can use this value to carry context between the original
                call site and the iteration procedure.

Return Value:

    None
--*/
{
    PLIST_ENTRY         ListMember;
    PNSCATALOGENTRY CatalogEntry;
    BOOL                enumerate_more;

    assert(IterationProc != NULL);

    enumerate_more = TRUE;

    AcquireCatalogLock ();

    ListMember = m_namespace_list.Flink;

    while (enumerate_more && (ListMember != & m_namespace_list)) {
        CatalogEntry = CONTAINING_RECORD(
            ListMember,
            NSCATALOGENTRY,
            m_CatalogLinkage);
        ListMember = ListMember->Flink;
        enumerate_more = (* IterationProc) (
            PassBack,     // PassBack
            CatalogEntry  // CatalogEntry
            );
    } //while

    ReleaseCatalogLock ();
}  // EnumerateCatalogItems




INT
NSCATALOG::GetCountedCatalogItemFromNameSpaceId(
    IN  DWORD NamespaceId,
    OUT PNSCATALOGENTRY FAR * CatalogItem
    )
/*++

Routine Description:

    Chooses  a  reference  to  a  suitable  catalog  item  given a provider ID.
    structure.   Note  that  any  one  of  multiple  catalog items for the same
    provider ID may be chosen.

    The operation takes care of creating, initializing, and setting a
    NSPROVIDER object  for the retrieved catalog item if necessary.  

Arguments:

    ProviderId  - Supplies  the  identification  of a provider to search for in
                  the catalog.

    CatalogItem - Returns  the reference to the chosen catalog item, or NULL if
                  no suitable entry was found.

Return Value:

    The  function  returns  ERROR_SUCESS if successful, otherwise it returns an
    appropriate WinSock error code.
--*/
{
    PLIST_ENTRY         ListMember;
    INT                 ReturnCode;
    PNSCATALOGENTRY     CatalogEntry;

    assert(CatalogItem != NULL);

    // Prepare for early error return
    * CatalogItem = NULL;
    ReturnCode = WSAEINVAL;

    AcquireCatalogLock();
    ListMember = m_namespace_list.Flink;

    while (ListMember != & m_namespace_list) {
        CatalogEntry = CONTAINING_RECORD(
            ListMember,
            NSCATALOGENTRY,
            m_CatalogLinkage);
        ListMember = ListMember->Flink;
        if (CatalogEntry->GetNamespaceId() == NamespaceId) {
            if (CatalogEntry->GetProvider() == NULL) {
                ReturnCode = LoadProvider(
                    CatalogEntry    // CatalogEntry
                    );
                if (ReturnCode != ERROR_SUCCESS) {
                    break;
                }
            }  // if provider is NULL
            CatalogEntry->Reference ();
            * CatalogItem = CatalogEntry;
            ReturnCode = ERROR_SUCCESS;
            break;
        } //if
    } //while

    ReleaseCatalogLock();
    return(ReturnCode);
}



INT
NSCATALOG::GetCountedCatalogItemFromProviderId(
    IN  LPGUID                ProviderId,
    OUT PNSCATALOGENTRY FAR * CatalogItem
    )
/*++

Routine Description:

    Chooses  a  reference  to  a  suitable  catalog  item  given a provider ID.
    structure.

Arguments:

    ProviderId  - Supplies  the  identification  of a provider to search for in
                  the catalog.

    CatalogItem - Returns  the reference to the chosen catalog item, or NULL if
                  no suitable entry was found.

Return Value:

    The  function  returns  ERROR_SUCESS if successful, otherwise it returns an
    appropriate WinSock error code.
--*/
{
    PLIST_ENTRY         ListMember;
    INT                 ReturnCode;
    PNSCATALOGENTRY      CatalogEntry;

    assert(CatalogItem != NULL);

    // Prepare for early error return
    *CatalogItem = NULL;
    ReturnCode = WSAEINVAL;

    AcquireCatalogLock();

    ListMember = m_namespace_list.Flink;

    while (ListMember != & m_namespace_list) {
        CatalogEntry = CONTAINING_RECORD(
            ListMember,
            NSCATALOGENTRY,
            m_CatalogLinkage);
        ListMember = ListMember->Flink;

        if ( *(CatalogEntry->GetProviderId()) == *ProviderId) {
            if (CatalogEntry->GetProvider() == NULL) {
                ReturnCode = LoadProvider(
                    CatalogEntry    // CatalogEntry
                    );
                if (ReturnCode != ERROR_SUCCESS) {
                    break;
                }
            }  // if provider is NULL
            CatalogEntry->Reference ();
            * CatalogItem = CatalogEntry;
            ReturnCode = ERROR_SUCCESS;
            break;
        } //if
    } //while

    ReleaseCatalogLock();

    return(ReturnCode);
}


VOID
NSCATALOG::AppendCatalogItem(
    IN  PNSCATALOGENTRY  CatalogItem
    )
/*++

Routine Description:

    This procedure appends a catalog item to the end of the (in-memory) catalog
    object.   It becomes the last item in the catalog.  The catalog information
    in the registry is NOT updated.

 Arguments:

    CatalogItem - Supplies a reference to the catalog item to be added.

Return Value:

    None
--*/
{
    assert(CatalogItem != NULL);
    assert(IsListEmpty (&CatalogItem->m_CatalogLinkage));
    InsertTailList(
        & m_namespace_list,               // ListHead
        & CatalogItem->m_CatalogLinkage  // Entry
        );
    m_num_items ++;
}  // AppendCatalogItem




VOID
NSCATALOG::RemoveCatalogItem(
    IN  PNSCATALOGENTRY  CatalogItem
    )
/*++

Routine Description:

    This  procedure removes a catalog item from the (in-memory) catalog object.
    The catalog information in the registry is NOT updated.

Arguments:

    CatalogItem - Supplies a reference to the catalog item to be removed.

Return Value:

    None
--*/
{
    assert(CatalogItem != NULL);
    assert (!IsListEmpty (&CatalogItem->m_CatalogLinkage));

    RemoveEntryList(
        & CatalogItem->m_CatalogLinkage  // Entry
        );
#if defined(DEBUG_TRACING)
    InitializeListHead (&CatalogItem->m_CatalogLinkage);
#endif
    assert(m_num_items > 0);
    m_num_items--;

}  // RemoveCatalogItem




INT WSAAPI
NSCATALOG::GetServiceClassInfo(
    IN OUT  LPDWORD                 lpdwBufSize,
    IN OUT  LPWSASERVICECLASSINFOW  lpServiceClassInfo
    )
/*++

Routine Description:

    Returns the service class info for the service class specified in
    lpServiceClassInfo from the current service clas info enabled namespace
    provider.

Arguments:

    lpdwBufSize - A pointer to the size of the buffer pointed to by
                  lpServiceClassInfo.

    lpServiceClassInfo - A pointer to a service class info struct

Return Value:

    ERROR_SUCCESS on success, Otherwise SOCKET_ERROR.  If the buffer passed in
    is to small to hold the service class info struct, *lpdwBufSize is updated
    to reflect the required buffer size to hole the class info and an error
    value of WSAEINVAL is set with SetLastError().

--*/
{
    SetLastError(ERROR_SUCCESS);
    return(SOCKET_ERROR);
    // This stubbed out until the model for how we find the service class
    // infomation is to be found.
    UNREFERENCED_PARAMETER(lpdwBufSize);
    UNREFERENCED_PARAMETER(lpServiceClassInfo);

#if 0
    INT ReturnCode;
    BOOL ValidAnswer = FALSE;
    DWORD BufSize;
    PNSPROVIDER Provider;


    // Save off the buffer size incase we need it later
    BufSize = *lpdwBufSize;

    if (!m_classinfo_provider){
        m_classinfo_provider = GetClassInfoProvider(
            BufSize,
            lpServiceClassInfo);
        if (!m_classinfo_provider){
            SetLastError(WSAEFAULT);
            return(SOCKET_ERROR);
        } //if
    } //if
    // Call the current classinfo provider.
    ReturnCode = m_classinfo_provider->NSPGetServiceClassInfo(
        lpdwBufSize,
        lpServiceClassInfo
        );

    if (ERROR_SUCCESS == ReturnCode){
        ValidAnswer = TRUE;
    } //if

    if (!ValidAnswer){
        // The name space provider we where using failed to find the class info
        // go find a provider that can answer the question
        ReturnCode = SOCKET_ERROR;
        Provider = GetClassInfoProvider(
            BufSize,
            lpServiceClassInfo);
        if (Provider){
            //We found a provider that can service the request so use this
            //provider until it fails
            m_classinfo_provider = Provider;

            // Now retry the call
             ReturnCode = m_classinfo_provider->NSPGetServiceClassInfo(
                 lpdwBufSize,
                 lpServiceClassInfo
                 );
        } //if
    } //if
    return(ReturnCode);
#endif
}

PNSPROVIDER
NSCATALOG::GetClassInfoProvider(
    IN  DWORD BufSize,
    IN  LPWSASERVICECLASSINFOW  lpServiceClassInfo
    )
/*++

Routine Description:

    Searches for a name space provider to satisfy get service class info
    request

Arguments:

    lpdwBufSize - A pointer to the size of the buffer pointed to by
                  lpServiceClassInfo.

    lpServiceClassInfo - A pointer to a service class info struct

Return Value:

    A pointer to a provider that can satisfy the query or NULL

--*/
{
    UNREFERENCED_PARAMETER(BufSize);
    UNREFERENCED_PARAMETER(lpServiceClassInfo);

    return(NULL);

#if 0
    PLIST_ENTRY ListEntry;
    PNSPROVIDER Provider=NULL;
    PNSCATALOGENTRY CatalogEntry;
    INT ReturnCode;


    ListEntry = m_namespace_list.Flink;

    while (ListEntry != &m_namespace_list){
        CatalogEntry = CONTAINING_RECORD(ListEntry,
                                         NSCATALOGENTRY,
                                         m_CatalogLinkage);
        Provider = CatalogEntry->GetProvider();
        if (Provider &&
            CatalogEntry->GetEnabledState() &&
            CatalogEntry->StoresServiceClassInfo()){
            ReturnCode = Provider->NSPGetServiceClassInfo(
                &BufSize,
                lpServiceClassInfo
                 );
            if (ERROR_SUCCESS == ReturnCode){
                break;
            } //if
        } //if
        Provider = NULL;
        ListEntry = ListEntry->Flink;
    } //while
    return(Provider);
#endif //0
}

INT
NSCATALOG::LoadProvider(
    IN PNSCATALOGENTRY CatalogEntry
    )
/*++

Routine Description:

    Load   the   provider  described  by  CatalogEntry and set it into
    catalog entry

Arguments:

    CatalogEntry - Supplies  a reference to a name sapce catalog entry describing
                   the provider to load.


Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it returns an
    appropriate WinSock error code.
--*/
{
    INT ReturnCode = ERROR_SUCCESS;
    PNSPROVIDER LocalProvider;

    // Serialize provider loading/unloading
    AcquireCatalogLock ();

    // Check if provider is loaded under the lock
    if (CatalogEntry->GetProvider ()==NULL) {

        LocalProvider = new NSPROVIDER;
        if (LocalProvider!=NULL){
            ReturnCode = LocalProvider->Initialize(
                CatalogEntry->GetLibraryPath (),
                CatalogEntry->GetProviderId ()
                );
            if (ERROR_SUCCESS == ReturnCode){
                CatalogEntry->SetProvider (LocalProvider);
            }
            LocalProvider->Dereference ();

        } //if
        else {
            DEBUGF(
                DBG_ERR,
                ("Allocating a NSPROVIDER object\n"));
            ReturnCode = WSA_NOT_ENOUGH_MEMORY;
        }
    } // if provider not loaded

    // Serialize provider loading/unloading
    ReleaseCatalogLock ();
    return ReturnCode;
}


LPSTR
NSCATALOG::GetCurrentCatalogName()
{
    return CATALOG_NAME;

} // GetCurrentCatalogName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\nspinstl.cpp ===
/*++

    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.

Module Name:

    nspinstl.cpp

Abstract:

    This module contains the entry points for name space provider
    installation/configuration.

Author:

    Dirk Brandewie (dirk@mink.intel.com) 04-December-1995

Notes:

    $Revision:   1.11  $

    $Modtime:   08 Mar 1996 15:46:16  $


Revision History:

    most-recent-revision-date email-name
        description

    04-Dec-1995 dirk@mink.intel.com
        Initial revision

--*/

#include "precomp.h"

// Structure used as context value for catalog enumerations
typedef struct
{
    GUID            ProviderId;
    PNSCATALOGENTRY CatalogItem;
} GUID_MATCH_CONTEXT, *PGUID_MATCH_CONTEXT;


BOOL
GuidMatcher(
    IN PVOID             PassBack,
    IN PNSCATALOGENTRY   CatalogItem
    )
#ifndef _WIN64_32
/*++

Routine Description:

    Enumeration proceedure for WSC calls. Finds catalog item
    with matching provider id

Arguments:

    PassBack - A context value passed to EunerateCatalogItems. It is really a
               pointer to a GUID_MATCH_CONTEXT struct.

    CatalogItem - A pointer to a catalog item to be inspected.

Return Value:

    TRUE if the Enumeration should continue else FALSE.

--*/
{
    PGUID_MATCH_CONTEXT Context;
    BOOL                ContinueEnumeration =TRUE;

    Context = (PGUID_MATCH_CONTEXT)PassBack;

    if (Context->ProviderId == *(CatalogItem->GetProviderId ())){
        Context->CatalogItem = CatalogItem;
        ContinueEnumeration = FALSE;
    } //if

    return(ContinueEnumeration);
}
#else
;
#endif


INT WSAAPI
#ifndef _WIN64_32
WSCInstallNameSpace (
#else
WSCInstallNameSpace32 (
#endif
    IN  LPWSTR  lpszIdentifier,
    IN  LPWSTR  lpszPathName,
    IN  DWORD   dwNameSpace,
    IN  DWORD   dwVersion,
    IN  LPGUID  lpProviderId
    )
/*++

Routine Description:

    WSCInstallNameSpace() is used to install a name space provider. For
    providers that are able to support multiple names spaces, this function
    must be called once for every name space supported, and a unique provider
    ID must be supplied each time.

Arguments:

    lpszIdentifier - Display string for the provider.

    lpszPathname - Points to a path to the providers DLL image which
                   follows  the usual rules for path resolution. This path may
                   contain embedded environment strings (such as
                   %SystemRoot%). Such environment strings are expanded
                   whenever the WinSock 2 DLL needs to subsequently load
                   theprovider DLL on behalf of an application. After any
                   embedded environment strings are expanded, the WinSock 2 DLL
                   passes the resulting string into the LoadLibrary() function
                   to load the provider into memory.

    dwNameSpace - Specifies the name space supported by this provider.

    dwVersion - Specifies the version number of the provider.

    bStoresAllServiceClassInfo - Specifies that this provider supports the
                                 storage  of service class schema information
                                 for all service classes across all namespaces.
                                 The Winsock DLL will then use this provider to
                                 get all of its classinfo information rather
                                 than asking each individual provider.

    lpProviderId - A unique identifier for this provider.  This GUID should be
                   generated by UUIDGEN.EXE.

Return Value:

    The function should return NO_ERROR (0) if the routine succeeds.  It should
    return SOCKET_ERROR (-1) if the routine fails and it must set the
    appropriate error code using SetLastError().
--*/
{
    INT             ReturnCode;
    PNSCATALOG      Catalog =NULL;
    PNSCATALOGENTRY Item =NULL;
    HKEY            registry_root;

    registry_root = OpenWinSockRegistryRoot();
    if (NULL == registry_root) {
        DEBUGF(
            DBG_ERR,
            ("Opening registry root\n"));
        SetLastError(WSASYSCALLFAILURE);
        return(SOCKET_ERROR);
    }

    //
    // Check the current protocol catalog key. If it doesn't match
    // the expected value, blow away the old key and update the
    // stored value.
    //

    ValidateCurrentCatalogName(
        registry_root,
        WINSOCK_CURRENT_NAMESPACE_CATALOG_NAME,
        NSCATALOG::GetCurrentCatalogName()
        );

    TRY_START(guard_memalloc){
        GUID_MATCH_CONTEXT context;


        Catalog = new NSCATALOG;
        if (NULL == Catalog){
            ReturnCode = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(guard_memalloc);
        } //item

        Item = new NSCATALOGENTRY;
        if (NULL == Item){
            ReturnCode = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(guard_memalloc);
        } //if


        __try {
            context.ProviderId = *lpProviderId;
            ReturnCode = Item->InitializeFromValues(
                lpszPathName,
                lpszIdentifier,
                lpProviderId,
                dwNameSpace,
                dwVersion
                );
        }
        __except (WS2_EXCEPTION_FILTER()) {
            ReturnCode = WSAEFAULT;
            TRY_THROW(guard_memalloc);
        }

        if (ERROR_SUCCESS != ReturnCode){
            TRY_THROW(guard_memalloc);
        } //if

#ifndef _WIN64_32
        ReturnCode = Catalog->InitializeFromRegistry(
            registry_root,  // ParentKey
            NULL            // ChangeEvent
            );
#else
        ReturnCode = Catalog->InitializeFromRegistry32(
            registry_root
            );
#endif

        if (ERROR_SUCCESS != ReturnCode){
            TRY_THROW(guard_memalloc);
        } //if

        context.CatalogItem = NULL;
        Catalog->EnumerateCatalogItems(
            GuidMatcher,
            &context
            );

        if (context.CatalogItem != NULL){
            ReturnCode = WSAEINVAL;
            TRY_THROW(guard_memalloc);
        } //if

        Catalog->AppendCatalogItem(
            Item
            );
        Item = NULL;  // item deletion is now covered by catalog

        ReturnCode = Catalog->WriteToRegistry();
        if (ReturnCode!=ERROR_SUCCESS) {
            TRY_THROW (guard_memalloc);
        }
        delete Catalog;

    } TRY_CATCH(guard_memalloc){
        assert (ReturnCode!=ERROR_SUCCESS);

        if (Item){
            Item->Dereference ();
        } //if

        if (Catalog){
            delete Catalog;
        } //if

    } TRY_END(guard_memalloc);


    CloseWinSockRegistryRoot(registry_root);

    if (ReturnCode == ERROR_SUCCESS) {
        HANDLE hHelper;

        //
        // Alert all interested apps of change via the notification method
        //


        if (WahOpenNotificationHandleHelper( &hHelper )==ERROR_SUCCESS) {
            WahNotifyAllProcesses( hHelper );
            WahCloseNotificationHandleHelper( hHelper );
        }
        else {
            // This is non-fatal and catalog was updated anyway
        }

        return ERROR_SUCCESS;
    }
    else {
        SetLastError(ReturnCode);
        return SOCKET_ERROR;
    }
}





INT
WSAAPI
#ifndef _WIN64_32
WSCUnInstallNameSpace (
#else
WSCUnInstallNameSpace32 (
#endif
    IN  LPGUID  lpProviderId
    )
/*++

Routine Description:

    WSCUnInstallNameSpace() is used to uninstall the indicated name space
    provider.

Arguments:

    lpProviderId - The unique identifier for a provider.

Return Value:

    The function should return NO_ERROR (0) if the routine succeeds.  It should
    return SOCKET_ERROR (-1) if the routine fails and it must set the
    appropriate error code using SetLastError().
--*/
{
    INT                  ReturnCode;
    PNSCATALOG           Catalog =NULL;
    HKEY                 registry_root;

    //Open and Initialize a name space jprovider catalog
    registry_root = OpenWinSockRegistryRoot();
    if (NULL == registry_root) {
        DEBUGF(
            DBG_ERR,
            ("Opening registry root\n"));
        SetLastError(WSASYSCALLFAILURE);
        return(SOCKET_ERROR);
    }

    TRY_START(guard_memalloc){
        GUID_MATCH_CONTEXT     context;
        Catalog = new NSCATALOG;
        if (NULL == Catalog){
            ReturnCode = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(guard_memalloc);
        } //item


#ifndef _WIN64_32
        ReturnCode = Catalog->InitializeFromRegistry(
                            registry_root,  // ParentKey
                            NULL            // ChangeEvent
                            );
#else
        ReturnCode = Catalog->InitializeFromRegistry32(
                            registry_root  // ParentKey
                            );
#endif
        if (ERROR_SUCCESS != ReturnCode){
            TRY_THROW(guard_memalloc);
        } //if

        __try {
            context.ProviderId = *lpProviderId;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            ReturnCode = WSAEFAULT;
            TRY_THROW(guard_memalloc);
        }

        context.CatalogItem = NULL;
        Catalog->EnumerateCatalogItems(
            GuidMatcher,
            &context);

        if (context.CatalogItem!=NULL) {
            Catalog->RemoveCatalogItem (context.CatalogItem);
            context.CatalogItem->Dereference ();
        }
        else {
            ReturnCode = WSAEINVAL;
            TRY_THROW(guard_memalloc);
        }

        ReturnCode = Catalog->WriteToRegistry();

        if (ERROR_SUCCESS != ReturnCode){
            TRY_THROW(guard_memalloc);
        } //if

        delete Catalog;
    } TRY_CATCH(guard_memalloc){
        assert (ReturnCode!=ERROR_SUCCESS);
        if (Catalog){
            delete Catalog;
        } //if
    } TRY_END(guard_memalloc);

    CloseWinSockRegistryRoot(registry_root);

    if (ERROR_SUCCESS == ReturnCode){
        HANDLE hHelper;

        //
        // Alert all interested apps of change via the notification method
        //

        if (WahOpenNotificationHandleHelper( &hHelper) == ERROR_SUCCESS) {
            WahNotifyAllProcesses( hHelper );
            WahCloseNotificationHandleHelper( hHelper );
        }
        else {
            //
            // This in non-fatal and catalog was updated anyway.
            //
        }

        return ERROR_SUCCESS;
    } 
    else {
        SetLastError(ReturnCode);
        return SOCKET_ERROR;
    }
}




INT WSAAPI
#ifndef _WIN64_32
WSCEnableNSProvider (
#else
WSCEnableNSProvider32 (
#endif
    IN  LPGUID  lpProviderId,
    IN  BOOL    fEnable
    )
/*++

Routine Description:

    WSCEnableNSProvider() is used to change the state of a given name space
    provider.  This function is intended to be used by the control panel applet
    to change the state of the providers.  An ISV should not just blindly
    de-activate another ISV's provider in order to activate their own.  This
    choice should be left up to the user.description-of-function

Arguments:

    lpProviderId - The unique identifier for this provider.

    fEnable - If TRUE, the provider is set to the active state.  If FALSE, the
              provider is disabled and will not be available for query
              operations or service registration.

Return Value:

    The function should return NO_ERROR (0) if the routine succeeds.  It should
    return SOCKET_ERROR (-1) if the routine fails and it must set the
    appropriate error code using SetLastError().

--*/
{
    INT                  ReturnCode;
    PNSCATALOG           Catalog =NULL;
    HKEY                 registry_root;

    registry_root = OpenWinSockRegistryRoot();
    if (NULL == registry_root) {
        DEBUGF(
            DBG_ERR,
            ("Opening registry root\n"));
        SetLastError(WSASYSCALLFAILURE);
        return(SOCKET_ERROR);
    }

    TRY_START(guard_memalloc){
        GUID_MATCH_CONTEXT     context;

        Catalog = new NSCATALOG;
        if (NULL == Catalog){
            ReturnCode = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(guard_memalloc);
        } //item


#ifndef _WIN64_32
        ReturnCode = Catalog->InitializeFromRegistry(
                        registry_root,  // ParentKey
                        NULL            // ChangeEvent
                        );
#else
        ReturnCode = Catalog->InitializeFromRegistry32(
                        registry_root   // ParentKey
                        );
#endif

        if (ERROR_SUCCESS != ReturnCode){
            TRY_THROW(guard_memalloc);
        } //if

        __try {
            context.ProviderId = *lpProviderId;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            ReturnCode = WSAEFAULT;
            TRY_THROW(guard_memalloc);
        }

        context.CatalogItem = NULL;
        Catalog->EnumerateCatalogItems(
            GuidMatcher,
            &context);

        if (context.CatalogItem!=NULL) {
            context.CatalogItem->Enable (fEnable ? (BOOLEAN)TRUE : (BOOLEAN)FALSE);
        }
        else {
            ReturnCode = WSAEINVAL;
            TRY_THROW(guard_memalloc);
        }

        ReturnCode = Catalog->WriteToRegistry();
        if (ReturnCode != ERROR_SUCCESS) {
            TRY_THROW(guard_memalloc);
        }

        delete Catalog;

    } TRY_CATCH(guard_memalloc){

        assert (ReturnCode!=ERROR_SUCCESS);
        if (Catalog){
            delete Catalog;
        } //if
    } TRY_END(guard_memalloc);

    CloseWinSockRegistryRoot(registry_root);

    if (ERROR_SUCCESS == ReturnCode){
        HANDLE hHelper;

        //
        // Alert all interested apps of change via the notification method
        //

        if (WahOpenNotificationHandleHelper( &hHelper) == ERROR_SUCCESS) {
            WahNotifyAllProcesses( hHelper );
            WahCloseNotificationHandleHelper( hHelper );
        }
        else {
            //
            // This in non-fatal and catalog was updated anyway.
            //
        }

        return ERROR_SUCCESS;
    } 
    else {
        SetLastError(ReturnCode);
        return SOCKET_ERROR;
    }

}


// The  following  type is used to pass context back and forth to an enumerator
// iteration procedure when removing all items form the catalog
typedef struct {
    IN  DWORD               Count;      // Number of ids / size of item array
    IN  GUID                *ProviderIds;// Array of provider id's to match against
    OUT PNSCATALOGENTRY     *Items;     // Array of item pointers to return
    OUT INT                 ErrorCode;
} PROVIDER_SNAP_CONTEXT,  FAR * PPROVIDER_SNAP_CONTEXT;




BOOL
ProviderSnap(
    IN PVOID                PassBack,
    IN PNSCATALOGENTRY      CatalogEntry
    )
#ifndef _WIN64_32
/*++

Routine Description:
    Snaps all the catalog items in the current catalog

Arguments:

    PassBack     - Supplies  a reference to a PROVIDER_SNAP_CONTEXT structure.
                   Returns an array of items in the order specified by catalog
                   id array.

    CatalogEntry - Supplies  to  the client a reference to a PROTO_CATALOG_ITEM
                   structure with values for this item of the enumeration.  The
                   pointer  is  not guaranteed to be valid after this procedure
                   returns, so the client should copy data if required.

Return Value:

    If an item is found that could not be matched to catalog id in the array,
    the function returns FALSE to terminate the iteration,
    otherwise it returns TRUE.
--*/
{
    PPROVIDER_SNAP_CONTEXT      context;
    DWORD                       i;

    context = (PPROVIDER_SNAP_CONTEXT)PassBack;

    __try {
        for (i=0; i<context->Count; i++) {
            if (context->ProviderIds[i]
                    == *(CatalogEntry->GetProviderId ())) {
                assert (context->Items[i]==NULL);
                context->Items[i] = CatalogEntry;
                return TRUE;
            }
        }
    }
    __except (WS2_EXCEPTION_FILTER()) {
        context->ErrorCode = WSAEFAULT;
    }

    return FALSE;
}  // ProviderSnap
#else
;
#endif

int
WSPAPI
#ifndef _WIN64_32
WSCWriteNameSpaceOrder (
#else
WSCWriteNameSpaceOrder32 (
#endif
    IN LPGUID lpProviderId,
    IN DWORD dwNumberOfEntries
    )
/*++

Routine Description:

    Reorder existing WinSock2 name space providers.  The order of the service
    providers determines their priority in being selected for use.  The
    sporder.exe tool will show you the installed provider and their ordering,
    Alternately, WSAEnumNameSpaces(), in conjunction with this function,
    will allow you to write your own tool.

Arguments:

    lpwdCatalogEntryId  [in]
      An array of CatalogEntryId elements as found in the WSAPROTOCOL_INFO
      structure.  The order of the CatalogEntryId elements is the new
      priority ordering for the service providers.

    dwNumberOfEntries  [in]
      The number of elements in the lpwdCatalogEntryId array.


Return Value:

    ERROR_SUCCESS   - the service providers have been reordered.
    WSAEINVAL       - input parameters were bad, no action was taken.
    WSAEFAULT       - CatalogEnryId array is not fully contained within
                        process address space.
    WSATRY_AGAIN    - the routine is being called by another thread or process.
    any registry error code


Comments:

    Here are scenarios in which the WSCWriteProviderOrder function may fail:

      The dwNumberOfEntries is not equal to the number of registered service
      providers.

      The lpwdCatalogEntryId contains an invalid catalog ID.

      The lpwdCatalogEntryId does not contain all valid catalog IDs exactly
      1 time.

      The routine is not able to access the registry for some reason
      (e.g. inadequate user persmissions)

      Another process (or thread) is currently calling the routine.


--*/
{
    INT             errno_result;
    HKEY            registry_root;
    PNSCATALOGENTRY *items = NULL;
    DWORD           i;

    // object protected by "try" block
    PNSCATALOG           catalog = NULL;


    items = new PNSCATALOGENTRY[dwNumberOfEntries];
    if (items==NULL) {
        DEBUGF(
            DBG_ERR,
            ("Allocating items array\n"));
        return WSA_NOT_ENOUGH_MEMORY;
    }

    memset (items, 0, sizeof (PNSCATALOGENTRY)*dwNumberOfEntries);

    errno_result = ERROR_SUCCESS;

    TRY_START(guard_memalloc) {
        PROVIDER_SNAP_CONTEXT context;
        registry_root = OpenWinSockRegistryRoot();
        if (registry_root == NULL) {
            DEBUGF(
                DBG_ERR,
                ("Opening registry root\n"));
            errno_result = WSANO_RECOVERY;
            TRY_THROW(guard_memalloc);
        }

        catalog = new NSCATALOG();
        if (catalog == NULL) {
            errno_result = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(guard_memalloc);
        }

#ifndef _WIN64_32
        errno_result = catalog->InitializeFromRegistry(
            registry_root,  // ParentKey
            NULL            // ChangeEvent
            );
#else
        errno_result = catalog->InitializeFromRegistry32(
            registry_root   // ParentKey
            );
#endif
        if (errno_result != ERROR_SUCCESS) {
            TRY_THROW(guard_memalloc);
        }

        context.Items = items;
        context.ProviderIds = lpProviderId;
        context.Count = dwNumberOfEntries;
        context.ErrorCode = ERROR_SUCCESS;

        catalog->EnumerateCatalogItems(
            ProviderSnap,         // Iteration
            & context               // PassBack
            );
        if (context.ErrorCode!=ERROR_SUCCESS) {
            errno_result = context.ErrorCode;
            TRY_THROW(guard_memalloc);
        }

        for (i=0; i<dwNumberOfEntries; i++) {
            if (context.Items[i]!=NULL) {
                //
                // Remove catalog item and add it in the end.
                //
                catalog->RemoveCatalogItem (context.Items[i]);
                catalog->AppendCatalogItem (context.Items[i]);
            }
            else {
                DEBUGF (DBG_ERR,
                    ("Checking item array against catalog, item: %ld.\n",
                    i));
                errno_result = WSAEINVAL;
                TRY_THROW(guard_memalloc);
            }
        } // for i

        errno_result = catalog->WriteToRegistry();
        if (errno_result!=ERROR_SUCCESS) {
            TRY_THROW(guard_memalloc);
        }

        delete catalog;
        CloseWinSockRegistryRoot(registry_root);

    } TRY_CATCH(guard_memalloc) {
        assert (errno_result != ERROR_SUCCESS);
        if (catalog != NULL) {
            delete catalog; // This destroys the items as well
        }
        
        if (registry_root!=NULL) {
            CloseWinSockRegistryRoot(registry_root);
        }
    } TRY_END(guard_memalloc);


    delete items;

    if (errno_result == ERROR_SUCCESS) {
        HANDLE hHelper;

        //
        // Alert all interested apps of change via the notification method
        //

        if (WahOpenNotificationHandleHelper( &hHelper) == ERROR_SUCCESS) {
            WahNotifyAllProcesses( hHelper );
            WahCloseNotificationHandleHelper( hHelper );
        }
        else {
            //
            // This in non-fatal and catalog was updated anyway.
            //
        }
    }

    return errno_result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\nsquery.cpp ===
/*++

    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.

Module Name:

    nsquery.cpp

Abstract:

    This module gives the class implementation for the NSQUERY object type.
    The NSQUERY object holds all the state information regarding a
    WSALookup{Begin/Next/End} series of operations. It supplies member
    functions that implement the API-level operations in terms of the SPI-level
    operations.

Author:

    Dirk Brandewie (dirk@mink.intel.com) 04-December-1995

Notes:

    $Revision:   1.14  $

    $Modtime:   08 Mar 1996 16:14:30  $


Revision History:

    most-recent-revision-date email-name
        description

    04-Dec-1995 dirk@mink.intel.com
        Initail revision

--*/

#include "precomp.h"

BOOL
MatchProtocols(DWORD dwNameSpace, LONG lfamily, LPWSAQUERYSETW lpqs)
/*++
Checks if the namespace provider identified by dwNamespace can
handle the protocol items in the list. It knows about NS_DNS and
NS_SAP only and therefore all other providers simply "pass". These
two providers are known to support one address family each and therefore
the protocol restrictions must include this family.
N.B. The right way to do this is to pass in the supported address family,
which in a more perfect world, would be store in the registry along with
the other NSP information. When that day dawns, this code can be
changed to use that value.
--*/
{
    DWORD dwProts = lpqs->dwNumberOfProtocols;
    LPAFPROTOCOLS lap = lpqs->lpafpProtocols;
    INT Match;

    //
    // this switch is the replacment for having the supported protocol
    // stored  in registry.
    //
    if(lfamily != -1)
    {
        if(lfamily == AF_UNSPEC)
        {
            return(TRUE);       // does them all
        }
        Match = lfamily;
    }
    else
    {
        switch(dwNameSpace)
        {
            case NS_SAP:
                Match = AF_IPX;
                break;

#if 0
      // The DNS name space provider now supports IPV6, IP SEC, ATM, etc.
      // Not just INET.

            case NS_DNS:
                Match = AF_INET;
                break;
#endif
            default:
                return(TRUE);      // use it
        }
    }
    //
    // If we get the address family-in-the registry=support, then
    // we should check for a value of AF_UNSPEC stored there
    // and accept this provider in that case. Note that if
    // AF_UNSPEC is given in the restriction list, we must
    // load each provider since we don't know the specific protocols
    // a provider supports.
    //
    for(; dwProts; dwProts--, lap++)
    {
        if((lap->iAddressFamily == AF_UNSPEC)
                      ||
           (lap->iAddressFamily == Match))
        {
            return(TRUE);
        }
    }
    return(FALSE);
}


NSQUERY::NSQUERY()
/*++

Routine Description:

    Constructor for the NSQUERY object.  The first member function called after
    this must be Initialize.

Arguments:

    None

Return Value:

    Returns a pointer to a NSQUERY object.
--*/
{
    m_signature = ~QUERYSIGNATURE;
    m_reference_count  = 0;
    m_shutting_down = FALSE;
    InitializeListHead(&m_provider_list);
    m_current_provider = NULL;
    m_change_ioctl_succeeded = FALSE;
#ifdef RASAUTODIAL
    m_query_set = NULL;
    m_control_flags = 0;
    m_catalog = NULL;
    m_restartable = TRUE;
#endif
}



INT
NSQUERY::Initialize(
    )
/*++

Routine Description:

    This  procedure  performs  all initialization for the NSQUERY object.  This
    function  must  be  invoked  after the constructor, before any other member
    function is invoked.

Arguments:


Return Value:

    If  the  function  is  successful,  it  returns ERROR_SUCCESS, otherwise it
    returns an appropriate WinSock 2 error code.
--*/
{
    INT     err;
    // Init mem variables that need some amount of processing
    __try {
        InitializeCriticalSection(&m_members_guard);
        m_signature = QUERYSIGNATURE;
        m_reference_count = 1; // Initial reference.
        err = ERROR_SUCCESS;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        err = WSA_NOT_ENOUGH_MEMORY;
    }

    return(err);
}



BOOL
NSQUERY::ValidateAndReference()
/*++

Routine Description:

   Checks the signature of this->m_signature to ensure that this is a valid
   query object and references it.

Arguments:

    NONE

Return Value:

    True if this points to valid query object and we were able to reference it.

--*/
{
    LONG    newCount;

    while (1) {
        //
        // Check the signature first
        //
        if (m_signature != QUERYSIGNATURE) {
            break;
        }

        //
        // Don't try to increment is object is being destroyed.
        //
        newCount = m_reference_count;
        if (newCount==0) {
            break;
        }

        //
        // Increment the count
        //
        if (InterlockedCompareExchange ((PLONG)&m_reference_count,
                                                newCount+1,
                                                newCount)==newCount) {
            return TRUE;
        }
        //
        // Try again, someone is executing in paraller with us.
        //
    }

    return FALSE;
}




NSQUERY::~NSQUERY()
/*++

Routine Description:

    Destructor of the NSQUERY object.  The object should be destroyed only when
    either  (1)  the  reference count goes to 0, or (2) if the
    Initialize() member function fails.

Arguments:

    None

Return Value:

    None
--*/
{
    PLIST_ENTRY ListEntry;
    PNSPROVIDERSTATE Provider;

    //
    // Check if we were fully initialized.
    //
    if (m_signature != QUERYSIGNATURE) {
        return;
    }
    EnterCriticalSection(&m_members_guard);

    //
    // invalidate the signature since simply freeing the memory
    // may not do so. Any value will do, so the one used is arbitrary.
    //
    m_signature = ~QUERYSIGNATURE;

    while (!IsListEmpty(&m_provider_list))
    {
        ListEntry = RemoveHeadList(&m_provider_list);
        Provider = CONTAINING_RECORD( ListEntry,
                                      NSPROVIDERSTATE,
                                      m_query_linkage);
        delete(Provider);
    }
#ifdef RASAUTODIAL
    delete(m_query_set);
#endif // RASAUTODIAL
    DeleteCriticalSection(&m_members_guard);
}


//Structure used to carry context to CatalogEnumerationProc()
typedef struct _NSPENUMERATIONCONTEXT {
    LPWSAQUERYSETW lpqs;
    DWORD ErrorCode;
    PNSQUERY aNsQuery;
    PNSCATALOG  Catalog;
} NSPENUMERATIONCONTEXT, * PNSPENUMERATIONCONTEXT;

BOOL
LookupBeginEnumerationProc(
    IN PVOID Passback,
    IN PNSCATALOGENTRY  CatalogEntry
    )
/*++

Routine Description:

    The enumeration procedure for LookupBegin. Inspects each catalog item to
    see if it matches the selection criteria the query, if so adds the provider
    associated with the item to the list of providers involved in the query.

Arguments:

    PassBack - A context value passed to EunerateCatalogItems. It is really a
               pointer to a NSPENUMERATIONCONTEXT struct.

    CatalogItem - A pointer to a catalog item to be inspected.


Return Value:

    True
--*/
{
    PNSPENUMERATIONCONTEXT Context;
    DWORD NamespaceId;
    PNSPROVIDER Provider;
    PNSQUERY aNsQuery;

    Context = (PNSPENUMERATIONCONTEXT)Passback;
    NamespaceId = CatalogEntry->GetNamespaceId();
    aNsQuery = Context->aNsQuery;

    __try { // we are holding catalog lock, make sure we won't av
            // because of bogus parameters and leave it locked.
        if ((((Context->lpqs->dwNameSpace != NamespaceId)
                        &&
            (Context->lpqs->dwNameSpace != NS_ALL))
                        ||
            (Context->lpqs->dwNumberOfProtocols
                        &&
             !MatchProtocols(NamespaceId,
                            CatalogEntry->GetAddressFamily(),
                            Context->lpqs)))
                        ||
             !CatalogEntry->GetEnabledState()) {
            return TRUE;        // go on to next one
        }
    }
    __except (WS2_EXCEPTION_FILTER ()) {
        Context->ErrorCode = WSAEFAULT;
        return FALSE;
    }

    Provider = CatalogEntry->GetProvider();
    if (Provider==NULL) {
        // Try to load provider
        INT ErrorCode;
        ErrorCode = Context->Catalog->LoadProvider (CatalogEntry);
        if (ErrorCode!=ERROR_SUCCESS) {
            // no error if the provider won't load.
            return TRUE;
        }
        Provider = CatalogEntry->GetProvider();
        assert (Provider!=NULL);
    }

    if (aNsQuery->AddProvider(Provider)){
        return TRUE;
    } //if
    else {
        Context->ErrorCode = WSASYSCALLFAILURE;
        return FALSE;
    }
}


INT
WINAPI
NSQUERY::LookupServiceBegin(
    IN  LPWSAQUERYSETW      lpqsRestrictions,
    IN  DWORD              dwControlFlags,
    IN PNSCATALOG          NsCatalog
    )
/*++

Routine Description:

   Complete the initialization of a NSQUERY object and call
   NSPLookupServiceBegin() for all service providers refereneced by the query.

Arguments:

    NsCatalog - Supplies  a  reference  to  the  name-space catalog object from
                which providers may be selected.

Return Value:

--*/
{
    INT ReturnCode = NO_ERROR;
    INT ErrorCode = NO_ERROR;
    PNSCATALOGENTRY  ProviderEntry;
    PNSPROVIDERSTATE Provider;
    PLIST_ENTRY      ListEntry;
    WSASERVICECLASSINFOW ClassInfo;
    LPWSASERVICECLASSINFOW ClassInfoBuf=NULL;
    DWORD                  ClassInfoSize=0;
    DWORD                  dwTempOutputFlags =
                               lpqsRestrictions->dwOutputFlags;
    LPWSTR                 lpszTempComment =
                               lpqsRestrictions->lpszComment;
    DWORD                  dwTempNumberCsAddrs =
                               lpqsRestrictions->dwNumberOfCsAddrs;
    PCSADDR_INFO           lpTempCsaBuffer =
                               lpqsRestrictions->lpcsaBuffer;

    // Select the service provider(s) that will be used for this query. A
    // service provider is selected using the provider GUID or the namespace ID
    // the namespace ID may be a specific namespace i.e. NS_DNS or NS_ALL for
    // all installed namespaces.

    //
    // Make sure that the ignored fields are cleared so that the
    // CopyQuerySetW function call below doesn't AV.
    //
    // This was a fix for bug #91655
    //
    lpqsRestrictions->dwOutputFlags = 0;
    lpqsRestrictions->lpszComment = NULL;
    lpqsRestrictions->dwNumberOfCsAddrs = 0;
    lpqsRestrictions->lpcsaBuffer = NULL;

#ifdef RASAUTODIAL
    //
    // Save the original parameters of the query, in
    // case we have to restart it due to an autodial
    // attempt.
    //
    if (m_restartable) {
        ErrorCode = CopyQuerySetW(lpqsRestrictions, &m_query_set);
        if (ErrorCode != ERROR_SUCCESS) {
            ReturnCode = SOCKET_ERROR;
            m_restartable = FALSE;
        }
        m_control_flags = dwControlFlags;
        m_catalog = NsCatalog;
    }
#endif // RASAUTODIAL

    if (ReturnCode==NO_ERROR) 
    {
        if (lpqsRestrictions->lpNSProviderId)
        {
            // Use a single namespace provider
            ReturnCode = NsCatalog->GetCountedCatalogItemFromProviderId(
                lpqsRestrictions->lpNSProviderId,
                &ProviderEntry);
            if (ReturnCode==NO_ERROR){
                if (!AddProvider(ProviderEntry->GetProvider())) {
                    ErrorCode = WSA_NOT_ENOUGH_MEMORY;
                    ReturnCode = SOCKET_ERROR;
                }
            }
            else {
                ErrorCode = WSAEINVAL;
                ReturnCode = SOCKET_ERROR;
            } //if
        } //if
        else{
            NSPENUMERATIONCONTEXT Context;
    
            Context.lpqs = lpqsRestrictions;
            Context.ErrorCode = NO_ERROR;
            Context.aNsQuery = this;
            Context.Catalog = NsCatalog;
    
            NsCatalog->EnumerateCatalogItems(
                LookupBeginEnumerationProc,
                &Context);
            if (Context.ErrorCode!=NO_ERROR){
                ErrorCode = Context.ErrorCode;
                ReturnCode = SOCKET_ERROR;
            } //if
        } //else
    } //if


    if (ReturnCode==NO_ERROR){
         //Get the class information for this query. Call once with a zero
         //buffer to size the buffer we need to allocate then call to get the
         //real answer
        ClassInfo.lpServiceClassId = lpqsRestrictions->lpServiceClassId;

        ReturnCode = NsCatalog->GetServiceClassInfo(
            &ClassInfoSize,
            &ClassInfo);

        if (ReturnCode!=NO_ERROR) {
            ErrorCode = GetLastError ();
            if (ErrorCode==WSAEFAULT){

                ClassInfoBuf = (LPWSASERVICECLASSINFOW)new BYTE[ClassInfoSize];

                if (ClassInfoBuf){
                    ReturnCode = NsCatalog->GetServiceClassInfo(
                        &ClassInfoSize,
                        ClassInfoBuf);
                    if (ReturnCode!=NO_ERROR) {
                        ErrorCode = GetLastError ();
                    }
                } //if
                else{
                    ErrorCode = WSA_NOT_ENOUGH_MEMORY;
                    ReturnCode = SOCKET_ERROR;
                } //else
            }//if
            else {
                // Ignore other error codes.
                ReturnCode = NO_ERROR;
            }
        } //if
    } //if

    if( ReturnCode==NO_ERROR) {
        if (IsListEmpty( &m_provider_list ) ) {
            ErrorCode = WSASERVICE_NOT_FOUND;
            ReturnCode = SOCKET_ERROR;
        }
        else {
            INT ReturnCode1;

            ReturnCode = SOCKET_ERROR;  // Assume all providers fail.
            //Call Begin on all the selected providers
            ListEntry = m_provider_list.Flink;
            Provider = CONTAINING_RECORD( ListEntry,
                                          NSPROVIDERSTATE,
                                          m_query_linkage);
            do {
                ReturnCode1 = Provider->LookupServiceBegin(lpqsRestrictions,
                                             ClassInfoBuf,
                                             dwControlFlags);
                if(ReturnCode1 == SOCKET_ERROR)
                {
                    //
                    // this provider didn't like it. So remove it
                    // from the list
                    //

                    PNSPROVIDERSTATE Provider1;
                    ErrorCode = GetLastError ();

                    Provider1 = Provider;
                    Provider = NextProvider(Provider);
                    RemoveEntryList(&Provider1->m_query_linkage);
                    delete(Provider1);
                }
                else
                {
                    ReturnCode = ERROR_SUCCESS;// Record that at least one
                                               // provider succeeded.
                    Provider = NextProvider(Provider);
                }
            } while (Provider);
            if (ReturnCode == NO_ERROR){
                ListEntry = m_provider_list.Flink;
                m_current_provider = CONTAINING_RECORD( ListEntry,
                                              NSPROVIDERSTATE,
                                              m_query_linkage);
            }
        }
    } //if
    else {
        // We failed somewhere along the way so clean up the provider on the
        // provider list.
        while (!IsListEmpty(&m_provider_list)){
            ListEntry = RemoveHeadList(&m_provider_list);
            Provider = CONTAINING_RECORD( ListEntry,
                                          NSPROVIDERSTATE,
                                          m_query_linkage);
            delete(Provider);
        } //while
    }
    
    if (ReturnCode!=NO_ERROR) {
        if (ClassInfoBuf){
            delete ClassInfoBuf;
        } //if
        // Set error after all is done so it is not overwritten
        // accidentally.
        SetLastError (ErrorCode);
    } //else

    //
    // Restore ignored field values to what callee had set.
    //
    lpqsRestrictions->dwOutputFlags = dwTempOutputFlags;
    lpqsRestrictions->lpszComment = lpszTempComment;
    lpqsRestrictions->dwNumberOfCsAddrs = dwTempNumberCsAddrs;
    lpqsRestrictions->lpcsaBuffer = lpTempCsaBuffer;

    return(ReturnCode);
}

// *** Fill in description from the spec when it stabilizes.



INT
WINAPI
NSQUERY::LookupServiceNext(
    IN     DWORD           dwControlFlags,
    IN OUT LPDWORD         lpdwBufferLength,
    IN OUT LPWSAQUERYSETW  lpqsResults
    )
/*++

Routine Description:

    //***TODO Fill in description from the spec when it stabilizes.

Arguments:


Return Value:

--*/
{
    INT ReturnCode = SOCKET_ERROR;
    PNSPROVIDERSTATE NewProvider = NULL;
    PNSPROVIDERSTATE ThisProvider;

    if (!m_shutting_down) {

        EnterCriticalSection(&m_members_guard);

        NewProvider = m_current_provider;

        if (!NewProvider) {

            if (m_change_ioctl_succeeded) {

                //
                // Push the ioctl provider to the end of the list and reset
                // the current provider pointer to it to make it possible to
                // continue calling LookupServiceNext after a change notification.
                //
                PNSPROVIDERSTATE tmp =
                    CONTAINING_RECORD(m_provider_list.Blink,
                                      NSPROVIDERSTATE,
                                      m_query_linkage);

                while ((tmp != NULL) && !tmp->SupportsIoctl())
                    tmp = PreviousProvider(tmp);

                if (tmp == NULL) {
                    LeaveCriticalSection(&m_members_guard);
                    SetLastError(WSA_E_NO_MORE);
                    return (SOCKET_ERROR);
                }

                RemoveEntryList(&tmp->m_query_linkage);
                InsertTailList(&m_provider_list, &tmp->m_query_linkage);

                NewProvider = m_current_provider = tmp;

            } else {
                LeaveCriticalSection(&m_members_guard);
                SetLastError(WSA_E_NO_MORE);
                return (SOCKET_ERROR);
            }
        }

        LeaveCriticalSection(&m_members_guard);

        while (NewProvider) {
            ReturnCode = NewProvider->LookupServiceNext(
                dwControlFlags,
                lpdwBufferLength,
                lpqsResults);
            if ((ERROR_SUCCESS == ReturnCode)
                        ||
                (WSAEFAULT == GetLastError()) )
            {
                break;
            } //if

            if (m_shutting_down)
                break;

            EnterCriticalSection(&m_members_guard);
            if (m_current_provider!=NULL) {
                ThisProvider = NewProvider;
                NewProvider = NextProvider (m_current_provider);
                if (ThisProvider==m_current_provider) {
                    m_current_provider = NewProvider;
                }
            }
            else {
                NewProvider = NULL;
            }

#ifdef RASAUTODIAL
            if (NewProvider == NULL &&
                m_restartable &&
                ReturnCode == SOCKET_ERROR &&
                !m_shutting_down)
            {
                PLIST_ENTRY ListEntry;
                DWORD errval;

                //
                // Save the error in case the Autodial
                // attempt fails.
                //
                errval = GetLastError();
                //
                // We only invoke Autodial once per query.
                //
                m_restartable = FALSE;
                if (WSAttemptAutodialName(m_query_set)) {
                    //
                    // Because the providers have cached state
                    // about this query, we need to call
                    // LookupServiceEnd/LookupServiceBegin
                    // to reset them.
                    //

                    while (!IsListEmpty(&m_provider_list)){
                        ListEntry = RemoveHeadList(&m_provider_list);
        
                        ThisProvider = CONTAINING_RECORD( ListEntry,
                                                      NSPROVIDERSTATE,
                                                      m_query_linkage);
                        ThisProvider->LookupServiceEnd();
                        delete(ThisProvider);

                    } //while
                    m_current_provider = NULL;

                    //
                    // Restart the query.
                    //
                    if (LookupServiceBegin(
                          m_query_set,
                          m_control_flags|LUP_FLUSHCACHE,
                          m_catalog) == ERROR_SUCCESS)
                    {
                        NewProvider = m_current_provider;
                        assert (NewProvider!=NULL);
                        m_current_provider = NextProvider (NewProvider);
                    }
                }
                else {
                    SetLastError(errval);
                }
            }
            LeaveCriticalSection (&m_members_guard);
#endif // RASAUTODIAL
        } //while
    }
    else {
        SetLastError(WSAECANCELLED);
    }

    return(ReturnCode);
}


INT
WINAPI
NSQUERY::Ioctl(
    IN  DWORD            dwControlCode,
    IN  LPVOID           lpvInBuffer,
    IN  DWORD            cbInBuffer,
    OUT LPVOID           lpvOutBuffer,
    IN  DWORD            cbOutBuffer,
    OUT LPDWORD          lpcbBytesReturned,
    IN  LPWSACOMPLETION  lpCompletion,
    IN  LPWSATHREADID    lpThreadId
    )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    INT ReturnCode = SOCKET_ERROR;

    if (!m_shutting_down){

        //
        // Make sure there is at least one and only one namespace
        // in the query that supports this operation.
        //

        PNSPROVIDERSTATE provider = NULL;
        unsigned int numProviders = 0;
        PLIST_ENTRY ListEntry;

        EnterCriticalSection (&m_members_guard);
        ListEntry = m_provider_list.Flink;
        while (ListEntry != &m_provider_list) {
            PNSPROVIDERSTATE CurrentProvider =
                CONTAINING_RECORD(ListEntry, NSPROVIDERSTATE, m_query_linkage);
            if (CurrentProvider->SupportsIoctl()) {
                if (++numProviders > 1)
                    break;
                provider = CurrentProvider;
            }
            ListEntry = ListEntry->Flink;
        }
        LeaveCriticalSection (&m_members_guard);

        if (numProviders > 1) {
            SetLastError(WSAEINVAL);
            return (SOCKET_ERROR);
        }

        if (provider == NULL) {
            SetLastError(WSAEOPNOTSUPP);
            return (SOCKET_ERROR);
        }

        ReturnCode = provider->Ioctl(dwControlCode, lpvInBuffer, cbInBuffer,
                                     lpvOutBuffer, cbOutBuffer, lpcbBytesReturned,
                                     lpCompletion, lpThreadId);

        //
        // If the ioctl succeeds or is pending, when the change occurs we
        // want to reset the provider list to permit further calls to
        // LookupServiceNext.
        //
        if ((dwControlCode == SIO_NSP_NOTIFY_CHANGE) &&
            ((ReturnCode == NO_ERROR) ||
             ((ReturnCode == SOCKET_ERROR) && (GetLastError() == WSA_IO_PENDING)))) {
                int error = GetLastError();
                EnterCriticalSection(&m_members_guard);
                m_change_ioctl_succeeded = TRUE;
                LeaveCriticalSection(&m_members_guard);
                SetLastError(error);
        }

    } else {
        SetLastError(WSAECANCELLED);
    }

    return (ReturnCode);
}


INT
WINAPI
NSQUERY::LookupServiceEnd()
/*++

Routine Description:

    This routine ends a query by calling NSPlookupServiceEnd on all the
    providers associated with this query.

Arguments:

    NONE

Return Value:

    ERROR_SUCCESS
--*/
{
    PLIST_ENTRY ListEntry;
    PNSPROVIDERSTATE CurrentProvider;

    EnterCriticalSection (&m_members_guard);
    
    m_shutting_down = TRUE;

    ListEntry = m_provider_list.Flink;

    while (ListEntry != &m_provider_list){
        CurrentProvider = CONTAINING_RECORD( ListEntry,
                                              NSPROVIDERSTATE,
                                              m_query_linkage);
        CurrentProvider->LookupServiceEnd();

        ListEntry = ListEntry->Flink;
    } //while
    LeaveCriticalSection (&m_members_guard);

    return(ERROR_SUCCESS);
}



VOID
WINAPI
NSQUERY::Dereference()
/*++

Routine Description:

    This  function  determines  whether the NSQUERY object should be destroyed.
    This  function should be invoked after every call to LookupServiceNext() or
    LookupEnd().   If it returns TRUE, any concurrent operations have completed
    and the NSQUERY object should be destroyed.

Arguments:

    None

Return Value:

    TRUE  - The NSQUERY object should be destroyed.
    FALSE - The NSQUERY object should not be destroyed.
--*/
{
    if (InterlockedDecrement ((PLONG)&m_reference_count)==0) {
        delete this;
    }
}


PNSPROVIDERSTATE
NSQUERY::NextProvider(
    PNSPROVIDERSTATE Provider
    )
/*++

Routine Description:

    Retrieve the next provider object from the list of providers associated
    with this query.

Arguments:

    Provider - A pointer to a provider state object.

Return Value:

    A pointer to the next provider state object on the list of providers or
    NULL if no entries are present after Provider.

--*/
{
    PNSPROVIDERSTATE NewProvider=NULL;
    PLIST_ENTRY ListEntry;

    ListEntry = Provider->m_query_linkage.Flink;

    if (ListEntry != &m_provider_list){
        NewProvider = CONTAINING_RECORD( ListEntry,
                                         NSPROVIDERSTATE,
                                         m_query_linkage);
    } //if
    return(NewProvider);
}


PNSPROVIDERSTATE
NSQUERY::PreviousProvider(
    PNSPROVIDERSTATE Provider
    )
/*++

Routine Description:

    Retrieve the previous provider object from the list of providers associated
    with this query.

Arguments:

    Provider - A pointer to a provider state object.

Return Value:

    A pointer to the previous provider state object on the list of providers or
    NULL if no entries are present before Provider.

--*/
{
    PNSPROVIDERSTATE NewProvider=NULL;
    PLIST_ENTRY ListEntry;

    ListEntry = Provider->m_query_linkage.Blink;

    if (ListEntry != &m_provider_list){
        NewProvider = CONTAINING_RECORD( ListEntry,
                                         NSPROVIDERSTATE,
                                         m_query_linkage);
    } //if
    return(NewProvider);
}


BOOL
NSQUERY::AddProvider(
    PNSPROVIDER  pNamespaceProvider
    )
/*++

Routine Description:

    Adds a namespace provider to the list of provider(s) involed with this
    query. A NSPROVIDERSTATE object is created for the provider the provider
    object is attached to the state object and the state object is added to the
    provider list.

Arguments:

    pNamespaceProvider - A pointer to a namespace provider object to be added
                         to the list of providers.

Return Value:
    TRUE if the operation is successful else FALSE.

--*/
{
    BOOL ReturnCode = TRUE;
    PNSPROVIDERSTATE ProviderHolder;

    ProviderHolder = new NSPROVIDERSTATE;
    if (ProviderHolder){
        ProviderHolder->Initialize(pNamespaceProvider);
        InsertTailList(&m_provider_list,
                           &(ProviderHolder->m_query_linkage));
    } //if
    else{
        SetLastError(WSASYSCALLFAILURE);
        ReturnCode = FALSE;
    } //else
    return(ReturnCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\nsprovid.cpp ===
/*++

    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.

Module Name:

    nsprovid.cpp

Abstract:

    This module gives the class implementation for the NSPROVIDE object type.

Author:

    Dirk Brandewie (dirk@mink.intel.com) 04-December-1995

Notes:

    $Revision:   1.8  $

    $Modtime:   08 Mar 1996 16:04:36  $


Revision History:

    most-recent-revision-date email-name
        description

    04-Dec-1995 dirk@mink.intel.com
        Initial revision

--*/

#include "precomp.h"

NSPROVIDER::NSPROVIDER()
/*++

Routine Description:

    Coustructor for a NSPROVIDER object. Initializes object member variables to
    default values.

Arguments:

    None

Return Value:

    None
--*/
{
    // Init all member variable to known values
    m_reference_count = 1;
    memset(&m_proctable, 0, sizeof(m_proctable));
    m_proctable.cbSize = sizeof(m_proctable);
    m_library_handle = NULL;
#ifdef DEBUG_TRACING
    m_library_name = NULL;
#endif
}


INT WSAAPI
NSPROVIDER::NSPCleanup(
    VOID
    )
/*++
Routine Description:

    Terminate use of the WinSock name space service provider.

Arguments:

    None

Return Value:

    If no error occurs, NSPCleanup returns a value of NO_ERROR (zero).
    Otherwise, SOCKET_ERROR (-1) is returned and the provider must
    set the appropriate error code using SetLastError

--*/
{
    INT ReturnValue = NO_ERROR;

    if (m_library_handle) {
        LPNSPCLEANUP    lpNSPCleanup;

        lpNSPCleanup =
            (LPNSPCLEANUP)InterlockedExchangePointer (
                            (PVOID *)&m_proctable.NSPCleanup,
                            NULL
                            );
        if (lpNSPCleanup!=NULL) {

            DEBUGF( DBG_TRACE,
                    ("Calling NSPCleanup for provider %s @ %p\n",
                        m_library_name,
                        this));

            ReturnValue = lpNSPCleanup(&m_provider_id);

        }
    }
    return ReturnValue;
}

NSPROVIDER::~NSPROVIDER()
/*++

Routine Description:

    Destructor for NSPROVIDER object.  Frees resoures used by the object and
    set the member variables to the uninitialized state.

Arguments:

    None

Return Value:

    None
--*/
{
#ifdef DEBUG_TRACING
    if (m_library_name)
    {
        delete(m_library_name);
        m_library_name = NULL;
    } //if
#endif


    if (m_library_handle)
    {
        NSPCleanup();
        FreeLibrary(m_library_handle);
        m_library_handle = NULL;
    } //if
}


INT
NSPROVIDER::Initialize(
    IN LPWSTR lpszLibFile,
    IN LPGUID  lpProviderId
    )
/*++

Routine Description:

    This routine initializes an NSPROVIDER object.

Arguments:

    lpszLibFile - A string containing the path to the DLL for the name space
                  provider to be associated with this object.

    lpProviderId - A pointer to a GUID containing the provider ID for the
                   namespace provider.

Return Value:

    ERROR_SUCCESS if the provider was successfully initialized else an
    apropriate winsock error code.
--*/
{
    LPNSPSTARTUP        NSPStartupFunc;
    WCHAR               ExpandedPath[MAX_PATH];
    INT                 ReturnCode;
    DWORD               ExpandedPathLen;

    DEBUGF( DBG_TRACE,
            ("Initializing namespace provider %ls\n", lpszLibFile));

    //
    // Expand the library name to pickup environment/registry variables
    //

    ExpandedPathLen = ExpandEnvironmentStringsW(lpszLibFile,
                                                ExpandedPath,
                                                MAX_PATH);

    if (ExpandedPathLen == 0) {
        DEBUGF(
            DBG_ERR,
            ("Expanding environment variable %ls failed\n", lpszLibFile));
        return WSASYSCALLFAILURE;
    } //if

    TRY_START(guard_memalloc) {
#ifdef DEBUG_TRACING
        m_library_name = ansi_dup_from_wcs (lpszLibFile);
        if (m_library_name == NULL) {
            DEBUGF(
                DBG_ERR,
                ("Allocating m_lib_name\n"));
            ReturnCode = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(guard_memalloc);
        }
#endif
        //
        // Load the provider DLL, Call the provider startup routine and validate
        // that the provider filled out all the NSP_ROUTINE function pointers.
        //
        m_library_handle = LoadLibraryW(ExpandedPath);
        if (NULL == m_library_handle)
        {
            ReturnCode = GetLastError ();
            DEBUGF(
                DBG_ERR,
                ("Loading DLL %ls, err: %ld\n",ExpandedPath, ReturnCode));
            switch (ReturnCode) {
            case ERROR_NOT_ENOUGH_MEMORY:
            case ERROR_COMMITMENT_LIMIT:
                ReturnCode = WSA_NOT_ENOUGH_MEMORY;
                break;
            default:
                ReturnCode = WSAEPROVIDERFAILEDINIT;
                break;
            }
            TRY_THROW(guard_memalloc);
        } //if

        //Get the procedure address of the NSPStartup routine
        NSPStartupFunc = (LPNSPSTARTUP)GetProcAddress(
            m_library_handle,
            "NSPStartup");
        if (NULL == NSPStartupFunc)
        {
            DEBUGF( DBG_ERR,("Getting startup entry point for NSP %ls\n",
                             lpszLibFile));
            ReturnCode = WSAEPROVIDERFAILEDINIT;
            TRY_THROW(guard_memalloc);
        } //if



        //
        // Set exception handler around this call since we
        // hold critical section (catalog lock).
        //
        WS2_32_W4_INIT ReturnCode = WSAEPROVIDERFAILEDINIT;
        __try {
#if !defined(DEBUG_TRACING)
            ReturnCode = (*NSPStartupFunc)(
                lpProviderId,
                &m_proctable);
#else
            { // declaration block
                BOOL       bypassing_call;
                bypassing_call = PREAPINOTIFY((
                    DTCODE_NSPStartup,
                    & ReturnCode,
                    m_library_name,
                    &lpProviderId,
                    &m_proctable));
                if (! bypassing_call) {
                    ReturnCode = (*NSPStartupFunc)(
                        lpProviderId,
                        &m_proctable);
                    POSTAPINOTIFY((
                        DTCODE_NSPStartup,
                        & ReturnCode,
                        m_library_name,
                        &lpProviderId,
                        &m_proctable));
                } // if ! bypassing_call
            } // declaration block
#endif // !defined(DEBUG_TRACING)

        }
        __except (WS2_PROVIDER_EXCEPTION_FILTER ("NSPStartup",
                                                    lpszLibFile,
                                                    L"",
                                                    lpProviderId
                                                    )) {
            ReturnCode = WSAEPROVIDERFAILEDINIT;
            TRY_THROW(guard_memalloc);
        }

        if (ERROR_SUCCESS != ReturnCode)
        {
            ReturnCode = GetLastError();
            DEBUGF(DBG_ERR, ("Calling NSPStartup for %ls (%8.8x-%4.4x-%4.4x-%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x), err:%ld\n",
                                    lpszLibFile,
                                    lpProviderId->Data1,
                                    lpProviderId->Data2,
                                    lpProviderId->Data3,
                                    lpProviderId->Data4[0],
                                    lpProviderId->Data4[1],
                                    lpProviderId->Data4[2],
                                    lpProviderId->Data4[3],
                                    lpProviderId->Data4[4],
                                    lpProviderId->Data4[5],
                                    lpProviderId->Data4[6],
                                    lpProviderId->Data4[7],
                                    ReturnCode));
            if(!ReturnCode)
            {
                ReturnCode = WSAEPROVIDERFAILEDINIT;
            }
            TRY_THROW(guard_memalloc);
        } //if

        // Check to see that the namespce provider filled in all the fields in the
        // NSP_ROUTINE struct like a good provider
        if (NULL == m_proctable.NSPCleanup             ||
            NULL == m_proctable.NSPLookupServiceBegin  ||
            NULL == m_proctable.NSPLookupServiceNext   ||
            NULL == m_proctable.NSPLookupServiceEnd    ||
            NULL == m_proctable.NSPSetService          ||
            NULL == m_proctable.NSPInstallServiceClass ||
            NULL == m_proctable.NSPRemoveServiceClass  ||
            NULL == m_proctable.NSPGetServiceClassInfo
            )
        {
            DEBUGF(DBG_ERR,
                   ("Service provider %ls (%8.8x-%4.4x-%4.4x-%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x) returned an invalid procedure table\n",
                    lpszLibFile,
                    lpProviderId->Data1,
                    lpProviderId->Data2,
                    lpProviderId->Data3,
                    lpProviderId->Data4[0],
                    lpProviderId->Data4[1],
                    lpProviderId->Data4[2],
                    lpProviderId->Data4[3],
                    lpProviderId->Data4[4],
                    lpProviderId->Data4[5],
                    lpProviderId->Data4[6],
                    lpProviderId->Data4[7]));
            ReturnCode = WSAEINVALIDPROCTABLE;
            TRY_THROW(guard_memalloc);
        } //if
        if (m_proctable.cbSize < sizeof(NSP_ROUTINE)) {
            //
            // Older provider, does not suport NSPIoctl
            //
            m_proctable.NSPIoctl = NULL;
        } else {
            if (m_proctable.NSPIoctl == NULL) {
                DEBUGF(DBG_ERR,
                       ("New service provider %ls (%8.8x-%4.4x-%4.4x-%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x) returned an invalid procedure table\n",
                        lpszLibFile,
                        lpProviderId->Data1,
                        lpProviderId->Data2,
                        lpProviderId->Data3,
                        lpProviderId->Data4[0],
                        lpProviderId->Data4[1],
                        lpProviderId->Data4[2],
                        lpProviderId->Data4[3],
                        lpProviderId->Data4[4],
                        lpProviderId->Data4[5],
                        lpProviderId->Data4[6],
                        lpProviderId->Data4[7]));
                ReturnCode = WSAEINVALIDPROCTABLE;
                TRY_THROW(guard_memalloc);
            }
        }
        m_provider_id = *lpProviderId;
        return(ERROR_SUCCESS);
    }
    TRY_CATCH(guard_memalloc) {
        // Cleanup
        if (m_library_handle!=NULL) {
            FreeLibrary (m_library_handle);
            m_library_handle = NULL;
        }
#ifdef DEBUG_TRACING
        if (m_library_name!=NULL) {
            delete m_library_name;
            m_library_name = NULL;
        }
#endif
        return ReturnCode;
    } TRY_END(guard_memalloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\perthrd.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    perthrd.c

Abstract:

    This module contains the winsock API functions that query and set
    per thread information contained in winsock DLL. The following
    functions are contained in this module.

    WSAGetLastError()
    WSASetLastError()

Author:

    Dirk Brandewie dirk@mink.intel.com  14-06-1995

[Environment:]

[Notes:]

Revision History:


--*/

#include "precomp.h"


int WSAAPI
WSAGetLastError(
    IN void
    )
/*++
Routine Description:

    Get the error status for the last operation which failed.

Arguments:

    NONE

Returns:
    The return value indicates the error code for the last failed WinSock
    routine performed by this thread.

--*/
{
    return(GetLastError());
}




void WSAAPI
WSASetLastError(
    IN int iError
    )
/*++
Routine Description:

    Set the error code which can be retrieved by WSAGetLastError().

Arguments:

    iError - Specifies the error code to be returned by a subsequent
             WSAGetLastError() call.

Returns:
    NONE

--*/
{
    SetLastError(iError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\qos.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    qos.c

Abstract:

    This modules contains the quality of service related entrypoints
    from the winsock API.  This module contains the following functions.

    WSAGetQosByName()


Author:

    Dirk Brandewie dirk@mink.intel.com  14-06-1995

Revision History:


--*/

#include "precomp.h"


BOOL WSAAPI
WSAGetQOSByName(
                SOCKET s,
                LPWSABUF lpQOSName,
                LPQOS lpQOS
                )
/*++
Routine Description:

     Initializes the QOS based on a template.

Arguments:

    s - A descriptor identifying a socket.

    lpQOSName - Specifies the QOS template name.

    lpQOS - A pointer to the QOS structure to be filled.

Returns:
    If the function succeeds, the return value is TRUE.  If the
    function fails, the return value is FALSE.
--*/
{
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDSOCKET            Socket;
    BOOL                ReturnValue;


    ErrorCode = TURBO_PROLOG();
    if (ErrorCode==ERROR_SUCCESS) {

        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPGetQOSByName( s,
                                       lpQOSName,
                                       lpQOS,
                                       &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\qshelpr.cpp ===
/*++

    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.

Module Name:

    qshelpr.cpp

Abstract:

    Helper functions for managing the WSAQUERYSET data structure.  The external
    entry points exported by this module are the following:

    WSAComputeQuerySetSizeA()
    WSAComputeQuerySetSizeW()
    WSABuildQuerySetBufferA()
    WSABuildQuerySetBufferW()

Author:

    Paul Drews (drewsxpa@ashland.intel.com) 11-Jan-1996

Revision History:

    most-recent-revision-date email-name
        description

    11-Jan-1996  drewsxpa@ashland.intel.com
        created

--*/


#include "precomp.h"

#ifdef _WIN64
#pragma warning (push)
#pragma warning (disable:4267)
#endif

//
//  Implementation Note:
//
//  It is important that these sizing routines be accurate and NOT throw
//  in random pads.
//  Here's the problem:
//      - the real work of WSALookupServiceNext() is done in unicode
//      and that ANSI call just translates the results
//      - WSALookupServiceNextA() called without a result buffer calls
//      WSALookupServiceNextW() without a result buffer and gets only
//      the size required for unicode results;  this unicode buffer size
//      is in all cases sufficient for the ANSI structure (which can only
//      be the same size or smaller)
//      - WSALookupServiceNextA() returns the unicode buffer size (plus small
//      pad) to the application
//      - the app then calls again with the requested buffer size
//      - WLSNextA calls WLSNextW() which returns the results
//      - WLSNextA then calls MapUnicodeQuerySetToAnsi() (below) to
//      convert the results to ANSI
//      - now if the sizing routines throw in random pads to the required
//      length, they may well determine that the required ANSI buffer size
//      is LARGER than the buffer the application provided and the copy
//      fails -- even though the buffer in fact is sufficient
//
//  This is in fact what happened with the original implementation.
//  It had numerous sloppy sizings of the form:
//      <compute size> + 3
//          later changed to
//      (sizeof(DWORD) - 1)
//
//  As soon as the number of addresses returned reached a certain number,
//  these unnecessary pads became larger than the fudge added to the
//  unicode buffer size when WSALookupServiceNextA() returned a required
//  size to the application.   Apps passed in the requested size and still
//  got a WSAEFAULT and another requested LARGER size.  But, even calling
//  down with a larger buffer doesn't work because the WSALookupServiceNextW()
//  call thought the call was successful, so a recall will get WSA_E_NO_MORE.
//
//  Bottom Line:  no unnecessary padding, the sizing must be correct
//

//
//  Rounding routines that don't unnecessarily pad
//

#define ROUND_TO_PTR(c)     ( ((c) + (sizeof(PVOID) - 1)) & ~(sizeof(PVOID)-1) ) 
#define ROUND_TO_DWORD(c)   ( ((c) + 3) & ~3 )
#define ROUND_TO_WORD(c)    ( ((c) + 1) & ~1 )
#define ROUND_TO_WCHAR(c)   ( ((c) + 1) & ~1 )


//
//  Define ASSERT
//

#define ASSERT( e )     assert( e )





static
INT
ComputeAddrInfoArraySize(
    IN      DWORD           dwNumAddrs,
    IN      PCSADDR_INFO    pCsAddrBuf
    )
/*++

Routine Description:

    This procedure computes the required size, in bytes, of a buffer to hold
    the indicated array of CSADDR_INFO structures if it were packed into a
    single buffer.

Arguments:

    dwNumAddrs - Supplies the number of CSADDR_INFO structures in the array.

    lpAddrBuf  - Supplies the array of CSADDR_INFO structures. These
                 structures in turn  may be organized as separately-allocated
                 pieces or as a single packed buffer.

Return Value:

    Required size, in bytes, of the packed buffer to hold this array
    of CSADDRs.

--*/
{
    INT     size;
    DWORD   i;

    //
    //  size
    //      - size of CSADDR array
    //      - size of sockaddrs for all CSADDRs in array
    //
    //  note that building function aligns each sockaddr on PTR boundary,
    //  so this sizing function must also
    //  

    size = dwNumAddrs * sizeof(CSADDR_INFO);

    for ( i = 0; i < dwNumAddrs; i++ )
    {
        PCSADDR_INFO paddr = &pCsAddrBuf[i];

        if ( paddr->LocalAddr.lpSockaddr )
        {
            size = ROUND_TO_PTR( size );
            size += paddr->LocalAddr.iSockaddrLength;
        }
    
        if ( paddr->RemoteAddr.lpSockaddr )
        {
            size = ROUND_TO_PTR( size );
            size += paddr->RemoteAddr.iSockaddrLength;
        }
    }

    return( size );

} // ComputeAddrInfoArraySize



static
INT
ComputeBlobSize(
    IN      LPBLOB          pBlob
    )
/*++

Routine Description:

    Computes size required to hold blob in packed buffer.

Arguments:

    pBlob - Ptr to BLOB.

Return Value:

    Required size, in bytes, of the packed buffer to hold this blob.

--*/
{
    INT size;

    size = sizeof(BLOB);

    if ( pBlob->pBlobData )
    {
        size += pBlob->cbSize;
    }

    return( size );

} // ComputeBlobSize



INT
static
StringSize(
    IN      PSTR            pString,
    IN      BOOL            fUnicode
    )
/*++

Routine Description:

    Get size of string in bytes.

    Utility to avoid dual code for sizing unicode\ANSI structures
    with imbedded strings.

Arguments:

    pString -- string to size

    fUnicode -- TRUE if string unicode
                FALSE for single byte representation

Return Value:

    Size of string in bytes including terminating NULL.

--*/
{
    if ( !pString )
    {
        return( 0 );
    }

    if ( fUnicode )
    {
        return( (wcslen((PWSTR)pString) + 1) * sizeof(WCHAR) );
    }
    else
    {
        return( strlen(pString) + 1 );
    }
}



INT
WSAAPI
ComputeQuerySetSize(
    IN      PWSAQUERYSETA   pQuerySet,
    IN      BOOL            fUnicode
    )
/*++

Routine Description:

    Get required size to hold query set in packed buffer.

    Utility to size query set independent of its unicode\ANSI character.
    This routine is called by specific routine for unicode\ANSI versions
    with the fUnicode flag set appropriately.

Arguments:

    pQuerySet - ptr to query set to compute required buffer size for

Return Value:

    Required size in bytes of packed buffer to hold pQuerySet.

--*/
{
    INT size;

    //
    //  note:  sizing must account for alignment in building
    //
    //  where build function aligns a field with TakeSpaceDWORD_PTR()
    //  then sizing here for that field must round up size to nearest
    //  DWORD_PTR
    //

    //
    //  basic structure -- size is the same unicode or ANSI
    //

    size = sizeof(WSAQUERYSETW);

    // DWORD        dwSize;
    // no further action required

    // LPSTR        lpszServiceInstanceName;

    if ( pQuerySet->lpszServiceInstanceName )
    {
        if ( fUnicode )
        {
            size = ROUND_TO_WCHAR( size );
        }
        size += StringSize( pQuerySet->lpszServiceInstanceName, fUnicode );
    }

    // LPGUID       lpServiceClassId;
    if ( pQuerySet->lpServiceClassId )
    {
        size = ROUND_TO_PTR( size );
        size += sizeof(GUID);
    }

    // LPWSAVERSION     lpVersion;
    if ( pQuerySet->lpVersion )
    {
        size = ROUND_TO_PTR( size );
        size += sizeof(WSAVERSION);
    }

    // LPSTR        lpszComment;
    if ( pQuerySet->lpszComment )
    {
        if ( fUnicode )
        {
            size = ROUND_TO_WCHAR( size );
        }
        size += StringSize( pQuerySet->lpszComment, fUnicode );
    }

    // DWORD        dwNameSpace;
    // no further action required

    // LPGUID       lpNSProviderId;
    if ( pQuerySet->lpNSProviderId )
    {
        size = ROUND_TO_PTR( size );
        size += sizeof(GUID);
    }

    // LPSTR        lpszContext;
    if (pQuerySet->lpszContext )
    {
        if ( fUnicode )
        {
            size = ROUND_TO_WCHAR( size );
        }
        size += StringSize( pQuerySet->lpszContext, fUnicode );
    }

    // LPSTR        lpszQueryString;
    if ( pQuerySet->lpszQueryString )
    {
        if ( fUnicode )
        {
            size = ROUND_TO_WCHAR( size );
        }
        size += StringSize( pQuerySet->lpszQueryString, fUnicode );
    }

    // DWORD        dwNumberOfProtocols;
    // no further action required

    // LPAFPROTOCOLS    lpafpProtocols;
    if ( pQuerySet->lpafpProtocols )
    {
        size = ROUND_TO_PTR( size );
        size += ( sizeof(AFPROTOCOLS) * pQuerySet->dwNumberOfProtocols );
    }

    // DWORD           dwNumberOfCsAddrs;
    // no further action required

    // PCSADDR_INFO    lpcsaBuffer;
    if ( pQuerySet->lpcsaBuffer )
    {
        size = ROUND_TO_PTR( size );
        size += ComputeAddrInfoArraySize(
                    pQuerySet->dwNumberOfCsAddrs,
                    pQuerySet->lpcsaBuffer );
    }

    // LPBLOB          lpBlob;
    if ( pQuerySet->lpBlob )
    {
        size = ROUND_TO_PTR( size );
        size += ComputeBlobSize( pQuerySet->lpBlob );
    }

    return( size );

} // ComputeQuerySetSize



INT
WSAAPI
WSAComputeQuerySetSizeA(
    IN      PWSAQUERYSETA  pQuerySet
    )
/*++

Routine Description:

    Get required size to hold query set in packed buffer.

Arguments:

    pQuerySet - ptr to query set to compute required buffer size for

Return Value:

    Required size in bytes of packed buffer to hold pQuerySet.

--*/
{
    return  ComputeQuerySetSize(
                pQuerySet,
                FALSE       // not unicode
                );

#if 0
    //
    //  here's the code prior to my change for reference (jamesg)
    //

    INT size;

    size = sizeof(WSAQUERYSETA);

    // DWORD           dwSize;
    // no further action required

    // LPSTR            lpszServiceInstanceName;
    if (pQuerySet->lpszServiceInstanceName != NULL) {
        size += lstrlen(pQuerySet->lpszServiceInstanceName)
            + sizeof(DWORD_PTR);
    }

    // LPGUID          lpServiceClassId;
    if (pQuerySet->lpServiceClassId != NULL) {
        size += sizeof(GUID) + (sizeof(DWORD_PTR) -1);
    }

    // LPWSAVERSION      lpVersion;
    if (pQuerySet->lpVersion != NULL) {
        size += sizeof(WSAVERSION) + (sizeof(DWORD_PTR) -1);
    }

    // LPSTR             lpszComment;
    if (pQuerySet->lpszComment != NULL) {
        size += lstrlen(pQuerySet->lpszComment)
            + sizeof(DWORD_PTR);
    }

    // DWORD           dwNameSpace;
    // no further action required

    // LPGUID          lpNSProviderId;
    if (pQuerySet->lpNSProviderId != NULL) {
        size += sizeof(GUID) + (sizeof(DWORD_PTR) -1);
    }

    // LPSTR             lpszContext;
    if (pQuerySet->lpszContext != NULL) {
        size += lstrlen(pQuerySet->lpszContext)
            + sizeof(DWORD_PTR);
    }

    // LPSTR             lpszQueryString;
    if (pQuerySet->lpszQueryString != NULL) {
        size += lstrlen(pQuerySet->lpszQueryString)
            + sizeof(DWORD_PTR);
    }

    // DWORD           dwNumberOfProtocols;
    // no further action required

    // LPAFPROTOCOLS   lpafpProtocols;
    if (pQuerySet->lpafpProtocols != NULL) {
        size += sizeof(AFPROTOCOLS) *
            pQuerySet->dwNumberOfProtocols + (sizeof(DWORD_PTR) -1);
    }

    // DWORD           dwNumberOfCsAddrs;
    // no further action required

    // PCSADDR_INFO    lpcsaBuffer;
    if (pQuerySet->lpcsaBuffer != NULL) {
        size += ComputeAddrInfoArraySize(
            pQuerySet->dwNumberOfCsAddrs,   // dwNumAddrs
            pQuerySet->lpcsaBuffer) + (sizeof(DWORD_PTR) -1);        // lpAddrBuf
    }

    // LPBLOB          lpBlob;
    if (pQuerySet->lpBlob != NULL) {
        size += ComputeBlobSize(
            pQuerySet->lpBlob) + (sizeof(DWORD_PTR) -1);
    }

    return(size);
#endif

} // WSAComputeQuerySetSizeA



INT
WSAAPI
WSAComputeQuerySetSizeW(
    IN      PWSAQUERYSETW  pQuerySet
    )
/*++

Routine Description:

    Get required size to hold query set in packed buffer.

Arguments:

    pQuerySet - ptr to query set to compute required buffer size for

Return Value:

    Required size in bytes of packed buffer to hold pQuerySet.

--*/
{
    return  ComputeQuerySetSize(
                (PWSAQUERYSETA) pQuerySet,
                TRUE        // unicode query set
                );

#if 0
    //
    //  here's the code prior to my change for reference (jamesg)
    //

    INT size;

    size = sizeof(WSAQUERYSETW);

    // DWORD           dwSize;
    // no further action required

    // PWSTR             lpszServiceInstanceName;

    if (pQuerySet->lpszServiceInstanceName != NULL)
    {
        size += (wcslen(pQuerySet->lpszServiceInstanceName)
                    + 1) * sizeof(WCHAR);
        size += (sizeof(DWORD_PTR) -1);
    }

    // LPGUID          lpServiceClassId;
    if (pQuerySet->lpServiceClassId != NULL) {
        size += sizeof(GUID) + (sizeof(DWORD_PTR) -1);
    }

    // LPWSAVERSION      lpVersion;
    if (pQuerySet->lpVersion != NULL) {
        size += sizeof(WSAVERSION) + (sizeof(DWORD_PTR) -1);
    }

    // PWSTR              lpszComment;
    if (pQuerySet->lpszComment != NULL) {
        size += (wcslen(pQuerySet->lpszComment)
            + 1) * sizeof(WCHAR);
        size += (sizeof(DWORD_PTR) -1);
    }

    // DWORD           dwNameSpace;
    // no further action required

    // LPGUID          lpNSProviderId;
    if (pQuerySet->lpNSProviderId != NULL) {
        size += sizeof(GUID) + (sizeof(DWORD_PTR) -1);
    }

    // PWSTR              lpszContext;
    if (pQuerySet->lpszContext != NULL) {
        size += (wcslen(pQuerySet->lpszContext)
            + 1) * sizeof(WCHAR);
        size += (sizeof(DWORD_PTR) -1);
    }

    // PWSTR              lpszQueryString;
    if (pQuerySet->lpszQueryString != NULL) {
        size += (wcslen(pQuerySet->lpszQueryString)
            + 1) * sizeof(WCHAR);
        size += (sizeof(DWORD_PTR) -1);
    }

    // DWORD           dwNumberOfProtocols;
    // no further action required

    // LPAFPROTOCOLS   lpafpProtocols;
    if (pQuerySet->lpafpProtocols != NULL) {
        size += sizeof(AFPROTOCOLS) *
            pQuerySet->dwNumberOfProtocols + 2;
    }

    // DWORD           dwNumberOfCsAddrs;
    // no further action required

    // PCSADDR_INFO    lpcsaBuffer;
    if (pQuerySet->lpcsaBuffer != NULL) {
        size += ComputeAddrInfoArraySize(
            pQuerySet->dwNumberOfCsAddrs,   // dwNumAddrs
            pQuerySet->lpcsaBuffer) + 2;        // lpAddrBuf
    }

    // LPBLOB          lpBlob;
    if (pQuerySet->lpBlob != NULL) {
        size += ComputeBlobSize(
            pQuerySet->lpBlob) + 2;
    }

    return(size);
#endif

} // WSAComputeQuerySetSizeW




//
//  Buffer space management class
//
//  Manages the free space at the tail end of a packed WSAQUERYSET
//  buffer as it is being built.
//

class SPACE_MGR
{
public:
    SPACE_MGR(
        IN INT    MaxBytes,
        IN LPVOID Buf
        );

    ~SPACE_MGR(
        );

    LPVOID
    TakeSpaceBYTE(
        IN INT  NumBytes
        );

    LPVOID
    TakeSpaceWORD(
        IN INT  NumBytes
        );

    LPVOID
    TakeSpaceDWORD(
        IN INT  NumBytes
        );

    LPVOID
    TakeSpaceDWORD_PTR(
        IN INT  NumBytes
        );

private:

    LPVOID
    TakeSpace(
        IN INT  NumBytes,
        IN INT  alignment
        );

    INT    m_MaxBytes;
        // The  maximum  number  of bytes that can be used in the entire buffer
        // (i.e., the size of the buffer).

    LPVOID m_Buf;
        // Pointer to the beginning of the buffer.

    INT    m_BytesUsed;
        // The  number  of  bytes that have been allocated out of the buffer so
        // far.

}; // class SPACE_MGR

typedef SPACE_MGR * LPSPACE_MGR;


SPACE_MGR::SPACE_MGR(
    IN      INT             MaxBytes,
    IN      LPVOID          pBuf
    )
/*++

Routine Description:

    Constructor for a SPACE_MGR object.  It initializes
    the object to indicate that zero bytes have so far been consumed.

Arguments:

    MaxBytes - Supplies  the  starting  number of bytes available in the entire
               buffer.

    pBuf     - Supplies the pointer to the beginning of the buffer.

Return Value:

    Implictly Returns the pointer to the newly allocated SPACE_MGR object.

--*/
{
    m_MaxBytes  = MaxBytes;
    m_Buf       = pBuf;
    m_BytesUsed = 0;
}  // SPACE_MGR::SPACE_MGR




SPACE_MGR::~SPACE_MGR(
    VOID
    )
/*++

Routine Description:

    Destructor for the SPACE_MGR object.

    Note that it is the caller's responsibility to deallocate the
    actual buffer as appropriate.

Arguments:

    None

Return Value:

    None

--*/
{
    m_Buf = NULL;
}  // SPACE_MGR::~SPACE_MGR

inline
LPVOID
SPACE_MGR::TakeSpaceBYTE(
    IN INT  NumBytes
    )
{
    return(TakeSpace(NumBytes, 1));
}

inline
LPVOID
SPACE_MGR::TakeSpaceWORD(
    IN INT  NumBytes
    )
{
    return(TakeSpace(NumBytes, 2));
}

inline
LPVOID
SPACE_MGR::TakeSpaceDWORD(
    IN INT  NumBytes
    )
{
    return(TakeSpace(NumBytes, 4));
}

inline
LPVOID
SPACE_MGR::TakeSpaceDWORD_PTR(
    IN INT NumBytes
    )
{
    return(TakeSpace(NumBytes, sizeof(ULONG_PTR)));
}



LPVOID
SPACE_MGR::TakeSpace(
    IN      INT             NumBytes,
    IN      INT             Align
    )
/*++
Routine Description:

    This  procedure  allocates  the  indicated number of bytes from the buffer,
    returning a pointer to the beginning of the allocated space.  The procedure
    assumes  that  the  caller  does not attempt to allocate more space than is
    available, although it does an internal consistency check.

    Pre-alignment of the buffer is made based on the value of align.

Arguments:

    NumBytes - Supplies the number of bytes to be allocated from the buffer.

    Align - number of bytes to align to

Return Value:

    Pointer to next aligned-by-Align byte in buffer free space.

--*/
{
    LPVOID  return_value;
    PCHAR   charbuf;

    //
    //  align
    //      - bring bytes used up to next multiple of alignment value
    //      - note alignment must be an integral power of 2
    //

    m_BytesUsed = (m_BytesUsed + Align - 1) & ~(Align - 1);

    ASSERT( (NumBytes + m_BytesUsed) <= m_MaxBytes );

    charbuf = (PCHAR) m_Buf;
    return_value = (LPVOID) & charbuf[m_BytesUsed];
    m_BytesUsed += NumBytes;

    return(return_value);

}  // SPACE_MGR::TakeSpace




//
//  WSAQUERYSET copy routines
//

static
PWSAQUERYSETA
CopyQuerySetDirectA(
    IN OUT  LPSPACE_MGR     SpaceMgr,
    IN      PWSAQUERYSETA   Source
    )
/*++
Routine Description:

    This  procedure copies the "direct" portion of the indicated PWSAQUERYSETA
    structure  into  the  managed buffer.  Pointer values in the direct portion
    are  copied,  however  no  "deep" copy is done of the objects referenced by
    those pointers.

Arguments:

    SpaceMgr - Supplies  the  starting  buffer  allocation  state.  Returns the
               resulting buffer allocation state.

    Source   - Supplies the source data to be copied.

Return Value:

    The  function returns a pointer to the beginning of the newly copied target
    values.   This  value  is  typically  used  as the "Target" in a subsequent
    CopyQuerySetIndirectA.
--*/
{
    PWSAQUERYSETA  Target;

    Target = (PWSAQUERYSETA) SpaceMgr->TakeSpaceDWORD_PTR(
                                            sizeof(WSAQUERYSETA));
    *Target = *Source;

    return(Target);

} // CopyQuerySetDirectA



LPBLOB
CopyBlobDirect(
    IN OUT  LPSPACE_MGR     SpaceMgr,
    IN      LPBLOB          Source
    )
/*++
Routine Description:

    This  procedure  copies  the  "direct"  portion  of  the  indicated  LPBLOB
    structure  into  the  managed buffer.  Pointer values in the direct portion
    are  copied,  however  no  "deep" copy is done of the objects referenced by
    those pointers.

Arguments:

    SpaceMgr - Supplies  the  starting  buffer  allocation  state.  Returns the
               resulting buffer allocation state.

    Source   - Supplies the source data to be copied.

Return Value:

    The  function returns a pointer to the beginning of the newly copied target
    values.   This  value  is  typically  used  as the "Target" in a subsequent
    CopyBlobIndirect.
--*/
{
    LPBLOB Target;

    Target = (LPBLOB) SpaceMgr->TakeSpaceDWORD_PTR( sizeof(BLOB) );
    *Target = *Source;

    return(Target);

} // CopyBlobDirect




VOID
CopyBlobIndirect(
    IN OUT  LPSPACE_MGR     SpaceMgr,
    IN OUT  LPBLOB          Target,
    IN      LPBLOB          Source
    )
/*++
Routine Description:

    This  procedure  does  a  full-depth copy of the "indirect" portions of the
    indicated LPBLOB structure into the managed buffer.  Space for the indirect
    portions  is  allocated  from  the  managed  buffer.  Pointer values in the
    "direct"  portion  of the target LPBLOB structure are updated to point into
    the managed buffer at the correct location.

Arguments:

    SpaceMgr - Supplies  the  starting  buffer  allocation  state.  Returns the
               resulting buffer allocation state.

    Target   - Supplies  the  starting values of the "direct" portion.  Returns
               the "direct" portion values with all pointers updated.

    Source   - Supplies the source data to be copied.

Return Value:

    none
--*/
{
    if ((Source->pBlobData != NULL) &&
        (Source->cbSize != 0))
    {
        Target->pBlobData = (BYTE *) SpaceMgr->TakeSpaceDWORD_PTR(
                                                        Source->cbSize);
        CopyMemory(
            (PVOID) Target->pBlobData,
            (PVOID) Source->pBlobData,
            Source->cbSize );
    }
    else
    {
        //  force the buffer to be well-formed
        Target->pBlobData = NULL;
        Target->cbSize = 0;
    }

} // CopyBlobIndirect



static
PCSADDR_INFO 
CopyAddrInfoArrayDirect(
    IN OUT  LPSPACE_MGR     SpaceMgr,
    IN      DWORD           NumAddrs,
    IN      PCSADDR_INFO    Source
    )
/*++
Routine Description:

    This  procedure  copies the "direct" portion of the indicated PCSADDR_INFO 
    array  into  the  managed buffer.  Pointer values in the direct portion are
    copied,  however  no "deep" copy is done of the objects referenced by those
    pointers.

Arguments:

    SpaceMgr - Supplies  the  starting  buffer  allocation  state.  Returns the
               resulting buffer allocation state.

    NumAddrs - Supplies the number of CSADDR_INFO structures in the array to be
               copied.

    Source   - Supplies the source data to be copied.

Return Value:

    The  function returns a pointer to the beginning of the newly copied target
    values.   This  value  is  typically  used  as the "Target" in a subsequent
    CopyAddrInfoArrayIndirect.
--*/
{
    PCSADDR_INFO   Target;

    Target = (PCSADDR_INFO ) SpaceMgr->TakeSpaceDWORD_PTR(
                                    NumAddrs * sizeof(CSADDR_INFO));
    CopyMemory(
        (PVOID) Target,
        (PVOID) Source,
        NumAddrs * sizeof(CSADDR_INFO));

    return(Target);

} // CopyAddrInfoArrayDirect



static
VOID
CopyAddrInfoArrayIndirect(
    IN OUT  LPSPACE_MGR     SpaceMgr,
    IN OUT  PCSADDR_INFO    Target,
    IN      DWORD           NumAddrs,
    IN      PCSADDR_INFO    Source
    )
/*++
Routine Description:

    This  procedure  does  a  full-depth copy of the "indirect" portions of the
    indicated  PCSADDR_INFO   array  into  the  managed  buffer.  Space for the
    indirect  portions is allocated from the managed buffer.  Pointer values in
    the "direct" portion of the target PCSADDR_INFO  array are updated to point
    into the managed buffer at the correct location.

Arguments:

    SpaceMgr - Supplies  the  starting  buffer  allocation  state.  Returns the
               resulting buffer allocation state.

    Target   - Supplies  the  starting values of the "direct" portion.  Returns
               the "direct" portion values with all pointers updated.

    NumAddrs - Supplies the number of CSADDR_INFO structures in the array to be
               copied.

    Source   - Supplies the source data to be copied.

Return Value:

    none
--*/
{
    DWORD i;

    for (i = 0; i < NumAddrs; i++) {
        // SOCKET_ADDRESS LocalAddr ;
        if ((Source[i].LocalAddr.lpSockaddr != NULL) &&
            (Source[i].LocalAddr.iSockaddrLength != 0)) {
            Target[i].LocalAddr.lpSockaddr =
                (LPSOCKADDR) SpaceMgr->TakeSpaceDWORD_PTR(
                    Source[i].LocalAddr.iSockaddrLength);
            CopyMemory(
                (PVOID) Target[i].LocalAddr.lpSockaddr,
                (PVOID) Source[i].LocalAddr.lpSockaddr,
                Source[i].LocalAddr.iSockaddrLength);
        }
        else {
            Target[i].LocalAddr.lpSockaddr = NULL;
            // And force the buffer to be well-formed
            Target[i].LocalAddr.iSockaddrLength = 0;
        }

        // SOCKET_ADDRESS RemoteAddr ;
        if ((Source[i].RemoteAddr.lpSockaddr != NULL) &&
            (Source[i].RemoteAddr.iSockaddrLength != 0)) {
            Target[i].RemoteAddr.lpSockaddr =
                (LPSOCKADDR) SpaceMgr->TakeSpaceDWORD_PTR(
                     Source[i].RemoteAddr.iSockaddrLength);
            CopyMemory(
                (PVOID) Target[i].RemoteAddr.lpSockaddr,
                (PVOID) Source[i].RemoteAddr.lpSockaddr,
                Source[i].RemoteAddr.iSockaddrLength);
        }
        else {
            Target[i].RemoteAddr.lpSockaddr = NULL;
            // And force the buffer to be well-formed
            Target[i].RemoteAddr.iSockaddrLength = 0;
        }

        // INT iSocketType ;
        // no action required

        // INT iProtocol ;
        // no action required

    } // for i

} // CopyAddrInfoArrayIndirect



static
VOID
CopyQuerySetIndirectA(
    IN OUT  LPSPACE_MGR     SpaceMgr,
    IN OUT  PWSAQUERYSETA  Target,
    IN      PWSAQUERYSETA  Source
    )
/*++
Routine Description:

    This  procedure  does  a  full-depth copy of the "indirect" portions of the
    indicated  PWSAQUERYSETA structure into the managed buffer.  Space for the
    indirect  portions is allocated from the managed buffer.  Pointer values in
    the  "direct" portion of the target PWSAQUERYSETA structure are updated to
    point into the managed buffer at the correct location.

Arguments:

    SpaceMgr - Supplies  the  starting  buffer  allocation  state.  Returns the
               resulting buffer allocation state.

    Target   - Supplies  the  starting values of the "direct" portion.  Returns
               the "direct" portion values with all pointers updated.

    Source   - Supplies the source data to be copied.

Return Value:

    none
--*/
{

    // DWORD           dwSize;
    // no action required

    // LPSTR            lpszServiceInstanceName;
    if (Source->lpszServiceInstanceName != NULL) {
        Target->lpszServiceInstanceName = (LPSTR) SpaceMgr->TakeSpaceBYTE(
            lstrlen(Source->lpszServiceInstanceName) + 1);
        lstrcpy(
            Target->lpszServiceInstanceName,
            Source->lpszServiceInstanceName);
    }
    else {
        Target->lpszServiceInstanceName = NULL;
    }

    // LPGUID          lpServiceClassId;
    if (Source->lpServiceClassId != NULL) {
        Target->lpServiceClassId = (LPGUID) SpaceMgr->TakeSpaceDWORD_PTR(
            sizeof(GUID));
        *(Target->lpServiceClassId) = *(Source->lpServiceClassId);
    }
    else {
        Target->lpServiceClassId = NULL;
    }

    // LPWSAVERSION      lpVersion;
    if (Source->lpVersion != NULL) {
        Target->lpVersion = (LPWSAVERSION) SpaceMgr->TakeSpaceDWORD_PTR(
            sizeof(WSAVERSION));
        *(Target->lpVersion) = *(Source->lpVersion);
    }
    else {
        Target->lpVersion = NULL;
    }

    // LPSTR             lpszComment;
    if (Source->lpszComment != NULL) {
        Target->lpszComment = (LPSTR) SpaceMgr->TakeSpaceBYTE(
            lstrlen(Source->lpszComment) + 1);
        lstrcpy(
            Target->lpszComment,
            Source->lpszComment);
    }
    else {
        Target->lpszComment = NULL;
    }

    // DWORD           dwNameSpace;
    // no action required

    // LPGUID          lpNSProviderId;
    if (Source->lpNSProviderId != NULL) {
        Target->lpNSProviderId = (LPGUID) SpaceMgr->TakeSpaceDWORD_PTR(
            sizeof(GUID));
        *(Target->lpNSProviderId) = *(Source->lpNSProviderId);
    }
    else {
        Target->lpNSProviderId = NULL;
    }

    // LPSTR             lpszContext;
    if (Source->lpszContext != NULL) {
        Target->lpszContext = (LPSTR) SpaceMgr->TakeSpaceBYTE(
            lstrlen(Source->lpszContext) + 1);
        lstrcpy(
            Target->lpszContext,
            Source->lpszContext);
    }
    else {
        Target->lpszContext = NULL;
    }

    // LPSTR             lpszQueryString;
    if (Source->lpszQueryString != NULL) {
        Target->lpszQueryString = (LPSTR) SpaceMgr->TakeSpaceBYTE(
            lstrlen(Source->lpszQueryString) + 1);
        lstrcpy(
            Target->lpszQueryString,
            Source->lpszQueryString);
    }
    else {
        Target->lpszQueryString = NULL;
    }

    // DWORD           dwNumberOfProtocols;
    // no action required

    // LPAFPROTOCOLS   lpafpProtocols;
    if ((Source->lpafpProtocols != NULL) &&
        (Source->dwNumberOfProtocols != 0)) {
        Target->lpafpProtocols = (LPAFPROTOCOLS) SpaceMgr->TakeSpaceDWORD_PTR(
            Source->dwNumberOfProtocols * sizeof(AFPROTOCOLS));
        CopyMemory (
            (PVOID) Target->lpafpProtocols,
            (PVOID) Source->lpafpProtocols,
            Source->dwNumberOfProtocols * sizeof(AFPROTOCOLS));
    }
    else {
        Target->lpafpProtocols = NULL;
        // And force the target buffer to be well-formed
        Target->dwNumberOfProtocols = 0;
    }

    // DWORD           dwNumberOfCsAddrs;
    // no action required

    // PCSADDR_INFO    lpcsaBuffer;
    if ((Source->lpcsaBuffer != NULL) &&
        (Source->dwNumberOfCsAddrs != 0)) {
        Target->lpcsaBuffer = CopyAddrInfoArrayDirect(
            SpaceMgr,
            Source->dwNumberOfCsAddrs,
            Source->lpcsaBuffer);
        CopyAddrInfoArrayIndirect(
            SpaceMgr,
            Target->lpcsaBuffer,
            Source->dwNumberOfCsAddrs,
            Source->lpcsaBuffer);
    }
    else {
        Target->lpcsaBuffer = NULL;
        // And force the target buffer to be well-formed
        Target->dwNumberOfCsAddrs = 0;
    }

    // LPBLOB          lpBlob;
    if (Source->lpBlob != NULL) {
        Target->lpBlob = CopyBlobDirect(
            SpaceMgr,
            Source->lpBlob);
        CopyBlobIndirect(
            SpaceMgr,
            Target->lpBlob,
            Source->lpBlob);
    }
    else {
        Target->lpBlob = NULL;
    }

} // CopyQuerySetIndirectA




INT
WSAAPI
WSABuildQuerySetBufferA(
    IN      PWSAQUERYSETA  pQuerySet,
    IN      DWORD           dwPackedQuerySetSize,
    OUT     PWSAQUERYSETA  lpPackedQuerySet
    )
/*++
Routine Description:

    This  procedure  copies  a  source  WSAQUERYSET  into  a target WSAQUERYSET
    buffer.  The target WSAQUERYSET buffer is assembled in "packed" form.  That
    is,  all  pointers  in  the  WSAQUERYSET  are  to locations within the same
    supplied buffer.

Arguments:

    pQuerySet     - Supplies  the  source  query set to be copied to the
                           target  buffer.   The  supplied  query  set  may  be
                           organized  as  separately-allocated  pieces  or as a
                           single packed buffer.

    dwPackedQuerySetSize - Supplies the size, in bytes, of the target query set
                           buffer.

    lpPackedQuerySet     - Returns the packed copied query set.

Return Value:

    ERROR_SUCCESS - The function succeeded.

    SOCKET_ERROR  - The function failed.  A specific error code can be obtained
                    from WSAGetLastError().

Implementation Notes:

    If (target buffer is big enough) then
        space_mgr = new buffer_space_manager(...);
        start_direct = CopyQuerySetDirectA(
            space_mgr,
            (LPVOID) pQuerySet);
        CopyQuerySetIndirectA(
            space_mgr,
            start_direct,
            pQuerySet);
        delete space_mgr;
        result = ERROR_SUCCESS;
    else
        result = SOCKET_ERROR;
    endif

--*/
{
    INT          return_value;
    INT          space_required;
    BOOL         ok_to_continue;

    ok_to_continue = TRUE;

    space_required = WSAComputeQuerySetSizeA( pQuerySet );

    if ((DWORD) space_required > dwPackedQuerySetSize) {
        SetLastError(WSAEFAULT);
        ok_to_continue = FALSE;
    }

    SPACE_MGR    space_mgr(
        dwPackedQuerySetSize,
        lpPackedQuerySet);

    if (ok_to_continue) {
        PWSAQUERYSETA  Target;
        Target = CopyQuerySetDirectA(
            & space_mgr,        // SpaceMgr
            pQuerySet);  // Source
        CopyQuerySetIndirectA(
            & space_mgr,        // SpaceMgr
            Target,             // Target
            pQuerySet);  // Source
    }

    if (ok_to_continue) {
        return_value = ERROR_SUCCESS;
    }
    else {
        return_value = SOCKET_ERROR;
    }
    return(return_value);

} // WSABuildQuerySetBufferA




static
PWSAQUERYSETW
CopyQuerySetDirectW(
    IN OUT  LPSPACE_MGR     SpaceMgr,
    IN      PWSAQUERYSETW  Source
    )
/*++
Routine Description:

    This  procedure copies the "direct" portion of the indicated PWSAQUERYSETW
    structure  into  the  managed buffer.  Pointer values in the direct portion
    are  copied,  however  no  "deep" copy is done of the objects referenced by
    those pointers.

Arguments:

    SpaceMgr - Supplies  the  starting  buffer  allocation  state.  Returns the
               resulting buffer allocation state.

    Source   - Supplies the source data to be copied.

Return Value:

    The  function returns a pointer to the beginning of the newly copied target
    values.   This  value  is  typically  used  as the "Target" in a subsequent
    CopyQuerySetIndirectW.
--*/
{
    PWSAQUERYSETW  Target;

    Target = (PWSAQUERYSETW) SpaceMgr->TakeSpaceDWORD_PTR(
        sizeof(WSAQUERYSETW));
    *Target = *Source;

    return(Target);

} // CopyQuerySetDirectW




VOID
CopyQuerySetIndirectW(
    IN OUT  LPSPACE_MGR     SpaceMgr,
    IN OUT  PWSAQUERYSETW  Target,
    IN      PWSAQUERYSETW  Source
    )
/*++
Routine Description:

    This  procedure  does  a  full-depth copy of the "indirect" portions of the
    indicated  PWSAQUERYSETW structure into the managed buffer.  Space for the
    indirect  portions is allocated from the managed buffer.  Pointer values in
    the  "direct" portion of the target PWSAQUERYSETW structure are updated to
    point into the managed buffer at the correct location.

Arguments:

    SpaceMgr - Supplies  the  starting  buffer  allocation  state.  Returns the
               resulting buffer allocation state.

    Target   - Supplies  the  starting values of the "direct" portion.  Returns
               the "direct" portion values with all pointers updated.

    Source   - Supplies the source data to be copied.

Return Value:

    none
--*/
{

    // DWORD           dwSize;
    // no action required

    // PWSTR             lpszServiceInstanceName;
    if (Source->lpszServiceInstanceName != NULL) {
        Target->lpszServiceInstanceName = (PWSTR ) SpaceMgr->TakeSpaceWORD(
            (wcslen(Source->lpszServiceInstanceName) + 1) * sizeof(WCHAR));
        wcscpy(
            Target->lpszServiceInstanceName,
            Source->lpszServiceInstanceName);
    }
    else {
        Target->lpszServiceInstanceName = NULL;
    }

    // LPGUID          lpServiceClassId;
    if (Source->lpServiceClassId != NULL) {
        Target->lpServiceClassId = (LPGUID) SpaceMgr->TakeSpaceDWORD_PTR(
            sizeof(GUID));
        *(Target->lpServiceClassId) = *(Source->lpServiceClassId);
    }
    else {
        Target->lpServiceClassId = NULL;
    }

    // LPWSAVERSION      lpVersion;
    if (Source->lpVersion != NULL) {
        Target->lpVersion = (LPWSAVERSION) SpaceMgr->TakeSpaceDWORD_PTR(
            sizeof(WSAVERSION));
        *(Target->lpVersion) = *(Source->lpVersion);
    }
    else {
        Target->lpVersion = NULL;
    }

    // PWSTR              lpszComment;
    if (Source->lpszComment != NULL) {
        Target->lpszComment = (PWSTR ) SpaceMgr->TakeSpaceWORD(
            (wcslen(Source->lpszComment) + 1) * sizeof(WCHAR));
        wcscpy(
            Target->lpszComment,
            Source->lpszComment);
    }
    else {
        Target->lpszComment = NULL;
    }

    // DWORD           dwNameSpace;
    // no action required

    // LPGUID          lpNSProviderId;
    if (Source->lpNSProviderId != NULL) {
        Target->lpNSProviderId = (LPGUID) SpaceMgr->TakeSpaceDWORD_PTR(
            sizeof(GUID));
        *(Target->lpNSProviderId) = *(Source->lpNSProviderId);
    }
    else {
        Target->lpNSProviderId = NULL;
    }

    // PWSTR              lpszContext;
    if (Source->lpszContext != NULL) {
        Target->lpszContext = (PWSTR ) SpaceMgr->TakeSpaceWORD(
            (wcslen(Source->lpszContext) + 1) * sizeof(WCHAR));
        wcscpy(
            Target->lpszContext,
            Source->lpszContext);
    }
    else {
        Target->lpszContext = NULL;
    }

    // PWSTR              lpszQueryString;
    if (Source->lpszQueryString != NULL) {
        Target->lpszQueryString = (PWSTR ) SpaceMgr->TakeSpaceWORD(
            (wcslen(Source->lpszQueryString) + 1) * sizeof(WCHAR));
        wcscpy(
            Target->lpszQueryString,
            Source->lpszQueryString);
    }
    else {
        Target->lpszQueryString = NULL;
    }

    // DWORD           dwNumberOfProtocols;
    // no action required

    // LPAFPROTOCOLS   lpafpProtocols;
    if ((Source->lpafpProtocols != NULL) &&
        (Source->dwNumberOfProtocols != 0)) {
        Target->lpafpProtocols = (LPAFPROTOCOLS) SpaceMgr->TakeSpaceDWORD_PTR(
            Source->dwNumberOfProtocols * sizeof(AFPROTOCOLS));
        CopyMemory (
            (PVOID) Target->lpafpProtocols,
            (PVOID) Source->lpafpProtocols,
            Source->dwNumberOfProtocols * sizeof(AFPROTOCOLS));
    }
    else {
        Target->lpafpProtocols = NULL;
        // And force the target buffer to be well-formed
        Target->dwNumberOfProtocols = 0;
    }

    // DWORD           dwNumberOfCsAddrs;
    // no action required

    // PCSADDR_INFO    lpcsaBuffer;
    if ((Source->lpcsaBuffer != NULL) &&
        (Source->dwNumberOfCsAddrs != 0)) {
        Target->lpcsaBuffer = CopyAddrInfoArrayDirect(
            SpaceMgr,
            Source->dwNumberOfCsAddrs,
            Source->lpcsaBuffer);
        CopyAddrInfoArrayIndirect(
            SpaceMgr,
            Target->lpcsaBuffer,
            Source->dwNumberOfCsAddrs,
            Source->lpcsaBuffer);
    }
    else {
        Target->lpcsaBuffer = NULL;
        // And force the target buffer to be well-formed
        Target->dwNumberOfCsAddrs = 0;
    }

    // LPBLOB          lpBlob;
    if (Source->lpBlob != NULL) {
        Target->lpBlob = CopyBlobDirect(
            SpaceMgr,
            Source->lpBlob);
        CopyBlobIndirect(
            SpaceMgr,
            Target->lpBlob,
            Source->lpBlob);
    }
    else {
        Target->lpBlob = NULL;
    }

} // CopyQuerySetIndirectW




INT
WSAAPI
WSABuildQuerySetBufferW(
    IN      PWSAQUERYSETW  pQuerySet,
    IN      DWORD           dwPackedQuerySetSize,
    OUT     PWSAQUERYSETW  lpPackedQuerySet
    )
/*++
Routine Description:

    This  procedure  copies  a  source  WSAQUERYSET  into  a target WSAQUERYSET
    buffer.  The target WSAQUERYSET buffer is assembled in "packed" form.  That
    is,  all  pointers  in  the  WSAQUERYSET  are  to locations within the same
    supplied buffer.

Arguments:

    pQuerySet     - Supplies  the  source  query set to be copied to the
                           target  buffer.   The  supplied  query  set  may  be
                           organized  as  separately-allocated  pieces  or as a
                           single packed buffer.

    dwPackedQuerySetSize - Supplies the size, in bytes, of the target query set
                           buffer.

    lpPackedQuerySet     - Returns the packed copied query set.

Return Value:

    ERROR_SUCCESS - The function succeeded.

    SOCKET_ERROR  - The function failed.  A specific error code can be obtained
                    from WSAGetLastError().
--*/
{
    INT     return_value = ERROR_SUCCESS;
    INT     space_required;
    BOOL    ok_to_continue = TRUE;

    space_required = WSAComputeQuerySetSizeW( pQuerySet );

    if ( (DWORD)space_required > dwPackedQuerySetSize )
    {
        SetLastError( WSAEFAULT );
        ok_to_continue = FALSE;
    }

    SPACE_MGR  space_mgr(
        dwPackedQuerySetSize,
        lpPackedQuerySet );

    if ( ok_to_continue )
    {
        PWSAQUERYSETW  Target;
        Target = CopyQuerySetDirectW(
                    & space_mgr,        // SpaceMgr
                    pQuerySet);  // Source

        CopyQuerySetIndirectW(
            & space_mgr,        // SpaceMgr
            Target,             // Target
            pQuerySet);         // Source
    }

    if (ok_to_continue)
    {
        return_value = ERROR_SUCCESS;
    }
    else
    {
        return_value = SOCKET_ERROR;
    }
    return(return_value);

} // WSABuildQuerySetBufferW




PWSTR 
wcs_dup_from_ansi(
    IN LPSTR  Source
    )
/*++
Routine Description:

    This  procedure  is intended for internal use only within this module since
    it  requires the caller to use the same memory management strategy that the
    procedure uses internally.

    The procedure allocates a Unicode string and initializes it with the string
    converted  from  the  supplied  Ansi  source  string.   It  is the caller's
    responsibility  to  eventually deallocate the returned Unicode string using
    the C++ "delete" operator.

Arguments:

    Source - Supplies the Ansi string to be duplicated into Unicode form.

Return Value:

    The  procedure  returns  the newly allocated and initialized Unicode string
    pointer.   It  caller  must eventually deallocate this string using the C++
    "delete" opertor.  The procedure returns NULL if memory allocation fails.
--*/
{
    INT     len_guess;
    BOOL    still_trying;
    PWSTR   return_string;

    ASSERT( Source != NULL );

    // An  initial guess length of zero is required, since that is the only way
    // we  can coax the conversion fuction to ignore the buffer and tell us the
    // length  required.   Note  that  "length"  is in terms of the destination
    // characters   whatever  byte-width  they  have.   Presumably  the  length
    // returned from a conversion function includes the terminator.

    len_guess = 0;
    still_trying = TRUE;
    return_string = NULL;

    while (still_trying) {
        int  chars_required;

        chars_required = MultiByteToWideChar(
                            CP_ACP,         // CodePage (Ansi)
                            0,              // dwFlags
                            Source,         // lpMultiByteStr
                            -1,             // cchMultiByte
                            return_string,  // lpWideCharStr
                            len_guess );    // cchWideChar

        if (chars_required > len_guess) {
            // retry with new size
            len_guess = chars_required;
            delete return_string;
            return_string = new WCHAR[len_guess];
            if (return_string == NULL) {
                still_trying = FALSE;
            }
        }
        else if (chars_required > 0) {
            // success
            still_trying = FALSE;
        }
        else {
            // utter failure
            delete return_string;
            return_string = NULL;
            still_trying = FALSE;
        }
    }

    return(return_string);

} // wcs_dup_from_ansi




LPSTR
ansi_dup_from_wcs(
    IN PWSTR   Source
    )
/*++
Routine Description:

    This  procedure  is intended for internal use only within this module since
    it  requires the caller to use the same memory management strategy that the
    procedure uses internally.

    The  procedure  allocates an Ansi string and initializes it with the string
    converted  from  the  supplied  Unicode  source string.  It is the caller's
    responsibility  to eventually deallocate the returned Ansi string using the
    C++ "delete" operator.

Arguments:

    Source - Supplies the Unicode string to be duplicated into Ansi form.

Return Value:

    The  procedure  returns  the  newly  allocated  and initialized Ansi string
    pointer.   It  caller  must eventually deallocate this string using the C++
    "delete" opertor.  The procedure returns NULL if memory allocation fails.
--*/
{
    INT     len_guess;
    BOOL    still_trying;
    LPSTR   return_string;

    ASSERT( Source != NULL );

    // An  initial guess length of zero is required, since that is the only way
    // we  can coax the conversion fuction to ignore the buffer and tell us the
    // length  required.   Note  that  "length"  is in terms of the destination
    // characters   whatever  byte-width  they  have.   Presumably  the  length
    // returned from a conversion function includes the terminator.

    len_guess = 0;
    still_trying = TRUE;
    return_string = NULL;

    while (still_trying) {
        int  chars_required;

        chars_required = WideCharToMultiByte(
                            CP_ACP,        // CodePage (Ansi)
                            0,             // dwFlags
                            Source,        // lpWideCharStr
                            -1,            // cchWideChar
                            return_string, // lpMultiByteStr
                            len_guess,     // cchMultiByte
                            NULL,          // lpDefaultChar
                            NULL );        // lpUsedDefaultChar
        if (chars_required > len_guess) {
            // retry with new size
            len_guess = chars_required;
            delete return_string;
            return_string = new CHAR[len_guess];
            if (return_string == NULL) {
                still_trying = FALSE;
            }
        }
        else if (chars_required > 0) {
            // success
            still_trying = FALSE;
        }
        else {
            // utter failure
            delete return_string;
            return_string = NULL;
            still_trying = FALSE;
        }
    } // while still_trying

    return(return_string);

} // ansi_dup_from_wcs




INT
MapAnsiQuerySetToUnicode(
    IN      PWSAQUERYSETA  Source,
    IN OUT  LPDWORD         lpTargetSize,
    OUT     PWSAQUERYSETW  Target
    )
/*++
Routine Description:

    This  procedure  takes  an  Ansi  PWSAQUERYSETA  and  builds an equivalent
    Unicode PWSAQUERYSETW packed structure.

Arguments:

    Source       - Supplies  the  source query set structure to be copied.  The
                   source  structure  may  be in packed or separately-allocated
                   form.

    lpTargetSize - Supplies  the  size, in bytes, of the Target buffer.  If the
                   function  fails  due to insufficient Target buffer space, it
                   returns  the  required  size of the Target buffer.  In other
                   situations, lpTargetSize is not updated.

    Target       - Returns   the   equivalent   Unicode  PWSAQUERYSETW  packed
                   structure.   This  value  is  ignored if lpTargetSize is not
                   enough  to  hold the resulting structure.  It may be NULL if
                   lpTargetSize is 0.

Return Value:

    ERROR_SUCCESS - The function was successful

    WSAEFAULT     - The  function  failed  due to insufficient buffer space and
                    lpTargetSize was updated with the required size.

    other         - If  the  function  fails  in  any  other way, it returns an
                    appropriate WinSock 2 error code.

Implementation:

    compute size required for copy of source;
    allocate a source copy buffer;
    build source copy;
    cast source copy to Unicode version;
    for each source string requiring conversion loop
        allocate and init with converted string;
        over-write string pointer with allocated;
    end loop
    compute size required for unicode version;
    if (we have enough size) then
        flatten unicode version into target
        return_value = ERROR_SUCCESS
    else
        *lpTargetSize = required unicode size
    endif
    for each allocated converted string loop
        delete converted string
    end loop
    delete source copy buffer
--*/
{
    INT             return_value = ERROR_SUCCESS;
    PWSAQUERYSETA   src_copy_A = NULL;
    PWSAQUERYSETW   src_copy_W;
    DWORD           src_size_A;
    DWORD           needed_size_W;
    INT             build_result_A;
    INT             build_result_W;
    PWSTR           W_string1 = NULL;
    PWSTR           W_string2 = NULL;
    PWSTR           W_string3 = NULL;
    PWSTR           W_string4 = NULL;
    BOOL            ok_to_continue = TRUE;

    //
    //  copy original string
    //
    //  note:  there's a possible optimization here if we know
    //      the input query set is ours (as in the return case)
    //      we can avoid the copy
    //          - save the original string field pointers
    //          - convert the string fields sticking pointers
    //              in the original query set
    //          - copy to target buffer
    //          - revert the string fields to original pointers
    //          - cleanup copies
    //

    src_size_A = WSAComputeQuerySetSizeA(Source);

    src_copy_A = (PWSAQUERYSETA) new char[src_size_A];

    if (src_copy_A == NULL) {
        return_value = WSA_NOT_ENOUGH_MEMORY;
        ok_to_continue = FALSE;
    }
    if (ok_to_continue) {
        build_result_A = WSABuildQuerySetBufferA(
            Source,      // pQuerySet
            src_size_A,  // dwPackedQuerySetSize
            src_copy_A); // lpPackedQuerySet
        if (build_result_A != ERROR_SUCCESS) {
            return_value = GetLastError();
            ok_to_continue = FALSE;
        }
    } // if (ok_to_continue)

    if (ok_to_continue) {
        // In  the following cast, we are taking advantage of the fact that the
        // layout of fields in the WSAQUERYSETA and WSAQUERYSETW are identical.
        // If  this  were not the case, we would have to assemble an equivalent
        // query  set  of the other type field by field.  Since the layouts are
        // the  same,  we  can  simply  alter  our  local  copy  in-place  with
        // converted, separately allocated strings.
        src_copy_W = (PWSAQUERYSETW) src_copy_A;

        if( src_copy_A->lpszServiceInstanceName != NULL ) {
            W_string1 = wcs_dup_from_ansi(
                src_copy_A->lpszServiceInstanceName);
            if (W_string1 == NULL) {
                return_value = WSA_NOT_ENOUGH_MEMORY;
                ok_to_continue = FALSE;
            }
        }
        src_copy_W->lpszServiceInstanceName = W_string1;
    } // if (ok_to_continue)
    else {
        src_copy_W = NULL;
    }

    if (ok_to_continue) {
        if( src_copy_A->lpszComment != NULL ) {
            W_string2 = wcs_dup_from_ansi(
                src_copy_A->lpszComment);
            if (W_string2 == NULL) {
                return_value = WSA_NOT_ENOUGH_MEMORY;
                ok_to_continue = FALSE;
            }
        }
        src_copy_W->lpszComment = W_string2;
    } // if (ok_to_continue)

    if (ok_to_continue) {
        if( src_copy_A->lpszContext != NULL ) {
            W_string3 = wcs_dup_from_ansi(
                src_copy_A->lpszContext);
            if (W_string3 == NULL) {
                return_value = WSA_NOT_ENOUGH_MEMORY;
                ok_to_continue = FALSE;
            }
        }
        src_copy_W->lpszContext = W_string3;
    } // if (ok_to_continue)

    if (ok_to_continue) {
        if( src_copy_A->lpszQueryString != NULL ) {
            W_string4 = wcs_dup_from_ansi(
                src_copy_A->lpszQueryString);
            if (W_string4 == NULL) {
                return_value = WSA_NOT_ENOUGH_MEMORY;
                ok_to_continue = FALSE;
            }
        }
        src_copy_W->lpszQueryString = W_string4;
    } // if (ok_to_continue)

    // Now  we  have  a  converted  query set, but it is composed of separately
    // allocated pieces attached to our locally-allocated buffer.

    if (ok_to_continue) {
        needed_size_W = WSAComputeQuerySetSizeW(src_copy_W);
        if (needed_size_W > (* lpTargetSize)) {
            * lpTargetSize = needed_size_W;
            return_value = WSAEFAULT;
            ok_to_continue = FALSE;
        }
    }

    if (ok_to_continue) {
        build_result_W = WSABuildQuerySetBufferW(
            src_copy_W,      // pQuerySet
            * lpTargetSize,  // dwPackedQuerySetSize
            Target);         // lpPackedQuerySet
        if (build_result_W != ERROR_SUCCESS) {
            return_value = GetLastError();
            ok_to_continue = FALSE;
        }
    }

    // clean up the temporarily-allocated memory
    delete W_string4;
    delete W_string3;
    delete W_string2;
    delete W_string1;
    delete src_copy_A;

    return(return_value);

} // MapAnsiQuerySetToUnicode



INT
MapUnicodeQuerySetToAnsi(
    IN      PWSAQUERYSETW  pSource,
    IN OUT  PDWORD          pTargetSize,
    OUT     PWSAQUERYSETA  pTarget
    )
/*++

Routine Description:

    Copy unicode query set to ANSI query set in packed buffer.

Arguments:

    pSource - existing unicode query set (may be packed or separately allocated)

    pTargetSize - addr of DWORD containing size of target buffer;
        if this size is insufficient, the address is updated with the required
            size for the ANSI query set;
        otherwise (including success) the size is not updated

    pTarget - ptr to buffer to receive ANSI version of query set in packed form
        - this buffer will not be written to if pTargetSize is less than
          required size of query set in ANSI packed buffer
        - may be NULL if pTargetSize contains zero (only size information desired)

Return Value:

    ERROR_SUCCESS - if wrote ANSI query set to buffer
    WSAEFAULT     - if failed due to insufficient buffer space and
                    pTargetSize was updated with the required size.
    WinsockError  - if functions fails for other reason (ex memory allocation)

--*/
{
    INT             retval = ERROR_SUCCESS;
    PWSAQUERYSETW   ptempW = NULL;
    PWSAQUERYSETA   ptempA;
    DWORD           size;
    LPSTR           ptempName = NULL;
    LPSTR           ptempComment = NULL;
    LPSTR           ptempContext = NULL;
    LPSTR           ptempQueryString = NULL;


    //
    //  copy original string
    //
    //  note:  there's a possible optimization here if we know
    //      the input query set is ours (as in the return case)
    //      we can avoid the copy
    //          - save the original string field pointers
    //          - convert the string fields sticking pointers
    //              in the original query set
    //          - copy to target buffer
    //          - revert the string fields to original pointers
    //          - cleanup copies
    //

    //
    //  size source query set and alloc space for copy
    //

    size = WSAComputeQuerySetSizeW( pSource );

    ptempW = (PWSAQUERYSETW) new char[size];
    if ( ptempW == NULL )
    {
        retval = WSA_NOT_ENOUGH_MEMORY;
        goto Done;
    }

    //
    //  make unicode copy of query set
    //

    retval = WSABuildQuerySetBufferW(
                        pSource,        // pQuerySet
                        size,           // dwPackedQuerySetSize
                        ptempW  // lpPackedQuerySet
                        );
    if ( retval != ERROR_SUCCESS )
    {
        ASSERT( FALSE );
        retval = GetLastError();
        goto Done;
    }

    //
    //  convert unicode copy to ANSI in place
    //
    //      - cast unicode structure to ANSI
    //      - all non-string fields left alone
    //      - replace string field pointers with pointers to
    //          individually allocated copies
    //
    //  note, that this approach depends on the fields in WSAQUERYSETA and
    //  WSAQUERYSETW being the same.
    //

    ptempA = (PWSAQUERYSETA) ptempW;

    if ( ptempW->lpszServiceInstanceName )
    {
        ptempName = ansi_dup_from_wcs( ptempW->lpszServiceInstanceName );
        if ( !ptempName )
        {
            retval = WSA_NOT_ENOUGH_MEMORY;
            goto Done;
        }
        ptempA->lpszServiceInstanceName = ptempName;
    }

    if ( ptempW->lpszComment )
    {
        ptempComment = ansi_dup_from_wcs( ptempW->lpszComment );
        if ( !ptempComment )
        {
            retval = WSA_NOT_ENOUGH_MEMORY;
            goto Done;
        }
        ptempA->lpszComment = ptempComment;
    }

    if ( ptempW->lpszContext )
    {
        ptempContext = ansi_dup_from_wcs( ptempW->lpszContext );
        if ( !ptempContext )
        {
            retval = WSA_NOT_ENOUGH_MEMORY;
            goto Done;
        }
        ptempA->lpszContext = ptempContext;
    }

    if( ptempW->lpszQueryString )
    {
        ptempQueryString = ansi_dup_from_wcs( ptempW->lpszQueryString );
        if ( !ptempQueryString )
        {
            retval = WSA_NOT_ENOUGH_MEMORY;
            goto Done;
        }
        ptempA->lpszQueryString = ptempQueryString;
    }

    //
    //  successfully converted temp query set to ANSI
    //      but it is separately allocated pieces, need to write as
    //      flat buffer to target buffer

    //
    //  verify adequate buffer length
    //      - get ANSI query set size
    //      - compare to buffer size
    //

    size = WSAComputeQuerySetSizeA( ptempA );

    if ( size > (*pTargetSize) )
    {
        *pTargetSize = size;
        retval = WSAEFAULT;
        goto Done;
    }

    //
    //  write query set to ANSI
    //

    retval = WSABuildQuerySetBufferA(
                    ptempA,             // pQuerySet
                    * pTargetSize,      // dwPackedQuerySetSize
                    pTarget );          // lpPackedQuerySet

    if ( retval != ERROR_SUCCESS )
    {
        ASSERT( FALSE );
        retval = GetLastError();
        goto Done;
    }
    
Done:

    //  clean up the temporary allocations

    delete ptempName;
    delete ptempComment;
    delete ptempContext;
    delete ptempQueryString;
    delete ptempW;

    return( retval );

} // MapUnicodeQuerySetToAnsi



INT
CopyQuerySetA(
    IN      PWSAQUERYSETA      Source,
    OUT     PWSAQUERYSETA *    Target
    )
{
    DWORD dwSize = WSAComputeQuerySetSizeA(Source);

    *Target = (PWSAQUERYSETA)new BYTE[dwSize];
    if (*Target == NULL)
        return WSA_NOT_ENOUGH_MEMORY;

    return WSABuildQuerySetBufferA(Source, dwSize, *Target);
} // CopyQuerySetA




INT
CopyQuerySetW(
    IN      PWSAQUERYSETW      Source,
    OUT     PWSAQUERYSETW *    Target
    )
{
    DWORD dwSize = WSAComputeQuerySetSizeW(Source);

    *Target = (PWSAQUERYSETW)new BYTE[dwSize];
    if (*Target == NULL)
        return WSA_NOT_ENOUGH_MEMORY;
    return WSABuildQuerySetBufferW(Source, dwSize, *Target);
} // CopyQuerySetW


//
//  End qshelpr.cpp
//
#ifdef _WIN64
#pragma warning (pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\recv.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    recv.cpp

Abstract:

    This module contains the data recption API functions for winsock2 DLL

Author:

    Dirk Brandewie dirk@mink.intel.com  14-06-1995

Revision History:

    22-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Moved includes to precomp.h. Reworked whole
        file. recv and recvform are now just calls to the WSA versions of the
        calls.

    dirk@mink.intel.com 21-Jul-1995
       Added warnoff.h to includes. Moved assignment statements
       outside of confditionals

    Mark Hamilton mark_hamilton@ccm.jf.intel.com 18-06-1995
       Implemented all of the functions.
--*/


#include "precomp.h"


int WSAAPI
recv(
     IN SOCKET s,
     OUT char FAR * buf,
     IN int len,
     IN int flags
     )
/*++
Routine Description:

    Receive data from a socket.

Arguments:

    s     - A descriptor identifying a connected socket.

    buf   - A buffer for the incoming data.

    len   - The length of buf.

    flags - Specifies the way in which the call is made.

Returns:

    The  number  of  bytes  received.   If  the  connection has been gracefully
    closed,  the  return  value  is  0.   Otherwise, a value of SOCKET_ERROR is
    returned, and a specific error code is stored with SetErrorCode().

--*/

{
    INT             ErrorCode;
    PDSOCKET        Socket;
    PDTHREAD        Thread;


	ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if (ErrorCode==ERROR_SUCCESS)
    {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            INT             ReturnValue;
            PDPROVIDER      Provider;
            DWORD           BytesReceived;
            WSABUF          Buffers;

            Buffers.len = len;
            Buffers.buf = buf;

            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPRecv(s,
                              &Buffers,
                              1,
                              &BytesReceived,
                              (LPDWORD)&flags,
                              NULL,                 // lpOverlapped
                              NULL,                 // lpCompletionRoutine
                              Thread->GetWahThreadID(),
                              &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS) {
                if ((flags & MSG_PARTIAL)==0) {
                    return (INT)BytesReceived;
                }
                ErrorCode = WSAEMSGSIZE;
            }

            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;

        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}




int WSAAPI
recvfrom(
    IN SOCKET s,
    OUT char FAR * buf,
    IN int len,
    IN int flags,
    OUT struct sockaddr FAR *from,
    IN OUT int FAR * fromlen
    )
/*++
Routine Description:

    Receive a datagram and store the source address.

Arguments:

    s       - A descriptor identifying a bound socket.

    buf     - A buffer for the incoming data.

    len     - The length of buf.

    flags   - Specifies the way in which the call is made.

    from    - An  optional  pointer  to  a  buffer  which  will hold the source
              address upon return.

    fromlen - An optional pointer to the size of the from buffer.

Returns:

    The  number  of  bytes  received.   If  the  connection has been gracefully
    closed,  the  return  value  is  0.   Otherwise, a value of SOCKET_ERROR is
    returned, and a specific error code is stored with SetErrorCode().

--*/

{
    INT                ErrorCode;
    PDSOCKET           Socket;
    PDTHREAD           Thread;

	ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if (ErrorCode==ERROR_SUCCESS)
    {

        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            INT             ReturnValue;
            PDPROVIDER      Provider;
            DWORD           BytesReceived;
            WSABUF          Buffers;

            Buffers.len = len;
            Buffers.buf = buf;

            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPRecvFrom(s,
                                  &Buffers,
                                  1,
                                  &BytesReceived,
                                  (LPDWORD)&flags,
                                  from,
                                  fromlen,
                                  NULL,                 // lpOverlapped
                                  NULL,                 // lpCompletionRoutine
                                  Thread->GetWahThreadID(),
                                  &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS) {
                if ((flags & MSG_PARTIAL)==0) {
                    return (INT)BytesReceived;
                }
                ErrorCode = WSAEMSGSIZE;
            }

            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}



int WSAAPI
WSARecv(
    IN SOCKET s,
    OUT LPWSABUF lpBuffers,
    IN DWORD dwBufferCount,
    OUT LPDWORD lpNumberOfBytesRecvd,
    IN OUT LPDWORD lpFlags,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
/*++
Routine Description:

    Receive data from a socket.

Arguments:

    s                    - A descriptor identifying a connected socket.

    lpBuffers            - A  pointer  to  an array of WSABUF structures.  Each
                           WSABUF  structure contains a pointer to a buffer and
                           the length of the buffer.

    dwBufferCount        - The  number  of  WSABUF  structures in the lpBuffers
                           array.

    lpNumberOfBytesRecvd - A  pointer  to  the number of bytes received by this
                           call if the receive operation completes immediately.

    lpFlags              - A pointer to flags.

    lpOverlapped         - A  pointer to a WSAOVERLAPPED structure (ignored for
                           non-overlapped sockets).

    lpCompletionRoutine  - A  pointer to the completion routine called when the
                           receive  operation  has  been completed (ignored for
                           non-overlapped sockets).

Returns:

    If  no  error  occurs  and the receive operation has completed immediately,
    WSARecv() returns the number of bytes received.  If the connection has been
    closed,  it returns 0.  Otherwise, a value of SOCKET_ERROR is returned, and
    the  specific  error  code  is  stored with SetErrorCode().  The error code
    WSA_IO_PENDING   indicates   that   the   overlapped   operation  has  been
    successfully  initiated  and  that  completion will be indicated at a later
    time.  Any other error code indicates that the overlapped operation was not
    successfully initiated and no completion indication will occur.

    If  the  MSG_INTERRUPT  flag  is  set,  the  meaning of the return value is
    changed.  A value of zero indicates success and is interpreted as described
    above.   Otherwise,  the return value will directly contain the appropriate
    error  code  as  shown  below.   Note that this is applicable only to Win16
    environments  and only for protocols that have the XP1_INTERRUPT bit set in
    the WSAPROTOCOL_INFO struct.

--*/
{
    INT                 ErrorCode;
    PDSOCKET            Socket;
    PDTHREAD            Thread;

	ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if (ErrorCode==ERROR_SUCCESS)
    {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            INT                 ReturnValue;
            PDPROVIDER          Provider;

            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPRecv(s,
                              lpBuffers,
                              dwBufferCount,
                              lpNumberOfBytesRecvd,
                              lpFlags,
                              lpOverlapped,
                              lpCompletionRoutine,
                              Thread->GetWahThreadID(),
                              &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;

        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}




int WSAAPI
WSARecvDisconnect(
    IN SOCKET s,
    OUT LPWSABUF lpInboundDisconnectData
    )
/*++
Routine Description:

    Terminate  reception  on  a socket, and retrieve the disconnect data if the
    socket is connection-oriented.

Arguments:

    s                       - A descriptor identifying a socket.

    lpInboundDisconnectData - A pointer to the incoming disconnect data.

Returns:

    Zero on success else SOCKET_ERROR. The error code is stored with
    SetErrorCode().

--*/

{
    INT                 ErrorCode;
    PDSOCKET            Socket;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode==ERROR_SUCCESS) {

        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            INT                 ReturnValue;
            PDPROVIDER          Provider;

            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPRecvDisconnect(
                s,
                lpInboundDisconnectData,
                &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ERROR_SUCCESS;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return(SOCKET_ERROR);
}



int WSAAPI
WSARecvFrom(
    IN SOCKET s,
    OUT LPWSABUF lpBuffers,
    IN DWORD dwBufferCount,
    OUT LPDWORD lpNumberOfBytesRecvd,
    IN OUT LPDWORD lpFlags,
    OUT struct sockaddr FAR *  lpFrom,
    IN OUT LPINT lpFromlen,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
/*++
Routine Description:

    Receive a datagram and store the source address.

Arguments:

    s                    - A descriptor identifying a socket

    lpBuffers            - A  pointer  to  an array of WSABUF structures.  Each
                           WSABUF  structure contains a pointer to a buffer and
                           the length of the buffer.

    dwBufferCount        - The  number  of  WSABUF  structures in the lpBuffers
                           array.

    lpNumberOfBytesRecvd - A  pointer  to  the number of bytes received by this
                           call if the receive operation completes immediately.

    lpFlags              - A pointer to flags.

    lpFrom               - An  optional pointer to a buffer which will hold the
                           source address upon the completion of the overlapped
                           operation.

    lpFromlen            - A  pointer  to the size of the from buffer, required
                           only if lpFrom is specified.

    lpOverlapped         - A  pointer to a WSAOVERLAPPED structure (ignored for
                           non- overlapped sockets).

    lpCompletionRoutine  - A  pointer to the completion routine called when the
                           receive  operation  has  been completed (ignored for
                           non-overlapped sockets).

Returns:

    Zero  on  success  else  SOCKET_ERROR.   The  error  code  is  stored  with
    SetErrorCode().

--*/

{
    INT                ErrorCode;
    PDSOCKET           Socket;
    PDTHREAD           Thread;

	ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if (ErrorCode==ERROR_SUCCESS)
    {

        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            INT             ReturnValue;
            PDPROVIDER      Provider;

            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPRecvFrom(s,
                                  lpBuffers,
                                  dwBufferCount,
                                  lpNumberOfBytesRecvd,
                                  lpFlags,
                                  lpFrom,
                                  lpFromlen,
                                  lpOverlapped,
                                  lpCompletionRoutine,
                                  Thread->GetWahThreadID(),
                                  &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\precomp.h ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    precomp.h

Abstract:

    This file includes all the headers required to build winsock2.dll
    to ease the process of building a precompiled header.

Author:

Dirk Brandewie dirk@mink.intel.com  11-JUL-1995

Revision History:


--*/

#ifndef _PRECOMP_
#define _PRECOMP_

#ifdef _WS2_32_W4_
    //
    // These are warning that we are willing to ignore.
    //
    #pragma warning(disable:4214)   // bit field types other than int
    #pragma warning(disable:4201)   // nameless struct/union
    #pragma warning(disable:4127)   // condition expression is constant
    #pragma warning(disable:4115)   // named type definition in parentheses
    #pragma warning(disable:4206)   // translation unit empty
    #pragma warning(disable:4706)   // assignment within conditional
    #pragma warning(disable:4324)   // structure was padded
    #pragma warning(disable:4328)   // greater alignment than needed
    #pragma warning(disable:4054)   // cast of function pointer to PVOID

    #define WS2_32_W4_INIT
#else
    #define WS2_32_W4_INIT if (FALSE)
#endif


//
// Turn off "declspec" decoration of entrypoints defined in WINSOCK2.H.
//

#define WINSOCK_API_LINKAGE


#include "osdef.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef ASSERT
#include <winsock2.h>
#include <ws2tcpip.h>
#include <ws2spi.h>
#include <mswsock.h>
#include <sporder.h>
#include <windows.h>
#include <wtypes.h>
#include <stdio.h>
#include <tchar.h>
#include "trace.h"
#include "wsassert.h"
#include "scihlpr.h"
#include "nsprovid.h"
#include "nspstate.h"
#include "nscatent.h"
#include "nscatalo.h"
#include "nsquery.h"
#include "ws2help.h"
#include "dprovide.h"
#include "dsocket.h"
#include "dprocess.h"
#include "dthread.h"
#include "wsautil.h"
#include "dcatalog.h"
#include "dcatitem.h"
#include "startup.h"
#include "dt_dll.h"
#include "dthook.h"
#include "trycatch.h"
#include "getxbyy.h"
#include "qshelpr.h"
#ifdef RASAUTODIAL
#include "autodial.h"
#endif // RASAUTODIAL
#include "async.h"

#endif  // _PRECOMP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\rnr.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    rnr.cpp

Abstract:

    This module contains the implementation of the Registration and
    Name Resolution API for the WinSock2 API

    This module contains the following functions. For functions whose function
    signature contains sting arguments both and ASCII and Wide charater version
    of the function are supplied

    WSAEnumNameSpaceProviders
    WSCEnumNameSpaceProviders
    WSALookupServiceBegin
    WSALookupServiceNext
    WSANSPIoctl
    WSALookupServiceEnd
    WSASetService
    WSAInstallServiceClass
    WSARemoveServiceClass
    WSAGetServiceClassNameByClassId

Author:

    Dirk Brandewie dirk@mink.intel.com  12-1-1995

[Environment:]

[Notes:]

Revision History:

    12-Dec-1995 dirk@mink.intel.com
        Initial Revision

--*/

#include "precomp.h"

#ifdef _WIN64
#pragma warning (push)
#pragma warning (disable:4267)
#endif

typedef struct
{
    BOOL    AllProviders;
    LPDWORD RequiredBufferSize;
    DWORD   BufferSize;
    PBYTE   Buffer;
    PBYTE   BufferFreePtr;
    BOOL    Ansi;
    INT     NumItemsEnumerated;
    INT     ErrorCode;
} NSCATALOG_ENUMERATION_CONTEXT, * PNSCATALOG_ENUMERATION_CONTEXT;

//
// BONUSSIZE is a hack that is used  to bias the computed size
// when WSALookupServiceNextA gets a WSAEFAULT from the
// WSALookupServiceNextW call. It is the "maximum" padding
// that we might need. Note this assumes all values returned
// and a limit of 3 addresses. There is no way to know exactly
// what the makeup of the returned data will be, so this is
// a "best guess". The right fix is to redo the code to
// pack the result optimally, so no padding is needed.
//

#define BONUSSIZE (3 + 3 + 3 + (3 * 3))


BOOL
CalculateBufferSize(
    PVOID           PassBack,
    PNSCATALOGENTRY CatalogEntry
    )
/*++

Routine Description:

    This fuction calculates the size of buffer required to return the
    NAMESPACE_INFO structs for a call to WSAEnumNameSpaces(). This function is
    a callback function used as an argument to the name space catalog
    enumeration funtion

Arguments:

    PassBack - A context value passed thru the catalog enumeration
               function. This passback value is really a pointer to a
               NSCATALOG_ENUMERATION_CONTEXT.

    CatalogEntry - A pointer to the current name space catalog entry to be
                   inspected.
Return Value:

   TRUE, Signalling the catalog enumeration function should continue the
   enumeration.

--*/
{
    PNSCATALOG_ENUMERATION_CONTEXT Context;
    LPWSTR                         EntryDisplayString;

    Context = (PNSCATALOG_ENUMERATION_CONTEXT)PassBack;

    // Add the fixed length of the WSANAMESPACE_INFO struct
    *(Context->RequiredBufferSize) += sizeof(WSANAMESPACE_INFO);

    // Add room for the GUID
    *(Context->RequiredBufferSize) += sizeof(GUID);

    // Add room for the display string
    EntryDisplayString = CatalogEntry->GetProviderDisplayString();
    *(Context->RequiredBufferSize) += ((wcslen(EntryDisplayString)+1) *
                                           sizeof(WCHAR));
    return(TRUE); // Continue the enumeration
}


BOOL
CopyFixedPortionNameSpaceInfo(
    PVOID           PassBack,
    PNSCATALOGENTRY CatalogEntry
    )
/*++

Routine Description:

    This Funtion copies the fixed size elements of a NSCATALOGENTRY object into
    a user buffer for return from a call to WSAEnumNameSpaces(). It also
    increments the number of fixed size elements copied so far.

Arguments:

    PassBack - A context value passed thru the catalog enumeration
               function. This passback value is really a pointer to a
               NSCATALOG_ENUMERATION_CONTEXT.

    CatalogEntry - A pointer to the current name space catalog entry to be
                   inspected.

Return Value:

  TRUE, Signalling the catalog enumeration function should continue the
   enumeration.

--*/
{
    PNSCATALOG_ENUMERATION_CONTEXT Context;
    LPWSANAMESPACE_INFOW CurrentNSInfo;

    Context =  (PNSCATALOG_ENUMERATION_CONTEXT)PassBack;

    CurrentNSInfo = (LPWSANAMESPACE_INFOW)Context->BufferFreePtr;
    __try {
        CurrentNSInfo->dwNameSpace  = CatalogEntry->GetNamespaceId();
        CurrentNSInfo->fActive      = CatalogEntry->GetEnabledState();
        CurrentNSInfo->dwVersion    = CatalogEntry->GetVersion();
        CurrentNSInfo->NSProviderId = *(CatalogEntry->GetProviderId());
        Context->BufferFreePtr += sizeof(WSANAMESPACE_INFO);
        Context->NumItemsEnumerated++;
        return(TRUE); // Continue the enumeration
    }
    __except (WS2_EXCEPTION_FILTER()) {
        Context->ErrorCode = WSAEFAULT;
        return(FALSE);
   }
}


BOOL
CopyVariablePortionNameSpaceInfo(
    PVOID           PassBack,
    PNSCATALOGENTRY CatalogEntry
    )
/*++

Routine Description:

    This Funtion copies the variable size elements of a NSCATALOGENTRY object
    into a user buffer for return from a call to WSAEnumNameSpaces().

Arguments:

    PassBack - A context value passed thru the catalog enumeration
               function. This passback value is really a pointer to a
               NSCATALOG_ENUMERATION_CONTEXT.

    CatalogEntry - A pointer to the current name space catalog entry to be
                   inspected.

Return Value:

    TRUE, Signalling the catalog enumeration function should continue the
    enumeration.

--*/
{
    PNSCATALOG_ENUMERATION_CONTEXT Context;
    LPWSANAMESPACE_INFOW CurrentNSInfo;
    LPWSTR DisplayString;
    INT    StringLength;

    Context =  (PNSCATALOG_ENUMERATION_CONTEXT)PassBack;

    CurrentNSInfo = (LPWSANAMESPACE_INFOW)Context->Buffer;

    // Copy over the display string
    DisplayString = CatalogEntry->GetProviderDisplayString();
    StringLength = ((wcslen(DisplayString)+1) * sizeof(WCHAR));

    CurrentNSInfo->lpszIdentifier = (LPWSTR)Context->BufferFreePtr;
    __try {
        if (Context->Ansi){
            WideCharToMultiByte(
                     CP_ACP,                                   // CodePage (ANSI)
                     0,                                        // dwFlags
                     DisplayString,                            // lpWideCharStr
                     -1,                                       // cchWideChar
                     (char*)CurrentNSInfo->lpszIdentifier,     // lpMultiByteStr
                     StringLength,                             // cchMultiByte
                     NULL,                                     // lpDefaultChar
                     NULL                                      // lpUsedDefaultChar
                     );
            Context->BufferFreePtr += lstrlen(
                (LPSTR)CurrentNSInfo->lpszIdentifier)+1;
        } //if
        else{
            memcpy(CurrentNSInfo->lpszIdentifier,
                   DisplayString,
                   StringLength);
            Context->BufferFreePtr += StringLength;

        } //else

        // point to the next struct
        Context->Buffer += sizeof(WSANAMESPACE_INFO);
        return(TRUE); // Continue the enumeration
    }
    __except (WS2_EXCEPTION_FILTER()) {
        Context->ErrorCode = WSAEFAULT;
        return FALSE;
    }
}


INT
WSAAPI
EnumNameSpaceProviders(
    IN      PNSCATALOG              Catalog,
    IN      BOOL                    Ansi,
    IN OUT  PDWORD                  BufferLength,
    IN OUT  LPWSANAMESPACE_INFOW    Buffer,
    OUT     PDWORD                  ErrorCode
    )
/*++

Routine Description:

    This Function is used by WSAEnumNameSpaceProvidersA and
    WSAEnumNameSpaceProvidersW to fill in the user buffer with the information
    about each name spcae provider install on the system.

Arguments:

    Catalog - A pointer to a NSCATALOG object containing the requested
              information.

    Ansi - A boolean value marking whether the user requested the ansi or
           unicode version of the WSANAMESPACE_INFO struct should be returned.

    BufferLength - The size of the user buffer in bytes.

    Buffer - A pointer to the user buffer.

    ErrorCode - A pointer to a DWORD to contain the error return from this
                function.

Return Value:

    If the function is successful it returns the number of name space providers
    enumerated.   Otherwise it returns SOCKET_ERROR.  If the user buffer is too
    small  to  contain  all  the  the WSANAMESPACE_INFO structs SOCKET_ERROR is
    returned,  the  error code is set to WSAEFAULT, and BufferLength is updated
    to  reflect  the  size  of  buffer  required  to  hold  all  the  requested
    information.
--*/
{
    INT        ReturnCode;
    DWORD      RequiredBufferSize;

    // Setup for early return
    ReturnCode = SOCKET_ERROR;
    *ErrorCode = WSAEFAULT;

    // Find out if the user handed in a big enough buffer
    RequiredBufferSize = 0;
    NSCATALOG_ENUMERATION_CONTEXT Context;

    Context.RequiredBufferSize = &RequiredBufferSize;
    Catalog->EnumerateCatalogItems(
                    CalculateBufferSize,
                    & Context );

    __try
    {
        if ( Buffer!=NULL && RequiredBufferSize <= *BufferLength )
        {
            Context.BufferSize = *BufferLength;
        }
        else
        {
            // Error code is set above
            *BufferLength = RequiredBufferSize;
            return (ReturnCode);
        }
    }
    __except( WS2_EXCEPTION_FILTER() )
    {
        // Everything is set
        return (ReturnCode);
    }

    Context.Buffer = (PBYTE)Buffer;
    Context.BufferFreePtr = (PBYTE)Buffer;
    Context.Ansi = Ansi;
    Context.NumItemsEnumerated = 0;
    Context.ErrorCode = ERROR_SUCCESS;

    //Copy over the fixed part of the WSANAMESPACE_INFO struct(s) into the
    //user buffer
    Catalog->EnumerateCatalogItems(
                    CopyFixedPortionNameSpaceInfo,
                    & Context );

    if ( Context.ErrorCode==ERROR_SUCCESS ) {
        //Copy over the variable part of the WSANAMESPACE_INFO struct(s) into
        //the user buffer
         Catalog->EnumerateCatalogItems(
                        CopyVariablePortionNameSpaceInfo,
                        & Context );
        if (Context.ErrorCode==ERROR_SUCCESS) {
            ReturnCode = Context.NumItemsEnumerated;
        }
        else {
            *ErrorCode = Context.ErrorCode;
        }
    }
    else
        *ErrorCode = Context.ErrorCode;

    return(ReturnCode);
}


INT
WSAAPI
WSAEnumNameSpaceProvidersA(
    IN OUT  PDWORD                  lpdwBufferLength,
    IN OUT  LPWSANAMESPACE_INFOA    lpnspBuffer
    )
/*++

Routine Description:

    Retrieve information about available name spaces.

Arguments:

    lpdwBufferLength - on input, the number of bytes contained in the buffer
                       pointed to by lpnspBuffer.  On output (if the API fails,
                       and the error is  WSAEFAULT), the minimum number of
                       bytes to pass for the lpnspBuffer to retrieve all the
                       requested information. The passed-in buffer must be
                       sufficient to hold all of the name space information.

    lpnspBuffer - A buffer which is filled with WSANAMESPACE_INFO structures
                  described below.  The returned structures are located
                  consecutively at the head of the buffer. Variable sized
                  information referenced by pointers in the structures point to
                  locations within the buffer located between the end of the
                  fixed sized structures and the end of the buffer.  The number
                  of structures filled in is the return value of
                  WSAEnumNameSpaceProviders().

Return Value:

    WSAEnumNameSpaceProviders() returns the number of WSANAMESPACE_INFO
    structures copied into lpnspBuffer. Otherwise the value SOCKET_ERROR is
    returned, and a specific error number may be retrieved by calling
    WSAGetLastError().

--*/
{
    INT        ReturnValue;
    PDPROCESS  Process;
    PDTHREAD   Thread;
    INT        ErrorCode;
    PNSCATALOG Catalog;

    ErrorCode = PROLOG(&Process,
                        &Thread);
    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    } //if


    Catalog = Process->GetNamespaceCatalog();

    ReturnValue = EnumNameSpaceProviders(
        Catalog,
        TRUE,    // Ansi
        lpdwBufferLength,
        (LPWSANAMESPACE_INFOW)lpnspBuffer,
        (LPDWORD)&ErrorCode);

    // If there was an error set this threads lasterror
    if (SOCKET_ERROR == ReturnValue ) {
        SetLastError(ErrorCode);
    } //if
    return(ReturnValue);
}

INT
WSAAPI
WSAEnumNameSpaceProvidersW(
    IN OUT  PDWORD                  lpdwBufferLength,
    IN OUT  LPWSANAMESPACE_INFOW    lpnspBuffer
    )
/*++

Routine Description:

    Retrieve information about available name spaces.

Arguments:

    lpdwBufferLength - on input, the number of bytes contained in the buffer
                       pointed to by lpnspBuffer.  On output (if the API fails,
                       and the error is  WSAEFAULT), the minimum number of
                       bytes to pass for the lpnspBuffer to retrieve all the
                       requested information. The passed-in buffer must be
                       sufficient to hold all of the name space information.

    lpnspBuffer - A buffer which is filled with WSANAMESPACE_INFO structures
                  described below.  The returned structures are located
                  consecutively at the head of the buffer. Variable sized
                  information referenced by pointers in the structures point to
                  locations within the buffer located between the end of the
                  fixed sized structures and the end of the buffer.  The number
                  of structures filled in is the return value of
                  WSAEnumNameSpaceProviders().

Return Value:

    WSAEnumNameSpaceProviders() returns the number of WSANAMESPACE_INFO
    structures copied into lpnspBuffer. Otherwise the value SOCKET_ERROR is
    returned, and a specific error number may be retrieved by calling
    WSAGetLastError().

--*/
{
    INT        ReturnValue;
    PDPROCESS  Process;
    PDTHREAD   Thread;
    INT        ErrorCode;
    PNSCATALOG Catalog;

    ErrorCode = PROLOG(&Process,
                        &Thread);
    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    } //if

    Catalog = Process->GetNamespaceCatalog();

    ReturnValue = EnumNameSpaceProviders(
        Catalog,
        FALSE,    //Unicode
        lpdwBufferLength,
        lpnspBuffer,
        (LPDWORD)&ErrorCode);

    // If there was an error set this threads lasterror
    if (SOCKET_ERROR == ReturnValue ) {
        SetLastError(ErrorCode);
    } //if
    return(ReturnValue);
}


#ifdef _WIN64
INT
WSAAPI
WSCEnumNameSpaceProviders32(
    IN OUT  LPDWORD                 lpdwBufferLength,
    IN OUT  LPWSANAMESPACE_INFOW    lpnspBuffer
    )
/*++

Routine Description:

    Retrieve information about available name spaces.

Arguments:

    lpdwBufferLength - on input, the number of bytes contained in the buffer
                       pointed to by lpnspBuffer.  On output (if the API fails,
                       and the error is  WSAEFAULT), the minimum number of
                       bytes to pass for the lpnspBuffer to retrieve all the
                       requested information. The passed-in buffer must be
                       sufficient to hold all of the name space information.

    lpnspBuffer - A buffer which is filled with WSANAMESPACE_INFO structures
                  described below.  The returned structures are located
                  consecutively at the head of the buffer. Variable sized
                  information referenced by pointers in the structures point to
                  locations within the buffer located between the end of the
                  fixed sized structures and the end of the buffer.  The number
                  of structures filled in is the return value of
                  WSAEnumNameSpaceProviders().

Return Value:

    WSAEnumNameSpaceProviders() returns the number of WSANAMESPACE_INFO
    structures copied into lpnspBuffer. Otherwise the value SOCKET_ERROR is
    returned, and a specific error number may be retrieved by calling
    WSAGetLastError().

--*/
{
    INT         ReturnValue=SOCKET_ERROR;
    INT         ErrorCode;
    PNSCATALOG  Catalog = NULL;
    HKEY        registry_root;


    registry_root = OpenWinSockRegistryRoot();
    if (registry_root == NULL) {
        DEBUGF(
            DBG_ERR,
            ("Opening registry root\n"));
        ErrorCode = WSANO_RECOVERY;
        goto Exit;
    }

    //
    // Build the protocol catalog
    //
    Catalog = new(NSCATALOG);

    if (Catalog!=NULL) {
        
        ErrorCode = Catalog->InitializeFromRegistry32(
                            registry_root
                            );
    }
    else {
        ErrorCode = WSA_NOT_ENOUGH_MEMORY;
        DEBUGF(
            DBG_ERR,
            ("Allocating dcatalog object\n"));
    }


    {
        LONG close_result;
        close_result = RegCloseKey(
            registry_root);  // hkey
        assert(close_result == ERROR_SUCCESS);
    }


    if (ErrorCode==ERROR_SUCCESS) {
        ReturnValue = EnumNameSpaceProviders(
            Catalog,
            FALSE,    //Unicode
            lpdwBufferLength,
            lpnspBuffer,
            (LPDWORD)&ErrorCode);
    }

Exit:
    if (Catalog!=NULL) {
        delete Catalog;
    }

    // If there was an error set this threads lasterror
    if (SOCKET_ERROR == ReturnValue ) {
        SetLastError(ErrorCode);
    } //if
    return(ReturnValue);
}
#endif


INT
WSAAPI
WSALookupServiceBeginA(
    IN      LPWSAQUERYSETA  lpqsRestrictions,
    IN      DWORD           dwControlFlags,
    OUT     LPHANDLE        lphLookup
    )
/*++

Routine Description:

    WSALookupServiceBegin() is used to initiate a client query that is
    constrained by the information contained within a WSAQUERYSET
    structure. WSALookupServiceBegin() only returns a handle, which should be
    used by subsequent calls to WSALookupServiceNext() to get the actual
    results.

Arguments:

    lpqsRestrictions - contains the search criteria.

    dwControlFlags - controls the depth of the search.

    lphLookup - Addr to receive handle to be used when calling WSALookupServiceNext
                in order to start retrieving the results set.

Returns:

    Zero if successful.
    SOCKET_ERROR on failure.  GetLastError() contains error code.

--*/
{
    INT             returnCode;
    PWSAQUERYSETW   UniCodeBuffer = NULL;
    DWORD           UniCodeBufferSize;

    //
    //  Verify that pointer is valid (lphLookup verified in XxxW func)
    //

    if ( IsBadReadPtr( lpqsRestrictions, sizeof(*lpqsRestrictions)) )
    {
        returnCode = WSAEFAULT;
        goto Done;
    }

    //
    // The Winsock spec says that these are ignored fields, clear them
    // so that they don't cause a problem in the Ansi to Unicode copy
    // routines - NT bug #91655
    //

    lpqsRestrictions->dwOutputFlags = 0;
    lpqsRestrictions->lpszComment = NULL;
    lpqsRestrictions->dwNumberOfCsAddrs = 0;
    lpqsRestrictions->lpcsaBuffer;

    //
    //  determine size of unicode buffer
    //

    UniCodeBufferSize = 0;

    returnCode = MapAnsiQuerySetToUnicode(
                    lpqsRestrictions,
                    & UniCodeBufferSize,
                    UniCodeBuffer );

    if ( WSAEFAULT != returnCode )
    {
        goto Done;
    }

    //
    //  copy input buffer to unicode
    //

    UniCodeBuffer = (LPWSAQUERYSETW)new BYTE[UniCodeBufferSize];
    if ( !UniCodeBuffer )
    {
        goto Done;
    }

    returnCode = MapAnsiQuerySetToUnicode(
                        lpqsRestrictions,
                        &UniCodeBufferSize,
                        UniCodeBuffer );

    if ( ERROR_SUCCESS != returnCode )
    {
        goto Done;
    }

    //
    //  call unicode version
    //

    returnCode = WSALookupServiceBeginW(
                    UniCodeBuffer,
                    dwControlFlags,
                    lphLookup );

    
Done:

    if ( UniCodeBuffer )
    {
        delete( UniCodeBuffer );
    }

    //
    //  on error, set last error and return SOCKET_ERROR
    //      - WSALookupServiceBeginW() will already have
    //      set error and returned SOCKET_ERROR

    if ( returnCode &&
         returnCode != SOCKET_ERROR )
    {
        SetLastError( returnCode );
        returnCode = SOCKET_ERROR;
    }

    return( returnCode );
}


INT
WSAAPI
WSALookupServiceBeginW(
    IN      LPWSAQUERYSETW  lpqsRestrictions,
    IN      DWORD           dwControlFlags,
    OUT     LPHANDLE        lphLookup
    )
/*++

Routine Description:

    WSALookupServiceBegin() is used to initiate a client query that is
    constrained by the information contained within a WSAQUERYSET
    structure. WSALookupServiceBegin() only returns a handle, which should be
    used by subsequent calls to WSALookupServiceNext() to get the actual
    results.

Arguments:

    lpqsRestrictions - contains the search criteria.

    dwControlFlags - controls the depth of the search.

    lphLookup - A pointer Handle to be used when calling WSALookupServiceNext
                in order to start retrieving the results set.

Returns:

    Zero if successful.
    SOCKET_ERROR on failure.  GetLastError() contains error code.

--*/
{
    PDPROCESS   Process;
    PDTHREAD    Thread;
    INT         errorCode;
    PNSQUERY    Query = NULL;


    errorCode = PROLOG( &Process, &Thread );

    if ( errorCode != ERROR_SUCCESS )
    {
        goto Done;
    }

    //
    //  verify that pointers are valid
    //

    if ( IsBadWritePtr( lphLookup, sizeof(*lphLookup) ) ||
         IsBadReadPtr( lpqsRestrictions, sizeof(*lpqsRestrictions) ) )
    {
        errorCode = WSAEFAULT;
        goto Done;
    }

    //
    //  Make sure we've got a current name space catalog
    //

    Query = new NSQUERY;
    if ( !Query )
    {
        errorCode = WSAENOBUFS;
        goto Done;
    }

    errorCode = Query->Initialize();
    if ( errorCode != NO_ERROR )
    {
        delete Query;
        goto Done;
    }

    //
    //  call provider
    //      - if successful save NSQUERY as context handle
    //      - if fails recover error code so not reset when
    //          dump NSQUERY
    //      


    errorCode = Query->LookupServiceBegin(
                            lpqsRestrictions,
                            dwControlFlags,
                            Process->GetNamespaceCatalog() );

    if ( ERROR_SUCCESS == errorCode )
    {
        *lphLookup = (LPHANDLE)Query;
    }
    else
    {
        *lphLookup = NULL;
        errorCode = GetLastError();
        delete Query;
    }

Done:

    //
    //  on error, set last error and return SOCKET_ERROR
    //

    if ( errorCode &&
         errorCode != SOCKET_ERROR )
    {
        SetLastError( errorCode );
        errorCode = SOCKET_ERROR;
    }

    return( errorCode );
}


INT
WSAAPI
WSALookupServiceNextA(
    IN      HANDLE          hLookup,
    IN      DWORD           dwControlFlags,
    IN OUT  LPDWORD         lpdwBufferLength,
    OUT     LPWSAQUERYSETA  lpqsResults
    )
/*++

Routine Description:

    WSALookupServiceNext() is called after obtaining a Handle from a previous
    call to WSALookupSefrviceBegin() in order to retrieve the requested service
    information.  The provider will pass back a WSAQUERYSET structure in the
    lpqsResults buffer.  The client should continue to call this API until it
    returns WSA_E_NOMORE, indicating that all of the WSAQUERYSET have been
    returned.

Arguments:

    hLookup - A Handle returned from the previous call to
              WSALookupServiceBegin().

    dwControlFlags - Flags to control the next operation.  This is currently
                     used to indicate to the provider what to do if the result
                     set is too big for the buffer.  If on the previous call to
                     WSALookupServiceNext() the result set was too large for
                     the buffer, the application can choose to do one of two
                     things on this call.  First, it can choose to pass a
                     bigger buffer and try again.  Second, if it cannot or is
                     unwilling to allocate a larger buffer, it can pass
                     LUP_FLUSHPREVIOUS to tell the provider to throw away the
                     last result set - which was too large - and move on to the
                     next set for this call.

    lpdwBufferLength - on input, the number of bytes contained in the buffer
                       pointed  to by lpresResults.  On output - if the API
                       fails, and the error is WSAEFAULT, then it contains the
                       minimum number of bytes to pass for the lpqsResults to
                       retrieve the record.

    lpqsResults - a pointer to a block of memory, which will contain one result
                  set in a WSAQUERYSET structure on return.


Returns:

    Zero if successful.
    Otherwise the value SOCKET_ERROR is returned.

--*/
{
    INT            ReturnCode;
    DWORD          ErrorCode;
    LPWSAQUERYSETW UniCodeBuffer;
    DWORD          UniCodeBufferLength;

    //
    // Verify that pointers are valid
    //
    //  note:  this error is classic winsock WSAEFAULT,
    //      but unfortunately, WSAEFAULT was spec'd as the
    //      buffer-is-too-small error which is part of normal
    //      API operation;  to avoid overloading the EFAULT
    //      i'm switching this to WSAEINVAL (jamesg)
    //      

    if ( IsBadReadPtr( lpdwBufferLength, sizeof(*lpdwBufferLength) ) ||
         ( *lpdwBufferLength != 0  &&
           IsBadWritePtr( lpqsResults, *lpdwBufferLength ) ) )
    {
        SetLastError( WSAEINVAL );
        return SOCKET_ERROR;
    }

    // Find how big a buffer we need to allocate. Base first guess on the
    // user's provided buffer. The alogirthm is as follows:
    // If the user supplied a buffer, allocate a buffer of size
    // (user buffer - sizeof(WSAQUERYSET) * sizeof(WCHAR). This
    //  is guaranteed to hold the data that could be held in
    // the user's buffer.

    UniCodeBufferLength = *lpdwBufferLength;
    if( UniCodeBufferLength >= sizeof(WSAQUERYSETW) )
    {
        // Assume all space, except the defined structure, is to
        // be string space. So scale it by the size of a UNICODE
        // character. It won't be that bad, but this seems "safe".
        //
        // UniCodeBufferLength = 
                              // This calculation doesn't work out
                              // correctly. Just use the size that the caller
                              // is trying to use.
                              // (UniCodeBufferLength * sizeof(WCHAR)) -
                              //    sizeof(WSAQUERYSETW);
        UniCodeBuffer = (LPWSAQUERYSETW) new BYTE[UniCodeBufferLength];
        if(!UniCodeBuffer)
        {
            UniCodeBufferLength = 0;        // memory allocation failure
        }
    }
    else
    {
        UniCodeBuffer = NULL;
        UniCodeBufferLength = 0;
    }

    ReturnCode = WSALookupServiceNextW(
                    hLookup,
                    dwControlFlags,
                    &UniCodeBufferLength,
                    UniCodeBuffer );

    //
    // if the call did not supply a buffer, the user does have a buffer,
    // and it the call failed, do it again. This should never happen,
    // and if it does things are very odd, but account for it nonetheless.
    //

    if ( !UniCodeBuffer
              &&
         (*lpdwBufferLength >= sizeof(WSAQUERYSET))
              &&
         (ReturnCode == SOCKET_ERROR) )
    {
        ErrorCode = GetLastError();
        if (WSAEFAULT == ErrorCode)
        {
            //
            // delete old buffer, if any, and get a new buffer of the
            // proper size.
            //
            delete  (PBYTE)UniCodeBuffer;

            UniCodeBuffer = (LPWSAQUERYSETW) new BYTE[UniCodeBufferLength];

            //
            // if a buffer is allocated, call the provider again. Else,
            // return the EFAULT and the buffer size to the
            // caller to handle it.
            //
            if ( UniCodeBuffer )
            {
                ReturnCode = WSALookupServiceNextW(
                                hLookup,
                                dwControlFlags,
                                & UniCodeBufferLength,
                                UniCodeBuffer );
            }
        }
    }

    //
    // Either it worked, in which case UniCodeBuffer contains the results,
    // or it didn't work for one of the above branches.
    //
    if (ERROR_SUCCESS == ReturnCode)
    {
        ReturnCode = MapUnicodeQuerySetToAnsi(
                        UniCodeBuffer,
                        lpdwBufferLength,
                        lpqsResults);
        if ( ERROR_SUCCESS != ReturnCode )
        {
            SetLastError(ReturnCode);
            ReturnCode=SOCKET_ERROR;
        }
    }
    else
    {
        if ( GetLastError() == WSAEFAULT )
        {
            *lpdwBufferLength = UniCodeBufferLength + BONUSSIZE;
        }
    }

    if ( UniCodeBuffer != NULL )
    {
        delete (PBYTE)UniCodeBuffer;
    }
    return(ReturnCode);
}


INT
WSAAPI
WSALookupServiceNextW(
    IN      HANDLE          hLookup,
    IN      DWORD           dwControlFlags,
    IN OUT  LPDWORD         lpdwBufferLength,
    OUT     LPWSAQUERYSETW  lpqsResults
    )
/*++

Routine Description:

    WSALookupServiceNext() is called after obtaining a Handle from a previous
    call to WSALookupServiceBegin() in order to retrieve the requested service
    information.  The provider will pass back a WSAQUERYSET structure in the
    lpqsResults buffer.  The client should continue to call this API until it
    returns WSA_E_NOMORE, indicating that all of the WSAQUERYSET have been
    returned.

Arguments:

    hLookup - A Handle returned from the previous call to
              WSALookupServiceBegin().

    dwControlFlags - Flags to control the next operation.  This is currently
                     used to indicate to the provider what to do if the result
                     set is too big for the buffer.  If on the previous call to
                     WSALookupServiceNext() the result set was too large for
                     the buffer, the application can choose to do one of two
                     things on this call.  First, it can choose to pass a
                     bigger buffer and try again.  Second, if it cannot or is
                     unwilling to allocate a larger buffer, it can pass
                     LUP_FLUSHPREVIOUS to tell the provider to throw away the
                     last result set - which was too large - and move on to the
                     next set for this call.

    lpdwBufferLength - on input, the number of bytes contained in the buffer
                       pointed  to by lpresResults.  On output - if the API
                       fails, and the error is WSAEFAULT, then it contains the
                       minimum number of bytes to pass for the lpqsResults to
                       retrieve the record.

    lpqsResults - a pointer to a block of memory, which will contain one result
                  set in a WSAQUERYSET structure on return.

Returns:

    Zero if successful.
    SOCKET_ERROR on failure.  GetLastError() contains error code.

--*/
{
    INT       ReturnValue;
    INT       ErrorCode;
    PNSQUERY  Query;

    ErrorCode = TURBO_PROLOG();
    if ( ErrorCode != ERROR_SUCCESS )
    {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    }

    //
    // Verify that pointers are valid
    //

    if ( IsBadReadPtr(lpdwBufferLength, sizeof(*lpdwBufferLength) ) ||
         ( *lpdwBufferLength != 0  &&
           IsBadWritePtr(lpqsResults, *lpdwBufferLength) ) )
    {
        SetLastError (WSAEFAULT);
        return SOCKET_ERROR;
    }

    if ( !hLookup )
    {
        SetLastError(WSA_INVALID_HANDLE);
        return(SOCKET_ERROR);
    }

    Query = (PNSQUERY) hLookup;

    if ( !Query->ValidateAndReference() )
    {
        SetLastError(WSA_INVALID_HANDLE);
        return(SOCKET_ERROR);
    }

    ReturnValue = Query->LookupServiceNext(
                            dwControlFlags,
                            lpdwBufferLength,
                            lpqsResults );

    Query->Dereference();
    return( ReturnValue );
}


INT
WSAAPI
WSANSPIoctl(
    IN      HANDLE          hLookup,
    IN      DWORD           dwControlCode,
    IN      PVOID           lpvInBuffer,
    IN      DWORD           cbInBuffer,
    OUT     PVOID           lpvOutBuffer,
    IN      DWORD           cbOutBuffer,
    OUT     PDWORD          lpcbBytesReturned,
    IN      LPWSACOMPLETION lpCompletion
    )
/*++
Routine Description:

Arguments:

Returns:
--*/
{
    PDTHREAD Thread;
    PNSQUERY Query;
    int ReturnValue;
    int ErrorCode;
    
    ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return (SOCKET_ERROR);
    }

    //
    // Verify that the completion structure is readable if given.
    //
    if ((lpCompletion != NULL) && IsBadReadPtr(lpCompletion, sizeof(*lpCompletion))) {
        SetLastError(WSAEINVAL);
        return (SOCKET_ERROR);
    }

    //
    // Verify lpcbBytesReturned.
    //
    if ((lpcbBytesReturned == NULL) ||
        IsBadWritePtr(lpcbBytesReturned, sizeof(*lpcbBytesReturned))) {
        SetLastError(WSAEINVAL);
        return (SOCKET_ERROR);
    }

    //
    // Verify that the query handle is valid.
    //
    if (!hLookup) {
        SetLastError(WSA_INVALID_HANDLE);
        return (SOCKET_ERROR);
    }
    Query = (PNSQUERY)hLookup;
    if (!Query->ValidateAndReference()) {
        SetLastError(WSA_INVALID_HANDLE);
        return (SOCKET_ERROR);
    }

    //
    // Perform the IOCTL.
    //
    ReturnValue = Query->Ioctl(
                        dwControlCode,
                        lpvInBuffer,
                        cbInBuffer,
                        lpvOutBuffer,
                        cbOutBuffer,
                        lpcbBytesReturned,
                        lpCompletion,
                        Thread->GetWahThreadID()
                        );
    Query->Dereference();

    return( ReturnValue );
}


INT
WSAAPI
WSALookupServiceEnd(
    IN      HANDLE          hLookup
    )
/*++

Routine Description:

    WSALookupServiceEnd() is called to free the handle after previous calls to
    WSALookupServiceBegin() and WSALookupServiceNext().  Note that if you call
    WSALookupServiceEnd() from another thread while an existing
    WSALookupServiceNext() is blocked, then the end call will have the same
    effect as a cancel, and will cause the WSALookupServiceNext() call to
    return immediately.

Arguments:

    hLookup - Handle previously obtained by calling WSALookupServiceBegin().

Returns:

    Zero if the operation was successful.
    SOCKET_ERROR on failure, GetLastError() contains error code.

--*/
{
    INT       ReturnValue;
    INT       ErrorCode;
    PNSQUERY  Query;

    ErrorCode = TURBO_PROLOG();
    if ( ErrorCode != ERROR_SUCCESS )
    {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    }

    if ( !hLookup )
    {
        SetLastError(WSA_INVALID_HANDLE);
        return(SOCKET_ERROR);
    }

    Query = (PNSQUERY) hLookup;

    if ( !Query->ValidateAndReference() )
    {
        SetLastError(WSA_INVALID_HANDLE);
        return(SOCKET_ERROR);
    }

    ReturnValue = Query->LookupServiceEnd();

    Query->Dereference();
    Query->Dereference();   // Remove initial reference.
    //
    // Why ?
    //
    return( NO_ERROR );
}


INT
WSAAPI
WSASetServiceA(
    IN      LPWSAQUERYSETA      lpqsRegInfo,
    IN      WSAESETSERVICEOP    essOperation,
    IN      DWORD               dwControlFlags
    )
/*++

Routine Description:

    WSASetService() is used to register or deregister a service instance within
    one or more name spaces.  This function may be used to affect a specific
    name space provider, all providers associated with a specific name space,
    or all providers across all name spaces.

Arguments:

    lpqsRegInfo - specifies service information for registration, identifies
                  service for deregistration.

    essOperation - an enumeration whose values include:
        REGISTER register the service.  For SAP, this means sending out a
        periodic broadcast.  This is a NOP for the DNS name space.  For
        persistent data stores this means updating the address information.

        DEREGISTER deregister the service.  For SAP, this means stop sending
        out the periodic broadcast.  This is a NOP for the DNS name space.  For
        persistent data stores this means deleting address information.

        FLUSH used to initiate the registration requests that have previously
        occurred.

    dwControlFlags - The meaning of dwControlFlags is dependent on the value of
    essOperation as follows:

        essOperation    dwControlFlags    Meaning
        REGISTER        SERVICE_DEFER     delay the request (use FLUSH to
                                          subsequently issue the request)
                        SERVICE_HARD      send the request immediately.
                        SERVICE_MULTIPLE  the registering service can be
                                          represented by multiple instances.
        DEREGISTER      SERVICE_HARD      remove all knowledge of the object
                                          within the name space.
Returns:

    Zero if the operation was successful.
    SOCKET_ERROR on failure, GetLastError() contains error code.

--*/
{
    INT            ReturnCode;
    DWORD          ErrorCode;
    LPWSAQUERYSETW UniCodeBuffer;
    DWORD          UniCodeBufferSize;

    ReturnCode = SOCKET_ERROR;
    UniCodeBuffer = NULL;
    UniCodeBufferSize = 0;

    if ( !lpqsRegInfo )
    {
        SetLastError (WSAEFAULT);
        return SOCKET_ERROR;
    }

    //find out how big a buffer we need
    ErrorCode = MapAnsiQuerySetToUnicode(
        lpqsRegInfo,
        &UniCodeBufferSize,
        UniCodeBuffer);
    if (WSAEFAULT == ErrorCode){
        UniCodeBuffer = (LPWSAQUERYSETW) new BYTE[UniCodeBufferSize];
        if (UniCodeBuffer){
            ErrorCode = MapAnsiQuerySetToUnicode(
                lpqsRegInfo,
                &UniCodeBufferSize,
                UniCodeBuffer);
            if (ERROR_SUCCESS == ErrorCode){
                ReturnCode = WSASetServiceW(
                    UniCodeBuffer,
                    essOperation,
                    dwControlFlags);
            } //if
            delete UniCodeBuffer;
        } //if
    } //if
    return(ReturnCode);
}


typedef class NSCATALOGENTRYSTATE *PNSCATALOGENTRYSTATE;
class NSCATALOGENTRYSTATE {
public:
    NSCATALOGENTRYSTATE();

    INT
    Initialize(
        PNSCATALOGENTRY  CatalogEntry
        );

    PNSPROVIDER
    GetProvider(
        IN  PNSCATALOG    Catalog
        );

    ~NSCATALOGENTRYSTATE();

    LIST_ENTRY   m_context_linkage;
    //Public data member to support putting this object on a linked list
private:
    PNSCATALOGENTRY  m_catalog_entry;
    // Pointer to the NSCATALOGENTRY object associated with this boject.
}; // NSCATALOGENTRYSTATE

inline
NSCATALOGENTRYSTATE::NSCATALOGENTRYSTATE()
/*++

Routine Description:

    Constructor for the NSCATALOGENTRYSTATE object.  The first member function
    called after this must be Initialize.

Arguments:

    None

Return Value:

    Returns a pointer to a NSCATALOGENTRYSTATE object.
--*/
{
    m_catalog_entry = NULL;
}

inline
INT
NSCATALOGENTRYSTATE::Initialize(
    PNSCATALOGENTRY  CatalogEntry
    )
/*++

Routine Description:

    This  procedure  performs  all initialization for the NSCATALOGENTRYSTATE
    object.  This function  must  be  invoked  after the constructor, before
    any other member function is invoked.

Arguments:

    CatalogEntry - A pointer to a namespace catalog entry object.

Return Value:

    If  the  function  is  successful,  it  returns ERROR_SUCCESS, otherwise it
    returns an appropriate WinSock 2 error code.
--*/
{
    assert (m_catalog_entry==NULL);
    CatalogEntry->Reference ();
    m_catalog_entry = CatalogEntry;
    return(ERROR_SUCCESS);
}

PNSPROVIDER
NSCATALOGENTRYSTATE::GetProvider(
    IN  PNSCATALOG    Catalog
    )
/*++

Routine Description:

    Returns provider object associated with this object
    Loads it if necessary

Arguments:

    None

Return Value:

    NS provider object
--*/
{
    PNSPROVIDER     Provider;
    Provider = m_catalog_entry->GetProvider ();
    if (Provider==NULL) {
        INT ErrorCode = Catalog->LoadProvider (m_catalog_entry);
        if (ErrorCode==ERROR_SUCCESS) {
            Provider = m_catalog_entry->GetProvider ();
            assert (Provider!=NULL);
        }
    }

    return Provider;
}

inline
NSCATALOGENTRYSTATE::~NSCATALOGENTRYSTATE()
/*++

Routine Description:

    Denstructor for the NSCATALOGENTRYSTATE object. 

Arguments:

    None

Return Value:

    None
--*/
{
    if (m_catalog_entry!=NULL) {
        m_catalog_entry->Dereference ();
        m_catalog_entry = NULL;
    }
}



typedef struct _MATCH_PROVIDERS_CONTEXT {
    IN  BOOL            UseGuid;
    union {
        IN  GUID        ProviderId;
        IN  DWORD       NameSpaceId;
    };
    OUT LIST_ENTRY      EntryList;
    OUT INT             ErrorCode;
} MATCH_PROVIDERS_CONTEXT, * PMATCH_PROVIDERS_CONTEXT;

BOOL
MatchProviders(
    IN PVOID                PassBack,
    IN PNSCATALOGENTRY      CatalogEntry
    )
/*++

Routine Description:

    This function is the enumeration procedure passed to EnumerateCatalogItems
    in a call to WSASetServiceW(). This function inspects the current catalog
    item to see if it meets the selection criteria contained in the context
    value passed back from EnumerateCatalogItems(). 

Arguments:

    PassBack - The context value passed to EnumerateCatalogItems().

    CatalogEntry - A pointer to a NSCATALOGENTRY object.

Return Value:

    TRUE if the enumeration should be continued else FALSE.

--*/
{
    PMATCH_PROVIDERS_CONTEXT Context;
    BOOLEAN ContinueEnumeration = TRUE;
    BOOLEAN UseThisProvider = FALSE;

    Context = (PMATCH_PROVIDERS_CONTEXT)PassBack;
    if (Context->UseGuid) {
        if (Context->ProviderId==*(CatalogEntry->GetProviderId())) {
            UseThisProvider = TRUE;
        }
    }
    else {
        if (CatalogEntry->GetEnabledState () &&
                ((Context->NameSpaceId==CatalogEntry->GetNamespaceId()) ||
                    Context->NameSpaceId==NS_ALL)) {
            UseThisProvider = TRUE;
        }
    }

    if (UseThisProvider) {
        PNSCATALOGENTRYSTATE    EntryState;

        EntryState = new NSCATALOGENTRYSTATE;
        if (EntryState!=NULL) {
            EntryState->Initialize (CatalogEntry);
            InsertTailList (&Context->EntryList,
                                &EntryState->m_context_linkage);
        }
        else {
            Context->ErrorCode = WSA_NOT_ENOUGH_MEMORY;
            ContinueEnumeration = FALSE;
        }
    }

    return ContinueEnumeration;
}

INT WSAAPI
WSASetServiceW(
    IN  LPWSAQUERYSETW    lpqsRegInfo,
    IN  WSAESETSERVICEOP  essOperation,
    IN  DWORD             dwControlFlags
    )
/*++
Routine Description:
    WSASetService() is used to register or deregister a service instance within
    one or more name spaces.  This function may be used to affect a specific
    name space provider, all providers associated with a specific name space,
    or all providers across all name spaces.
Arguments:
    lpqsRegInfo - specifies service information for registration, identifies
                  service for deregistration.

    essOperation - an enumeration whose values include:
        REGISTER register the service.  For SAP, this means sending out a
        periodic broadcast.  This is a NOP for the DNS name space.  For
        persistent data stores this means updating the address information.

        DEREGISTER deregister the service.  For SAP, this means stop sending
        out the periodic broadcast.  This is a NOP for the DNS name space.  For
        persistent data stores this means deleting address information.

        FLUSH used to initiate the registration requests that have previously
        occurred.

    dwControlFlags - The meaning of dwControlFlags is dependent on the value of
    essOperation as follows:

        essOperation    dwControlFlags    Meaning
        REGISTER        SERVICE_DEFER     delay the request (use FLUSH to
                                          subsequently issue the request)
                        SERVICE_HARD      send the request immediately.
                        SERVICE_MULTIPLE  the registering service can be
                                          represented by multiple instances.
        DEREGISTER      SERVICE_HARD      remove all knowledge of the object
                                          within the name space.
Returns:
    The return value is 0 if the operation was successful.  Otherwise the value
    SOCKET_ERROR is returned.
--*/
{
    PDPROCESS          Process;
    PDTHREAD           Thread;
    INT                ErrorCode;
    PNSCATALOG         Catalog;
    MATCH_PROVIDERS_CONTEXT Context;

    if ( !lpqsRegInfo )
    {
        SetLastError (WSAEFAULT);
        return SOCKET_ERROR;
    }

    ErrorCode = PROLOG(&Process,
                        &Thread);
    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    } //if

    Catalog = Process->GetNamespaceCatalog();

    __try {
        if (lpqsRegInfo->lpNSProviderId!=NULL) {
            Context.ProviderId = *(lpqsRegInfo->lpNSProviderId);
            Context.UseGuid = TRUE;
        }
        else {
            Context.NameSpaceId = lpqsRegInfo->dwNameSpace;
            Context.UseGuid = FALSE;
        }
    }
    __except (WS2_EXCEPTION_FILTER()) {
        SetLastError (WSAEFAULT);
        return(SOCKET_ERROR);
    }

    InitializeListHead (&Context.EntryList);
    Context.ErrorCode = ERROR_SUCCESS;

    Catalog->EnumerateCatalogItems(
        MatchProviders,
        &Context);

    if (Context.ErrorCode == ERROR_SUCCESS) {
        ErrorCode = NO_DATA;
        while (!IsListEmpty (&Context.EntryList)) {
            PNSCATALOGENTRYSTATE    EntryState;
            PLIST_ENTRY             ListItem;
            PNSPROVIDER             Provider;
            ListItem = RemoveHeadList (&Context.EntryList);
            EntryState = CONTAINING_RECORD (ListItem,
                                                NSCATALOGENTRYSTATE,
                                                m_context_linkage
                                                );
            Provider = EntryState->GetProvider (Catalog);
            if (Provider!=NULL) {
                if (Provider->NSPSetService(
                                        NULL, // lpServiceClassInfo
                                        lpqsRegInfo,
                                        essOperation,
                                        dwControlFlags)==ERROR_SUCCESS) {
                    ErrorCode = ERROR_SUCCESS;
                }
                else {
                    if (ErrorCode!=ERROR_SUCCESS) {
                        ErrorCode = GetLastError ();
                        //
                        // Reset error code if provider fails
                        // to set last error for some reason
                        //
                        if (ErrorCode==ERROR_SUCCESS)
                            ErrorCode = NO_DATA;
                    }
                }
            }
            delete EntryState;
        }
    }
    else
        ErrorCode = Context.ErrorCode;

    if (ErrorCode == ERROR_SUCCESS) {
        return (ERROR_SUCCESS);
    }
    else {
        SetLastError(ErrorCode);
        return (SOCKET_ERROR);
    }
}


INT WSAAPI
WSAInstallServiceClassA(
    IN  LPWSASERVICECLASSINFOA   lpServiceClassInfo
    )
/*++
Routine Description:
    WSAInstallServiceClass() is used to register a service class schema within
    a name space. This schema includes the class name, class id, and any name
    space specific information that is common to all instances of the service,
    such as the SAP ID or object ID.

Arguments:
    lpServiceClasslnfo - contains service class to name space specific type
                         mapping information.  Multiple mappings can be handled
                         at one time.
Returns:
    The return value is 0 if the operation was successful.  Otherwise the value
    SOCKET_ERROR is returned.
--*/
{
    LPWSASERVICECLASSINFOW WideServiceClassInfo;
    DWORD WideServiceClassInfoSize;
    DWORD ErrorCode;
    INT   ReturnCode;

    if ( !lpServiceClassInfo ) {
        SetLastError (WSAEINVAL);
        return SOCKET_ERROR;
    }

    WideServiceClassInfo = NULL;
    WideServiceClassInfoSize = 0;
    ReturnCode = SOCKET_ERROR;

    //Find the size of buffer we are going to need
    ErrorCode = MapAnsiServiceClassInfoToUnicode(
        lpServiceClassInfo,
        &WideServiceClassInfoSize,
        WideServiceClassInfo);

    if (WSAEFAULT == ErrorCode){
        WideServiceClassInfo = (LPWSASERVICECLASSINFOW)
            new BYTE[WideServiceClassInfoSize];
        if (WideServiceClassInfo){
            ErrorCode = MapAnsiServiceClassInfoToUnicode(
                lpServiceClassInfo,
                &WideServiceClassInfoSize,
                WideServiceClassInfo);
            if (ERROR_SUCCESS == ErrorCode){
                ReturnCode = WSAInstallServiceClassW(
                    WideServiceClassInfo);
            } //if
            delete WideServiceClassInfo;
        } //if
    } //if
    else{
        SetLastError(ErrorCode);
    } //else
    return(ReturnCode);

}

INT WSAAPI
WSAInstallServiceClassW(
    IN  LPWSASERVICECLASSINFOW   lpServiceClassInfo
    )
/*++
Routine Description:
    WSAInstallServiceClass() is used to register a service class schema within
    a name space. This schema includes the class name, class id, and any name
    space specific information that is common to all instances of the service,
    such as the SAP ID or object ID.

Arguments:
    lpServiceClasslnfo - contains service class to name space specific type
                         mapping information.  Multiple mappings can be handled
                         at one time.
Returns:
    The return value is 0 if the operation was successful.  Otherwise the value
    SOCKET_ERROR is returned.
--*/
{
    PDPROCESS       Process;
    PDTHREAD        Thread;
    INT             ErrorCode;
    PNSCATALOG      Catalog;
    MATCH_PROVIDERS_CONTEXT Context;

    ErrorCode = PROLOG(&Process,
                        &Thread);
    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    } //if

    if ( !lpServiceClassInfo ) {
        SetLastError(WSAEINVAL);
        return(SOCKET_ERROR);
    }

    Catalog = Process->GetNamespaceCatalog();

    //
    // Specifying all namespaces gives us all enabled providers
    // which is exactly what we want
    //

    Context.NameSpaceId = NS_ALL;
    Context.UseGuid = FALSE;
    InitializeListHead (&Context.EntryList);
    Context.ErrorCode = ERROR_SUCCESS;

    Catalog->EnumerateCatalogItems(
        MatchProviders,
        &Context);

    if (Context.ErrorCode == ERROR_SUCCESS)
    {
        ErrorCode = NO_DATA;

        while (!IsListEmpty (&Context.EntryList))
        {
            PNSCATALOGENTRYSTATE    EntryState;
            PLIST_ENTRY             ListItem;
            PNSPROVIDER             Provider;

            ListItem = RemoveHeadList (&Context.EntryList);
            EntryState = CONTAINING_RECORD (ListItem,
                                                NSCATALOGENTRYSTATE,
                                                m_context_linkage
                                                );

            Provider = EntryState->GetProvider (Catalog);

            if (Provider!=NULL)
            {
                INT Error = Provider->NSPInstallServiceClass(
                                         lpServiceClassInfo);

                if (!Error)
                {
                    ErrorCode = ERROR_SUCCESS;
                }
                else
                {
                    if (ErrorCode)
                    {
                        ErrorCode = GetLastError();
                        //
                        // Reset error code if provider fails
                        // to set last error for some reason
                        //
                        if (ErrorCode==ERROR_SUCCESS)
                            ErrorCode = NO_DATA;
                    }
                }
            }
            delete EntryState;
        }
    }
    else
        ErrorCode = Context.ErrorCode;

    if (ErrorCode == ERROR_SUCCESS)
    {
        return (ERROR_SUCCESS);
    }
    else
    {
        SetLastError(ErrorCode);
        return (SOCKET_ERROR);
    }
}


INT WSAAPI
WSARemoveServiceClass(
    IN  LPGUID  lpServiceClassId
    )
/*++
Routine Description:
    WSARemoveServiceClass() is used to permanently unregister service class
    schema.
Arguments:
    lpServiceClassId - Pointer to the service class GUID that you wish to
                       remove.
Returns:
    The return value is 0 if the operation was successful.  Otherwise the value
    SOCKET_ERROR is returned.

--*/
{
    PDPROCESS       Process;
    PDTHREAD        Thread;
    INT             ErrorCode;
    PNSCATALOG      Catalog;
    MATCH_PROVIDERS_CONTEXT Context;

    ErrorCode = PROLOG(&Process,
                        &Thread);
    if (ErrorCode != ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    } //if

    if ( !lpServiceClassId )
    {
        SetLastError(WSAEINVAL);
        return(SOCKET_ERROR);
    }

    Catalog = Process->GetNamespaceCatalog();
    //
    // Specifying all namespaces gives us all enabled providers
    // which is exactly what we want
    //

    Context.NameSpaceId = NS_ALL;
    Context.UseGuid = FALSE;
    InitializeListHead (&Context.EntryList);
    Context.ErrorCode = ERROR_SUCCESS;

    Catalog->EnumerateCatalogItems(
        MatchProviders,
        &Context);

    if (Context.ErrorCode == ERROR_SUCCESS)
    {
        ErrorCode = NO_DATA;

        while (!IsListEmpty (&Context.EntryList))
        {
            PNSCATALOGENTRYSTATE    EntryState;
            PLIST_ENTRY             ListItem;
            PNSPROVIDER             Provider;

            ListItem = RemoveHeadList (&Context.EntryList);
            EntryState = CONTAINING_RECORD (ListItem,
                                                NSCATALOGENTRYSTATE,
                                                m_context_linkage
                                                );

            Provider = EntryState->GetProvider (Catalog);

            if (Provider!=NULL)
            {
                INT Error = Provider->NSPRemoveServiceClass(lpServiceClassId);

                if (!Error)
                {
                    ErrorCode = ERROR_SUCCESS;
                }
                else
                {
                    if (ErrorCode)
                    {
                        ErrorCode = GetLastError();
                        //
                        // Reset error code if provider fails
                        // to set last error for some reason
                        //
                        if (ErrorCode==ERROR_SUCCESS)
                            ErrorCode = NO_DATA;
                    }
                }
            }
            delete EntryState;
        }
    }
    else
        ErrorCode = Context.ErrorCode;

    if (ErrorCode == ERROR_SUCCESS)
    {
        return (ERROR_SUCCESS);
    }
    else
    {
        SetLastError(ErrorCode);
        return (SOCKET_ERROR);
    }
}


INT WSAAPI
WSAGetServiceClassNameByClassIdA(
    IN      LPGUID  lpServiceClassId,
    OUT     LPSTR lpszServiceClassName,
    IN OUT  LPDWORD lpdwBufferLength
    )
/*++
Routine Description:
    This API will return the name of the service associated with the given
    type.  This name is the generic service name, like FTP, or SNA, and not the
    name of a specific instance of that service.

Arguments:
    lpServiceClassId - pointer to the GUID for the service class.

    lpszServiceClassName - service name.

    lpdwBufferLength - on input length of buffer returned by
                       lpszServiceClassName. On output, the length of the
                       service name copied into lpszServiceClassName.

Returns:
    The return value is 0 if the operation was successful.  Otherwise the value
    SOCKET_ERROR is returned.

--*/
{
    PDPROCESS       Process;
    PDTHREAD        Thread;
    INT             ErrorCode;
    PNSCATALOG      Catalog;
    MATCH_PROVIDERS_CONTEXT Context;

    ErrorCode = PROLOG(&Process,
                        &Thread);
    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    } //if

    Catalog = Process->GetNamespaceCatalog();
    //
    // Specifying all namespaces gives us all enabled providers
    // which is exactly what we want
    //

    Context.NameSpaceId = NS_ALL;
    Context.UseGuid = FALSE;
    InitializeListHead (&Context.EntryList);
    Context.ErrorCode = ERROR_SUCCESS;

    Catalog->EnumerateCatalogItems(
        MatchProviders,
        &Context);

    if (Context.ErrorCode == ERROR_SUCCESS) {
        ErrorCode = NO_DATA;
        while (!IsListEmpty (&Context.EntryList)) {
            PNSCATALOGENTRYSTATE    EntryState;
            PLIST_ENTRY             ListItem;
            PNSPROVIDER             Provider;
            WSASERVICECLASSINFOW    Buffer, *pBuffer;
            DWORD                   BufferSize;

            ListItem = RemoveHeadList (&Context.EntryList);
            EntryState = CONTAINING_RECORD (ListItem,
                                                NSCATALOGENTRYSTATE,
                                                m_context_linkage
                                                );

            Provider = EntryState->GetProvider (Catalog);
            if (Provider!=NULL) {
                BufferSize = sizeof (Buffer);
                Buffer.lpServiceClassId = lpServiceClassId;
                ErrorCode = Provider->NSPGetServiceClassInfo(
                                                &BufferSize,
                                                &Buffer);
                if(ErrorCode == ERROR_SUCCESS)
                {
                    //
                    // this is impossible. The provider has made an error, so
                    // concoct an error for it.
                    //
                    //
                    // ErrorCode = WSANO_DATA; // done above
                }
                else
                {
                    ErrorCode = GetLastError();
                    if (ErrorCode==ERROR_SUCCESS)
                        ErrorCode = WSANO_DATA;
                }

                if (WSAEFAULT == ErrorCode){
                    // The service provider claimed that it had an answer but our
                    // buffer was to small big suprise :-() so get a new buffer and go
                    // get the answer.
                    pBuffer = (LPWSASERVICECLASSINFOW) new BYTE[BufferSize];

                    if( pBuffer != NULL ) {

                        pBuffer->lpServiceClassId = lpServiceClassId;

                        ErrorCode = Provider->NSPGetServiceClassInfo(
                                        &BufferSize,
                                        pBuffer);
                        if ( ErrorCode == ERROR_SUCCESS &&
                             pBuffer->lpszServiceClassName )
                        {
                            DWORD StringLen = ((wcslen(pBuffer->lpszServiceClassName)+1)
                                                * sizeof(WCHAR));

                            __try {
                                if (*lpdwBufferLength >= StringLen){
                                    WideCharToMultiByte(
                                        CP_ACP,                         // CodePage (ANSI)
                                        0,                              // dwFlags
                                        pBuffer->lpszServiceClassName,  // lpWideCharStr
                                        -1,                             // cchWideChar
                                        lpszServiceClassName,           // lpMultiByteStr
                                        StringLen,                      // cchMultiByte
                                        NULL,                           // lpDefaultChar
                                        NULL                            // lpUsedDefaultChar
                                        );
                    
                                } //if
                                else{
                                    ErrorCode  = WSAEFAULT;
                                } //else
                                *lpdwBufferLength = StringLen;
                            }
                            __except (WS2_EXCEPTION_FILTER()) {
                                // Not much more we can do
                                ErrorCode = WSAEFAULT;
                            }

                        }
                        else
                        {
                            ErrorCode = GetLastError();
                            if (ErrorCode==ERROR_SUCCESS)
                                ErrorCode = WSANO_DATA;
                        }
                        delete pBuffer;
                    }
                    else {
                        ErrorCode = WSAENOBUFS;
                    }

                    delete EntryState;
                    // Provider at least once told us that he has
                    // something for us. Delete the rest and complete.
                    while (!IsListEmpty (&Context.EntryList)) {
                        ListItem = RemoveHeadList (&Context.EntryList);
                        EntryState = CONTAINING_RECORD (ListItem,
                                                            NSCATALOGENTRYSTATE,
                                                            m_context_linkage
                                                            );
                        delete EntryState;
                    }
                    break;
                } //if GetSize call succeeded
            } //if Provider is loaded
            delete EntryState;
        }
    }
    else
        ErrorCode = Context.ErrorCode;

    if (ErrorCode == ERROR_SUCCESS) {
        return (ERROR_SUCCESS);
    }
    else {
        SetLastError(ErrorCode);
        return (SOCKET_ERROR);
    }
}

INT WSAAPI
WSAGetServiceClassNameByClassIdW(
    IN      LPGUID  lpServiceClassId,
    OUT     LPWSTR lpszServiceClassName,
    IN OUT  LPDWORD lpdwBufferLength
    )
/*++
Routine Description:
    This API will return the name of the service associated with the given
    type.  This name is the generic service name, like FTP, or SNA, and not the
    name of a specific instance of that service.

Arguments:
    lpServiceClassId - pointer to the GUID for the service class.

    lpszServiceClassName - service name.

    lpdwBufferLength - on input length of buffer returned by
                       lpszServiceClassName. On output, the length of the
                       service name copied into lpszServiceClassName.

Returns:
    The return value is 0 if the operation was successful.  Otherwise the value
    SOCKET_ERROR is returned.

--*/
{
    PDPROCESS       Process;
    PDTHREAD        Thread;
    INT             ErrorCode;
    PNSCATALOG      Catalog;
    MATCH_PROVIDERS_CONTEXT Context;

    ErrorCode = PROLOG(&Process,
                        &Thread);
    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    } //if

    Catalog = Process->GetNamespaceCatalog();
    //
    // Specifying all namespaces gives us all enabled providers
    // which is exactly what we want
    //

    Context.NameSpaceId = NS_ALL;
    Context.UseGuid = FALSE;
    InitializeListHead (&Context.EntryList);
    Context.ErrorCode = ERROR_SUCCESS;

    Catalog->EnumerateCatalogItems(
        MatchProviders,
        &Context);

    if (Context.ErrorCode == ERROR_SUCCESS) {
        ErrorCode = NO_DATA;
        while (!IsListEmpty (&Context.EntryList)) {
            PNSCATALOGENTRYSTATE    EntryState;
            PLIST_ENTRY             ListItem;
            PNSPROVIDER             Provider;
            WSASERVICECLASSINFOW    Buffer, *pBuffer;
            DWORD                   BufferSize;

            ListItem = RemoveHeadList (&Context.EntryList);
            EntryState = CONTAINING_RECORD (ListItem,
                                                NSCATALOGENTRYSTATE,
                                                m_context_linkage
                                                );

            Provider = EntryState->GetProvider (Catalog);
            if (Provider!=NULL) {
                BufferSize = sizeof (Buffer);
                Buffer.lpServiceClassId = lpServiceClassId;
                ErrorCode = Provider->NSPGetServiceClassInfo(
                                                &BufferSize,
                                                &Buffer);
                if(ErrorCode == ERROR_SUCCESS)
                {
                    //
                    // this is impossible. The provider has made an error, so
                    // concoct an error for it.
                    //
                    //
                    // ErrorCode = WSANO_DATA; // done above
                }
                else
                {
                    ErrorCode = GetLastError();
                    if (ErrorCode==ERROR_SUCCESS)
                        ErrorCode = WSANO_DATA;
                }

                if (WSAEFAULT == ErrorCode){
                    // The service provider claimed that it had an answer but our
                    // buffer was to small big suprise :-() so get a new buffer and go
                    // get the answer.
                    pBuffer = (LPWSASERVICECLASSINFOW) new BYTE[BufferSize];

                    if( pBuffer != NULL ) {

                        pBuffer->lpServiceClassId = lpServiceClassId;

                        ErrorCode = Provider->NSPGetServiceClassInfo(
                                        &BufferSize,
                                        pBuffer);
                        if(ErrorCode == ERROR_SUCCESS) {
                            DWORD StringLen = ((wcslen(pBuffer->lpszServiceClassName)+1)
                                                * sizeof(WCHAR));

                            __try {
                                if (*lpdwBufferLength >= StringLen){
                                    wcscpy( lpszServiceClassName,
                                            pBuffer->lpszServiceClassName);
                    
                                } //if
                                else{
                                    ErrorCode  = WSAEFAULT;
                                } //else
                                *lpdwBufferLength = StringLen;
                            }
                            __except (WS2_EXCEPTION_FILTER()) {
                                // Not much more we can do
                                ErrorCode = WSAEFAULT;
                            }

                        }
                        else
                        {
                            ErrorCode = GetLastError();
                            if (ErrorCode==ERROR_SUCCESS)
                                ErrorCode = WSANO_DATA;
                        }
                        delete pBuffer;
                    }
                    else {
                        ErrorCode = WSAENOBUFS;
                    }

                    delete EntryState;
                    // Provider at least once told us that he has
                    // something for us. Delete the rest and complete.
                    while (!IsListEmpty (&Context.EntryList)) {
                        ListItem = RemoveHeadList (&Context.EntryList);
                        EntryState = CONTAINING_RECORD (ListItem,
                                                            NSCATALOGENTRYSTATE,
                                                            m_context_linkage
                                                            );
                        delete EntryState;
                    }
                    break;
                } //if GetSize call succeeded
            } //if Provider is loaded
            delete EntryState;
        }
    }
    else
        ErrorCode = Context.ErrorCode;

    if (ErrorCode == ERROR_SUCCESS) {
        return (ERROR_SUCCESS);
    }
    else {
        SetLastError(ErrorCode);
        return (SOCKET_ERROR);
    }
}




INT
WSAAPI
WSAGetServiceClassInfoA(
    IN  LPGUID                  lpProviderId,
    IN  LPGUID                  lpServiceClassId,
    OUT LPDWORD                 lpdwBufSize,
    OUT LPWSASERVICECLASSINFOA  lpServiceClassInfo
    )
/*++

Routine Description:

    WSAGetServiceClassInfo() is used to retrieve all of the class information
    (schema) pertaining to a specified service class from a specified name
    space provider.

Arguments:

    lpProviderId - Pointer to a GUID which identifies a specific name space
                   provider.

    lpServiceClassId - Pointer to a GUID identifying the service class in
                       question.

    lpdwBufferLength - on input, the number of bytes contained in the buffer
                       pointed  to by lpServiceClassInfos.  On output - if the
                       API fails, and the error is WSAEFAULT, then it contains
                       the minimum number of bytes to pass for the
                       lpServiceClassInfo to retrieve the record.

    lpServiceClasslnfo - returns service class information from the indicated
                         name space provider for the specified service class.

Return Value:

    The return value is 0 if the operation was successful.  Otherwise the value
    SOCKET_ERROR is returned.

--*/
{
    LPWSASERVICECLASSINFOW WideServiceClassInfo;
    INT   ReturnCode;
    DWORD ErrorCode;

    if (!lpProviderId ||      // Fix for bug #102088
        !lpServiceClassId ||
        !lpdwBufSize ||
        !lpServiceClassInfo ) {
        SetLastError(WSAEINVAL);
        return(SOCKET_ERROR);
    }

    ReturnCode = SOCKET_ERROR;
    ErrorCode = WSAEINVAL;

    WideServiceClassInfo =(LPWSASERVICECLASSINFOW) new BYTE[*lpdwBufSize];
    if (WideServiceClassInfo){
        ReturnCode = WSAGetServiceClassInfoW(
            lpProviderId,
            lpServiceClassId,
            lpdwBufSize,
            WideServiceClassInfo);
        if (ERROR_SUCCESS == ReturnCode){
            MapUnicodeServiceClassInfoToAnsi(
                WideServiceClassInfo,
                lpdwBufSize,
                lpServiceClassInfo);
        } //if
        else{
            ErrorCode = GetLastError();
        } //else
        delete WideServiceClassInfo;
    } //if

    if (ERROR_SUCCESS != ReturnCode){
        SetLastError(ErrorCode);
    } //if
    return(ReturnCode);
}


INT
WSAAPI
WSAGetServiceClassInfoW(
    IN  LPGUID  lpProviderId,
    IN  LPGUID  lpServiceClassId,
    IN  OUT LPDWORD  lpdwBufSize,
    OUT LPWSASERVICECLASSINFOW lpServiceClassInfo
)
/*++

Routine Description:

    WSAGetServiceClassInfo() is used to retrieve all of the class information
    (schema) pertaining to a specified service class from a specified name
    space provider.

Arguments:

    lpProviderId - Pointer to a GUID which identifies a specific name space
                   provider.

    lpServiceClassId - Pointer to a GUID identifying the service class in
                       question.

    lpdwBufferLength - on input, the number of bytes contained in the buffer
                       pointed  to by lpServiceClassInfos.  On output - if the
                       API fails, and the error is WSAEFAULT, then it contains
                       the minimum number of bytes to pass for the
                       lpServiceClassInfo to retrieve the record.

    lpServiceClasslnfo - returns service class information from the indicated
                         name space provider for the specified service class.

Return Value:

    The return value is 0 if the operation was successful.  Otherwise the value
    SOCKET_ERROR is returned.

--*/
{

    PDPROCESS       Process;
    PDTHREAD        Thread;
    INT             ErrorCode;
    PNSCATALOG      Catalog;
    PNSPROVIDER     Provider;
    PNSCATALOGENTRY CatalogEntry;

    if (!lpProviderId ||      // Fix for bug #102088
        !lpServiceClassId ||
        !lpdwBufSize ||
        !lpServiceClassInfo ) {
        SetLastError(WSAEINVAL);
        return(SOCKET_ERROR);
    }

    ErrorCode = PROLOG(&Process,
                        &Thread);
    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    }

    Catalog = Process->GetNamespaceCatalog();
    ErrorCode = Catalog->GetCountedCatalogItemFromProviderId(
        lpProviderId,
        &CatalogEntry);
    if(ERROR_SUCCESS == ErrorCode){
        if (CatalogEntry->GetEnabledState()) {
            WSASERVICECLASSINFOW scliTemp;
            Provider = CatalogEntry->GetProvider();
            if (Provider==NULL) {
                ErrorCode = Catalog->LoadProvider (CatalogEntry);
                if (ErrorCode!=NO_ERROR) {
                    goto DereferenceEntry;
                }
                Provider = CatalogEntry->GetProvider ();
                assert (Provider!=NULL);
            }


            __try {
                if(*lpdwBufSize < sizeof(*lpServiceClassInfo)) {
                    //
                    // this is sleazy as we don't adjust the buffer
                    // size. But it makes things work
                    //
                    lpServiceClassInfo = &scliTemp;
                }
                lpServiceClassInfo->lpServiceClassId = lpServiceClassId;
            }
            __except (WS2_EXCEPTION_FILTER()) {
                ErrorCode = WSAEFAULT;
                goto DereferenceEntry;
            }
            if (Provider->NSPGetServiceClassInfo(
                   lpdwBufSize,
                   lpServiceClassInfo)!=ERROR_SUCCESS) {
                ErrorCode = GetLastError ();
                if (ErrorCode==ERROR_SUCCESS)
                    ErrorCode = WSANO_DATA;

            }
        }
        else {
            ErrorCode = WSAEINVAL;
        }
    DereferenceEntry:
        CatalogEntry->Dereference ();
    }

    if(ErrorCode == ERROR_SUCCESS) {
        return ERROR_SUCCESS;
    }
    else {
        SetLastError(ErrorCode);
        return SOCKET_ERROR;
    }

}

INT
WSAAPI
WSAAddressToStringW(
    IN     LPSOCKADDR          lpsaAddress,
    IN     DWORD               dwAddressLength,
    IN     LPWSAPROTOCOL_INFOW lpProtocolInfo,
    IN OUT LPWSTR              lpszAddressString,
    IN OUT LPDWORD             lpdwAddressStringLength
    )
/*++

Routine Description:

    WSAAddressToString() converts a SOCKADDR structure into a human-readable
    string representation of the address.  This is intended to be used mainly
    for display purposes. If the caller wishes the translation to be done by a
    particular provider, it should supply the corresponding WSAPROTOCOL_INFO
    struct in the lpProtocolInfo parameter.

Arguments:

    lpsaAddress - points to a SOCKADDR structure to translate into a string.

    dwAddressLength - the length of the Address SOCKADDR.

    lpProtocolInfo - (optional) the WSAPROTOCOL_INFO struct for a particular
                     provider.

    lpszAddressString - a buffer which receives the human-readable address
                        string.

    lpdwAddressStringLength - on input, the length of the AddressString buffer.
                              On output, returns the length of  the string
                              actually copied into the buffer.

Return Value:

    The return value is 0 if the operation was successful.  Otherwise the value
    SOCKET_ERROR is returned
--*/
{
    INT                 ReturnValue;
    PDPROCESS           Process;
    PDTHREAD            Thread;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDCATALOG           Catalog;
    PPROTO_CATALOG_ITEM CatalogEntry;
    LPWSAPROTOCOL_INFOW ProtocolInfo;

    ErrorCode = PROLOG(&Process,
                        &Thread);
    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    } //if

    if (!lpsaAddress ||      // Fix for bug #114256
        !dwAddressLength ||
        !lpszAddressString ||
        !lpdwAddressStringLength ) {
        SetLastError(WSAEINVAL);
        return(SOCKET_ERROR);
    }

    // Find a provider that can support the user request
    Catalog = Process->GetProtocolCatalog();

    if (lpProtocolInfo) {
        DWORD   dwCatalogEntryId;
        __try {
            dwCatalogEntryId = lpProtocolInfo->dwCatalogEntryId;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            SetLastError(WSAEFAULT);
            return(SOCKET_ERROR);
        }

        ErrorCode =  Catalog->GetCountedCatalogItemFromCatalogEntryId(
            dwCatalogEntryId,
            &CatalogEntry);
    } //if
    else {
        int family;
        __try {
            family = lpsaAddress->sa_family;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            SetLastError(WSAEFAULT);
            return(SOCKET_ERROR);
        }

        ErrorCode = Catalog->GetCountedCatalogItemFromAddressFamily(
            family,
            &CatalogEntry);
    }

    if ( ERROR_SUCCESS == ErrorCode) {
        ProtocolInfo = CatalogEntry->GetProtocolInfo();
        assert( ProtocolInfo != NULL );
        Provider = CatalogEntry->GetProvider();
        ReturnValue = Provider->WSPAddressToString(
            lpsaAddress,
            dwAddressLength,
            ProtocolInfo,
            lpszAddressString,
            lpdwAddressStringLength,
            &ErrorCode);
        CatalogEntry->Dereference ();
        if (ReturnValue==ERROR_SUCCESS)
            return ERROR_SUCCESS;
    } //if

    SetLastError(ErrorCode);
    return(SOCKET_ERROR);

}


INT
WSAAPI
WSAAddressToStringA(
    IN     LPSOCKADDR          lpsaAddress,
    IN     DWORD               dwAddressLength,
    IN     LPWSAPROTOCOL_INFOA lpProtocolInfo,
    IN OUT LPSTR               lpszAddressString,
    IN OUT LPDWORD             lpdwAddressStringLength
    )
/*++

Routine Description:

    WSAAddressToString() converts a SOCKADDR structure into a human-readable
    string representation of the address.  This is intended to be used mainly
    for display purposes. If the caller wishes the translation to be done by a
    particular provider, it should supply the corresponding WSAPROTOCOL_INFO
    struct in the lpProtocolInfo parameter.

Arguments:

    lpsaAddress - points to a SOCKADDR structure to translate into a string.

    dwAddressLength - the length of the Address SOCKADDR.

    lpProtocolInfo - (optional) the WSAPROTOCOL_INFO struct for a particular
                     provider.

    lpszAddressString - a buffer which receives the human-readable address
                        string.

    lpdwAddressStringLength - on input, the length of the AddressString buffer.
                              On output, returns the length of  the string
                              actually copied into the buffer.

Return Value:

    The return value is 0 if the operation was successful.  Otherwise the value
    SOCKET_ERROR is returned
--*/
{
    INT                 ReturnValue;
    PDPROCESS           Process;
    PDTHREAD            Thread;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDCATALOG           Catalog;
    PPROTO_CATALOG_ITEM CatalogEntry;
    LPWSAPROTOCOL_INFOW ProtocolInfo;
    LPWSTR              LocalString;
    DWORD               LocalStringLength;


    ErrorCode = PROLOG(&Process,
                        &Thread);
    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    } //if

    if (!lpsaAddress ||      // Fix for bug #114256
        !dwAddressLength ||
        !lpszAddressString ||
        !lpdwAddressStringLength ) {
        SetLastError(WSAEINVAL);
        return(SOCKET_ERROR);
    }

    //Get a buffer to hold the unicode string the service provider is going to
    //return
    __try {
        LocalStringLength = *lpdwAddressStringLength;
    }
    __except (WS2_EXCEPTION_FILTER()) {
        SetLastError(WSAEFAULT);
        return(SOCKET_ERROR);
    }

    LocalString = (LPWSTR) new WCHAR[LocalStringLength];
    if (LocalString==NULL) {
        SetLastError(WSAENOBUFS);
        return(SOCKET_ERROR);
    } //if

    // Find a provider that can support the user request
    Catalog = Process->GetProtocolCatalog();

    if (lpProtocolInfo) {
        DWORD   dwCatalogEntryId;
        __try {
            dwCatalogEntryId = lpProtocolInfo->dwCatalogEntryId;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            delete(LocalString);
            SetLastError(WSAEFAULT);
            return(SOCKET_ERROR);
        }

        ErrorCode =  Catalog->GetCountedCatalogItemFromCatalogEntryId(
            dwCatalogEntryId,
            &CatalogEntry);
    } //if
    else {
        int family;
        __try {
            family = lpsaAddress->sa_family;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            delete(LocalString);
            SetLastError(WSAEFAULT);
            return(SOCKET_ERROR);
        }

        ErrorCode = Catalog->GetCountedCatalogItemFromAddressFamily(
            family,
            &CatalogEntry);
    }

    if ( ERROR_SUCCESS == ErrorCode) {
        ProtocolInfo = CatalogEntry->GetProtocolInfo();
        assert( ProtocolInfo != NULL );
        Provider = CatalogEntry->GetProvider();

        ReturnValue = Provider->WSPAddressToString(
            lpsaAddress,
            dwAddressLength,
            ProtocolInfo,
            LocalString,
            lpdwAddressStringLength,
            &ErrorCode);

        if (ERROR_SUCCESS == ReturnValue){
            __try {
                WideCharToMultiByte(
                    CP_ACP,                        // CodePage (Ansi)
                    0,                             // dwFlags
                    LocalString,                   // lpWideCharStr
                    -1,                            // cchWideCharStr
                    lpszAddressString,             // lpMultiByte
                    LocalStringLength,             // cchMultiByte
                    NULL,
                    NULL);
            }
            __except (WS2_EXCEPTION_FILTER()) {
                ErrorCode = WSAEFAULT;
                ReturnValue = SOCKET_ERROR;
            }
        } //if

        delete(LocalString);
        CatalogEntry->Dereference ();
        if (ReturnValue==ERROR_SUCCESS)
            return ERROR_SUCCESS;

    } //if
    else {
        delete(LocalString);
    }

    SetLastError(ErrorCode);
    return(SOCKET_ERROR);
}

INT
WSAAPI
WSAStringToAddressW(
    IN     LPWSTR              AddressString,
    IN     INT                 AddressFamily,
    IN     LPWSAPROTOCOL_INFOW lpProtocolInfo,
    IN OUT LPSOCKADDR          lpAddress,
    IN OUT LPINT               lpAddressLength
    )
/*++

Routine Description:

    WSAStringToAddress() converts a human-readable string to a socket address
    structure (SOCKADDR) suitable for pass to Windows Sockets routines which
    take such a structure.  If the caller wishes the translation to be done by
    a particular provider, it should supply the corresponding WSAPROTOCOL_INFOW
    struct in the lpProtocolInfo parameter.

Arguments:

    AddressString - points to the zero-terminated human-readable string to
                    convert.

    AddressFamily - the address family to which the string belongs.

    lpProtocolInfo - (optional) the WSAPROTOCOL_INFOW struct for a particular
                     provider.

    Address - a buffer which is filled with a single SOCKADDR structure.

    lpAddressLength - The length of the Address buffer.  Returns the size of
                      the resultant SOCKADDR structure.

Return Value:

    The return value is 0 if the operation was successful.  Otherwise the value
    SOCKET_ERROR is returned.

--*/
{
    INT                 ReturnValue;
    PDPROCESS           Process;
    PDTHREAD            Thread;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDCATALOG           Catalog;
    PPROTO_CATALOG_ITEM CatalogEntry;
    LPWSAPROTOCOL_INFOW ProtocolInfo;

    ErrorCode = PROLOG(&Process,
                        &Thread);
    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    } //if

    // Find a provider that can support the user request
    Catalog = Process->GetProtocolCatalog();

    if (lpProtocolInfo) {
        DWORD dwCatalogEntryId;
        __try {
            dwCatalogEntryId =  lpProtocolInfo->dwCatalogEntryId;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            SetLastError(WSAEFAULT);
            return(SOCKET_ERROR);
        }
        ErrorCode =  Catalog->GetCountedCatalogItemFromCatalogEntryId(
            dwCatalogEntryId,
            &CatalogEntry);
    } //if
    else{
        ErrorCode = Catalog->GetCountedCatalogItemFromAddressFamily(
            AddressFamily,
            &CatalogEntry);
    }

    if ( ERROR_SUCCESS == ErrorCode) {
        ProtocolInfo = CatalogEntry->GetProtocolInfo();
        assert( ProtocolInfo != NULL );
        Provider = CatalogEntry->GetProvider();
        ReturnValue = Provider->WSPStringToAddress(
            AddressString,
            AddressFamily,
            ProtocolInfo,
            lpAddress,
            lpAddressLength,
            &ErrorCode);
        CatalogEntry->Dereference ();
        if (ReturnValue==ERROR_SUCCESS)
            return ERROR_SUCCESS;
    } //if

    SetLastError(ErrorCode);
    return(SOCKET_ERROR);
}

INT
WSAAPI
WSAStringToAddressA(
    IN     LPSTR               AddressString,
    IN     INT                 AddressFamily,
    IN     LPWSAPROTOCOL_INFOA lpProtocolInfo,
    IN OUT LPSOCKADDR          lpAddress,
    IN OUT LPINT               lpAddressLength
    )
/*++

Routine Description:

    WSAStringToAddress() converts a human-readable string to a socket address
    structure (SOCKADDR) suitable for pass to Windows Sockets routines which
    take such a structure.  If the caller wishes the translation to be done by
    a particular provider, it should supply the corresponding WSAPROTOCOL_INFOA
    struct in the lpProtocolInfo parameter.

Arguments:

    AddressString - points to the zero-terminated human-readable string to
                    convert.

    AddressFamily - the address family to which the string belongs.

    lpProtocolInfo - (optional) the WSAPROTOCOL_INFOA struct for a particular
                     provider.

    Address - a buffer which is filled with a single SOCKADDR structure.

    lpAddressLength - The length of the Address buffer.  Returns the size of
                      the resultant SOCKADDR structure.

Return Value:

    The return value is 0 if the operation was successful.  Otherwise the value
    SOCKET_ERROR is returned.

--*/
{
    INT                 ReturnValue;
    PDPROCESS           Process;
    PDTHREAD            Thread;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDCATALOG           Catalog;
    PPROTO_CATALOG_ITEM CatalogEntry;
    LPWSAPROTOCOL_INFOW ProtocolInfo;
    LPWSTR              LocalString;
    INT                 LocalStringLength;

    ErrorCode = PROLOG(&Process,
                        &Thread);
    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    } //if

    __try {
        // Get a buffer to hold the ansi string handed in by the user.
        LocalStringLength = strlen(AddressString)+1;
        LocalString = (LPWSTR)new WCHAR[LocalStringLength];
        if (LocalString==NULL) {
            SetLastError (WSAENOBUFS);
            return (SOCKET_ERROR);
        }

        MultiByteToWideChar(
            CP_ACP,                          // CodePage (Ansi)
            0,                               // dwFlags
            AddressString,                   // lpMultiByte
            -1,                              // cchMultiByte
            LocalString,                     // lpWideChar
            LocalStringLength);              // ccWideChar
    }
    __except (WS2_EXCEPTION_FILTER()) {
        SetLastError(WSAEFAULT);
        return(SOCKET_ERROR);
    }

    // Find a provider that can support the user request
    Catalog = Process->GetProtocolCatalog();

    if (lpProtocolInfo) {
        DWORD dwCatalogEntryId;
        __try {
            dwCatalogEntryId =  lpProtocolInfo->dwCatalogEntryId;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            delete (LocalString);
            SetLastError(WSAEFAULT);
            return(SOCKET_ERROR);
        }

        ErrorCode =  Catalog->GetCountedCatalogItemFromCatalogEntryId(
            dwCatalogEntryId,
            &CatalogEntry);
    } //if
    else{
        ErrorCode = Catalog->GetCountedCatalogItemFromAddressFamily(
            AddressFamily,
            &CatalogEntry);
    }

    if ( ERROR_SUCCESS == ErrorCode) {
        ProtocolInfo = CatalogEntry->GetProtocolInfo();
        assert( ProtocolInfo != NULL );

        Provider = CatalogEntry->GetProvider();

        ReturnValue = Provider->WSPStringToAddress(
            LocalString,
            AddressFamily,
            ProtocolInfo,
            lpAddress,
            lpAddressLength,
            &ErrorCode);
        CatalogEntry->Dereference ();
        delete(LocalString);
        if (ReturnValue==ERROR_SUCCESS)
            return ERROR_SUCCESS;
    } //if
    else {
        delete(LocalString);
    }


    SetLastError(ErrorCode);
    return(SOCKET_ERROR);
}



PNSCATALOG
OpenInitializedNameSpaceCatalog()
{
    BOOL ReturnCode = TRUE;
    PNSCATALOG ns_catalog;
    HKEY RegistryKey = 0;

     TRY_START(mem_guard){

        //
        // Build the protocol catalog
        //

        ns_catalog = new (NSCATALOG);

        if (!ns_catalog) {

            DEBUGF (DBG_ERR, ("Allocating nscatalog object\n"));
            TRY_THROW(mem_guard);
        }

        RegistryKey = OpenWinSockRegistryRoot();

        if (!RegistryKey) {

            TRY_THROW(mem_guard);
        }

        ReturnCode = ns_catalog->InitializeFromRegistry(
                                    RegistryKey,
                                    NULL
                                    );

        if (ERROR_SUCCESS != ReturnCode) {

            DEBUGF (DBG_ERR, ("Initializing from registry\n"));
            TRY_THROW(mem_guard);
        }

    } TRY_CATCH(mem_guard) {

        delete (ns_catalog);
        ns_catalog = NULL;

    } TRY_END(mem_guard);

    LONG close_result;

    if (RegistryKey) {

        close_result = RegCloseKey (RegistryKey);
        assert(close_result == ERROR_SUCCESS);
    }

    return (ns_catalog);
}


#ifdef _WIN64
#pragma warning (pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\send.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    Send.cpp

Abstract:

    This module contains the winsock API entrypoints for transmitting data.

Author:

    Dirk Brandewie dirk@mink.intel.com  14-06-1995

Revision History:

    23-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Moved includes into precomp.h. Reworked
        entirre file to conform to coding standard.

    Mark Hamilton mark_hamilton@ccm.jf.intel.com 18-07-1995
        Implemented all functions.


--*/

#include "precomp.h"



int WSAAPI
send(
    IN SOCKET s,
    IN const char FAR * buf,
    IN int len,
    IN int flags
    )
/*++
Routine Description:

    Send data on a connected socket.

Arguments:

    s     - A descriptor identifying a connected socket.

    buf   - A buffer containing the data to be transmitted.

    len   - The length of the data in buf.

    flags - Specifies the way in which the call is made.

Returns:

    The  total  number  of  bytes  sent.  Otherwise, a value of SOCKET_ERROR is
    returned, and the error code is stored with SetLastError().

--*/
{
    PDSOCKET           Socket;
    INT                ErrorCode;
    PDTHREAD           Thread;


	ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if (ErrorCode==ERROR_SUCCESS)
    {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            INT           ReturnValue;
            PDPROVIDER    Provider;
            WSABUF        Buffer;
            DWORD         BytesSent;

            Buffer.len = len;
            Buffer.buf = (char*)buf;

            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPSend(s,
                                            &Buffer,
                                            1,
                                            &BytesSent,
                                            (DWORD)flags,
                                            NULL,               // lpOverlapped
                                            NULL,               // lpCompletionRoutine
                                            Thread->GetWahThreadID(),
                                            &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return (INT)BytesSent;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
} //send



int WSAAPI
sendto (
    IN SOCKET s,
    IN const char FAR * buf,
    IN int len,
    IN int flags,
    IN const struct sockaddr FAR *to,
    IN int tolen
    )
/*++
Routine Description:

    Send data to a specific destination.

Arguments:

    s     - A descriptor identifying a socket.

    buf   - A buffer containing the data to be transmitted.

    len   - The length of the data in buf.

    flags - Specifies the way in which the call is made.

    to    - An optional pointer to the address of the target socket.

    tolen - The size of the address in to.

Returns:

    The  total  number  of  bytes  sent.  Otherwise, a value of SOCKET_ERROR is
    returned, and the error code is stored with SetLastError().

--*/
{
    PDSOCKET           Socket;
    INT                ErrorCode;
    PDTHREAD           Thread;

	ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if (ErrorCode==ERROR_SUCCESS)
    {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            INT             ReturnValue;
            PDPROVIDER      Provider;
            WSABUF          Buffers;
            DWORD           BytesSent;

            Buffers.len = len;
            Buffers.buf = (char*)buf;

            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPSendTo(s,
                                &Buffers,
                                1,
                                &BytesSent,
                                (DWORD)flags,
                                to,
                                tolen,
                                NULL,                   // lpOverlapped
                                NULL,                   // lpCompletionRoutine
                                Thread->GetWahThreadID(),
                                &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return (INT)BytesSent;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
} // End of sendTo



int WSAAPI
WSASend(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesSent,
    DWORD dwFlags,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
/*++
Routine Description:

    Send data on a connected socket.

Arguments:

    s                   - A descriptor identifying a connected socket.

    lpBuffers           - A  pointer  to  an  array of WSABUF structures.  Each
                          WSABUF  structure  contains a pointer to a buffer and
                          the length of the buffer.

    dwBufferCount       - The  number  of  WSABUF  structures  in the lpBuffers
                          array.

    lpNumberOfBytesSent - A pointer to the number of bytes sent by this call if
                          the I/O operation completes immediately.

    dwFlags             - Specifies the way in which the call is made.

    lpOverlapped        - A  pointer  to a WSAOVERLAPPED structure (ignored for
                          non-overlapped sockets).

    lpCompletionRoutine - A  pointer  to the completion routine called when the
                          send   operation  has  been  completed  (ignored  for
                          non-overlapped sockets).

Returns:

    If  no  error  occurs  and  the  send  operation has completed immediately,
    WSASend() returns 0.  Otherwise, a value of SOCKET_ERROR is returned, and a
    specific  error  code  may  be retrieved by calling WSAGetLastError().  The
    error  code WSA_IO_PENDING indicates that the overlapped operation has been
    successfully  initiated  and  that  completion will be indicated at a later
    time.  Any other error code indicates that the overlapped operation was not
    successfully  initiated  and  no  completion indication will occur.  If the
    MSG_INTERRUPT  flag  is set, the meaning of the return value is changed.  A
    value  of  zero  indicates  success  and is interpreted as described above.
    Otherwise,  the  return  value  will directly contain the appropriate error
    code.  Note that this is applicable only to Win16 environments and only for
    protocols that have the XP1_INTERRUPT bit set in the WSAPROTOCOL_INFO
    struct.

--*/
{
    PDSOCKET           Socket;
    INT                ErrorCode;
    PDTHREAD           Thread;

	ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if (ErrorCode==ERROR_SUCCESS)
    {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            INT                ReturnValue;
            PDPROVIDER         Provider;

            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPSend(s,
                                            lpBuffers,
                                            dwBufferCount,
                                            lpNumberOfBytesSent,
                                            dwFlags,
                                            lpOverlapped,
                                            lpCompletionRoutine,
                                            Thread->GetWahThreadID(),
                                            &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}



int WSAAPI
WSASendDisconnect(
    IN SOCKET s,
    OUT LPWSABUF lpOutboundDisconnectData
    )
/*++
Routine Description:

    Initiate termination of the connection for the socket.

Arguments:

    s                        - A descriptor identifying a socket.

    lpOutboundDisconnectData - A pointer to the outgoing disconnect data.

Returns:

    ERROR_SUCCESS  on  success  else  SOCKET_ERROR.   The  error  code
    is  stored  with SetLastError().

--*/
{
    INT                ErrorCode;
    PDSOCKET           Socket;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode==ERROR_SUCCESS) {

        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            INT                ReturnValue;
            PDPROVIDER         Provider;

            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPSendDisconnect(
                s,
                lpOutboundDisconnectData,
                &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ERROR_SUCCESS;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}



int WSAAPI
WSASendTo(
    IN SOCKET s,
    IN LPWSABUF lpBuffers,
    IN DWORD dwBufferCount,
    OUT LPDWORD lpNumberOfBytesSent,
    IN DWORD dwFlags,
    IN const struct sockaddr * lpTo,
    IN int iTolen,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
/*++
Routine Description:

    Send data to a specific destination, using overlapped I/O where
    applicable.

Arguments:


    s                   - A descriptor identifying a connected socket which was
                          created      using      WSASocket()     with     flag
                          WSA_FLAG_OVERLAPPED.

    lpBuffers           - A  pointer  to  an  array of WSABUF structures.  Each
                          WSABUF  structure  contains a pointer to a buffer and
                          thee length of the buffer.

    dwBufferCount       - The  number  of  WSABUF  structures  in the lpBuffers
                          array.

    lpNumberOfBytesSent - A pointer to the number of bytes sent by this call if
                          the I/O operation completes immediately.

    dwFlags             - Specifies the way in which the call is made.

    lpTo                - An  optional  pointer  to  the  address of the target
                          socket.

    iToLen              - The size of the address in lpTo.

    lpOverlapped        - A  pointer  to a WSAOVERLAPPED structure (ignored for
                          non-overlapped sockets).

    lpCompletionRoutine - A  pointer  to the completion routine called when the
                          send   operation  has  been  completed  (ignored  for
                          non-overlapped sockets).

Returns:

    If the function completes successfully, it returns ERROR_SUCCESS, otherwise
    it returns SOCKET_ERROR.

--*/
{
    PDSOCKET           Socket;
    INT                ErrorCode;
    PDTHREAD           Thread;

	ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if (ErrorCode==ERROR_SUCCESS)
    {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            INT                ReturnValue;
            PDPROVIDER         Provider;

            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPSendTo(s,
                                lpBuffers,
                                dwBufferCount,
                                lpNumberOfBytesSent,
                                dwFlags,
                                lpTo,
                                iTolen,
                                lpOverlapped,
                                lpCompletionRoutine,
                                Thread->GetWahThreadID(),
                                &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\spinst64.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    64_32.cpp

Abstract:


Author:

Revision History:

--*/

#include "precomp.h"
#ifdef _WIN64
#define _WIN64_32
#include "spinstal.cpp"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\scihlpr.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    scihlpr.cpp

Abstract:

    This module contains the implementation of the helper functions for
    translating WSASERVICECLASSINFO structs from the ansi to unicode and uncode
    to ansi

Author:

    Dirk Brandewie dirk@mink.intel.com  12-1-1995

[Environment:]

[Notes:]

    $Revision:   1.0  $

    $Modtime:   29 Jan 1996 08:58:54  $

Revision History:

    25-Jan-1996 dirk@mink.intel.com
        Initial Revision

--*/

#include "precomp.h"


DWORD
CalculateBufferSize(
    BOOL IsAnsi,
    LPVOID Buffer
    )
{
    LPWSASERVICECLASSINFOW UnicodeBuffer;
    LPWSASERVICECLASSINFOA AnsiBuffer;
    LPSTR                  Astring=NULL;
    INT                    StringLen=0;
    DWORD                  Index;
    DWORD                  Count;

    DWORD Size=0;

    if (IsAnsi){
        AnsiBuffer = (LPWSASERVICECLASSINFOA) Buffer;
        WS2_32_W4_INIT UnicodeBuffer = NULL;
    } //if
    else{
        UnicodeBuffer =(LPWSASERVICECLASSINFOW) Buffer;
        WS2_32_W4_INIT AnsiBuffer = NULL;
    } //else

    //Size of the fixed portion of the buffer
    if (IsAnsi){
        Size += sizeof(WSASERVICECLASSINFO);
        Size += (sizeof(WSANSCLASSINFO) * AnsiBuffer->dwCount);
    } //if
    else{
        Size += sizeof(WSASERVICECLASSINFO);
        Size += (sizeof(WSANSCLASSINFO) * UnicodeBuffer->dwCount);
    } //else

    //The toplevel GUID
    Size += sizeof(GUID);
    //The GUID's in the NSCLLASSINFO's
    if (IsAnsi){
        Size += (sizeof(GUID) * AnsiBuffer->dwCount);
    } //if
    else{
        Size += (sizeof(GUID) * UnicodeBuffer->dwCount);
    } //else

    //The toplevle string
    if (IsAnsi){
        StringLen =0;
        StringLen = MultiByteToWideChar(
            CP_ACP,                      // CodePage (Ansi)
            0,                           // dwFlags
            AnsiBuffer->lpszServiceClassName,  // lpMultiByteStr
            -1,                          // cchMultiByte
            NULL,                     // lpWideCharStr
            StringLen);                  // cchWideChar
        Size += ((StringLen+1) * sizeof(WCHAR));
    } //if
    else{
        StringLen =0;
        StringLen = WideCharToMultiByte(
            CP_ACP,                        // CodePage (Ansi)
            0,                             // dwFlags
            UnicodeBuffer->lpszServiceClassName, // lpWideCharStr
            -1,                            // cchWideChar
            Astring,                       // lpMultiByteStr
            StringLen,                     // cchMultiByte
            NULL,                          // lpDefaultChar
            NULL);                         // lpUsedDefaultChar
        Size += (StringLen+1);
    } //else


    if (IsAnsi){
        Count = AnsiBuffer->dwCount;
    } //if
    else{
        Count = UnicodeBuffer->dwCount;
    } //else

    // The variable parts of NSCLASSINFO
    for (Index = 0; Index < Count ;Index++ ){
        if (IsAnsi){
            StringLen = 0;
            StringLen = MultiByteToWideChar(
                CP_ACP,                      // CodePage (Ansi)
                0,                           // dwFlags
                AnsiBuffer->lpClassInfos[Index].lpszName, // lpMultiByteStr
                -1,                          // cchMultiByte
                NULL,                     // lpWideCharStr
                StringLen);                  // cchWideChar
            Size += ((StringLen+1) * sizeof(WCHAR));
        } //if
        else{
            StringLen = 0;
            StringLen = WideCharToMultiByte(
                CP_ACP,                        // CodePage (Ansi)
                0,                             // dwFlags
                UnicodeBuffer->lpClassInfos[Index].lpszName,  // lpWideCharStr
                -1,                            // cchWideChar
                Astring,                       // lpMultiByteStr
                StringLen,                     // cchMultiByte
                NULL,                          // lpDefaultChar
                NULL);                         // lpUsedDefaultChar
            Size += (StringLen+1);
        } //else

        if (IsAnsi){
            Size += AnsiBuffer->lpClassInfos[Index].dwValueSize;
        } //if
        else{
            Size += UnicodeBuffer->lpClassInfos[Index].dwValueSize;
        } //else
    } //for
    return(Size);
}


INT
MapAnsiServiceClassInfoToUnicode(
    IN     LPWSASERVICECLASSINFOA Source,
    IN OUT LPDWORD                lpTargetSize,
    IN     LPWSASERVICECLASSINFOW Target
    )
{
    DWORD RequiredBufferSize;
    LPBYTE FreeSpace;
    INT    StringLen;
    DWORD  Index;

    __try {
        // Find the size of buffer we will need
        RequiredBufferSize = CalculateBufferSize(
            TRUE, // Ansi Source
            Source);
        if (RequiredBufferSize > *lpTargetSize){
            *lpTargetSize = RequiredBufferSize;
            return(WSAEFAULT);
        } //if

        // Copy known size portions of buffer

        // Toplevel structure
        FreeSpace = (LPBYTE)Target;
        CopyMemory(Target,
                   Source,
                   sizeof(WSASERVICECLASSINFOW));
        FreeSpace += sizeof(WSASERVICECLASSINFOW);

        // The array of WSANSCLASSINFO's
        Target->lpClassInfos = (LPWSANSCLASSINFOW)FreeSpace;
        CopyMemory(Target->lpClassInfos,
                   Source->lpClassInfos,
                   (sizeof(WSANSCLASSINFO) * Source->dwCount));
        FreeSpace += (sizeof(WSANSCLASSINFO) * Source->dwCount);

        // The service class ID GUID
        Target->lpServiceClassId = (LPGUID)FreeSpace;
        CopyMemory(Target->lpServiceClassId,
                   Source->lpServiceClassId,
                   sizeof(GUID));
        FreeSpace += sizeof(GUID);

        // Copy variable portion

        Target->lpszServiceClassName = (LPWSTR)FreeSpace;
        StringLen = MultiByteToWideChar(
            CP_ACP,                        // CodePage (Ansi)
            0,                             // dwFlags
            Source->lpszServiceClassName,  // lpMultiByteStr
            -1,                            // cchMultiByte
            NULL,                          // lpWideCharStr
            0);                            // cchWideChar

        FreeSpace += ((StringLen+1) * sizeof(WCHAR));
        MultiByteToWideChar(
            CP_ACP,                        // CodePage (Ansi)
            0,                             // dwFlags
            Source->lpszServiceClassName,  // lpMultiByteStr
            -1,                            // cchMultiByte
            Target->lpszServiceClassName,  // lpWideCharStr
            StringLen);  // cchWideChar

        for (Index=0;Index < Source->dwCount ;Index++ ){
            LPSTR SourceString;
            LPWSTR TargetString;

            SourceString = Source->lpClassInfos[Index].lpszName;
            Target->lpClassInfos[Index].lpszName = (LPWSTR)FreeSpace;
            TargetString = Target->lpClassInfos[Index].lpszName;

            StringLen = MultiByteToWideChar(
                CP_ACP,                        // CodePage (Ansi)
                0,                             // dwFlags
                SourceString,                  // lpMultiByteStr
                -1,                            // cchMultiByte
                NULL,                          // lpWideCharStr
                0);                            // cchWideChar

            FreeSpace += ((StringLen +1) * sizeof(WCHAR));
            MultiByteToWideChar(
                CP_ACP,                        // CodePage (Ansi)
                0,                             // dwFlags
                SourceString,                  // lpMultiByteStr
                -1,                            // cchMultiByte
                TargetString,                  // lpWideCharStr
                StringLen);                    // cchWideChar

            Target->lpClassInfos[Index].lpValue = FreeSpace;
            CopyMemory(
                Target->lpClassInfos[Index].lpValue,
                Source->lpClassInfos[Index].lpValue,
                Source->lpClassInfos[Index].dwValueSize);
            FreeSpace += Source->lpClassInfos[Index].dwValueSize;
        } //for
        return(ERROR_SUCCESS);
    }
    __except (WS2_EXCEPTION_FILTER()) {
        return (WSAEFAULT);
    }
}


INT
MapUnicodeServiceClassInfoToAnsi(
    IN     LPWSASERVICECLASSINFOW Source,
    IN OUT LPDWORD                lpTargetSize,
    IN     LPWSASERVICECLASSINFOA Target
    )
{
    DWORD RequiredBufferSize;
    LPBYTE FreeSpace;
    INT    StringLen;
    DWORD  Index;

    __try {
        // Find the size of buffer we will need
        RequiredBufferSize = CalculateBufferSize(
            TRUE, // Ansi Source
            Source);
        if (RequiredBufferSize > *lpTargetSize){
            *lpTargetSize = RequiredBufferSize;
            return(WSAEFAULT);
        } //if

        // Copy known size portions of buffer

        // Toplevel structure
        FreeSpace = (LPBYTE)Target;
        CopyMemory(Target,
                   Source,
                   sizeof(WSASERVICECLASSINFOA));
        FreeSpace += sizeof(WSASERVICECLASSINFOA);

        // The array of WSANSCLASSINFO's
        Target->lpClassInfos = (LPWSANSCLASSINFOA)FreeSpace;
        CopyMemory(Target->lpClassInfos,
                   Source->lpClassInfos,
                   (sizeof(WSANSCLASSINFOA) * Source->dwCount));
        FreeSpace += (sizeof(WSANSCLASSINFOA) * Source->dwCount);

        // The service class ID GUID
        Target->lpServiceClassId = (LPGUID)FreeSpace;
        CopyMemory(Target->lpServiceClassId,
                   Source->lpServiceClassId,
                   sizeof(GUID));
        FreeSpace += sizeof(GUID);

        // Copy variable portion

        Target->lpszServiceClassName = (LPSTR)FreeSpace;
        StringLen = WideCharToMultiByte(
            CP_ACP,                          // CodePage (Ansi)
            0,                               // dwFlags
            Source->lpszServiceClassName,    // lpWideCharStr
            -1,                              // cchWideChar
            NULL         ,                   // lpMultiByteStr
            0,                               // cchMultiByte
            NULL,                            // lpDefaultChar
            NULL);                           // lpUsedDefaultChar

        FreeSpace += (StringLen+1);
        WideCharToMultiByte(
            CP_ACP,                          // CodePage (Ansi)
            0,                               // dwFlags
            Source->lpszServiceClassName,    // lpWideCharStr
            -1,                              // cchWideChar
            Target->lpszServiceClassName,    // lpMultiByteStr
            StringLen,                       // cchMultiByte
            NULL,                            // lpDefaultChar
            NULL);                           // lpUsedDefaultChar

        for (Index=0;Index < Source->dwCount ;Index++ ){
            LPWSTR SourceString;
            LPSTR TargetString;

            SourceString = Source->lpClassInfos[Index].lpszName;
            Target->lpClassInfos[Index].lpszName = (LPSTR)FreeSpace;
            TargetString = Target->lpClassInfos[Index].lpszName;

            StringLen = WideCharToMultiByte(
                CP_ACP,                          // CodePage (Ansi)
                0,                               // dwFlags
                SourceString,                    // lpWideCharStr
                -1,                              // cchWideChar
                NULL         ,                   // lpMultiByteStr
                0,                               // cchMultiByte
                NULL,                            // lpDefaultChar
                NULL);                           // lpUsedDefaultChar

            FreeSpace += (StringLen+1);
            WideCharToMultiByte(
                CP_ACP,                          // CodePage (Ansi)
                0,                               // dwFlags
                SourceString,                    // lpWideCharStr
                -1,                              // cchWideChar
                TargetString,                    // lpMultiByteStr
                StringLen,                       // cchMultiByte
                NULL,                            // lpDefaultChar
                NULL);                           // lpUsedDefaultChar

            Target->lpClassInfos[Index].lpValue = FreeSpace;
            CopyMemory(
                Target->lpClassInfos[Index].lpValue,
                Source->lpClassInfos[Index].lpValue,
                Source->lpClassInfos[Index].dwValueSize);
            FreeSpace += Source->lpClassInfos[Index].dwValueSize;
        } //for
        return(ERROR_SUCCESS);
    }
    __except (WS2_EXCEPTION_FILTER()) {
        return (WSAEFAULT);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\socklife.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    socklife.c

Abstract:

    This module contains the Winsock API functions concerned with socket
    lifetime. The following API functions are contained in this module.

    socket()
    WSASocketA()
    WSASocketW()
    accept()
    WSAAccept()
    WPUCreateSocketHandle()
    WPUCloseSocketHandle
    WPUQuerySocketHandleContext
    WPUModifyIFSHandle
    WSAJoinLeaf()
    closesocket()

Author:

    dirk@mink.intel.com  14-06-1995

Revision History:

    22-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Moved includes to precomp.h. Added
        asserts for debugging
--*/

#include "precomp.h"
#pragma hdrstop
#include <wsipx.h>
#include <wsnwlink.h>
#include <atalkwsh.h>

#define NSPROTO_MAX (NSPROTO_IPX + 255)


SOCKET WSAAPI
socket(
    IN int af,
    IN int type,
    IN int protocol)
/*++
Routine Description:

     Create a socket which is bound to a specific service provider.

Arguments:
    af - An address family specification.  The
         only format currently supported is
         PF_INET, which is the ARPA Internet
         address format.

    type - A type specification for the new socket.

    protocol- A particular protocol to be used with
              the socket, or 0 if the caller does not
              wish to specify a protocol.

Returns:
    A socket descriptor referencing the new socket. Otherwise, a value
    of INVALID_SOCKET is returned and the error code is stored with
    SetErrorCode.
--*/
{
    PDTHREAD  Thread;
    INT       ErrorCode;
    DWORD     dwFlags;

    ErrorCode = TURBO_PROLOG_OVLP(
        &Thread);

    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return(INVALID_SOCKET);
    } //if

    if( Thread->GetOpenType() == 0 ) {
        dwFlags = WSA_FLAG_OVERLAPPED;
    } else {
        dwFlags = 0;
    }

    //
    // HACK for NetBIOS!
    //

    if( af == AF_NETBIOS && protocol > 0 ) {
        protocol *= -1;
    }

    return(WSASocketW(
        af,
        type,
        protocol,
        NULL,      // lpProtocolInfo
        0,         // g
        dwFlags));
}

SOCKET WSAAPI
WSASocketW (
    IN int af,
    IN int type,
    IN int protocol,
    IN LPWSAPROTOCOL_INFOW lpProtocolInfo,
    IN GROUP g,
    IN DWORD dwFlags)
/*++
Routine Description:

    Create  a  socket  which is bound to a specific transport service provider,
    optionally create and/or join a socket group.

Arguments:

    af             - An   address   family   specification.   The  only  format
                     currently supported is PF_INET, which is the ARPA Internet
                     address format.

    type           - A type specification for the new socket.

    protocol       - A  particular protocol to be used with the socket, or 0 if
                     the caller does not wish to specify a protocol.

    lpProtocolInfo - A pointer to a WSAPROTOCOL_INFOW struct that defines the
                     characteristics  of  the  socket  to  be created.  If this
                     parameter  is  not  NULL,  the first three parameters (af,
                     type, protocol) are ignored.

     g             - The identifier of the socket group.

     dwFlags       - The socket attribute specification.


Returns:

    A  socket  descriptor  referencing  the  new socket.  Otherwise, a value of
    INVALID_SOCKET is returned and the error code is stored with SetErrorCode.
--*/
{
    SOCKET              ReturnValue;
    PDPROCESS           Process;
    PDTHREAD            CurrentThread;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDCATALOG           Catalog;
    PPROTO_CATALOG_ITEM CatalogEntry;
    LPWSAPROTOCOL_INFOW ProtocolInfo;
    DWORD               dwCatalogId;

    ErrorCode = PROLOG(
        &Process,
        &CurrentThread);

    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return(INVALID_SOCKET);
        } //if

    //Set Default return code
    ReturnValue = INVALID_SOCKET;

    // Find a provider that can support the user request
    Catalog = Process->GetProtocolCatalog();

    if (lpProtocolInfo) {

        __try {
            dwCatalogId =  lpProtocolInfo->dwCatalogEntryId;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            SetLastError(WSAEFAULT);
            return(INVALID_SOCKET);
        }
        ErrorCode =  Catalog->GetCountedCatalogItemFromCatalogEntryId(
            dwCatalogId,
            &CatalogEntry);
    } //if
    else {
        dwCatalogId = 0;

RestartCatalogLookupHack:

        ErrorCode = Catalog->GetCountedCatalogItemFromAttributes(
            af,
            type,
            protocol,
            dwCatalogId,
            &CatalogEntry
            );

        //
        // If we failed to find a provider, try to reload the catalog
        // from the registry and retry the lookup. This handles the
        // case (first noticed in CAIRO SETUP) where WS2_32.DLL is loaded
        // and WSAStartup() is called *before* CAIRO SETUP has had the
        // opportunity to install the necessary providers. Later, CAIRO
        // SETUP needs to create sockets.
        //
        // Do not need this anymore, we now support dynamic notifications
        // of protocol installation/removal and check for changes every
        // time we access the catalog.
        //

    } // else choosing from attributes

    if ( ERROR_SUCCESS == ErrorCode) {

        Provider = CatalogEntry->GetProvider();
        if (lpProtocolInfo) {
            // Must  be  sure  we  use  the  client's lpProtocolInfo if one was
            // supplied, to support the WSADuplicateSocket model.
            ProtocolInfo = lpProtocolInfo;
        } //if
        else {
            ProtocolInfo = CatalogEntry->GetProtocolInfo();
        } //else

        assert(ProtocolInfo != NULL);

        //
        // Hack-O-Rama. Temporary set the open type of the thread
        // depending on the overlapped flag so that we can create
        // appropriate socket handle for the layered service
        // provider.  However, if layered service provide caches
        // the handles we create for it, not much we can do.
        //
        {
            INT oldOpenType = CurrentThread->GetOpenType ();
            CurrentThread->SetOpenType ((dwFlags & WSA_FLAG_OVERLAPPED) ? 0 : SO_SYNCHRONOUS_NONALERT);

            // Now we have a provider that can support the user
            // request lets ask get a socket
            ReturnValue = Provider->WSPSocket(
                af,
                type,
                protocol,
                ProtocolInfo,
                g,
                dwFlags,
                &ErrorCode);

            //
            // Reset saved open type
            //
            CurrentThread->SetOpenType (oldOpenType);
        }

        //
        // Hack-O-Rama. If WSPSocket() failed with the distinguished
        // error code WSAEINPROGRESS *and* this was not a request for a
        // specific provider (i.e. lpProtocolInfo == NULL) then
        // restart the catalog lookup starting at the current item
        // (the current catalog id).
        //

        //
        // Snap the catalog id and dereference the catalog entry
        //
        dwCatalogId = ProtocolInfo->dwCatalogEntryId;
        CatalogEntry->Dereference ();

        if( ReturnValue == INVALID_SOCKET &&
                ErrorCode == WSAEINPROGRESS &&
                lpProtocolInfo == NULL ) {
            goto RestartCatalogLookupHack;
        }

        if( ReturnValue != INVALID_SOCKET ) {
            DSOCKET::AddSpecialApiReference( ReturnValue );
            return ReturnValue;
        }
    } //if

    assert (ErrorCode!=ERROR_SUCCESS);
    // There was an error, set this threads lasterror
    SetLastError(ErrorCode);
    return(INVALID_SOCKET);
}


SOCKET WSAAPI
WSASocketA (
    IN int af,
    IN int type,
    IN int protocol,
    IN LPWSAPROTOCOL_INFOA lpProtocolInfo,
    IN GROUP g,
    IN DWORD dwFlags)
/*++

Routine Description:

    ANSI thunk to WSASocketW.

Arguments:

    af             - An   address   family   specification.   The  only  format
                     currently supported is PF_INET, which is the ARPA Internet
                     address format.

    type           - A type specification for the new socket.

    protocol       - A  particular protocol to be used with the socket, or 0 if
                     the caller does not wish to specify a protocol.

    lpProtocolInfo - A pointer to a WSAPROTOCOL_INFOA struct that defines the
                     characteristics  of  the  socket  to  be created.  If this
                     parameter  is  not  NULL,  the first three parameters (af,
                     type, protocol) are ignored.

     g             - The identifier of the socket group.

     dwFlags       - The socket attribute specification.


Returns:

    A  socket  descriptor  referencing  the  new socket.  Otherwise, a value of
    INVALID_SOCKET is returned and the error code is stored with SetErrorCode.
--*/
{

    INT                 error;
    WSAPROTOCOL_INFOW   ProtocolInfoW;

    //
    // Map the ANSI WSAPROTOCOL_INFOA structure to UNICODE.
    //

    if( lpProtocolInfo != NULL ) {

        error = MapAnsiProtocolInfoToUnicode(
                    lpProtocolInfo,
                    &ProtocolInfoW
                    );

        if( error != ERROR_SUCCESS ) {

            SetLastError( error );
            return INVALID_SOCKET;

        }

    }

    //
    // Call through to the UNICODE version.
    //

    return WSASocketW(
               af,
               type,
               protocol,
               lpProtocolInfo
                    ? &ProtocolInfoW
                    : NULL,
               g,
               dwFlags
               );

}   // WSASocketA




SOCKET WSAAPI
accept(
    IN SOCKET s,
    OUT struct sockaddr FAR *addr,
    OUT int FAR *addrlen
    )
/*++
Routine Description:

    Accept a connection on a socket.

Arguments:

    s - A descriptor identifying a socket which is listening for connections
        after a listen().

    addr - An optional pointer to a buffer which receives the address of the
           connecting entity, as known to the communications layer.  The exact
           format of the addr argument is determined by the address family
           established when the socket was  created.

    addrlen - An optional pointer to an integer which contains the length of
              the address addr.

Returns:
    A descriptor for the accepted socket. Otherwise, a value of INVALID_SOCKET
    is returned and the error code is stored with SetErrorCode.
--*/
{
    return(WSAAccept(
        s,
        addr,
        addrlen,
        NULL,   // No condition function
        NULL)); //No callback data
}





SOCKET WSAAPI
WSAAccept(
    IN SOCKET s,
    OUT struct sockaddr FAR *addr,
    OUT LPINT addrlen,
    IN LPCONDITIONPROC lpfnCondition,
    IN DWORD_PTR dwCallbackData
    )
/*++
Routine Description:

     Conditionally accept a connection based on the return value of a
     condition function, and optionally create and/or join a socket
     group.

Arguments:

    s - A descriptor identifying a socket which is listening for connections
        after a listen().

    addr - An optional pointer to a buffer which receives the address of the
           connecting entity, as known to the communications layer. The exact
           format of the addr argument is determined by the address family
           established when the socket was  created.

    addrlen - An optional pointer to an integer which contains the length of
              the address addr.

    lpfnCondition - The procedure instance address of the optional,
                    application-supplied condition function which will make an
                    accept/reject decision based on the caller information
                    passed in as parameters, and optionally create and/or join
                    a socket group by assigning an appropriate value to the
                    result parameter g of this function.


    dwCallbackData - The callback data passed back to the application as a
                     condition function parameter.  This parameter is not
                     interpreted by WinSock.
Returns:
    A socket descriptor for the newly accepted socket on success, otherwise
    INVALID_SOCKET.
--*/
{
    SOCKET             ReturnValue;
    INT                ErrorCode;
    PDSOCKET           Socket;
    PDPROVIDER         Provider;
    PDTHREAD           CurrentThread;

    ErrorCode = TURBO_PROLOG_OVLP(&CurrentThread);

    if (ErrorCode == ERROR_SUCCESS) {

		Socket = DSOCKET::GetCountedDSocketFromSocket(s);
		if(Socket != NULL){
            //
            // Hack-O-Rama. Temporary set the open type of the thread
            // depending on the overlapped flag so that we can create
            // appropriate socket handle for the layered service
            // provider.  However, if layered service provide caches
            // the handles we create for it, not much we can do.
            //
            INT oldOpenType = CurrentThread->GetOpenType ();
            CurrentThread->SetOpenType (Socket->IsOverlappedSocket() ? 0 : SO_SYNCHRONOUS_NONALERT);

			Provider = Socket->GetDProvider();
			ReturnValue = Provider->WSPAccept(
				s,
				addr,
				addrlen,
				lpfnCondition,
				dwCallbackData,
				&ErrorCode);

            //
            // Reset saved open type
            //
            CurrentThread->SetOpenType (oldOpenType);

			Socket->DropDSocketReference();
            if( ReturnValue != INVALID_SOCKET) {
				//
				// Add a reference if the socket we got back was different
				// that the one we passed in (just in case someone
                // implements it this way which is not explicitly
                // prohibited by the specification).
				//

                if (ReturnValue != s ) {
				    DSOCKET::AddSpecialApiReference( ReturnValue );
                }
				return ReturnValue;
			}
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;

		} //if
		else {
			ErrorCode = WSAENOTSOCK;
		}
	}

    SetLastError(ErrorCode);
    return(INVALID_SOCKET);
}




SOCKET WSPAPI
WPUCreateSocketHandle(
    IN DWORD dwCatalogEntryId,
    IN DWORD_PTR lpContext,
    OUT LPINT lpErrno )
/*++
Routine Description:

    Creates a new socket handle.

Arguments:

    dwCatalogEntryId - Indentifies the calling service provider.

    lpContext - A context value to associate with the new socket handle.

    lpErrno - A pointer to the error code.

Returns:
    A socket handle if successful, otherwise INVALID_SOCKET.
--*/
{
    SOCKET              ReturnCode=INVALID_SOCKET;
    INT                 ErrorCode=ERROR_SUCCESS;
    PDPROCESS           Process;
    PDCATALOG           Catalog;
    SOCKET              SocketID;
    HANDLE              HelperHandle;


    Process = DPROCESS::GetCurrentDProcess();
    if (Process!=NULL) {
        Catalog = Process->GetProtocolCatalog();
        if (Catalog)
        {
            PPROTO_CATALOG_ITEM CatalogEntry;

            ErrorCode = Catalog->GetCountedCatalogItemFromCatalogEntryId(
                dwCatalogEntryId,
                &CatalogEntry);

            if (ERROR_SUCCESS == ErrorCode) {
#if DBG
                if (CatalogEntry->GetProtocolInfo()->dwServiceFlags1 & XP1_IFS_HANDLES) {
                    DEBUGF(DBG_WARN,("IFS provider %ls asking for non-IFS socket handle\n",
                                        CatalogEntry->GetProtocolInfo()->szProtocol));
                }
#endif
                ErrorCode = Process->GetHandleHelperDeviceID (&HelperHandle);
                if (ErrorCode == ERROR_SUCCESS) {
                    ErrorCode = WahCreateSocketHandle (HelperHandle, &SocketID);
                    if (ErrorCode == ERROR_SUCCESS) {
                        PDSOCKET            Socket;
                        // Alloc new DSocket object
                        Socket = new(DSOCKET);
                        if (Socket) {
                            // Init the new socket
                            Socket->Initialize(CatalogEntry);

                            // Add Socket into the handle table allocated.
                            ErrorCode = Socket->AssociateSocketHandle(
                                    SocketID, // Socket handler
                                    FALSE);   // ProviderSocket
                            if (ErrorCode == ERROR_SUCCESS) {
                                //Finish putting the socket together
                                Socket->SetContext(lpContext);
                                ReturnCode = SocketID;
                            }
                            else {
                                WahCloseSocketHandle (HelperHandle, SocketID);
                                Socket->DropDSocketReference ();
                            }

                            Socket->DropDSocketReference ();
                        } // if socket was allocated
                        else {
                            WahCloseSocketHandle (HelperHandle, SocketID);
                            ErrorCode = WSAENOBUFS;
                        }
                    }
                } // Helper device was loaded OK

                CatalogEntry->Dereference ();
            } //if catalog entry found
            else
            {
                DEBUGF(DBG_ERR,("Failed to find catalog entry for provider %ld\n",
                                    dwCatalogEntryId));

            } //else
        } //if catalog is there
        else {
            ErrorCode = WSANOTINITIALISED;
        }
    } //if process is initialized
    else {
        ErrorCode = WSANOTINITIALISED;
    }

    *lpErrno = ErrorCode;
    return(ReturnCode);

} // WPUCreateSocketHandle


int WSPAPI
WPUCloseSocketHandle(
    IN SOCKET s,
    OUT LPINT lpErrno
    )
/*++
Routine Description:

    Closes an exsisting socket handle.

Arguments:

    s       - Identifies a socket handle created with WPUCreateSocketHandle().

    lpErrno - A pointer to the error code.

Returns:

    Zero on success else SOCKET_ERROR.
--*/
{
    INT                 ReturnValue = ERROR_SUCCESS;
    PDPROCESS           Process;
    INT                 ErrorCode;
    PDSOCKET            Socket;
    HANDLE              HandleHelper;

    assert(lpErrno);

	Process = DPROCESS::GetCurrentDProcess ();
	if (Process!=NULL) {


		//
		// We use the no-export version because there is no way such handle
		// can be exported anyway.
		//

		Socket = DSOCKET::GetCountedDSocketFromSocketNoExport(s);
		if (Socket!=NULL) {
			if (!Socket->IsProviderSocket()) {
				ErrorCode = Socket->DisassociateSocketHandle();
                assert (ErrorCode == ERROR_SUCCESS);
				ErrorCode = Process->GetHandleHelperDeviceID(&HandleHelper);
				if (ErrorCode==ERROR_SUCCESS) {
					ErrorCode = WahCloseSocketHandle (HandleHelper, Socket->GetSocketHandle ());
					if (ErrorCode!=ERROR_SUCCESS) {
						ReturnValue = SOCKET_ERROR;
					}
				}
				else {
					*lpErrno = ErrorCode;
					ReturnValue = SOCKET_ERROR;
				}
				//
				// Drop active reference.  IFS socket's active reference
				// is dropped in closesocket routine.
				//
				Socket->DropDSocketReference();
			}
			else {
				DEBUGF(
					DBG_ERR,
					("Foreign socket handle %p handed in by service provider for closure\n", s));
				*lpErrno = WSAEINVAL;
				ReturnValue = SOCKET_ERROR;
			}
			Socket->DropDSocketReference();
		} // if ERROR_SUCCESS
		else {
			DEBUGF(
				DBG_ERR,
				("Bad socket handle %p handed in by service provider for closure\n", s));
			*lpErrno = WSAENOTSOCK;
			ReturnValue = SOCKET_ERROR;
		}
	}
	else {
		*lpErrno = WSANOTINITIALISED;
		ReturnValue = SOCKET_ERROR;
	}

    return (ReturnValue);
}


int WSPAPI
WPUQuerySocketHandleContext(
    IN SOCKET s,
    OUT PDWORD_PTR lpContext,
    OUT LPINT lpErrno
    )
/*++
Routine Description:

    Queries the context value associated with the specified socket handle.

Arguments:

    s         - Identifies the socket whose context is to be queried.

    lpContext - A pointer to an DWORD that will receive the context value.

    lpErrno   - A pointer to the error code.

Returns:

    If  no error occurs, WPUQuerySocketHandleContext() returns 0 and stores the
    current  context  value  in lpdwContext.  Otherwise, it returns
    SOCKET_ERROR, and a specific error code is available in lpErrno.
--*/
{
    INT ReturnCode=SOCKET_ERROR;
    INT ErrorCode=WSAENOTSOCK;
    PDSOCKET Socket;

    //
    // We use the no-export version because there is no way such handle
    // can be exported anyway.
    //
    Socket = DSOCKET::GetCountedDSocketFromSocketNoExport(s);
    if (Socket!=NULL) {
        if (!Socket->IsProviderSocket()) {
            *lpContext = Socket->GetContext();
            ReturnCode = ERROR_SUCCESS;
        }
        else {
            DEBUGF(
                DBG_ERR,
                ("Foreign socket handle %p handed in by service provider for query\n", s));
            *lpErrno = WSAEINVAL;
        }
        Socket->DropDSocketReference ();
    }
    else {
        DEBUGF(
            DBG_ERR,
            ("Bad socket handle %p handed in by service provider for query\n", s));
        *lpErrno = ErrorCode;
    }
    return(ReturnCode);
}



SOCKET WSPAPI
WPUModifyIFSHandle(
    IN DWORD dwCatalogEntryId,
    IN SOCKET ProposedHandle,
    OUT LPINT lpErrno
    )
/*++
Routine Description:

    Receive (possibly) modifies IFS handle from winsock DLL.

Arguments:

    dwCatalogEntryId - Identifies the calling service provider.

    ProposedHandle   - An  Installable File System(IFS) handle allocated by the
                       provider.

    lpErrno          - A pointer to the error code.

Returns:

    If  no  error  occurs,  WPUModifyIFSHandle()  returns  the  modified socket
    handle.  Otherwise, it returns INVALID_SOCKET, and a specific error code is
    available in lpErrno.
--*/
{
    SOCKET              ReturnCode=INVALID_SOCKET;
    INT                 ErrorCode=ERROR_SUCCESS;
    PDPROCESS           Process;
    PDCATALOG           Catalog;


    // Alloc new DSocket object
    Process = DPROCESS::GetCurrentDProcess();
    if (Process!=NULL) {
        Catalog = Process->GetProtocolCatalog();
        if (Catalog) {
            PPROTO_CATALOG_ITEM CatalogEntry;

            ErrorCode = Catalog->GetCountedCatalogItemFromCatalogEntryId(
                dwCatalogEntryId,
                &CatalogEntry);

            if (ERROR_SUCCESS == ErrorCode) {
                PDSOCKET            Socket;

                // Create new socket object
                Socket = new DSOCKET;

                if (Socket!=NULL) {
                    // Init the new socket
                    Socket->Initialize(CatalogEntry);

                    //
                    // Add socket to the handle table.  In this implementation, we
                    // wind up never changing the proposed IFS handle.
                    //

                    ErrorCode = Socket->AssociateSocketHandle(
                        ProposedHandle, // SocketHandle
                        TRUE);           // ProviderSocket

                    if (ErrorCode == ERROR_SUCCESS) {

                        ReturnCode = ProposedHandle;
                        *lpErrno = ERROR_SUCCESS;
                    } //if
                    else {
                        //
                        // Failed to insert into the table
                        // Remove creation reference
                        //
                        Socket->DropDSocketReference ();
                        *lpErrno = ErrorCode;
                    }

                    //
                    // Note that the new DSOCKET starts out with a ref count
                    // of two, so we'll always need to dereference it once.
                    //
                    Socket->DropDSocketReference ();

                } // if socket was created or found
                else {
                    *lpErrno = WSAENOBUFS;
                }
                CatalogEntry->Dereference ();
            } //if catalog entry was found
            else {
                DEBUGF(DBG_ERR,("Failed to find catalog entry for provider %ld\n",
                                    dwCatalogEntryId));
                *lpErrno = ErrorCode;
            }
        } //if catalog is there
        else
        {
            DEBUGF(DBG_ERR,("Failed to find Catalog object"));
            *lpErrno = WSANOTINITIALISED;

        } //else
    } //if process is initialized
    else {
        *lpErrno = WSANOTINITIALISED;
    }

    return(ReturnCode);

}  // WPUModifyIfsHandle




SOCKET WSAAPI
WSAJoinLeaf(
    IN SOCKET s,
    IN const struct sockaddr FAR * name,
    IN int namelen,
    IN LPWSABUF lpCallerData,
    OUT LPWSABUF lpCalleeData,
    IN LPQOS lpSQOS,
    IN LPQOS lpGQOS,
    IN DWORD dwFlags
    )
/*++
Routine Description:

    Join  a  leaf  node  into  a multipoint session, exchange connect data, and
    specify needed quality of service based on the supplied flow specs.

Arguments:

    s            - A descriptor identifying an multipoint socket.

    name         - The name of the peer to which the socket is to be joined.

    namelen      - The length of the name.

    lpCallerData - A  pointer to the user data that is to be transferred to the
                   peer during multipoint session establishment.

    lpCalleeData - pointer to the user data that is to be transferred back from
                   the peer during multipoint session establishment.

    lpSQOS       - A  pointer  to  the  flow  specs  for socket s, one for each
                   direction.

    lpGQOS       - A  pointer  to  the  flow  specs  for  the  socket group (if
                   applicable).

    dwFlags      - Flags  to  indicate the socket acting as a sender, receiver,
                   or both.

Returns:
    If no error occurs, WSAJoinLeaf() returns a value of type SOCKET which is a
    descriptor  for the newly created multipoint socket.  Otherwise, a value of
    INVALID_SOCKET  is  returned, and a specific error code may be retrieved by
    calling WSAGetLastError().

--*/
{

    SOCKET             ReturnValue;
    INT                ErrorCode;
    PDPROVIDER         Provider;
    PDSOCKET           Socket;
    PDTHREAD           CurrentThread;

    ErrorCode = TURBO_PROLOG_OVLP(&CurrentThread);

    if (ErrorCode == ERROR_SUCCESS) {

		Socket = DSOCKET::GetCountedDSocketFromSocket(s);
		if(Socket != NULL){
            //
            // Hack-O-Rama. Temporary set the open type of the thread
            // depending on the overlapped flag so that we can create
            // appropriate socket handle for the layered service
            // provider.  However, if layered service provide caches
            // the handles we create for it, not much we can do.
            //
            INT oldOpenType = CurrentThread->GetOpenType ();
            CurrentThread->SetOpenType (Socket->IsOverlappedSocket() ? 0 : SO_SYNCHRONOUS_NONALERT);

            Provider = Socket->GetDProvider();
			ReturnValue = Provider->WSPJoinLeaf(
				s,
				name,
				namelen,
				lpCallerData,
				lpCalleeData,
				lpSQOS,
				lpGQOS,
				dwFlags,
				&ErrorCode);

            //
            // Reset saved open type
            //
            CurrentThread->SetOpenType (oldOpenType);

            Socket->DropDSocketReference();


			if( ReturnValue != INVALID_SOCKET) {

				//
				// Add a reference if the socket we got back was different
				// that the one we passed in (c_root cases only)
				//
				if (ReturnValue != s) {
					DSOCKET::AddSpecialApiReference( ReturnValue );
				}

				return ReturnValue;
			}
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;

		} //if
		else {
			ErrorCode = WSAENOTSOCK;
		}
	}

    SetLastError(ErrorCode);
    return(INVALID_SOCKET);
}




int WSAAPI
closesocket(
    IN SOCKET s
    )
/*++
Routine Description:

    Close a socket.

Arguments:

    s - A descriptor identifying a socket.

Returns:
    Zero on success else SOCKET_ERROR. The error code is stored with
    SetErrorCode().
--*/
{
    INT                 ReturnValue;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDSOCKET            Socket;

    ErrorCode = TURBO_PROLOG();

    if (ErrorCode == ERROR_SUCCESS) {

		Socket = DSOCKET::GetCountedDSocketFromSocket(s);
		if(Socket != NULL){
			// The   actual  destruction  of  the  DSOCKET  object  closed  through
			// "closesocket"   happens  after  we  return  from  the  provider  and
			// determine  that  no  other  threads have remaining references to the
			// object.

			//
			// First, determine if this handle is for the provider socket so
			// we can clear the context table entry BEFORE closing the
			// socket. This plugs a nasty race condition where the provider
			// closes its handle and another thread creates a new socket
			// with the same handle value BEFORE the first thread manages
			// to clear the handle table entry.
			//
            // This is now handled by new context referencing functions
            // which will not clear handle table entry if it was replaced.
            //

			// if (ProviderSocket) {
			//	Socket->DisassociateSocketHandle();
			// }


			//Call the provider to close the socket.
			Provider = Socket->GetDProvider();
			ReturnValue = Provider->WSPCloseSocket( s,
												   &ErrorCode);
			if( (ReturnValue == ERROR_SUCCESS)
                    && Socket->IsProviderSocket ()){

				//
				// Remove context from the table and "active" reference
                // from the socket.
				// Non-provider generated socket active reference
                // is removed when provider destroys the handle
                // via WPUCloseSocketHandle call.
				//
				// Note the spec flow in case provider generated socket was
				// used only by the layered provider above and never
				// returned via socket/WSASocket call.  closesocket
				// is not called for such socket and we never get to
				// execute the code below. which leads to socket object
				// leak.
                //
                // It may have been replaced by another handle
                // when we call this funciton in which case
                // we do not need to drop the reference count
                // becuase it was done by whoever bumped it
                // out of the table, see comment above
                //
                if (Socket->DisassociateSocketHandle()==NO_ERROR)
                    Socket->DropDSocketReference();
			}

			//
			// Remove the reference added by GetCountedDSocketFromSocket.
			//

			Socket->DropDSocketReference();

			if( ReturnValue == ERROR_SUCCESS)
				return ReturnValue;
            //
			// The close failed. Restore the context table entry if
			// necessary.
			//
            // Don't need to do this anymore, see comment above
            //

			// if( ProviderSocket ) {
			//	if (Socket->AssociateSocketHandle(s, TRUE)!=NO_ERROR) {
					//
					// Failed to reinsert the socket into the table
					// This is the only thing we can do here.
					//
			//		assert (FALSE);
			//	}
			//}

            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;

		} // if
		else {
			ErrorCode = WSAENOTSOCK;
		}
	}

    SetLastError(ErrorCode);
    return(SOCKET_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\select.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    select.c

Abstract:

    This module contains the "select" entry points from the winsock
    API. The following functions aare contained in this module.

    select()
    WSAEventSelect()
    WSAAsyncSelect()
    __WSAFDIsSet()

Author:

    Dirk Brandewie dirk@mink.intel.com  14-06-1995

Revision History:

    22-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Moved includes to precomp.h

    16-Aug-1995  dirk@mink.intel.com
        Added implementation of __WSAFDIsSet

--*/
#include "precomp.h"




int WSAAPI
select (
    IN int nfds,
    IN OUT fd_set FAR *readfds,
    IN OUT fd_set FAR *writefds,
    IN OUT fd_set FAR *exceptfds,
    IN const struct timeval FAR *timeout
    )
/*++
Routine Description:

    Determine the status of one or more sockets, waiting if necessary.

Arguments:

    nfds - This argument is ignored and included only for the sake of
           compatibility.

    readfds - An optional pointer to a set of sockets to be checked
              for readability.

    writefds - An optional pointer to a set of sockets to be checked
               for writability.

    exceptfds - An optional pointer to a set of sockets to be checked
                for errors.

    timeout - The maximum time for select() to wait, or NULL for
              blocking operation.

Returns:
    select() returns the total number of descriptors which are ready
    and contained in the fd_set structures, 0 if the time limit
    expired, or SOCKET_ERROR if an error occurred.  If the return
    value is SOCKET_ERROR, The error code is stored with
    SetLastError().
--*/
{
    INT                ReturnValue;
    INT                ErrorCode;
    PDPROVIDER         Provider;
    PDSOCKET           Socket;
    SOCKET             SocketID;
    BOOL               FoundSocket=FALSE;

    ErrorCode = TURBO_PROLOG();

    if (ErrorCode == ERROR_SUCCESS) {
        WS2_32_W4_INIT SocketID = INVALID_SOCKET;
        __try {
            // Look for a socket in the three fd_sets handed in. The first
            // socket found will be used to select the service provider to
            // service this call
            if (readfds && readfds->fd_count)
                {
                SocketID = readfds->fd_array[0];
                FoundSocket = TRUE;
                } //if

            if (!FoundSocket && writefds && writefds->fd_count )
                {
                SocketID = writefds->fd_array[0];
                FoundSocket = TRUE;
                } //if

            if (!FoundSocket && exceptfds && exceptfds->fd_count )
                {
                SocketID = exceptfds->fd_array[0];
                FoundSocket = TRUE;
                } //if
        }
        __except (WS2_EXCEPTION_FILTER()) {
            ErrorCode = WSAEFAULT;
            goto ReturnError;
        }

        if (FoundSocket) {
            Socket = DSOCKET::GetCountedDSocketFromSocket(SocketID);
            if(Socket != NULL){
                Provider = Socket->GetDProvider();
                ReturnValue = Provider->WSPSelect(
                    nfds,
                    readfds,
                    writefds,
                    exceptfds,
                    timeout,
                    &ErrorCode);
                Socket->DropDSocketReference();
                if (ReturnValue!=SOCKET_ERROR)
                    return ReturnValue;

                assert (ErrorCode!=NO_ERROR);
                if (ErrorCode==NO_ERROR)
                    ErrorCode = WSASYSCALLFAILURE;

            } //if
            else {
                ErrorCode = WSAENOTSOCK;
            }
        } //if
        else {
            ErrorCode = WSAEINVAL;
        } //else
    }

ReturnError:
    SetLastError(ErrorCode);
    return(SOCKET_ERROR);
} //select




int WSAAPI
WSAEventSelect(
    IN SOCKET s,
    IN WSAEVENT hEventObject,
    IN long lNetworkEvents
    )
/*++
Routine Description:

    Specify an event object to be associated with the supplied set of
    FD_XXX network events.

Arguments:

    s - A descriptor identifying the socket.

    hEventObject - A handle identifying the event object to be
                   associated with the supplied set of FD_XXX network
                   events.

    lNetworkEvents - A bitmask which specifies the combination of
                     FD_XXX network events in which the application
                     has interest.

Returns:
    Zero on success else SOCKET_Error. The error code is stored with
    SetLastError().
--*/
{
    INT                ReturnValue;
    INT                ErrorCode;
    PDPROVIDER         Provider;
    PDSOCKET           Socket;

    ErrorCode = TURBO_PROLOG();

    if (ErrorCode == ERROR_SUCCESS) {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPEventSelect(
                s,
                hEventObject,
                lNetworkEvents,
                &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
} //WSAEventSelect


int WSAAPI
WSAAsyncSelect(
    IN SOCKET s,
    IN HWND hWnd,
    IN u_int wMsg,
    IN long lEvent
    )
/*++
Routine Description:

    Request event notification for a socket.

Arguments:

    s - A descriptor identifying the socket for which event notification is
        required.

    hWnd - A handle identifying the window which should receive a message when
           a network event occurs.

    wMsg - The message to be received when a network event occurs.

    lEvent - A bitmask which specifies a combination of network events in which
             the application is interested.

Returns:
    The return value is 0 if the application's declaration of interest in the
    network event set was successful.  Otherwise the value SOCKET_ERROR is
    returned, and a specific error number may be retrieved by calling
    WSAGetLastError().
--*/
{
    INT                ReturnValue;
    INT                ErrorCode;
    PDPROVIDER         Provider;
    PDSOCKET           Socket;

    ErrorCode = TURBO_PROLOG();

    if (ErrorCode == ERROR_SUCCESS) {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPAsyncSelect(
                s,
                hWnd,
                wMsg,
                lEvent,
                &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
} //WSAAsyncSelect



int FAR PASCAL
__WSAFDIsSet(
    SOCKET fd,
    fd_set FAR *set)
/*++
Routine Description:

    Determines if a specific socket is a contained in an FD_SET.

Arguments:

    s - A descriptor identifying the socket.

    set - A pointer to an FD_SET.
Returns:

    Returns TRUE if socket s is a member of set, otherwise FALSE.

--*/
{
    int i = set->fd_count; // index into FD_SET
    int rc=FALSE; // user return code

    while (i--){
        if (set->fd_array[i] == fd) {
            rc = TRUE;
        } //if
    } //while
    return (rc);
} // __WSAFDIsSet



int FAR PASCAL
WPUFDIsSet(
    SOCKET fd,
    fd_set FAR *set)
/*++
Routine Description:

    Determines if a specific socket is a contained in an FD_SET.

Arguments:

    s - A descriptor identifying the socket.

    set - A pointer to an FD_SET.
Returns:

    Returns TRUE if socket s is a member of set, otherwise FALSE.

--*/
{
    int return_value;

    return_value = __WSAFDIsSet(
        fd,
        set
        );
    return(return_value);
} // WPUFDIsSet
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\sockctrl.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    SockCtrl.c

Abstract:

    This  module  contains  functions  that control the state of a socket.  The
    following functions are contained in the module.

    bind()
    connect()
    getpeername()
    getsockname()
    listen()
    setsockopt()
    shutdown()
    WSAConnect()
    WSAEnumNetworkEvents()
    WSAGetOverlapedResult()
    WSAJoinLeaf()


Author:

    Dirk Brandewie dirk@mink.intel.com  14-06-1995

Revision History:

    23-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Moved includes into precomp.h. Reworked all
        functions to remove extra if's and to be consistant with the rest of
        the project.

--*/
#include "precomp.h"



int WSAAPI
bind(
    IN SOCKET s,
    IN const struct sockaddr FAR *name,
    IN int namelen
    )
/*++
Routine Description:

    Associate a local address with a socket.

Arguments:

    s       - A descriptor identifying an unbound socket.

    name    - The address to assign to the socket.

    namelen - The length of the name.

Returns:

    Zero  on  success  else  SOCKET_ERROR.   The  error  code  is  stored  with
    SetLastError().

--*/
{
    INT                ReturnValue;
    PDPROVIDER         Provider;
    INT                ErrorCode;
    PDSOCKET           Socket;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode==ERROR_SUCCESS)
    {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPBind(s,
                                            name,
                                            namelen,
                                            &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}



int WSAAPI
connect(
    IN SOCKET s,
    IN const struct sockaddr FAR *name,
    IN int namelen
    )
/*++
Routine Description:

    Establish a connection to a peer.

Arguments:

    s       - A descriptor identifying an unconnected socket.

    name    - The name of the peer to which the socket is to be connected.

    namelen - The length of the name.

Returns:

    Zero  on  success  else  SOCKET_ERROR.   The  error  code  is  stored  with
    SetLastError().

--*/
{

    INT                ReturnValue;
    PDPROCESS          Process;
    PDTHREAD           Thread;
    PDPROVIDER         Provider;
    INT                ErrorCode;
    PDSOCKET           Socket;
    BOOL               RetryConnect;
    INT				   SavedErrorCode;


    ErrorCode = PROLOG(&Process, &Thread);
    if (ErrorCode==ERROR_SUCCESS)
    {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
#ifdef RASAUTODIAL
			RetryConnect = FALSE;
            WS2_32_W4_INIT SavedErrorCode=SOCKET_ERROR;
        retry:
#endif // RASAUTODIAL
            ReturnValue = Provider->WSPConnect(s,
                                               name,
                                               namelen,
                                               NULL,
                                               NULL,
                                               NULL,
                                               NULL,
                                               &ErrorCode);
#ifdef RASAUTODIAL
            if (ReturnValue == SOCKET_ERROR &&
                (ErrorCode == WSAEHOSTUNREACH || ErrorCode == WSAENETUNREACH))
            {
                if (!RetryConnect) {
                    //
                    // We preserve the original error
                    // so we can return it in case the
                    // second call to WSPConnect() fails
                    // also.
                    //
                    SavedErrorCode = ErrorCode;
                    //
                    // Only one retry per connect attempt.
                    //
                    RetryConnect = TRUE;
                    if (WSAttemptAutodialAddr(name, namelen))
                        goto retry;
                }
                else
                    ErrorCode = SavedErrorCode;
            }
#endif // RASAUTODIAL
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    //
    // If this is a 1.x application and the service provider
    // failed the request with WSAEALREADY, map the error code
    // to WSAEINVAL to be consistent with MS's WinSock 1.1
    // implementations.
    //

    if( ErrorCode == WSAEALREADY &&
        Process->GetMajorVersion() == 1 ) {
        ErrorCode = WSAEINVAL;
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}



int WSAAPI
getpeername(
    IN SOCKET s,
    OUT struct sockaddr FAR *name,
    OUT int FAR * namelen
    )
/*++
Routine Description:

    Get the address of the peer to which a socket is connected.

Arguments:

    s       - A descriptor identifying a connected socket.

    name    - The structure which is to receive the name of the peer.

    namelen - A pointer to the size of the name structure.

Returns:

    Zero  on  success  else  SOCKET_ERROR.   The  error  code  is  stored  with
    SetLastError().
--*/
{
    INT                 ReturnValue;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDSOCKET            Socket;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode == ERROR_SUCCESS) {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPGetPeerName(s,
                                                   name,
                                                   namelen,
                                                   &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}



int WSAAPI
getsockname(
    IN SOCKET s,
    OUT struct sockaddr FAR *name,
    OUT int FAR * namelen
    )
/*++
Routine Description:

    Get the local name for a socket.

Arguments:

    s       - A descriptor identifying a bound socket.

    name    - Receives the address (name) of the socket.

    namelen - The size of the name buffer.

Returns:

    Zero  on  success  else  SOCKET_ERROR.   The  error  code  is  stored  with
    SetLastError().

--*/
{
    INT                 ReturnValue;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDSOCKET            Socket;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode == ERROR_SUCCESS) {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPGetSockName(s,
                                                   name,
                                                   namelen,
                                                   &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}




int WSAAPI
getsockopt(
    IN SOCKET s,
    IN int level,
    IN int optname,
    OUT char FAR * optval,
    IN OUT int FAR *optlen
    )
/*++
Routine Description:

    Retrieve a socket option.

Arguments:

    s       - A descriptor identifying a socket.

    level   - The  level  at  which the option is defined; the supported levels
              include   SOL_SOCKET   and  IPPROTO_TCP.   (See  annex  for  more
              protocol-specific levels.)

    optname - The socket option for which the value is to be retrieved.

    optval  - A  pointer  to  the  buffer  in which the value for the requested
              option is to be returned.

    optlen  - A pointer to the size of the optval buffer.

Returns:

    Zero  on  success  else  SOCKET_ERROR.   The  error  code  is  stored  with
    SetLastError().

--*/
{
    INT                 ReturnValue;
    PDTHREAD            Thread;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDSOCKET            Socket;
    WSAPROTOCOL_INFOW   ProtocolInfoW;
    char FAR *          SavedOptionValue = NULL;
    int                 SavedOptionLen = 0;

    ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if (ErrorCode==ERROR_SUCCESS) {
        //
        // SO_OPENTYPE hack-o-rama.
        //

        if( level == SOL_SOCKET && optname == SO_OPENTYPE ) {
            __try {
                if( optlen == NULL || *optlen < sizeof(INT) ) {
                    SetLastError( WSAEFAULT );
                    return SOCKET_ERROR;
                }

                *((LPINT)optval) = Thread->GetOpenType();
                *optlen = sizeof(INT);
                return ERROR_SUCCESS;
            }
            __except (WS2_EXCEPTION_FILTER()) {
                SetLastError (WSAEFAULT);
                return SOCKET_ERROR;
            }
        }

        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();

            //
            // If we managed to lookup the provider from the socket, and the
            // user is asking for the ANSI WSAPROTOCOL_INFOA information,
            // then validate their option length parameter, remember this fact,
            // and map the option name to SO_PROTOCOL_INFOW.
            //

            if( level == SOL_SOCKET &&
                optname == SO_PROTOCOL_INFOA ) {

                __try {
                    if( optval == NULL ||
                        optlen == NULL ||
                        *optlen < sizeof(WSAPROTOCOL_INFOA) ) {

                        * optlen = sizeof(WSAPROTOCOL_INFOA);
                        ErrorCode = WSAEFAULT;
                        Socket->DropDSocketReference();
                        goto ErrorExit;
                    }


                    SavedOptionLen = *optlen;
                    *optlen = sizeof(WSAPROTOCOL_INFOW);
                    SavedOptionValue = optval;
                    optval = (char FAR *)&ProtocolInfoW;
                    optname = SO_PROTOCOL_INFOW;
                }
                __except (WS2_EXCEPTION_FILTER()) {
                    ErrorCode = WSAEFAULT;
                    Socket->DropDSocketReference();
                    goto ErrorExit;
                }
            }

            ReturnValue = Provider->WSPGetSockOpt(s,
                                                  level,
                                                  optname,
                                                  optval,
                                                  optlen,
                                                  &ErrorCode);

            Socket->DropDSocketReference();
            if( ReturnValue == ERROR_SUCCESS ) {
                if (SavedOptionValue == NULL ) {
                    return ReturnValue;
                }
                else {
                    //
                    // We successfully retrieved the UNICODE WSAPROTOCOL_INFOW
                    // structure. Now just map it to ANSI.
                    //

                    ErrorCode = MapUnicodeProtocolInfoToAnsi(
                        &ProtocolInfoW,
                        (LPWSAPROTOCOL_INFOA)SavedOptionValue
                        );
                    __try {
                        *optlen = SavedOptionLen;
                    }
                    __except (WS2_EXCEPTION_FILTER()) {
                        ErrorCode = WSAEFAULT;
                    }

                    if (ErrorCode==ERROR_SUCCESS) {
                        return ReturnValue;
                    }
                }
            }
            else {
                assert (ErrorCode!=NO_ERROR);
                if (ErrorCode==NO_ERROR)
                    ErrorCode = WSASYSCALLFAILURE;
            }
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

ErrorExit:
    SetLastError(ErrorCode);
    return(SOCKET_ERROR);
}



int WSAAPI
listen(
    IN SOCKET s,
    IN int backlog
    )
/*++
Routine Description:

    Establish a socket to listen for incoming connection.

Arguments:

    s       - A descriptor identifying a bound, unconnected socket.

    backlog - The  maximum length to which the queue of pending connections may
              grow.   If  this  value is SOMAXCONN, then the underlying service
              provider  responsible  for  socket  s  will  set the backlog to a
              maximum reasonable value.

Returns:

    Zero  on  success  else  SOCKET_ERROR.   The  error  code  is  stored  with
    SetLastError().

--*/
{
    INT                 ReturnValue;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDSOCKET            Socket;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode == ERROR_SUCCESS) {

        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPListen(s,
                                              backlog,
                                              &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}




int WSAAPI
setsockopt(
    IN SOCKET s,
    IN int level,
    IN int optname,
    IN const char FAR * optval,
    IN int optlen
    )
/*++
Routine Description:

    Set a socket option.

Arguments:

    s       - A descriptor identifying a socket.

    level   - The  level  at  which the option is defined; the supported levels
              include SOL_SOCKET and IPPROTO_TCP.

    optname - The socket option for which the value is to be set.

    optval  - A  pointer  to  the  buffer  in which the value for the requested
              option is supplied.

    optlen  - The size of the optval buffer.

Returns:

    Zero  on  success  else  SOCKET_ERROR.   The  error  code  is  stored  with
    SetLastError().

--*/

{
    INT                 ReturnValue;
    PDTHREAD            Thread;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDSOCKET            Socket;

    ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if (ErrorCode == ERROR_SUCCESS) {
        //
        // SO_OPENTYPE hack-o-rama.
        //

        if( level == SOL_SOCKET && optname == SO_OPENTYPE ) {
            INT openType;
            if( optlen < sizeof(INT) ) {
                SetLastError( WSAEFAULT );
                return SOCKET_ERROR;
            }

            __try {
                openType = *((LPINT)optval);
            }
            __except (WS2_EXCEPTION_FILTER()) {
                SetLastError (WSAEFAULT);
                return SOCKET_ERROR;
            }

            Thread->SetOpenType( openType );
            return ERROR_SUCCESS;
        }

        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPSetSockOpt(s,
                                                  level,
                                                  optname,
                                                  optval,
                                                  optlen,
                                                  &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}



int WSAAPI
shutdown(
    IN SOCKET s,
    IN int how
    )
/*++
Routine Description:

    Disable sends and/or receives on a socket.

Arguments:

     s   - A descriptor identifying a socket.

     how - A  flag  that  describes  what  types of operation will no longer be
           allowed.

Returns:

    Zero  on  success  else  SOCKET_ERROR.   The  error  code  is  stored  with
    SetLastError().
--*/
{
    INT                 ReturnValue;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDSOCKET            Socket;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode==ERROR_SUCCESS) {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPShutdown(s,
                                                how,
                                                &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}



int WSAAPI
WSAConnect(
    IN SOCKET s,
    IN const struct sockaddr FAR *name,
    IN int namelen,
    IN LPWSABUF lpCallerData,
    OUT LPWSABUF lpCalleeData,
    IN LPQOS lpSQOS,
    IN LPQOS lpGQOS
    )
/*++
Routine Description:

    Establish a connection to a peer, exchange connect data, and specify needed
    quality of service based on the supplied flow spec.

Arguments:

    s            - A descriptor identifying an unconnected socket.

    name         - The name of the peer to which the socket is to be connected.

    namelen      - The length of the name.

    lpCallerData - A  pointer to the user data that is to be transferred to the
                   peer during connection establishment.

    lpCalleeData - A  pointer  to  the user data that is to be transferred back
                   from the peer during connection establishment.

    lpSQOS       - A pointer to the flow spec for socket s.

    lpGQOS       - A  pointer  to  the  flow  spec  for  the  socket  group (if
                   applicable).

Returns:

    Zero  on  success  else  SOCKET_ERROR.   The  error  code  is  stored  with
    SetLastError().

--*/
{
    INT                 ReturnValue;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDSOCKET            Socket;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode==ERROR_SUCCESS) {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPConnect(s,
                                               name,
                                               namelen,
                                               lpCallerData,
                                               lpCalleeData,
                                               lpSQOS,
                                               lpGQOS,
                                               &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}



int WSAAPI
WSAEnumNetworkEvents(
    IN SOCKET s,
    IN WSAEVENT hEventObject,
    IN LPWSANETWORKEVENTS lpNetworkEvents
    )
/*++
Routine Description:

    Discover occurrences of network events for the indicated socket.

Arguments:
     s               - A descriptor identifying the socket.

     hEventObject    - An  optional  handle  identifying  an  associated  event
                       object to be reset.

     lpNetworkEvents - A  pointer  to a WSANETWORKEVENTS struct which is filled
                       with  a  record  of  occurred  network  events  and  any
                       associated error codes.

Returns:

    Zero  on  success  else  SOCKET_ERROR.   The  error  code  is  stored  with
    SetLastError().
--*/
{
    INT                 ReturnValue;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDSOCKET            Socket;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode==ERROR_SUCCESS) {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPEnumNetworkEvents(s,
                                                         hEventObject,
                                                         lpNetworkEvents,
                                                         &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}



BOOL WSAAPI
WSAGetOverlappedResult(
    IN SOCKET s,
    IN LPWSAOVERLAPPED lpOverlapped,
    OUT LPDWORD lpcbTransfer,
    IN BOOL fWait,
    OUT LPDWORD lpdwFlags
    )
/*++
Routine Description:

    Returns the results of an overlapped operation on the specified socket.

Arguments:
    s            - Identifies  the  socket.   This  is the same socket that was
                   specified  when  the  overlapped  operation was started by a
                   call to WSARecv(), WSARecvFrom(), WSASend(), WSASendTo(), or
                   WSAIoctl().

    lpOverlapped - Points  to a WSAOVERLAPPED structure that was specified when
                   the overlapped operation was started.

    lpcbTransfer - Points  to  a  32-bit  variable  that receives the number of
                   bytes  that  were  actually transferred by a send or receive
                   operation, or by WSAIoctl().

    fWait        - Specifies  whether  the function should wait for the pending
                   overlapped  operation  to  complete.   If TRUE, the function
                   does  not return until the operation has been completed.  If
                   FALSE  and  the  operation  is  still  pending, the function
                   returns  FALSE  and  the  WSAGetLastError() function returns
                   WSA_IO_INCOMPLETE.

    lpdwFlags    - Points  to  a  32-bit variable that will receive one or more
                   flags   that  supplement  the  completion  status.   If  the
                   overlapped   operation   was   initiated  via  WSARecv()  or
                   WSARecvFrom(), this parameter will contain the results value
                   for lpFlags parameter.

Returns:

     If  the  function succeeds, the return value is TRUE.  This means that the
     overlapped  operation  has  completed  and  that  the  value pointed to by
     lpcbTransfer    has   been   updated.    The   application   should   call
     WSAGetLastError() to obtain any error status for the overlapped operation.
     If  the function fails, the return value is FALSE.  This means that either
     the overlapped operation has not completed or that completion status could
     not  be  determined  due to errors in one or more parameters.  On failure,
     the   value   pointed  to  by  lpcbTransfer  will  not  be  updated.   Use
     WSAGetLastError() to determine the cause of the failure.

--*/
{
    BOOL                ReturnValue;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDSOCKET            Socket;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode==ERROR_SUCCESS) {

        //
        // Handle may have been closed before overlapped operation
        // completed, avoid exporting it from another process/provider.
        // After all, it is almost impossible to do overlapped operation
        // in one process and get the result in another.
        //
        Socket = DSOCKET::GetCountedDSocketFromSocketNoExport (s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPGetOverlappedResult(
                s,
                lpOverlapped,
                lpcbTransfer,
                fWait,
                lpdwFlags,
                &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\spinstal.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    spinstall.cpp

Abstract:

    This module contains the entry points for service provider installation and
    deinstallation.

Author:

    Paul Drews (drewsxpa@ashland.intel.com) 2-Aug-1995

Notes:

    $Revision:   1.16  $

    $Modtime:   12 Jan 1996 14:55:36  $

Revision History:

    most-recent-revision-date email-name
        description

    23-Aug-1995 dirk@mink.intel.com
        Moved includes to precomp.h

    2-Aug-1995 drewsxpa@ashland.intel.com
        Original created

--*/

#include "precomp.h"


// The  following  type is used to pass context back and forth to an enumerator
// iteration procedure when attempting to match a provider.
typedef struct {
    GUID                ProviderId;
    PPROTO_CATALOG_ITEM CatalogItem;
} GUID_MATCH_CONTEXT,  FAR * PGUID_MATCH_CONTEXT;


BOOL
GuidMatcher (
    IN PVOID                PassBack,
    IN PPROTO_CATALOG_ITEM  CatalogEntry
    )
#ifndef _WIN64_32
/*++

Routine Description:

    This  procedure determines if ProviderId of a passed CatalogEntry matches
    a  target  provider GUID.  If so, it sets a flag to indicate that the match
    was  found  and  returns  FALSE to terminate the enumeration.  Otherwise it
    returns TRUE and the enumeration continues.

Arguments:

    PassBack     - Supplies  a  reference  to  a  GUID_MATCH_CONTEXT structure.
                    Returns catalog entry reference if it was discovered

    CatalogEntry - Supplies  to  the client a reference to a PROTO_CATALOG_ITEM
                   structure with values for this item of the enumeration.

Return Value:

    If a match is found, the function returns FALSE to terminate the iteration,
    otherwise it returns TRUE to continue the iteration.
--*/
{
    PGUID_MATCH_CONTEXT  context;

    context = (PGUID_MATCH_CONTEXT)PassBack;

    if( context->ProviderId == *(CatalogEntry->GetProviderId()) ) {
        context->CatalogItem = CatalogEntry;
        return FALSE;  // do not continue iteration
    }

    return TRUE;  // continue iteration
}  // GuidMatcher
#else
;
#endif


int
WSPAPI
#ifndef _WIN64_32
WSCInstallProvider(
#else
WSCInstallProvider64_32(
#endif
    IN  LPGUID lpProviderId,
    IN  const WCHAR FAR * lpszProviderDllPath,
    IN  const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN  DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    )
/*++

Routine Description:

    This   procedure   installs   the   specified   provider  into  the  system
    configuration  database.   After  this  call,  a  WinSock  2  DLL  instance
    initialized  via  a  first call to WSAStartup will return the new protocols
    from the WSAEnumProtocols function.

    It  is the caller's responsibility to perform required file installation or
    service provider specific configuration.

Arguments:

    lpProviderId        - Supplies a GUID giving the locally unique identifier
                          for the newly installed provider.

    lpszProviderDllPath - Supplies a reference to a fully qualified path to the
                          providers  DLL image.  This path may contain embedded
                          environment  strings  (such  as  %SystemRoot%).  Such
                          environment strings are expanded whenever the WinSock
                          2  DLL  needs  to  load  the provider DLL.  After any
                          embedded   environment   strings  are  expanded,  the
                          WinSock  2  DLL  passes the resulting string into the
                          LoadLibrary() API to load the provider into memory.

    lpProtocolInfoList  - Supplies a reference to an array of WSAPROTOCOL_INFOW
                          structures.      Each     structure     defines     a
                          protocol/address_family/socket_type  supported by the
                          provider.

    dwNumberOfEntries   - Supplies    the    number    of    entries   in   the
                          lpProtocolInfoList array.

    lpErrno             - Returns the error code.

Return Value:

    If no error occurs, WSCInstallProvider() returns ERROR_SUCCESS.  Otherwise,
    it  returns  SOCKET_ERROR, and a specific error code is returned in the int
    referenced by lpErrno.

Implementation Notes:

    open winsock registry
    create catalog from registry
    check provider name for uniqueness
    providerid = allocate provider id
    for each protocolinfo in list
        allocate catalog entry id
        write provider id and catalog entry id into protocol info
        create catalogitem from values
        append item to catalog
        check if item is for NonIFS provider
    end for
    enable non-IFS handle support if any NonIFS providers
    write catalog to registry
    close winsock registry
--*/
{
    int  errno_result;
    int  return_value;
    HKEY  registry_root;
    DWORD  entry_id;
    int pindex;
    WSAPROTOCOL_INFOW proto_info;
    BOOL NonIFS = FALSE;

    // objects protected by "try" block
    PDCATALOG            catalog = NULL;
    PPROTO_CATALOG_ITEM  item = NULL;
    BOOL InstalledNonIFS = FALSE;

    registry_root = OpenWinSockRegistryRoot();
    if (registry_root == NULL) {
        DEBUGF(
            DBG_ERR,
            ("Opening registry root\n"));
        * lpErrno = WSANO_RECOVERY;
        return SOCKET_ERROR;
    }

    //
    // Check the current protocol catalog key. If it doesn't match
    // the expected value, blow away the old key and update the
    // stored value.
    //

    ValidateCurrentCatalogName(
        registry_root,
        WINSOCK_CURRENT_PROTOCOL_CATALOG_NAME,
        DCATALOG::GetCurrentCatalogName()
        );

    errno_result = ERROR_SUCCESS;
    return_value = ERROR_SUCCESS;

    TRY_START(guard_memalloc) {
        GUID_MATCH_CONTEXT  context;

        context.CatalogItem = NULL;
        __try {
            context.ProviderId = *lpProviderId;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            errno_result = WSAEFAULT;
            TRY_THROW (guard_memalloc);
        }

        catalog = new DCATALOG();
        if (catalog == NULL) {
            errno_result = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(guard_memalloc);
        }

#ifndef _WIN64_32
        errno_result = catalog->InitializeFromRegistry(
            registry_root,  // ParentKey
            NULL            // ChangeEvent
            );
#else
        errno_result = catalog->InitializeFromRegistry64_32(
            registry_root  // ParentKey
            );
#endif
        if (errno_result != ERROR_SUCCESS) {
            TRY_THROW(guard_memalloc);
        }

        catalog->EnumerateCatalogItems(
            GuidMatcher,         // Iteration
            & context  // PassBack
            );
        if (context.CatalogItem!=NULL) {
            errno_result = WSANO_RECOVERY;
            TRY_THROW(guard_memalloc);
        }

        for (pindex = 0; pindex < (int) dwNumberOfEntries; pindex++) {

            entry_id = catalog->AllocateCatalogEntryId();

            item = new PROTO_CATALOG_ITEM();
            if (item == NULL) {
                errno_result = WSA_NOT_ENOUGH_MEMORY;
                TRY_THROW(guard_memalloc);
            }

            __try {
                proto_info = lpProtocolInfoList[pindex];
                proto_info.ProviderId = *lpProviderId;
                proto_info.dwCatalogEntryId = entry_id;

                if (!(proto_info.dwServiceFlags1 & XP1_IFS_HANDLES)) {
                    NonIFS = TRUE;
                }

                errno_result = item->InitializeFromValues(
                    (LPWSTR)lpszProviderDllPath,  // LibraryPath
                    & proto_info    // ProtoInfo
                    );
            }
            __except (WS2_EXCEPTION_FILTER()) {
                errno_result = WSAEFAULT;
            }

            if (errno_result != ERROR_SUCCESS) {
                TRY_THROW(guard_memalloc);
            }

            catalog->AppendCatalogItem(
                item  // CatalogItem
                );
#ifdef _WIN64_32
            item = new PROTO_CATALOG_ITEM();
            if (item == NULL) {
                errno_result = WSA_NOT_ENOUGH_MEMORY;
                TRY_THROW(guard_memalloc);
            }
            __try {
                errno_result = item->InitializeFromValues(
                    (LPWSTR)lpszProviderDllPath,  // LibraryPath
                    & proto_info    // ProtoInfo
                    );
            }
            __except (WS2_EXCEPTION_FILTER()) {
                errno_result = WSAEFAULT;
            }
            if (errno_result != ERROR_SUCCESS) {
                TRY_THROW(guard_memalloc);
            }

            catalog->AppendCatalogItem32(
                item  // CatalogItem
                );
#endif
            item = NULL;  // item deletion is now covered by catalog
        }  // for pindex
    
        if (NonIFS) {
            errno_result = WahEnableNonIFSHandleSupport();
            if (errno_result==ERROR_SUCCESS)
                InstalledNonIFS = TRUE;
            else if (errno_result==ERROR_SERVICE_ALREADY_RUNNING) {
                errno_result = ERROR_SUCCESS;
            }
            else {
                TRY_THROW(guard_memalloc);
            }
        }

        errno_result = catalog->WriteToRegistry();
        if (errno_result!=ERROR_SUCCESS) {
            TRY_THROW(guard_memalloc);
        }

        delete catalog;

    } TRY_CATCH(guard_memalloc) {
        assert (errno_result != ERROR_SUCCESS);
        if (item != NULL) {
            item->Dereference ();
        }
        if (catalog != NULL) {
            delete catalog;
        }

        if (InstalledNonIFS)
            WahDisableNonIFSHandleSupport ();
    } TRY_END(guard_memalloc);

    CloseWinSockRegistryRoot(registry_root);

    if (errno_result == ERROR_SUCCESS) {
        HANDLE hHelper;

        //
        // Alert all interested apps of change via the notification method
        //

        if (WahOpenNotificationHandleHelper( &hHelper) == ERROR_SUCCESS) {
            WahNotifyAllProcesses( hHelper );
            WahCloseNotificationHandleHelper( hHelper );
        }
        else {
            //
            // This in non-fatal and catalog was updated anyway.
            //
        }

        return ERROR_SUCCESS;
    }
    else {

        __try {
            * lpErrno = errno_result;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            // Not much we can do about this
        }
        return SOCKET_ERROR;
    }

}  // WSCInstallProvider


// The  following  type is used to pass context back and forth to an enumerator
// iteration procedure when attempting to update a provider.
typedef struct {
    LPGUID              ProviderId;
    LPWSTR              LibraryPath;
    LPWSAPROTOCOL_INFOW ProtocolInfoArray;
    DWORD               ProtocolInfoCount;
    DWORD               UpdatedProtocolCount;
    INT                 Error;
    INT                 OriginalNonIfsCount;
    INT                 FinalNonIfsCount;
} PROVIDER_UPDATE_CONTEXT,  FAR * PPROVIDER_UPDATE_CONTEXT;


BOOL
ProviderUpdater(
    IN PVOID                PassBack,
    IN PPROTO_CATALOG_ITEM  CatalogEntry
    )
#ifndef _WIN64_32
/*++

Routine Description:

    This  procedure determines if ProviderId and any of catalog entry id
    of a passed context matches provider GUID and catalog entry of the  target  
    provider.  If so, it updates it and increments the updated count.

Arguments:

    PassBack     - Supplies  a  reference  to  a  GUID_MATCH_CONTEXT structure.
                    Returns catalog entry reference if it was discovered

    CatalogEntry - Supplies  to  the client a reference to a PROTO_CATALOG_ITEM
                   structure with values for this item of the enumeration.

Return Value:

    If a match is found, the function returns FALSE to terminate the iteration,
    otherwise it returns TRUE to continue the iteration.
--*/
{
    PPROVIDER_UPDATE_CONTEXT    context;
    DWORD                       i;

    context = (PPROVIDER_UPDATE_CONTEXT)PassBack;
    assert (context->UpdatedProtocolCount<=context->ProtocolInfoCount);
    assert (context->Error==NO_ERROR);
    if (!(CatalogEntry->GetProtocolInfo()->dwServiceFlags1 & XP1_IFS_HANDLES)) {
        context->OriginalNonIfsCount += 1;
    }

    __try {
        if( *context->ProviderId == *(CatalogEntry->GetProviderId())) {
            for (i=0; i<context->ProtocolInfoCount; i++) {
                if (context->ProtocolInfoArray[i].dwCatalogEntryId==
                        CatalogEntry->GetProtocolInfo()->dwCatalogEntryId) {
                    WSAPROTOCOL_INFOW    protoInfo;
                    protoInfo = context->ProtocolInfoArray[i];
                    protoInfo.ProviderId = *context->ProviderId;
                    CatalogEntry->InitializeFromValues (context->LibraryPath,
                                                        &protoInfo);
                    context->UpdatedProtocolCount += 1;
                    break;
                }
            }
        }
        if (!(CatalogEntry->GetProtocolInfo()->dwServiceFlags1 & XP1_IFS_HANDLES)) {
            context->FinalNonIfsCount += 1;
        }
        return TRUE;  // continue iteration
    }
    __except (WS2_EXCEPTION_FILTER ()) {
        context->Error = WSAEFAULT;
        return FALSE; // Stop iteration on error.
    }

}  // ProviderUpdater
#else
;
#endif


int
WSPAPI
#ifndef _WIN64_32
WSCUpdateProvider(
#else _WIN64_32
WSCUpdateProvider32(
#endif
    IN  LPGUID lpProviderId,
    IN  const WCHAR FAR * lpszProviderDllPath,
    IN  const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN  DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    )
/*++

Routine Description:

    This   procedure   installs   the   specified   provider  into  the  system
    configuration  database.   After  this  call,  a  WinSock  2  DLL  instance
    initialized  via  a  first call to WSAStartup will return the new protocols
    from the WSAEnumProtocols function.

    It  is the caller's responsibility to perform required file installation or
    service provider specific configuration.

Arguments:

    lpProviderId        - Supplies a GUID giving the locally unique identifier
                          for the newly installed provider.

    lpszProviderDllPath - Supplies a reference to a fully qualified path to the
                          providers  DLL image.  This path may contain embedded
                          environment  strings  (such  as  %SystemRoot%).  Such
                          environment strings are expanded whenever the WinSock
                          2  DLL  needs  to  load  the provider DLL.  After any
                          embedded   environment   strings  are  expanded,  the
                          WinSock  2  DLL  passes the resulting string into the
                          LoadLibrary() API to load the provider into memory.

    lpProtocolInfoList  - Supplies a reference to an array of WSAPROTOCOL_INFOW
                          structures.      Each     structure     defines     a
                          protocol/address_family/socket_type  supported by the
                          provider.

    dwNumberOfEntries   - Supplies    the    number    of    entries   in   the
                          lpProtocolInfoList array.

    lpErrno             - Returns the error code.

Return Value:

    If no error occurs, WSCInstallProvider() returns ERROR_SUCCESS.  Otherwise,
    it  returns  SOCKET_ERROR, and a specific error code is returned in the int
    referenced by lpErrno.

Implementation Notes:

    open winsock registry
    create catalog from registry
    check provider name for uniqueness
    providerid = allocate provider id
    for each protocolinfo in list
        allocate catalog entry id
        write provider id and catalog entry id into protocol info
        create catalogitem from values
        append item to catalog
        check if item is for NonIFS provider
    end for
    enable non-IFS handle support if any NonIFS providers
    write catalog to registry
    close winsock registry
--*/
{
    int  errno_result;
    int  return_value;
    HKEY  registry_root;

    // objects protected by "try" block
    PDCATALOG   catalog = NULL;
    BOOL        InstalledNonIFS = FALSE;
    PROVIDER_UPDATE_CONTEXT  context;
    context.ProviderId = lpProviderId;
    context.LibraryPath = NULL;
    context.ProtocolInfoArray = lpProtocolInfoList;
    context.ProtocolInfoCount = dwNumberOfEntries;
    context.UpdatedProtocolCount = 0;
    context.Error = NO_ERROR;
    context.OriginalNonIfsCount = 0;
    context.FinalNonIfsCount = 0;

    registry_root = OpenWinSockRegistryRoot();
    if (registry_root == NULL) {
        DEBUGF(
            DBG_ERR,
            ("Opening registry root\n"));
        * lpErrno = WSANO_RECOVERY;
        return SOCKET_ERROR;
    }

    //
    // Check the current protocol catalog key. If it doesn't match
    // the expected value, blow away the old key and update the
    // stored value.
    //

    ValidateCurrentCatalogName(
        registry_root,
        WINSOCK_CURRENT_PROTOCOL_CATALOG_NAME,
        DCATALOG::GetCurrentCatalogName()
        );

    errno_result = ERROR_SUCCESS;
    return_value = ERROR_SUCCESS;

    TRY_START(guard_memalloc) {
        context.LibraryPath = (LPWSTR)lpszProviderDllPath;
        catalog = new DCATALOG();
        if (catalog == NULL) {
            errno_result = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(guard_memalloc);
        }

#ifndef _WIN64_32
        errno_result = catalog->InitializeFromRegistry(
            registry_root,  // ParentKey
            NULL            // ChangeEvent
            );
#else
        errno_result = catalog->InitializeFromRegistry32(
            registry_root   // ParentKey
            );
#endif

        if (errno_result != ERROR_SUCCESS) {
            TRY_THROW(guard_memalloc);
        }

        catalog->EnumerateCatalogItems(
            ProviderUpdater,         // Iteration
            & context  // PassBack
            );
        if (context.UpdatedProtocolCount!=context.ProtocolInfoCount) {
            errno_result = WSANO_RECOVERY;
            TRY_THROW(guard_memalloc);
        }

        if (context.OriginalNonIfsCount==0 && context.FinalNonIfsCount!=0) {
            errno_result = WahEnableNonIFSHandleSupport();
            if (errno_result==ERROR_SUCCESS)
                InstalledNonIFS = TRUE;
            else if (errno_result==ERROR_SERVICE_ALREADY_RUNNING) {
                errno_result = ERROR_SUCCESS;
            }
            else {
                TRY_THROW(guard_memalloc);
            }
        }

        errno_result = catalog->WriteToRegistry();
        if (errno_result!=ERROR_SUCCESS) {
            TRY_THROW(guard_memalloc);
        }

        if (context.OriginalNonIfsCount!=0 && context.FinalNonIfsCount==0) {
            WahDisableNonIFSHandleSupport(); // ignore the error.
        }

        delete catalog;

    } TRY_CATCH(guard_memalloc) {
        assert (errno_result != ERROR_SUCCESS);
        if (catalog != NULL) {
            delete catalog;
        }

        if (InstalledNonIFS)
            WahDisableNonIFSHandleSupport ();
    } TRY_END(guard_memalloc);

    CloseWinSockRegistryRoot(registry_root);

    if (errno_result == ERROR_SUCCESS) {
        HANDLE hHelper;

        //
        // Alert all interested apps of change via the notification method
        //

        if (WahOpenNotificationHandleHelper( &hHelper) == ERROR_SUCCESS) {
            WahNotifyAllProcesses( hHelper );
            WahCloseNotificationHandleHelper( hHelper );
        }
        else {
            //
            // This in non-fatal and catalog was updated anyway.
            //
        }

        return ERROR_SUCCESS;
    }
    else {

        __try {
            * lpErrno = errno_result;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            // Not much we can do about this
        }
        return SOCKET_ERROR;
    }

}  // WSCInstallProvider


BOOL
NonIFSFinder(
    IN PVOID                PassBack,
    IN PPROTO_CATALOG_ITEM  CatalogEntry)
#ifndef _WIN64_32
/*++

Routine Description:

    This  procedure  checks catalog for NonIFS transport service providers.
    If one is found, it clears a flag to indicate that NonIFS handle support
    should not be removed and returns FALSE to terminate the enumeration.  
    Otherwise it returns TRUE and the enumeration continues.

Arguments:

    PassBack     - Supplies a pointer to bool that servers as the flag to
                    tell if NonIFS provider is found

    CatalogEntry - Supplies  to  the client a reference to a PROTO_CATALOG_ITEM
                   structure with values for this item of the enumeration.  The
                   pointer  is  not guaranteed to be valid after this procedure
                   returns, so the client should copy data if required.

Return Value:

    If a match is found, the function returns FALSE to terminate the iteration,
    otherwise it returns TRUE.
--*/
{
    PBOOL  context;

    context = (PBOOL)PassBack;

    if( !(CatalogEntry->GetProtocolInfo()->dwServiceFlags1 & XP1_IFS_HANDLES) ) {
        *context = FALSE;
        return FALSE;  // do not continue iteration
    }

    return TRUE;  // continue iteration
}  // NonIFSFinder
#else
;
#endif


int
WSPAPI
#ifndef _WIN64_32
WSCDeinstallProvider(
#else
WSCDeinstallProvider32(
#endif
    IN  LPGUID lpProviderId,
    OUT LPINT lpErrno
    )
/*++

Routine Description:

    This procedure removes the specified provider from the system configuration
    database.   After  this  call,  a  WinSock 2 DLL instance initialized via a
    first  call  to  WSAStartup  will no longer return the specified provider's
    protocols from the WSAEnumProtocols function.

    Any  additional  file  removal  or  service provider specific configuration
    information  removal  needed  to completely de-install the service provider
    must be performed by the caller.

Arguments:

    lpProviderId - Supplies  the  locally  unique identifier of the provider to
                   deinstall.   This  must  be  a  value previously passed to
                   WSCInstallProvider().

    lpErrno      - Returns the error code.

Return Value:

    If   no   error   occurs,   WSCDeinstallProvider()  returns  ERROR_SUCCESS.
    Otherwise,  it returns SOCKET_ERROR, and a specific error code is available
    in lpErrno.

Implementation Notes:

    open winsock registry
    create catalog from registry
    while (item = enumerate until find provider id) do
        remove item from catalog
        delete item
    end while
    write catalog to registry
    close winsock registry

--*/
{
    int  errno_result;
    int  return_value;
    HKEY  registry_root;
    BOOL  items_found;
    BOOL  DeinstallNonIFS = FALSE;

    // objects protected by "try" block
    PDCATALOG            catalog = NULL;

    registry_root = OpenWinSockRegistryRoot();
    if (registry_root == NULL) {
        DEBUGF(
            DBG_ERR,
            ("Opening registry root\n"));
        * lpErrno = WSANO_RECOVERY;
        return SOCKET_ERROR;
    }

    errno_result = ERROR_SUCCESS;
    return_value = ERROR_SUCCESS;

    TRY_START(guard_memalloc) {
        GUID_MATCH_CONTEXT  context;
        __try {
            context.ProviderId = *lpProviderId;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            errno_result = WSAEFAULT;
            TRY_THROW(guard_memalloc);
        }

        catalog = new DCATALOG();
        if (catalog == NULL) {
            errno_result = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(guard_memalloc);
        }
#ifndef _WIN64_32
        errno_result = catalog->InitializeFromRegistry(
            registry_root,  // ParentKey
            NULL            // ChangeEvent
            );
#else
        errno_result = catalog->InitializeFromRegistry32(
            registry_root   // ParentKey
            );
#endif
        if (errno_result != ERROR_SUCCESS) {
            TRY_THROW(guard_memalloc);
        }

        items_found = FALSE;
        do {
            context.CatalogItem = NULL;
            catalog->EnumerateCatalogItems(
                GuidMatcher,    // Iteration
                & context           // PassBack
                );
            if (context.CatalogItem!=NULL) {
                items_found = TRUE;
                //
                // Check if provider we are deinstalling is 
                // a non-ifs provider, we may want to disable
                // non-ifs support is this was the last non-ifs 
                // provider.
                //
                if (!DeinstallNonIFS) {
                    DeinstallNonIFS 
                        = !(context.CatalogItem->GetProtocolInfo()->dwServiceFlags1 
                            & XP1_IFS_HANDLES);
                }
                catalog->RemoveCatalogItem(context.CatalogItem);
                context.CatalogItem->Dereference ();
            }
        }
        while (context.CatalogItem!=NULL);

        if (! items_found) {
            errno_result = WSAEFAULT;
            TRY_THROW(guard_memalloc);
        }

        if (DeinstallNonIFS) {
            //
            // Check if there are any remaining non-IFS
            // providers left, if none left we will disable
            // non-IFS support
            //
            catalog->EnumerateCatalogItems(
                NonIFSFinder,               // Iteration
                & DeinstallNonIFS           // PassBack
                );
        }
        errno_result = catalog->WriteToRegistry();
        if (errno_result!=ERROR_SUCCESS) {
            TRY_THROW(guard_memalloc);
        }

        delete catalog;

        if (DeinstallNonIFS)
            WahDisableNonIFSHandleSupport();

    } TRY_CATCH(guard_memalloc) {
        assert (errno_result != ERROR_SUCCESS);
        if (catalog != NULL) {
            delete catalog;
        }
    } TRY_END(guard_memalloc);

    CloseWinSockRegistryRoot(registry_root);

    if (errno_result == ERROR_SUCCESS) {
        HANDLE hHelper;

        //
        // Alert all interested apps of change via the notification method
        //


        if (WahOpenNotificationHandleHelper( &hHelper )==ERROR_SUCCESS) {
            WahNotifyAllProcesses( hHelper );
            WahCloseNotificationHandleHelper( hHelper );
        }
        else {
            // This is non-fatal and catalog was updated anyway
        }

        return ERROR_SUCCESS;
    }
    else {

        __try {
            * lpErrno = errno_result;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            // Not much we can do about this
        }
        return SOCKET_ERROR;
    }

}  // WSCDeinstallProvider



// The  following  type is used to pass context back and forth to an enumerator
// iteration procedure when removing all items form the catalog
typedef struct {
    IN  DWORD               Count;      // Number of ids / size of item array
    IN  DWORD               *CatIds;    // Array of catalog id's to match against
    OUT PPROTO_CATALOG_ITEM *Items;     // Array of item pointers to return
    OUT INT                 ErrorCode;
} PROVIDER_SNAP_CONTEXT,  FAR * PPROVIDER_SNAP_CONTEXT;




BOOL
ProviderSnap(
    IN PVOID                PassBack,
    IN PPROTO_CATALOG_ITEM  CatalogEntry)
#ifndef _WIN64_32
/*++

Routine Description:
    Snaps all the catalog items in the current catalog

Arguments:

    PassBack     - Supplies  a reference to a PROVIDER_SNAP_CONTEXT structure.
                   Returns an array of items in the order specified by catalog
                   id array.

    CatalogEntry - Supplies  to  the client a reference to a PROTO_CATALOG_ITEM
                   structure with values for this item of the enumeration.  The
                   pointer  is  not guaranteed to be valid after this procedure
                   returns, so the client should copy data if required.

Return Value:

    If an item is found that could not be matched to catalog id in the array,
    the function returns FALSE to terminate the iteration,
    otherwise it returns TRUE.
--*/
{
    PPROVIDER_SNAP_CONTEXT      context;
    DWORD                       i;

    context = (PPROVIDER_SNAP_CONTEXT)PassBack;

    for (i=0; i<context->Count; i++) {
        __try {
            if (context->CatIds[i]
                    ==CatalogEntry->GetProtocolInfo ()->dwCatalogEntryId) {
                assert (context->Items[i]==NULL);
                context->Items[i] = CatalogEntry;
                return TRUE;
            }
        }
        __except (WS2_EXCEPTION_FILTER ()) {
            context->ErrorCode = WSAEFAULT;
            return FALSE;
        }
    }

    DEBUGF (DBG_ERR,
        ("Checking item array against catalog, CatId:%ld not in the array.\n",
        CatalogEntry->GetProtocolInfo ()->dwCatalogEntryId));
    context->ErrorCode = WSAEINVAL;

    return FALSE;
}  // ProviderSnap
#else
;
#endif _WIN64_32



int
WSPAPI
#ifndef _WIN64_32
WSCWriteProviderOrder (
#else
WSCWriteProviderOrder32 (
#endif
    IN LPDWORD lpwdCatalogEntryId,
    IN DWORD dwNumberOfEntries
    )
/*++

Routine Description:

    Reorder existing WinSock2 service providers.  The order of the service
    providers determines their priority in being selected for use.  The
    sporder.exe tool will show you the installed provider and their ordering,
    Alternately, WSCEnumProtocols(), in conjunction with this function,
    will allow you to write your own tool.

Arguments:

    lpwdCatalogEntryId  [in]
      An array of CatalogEntryId elements as found in the WSAPROTOCOL_INFO
      structure.  The order of the CatalogEntryId elements is the new
      priority ordering for the service providers.

    dwNumberOfEntries  [in]
      The number of elements in the lpwdCatalogEntryId array.


Return Value:

    ERROR_SUCCESS   - the service providers have been reordered.
    WSAEINVAL       - input parameters were bad, no action was taken.
    WSAEFAULT       - CatalogEnryId array is not fully contained within
                        process address space.
    WSATRY_AGAIN    - the routine is being called by another thread or process.
    any registry error code


Comments:

    Here are scenarios in which the WSCWriteProviderOrder function may fail:

      The dwNumberOfEntries is not equal to the number of registered service
      providers.

      The lpwdCatalogEntryId contains an invalid catalog ID.

      The lpwdCatalogEntryId does not contain all valid catalog IDs exactly
      1 time.

      The routine is not able to access the registry for some reason
      (e.g. inadequate user persmissions)

      Another process (or thread) is currently calling the routine.


--*/
{
    INT     errno_result;
    HKEY    registry_root;
    PPROTO_CATALOG_ITEM *items = NULL;
    DWORD   i;

    // object protected by "try" block
    PDCATALOG           catalog = NULL;


    items = new PPROTO_CATALOG_ITEM[dwNumberOfEntries];
    if (items==NULL) {
        DEBUGF(
            DBG_ERR,
            ("Allocating items array\n"));
        return WSA_NOT_ENOUGH_MEMORY;
    }

    memset (items, 0, sizeof (PPROTO_CATALOG_ITEM)*dwNumberOfEntries);
    errno_result = ERROR_SUCCESS;

    TRY_START(guard_memalloc) {
        PROVIDER_SNAP_CONTEXT context;
        registry_root = OpenWinSockRegistryRoot();
        if (registry_root == NULL) {
            DEBUGF(
                DBG_ERR,
                ("Opening registry root\n"));
            errno_result = WSANO_RECOVERY;
            TRY_THROW(guard_memalloc);
        }
        catalog = new DCATALOG();
        if (catalog == NULL) {
            errno_result = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(guard_memalloc);
        }

#ifndef _WIN64_32
        errno_result = catalog->InitializeFromRegistry(
            registry_root,  // ParentKey
            NULL            // ChangeEvent
            );
#else
        errno_result = catalog->InitializeFromRegistry32(
            registry_root
            );
#endif
        if (errno_result != ERROR_SUCCESS) {
            TRY_THROW(guard_memalloc);
        }

        context.Items = items;
        context.CatIds = lpwdCatalogEntryId;
        context.Count = dwNumberOfEntries;
        context.ErrorCode = ERROR_SUCCESS;

        catalog->EnumerateCatalogItems(
            ProviderSnap,         // Iteration
            & context               // PassBack
            );

        if (context.ErrorCode!=ERROR_SUCCESS) {
            errno_result = context.ErrorCode;
            TRY_THROW(guard_memalloc);
        }

        for (i=0; i<dwNumberOfEntries; i++) {
            if (context.Items[i]!=NULL) {
                //
                // Remove catalog item and add it in the end.
                //
                catalog->RemoveCatalogItem (context.Items[i]);
                catalog->AppendCatalogItem (context.Items[i]);
            }
            else {
                DEBUGF (DBG_ERR,
                    ("Checking item array against catalog, item: %ld(CatId:%ld) not in the catalog.\n",
                    i,lpwdCatalogEntryId[i]));
                errno_result = WSAEINVAL;
                TRY_THROW(guard_memalloc);
            }
        } // for i

        errno_result = catalog->WriteToRegistry();
        if (errno_result!=ERROR_SUCCESS) {
            TRY_THROW(guard_memalloc);
        }

        delete catalog;
        CloseWinSockRegistryRoot(registry_root);

    } TRY_CATCH(guard_memalloc) {
        assert (errno_result != ERROR_SUCCESS);
        if (catalog != NULL) {
            delete catalog; // This destroys the items as well
        }

        if (registry_root!=NULL) {
            CloseWinSockRegistryRoot(registry_root);
        }
    } TRY_END(guard_memalloc);

    delete items;

    if (errno_result == ERROR_SUCCESS) {
        HANDLE hHelper;

        //
        // Alert all interested apps of change via the notification method
        //

        if (WahOpenNotificationHandleHelper( &hHelper) == ERROR_SUCCESS) {
            WahNotifyAllProcesses( hHelper );
            WahCloseNotificationHandleHelper( hHelper );
        }
        else {
            //
            // This in non-fatal and catalog was updated anyway.
            //
        }
    }

    return errno_result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsock32\makefile.inc ===
$(O)\nlstxt.mc: $(PROJECT_ROOT)\inc\unixapis.mc ..\..\sockutil\sockutil.mc localmsg.mc
    copy $(PROJECT_ROOT)\inc\unixapis.mc+..\..\sockutil\sockutil.mc+localmsg.mc $@
    $(MC) -v -h $(O) -r $(O) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\sputil.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    sputil.cpp

Abstract:

    This  module  contains the implementation of the utility functions provided
    to   winsock   service  providers.   This  module  contains  the  following
    functions.

    WPUCloseEvent
    WPUCreateEvent
    WPUResetEvent
    WPUSetEvent
    WPUQueryBlockingCallback
    WSCGetProviderPath

Author:

    Dirk Brandewie (dirk@mink.intel.com) 20-Jul-1995

Notes:

    $Revision:   1.21  $

    $Modtime:   08 Mar 1996 00:45:22  $


Revision History:

    22-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Moved includes to precomp.h. Added
        some trace code
--*/


#include "precomp.h"


PWINSOCK_POST_ROUTINE SockPostRoutine = NULL;


BOOL WSPAPI
WPUCloseEvent(
    IN WSAEVENT hEvent,
    OUT LPINT lpErrno
    )
/*++
Routine Description:

    Closes an open event object handle.

Arguments:

    hEvent  - Identifies an open event object handle.

    lpErrno - A pointer to the error code.

Returns:

    If the function succeeds, the return value is TRUE.

--*/
{
    BOOL ReturnCode;

    ReturnCode = CloseHandle(hEvent);
    if (!ReturnCode) {
        *lpErrno = GetLastError();
    } //if
    return(ReturnCode);
}



WSAEVENT WSPAPI
WPUCreateEvent(
    OUT LPINT lpErrno
    )
/*++
Routine Description:

    Create a new event object.

Arguments:

    lpErrno - A pointer to the error code.

Returns:

    If  the  function  succeeds,  the  return  value is the handle of the event
    object.

    If the function fails, the return value is WSA_INVALID_EVENT and a specific
    error code is available in lpErrno.

--*/
{
    HANDLE ReturnValue;

    ReturnValue = CreateEvent(NULL, // default security
                              TRUE, // manual reset
                              FALSE, // nonsignalled state
                              NULL); // anonymous
    if (NULL == ReturnValue) {
        *lpErrno = GetLastError();
    } //if
    return(ReturnValue);
}




int WSPAPI
WPUQueryBlockingCallback(
    IN DWORD dwCatalogEntryId,
    OUT LPBLOCKINGCALLBACK FAR * lplpfnCallback,
    OUT PDWORD_PTR lpdwContext,
    OUT LPINT lpErrno
    )
/*++
Routine Description:

    Returns a pointer to a callback function the service probider should invoke
    periodically while servicing blocking operations.

Arguments:

    dwCatalogEntryId - Identifies the calling service provider.

    lplpfnCallback   - Receives a pointer to the blocking callback function.

    lpdwContext      - Receives  a context value the service provider must pass
                       into the blocking callback.

    lpErrno          - A pointer to the error code.

Returns:

    If  the function succeeds, it returns ERROR_SUCCESS.  Otherwise, it returns
    SOCKET_ERROR and a specific error code is available in the location pointed
    to by lpErrno.
--*/
{
    int                  ReturnValue;
    INT                  ErrorCode;
    LPBLOCKINGCALLBACK   callback_func = NULL;
    PDTHREAD             Thread;
    PDPROCESS            Process;
    DWORD_PTR            ContextValue  = 0;
    PDCATALOG            Catalog;

    assert(lpdwContext);
    assert(lpErrno);

    ErrorCode = PROLOG(&Process,
           &Thread);
    if (ErrorCode == ERROR_SUCCESS) {
        callback_func = Thread->GetBlockingCallback();

        if( callback_func != NULL ) {
            PPROTO_CATALOG_ITEM  CatalogItem;
            PDPROVIDER           Provider;

            Catalog = Process->GetProtocolCatalog();
            assert(Catalog);
            ErrorCode = Catalog->GetCountedCatalogItemFromCatalogEntryId(
                dwCatalogEntryId,  // CatalogEntryId
                & CatalogItem);    // CatalogItem
            if (ERROR_SUCCESS == ErrorCode) {

                Provider = CatalogItem->GetProvider();
                assert(Provider);
                ContextValue = Provider->GetCancelCallPtr();
                CatalogItem->Dereference ();
            } //if
        } //if
    } //if

    if (ERROR_SUCCESS == ErrorCode) {
        ReturnValue = ERROR_SUCCESS;
    }
    else {
        ReturnValue = SOCKET_ERROR;
        callback_func = NULL;
    } //if

    // Set the out parameters.
    *lpdwContext = ContextValue;
    *lpErrno = ErrorCode;
    *lplpfnCallback = callback_func;

    return(ReturnValue);
}




int WSPAPI
WPUQueueApc(
    IN LPWSATHREADID lpThreadId,
    IN LPWSAUSERAPC lpfnUserApc,
    IN DWORD_PTR dwContext,
    OUT LPINT lpErrno
    )
/*++
Routine Description:

    Queues  a  user-mode  APC  to  the  specified thread in order to facilitate
    invocation of overlapped I/O completion routines.

Arguments:

    lpThreadId  - A  pointer  to  a  WSATHREADID  structure that identifies the
                  thread  context.   This  is typically supplied to the service
                  provider  by  the  WinSock  DLL  as  in input parameter to an
                  overlapped operation.

    lpfnUserApc - Points to the APC function to be called.


    dwContext   - A  32  bit context value which is subsequently supplied as an
                  input parameter to the APC function.

    lpErrno     - A pointer to the error code.

Returns:

    If  no  error  occurs,  WPUQueueApc()  returns  0 and queues the completion
    routine  for the specified thread.  Otherwise, it returns SOCKET_ERROR, and
    a specific error code is available in lpErrno.

--*/
{
    HANDLE HelperHandle;
    PDPROCESS Process;
    PDTHREAD Thread;
    INT      ErrorCode;

    // Use ProLog to fill in Process and thread pointers. Only fail if
    // there is no valid process context
    ErrorCode = PROLOG(&Process,
           &Thread);
    if (ErrorCode == WSANOTINITIALISED) {
        *lpErrno = ErrorCode;
        return(SOCKET_ERROR);
    } //if
    assert (Process!=NULL);

    ErrorCode = Process->GetAsyncHelperDeviceID(&HelperHandle);
    if (ERROR_SUCCESS == ErrorCode )
    {
        ErrorCode = (INT) WahQueueUserApc(HelperHandle,
                                           lpThreadId,
                                           lpfnUserApc,
                                           dwContext);

    } //if

    if( ErrorCode == NO_ERROR ) {
        return ERROR_SUCCESS;
    }
    else {
        *lpErrno = ErrorCode;
        return SOCKET_ERROR;
    }
}


int
WSPAPI
WPUCompleteOverlappedRequest (
    SOCKET s, 	
    LPWSAOVERLAPPED lpOverlapped, 	
    DWORD dwError, 	
    DWORD cbTransferred, 	
    LPINT lpErrno
)
/*++
Routine Description:

    This function simmulates completion of overlapped IO request
    on socket handle created for non-IFS providers

Arguments:

    s            - socket handle to complete request on
    lpOverlapped - pointer to overlapped structure
    dwError      - WinSock 2.0 error code for opreation being completed
    cbTransferred- number of bytes transferred to/from user buffers as the
                    result of the operation being completed
    lpErrno     - A pointer to the error code.

Returns:

    If  no  error  occurs,  WPUCompleteOverlappedRequest()  returns  0 and
    completes the overlapped request as request by the application.
    Otherwise, it returns SOCKET_ERROR, and a specific error code is available
    in lpErrno.

--*/
{
    HANDLE HelperHandle;
    PDPROCESS Process;
    PDTHREAD Thread;
    INT      ErrorCode;

    // Use ProLog to fill in Process and thread pointers. Only fail if
    // there is no valid process context
    ErrorCode = PROLOG(&Process,
           &Thread);
    if (ErrorCode == WSANOTINITIALISED) {
        *lpErrno = ErrorCode;
        return(SOCKET_ERROR);
    } //if
    assert (Process!=NULL);

    ErrorCode = Process->GetHandleHelperDeviceID(&HelperHandle);
    if (ERROR_SUCCESS == ErrorCode )
    {
        ErrorCode = (INT) WahCompleteRequest (HelperHandle,
                                           s,
                                           lpOverlapped,
                                           dwError,
                                           cbTransferred);

    } //if

    if( ErrorCode == NO_ERROR ) {
        return ERROR_SUCCESS;
    }
    else {
        *lpErrno = ErrorCode;
        return SOCKET_ERROR;
    }
}


int WSPAPI
WPUOpenCurrentThread(
    OUT LPWSATHREADID lpThreadId,
    OUT LPINT lpErrno
    )
/*++
Routine Description:

    Opens the current thread. This is intended to be used by layered service
    providers that wish to initiate overlapped IO from non-application threads.

Arguments:

    lpThreadId  - A pointer to a WSATHREADID structure that will receive the
                  thread data.

    lpErrno     - A pointer to the error code.

Returns:

    If no error occurs, WPUOpenCurrentThread() returns 0 and the caller is
    responsible for (eventually) closing the thread by calling WPUCloseThread().
    Otherwise, WPUOpenCurrentThread() returns SOCKET_ERROR and a specific
    error code is available in lpErrno.

--*/
{
    HANDLE HelperHandle;
    PDPROCESS Process;
    PDTHREAD Thread;
    INT      ErrorCode;

    // Use ProLog to fill in Process and thread pointers. Only fail if
    // there is no valid process context
    ErrorCode = PROLOG(&Process,
           &Thread);
    if (ErrorCode == WSANOTINITIALISED) {
        *lpErrno = ErrorCode;
        return(SOCKET_ERROR);
    } //if
    assert (Process!=NULL);

    ErrorCode = Process->GetAsyncHelperDeviceID(&HelperHandle);
    if (ERROR_SUCCESS == ErrorCode )
    {
        ErrorCode = (INT) WahOpenCurrentThread(HelperHandle,
                                                lpThreadId);

    } //if

    if( ErrorCode == NO_ERROR ) {
        return ERROR_SUCCESS;
    }
    else {
        *lpErrno = ErrorCode;
        return SOCKET_ERROR;
    }
}


int WSPAPI
WPUCloseThread(
    IN LPWSATHREADID lpThreadId,
    OUT LPINT lpErrno
    )
/*++
Routine Description:

    Closes a thread opened via WPUOpenCurrentThread().

Arguments:

    lpThreadId  - A pointer to a WSATHREADID structure that identifies the
                  thread context.  This structure must have been initialized
                  by a previous call to WPUOpenCurrentThread().

    lpErrno     - A pointer to the error code.

Returns:

    If no error occurs, WPUCloseThread() returns 0.  Otherwise, it returns
    SOCKET_ERROR, and a specific error code is available in lpErrno.

--*/
{
    HANDLE HelperHandle;
    PDPROCESS Process;
    PDTHREAD Thread;
    INT      ErrorCode=0;

    // Use ProLog to fill in Process and thread pointers. Only fail if
    // there is no valid process context
    ErrorCode = PROLOG(&Process,
           &Thread);
    if (ErrorCode == WSANOTINITIALISED) {
        *lpErrno = ErrorCode;
        return(SOCKET_ERROR);
    } //if
    assert (Process!=NULL);

    ErrorCode = Process->GetAsyncHelperDeviceID(&HelperHandle);
    if (ERROR_SUCCESS == ErrorCode )
        {
        ErrorCode = (INT) WahCloseThread(HelperHandle,
                                          lpThreadId);

    } //if

    if( ErrorCode == NO_ERROR ) {
        return ERROR_SUCCESS;
    }
    else {
        *lpErrno = ErrorCode;
        return SOCKET_ERROR;
    }
}



BOOL WSPAPI
WPUResetEvent(
    IN WSAEVENT hEvent,
    OUT LPINT lpErrno
    )
/*++
Routine Description:

    Resets the state of the specified event object to nonsignaled.

Arguments:

    hEvent  - Identifies an open event object handle.

    lpErrno - A pointer to the error code.

Returns:

    If the function succeeds, the return value is TRUE.  If the function fails,
    the  return  value  is  FALSE  and  a  specific  error code is available in
    lpErrno.
--*/
{
    BOOL ReturnCode;

    ReturnCode = ResetEvent(hEvent);
    if (FALSE == ReturnCode) {
        *lpErrno = GetLastError();
    } //if
    return(ReturnCode);
}




BOOL WSPAPI
WPUSetEvent(
    IN WSAEVENT hEvent,
    OUT LPINT lpErrno
    )
/*++
Routine Description:

    Sets the state of the specified event object to signaled.

Arguments:

    hEvent  - Identifies an open event object handle.

    lpErrno - A pointer to the error code.

Returns:

    If the function succeeds, the return value is TRUE.  If the function fails,
    the  return  value  is  FALSE  and  a  specific  error code is available in
    lpErrno.
--*/
{
    BOOL ReturnCode;

    ReturnCode = SetEvent(hEvent);
    if (FALSE == ReturnCode) {
        *lpErrno = GetLastError();
    } //if
    return(ReturnCode);
}


BOOL
WINAPI
WPUPostMessage(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PWINSOCK_POST_ROUTINE   sockPostRoutine;
    sockPostRoutine = GET_SOCK_POST_ROUTINE ();
    if (sockPostRoutine==NULL)
        return FALSE;

    //
    // Special post routine works only for 16 bit apps.
    // It assumes that message is in HIWORD of Msg and LOWORD
    // is an index that tells it what post routine to call
    // (so it can properly map parameters for async name resolution).
    // If layered provider did its own async select and used its own
    // message and window in the context of 16 bit process it will simply
    // crash when processing message posted by the base provider. Grrr...
    //
    // So in the code below we try our best to figure out if message is
    // directed not to application but to layered provider window.
    //
    if (sockPostRoutine!=PostMessage) {
        PDSOCKET    Socket = DSOCKET::GetCountedDSocketFromSocketNoExport((SOCKET)wParam);
        BOOL        apiSocket;
        if (Socket!=NULL) {
            apiSocket = Socket->IsApiSocket();
            Socket->DropDSocketReference ();
            if (!apiSocket) {
                return PostMessage (hWnd, Msg, wParam, lParam);
            }
        }
    }

    return (sockPostRoutine)( hWnd, Msg, wParam, lParam );
}   // WPUPostMessage
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\wsautil.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    wsautil.cpp

Abstract:

    This  module  contains utility functions for the winsock DLL implementation
    that did not seem to fit into the other module.

Author:

    Dirk Brandewie dirk@mink.intel.com

Notes:

    $Revision:   1.24  $

    $Modtime:   14 Feb 1996 10:32:32  $

Revision History:

    23-Aug-1995 dirk@mink.intel.com
        Moved includes into precomp.h

    07-31-1995 drewsxpa@ashland.intel.com
        Added Registry-manipulation functions

    07-18-1995 dirk@mink.intel.com
        Initial revision

--*/

#include "precomp.h"

//
// Global pointer to the appropriate prolog function. This either points
// to Prolog_v1 for WinSock 1.1 apps or Prolog_v2 for WinSock 2.x apps.
//

LPFN_PROLOG PrologPointer = &Prolog_v2;
HANDLE      gHeap = NULL;



INT
WINAPI
SlowPrologOvlp (
        OUT     PDTHREAD FAR *  Thread
        ) 
{
    PDPROCESS   Process;
        
    return PROLOG( &Process, Thread );
}



INT
WINAPI
SlowProlog(
    VOID
    ) 
{
    PDPROCESS   Process;
    PDTHREAD    Thread;

    return PROLOG( &Process, &Thread );
}



INT
WINAPI
Prolog_v2(
    OUT PDPROCESS FAR * Process,
    OUT PDTHREAD FAR * Thread
    )
/*++

Routine Description:

     This routine is the standard WinSock 1.1 prolog function used at all the
     winsock API entrypoints.  This function ensures that the process has
     called WSAStartup.

Arguments:

    Process   - Pointer to the DPROCESS object for the process calling the
                winsock API.

    Thread    - Pointer to the DTHREAD object for the calling thread

Returns:

    This function returns ERROR_SUCCESS if successful, otherwise 
    the specific WinSock error code

--*/

{   
    INT ErrorCode;
    if ((*Process = DPROCESS::GetCurrentDProcess()) !=NULL) {
        *Thread = DTHREAD::GetCurrentDThread();
        if (*Thread!=NULL) {
            ErrorCode = ERROR_SUCCESS;
        }
        else {
            ErrorCode = DTHREAD::CreateDThreadForCurrentThread (*Process, Thread);
        }
    } //if
    else {
        ErrorCode = WSANOTINITIALISED;
    }
    return(ErrorCode);

}   // Prolog_v2



INT
WINAPI
Prolog_v1(
    OUT PDPROCESS FAR * Process,
    OUT PDTHREAD FAR * Thread
    )
/*++

Routine Description:

    This routine is the standard WinSock 1.1 prolog function used at all the
    winsock API entrypoints.  This function ensures that the process has
    called WSAStartup and that the current thread in the process does not have
    a WinSock call outstanding.

Arguments:

    Process   - Pointer to the DPROCESS object for the process calling the
                winsock API.

    Thread    - Pointer to the DTHREAD object for the calling thread


Returns:

    This function returns ERROR_SUCCESS if successful, otherwise 
    the specific WinSock error code

--*/
{
    INT ErrorCode;


    if ((*Process=DPROCESS::GetCurrentDProcess())!=NULL) {
        *Thread = DTHREAD::GetCurrentDThread();
        if (*Thread!=NULL) {
            ErrorCode = ERROR_SUCCESS;
        }
        else {
            ErrorCode = DTHREAD::CreateDThreadForCurrentThread (*Process, Thread);
        }
        if (ErrorCode == ERROR_SUCCESS) {
            if( !(*Thread)->IsBlocking() ) {
                ;
            } else {
                ErrorCode = WSAEINPROGRESS;
            }
        } //if

    } //if
    else {
        ErrorCode = WSANOTINITIALISED;
    }
    return(ErrorCode);
}   // Prolog_v1



INT
WINAPI
Prolog_Detached(
    OUT PDPROCESS FAR * Process,
    OUT PDTHREAD FAR * Thread
    )
/*++

Routine Description:

    API prolog used after we've been detached from the process's address
    space. In theory, this should be totally unnecessary, but at least one
    popular DLL (MFC 4.x) calls WSACleanup() in its process detach handler,
    which may occur *after* our DLL is already detached. Grr...

Arguments:

    Process - Unused.

    Thread - Unused.

Returns:

    INT - Always WSASYSNOTREADY.

--*/
{
    Process;
    Thread;

    return WSASYSNOTREADY;

}   // Prolog_Detached



BOOL
WriteRegistryEntry(
    IN      HKEY            EntryKey,
    IN      LPCTSTR         EntryName,
    IN      PVOID           Data,
    IN      DWORD           TypeFlag
    )
/*++

Routine Description:

    This  procedure  writes  a  single named value into an opened registry key.
    The  value  may  be  any  type whose length can be determined from its type
    (e.g., scalar types, zero-terminated strings).

Arguments:

    EntryKey  - Supplies  the open entry key under which the new named value is
                to be written.

    EntryName - Supplies the name of the value to be written.

    Data      - Supplies  a  reference  to the location where the entry data is
                found,  or to a WSABUF describing the data location in the case
                of REG_BINARY data.

    TypeFlag  - Supplies  an identifier for the type of the data to be written.
                Supported   types  are  REG_BINARY,  REG_DWORD,  REG_EXPAND_SZ,
                REG_SZ.    Types   not   supported   are  REG_DWORD_BIG_ENDIAN,
                REG_DWORD_LITTLE_ENDIAN,   REG_LINK,   REG_MULTI_SZ,  REG_NONE,
                REG_RESOURCE_LIST.   Note  that  depending on the architecture,
                one   of   the   "big_endian"   or   "little_endian"  forms  of
                REG_DWORD_x_ENDIAN  is implicitly allowed, since it is equal to
                REG_DWORD.

Return Value:

    The function returns TRUE if successful, or FALSE if an error occurred.

Implementation note:

    There was no need identified for the REG_MULTI_SZ case, so support for this
    case  was  omitted  since  it was more difficult to derive the data length.
    There  is  no  reason  in  principle why this case cannot be added if it is
    really needed.

--*/
{
    DWORD   cbData;
    LONG    result;
    BYTE *  data_buf;

    assert( (TypeFlag == REG_BINARY) ||
            (TypeFlag == REG_DWORD) ||
            (TypeFlag == REG_EXPAND_SZ) ||
            (TypeFlag == REG_SZ));


    switch (TypeFlag) {
        case REG_BINARY:
            cbData = (DWORD) (((LPWSABUF) Data)->len);
            data_buf = (BYTE *) (((LPWSABUF) Data)->buf);
            break;

        case REG_DWORD:
            cbData = sizeof(DWORD);
            data_buf = (BYTE *) Data;
            break;

        case REG_EXPAND_SZ:
            cbData = (DWORD) (lstrlen((char *) Data)+1);
            data_buf = (BYTE *) Data;
            break;

        case REG_SZ:
            cbData = (DWORD) (lstrlen((char *) Data)+1);
            data_buf = (BYTE *) Data;
            break;

        default:
            DEBUGF(
                DBG_ERR,
                ("Unsupported type flag specified (%lu)",
                TypeFlag));
            return FALSE;

    }  // switch (TypeFlag)

    result = RegSetValueEx(
                EntryKey,             // hkey
                (LPCTSTR) EntryName,  // lpszValueName
                0,                    // dwReserved
                TypeFlag,             // fdwType
                data_buf,             // lpbData
                cbData                // cbData
                );
    if (result == ERROR_SUCCESS) {
        return TRUE;
    }
    else {
        DEBUGF(
            DBG_ERR,
            ("Setting value %s, err:%ld\n",
            EntryName, result));
        return FALSE;
    } // if not success

}  // WriteRegistryEntry



BOOL
ReadRegistryEntry(
    IN      HKEY    EntryKey,
    IN      LPTSTR  EntryName,
    OUT     PVOID   Data,
    IN      DWORD   MaxBytes,
    IN      DWORD   TypeFlag
    )
/*++

Routine Description:

    This procedure reads a single named value from an opened registry key.  The
    value  may  be any type whose length can be determined from its type (e.g.,
    scalar  types,  zero-terminated  strings).  The function checks the type of
    the newly read value to make sure it matches the expected type.

Arguments:

    EntryKey  - Supplies  the  open entry key from which the new named value is
                to be read.

    EntryName - Supplies the name of the value to be read.

    Data      - Supplies  a  reference  to the location where the entry data is
                placed.   Returns  the registry entry value.  In the case where
                the  TypeFlag  is  REG_BINARY,  this is a reference to a WSABUF
                describing the target data buffer.  The "len" field returns the
                length read (or required) from the registry.

    MaxData   - Supplies the size in bytes of the Data buffer supplied.

    TypeFlag  - Supplies  an  identifier  for  the type of the data to be read.
                Supported   types  are  REG_BINARY,  REG_DWORD,  REG_EXPAND_SZ,
                REG_SZ.    Types   not   supported   are  REG_DWORD_BIG_ENDIAN,
                REG_DWORD_LITTLE_ENDIAN,   REG_LINK,   REG_MULTI_SZ,  REG_NONE,
                REG_RESOURCE_LIST.   Note  that  depending on the architecture,
                one   of   the   "big_endian"   or   "little_endian"  forms  of
                REG_DWORD_x_ENDIAN  is implicitly allowed, since it is equal to
                REG_DWORD.

Return Value:

    The  function  returns  TRUE  if successful, or FALSE if an error occurred.
    Errors include unsupported types, non-matching types, and oversize data.

Implementation note:

    There was no need identified for the REG_MULTI_SZ case, so support for this
    case  was  omitted  since  it was more difficult to derive the data length.
    There  is  no  reason  in  principle why this case cannot be added if it is
    really needed.

    The  validity  checks  in this routine have been written as a linear series
    instead  of  in the "conditional-tunnelling" nested-if form.  The series of
    tests  is  long  enough that the nested-if form is far too complex to read.
    This  procedure  should  not  be sensitive to execution speed, so the extra
    tests and branches in the linear series form should not be a problem.
--*/
{
    DWORD  count_expected;
    LONG   result;
    DWORD  type_read;
    DWORD  entry_size;
    BOOL   need_exact_length;
    BYTE * data_buf;

    assert(
        (TypeFlag == REG_BINARY) ||
        (TypeFlag == REG_DWORD) ||
        (TypeFlag == REG_EXPAND_SZ) ||
        (TypeFlag == REG_SZ));

    switch (TypeFlag) {
        case REG_BINARY:
            count_expected = MaxBytes;
            // Special case: REG_BINARY length compared against maximum
            need_exact_length = FALSE;
            data_buf = (BYTE *) (((LPWSABUF) Data)->buf);
            break;

        case REG_DWORD:
            count_expected = sizeof(DWORD);
            need_exact_length = TRUE;
            data_buf = (BYTE *) Data;
            break;

        case REG_EXPAND_SZ:
            count_expected = MaxBytes;
            // Special case: strings length compared against maximum
            need_exact_length = FALSE;
            data_buf = (BYTE *) Data;
            break;

        case REG_SZ:
            count_expected = MaxBytes;
            // Special case: strings length compared against maximum
            need_exact_length = FALSE;
            data_buf = (BYTE *) Data;
            break;

        default:
            DEBUGF(
                DBG_ERR,
                ("Unsupported type flag specified (%lu)",
                TypeFlag));
            return FALSE;

    }  // switch (TypeFlag)


    entry_size = MaxBytes;
    result = RegQueryValueEx(
        EntryKey,            // hkey
        (LPTSTR) EntryName,  // lpszValueName
        0,                   // dwReserved
        & type_read,         // lpdwType
        data_buf,            // lpbData
        & entry_size         // lpcbData
        );
    if (result != ERROR_SUCCESS) {
        DEBUGF(
            DBG_WARN,
            ("Reading value %s, err: %ld\n",
            EntryName, result));
        if (result == ERROR_MORE_DATA) {
            DEBUGF(
                DBG_WARN,
                ("Data buffer too small\n"));
        } // if ERROR_MORE_DATA
        return FALSE;
    } // if result != ERROR_SUCCESS


    // Special case for REG_BINARY
    if (TypeFlag == REG_BINARY) {
        (((LPWSABUF) Data)->len) = (u_long) entry_size;
    }


    // check type
    if (type_read != TypeFlag) {
        DEBUGF(
            DBG_ERR,
            ("Type read (%lu) different from expected (%lu)\n",
            type_read,
            TypeFlag));
        return FALSE;
    } // if type_read != TypeFlag


    // Check length
    if (need_exact_length) {
        if (count_expected != entry_size) {
            DEBUGF(
                DBG_ERR,
                ("Length read (%lu) different from expected (%lu)\n",
                entry_size,
                count_expected));
            return FALSE;
         } // if size mismatch
    } // if need_exact_length

    return TRUE;

}  // ReadRegistryEntry




LONG
RegDeleteKeyRecursive(
    IN      HKEY            hkey,
    IN      LPCTSTR         lpszSubKey
    )
/*++

Routine Description:

    The RegDeleteKeyRecursive function deletes the specified key and all of its
    subkeys, recursively.

Arguments:

    hkey       - Supplies  a  currently  open  key  or  any  of  the  following
                 predefined reserved handle values:

                 HKEY_CLASSES_ROOT
                 HKEY_CURRENT_USER
                 HKEY_LOCAL_MACHINE
                 HKEY_USERS

                 The key specified by the lpszSubKey parameter must be a subkey
                 of the key identified by hkey.

    lpszSubKey - Supplies  a  reference  to a null-terminated string specifying
                 the name of the key to delete.  This parameter cannot be NULL.
                 The specified key may have subkeys.

Return Value:

    If  the  function  succeeds,  the  return  value  is ERROR_SUCCESS.  If the
    function fails, the return value is an operating system error value.

Implementation Notes:

    Open targetkey
    while find subkey
        RegDeleteKeyRecursive(... subkey)
    end while
    close targetkey
    delete targetkey

--*/
{
    LONG    result;
    HKEY    targetkey;
    LONG    return_value;

    DEBUGF(
        DBG_TRACE,
        ("RegDeleteKeyRecursive (%lu), '%s'\n",
        (ULONG_PTR) hkey,
        lpszSubKey));

    result = RegOpenKeyEx(
                hkey,            // hkey
                lpszSubKey,      // lpszSubKey
                0,               // dwReserved
                KEY_READ|KEY_WRITE,// samDesired
                & targetkey      // phkResult
                );

    if (result != ERROR_SUCCESS) {
        DEBUGF(
            DBG_WARN,
            ("Opening key '%s' to be deleted, err: %ld\n",
            lpszSubKey, result));
        return result;
    }

    //
    //  delete subkeys of target key
    //

    {
        BOOL      deleting_subkeys;
        LPTSTR    subkey_name;
        DWORD     subkey_name_len;
        FILETIME  dont_care;

        return_value = ERROR_SUCCESS;
        deleting_subkeys = TRUE;
        subkey_name = (LPTSTR) new char[MAX_PATH];
        if ( subkey_name == NULL ) {
            return_value = ERROR_OUTOFMEMORY;
            deleting_subkeys = FALSE;
        }
        while (deleting_subkeys) {
            subkey_name_len = MAX_PATH;
            // Since  we  delete  a  subkey  each  time  through this loop, the
            // remaining  subkeys  effectively  get  renumbered.  Therefore the
            // subkey   index  we  "enumerate"  each  time  is  0  (instead  of
            // incrementing) to retrieve any remaining subkey.
            result = RegEnumKeyEx(
                        targetkey,         // hkey
                        0,                 // iSubkey
                        subkey_name,       // lpszName
                        & subkey_name_len, // lpcchName
                        0,                 // lpdwReserved
                        NULL,              // lpszClass
                        NULL,              // lpcchClass
                        & dont_care        // lpftLastWrite
                        );
            switch (result) {
                case ERROR_SUCCESS:
                    result = RegDeleteKeyRecursive(
                        targetkey,   // hkey
                        subkey_name  // lpszSubKey
                        );
                    if (result != ERROR_SUCCESS) {
                        deleting_subkeys = FALSE;
                        return_value = result;
                    }
                    break;

                case ERROR_NO_MORE_ITEMS:
                    deleting_subkeys = FALSE;
                    break;

                default:
                    DEBUGF(
                        DBG_ERR,
                        ("Unable to enumerate subkeys\n"));
                    deleting_subkeys = FALSE;
                    return_value = result;
                    break;

            }  // switch (result)
        }  // while (deleting_subkeys)

        delete subkey_name;
    }

    //
    //  finally delete target key itself
    //

    result = RegCloseKey( targetkey );

    if ( result != ERROR_SUCCESS ) {
        DEBUGF(
            DBG_ERR,
            ("Closing subkey %s, err: %ld\n",
            lpszSubKey, result));
        return_value = result;
    }

    result = RegDeleteKey(
                hkey,       // hkey
                lpszSubKey  // lpszSubKey
                );
    if ( result != ERROR_SUCCESS ) {
        DEBUGF(
            DBG_WARN,
            ("Deleting subkey %s, err: %ld\n",
            lpszSubKey, result));
        return_value = result;
    }

    return return_value;

}  // RegDeleteKeyRecursive



LONG
RegDeleteSubkeys(
    IN      HKEY            hkey
    )
/*++

Routine Description:

    Deletes all the first level subkeys of the specified key

Arguments:

    hkey -  Supplies a currently open key or any of the following
            predefined reserved handle values:
                HKEY_CLASSES_ROOT
                HKEY_CURRENT_USER
                HKEY_LOCAL_MACHINE
                HKEY_USERS

Return Value:

    ERROR_SUCCESS if successful.
    Win32 error on failure.

--*/
{
    BOOL        deleting_subkeys = TRUE;
    LONG        result;
    LONG        return_value;
    LPTSTR      subkey_name;
    DWORD       subkey_name_len;
    FILETIME    dont_care;

    DEBUGF( DBG_TRACE, (
        "RegDeleteSubkeys (%lu)\n",
        (ULONG_PTR)hkey));

    subkey_name = (LPTSTR) new char[MAX_PATH];
    if (subkey_name == NULL) {
        return WSA_NOT_ENOUGH_MEMORY;
    }

    return_value = ERROR_SUCCESS;
    while (deleting_subkeys) {
        subkey_name_len = MAX_PATH;
        // Since  we  delete  a  subkey  each  time  through this loop, the
        // remaining  subkeys  effectively  get  renumbered.  Therefore the
        // subkey   index  we  "enumerate"  each  time  is  0  (instead  of
        // incrementing) to retrieve any remaining subkey.
        result = RegEnumKeyEx(
                    hkey,               // hkey
                    0,                 // iSubkey
                    subkey_name,       // lpszName
                    & subkey_name_len, // lpcchName
                    0,                 // lpdwReserved
                    NULL,              // lpszClass
                    NULL,              // lpcchClass
                    & dont_care        // lpftLastWrite
                    );
        switch (result) {
            case ERROR_SUCCESS:
                result = RegDeleteKey(
                    hkey,        // hkey
                    subkey_name  // lpszSubKey
                    );
                if (result != ERROR_SUCCESS) {
                    deleting_subkeys = FALSE;
                    return_value = result;
                }
                break;

            case ERROR_NO_MORE_ITEMS:
                deleting_subkeys = FALSE;
                break;

            default:
                DEBUGF(
                    DBG_ERR,
                    ("Enumerating subkeys %ld\n", result));
                deleting_subkeys = FALSE;
                return_value = result;
                break;

        }  // switch (result)
    }  // while (deleting_subkeys)

    delete subkey_name;

    return return_value;

}  // RegDeleteSubkeys



HKEY
OpenWinSockRegistryRoot(
    VOID
    )
/*++

Routine Description:

    This  procedure opens the root of the WinSock2 portion of the registry.  It
    takes  care  of  creating  and initializing the root if necessary.  It also
    takes  care  of  comparing versions of the WinSock2 portion of the registry
    and updating the registry version if required.

    It   is   the  caller's  responsibility  to  call  CloseWinSockRegistryRoot
    eventually with the returned key.

Arguments:

    None

Return Value:

    The  function  returns the opened registry key if successful.  If it is not
    successful, it returns NULL.

Implementation Notes:

    The first version of this function has no previous versions of the registry
    to  be  compatible  with,  so it does not have to take care of updating any
    out-of-date  registry  information.   If  and  when  the  WinSock  spec  or
    implementation  is  updated  in a way that changes the registry information
    this procedure may have to be updated to update the registry.
--*/
{
    HKEY    root_key;
    LONG    lresult;
    DWORD   create_disp;

    DEBUGF(
        DBG_TRACE,
        ("OpenWinSockRegistryRoot\n"));

    //
    // We must first try to open the key before trying to create it.
    // RegCreateKeyEx() will fail with ERROR_ACCESS_DENIED if the current
    // user has insufficient privilege to create the target registry key,
    // even if that key already exists.
    //

    lresult = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,             // hkey
        WINSOCK_REGISTRY_ROOT,          // lpszSubKey
        0,                              // dwReserved
        MAXIMUM_ALLOWED,                // samDesired
        & root_key                      // phkResult
        );

    if( lresult == ERROR_SUCCESS ) {
        create_disp = REG_OPENED_EXISTING_KEY;
    } else if (lresult != ERROR_FILE_NOT_FOUND ||
                (lresult = RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,         // hkey
                    WINSOCK_REGISTRY_ROOT,      // lpszSubKey
                    0,                          // dwReserved
                    NULL,                       // lpszClass
                    REG_OPTION_NON_VOLATILE,    // fdwOptions
                    KEY_READ|KEY_WRITE,         // samDesired
                    NULL,                       // lpSecurityAttributes
                    & root_key,                 // phkResult
                    & create_disp               // lpdwDisposition
                    ))!=ERROR_SUCCESS) {
        DEBUGF(
            DBG_ERR,
            ("Creating/opening registry root, err: %ld\n",
            lresult));
        return NULL;
    }

    TRY_START(guard_root_open) {

        BOOL   bresult;
        TCHAR  reg_version[] = WINSOCK_REGISTRY_VERSION_VALUE;
        // Initialization forces size to be the size desired.

        switch (create_disp) {
            case REG_CREATED_NEW_KEY:
                bresult = WriteRegistryEntry(
                    root_key,                               // EntryKey
                    WINSOCK_REGISTRY_VERSION_NAME,          // EntryName
                    (PVOID)WINSOCK_REGISTRY_VERSION_VALUE,  // Data
                    REG_SZ                                  // TypeFlag
                    );
                if (! bresult) {
                    DEBUGF(
                        DBG_ERR,
                        ("Writing version value to registry\n"));
                    TRY_THROW(guard_root_open);
                }
                break;

            case REG_OPENED_EXISTING_KEY:
                bresult = ReadRegistryEntry(
                    root_key,                               // EntryKey
                    WINSOCK_REGISTRY_VERSION_NAME,          // EntryName
                    (PVOID) reg_version,                    // Data
                    sizeof(reg_version),                    // MaxBytes
                    REG_SZ                                  // TypeFlag
                    );
                if (! bresult) {
                    DEBUGF(
                        DBG_ERR,
                        ("Reading version value from registry\n"));
                    TRY_THROW(guard_root_open);
                }
                if (lstrcmp(reg_version, WINSOCK_REGISTRY_VERSION_VALUE) != 0) {
                    DEBUGF(
                        DBG_ERR,
                        ("Expected registry version '%s', got '%s'\n",
                        WINSOCK_REGISTRY_VERSION_VALUE,
                        reg_version));
                    TRY_THROW(guard_root_open);
                }
                break;

            default:
                break;

        }  // switch (create_disp)

    } TRY_CATCH(guard_root_open) {
        CloseWinSockRegistryRoot(root_key);
        root_key = NULL;
    } TRY_END(guard_root_open);

    return root_key;

}  // OpenWinSockRegistryRoot



VOID
CloseWinSockRegistryRoot(
    IN      HKEY            RootKey
    )
/*++

Routine Description:

    This  procedure  closes  the open registry key representing the root of the
    WinSock  portion  of the registry.  The function checks for and handles any
    errors that might occur.

Arguments:

    RootKey - Supplies  the  open  registry  key  representing  the root of the
              WinSock portion of the registry.

Return Value:

    None

--*/
{
    LONG lresult;

    DEBUGF( DBG_TRACE,
        ("Closing registry root\n"));

    lresult = RegCloseKey( RootKey );

    if ( lresult != ERROR_SUCCESS) {
        DEBUGF(
            DBG_ERR,
            ("Closing registry root, err: %ld\n",
            lresult));
    }

}  // CloseWinSockRegistryRoot



INT
MapUnicodeProtocolInfoToAnsi(
    IN      LPWSAPROTOCOL_INFOW UnicodeProtocolInfo,
    OUT     LPWSAPROTOCOL_INFOA AnsiProtocolInfo
    )
/*++

Routine Description:

    This procedure maps a UNICODE WSAPROTOCOL_INFOW structure to the
    corresponding ANSI WSAPROTOCOL_INFOA structure. All scalar fields
    are copied over "as is" and any embedded strings are mapped.

Arguments:

    UnicodeProtocolInfo - Points to the source WSAPROTOCOL_INFOW structure.

    AnsiProtocolInfo - Points to the destination WSAPROTOCOL_INFOA structure.

Return Value:

    INT - ERROR_SUCCESS if successful, a Win32 status code otherwise.

--*/
{
    INT result;

    //
    // Sanity check.
    //

    assert( UnicodeProtocolInfo != NULL );
    assert( AnsiProtocolInfo != NULL );


    __try {
        //
        // Copy over the scalar values.
        //
        // Just to make things a bit easier, this code depends on the fact
        // that the szProtocol[] character array is the last field of the
        // WSAPROTOCOL_INFO structure.
        //

        CopyMemory(
            AnsiProtocolInfo,
            UnicodeProtocolInfo,
            sizeof(*UnicodeProtocolInfo) - sizeof(UnicodeProtocolInfo->szProtocol)
            );

        //
        // And now map the string from UNICODE to ANSI.
        //

        result = WideCharToMultiByte(
                     CP_ACP,                                    // CodePage (ANSI)
                     0,                                         // dwFlags
                     UnicodeProtocolInfo->szProtocol,           // lpWideCharStr
                     -1,                                        // cchWideChar
                     AnsiProtocolInfo->szProtocol,              // lpMultiByteStr
                     sizeof(AnsiProtocolInfo->szProtocol),      // cchMultiByte
                     NULL,                                      // lpDefaultChar
                     NULL                                       // lpUsedDefaultChar
                     );

        if( result == 0 ) {

            // WideCharToMultiByte() failed.

            return WSASYSCALLFAILURE;
        }

        //
        // Success!
        //

        return ERROR_SUCCESS;
    }
    __except (WS2_EXCEPTION_FILTER()) {
        return WSAEFAULT;
    }

}   // MapUnicodeProtocolInfoToAnsi




INT
MapAnsiProtocolInfoToUnicode(
    IN      LPWSAPROTOCOL_INFOA AnsiProtocolInfo,
    OUT     LPWSAPROTOCOL_INFOW UnicodeProtocolInfo
    )
/*++

Routine Description:

    This procedure maps an ANSI WSAPROTOCOL_INFOA structure to the
    corresponding UNICODE WSAPROTOCOL_INFOW structure. All scalar fields
    are copied over "as is" and any embedded strings are mapped.

Arguments:

    AnsiProtocolInfo - Points to the source WSAPROTOCOL_INFOA structure.

    UnicodeProtocolInfo - Points to the destination WSAPROTOCOL_INFOW
        structure.

Return Value:

    INT - ERROR_SUCCESS if successful, a Win32 status code otherwise.

--*/
{
    INT result;

    //
    // Sanity check.
    //

    assert( AnsiProtocolInfo != NULL );
    assert( UnicodeProtocolInfo != NULL );

    __try {
        //
        // Copy over the scalar values.
        //
        // Just to make things a bit easier, this code depends on the fact
        // that the szProtocol[] character array is the last field of the
        // WSAPROTOCOL_INFO structure.
        //

        CopyMemory(
            UnicodeProtocolInfo,
            AnsiProtocolInfo,
            sizeof(*AnsiProtocolInfo) - sizeof(AnsiProtocolInfo->szProtocol)
            );

        //
        // And now map the string from ANSI to UNICODE.
        //

        result = MultiByteToWideChar(
                     CP_ACP,                                    // CodePage (ANSI)
                     0,                                         // dwFlags
                     AnsiProtocolInfo->szProtocol,              // lpMultiByteStr
                     -1,                                        // cchWideChar
                     UnicodeProtocolInfo->szProtocol,           // lpWideCharStr
                     sizeof(UnicodeProtocolInfo->szProtocol)/
                        sizeof(UnicodeProtocolInfo->szProtocol[0])// cchMultiByte
                     );

        if( result == 0 ) {

            //
            // MultiByteToWideChar() failed.
            //

            return WSASYSCALLFAILURE;

        }

        //
        // Success!
        //

        return ERROR_SUCCESS;

    }
    __except (WS2_EXCEPTION_FILTER()) {
        return WSAEFAULT;
    }
}   // MapAnsiProtocolInfoToUnicode



VOID
ValidateCurrentCatalogName(
    IN      HKEY            RootKey,
    IN      LPSTR           ValueName,
    IN      LPSTR           ExpectedName
    )
/*++

Routine Description:

    This routine checks for consistency between the protocol or namespace
    catalog as stored in the registry and the catalog format expected by
    the current version of this DLL. There's no great magic here; this
    code assumes that the person updating the registry format will change
    the catalog to use a different catalog name (such as Protocol_Catalog9,
    Protocol_Catalog10, etc.). This assumption means we can validate the
    registry format by validating the *name* of the registry key used
    for this catalog.

    The following steps are performed:

        1.  Try to read 'ValueName' from the registry.

        2.  If it doesn't exist, cool. Just create the new value. This
            typically means we're updating a pre-release system that
            did not support this mechanism.

        3.  If it does, and its value matches 'ExpectedName', fine.

        4.  If it does, and its value doesn't match, then the catalog
            format has been updated, so blow away the old catalog, then
            write the updated value into the registry.

    Since this routine is called at setup/upgrade time, it should only
    fail if something truly horrible happens. In other words, it should
    be very 'fault tolerant'.

Arguments:

    RootKey - An open key to the WinSock configuration registry tree.

    ValueName - The name of the registry value that contains the name
        of the current catalog. This will typically be a value such as
        "Current_Protocol_Catalog" or "Current_NameSpace_Catalog".

    ExpectedName - The expected value stored in the 'ValueName' registry
        value. This will typically be a value such as "Protocol_Catalog9"
        or "NameSpace_Catalog5".

Return Value:

    None.

--*/
{
    BOOL    result;
    LONG    err;
    CHAR    value[MAX_CATALOG_NAME_LENGTH];

    //
    // Try to read the name from the registry.
    //

    result = ReadRegistryEntry(
                 RootKey,
                 ValueName,
                 (PVOID)value,
                 sizeof(value),
                 REG_SZ
                 );

    if( result ) {

        if( lstrcmp( value, ExpectedName ) == 0 ) {

            //
            // No update in format. We're done.
            //

            return;
        }

        //
        // The values don't match, indicating an update in registry format.
        // So, blow away the old key.
        //

        err = RegDeleteKeyRecursive(
                  RootKey,
                  value
                  );

        if( err != NO_ERROR ) {

            // Unfortunate, but nonfatal.

            DEBUGF(
                DBG_ERR,
                ("Deleting key %s, continuing\n",
                value
                ));
        }
    }

    //
    // At this point, we either couldn't read the value from the registry
    // (probably indicating that we're upgrading a pre-release system
    // that was setup before we supported this particular feature) OR
    // the values don't match and we've just blown away the old catalog.
    // In either case we need to update the value in the registry before
    // returning.
    //

    result = WriteRegistryEntry(
                 RootKey,
                 ValueName,
                 ExpectedName,
                 REG_SZ
                 );

    if( !result ) {

        // Also unfortunate, but nonfatal.

        DEBUGF(
            DBG_ERR,
            ("Writing %s with value %s\n",
            ValueName,
            ExpectedName
            ));
    }

}   // ValidateCurrentCatalogName



INT
AcquireExclusiveCatalogAccess(
    IN      HKEY    CatalogKey,
    IN      DWORD   ExpectedSerialNum,
    OUT     PHKEY   AccessKey
    )
/*++

Routine Description:

    This procedure acquires registry lock using volatile registry key.
    This ensures that only one application at a time can modify
    registry catalog.

Arguments:

    CatalogKey - Supplies catalog key to lock

    ExpectedSerialNum - Supplies catalog serial number that caller
                        expects to see in the registry. It validates
                        that catalog has not changed since it was last read
                        by the client

    AccessKey - Returns handle to the registry key that is used
                for synchronization (to be passed back in
                ReleaseExclusiveCatalogAccess)

Return Value:

    If  the  function  is  successful, it returns ERROR_SUCCESS.
    Otherwise, it returns an appropriate WinSock error code:

        WSATRY_AGAIN - catalog serial number in the registry does not
                       match the one supplied
        WSAEACCESS   - caller does not have write access to the catalog portion
                       of the registry
        WSASYSCALLFAILURE - one of the registry operation failed

--*/
{
    LONG        lresult;
    BOOL        bresult;
    DWORD       serial_num, disposition;
    HKEY        access_key;
    TCHAR       serial_num_buffer[32];


    // Initialize return value
    *AccessKey = NULL;

    // Read current serial number
    bresult = ReadRegistryEntry (
                    CatalogKey,             // EntryKey
                    SERIAL_NUMBER_NAME,     // EntryName
                    (PVOID) &serial_num,    // Data
                    sizeof (DWORD),         // MaxBytes
                    REG_DWORD               // TypeFlag
                    ); 
    if (!bresult) {
        DEBUGF (DBG_ERR, ("Reading catalog serial number value.\n"));
        return WSASYSCALLFAILURE;
    }

        // Check if it what caller was expecting
    if (ExpectedSerialNum!=serial_num) {
        DEBUGF (DBG_ERR,
            ("Catalog serial number changed since we read it, %ld->%ld.\n",
            ExpectedSerialNum, serial_num));
        return WSATRY_AGAIN;
    }

    // Create synchronization key
    _stprintf (serial_num_buffer, TEXT("%08.8lX"), serial_num);

    lresult = RegCreateKeyEx (
                    CatalogKey,              // hKey
                    serial_num_buffer,      // lpSubKey
                    0,                      // dwReserved
                    NULL,                   // lpszClass
                    REG_OPTION_VOLATILE,    // fdwOptions
                    KEY_READ|KEY_WRITE,     // samDesired
                    NULL,                   // lpSecurityAttributes
                    &access_key,            // phkResult
                    &disposition            // lpdwDisposition
                    );
    if (lresult != ERROR_SUCCESS) {
        DEBUGF (DBG_ERR, ("Creating access key '%s', err: %ld.\n",
            serial_num_buffer));
        if (lresult == ERROR_ACCESS_DENIED)
            return WSAEACCES;
        else
            return WSASYSCALLFAILURE;
    }

    if (disposition==REG_CREATED_NEW_KEY) {
        // We created the key, so caller can have the registry to itself
        *AccessKey = access_key;
        return ERROR_SUCCESS;
    }
    else {
        // The key was there already, someone must be writing to the
        // registry and thus current callers representation of it
        // becomes invalid.
        RegCloseKey (access_key);
        DEBUGF (DBG_WARN, 
            ("Trying to lock accessed catalog, serial num: %ld.\n",
            serial_num));
        return WSATRY_AGAIN;
    }

} // AcquireExclusiveRegistryAccess



VOID
ReleaseExclusiveCatalogAccess(
    IN      HKEY            CatalogKey,
    IN      DWORD           CurrentSerialNum,
    IN      HKEY            access_key
    )
/*++

Routine Description:

    This procedure releases registry lock acquired using
    AcuireExclusiveCatalogAccess.

Arguments:

    CatalogKey       - Supplies catalog key to lock

    CurrentSerialNum - Supplies catalog serial number which was in
                       effect when catalog was locked.

    AccessKey        - Supplise handle to the registry key that was used
                       for synchronization.

Return Value:

    None

--*/
{
    LONG        lresult;
    BOOL        bresult;
    TCHAR       serial_num_buffer[32];

    // Save and increment catalog serial number
    _stprintf (serial_num_buffer, TEXT("%08.8lX"), CurrentSerialNum);
        
    CurrentSerialNum += 1;

    // Store new catalog serial number
    bresult = WriteRegistryEntry (
                    CatalogKey,                                 // EntryKey
                    SERIAL_NUMBER_NAME,                 // EntryName
                    (PVOID)&CurrentSerialNum,   // Data
                    REG_DWORD                                   // TypeFlag
                    );
    if (!bresult) {
        DEBUGF (DBG_ERR,
            ("Writing serial number value %ld.\n", CurrentSerialNum));
        assert (FALSE);
        //
        // Nothing we can do, writer has done its job anyway
        // To recover, the user will have to reboot the machine
        // and the volatile key will not be there anymore.
        //
    }

    lresult = RegDeleteKey (CatalogKey, serial_num_buffer);
    if (lresult != ERROR_SUCCESS) {
        DEBUGF (DBG_ERR,
            ("Deleting serial access key '%s', err: %ld.\n",
                        serial_num_buffer, lresult));
        //
        // Unfortunate but not fatal (just leaves it in the regstry until
        // next reboot);
        //
    }

    lresult = RegCloseKey (access_key);
    if (lresult != ERROR_SUCCESS) {
        DEBUGF (DBG_ERR,
            ("Closing serial access key '%s', err: %ld.\n", 
                        serial_num_buffer, lresult));
        //
        // Unfortunate but not fatal (does not deallocate memory
        // and possibly leaves it in the regstry until next reboot);
        //
    }

} //ReleaseExclusiveRegistryAccess



#define MAX_WRITER_WAIT_TIME    (3*60*1000)
INT
SynchronizeSharedCatalogAccess(
    IN      HKEY            CatalogKey,
    IN      HANDLE          ChangeEvent,
    OUT     LPDWORD         CurrentSerialNum
    )
/*++

Routine Description:

    This procedure synchronizes reades access to the registry
    catalog against possible writers.  It waits for any writers
    that are accessing the catalog at the time of the call
    and establishes event notification mechanism for any registry
    catalog modification afterwards

Arguments:
        CatalogKey      -       Supplies catalog key to synchronize with

    ChangeEvent -   Supplies event to signal when registry catalog 
                    is changed.

    CurrentSerialNumber - Returns current catalog serial number

Return Value:
    If  the  function  is  successful, it returns ERROR_SUCCESS.  Otherwise, it
    returns an appropriate WinSock error code:

    
--*/
{
    LONG    lresult;
    INT     return_value;
    BOOL    bresult;
    DWORD   serial_num;
    TCHAR   serial_num_buffer[32];
    HKEY    access_key;

    do {
        //
        // Register for notification of key creation/deletion
        // (The writer creates and keeps access key while it
        // modifies the catalog)
        //

        lresult = RegNotifyChangeKeyValue (
                    CatalogKey,                 // hKey
                    FALSE,                      // bWatchSubtree
                    REG_NOTIFY_CHANGE_NAME,     // dwNotifyFilter,
                    ChangeEvent,                // hEvent
                    TRUE                        // fAsynchronous
                    );
        if (lresult != ERROR_SUCCESS) {
            DEBUGF (DBG_ERR,
                ("Registering for registry key change notification, err: %ld.\n",
                lresult));
            return_value = WSASYSCALLFAILURE;
            break;
        }

        // Read current catalog serial number, which is also
        // the name of the writer access key
        bresult = ReadRegistryEntry (
                        CatalogKey,             // EntryKey
                        SERIAL_NUMBER_NAME,     // EntryName
                        (PVOID) &serial_num,    // Data
                        sizeof (DWORD),         // MaxBytes
                        REG_DWORD               // TypeFlag
                        ); 
        if (!bresult) {
            DEBUGF (DBG_ERR, ("Reading '%s' value.\n", SERIAL_NUMBER_NAME));
            return_value = WSASYSCALLFAILURE;
            break;
        }

        // Try to open writer access key.

        _stprintf (serial_num_buffer, TEXT("%08.8lX"), serial_num);

        lresult = RegOpenKeyEx(
                        CatalogKey,             // hkey
                        serial_num_buffer,      // lpszSubKey
                        0,                      // dwReserved
                        MAXIMUM_ALLOWED,        // samDesired
                        & access_key            // phkResult
                        );
        if ((lresult == ERROR_FILE_NOT_FOUND)
                || (lresult == ERROR_KEY_DELETED)) {
            // Key was not found or is being deleted,
            // we can access the catalog
            return_value = ERROR_SUCCESS;
            *CurrentSerialNum = serial_num;
            break;
        }
        else if (lresult != ERROR_SUCCESS) {
            // Some other failure
            DEBUGF (DBG_ERR,
                ("Opening access key '%s', err: %ld.\n", 
                serial_num_buffer, lresult));
            return_value = WSASYSCALLFAILURE;
            break;
        }

        // Success, writer is active, close the key,
        // wait till it gets removed, and start over again

        lresult = RegCloseKey (access_key);
        if (lresult!=ERROR_SUCCESS) {
            DEBUGF (DBG_ERR,
                ("Closing access key '%ls', err: %ld.\n", 
                serial_num_buffer, lresult));
            // Non-fatal.
        }
        // Set the error code in case we fail the wait.
        return_value = WSANO_RECOVERY;
        // Limit the wait time in case writer crashed or
        // failed to remove the key.
    }
    while ( WaitForSingleObject( ChangeEvent, MAX_WRITER_WAIT_TIME ) == WAIT_OBJECT_0 );

    return return_value;
}



BOOL
HasCatalogChanged(
    IN      HANDLE  ChangeEvent
    )
/*++

Routine Description:

    This procedure checks if registry catalog has changes since the
    caller has last synchronized with it

Arguments:

    ChangeEvent - Event used for catalog syncrhonization.

Return Value:

    TRUE - catalog has changed
    FALSE - otherwise
    
--*/
{
    DWORD   wait_result;

    // Simply check the event state

    wait_result = WaitForSingleObject( ChangeEvent, 0 );
    if (wait_result==WAIT_OBJECT_0)
            return TRUE;
    if (wait_result==WAIT_TIMEOUT)
            return FALSE;

    DEBUGF (DBG_ERR, ("Waiting for registry change event, rc=%ld, err=%ld.\n",
                            wait_result, GetLastError ()));
    assert (FALSE);
    return FALSE;
}



extern "C" {

VOID
WEP( VOID )
{
    // empty
}   // WEP

}   // extern "C"


void * __cdecl operator new(size_t sz)
{
    return HeapAlloc (gHeap, 0, sz);
}

void __cdecl operator delete(void *p)
{
    HeapFree (gHeap, 0, p);
}

void * __cdecl renew(void *p, size_t sz)
{
    return HeapReAlloc (gHeap, 0, p, sz);
}

//
//  End wsautil.cpp
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\accept.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    accept.c

Abstract:

    This module contains the handling code for IOCTL_AFD_ACCEPT.
    as well as IOCTL_AFD_SUPER_ACCEPT

Author:

    David Treadwell (davidtr)    21-Feb-1992

Revision History:
    Vadim Eydelman (vadime) 1999 - No spinlock performance path in super accept,
                                general code restructuring.

--*/

#include "afdp.h"

VOID
AfdDoListenBacklogReplenish (
    IN PVOID Context
    );

NTSTATUS
AfdReplenishListenBacklog (
    IN PAFD_ENDPOINT Endpoint
    );

VOID
AfdReportConnectionAllocationFailure (
    PAFD_ENDPOINT   Endpoint,
    NTSTATUS        Status
    );


NTSTATUS
AfdContinueSuperAccept (
    IN PIRP         Irp,
    PAFD_CONNECTION Connection
    );

NTSTATUS
AfdRestartSuperAcceptGetAddress (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdRestartSuperAcceptReceive (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdRestartDelayedAccept (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
AfdSuperAcceptApcKernelRoutine (
    IN struct _KAPC         *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID            *NormalContext,
    IN OUT PVOID            *SystemArgument1,
    IN OUT PVOID            *SystemArgument2
    );

VOID
AfdSuperAcceptApcRundownRoutine (
    IN struct _KAPC *Apc
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGEAFD, AfdAccept )
#pragma alloc_text( PAGEAFD, AfdSuperAccept )
#pragma alloc_text( PAGEAFD, AfdDeferAccept )
#pragma alloc_text( PAGEAFD, AfdDoListenBacklogReplenish )
#pragma alloc_text( PAGEAFD, AfdSetupAcceptEndpoint )
#pragma alloc_text( PAGE, AfdReplenishListenBacklog )
#pragma alloc_text( PAGEAFD, AfdReportConnectionAllocationFailure )
#pragma alloc_text( PAGEAFD, AfdInitiateListenBacklogReplenish )
#pragma alloc_text( PAGEAFD, AfdRestartSuperAccept )
#pragma alloc_text( PAGEAFD, AfdRestartSuperAcceptListen )
#pragma alloc_text( PAGEAFD, AfdContinueSuperAccept )
#pragma alloc_text( PAGEAFD, AfdServiceSuperAccept )
#pragma alloc_text( PAGEAFD, AfdRestartSuperAcceptGetAddress )
#pragma alloc_text( PAGEAFD, AfdRestartSuperAcceptReceive )
#pragma alloc_text( PAGE, AfdSuperAcceptApcKernelRoutine )
#pragma alloc_text( PAGE, AfdSuperAcceptApcRundownRoutine )
#pragma alloc_text( PAGEAFD, AfdCancelSuperAccept )
#pragma alloc_text( PAGEAFD, AfdCleanupSuperAccept )
#pragma alloc_text( PAGEAFD, AfdRestartDelayedAccept)
#pragma alloc_text( PAGEAFD, AfdRestartDelayedSuperAccept)
#endif


//
// Macros to make the super accept restart code more maintainable.
//

#define AfdRestartSuperAcceptInfo   DeviceIoControl

// Used while IRP is in AFD queue (otherwise AfdAcceptFileObject
// is stored as completion routine context).
#define AfdAcceptFileObject         Type3InputBuffer
// Used when IRP is passed to the transport (otherwise MdlAddress
// is stored in the IRP itself).
#define AfdMdlAddress               Type3InputBuffer

#define AfdReceiveDataLength        OutputBufferLength
#define AfdRemoteAddressLength      InputBufferLength
#define AfdLocalAddressLength       IoControlCode


//
// Similar macros for delayed accept restart code.
//
#define AfdRestartDelayedAcceptInfo DeviceIoControl
#define AfdSystemBuffer             Type3InputBuffer


NTSTATUS
FASTCALL
AfdAccept (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Accepts an incoming connection.  The connection is identified by the
    sequence number returned in the wait for listen IRP, and then
    associated with the endpoint specified in this request.  When this
    request completes, the connection is fully established and ready for
    data transfer.

Arguments:

    Irp - a pointer to a transmit file IRP.

    IrpSp - Our stack location for this IRP.

Return Value:

    STATUS_SUCCESS if the request was completed successfully, or a
    failure status code if there was an error.

--*/

{
    NTSTATUS status;
    PAFD_ACCEPT_INFO acceptInfo;
    PAFD_ENDPOINT listenEndpoint;
    PFILE_OBJECT acceptFileObject;
    PAFD_ENDPOINT acceptEndpoint;
    PAFD_CONNECTION connection;


    //
    // Set up local variables.
    //

    listenEndpoint = IrpSp->FileObject->FsContext;
    Irp->IoStatus.Information = 0;

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        PAFD_ACCEPT_INFO      newSystemBuffer;
        PAFD_ACCEPT_INFO32    oldSystemBuffer = Irp->AssociatedIrp.SystemBuffer;

        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                     sizeof(AFD_ACCEPT_INFO32) ) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }

        try {
            newSystemBuffer = ExAllocatePoolWithQuotaTag (
                                    NonPagedPool|POOL_RAISE_IF_ALLOCATION_FAILURE, 
                                    sizeof (AFD_ACCEPT_INFO), 
                                    AFD_SYSTEM_BUFFER_POOL_TAG);
                                                
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            status = GetExceptionCode ();
            goto complete;
        }

        newSystemBuffer->SanActive = oldSystemBuffer->SanActive;
        newSystemBuffer->AcceptHandle = oldSystemBuffer->AcceptHandle;
        newSystemBuffer->Sequence = oldSystemBuffer->Sequence;

        ExFreePool (Irp->AssociatedIrp.SystemBuffer);
        Irp->AssociatedIrp.SystemBuffer = newSystemBuffer;
        IrpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof (AFD_ACCEPT_INFO);
    }
#endif // _WIN64

    acceptInfo = Irp->AssociatedIrp.SystemBuffer;

    //
    // Make sure that this request is valid.
    //

    if ( !listenEndpoint->Listening ||
             IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                 sizeof(AFD_ACCEPT_INFO) ||
             Irp->MdlAddress!=NULL) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    ASSERT ((listenEndpoint->Type & AfdBlockTypeVcListening)==AfdBlockTypeVcListening);

    //
    // Check for if the caller is unaware of the SAN
    // provider activation and report the error.
    //
    if (!acceptInfo->SanActive && AfdSanServiceHelper!=NULL) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AFD: Process %p is being told to enable SAN on accept\n",
                    PsGetCurrentProcessId ()));
        status = STATUS_INVALID_PARAMETER_12;
        goto complete;
    }

    //
    // Add another free connection to replace the one we're accepting.
    // Also, add extra to account for past failures in calls to
    // AfdAddFreeConnection().
    //

    InterlockedIncrement(
        &listenEndpoint->Common.VcListening.FailedConnectionAdds
        );

    AfdReplenishListenBacklog( listenEndpoint );

    //
    // Obtain a pointer to the endpoint on which we're going to
    // accept the connection.
    //

    status = ObReferenceObjectByHandle(
                 acceptInfo->AcceptHandle,
                 (IrpSp->Parameters.DeviceIoControl.IoControlCode>>14) & 3,
                                                // DesiredAccess
                 *IoFileObjectType,
                 Irp->RequestorMode,
                 (PVOID *)&acceptFileObject,
                 NULL
                 );

    if ( !NT_SUCCESS(status) ) {
        goto complete;
    }


    //
    // We may have a file object that is not an AFD endpoint.  Make sure
    // that this is an actual AFD endpoint.
    //

    if ( acceptFileObject->DeviceObject!=AfdDeviceObject) {
        status = STATUS_INVALID_HANDLE;
        goto complete_deref;
    }

    acceptEndpoint = acceptFileObject->FsContext;
    if (acceptEndpoint->TransportInfo!=listenEndpoint->TransportInfo) {
        status = STATUS_INVALID_PARAMETER;
        goto complete_deref;
    }

    ASSERT( InterlockedIncrement( &acceptEndpoint->ObReferenceBias ) > 0 );

    IF_DEBUG(ACCEPT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdAccept: file object %p, accept endpoint %p, listen endpoint %p\n",
                      acceptFileObject, acceptEndpoint, listenEndpoint ));
    }

    if (AFD_START_STATE_CHANGE (acceptEndpoint, AfdEndpointStateConnected)) {
        if (acceptEndpoint->State!=AfdEndpointStateOpen ||
                acceptEndpoint->TransportInfo!=listenEndpoint->TransportInfo ||
                acceptEndpoint->SecurityDescriptor!=NULL) {
            status = STATUS_INVALID_PARAMETER;
        }
        else {
            AFD_LOCK_QUEUE_HANDLE   lockHandle;
            AfdAcquireSpinLock (&listenEndpoint->SpinLock, &lockHandle);
            connection = AfdGetReturnedConnection (listenEndpoint,
                                                    acceptInfo->Sequence);
            if (connection==NULL) {
                AfdReleaseSpinLock (&listenEndpoint->SpinLock, &lockHandle);
                status = STATUS_INVALID_PARAMETER;
            }
            else if (connection->SanConnection) {
                Irp->Tail.Overlay.DriverContext[3] = acceptInfo->AcceptHandle;
                IrpSp->Parameters.AfdRestartSuperAcceptInfo.AfdAcceptFileObject = acceptFileObject;
                IrpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength = 0;
                IrpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength = 0;
                IrpSp->Parameters.AfdRestartSuperAcceptInfo.AfdRemoteAddressLength = 0;
                status = AfdSanAcceptCore (Irp, acceptFileObject, connection, &lockHandle);
                if (status==STATUS_PENDING) {
                    return STATUS_PENDING;
                }
            }
            else {
                status = AfdAcceptCore (Irp, acceptEndpoint, connection);
                AfdReleaseSpinLock (&listenEndpoint->SpinLock, &lockHandle);

                AFD_RETURN_REMOTE_ADDRESS (
                        connection->RemoteAddress,
                        connection->RemoteAddressLength
                        );
                connection->RemoteAddress = NULL;

                if (status==STATUS_SUCCESS) {
                    NOTHING;
                }
                else if (status==STATUS_PENDING) {

                    //
                    // Remember that a TDI accept has started on this endpoint.
                    //

                    InterlockedIncrement(
                        &listenEndpoint->Common.VcListening.TdiAcceptPendingCount
                        );

                    IrpSp->Parameters.AfdRestartDelayedAcceptInfo.AfdSystemBuffer = 
                            Irp->AssociatedIrp.SystemBuffer;
                    Irp->AssociatedIrp.SystemBuffer = NULL;

                    ASSERT (Irp->MdlAddress==NULL);

                    IoSetCompletionRoutine(
                            Irp,
                            AfdRestartDelayedAccept,
                            acceptFileObject,
                            TRUE,
                            TRUE,
                            TRUE
                            );

                    AfdIoCallDriver (
                            acceptEndpoint,
                            connection->DeviceObject,
                            Irp
                            );

                    return STATUS_PENDING;
                }
                else {
                    AfdAbortConnection (connection);
                    ASSERT (status==STATUS_CANCELLED);
                }
            }
        }
        AFD_END_STATE_CHANGE (acceptEndpoint);
    }
    else {
        status = STATUS_INVALID_PARAMETER;
    }

    ASSERT( InterlockedDecrement( &acceptEndpoint->ObReferenceBias ) >= 0 );

complete_deref:
    ObDereferenceObject( acceptFileObject );

complete:

    Irp->IoStatus.Status = status;
    ASSERT( Irp->CancelRoutine == NULL );

    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

} // AfdAccept



NTSTATUS
AfdAcceptCore (
    IN PIRP AcceptIrp,
    IN PAFD_ENDPOINT AcceptEndpoint,
    IN PAFD_CONNECTION Connection
    )

/*++

Routine Description:

    Performs the key functions of associating a connection accepted
    on a listening endpoint with a new endpoint.

Arguments:

    AcceptIrp - Irp used for accept operation

    AcceptEndpoint - the new endpoint with which to associate the
        connectuion.

    Connection -  the connection being accepted.

Return Value:

    STATUS_SUCCESS if the operation was completed successfully,
    STATUS_PENDING if IRP was passed further to the transport
    failure status code if there was an error.

--*/

{
    PAFD_ENDPOINT   listenEndpoint;
    NTSTATUS        status;
    PIO_STACK_LOCATION  irpSp;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    irpSp = IoGetCurrentIrpStackLocation (AcceptIrp);
    listenEndpoint = irpSp->FileObject->FsContext;

    //
    // Reenable the accept event bit, and if there are additional
    // unaccepted connections on the endpoint, post another event.
    //


    listenEndpoint->EventsActive &= ~AFD_POLL_ACCEPT;

    IF_DEBUG(EVENT_SELECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
            "AfdAcceptCore: Endp %08lX, Active %08lX\n",
            listenEndpoint,
            listenEndpoint->EventsActive
            ));
    }

    if( !IsListEmpty( &listenEndpoint->Common.VcListening.UnacceptedConnectionListHead ) ) {

        AfdIndicateEventSelectEvent(
            listenEndpoint,
            AFD_POLL_ACCEPT,
            STATUS_SUCCESS
            );

    }

    //
    // Do not release the listening endpoint spinlock here.
    // We are going to be chaning connection object which assumes
    // protection from listening endpoint spinlock until it is associated
    // with accept endpoint (this plugs nasty racing conditions when
    // receive is indicated rigth before connection object is updated, so
    // it takes listening endpoint spinlock, and rigth before it queues
    // the buffer to the connection object, it gets associated with accept
    // endpoint and AcceptEx'es receive does not notice the buffer because
    // it takes accept endpoint spinlock)
    //
    // AfdReleaseSpinLock( &ListenEndpoint->SpinLock, &lockHandle );

    //
    // Check the state of the accepting endpoint under the guard
    // of the endpoint's spinlock.
    //

    AfdAcquireSpinLockAtDpcLevel( &AcceptEndpoint->SpinLock, &lockHandle);
    status = AfdSetupAcceptEndpoint (listenEndpoint, AcceptEndpoint, Connection);
    if (status==STATUS_SUCCESS) {


        if (IS_DELAYED_ACCEPTANCE_ENDPOINT (listenEndpoint)) {
            PTDI_CONNECTION_INFORMATION requestConnectionInformation;

            if( Connection->ConnectDataBuffers != NULL ) {

                //
                // We allocated extra space at the end of the connect data
                // buffers structure.  We'll use this for the
                // TDI_CONNECTION_INFORMATION structure that holds response
                // connect data and options.  Not pretty, but the fastest
                // and easiest way to accomplish this.
                //

                requestConnectionInformation =
                    &Connection->ConnectDataBuffers->RequestConnectionInfo;

                RtlZeroMemory(
                    requestConnectionInformation,
                    sizeof(*requestConnectionInformation)
                    );

                requestConnectionInformation->UserData =
                    Connection->ConnectDataBuffers->SendConnectData.Buffer;
                requestConnectionInformation->UserDataLength =
                    Connection->ConnectDataBuffers->SendConnectData.BufferLength;
                requestConnectionInformation->Options =
                    Connection->ConnectDataBuffers->SendConnectOptions.Buffer;
                requestConnectionInformation->OptionsLength =
                    Connection->ConnectDataBuffers->SendConnectOptions.BufferLength;

            } else {

                requestConnectionInformation = NULL;

            }

            TdiBuildAccept(
                AcceptIrp,
                Connection->DeviceObject,
                Connection->FileObject,
                NULL,
                NULL,
                requestConnectionInformation,
                NULL
                );

            status = STATUS_PENDING;
        }
        else {
            //
            // Set the endpoint to the connected state.
            //

            AcceptEndpoint->State = AfdEndpointStateConnected;
            Connection->State = AfdConnectionStateConnected;

            //
            // Set events active field base on data accumulated on the connection.
            //

            if( IS_DATA_ON_CONNECTION( Connection ) ||
                ( AcceptEndpoint->InLine &&
                  IS_EXPEDITED_DATA_ON_CONNECTION( Connection ) ) ) {

                AcceptEndpoint->EventsActive |= AFD_POLL_RECEIVE;

            }

            if( !AcceptEndpoint->InLine &&
                IS_EXPEDITED_DATA_ON_CONNECTION( Connection ) ) {

                AcceptEndpoint->EventsActive |= AFD_POLL_RECEIVE_EXPEDITED;

            }

            AcceptEndpoint->EventsActive |= AFD_POLL_SEND;

            if( Connection->DisconnectIndicated ) {

                AcceptEndpoint->EventsActive |= AFD_POLL_DISCONNECT;
            }


            if( Connection->Aborted ) {

                AcceptEndpoint->EventsActive |= AFD_POLL_ABORT;

            }


            IF_DEBUG(EVENT_SELECT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdAcceptCore: Endp %08lX, Active %08lX\n",
                    AcceptEndpoint,
                    AcceptEndpoint->EventsActive
                    ));
            }

            status = STATUS_SUCCESS;
        }
    }

    AfdReleaseSpinLockFromDpcLevel( &AcceptEndpoint->SpinLock, &lockHandle);
    return status;
} // AfdAcceptCore


VOID
AfdInitiateListenBacklogReplenish (
    IN PAFD_ENDPOINT Endpoint
    )

/*++

Routine Description:

    Queues a work item to begin replenishing the listen backlog
    on a listening endpoint.

Arguments:

    Endpoint - the listening endpoint on which to replenish the
        backlog.

Return Value:

    None.

--*/

{
    AFD_LOCK_QUEUE_HANDLE   lockHandle;

    //
    // Check if backlog replenish is active already.
    //
    AfdAcquireSpinLock (&Endpoint->SpinLock, &lockHandle);
    if (!Endpoint->Common.VcListening.BacklogReplenishActive) {

        Endpoint->Common.VcListening.BacklogReplenishActive = TRUE;
        //
        // Reference the endpoint so that it won't go away until we're
        // done with it.
        //

        REFERENCE_ENDPOINT( Endpoint );


        AfdQueueWorkItem(
            AfdDoListenBacklogReplenish,
            &Endpoint->WorkItem
            );
    }

    AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
    return;
} // AfdInitiateListenBacklogReplenish


VOID
AfdDoListenBacklogReplenish (
    IN PVOID Context
    )

/*++

Routine Description:

    The worker routine for replenishing the listen backlog on a
    listening endpoint.  This routine only runs in the context of
    an executive worker thread.

Arguments:

    Context - Points to an AFD_WORK_ITEM structure. The Context field
        of this structure points to the endpoint on which to replenish
        the listen backlog.

Return Value:

     None.

--*/

{
    PAFD_ENDPOINT endpoint;
    NTSTATUS    status;
    AFD_LOCK_QUEUE_HANDLE lockHandle;


    endpoint = CONTAINING_RECORD(
                   Context,
                   AFD_ENDPOINT,
                   WorkItem
                   );

    ASSERT( endpoint->Type == AfdBlockTypeVcListening ||
            endpoint->Type == AfdBlockTypeVcBoth );

    ASSERT (endpoint->Common.VcListening.BacklogReplenishActive == TRUE);

    AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    endpoint->Common.VcListening.BacklogReplenishActive = FALSE;
    AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

    //
    // Fill up the free connection backlog.
    //

    status = AfdReplenishListenBacklog( endpoint );
    if (!NT_SUCCESS (status)) {
        //
        // If we failed, try to notify application
        //
        AfdReportConnectionAllocationFailure (endpoint, status);
    }


    //
    // Clean up and return.
    //

    DEREFERENCE_ENDPOINT( endpoint );

    return;

} // AfdDoListenBacklogReplenish


NTSTATUS
AfdReplenishListenBacklog (
    IN PAFD_ENDPOINT Endpoint
    )

/*++

Routine Description:

    Does the actual work of filling up the listen backlog on a listening
    endpoint.

Arguments:

    Endpoint - the listening endpoint on which to replenish the
        listen backlog.

Return Value:

    STATUS_SUCCESS - if new connection was allocated or we already
                        had enough
    status of conneciton allocation failure otherwise
--*/

{
    NTSTATUS status;
    LONG result;

    PAGED_CODE( );

    ASSERT( Endpoint->Type == AfdBlockTypeVcListening ||
            Endpoint->Type == AfdBlockTypeVcBoth );


    //
    // Decrement the count of failed connection additions.
    //

    result = InterlockedDecrement(
                 &Endpoint->Common.VcListening.FailedConnectionAdds
                 );

    //
    // Continue opening new free conections until we've hit the
    // backlog or a connection open fails.
    //
    // If the result of the decrement is negative, then we are either
    // all set on the connection count or else have available extra
    // connection objects on the listening endpoint.  These connections
    // have been reused from prior connections which have now
    // terminated.
    //

    while ( result >= 0 ) {

        status = AfdAddFreeConnection( Endpoint );

        if ( !NT_SUCCESS(status) ) {

            InterlockedIncrement(
                &Endpoint->Common.VcListening.FailedConnectionAdds
                );

            IF_DEBUG(LISTEN) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdReplenishListenBacklog: AfdAddFreeConnection failed: %X, fail count = %ld\n", status,
                            Endpoint->Common.VcListening.FailedConnectionAdds ));
            }

            //
            // Return connection allocation failure to the application
            // if it cares to know (posted accept request).
            //

            return status;
        }

        result = InterlockedDecrement(
                     &Endpoint->Common.VcListening.FailedConnectionAdds
                     );
    }

    //
    // Correct the counter to reflect the number of connections
    // we have available.  Then just return from here.
    //

    InterlockedIncrement(
        &Endpoint->Common.VcListening.FailedConnectionAdds
        );

    return STATUS_SUCCESS;

} // AfdReplenishListenBacklog



VOID
AfdReportConnectionAllocationFailure (
    PAFD_ENDPOINT   Endpoint,
    NTSTATUS        Status
    )
/*++

Routine Description:

    Reports connection allocation failure to the application by 
    failing then first wait for listen irp in the queue (if application
    has AcceptEx or blockin accept outstanding, it will get this notification).

Arguments:

    Endpoint - the listening endpoint on which to report an error
    Status - status code to report

Return Value:

    None
--*/
{
    AFD_LOCK_QUEUE_HANDLE       lockHandle;

    AfdAcquireSpinLock (&Endpoint->SpinLock, &lockHandle);
    if ((Endpoint->Common.VcListening.FailedConnectionAdds>0) &&
            IsListEmpty (&Endpoint->Common.VcListening.UnacceptedConnectionListHead) &&
            !IsListEmpty (&Endpoint->Common.VcListening.ListeningIrpListHead)) {
        PIRP                irp;
        PIO_STACK_LOCATION  irpSp;

        irp = CONTAINING_RECORD (Endpoint->Common.VcListening.ListeningIrpListHead.Flink,
                                        IRP,
                                        Tail.Overlay.ListEntry);
        irpSp = IoGetCurrentIrpStackLocation (irp);
        RemoveEntryList (&irp->Tail.Overlay.ListEntry);
        irp->Tail.Overlay.ListEntry.Flink = NULL;

        AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);

        if (IoSetCancelRoutine (irp, NULL)==NULL) {
            KIRQL   cancelIrql;
            //
            // If the cancel routine was NULL then cancel routine
            // may be running.  Wait on the cancel spinlock until
            // the cancel routine is done.
            //
            // Note: The cancel routine will not find the IRP
            // since it is not in the list.
            //
    
            IoAcquireCancelSpinLock( &cancelIrql );
            ASSERT( irp->Cancel );
            IoReleaseCancelSpinLock( cancelIrql );
        }
        if (irpSp->MajorFunction==IRP_MJ_INTERNAL_DEVICE_CONTROL) {
            AfdCleanupSuperAccept (irp, Status);
        }
        else {
            irp->IoStatus.Status = Status;
            irp->IoStatus.Information = 0;
        }
        IoCompleteRequest (irp, AfdPriorityBoost);
    }
    else {
        AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
    }
}




NTSTATUS
FASTCALL
AfdSuperAccept (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Initial entrypoint for handling super accept IRPs.  A super accept
    combines several operations for high-performance connection
    acceptance.  The combined operations are waiting for an incoming
    connection, accepting it, retrieving the local and remote socket
    addresses, and receiving the first chunk of data on the connection.

    This routine verifies parameters, initializes data structures to be
    used for the request, and initiates the I/O.

Arguments:

    Irp - a pointer to a transmit file IRP.

    IrpSp - Our stack location for this IRP.

Return Value:

    STATUS_PENDING if the request was initiated successfully, or a
    failure status code if there was an error.

--*/

{
    PAFD_ENDPOINT listenEndpoint;
    PAFD_ENDPOINT acceptEndpoint;
    PFILE_OBJECT acceptFileObject;
    HANDLE  acceptHandle;
    ULONG receiveDataLength, localAddressLength, remoteAddressLength;
    BOOLEAN sanActive;
#ifndef i386
    BOOLEAN fixAddressAlignment;
#endif
    NTSTATUS status;
    ULONG totalLength;
    PSLIST_ENTRY listEntry;
    PAFD_CONNECTION connection;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    //
    // Set up local variables.
    //

    listenEndpoint = IrpSp->FileObject->FsContext;
    acceptFileObject = NULL;
    acceptEndpoint = NULL;

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        PAFD_SUPER_ACCEPT_INFO32    superAcceptInfo32;
        superAcceptInfo32 = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                     sizeof(AFD_SUPER_ACCEPT_INFO32) ) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }

        AFD_W4_INIT status = STATUS_SUCCESS;
        try {
            if (Irp->RequestorMode!=KernelMode) {
                ProbeForReadSmallStructure (superAcceptInfo32,
                                    sizeof (*superAcceptInfo32),
                                    PROBE_ALIGNMENT32 (AFD_SUPER_ACCEPT_INFO32));
            }

            acceptHandle = superAcceptInfo32->AcceptHandle;
            receiveDataLength = superAcceptInfo32->ReceiveDataLength;
            localAddressLength = superAcceptInfo32->LocalAddressLength;
            remoteAddressLength = superAcceptInfo32->RemoteAddressLength;
            sanActive = superAcceptInfo32->SanActive;
            fixAddressAlignment = superAcceptInfo32->FixAddressAlignment;
        }
        except (AFD_EXCEPTION_FILTER (status)) {
            ASSERT (NT_ERROR (status));
            goto complete;
        }
    }
    else 
#endif // _WIN64
    {
        PAFD_SUPER_ACCEPT_INFO    superAcceptInfo;
        superAcceptInfo = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

        AFD_W4_INIT status = STATUS_SUCCESS;
        try {
            if (Irp->RequestorMode!=KernelMode) {
                ProbeForReadSmallStructure (superAcceptInfo,
                                    sizeof (*superAcceptInfo),
                                    PROBE_ALIGNMENT (AFD_SUPER_ACCEPT_INFO));
            }
            acceptHandle = superAcceptInfo->AcceptHandle;
            receiveDataLength = superAcceptInfo->ReceiveDataLength;
            localAddressLength = superAcceptInfo->LocalAddressLength;
            remoteAddressLength = superAcceptInfo->RemoteAddressLength;
            sanActive = superAcceptInfo->SanActive;
#ifndef i386
            fixAddressAlignment = superAcceptInfo->FixAddressAlignment;
#endif
        }
        except (AFD_EXCEPTION_FILTER (status)) {
            ASSERT (NT_ERROR (status));
            goto complete;
        }
    }


    //
    // Check for if the caller is unaware of the SAN
    // provider activation and report the error.
    //
    if (!sanActive && AfdSanServiceHelper!=NULL) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AFD: Process %p is being told to enable SAN on AcceptEx\n",
                    PsGetCurrentProcessId ()));
        status = STATUS_INVALID_PARAMETER_12;
        goto complete;
    }
    //
    // Validate the input information.  The input buffer must be large
    // enough to hold all the input information, plus some extra to use
    // here to hold the local address.  The output buffer must be
    // non-NULL and large enough to hold the specified information.
    //
    //

    if ( !listenEndpoint->Listening

                ||

            remoteAddressLength < (ULONG)FIELD_OFFSET (TRANSPORT_ADDRESS, 
                                        Address[0].Address)

                ||

                //
                // Do the check in such a manner that integer overflow
                // (which is not enabled by the compiler) does not
                // affect the validity of the result.
                //
            (totalLength=IrpSp->Parameters.DeviceIoControl.OutputBufferLength)<
                    receiveDataLength
             
                ||

            (totalLength-=receiveDataLength) < localAddressLength

                ||

            (totalLength-=localAddressLength) < remoteAddressLength

                                                ) {

        if( !listenEndpoint->Listening ) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                "AfdSuperAccept: non-listening endpoint @ %08lX\n",
                listenEndpoint
                ));
            status = STATUS_INVALID_PARAMETER;
        }
        else {
            status = STATUS_BUFFER_TOO_SMALL;
        }

        goto complete;
    }

    AFD_W4_INIT ASSERT (status == STATUS_SUCCESS);
    try {
        if (IoAllocateMdl(Irp->UserBuffer,
                            IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                            FALSE,      // Secondary buffer
                            TRUE,       // Charge quota
                            Irp
                            )==NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto complete;
        }

        MmProbeAndLockPages (Irp->MdlAddress, Irp->RequestorMode, IoWriteAccess);
    }
    __except (AFD_EXCEPTION_FILTER (status)) {
        ASSERT (NT_ERROR (status));
        goto complete;
    }

    ASSERT ((listenEndpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening);
    //
    // Obtain a pointer to the endpoint on which we're going to
    // accept the connection.
    //

    status = ObReferenceObjectByHandle(
                 acceptHandle,
                 (IrpSp->Parameters.DeviceIoControl.IoControlCode>>14) & 3,
                                                    // DesiredAccess
                 *IoFileObjectType,
                 Irp->RequestorMode,
                 &acceptFileObject,
                 NULL
                 );

    if ( !NT_SUCCESS(status) ) {
        goto complete;
    }


    //
    // We may have a file object that is not an AFD endpoint.  Make sure
    // that this is an actual AFD endpoint.
    //

    if (acceptFileObject->DeviceObject!= AfdDeviceObject) {
        status = STATUS_INVALID_HANDLE;
        goto complete;
    }


    acceptEndpoint = acceptFileObject->FsContext;
    ASSERT( InterlockedIncrement( &acceptEndpoint->ObReferenceBias ) > 0 );


    if (!AFD_START_STATE_CHANGE (acceptEndpoint, AfdEndpointStateConnected)) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    if (acceptEndpoint->TransportInfo!=listenEndpoint->TransportInfo || 
            acceptEndpoint->State != AfdEndpointStateOpen ||
            acceptEndpoint->SecurityDescriptor!=NULL) {
        status = STATUS_INVALID_PARAMETER;
        goto complete_state_change;
    }


#ifndef i386
    acceptEndpoint->Common.VcConnecting.FixAddressAlignment = fixAddressAlignment;
#endif
    Irp->Tail.Overlay.DriverContext[3] = acceptHandle;

    //
    // Save common IRP parameters in our stack location so
    // we can retreive them when necessary
    //

    IrpSp->Parameters.AfdRestartSuperAcceptInfo.AfdAcceptFileObject = acceptFileObject;
    IrpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength = receiveDataLength;
    IrpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength = localAddressLength;
    IrpSp->Parameters.AfdRestartSuperAcceptInfo.AfdRemoteAddressLength = remoteAddressLength;

    //
    // Add another free connection to replace the one we're accepting.
    // Also, add extra to account for past failures in calls to
    // AfdAddFreeConnection().
    //

    InterlockedIncrement(
        &listenEndpoint->Common.VcListening.FailedConnectionAdds
        );

    status = AfdReplenishListenBacklog( listenEndpoint );


    //
    // Save the IRP, so that accept enpoint cleanup can find it.
    // Note, that even if found, the cleanup won't touch the IRP
    // until cancel routine is set in it.
    //
    ASSERT (acceptEndpoint->Irp==NULL);
    acceptEndpoint->Irp = Irp;

    //
    // Get free connection from the list, if none is available,
    // or direct super accept is disabled, go through the regular
    // listen-accept path.
    //

    if (AfdDisableDirectSuperAccept ||
        IS_DELAYED_ACCEPTANCE_ENDPOINT (listenEndpoint) ||
        ExQueryDepthSList (&listenEndpoint->Common.VcListening.PreacceptedConnectionsListHead)
                    > AFD_MAXIMUM_FREE_CONNECTIONS ||
        ((listEntry = InterlockedPopEntrySList (
                     &listenEndpoint->Common.VcListening.FreeConnectionListHead
                     ))==NULL)) {
    
        //
        // Setup super accept IRP to be put into the wait for
        // listen queue. Internal device control distinguishes this
        // from the regular wait for listen IRPs that come directly
        // from the application.
        //
        IrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

        //
        // Mark this IRP as pending since we are going to return
        // STATUS_PENDING no matter what (sometimes the actual
        // status is hidden very deep inside the call stack and
        // it is impossible to propagate it all the way up).
        //
        IoMarkIrpPending (Irp);

        AfdWaitForListen (Irp, IrpSp);

        //
        // If connection allocation failed above, we need to report 
        // this to application.  We delay this call in case there is
        // already a preaccepted connection, so the allocation failure
        // is not important.
        //
        if (!NT_SUCCESS (status)) {
            AfdReportConnectionAllocationFailure (listenEndpoint, status);
        }

        return STATUS_PENDING;
    }

    //
    // Get connection object of the list entry
    //
    connection = CONTAINING_RECORD(
                     listEntry,
                     AFD_CONNECTION,
                     SListEntry
                     );


    //
    // Stuff special constant into the connection object accept IRP
    // pointer, so that cancel routine does not complete the IRP
    // while we are still looking at it, but in the same time we
    // can detect that the IRP was cancelled (cancel routine will
    // replace the -1 with NULL to indicate that it has been ran).
    // This technique avoids extra spinlock acquire/release and
    // associated IRQL raise/lower on an extremely performance-sensitive 
    // code path.
    //

    connection->AcceptIrp = (PIRP)-1;
    Irp->Tail.Overlay.DriverContext[0] = connection;

    //
    // We are going to pend this Irp, so mark it as pending
    // and set up the cancel routine. 
    //

    IoMarkIrpPending (Irp);

    IoSetCancelRoutine( Irp, AfdCancelSuperAccept );


    //
    // Check if the IRP has already been canceled.
    // If the cancel routine ran, it just reset the connection
    // object accept pointer to NULL (instead of -1 that we stuffed
    // in it above), but it did not complete the IRP.
    //

    if ( !Irp->Cancel &&
            (InterlockedCompareExchangePointer (
                    (PVOID *)&connection->AcceptIrp,
                    Irp,
                    (PVOID)-1)==(PVOID)-1)) {
        //
        // Can't touch the IRP after this point since it may have already
        // been canceled.
        //
        DEBUG   Irp = NULL;

        //
        // Push the connection and associated Irp/endpoint
        // onto preaccepted connection list.
        //

        if (InterlockedPushEntrySList(
                &listenEndpoint->Common.VcListening.PreacceptedConnectionsListHead,
                &connection->SListEntry
                )==NULL) {

            //
            // This is the first Irp in the list, we need to check
            // if there are any unaccepted connections that we
            // can use to satisfy super accept.
            //

            AfdAcquireSpinLock (&listenEndpoint->SpinLock, &lockHandle);

            if (!listenEndpoint->EndpointCleanedUp) {
                LIST_ENTRY  irpList;
                InitializeListHead (&irpList);

                //
                // First see if there is an unaccepted connection
                //
                while (!IsListEmpty (&listenEndpoint->Common.VcListening.UnacceptedConnectionListHead)) {
                    connection = CONTAINING_RECORD(
                                         listenEndpoint->Common.VcListening.UnacceptedConnectionListHead.Flink,
                                         AFD_CONNECTION,
                                         ListEntry
                                         );
                    RemoveEntryList (&connection->ListEntry);
                    //
                    // Now make sure we still have super accept irp
                    //
                    if (AfdServiceSuperAccept (listenEndpoint, connection, &lockHandle, &irpList)) {
                        //
                        // The routine has found and completed super accept IRP
                        // Reaquire a spinlock and continue searching for more.
                        //
                        AfdAcquireSpinLock (&listenEndpoint->SpinLock, &lockHandle);
                    }
                    else {
                        //
                        // No super accept Irps, put connection back onto the list
                        // while we are still holding the lock and bail out.
                        //
                        InsertHeadList (&listenEndpoint->Common.VcListening.UnacceptedConnectionListHead,
                                            &connection->ListEntry);
                        break;
                    }
                }
                AfdReleaseSpinLock (&listenEndpoint->SpinLock, &lockHandle);

                //
                // Complete failed super accept IRPs (if any)
                //
                if (!IsListEmpty (&irpList)) {
                    KIRQL   cancelIrql;
                    //
                    // Make sure cancel routines will
                    // not access the completed IRPs
                    //
                    IoAcquireCancelSpinLock (&cancelIrql);
                    IoReleaseCancelSpinLock (cancelIrql);
                    while (!IsListEmpty (&irpList)) {
                        PIRP    irp;
                        irp = CONTAINING_RECORD (irpList.Flink, IRP, Tail.Overlay.ListEntry);
                        RemoveEntryList (&irp->Tail.Overlay.ListEntry);
                        IoCompleteRequest (irp, AfdPriorityBoost);
                    }
                }
            }
            else {
                AfdReleaseSpinLock (&listenEndpoint->SpinLock, &lockHandle);
                AfdFreeQueuedConnections (listenEndpoint);
            }
        }
        else {
            USHORT  depth = 
                ExQueryDepthSList (&listenEndpoint->Common.VcListening.PreacceptedConnectionsListHead);

            if (depth > listenEndpoint->Common.VcListening.MaxExtraConnections) {
                //
                // Update under the lock, so we do not corrupt
                // other fields in the same memory access granularity unit.
                // This should be infrequent operation anyway.
                //
                AfdAcquireSpinLock (&listenEndpoint->SpinLock, &lockHandle);
                listenEndpoint->Common.VcListening.MaxExtraConnections = depth;
                AfdReleaseSpinLock (&listenEndpoint->SpinLock, &lockHandle);
             }
        }
    }
    else {
        //
        // Reset and call the cancel routine, since
        // even if cancel routine ran, it could not complete
        // the irp because it was not set in the connection
        // object. Note that cancel routine is done with the IRP
        // once it releases cancel spinlock which we acquire here.
        //
        AfdCleanupSuperAccept (Irp, STATUS_CANCELLED);
        if (IoSetCancelRoutine (Irp, NULL)==NULL) {
            KIRQL cancelIrql;
            IoAcquireCancelSpinLock (&cancelIrql);
            IoReleaseCancelSpinLock (cancelIrql);
        }

        IoCompleteRequest (Irp, AfdPriorityBoost);

        //
        // We have to return pending because we have already
        // marked the Irp as pending.
        //
    }

    return STATUS_PENDING;

complete_state_change:
    AFD_END_STATE_CHANGE (acceptEndpoint);

complete:

    if ( acceptFileObject != NULL ) {
        if (acceptEndpoint!=NULL) {
            ASSERT( InterlockedDecrement( &acceptEndpoint->ObReferenceBias ) >= 0 );
        }
        ObDereferenceObject( acceptFileObject );
    }

    //
    // Free MDL here as IO system can't do it if it is
    // not locked.
    //
    if (Irp->MdlAddress!=NULL) {
        if (Irp->MdlAddress->MdlFlags & MDL_PAGES_LOCKED) {
            MmUnlockPages (Irp->MdlAddress);
        }

        IoFreeMdl (Irp->MdlAddress);
        Irp->MdlAddress = NULL;
    }

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, 0 );

    return status;

} // AfdSuperAccept



NTSTATUS
AfdRestartSuperAccept (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    The completion routine for the AFD wait for listen IRP portion
    of a super accept.

Arguments:

    DeviceObject - the devoce object on which the request is completing.

    Irp - The super accept IRP.

    Context - points to accept file object.

Return Value:

    STATUS_SUCCESS if the I/O system should complete the super accept
    request, or STATUS_MORE_PROCESSING_REQUIRED if the super accept
    request is still being processed.

--*/

{
    PAFD_ENDPOINT listenEndpoint;
    PFILE_OBJECT acceptFileObject;
    PAFD_ENDPOINT acceptEndpoint;
    PAFD_CONNECTION connection;

    PIO_STACK_LOCATION irpSp;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    UNREFERENCED_PARAMETER (DeviceObject);

    //
    // Initialize some locals.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    listenEndpoint = irpSp->FileObject->FsContext;

    acceptFileObject = Context;
    acceptEndpoint = acceptFileObject->FsContext;
    ASSERT (IS_AFD_ENDPOINT_TYPE (acceptEndpoint));

    connection = acceptEndpoint->Common.VcConnecting.Connection;
    ASSERT (connection->Type==AfdBlockTypeConnection);
    ASSERT (connection->Endpoint==acceptEndpoint);


    //
    // Overwrite listen file object with accept file object
    // since we won't be using listen file object anymore,
    // while we still need to deference accept file object
    // upon IRP completion.
    //
    irpSp->FileObject = acceptFileObject;


    //
    // Fix up the MDL pointer in the IRP.
    //

    ASSERT (Irp->MdlAddress==NULL);
    Irp->MdlAddress = irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdMdlAddress;

    //
    // If pending has been returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending( Irp );
    }

    //
    // Remember that a TDI accept has completed on this endpoint.
    //

    InterlockedDecrement(
        &listenEndpoint->Common.VcListening.TdiAcceptPendingCount
        );

    connection->ConnectTime = KeQueryInterruptTime();

    if ( NT_SUCCESS(Irp->IoStatus.Status)) {

        //
        // Set the endpoint to the connected state.
        //

        AfdAcquireSpinLock (&acceptEndpoint->SpinLock, &lockHandle);

        acceptEndpoint->State = AfdEndpointStateConnected;
        connection->State = AfdConnectionStateConnected;
        acceptEndpoint->EventsActive |= AFD_POLL_SEND;


        //
        // Remove the TDI accept IRP reference to the connection.
        // Combine with reference below to optimize.
        //

        // DEREFERENCE_CONNECTION( connection );

        //
        // Reference connection to prevent it from going away during
        // accept process as the result of transmit file completion.
        // (transmit file can now occur at any time since we
        // marked the endpoint as connected and about to end state change)
        //

        // REFERENCE_CONNECTION (connection);

        AfdReleaseSpinLock (&acceptEndpoint->SpinLock, &lockHandle);
        AFD_END_STATE_CHANGE(acceptEndpoint);

        return AfdContinueSuperAccept (Irp, connection);
    }
    else {
        //
        // If the accept failed, treat it like an abortive disconnect.
        // This way the application still gets a new endpoint, but it gets
        // told about the reset.
        //

        AFD_END_STATE_CHANGE(acceptEndpoint);
        AfdDisconnectEventHandler(
            NULL,
            connection,
            0,
            NULL,
            0,
            NULL,
            TDI_DISCONNECT_ABORT
            );

        ASSERT( InterlockedDecrement( &acceptEndpoint->ObReferenceBias ) >= 0 );
        ObDereferenceObject( acceptFileObject );

        //
        // Check if we have secondary MDL for local address query and
        // free it.
        //
        if (Irp->MdlAddress->Next!=NULL) {
            //
            // We never lock pages for this one (they are locked
            // as part of main MDL).
            //
            ASSERT (irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength>0);
            ASSERT ((Irp->MdlAddress->Next->MdlFlags & MDL_PAGES_LOCKED)==0);
            IoFreeMdl (Irp->MdlAddress->Next);
            Irp->MdlAddress->Next = NULL;
        }

        //
        // Remove the TDI accept IRP reference to the connection.
        //

        DEREFERENCE_CONNECTION( connection );

        return STATUS_SUCCESS;
    }

} // AfdRestartSuperAccept


VOID
AfdRestartSuperAcceptListen (
    IN PIRP            Irp,
    IN PAFD_CONNECTION Connection
    )

/*++

Routine Description:

    The completion routine for the AFD wait for listen IRP portion
    of a super accept.

Arguments:

    Irp - The super accept IRP.

    Connection - points to the connection object

Return Value:

    None
--*/

{
    PAFD_ENDPOINT acceptEndpoint;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS    status;

    //
    // Initialize some locals.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    acceptEndpoint = irpSp->FileObject->FsContext;
    ASSERT (IS_AFD_ENDPOINT_TYPE (acceptEndpoint));
    AFD_END_STATE_CHANGE(acceptEndpoint);

    //
    // Fix up the system buffer and MDL pointers in the IRP.
    //

    ASSERT (Irp->MdlAddress==NULL);
    ASSERT (Irp->AssociatedIrp.SystemBuffer == NULL);
    Irp->MdlAddress = irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdMdlAddress;

    //
    // This routine shouldn't have been called if accept failed
    //
    ASSERT ( NT_SUCCESS(Irp->IoStatus.Status) );

    //
    // Reference connection to prevent it from going away during
    // accept process as the result of transmit file completion.
    // (transmit file can now occur at any time since we
    // marked the endpoint as connected and about to end state change)
    //
    REFERENCE_CONNECTION (Connection);

    status = AfdContinueSuperAccept (Irp, Connection);

    //
    // If completion routine return anything other
    // than STATUS_MORE_PROCESSING_REQUIRED, the IRP
    // is ready to be completed.  Otherwise, is was
    // reused to call transport driver and will be completed
    // by the driver.  Note that in the latter case
    // the IRP cannot be touched because
    // it could have been completed inside of the
    // completion routine or by the driver before the
    // completion routine returned.
    //
    if (status!=STATUS_MORE_PROCESSING_REQUIRED) {
        IoCompleteRequest (Irp, AfdPriorityBoost);
    }

} // AfdRestartSuperAcceptListen

NTSTATUS
AfdRestartDelayedSuperAccept (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    The completion routine for the AFD wait for delayed accept IRP portion
    of a super accept.

Arguments:

    DeviceObject - the devoce object on which the request is completing.

    Irp - The super accept IRP.

    Context - points to accept file object

Return Value:

    STATUS_SUCCESS if the I/O system should complete the super accept
    request, or STATUS_MORE_PROCESSING_REQUIRED if the super accept
    request is still being processed.

--*/

{
    PAFD_ENDPOINT listenEndpoint;
    PFILE_OBJECT  acceptFileObject;
    PAFD_ENDPOINT acceptEndpoint;
    PAFD_CONNECTION connection;

    PIO_STACK_LOCATION irpSp;
    AFD_LOCK_QUEUE_HANDLE   lockHandle;

    UNREFERENCED_PARAMETER (DeviceObject);

    //
    // Initialize some locals.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    listenEndpoint = irpSp->FileObject->FsContext;
    acceptFileObject = Context;
    acceptEndpoint = acceptFileObject->FsContext;
    ASSERT (IS_AFD_ENDPOINT_TYPE (acceptEndpoint));

    //
    // Overwrite listen file object with accept file object
    // since we won't be using listen file object anymore,
    // while we still need to deference accept file object
    // upon IRP completion.
    //
    irpSp->FileObject = acceptFileObject;

    //
    // Fix up the MDL pointer in the IRP.
    //

    ASSERT (Irp->MdlAddress==NULL);
    Irp->MdlAddress = irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdMdlAddress;

    AfdCompleteOutstandingIrp (acceptEndpoint, Irp);

    //
    // If pending has been returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending( Irp );
    }

    //
    // Remember that a TDI accept has completed on this endpoint.
    //

    InterlockedDecrement(
        &listenEndpoint->Common.VcListening.TdiAcceptPendingCount
        );

    AfdAcquireSpinLock (&acceptEndpoint->SpinLock, &lockHandle);
    //
    // The AFD connection object should now be in the endpoiont.
    //

    connection = AFD_CONNECTION_FROM_ENDPOINT( acceptEndpoint );
    if (connection!=NULL) {
        //
        // If the IRP failed, quit processing.
        //

        if ( NT_SUCCESS(Irp->IoStatus.Status) ) {

            acceptEndpoint->State = AfdEndpointStateConnected;
            connection->State = AfdConnectionStateConnected;
            acceptEndpoint->EventsActive |= AFD_POLL_SEND;

            //
            // Reference connection to prevent it from going away during
            // accept process as the result of transmit file completion.
            // (transmit file can now occur at any time since we
            // marked the endpoint as connected and about to end state change)
            //
            REFERENCE_CONNECTION (connection);

            AfdReleaseSpinLock (&acceptEndpoint->SpinLock, &lockHandle);
            AFD_END_STATE_CHANGE(acceptEndpoint);

            return AfdContinueSuperAccept (Irp, connection);

        }
        else {
            //
            // If the accept failed, treat it like an abortive disconnect.
            // This way the application still gets a new endpoint, but it gets
            // told about the reset.
            //

            AfdReleaseSpinLock (&acceptEndpoint->SpinLock, &lockHandle);

            AFD_END_STATE_CHANGE(acceptEndpoint);
            AfdDisconnectEventHandler(
                NULL,
                connection,
                0,
                NULL,
                0,
                NULL,
                TDI_DISCONNECT_ABORT
                );

            ASSERT( InterlockedDecrement( &acceptEndpoint->ObReferenceBias ) >= 0 );
            ObDereferenceObject( acceptFileObject );
            //
            // After dereferencing file object we shouldn't be accessing it
            // or associated endpoint structure
            //
        }
    }
    else {
        // this could happed if transmit file cleaned up the object
        // really quickly somehow,
        AfdReleaseSpinLock (&acceptEndpoint->SpinLock, &lockHandle);

        ASSERT( InterlockedDecrement( &acceptEndpoint->ObReferenceBias ) >= 0 );
        ObDereferenceObject( acceptFileObject );
        //
        // After dereferencing file object we shouldn't be accessing it
        // or associated endpoint structure
        //
    }

    //
    // Check if we have secondary MDL for local address query and
    // free it.
    //
    if (Irp->MdlAddress->Next!=NULL) {
        //
        // We never lock pages for this one (they are locked
        // as part of main MDL).
        //
        ASSERT (irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength>0);
        ASSERT ((Irp->MdlAddress->Next->MdlFlags & MDL_PAGES_LOCKED)==0);
        IoFreeMdl (Irp->MdlAddress->Next);
        Irp->MdlAddress->Next = NULL;
    }

    return STATUS_SUCCESS;

} // AfdRestartDelayedSuperAccept

NTSTATUS
AfdContinueSuperAccept (
    IN PIRP         Irp,
    PAFD_CONNECTION Connection
    )
/*++

Routine Description:

    Continues super accept IRP processing after the initial accept
    phase by requesting local address and/or first portion of the 
    received data.

Arguments:

    Irp - a pointer to the super accept IRP
    Connection - pointer to the accepted connection


Return Value:
    STATUS_SUCCESS if Irp processing is completed
    STATUS_MORE_PROCESSING_REQUIRED if it submits another request
        and processing will ocurr in the completion routine.

--*/

{
    PAFD_ENDPOINT       acceptEndpoint;
    PIO_STACK_LOCATION  irpSp;
    ULONG               length;


    //
    // Initialize locals
    //
    irpSp = IoGetCurrentIrpStackLocation (Irp);
    acceptEndpoint = irpSp->FileObject->FsContext;

    //
    // See if we need to get local address.
    //
    if (irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength>0) {

        ASSERT (Irp->MdlAddress->Next!=NULL);

        //
        // Get the MDL that describes local address part of the user buffer
        // The oritinal mdl chain address is safe in our stack location
        //
        Irp->MdlAddress = Irp->MdlAddress->Next;

        //
        // Unchain the address MDL from the receive MDL - we will
        // free it upon completion of the address query operation
        //
        ((PMDL)irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdMdlAddress)->Next = NULL;

        ASSERT (irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength
                    == MmGetMdlByteCount (Irp->MdlAddress));

        IoBuildPartialMdl (
                    irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdMdlAddress,
                    Irp->MdlAddress,
                    MmGetMdlVirtualAddress (Irp->MdlAddress),
                    MmGetMdlByteCount (Irp->MdlAddress)
                    );
                            

        TdiBuildQueryInformation(
            Irp,
            Connection->DeviceObject,
            Connection->FileObject,
            AfdRestartSuperAcceptGetAddress,
            Connection,
            TDI_QUERY_ADDRESS_INFO,
            Irp->MdlAddress
            );

        //
        // Perform the local address query.  We'll continue processing from
        // the completion routine.
        //

        AfdIoCallDriver( acceptEndpoint, Connection->DeviceObject, Irp );
        return STATUS_MORE_PROCESSING_REQUIRED;
    }
    //
    // See if want to get first portion of the data
    //
    else if (irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength>0) {
        PIO_STACK_LOCATION  nextIrpSp;

        ASSERT (Irp->MdlAddress->Next==NULL);
        //
        // Get the length of the receive portion of the buffer
        // and save the length of the MDL to restore in the completion routine
        // Set the length of the MDL to match that of the receive request
        //

        length = irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength;
        irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength =
                        MmGetMdlByteCount (Irp->MdlAddress);
        Irp->MdlAddress->ByteCount = length;

        //
        // Prepare the IRP to be used to receive the first chunk of data on
        // the connection.
        //
        // Also note that we send ourselves an IRP_MJ_READ IRP because
        // the I/O subsystem has already probed & locked the output buffer,
        // which just happens to look just like an IRP_MJ_READ IRP.
        //

        nextIrpSp = IoGetNextIrpStackLocation( Irp );

        nextIrpSp->FileObject = irpSp->FileObject;
        nextIrpSp->DeviceObject = IoGetRelatedDeviceObject( nextIrpSp->FileObject );
        nextIrpSp->MajorFunction = IRP_MJ_READ;

        nextIrpSp->Parameters.Read.Length = length;
        nextIrpSp->Parameters.Read.Key = 0;
        nextIrpSp->Parameters.Read.ByteOffset.QuadPart = 0;


        IoSetCompletionRoutine(
            Irp,
            AfdRestartSuperAcceptReceive,
            Connection,
            TRUE,
            TRUE,
            TRUE
            );


        //
        // Perform the receive.  We'll continue processing from
        // the completion routine.
        //

        AfdIoCallDriver( acceptEndpoint, nextIrpSp->DeviceObject, Irp );
        return STATUS_MORE_PROCESSING_REQUIRED;

    }

    Irp->IoStatus.Information = 0;

    if (Connection->Aborted && NT_SUCCESS (Irp->IoStatus.Status)) {
        Irp->IoStatus.Status = STATUS_CONNECTION_RESET;
    }

    if (NT_SUCCESS (Irp->IoStatus.Status) &&
            (Connection->RemoteAddress!=NULL) &&
            (KeInitializeApc (&acceptEndpoint->Common.VcConnecting.Apc,
                            PsGetThreadTcb (Irp->Tail.Overlay.Thread),
                            Irp->ApcEnvironment,
                            AfdSuperAcceptApcKernelRoutine,
                            AfdSuperAcceptApcRundownRoutine,
                            (PKNORMAL_ROUTINE)NULL,
                            KernelMode,
                            NULL
                            ),
                KeInsertQueueApc (&acceptEndpoint->Common.VcConnecting.Apc,
                            Irp,
                            Connection,
                            AfdPriorityBoost))) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }
    else {
        //
        // Dereference the accept file object and tell IO to complete this IRP.
        //

        ASSERT( InterlockedDecrement( &acceptEndpoint->ObReferenceBias ) >= 0 );

        ObDereferenceObject( irpSp->FileObject );

        //
        // After dereferencing file object we shouldn't be accessing it
        // or associated endpoint structure
        //
        DEREFERENCE_CONNECTION (Connection);
        return STATUS_SUCCESS;
    }

}


NTSTATUS
AfdRestartSuperAcceptGetAddress (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    The completion routine for the AFD wait for query local address
    portion of a super accept.

Arguments:

    DeviceObject - the devoce object on which the request is completing.

    Irp - The super accept IRP.

    Context - points to the accepted connection 

Return Value:

    STATUS_SUCCESS if the I/O system should complete the super accept
    request, or STATUS_MORE_PROCESSING_REQUIRED if the super accept
    request is still being processed.

--*/

{
    PAFD_ENDPOINT acceptEndpoint;
    PAFD_CONNECTION connection;

    PIO_STACK_LOCATION irpSp;

    UNREFERENCED_PARAMETER (DeviceObject);

    //
    // Initialize some locals.
    //

    irpSp = IoGetCurrentIrpStackLocation (Irp);

    acceptEndpoint = irpSp->FileObject->FsContext;
    ASSERT (IS_AFD_ENDPOINT_TYPE (acceptEndpoint));

    connection = Context;
    ASSERT (connection->Type==AfdBlockTypeConnection);
    ASSERT (connection->Endpoint==acceptEndpoint);

    AfdCompleteOutstandingIrp (acceptEndpoint, Irp);

    //
    // If pending has been returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending( Irp );
    }


    ASSERT (Irp->MdlAddress->MdlFlags & MDL_PARTIAL);
    IoFreeMdl( Irp->MdlAddress );

    //
    // Fix up the MDL pointer in the IRP and set local address length
    // to 0 to use the common routine for receive part of the super
    // accept Irp
    //

    Irp->MdlAddress = irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdMdlAddress;

    if (NT_SUCCESS (Irp->IoStatus.Status)) {
#ifndef i386
        if (acceptEndpoint->Common.VcConnecting.FixAddressAlignment) {
            PTDI_ADDRESS_INFO   addressInfo = (PVOID)
                    ((PUCHAR)MmGetSystemAddressForMdl(Irp->MdlAddress)
                        + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength);
            USHORT addressLength = addressInfo->Address.Address[0].AddressLength+sizeof(USHORT);
            USHORT UNALIGNED *pAddrLength = (PVOID)
                    ((PUCHAR)addressInfo 
                    +irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength
                    -sizeof(USHORT));
            RtlMoveMemory (addressInfo,
                            &addressInfo->Address.Address[0].AddressType,
                            addressLength);
            *pAddrLength = addressLength;
        }
#endif // ifndef i386
        irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength = 0;
        return AfdContinueSuperAccept (Irp, connection);
    }
    else {
        //
        // Dereference the accept file object and tell IO to complete this IRP.
        //

        ASSERT( InterlockedDecrement( &acceptEndpoint->ObReferenceBias ) >= 0 );

        ObDereferenceObject( irpSp->FileObject );
        //
        // After dereferencing file object we shouldn't be accessing it
        // or associated endpoint structure
        //
        DEREFERENCE_CONNECTION (connection);

        return STATUS_SUCCESS;
    }

} // AfdRestartSuperAcceptGetAddress


NTSTATUS
AfdRestartSuperAcceptReceive (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    The completion routine for the AFD receive portion of a super accept.

Arguments:

    DeviceObject - the devoce object on which the request is completing.

    Irp - The super accept IRP.

    Context - points to the accepted connection 

Return Value:

    STATUS_SUCCESS if the I/O system should complete the super accept
    request, or STATUS_MORE_PROCESSING_REQUIRED if the super accept
    request is still being processed.

--*/

{
    PAFD_ENDPOINT acceptEndpoint;
    PAFD_CONNECTION connection;

    PIO_STACK_LOCATION  irpSp;

    UNREFERENCED_PARAMETER (DeviceObject);

    //
    // Initialize some locals.
    //

    irpSp = IoGetCurrentIrpStackLocation (Irp);

    acceptEndpoint = irpSp->FileObject->FsContext;
    ASSERT (IS_AFD_ENDPOINT_TYPE (acceptEndpoint));

    connection = Context;
    ASSERT (connection->Type == AfdBlockTypeConnection);
    ASSERT (connection->Endpoint==acceptEndpoint);

    AfdCompleteOutstandingIrp (acceptEndpoint, Irp);


    //
    // Restore MDL length so that IO system can properly unmap 
    // and unlock it when it completes the IRP
    //

    ASSERT (Irp->MdlAddress!=NULL);
    ASSERT (Irp->MdlAddress->Next==NULL);
    Irp->MdlAddress->ByteCount = 
        irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength;

    //
    // If pending has been returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending( Irp );
    }




    if (NT_SUCCESS (Irp->IoStatus.Status) &&
            (connection->RemoteAddress!=NULL) &&
            (KeInitializeApc (&acceptEndpoint->Common.VcConnecting.Apc,
                            PsGetThreadTcb (Irp->Tail.Overlay.Thread),
                            Irp->ApcEnvironment,
                            AfdSuperAcceptApcKernelRoutine,
                            AfdSuperAcceptApcRundownRoutine,
                            (PKNORMAL_ROUTINE)NULL,
                            KernelMode,
                            NULL
                            ),
                KeInsertQueueApc (&acceptEndpoint->Common.VcConnecting.Apc,
                            Irp,
                            connection,
                            AfdPriorityBoost))) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }
    else {
        //
        // Dereference the accept file object and tell IO to complete this IRP.
        //

        ASSERT( InterlockedDecrement( &acceptEndpoint->ObReferenceBias ) >= 0 );

        ObDereferenceObject( irpSp->FileObject );

        //
        // After dereferencing file object we shouldn't be accessing it
        // or associated endpoint structure
        //
        DEREFERENCE_CONNECTION (connection);
        return STATUS_SUCCESS;
    }


} // AfdRestartSuperAcceptReceive

VOID
AfdSuperAcceptApcKernelRoutine (
    IN struct _KAPC         *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID            *NormalContext,
    IN OUT PVOID            *SystemArgument1,
    IN OUT PVOID            *SystemArgument2
    )
{
    PIRP            irp;
    PIO_STACK_LOCATION irpSp;
    PAFD_ENDPOINT   endpoint;
    PAFD_CONNECTION connection;
    PVOID   context;

    PAGED_CODE ();
    UNREFERENCED_PARAMETER (NormalContext);
#if DBG
    try {
        ASSERT (*NormalRoutine == NULL);
#else
        UNREFERENCED_PARAMETER (NormalRoutine);
#endif



    endpoint = CONTAINING_RECORD (Apc, AFD_ENDPOINT, Common.VcConnecting.Apc);
    ASSERT (IS_AFD_ENDPOINT_TYPE (endpoint));

    irp = *SystemArgument1;
    irpSp = IoGetCurrentIrpStackLocation( irp );
    ASSERT (irpSp->FileObject->FsContext==endpoint);

    connection = *SystemArgument2;
    ASSERT( connection->Type == AfdBlockTypeConnection );

    ASSERT (connection->Endpoint==endpoint);

    //
    // Copy remote address to the user mode context
    //
    context = AfdLockEndpointContext (endpoint);
    if ( (((CLONG)(endpoint->Common.VcConnecting.RemoteSocketAddressOffset+
                endpoint->Common.VcConnecting.RemoteSocketAddressLength)) <
                endpoint->ContextLength) &&
            (endpoint->Common.VcConnecting.RemoteSocketAddressLength >=
                connection->RemoteAddress->Address[0].AddressLength +
                                          sizeof(u_short))) {

        RtlMoveMemory ((PUCHAR)context +
                            endpoint->Common.VcConnecting.RemoteSocketAddressOffset,
            &connection->RemoteAddress->Address[0].AddressType,
            connection->RemoteAddress->Address[0].AddressLength +
                                          sizeof(u_short));
    }
    else {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
            "AfdSuperAcceptApcKernelRoutine: Could not copy remote address for AcceptEx on endpoint: %p, process: %p\n",
                        endpoint, endpoint->OwningProcess));
    }
    AfdUnlockEndpointContext (endpoint, context);

    AFD_RETURN_REMOTE_ADDRESS (
            connection->RemoteAddress,
            connection->RemoteAddressLength
            );
    connection->RemoteAddress = NULL;

    //
    // Dereference the accept file object and tell IO to complete this IRP.
    //

    ASSERT( InterlockedDecrement( &endpoint->ObReferenceBias ) >= 0 );

    ObDereferenceObject( irpSp->FileObject );

    //
    // After dereferencing file object we shouldn't be accessing it
    // or associated endpoint structure
    //
    DEREFERENCE_CONNECTION (connection);

    IoCompleteRequest (irp, AfdPriorityBoost);
#if DBG
    }
    except (AfdApcExceptionFilter (
                GetExceptionInformation(),
                (LPSTR)__FILE__,
                (LONG)__LINE__)) {
        DbgBreakPoint ();
    }
#endif

}

VOID
AfdSuperAcceptApcRundownRoutine (
    IN struct _KAPC *Apc
    )
{
    PIRP            irp;
    PIO_STACK_LOCATION irpSp;
    PAFD_ENDPOINT   endpoint;
    PAFD_CONNECTION connection;

    PAGED_CODE ();

    endpoint = CONTAINING_RECORD (Apc, AFD_ENDPOINT, Common.VcConnecting.Apc);
    ASSERT (IS_AFD_ENDPOINT_TYPE (endpoint));
    
    irp = Apc->SystemArgument1;
    irpSp = IoGetCurrentIrpStackLocation( irp );
    ASSERT (irpSp->FileObject->FsContext==endpoint);

    connection = Apc->SystemArgument2;
    ASSERT( connection->Type == AfdBlockTypeConnection );
    
    ASSERT (connection->Endpoint==endpoint);

    //
    // Dereference the accept file object and tell IO to complete this IRP.
    //

    ASSERT( InterlockedDecrement( &endpoint->ObReferenceBias ) >= 0 );

    ObDereferenceObject( irpSp->FileObject );

    //
    // After dereferencing file object we shouldn't be accessing it
    // or associated endpoint structure
    //
    DEREFERENCE_CONNECTION (connection);

    IoCompleteRequest (irp, AfdPriorityBoost);
}


NTSTATUS
FASTCALL
AfdDeferAccept (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Defers acceptance of an incoming connection for which an
    AFD_WAIT_FOR_LISTEN IOCTL has already completed. The caller
    may specify that the connection be deferred for later acceptance
    or rejected totally.

Arguments:

    Irp - a pointer to a transmit file IRP.

    IrpSp - Our stack location for this IRP.

Return Value:

    STATUS_SUCCESS if the request was completed successfully, or a
    failure status code if there was an error.

--*/

{
    NTSTATUS status;
    PAFD_DEFER_ACCEPT_INFO deferAcceptInfo;
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    //
    // Set up local variables.
    //

    endpoint = IrpSp->FileObject->FsContext;
    deferAcceptInfo = Irp->AssociatedIrp.SystemBuffer;

    Irp->IoStatus.Information = 0;

    //
    // Make sure that this request is valid.
    //

    if( !endpoint->Listening ||
        IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(AFD_DEFER_ACCEPT_INFO) ) {

        status = STATUS_INVALID_PARAMETER;
        goto complete;

    }

    ASSERT ((endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening);
    
    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
    //
    // Find the specified connection. If it cannot be found, then this
    // is a bogus request.
    //

    connection = AfdGetReturnedConnection(
                     endpoint,
                     deferAcceptInfo->Sequence
                     );

    if( connection == NULL ) {

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        status = STATUS_INVALID_PARAMETER;
        goto complete;

    }

    ASSERT( connection->Type == AfdBlockTypeConnection );

    //
    // If this is a request to reject the accepted connection, then
    // abort the connection. Otherwise (this is a request to defer
    // acceptance until later) then insert the connection at the *head*
    // of the endpoint's unaccepted connection queue.
    //

    if( deferAcceptInfo->Reject ) {


        //
        // Reenable the accept event bit, and if there are additional
        // unaccepted connections on the endpoint, post another event.
        //


        endpoint->EventsActive &= ~AFD_POLL_ACCEPT;

        IF_DEBUG(EVENT_SELECT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdDeferAccept: Endp %08lX, Active %08lX\n",
                endpoint,
                endpoint->EventsActive
                ));
        }

        if( !IsListEmpty( &endpoint->Common.VcListening.UnacceptedConnectionListHead ) ) {

            AfdIndicateEventSelectEvent(
                endpoint,
                AFD_POLL_ACCEPT,
                STATUS_SUCCESS
                );

        }

        //
        // Special handling for SAN connections
        //
        if (connection->SanConnection) {
            PIRP    connectIrp;
            //
            // Snag the connect indication IRP
            //
            connectIrp = connection->ConnectIrp;
            ASSERT (connectIrp!=NULL);
            connection->ConnectIrp = NULL;

            //
            // We can now release listen endpoint spinlock
            // The cancel routine will not find IRP in the connection
            //
            if (IoSetCancelRoutine (connectIrp, NULL)==NULL) {
                KIRQL   cancelIrql;
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                //
                // Cancel routine is running, make sure
                // it finishes before proceeding further
                //
                IoAcquireCancelSpinLock (&cancelIrql);
                IoReleaseCancelSpinLock (cancelIrql);
                connectIrp->IoStatus.Status = STATUS_CANCELLED;
            }
            else {
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                connectIrp->IoStatus.Status = STATUS_CONNECTION_REFUSED;
            }
                

            //
            // Return the connection and complete SAN provider IRP
            //

            connection->Endpoint = NULL;
            connection->SanConnection = FALSE;

            AfdSanReleaseConnection (endpoint, connection, FALSE);
            DEREFERENCE_ENDPOINT (endpoint);

            connectIrp->IoStatus.Information = 0;
            IoCompleteRequest (connectIrp, AfdPriorityBoost);
        }
        else {
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

            //
            // Abort the connection.
            //

            AfdAbortConnection( connection );

            //
            // Add another free connection to replace the one we're rejecting.
            // Also, add extra to account for past failures in calls to
            // AfdAddFreeConnection().
            //

            InterlockedIncrement(
                &endpoint->Common.VcListening.FailedConnectionAdds
                );

            AfdReplenishListenBacklog( endpoint );
        }

    } else {

        //
        // Restore the connection's state before putting it back
        // on the queue.
        //

        connection->State = AfdConnectionStateUnaccepted;

        InsertHeadList(
            &endpoint->Common.VcListening.UnacceptedConnectionListHead,
            &connection->ListEntry
            );
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
    }

    status = STATUS_SUCCESS;

complete:

    Irp->IoStatus.Status = status;
    ASSERT( Irp->CancelRoutine == NULL );

    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

} // AfdDeferAccept



NTSTATUS
AfdRestartDelayedAccept (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    The completion routine for the AFD wait for delayed accept IRP portion
    of an accept.

Arguments:

    DeviceObject - the devoce object on which the request is completing.

    Irp - The accept IRP.

    Context - points to accept file object

Return Value:

    STATUS_SUCCESS if the I/O system should complete the super accept
    request, or STATUS_MORE_PROCESSING_REQUIRED if the super accept
    request is still being processed.

--*/
{
    PIO_STACK_LOCATION  irpSp;
    PFILE_OBJECT    acceptFileObject;
    PAFD_ENDPOINT   acceptEndpoint;
    PAFD_CONNECTION connection;
    PAFD_ENDPOINT   listenEndpoint;
    AFD_LOCK_QUEUE_HANDLE   lockHandle;

    UNREFERENCED_PARAMETER (DeviceObject);
    
    acceptFileObject = Context;
    acceptEndpoint = acceptFileObject->FsContext;

    irpSp = IoGetCurrentIrpStackLocation (Irp);
    listenEndpoint = irpSp->FileObject->FsContext;

    //
    // Remember that a TDI accept has completed on this endpoint.
    //

    InterlockedDecrement(
        &listenEndpoint->Common.VcListening.TdiAcceptPendingCount
        );

    AfdCompleteOutstandingIrp (acceptEndpoint, Irp);

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending( Irp );
    }

    AfdAcquireSpinLock (&acceptEndpoint->SpinLock, &lockHandle);
    //
    // The AFD connection object should now be in the endpoiont.
    //

    connection = AFD_CONNECTION_FROM_ENDPOINT( acceptEndpoint );
    if (connection!=NULL) {
        if (NT_SUCCESS (Irp->IoStatus.Status)) {
            acceptEndpoint->State = AfdEndpointStateConnected;
            connection->State = AfdConnectionStateConnected;
            acceptEndpoint->EventsActive |= AFD_POLL_SEND;
            acceptEndpoint->EnableSendEvent = TRUE;
            AfdReleaseSpinLock (&acceptEndpoint->SpinLock, &lockHandle);
            AFD_END_STATE_CHANGE (acceptEndpoint);
        }
        else {
            //
            // If the accept failed, treat it like an abortive disconnect.
            // This way the application still gets a new endpoint, but it gets
            // told about the reset.
            //
            REFERENCE_CONNECTION (connection);

            AfdReleaseSpinLock (&acceptEndpoint->SpinLock, &lockHandle);

            AFD_END_STATE_CHANGE (acceptEndpoint);

            AfdDisconnectEventHandler(
                NULL,
                connection,
                0,
                NULL,
                0,
                NULL,
                TDI_DISCONNECT_ABORT
                );
            DEREFERENCE_CONNECTION (connection);
        }
    }


    ASSERT( InterlockedDecrement( &acceptEndpoint->ObReferenceBias ) >= 0 );

    ObDereferenceObject( acceptFileObject );

    Irp->AssociatedIrp.SystemBuffer = irpSp->Parameters.AfdRestartDelayedAcceptInfo.AfdSystemBuffer;

    return STATUS_SUCCESS;
}



VOID
AfdCleanupSuperAccept (
    IN PIRP     Irp,
    IN NTSTATUS Status
    )
/*++

Routine Description:

    Cleans up a super accept IRP and prepeares it for completion

Arguments:

    Irp - the IRP to cleanup.
    Status - failure status

Return Value:

    None.

--*/

{

    PAFD_ENDPOINT listenEndpoint;
    PFILE_OBJECT  acceptFileObject;
    PAFD_ENDPOINT acceptEndpoint;
    PIO_STACK_LOCATION  irpSp;
    AFD_LOCK_QUEUE_HANDLE  lockHandle;

    ASSERT (!NT_SUCCESS (Status));
    //
    // Initialize some locals.
    //

    irpSp = IoGetCurrentIrpStackLocation (Irp);
    listenEndpoint = irpSp->FileObject->FsContext;

    //
    // Reduce the count of failed connection adds on the listening
    // endpoint to account for this connection object which we're
    // adding back onto the queue once it is pulled from pre-accepted connection
    // list.
    //
    InterlockedDecrement (&listenEndpoint->Common.VcListening.FailedConnectionAdds);


    acceptFileObject = irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdAcceptFileObject;
    acceptEndpoint = acceptFileObject->FsContext;
    ASSERT (IS_AFD_ENDPOINT_TYPE (acceptEndpoint));

    //
    // Cleanup super accept IRP out of endpoint.
    //
    AfdAcquireSpinLock (&acceptEndpoint->SpinLock, &lockHandle);
    ASSERT (acceptEndpoint->Irp==Irp); // May need to remove this assert 
                                       // in the future.
    acceptEndpoint->Irp = NULL;
    AfdReleaseSpinLock (&acceptEndpoint->SpinLock, &lockHandle);

    //
    // Mark the end of state change letting the endpoint
    // to be used again in state change operation (e.g. accept).
    //

    AFD_END_STATE_CHANGE (acceptEndpoint);

    //
    // Dereference accept file object
    //
    ASSERT( InterlockedDecrement( &acceptEndpoint->ObReferenceBias ) >= 0 );

    ObDereferenceObject( acceptFileObject );

    //
    // Check if we have secondary MDL for local address query and
    // free it.
    //
    if (Irp->MdlAddress->Next!=NULL) {
        //
        // We never lock pages for this one (they are locked
        // as part of main MDL).
        //
        ASSERT (irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength>0);
        ASSERT ((Irp->MdlAddress->Next->MdlFlags & MDL_PAGES_LOCKED)==0);
        IoFreeMdl (Irp->MdlAddress->Next);
        Irp->MdlAddress->Next = NULL;
    }

   
    //
    // Set the status specified in the IRP and return
    // The caller will eventually complete it.
    //

    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = 0;

    return;
}


VOID
AfdCancelSuperAccept (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Cancels a super accept IRP that is pended in AFD.

Arguments:

    DeviceObject - not used.

    Irp - the IRP to cancel.

Return Value:

    None.

--*/

{
    PAFD_CONNECTION connection;

    UNREFERENCED_PARAMETER (DeviceObject);

    connection = Irp->Tail.Overlay.DriverContext[0];
    ASSERT (connection->Type==AfdBlockTypeConnection);
    ASSERT (connection->Endpoint==NULL);
    //
    // If IRP is in the connection object, cleanup and complete it
    //
    if (InterlockedExchangePointer (
                (PVOID *)&connection->AcceptIrp, 
                NULL)==Irp) {
        IoReleaseCancelSpinLock( Irp->CancelIrql );
        AfdCleanupSuperAccept (Irp, STATUS_CANCELLED);
        IoCompleteRequest( Irp, AfdPriorityBoost );

    }
    else {
        IoReleaseCancelSpinLock( Irp->CancelIrql );
    }

    return;
}


BOOLEAN
AfdServiceSuperAccept (
    IN  PAFD_ENDPOINT   Endpoint,
    IN  PAFD_CONNECTION Connection,
    IN  PAFD_LOCK_QUEUE_HANDLE LockHandle,
    OUT PLIST_ENTRY     AcceptIrpList
    )
/*++

Routine Description:

    Attemts to satisfy super accept irp using the incoming
    connection. This routine must be called with listening endpoint
    spinlock held.

Arguments:

    Endpoint - listening endpoint on which connection is
                being accepted
    Connection - connection being accepted.
    AcceptIrpList - returns a list of accept Irps which were failed and 
                    need to be completed after listening endpoint spinlock
                    is released.


Return Value:

    TRUE - the super accept IRP was found and is in the head of the list
    FALSE - no usable super accept IRP exists.

--*/

 
{
    PSLIST_ENTRY        listEntry;
    PIRP                acceptIrp;
    PAFD_CONNECTION     oldConnection;

    //
    // Keep removing super accept IRPs while there are any there
    //
    while ((listEntry = InterlockedPopEntrySList (
                 &Endpoint->Common.VcListening.PreacceptedConnectionsListHead
                 ))!=NULL) {
        NTSTATUS            status;

        //
        // Find the connection pointer from the list entry and return a
        // pointer to the connection object.
        //

        oldConnection = CONTAINING_RECORD(
                         listEntry,
                         AFD_CONNECTION,
                         SListEntry
                         );

        acceptIrp = InterlockedExchangePointer ((PVOID *)&oldConnection->AcceptIrp, NULL);
        //
        // Check if there is accept irp associated with
        // this connection, if not just put it back on the free list
        // (the IRP must have been cancelled)
        //
        if (acceptIrp!=NULL) {
            if (IoSetCancelRoutine (acceptIrp, NULL)!=NULL) {

                PFILE_OBJECT            acceptFileObject;
                PAFD_ENDPOINT           acceptEndpoint;
                PIO_STACK_LOCATION      irpSp;

                //
                // Initialize some locals.
                //

                irpSp = IoGetCurrentIrpStackLocation (acceptIrp);
                acceptFileObject = irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdAcceptFileObject;
                acceptEndpoint = acceptFileObject->FsContext;
                ASSERT (IS_AFD_ENDPOINT_TYPE (acceptEndpoint));

                //
                // Check if super accept Irp has enough space for
                // the remote address
                //
                if (Connection->RemoteAddressLength>
                        irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdRemoteAddressLength) {
                
                    status = STATUS_BUFFER_TOO_SMALL;

                }
                //
                // Check if we have enough system PTE's to map
                // the buffer.
                //
                else if ((status = AfdMapMdlChain (acceptIrp->MdlAddress)),
                            !NT_SUCCESS (status)) {
                    NOTHING;
                }
                else if (Connection->SanConnection) {
                    status = AfdSanAcceptCore (acceptIrp, acceptFileObject, Connection, LockHandle);
                    if (status==STATUS_PENDING) {
                        //
                        // Accept IRP is pending waiting for Switch
                        // completion notification
                        // Release old connection object
                        //
                        ASSERT (oldConnection->Endpoint==NULL);
                        InterlockedPushEntrySList (
                            &Endpoint->Common.VcListening.FreeConnectionListHead,
                            &oldConnection->SListEntry);


                    }
                    else {
                        //
                        // Something failed, we need to complete accept IRP
                        //
                        ASSERT (NT_ERROR (status));
                        AfdCleanupSuperAccept (acceptIrp, status);
                        IoCompleteRequest (acceptIrp, AfdPriorityBoost);
                        //
                        // This connection has already been diassociated from endpoint.
                        // If backlog is below the level we need, put it on the free
                        // list, otherwise, get rid of it.
                        //

                        ASSERT (oldConnection->Endpoint==NULL);
                        if (InterlockedIncrement (&Endpoint->Common.VcListening.FailedConnectionAdds)>0) {
                            InterlockedDecrement (&Endpoint->Common.VcListening.FailedConnectionAdds);
                            InterlockedPushEntrySList (
                                            &Endpoint->Common.VcListening.FreeConnectionListHead,
                                            &oldConnection->SListEntry);
                        }
                        else {
                            DEREFERENCE_CONNECTION (oldConnection);
                        }
                    }
                    //
                    // Complete previously failed accept irps if any.
                    //
                    while (!IsListEmpty (AcceptIrpList)) {
                        PIRP    irp;
                        irp = CONTAINING_RECORD (AcceptIrpList->Flink, IRP, Tail.Overlay.ListEntry);
                        RemoveEntryList (&irp->Tail.Overlay.ListEntry);
                        IoCompleteRequest (irp, AfdPriorityBoost);
                    }
                    return TRUE;
                }
                //
                // Allocate MDL for local address query if requested
                //
                else if ((irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength>0) &&
                    (IoAllocateMdl ((PUCHAR)acceptIrp->UserBuffer+irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength,
                                    irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength,
                                    TRUE,
                                    FALSE,
                                    acceptIrp)==NULL)){
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
                else {
                    //
                    // Copy over the address information to the user's buffer.
                    //
#ifndef i386
                    if (acceptEndpoint->Common.VcConnecting.FixAddressAlignment) {
                        USHORT addressLength = 
                                Connection->RemoteAddress->Address[0].AddressLength
                                + sizeof (USHORT);
                        USHORT UNALIGNED *pAddrLength = (PVOID)
                                    ((PUCHAR)MmGetSystemAddressForMdl (acceptIrp->MdlAddress)
                                     + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                                     + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength
                                     + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdRemoteAddressLength
                                     - sizeof (USHORT));
                        RtlMoveMemory (
                                    (PUCHAR)MmGetSystemAddressForMdl (acceptIrp->MdlAddress)
                                     + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                                     + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength,
                                     &Connection->RemoteAddress->Address[0].AddressType,
                                     addressLength);
                        *pAddrLength = addressLength;
                    }
                    else
#endif
                    {
                        RtlMoveMemory (
                                    (PUCHAR)MmGetSystemAddressForMdl (acceptIrp->MdlAddress)
                                     + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                                     + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength,
                                     Connection->RemoteAddress,
                                     Connection->RemoteAddressLength);
                    }
                    status = AfdAcceptCore (acceptIrp, acceptEndpoint, Connection);
                    if (status==STATUS_SUCCESS) {
                        AfdReleaseSpinLock (&Endpoint->SpinLock, LockHandle);


                        //
                        // Decrement counter to account for connection being
                        // returned to the free pool.  No need to do this because
                        // we are picking up a connection from the free pool
                        // InterlockedDecrement (&Endpoint->Common.VcListening.FailedConnectionAdds);
                        //
                        ASSERT (oldConnection->Endpoint==NULL);
                        InterlockedPushEntrySList (
                            &Endpoint->Common.VcListening.FreeConnectionListHead,
                            &oldConnection->SListEntry);



                        //
                        // Complete previously failed accept irps if any.
                        //
                        while (!IsListEmpty (AcceptIrpList)) {
                            PIRP    irp;
                            irp = CONTAINING_RECORD (AcceptIrpList->Flink, IRP, Tail.Overlay.ListEntry);
                            RemoveEntryList (&irp->Tail.Overlay.ListEntry);
                            IoCompleteRequest (irp, AfdPriorityBoost);
                        }

                        //
                        // Make irp look like it is completed by the
                        // transport.
                        //
                        acceptIrp->IoStatus.Status = STATUS_SUCCESS;
                        irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdMdlAddress = acceptIrp->MdlAddress;
                        acceptIrp->MdlAddress = NULL;
                        irpSp->FileObject = acceptFileObject;

                        //
                        // Call completion routine directly to simulate
                        // completion by the transport stack
                        //
                        AfdRestartSuperAcceptListen (acceptIrp, Connection);

                        return TRUE;
                    }
                    else {
                        ASSERT (status!=STATUS_PENDING);
                    }
                }
            }
            else { // if (IoSetCancelRoutine (accpetIrp, NULL)!=NULL)
                status = STATUS_CANCELLED;
            }

            //
            // Cleanup the IRP and insert it into the completion list
            //
            AfdCleanupSuperAccept (acceptIrp, status);
            InsertTailList (AcceptIrpList,
                            &acceptIrp->Tail.Overlay.ListEntry);
        } // if (acceptIrp!=NULL)
        else {
            status = STATUS_CANCELLED;
        }
            
        //
        // This connection has already been diassociated from endpoint.
        // If backlog is below the level we need, put it on the free
        // list, otherwise, get rid of it.
        //

        ASSERT (oldConnection->Endpoint==NULL);
        if (Endpoint->Common.VcListening.FailedConnectionAdds>=0 &&
                status!=STATUS_INSUFFICIENT_RESOURCES &&
                ExQueryDepthSList (&Endpoint->Common.VcListening.FreeConnectionListHead)<AFD_MAXIMUM_FREE_CONNECTIONS) {
            InterlockedPushEntrySList (
                            &Endpoint->Common.VcListening.FreeConnectionListHead,
                            &oldConnection->SListEntry);
        }
        else {
            InterlockedIncrement (&Endpoint->Common.VcListening.FailedConnectionAdds);
            DEREFERENCE_CONNECTION (oldConnection);
        }
    }

    return FALSE;
}


NTSTATUS
AfdSetupAcceptEndpoint (
    PAFD_ENDPOINT   ListenEndpoint,
    PAFD_ENDPOINT   AcceptEndpoint,
    PAFD_CONNECTION Connection
    )
/*++

Routine Description:

    Sets up the accept endpoint to get ready to accept connection
    (copies parameters of the listening endpoint on which connection
    was indicated)

Arguments:

    ListenEndpoint   - endpoint on which connection was indicated
    AcceptEndpoint   - endpoint on which to accept the connection
    Connection       - connection to accept

Return Value:

    STATUS_SUCCESS   - endpoint state/parameters adjusted OK
    STATUS_CANCELLED - endpoint has already been cleaned up.

Note:
    Accepting endpoint spinlock must be held when calling this routine.
    Listen endpoint spinlock needs to be held only if connection has already
    been accepted (transport was told to accept it).  This is necessary
    to synchronize with receive indication handler since it uses endpoint
    spinlock pointed to by the connection structure and we switch this pointer
    inside this routine.

--*/
{
    //
    // Check the state of the accepting endpoint.
    //


    if ( AcceptEndpoint->EndpointCleanedUp ) {
        return STATUS_CANCELLED;
    }


    //
    // Note that the returned connection structure already has a
    // referenced pointer to the listening endpoint. Rather than
    // removing the reference here, only to re-add it later, we'll
    // just not touch the reference count.
    //

    ASSERT( Connection->Endpoint == ListenEndpoint );

    //
    // Set up the accept endpoint.  Note that we already have a reference to
    // the endpoint by the virtue of its file object
    //

    //
    // Place the connection on the endpoint we'll accept it on.  It is
    // still referenced from when it was created.
    //

    AcceptEndpoint->Common.VcConnecting.Connection = Connection;

    //
    // Remove super accept IRP from the endpoint
    //
    AcceptEndpoint->Irp = NULL;

    //
    // Set up the accept endpoint's type, and remember blocking
    // characteristics of the TDI provider.
    //

    AcceptEndpoint->Type = AfdBlockTypeVcConnecting;
    AcceptEndpoint->TdiServiceFlags = ListenEndpoint->TdiServiceFlags;

    ASSERT (AcceptEndpoint->TransportInfo == ListenEndpoint->TransportInfo);
    ASSERT (AcceptEndpoint->TransportInfo->ReferenceCount>0);


    //
    // Set up a referenced pointer to the listening endpoint.  This is
    // necessary so that the endpoint does not go away until all
    // accepted endpoints have gone away.  Without this, a connect
    // indication could occur on a TDI address object held open
    // by an accepted endpoint after the listening endpoint has
    // been closed and the memory for it deallocated.
    //
    // Note that, since we didn't remove the reference above, we don't
    // need to add it here.
    //

    AcceptEndpoint->Common.VcConnecting.ListenEndpoint = ListenEndpoint;

    //
    // Set up a referenced pointer in the accepted endpoint to the
    // TDI address object.
    //

    ObReferenceObject( ListenEndpoint->AddressFileObject );
    AfdRecordAddrRef();

    AcceptEndpoint->AddressFileObject = ListenEndpoint->AddressFileObject;
    AcceptEndpoint->AddressDeviceObject = ListenEndpoint->AddressDeviceObject;

    //
    // Copy the pointer to the local address. Because we keep listen
    // endpoint alive for as long as any of its connection is
    // active, we can rely on the fact that address structure won't go
    // away as well.
    //
    AcceptEndpoint->LocalAddress = ListenEndpoint->LocalAddress;
    AcceptEndpoint->LocalAddressLength = ListenEndpoint->LocalAddressLength;

    //
    // Set up a referenced pointer from the connection to the accept
    // endpoint.  
    //
    REFERENCE_ENDPOINT( AcceptEndpoint );
    Connection->Endpoint = AcceptEndpoint;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\afddata.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    afddata.c

Abstract:

    This module contains global data for AFD.

Author:

    David Treadwell (davidtr)    21-Feb-1992

Revision History:
    Vadim Eydelman (vadime)
        1998-1999   NT5.0 Optimization changes

--*/

#include "afdp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, AfdInitializeData )
#endif

PDEVICE_OBJECT AfdDeviceObject;

LIST_ENTRY AfdEndpointListHead;
LIST_ENTRY AfdConstrainedEndpointListHead;

LIST_ENTRY AfdPollListHead;
AFD_QSPIN_LOCK AfdPollListLock;

LIST_ENTRY AfdTransportInfoListHead;
KEVENT     AfdContextWaitEvent;

PKPROCESS AfdSystemProcess;

//
// Global data which must always be in nonpaged pool,
// even when the driver is paged out (resource, lookaside lists).
//
PAFD_GLOBAL_DATA AfdGlobalData;

//
// Globals for dealing with AFD's executive worker thread.
//

LIST_ENTRY AfdWorkQueueListHead;
BOOLEAN AfdWorkThreadRunning = FALSE;
PIO_WORKITEM AfdWorkQueueItem;

//
// Globals to track the buffers used by AFD.
//

ULONG AfdLargeBufferListDepth;
ULONG AfdMediumBufferListDepth;
ULONG AfdSmallBufferListDepth;
ULONG AfdBufferTagListDepth;

ULONG AfdLargeBufferSize;   // default == AfdBufferLengthForOnePage
ULONG AfdMediumBufferSize = AFD_DEFAULT_MEDIUM_BUFFER_SIZE;
ULONG AfdSmallBufferSize = AFD_DEFAULT_SMALL_BUFFER_SIZE;
ULONG AfdBufferTagSize = AFD_DEFAULT_TAG_BUFFER_SIZE;

ULONG AfdCacheLineSize;
ULONG AfdBufferLengthForOnePage;
ULONG AfdBufferOverhead;
ULONG AfdBufferAlignment;
ULONG AfdAlignmentTableSize;
ULONG AfdAlignmentOverhead;

//
// Globals for tuning TransmitFile().
//

LIST_ENTRY AfdQueuedTransmitFileListHead;
AFD_QSPIN_LOCK AfdQueuedTransmitFileSpinLock;
ULONG AfdActiveTransmitFileCount;
ULONG AfdMaxActiveTransmitFileCount;
ULONG AfdDefaultTransmitWorker = AFD_DEFAULT_TRANSMIT_WORKER;

//
// Various pieces of configuration information, with default values.
//

ULONG AfdReceiveWindowSize;
ULONG AfdSendWindowSize;

ULONG AfdStandardAddressLength = AFD_DEFAULT_STD_ADDRESS_LENGTH;
CCHAR AfdIrpStackSize = AFD_DEFAULT_IRP_STACK_SIZE;
CCHAR AfdTdiStackSize = AFD_DEFAULT_IRP_STACK_SIZE-1;
#ifdef _AFD_VARIABLE_STACK_
CCHAR AfdMaxStackSize = AFD_DEFAULT_IRP_STACK_SIZE-1;
#endif // _AFD_VARIABLE_STACK_
CCHAR AfdPriorityBoost = AFD_DEFAULT_PRIORITY_BOOST;

ULONG AfdBlockingSendCopyThreshold = AFD_BLOCKING_SEND_COPY_THRESHOLD;
ULONG AfdFastSendDatagramThreshold = AFD_FAST_SEND_DATAGRAM_THRESHOLD;
ULONG AfdTPacketsCopyThreshold = AFD_TPACKETS_COPY_THRESHOLD;

ULONG AfdTransmitIoLength;
ULONG AfdMaxFastTransmit = AFD_DEFAULT_MAX_FAST_TRANSMIT;
ULONG AfdMaxFastCopyTransmit = AFD_DEFAULT_MAX_FAST_COPY_TRANSMIT;


LONG AfdEndpointsOpened = 0;
LONG AfdEndpointsCleanedUp = 0;
LONG AfdEndpointsClosed = 0;
LONG AfdEndpointsFreeing = 0;
LONG AfdConnectionsFreeing = 0;

BOOLEAN AfdIgnorePushBitOnReceives = FALSE;

BOOLEAN AfdEnableDynamicBacklog = AFD_DEFAULT_ENABLE_DYNAMIC_BACKLOG;
LONG AfdMinimumDynamicBacklog = AFD_DEFAULT_MINIMUM_DYNAMIC_BACKLOG;
LONG AfdMaximumDynamicBacklog = AFD_DEFAULT_MAXIMUM_DYNAMIC_BACKLOG;
LONG AfdDynamicBacklogGrowthDelta = AFD_DEFAULT_DYNAMIC_BACKLOG_GROWTH_DELTA;

PSECURITY_DESCRIPTOR AfdAdminSecurityDescriptor = NULL;
SECURITY_DESCRIPTOR  AfdEmptySd;
BOOLEAN AfdDisableRawSecurity = FALSE;

BOOLEAN AfdDisableDirectSuperAccept = FALSE;
BOOLEAN AfdDisableChainedReceive = FALSE;
#ifdef TDI_SERVICE_SEND_AND_DISCONNECT
BOOLEAN AfdUseTdiSendAndDisconnect = TRUE;
#endif //TDI_SERVICE_SEND_AND_DISCONNECT

ULONG   AfdDefaultTpInfoElementCount = 3;
//
// Data for transport address lists and queued change queries
//
HANDLE          AfdBindingHandle = NULL;
LIST_ENTRY      AfdAddressEntryList;
LIST_ENTRY      AfdAddressChangeList;
PERESOURCE      AfdAddressListLock = NULL;
AFD_QSPIN_LOCK  AfdAddressChangeLock;
PERESOURCE      AfdTdiPnPHandlerLock = NULL;
AFD_WORK_ITEM   AfdPnPDeregisterWorker;



IO_STATUS_BLOCK AfdDontCareIoStatus;
// Holds TDI connect timeout (-1).
const LARGE_INTEGER AfdInfiniteTimeout = {(ULONG)-1,-1};

SLIST_HEADER    AfdLRList;
KDPC            AfdLRListDpc;
KTIMER          AfdLRListTimer;
AFD_WORK_ITEM   AfdLRListWorker;
LONG            AfdLRListCount;

SLIST_HEADER    AfdLRFileMdlList;
AFD_LR_LIST_ITEM AfdLRFileMdlListItem;


//
// Global which holds AFD's discardable code handle, and a BOOLEAN
// that tells whether AFD is loaded.
//

PVOID AfdDiscardableCodeHandle;
PKEVENT AfdLoaded = NULL;
AFD_WORK_ITEM AfdUnloadWorker;
BOOLEAN AfdVolatileConfig=0;
HANDLE AfdParametersNotifyHandle;
WORK_QUEUE_ITEM AfdParametersNotifyWorker;
PKEVENT AfdParametersUnloadEvent = NULL;

// SAN code segment handle, loaded only when SAN support is needed by the app.
HANDLE AfdSanCodeHandle = NULL;
// List of SAN helper endpoints
LIST_ENTRY AfdSanHelperList;
// San helper endpoint for special service process used for socket handle
// duplication and provider change notifications.
PAFD_ENDPOINT   AfdSanServiceHelper = NULL;
// PID of service process.
HANDLE  AfdSanServicePid = NULL;
// Completion object type (kernel does not export this constant)
POBJECT_TYPE IoCompletionObjectType = NULL;
// Provider list sequence number.
LONG AfdSanProviderListSeqNum = 0;

FAST_IO_DISPATCH AfdFastIoDispatch =
{
    sizeof (FAST_IO_DISPATCH), // SizeOfFastIoDispatch
    NULL,                      // FastIoCheckIfPossible
    AfdFastIoRead,             // FastIoRead
    AfdFastIoWrite,            // FastIoWrite
    NULL,                      // FastIoQueryBasicInfo
    NULL,                      // FastIoQueryStandardInfo
    NULL,                      // FastIoLock
    NULL,                      // FastIoUnlockSingle
    AfdSanFastUnlockAll,       // FastIoUnlockAll
    NULL,                      // FastIoUnlockAllByKey
    AfdFastIoDeviceControl     // FastIoDeviceControl
};

//
// Lookup table to verify incoming IOCTL codes.
//

ULONG AfdIoctlTable[AFD_NUM_IOCTLS] =
        {
            IOCTL_AFD_BIND,
            IOCTL_AFD_CONNECT,
            IOCTL_AFD_START_LISTEN,
            IOCTL_AFD_WAIT_FOR_LISTEN,
            IOCTL_AFD_ACCEPT,
            IOCTL_AFD_RECEIVE,
            IOCTL_AFD_RECEIVE_DATAGRAM,
            IOCTL_AFD_SEND,
            IOCTL_AFD_SEND_DATAGRAM,
            IOCTL_AFD_POLL,
            IOCTL_AFD_PARTIAL_DISCONNECT,
            IOCTL_AFD_GET_ADDRESS,
            IOCTL_AFD_QUERY_RECEIVE_INFO,
            IOCTL_AFD_QUERY_HANDLES,
            IOCTL_AFD_SET_INFORMATION,
            IOCTL_AFD_GET_REMOTE_ADDRESS,
            IOCTL_AFD_GET_CONTEXT,
            IOCTL_AFD_SET_CONTEXT,
            IOCTL_AFD_SET_CONNECT_DATA,
            IOCTL_AFD_SET_CONNECT_OPTIONS,
            IOCTL_AFD_SET_DISCONNECT_DATA,
            IOCTL_AFD_SET_DISCONNECT_OPTIONS,
            IOCTL_AFD_GET_CONNECT_DATA,
            IOCTL_AFD_GET_CONNECT_OPTIONS,
            IOCTL_AFD_GET_DISCONNECT_DATA,
            IOCTL_AFD_GET_DISCONNECT_OPTIONS,
            IOCTL_AFD_SIZE_CONNECT_DATA,
            IOCTL_AFD_SIZE_CONNECT_OPTIONS,
            IOCTL_AFD_SIZE_DISCONNECT_DATA,
            IOCTL_AFD_SIZE_DISCONNECT_OPTIONS,
            IOCTL_AFD_GET_INFORMATION,
            IOCTL_AFD_TRANSMIT_FILE,
            IOCTL_AFD_SUPER_ACCEPT,
            IOCTL_AFD_EVENT_SELECT,
            IOCTL_AFD_ENUM_NETWORK_EVENTS,
            IOCTL_AFD_DEFER_ACCEPT,
            IOCTL_AFD_WAIT_FOR_LISTEN_LIFO,
            IOCTL_AFD_SET_QOS,
            IOCTL_AFD_GET_QOS,
            IOCTL_AFD_NO_OPERATION,
            IOCTL_AFD_VALIDATE_GROUP,
            IOCTL_AFD_GET_UNACCEPTED_CONNECT_DATA,
            IOCTL_AFD_ROUTING_INTERFACE_QUERY,
            IOCTL_AFD_ROUTING_INTERFACE_CHANGE,
            IOCTL_AFD_ADDRESS_LIST_QUERY,
            IOCTL_AFD_ADDRESS_LIST_CHANGE,
            IOCTL_AFD_JOIN_LEAF,
            0,                         // AFD_TRANSPORT_IOCTL
            IOCTL_AFD_TRANSMIT_PACKETS,
            IOCTL_AFD_SUPER_CONNECT,
            IOCTL_AFD_SUPER_DISCONNECT,
            IOCTL_AFD_RECEIVE_MESSAGE,


            //
            // SAN Ioctls
            //
            IOCTL_AFD_SWITCH_CEMENT_SAN,
            IOCTL_AFD_SWITCH_SET_EVENTS,
            IOCTL_AFD_SWITCH_RESET_EVENTS,
            IOCTL_AFD_SWITCH_CONNECT_IND,
            IOCTL_AFD_SWITCH_CMPL_ACCEPT,
            IOCTL_AFD_SWITCH_CMPL_REQUEST,
            IOCTL_AFD_SWITCH_CMPL_IO,
            IOCTL_AFD_SWITCH_REFRESH_ENDP,
            IOCTL_AFD_SWITCH_GET_PHYSICAL_ADDR,
            IOCTL_AFD_SWITCH_ACQUIRE_CTX,
            IOCTL_AFD_SWITCH_TRANSFER_CTX,
            IOCTL_AFD_SWITCH_GET_SERVICE_PID,
            IOCTL_AFD_SWITCH_SET_SERVICE_PROCESS,
            IOCTL_AFD_SWITCH_PROVIDER_CHANGE,
            IOCTL_AFD_SWITCH_ADDRLIST_CHANGE
        };

//
// Table of IRP based IOCTLS.
//
PAFD_IRP_CALL AfdIrpCallDispatch[AFD_NUM_IOCTLS]= {
     AfdBind,                  // IOCTL_AFD_BIND
     AfdConnect,               // IOCTL_AFD_CONNECT,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_START_LISTEN,
     AfdWaitForListen,         // IOCTL_AFD_WAIT_FOR_LISTEN,
     AfdAccept,                // IOCTL_AFD_ACCEPT,
     AfdReceive,               // IOCTL_AFD_RECEIVE,
     AfdReceiveDatagram,       // IOCTL_AFD_RECEIVE_DATAGRAM,
     AfdSend,                  // IOCTL_AFD_SEND,
     AfdSendDatagram,          // IOCTL_AFD_SEND_DATAGRAM,
     AfdPoll,                  // IOCTL_AFD_POLL,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_PARTIAL_DISCONNECT,
     AfdGetAddress,            // IOCTL_AFD_GET_ADDRESS,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_QUERY_RECEIVE_INFO,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_QUERY_HANDLES,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SET_INFORMATION,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_GET_REMOTE_ADDRESS,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_GET_CONTEXT,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SET_CONTEXT,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SET_CONNECT_DATA,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SET_CONNECT_OPTIONS,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SET_DISCONNECT_DATA,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SET_DISCONNECT_OPTIONS,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_GET_CONNECT_DATA,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_GET_CONNECT_OPTIONS,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_GET_DISCONNECT_DATA,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_GET_DISCONNECT_OPTIONS,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SIZE_CONNECT_DATA,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SIZE_CONNECT_OPTIONS,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SIZE_DISCONNECT_DATA,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SIZE_DISCONNECT_OPTIONS,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_GET_INFORMATION,
     AfdTransmitFile,          // IOCTL_AFD_TRANSMIT_FILE,
     AfdSuperAccept,           // IOCTL_AFD_SUPER_ACCEPT,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_EVENT_SELECT,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_ENUM_NETWORK_EVENTS,
     AfdDeferAccept,           // IOCTL_AFD_DEFER_ACCEPT,
     AfdWaitForListen,         // IOCTL_AFD_WAIT_FOR_LISTEN_LIFO,
     AfdSetQos,                // IOCTL_AFD_SET_QOS,
     AfdGetQos,                // IOCTL_AFD_GET_QOS,
     AfdNoOperation,           // IOCTL_AFD_NO_OPERATION,
     AfdValidateGroup,         // IOCTL_AFD_VALIDATE_GROUP,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_GET_UNACCEPTED_CONNECT_DATA
     AfdDispatchImmediateIrp,  // IOCTL_AFD_ROUTING_INTERFACE_QUERY,
     AfdRoutingInterfaceChange,// IOCTL_AFD_ROUTING_INTERFACE_CHANGE,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_ADDRESS_LIST_QUERY,
     AfdAddressListChange,     // IOCTL_AFD_ADDRESS_LIST_CHANGE,
     AfdJoinLeaf,              // IOCTL_AFD_JOIN_LEAF,
     NULL,                     // IOCTL_AFD_TRANSPORT_IOCTL,
     AfdTransmitPackets,       // IOCTL_AFD_TRANSMIT_PACKETS 
     AfdSuperConnect,          // IOCTL_AFD_SUPER_CONNECT
     AfdSuperDisconnect,       // IOCTL_AFD_SUPER_DISCONNECT
     AfdReceiveDatagram,       // IOCTL_AFD_RECEIVE_MESSAGE

     AfdDispatchImmediateIrp,  // IOCTL_AFD_SWITCH_CEMENT_SAN
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SWITCH_SET_EVENTS
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SWITCH_RESET_EVENTS
     AfdSanConnectHandler,     // IOCTL_AFD_SWITCH_CONNECT_IND
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SWITCH_CMPL_ACCEPT
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SWITCH_CMPL_REQUEST
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SWITCH_CMPL_IO
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SWITCH_REFRESH_ENDP
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SWITCH_GET_PHYSICAL_ADDR
     AfdSanAcquireContext,     // IOCTL_AFD_SWITCH_ACQUIRE_CTX
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SWITCH_TRANSFER_CTX
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SWITCH_GET_SERVICE_PID
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SWITCH_SET_SERVICE_PROCESS
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SWITCH_PROVIDER_CHANGE
     AfdSanAddrListChange      // IOCTL_AFD_SWITCH_ADDRLIST_CHANGE
    };

//
// Table of immediate IOCTLS (can never be pended).
//
PAFD_IMMEDIATE_CALL AfdImmediateCallDispatch[AFD_NUM_IOCTLS]= {
     NULL,                     // IOCTL_AFD_BIND
     NULL,                     // IOCTL_AFD_CONNECT,
     AfdStartListen,           // IOCTL_AFD_START_LISTEN,
     NULL,                     // IOCTL_AFD_WAIT_FOR_LISTEN,
     NULL,                     // IOCTL_AFD_ACCEPT,
     NULL,                     // IOCTL_AFD_RECEIVE,
     NULL,                     // IOCTL_AFD_RECEIVE_DATAGRAM,
     NULL,                     // IOCTL_AFD_SEND,
     NULL,                     // IOCTL_AFD_SEND_DATAGRAM,
     NULL,                     // IOCTL_AFD_POLL,
     AfdPartialDisconnect,     // IOCTL_AFD_PARTIAL_DISCONNECT,
     NULL,                     // IOCTL_AFD_GET_ADDRESS,
     AfdQueryReceiveInformation,// IOCTL_AFD_QUERY_RECEIVE_INFO,
     AfdQueryHandles,          // IOCTL_AFD_QUERY_HANDLES,
     AfdSetInformation,        // IOCTL_AFD_SET_INFORMATION,
     AfdGetRemoteAddress,      // IOCTL_AFD_GET_REMOTE_ADDRESS,
     AfdGetContext,            // IOCTL_AFD_GET_CONTEXT,
     AfdSetContext,            // IOCTL_AFD_SET_CONTEXT,
     AfdSetConnectData,        // IOCTL_AFD_SET_CONNECT_DATA,
     AfdSetConnectData,        // IOCTL_AFD_SET_CONNECT_OPTIONS,
     AfdSetConnectData,        // IOCTL_AFD_SET_DISCONNECT_DATA,
     AfdSetConnectData,        // IOCTL_AFD_SET_DISCONNECT_OPTIONS,
     AfdGetConnectData,        // IOCTL_AFD_GET_CONNECT_DATA,
     AfdGetConnectData,        // IOCTL_AFD_GET_CONNECT_OPTIONS,
     AfdGetConnectData,        // IOCTL_AFD_GET_DISCONNECT_DATA,
     AfdGetConnectData,        // IOCTL_AFD_GET_DISCONNECT_OPTIONS,
     AfdSetConnectData,        // IOCTL_AFD_SIZE_CONNECT_DATA,
     AfdSetConnectData,        // IOCTL_AFD_SIZE_CONNECT_OPTIONS,
     AfdSetConnectData,        // IOCTL_AFD_SIZE_DISCONNECT_DATA,
     AfdSetConnectData,        // IOCTL_AFD_SIZE_DISCONNECT_OPTIONS,
     AfdGetInformation,        // IOCTL_AFD_GET_INFORMATION,
     NULL,                     // IOCTL_AFD_TRANSMIT_FILE,
     NULL,                     // IOCTL_AFD_SUPER_ACCEPT,
     AfdEventSelect,           // IOCTL_AFD_EVENT_SELECT,
     AfdEnumNetworkEvents,     // IOCTL_AFD_ENUM_NETWORK_EVENTS,
     NULL,                     // IOCTL_AFD_DEFER_ACCEPT,
     NULL,                     // IOCTL_AFD_WAIT_FOR_LISTEN_LIFO,
     NULL,                     // IOCTL_AFD_SET_QOS,
     NULL,                     // IOCTL_AFD_GET_QOS,
     NULL,                     // IOCTL_AFD_NO_OPERATION,
     NULL,                     // IOCTL_AFD_VALIDATE_GROUP,
     AfdGetUnacceptedConnectData,// IOCTL_AFD_GET_UNACCEPTED_CONNECT_DATA
     AfdRoutingInterfaceQuery, // IOCTL_AFD_ROUTING_INTERFACE_QUERY,
     NULL,                     // IOCTL_AFD_ROUTING_INTERFACE_CHANGE,
     AfdAddressListQuery,      // IOCTL_AFD_ADDRESS_LIST_QUERY,
     NULL,                     // IOCTL_AFD_ADDRESS_LIST_CHANGE,
     NULL,                     // IOCTL_AFD_JOIN_LEAF,
     NULL,                     // IOCTL_AFD_TRANSPORT_IOCTL,
     NULL,                     // IOCTL_AFD_TRANSMIT_PACKETS 
     NULL,                     // IOCTL_AFD_SUPER_CONNECT
     NULL,                     // IOCTL_AFD_SUPER_DISCONNECT
     NULL,                     // IOCTL_AFD_RECEIVE_MESSAGE

     AfdSanFastCementEndpoint, // IOCTL_AFD_SWITCH_CEMENT_SAN
     AfdSanFastSetEvents,      // IOCTL_AFD_SWITCH_SET_EVENTS
     AfdSanFastResetEvents,    // IOCTL_AFD_SWITCH_RESET_EVENTS
     NULL,                     // IOCTL_AFD_SWITCH_CONNECT_IND
     AfdSanFastCompleteAccept, // IOCTL_AFD_SWITCH_CMPL_ACCEPT
     AfdSanFastCompleteRequest,// IOCTL_AFD_SWITCH_CMPL_REQUEST
     AfdSanFastCompleteIo,     // IOCTL_AFD_SWITCH_CMPL_IO
     AfdSanFastRefreshEndpoint,// IOCTL_AFD_SWITCH_REFRESH_ENDP
     AfdSanFastGetPhysicalAddr,// IOCTL_AFD_SWITCH_GET_PHYSICAL_ADDR
     NULL,                     // IOCTL_AFD_SWITCH_ACQUIRE_CTX
     AfdSanFastTransferCtx,    // IOCTL_AFD_SWITCH_TRANSFER_CTX
     AfdSanFastGetServicePid,  // IOCTL_AFD_SWITCH_GET_SERVICE_PID
     AfdSanFastSetServiceProcess,// IOCTL_AFD_SWITCH_SET_SERVICE_PROCESS
     AfdSanFastProviderChange, // IOCTL_AFD_SWITCH_PROVIDER_CHANGE
     NULL                      // IOCTL_AFD_SWITCH_ADDRLIST_CHANGE
    };
//
// Make sure the above IOCTLs have method neither.
//
C_ASSERT ((IOCTL_AFD_START_LISTEN & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_PARTIAL_DISCONNECT & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_QUERY_RECEIVE_INFO & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_QUERY_HANDLES & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SET_INFORMATION & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_GET_REMOTE_ADDRESS & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_GET_CONTEXT & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SET_CONTEXT & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SET_CONNECT_DATA & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SET_CONNECT_OPTIONS & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SET_DISCONNECT_DATA & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SET_DISCONNECT_OPTIONS & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_GET_CONNECT_DATA & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_GET_CONNECT_OPTIONS & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_GET_DISCONNECT_DATA & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_GET_DISCONNECT_OPTIONS & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SIZE_CONNECT_DATA & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SIZE_CONNECT_OPTIONS & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SIZE_DISCONNECT_DATA & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SIZE_DISCONNECT_OPTIONS & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_GET_INFORMATION & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_EVENT_SELECT & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_ENUM_NETWORK_EVENTS & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_GET_UNACCEPTED_CONNECT_DATA & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_ADDRESS_LIST_QUERY & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_ROUTING_INTERFACE_QUERY & 3) == METHOD_NEITHER);

C_ASSERT ((IOCTL_AFD_SWITCH_CEMENT_SAN & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SWITCH_SET_EVENTS & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SWITCH_RESET_EVENTS & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SWITCH_CMPL_ACCEPT & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SWITCH_CMPL_REQUEST & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SWITCH_CMPL_IO & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SWITCH_REFRESH_ENDP & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SWITCH_GET_PHYSICAL_ADDR & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SWITCH_TRANSFER_CTX & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SWITCH_GET_SERVICE_PID & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SWITCH_SET_SERVICE_PROCESS & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SWITCH_PROVIDER_CHANGE & 3) == METHOD_NEITHER);


#if DBG
ULONG AfdDebug = 0;
ULONG AfdLocksAcquired = 0;
BOOLEAN AfdUsePrivateAssert = TRUE;
#endif


//
// Some counters used for monitoring performance.  These are not enabled
// in the normal build.
//

#if AFD_PERF_DBG

LONG AfdFullReceiveIndications = 0;
LONG AfdPartialReceiveIndications = 0;

LONG AfdFullReceiveDatagramIndications = 0;
LONG AfdPartialReceiveDatagramIndications = 0;

LONG AfdFastSendsSucceeded = 0;
LONG AfdFastSendsFailed = 0;
LONG AfdFastReceivesSucceeded = 0;
LONG AfdFastReceivesFailed = 0;

LONG AfdFastSendDatagramsSucceeded = 0;
LONG AfdFastSendDatagramsFailed = 0;
LONG AfdFastReceiveDatagramsSucceeded = 0;
LONG AfdFastReceiveDatagramsFailed = 0;

LONG AfdFastReadsSucceeded = 0;
LONG AfdFastReadsFailed = 0;
LONG AfdFastWritesSucceeded = 0;
LONG AfdFastWritesFailed = 0;

LONG AfdFastTfSucceeded=0;
LONG AfdFastTfFailed=0;
LONG AfdFastTfReadFailed=0;

LONG AfdTPWorkersExecuted=0;
LONG AfdTPRequests=0;

BOOLEAN AfdDisableFastIo = FALSE;
BOOLEAN AfdDisableConnectionReuse = FALSE;

#endif  // AFD_PERF_DBG

#if AFD_KEEP_STATS

AFD_QUOTA_STATS AfdQuotaStats;
AFD_HANDLE_STATS AfdHandleStats;
AFD_QUEUE_STATS AfdQueueStats;
AFD_CONNECTION_STATS AfdConnectionStats;

#endif  // AFD_KEEP_STATS

#ifdef _WIN64
QOS32 AfdDefaultQos32 =
        {
            {                           // SendingFlowspec
                (ULONG)-1,                  // TokenRate
                (ULONG)-1,                  // TokenBucketSize
                (ULONG)-1,                  // PeakBandwidth
                (ULONG)-1,                  // Latency
                (ULONG)-1,                  // DelayVariation
                SERVICETYPE_BESTEFFORT,     // ServiceType
                (ULONG)-1,                  // MaxSduSize
                (ULONG)-1                   // MinimumPolicedSize
            },

            {                           // SendingFlowspec
                (ULONG)-1,                  // TokenRate
                (ULONG)-1,                  // TokenBucketSize
                (ULONG)-1,                  // PeakBandwidth
                (ULONG)-1,                  // Latency
                (ULONG)-1,                  // DelayVariation
                SERVICETYPE_BESTEFFORT,     // ServiceType
                (ULONG)-1,                  // MaxSduSize
                (ULONG)-1                   // MinimumPolicedSize
            },
        };
#endif

QOS AfdDefaultQos =
        {
            {                           // SendingFlowspec
                (ULONG)-1,                  // TokenRate
                (ULONG)-1,                  // TokenBucketSize
                (ULONG)-1,                  // PeakBandwidth
                (ULONG)-1,                  // Latency
                (ULONG)-1,                  // DelayVariation
                SERVICETYPE_BESTEFFORT,     // ServiceType
                (ULONG)-1,                  // MaxSduSize
                (ULONG)-1                   // MinimumPolicedSize
            },

            {                           // SendingFlowspec
                (ULONG)-1,                  // TokenRate
                (ULONG)-1,                  // TokenBucketSize
                (ULONG)-1,                  // PeakBandwidth
                (ULONG)-1,                  // Latency
                (ULONG)-1,                  // DelayVariation
                SERVICETYPE_BESTEFFORT,     // ServiceType
                (ULONG)-1,                  // MaxSduSize
                (ULONG)-1                   // MinimumPolicedSize
            },
        };

VOID
AfdInitializeData (
    VOID
    )
{
    PAGED_CODE( );

#if DBG || REFERENCE_DEBUG
    AfdInitializeDebugData( );
#endif

    //
    // Initialize global spin locks and lists.
    //

    AfdInitializeSpinLock( &AfdPollListLock );

    //
    // Initialize global lists.
    //

    InitializeListHead( &AfdEndpointListHead );
    InitializeListHead( &AfdPollListHead );
    InitializeListHead( &AfdTransportInfoListHead );
    InitializeListHead( &AfdWorkQueueListHead );
    InitializeListHead( &AfdConstrainedEndpointListHead );

    InitializeListHead( &AfdQueuedTransmitFileListHead );
    AfdInitializeSpinLock( &AfdQueuedTransmitFileSpinLock );

    InitializeListHead( &AfdAddressEntryList );
    InitializeListHead( &AfdAddressChangeList );

    ExInitializeSListHead( &AfdLRList);

    ExInitializeSListHead( &AfdLRFileMdlList);

    AfdBufferAlignment = KeGetRecommendedSharedDataAlignment( );
    if (AfdBufferAlignment < AFD_MINIMUM_BUFFER_ALIGNMENT) {
        AfdBufferAlignment = AFD_MINIMUM_BUFFER_ALIGNMENT;
    }
    AfdAlignmentTableSize = AfdBufferAlignment/AFD_MINIMUM_BUFFER_ALIGNMENT;

    AfdBufferOverhead = AfdCalculateBufferSize(
                                    PAGE_SIZE,
                                    AfdStandardAddressLength,
                                    AfdTdiStackSize) - PAGE_SIZE;
    AfdBufferLengthForOnePage = ALIGN_DOWN_A(
                                    PAGE_SIZE-AfdBufferOverhead,
                                    AFD_MINIMUM_BUFFER_ALIGNMENT);

    AfdLargeBufferSize = AfdBufferLengthForOnePage;

    //
    // Set up buffer counts based on machine size.  For smaller
    // machines, it is OK to take the perf hit of the additional
    // allocations in order to save the nonpaged pool overhead.
    //

    switch ( MmQuerySystemSize( ) ) {

    case MmSmallSystem:

        AfdReceiveWindowSize = AFD_SM_DEFAULT_RECEIVE_WINDOW;
        AfdSendWindowSize = AFD_SM_DEFAULT_SEND_WINDOW;
        AfdTransmitIoLength = AFD_SM_DEFAULT_TRANSMIT_IO_LENGTH;
        AfdLargeBufferListDepth = AFD_SM_DEFAULT_LARGE_LIST_DEPTH;
        AfdMediumBufferListDepth = AFD_SM_DEFAULT_MEDIUM_LIST_DEPTH;
        AfdSmallBufferListDepth = AFD_SM_DEFAULT_SMALL_LIST_DEPTH;
        AfdBufferTagListDepth = AFD_SM_DEFAULT_TAG_LIST_DEPTH;
        break;

    case MmMediumSystem:

        AfdReceiveWindowSize = AFD_MM_DEFAULT_RECEIVE_WINDOW;
        AfdSendWindowSize = AFD_MM_DEFAULT_SEND_WINDOW;
        AfdTransmitIoLength = AFD_MM_DEFAULT_TRANSMIT_IO_LENGTH;
        AfdLargeBufferListDepth = AFD_MM_DEFAULT_LARGE_LIST_DEPTH;
        AfdMediumBufferListDepth = AFD_MM_DEFAULT_MEDIUM_LIST_DEPTH;
        AfdSmallBufferListDepth = AFD_MM_DEFAULT_SMALL_LIST_DEPTH;
        AfdBufferTagListDepth = AFD_MM_DEFAULT_TAG_LIST_DEPTH;
        break;

    default:
        ASSERT(!"Unknown system size" );

    case MmLargeSystem:

        AfdReceiveWindowSize = AFD_LM_DEFAULT_RECEIVE_WINDOW;
        AfdSendWindowSize = AFD_LM_DEFAULT_SEND_WINDOW;
        AfdTransmitIoLength = AFD_LM_DEFAULT_TRANSMIT_IO_LENGTH;
        AfdLargeBufferListDepth = AFD_LM_DEFAULT_LARGE_LIST_DEPTH;
        AfdMediumBufferListDepth = AFD_LM_DEFAULT_MEDIUM_LIST_DEPTH;
        AfdSmallBufferListDepth = AFD_LM_DEFAULT_SMALL_LIST_DEPTH;
        AfdBufferTagListDepth = AFD_LM_DEFAULT_TAG_LIST_DEPTH;
        break;
    }


    if( MmIsThisAnNtAsSystem() ) {

        //
        // On the NT Server product, there is no maximum active TransmitFile
        // count. Setting this counter to zero short-circuits a number of
        // tests for queueing TransmitFile IRPs.
        //

        AfdMaxActiveTransmitFileCount = 0;

    } else {

        //
        // On the workstation product, the TransmitFile default I/O length
        // is always a page size.  This conserves memory on workstatioons
        // and keeps the server product's performance high.
        //

        AfdTransmitIoLength = PAGE_SIZE;

        //
        // Enforce a maximum active TransmitFile count.
        //

        AfdMaxActiveTransmitFileCount =
            AFD_DEFAULT_MAX_ACTIVE_TRANSMIT_FILE_COUNT;

    }

    RtlCreateSecurityDescriptor (&AfdEmptySd,
                                 SECURITY_DESCRIPTOR_REVISION);
} // AfdInitializeData
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\src\startup.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    startup.c

Abstract:

    This module contains the startup and cleanup code for winsock2 DLL

Author:

    dirk@mink.intel.com  14-JUN-1995

Revision History:

    22-Aug-1995 dirk@mink.intel.com
        Cleanup after code review.

--*/

#include "precomp.h"


INT
CheckForHookersOrChainers();

static
CRITICAL_SECTION  Startup_Synchro;
    // Startup_Synchro  is  used  as  a  synchronization  mechanism  to prevent
    // multiple  threads  from  overlapping  execution  of  the  WSAStartup and
    // WSACleanup procedures.




VOID
CreateStartupSynchronization()
/*++

Routine Description:

    This procedure creates the Startup/Cleanup synchronization mechanism.  This
    must  be  called  once  before  the  WSAStartup  procedure  may  be called.
    Typically, this is called from the DLL_PROCESS_ATTACH branch of DllMain, as
    the  only  reliable  way to guarantee that it gets called before any thread
    calls WSAStartup.

Arguments:

    None

Return Value:

    None
--*/
{
    DEBUGF(
        DBG_TRACE,
        ("Initializing Startup/Cleanup critical section\n"));

    InitializeCriticalSection(
        & Startup_Synchro
        );
}  // CreateStartupSynchronization




VOID
DestroyStartupSynchronization()
/*++

Routine Description:

    This  procedure  destroys  the  Startup/Cleanup  synchronization mechanism.
    This  must  be  called once after the final WSACleanup procedure is called.
    Typically, this is called from the DLL_PROCESS_DETACH branch of DllMain, as
    the  only  reliable  way  to guarantee that it gets called after any thread
    calls WSACleanup.

Arguments:

    None

Return Value:

    None
--*/
{
    DEBUGF(
        DBG_TRACE,
        ("Deleting Startup/Cleanup critical section\n"));

    DeleteCriticalSection(
        & Startup_Synchro
        );
}  // DestroyStartupSynchronization



int WSAAPI
WSAStartup(
    IN WORD wVersionRequired,
    OUT LPWSADATA lpWSAData
    )
/*++
Routine Description:

    Winsock  DLL initialization routine.  A Process must successfully call this
    routine before calling any other winsock API function.

Arguments:

    wVersionRequested - The  highest version of WinSock support that the caller
                        can  use.   The  high  order  byte  specifies the minor
                        version (revision) number; the low-order byte specifies
                        the major version number.

    lpWSAData         - A  pointer  to  the  WSADATA  data structure that is to
                        receive details of the WinSock implementation.

Returns:

    Zero if sucessful or an error code as listed in the specification.

Implementation Notes:

    check versions for validity
    enter critical section
        current_proc = get current process
        if failed to get current process then
            dprocess class initialize
            dthread class initialize
            current_proc = get current process
        endif
        current_proc->increment_ref_count
    leave critical section
--*/
{
    int ReturnCode = ERROR_SUCCESS;
    WORD SupportedVersion;
    WORD MajorVersion;
    WORD MinorVersion;

    // Our DLL initialization routine has not been called yet
    if (gDllHandle==NULL)
        return WSASYSNOTREADY;

    // Check  the  version the user requested and see if we can support it.  If
    // the requested version is less than 2.0 then we can support it
    // Extract the version number from the user request
    MajorVersion = LOBYTE(wVersionRequired);
    MinorVersion = HIBYTE(wVersionRequired);

    //
    // Version checks
    //

    switch (MajorVersion) {

    case 0:

        ReturnCode = WSAVERNOTSUPPORTED;
        SupportedVersion = MAKEWORD (2,2);
        break;

    case 1:

        if( MinorVersion == 0 ) {
            SupportedVersion = MAKEWORD(1,0);
        } else {
            MinorVersion = 1;
            SupportedVersion = MAKEWORD(1,1);
        }

        break;

    case 2:

        if( MinorVersion <= 2 ) {
            SupportedVersion = MAKEWORD(2,(BYTE)MinorVersion);
        } else {
            MinorVersion = 2;
            SupportedVersion = MAKEWORD(2,2);
        }

        break;

    default:

        MajorVersion =
        MinorVersion = 2;
        SupportedVersion = MAKEWORD(2,2);
        break;
    }


    __try {
        //
        // Fill in the user structure
        //
        lpWSAData->wVersion = SupportedVersion;
        lpWSAData->wHighVersion = WINSOCK_HIGH_API_VERSION;

        // Fill in the required fields from 1.0 and 1.1 these fields are
        // ignored in 2.0 and later versions of API spec
        if (MajorVersion == 1) {

            // WinSock  1.1  under  NT  always  set iMaxSockets=32767.  WinSock 1.1
            // under  Windows  95  always  set  iMaxSockets=256.   Either  value is
            // actually  incorrect,  since there was no fixed upper limit.  We just
            // use  32767,  since  it  is likely to damage the fewest number of old
            // applications.
            lpWSAData->iMaxSockets = 32767;

            // WinSock 1.1 under Windows 95 and early versions of NT used the value
            // 65535-68  for  iMaxUdpDg.   This  number  is  also  meaningless, but
            // preserving  the  same value is likely to damage the fewest number of
            // old applications.
            lpWSAData->iMaxUdpDg = 65535 - 68;
        } //if
        else {

            // iMaxSockets  and  iMaxUdpDg  are no longer relevant in WinSock 2 and
            // later.  No applications should depend on their values.  We use 0 for
            // both  of  these  as  a  means  of  flushing  out  applications  that
            // incorrectly  depend  on  the  values.   This is NOT a bug.  If a bug
            // report  is  ever  issued  against  these 0 values, the bug is in the
            // caller's code that is incorrectly depending on the values.
            lpWSAData->iMaxSockets = 0;
            lpWSAData->iMaxUdpDg = 0;
        } // else


        (void) lstrcpy(
            lpWSAData->szDescription,
            "WinSock 2.0");
    #if defined(TRACING) && defined(BUILD_TAG_STRING)
        (void) lstrcat(
            lpWSAData->szDescription,
            " Alpha BUILD_TAG=");
        (void) lstrcat(
            lpWSAData->szDescription,
            BUILD_TAG_STRING);
    #endif  // TRACING && BUILD_TAG_STRING

        //TODO: Think up a good value for "system status"
        (void) lstrcpy(
            lpWSAData->szSystemStatus,
            "Running");

        //
        // The following line is commented-out due to annoying and totally
        // nasty alignment problems in WINSOCK[2].H. The exact location of
        // the lpVendorInfo field of the WSAData structure is dependent on
        // the structure alignment used when compiling the source. Since we
        // cannot change the structure alignment of existing apps, the best
        // way to handle this mess is to just not set this value. This turns
        // out to not be too bad a solution, as neither the WinNT nor the Win95
        // WinSock implementations set this value, and nobody appears to pay
        // any attention to it anyway.
        //
        // lpWSAData->lpVendorInfo = NULL;
        //
    }
    __except (WS2_EXCEPTION_FILTER()) {
        if (ReturnCode==ERROR_SUCCESS)
            ReturnCode = WSAEFAULT;
    }

    if (ReturnCode==ERROR_SUCCESS) {
        // Do this outside of critical section
        // because it does GetModuleHandle and GetProcAddress
        // which take loader lock.
        if (CheckForHookersOrChainers() == ERROR_SUCCESS) {

            BOOL process_class_init_done = FALSE;
            BOOL thread_class_init_done = FALSE;
            BOOL socket_class_init_done = FALSE;
            PDPROCESS CurrentProcess=NULL;
            PDTHREAD CurrentThread=NULL;

            EnterCriticalSection(
                & Startup_Synchro
                );

            while (1) {
                CurrentProcess = DPROCESS::GetCurrentDProcess();

                // GetCurrentDProcess  has  a  most-likely "normal" failure case in the
                // case  where  this  is  the first time WSAStartup is called.

                if (CurrentProcess != NULL) {
                    break;
                }

                ReturnCode = DPROCESS::DProcessClassInitialize();
                if (ReturnCode != ERROR_SUCCESS) {
                    break;
                }
                process_class_init_done = TRUE;

                ReturnCode = DSOCKET::DSocketClassInitialize();
                if (ReturnCode != ERROR_SUCCESS) {
                    break;
                }
                socket_class_init_done = TRUE;

                ReturnCode = DTHREAD::DThreadClassInitialize();
                if (ReturnCode != ERROR_SUCCESS) {
                    break;
                }
                thread_class_init_done = TRUE;

                CurrentProcess = DPROCESS::GetCurrentDProcess();
                if (CurrentProcess==NULL) {
                    ReturnCode = WSASYSNOTREADY;
                    break;
                }

                // We   don't   need   a   reference  to  the  current  thread.
                // Nevertheless,  we retrieve the current thread here just as a
                // means  of  validating  that  initialization  has  gotten far
                // enough   to   be   able  to  retrieve  the  current  thread.
                // Otherwise,  we might detect a peculiar failure at some later
                // time when the client tries to do some real operation.
                CurrentThread = DTHREAD::GetCurrentDThread();
                if (CurrentThread==NULL) {
                    ReturnCode = DTHREAD::CreateDThreadForCurrentThread(
                        CurrentProcess,    // Process
                        & CurrentThread);  // CurrentThread
                }
                else {
                    assert (ReturnCode == ERROR_SUCCESS);
                }
            } // while (1)

            if (ReturnCode == ERROR_SUCCESS) {

                //
                // Save the version number. If the new version is 1.x,
                // set the API prolog to the old, inefficient prolog.
                // If the new version is NOT 1.x, don't touch the prolog
                // pointer because:
                //
                //     1. It defaults to the 2.x prolog.
                //
                //     2. The process may have already negotiated version
                //        1.x in anticipation of using 1.x-specific features
                //        (such as blocking hooks) and we don't want to
                //        overwrite the prolog pointer with the 2.x prolog.
                //

                CurrentProcess->SetVersion( wVersionRequired );

                if( CurrentProcess->GetMajorVersion() == 1 ) {

                    PrologPointer = &Prolog_v1;

                }

                //
                // Bump the ref count.
                //

                CurrentProcess->IncrementRefCount();
            }  // if success so far

            else {  // some failure occurred, cleanup
                INT dont_care;
                if (thread_class_init_done) {
                    DTHREAD::DThreadClassCleanup();
                } // if thread init done
                if (socket_class_init_done) {
                    dont_care = DSOCKET::DSocketClassCleanup();
                }
                if (process_class_init_done) {
                    if (CurrentProcess != NULL) {
                        delete CurrentProcess;
                    }  // if CurrentProcess is non-null
                } // if process init done
            }  // else

            LeaveCriticalSection(
                & Startup_Synchro
                );
        }
        else {
            ReturnCode = WSASYSNOTREADY;
        }

    }  // if ReturnCode==ERROR_SUCCESS

    return(ReturnCode);
}




int WSAAPI
WSACleanup(
    void
    )
/*++
Routine Description:

     Terminate use of the WinSock DLL.

Arguments:

    None

Returns:

    Zero  on  success  else  SOCKET_ERROR.   The  error  code  is  stored  with
    SetErrorCode().

Implementation Notes:

    enter critical section
        current_proc = get current process
        current_proc->decrement_ref_count
        if current count is zero then
            destroy the process
            dthread class cleanup
        endif
    leave critical section

--*/
{
    INT ReturnValue;
    PDPROCESS CurrentProcess;
    PDTHREAD CurrentThread;
    INT      ErrorCode;
    DWORD    CurrentRefCount;


    EnterCriticalSection(
        & Startup_Synchro
        );

    ErrorCode = PROLOG(&CurrentProcess,
                        &CurrentThread);
    if (ErrorCode == ERROR_SUCCESS) {

        CurrentRefCount = CurrentProcess->DecrementRefCount();

        if (CurrentRefCount == 0) {
            delete CurrentProcess;
        }  // if ref count is zero

        else if (CurrentRefCount == 1  &&  SockIsAsyncThreadInitialized() ) {

            SockTerminateAsyncThread();
        }

        ReturnValue = ERROR_SUCCESS;

    }  // if prolog succeeded
    else {
        SetLastError(ErrorCode);
        ReturnValue = SOCKET_ERROR;
    }

    LeaveCriticalSection(
        & Startup_Synchro
        );

    return(ReturnValue);

}  // WSACleanup


PWINSOCK_POST_ROUTINE
GetSockPostRoutine(
    VOID
    )
{
    EnterCriticalSection(
        & Startup_Synchro
        );

    if (SockPostRoutine==NULL) {
        SockPostRoutine = PostMessage;
    }
    LeaveCriticalSection(
        & Startup_Synchro
        );

    return SockPostRoutine;

}   // InitializeSockPostRoutine


int
PASCAL
WSApSetPostRoutine (
    IN PVOID PostRoutine
    )
{

    EnterCriticalSection(
        & Startup_Synchro
        );

    //
    // Save the routine locally.
    //

    SockPostRoutine = (LPFN_POSTMESSAGE)PostRoutine;

    LeaveCriticalSection(
        & Startup_Synchro
        );
    return ERROR_SUCCESS;

}   // WSApSetPostRoutine


#if defined(DEBUG_TRACING)

extern "C" {

SOCKET WSAAPI
DTHOOK_accept (
    SOCKET s,
    struct sockaddr FAR *addr,
    int FAR *addrlen);

int WSAAPI
DTHOOK_bind (
    SOCKET s,
    const struct sockaddr FAR *name,
    int namelen);

int WSAAPI
DTHOOK_closesocket (
    SOCKET s);

int WSAAPI
DTHOOK_connect (
    SOCKET s,
    const struct sockaddr FAR *name,
    int namelen);

int WSAAPI
DTHOOK_getpeername (
    SOCKET s,
    struct sockaddr FAR *name,
    int FAR * namelen);

int WSAAPI
DTHOOK_getsockname (
    SOCKET s,
    struct sockaddr FAR *name,
    int FAR * namelen);

int WSAAPI
DTHOOK_getsockopt (
    SOCKET s,
    int level,
    int optname,
    char FAR * optval,
    int FAR *optlen);

u_long WSAAPI
DTHOOK_htonl (
    u_long hostlong);

u_short WSAAPI
DTHOOK_htons (
    u_short hostshort);

int WSAAPI
DTHOOK_ioctlsocket (
    SOCKET s,
    long cmd,
    u_long FAR *argp);

unsigned long WSAAPI
DTHOOK_inet_addr (
    const char FAR * cp);

char FAR * WSAAPI
DTHOOK_inet_ntoa (
    struct in_addr in);

int WSAAPI
DTHOOK_listen (
    SOCKET s,
    int backlog);

u_long WSAAPI
DTHOOK_ntohl (
    u_long netlong);

u_short WSAAPI
DTHOOK_ntohs (
    u_short netshort);

int WSAAPI
DTHOOK_recv (
    SOCKET s,
    char FAR * buf,
    int len,
    int flags);

int WSAAPI
DTHOOK_recvfrom (
    SOCKET s,
    char FAR * buf,
    int len,
    int flags,
    struct sockaddr FAR *from,
    int FAR * fromlen);

int WSAAPI
DTHOOK_select (
    int nfds,
    fd_set FAR *readfds,
    fd_set FAR *writefds,
    fd_set FAR *exceptfds,
    const struct timeval FAR *timeout);

int WSAAPI
DTHOOK_send (
    SOCKET s,
    const char FAR * buf,
    int len,
    int flags);

int WSAAPI
DTHOOK_sendto (
    SOCKET s,
    const char FAR * buf,
    int len,
    int flags,
    const struct sockaddr FAR *to,
    int tolen);

int WSAAPI
DTHOOK_setsockopt (
    SOCKET s,
    int level,
    int optname,
    const char FAR * optval,
    int optlen);

int WSAAPI
DTHOOK_shutdown (
    SOCKET s,
    int how);

SOCKET WSAAPI
DTHOOK_socket (
    int af,
    int type,
    int protocol);


SOCKET WSAAPI
DTHOOK_WSAAccept (
    SOCKET s,
    struct sockaddr FAR *addr,
    LPINT addrlen,
    LPCONDITIONPROC lpfnCondition,
    DWORD dwCallbackData);

int WSAAPI
DTHOOK_WSAAsyncSelect(
    SOCKET s,
    HWND hWnd,
    u_int wMsg,
    long lEvent);

int WSAAPI
DTHOOK_WSACleanup(
    void);

BOOL WSAAPI
DTHOOK_WSACloseEvent (
    WSAEVENT hEvent);

int WSAAPI
DTHOOK_WSAConnect (
    SOCKET s,
    const struct sockaddr FAR *name,
    int namelen,
    LPWSABUF lpCallerData,
    LPWSABUF lpCalleeData,
    LPQOS lpSQOS,
    LPQOS lpGQOS);

WSAEVENT WSAAPI
DTHOOK_WSACreateEvent (
    void);

int WSAAPI
DTHOOK_WSADuplicateSocketA (
    SOCKET s,
    DWORD dwProcessId,
    LPWSAPROTOCOL_INFOA lpProtocolInfo);

int WSAAPI
DTHOOK_WSADuplicateSocketW (
    SOCKET s,
    DWORD dwProcessId,
    LPWSAPROTOCOL_INFOW lpProtocolInfo);

int WSAAPI
DTHOOK_WSAEnumNetworkEvents (
    SOCKET s,
    WSAEVENT hEventObject,
    LPWSANETWORKEVENTS lpNetworkEvents);

int WSAAPI
DTHOOK_WSAEnumProtocolsA (
    LPINT lpiProtocols,
    LPWSAPROTOCOL_INFOA lpProtocolBuffer,
    LPDWORD lpdwBufferLength);

int WSAAPI
DTHOOK_WSAEnumProtocolsW (
    LPINT lpiProtocols,
    LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    LPDWORD lpdwBufferLength);

int WSPAPI
DTHOOK_WSCEnumProtocols (
    LPINT lpiProtocols,
    LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    LPDWORD lpdwBufferLength,
    LPINT  lpErrno);

int WSAAPI
DTHOOK_WSAEventSelect (
    SOCKET s,
    WSAEVENT hEventObject,
    long lNetworkEvents);

int WSAAPI
DTHOOK_WSAGetLastError(
    void);

BOOL WSAAPI
DTHOOK_WSAGetOverlappedResult (
    SOCKET s,
    LPWSAOVERLAPPED lpOverlapped,
    LPDWORD lpcbTransfer,
    BOOL fWait,
    LPDWORD lpdwFlags);

BOOL WSAAPI
DTHOOK_WSAGetQOSByName (
    SOCKET s,
    LPWSABUF lpQOSName,
    LPQOS lpQOS);

int WSAAPI
DTHOOK_WSAHtonl (
    SOCKET s,
    u_long hostlong,
    u_long FAR * lpnetlong);

int WSAAPI
DTHOOK_WSAHtons (
    SOCKET s,
    u_short hostshort,
    u_short FAR * lpnetshort);

int WSAAPI
DTHOOK_WSAIoctl (
    SOCKET s,
    DWORD dwIoControlCode,
    LPVOID lpvInBuffer,
    DWORD cbInBuffer,
    LPVOID lpvOutBuffer,
    DWORD cbOutBuffer,
    LPDWORD lpcbBytesReturned,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);

SOCKET WSAAPI
DTHOOK_WSAJoinLeaf (
    SOCKET s,
    const struct sockaddr FAR * name,
    int namelen,
    LPWSABUF lpCallerData,
    LPWSABUF lpCalleeData,
    LPQOS lpSQOS,
    LPQOS lpGQOS,
    DWORD dwFlags);

int WSAAPI
DTHOOK_WSANtohl (
    SOCKET s,
    u_long netlong,
    u_long FAR * lphostlong);

int WSAAPI
DTHOOK_WSANtohs (
    SOCKET s,
    u_short netshort,
    u_short FAR * lphostshort);

int WSAAPI
DTHOOK_WSARecv (
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesRecvd,
    LPDWORD lpFlags,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);

int WSAAPI
DTHOOK_WSARecvDisconnect (
    SOCKET s,
    LPWSABUF lpInboundDisconnectData);

int WSAAPI
DTHOOK_WSARecvFrom (
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesRecvd,
    LPDWORD lpFlags,
    struct sockaddr FAR * lpFrom,
    LPINT lpFromlen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);

BOOL WSAAPI
DTHOOK_WSAResetEvent (
    WSAEVENT hEvent);

int WSAAPI
DTHOOK_WSASend (
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesSent,
    DWORD dwFlags,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);

int WSAAPI
DTHOOK_WSASendDisconnect (
    SOCKET s,
    LPWSABUF lpOutboundDisconnectData);

int WSAAPI
DTHOOK_WSASendTo (
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesSent,
    DWORD dwFlags,
    const struct sockaddr FAR * lpTo,
    int iTolen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);

BOOL WSAAPI
DTHOOK_WSASetEvent(
    WSAEVENT hEvent);

void WSAAPI
DTHOOK_WSASetLastError(
    int iError);

SOCKET WSAAPI
DTHOOK_WSASocketA(
    int af,
    int type,
    int protocol,
    LPWSAPROTOCOL_INFOA lpProtocolInfo,
    GROUP g,
    DWORD dwFlags);

SOCKET WSAAPI
DTHOOK_WSASocketW(
    int af,
    int type,
    int protocol,
    LPWSAPROTOCOL_INFOW lpProtocolInfo,
    GROUP g,
    DWORD dwFlags);

int WSAAPI
DTHOOK_WSAStartup(
    WORD wVersionRequested,
    LPWSADATA lpWSAData);

DWORD WSAAPI
DTHOOK_WSAWaitForMultipleEvents(
    DWORD cEvents,
    const WSAEVENT FAR * lphEvents,
    BOOL fWaitAll,
    DWORD dwTimeout,
    BOOL fAlertable);

struct hostent FAR * WSAAPI
DTHOOK_gethostbyaddr(
    const char FAR * addr,
    int len,
    int type);

struct hostent FAR * WSAAPI
DTHOOK_gethostbyname(
    const char FAR * name);

int WSAAPI
DTHOOK_gethostname (
    char FAR * name,
    int namelen);

struct protoent FAR * WSAAPI
DTHOOK_getprotobyname(
    const char FAR * name);

struct protoent FAR * WSAAPI
DTHOOK_getprotobynumber(
    int number);

struct servent FAR * WSAAPI
DTHOOK_getservbyname(
    const char FAR * name,
    const char FAR * proto);

struct servent FAR * WSAAPI
DTHOOK_getservbyport(
    int port,
    const char FAR * proto);

HANDLE WSAAPI
DTHOOK_WSAAsyncGetHostByAddr(
    HWND hWnd,
    u_int wMsg,
    const char FAR * addr,
    int len,
    int type,
    char FAR * buf,
    int buflen);

HANDLE WSAAPI
DTHOOK_WSAAsyncGetHostByName(
    HWND hWnd,
    u_int wMsg,
    const char FAR * name,
    char FAR * buf,
    int buflen);

HANDLE WSAAPI
DTHOOK_WSAAsyncGetProtoByName(
    HWND hWnd,
    u_int wMsg,
    const char FAR * name,
    char FAR * buf,
    int buflen);

HANDLE WSAAPI
DTHOOK_WSAAsyncGetProtoByNumber(
    HWND hWnd,
    u_int wMsg,
    int number,
    char FAR * buf,
    int buflen);

HANDLE WSAAPI
DTHOOK_WSAAsyncGetServByName(
    HWND hWnd,
    u_int wMsg,
    const char FAR * name,
    const char FAR * proto,
    char FAR * buf,
    int buflen);

HANDLE WSAAPI
DTHOOK_WSAAsyncGetServByPort(
    HWND hWnd,
    u_int wMsg,
    int port,
    const char FAR * proto,
    char FAR * buf,
    int buflen);

int WSAAPI
DTHOOK_WSACancelAsyncRequest(
    HANDLE hAsyncTaskHandle);

BOOL WSPAPI
DTHOOK_WPUCloseEvent(
    WSAEVENT hEvent,
    LPINT lpErrno );

int WSPAPI
DTHOOK_WPUCloseSocketHandle(
    SOCKET s,
    LPINT lpErrno );

WSAEVENT WSPAPI
DTHOOK_WPUCreateEvent(
    LPINT lpErrno );

SOCKET WSPAPI
DTHOOK_WPUCreateSocketHandle(
    DWORD dwCatalogEntryId,
    DWORD_PTR dwContext,
    LPINT lpErrno);

SOCKET WSPAPI
DTHOOK_WPUModifyIFSHandle(
    DWORD dwCatalogEntryId,
    SOCKET ProposedHandle,
    LPINT lpErrno);

int WSPAPI
DTHOOK_WPUQueryBlockingCallback(
    DWORD dwCatalogEntryId,
    LPBLOCKINGCALLBACK FAR * lplpfnCallback,
    PDWORD_PTR lpdwContext,
    LPINT lpErrno);

int WSPAPI
DTHOOK_WPUQuerySocketHandleContext(
    SOCKET s,
    PDWORD_PTR lpContext,
    LPINT lpErrno );

int WSPAPI
DTHOOK_WPUQueueApc(
    LPWSATHREADID lpThreadId,
    LPWSAUSERAPC lpfnUserApc,
    DWORD_PTR dwContext,
    LPINT lpErrno);

BOOL WSPAPI
DTHOOK_WPUResetEvent(
    WSAEVENT hEvent,
    LPINT lpErrno);

BOOL WSPAPI
DTHOOK_WPUSetEvent(
    WSAEVENT hEvent,
    LPINT lpErrno);

int WSPAPI
DTHOOK_WSCDeinstallProvider(
    LPGUID lpProviderId,
    LPINT lpErrno);

int WSPAPI
DTHOOK_WSCInstallProvider(
    LPGUID lpProviderId,
    const WCHAR FAR * lpszProviderDllPath,
    const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    DWORD dwNumberOfEntries,
    LPINT lpErrno);

int WSPAPI
DTHOOK_WPUGetProviderPath(
    IN     LPGUID     lpProviderId,
    OUT    WCHAR FAR * lpszProviderDllPath,
    IN OUT LPINT      lpProviderDllPathLen,
    OUT    LPINT      lpErrno
    );

BOOL WSPAPI
DTHOOK_WPUPostMessage(
    HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    );

int WSPAPI
DTHOOK_WPUFDIsSet(
    SOCKET       s,
    fd_set FAR * set
    );

int WSPAPI
DTHOOK___WSAFDIsSet(
    SOCKET       s,
    fd_set FAR * set
    );

INT
WSPAPI
DTHOOK_WSAAddressToStringA(
    IN     LPSOCKADDR          lpsaAddress,
    IN     DWORD               dwAddressLength,
    IN     LPWSAPROTOCOL_INFOA lpProtocolInfo,
    IN OUT LPSTR               lpszAddressString,
    IN OUT LPDWORD             lpdwAddressStringLength
    );

INT
WSPAPI
DTHOOK_WSAAddressToStringW(
    IN     LPSOCKADDR          lpsaAddress,
    IN     DWORD               dwAddressLength,
    IN     LPWSAPROTOCOL_INFOW lpProtocolInfo,
    IN OUT LPWSTR              lpszAddressString,
    IN OUT LPDWORD             lpdwAddressStringLength
    );

INT
WSPAPI
DTHOOK_WSAStringToAddressA(
    IN     LPSTR               AddressString,
    IN     INT                 AddressFamily,
    IN     LPWSAPROTOCOL_INFOA  lpProtocolInfo,
    IN OUT LPSOCKADDR          lpAddress,
    IN OUT LPINT               lpAddressLength
    );

INT
WSPAPI
DTHOOK_WSAStringToAddressW(
    IN     LPWSTR              AddressString,
    IN     INT                 AddressFamily,
    IN     LPWSAPROTOCOL_INFOW lpProtocolInfo,
    IN OUT LPSOCKADDR          lpAddress,
    IN OUT LPINT               lpAddressLength
    );

INT
WSPAPI
DTHOOK_WSALookupServiceBeginA(
    IN  LPWSAQUERYSETA lpqsRestrictions,
    IN  DWORD          dwControlFlags,
    OUT LPHANDLE       lphLookup
    );

INT
WSPAPI
DTHOOK_WSALookupServiceBeginW(
    IN  LPWSAQUERYSETW lpqsRestrictions,
    IN  DWORD          dwControlFlags,
    OUT LPHANDLE       lphLookup
    );

INT
WSPAPI
DTHOOK_WSALookupServiceNextA(
    IN     HANDLE           hLookup,
    IN     DWORD            dwControlFlags,
    IN OUT LPDWORD          lpdwBufferLength,
    OUT    LPWSAQUERYSETA   lpqsResults
    );

INT
WSPAPI
DTHOOK_WSALookupServiceNextW(
    IN     HANDLE           hLookup,
    IN     DWORD            dwControlFlags,
    IN OUT LPDWORD          lpdwBufferLength,
    OUT    LPWSAQUERYSETW   lpqsResults
    );

INT
WSPAPI
DTHOOK_WSANSPIoctl(
    IN  HANDLE           hLookup,
    IN  DWORD            dwControlCode,
    IN  LPVOID           lpvInBuffer,
    IN  DWORD            cbInBuffer,
    OUT LPVOID           lpvOutBuffer,
    IN  DWORD            cbOutBuffer,
    OUT LPDWORD          lpcbBytesReturned,
    IN  LPWSACOMPLETION  lpCompletion
    );

INT
WSPAPI
DTHOOK_WSALookupServiceEnd(
    IN HANDLE  hLookup
    );

INT
WSPAPI
DTHOOK_WSAInstallServiceClassA(
    IN  LPWSASERVICECLASSINFOA   lpServiceClassInfo
    );

INT
WSPAPI
DTHOOK_WSAInstallServiceClassW(
    IN  LPWSASERVICECLASSINFOW   lpServiceClassInfo
    );

INT WSPAPI
DTHOOK_WSASetServiceA(
    IN  LPWSAQUERYSETA    lpqsRegInfo,
    IN  WSAESETSERVICEOP  essOperation,
    IN  DWORD             dwControlFlags
    );

INT WSPAPI
DTHOOK_WSASetServiceW(
    IN  LPWSAQUERYSETW    lpqsRegInfo,
    IN  WSAESETSERVICEOP  essOperation,
    IN  DWORD             dwControlFlags
    );

INT
WSPAPI
DTHOOK_WSARemoveServiceClass(
    IN  LPGUID  lpServiceClassId
    );

INT
WSPAPI
DTHOOK_WSAGetServiceClassInfoA(
    IN     LPGUID                  lpProviderId,
    IN     LPGUID                  lpServiceClassId,
    IN OUT LPDWORD                 lpdwBufSize,
    OUT    LPWSASERVICECLASSINFOA   lpServiceClassInfo
    );

INT
WSPAPI
DTHOOK_WSAGetServiceClassInfoW(
    IN     LPGUID                  lpProviderId,
    IN     LPGUID                  lpServiceClassId,
    IN OUT LPDWORD                 lpdwBufSize,
    OUT    LPWSASERVICECLASSINFOW   lpServiceClassInfo
    );

INT
WSPAPI
DTHOOK_WSAEnumNameSpaceProvidersA(
    IN OUT LPDWORD              lpdwBufferLength,
    IN     LPWSANAMESPACE_INFOA  Lpnspbuffer
    );

INT
WSPAPI
DTHOOK_WSAEnumNameSpaceProvidersW(
    IN OUT LPDWORD              lpdwBufferLength,
    IN     LPWSANAMESPACE_INFOW  Lpnspbuffer
    );

INT
WSPAPI
DTHOOK_WSAGetServiceClassNameByClassIdA(
    IN      LPGUID  lpServiceClassId,
    OUT     LPSTR   lpszServiceClassName,
    IN OUT  LPDWORD lpdwBufferLength
    );

INT
WSPAPI
DTHOOK_WSAGetServiceClassNameByClassIdW(
    IN      LPGUID  lpServiceClassId,
    OUT     LPWSTR   lpszServiceClassName,
    IN OUT  LPDWORD lpdwBufferLength
    );

INT
WSAAPI
DTHOOK_WSACancelBlockingCall(
    VOID
    );

FARPROC
WSAAPI
DTHOOK_WSASetBlockingHook(
    FARPROC lpBlockFunc
    );

INT
WSAAPI
DTHOOK_WSAUnhookBlockingHook(
    VOID
    );

BOOL
WSAAPI
DTHOOK_WSAIsBlocking(
    VOID
    );

int WSPAPI
DTHOOK_WSCGetProviderPath(
    LPGUID lpProviderId,
    WCHAR FAR * lpszProviderDllPath,
    LPINT lpProviderDllPathLen,
    LPINT lpErrno);

int WSPAPI
DTHOOK_WSCInstallNameSpace(
    LPWSTR lpszIdentifier,
    LPWSTR lpszPathName,
    DWORD dwNameSpace,
    DWORD dwVersion,
    LPGUID lpProviderId);

int WSPAPI
DTHOOK_WSCUnInstallNameSpace(
    LPGUID lpProviderId
    );

int WSPAPI
DTHOOK_WSCEnableNSProvider(
    LPGUID lpProviderId,
    BOOL fEnable
    );

int
WSPAPI
DTHOOK_WPUCompleteOverlappedRequest (
    SOCKET s,   
    LPWSAOVERLAPPED lpOverlapped,       
    DWORD dwError,      
    DWORD cbTransferred,        
    LPINT lpErrno
    );

int WSAAPI
DTHOOK_WSAProviderConfigChange(
    IN OUT LPHANDLE lpNotificationHandle,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );

int
WSPAPI
DTHOOK_WSCWriteProviderOrder (
    IN LPDWORD lpwdCatalogEntryId,
    IN DWORD dwNumberOfEntries
    );

int
WSPAPI
DTHOOK_WSCWriteNameSpaceOrder (
    IN LPGUID lpProviderId,
    IN DWORD dwNumberOfEntries
    );

int
WSPAPI
DTHOOK_WSCUpdateProvider(
    IN  LPGUID lpProviderId,
    IN  const WCHAR FAR * lpszProviderDllPath,
    IN  const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN  DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    );

int WSAAPI
DTHOOK_getaddrinfo(
    const char FAR *NodeName,
    const char FAR *ServiceName,
    const struct addrinfo FAR *Hints,
    struct addrinfo FAR * FAR *Result
    );

int
WSAAPI
DTHOOK_GetAddrInfoW(
    IN      PCWSTR                      pNodeName,
    IN      PCWSTR                      pServiceName,
    IN      const struct addrinfoW *    pHints,
    OUT     PADDRINFOW *                ppResult
    );

int WSAAPI
DTHOOK_getnameinfo(
    const struct sockaddr *SocketAddress,
    socklen_t SocketAddressLength,
    char *NodeName,
    DWORD NodeBufferSize,
    char *ServiceName,
    DWORD ServiceBufferSize,
    int Flags
    );

INT
WSAAPI
DTHOOK_GetNameInfoW(
    IN      const SOCKADDR *    pSockaddr,
    IN      socklen_t           SockaddrLength,
    OUT     PWCHAR              pNodeBuffer,
    IN      DWORD               NodeBufferSize,
    OUT     PWCHAR              pServiceBuffer,
    IN      DWORD               ServiceBufferSize,
    IN      INT                 Flags
    );

void WSAAPI
DTHOOK_freeaddrinfo(                                                                   
    struct addrinfo *Free
    );

#ifdef _WIN64

int 
WSPAPI
DTHOOK_WSCEnumProtocols32(
    IN LPINT                lpiProtocols,
    OUT LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    IN OUT LPDWORD          lpdwBufferLength,
    LPINT                   lpErrno
    );

int
WSPAPI
DTHOOK_WSCInstallProvider64_32(
    IN  LPGUID lpProviderId,
    IN  const WCHAR FAR * lpszProviderDllPath,
    IN  const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN  DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    );

int
WSPAPI
DTHOOK_WSCDeinstallProvider32(
    IN  LPGUID lpProviderId,
    OUT LPINT lpErrno
    );

int
WSPAPI
DTHOOK_WSCGetProviderPath32 (
    IN LPGUID lpProviderId,
    OUT WCHAR FAR * lpszProviderDllPath,
    IN OUT LPINT ProviderDLLPathLen,
    OUT LPINT lpErrno
    );

int
WSPAPI
DTHOOK_WSCUpdateProvider32(
    IN  LPGUID lpProviderId,
    IN  const WCHAR FAR * lpszProviderDllPath,
    IN  const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN  DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    );

int
WSPAPI
DTHOOK_WSCWriteProviderOrder32 (
    IN LPDWORD lpwdCatalogEntryId,
    IN DWORD dwNumberOfEntries
    );

INT 
WSAAPI
DTHOOK_WSCEnumNameSpaceProviders32(
    IN OUT LPDWORD              lpdwBufferLength,
    IN OUT LPWSANAMESPACE_INFOW lpnspBuffer
    );

INT 
WSAAPI
DTHOOK_WSCInstallNameSpace32 (
    IN  LPWSTR  lpszIdentifier,
    IN  LPWSTR  lpszPathName,
    IN  DWORD   dwNameSpace,
    IN  DWORD   dwVersion,
    IN  LPGUID  lpProviderId
    );

INT
WSAAPI
DTHOOK_WSCUnInstallNameSpace32 (
    IN  LPGUID  lpProviderId
    );

INT
WSAAPI
DTHOOK_WSCEnableNSProvider32 (
    IN  LPGUID  lpProviderId,
    IN  BOOL    fEnable
    );

int
WSPAPI
DTHOOK_WSCWriteNameSpaceOrder32 (
    IN LPGUID lpProviderId,
    IN DWORD dwNumberOfEntries
    );

#endif // _WIN64
} // extern "C"

#endif // DEBUG_TRACING


LPVOID apfns[] =
{
#if defined(DEBUG_TRACING)
    (LPVOID) DTHOOK_accept,
    (LPVOID) DTHOOK_bind,
    (LPVOID) DTHOOK_closesocket,
    (LPVOID) DTHOOK_connect,
    (LPVOID) DTHOOK_getpeername,
    (LPVOID) DTHOOK_getsockname,
    (LPVOID) DTHOOK_getsockopt,
    (LPVOID) DTHOOK_htonl,
    (LPVOID) DTHOOK_htons,
    (LPVOID) DTHOOK_ioctlsocket,
    (LPVOID) DTHOOK_inet_addr,
    (LPVOID) DTHOOK_inet_ntoa,
    (LPVOID) DTHOOK_listen,
    (LPVOID) DTHOOK_ntohl,
    (LPVOID) DTHOOK_ntohs,
    (LPVOID) DTHOOK_recv,
    (LPVOID) DTHOOK_recvfrom,
    (LPVOID) DTHOOK_select,
    (LPVOID) DTHOOK_send,
    (LPVOID) DTHOOK_sendto,
    (LPVOID) DTHOOK_setsockopt,
    (LPVOID) DTHOOK_shutdown,
    (LPVOID) DTHOOK_socket,
    (LPVOID) DTHOOK_gethostbyaddr,
    (LPVOID) DTHOOK_gethostbyname,
    (LPVOID) DTHOOK_getprotobyname,
    (LPVOID) DTHOOK_getprotobynumber,
    (LPVOID) DTHOOK_getservbyname,
    (LPVOID) DTHOOK_getservbyport,
    (LPVOID) DTHOOK_gethostname,
    (LPVOID) DTHOOK_WSAAsyncSelect,
    (LPVOID) DTHOOK_WSAAsyncGetHostByAddr,
    (LPVOID) DTHOOK_WSAAsyncGetHostByName,
    (LPVOID) DTHOOK_WSAAsyncGetProtoByNumber,
    (LPVOID) DTHOOK_WSAAsyncGetProtoByName,
    (LPVOID) DTHOOK_WSAAsyncGetServByPort,
    (LPVOID) DTHOOK_WSAAsyncGetServByName,
    (LPVOID) DTHOOK_WSACancelAsyncRequest,
    (LPVOID) DTHOOK_WSASetBlockingHook,
    (LPVOID) DTHOOK_WSAUnhookBlockingHook,
    (LPVOID) DTHOOK_WSAGetLastError,
    (LPVOID) DTHOOK_WSASetLastError,
    (LPVOID) DTHOOK_WSACancelBlockingCall,
    (LPVOID) DTHOOK_WSAIsBlocking,
    (LPVOID) DTHOOK_WSAStartup,
    (LPVOID) DTHOOK_WSACleanup,

    (LPVOID) DTHOOK_WSAAccept,
    (LPVOID) DTHOOK_WSACloseEvent,
    (LPVOID) DTHOOK_WSAConnect,
    (LPVOID) DTHOOK_WSACreateEvent,
    (LPVOID) DTHOOK_WSADuplicateSocketA,
    (LPVOID) DTHOOK_WSADuplicateSocketW,
    (LPVOID) DTHOOK_WSAEnumNetworkEvents,
    (LPVOID) DTHOOK_WSAEnumProtocolsA,
    (LPVOID) DTHOOK_WSAEnumProtocolsW,
    (LPVOID) DTHOOK_WSAEventSelect,
    (LPVOID) DTHOOK_WSAGetOverlappedResult,
    (LPVOID) DTHOOK_WSAGetQOSByName,
    (LPVOID) DTHOOK_WSAHtonl,
    (LPVOID) DTHOOK_WSAHtons,
    (LPVOID) DTHOOK_WSAIoctl,
    (LPVOID) DTHOOK_WSAJoinLeaf,
    (LPVOID) DTHOOK_WSANtohl,
    (LPVOID) DTHOOK_WSANtohs,
    (LPVOID) DTHOOK_WSARecv,
    (LPVOID) DTHOOK_WSARecvDisconnect,
    (LPVOID) DTHOOK_WSARecvFrom,
    (LPVOID) DTHOOK_WSAResetEvent,
    (LPVOID) DTHOOK_WSASend,
    (LPVOID) DTHOOK_WSASendDisconnect,
    (LPVOID) DTHOOK_WSASendTo,
    (LPVOID) DTHOOK_WSASetEvent,
    (LPVOID) DTHOOK_WSASocketA,
    (LPVOID) DTHOOK_WSASocketW,
    (LPVOID) DTHOOK_WSAWaitForMultipleEvents,

    (LPVOID) DTHOOK_WSAAddressToStringA,
    (LPVOID) DTHOOK_WSAAddressToStringW,
    (LPVOID) DTHOOK_WSAStringToAddressA,
    (LPVOID) DTHOOK_WSAStringToAddressW,
    (LPVOID) DTHOOK_WSALookupServiceBeginA,
    (LPVOID) DTHOOK_WSALookupServiceBeginW,
    (LPVOID) DTHOOK_WSALookupServiceNextA,
    (LPVOID) DTHOOK_WSALookupServiceNextW,
    (LPVOID) DTHOOK_WSANSPIoctl,
    (LPVOID) DTHOOK_WSALookupServiceEnd,
    (LPVOID) DTHOOK_WSAInstallServiceClassA,
    (LPVOID) DTHOOK_WSAInstallServiceClassW,
    (LPVOID) DTHOOK_WSARemoveServiceClass,
    (LPVOID) DTHOOK_WSAGetServiceClassInfoA,
    (LPVOID) DTHOOK_WSAGetServiceClassInfoW,
    (LPVOID) DTHOOK_WSAEnumNameSpaceProvidersA,
    (LPVOID) DTHOOK_WSAEnumNameSpaceProvidersW,
    (LPVOID) DTHOOK_WSAGetServiceClassNameByClassIdA,
    (LPVOID) DTHOOK_WSAGetServiceClassNameByClassIdW,
    (LPVOID) DTHOOK_WSASetServiceA,
    (LPVOID) DTHOOK_WSASetServiceW,

    (LPVOID) DTHOOK_WSCDeinstallProvider,
    (LPVOID) DTHOOK_WSCInstallProvider,
    (LPVOID) DTHOOK_WSCEnumProtocols,
    (LPVOID) DTHOOK_WSCGetProviderPath,
    (LPVOID) DTHOOK_WSCInstallNameSpace,
    (LPVOID) DTHOOK_WSCUnInstallNameSpace,
    (LPVOID) DTHOOK_WSCEnableNSProvider,
    
    (LPVOID) DTHOOK_WPUCompleteOverlappedRequest,
    
    (LPVOID) DTHOOK_WSAProviderConfigChange,
    
    (LPVOID) DTHOOK_WSCWriteProviderOrder,
    (LPVOID) DTHOOK_WSCWriteNameSpaceOrder,
    (LPVOID) DTHOOK_WSCUpdateProvider,

    (LPVOID) DTHOOK_getaddrinfo,
    (LPVOID) DTHOOK_GetAddrInfoW,
    (LPVOID) DTHOOK_getnameinfo,
    (LPVOID) DTHOOK_GetNameInfoW,
    (LPVOID) DTHOOK_freeaddrinfo,

#ifdef _WIN64
    (LPVOID) DTHOOK_WSCEnumProtocols32,
    (LPVOID) DTHOOK_WSCInstallProvider64_32,
    (LPVOID) DTHOOK_WSCDeinstallProvider32,
    (LPVOID) DTHOOK_WSCGetProviderPath32,
    (LPVOID) DTHOOK_WSCUpdateProvider32,
    (LPVOID) DTHOOK_WSCWriteProviderOrder32,
    (LPVOID) DTHOOK_WSCEnumNameSpaceProviders32,
    (LPVOID) DTHOOK_WSCInstallNameSpace32,
    (LPVOID) DTHOOK_WSCUnInstallNameSpace32,
    (LPVOID) DTHOOK_WSCEnableNSProvider32,
    (LPVOID) DTHOOK_WSCWriteNameSpaceOrder32,
#endif //_WIN64

#else // DEBUG_TRACING

    (LPVOID) accept,
    (LPVOID) bind,
    (LPVOID) closesocket,
    (LPVOID) connect,
    (LPVOID) getpeername,
    (LPVOID) getsockname,
    (LPVOID) getsockopt,
    (LPVOID) htonl,
    (LPVOID) htons,
    (LPVOID) ioctlsocket,
    (LPVOID) inet_addr,
    (LPVOID) inet_ntoa,
    (LPVOID) listen,
    (LPVOID) ntohl,
    (LPVOID) ntohs,
    (LPVOID) recv,
    (LPVOID) recvfrom,
    (LPVOID) select,
    (LPVOID) send,
    (LPVOID) sendto,
    (LPVOID) setsockopt,
    (LPVOID) shutdown,
    (LPVOID) socket,
    (LPVOID) gethostbyaddr,
    (LPVOID) gethostbyname,
    (LPVOID) getprotobyname,
    (LPVOID) getprotobynumber,
    (LPVOID) getservbyname,
    (LPVOID) getservbyport,
    (LPVOID) gethostname,
    (LPVOID) WSAAsyncSelect,
    (LPVOID) WSAAsyncGetHostByAddr,
    (LPVOID) WSAAsyncGetHostByName,
    (LPVOID) WSAAsyncGetProtoByNumber,
    (LPVOID) WSAAsyncGetProtoByName,
    (LPVOID) WSAAsyncGetServByPort,
    (LPVOID) WSAAsyncGetServByName,
    (LPVOID) WSACancelAsyncRequest,
    (LPVOID) WSASetBlockingHook,
    (LPVOID) WSAUnhookBlockingHook,
    (LPVOID) WSAGetLastError,
    (LPVOID) WSASetLastError,
    (LPVOID) WSACancelBlockingCall,
    (LPVOID) WSAIsBlocking,
    (LPVOID) WSAStartup,
    (LPVOID) WSACleanup,

    (LPVOID) WSAAccept,
    (LPVOID) WSACloseEvent,
    (LPVOID) WSAConnect,
    (LPVOID) WSACreateEvent,
    (LPVOID) WSADuplicateSocketA,
    (LPVOID) WSADuplicateSocketW,
    (LPVOID) WSAEnumNetworkEvents,
    (LPVOID) WSAEnumProtocolsA,
    (LPVOID) WSAEnumProtocolsW,
    (LPVOID) WSAEventSelect,
    (LPVOID) WSAGetOverlappedResult,
    (LPVOID) WSAGetQOSByName,
    (LPVOID) WSAHtonl,
    (LPVOID) WSAHtons,
    (LPVOID) WSAIoctl,
    (LPVOID) WSAJoinLeaf,
    (LPVOID) WSANtohl,
    (LPVOID) WSANtohs,
    (LPVOID) WSARecv,
    (LPVOID) WSARecvDisconnect,
    (LPVOID) WSARecvFrom,
    (LPVOID) WSAResetEvent,
    (LPVOID) WSASend,
    (LPVOID) WSASendDisconnect,
    (LPVOID) WSASendTo,
    (LPVOID) WSASetEvent,
    (LPVOID) WSASocketA,
    (LPVOID) WSASocketW,
    (LPVOID) WSAWaitForMultipleEvents,

    (LPVOID) WSAAddressToStringA,
    (LPVOID) WSAAddressToStringW,
    (LPVOID) WSAStringToAddressA,
    (LPVOID) WSAStringToAddressW,
    (LPVOID) WSALookupServiceBeginA,
    (LPVOID) WSALookupServiceBeginW,
    (LPVOID) WSALookupServiceNextA,
    (LPVOID) WSALookupServiceNextW,
    (LPVOID) WSANSPIoctl,
    (LPVOID) WSALookupServiceEnd,
    (LPVOID) WSAInstallServiceClassA,
    (LPVOID) WSAInstallServiceClassW,
    (LPVOID) WSARemoveServiceClass,
    (LPVOID) WSAGetServiceClassInfoA,
    (LPVOID) WSAGetServiceClassInfoW,
    (LPVOID) WSAEnumNameSpaceProvidersA,
    (LPVOID) WSAEnumNameSpaceProvidersW,
    (LPVOID) WSAGetServiceClassNameByClassIdA,
    (LPVOID) WSAGetServiceClassNameByClassIdW,
    (LPVOID) WSASetServiceA,
    (LPVOID) WSASetServiceW,

    (LPVOID) WSCDeinstallProvider,
    (LPVOID) WSCInstallProvider,
    (LPVOID) WSCEnumProtocols,
    (LPVOID) WSCGetProviderPath,
    (LPVOID) WSCInstallNameSpace,
    (LPVOID) WSCUnInstallNameSpace,
    (LPVOID) WSCEnableNSProvider,

    (LPVOID) WPUCompleteOverlappedRequest,

    (LPVOID) WSAProviderConfigChange,

    (LPVOID) WSCWriteProviderOrder,
    (LPVOID) WSCWriteNameSpaceOrder,
    (LPVOID) WSCUpdateProvider,

    (LPVOID) getaddrinfo,
    (LPVOID) GetAddrInfoW,
    (LPVOID) getnameinfo,
    (LPVOID) GetNameInfoW,
    (LPVOID) freeaddrinfo,
#ifdef _WIN64
    (LPVOID) WSCEnumProtocols32,
    (LPVOID) WSCInstallProvider64_32,
    (LPVOID) WSCDeinstallProvider32,
    (LPVOID) WSCGetProviderPath32,
    (LPVOID) WSCUpdateProvider32,
    (LPVOID) WSCWriteProviderOrder32,
    (LPVOID) WSCEnumNameSpaceProviders32,
    (LPVOID) WSCInstallNameSpace32,
    (LPVOID) WSCUnInstallNameSpace32,
    (LPVOID) WSCEnableNSProvider32,
    (LPVOID) WSCWriteNameSpaceOrder32,
#endif //_WIN64
#endif // DEBUG_TRACING
};

static char *aszFuncNames[] =
{
    "accept",
    "bind",
    "closesocket",
    "connect",
    "getpeername",
    "getsockname",
    "getsockopt",
    "htonl",
    "htons",
    "ioctlsocket",
    "inet_addr",
    "inet_ntoa",
    "listen",
    "ntohl",
    "ntohs",
    "recv",
    "recvfrom",
    "select",
    "send",
    "sendto",
    "setsockopt",
    "shutdown",
    "socket",
    "gethostbyaddr",
    "gethostbyname",
    "getprotobyname",
    "getprotobynumber",
    "getservbyname",
    "getservbyport",
    "gethostname",
    "WSAAsyncSelect",
    "WSAAsyncGetHostByAddr",
    "WSAAsyncGetHostByName",
    "WSAAsyncGetProtoByNumber",
    "WSAAsyncGetProtoByName",
    "WSAAsyncGetServByPort",
    "WSAAsyncGetServByName",
    "WSACancelAsyncRequest",
    "WSASetBlockingHook",
    "WSAUnhookBlockingHook",
    "WSAGetLastError",
    "WSASetLastError",
    "WSACancelBlockingCall",
    "WSAIsBlocking",
    "WSAStartup",
    "WSACleanup",

    "WSAAccept",
    "WSACloseEvent",
    "WSAConnect",
    "WSACreateEvent",
    "WSADuplicateSocketA",
    "WSADuplicateSocketW",
    "WSAEnumNetworkEvents",
    "WSAEnumProtocolsA",
    "WSAEnumProtocolsW",
    "WSAEventSelect",
    "WSAGetOverlappedResult",
    "WSAGetQOSByName",
    "WSAHtonl",
    "WSAHtons",
    "WSAIoctl",
    "WSAJoinLeaf",
    "WSANtohl",
    "WSANtohs",
    "WSARecv",
    "WSARecvDisconnect",
    "WSARecvFrom",
    "WSAResetEvent",
    "WSASend",
    "WSASendDisconnect",
    "WSASendTo",
    "WSASetEvent",
    "WSASocketA",
    "WSASocketW",
    "WSAWaitForMultipleEvents",

    "WSAAddressToStringA",
    "WSAAddressToStringW",
    "WSAStringToAddressA",
    "WSAStringToAddressW",
    "WSALookupServiceBeginA",
    "WSALookupServiceBeginW",
    "WSALookupServiceNextA",
    "WSALookupServiceNextW",
    "WSANSPIoctl",
    "WSALookupServiceEnd",
    "WSAInstallServiceClassA",
    "WSAInstallServiceClassW",
    "WSARemoveServiceClass",
    "WSAGetServiceClassInfoA",
    "WSAGetServiceClassInfoW",
    "WSAEnumNameSpaceProvidersA",
    "WSAEnumNameSpaceProvidersW",
    "WSAGetServiceClassNameByClassIdA",
    "WSAGetServiceClassNameByClassIdW",
    "WSASetServiceA",
    "WSASetServiceW",

    "WSCDeinstallProvider",
    "WSCInstallProvider",
    "WSCEnumProtocols",
    "WSCGetProviderPath",
    "WSCInstallNameSpace",
    "WSCUnInstallNameSpace",
    "WSCEnableNSProvider",

    "WPUCompleteOverlappedRequest",

    "WSAProviderConfigChange",

    "WSCWriteProviderOrder",
    "WSCWriteNameSpaceOrder",
    "WSCUpdateProvider",

    "getaddrinfo",
    "GetAddrInfoW",
    "getnameinfo",
    "GetNameInfoW",
    "freeaddrinfo",

#ifdef _WIN64
    "WSCEnumProtocols32",
    "WSCInstallProvider64_32",
    "WSCDeinstallProvider32",
    "WSCGetProviderPath32",
    "WSCUpdateProvider32",
    "WSCWriteProviderOrder32",
    "WSCEnumNameSpaceProviders32",
    "WSCInstallNameSpace32",
    "WSCUnInstallNameSpace32",
    "WSCEnableNSProvider32",
    "WSCWriteNameSpaceOrder32",
#endif // _WIN64
    NULL
};


INT
CheckForHookersOrChainers()
/*++

Routine Description:

    This procedure checks to see if there are any ws2_32 hookers or chainers
    out there, returning ERROR_SUCCESS if not or SOCKET_ERROR if so.

Arguments:

    None

Return Value:

    None
--*/
{
    LPVOID pfnXxx;
    int i;

    DEBUGF(DBG_TRACE, ("Checking for ws2_32 hookers or chainers...\n"));

    for (i = 0; aszFuncNames[i]; i++)
    {
        if (!(pfnXxx = (LPVOID) GetProcAddress (gDllHandle, aszFuncNames[i])) ||
            pfnXxx != apfns[i])
        {
            DEBUGF(DBG_ERR, ("Hooker or chainer found for %s @ %p, failing init\n",
                            aszFuncNames[i], pfnXxx));

            return SOCKET_ERROR;
        }
    }

    DEBUGF(DBG_TRACE, ("No ws2_32 hookers or chainers found\n"));

    return ERROR_SUCCESS;

}  // CheckForHookersOrChainers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsock32\sockopt.c ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    Sockopt.c

Abstract:

    This module contains support for the getsockopt( ) and setsockopt( )
    WinSock APIs.

Author:

    David Treadwell (davidtr)    31-Mar-1992

Revision History:

--*/

#define WINSOCK_API_LINKAGE
#define getsockopt getsockopt_v11
#define setsockopt setsockopt_v11

#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>

//
// The versions of WSOCK32.DLL that shiped with NT 3.1, NT 3.5, NT 3.51,
// TCP/IP-32 for WFW, and Win95 all use the "Steve Deering" values for the
// IP Multicast options. Unfortunately, the TCP/IP subgroup of the Windows
// Sockets 2.0 standards effort chose to use the BSD values for these options.
// Since these values overlap considerably, we have a rather unfortunate
// situation.
//
// Here's how we'll deal with this.
//
// Applications built using WINSOCK2.H & WS2TCPIP.H will use the BSD
// values as #defined in WS2TCPIP.H. These applications will link with
// WS2_32.DLL, and life is swell.
//
// Applications built using WINSOCK.H will use the Steve Deering values
// as #defined in WINSOCK.H. These applications will link with WSOCK32.DLL,
// which will map these options to the BSD values before passing them
// down to WS2_32.DLL. Life is still swell.
//
// These are the "old" Steve Deering values that must be mapped:
//

#define OLD_IP_MULTICAST_IF     2
#define OLD_IP_MULTICAST_TTL    3
#define OLD_IP_MULTICAST_LOOP   4
#define OLD_IP_ADD_MEMBERSHIP   5
#define OLD_IP_DROP_MEMBERSHIP  6
#define OLD_IP_TTL              7
#define OLD_IP_TOS              8
#define OLD_IP_DONTFRAGMENT     9

#define TCP_BSDURGENT           0x7000

INT
MapOldIpMulticastOptionToBsdValue(
    INT OptionName
    );


int PASCAL
getsockopt(
    IN SOCKET Handle,
    IN int Level,
    IN int OptionName,
    char *OptionValue,
    int *OptionLength
    )

/*++

Routine Description:

    getsockopt() retrieves the current value for a socket option
    associated with a socket of any type, in any state, and stores the
    result in optval.  Options may exist at multiple protocol levels,
    but they are always present at the uppermost "socket'' level.
    Options affect socket operations, such as whether an operation
    blocks or not, the routing of packets, out-of-band data transfer,
    etc.

    The value associated with the selected option is returned in the
    buffer optval.  The integer pointed to by optlen should originally
    contain the size of this buffer; on return, it will be set to the
    size of the value returned.  For SO_LINGER, this will be the size of
    a struct linger; for all other options it will be the size of an
    integer.

    If the option was never set with setsockopt(), then getsockopt()
    returns the default value for the option.

    The following options are supported for
    getsockopt().  The Type identifies the type of
    data addressed by optval.

         Value         Type     Meaning

         SO_ACCEPTCONN BOOL     Socket is listen()ing.

         SO_BROADCAST  BOOL     Socket is configured for the transmission
                                of broadcast messages.

         SO_DEBUG      BOOL     Debugging is enabled.

         SO_DONTLINGER BOOL     If true, the SO_LINGER option is disabled.

         SO_DONTROUTE  BOOL     Routing is disabled.

         SO_ERROR      int      Retrieve error status and clear.

         SO_KEEPALIVE  BOOL     Keepalives are being sent.

         SO_LINGER     struct   Returns the current linger
                       linger   options.
                       FAR *

         SO_OOBINLINE  BOOL     Out-of-band data is being received in the
                                normal data stream.

         SO_RCVBUF     int      Buffer size for receives

         SO_REUSEADDR  BOOL     The socket may be bound to an address which
                                is already in use.

         SO_SNDBUF     int      Buffer size for sends

         SO_TYPE       int      The type of the socket (e.g. SOCK_STREAM).

Arguments:

    s - A descriptor identifying a socket.

    level - The level at which the option is defined; the only supported
        level is SOL_SOCKET.

    optname - The socket option for which the value is to be retrieved.

    optval - A pointer to the buffer in which the value for the
        requested option is to be returned.

    optlen - A pointer to the size of the optval buffer.

Return Value:

    If no error occurs, getsockopt() returns 0.  Otherwise, a value of
    SOCKET_ERROR is returned, and a specific error code may be retrieved
    by calling WSAGetLastError().

--*/

{
    ULONG error;
#undef getsockopt
    extern int WSAAPI getsockopt( SOCKET s, int level, int optname,
                                        char FAR * optval, int FAR * optlen );

    //
    // Set up locals so that we know how to clean up on exit.
    //

    error = NO_ERROR;

    //
    // Map the old IP multicast values to their BSD equivilants.
    //

    if( Level == IPPROTO_IP ) {

        OptionName = MapOldIpMulticastOptionToBsdValue( OptionName );

    }

    //
    // Handle TCP_BSDURGENT specially.
    //

    if( Level == IPPROTO_TCP && OptionName == TCP_BSDURGENT ) {

        if( getsockopt(
                Handle,
                Level,
                TCP_EXPEDITED_1122,
                OptionValue,
                OptionLength
                ) == SOCKET_ERROR ) {

            return SOCKET_ERROR;

        }

        //
        // TCP_BSDURGENT is the inverse of TCP_EXPEDITED_1122.
        //

        *OptionValue = !(*OptionValue);
        goto exit;

    }

    //
    // Forward it to the "real" WS2_32.DLL.
    //

    if( getsockopt(
            Handle,
            Level,
            OptionName,
            OptionValue,
            OptionLength
            ) == SOCKET_ERROR ) {

        return SOCKET_ERROR;

    }

exit:

    if ( error != NO_ERROR ) {
        SetLastError( error );
        return SOCKET_ERROR;
    }

    return NO_ERROR;

} // getsockopt


int PASCAL
setsockopt(
    IN SOCKET Handle,
    IN int Level,
    IN int OptionName,
    IN const char *OptionValue,
    IN int OptionLength
    )

/*++

Routine Description:

    setsockopt() sets the current value for a socket option associated
    with a socket of any type, in any state.  Although options may exist
    at multiple protocol levels, this specification only defines options
    that exist at the uppermost "socket'' level.  Options affect socket
    operations, such as whether expedited data is received in the normal
    data stream, whether broadcast messages may be sent on the socket,
    etc.

    There are two types of socket options: Boolean options that enable
    or disable a feature or behavior, and options which require an
    integer value or structure.  To enable a Boolean option, optval
    points to a nonzero integer.  To disable the option optval points to
    an integer equal to zero.  optlen should be equal to sizeof(int) for
    Boolean options.  For other options, optval points to the an integer
    or structure that contains the desired value for the option, and
    optlen is the length of the integer or structure.

    SO_LINGER controls the action taken when unsent data is queued on a
    socket and a closesocket() is performed.  See closesocket() for a
    description of the way in which the SO_LINGER settings affect the
    semantics of closesocket().  The application sets the desired
    behavior by creating a struct linger (pointed to by the optval
    argument) with the following elements:

        struct linger {
             int  l_onoff;
             int  l_linger;
        }

    To enable SO_LINGER, the application should set l_onoff to a
    non-zero value, set l_linger to 0 or the desired timeout (in
    seconds), and call setsockopt().  To enable SO_DONTLINGER (i.e.
    disable SO_LINGER) l_onoff should be set to zero and setsockopt()
    should be called.

    By default, a socket may not be bound (see bind()) to a local
    address which is already in use.  On occasions, however, it may be
    desirable to "re- use" an address in this way.  Since every
    connection is uniquely identified by the combination of local and
    remote addresses, there is no problem with having two sockets bound
    to the same local address as long as the remote addresses are
    different.  To inform the Windows Sockets implementation that a
    bind() on a socket should not be disallowed because of address
    re-use, the application should set the SO_REUSEADDR socket option
    for the socket before issuing the bind().  Note that the option is
    interpreted only at the time of the bind(): it is therefore
    unnecessary (but harmless) to set the option on a socket which is
    not to be bound to an existing address, and setting or resetting the
    option after the bind() has no effect on this or any other socket..

    An application may request that the Windows Sockets implementation
    enable the use of "keep- alive" packets on TCP connections by
    turning on the SO_KEEPALIVE socket option.  A Windows Sockets
    implementation need not support the use of keep- alives: if it does,
    the precise semantics are implementation-specific but should conform
    to section 4.2.3.6 of RFC 1122: Requirements for Internet Hosts --
    Communication Layers.  If a connection is dropped as the result of
    "keep- alives" the error code WSAENETRESET is returned to any calls
    in progress on the socket, and any subsequent calls will fail with
    WSAENOTCONN.

    The following options are supported for setsockopt().  The Type
    identifies the type of data addressed by optval.

         Value         Type     Meaning

         SO_ACCEPTCONN BOOL     Socket is listen()ing.

         SO_BROADCAST  BOOL     Socket is configured for the transmission
                                of broadcast messages.

         SO_DEBUG      BOOL     Debugging is enabled.

         SO_DONTLINGER BOOL     If true, the SO_LINGER option is disabled.

         SO_DONTROUTE  BOOL     Routing is disabled.

         SO_ERROR      int      Retrieve error status and clear.

         SO_KEEPALIVE  BOOL     Keepalives are being sent.

         SO_LINGER     struct   Returns the current linger
                       linger   options.
                       FAR *

         SO_OOBINLINE  BOOL     Out-of-band data is being received in the
                                normal data stream.

         SO_RCVBUF     int      Buffer size for receives

         SO_REUSEADDR  BOOL     The socket may be bound to an address which
                                is already in use.

         SO_SNDBUF     int      Buffer size for sends

         SO_TYPE       int      The type of the socket (e.g. SOCK_STREAM).

Arguments:

Return Value:

    If no error occurs, setsockopt() returns 0.  Otherwise, a value of
    SOCKET_ERROR is returned, and a specific error code may be retrieved
    by calling WSAGetLastError().

--*/

{
    ULONG error;
    INT optionValue;
    INT invertedValue;
    char FAR * valuePointer;

#undef setsockopt
    extern int WSAAPI setsockopt( SOCKET s, int level, int optname,
                                        const char FAR * optval, int optlen );

    //
    // Set up locals so that we know how to clean up on exit.
    //

    error = NO_ERROR;

    //
    // Map the old IP multicast values to their BSD equivilants.
    //

    if( Level == IPPROTO_IP ) {

        OptionName = MapOldIpMulticastOptionToBsdValue( OptionName );

    }

    //
    // Handle TCP_BSDURGENT specially.
    //

    valuePointer = (char FAR *)OptionValue;

    if( Level == IPPROTO_TCP && OptionName == TCP_BSDURGENT ) {

        OptionName = TCP_EXPEDITED_1122;

        if( OptionLength >= sizeof(INT) ) {

            invertedValue = !(*OptionValue);
            valuePointer = (char FAR *)&invertedValue;
            OptionLength = sizeof(invertedValue);

        }

    }

    return setsockopt(
               Handle,
               Level,
               OptionName,
               valuePointer,
               OptionLength
               );

} // setsockopt


INT
MapOldIpMulticastOptionToBsdValue(
    INT OptionName
    )
{

    switch( OptionName ) {

    case OLD_IP_MULTICAST_IF :
        OptionName = IP_MULTICAST_IF;
        break;

    case OLD_IP_MULTICAST_TTL :
        OptionName = IP_MULTICAST_TTL;
        break;

    case OLD_IP_MULTICAST_LOOP :
        OptionName = IP_MULTICAST_LOOP;
        break;

    case OLD_IP_ADD_MEMBERSHIP :
        OptionName = IP_ADD_MEMBERSHIP;
        break;

    case OLD_IP_DROP_MEMBERSHIP :
        OptionName = IP_DROP_MEMBERSHIP;
        break;

    case OLD_IP_TTL :
        OptionName = IP_TTL;
        break;

    case OLD_IP_TOS :
        OptionName = IP_TOS;
        break;

    case OLD_IP_DONTFRAGMENT :
        OptionName = IP_DONTFRAGMENT;
        break;
    }

    return OptionName;

}   // MapOldIpMulticastOptionToBsdValue


int WSAAPI
recv(
     IN SOCKET s,
     OUT char FAR * buf,
     IN int len,
     IN int flags
     )
/*++
Routine Description:

    Receive data from a socket.

Arguments:

    s     - A descriptor identifying a connected socket.

    buf   - A buffer for the incoming data.

    len   - The length of buf.

    flags - Specifies the way in which the call is made.

Returns:

    The  number  of  bytes  received.   If  the  connection has been gracefully
    closed,  the  return  value  is  0.   Otherwise, a value of SOCKET_ERROR is
    returned, and a specific error code is stored with SetErrorCode().

--*/

{
    INT     ReturnValue;
    WSABUF  Buffers;
    DWORD   LocalFlags;
    INT     ErrorCode;

    Buffers.len = len;
    Buffers.buf = buf;
    LocalFlags = (DWORD) flags;

    ErrorCode = WSARecv(s,
            &Buffers,
            1, // Buffer count
            (LPDWORD)&ReturnValue,
            &LocalFlags,
            NULL,
            NULL);
    if (SOCKET_ERROR == ErrorCode) {
        ReturnValue = SOCKET_ERROR;
    } else if (LocalFlags & MSG_PARTIAL) {

        // If the receive was a partial message (won't happen on a
        // streams transport like TCP) set the last error to
        // WSAEMSGSIZE and negate ths number of bytes received.
        // This allows the app to know that the receive was partial
        // and also how many bytes were received.
        //

        ReturnValue *= -1;
        SetLastError (WSAEMSGSIZE);
    }

    return(ReturnValue);
}


int WSAAPI
recvfrom(
    IN SOCKET s,
    OUT char FAR * buf,
    IN int len,
    IN int flags,
    OUT struct sockaddr FAR *from,
    IN OUT int FAR * fromlen
    )
/*++
Routine Description:

    Receive a datagram and store the source address.

Arguments:

    s       - A descriptor identifying a bound socket.

    buf     - A buffer for the incoming data.

    len     - The length of buf.

    flags   - Specifies the way in which the call is made.

    from    - An  optional  pointer  to  a  buffer  which  will hold the source
              address upon return.

    fromlen - An optional pointer to the size of the from buffer.

Returns:

    The  number  of  bytes  received.   If  the  connection has been gracefully
    closed,  the  return  value  is  0.   Otherwise, a value of SOCKET_ERROR is
    returned, and a specific error code is stored with SetErrorCode().

--*/

{
    INT     ReturnValue;
    WSABUF  Buffers;
    DWORD   LocalFlags;
    INT     ErrorCode;

    Buffers.len = len;
    Buffers.buf = buf;
    LocalFlags = (DWORD) flags;

    ErrorCode = WSARecvFrom(s,
                &Buffers,
                1,
                (LPDWORD)&ReturnValue,
                &LocalFlags,
                from,
                fromlen,
                NULL,
                NULL);

    if (SOCKET_ERROR == ErrorCode) {
        ReturnValue = SOCKET_ERROR;
    } else if (LocalFlags & MSG_PARTIAL) {

        // If the receive was a partial message (won't happen on a
        // streams transport like TCP) set the last error to
        // WSAEMSGSIZE and negate ths number of bytes received.
        // This allows the app to know that the receive was partial
        // and also how many bytes were received.
        //

        ReturnValue *= -1;
        SetLastError (WSAEMSGSIZE);
    }

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\afddata.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    afddata.h

Abstract:

    This module declares global data for AFD.

Author:

    David Treadwell (davidtr)    21-Feb-1992

Revision History:
    Vadim Eydelman (vadime)
        1998-1999   NT5.0 optimizations

--*/

#ifndef _AFDDATA_
#define _AFDDATA_

extern PDEVICE_OBJECT AfdDeviceObject;


extern LIST_ENTRY AfdEndpointListHead;
extern LIST_ENTRY AfdConstrainedEndpointListHead;

extern LIST_ENTRY AfdPollListHead;
extern AFD_QSPIN_LOCK AfdPollListLock;

extern LIST_ENTRY AfdTransportInfoListHead;
extern KEVENT AfdContextWaitEvent;
#define AFD_CONTEXT_BUSY    ((PVOID)-1)
#define AFD_CONTEXT_WAITING ((PVOID)-2)

extern PKPROCESS AfdSystemProcess;
extern FAST_IO_DISPATCH AfdFastIoDispatch;

//
// Global data which must always be in nonpaged pool,
// even when the driver is paged out (resource, lookaside lists).
//
PAFD_GLOBAL_DATA AfdGlobalData;
#define AfdResource  (&AfdGlobalData->Resource)
#define AfdLookasideLists (AfdGlobalData)
#define AfdAlignmentTable (AfdGlobalData->BufferAlignmentTable)

//
// Globals for dealing with AFD's executive worker thread.
//

extern LIST_ENTRY AfdWorkQueueListHead;
extern BOOLEAN AfdWorkThreadRunning;
extern PIO_WORKITEM AfdWorkQueueItem;

//
// Globals to track the buffers used by AFD.
//

extern ULONG AfdLargeBufferListDepth;
#define AFD_SM_DEFAULT_LARGE_LIST_DEPTH 0
#define AFD_MM_DEFAULT_LARGE_LIST_DEPTH 2
#define AFD_LM_DEFAULT_LARGE_LIST_DEPTH 10

extern ULONG AfdMediumBufferListDepth;
#define AFD_SM_DEFAULT_MEDIUM_LIST_DEPTH 4
#define AFD_MM_DEFAULT_MEDIUM_LIST_DEPTH 8
#define AFD_LM_DEFAULT_MEDIUM_LIST_DEPTH 24

extern ULONG AfdSmallBufferListDepth;
#define AFD_SM_DEFAULT_SMALL_LIST_DEPTH 8
#define AFD_MM_DEFAULT_SMALL_LIST_DEPTH 16
#define AFD_LM_DEFAULT_SMALL_LIST_DEPTH 32

extern ULONG AfdBufferTagListDepth;
#define AFD_SM_DEFAULT_TAG_LIST_DEPTH 16
#define AFD_MM_DEFAULT_TAG_LIST_DEPTH 32
#define AFD_LM_DEFAULT_TAG_LIST_DEPTH 64

extern ULONG AfdLargeBufferSize;
// default value is AfdBufferLengthForOnePage

extern ULONG AfdMediumBufferSize;
#define AFD_DEFAULT_MEDIUM_BUFFER_SIZE 1504

extern ULONG AfdSmallBufferSize;
#define AFD_DEFAULT_SMALL_BUFFER_SIZE 128

extern ULONG AfdBufferTagSize;
#define AFD_DEFAULT_TAG_BUFFER_SIZE 0

extern ULONG AfdStandardAddressLength;
#define AFD_DEFAULT_STD_ADDRESS_LENGTH sizeof(TA_IP_ADDRESS)

extern ULONG AfdBufferLengthForOnePage;
extern ULONG AfdBufferAlignment;
#define AFD_MINIMUM_BUFFER_ALIGNMENT                        \
    max(TYPE_ALIGNMENT(TRANSPORT_ADDRESS),                  \
        max(TYPE_ALIGNMENT(KAPC),                           \
            max(TYPE_ALIGNMENT(WORK_QUEUE_ITEM),            \
                max(TYPE_ALIGNMENT(AFD_BUFFER),             \
                    max(TYPE_ALIGNMENT(MDL),                \
                        max(TYPE_ALIGNMENT(IRP),            \
                            MEMORY_ALLOCATION_ALIGNMENT))))))

extern ULONG AfdAlignmentTableSize;
extern ULONG AfdAlignmentOverhead;
extern ULONG AfdBufferOverhead;

//
// Globals for tuning TransmitFile().
//

extern LIST_ENTRY AfdQueuedTransmitFileListHead;
extern AFD_QSPIN_LOCK AfdQueuedTransmitFileSpinLock;
extern ULONG AfdActiveTransmitFileCount;
extern ULONG AfdMaxActiveTransmitFileCount;
#define AFD_DEFAULT_MAX_ACTIVE_TRANSMIT_FILE_COUNT 2

extern ULONG AfdDefaultTransmitWorker;
#define AFD_DEFAULT_TRANSMIT_WORKER AFD_TF_USE_SYSTEM_THREAD

#define AFD_MAX_FAST_TRANSPORT_ADDRESS sizeof (TA_IP6_ADDRESS)
//
// Various pieces of configuration information, with default values.
//

extern CCHAR AfdIrpStackSize;
extern CCHAR AfdTdiStackSize;
#ifdef _AFD_VARIABLE_STACK_
extern CCHAR AfdMaxStackSize;
#endif // _AFD_VARIABLE_STACK_
#define AFD_DEFAULT_IRP_STACK_SIZE 4

extern CCHAR AfdPriorityBoost;
#define AFD_DEFAULT_PRIORITY_BOOST 2

extern ULONG AfdBlockingSendCopyThreshold;
#define AFD_BLOCKING_SEND_COPY_THRESHOLD 65536
extern ULONG AfdFastSendDatagramThreshold;
#define AFD_FAST_SEND_DATAGRAM_THRESHOLD 1024
extern ULONG AfdTPacketsCopyThreshold;
#define AFD_TPACKETS_COPY_THRESHOLD AFD_DEFAULT_MEDIUM_BUFFER_SIZE

extern PVOID AfdDiscardableCodeHandle;
extern PKEVENT AfdLoaded;
extern AFD_WORK_ITEM AfdUnloadWorker;
extern BOOLEAN AfdVolatileConfig;
extern HANDLE AfdParametersNotifyHandle;
extern WORK_QUEUE_ITEM AfdParametersNotifyWorker;
extern PKEVENT AfdParametersUnloadEvent;

//
// Various globals for SAN
//
extern HANDLE AfdSanCodeHandle;
extern LIST_ENTRY AfdSanHelperList;
extern PAFD_ENDPOINT   AfdSanServiceHelper;
extern HANDLE  AfdSanServicePid;
extern POBJECT_TYPE IoCompletionObjectType;
extern LONG AfdSanProviderListSeqNum;

extern ULONG AfdReceiveWindowSize;
#define AFD_LM_DEFAULT_RECEIVE_WINDOW 8192
#define AFD_MM_DEFAULT_RECEIVE_WINDOW 8192
#define AFD_SM_DEFAULT_RECEIVE_WINDOW 4096

extern ULONG AfdSendWindowSize;
#define AFD_LM_DEFAULT_SEND_WINDOW 8192
#define AFD_MM_DEFAULT_SEND_WINDOW 8192
#define AFD_SM_DEFAULT_SEND_WINDOW 4096

extern ULONG AfdBufferMultiplier;
#define AFD_DEFAULT_BUFFER_MULTIPLIER 4

extern ULONG AfdTransmitIoLength;
#define AFD_LM_DEFAULT_TRANSMIT_IO_LENGTH 65536
#define AFD_MM_DEFAULT_TRANSMIT_IO_LENGTH (PAGE_SIZE*2)
#define AFD_SM_DEFAULT_TRANSMIT_IO_LENGTH PAGE_SIZE

extern ULONG AfdMaxFastTransmit;
#define AFD_DEFAULT_MAX_FAST_TRANSMIT 65536
extern ULONG AfdMaxFastCopyTransmit;
#define AFD_DEFAULT_MAX_FAST_COPY_TRANSMIT 128

extern LONG AfdEndpointsOpened;
extern LONG AfdEndpointsCleanedUp;
extern LONG AfdEndpointsClosed;
#define AFD_ENDPOINTS_FREEING_MAX       10
extern LONG AfdEndpointsFreeing;
#define AFD_CONNECTIONS_FREEING_MAX     10
extern LONG AfdConnectionsFreeing;

extern BOOLEAN AfdIgnorePushBitOnReceives;

extern BOOLEAN AfdEnableDynamicBacklog;
#define AFD_DEFAULT_ENABLE_DYNAMIC_BACKLOG FALSE

extern LONG AfdMinimumDynamicBacklog;
#define AFD_DEFAULT_MINIMUM_DYNAMIC_BACKLOG 0

extern LONG AfdMaximumDynamicBacklog;
#define AFD_DEFAULT_MAXIMUM_DYNAMIC_BACKLOG 0

extern LONG AfdDynamicBacklogGrowthDelta;
#define AFD_DEFAULT_DYNAMIC_BACKLOG_GROWTH_DELTA 0

// Maximum number of free connections that we keep
// on listening endpoint. This is not the same as a backlog,
// it is just a policy on connection object reuse via AcceptEx
// We stop reusing if we have that many free objects in the list
// Currently the main reason for this limit is the ability to use the
// SLists which have USHORT for item count.
#define AFD_MAXIMUM_FREE_CONNECTIONS    32767

//
// These are limits on backlog in AFD_START_LISTEN
// Application can work around this limit by posting AcceptEx(-s)
//
#define AFD_MAXIMUM_BACKLOG_NTS         200
#define AFD_MAXIMUM_BACKLOG_NTW         5
#define AFD_MINIMUM_BACKLOG             1

extern BOOLEAN AfdDisableRawSecurity;
extern PSECURITY_DESCRIPTOR AfdAdminSecurityDescriptor;
extern SECURITY_DESCRIPTOR  AfdEmptySd;

extern BOOLEAN AfdDisableDirectSuperAccept;
extern BOOLEAN AfdDisableChainedReceive;
#ifdef TDI_SERVICE_SEND_AND_DISCONNECT
extern BOOLEAN AfdUseTdiSendAndDisconnect;
#endif //TDI_SERVICE_SEND_AND_DISCONNECT

#define AFD_MINIMUM_TPINFO_ELEMENT_COUNT    3 // For transmit file compatibility.
extern ULONG   AfdDefaultTpInfoElementCount;
//
// Data for transport address lists and queued change queries
//
extern HANDLE          AfdBindingHandle;
extern LIST_ENTRY      AfdAddressEntryList;
extern LIST_ENTRY      AfdAddressChangeList;
extern PERESOURCE      AfdAddressListLock;
extern AFD_QSPIN_LOCK  AfdAddressChangeLock;
extern PERESOURCE      AfdTdiPnPHandlerLock;
extern AFD_WORK_ITEM   AfdPnPDeregisterWorker;


extern IO_STATUS_BLOCK AfdDontCareIoStatus;
// Holds TDI connect timeout (-1).
extern const LARGE_INTEGER AfdInfiniteTimeout;
                        



extern SLIST_HEADER    AfdLRList;

extern KDPC            AfdLRListDpc;
extern KTIMER          AfdLRListTimer;
extern AFD_WORK_ITEM   AfdLRListWorker;
extern LONG            AfdLRListCount;
extern SLIST_HEADER    AfdLRFileMdlList;
extern AFD_LR_LIST_ITEM AfdLRFileMdlListItem;


#if AFD_PERF_DBG

extern LONG AfdFullReceiveIndications;
extern LONG AfdPartialReceiveIndications;

extern LONG AfdFullReceiveDatagramIndications;
extern LONG AfdPartialReceiveDatagramIndications;

extern LONG AfdFastSendsSucceeded;
extern LONG AfdFastSendsFailed;
extern LONG AfdFastReceivesSucceeded;
extern LONG AfdFastReceivesFailed;

extern LONG AfdFastSendDatagramsSucceeded;
extern LONG AfdFastSendDatagramsFailed;
extern LONG AfdFastReceiveDatagramsSucceeded;
extern LONG AfdFastReceiveDatagramsFailed;

extern LONG AfdFastReadsSucceeded;
extern LONG AfdFastReadsFailed;
extern LONG AfdFastWritesSucceeded;
extern LONG AfdFastWritesFailed;

extern LONG AfdFastTfSucceeded;
extern LONG AfdFastTfFailed;
extern LONG AfdFastTfReadFailed;

extern LONG AfdTPWorkersExecuted;
extern LONG AfdTPRequests;

extern BOOLEAN AfdDisableFastIo;
extern BOOLEAN AfdDisableConnectionReuse;

#endif  // if AFD_PERF_DBG

#if AFD_KEEP_STATS

extern AFD_QUOTA_STATS AfdQuotaStats;
extern AFD_HANDLE_STATS AfdHandleStats;
extern AFD_QUEUE_STATS AfdQueueStats;
extern AFD_CONNECTION_STATS AfdConnectionStats;

#endif // if AFD_KEEP_STATS

#if DBG
extern BOOLEAN AfdUsePrivateAssert;
#endif

#ifdef _WIN64
extern QOS32 AfdDefaultQos32;
#endif
extern QOS AfdDefaultQos;

ULONG AfdIoctlTable[AFD_NUM_IOCTLS];
PAFD_IMMEDIATE_CALL AfdImmediateCallDispatch[AFD_NUM_IOCTLS];
PAFD_IRP_CALL AfdIrpCallDispatch[AFD_NUM_IOCTLS];


#define AFD_FAST_CONNECT_DATA_SIZE  256
#endif // ndef _AFDDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\afdp.h ===
/*+r

Copyright (c) 1989  Microsoft Corporation

Module Name:

    afd.h

Abstract:

    This is the local header file for AFD.  It includes all other
    necessary header files for AFD.

Author:

    David Treadwell (davidtr)    21-Feb-1992

Revision History:

--*/

#ifndef _AFDP_
#define _AFDP_

#ifdef _AFD_W4_
    //
    // These are warning that we are willing to ignore.
    //
    #pragma warning(disable:4214)   // bit field types other than int
    #pragma warning(disable:4201)   // nameless struct/union
    #pragma warning(disable:4127)   // condition expression is constant
    #pragma warning(disable:4115)   // named type definition in parentheses
    //#pragma warning(disable:4206)   // translation unit empty
    //#pragma warning(disable:4706)   // assignment within conditional
    #pragma warning(disable:4324)   // structure was padded
    #pragma warning(disable:4327)   // idirection alignment of LHS is greater than RHS
    #pragma warning(disable:4328)   // greater alignment than needed
    #pragma warning(disable:4054)   // cast of function pointer to PVOID

    //
    // Extra initialization to allow compiler check for use of uninitialized
    // variables at w4 level.  Currently this mostly affects status set
    // inside of the exception filter as follows:
    //      __try {} __except (status=1,EXCEPTION_EXECUTE_HANDLER) { NT_ERROR (status)}
    // NT_ERROR(status) - generates uninitialized variable warning and it shouldn't
    //
    #define AFD_W4_INIT

#else

    #define AFD_W4_INIT if (FALSE)

#endif

#include <ntosp.h>
#include <zwapi.h>
#include <tdikrnl.h>


#ifndef _AFDKDP_H_
extern POBJECT_TYPE *ExEventObjectType;
#endif  // _AFDKDP_H_


#if DBG

#ifndef AFD_PERF_DBG
#define AFD_PERF_DBG   1
#endif

#ifndef AFD_KEEP_STATS
#define AFD_KEEP_STATS 1
#endif

#else

#ifndef AFD_PERF_DBG
#define AFD_PERF_DBG   0
#endif

#ifndef AFD_KEEP_STATS
#define AFD_KEEP_STATS 0
#endif

#endif  // DBG

//
// Hack-O-Rama. TDI has a fundamental flaw in that it is often impossible
// to determine exactly when a TDI protocol is "done" with a connection
// object. The biggest problem here is that AFD may get a suprious TDI
// indication *after* an abort request has completed. As a temporary work-
// around, whenever an abort request completes, we'll start a timer. AFD
// will defer further processing on the connection until that timer fires.
//
// If the following symbol is defined, then our timer hack is enabled.
// Afd now uses InterlockedCompareExchange to protect itself
//

// #define ENABLE_ABORT_TIMER_HACK 0

//
// The following constant defines the relative time interval (in seconds)
// for the "post abort request complete" timer.
//

// #define AFD_ABORT_TIMER_TIMEOUT_VALUE 5 // seconds

//
// Goodies stolen from other header files.
//

#ifndef FAR
#define FAR
#endif

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

typedef unsigned short u_short;

#ifndef SG_UNCONSTRAINED_GROUP
#define SG_UNCONSTRAINED_GROUP   0x01
#endif

#ifndef SG_CONSTRAINED_GROUP
#define SG_CONSTRAINED_GROUP     0x02
#endif


#include <afd.h>
#include "afdstr.h"
#include "afddata.h"
#include "afdprocs.h"

#define AFD_EA_POOL_TAG                 ( (ULONG)'AdfA' | PROTECTED_POOL )
#define AFD_DATA_BUFFER_POOL_TAG        ( (ULONG)'BdfA' | PROTECTED_POOL )
#define AFD_CONNECTION_POOL_TAG         ( (ULONG)'CdfA' | PROTECTED_POOL )
#define AFD_CONNECT_DATA_POOL_TAG       ( (ULONG)'cdfA' | PROTECTED_POOL )
#define AFD_DEBUG_POOL_TAG              ( (ULONG)'DdfA' | PROTECTED_POOL )
#define AFD_ENDPOINT_POOL_TAG           ( (ULONG)'EdfA' | PROTECTED_POOL )
#define AFD_TRANSMIT_INFO_POOL_TAG      ( (ULONG)'FdfA' | PROTECTED_POOL )
#define AFD_GROUP_POOL_TAG              ( (ULONG)'GdfA' | PROTECTED_POOL )
#define AFD_ADDRESS_CHANGE_POOL_TAG     ( (ULONG)'hdfA' | PROTECTED_POOL )
#define AFD_TDI_POOL_TAG                ( (ULONG)'IdfA' | PROTECTED_POOL )
#define AFD_LOCAL_ADDRESS_POOL_TAG      ( (ULONG)'LdfA' | PROTECTED_POOL )
#define AFD_POLL_POOL_TAG               ( (ULONG)'PdfA' | PROTECTED_POOL )
#define AFD_TRANSPORT_IRP_POOL_TAG      ( (ULONG)'pdfA' | PROTECTED_POOL )
#define AFD_ROUTING_QUERY_POOL_TAG      ( (ULONG)'qdfA' | PROTECTED_POOL )
#define AFD_REMOTE_ADDRESS_POOL_TAG     ( (ULONG)'RdfA' | PROTECTED_POOL )
#define AFD_RESOURCE_POOL_TAG           ( (ULONG)'rdfA' | PROTECTED_POOL )
// Can't be protected - freed by kernel.
#define AFD_SECURITY_POOL_TAG           ( (ULONG)'SdfA' )
// Can't be protected - freed by kernel.
#define AFD_SYSTEM_BUFFER_POOL_TAG      ( (ULONG)'sdfA' )
#define AFD_TRANSPORT_ADDRESS_POOL_TAG  ( (ULONG)'tdfA' | PROTECTED_POOL )
#define AFD_TRANSPORT_INFO_POOL_TAG     ( (ULONG)'TdfA' | PROTECTED_POOL )
#define AFD_TEMPORARY_POOL_TAG          ( (ULONG)' dfA' | PROTECTED_POOL )
#define AFD_CONTEXT_POOL_TAG            ( (ULONG)'XdfA' | PROTECTED_POOL )
#define AFD_SAN_CONTEXT_POOL_TAG        ( (ULONG)'xdfA' | PROTECTED_POOL )

#define MyFreePoolWithTag(a,t) ExFreePoolWithTag(a,t)

#if DBG

extern ULONG AfdDebug;

#undef IF_DEBUG
#define IF_DEBUG(a) if ( (AFD_DEBUG_ ## a & AfdDebug) != 0 )

#define AFD_DEBUG_OPEN_CLOSE        0x00000001
#define AFD_DEBUG_ENDPOINT          0x00000002
#define AFD_DEBUG_CONNECTION        0x00000004
#define AFD_DEBUG_EVENT_SELECT      0x00000008

#define AFD_DEBUG_BIND              0x00000010
#define AFD_DEBUG_CONNECT           0x00000020
#define AFD_DEBUG_LISTEN            0x00000040
#define AFD_DEBUG_ACCEPT            0x00000080

#define AFD_DEBUG_SEND              0x00000100
#define AFD_DEBUG_QUOTA             0x00000200
#define AFD_DEBUG_RECEIVE           0x00000400
#define AFD_DEBUG_11                0x00000800

#define AFD_DEBUG_POLL              0x00001000
#define AFD_DEBUG_FAST_IO           0x00002000
#define AFD_DEBUG_ROUTING_QUERY     0x00010000
#define AFD_DEBUG_ADDRESS_LIST      0x00020000
#define AFD_DEBUG_TRANSMIT          0x00100000

#define AFD_DEBUG_SAN_SWITCH        0x00200000

#define DEBUG

#else // DBG

#undef IF_DEBUG
#define IF_DEBUG(a) if (FALSE)
#define DEBUG if ( FALSE )

#endif // DBG

//
// Make some of the receive code a bit prettier.
//

#define TDI_RECEIVE_EITHER ( TDI_RECEIVE_NORMAL | TDI_RECEIVE_EXPEDITED )

#endif // ndef _AFDP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\afdprocs.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    afdprocs.h

Abstract:

    This module contains routine prototypes for AFD.

Author:

    David Treadwell (davidtr)    21-Feb-1992

Revision History:

--*/

#ifndef _AFDPROCS_
#define _AFDPROCS_

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
FASTCALL
AfdAccept (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
FASTCALL
AfdSuperAccept (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
FASTCALL
AfdDeferAccept (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
AfdRestartSuperAccept (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
AfdCancelSuperAccept (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
AfdCleanupSuperAccept (
    IN PIRP Irp,
    IN NTSTATUS Status
    );


BOOLEAN
AfdServiceSuperAccept (
    IN  PAFD_ENDPOINT   Endpoint,
    IN  PAFD_CONNECTION Connection,
    IN  PAFD_LOCK_QUEUE_HANDLE LockHandle,
    OUT PLIST_ENTRY     AcceptIrpList
    );

NTSTATUS
AfdAcceptCore (
    IN PIRP          AcceptIrp,
    IN PAFD_ENDPOINT AcceptEndpoint,
    IN PAFD_CONNECTION Connection
    );

NTSTATUS
AfdSetupAcceptEndpoint (
    PAFD_ENDPOINT   ListenEndpoint,
    PAFD_ENDPOINT   AcceptEndpoint,
    PAFD_CONNECTION Connection
    );

VOID
AfdRestartSuperAcceptListen (
    IN PIRP Irp,
    IN PAFD_CONNECTION Connection
    );

NTSTATUS
AfdRestartDelayedSuperAccept (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

PMDL
AfdAdvanceMdlChain(
    IN PMDL Mdl,
    IN ULONG Offset
    );

#ifdef _WIN64
NTSTATUS
AfdAllocateMdlChain32(
    IN PIRP Irp,
    IN LPWSABUF32 BufferArray,
    IN ULONG BufferCount,
    IN LOCK_OPERATION Operation,
    OUT PULONG TotalByteCount
    );
#endif

NTSTATUS
AfdAllocateMdlChain(
    IN PIRP Irp,
    IN LPWSABUF BufferArray,
    IN ULONG BufferCount,
    IN LOCK_OPERATION Operation,
    OUT PULONG TotalByteCount
    );

BOOLEAN
AfdAreTransportAddressesEqual (
    IN PTRANSPORT_ADDRESS EndpointAddress,
    IN ULONG EndpointAddressLength,
    IN PTRANSPORT_ADDRESS RequestAddress,
    IN ULONG RequestAddressLength,
    IN BOOLEAN HonorWildcardIpPortInEndpointAddress
    );

NTSTATUS
AfdBeginAbort (
    IN PAFD_CONNECTION Connection
    );

NTSTATUS
AfdBeginDisconnect (
    IN PAFD_ENDPOINT Endpoint,
    IN PLARGE_INTEGER Timeout OPTIONAL,
    OUT PIRP *DisconnectIrp OPTIONAL
    );

NTSTATUS
FASTCALL
AfdBind (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

ULONG
AfdCalcBufferArrayByteLength(
    IN LPWSABUF BufferArray,
    IN ULONG BufferCount
    );

VOID
AfdCancelReceiveDatagram (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FASTCALL
AfdCleanup (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
FASTCALL
AfdClose (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
AfdCompleteIrpList (
    IN PLIST_ENTRY IrpListHead,
    IN PAFD_ENDPOINT Endpoint,
    IN NTSTATUS Status,
    IN PAFD_IRP_CLEANUP_ROUTINE CleanupRoutine OPTIONAL
    );

VOID
AfdCompleteClosePendedTransmit (
    IN PVOID    Context
    );

NTSTATUS
FASTCALL
AfdConnect (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
FASTCALL
AfdJoinLeaf (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
FASTCALL
AfdSuperConnect (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
AfdConnectEventHandler (
    IN PVOID TdiEventContext,
    IN int RemoteAddressLength,
    IN PVOID RemoteAddress,
    IN int UserDataLength,
    IN PVOID UserData,
    IN int OptionsLength,
    IN PVOID Options,
    OUT CONNECTION_CONTEXT *ConnectionContext,
    OUT PIRP *AcceptIrp
    );

#ifdef _WIN64
ULONG
AfdComputeCMSGLength32 (
    PVOID   ControlBuffer,
    ULONG   ControlLength
    );

VOID
AfdCopyCMSGBuffer32 (
    PVOID   Dst,
    PVOID   ControlBuffer,
    ULONG   CopyLength
    );
#endif //_WIN64

ULONG
AfdCopyBufferArrayToBuffer(
    IN PVOID Destination,
    IN ULONG DestinationLength,
    IN LPWSABUF BufferArray,
    IN ULONG BufferCount
    );

ULONG
AfdCopyBufferToBufferArray(
    IN LPWSABUF BufferArray,
    IN ULONG Offset,
    IN ULONG BufferCount,
    IN PVOID Source,
    IN ULONG SourceLength
    );

ULONG
AfdCopyMdlChainToBufferArray(
    IN LPWSABUF BufferArray,
    IN ULONG BufferOffset,
    IN ULONG BufferCount,
    IN PMDL  Source,
    IN ULONG SourceOffset,
    IN ULONG SourceLength
    );

NTSTATUS
AfdCopyMdlChainToMdlChain (
    PMDL    Destination,
    ULONG   DestinationOffset,
    PMDL    Source,
    ULONG   SourceOffset,
    ULONG   SourceLength,
    PULONG  BytesCopied
    );

NTSTATUS
AfdCopyMdlChainToBufferAvoidMapping(
    IN PMDL     SourceMdl,
    IN ULONG    SourceOffset,
    IN ULONG    SourceLength,
    IN PUCHAR   Buffer,
    IN ULONG    BufferSize
    );

NTSTATUS
AfdMapMdlChain (
    PMDL    MdlChain
    );

NTSTATUS
FASTCALL
AfdCreate (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
AfdDelayedAcceptListen (
    PAFD_ENDPOINT   Endpoint,
    PAFD_CONNECTION Connection
    );

VOID
AfdDestroyMdlChain (
    IN PIRP Irp
    );

NTSTATUS
AfdDisconnectEventHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN int DisconnectDataLength,
    IN PVOID DisconnectData,
    IN int DisconnectInformationLength,
    IN PVOID DisconnectInformation,
    IN ULONG DisconnectFlags
    );

NTSTATUS
AfdDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
AfdDispatchDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FASTCALL
AfdDispatchImmediateIrp(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
AfdEnumNetworkEvents (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    );

NTSTATUS
AfdErrorEventHandler (
    IN PVOID TdiEventContext,
    IN NTSTATUS Status
    );

NTSTATUS
AfdErrorExEventHandler (
    IN PVOID TdiEventContext,
    IN NTSTATUS Status,
    IN PVOID Context
    );

NTSTATUS
AfdEventSelect (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    );

LONG
AfdExceptionFilter(
#if DBG
    IN  PCHAR SourceFile,
    IN  LONG LineNumber,
#endif
    IN  PEXCEPTION_POINTERS ExceptionPointers,
    OUT PNTSTATUS   ExceptionCode OPTIONAL
    );

BOOLEAN
AfdFastTransmitFile (
    IN PAFD_ENDPOINT endpoint,
    IN PAFD_TRANSMIT_FILE_INFO transmitInfo,
    OUT PIO_STATUS_BLOCK IoStatus
    );


VOID
AfdFreeConnectDataBuffers (
    IN PAFD_CONNECT_DATA_BUFFERS ConnectDataBuffers
    );

VOID
AfdFreeQueuedConnections (
    IN PAFD_ENDPOINT Endpoint
    );

NTSTATUS
FASTCALL
AfdGetAddress (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
AfdGetRemoteAddress (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    );

NTSTATUS
AfdGetContext (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    );

NTSTATUS
AfdGetInformation (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    );

NTSTATUS
AfdGetTransportInfo (
    IN  PUNICODE_STRING TransportDeviceName,
    IN OUT PAFD_TRANSPORT_INFO *TransportInfo
    );

NTSTATUS
AfdQueryProviderInfo (
    IN  PUNICODE_STRING TransportDeviceName,
#ifdef _AFD_VARIABLE_STACK_
    OUT CCHAR *StackSize OPTIONAL,
#endif //_AFD_VARIABLE_STACK_
    OUT PTDI_PROVIDER_INFO ProviderInfo
    );

VOID
AfdIndicateEventSelectEvent (
    IN PAFD_ENDPOINT Endpoint,
    IN ULONG PollEventMask,
    IN NTSTATUS Status
    );



VOID
AfdIndicatePollEventReal (
    IN PAFD_ENDPOINT Endpoint,
    IN ULONG PollEventMask,
    IN NTSTATUS Status
    );

#define AfdIndicatePollEvent(_e,_m,_s)  \
    ((_e)->PollCalled ? (AfdIndicatePollEventReal((_e),(_m),(_s)), TRUE) : FALSE)

VOID
AfdInitiateListenBacklogReplenish (
    IN PAFD_ENDPOINT Endpoint
    );

VOID
AfdInitializeData (
    VOID
    );

NTSTATUS
AfdIssueDeviceControl (
    IN PFILE_OBJECT FileObject,
    IN PVOID IrpParameters,
    IN ULONG IrpParametersLength,
    IN PVOID MdlBuffer,
    IN ULONG MdlBufferLength,
    IN UCHAR MinorFunction
    );


VOID
AfdIncrementLockCount (
    VOID
    );

VOID
AfdDecrementLockCount (
    VOID
    );

VOID
AfdInsertNewEndpointInList (
    IN PAFD_ENDPOINT Endpoint
    );

VOID
AfdRemoveEndpointFromList (
    IN PAFD_ENDPOINT Endpoint
    );

PVOID
AfdLockEndpointContext (
    PAFD_ENDPOINT   Endpoint
    );

VOID
AfdUnlockEndpointContext (
    PAFD_ENDPOINT   Endpoint,
    PVOID           Context
    );


NTSTATUS
AfdPartialDisconnect (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    );

NTSTATUS
FASTCALL
AfdPoll (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );


VOID
AfdQueueWorkItem (
    IN PWORKER_THREAD_ROUTINE AfdWorkerRoutine,
    IN PAFD_WORK_ITEM AfdWorkItem
    );

PAFD_WORK_ITEM
AfdGetWorkerByRoutine (
    PWORKER_THREAD_ROUTINE  Routine
    );

NTSTATUS
AfdQueryHandles (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    );

NTSTATUS
AfdQueryReceiveInformation (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    );

NTSTATUS
AfdSetContext (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    );

NTSTATUS
AfdSetEventHandler (
    IN PFILE_OBJECT FileObject,
    IN ULONG EventType,
    IN PVOID EventHandler,
    IN PVOID EventContext
    );

NTSTATUS
AfdSetInLineMode (
    IN PAFD_CONNECTION Connection,
    IN BOOLEAN InLine
    );

NTSTATUS
AfdUnbind (
    IN PAFD_ENDPOINT Endpoint
    );

NTSTATUS
FASTCALL
AfdReceive (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
AfdBReceive (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG RecvFlags,
    IN ULONG AfdFlags,
    IN ULONG RecvLength
    );

NTSTATUS
FASTCALL
AfdReceiveDatagram (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
AfdSetupReceiveDatagramIrp (
    IN PIRP Irp,
    IN PVOID DatagramBuffer OPTIONAL,
    IN ULONG DatagramLength,
    IN PVOID OptionsBuffer OPTIONAL,
    IN ULONG OptionsLength,
    IN PVOID SourceAddress OPTIONAL,
    IN ULONG SourceAddressLength,
    IN ULONG TdiFlags
    );

BOOLEAN
AfdCleanupReceiveDatagramIrp(
    IN PIRP Irp
    );

BOOLEAN
AfdCleanupSendIrp (
    PIRP    Irp
    );

NTSTATUS
AfdReceiveEventHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    );


NTSTATUS
AfdBChainedReceiveEventHandler(
    IN PVOID  TdiEventContext,
    IN CONNECTION_CONTEXT  ConnectionContext,
    IN ULONG  ReceiveFlags,
    IN ULONG  ReceiveLength,
    IN ULONG  StartingOffset,
    IN PMDL  Tsdu,
    IN PVOID  TsduDescriptor
    );
    
NTSTATUS
AfdBReceiveEventHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    );

NTSTATUS
AfdReceiveDatagramEventHandler (
    IN PVOID TdiEventContext,
    IN int SourceAddressLength,
    IN PVOID SourceAddress,
    IN int OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    );

NTSTATUS
AfdReceiveExpeditedEventHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    );

NTSTATUS
AfdBReceiveExpeditedEventHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    );

NTSTATUS
AfdRestartBufferReceive (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdRestartAbort (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
FASTCALL
AfdSend (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
FASTCALL
AfdSendDatagram (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
AfdSendPossibleEventHandler (
    IN PVOID TdiEventContext,
    IN PVOID ConnectionContext,
    IN ULONG BytesAvailable
    );

NTSTATUS
AfdRestartBufferSend (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
AfdProcessBufferSend (
    IN PAFD_CONNECTION Connection,
    IN PIRP            Irp
    );

NTSTATUS
AfdSetInformation (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    );

NTSTATUS
AfdGetSecurity (
    IN  PAFD_ENDPOINT           Endpoint,
    IN  SECURITY_INFORMATION    SecurityInformation,
    IN  ULONG                   BufferLength,
    OUT PVOID                   Buffer,
    OUT PSIZE_T                 DataLength
    );

NTSTATUS
AfdSetSecurity (
    IN  PAFD_ENDPOINT           Endpoint,
    IN  SECURITY_INFORMATION    SecurityInformation,
    IN  PSECURITY_DESCRIPTOR    SecurityDescriptor
    );

BOOLEAN
AfdShouldSendBlock (
    IN PAFD_ENDPOINT Endpoint,
    IN PAFD_CONNECTION Connection,
    IN ULONG SendLength
    );

NTSTATUS
AfdStartListen (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    );

NTSTATUS
FASTCALL
AfdTransmitFile (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );


NTSTATUS
FASTCALL
AfdWaitForListen (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
FASTCALL
AfdSetQos (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
FASTCALL
AfdGetQos (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
FASTCALL
AfdNoOperation (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
FASTCALL
AfdValidateGroup (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
AfdGetUnacceptedConnectData (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    );


#define AfdReferenceEventObjectByHandle(Handle, AccessMode, Object) \
            ObReferenceObjectByHandle(                              \
                (Handle),                                           \
                EVENT_MODIFY_STATE,                                 \
                *(POBJECT_TYPE *)ExEventObjectType,                 \
                (AccessMode),                                       \
                (Object),                                           \
                NULL                                                \
                )

//
// Endpoint handling routines.
//

NTSTATUS
AfdAllocateEndpoint (
    OUT PAFD_ENDPOINT * NewEndpoint,
    IN PUNICODE_STRING TransportDeviceName,
    IN LONG GroupID
    );

#if REFERENCE_DEBUG

VOID
AfdReferenceEndpoint (
    IN PAFD_ENDPOINT Endpoint,
    IN LONG  LocationId,
    IN ULONG Param
    );

BOOLEAN
AfdCheckAndReferenceEndpoint (
    IN PAFD_ENDPOINT Endpoint,
    IN LONG  LocationId,
    IN ULONG Param
    );

VOID
AfdDereferenceEndpoint (
    IN PAFD_ENDPOINT Endpoint,
    IN LONG  LocationId,
    IN ULONG Param
    );

VOID
AfdUpdateEndpoint (
    IN PAFD_ENDPOINT Endpoint,
    IN LONG  LocationId,
    IN ULONG Param
    );

#define REFERENCE_ENDPOINT(_e) {                                            \
        static LONG _arl;                                                   \
        AfdReferenceEndpoint((_e),AFD_GET_ARL(__FILE__"(%d)+"),__LINE__);   \
    }

#define REFERENCE_ENDPOINT2(_e,_s,_p) {                                     \
        static LONG _arl;                                                   \
        AfdReferenceEndpoint((_e),AFD_GET_ARL(_s"+"),(_p));                 \
    }

#define CHECK_REFERENCE_ENDPOINT(_e,_r) {                                   \
        static LONG _arl;                                                   \
        _r = AfdCheckAndReferenceEndpoint((_e),AFD_GET_ARL(__FILE__"(%d)*"),\
                                                                __LINE__);  \
    }

#define DEREFERENCE_ENDPOINT(_e) {                                          \
        static LONG _arl;                                                   \
        AfdDereferenceEndpoint((_e),AFD_GET_ARL(__FILE__"(%d)-"),__LINE__); \
    }

#define DEREFERENCE_ENDPOINT2(_e,_s,_p) {                                   \
        static LONG _arl;                                                   \
        AfdDereferenceEndpoint((_e),AFD_GET_ARL(_s"-"),(_p));               \
    }

#define UPDATE_ENDPOINT(_e) {                                               \
        static LONG _arl;                                                   \
        AfdUpdateEndpoint((_e),AFD_GET_ARL(__FILE__"(%d)="),__LINE__);      \
    }

#define UPDATE_ENDPOINT2(_e,_s,_p) {                                        \
        static LONG _arl;                                                   \
        AfdUpdateEndpoint((_e),AFD_GET_ARL(_s"="),(_p));                    \
    }

#else

BOOLEAN
AfdCheckAndReferenceEndpoint (
    IN PAFD_ENDPOINT Endpoint
    );

VOID
AfdDereferenceEndpoint (
    IN PAFD_ENDPOINT Endpoint
    );

#define REFERENCE_ENDPOINT(_e) (VOID)InterlockedIncrement( (PLONG)&(_e)->ReferenceCount )
#define REFERENCE_ENDPOINT2(_e,_s,_p) InterlockedIncrement( (PLONG)&(_e)->ReferenceCount )
#define CHECK_REFERENCE_ENDPOINT(_e,_r) _r=AfdCheckAndReferenceEndpoint((_e))

#define DEREFERENCE_ENDPOINT(_e) AfdDereferenceEndpoint((_e))
#define DEREFERENCE_ENDPOINT2(_e,_s,_p) AfdDereferenceEndpoint((_e))
#define UPDATE_ENDPOINT(_e)
#define UPDATE_ENDPOINT2(_e,_s,_p)

#endif

VOID
AfdRefreshEndpoint (
    IN PAFD_ENDPOINT Endpoint
    );

//
// Connection handling routines.
//

VOID
AfdAbortConnection (
    IN PAFD_CONNECTION Connection
    );

NTSTATUS
AfdAddFreeConnection (
    IN PAFD_ENDPOINT Endpoint
    );

PAFD_CONNECTION
AfdAllocateConnection (
    VOID
    );

NTSTATUS
AfdCreateConnection (
    IN PAFD_TRANSPORT_INFO TransportInfo,
    IN HANDLE AddressHandle OPTIONAL,
    IN BOOLEAN TdiBufferring,
    IN LOGICAL InLine,
    IN PEPROCESS ProcessToCharge,
    OUT PAFD_CONNECTION *Connection
    );

PAFD_CONNECTION
AfdGetFreeConnection (
    IN PAFD_ENDPOINT Endpoint,
    OUT PIRP        *Irp
    );

PAFD_CONNECTION
AfdGetReturnedConnection (
    IN PAFD_ENDPOINT Endpoint,
    IN LONG Sequence
    );

PAFD_CONNECTION
AfdFindReturnedConnection(
    IN PAFD_ENDPOINT Endpoint,
    IN LONG Sequence
    );

PAFD_CONNECTION
AfdGetUnacceptedConnection (
    IN PAFD_ENDPOINT Endpoint
    );

PAFD_CONNECTION
AfdGetConnectionReferenceFromEndpoint (
    PAFD_ENDPOINT   Endpoint
    );

#if REFERENCE_DEBUG

VOID
AfdReferenceConnection (
    IN PAFD_CONNECTION Connection,
    IN LONG  LocationId,
    IN ULONG Param
    );

BOOLEAN
AfdCheckAndReferenceConnection (
    PAFD_CONNECTION     Connection,
    IN LONG  LocationId,
    IN ULONG Param
    );

VOID
AfdDereferenceConnection (
    IN PAFD_CONNECTION Connection,
    IN LONG  LocationId,
    IN ULONG Param
    );

#define REFERENCE_CONNECTION(_c) {                                          \
        static LONG _arl;                                                   \
        AfdReferenceConnection((_c),AFD_GET_ARL(__FILE__"(%d)+"),__LINE__); \
    }

#define REFERENCE_CONNECTION2(_c,_s,_p) {                                   \
        static LONG _arl;                                                   \
        AfdReferenceConnection((_c),AFD_GET_ARL(_s"+"),(_p));               \
    }

#define CHECK_REFERENCE_CONNECTION(_c,_r) {                                 \
        static LONG _arl;                                                   \
        _r=AfdCheckAndReferenceConnection((_c),AFD_GET_ARL(__FILE__"(%d)*"),\
                                                                __LINE__);  \
    }

#define CHECK_REFERENCE_CONNECTION2(_c,_s,_p,_r) {                          \
        static LONG _arl;                                                   \
        _r = AfdCheckAndReferenceConnection((_c),AFD_GET_ARL(_s"*"),(_p));  \
    }

#define DEREFERENCE_CONNECTION(_c) {                                        \
        static LONG _arl;                                                   \
        AfdDereferenceConnection((_c),AFD_GET_ARL(__FILE__"(%d)-"),__LINE__);\
    }

#define DEREFERENCE_CONNECTION2(_c,_s,_p) {                                 \
        static LONG _arl;                                                   \
        AfdDereferenceConnection((_c),AFD_GET_ARL(_s"-"),(_p));             \
    }

VOID
AfdUpdateConnectionTrack (
    IN PAFD_CONNECTION Connection,
    IN LONG  LocationId,
    IN ULONG Param
    );

#define UPDATE_CONN(_c)                             \
    if( (_c) != NULL ) {                            \
        static LONG _arl;                           \
        AfdUpdateConnectionTrack(                   \
            (_c),                                   \
            AFD_GET_ARL(__FILE__"(%d)="),           \
            __LINE__                                \
            );                                      \
    } else

#define UPDATE_CONN2(_c,_s,_p)                                              \
    if( (_c) != NULL ) {                                                    \
        static LONG _arl;                                                   \
        AfdUpdateConnectionTrack((_c),AFD_GET_ARL(_s"="),(_p));             \
    } else

#else

VOID
AfdCloseConnection (
    IN PAFD_CONNECTION Connection
    );

BOOLEAN
AfdCheckAndReferenceConnection (
    PAFD_CONNECTION     Connection
    );

#define REFERENCE_CONNECTION(_c) (VOID)InterlockedIncrement( (PLONG)&(_c)->ReferenceCount )
#define REFERENCE_CONNECTION2(_c,_s,_p) (VOID)InterlockedIncrement( (PLONG)&(_c)->ReferenceCount )
#define CHECK_REFERENCE_CONNECTION(_c,_r) _r=AfdCheckAndReferenceConnection((_c))
#define CHECK_REFERENCE_CONNECTION2(_c,_s,_p,_r) _r=AfdCheckAndReferenceConnection((_c))

#define DEREFERENCE_CONNECTION(_c)                                  \
    if (InterlockedDecrement((PLONG)&(_c)->ReferenceCount)==0) {    \
        AfdCloseConnection (_c);                                    \
    }                                                               \

#define DEREFERENCE_CONNECTION2(_c,_s,_p)                           \
    if (InterlockedDecrement((PLONG)&(_c)->ReferenceCount)==0) {    \
        AfdCloseConnection (_c);                                    \
    }                                                               \


#define UPDATE_CONN(_c)
#define UPDATE_CONN2(_c,_s,_p)

#endif

VOID
AfdAddConnectedReference (
    IN PAFD_CONNECTION Connection
    );

VOID
AfdDeleteConnectedReference (
    IN PAFD_CONNECTION Connection,
    IN BOOLEAN EndpointLockHeld
    );


//
// Routines to handle fast IO.
//

BOOLEAN
AfdFastIoRead (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
AfdFastIoWrite (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
AfdFastIoDeviceControl (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Routines to handle getting and setting connect data.
//

NTSTATUS
AfdGetConnectData (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    );

NTSTATUS
AfdSetConnectData (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    );

NTSTATUS
AfdSaveReceivedConnectData (
    IN OUT PAFD_CONNECT_DATA_BUFFERS * DataBuffers,
    IN ULONG IoControlCode,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

//
// Buffer management routines.
//

PVOID
AfdAllocateBuffer (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

PVOID
AfdAllocateBufferTag (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

VOID
NTAPI
AfdFreeBufferTag(
    IN PVOID AfdBufferTag
    );

PVOID
AfdAllocateRemoteAddress (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

VOID
NTAPI
AfdFreeRemoteAddress(
    IN PVOID AfdBufferTag
    );

#define AFDB_RAISE_ON_FAILURE  ((ULONG_PTR)1)

PAFD_BUFFER_TAG
AfdGetBufferTag (
    IN ULONG AddressSize,
    IN PEPROCESS Process
    );
#define AfdGetBufferTagRaiseOnFailure(_as,_pr)  \
    AfdGetBufferTag((_as),((PEPROCESS)((ULONG_PTR)(_pr)|AFDB_RAISE_ON_FAILURE)))

ULONG
AfdCalculateBufferSize (
    IN ULONG BufferDataSize,
    IN ULONG AddressSize,
    IN CCHAR StackSize
    );

PAFD_BUFFER
FASTCALL
AfdGetBufferFast (
    IN ULONG BufferDataSize,
    IN ULONG AddressSize,
    IN PEPROCESS Process
    );

#ifdef _AFD_VARIABLE_STACK_
PAFD_BUFFER
FASTCALL
AfdGetBufferWithMaxStackSize (
    IN ULONG BufferDataSize,
    IN ULONG AddressSize,
    IN PEPROCESS Process
    );

#define AfdGetBuffer(_e,_ds,_as,_pr)    \
    (((_e)->TransportInfo->GetBuffer)(_ds,_as,_pr))
#else // _AFD_VARIABLE_STACK_
#define AfdGetBuffer(_e,_ds,_as,_pr) AfdGetBufferFast(_ds,_as,_pr)
#endif // _AFD_VARIABLE_STACK_

#define AfdGetBufferRaiseOnFailure(_e,_ds,_as,_pr)  \
    AfdGetBuffer(_e,_ds,_as,((PEPROCESS)((ULONG_PTR)(_pr)|AFDB_RAISE_ON_FAILURE)))

VOID
AfdReturnBuffer (
    IN PAFD_BUFFER_HEADER AfdBufferHeader,
    IN PEPROCESS Process
    );

VOID
NTAPI
AfdFreeBuffer(
    IN PVOID AfdBuffer
    );

VOID
AfdInitializeBufferManager (
    VOID
    );

//
// Group ID managment routines.
//

BOOLEAN
AfdInitializeGroup(
    VOID
    );

VOID
AfdTerminateGroup(
    VOID
    );

BOOLEAN
AfdReferenceGroup(
    IN LONG Group,
    OUT PAFD_GROUP_TYPE GroupType
    );

BOOLEAN
AfdDereferenceGroup(
    IN LONG Group
    );

BOOLEAN
AfdGetGroup(
    IN OUT PLONG Group,
    OUT PAFD_GROUP_TYPE GroupType
    );

BOOLEAN
AfdCancelIrp (
    IN PIRP Irp
    );


// PnP and PM routines
NTSTATUS
FASTCALL
AfdPnpPower (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
AfdRoutingInterfaceQuery (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    );

NTSTATUS
FASTCALL
AfdRoutingInterfaceChange (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
AfdAddressListQuery (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    );

NTSTATUS
FASTCALL
AfdAddressListChange (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
AfdDeregisterPnPHandlers (
    PVOID   Param
    );

VOID
AfdCleanupRoutingChange (
    IN PAFD_ENDPOINT    Endpoint
    );


NTSTATUS
FASTCALL
AfdDoTransportIoctl (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

BOOLEAN
AfdLRRepostReceive (
    PAFD_LR_LIST_ITEM ListEntry
    );

VOID
AfdLRListAddItem (
    PAFD_LR_LIST_ITEM  Item,
    PAFD_LR_LIST_ROUTINE Routine
    );

VOID
AfdCheckLookasideLists (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

#ifdef _AFD_VARIABLE_STACK_

VOID
AfdFixTransportEntryPointsForBigStackSize (
    IN OUT PAFD_TRANSPORT_INFO  TransportInfo,
    IN CCHAR                    StackSize
    );

NTSTATUS
FASTCALL
AfdCallDriverStackIncrease (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

PIRP
AfdGetStackIncreaseIrpAndRecordIt (
    IN PAFD_ENDPOINT Endpoint,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
#if DBG
                    ,
    IN PCHAR File,
    IN ULONG Line
#endif
    );
#endif //_AFD_VARIABLE_STACK_

PAFD_TPACKETS_INFO_INTERNAL
FASTCALL
AfdGetTpInfoFast (
    ULONG   ElementCount
    );

#ifdef _AFD_VARIABLE_STACK_

#define AfdGetTpInfo(_e,_c) \
        (((_e)->TransportInfo->GetTpInfo)(_c))

PAFD_TPACKETS_INFO_INTERNAL
FASTCALL
AfdGetTpInfoWithMaxStackSize (
    ULONG   ElementCount
    );

#else //_AFD_VARIABLE_STACK_
#define AfdGetTpInfo(_e,_c) AfdGetTpInfoFast(_c)
#endif //_AFD_VARIABLE_STACK_

ULONG
AfdComputeTpInfoSize (
    ULONG   ElementCount,
    CCHAR   IrpStackCount
    );

NTSTATUS
FASTCALL
AfdTransmitPackets (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
FASTCALL
AfdSuperDisconnect (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
AfdCompleteClosePendedTPackets (
    PAFD_ENDPOINT   Endpoint
    );

BOOLEAN
AfdEnqueueTpSendIrp (
    PAFD_ENDPOINT   Endpoint,
    PIRP            SendIrp,
    BOOLEAN         AfdIrp
    );

PVOID
AfdAllocateTpInfo (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

VOID
NTAPI
AfdFreeTpInfo (
    PVOID   TpInfo
    );

//
// SAN prototypes
//
NTSTATUS
AfdServiceWaitForListen (
    PIRP            Irp,
    PAFD_CONNECTION Connection,
    PAFD_LOCK_QUEUE_HANDLE LockHandle
    );

VOID
AfdSanCancelAccept (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
AfdSanAcceptCore (
    PIRP            AcceptIrp,
    PFILE_OBJECT    AcceptFileObject,
    PAFD_CONNECTION Connection,
    PAFD_LOCK_QUEUE_HANDLE LockHandle
    );


NTSTATUS
AfdSanCreateHelper (
    PIRP                        Irp,
    PFILE_FULL_EA_INFORMATION   EaBuffer,
    PAFD_ENDPOINT               *Endpoint
    );

VOID
AfdSanHelperCleanup (
    PAFD_ENDPOINT   SanHlprEndpoint
    );

VOID
AfdSanCleanupHelper (
    PAFD_ENDPOINT   Endpoint
    );

VOID
AfdSanCleanupEndpoint (
    PAFD_ENDPOINT   Endpoint
    );

NTSTATUS
AfdSanFastCementEndpoint (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    );

NTSTATUS
AfdSanFastSetEvents (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    );

NTSTATUS
AfdSanFastResetEvents (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    );

NTSTATUS
FASTCALL
AfdSanConnectHandler (
    PIRP                Irp,
    PIO_STACK_LOCATION  IrpSp
    );

NTSTATUS
AfdSanFastCompleteAccept (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    );

NTSTATUS
FASTCALL
AfdSanRedirectRequest (
    PIRP    Irp,
    PIO_STACK_LOCATION  IrpSp
    );

NTSTATUS
AfdSanFastCompleteRequest (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    );

NTSTATUS
AfdSanFastCompleteIo (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    );

NTSTATUS
AfdSanFastRefreshEndpoint (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    );

NTSTATUS
AfdSanFastGetPhysicalAddr (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    );

NTSTATUS
AfdSanPollBegin (
    PAFD_ENDPOINT   Endpoint,
    ULONG           EventMask
    );

VOID
AfdSanPollEnd (
    PAFD_ENDPOINT   Endpoint,
    ULONG           EventMask
    );

VOID
AfdSanPollUpdate (
    PAFD_ENDPOINT   Endpoint,
    ULONG           EventMask
    );

NTSTATUS
AfdSanPollMerge (
    PAFD_ENDPOINT       Endpoint,
    PAFD_SWITCH_CONTEXT Context
    );

NTSTATUS
AfdSanFastTransferCtx (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    );

NTSTATUS
AfdSanFastGetServicePid (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    );

NTSTATUS
AfdSanFastSetServiceProcess (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    );

NTSTATUS
AfdSanFastProviderChange (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    );


NTSTATUS
FASTCALL
AfdSanAddrListChange (
    PIRP    Irp,
    PIO_STACK_LOCATION  IrpSp
    );

NTSTATUS
FASTCALL
AfdSanAcquireContext (
    PIRP    Irp,
    PIO_STACK_LOCATION  IrpSp
    );

BOOLEAN
AfdSanFastUnlockAll (
    IN PFILE_OBJECT     FileObject,
    IN PEPROCESS        Process,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
AfdSanReleaseConnection (
    PAFD_ENDPOINT   ListenEndpoint,
    PAFD_CONNECTION Connection,
    BOOLEAN         CheckBacklog
    );

VOID
AfdSanAbortConnection (
    PAFD_CONNECTION Connection
    );

NTSTATUS
AfdSanRestartRequestProcessing (
    PAFD_ENDPOINT   Endpoint,
    NTSTATUS        Status
    );

NTSTATUS
AfdValidateStatus (
    NTSTATUS    Status
    );




//
// Check if datagram part of the union is valid
//
#define IS_DGRAM_ENDPOINT(endp) \
            ((endp)->Type==AfdBlockTypeDatagram)

//
// Check if Vc part of the union is valid
//
#define IS_VC_ENDPOINT(endp)                            \
        ( ((endp)->Type==AfdBlockTypeEndpoint) ||       \
          ((endp)->Type==AfdBlockTypeVcConnecting) ||   \
          ((endp)->Type==AfdBlockTypeVcListening) ||    \
          ((endp)->Type==AfdBlockTypeVcBoth) )

#define IS_SAN_ENDPOINT(endp)                                   \
        ((endp)->Type==AfdBlockTypeSanEndpoint)
#define IS_SAN_HELPER(endp)                                     \
        ((endp)->Type==AfdBlockTypeSanHelper)

#define IS_MESSAGE_ENDPOINT(endp) \
            ((endp)->afdMessageMode)
#define IS_RAW_ENDPOINT(endp) \
            ((endp)->afdRaw)
#define IS_CROOT_ENDPOINT(endp) \
            ((endp)->afdMultipoint && (endp)->afdC_Root)
#define IS_DELAYED_ACCEPTANCE_ENDPOINT(endp) \
            ((endp)->DelayedAcceptance)

#define IS_TDI_MESSAGE_MODE(endp)       \
            ((BOOLEAN)(((endp)->TdiServiceFlags&TDI_SERVICE_MESSAGE_MODE)!=0))
#define IS_TDI_BUFFERRING(endp)         \
            ((BOOLEAN)(((endp)->TdiServiceFlags&TDI_SERVICE_INTERNAL_BUFFERING)!=0))
#define IS_TDI_EXPEDITED(endp)          \
            ((BOOLEAN)(((endp)->TdiServiceFlags&TDI_SERVICE_EXPEDITED_DATA)!=0))
#define IS_TDI_ORDERLY_RELEASE(endp)    \
            ((BOOLEAN)(((endp)->TdiServiceFlags&TDI_SERVICE_ORDERLY_RELEASE)!=0))
#define IS_TDI_DGRAM_CONNECTION(endp)   \
            ((BOOLEAN)(((endp)->TdiServiceFlags&TDI_SERVICE_DGRAM_CONNECTION)!=0))
#define IS_TDI_FORCE_ACCESS_CHECK(endp) \
            ((BOOLEAN)(((endp)->TdiServiceFlags&TDI_SERVICE_FORCE_ACCESS_CHECK)!=0))
#define IS_TDI_DELAYED_ACCEPTANCE(endp) \
            ((BOOLEAN)(((endp)->TdiServiceFlags&TDI_SERVICE_DELAYED_ACCEPTANCE)!=0))
#ifdef TDI_SERVICE_ADDRESS_SECURITY
#define IS_TDI_ADDRESS_SECURITY(endp)   \
            ((BOOLEAN)(((endp)->TdiServiceFlags&TDI_SERVICE_ADDRESS_SECURITY)!=0))
#else
#define IS_TDI_ADDRESS_SECURITY(endp)   \
            FALSE
#endif

#define IS_DATA_ON_CONNECTION_B(conn)                                         \
            ((conn)->Common.Bufferring.ReceiveBytesIndicated.QuadPart >       \
                 ((conn)->Common.Bufferring.ReceiveBytesTaken.QuadPart +      \
                  (conn)->Common.Bufferring.ReceiveBytesOutstanding.QuadPart )\
             ||                                                               \
             (conn)->VcZeroByteReceiveIndicated)

#define IS_EXPEDITED_DATA_ON_CONNECTION_B(conn)                                        \
            ((conn)->Common.Bufferring.ReceiveExpeditedBytesIndicated.QuadPart >       \
                ((conn)->Common.Bufferring.ReceiveExpeditedBytesTaken.QuadPart +       \
                 (conn)->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart) )

#define IS_DATA_ON_CONNECTION_NB(conn)                                        \
            ( (conn)->VcBufferredReceiveCount != 0 )

#define IS_EXPEDITED_DATA_ON_CONNECTION_NB(conn)                              \
            ( (conn)->VcBufferredExpeditedCount != 0 )

#define IS_DATA_ON_CONNECTION(conn)                                           \
            ((conn)->TdiBufferring ?                            \
                IS_DATA_ON_CONNECTION_B(conn) :                 \
                IS_DATA_ON_CONNECTION_NB(conn) )

#define IS_EXPEDITED_DATA_ON_CONNECTION(conn)                                 \
            ((conn)->TdiBufferring ?                            \
                IS_EXPEDITED_DATA_ON_CONNECTION_B(conn) :       \
                IS_EXPEDITED_DATA_ON_CONNECTION_NB(conn) )

#define ARE_DATAGRAMS_ON_ENDPOINT(endp)                          \
            ( (endp)->DgBufferredReceiveCount != 0 )

#define AFD_START_STATE_CHANGE(endp,newState)                   \
        (InterlockedCompareExchange(                            \
                &(endp)->StateChangeInProgress,                 \
                newState,                                       \
                0)==0)

#if DBG
#define AFD_END_STATE_CHANGE(endp)                              \
    ASSERT (InterlockedExchange(&(endp)->StateChangeInProgress,0)!=0)
#else
//
// Do interlocked to have a memory barrier (on both x86 and IA64)
//
#define AFD_END_STATE_CHANGE(endp)                              \
        InterlockedExchange(&(endp)->StateChangeInProgress,0)
#endif

LOGICAL
FORCEINLINE
AfdPreventStateChange (
    PAFD_ENDPOINT   Endpoint
    )
{
    LONG    state;
    do {
        state = Endpoint->StateChangeInProgress;
    }
    while (state<=0 &&
        InterlockedCompareExchange (
            &Endpoint->StateChangeInProgress,
            state-1,
            state)!=state);
    return (state<=0);
}

#define AFD_PREVENT_STATE_CHANGE(endp)  AfdPreventStateChange(endp)

#if DBG
#define AFD_REALLOW_STATE_CHANGE(endp)                          \
    ASSERT (InterlockedIncrement(&(endp)->StateChangeInProgress)<=0)
#else
#define AFD_REALLOW_STATE_CHANGE(endp)                          \
    InterlockedIncrement(&(endp)->StateChangeInProgress)
#endif

#define AFD_ALLOCATE_REMOTE_ADDRESS(_l)                         \
    (((ULONG)(_l)<=AfdStandardAddressLength)                    \
            ? ExAllocateFromNPagedLookasideList(                \
                            &AfdLookasideLists->RemoteAddrList )\
            : AFD_ALLOCATE_POOL(NonPagedPool,                   \
                            (_l), AFD_REMOTE_ADDRESS_POOL_TAG)  \
        )

#define AFD_RETURN_REMOTE_ADDRESS(_a,_l)                        \
    (((ULONG)(_l)<=AfdStandardAddressLength)                    \
            ? ExFreeToNPagedLookasideList(                      \
                            &AfdLookasideLists->RemoteAddrList, \
                            (_a))                               \
            : AFD_FREE_POOL((_a), AFD_REMOTE_ADDRESS_POOL_TAG)  \
        )

#if DBG
LONG
AfdApcExceptionFilter(
    PEXCEPTION_POINTERS ExceptionPointers,
    PCHAR SourceFile,
    LONG LineNumber
    );
#endif
//
// Debug statistic manipulators. On checked builds these macros update
// their corresponding statistic counter. On retail builds, these macros
// evaluate to nothing.
//

#if AFD_KEEP_STATS

#define AfdRecordPoolQuotaCharged( b )                                      \
            ExInterlockedAddLargeStatistic(                                 \
                &AfdQuotaStats.Charged,                                     \
                (b)                                                         \
                )

#define AfdRecordPoolQuotaReturned( b )                                     \
            ExInterlockedAddLargeStatistic(                                 \
                &AfdQuotaStats.Returned,                                    \
                (b)                                                         \
                )

#define AfdRecordAddrOpened() InterlockedIncrement( &AfdHandleStats.AddrOpened )
#define AfdRecordAddrClosed() InterlockedIncrement( &AfdHandleStats.AddrClosed )
#define AfdRecordAddrRef()    InterlockedIncrement( &AfdHandleStats.AddrRef )
#define AfdRecordAddrDeref()  InterlockedIncrement( &AfdHandleStats.AddrDeref )
#define AfdRecordConnOpened() InterlockedIncrement( &AfdHandleStats.ConnOpened )
#define AfdRecordConnClosed() InterlockedIncrement( &AfdHandleStats.ConnClosed )
#define AfdRecordConnRef()    InterlockedIncrement( &AfdHandleStats.ConnRef )
#define AfdRecordConnDeref()  InterlockedIncrement( &AfdHandleStats.ConnDeref )
#define AfdRecordFileRef()    InterlockedIncrement( &AfdHandleStats.FileRef )
#define AfdRecordFileDeref()  InterlockedIncrement( &AfdHandleStats.FileDeref )

#define AfdRecordAfdWorkItemsQueued()    InterlockedIncrement( &AfdQueueStats.AfdWorkItemsQueued )
#define AfdRecordExWorkItemsQueued()     InterlockedIncrement( &AfdQueueStats.ExWorkItemsQueued )
#define AfdRecordWorkerEnter()           InterlockedIncrement( &AfdQueueStats.WorkerEnter )
#define AfdRecordWorkerLeave()           InterlockedIncrement( &AfdQueueStats.WorkerLeave )
#define AfdRecordAfdWorkItemsProcessed() InterlockedIncrement( &AfdQueueStats.AfdWorkItemsProcessed )

#define AfdRecordAfdWorkerThread(t) \
            if( 1 ) { \
                ASSERT( AfdQueueStats.AfdWorkerThread == NULL || \
                        (t) == NULL ); \
                AfdQueueStats.AfdWorkerThread = (t); \
            } else

#define AfdRecordConnectedReferencesAdded()      InterlockedIncrement( &AfdConnectionStats.ConnectedReferencesAdded )
#define AfdRecordConnectedReferencesDeleted()    InterlockedIncrement( &AfdConnectionStats.ConnectedReferencesDeleted )
#define AfdRecordGracefulDisconnectsInitiated()  InterlockedIncrement( &AfdConnectionStats.GracefulDisconnectsInitiated )
#define AfdRecordGracefulDisconnectsCompleted()  InterlockedIncrement( &AfdConnectionStats.GracefulDisconnectsCompleted )
#define AfdRecordGracefulDisconnectIndications() InterlockedIncrement( &AfdConnectionStats.GracefulDisconnectIndications )
#define AfdRecordAbortiveDisconnectsInitiated()  InterlockedIncrement( &AfdConnectionStats.AbortiveDisconnectsInitiated )
#define AfdRecordAbortiveDisconnectsCompleted()  InterlockedIncrement( &AfdConnectionStats.AbortiveDisconnectsCompleted )
#define AfdRecordAbortiveDisconnectIndications() InterlockedIncrement( &AfdConnectionStats.AbortiveDisconnectIndications )
#define AfdRecordConnectionIndications()         InterlockedIncrement( &AfdConnectionStats.ConnectionIndications )
#define AfdRecordConnectionsDropped()            InterlockedIncrement( &AfdConnectionStats.ConnectionsDropped )
#define AfdRecordConnectionsAccepted()           InterlockedIncrement( &AfdConnectionStats.ConnectionsAccepted )
#define AfdRecordConnectionsPreaccepted()        InterlockedIncrement( &AfdConnectionStats.ConnectionsPreaccepted )
#define AfdRecordConnectionsReused()             InterlockedIncrement( &AfdConnectionStats.ConnectionsReused )
#define AfdRecordEndpointsReused()               InterlockedIncrement( &AfdConnectionStats.EndpointsReused )

#else   // !AFD_KEEP_STATS

#define AfdRecordPoolQuotaCharged(b)
#define AfdRecordPoolQuotaReturned(b)

#define AfdRecordAddrOpened()
#define AfdRecordAddrClosed()
#define AfdRecordAddrRef()
#define AfdRecordAddrDeref()
#define AfdRecordConnOpened()
#define AfdRecordConnClosed()
#define AfdRecordConnRef()
#define AfdRecordConnDeref()
#define AfdRecordFileRef()
#define AfdRecordFileDeref()

#define AfdRecordAfdWorkItemsQueued()
#define AfdRecordExWorkItemsQueued()
#define AfdRecordWorkerEnter()
#define AfdRecordWorkerLeave()
#define AfdRecordAfdWorkItemsProcessed()
#define AfdRecordAfdWorkerThread(t)

#define AfdRecordConnectedReferencesAdded()
#define AfdRecordConnectedReferencesDeleted()
#define AfdRecordGracefulDisconnectsInitiated()
#define AfdRecordGracefulDisconnectsCompleted()
#define AfdRecordGracefulDisconnectIndications()
#define AfdRecordAbortiveDisconnectsInitiated()
#define AfdRecordAbortiveDisconnectsCompleted()
#define AfdRecordAbortiveDisconnectIndications()
#define AfdRecordConnectionIndications()
#define AfdRecordConnectionsDropped()
#define AfdRecordConnectionsAccepted()
#define AfdRecordConnectionsPreaccepted()
#define AfdRecordConnectionsReused()
#define AfdRecordEndpointsReused()

#endif // if AFD_KEEP_STATS

#if DBG
#define AFD_ALLOCATE_POOL(a,b,t) AfdAllocatePool( a,b,t,__FILE__,__LINE__,FALSE,LowPoolPriority )
#define AFD_ALLOCATE_POOL_WITH_QUOTA(a,b,t) AfdAllocatePool( (a)|POOL_RAISE_IF_ALLOCATION_FAILURE,b,t,__FILE__,__LINE__,TRUE,LowPoolPriority )
#define AFD_ALLOCATE_POOL_PRIORITY(a,b,t,p) AfdAllocatePool( a,b,t,__FILE__,__LINE__,FALSE,p )

PVOID
AfdAllocatePool (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    IN PCHAR FileName,
    IN ULONG LineNumber,
    IN BOOLEAN WithQuota,
    IN EX_POOL_PRIORITY Priority
    );

#define AFD_FREE_POOL(a,t) AfdFreePool(a,t)
VOID
AfdFreePool (
    IN PVOID Pointer,
    IN ULONG Tag
    );

BOOLEAN
AfdRecordOutstandingIrpDebug (
    IN PAFD_ENDPOINT Endpoint,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PCHAR FileName,
    IN ULONG LineNumber
    );

#define AfdRecordOutstandingIrp(a,b,c)  \
          AfdRecordOutstandingIrpDebug(a,b,c,__FILE__,__LINE__)


#ifdef _AFD_VARIABLE_STACK_

#define AfdIoCallDriver(_e,_d,_i)                           \
    (AfdRecordOutstandingIrp(_e,_d,_i)                      \
        ? ((_e)->TransportInfo->CallDriver)(_d,_i)          \
        : STATUS_INSUFFICIENT_RESOURCES                     \
    )

#define AfdCheckStackSizeAndRecordOutstandingIrp(_e,_d,_i)              \
    ( ((_i)->CurrentLocation>(_d)->StackSize)                           \
        ? (AfdRecordOutstandingIrp(_e,_d,_i) ? (_i) : (PIRP)NULL)       \
        : AfdGetStackIncreaseIrpAndRecordIt(_e,_d,_i,__FILE__,__LINE__) \
        )
#else // _AFD_VARIABLE_STACK_

#define AfdIoCallDriver(_e,_d,_i)                           \
    (AfdRecordOutstandingIrp(_e,_d,_i)                      \
        ? IoCallDriver(_d,_i)                               \
        : STATUS_INSUFFICIENT_RESOURCES                     \
    )
#endif // _AFD_VARIABLE_STACK_

#define AfdCompleteOutstandingIrp(_e,_i) \
    AfdCompleteOutstandingIrpDebug(_e,_i)

VOID
AfdCompleteOutstandingIrpDebug (
    IN PAFD_ENDPOINT Endpoint,
    IN PIRP Irp
    );

#ifdef AFDDBG_QUOTA
VOID
AfdRecordQuotaHistory(
    IN PEPROCESS Process,
    IN LONG Bytes,
    IN PSZ Type,
    IN PVOID Block
    );
#else
#define AfdRecordQuotaHistory(a,b,c,d)
#endif

extern ULONG AfdLocksAcquired;

//
// Queued spinlock wrappers - perform basic validation
//
#define AfdAcquireSpinLock(a,b) \
            ASSERT(AfdLoaded); (b)->SpinLock=(a); KeAcquireInStackQueuedSpinLock(&(a)->ActualSpinLock,&((b)->LockHandle)); AfdLocksAcquired++

#define AfdReleaseSpinLock(a,b) \
            AfdLocksAcquired--; ASSERT ((b)->SpinLock==(a)); ASSERT( AfdLoaded ); KeReleaseInStackQueuedSpinLock(&((b)->LockHandle)); 

#define AfdAcquireSpinLockAtDpcLevel(a,b) \
            ASSERT( AfdLoaded ); (b)->SpinLock=(a); KeAcquireInStackQueuedSpinLockAtDpcLevel(&(a)->ActualSpinLock,&((b)->LockHandle)); AfdLocksAcquired++

#define AfdReleaseSpinLockFromDpcLevel(a,b) \
            AfdLocksAcquired--; ASSERT ((b)->SpinLock==(a)); ASSERT( AfdLoaded );  KeReleaseInStackQueuedSpinLockFromDpcLevel(&((b)->LockHandle))

#define AfdInitializeSpinLock(a) \
            KeInitializeSpinLock(&(a)->ActualSpinLock)

//
// Define our own assert so that we can actually catch assertion failures
// when running a checked AFD on a free kernel.
//

VOID
AfdAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#undef ASSERT
#define ASSERT( exp ) \
    if (!(exp)) \
        AfdAssert( #exp, __FILE__, __LINE__, NULL )

#undef ASSERTMSG
#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        AfdAssert( #exp, __FILE__, __LINE__, msg )

#define AFD_EXCEPTION_FILTER_NO_STATUS()                                    \
            AfdExceptionFilter(                                             \
                (LPSTR)__FILE__,                                            \
                (LONG)__LINE__,                                             \
                GetExceptionInformation(),                                  \
                NULL                                                        \
                )

#define AFD_EXCEPTION_FILTER(_s)                                            \
            AfdExceptionFilter(                                             \
                (LPSTR)__FILE__,                                            \
                (LONG)__LINE__,                                             \
                GetExceptionInformation(),                                  \
                &_s                                                         \
                )

#else   // !DBG


#define AFD_ALLOCATE_POOL(a,b,t) ExAllocatePoolWithTagPriority(a,b,t,LowPoolPriority)
#define AFD_ALLOCATE_POOL_WITH_QUOTA(a,b,t) ExAllocatePoolWithQuotaTag((a)|POOL_RAISE_IF_ALLOCATION_FAILURE,b,t)
#define AFD_ALLOCATE_POOL_PRIORITY(a,b,t,p) ExAllocatePoolWithTagPriority(a,b,t,p)
#define AFD_FREE_POOL(a,t) MyFreePoolWithTag(a,t)

#define AfdRecordOutstandingIrp(_e,_d,_i) \
    (InterlockedIncrement(&((_e)->OutstandingIrpCount)), TRUE)

#ifdef _AFD_VARIABLE_STACK_

#define AfdIoCallDriver(_e,_d,_i) \
    (AfdRecordOutstandingIrp(_e,_d,_i), ((_e)->TransportInfo->CallDriver) (_d,_i))

#define AfdCheckStackSizeAndRecordOutstandingIrp(_e,_d,_i)          \
    ( ((_i)->CurrentLocation>(_d)->StackSize)                       \
        ? (InterlockedIncrement(&((_e)->OutstandingIrpCount)),_i)   \
        : AfdGetStackIncreaseIrpAndRecordIt(_e,_d,_i)               \
        )

#else // _AFD_VARIABLE_STACK_
#define AfdIoCallDriver(_e,_d,_i) \
    (AfdRecordOutstandingIrp(_e,_d,_i), IoCallDriver (_d,_i))
#endif

#define AfdCompleteOutstandingIrp(_e,_i) \
    InterlockedDecrement(&((_e)->OutstandingIrpCount))

#define AfdRecordQuotaHistory(a,b,c,d)

#define AfdAcquireSpinLock(a,b) KeAcquireInStackQueuedSpinLock(&(a)->ActualSpinLock,(b))
#define AfdReleaseSpinLock(a,b) KeReleaseInStackQueuedSpinLock((b))
#define AfdAcquireSpinLockAtDpcLevel(a,b) KeAcquireInStackQueuedSpinLockAtDpcLevel(&(a)->ActualSpinLock,(b))
#define AfdReleaseSpinLockFromDpcLevel(a,b) KeReleaseInStackQueuedSpinLockFromDpcLevel((b))
#define AfdInitializeSpinLock(a) \
            KeInitializeSpinLock(&(a)->ActualSpinLock)

#define AFD_EXCEPTION_FILTER_NO_STATUS()                                    \
            EXCEPTION_EXECUTE_HANDLER

#define AFD_EXCEPTION_FILTER(_s)                                            \
            AfdExceptionFilter(                                             \
                GetExceptionInformation(),                                  \
                &_s                                                         \
                )
#endif // def DBG

#if DBG || REFERENCE_DEBUG
VOID
AfdInitializeDebugData(
    VOID
    );

VOID
AfdFreeDebugData (
    VOID
    );
#endif

#endif // ndef _AFDPROCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\bind.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    bind.c

Abstract:

    Contains AfdBind for binding an endpoint to a transport address.

Author:

    David Treadwell (davidtr)    25-Feb-1992

Revision History:
    Vadim Eydelman (vadime) 1999 - C_ROOT endpoint handling,
                                    exclusive access endpoints.

--*/

#include "afdp.h"

NTSTATUS
AfdRestartGetAddress (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdRestartBindGetAddress (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

BOOLEAN
AfdIsAddressInUse (
    PAFD_ENDPOINT   Endpoint,
    BOOLEAN         OtherProcessesOnly
    );

PFILE_OBJECT
AfdGetAddressFileReference (
    PAFD_ENDPOINT   Endpoint
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfdBind )
#pragma alloc_text( PAGE, AfdIsAddressInUse )
#pragma alloc_text( PAGE, AfdGetAddress )
#pragma alloc_text( PAGEAFD, AfdAreTransportAddressesEqual )
#pragma alloc_text( PAGEAFD, AfdGetAddressFileReference )
#pragma alloc_text( PAGEAFD, AfdRestartGetAddress )
#pragma alloc_text( PAGEAFD, AfdRestartBindGetAddress )
#if NOT_YET
NTSTATUS
AfdStealClosedEnpointAddress (
    PAFD_ENDPOINT   Endpoint,
    NTSTATUS        Status
    );
#pragma alloc_text( PAGE, AfdStealClosedEnpointAddress )
#endif // NOT_YET
#endif

NTSTATUS
FASTCALL
AfdBind (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Handles the IOCTL_AFD_BIND IOCTL.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    NTSTATUS status;
    ULONG shareAccess, afdShareAccess;
    ULONG tdiAddressLength;
    PAFD_ENDPOINT endpoint;
    PSECURITY_DESCRIPTOR sd = NULL; // Use endpoint sd for secure transports
    PSECURITY_DESCRIPTOR oldSd;

    ULONG options;
    PTRANSPORT_ADDRESS localAddress;
    HANDLE addressHandle;
    OBJECT_ATTRIBUTES   objectAttributes;
    IO_STATUS_BLOCK     iosb;
    PFILE_FULL_EA_INFORMATION eaInfo;
    ULONG eaLength;
    // Local buffer to avoid memory allocation
    PCHAR   eaBuffer[sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                         TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                         AFD_MAX_FAST_TRANSPORT_ADDRESS];


    PAGED_CODE( );

    //
    // Initialize returned parameter
    //
    Irp->IoStatus.Information = 0;


    //
    // Need to have output buffer at least as long as input buffer
    // to pass the address that was actually used by the transport
    // back.
    //

    if ( (IrpSp->Parameters.DeviceIoControl.InputBufferLength<
                (ULONG)FIELD_OFFSET (AFD_BIND_INFO, Address.Address)) ||
            IrpSp->Parameters.DeviceIoControl.OutputBufferLength<
                (ULONG)FIELD_OFFSET (TDI_ADDRESS_INFO, Address.Address[0].Address) ||
            (IrpSp->Parameters.DeviceIoControl.OutputBufferLength-
                    (ULONG)FIELD_OFFSET (TDI_ADDRESS_INFO, Address) <
                IrpSp->Parameters.DeviceIoControl.InputBufferLength-
                    (ULONG)FIELD_OFFSET (AFD_BIND_INFO, Address) ) ) {

        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

   
    //
    // Set up local pointers.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    localAddress = NULL;
    addressHandle = NULL;

    tdiAddressLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength
                                    - FIELD_OFFSET (AFD_BIND_INFO, Address);

    //
    // This is a state change operation, there should be no other
    // state changes going at the same time.
    //
    if (!AFD_START_STATE_CHANGE (endpoint, AfdEndpointStateBound)) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    //
    // Bomb off if this endpoind already has address associated with it
    //

    if ( endpoint->State != AfdEndpointStateOpen ) {
        status = STATUS_ADDRESS_ALREADY_ASSOCIATED;
        goto complete_wrong_state;
    }


    //
    // Remember SD (so we can destroy it later) since it shares the storage 
    // with device object field
    //
    oldSd = endpoint->SecurityDescriptor;

    AFD_W4_INIT status = STATUS_SUCCESS;
    try {
        PAFD_BIND_INFO bindInfo;

        bindInfo = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
        if (Irp->RequestorMode!=KernelMode) {
            ProbeForRead (IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                            IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                            PROBE_ALIGNMENT (AFD_BIND_INFO));
        }

        //
        // Allocate space for local address
        //
        localAddress = AFD_ALLOCATE_POOL_WITH_QUOTA (
                                     NonPagedPool,
                                     tdiAddressLength,
                                     AFD_LOCAL_ADDRESS_POOL_TAG
                                     );

        // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets POOL_RAISE_IF_ALLOCATION_FAILURE flag
        ASSERT ( localAddress != NULL );

        afdShareAccess = bindInfo->ShareAccess;
        RtlMoveMemory(
            localAddress,
            &bindInfo->Address,
            tdiAddressLength
            );
        //
        // Validate internal consistency of the transport address structure.
        // Note that we HAVE to do this after copying since the malicious
        // application can change the content of the buffer on us any time
        // and our check will be bypassed.
        //
        if ((localAddress->TAAddressCount!=1) ||
                (LONG)tdiAddressLength<
                    FIELD_OFFSET (TRANSPORT_ADDRESS,
                        Address[0].Address[localAddress->Address[0].AddressLength])) {
            status = STATUS_INVALID_PARAMETER;
            goto complete_state_change;
        }

        if (IoAllocateMdl (Irp->UserBuffer,
                            IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                            FALSE,              // SecondaryBuffer
                            TRUE,               // ChargeQuota
                            Irp                 // Irp
                            )==NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto complete_state_change;
        }
        MmProbeAndLockPages (Irp->MdlAddress,
                                Irp->RequestorMode,
                                IoWriteAccess);
        if (MmGetSystemAddressForMdlSafe (Irp->MdlAddress, HighPagePriority)==NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto complete_state_change;
        }
    }
    except (AFD_EXCEPTION_FILTER(status)) {
        ASSERT (NT_ERROR (status));
        goto complete_state_change;
    }



    //
    // Make sure we have a valid provider info structure.
    // (we do not take any locks because this is read access only
    // and additional verification will be performed inside of the
    // routine under the lock).
    // If not, attempt to get it from provider
    // (this can happen if when the socket was created, transport
    // was not loaded yet)
    //
    if (!endpoint->TransportInfo->InfoValid) {
        status = AfdGetTransportInfo (
                        &endpoint->TransportInfo->TransportDeviceName,
                        &endpoint->TransportInfo);
        if (!NT_SUCCESS (status)) {
            goto complete_state_change;
        }
        //
        // Must be valid because we got success.
        //
        ASSERT (endpoint->TransportInfo->InfoValid);
    }

    //
    // Cache service flags for quick determination of provider characteristics
    // such as bufferring and messaging.  Do it even if provider structure was
    // valid already because in may have become valid between the time the
    // flags were set and we checked it here.  In any case update to the same
    // value won't hurt.
    //
    endpoint->TdiServiceFlags = endpoint->TransportInfo->ProviderInfo.ServiceFlags;


    //
    // Attempt to take ownership of the address.
    // We have to do this before we start looking for a conflict
    // so if someone does it in parallel with us, will see him or
    // he sees us.
    //
    ASSERT (endpoint->LocalAddress==NULL);
    endpoint->LocalAddress = localAddress;
    endpoint->LocalAddressLength = tdiAddressLength;

    if (IS_TDI_ADDRESS_SECURITY(endpoint) &&
            endpoint->SecurityDescriptor!=NULL) {
        sd = endpoint->SecurityDescriptor;
        shareAccess = 0;
    }
    else 
    {

        //
        // There are three possibilities here.
        //
        switch (afdShareAccess) {
        case AFD_NORMALADDRUSE:

            if (IS_TDI_ADDRESS_SECURITY(endpoint)) {
                shareAccess = 0;
                sd = &AfdEmptySd;
            }
            else {
                //
                // This is the default. Application did not request to reuse
                // the address that is already owned by someone else, so we
                // have to check against all addresses that we know about.
                // There is still a possibility that another TDI client has
                // this address in exclusive use, so the transport can reject 
                // our request even if we succeed. Note that we cannot relegate
                // this check to the transport because we request shared access
                // to the transport address: we cannot request exclusive access
                // because this is not what application asked for.
                //
                if (AfdIsAddressInUse (endpoint, FALSE)) {
                    status = STATUS_SHARING_VIOLATION;
                    goto complete_state_change;
                }
                shareAccess = FILE_SHARE_READ|FILE_SHARE_WRITE;
            }
            break;
        case AFD_REUSEADDRESS:
            //
            // We are asked to reuse the existing address 
            //
            if (IS_TDI_ADDRESS_SECURITY(endpoint)) {
                sd = &AfdEmptySd;
            }
            shareAccess = FILE_SHARE_READ|FILE_SHARE_WRITE;
            break;
        case AFD_WILDCARDADDRESS:
            //
            // Application is binding to a wildcard port, so we leave the 
            // decision with the transport.
            //
            if (IS_TDI_ADDRESS_SECURITY(endpoint)) {
                shareAccess = 0;
                sd = &AfdEmptySd;
            }
            else {
                shareAccess = FILE_SHARE_READ|FILE_SHARE_WRITE;
            }
            break;
        case AFD_EXCLUSIVEADDRUSE:
            //
            // Application has requested exclisuve access to the address.
            // We let the transport to decide by requesting exclusive access.
            //
            shareAccess = 0;
            break;
        default:
            ASSERT (!"Invalid share access");
            status = STATUS_INVALID_PARAMETER;
            goto complete_state_change;
        }
    }

    //
    // Set create options.
    //

    options = IO_NO_PARAMETER_CHECKING;
    if (IS_TDI_FORCE_ACCESS_CHECK(endpoint)) {
        options |=  IO_FORCE_ACCESS_CHECK;
    }
    else {
        //
        // If this is an open of a raw address, fail if user is
        // not an admin and transport does not perform security
        // checking itself.
        //
        if ( endpoint->afdRaw && !AfdDisableRawSecurity) {

            if (!endpoint->AdminAccessGranted) {
                status = STATUS_ACCESS_DENIED;
                goto complete_state_change;
            }
        }
    }

    //
    // Allocate memory to hold the EA buffer we'll use to specify the
    // transport address to NtCreateFile.
    //

    eaLength = sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                         TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                         tdiAddressLength;

    if (eaLength<=sizeof (eaBuffer)) {
        eaInfo = (PVOID)eaBuffer;
    }
    else {
        try {
#if DBG
            eaInfo = AFD_ALLOCATE_POOL_WITH_QUOTA(
                     NonPagedPool,
                     eaLength,
                     AFD_EA_POOL_TAG
                     );
#else
            eaInfo = AFD_ALLOCATE_POOL_WITH_QUOTA(
                     PagedPool,
                     eaLength,
                     AFD_EA_POOL_TAG
                     );
#endif
            // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets POOL_RAISE_IF_ALLOCATION_FAILURE flag
            ASSERT ( eaInfo != NULL );
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            status = GetExceptionCode ();
            goto complete_state_change;
        }

    }


    //
    // Initialize the EA.
    //

    eaInfo->NextEntryOffset = 0;
    eaInfo->Flags = 0;
    eaInfo->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    eaInfo->EaValueLength = (USHORT)tdiAddressLength;

    RtlMoveMemory(
        eaInfo->EaName,
        TdiTransportAddress,
        TDI_TRANSPORT_ADDRESS_LENGTH + 1
        );

    RtlMoveMemory(
        &eaInfo->EaName[TDI_TRANSPORT_ADDRESS_LENGTH + 1],
        localAddress,
        tdiAddressLength
        );

    //
    // Prepare for opening the address object.
    // We ask to create a kernel handle which is 
    // the handle in the context of the system process
    // so that application cannot close it on us while
    // we are creating and referencing it.
    //
    
    InitializeObjectAttributes(
        &objectAttributes,
        &endpoint->TransportInfo->TransportDeviceName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,       // attributes
        NULL,                                           // RootDirectory
        sd                                              // SecurityDescriptor
        );

    ASSERT (endpoint->AddressHandle==NULL);

    //
    // We specify MAXIMUM_ALLOWED access for the following reasons:
    //  * transport objects are file objects, but regular file access
    //      permissions don't really make sense - it is not really
    //      meaningfull to say be able to receive and not send or vice
    //      versa;
    //  * we need to specify some access mask to get the IO manager and
    //      possibly the transport to perform an access check to verify
    //      that current caller has access, hence MAXIMUM_ALLOWED;
    //  * the handle and the object is going to be used by AFD in kernel
    //      mode - no access check will be performed anyway, so it doesn't
    //      matter what we actually get;
    //  * MAXIMUM_ALLOWED is not perfect in terms of performance since 
    //      security monitor is going to walk the whole DACL, it would be
    //      better to specify a specific mask;
    //  * currently IO manager allows the World only EXECUTE access to 
    //      transport device objects BEFORE any further restrictions imposed 
    //      by a particular transport so we can in theory specify
    //      just GENERIC_EXECUTE, however, it is not clear if this is
    //      going to remain valid forever;
    //  
    status = IoCreateFile(
                 &endpoint->AddressHandle,
                 MAXIMUM_ALLOWED,                // DesiredAccess (see above).
                 &objectAttributes,
                 &iosb,                          // returned status information.
                 0,                              // block size (unused).
                 0,                              // file attributes.
                 shareAccess,                    // share access
                 FILE_CREATE,                    // create disposition.
                 0,                              // create options.
                 eaInfo,                         // EaBuffer
                 eaLength,                       // EaLength
                 CreateFileTypeNone,             // CreateFileType
                 NULL,                           // ExtraCreateParameters
                 options
                 );

    if (eaInfo!=(PVOID)eaBuffer) {
        AFD_FREE_POOL (eaInfo, AFD_EA_POOL_TAG);
    }

    if ( !NT_SUCCESS(status) ) {
        if ((status==STATUS_SHARING_VIOLATION) ||
            (status==STATUS_ADDRESS_ALREADY_EXISTS)) {
            if (afdShareAccess==AFD_REUSEADDRESS) {
                //
                // Map error code if application requested address
                // reuse, but the transport denied it (apparently due to
                // other client having this address for its exclusive use).
                //
                status = STATUS_ACCESS_DENIED;
            }
        }

        goto complete_state_change;
    }

#if DBG
    {
        NTSTATUS    status1;
        OBJECT_HANDLE_FLAG_INFORMATION  handleInfo;
        handleInfo.Inherit = FALSE;
        handleInfo.ProtectFromClose = TRUE;
        status1 = ZwSetInformationObject (
                        endpoint->AddressHandle,
                        ObjectHandleFlagInformation,
                        &handleInfo,
                        sizeof (handleInfo)
                        );
        ASSERT (NT_SUCCESS (status1));
    }
#endif

    AfdRecordAddrOpened();

    //
    // Get a pointer to the file object of the address.
    //

    status = ObReferenceObjectByHandle(
                 endpoint->AddressHandle,
                 0L,                         // DesiredAccess - we don't really need
                                             // one for kernel mode caller.
                 NULL,
                 KernelMode,
                 (PVOID *)&endpoint->AddressFileObject,
                 NULL
                 );

    if ( !NT_SUCCESS(status) ) {
        goto complete_state_change;
    }
    AfdRecordAddrRef();


    //
    // Now open the handle for our caller.
    // If transport does not support new TDI_SERVICE_FORCE_ACCESS_CHECK_FLAG
    // we get the maximum possible access for the handle so that helper
    // DLL can do what it wants with it.  Of course this compromises the
    // security, but we can't enforce it without the transport cooperation.
    //
    status = ObOpenObjectByPointer(
                 endpoint->AddressFileObject,
                 OBJ_CASE_INSENSITIVE,
                 NULL,
                 MAXIMUM_ALLOWED,
                 *IoFileObjectType,
                 (KPROCESSOR_MODE)((endpoint->TdiServiceFlags&TDI_SERVICE_FORCE_ACCESS_CHECK)
                    ? Irp->RequestorMode
                    : KernelMode),
                 &addressHandle
                 );

    if ( !NT_SUCCESS(status) ) {
        goto complete_state_change;
    }

    //
    // Remember the device object to which we need to give requests for
    // this address object.  We can't just use the
    // fileObject->DeviceObject pointer because there may be a device
    // attached to the transport protocol.
    //

    endpoint->AddressDeviceObject =
        IoGetRelatedDeviceObject( endpoint->AddressFileObject );

#ifdef _AFD_VARIABLE_STACK_
    if (endpoint->AddressDeviceObject->StackSize!=endpoint->TransportInfo->StackSize &&
            endpoint->AddressDeviceObject->StackSize > AfdTdiStackSize) {
        AfdFixTransportEntryPointsForBigStackSize (
                        endpoint->TransportInfo,
                        endpoint->AddressDeviceObject->StackSize);
    }
#endif //_AFD_VARIABLE_STACK
    //
    // Set up indication handlers on the address object.  Only set up
    // appropriate event handlers--don't set unnecessary event handlers.
    //

    status = AfdSetEventHandler(
                 endpoint->AddressFileObject,
                 TDI_EVENT_ERROR,
                 (PVOID)AfdErrorEventHandler,
                 endpoint
                 );
#if DBG
    if ( !NT_SUCCESS(status) ) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdBind: Transport %*ls failed setting TDI_EVENT_ERROR: %lx\n",
                    endpoint->TransportInfo->TransportDeviceName.Length/2,
                    endpoint->TransportInfo->TransportDeviceName.Buffer,
                    status ));
    }
#endif


    if ( IS_DGRAM_ENDPOINT(endpoint) ) {

        endpoint->EventsActive = AFD_POLL_SEND;

        IF_DEBUG(EVENT_SELECT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdBind: Endp %08lX, Active %08lX\n",
                endpoint,
                endpoint->EventsActive
                ));
        }

        status = AfdSetEventHandler(
                     endpoint->AddressFileObject,
                     TDI_EVENT_RECEIVE_DATAGRAM,
                     (PVOID)AfdReceiveDatagramEventHandler,
                     endpoint
                     );
#if DBG
        if ( !NT_SUCCESS(status) ) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                        "AfdBind: Transport %*ls failed setting TDI_EVENT_RECEIVE_DATAGRAM: %lx\n",
                        endpoint->TransportInfo->TransportDeviceName.Length/2,
                        endpoint->TransportInfo->TransportDeviceName.Buffer,
                        status ));
        }
#endif

        status = AfdSetEventHandler(
                     endpoint->AddressFileObject,
                     TDI_EVENT_ERROR_EX,
                     (PVOID)AfdErrorExEventHandler,
                     endpoint
                     );

        if ( !NT_SUCCESS(status)) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                "AfdBind: Transport %*ls failed setting TDI_EVENT_ERROR_EX: %lx\n",
                            endpoint->TransportInfo->TransportDeviceName.Length/2,
                            endpoint->TransportInfo->TransportDeviceName.Buffer,
                            status ));
        }

        //
        // Since we don't use a spinlock for performance and AfdCleanup
        // relies upon endpoint->State != AfdEndpointStateOpen to
        // determine whether or not to remove TDI event handlers and
        // call AfdUnbind, we must guarantee that all of the above
        // instructions have completed and weren't reordered before we
        // set the state.  If AfdCleanup winds up missing the state
        // transition, it's no big deal as the application would have
        // to be behaving rather badly for this race condition, and TDI
        // will eventually recycle the address (just not immediately).
        //
        // However, the current code calls a function just prior to
        // this assignment in all cases so a memory fence is unecessary.
        // We'll leave it commented out until future revisions of the
        // code add write instructions we depend on which could be
        // reordered.  We could also use InterlockedExchange for this
        // on endpoint->State.
        //
        // KeMemoryBarrier();
        //

        //
        // Remember that the endpoint has been bound to a transport address.
        // (this is the fact even though the call below can fail for some reason)
        //

        endpoint->State = AfdEndpointStateBound;

    } else {

        status = AfdSetEventHandler(
                     endpoint->AddressFileObject,
                     TDI_EVENT_DISCONNECT,
                     (PVOID)AfdDisconnectEventHandler,
                     endpoint
                     );
#if DBG
        if ( !NT_SUCCESS(status) ) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                        "AfdBind: Transport %*ls failed setting TDI_EVENT_DISCONNECT: %lx\n",
                        endpoint->TransportInfo->TransportDeviceName.Length/2,
                        endpoint->TransportInfo->TransportDeviceName.Buffer,
                        status ));
        }
#endif


        if ( IS_TDI_BUFFERRING(endpoint) ) {
            status = AfdSetEventHandler(
                         endpoint->AddressFileObject,
                         TDI_EVENT_RECEIVE,
                         (PVOID)AfdReceiveEventHandler,
                         endpoint
                         );
#if DBG
            if ( !NT_SUCCESS(status) ) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                            "AfdBind: Transport %*ls failed setting TDI_EVENT_RECEIVE: %lx\n",
                            endpoint->TransportInfo->TransportDeviceName.Length/2,
                            endpoint->TransportInfo->TransportDeviceName.Buffer,
                            status ));
            }
#endif
//
// PROBLEM:  Why don't we check for this
//            if (IS_TDI_EXPEDITED (endpoint)) {
                status = AfdSetEventHandler(
                             endpoint->AddressFileObject,
                             TDI_EVENT_RECEIVE_EXPEDITED,
                             (PVOID)AfdReceiveExpeditedEventHandler,
                             endpoint
                             );
#if DBG
                if ( !NT_SUCCESS(status) ) {
                    DbgPrint( "AfdBind: Transport %*ls failed setting TDI_EVENT_RECEIVE_EXPEDITED: %lx\n",
                                    endpoint->TransportInfo->TransportDeviceName.Length/2,
                                    endpoint->TransportInfo->TransportDeviceName.Buffer,
                                    status );
                }
#endif
//            }
            status = AfdSetEventHandler(
                         endpoint->AddressFileObject,
                         TDI_EVENT_SEND_POSSIBLE,
                         (PVOID)AfdSendPossibleEventHandler,
                         endpoint
                         );
#if DBG
            if ( !NT_SUCCESS(status) ) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                            "AfdBind: Transport %*ls failed setting TDI_EVENT_SEND_POSSIBLE: %lx\n",
                            endpoint->TransportInfo->TransportDeviceName.Length/2,
                            endpoint->TransportInfo->TransportDeviceName.Buffer,
                            status ));
            }
#endif

        } else {

            status = AfdSetEventHandler(
                         endpoint->AddressFileObject,
                         TDI_EVENT_RECEIVE,
                         (PVOID)AfdBReceiveEventHandler,
                         endpoint
                         );
#if DBG
            if ( !NT_SUCCESS(status) ) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                                "AfdBind: Transport %*ls failed setting TDI_EVENT_RECEIVE: %lx\n",
                                endpoint->TransportInfo->TransportDeviceName.Length/2,
                                endpoint->TransportInfo->TransportDeviceName.Buffer,
                                status ));
            }
#endif

            if (IS_TDI_EXPEDITED (endpoint)) {
                status = AfdSetEventHandler(
                             endpoint->AddressFileObject,
                             TDI_EVENT_RECEIVE_EXPEDITED,
                             (PVOID)AfdBReceiveExpeditedEventHandler,
                             endpoint
                             );
#if DBG
                if ( !NT_SUCCESS(status) ) {
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                                    "AfdBind: Transport %*ls failed setting TDI_EVENT_RECEIVE_EXPEDITED: %lx\n",
                                    endpoint->TransportInfo->TransportDeviceName.Length/2,
                                    endpoint->TransportInfo->TransportDeviceName.Buffer,
                                    status ));
                }
#endif
            }
            if (!AfdDisableChainedReceive) {
                status = AfdSetEventHandler(
                             endpoint->AddressFileObject,
                             TDI_EVENT_CHAINED_RECEIVE,
                             (PVOID)AfdBChainedReceiveEventHandler,
                             endpoint
                             );
                if ( !NT_SUCCESS(status) ) {
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                        "AfdBind: Transport %*ls failed setting TDI_EVENT_CHAINED_RECEIVE: %lx\n",
                                        endpoint->TransportInfo->TransportDeviceName.Length/2,
                                        endpoint->TransportInfo->TransportDeviceName.Buffer,
                                        status ));
                }
            }
        }

        if (IS_CROOT_ENDPOINT(endpoint)) {
            PAFD_CONNECTION     connection;
            //
            // Create root connection
            // This one will be used to send data to all
            // leaf nodes (what if there are none -> the transport
            // should handle this.
            //
            status = AfdCreateConnection(
                         endpoint->TransportInfo,
                         endpoint->AddressHandle,
                         IS_TDI_BUFFERRING(endpoint),
                         endpoint->InLine,
                         endpoint->OwningProcess,
                         &connection
                         );
            if (!NT_SUCCESS(status)) {
                goto complete_state_change;
            }

            //
            // Set up a referenced pointer from the connection to the endpoint.
            // Note that we set up the connection's pointer to the endpoint
            // BEFORE the endpoint's pointer to the connection so that AfdPoll
            // doesn't try to back reference the endpoint from the connection.
            //

            REFERENCE_ENDPOINT( endpoint );
            connection->Endpoint = endpoint;

            //
            // Remember that this is now a connecting type of endpoint, and set
            // up a pointer to the connection in the endpoint.  This is
            // implicitly a referenced pointer.
            //

            endpoint->Common.VirtualCircuit.Connection = connection;
            endpoint->Type = AfdBlockTypeVcConnecting;

            // 
            // The root connection is marked as connected immediately upon
            // creation. See the comment above
            //

            AfdAddConnectedReference (connection);

            //
            // Since we don't use a spinlock for performance and AfdCleanup
            // relies upon endpoint->State != AfdEndpointStateOpen to
            // determine whether or not to remove TDI event handlers and
            // call AfdUnbind, we must guarantee that all of the above
            // instructions have completed and weren't reordered before we
            // set the state.  If AfdCleanup winds up missing the state
            // transition, it's no big deal as the application would have
            // to be behaving rather badly for this race condition, and TDI
            // will eventually recycle the address (just not immediately).
            //
            // However, the current code calls a function just prior to
            // this assignment in all cases so a memory fence is unecessary.
            // We'll leave it commented out until future revisions of the
            // code add write instructions we depend on which could be
            // reordered.  We could also use InterlockedExchange for this
            // on endpoint->State.
            //
            // KeMemoryBarrier();
            //

            endpoint->State = AfdEndpointStateConnected;
            connection->State = AfdConnectionStateConnected;

            ASSERT( IS_TDI_BUFFERRING(endpoint) == connection->TdiBufferring );

        } else {

            //
            // Since we don't use a spinlock for performance and AfdCleanup
            // relies upon endpoint->State != AfdEndpointStateOpen to
            // determine whether or not to remove TDI event handlers and
            // call AfdUnbind, we must guarantee that all of the above
            // instructions have completed and weren't reordered before we
            // set the state.  If AfdCleanup winds up missing the state
            // transition, it's no big deal as the application would have
            // to be behaving rather badly for this race condition, and TDI
            // will eventually recycle the address (just not immediately).
            //
            // However, the current code calls a function just prior to
            // this assignment in all cases so a memory fence is unecessary.
            // We'll leave it commented out until future revisions of the
            // code add write instructions we depend on which could be
            // reordered.  We could also use InterlockedExchange for this
            // on endpoint->State.
            //
            // KeMemoryBarrier();
            //

            //
            // Remember that the endpoint has been bound to a transport address.
            // (this is the fact even though the call below can fail for some reason)
            //

            endpoint->State = AfdEndpointStateBound;

        }
    }

    AFD_END_STATE_CHANGE (endpoint);

    //
    // endpoint->State is no longer Open. Dispose of the SD
    //
    if (oldSd != NULL) {
        ObDereferenceSecurityDescriptor( oldSd, 1 );
    }


    TdiBuildQueryInformation(
        Irp,
        endpoint->AddressDeviceObject,
        endpoint->AddressFileObject,
        AfdRestartBindGetAddress,
        endpoint,
        TDI_QUERY_ADDRESS_INFO,
        Irp->MdlAddress
        );

    //
    // Save address handle to use in completion routine
    //
    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = addressHandle;

    IF_DEBUG(BIND) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
            "AfdBind: endpoint at %p (address at %p, address file at %p).\n",
                     endpoint,
                     endpoint->LocalAddress,
                     endpoint->AddressFileObject ));
    }

    status = AfdIoCallDriver( endpoint, endpoint->AddressDeviceObject, Irp );
    return status;

complete_state_change:

    if (endpoint->AddressFileObject!=NULL) {
        ObDereferenceObject (endpoint->AddressFileObject);
        endpoint->AddressFileObject = NULL;
        ASSERT (endpoint->AddressHandle!=NULL);
    }

    //
    // Restore SD (might have been over-written by AddressDeviceObject)
    // We're still holding endpoint state change lock.
    //
    ASSERT (endpoint->State == AfdEndpointStateOpen);
    endpoint->SecurityDescriptor = oldSd;

    if (endpoint->AddressHandle!=NULL) {
#if DBG
        {
            NTSTATUS    status1;
            OBJECT_HANDLE_FLAG_INFORMATION  handleInfo;
            handleInfo.Inherit = FALSE;
            handleInfo.ProtectFromClose = FALSE;
            status1 = ZwSetInformationObject (
                            endpoint->AddressHandle,
                            ObjectHandleFlagInformation,
                            &handleInfo,
                            sizeof (handleInfo)
                            );
            ASSERT (NT_SUCCESS (status1));
        }
#endif
        ZwClose(endpoint->AddressHandle);
        endpoint->AddressHandle = NULL;
        ASSERT (localAddress!=NULL);
    }


    if (localAddress!=NULL) {

        //
        // Need to have exclusive access to make sure no one
        // uses it (to compare) as we are going to free it.
        // We'll use a local variable to free memory
        //

        //
        // Make sure the thread in which we execute cannot get
        // suspeneded in APC while we own the global resource.
        //
        KeEnterCriticalRegion ();
        ExAcquireResourceExclusiveLite( AfdResource, TRUE);

        endpoint->LocalAddress = NULL;
        endpoint->LocalAddressLength = 0;

        ExReleaseResourceLite( AfdResource );
        KeLeaveCriticalRegion ();
        AFD_FREE_POOL (
            localAddress,
            AFD_LOCAL_ADDRESS_POOL_TAG
            );
    }

complete_wrong_state:

    AFD_END_STATE_CHANGE (endpoint);

    //
    // Free MDL here as IO system can't do it if it is
    // not locked.
    //
    if (Irp->MdlAddress!=NULL) {
        if (Irp->MdlAddress->MdlFlags & MDL_PAGES_LOCKED) {
            MmUnlockPages (Irp->MdlAddress);
        }
        IoFreeMdl (Irp->MdlAddress);
        Irp->MdlAddress = NULL;
    }

complete:

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

} // AfdBind


NTSTATUS
AfdRestartBindGetAddress (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    NTSTATUS status;
    PAFD_ENDPOINT endpoint = Context;

    UNREFERENCED_PARAMETER (DeviceObject);

    ASSERT (IS_AFD_ENDPOINT_TYPE (endpoint));

    //
    // If the request succeeded, save the address in the endpoint so
    // we can use it to handle address sharing.
    //

    if ( NT_SUCCESS(Irp->IoStatus.Status) ) {

        ULONG addressLength;
        //
        // First determine the length of the address by walking the MDL
        // chain.
        //

        //
        // We cannot have a chain here.
        //
        ASSERT( Irp->MdlAddress != NULL);
        ASSERT( Irp->MdlAddress->Next == NULL );

        //
        // If the new address is longer than the original address, allocate
        // a new local address buffer.  The +4 accounts for the ActivityCount
        // field that is returned by a query address but is not part
        // of a TRANSPORT_ADDRESS.
        //
        // This cannot happen, in any case msafd does not retry if buffer is
        // insuffucient, so application perceives this as failure to bind
        // or get address.
        //

        addressLength = MmGetMdlByteCount (Irp->MdlAddress) - FIELD_OFFSET (TDI_ADDRESS_INFO, Address);
        if (addressLength>endpoint->LocalAddressLength) {
            addressLength = (ULONG)Irp->IoStatus.Information - FIELD_OFFSET (TDI_ADDRESS_INFO, Address);
        }
        if ( addressLength <= endpoint->LocalAddressLength) {
            status = TdiCopyMdlToBuffer(
                         Irp->MdlAddress,
                         FIELD_OFFSET (TDI_ADDRESS_INFO, Address),
                         endpoint->LocalAddress,
                         0,
                         addressLength,
                         &endpoint->LocalAddressLength
                         );
            ASSERT( NT_SUCCESS(status) );
        }
        else {
            DbgPrint ("AfdRestartBindGetAddress: Endpoint %p transport returned"
                    " address is longer than the original one.\n",
                    endpoint);
            ASSERT (FALSE);
        }

    }
    else {
        //
        //
        //
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
            "AfdRestartBindGetAddress: Transport %*ls failed get address query, status %lx.\n",
                    endpoint->TransportInfo->TransportDeviceName.Length/2,
                    endpoint->TransportInfo->TransportDeviceName.Buffer,
                    Irp->IoStatus.Status));
    }


    //
    // If pending has been returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending( Irp );
    }

    //
    // Retreive and return address handle in the information field
    //
    Irp->IoStatus.Information = 
        (ULONG_PTR)IoGetCurrentIrpStackLocation (Irp)->Parameters.DeviceIoControl.Type3InputBuffer;

    AfdCompleteOutstandingIrp( endpoint, Irp );

    return STATUS_SUCCESS;

} // AfdRestartBindGetAddress




NTSTATUS
FASTCALL
AfdGetAddress (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Handles the IOCTL_AFD_BIND IOCTL.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    NTSTATUS status;
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE( );

    Irp->IoStatus.Information = 0;
    if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength<
            (ULONG) FIELD_OFFSET(TDI_ADDRESS_INFO, Address.Address[0].Address)) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    AFD_W4_INIT status = STATUS_SUCCESS;
    try {
        if (IoAllocateMdl (Irp->UserBuffer,
                            IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                            FALSE,              // SecondaryBuffer
                            TRUE,               // ChargeQuota
                            Irp                 // Irp
                            )==NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto complete;
        }
        MmProbeAndLockPages (Irp->MdlAddress,
                                Irp->RequestorMode,
                                IoWriteAccess);
        if (MmGetSystemAddressForMdlSafe (Irp->MdlAddress, HighPagePriority)==NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto complete;
        }
    }
    except (AFD_EXCEPTION_FILTER (status)) {
        ASSERT (NT_ERROR (status));
        goto complete;
    }

    //
    // Make sure that the endpoint is in the correct state.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    if ( endpoint->State!=AfdEndpointStateBound &&
             endpoint->State != AfdEndpointStateConnected ) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    //
    // If the endpoint is connected, use the connection's file object.
    // Otherwise, use the address file object.  Don't use the connection
    // file object if this is a Netbios endpoint because NETBT cannot
    // support this TDI feature.
    //

    if ( endpoint->LocalAddress->Address[0].AddressType !=
                 TDI_ADDRESS_TYPE_NETBIOS &&
            endpoint->Type == AfdBlockTypeVcConnecting &&
            endpoint->State == AfdEndpointStateConnected &&
            ((connection=AfdGetConnectionReferenceFromEndpoint (endpoint)) != NULL)
              ) {
        ASSERT( connection->Type == AfdBlockTypeConnection );
        fileObject = connection->FileObject;
        deviceObject = connection->DeviceObject;
        //
        // Reference file object so it cannot go away even if
        // connection is disassociated in TransmitFile (REUSE)
        // and closed.
        //
        ObReferenceObject (fileObject);
        DEREFERENCE_CONNECTION (connection);
    } 
    //
    // Reference address file object under the lock so it cannot go away
    // in TransmitFile (REUSE).
    //
    else if ((fileObject=AfdGetAddressFileReference (endpoint))!=NULL) {
        fileObject = endpoint->AddressFileObject;
        deviceObject = IoGetRelatedDeviceObject (fileObject);
    }
    else {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    //
    // Set up the query info to the TDI provider.
    //

    TdiBuildQueryInformation(
        Irp,
        deviceObject,
        fileObject,
        AfdRestartGetAddress,
        fileObject,
        TDI_QUERY_ADDRESS_INFO,
        Irp->MdlAddress
        );

    //
    // Call the TDI provider to get the address.
    //

    return AfdIoCallDriver( endpoint, deviceObject, Irp );

complete:
    if (Irp->MdlAddress!=NULL) {
        if (Irp->MdlAddress->MdlFlags & MDL_PAGES_LOCKED) {
            MmUnlockPages (Irp->MdlAddress);
        }
        IoFreeMdl (Irp->MdlAddress);
        Irp->MdlAddress = NULL;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

} // AfdGetAddress


PFILE_OBJECT
AfdGetAddressFileReference (
    PAFD_ENDPOINT   Endpoint
    )
{
    AFD_LOCK_QUEUE_HANDLE   lockHandle;
    PFILE_OBJECT    fileObject;

    AfdAcquireSpinLock (&Endpoint->SpinLock, &lockHandle);
    fileObject = Endpoint->AddressFileObject;
    if (fileObject!=NULL) {
        ObReferenceObject (fileObject);
    }
    AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
    return fileObject;
}

NTSTATUS
AfdRestartGetAddress (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    NTSTATUS status;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation (Irp);
    PAFD_ENDPOINT endpoint = irpSp->FileObject->FsContext;
    PFILE_OBJECT    fileObject = Context;

    UNREFERENCED_PARAMETER (DeviceObject);

    ASSERT (IS_AFD_ENDPOINT_TYPE( endpoint ));

    //
    // If the request succeeded, save the address in the endpoint so
    // we can use it to handle address sharing.
    // Avoid updating accepting endpoint since they share address
    // with listening endpoint.
    //

    if ( NT_SUCCESS(Irp->IoStatus.Status) &&
         (endpoint->Type!=AfdBlockTypeVcConnecting ||
            endpoint->Common.VcConnecting.ListenEndpoint==NULL)) {
         ULONG addressLength;
        //
        // First determine the length of the address by walking the MDL
        // chain.
        //

        //
        // We cannot have a chain here.
        //
        ASSERT( Irp->MdlAddress != NULL);
        ASSERT( Irp->MdlAddress->Next == NULL );

        //
        // If the new address is longer than the original address, allocate
        // a new local address buffer.  The +4 accounts for the ActivityCount
        // field that is returned by a query address but is not part
        // of a TRANSPORT_ADDRESS.
        //
        // This cannot happen, in any case msafd does not retry if buffer is
        // insuffucient, so application perceives this as failure to bind
        // or get address.
        //

        addressLength = MmGetMdlByteCount (Irp->MdlAddress) - FIELD_OFFSET (TDI_ADDRESS_INFO, Address);

        if (addressLength>endpoint->LocalAddressLength) {
            addressLength = (ULONG)Irp->IoStatus.Information - FIELD_OFFSET (TDI_ADDRESS_INFO, Address);
        }
        if ( addressLength <= endpoint->LocalAddressLength) {
            status = TdiCopyMdlToBuffer(
                         Irp->MdlAddress,
                         FIELD_OFFSET (TDI_ADDRESS_INFO, Address),
                         endpoint->LocalAddress,
                         0,
                         addressLength,
                         &endpoint->LocalAddressLength
                         );
            ASSERT( NT_SUCCESS(status) );
        }
        else {
            DbgPrint ("AfdRestartGetAddress: Endpoint %p transport returned"
                    " address is longer than the original one.\n",
                    endpoint);
            ASSERT (FALSE);
        }
    }

    //
    // If pending has been returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending( Irp );
    }

    AfdCompleteOutstandingIrp( endpoint, Irp );
    ObDereferenceObject (fileObject);

    return STATUS_SUCCESS;

} // AfdRestartGetAddress

const CHAR ZeroNodeAddress[6]={0};
const CHAR ZeroIP6Address[16]={0};


BOOLEAN
AfdAreTransportAddressesEqual (
    IN PTRANSPORT_ADDRESS EndpointAddress,
    IN ULONG EndpointAddressLength,
    IN PTRANSPORT_ADDRESS RequestAddress,
    IN ULONG RequestAddressLength,
    IN BOOLEAN HonorWildcardIpPortInEndpointAddress
    )
{
    //
    // Make sure we can safely access the address type and length fields
    // 
    if ((EndpointAddressLength<(ULONG)FIELD_OFFSET (TRANSPORT_ADDRESS,Address[0].Address))
            || (RequestAddressLength<(ULONG)FIELD_OFFSET (TRANSPORT_ADDRESS,Address[0].Address)) ) {
        return FALSE;
    }
    
    if ( EndpointAddress->Address[0].AddressType == TDI_ADDRESS_TYPE_IP &&
         RequestAddress->Address[0].AddressType == TDI_ADDRESS_TYPE_IP ) {

        TDI_ADDRESS_IP UNALIGNED *ipEndpointAddress;
        TDI_ADDRESS_IP UNALIGNED *ipRequestAddress;

        //
        // They are both IP addresses.  If the ports are the same, and
        // the IP addresses are or _could_be_ the same, then the addresses
        // are equal.  The "cound be" part is true if either IP address
        // is 0, the "wildcard" IP address.
        //

        ipEndpointAddress = (TDI_ADDRESS_IP UNALIGNED *)&EndpointAddress->Address[0].Address[0];
        ipRequestAddress = (TDI_ADDRESS_IP UNALIGNED *)&RequestAddress->Address[0].Address[0];

        if ( (EndpointAddressLength>=(ULONG)FIELD_OFFSET (TA_IP_ADDRESS, Address[0].Address[0].sin_zero)) &&
                (RequestAddressLength>=(ULONG)FIELD_OFFSET (TA_IP_ADDRESS, Address[0].Address[0].sin_zero)) &&
                ( ipEndpointAddress->sin_port == ipRequestAddress->sin_port ||
               ( HonorWildcardIpPortInEndpointAddress &&
                 ipEndpointAddress->sin_port == 0 ) ) &&
             ( ipEndpointAddress->in_addr == ipRequestAddress->in_addr ||
               ipEndpointAddress->in_addr == 0 || ipRequestAddress->in_addr == 0 ) ) {

            return TRUE;
        }

        //
        // The addresses are not equal.
        //

        return FALSE;
    }

    if ( EndpointAddress->Address[0].AddressType == TDI_ADDRESS_TYPE_IP6 &&
         RequestAddress->Address[0].AddressType == TDI_ADDRESS_TYPE_IP6 ) {

        TDI_ADDRESS_IP6 UNALIGNED *ipEndpointAddress;
        TDI_ADDRESS_IP6 UNALIGNED *ipRequestAddress;
        C_ASSERT (sizeof (ZeroIP6Address)==sizeof (ipEndpointAddress->sin6_addr));

        //
        // They are both IPv6 addresses.  If the ports are the same, and
        // the IPv6 addresses are or _could_be_ the same, then the addresses
        // are equal.  The "could be" part is true if either IPv6 address
        // is the unspecified IPv6 address.
        //

        ipEndpointAddress = (TDI_ADDRESS_IP6 UNALIGNED *)&EndpointAddress->Address[0].Address;
        ipRequestAddress = (TDI_ADDRESS_IP6 UNALIGNED *)&RequestAddress->Address[0].Address;

        if ( (EndpointAddressLength>=sizeof (TA_IP6_ADDRESS)) &&
             (RequestAddressLength>=sizeof (TA_IP6_ADDRESS)) &&

             (ipEndpointAddress->sin6_port == ipRequestAddress->sin6_port ||
               ( HonorWildcardIpPortInEndpointAddress &&
                 ipEndpointAddress->sin6_port == 0 ) ) &&

             ( RtlEqualMemory(&ipEndpointAddress->sin6_addr,
                              &ipRequestAddress->sin6_addr,
                              sizeof (ipEndpointAddress->sin6_addr)) ||
               RtlEqualMemory(&ipEndpointAddress->sin6_addr,
                              ZeroIP6Address,
                              sizeof (ipEndpointAddress->sin6_addr)) ||
               RtlEqualMemory(&ipRequestAddress->sin6_addr,
                              ZeroIP6Address,
                              sizeof (ipEndpointAddress->sin6_addr)) ) ) {

            return TRUE;
        }

        //
        // The addresses are not equal.
        //

        return FALSE;
    }

    if ( EndpointAddress->Address[0].AddressType == TDI_ADDRESS_TYPE_IPX &&
         RequestAddress->Address[0].AddressType == TDI_ADDRESS_TYPE_IPX ) {

        TDI_ADDRESS_IPX UNALIGNED *ipxEndpointAddress;
        TDI_ADDRESS_IPX UNALIGNED *ipxRequestAddress;
        C_ASSERT (sizeof (ZeroNodeAddress)==sizeof (ipxEndpointAddress->NodeAddress));

        ipxEndpointAddress = (TDI_ADDRESS_IPX UNALIGNED *)&EndpointAddress->Address[0].Address[0];
        ipxRequestAddress = (TDI_ADDRESS_IPX UNALIGNED *)&RequestAddress->Address[0].Address[0];

        //
        // They are both IPX addresses.  Check the network addresses
        // first--if they don't match and both != 0, the addresses
        // are different.
        //

        if ( (EndpointAddressLength<sizeof (TA_IPX_ADDRESS)) ||
                (RequestAddressLength<sizeof (TA_IPX_ADDRESS)) ||
            ( ipxEndpointAddress->NetworkAddress != ipxRequestAddress->NetworkAddress &&
             ipxEndpointAddress->NetworkAddress != 0 &&
             ipxRequestAddress->NetworkAddress != 0 )) {
            return FALSE;
        }

        //
        // Now check the node addresses.  Again, if they don't match
        // and neither is 0, the addresses don't match.
        //

        ASSERT( ZeroNodeAddress[0] == 0 );
        ASSERT( ZeroNodeAddress[1] == 0 );
        ASSERT( ZeroNodeAddress[2] == 0 );
        ASSERT( ZeroNodeAddress[3] == 0 );
        ASSERT( ZeroNodeAddress[4] == 0 );
        ASSERT( ZeroNodeAddress[5] == 0 );

        if ( !RtlEqualMemory(
                 ipxEndpointAddress->NodeAddress,
                 ipxRequestAddress->NodeAddress,
                 6 ) &&
             !RtlEqualMemory(
                 ipxEndpointAddress->NodeAddress,
                 ZeroNodeAddress,
                 6 ) &&
             !RtlEqualMemory(
                 ipxRequestAddress->NodeAddress,
                 ZeroNodeAddress,
                 6 ) ) {
            return FALSE;
        }

        //
        // Finally, make sure the socket numbers match.
        //

        if ( ipxEndpointAddress->Socket != ipxRequestAddress->Socket ) {
            return FALSE;
        }

        return TRUE;

    }

    //
    // If either address is not of a known address type, then do a
    // simple memory compare. (Don't go out of bounds on either
    // structure).
    //
    if (RequestAddressLength>EndpointAddressLength)
        RequestAddressLength = EndpointAddressLength;

    return (BOOLEAN)(EndpointAddressLength == RtlCompareMemory(
                                   EndpointAddress,
                                   RequestAddress,
                                   RequestAddressLength ) );
} // AfdAreTransportAddressesEqual



BOOLEAN
AfdIsAddressInUse (
    PAFD_ENDPOINT   Endpoint,
    BOOLEAN         OtherProcessesOnly
    )
{
    PLIST_ENTRY listEntry;
    BOOLEAN     res = FALSE;

    PAGED_CODE ();

    //
    // We use shared access to the resource because we only need to make
    // sure that endpoint list is not modified while we are accessing it
    // and existing local addresses are not removed (both of these
    // operations are performed under exclusive access).
    //
    //
    // Make sure the thread in which we execute cannot get
    // suspeneded in APC while we own the global resource.
    //
    KeEnterCriticalRegion ();
    ExAcquireResourceSharedLite( AfdResource, TRUE );

    //
    // Walk the global list of endpoints,
    // and compare this address againat the address on each endpoint.
    //

    for ( listEntry = AfdEndpointListHead.Flink;
          listEntry != &AfdEndpointListHead;
          listEntry = listEntry->Flink ) {

        PAFD_ENDPOINT compareEndpoint;

        compareEndpoint = CONTAINING_RECORD(
                              listEntry,
                              AFD_ENDPOINT,
                              GlobalEndpointListEntry
                              );

        ASSERT( IS_AFD_ENDPOINT_TYPE( compareEndpoint ) );

        //
        // Check whether the endpoint has a local address, whether
        // the endpoint has been disconnected, whether the
        // endpoint is in the process of closing, and whether
        // it represents accepted connection.  If any of these
        // is true, don't compare addresses with this endpoint.
        //

        if (compareEndpoint!=Endpoint &&
                 compareEndpoint->LocalAddress != NULL &&
                 ( (compareEndpoint->DisconnectMode &
                        (AFD_PARTIAL_DISCONNECT_SEND |
                         AFD_ABORTIVE_DISCONNECT) ) == 0 ) &&
                 (compareEndpoint->State != AfdEndpointStateClosing) &&
                 ((compareEndpoint->State != AfdEndpointStateConnected)
                    || (compareEndpoint->Type!=AfdBlockTypeVcConnecting)
                    || (compareEndpoint->Common.VcConnecting.ListenEndpoint==NULL)) &&
                 (!OtherProcessesOnly ||
                    compareEndpoint->OwningProcess!=Endpoint->OwningProcess)
                 ) {

            //
            // Compare the bits in the endpoint's address and the
            // address we're attempting to bind to.  Note that we
            // also compare the transport device names on the
            // endpoints, as it is legal to bind to the same address
            // on different transports (e.g.  bind to same port in
            // TCP and UDP).  We can just compare the transport
            // device name pointers because unique names are stored
            // globally.
            //

            if ( Endpoint->TransportInfo ==
                     compareEndpoint->TransportInfo &&
                 compareEndpoint->LocalAddressLength == Endpoint->LocalAddressLength &&
                 AfdAreTransportAddressesEqual(
                     compareEndpoint->LocalAddress,
                     compareEndpoint->LocalAddressLength,
                     Endpoint->LocalAddress,
                     Endpoint->LocalAddressLength,
                     FALSE
                     ) ) {

                //
                // The addresses are equal.
                //
                res = TRUE;
                break;
            }
        }
    }

    ExReleaseResourceLite( AfdResource );
    KeLeaveCriticalRegion ();
    return res;
}

#if NOT_YET
NTSTATUS
AfdStealClosedEnpointAddress (
    PAFD_ENDPOINT   Endpoint,
    NTSTATUS        Status
    )
/*++

Routine Description:

    Allows reuse of address consumed by listening socket being closed
    This a workaround the problem posed by TDI semantics.  The TDI client
    must maintain an address object for connections accepted on such object
    to stay open.  The prevents creation of another address object with
    the same address although from the transport point of view there
    is no conflict.

Arguments:

    Endpoint - endpoint that failed address object creation due to a conflict

    Status   - original failure status

Return Value:

    STATUS_SUCCESS - the candidate for reuse was found
    Original status passed - no listening endpoint with matching address was found
    Other - failure to create handle for some other reason.

--*/
{
    PLIST_ENTRY listEntry;

    PAGED_CODE ();

    //
    // We use shared access to the resource because we only need to make
    // sure that endpoint list is not modified while we are accessing it
    // and existing local addresses are not removed (both of these
    // operations are performed under exclusive access).
    //
    //
    // Make sure the thread in which we execute cannot get
    // suspeneded in APC while we own the global resource.
    //
    KeEnterCriticalRegion ();
    ExAcquireResourceSharedLite( AfdResource, TRUE );

    //
    // Walk the global list of endpoints,
    // and compare this address againat the address on each endpoint.
    //

    for ( listEntry = AfdEndpointListHead.Flink;
          listEntry != &AfdEndpointListHead;
          listEntry = listEntry->Flink ) {

        PAFD_ENDPOINT compareEndpoint;

        compareEndpoint = CONTAINING_RECORD(
                              listEntry,
                              AFD_ENDPOINT,
                              GlobalEndpointListEntry
                              );

        ASSERT( IS_AFD_ENDPOINT_TYPE( compareEndpoint ) );


        if (compareEndpoint!=Endpoint &&
                compareEndpoint->EndpointCleanedUp &&
                compareEndpoint->TransportInfo==
                        Endpoint->TransportInfo &&
                compareEndpoint->Listening &&
                compareEndpoint->AddressHandle!=NULL &&
                compareEndpoint->LocalAddressLength == Endpoint->LocalAddressLength &&
                AfdAreTransportAddressesEqual(
                     compareEndpoint->LocalAddress,
                     compareEndpoint->LocalAddressLength,
                     Endpoint->LocalAddress,
                     Endpoint->LocalAddressLength,
                     FALSE
                     )) {

            //
            // There is a theoretical security issue here.
            // We open a handle from kernel mode and thus
            // bypass the security checks which were done by the
            // original client when calling IoCreateFile.
            //
            Status = ObOpenObjectByPointer(
                         compareEndpoint->AddressFileObject,
                         OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                         NULL,
                         MAXIMUM_ALLOWED,
                         *IoFileObjectType,
                         KernelMode,
                         &Endpoint->AddressHandle
                         );
            break;
        }
    }
    ExReleaseResourceLite( AfdResource );
    KeLeaveCriticalRegion ();

    return Status;
}
#endif // NOT_YET
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\afdstr.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    afdstr.h

Abstract:

    This module contains typedefs for structures used by AFD.

Author:

    David Treadwell (davidtr)    21-Feb-1992

Revision History:

--*/

#ifndef _AFDSTR_
#define _AFDSTR_

//
// This field defines the layout of a 32-bit pointer.
// This must be ULONG as wow64 support 4gb address on win64.
// You shouldn't POINTER_32 as this will sign-extend addresses when converting
// it to a 64-bit pointer and will end up having the wrong address.
//
typedef ULONG AFD_POINTER_32;

//
// Make sure that queued spinlocks are not used with
// regular spinlock functions by wrapping them into
// a different structure.
//
typedef struct _AFD_QSPIN_LOCK {
    KSPIN_LOCK  ActualSpinLock;
} AFD_QSPIN_LOCK, *PAFD_QSPIN_LOCK;

#if DBG

#ifndef REFERENCE_DEBUG
#define REFERENCE_DEBUG 1
#endif

#ifndef GLOBAL_REFERENCE_DEBUG
#define GLOBAL_REFERENCE_DEBUG 0
#endif

//
// Debug aid for queued spinlocks
// Allows us to verify that spinlock is released using
// the same handle as it was taken with.
//
typedef struct _AFD_LOCK_QUEUE_HANDLE {
    KLOCK_QUEUE_HANDLE  LockHandle;
    PAFD_QSPIN_LOCK     SpinLock;
} AFD_LOCK_QUEUE_HANDLE, *PAFD_LOCK_QUEUE_HANDLE;

#else

#ifndef REFERENCE_DEBUG
#define REFERENCE_DEBUG 0
#endif

#ifndef GLOBAL_REFERENCE_DEBUG
#define GLOBAL_REFERENCE_DEBUG 0
#endif

#define AFD_LOCK_QUEUE_HANDLE KLOCK_QUEUE_HANDLE
#define PAFD_LOCK_QUEUE_HANDLE PKLOCK_QUEUE_HANDLE

#endif // DBG

#if REFERENCE_DEBUG

#define AFD_REF_SHIFT       6
#define AFD_REF_MASK        ((1<<AFD_REF_SHIFT)-1)
#define AFD_MAX_REF         (1<<AFD_REF_SHIFT)
#define AFD_REF_TIME_BITS   16
#define AFD_MAX_REF_TIME    ((1<<AFD_REF_TIME_BITS)-1)
#define AFD_TIME_EXP_SHIFT  4
#define AFD_TIME_EXP_BITS   2
#define AFD_REF_CNT_BITS    4
#define AFD_REF_LOC_BITS    (32-AFD_REF_CNT_BITS-AFD_REF_TIME_BITS-AFD_TIME_EXP_BITS)

C_ASSERT (32-AFD_REF_SHIFT-AFD_REF_TIME_BITS <=
          AFD_TIME_EXP_SHIFT*((1<<AFD_TIME_EXP_BITS)-1));

typedef union _AFD_REFERENCE_DEBUG {
    struct {
        ULONGLONG   NewCount:AFD_REF_CNT_BITS;
        ULONGLONG   LocationId:AFD_REF_LOC_BITS;
        ULONGLONG   TimeExp:AFD_TIME_EXP_BITS;
        ULONGLONG   TimeDif:AFD_REF_TIME_BITS;
        ULONGLONG   Param:32;
    };
    ULONGLONG       QuadPart;
} AFD_REFERENCE_DEBUG, *PAFD_REFERENCE_DEBUG;
C_ASSERT (sizeof (AFD_REFERENCE_DEBUG)==sizeof (ULONGLONG));

typedef struct _AFD_REFERENCE_LOCATION {
    PCHAR       Format;
    PVOID       Address;
} AFD_REFERENCE_LOCATION, *PAFD_REFERENCE_LOCATION;

LONG
AfdFindReferenceLocation (
    IN  PCHAR   Format,
    OUT PLONG   LocationId
    );

#define AFD_GET_ARL(_s) (_arl ? _arl : AfdFindReferenceLocation((_s),&_arl))

#define AFD_UPDATE_REFERENCE_DEBUG(_rd,_r,_l,_p)                            \
        do {                                                                \
            LONG _n, _n1;                                                   \
            ULONGLONG _t = KeQueryInterruptTime ();                         \
            _n = (_rd)->CurrentReferenceSlot;                               \
            _n1 = (((LONG)(_t>>13))<<AFD_REF_SHIFT) + ((_n+1)&AFD_REF_MASK);\
            if (InterlockedCompareExchange (&(_rd)->CurrentReferenceSlot,   \
                                            _n1,_n)==_n) {                  \
                PAFD_REFERENCE_DEBUG _s;                                    \
                LONG    _d,_e=0;                                            \
                (_rd)->CurrentTimeHigh = (LONG)(_t>>(13+32-AFD_REF_SHIFT)); \
                _s = &(_rd)->ReferenceDebug[_n & AFD_REF_MASK];             \
                _s->NewCount = _r;                                          \
                _s->LocationId = _l;                                        \
                _s->Param = _p;                                             \
                _d = (_n1-1-_n) >> AFD_REF_SHIFT;                           \
                while (_d>=AFD_MAX_REF_TIME) {                              \
                    _e += 1;                                                \
                    _d >>= _e*AFD_TIME_EXP_SHIFT;                           \
                }                                                           \
                _s->TimeDif = _d;                                           \
                _s->TimeExp = _e;                                           \
                break;                                                      \
            }                                                               \
        } while (1)


#if GLOBAL_REFERENCE_DEBUG
#define MAX_GLOBAL_REFERENCE 4096

typedef struct _AFD_GLOBAL_REFERENCE_DEBUG {
    PVOID Info1;
    PVOID Info2;
    PVOID Connection;
    ULONG_PTR Action;
    LARGE_INTEGER TickCounter;
    ULONG NewCount;
    ULONG Dummy;
} AFD_GLOBAL_REFERENCE_DEBUG, *PAFD_GLOBAL_REFERENCE_DEBUG;
#endif

#endif

//
// A structure for maintaining work queue information in AFD.
//

typedef struct _AFD_WORK_ITEM {
    LIST_ENTRY WorkItemListEntry;
    PWORKER_THREAD_ROUTINE AfdWorkerRoutine;
    PVOID Context;
} AFD_WORK_ITEM, *PAFD_WORK_ITEM;

//
// Structures for holding connect data pointers and lengths.  This is
// kept separate from the normal structures to save space in those
// structures for transports that do not support and applications
// which do not use connect data.
//

typedef struct _AFD_CONNECT_DATA_INFO {
    PVOID Buffer;
    ULONG BufferLength;
} AFD_CONNECT_DATA_INFO, *PAFD_CONNECT_DATA_INFO;

typedef struct _AFD_CONNECT_DATA_BUFFERS {
    AFD_CONNECT_DATA_INFO SendConnectData;
    AFD_CONNECT_DATA_INFO SendConnectOptions;
    AFD_CONNECT_DATA_INFO ReceiveConnectData;
    AFD_CONNECT_DATA_INFO ReceiveConnectOptions;
    AFD_CONNECT_DATA_INFO SendDisconnectData;
    AFD_CONNECT_DATA_INFO SendDisconnectOptions;
    AFD_CONNECT_DATA_INFO ReceiveDisconnectData;
    AFD_CONNECT_DATA_INFO ReceiveDisconnectOptions;
    TDI_CONNECTION_INFORMATION RequestConnectionInfo;
    TDI_CONNECTION_INFORMATION ReturnConnectionInfo;
    ULONG Flags;
} AFD_CONNECT_DATA_BUFFERS, *PAFD_CONNECT_DATA_BUFFERS;

//
// Structure used for holding disconnect context information.
//

typedef struct _AFD_ENDPOINT AFD_ENDPOINT, *PAFD_ENDPOINT;
typedef struct _AFD_CONNECTION AFD_CONNECTION, *PAFD_CONNECTION;

typedef struct _AFD_TPACKETS_INFO_INTERNAL 
                AFD_TPACKETS_INFO_INTERNAL,
                *PAFD_TPACKETS_INFO_INTERNAL;

typedef DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT)
             struct _AFD_BUFFER 
                    AFD_BUFFER, 
                    *PAFD_BUFFER;

typedef struct _AFD_DISCONNECT_CONTEXT {
    LARGE_INTEGER Timeout;
    PIRP          Irp;
} AFD_DISCONNECT_CONTEXT, *PAFD_DISCONNECT_CONTEXT;


typedef struct _AFD_LR_LIST_ITEM AFD_LR_LIST_ITEM, *PAFD_LR_LIST_ITEM;
typedef BOOLEAN (* PAFD_LR_LIST_ROUTINE) (PAFD_LR_LIST_ITEM Item);

struct _AFD_LR_LIST_ITEM {
    SLIST_ENTRY             SListLink;    // Link in the list
    PAFD_LR_LIST_ROUTINE    Routine;      // Processing routine;
};


//
// Endpoint and connection structures and related informaion.
//
//
// Block types that identify which fields are
// available in the strucutures.
//

#define AfdBlockTypeEndpoint            0xAFD0  // VC endpoint before connect/accept/listen
#define AfdBlockTypeDatagram            0xAFD1  // Datagram endpoint in any state
#define AfdBlockTypeVcConnecting        0xAFD2  // VC endpoint after connect/accept
#define AfdBlockTypeVcListening         0xAFD4  // VC endpoint after listen
#define AfdBlockTypeVcBoth              0xAFD6  // VC endpoint after connect+listen
                                                // (used in multipoint root cases)


#define AfdBlockTypeHelper              0xAAFD  // Regular helper endpoint
#define AfdBlockTypeSanHelper           0x0AFD  // SAN helper endpoint
#define AfdBlockTypeSanEndpoint         0x1AFD  // SAN endpoint

#define AfdBlockTypeInvalidEndpoint     0xCAFD  // Right before we call ExFreePool

#define AfdBlockTypeConnection          0xAFD8  // Connection object
#define AfdBlockTypeInvalidConnection   0xEAFD  // Right before we call ExFreePool


#if DBG
#define IS_AFD_ENDPOINT_TYPE( endpoint )                         \
            ( (endpoint)->Type == AfdBlockTypeEndpoint ||        \
              (endpoint)->Type == AfdBlockTypeDatagram ||        \
              (endpoint)->Type == AfdBlockTypeVcConnecting ||    \
              (endpoint)->Type == AfdBlockTypeVcListening ||     \
              (endpoint)->Type == AfdBlockTypeVcBoth ||          \
              (endpoint)->Type == AfdBlockTypeHelper ||          \
              (endpoint)->Type == AfdBlockTypeSanHelper ||       \
              (endpoint)->Type == AfdBlockTypeSanEndpoint )
#endif

enum {
    AfdConnectionStateFree          = 0,    // On free/AcceptEx/DelayedAccept list
    AfdConnectionStateUnaccepted    = 1,    // On unaccepted list
    AfdConnectionStateReturned      = 2,    // On returned list
    AfdConnectionStateConnected     = 3,    // Accepted or connected
    AfdConnectionStateClosing       = 4     // Not  used anymore
};

//
// Flags that further qualify the state of the connection
//
typedef struct AFD_CONNECTION_STATE_FLAGS {
    union {
        struct {
            LOGICAL TdiBufferring:1,    // (Does not really belon here)
                    :3,                 // This spacing makes strcutures
                                        // much more readable (hex) in the 
                                        // debugger and has no effect
                                        // on the generated code as long
                                        // as number of flags is less than
                                        // 8 (we still take up full 32 bits
                                        // because of aligment requiremens
                                        // of most other fields)
                    Aborted:1,
                    AbortIndicated:1,
                    AbortFailed:1,
                    :1,
                    DisconnectIndicated:1,
                    :3,
                    ConnectedReferenceAdded:1,
                    :3,
                    SpecialCondition:1,
                    :3,
                    CleanupBegun:1,
                    :3,
                    ClosePendedTransmit:1,
                    :3,
                    OnLRList:1,         // Low-resource list
                    SanConnection:1,
                    RcvInitiated:1,     // AFD initiated receive to transport.
                    :1;
        };
        LOGICAL     ConnectionStateFlags;
    };
} AFD_CONNECTION_STATE_FLAGS;
C_ASSERT (sizeof (AFD_CONNECTION_STATE_FLAGS)==sizeof (LOGICAL));

struct _AFD_CONNECTION {
    // *** Frequently used, mostly read-only fields (state/type/flag changes are rare).
    USHORT Type;
    USHORT State;
    AFD_CONNECTION_STATE_FLAGS
#ifdef __cplusplus
        StateFlags
#endif
        ;

    PAFD_ENDPOINT Endpoint;
    PFILE_OBJECT FileObject;
    PDEVICE_OBJECT DeviceObject;
    PEPROCESS   OwningProcess;


    union {
        LONGLONG ConnectTime;   // After connection is accepted.
        PIRP     AcceptIrp;     // For AcceptEx
        PIRP     ListenIrp;     // For delayed accept
        PIRP     ConnectIrp;    // for SAN
    };

    // *** Frequently used volatile fields.
    volatile LONG ReferenceCount;

    union {

        struct {
            LARGE_INTEGER ReceiveBytesIndicated;
            LARGE_INTEGER ReceiveBytesTaken;
            LARGE_INTEGER ReceiveBytesOutstanding;

            LARGE_INTEGER ReceiveExpeditedBytesIndicated;
            LARGE_INTEGER ReceiveExpeditedBytesTaken;
            LARGE_INTEGER ReceiveExpeditedBytesOutstanding;
            BOOLEAN NonBlockingSendPossible;
            BOOLEAN ZeroByteReceiveIndicated;
        } Bufferring;

        struct {
            LIST_ENTRY ReceiveIrpListHead;
            LIST_ENTRY ReceiveBufferListHead;

            ULONG BufferredReceiveBytes;
            ULONG BufferredExpeditedBytes;

            USHORT BufferredReceiveCount;
            USHORT BufferredExpeditedCount;
            ULONG ReceiveBytesInTransport;

            LIST_ENTRY SendIrpListHead;
            
            ULONG BufferredSendBytes;
            ULONG BufferredSendCount;

            PIRP DisconnectIrp;

            LONG  ReceiveIrpsInTransport;   // debug only.
        } NonBufferring;

    } Common;


    ULONG MaxBufferredReceiveBytes;
    ULONG MaxBufferredSendBytes;

    PTRANSPORT_ADDRESS RemoteAddress;
    ULONG RemoteAddressLength;
    LONG    Sequence;

    HANDLE Handle;                          // Ref count protection



    union {
        AFD_WORK_ITEM           WorkItem;   // Work item to free the connection
                                            // Connection has to be at ref 0 to be
                                            // on the work queue, so it cannot be
                                            // on the lists below or being disconnected
                                            // because when on any of these lists the
                                            // ref count is above 0.
        struct {
            union {
                AFD_DISCONNECT_CONTEXT  DisconnectContext;
                                            // Disconnect operation context, we cannot be
                                            // on the listening endpoint list
                SLIST_ENTRY             SListEntry;
                                            // Links for listening endpoint lists
                LIST_ENTRY              ListEntry;
            };
            AFD_LR_LIST_ITEM    LRListItem; // Link for low resource list. When on this
                                            // list connection is referenced, but it can
                                            // also be on the listening endpoint list or
                                            // in the process of disconnecting.
        };
    };

    PAFD_CONNECT_DATA_BUFFERS ConnectDataBuffers;

#if REFERENCE_DEBUG
    LONG CurrentTimeHigh;
    volatile LONG CurrentReferenceSlot;
    AFD_REFERENCE_DEBUG ReferenceDebug[AFD_MAX_REF];
#endif

#ifdef _AFD_VERIFY_DATA_
    ULONGLONG VerifySequenceNumber;
#endif // _AFD_VERIFY_DATA_
};
// Fields of the AFD_CONNECTION are protected by the endpoint
// spinlock, except:
//  Type, FileObject, DeviceObject, OwningProcess, Handle which are
//      only set once and cleared when reference count goes to 0
// Endpoint field itself (and thus the spinlock) can change though.
//  - it is NULL when connection is on listening endpoint backlog
//      and connection cannot be referenced outside of listening endpoint.
//  - when it is assigned to listening endpoint it cannot change outside 
//      of listening endpoint spinlock
//  - when it is assigned to connecting/accepting endpoint, it cannot
//      change at all until reference count drops to 0 and
//      connection is again placed on listening endpoint backlog or
//      destroyed.
//  ReferenceCount only updated via interlocked operations.
//

#ifdef _AFD_VERIFY_DATA_
VOID
AfdVerifyBuffer (
    PAFD_CONNECTION Connection,
    PVOID           Buffer,
    ULONG           Length
    );
VOID
AfdVerifyMdl (
    PAFD_CONNECTION Connection,
    PMDL            Mdl,
    ULONG           Offset,
    ULONG           Length
    );
VOID
AfdVerifyAddress (
    PAFD_CONNECTION Connection,
    PTRANSPORT_ADDRESS Address
    );

#define AFD_VERIFY_BUFFER(_connection,_buffer,_length) \
            AfdVerifyBuffer(_connection,_buffer,_length)
#define AFD_VERIFY_MDL(_connection,_mdl,_offset,_length) \
            AfdVerifyMdl(_connection,_mdl,_offset,_length)
#define AFD_VERIFY_ADDRESS(_connection,_address) \
            AfdVerifyAddress(_connection,_address)
#else
#define AFD_VERIFY_BUFFER(_connection,_buffer,_length)
#define AFD_VERIFY_MDL(_connection,_mdl,_offset,_length)
#define AFD_VERIFY_ADDRESS(_connection,_address)
#endif // _AFD_VERIFY_DATA_

//
// Some macros that make code more readable.
//

#define VcNonBlockingSendPossible Common.Bufferring.NonBlockingSendPossible
#define VcZeroByteReceiveIndicated Common.Bufferring.ZeroByteReceiveIndicated

#define VcReceiveIrpListHead Common.NonBufferring.ReceiveIrpListHead
#define VcReceiveBufferListHead Common.NonBufferring.ReceiveBufferListHead
#define VcSendIrpListHead Common.NonBufferring.SendIrpListHead

#define VcBufferredReceiveBytes Common.NonBufferring.BufferredReceiveBytes
#define VcBufferredExpeditedBytes Common.NonBufferring.BufferredExpeditedBytes
#define VcBufferredReceiveCount Common.NonBufferring.BufferredReceiveCount
#define VcBufferredExpeditedCount Common.NonBufferring.BufferredExpeditedCount

#define VcReceiveBytesInTransport Common.NonBufferring.ReceiveBytesInTransport
#if DBG
#define VcReceiveIrpsInTransport Common.NonBufferring.ReceiveIrpsInTransport
#endif

#define VcBufferredSendBytes Common.NonBufferring.BufferredSendBytes
#define VcBufferredSendCount Common.NonBufferring.BufferredSendCount

#define VcDisconnectIrp Common.NonBufferring.DisconnectIrp

//
// Information stored about each transport device name for which there
// is an open endpoint.
//
typedef
NTSTATUS
(FASTCALL *PIO_CALL_DRIVER) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

typedef
PAFD_BUFFER
(FASTCALL *PAFD_GET_BUFFER) (
    IN ULONG    BufferDataSize,
    IN ULONG  AddressSize,
    IN PEPROCESS Process
);

typedef
PAFD_TPACKETS_INFO_INTERNAL
(FASTCALL *PAFD_GET_TPINFO) (
    IN ULONG    ElementCount
);

typedef struct _AFD_TRANSPORT_INFO {
    LIST_ENTRY TransportInfoListEntry;
    volatile LONG ReferenceCount;
    BOOLEAN InfoValid;
#ifdef _AFD_VARIABLE_STACK_
    CCHAR   StackSize;
    PAFD_GET_BUFFER GetBuffer;
    PAFD_GET_TPINFO GetTpInfo;
    PIO_CALL_DRIVER CallDriver;
#endif // _AFD_VARIABLE_STACK_
    UNICODE_STRING TransportDeviceName;
    TDI_PROVIDER_INFO ProviderInfo;
    //WCHAR TransportDeviceNameStructure;
} AFD_TRANSPORT_INFO, *PAFD_TRANSPORT_INFO;

//
// Endpoint state definitions (can't be <=0 or state change
// macros won't work correctly).
//
enum {
    AfdEndpointStateOpen             =1,    // Socket created but no yet bound
    AfdEndpointStateBound            =2,
    AfdEndpointStateConnected        =3,
    AfdEndpointStateCleanup          =4,    // Not used anymore
    AfdEndpointStateClosing          =5,
    AfdEndpointStateTransmitClosing  =6,    // TransmitFile with reuse
    AfdEndpointStateInvalid          =7     // Helper endpoints
};

//
// Flags that further qualify the state of the endpoint
//
typedef struct AFD_ENDPOINT_STATE_FLAGS {
    union {
        struct {
            LOGICAL Listening:1,
                    DelayedAcceptance:1,
                    :2,                 // This spacing makes strcutures
                                        // much more readable (hex) in the 
                                        // debugger and has no effect
                                        // on the generated code as long
                                        // as number of flags is less than
                                        // 8 (we still take up full 32 bits
                                        // because of aligment requiremens
                                        // of most other fields)
                    NonBlocking:1,
                    :3,
                    InLine:1,
                    :3,
                    EndpointCleanedUp:1,
                    :3,
                    PollCalled:1,
                    :3,
                    RoutingQueryReferenced:1,
                    RoutingQueryIPv6:1,
                    :2,
                    DisableFastIoSend:1,
                    EnableSendEvent:1,
                    :2,
                    DisableFastIoRecv:1,
                    :3;
        };
        LOGICAL     EndpointStateFlags;
    };
} AFD_ENDPOINT_STATE_FLAGS;
C_ASSERT (sizeof (AFD_ENDPOINT_STATE_FLAGS)==sizeof (LOGICAL));

struct _AFD_ENDPOINT {
    // *** Frequently used, mostly read-only fields (state/type/flag changes are rare).
    USHORT  Type;
    UCHAR   State;
    BOOLEAN AdminAccessGranted;
    ULONG   TdiServiceFlags;        // Tdi transport flags cached for quick access.

    AFD_ENDPOINT_FLAGS __f;         // As requested by the application through the
                                    // Winsock2 provider flags and/or socket type
    AFD_ENDPOINT_STATE_FLAGS 
#ifdef __cplusplus
        StateFlags
#endif
        ;
    PFILE_OBJECT    AddressFileObject;
    union {
        PDEVICE_OBJECT  AddressDeviceObject;
        PSECURITY_DESCRIPTOR SecurityDescriptor; // Only
    };
    PEPROCESS       OwningProcess;

    // *** Frequently used volatile fields.
    AFD_QSPIN_LOCK  SpinLock;       // Pointer sized.
    volatile LONG ReferenceCount;
    ULONG EventsActive;

    //
    // Use a union to overlap the fields that are exclusive to datagram
    // connecting, or listening endpoints.  Since many fields are
    // relevant to only one type of socket, it makes no sense to
    // maintain the fields for all sockets--instead, save some nonpaged
    // pool by combining them.
    //

    union {
        //
        // Information for circuit-based endpoints
        //
        struct {
            union {
                struct {
                    // These members are valid for listening endpoints
                    // (AfdBlockTypeVcListening).
                    LIST_ENTRY UnacceptedConnectionListHead;
                    LIST_ENTRY ReturnedConnectionListHead;
                    LIST_ENTRY ListeningIrpListHead;

                    // The below lists have their own lock which gets
                    // used on the machines that do not support 64-bit
                    // interlocked compare and exchange.  On these machines
                    // using endpoint spinlock to synchronize causes all kinds
                    // of nasty deadlock conditions.
                    union {
                        LIST_ENTRY  ListenConnectionListHead; // Delayed accept
                        SLIST_HEADER FreeConnectionListHead;
                    };
                    SLIST_HEADER PreacceptedConnectionsListHead;

                    LONG FailedConnectionAdds;
                    LONG TdiAcceptPendingCount;

                    LONG Sequence;
                    BOOLEAN EnableDynamicBacklog;
                    BOOLEAN BacklogReplenishActive; // Worker is scheduled
                    USHORT  MaxExtraConnections;  // Extra connections we keep in the free queue
                                                  // based on maximum number of AcceptEx requests
                } Listening;
                struct {
                    KAPC    Apc;
                    USHORT  RemoteSocketAddressOffset;  // Offset inside of socket context
                                                        // pointing to remote address.
                    USHORT  RemoteSocketAddressLength;  // Length of the address.
#ifndef i386
                    BOOLEAN FixAddressAlignment;        // Fix address alignment in
                                                        // SuperAccept
#endif
                };
            };
            // These members are valid for all vc endpoints (but
            // can be NULL)
            PAFD_CONNECTION Connection;
            struct _AFD_ENDPOINT *ListenEndpoint;
            PAFD_CONNECT_DATA_BUFFERS ConnectDataBuffers;
        } VirtualCircuit;

#define VcConnecting    VirtualCircuit
#define VcListening     VirtualCircuit.Listening
#define VcConnection    VirtualCircuit.Connection
        //
        // Information for datagram endpoints.  Note that different
        // information is kept depending on whether the underlying
        // transport buffers internally.
        //

        struct {
            LIST_ENTRY ReceiveIrpListHead;
            LIST_ENTRY PeekIrpListHead;
            LIST_ENTRY ReceiveBufferListHead;

            ULONG BufferredReceiveBytes;
            ULONG BufferredReceiveCount;

            ULONG MaxBufferredReceiveBytes;
            ULONG BufferredSendBytes;
            ULONG MaxBufferredSendBytes;


            ULONG RemoteAddressLength;
            PTRANSPORT_ADDRESS RemoteAddress;

            union {
                struct {
                    LOGICAL CircularQueueing:1,
                        :3,
                        HalfConnect:1,
                        :3,
                        DisablePUError:1,
                        :3,
                        AddressDrop:1,
                        ResourceDrop:1,
                        BufferDrop:1,
                        ErrorDrop:1;
                };
                LOGICAL Flags;
            };
        } Datagram;

        struct {
            LIST_ENTRY SanListLink;
            PVOID   IoCompletionPort;
            PKEVENT IoCompletionEvent;
            LONG    Plsn;   // Provider list sequence number
            LONG    PendingRequests; // Number of pending requests to this process 
        } SanHlpr;

        struct {
            struct _AFD_ENDPOINT *SanHlpr;
            PFILE_OBJECT FileObject;
            union {
                //
                // We can only have either one of two at any given time.
                //
                PAFD_SWITCH_CONTEXT  SwitchContext;
                PVOID       SavedContext;
            };
            PAFD_SWITCH_CONTEXT  LocalContext;
            LIST_ENTRY  IrpList;
            ULONG       SavedContextLength;
            ULONG       RequestId;
            ULONG       SelectEventsActive;
            NTSTATUS    CtxTransferStatus;
            BOOLEAN     ImplicitDup; // Dup-ed into another process without
                                     // explicit request from the applicaiton
                                        
        } SanEndp;

    } Common;


    volatile PVOID Context;
    ULONG ContextLength;

    ULONG LocalAddressLength;
    PTRANSPORT_ADDRESS LocalAddress;

    ULONG DisconnectMode;
    LONG  OutstandingIrpCount;

    HANDLE  AddressHandle;      // TDI transport address object
    PAFD_TRANSPORT_INFO TransportInfo;

    LIST_ENTRY RoutingNotifications;  // For non-blocking sockets
    LIST_ENTRY RequestList;         // For misc requests

    LIST_ENTRY GlobalEndpointListEntry;
    AFD_WORK_ITEM   WorkItem;
    PIRP            Irp;        // AcceptEx or TransmitPackets IRP
    //
    // Non-zero when state change such as binding, accepting,
    // conntecting, and transmit file are in progress.
    LONG  StateChangeInProgress;

    //
    // EventSelect info.
    //

    ULONG EventsEnabled;
    NTSTATUS EventStatus[AFD_NUM_POLL_EVENTS]; // Currently 13 events
    PKEVENT EventObject;

    //
    // Socket grouping.
    //

    LONG GroupID;
    AFD_GROUP_TYPE GroupType;
    LIST_ENTRY ConstrainedEndpointListEntry;

    //
    // Debug stuff.
    //

#if REFERENCE_DEBUG
    LONG CurrentTimeHigh;
    LONG CurrentReferenceSlot;
    AFD_REFERENCE_DEBUG ReferenceDebug[AFD_MAX_REF];
#endif

#if DBG
    LIST_ENTRY OutstandingIrpListHead;
    LONG ObReferenceBias;
#endif
};
// Fields AFD_ENDPOINT structure are protected by the embedded
// spinlock, except:
// AdminAccessGranted, TdiServiceFlags, __f, OwningProcess, TransportInfo,
//  IoCompletionPort, IoCompletionEvent, AddressHandle which are
//  set once and are not touched until reference count goes to 0
// Type, State, LocalAddress, LocalAddressLength, AddressFileObject,
//  AddressDeviceObject, AddressHandle, TdiServiceFlags are protected by the 
//  StateChange interlocked mutex (AddressHandle and TdiServiceFlags can only be set
//  once under the mutex).
// AddressFileObject,AddressDeviceObject,LocalAddress, LocalAddressLength can only be 
//  reset to NULL under the endpoint spinlock in case of TransmitFile (REUSE) on
//  accepting endpoint (StateChange protection still applies).
// Counters: ReferenceCount, FailedConnectionAdds, TdiAcceptPendingCount,
//  Sequence, PendingRequests, SelectEventsActive are accessed with interlocked operations.
// Context, ContextLength, SwitchContext, SavedContext, LocalContext,
//  SavedContextLength, RemoveSocketAddressOffset, RemoteSocketAddressLength
//  are protected by the context lock (AfdLockContext).


typedef struct _AFD_POLL_ENDPOINT_INFO {
    PAFD_ENDPOINT Endpoint;
    PFILE_OBJECT FileObject;
    HANDLE Handle;
    ULONG PollEvents;
} AFD_POLL_ENDPOINT_INFO, *PAFD_POLL_ENDPOINT_INFO;

typedef struct _AFD_POLL_INFO_INTERNAL {
    LIST_ENTRY PollListEntry;
    ULONG NumberOfEndpoints;
    PIRP Irp;
    union {
        struct {
            KDPC Dpc;
            KTIMER Timer;
        };
        KAPC    Apc;            // for SAN
    };
    BOOLEAN Unique;
    BOOLEAN TimerStarted;
    BOOLEAN SanPoll;
    AFD_POLL_ENDPOINT_INFO EndpointInfo[1];
} AFD_POLL_INFO_INTERNAL, *PAFD_POLL_INFO_INTERNAL;

//
// A couple of useful manifests that make code more readable.
//

#define ReceiveDatagramIrpListHead Common.Datagram.ReceiveIrpListHead
#define PeekDatagramIrpListHead Common.Datagram.PeekIrpListHead
#define ReceiveDatagramBufferListHead Common.Datagram.ReceiveBufferListHead
#define DgBufferredReceiveCount Common.Datagram.BufferredReceiveCount
#define DgBufferredReceiveBytes Common.Datagram.BufferredReceiveBytes
#define DgBufferredSendBytes Common.Datagram.BufferredSendBytes

#define AFD_CONNECTION_FROM_ENDPOINT( endpoint ) (  \
        (((endpoint)->Type & AfdBlockTypeVcConnecting)==AfdBlockTypeVcConnecting) \
            ? (endpoint)->Common.VirtualCircuit.Connection                        \
            : (PAFD_CONNECTION)NULL                                               \
     )

//
// A structure which describes buffers used by AFD to perform bufferring
// for TDI providers which do not perform internal bufferring.
// It is also used in other code path as buffer descriptors.
//
typedef struct _AFD_BUFFER_HEADER AFD_BUFFER_HEADER, *PAFD_BUFFER_HEADER;

#define _AFD_BUFFER_HEADER_                                                    \
    union {                                                                    \
      TDI_CONNECTION_INFORMATION TdiInfo; /*holds info for TDI requests */     \
                                          /*with remote address */             \
      struct {                                                                 \
        union {           /* Links */                                          \
          struct {                                                             \
            union {                                                            \
              SINGLE_LIST_ENTRY SList; /* for buffer lookaside lists */        \
              PAFD_BUFFER_HEADER  Next; /* for transmit packet lists */        \
            };                                                                 \
            PFILE_OBJECT FileObject; /* for cached file in transmit file */    \
          };                                                                   \
          LIST_ENTRY BufferListEntry; /* for endpoint/connection lists */      \
        };                                                                     \
        union {                                                                \
          struct {                                                             \
            ULONG   DataOffset;   /* offset in buffer to start of unread data*/\
            union {                                                            \
              ULONG   DatagramFlags;/* flags for datagrams with control info */\
              LONG    RefCount; /* Permit partial copy outside the lock*/      \
            };                                                                 \
          };                                                                   \
          LARGE_INTEGER FileOffset;/* data offset from the start of the file */\
        };                                                                     \
        UCHAR       _Test; /* used to test relative field pos in the union */  \
      };                                                                       \
    };                                                                         \
    union {                                                                    \
      PVOID     Context; /* stores context info (endp/conn/etc)*/              \
      NTSTATUS  Status;/* stores status of completed operation */              \
    };                                                                         \
    PMDL        Mdl;             /* pointer to an MDL describing the buffer*/  \
    ULONG       DataLength;      /* actual data in the buffer */               \
    ULONG       BufferLength;    /* amount of space allocated for the buffer */\
    union {                                                                    \
      struct {                                                                 \
        /* Flags that describe data in the buffer */                           \
        UCHAR   ExpeditedData:1, /* The buffer contains expedited data*/       \
                :3,                                                            \
                PartialMessage:1,/* This is a partial message*/                \
                :3;                                                            \
        /* Flags that keep allocation information */                           \
        UCHAR   NdisPacket:1,    /* Context is a packet to return to NDIS/TDI*/\
                :3,                                                            \
                Placement:2,     /* Relative placement of the pieces */        \
                AlignmentAdjusted:1, /* MM block alignment was adjusted to */  \
                                 /* meet AFD buffer alignment requirement */   \
                Lookaside:1;     /* Poped from Slist (no quota charge)*/       \
      };                                                                       \
      USHORT    Flags;                                                         \
    };                                                                         \
    USHORT      AllocatedAddressLength/* length allocated for address */       \


struct _AFD_BUFFER_HEADER {
    _AFD_BUFFER_HEADER_ ;
};

//
// The buffer management code makes the following assumptions
// about the union at the top the buffer header so that list
// links and DataOffset field are not in conflict with
// RemoteAddress fields of the TDI_CONNECTION_INFORMATION.
//
C_ASSERT (FIELD_OFFSET (AFD_BUFFER_HEADER, TdiInfo.RemoteAddress) >=
                            FIELD_OFFSET (AFD_BUFFER_HEADER, _Test));
C_ASSERT (FIELD_OFFSET (AFD_BUFFER_HEADER, TdiInfo.RemoteAddressLength)>=
                            FIELD_OFFSET (AFD_BUFFER_HEADER, _Test));

C_ASSERT(FIELD_OFFSET (AFD_BUFFER_HEADER, AllocatedAddressLength)==
                FIELD_OFFSET(AFD_BUFFER_HEADER, Flags)+sizeof (USHORT));

typedef struct AFD_BUFFER_TAG {
    union {
        struct {
            _AFD_BUFFER_HEADER_;    // easy access to individual members
        };
        AFD_BUFFER_HEADER Header;   // access to the header as a whole
    };
#if DBG
    PVOID Caller;
    PVOID CallersCaller;
#endif
    // UCHAR Address[];            // address of datagram sender
} AFD_BUFFER_TAG, *PAFD_BUFFER_TAG;

struct _AFD_BUFFER {
    union {
        struct {
            _AFD_BUFFER_HEADER_;    // easy access to individual members
        };
        AFD_BUFFER_HEADER Header;   // access to the header as a whole
    };
    PIRP Irp;                      // pointer to the IRP associated w/the buffer
    PVOID Buffer;                  // a pointer to the actual data buffer

#if DBG
    LIST_ENTRY DebugListEntry;
    PVOID Caller;
    PVOID CallersCaller;
#endif
    // IRP Irp;                    // the IRP follows this structure
    // MDL Mdl;                    // the MDL follows the IRP
    // UCHAR Address[];            // address of datagram sender
    // UCHAR Buffer[BufferLength]; // the actual data buffer is last
} ;

//
// Placement of pieces that comprise the AFD_BUFFER.
// We have four pieces: header, IRP, MDL, data buffer
// and use 2 bits to encode each.
// We need to save the first piece so we know where the memory block
// starts when we need to return it to the memory manager.
//
enum {
    AFD_PLACEMENT_HDR      =0,
    AFD_PLACEMENT_IRP      =1,
    AFD_PLACEMENT_MDL      =2,
    AFD_PLACEMENT_BUFFER   =3,
    AFD_PLACEMENT_HDR_IRP  =(AFD_PLACEMENT_HDR|(AFD_PLACEMENT_IRP<<2)),
    AFD_PLACEMENT_HDR_MDL  =(AFD_PLACEMENT_HDR|(AFD_PLACEMENT_MDL<<2)),
    AFD_PLACEMENT_IRP_MDL  =(AFD_PLACEMENT_IRP|(AFD_PLACEMENT_MDL<<2)),
    AFD_PLACEMENT_HDR_IRP_MDL=(AFD_PLACEMENT_HDR|(AFD_PLACEMENT_IRP<<2)|(AFD_PLACEMENT_MDL<<4))
};


//
// ALIGN_DOWN_A aligns to given alignment requirement
// (as opposed to the type in the original ALIGN_DOWN macro)
//
#define ALIGN_DOWN_A(length,alignment)   \
    (((ULONG)(length)) & ~ ((alignment)-1))

//
// ALIGN_DOWN_A for pointers.
//
#define ALIGN_DOWN_A_POINTER(address,alignment)  \
    ((PVOID)(((ULONG_PTR)(address)) & ~ ((ULONG_PTR)(alignment)-1)))


//
// ALIGN_UP_A aligns to given alignment requirement
// (as opposed to the type in the original ALIGN_UP macro)
//
#define ALIGN_UP_A(length,alignment)   \
    ((((ULONG)(length)) + (alignment)-1) & ~ ((alignment)-1))

//
// ALIGN_UP_A for pointers.
//
#define ALIGN_UP_A_POINTER(address,alignment)  \
    ALIGN_DOWN_A_POINTER(((ULONG_PTR)(address) + alignment-1), alignment)

//
// ALIGN_UP_TO_TYPE aligns size to make sure it meets
// the type alignment requirement
//
#define ALIGN_UP_TO_TYPE(length,type)   \
    ALIGN_UP_A(length,TYPE_ALIGNMENT(type))

//
// ALIGN_UP_TO_TYPE for pointers.
//
#define ALIGN_UP_TO_TYPE_POINTER(address,type)   \
    ALIGN_UP_A_POINTER(address,TYPE_ALIGNMENT(type))

#if DBG

#define IS_VALID_AFD_BUFFER(b) (                                                                                                    \
    ((b)->Placement==AFD_PLACEMENT_HDR)                                                                                             \
        ? ((PUCHAR)b<(PUCHAR)(b)->Buffer && (PUCHAR)b<(PUCHAR)(b)->Mdl && (PUCHAR)b<(PUCHAR)(b)->Irp)                               \
        : (((b)->Placement==AFD_PLACEMENT_MDL)                                                                                      \
            ? ((PUCHAR)(b)->Mdl<(PUCHAR)(b)->Buffer && (PUCHAR)(b)->Mdl<(PUCHAR)b && (PUCHAR)(b)->Mdl<(PUCHAR)(b)->Irp)             \
            : ((b->Placement==AFD_PLACEMENT_IRP)                                                                                    \
                ? ((PUCHAR)(b)->Irp<(PUCHAR)(b)->Buffer && (PUCHAR)(b)->Irp<(PUCHAR)b && (PUCHAR)(b)->Irp<(PUCHAR)(b)->Mdl)         \
                : ((PUCHAR)(b)->Buffer<(PUCHAR)(b)->Irp && (PUCHAR)(b)->Buffer<(PUCHAR)b && (PUCHAR)(b)->Buffer<(PUCHAR)(b)->Mdl))  \
            )                                                                                                                       \
        )                                                                                                                           \

#endif


//
// Pointer to an IRP cleanup routine. This is used as a parameter to
// AfdCompleteIrpList().
//

typedef
BOOLEAN
(NTAPI * PAFD_IRP_CLEANUP_ROUTINE)(
    IN PIRP Irp
    );

//
// Debug statistics.
//

typedef struct _AFD_QUOTA_STATS {
    LARGE_INTEGER Charged;
    LARGE_INTEGER Returned;
} AFD_QUOTA_STATS;

typedef struct _AFD_HANDLE_STATS {
    LONG AddrOpened;
    LONG AddrClosed;
    LONG AddrRef;
    LONG AddrDeref;
    LONG ConnOpened;
    LONG ConnClosed;
    LONG ConnRef;
    LONG ConnDeref;
    LONG FileRef;
    LONG FileDeref;
} AFD_HANDLE_STATS;

typedef struct _AFD_QUEUE_STATS {
    LONG AfdWorkItemsQueued;
    LONG ExWorkItemsQueued;
    LONG WorkerEnter;
    LONG WorkerLeave;
    LONG AfdWorkItemsProcessed;
    PETHREAD AfdWorkerThread;
} AFD_QUEUE_STATS;

typedef struct _AFD_CONNECTION_STATS {
    LONG ConnectedReferencesAdded;
    LONG ConnectedReferencesDeleted;
    LONG GracefulDisconnectsInitiated;
    LONG GracefulDisconnectsCompleted;
    LONG GracefulDisconnectIndications;
    LONG AbortiveDisconnectsInitiated;
    LONG AbortiveDisconnectsCompleted;
    LONG AbortiveDisconnectIndications;
    LONG ConnectionIndications;
    LONG ConnectionsDropped;
    LONG ConnectionsAccepted;
    LONG ConnectionsPreaccepted;
    LONG ConnectionsReused;
    LONG EndpointsReused;
} AFD_CONNECTION_STATS;

//
// Global data. Resouces and lookaside list descriptors
// cannot be statically allocated, as they need to ALWAYS be nonpageable,
// even when the entire driver is paged out.
// Alignment table is variable-size and also cannot be statically allocated.
//

enum {
    AFD_LARGE_BUFFER_LIST=0,
    AFD_MEDIUM_BUFFER_LIST,
    AFD_SMALL_BUFFER_LIST,
    AFD_BUFFER_TAG_LIST,
    AFD_TP_INFO_LIST,
    AFD_REMOTE_ADDR_LIST,
    AFD_NUM_LOOKASIDE_LISTS
} AFD_LOOKASIDE_LISTS_INDEX;

typedef struct _AFD_GLOBAL_DATA {
    ERESOURCE               Resource;
    NPAGED_LOOKASIDE_LIST   List[AFD_NUM_LOOKASIDE_LISTS];
#define LargeBufferList     List[AFD_LARGE_BUFFER_LIST]
#define MediumBufferList    List[AFD_MEDIUM_BUFFER_LIST]
#define SmallBufferList     List[AFD_SMALL_BUFFER_LIST]
#define BufferTagList       List[AFD_BUFFER_TAG_LIST]
#define TpInfoList          List[AFD_TP_INFO_LIST]
#define RemoteAddrList      List[AFD_REMOTE_ADDR_LIST]
    LONG                    TrimFlags;
    KTIMER                  Timer;
    KDPC                    Dpc;
    UCHAR                   BufferAlignmentTable[ANYSIZE_ARRAY];
} AFD_GLOBAL_DATA, *PAFD_GLOBAL_DATA;

//
// Context structure for misc requests pended in AFD.
//
typedef struct _AFD_REQUEST_CONTEXT AFD_REQUEST_CONTEXT, *PAFD_REQUEST_CONTEXT;

//
// The routine is called after request is removed from endpoint list
// for cleanup purposes
//
typedef BOOLEAN (* PAFD_REQUEST_CLEANUP) (
                    PAFD_ENDPOINT           Endpoint,
                    PAFD_REQUEST_CONTEXT     NotifyCtx
                    );

//
// This structure has to no more 16 bytes long so we can
// reuse IrpSp->Parameters for it.
//
struct _AFD_REQUEST_CONTEXT {
    LIST_ENTRY              EndpointListLink;   // Link in endpoint list
    PAFD_REQUEST_CLEANUP    CleanupRoutine;     // Routine to call to cancel
    PVOID                   Context;            // Request dependent context
                                                // (PIRP)
};

//
// We use list entry fields to synchronize completion with cleanup/cancel
// routine assuming that as long as the entry is in the list
// both Flink and Blink fields cannot be NULL. (using these
// fields for synchronization allows us to cut down on
// cancel spinlock usage)
//

#define AfdEnqueueRequest(Endpoint,Request)                     \
    ExInterlockedInsertTailList(&(Endpoint)->RequestList,       \
                                &(Request)->EndpointListLink,   \
                                &(Endpoint)->SpinLock)


#define AfdIsRequestInQueue(Request)                           \
            ((Request)->EndpointListLink.Flink!=NULL)

#define AfdMarkRequestCompleted(Request)                       \
            (Request)->EndpointListLink.Blink = NULL

#define AfdIsRequestCompleted(Request)                         \
            ((Request)->EndpointListLink.Blink==NULL)


typedef struct _ROUTING_NOTIFY {
    LIST_ENTRY      NotifyListLink;
    PIRP            NotifyIrp;
    PVOID           NotifyContext;
} ROUTING_NOTIFY, *PROUTING_NOTIFY;

typedef struct _AFD_ADDRESS_ENTRY {
    LIST_ENTRY      AddressListLink;
    UNICODE_STRING  DeviceName;
    TA_ADDRESS      Address;
} AFD_ADDRESS_ENTRY, *PAFD_ADDRESS_ENTRY;

typedef struct _AFD_ADDRESS_CHANGE {
    LIST_ENTRY      ChangeListLink;
    union {
        PAFD_ENDPOINT   Endpoint;
        PIRP            Irp;
    };
    USHORT          AddressType;
    BOOLEAN         NonBlocking;
} AFD_ADDRESS_CHANGE, *PAFD_ADDRESS_CHANGE;


typedef 
NTSTATUS
(* PAFD_IMMEDIATE_CALL) (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    );

typedef
NTSTATUS
(FASTCALL * PAFD_IRP_CALL) (
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpSp
    );
    
typedef struct _AFD_TRANSMIT_PACKETS_ELEMENT {
#define TP_MDL      0x80000000
#define TP_COMBINE  0x40000000
    ULONG Flags;
    ULONG Length;
    union {
        struct {
            LARGE_INTEGER FileOffset;
            PFILE_OBJECT  FileObject;
        };
        struct {
            PVOID         Buffer;
            PMDL          Mdl;
        };
    };
} AFD_TRANSMIT_PACKETS_ELEMENT, *PAFD_TRANSMIT_PACKETS_ELEMENT;

//
// Structure to keep track of transmit packets request
//
struct _AFD_TPACKETS_INFO_INTERNAL {
    union {
        SINGLE_LIST_ENTRY   SListEntry;     // Link on S-List
        PFILE_OBJECT    TdiFileObject;      // Tdi objects (sending to)
    };

    PDEVICE_OBJECT  TdiDeviceObject;

    PMDL            HeadMdl;        // Ready to send chain
    PMDL            *TailMdl;
    
    PAFD_BUFFER_HEADER  HeadPd;     // Corresponding packet chain
    PAFD_BUFFER_HEADER  *TailPd;

    PIRP            ReadIrp;        // Irp used for file reads.
    PAFD_TRANSMIT_PACKETS_ELEMENT
                    ElementArray;   // Packet array
    
    ULONG           NextElement;    // Next element to send.
    ULONG           ElementCount;   // Total number of elements in the array
    
    ULONG           RemainingPkts;  // Number of packets remaining to be sent.
    USHORT          NumSendIrps;    // Actual number of send IRPs
    BOOLEAN         ArrayAllocated; // Element array is allocated (not built-in).
    BOOLEAN         PdNeedsPps;     // Packet descriptor being built needs post-
                                    // processing after completion.
    ULONG           PdLength;       // Currently accumulated send length
    ULONG           SendPacketLength; // Maximum length of the packet
                                    // APC/Work item for worker scheduling
    union {
        KAPC                Apc;
        WORK_QUEUE_ITEM     WorkItem;
    };

#if REFERENCE_DEBUG
    LONG CurrentTimeHigh;
    LONG CurrentReferenceSlot;
    AFD_REFERENCE_DEBUG ReferenceDebug[AFD_MAX_REF];
#endif
#if AFD_PERF_DBG
    LONG            WorkersExecuted;
#endif
#define AFD_TP_MIN_SEND_IRPS    2   // Need at least two to keep transport busy
#define AFD_TP_MAX_SEND_IRPS    8   // Max is based on current flags layout below
    PIRP            SendIrp[AFD_TP_MAX_SEND_IRPS];
    // ElementArray
    // SendIrp1
    // SendIrp2
};

//
// Structure maintained in driver context of the TPackets IRP
//
typedef struct _AFD_TPACKETS_IRP_CTX AFD_TPACKETS_IRP_CTX, *PAFD_TPACKETS_IRP_CTX;
#define AFD_GET_TPIC(_i) ((PAFD_TPACKETS_IRP_CTX)&(_i)->Tail.Overlay.DriverContext)
struct _AFD_TPACKETS_IRP_CTX {
    PAFD_TPACKETS_IRP_CTX       Next;           // Next TPackets IRP in the list
    LONG                        Flags;          // Application flags.
    volatile LONG               ReferenceCount; // IRP reference count
    volatile LONG               StateFlags;     // TPackets state flags
};

#define AFD_GET_TPIRP(_i) CONTAINING_RECORD(_i,IRP,Tail.Overlay.DriverContext)

#define AFD_TP_ABORT_PENDING         0x00000001  // Request is being aborted
#define AFD_TP_WORKER_SCHEDULED      0x00000002  // Worker is scheduled or active
#define AFD_TP_SENDS_POSTED          0x00000010  // All sends have been posted.
#define AFD_TP_QUEUED                0x00000020  // Irp is in the queue.
#define AFD_TP_SEND                  0x00000100  // This is a plain send in TP queue.
#define AFD_TP_AFD_SEND              0x00000200  // This is AFD send IRP.
#ifdef TDI_SERVICE_SEND_AND_DISCONNECT
#define AFD_TP_SEND_AND_DISCONNECT   0x00000400  // S&D is enabled
#endif // TDI_SERVICE_SEND_AND_DISCONNECT

#define AFD_TP_READ_CALL_PENDING     0x00001000  // MDL_READ call is imminent or in progress on ReadIrp
#define AFD_TP_READ_COMP_PENDING     0x00002000  // Read completion is expected on ReadIrp
#define AFD_TP_READ_BUSY (AFD_TP_READ_CALL_PENDING|AFD_TP_READ_COMP_PENDING)

    // TDI_SEND call is imminent or in progress on send Irp i
#define AFD_TP_SEND_CALL_PENDING(i) (0x00010000<<((i)*2))
    // Send completion is expected on send Irp i
#define AFD_TP_SEND_COMP_PENDING(i) (0x00020000<<((i)*2))
#define AFD_TP_SEND_BUSY(i)         (0x00030000<<((i)*2))
#define AFD_TP_SEND_MASK            (0x55550000)


#if DBG
//
// N.B. This structure MUST be alligned on memory allocation boundary
//

typedef struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) _AFD_POOL_HEADER {
    SIZE_T Size;
    PCHAR FileName;
    ULONG LineNumber;
    LONG  InUse;
} AFD_POOL_HEADER, *PAFD_POOL_HEADER;
#define AFD_POOL_OVERHEAD  (sizeof(AFD_POOL_HEADER))
#else
#define AFD_POOL_OVERHEAD   0
#endif

//
// This macro verifies that the 32-bit mapping of the structures in 64-bit
// compiler match original 32-bit structures.  Note, that the verification is
// performed when this file is compiled by 32 bit compiler, but
// the actual structures are used by 64 bit code.
//

#ifdef _WIN64
#define AFD_CHECK32on64(_str,_fld)
#define AFD_MAX_NATURAL_ALIGNMENT32  sizeof(ULONG)
#else
#define AFD_CHECK32on64(_str,_fld)    \
    C_ASSERT (FIELD_OFFSET (_str,_fld)==FIELD_OFFSET(_str##32,_fld))
#endif

//
// Structures for mapping IOCTL parameters for 32-bit clients on 64-bit
// platform.
//
typedef UNALIGNED struct _WSABUF32 {
    ULONG            len;
    AFD_POINTER_32   buf;
} WSABUF32, *LPWSABUF32;
AFD_CHECK32on64(WSABUF,len);
AFD_CHECK32on64(WSABUF,buf);

typedef UNALIGNED struct _QualityOfService32 {
    FLOWSPEC      SendingFlowspec;       /* the flow spec for data sending */
    FLOWSPEC      ReceivingFlowspec;     /* the flow spec for data receiving */
    WSABUF32      ProviderSpecific;      /* additional provider specific stuff */
} QOS32, * LPQOS32;
AFD_CHECK32on64(QOS,SendingFlowspec);
AFD_CHECK32on64(QOS,ReceivingFlowspec);
AFD_CHECK32on64(QOS,ProviderSpecific);

typedef UNALIGNED struct _AFD_ACCEPT_INFO32 {
    BOOLEAN     SanActive;
    LONG        Sequence;
    VOID * POINTER_32 AcceptHandle;
} AFD_ACCEPT_INFO32, *PAFD_ACCEPT_INFO32;
AFD_CHECK32on64(AFD_ACCEPT_INFO,SanActive);
AFD_CHECK32on64(AFD_ACCEPT_INFO,Sequence);
AFD_CHECK32on64(AFD_ACCEPT_INFO,AcceptHandle);

typedef UNALIGNED struct _AFD_SUPER_ACCEPT_INFO32 {
    BOOLEAN     SanActive;
    BOOLEAN     FixAddressAlignment;
    VOID * POINTER_32 AcceptHandle;
    ULONG ReceiveDataLength;
    ULONG LocalAddressLength;
    ULONG RemoteAddressLength;
} AFD_SUPER_ACCEPT_INFO32, *PAFD_SUPER_ACCEPT_INFO32;
AFD_CHECK32on64(AFD_SUPER_ACCEPT_INFO,SanActive);
AFD_CHECK32on64(AFD_SUPER_ACCEPT_INFO,FixAddressAlignment);
AFD_CHECK32on64(AFD_SUPER_ACCEPT_INFO,AcceptHandle);
AFD_CHECK32on64(AFD_SUPER_ACCEPT_INFO,ReceiveDataLength);
AFD_CHECK32on64(AFD_SUPER_ACCEPT_INFO,LocalAddressLength);
AFD_CHECK32on64(AFD_SUPER_ACCEPT_INFO,RemoteAddressLength);

typedef UNALIGNED struct _AFD_POLL_HANDLE_INFO32 {
    VOID * POINTER_32 Handle;
    ULONG             PollEvents;
    NTSTATUS          Status;
} AFD_POLL_HANDLE_INFO32, *PAFD_POLL_HANDLE_INFO32;
AFD_CHECK32on64(AFD_POLL_HANDLE_INFO,Handle);
AFD_CHECK32on64(AFD_POLL_HANDLE_INFO,PollEvents);
AFD_CHECK32on64(AFD_POLL_HANDLE_INFO,Status);

typedef UNALIGNED struct _AFD_POLL_INFO32 {
    LARGE_INTEGER Timeout;
    ULONG NumberOfHandles;
    BOOLEAN Unique;
    AFD_POLL_HANDLE_INFO32 Handles[1];
} AFD_POLL_INFO32, *PAFD_POLL_INFO32;
AFD_CHECK32on64(AFD_POLL_INFO,Timeout);
AFD_CHECK32on64(AFD_POLL_INFO,NumberOfHandles);
AFD_CHECK32on64(AFD_POLL_INFO,Unique);
AFD_CHECK32on64(AFD_POLL_INFO,Handles);

typedef UNALIGNED struct _AFD_HANDLE_INFO632 {
    VOID * POINTER_32 TdiAddressHandle;
    VOID * POINTER_32 TdiConnectionHandle;
} AFD_HANDLE_INFO32, *PAFD_HANDLE_INFO32;
AFD_CHECK32on64(AFD_HANDLE_INFO,TdiAddressHandle);
AFD_CHECK32on64(AFD_HANDLE_INFO,TdiConnectionHandle);

typedef UNALIGNED struct _AFD_TRANSMIT_FILE_INFO32 {
    LARGE_INTEGER Offset;
    LARGE_INTEGER WriteLength;
    ULONG SendPacketLength;
    VOID * POINTER_32 FileHandle;
    AFD_POINTER_32 Head;
    ULONG HeadLength;
    AFD_POINTER_32 Tail;
    ULONG TailLength;
    ULONG Flags;
} AFD_TRANSMIT_FILE_INFO32, *PAFD_TRANSMIT_FILE_INFO32;
AFD_CHECK32on64(AFD_TRANSMIT_FILE_INFO,Offset);
AFD_CHECK32on64(AFD_TRANSMIT_FILE_INFO,WriteLength);
AFD_CHECK32on64(AFD_TRANSMIT_FILE_INFO,SendPacketLength);
AFD_CHECK32on64(AFD_TRANSMIT_FILE_INFO,FileHandle);
AFD_CHECK32on64(AFD_TRANSMIT_FILE_INFO,Head);
AFD_CHECK32on64(AFD_TRANSMIT_FILE_INFO,HeadLength);
AFD_CHECK32on64(AFD_TRANSMIT_FILE_INFO,Tail);
AFD_CHECK32on64(AFD_TRANSMIT_FILE_INFO,TailLength);
AFD_CHECK32on64(AFD_TRANSMIT_FILE_INFO,Flags);

typedef UNALIGNED struct _AFD_SEND_INFO32 {
    AFD_POINTER_32 BufferArray;
    ULONG BufferCount;
    ULONG AfdFlags;
    ULONG TdiFlags;
} AFD_SEND_INFO32, *PAFD_SEND_INFO32;
AFD_CHECK32on64(AFD_SEND_INFO,BufferArray);
AFD_CHECK32on64(AFD_SEND_INFO,BufferCount);
AFD_CHECK32on64(AFD_SEND_INFO,AfdFlags);
AFD_CHECK32on64(AFD_SEND_INFO,TdiFlags);

typedef UNALIGNED struct _TDI_REQUEST32 {
    union {
        VOID * POINTER_32 AddressHandle;
        VOID * POINTER_32 ConnectionContext;
        VOID * POINTER_32 ControlChannel;
    } Handle;

    VOID * POINTER_32 RequestNotifyObject;
    VOID * POINTER_32 RequestContext;
    TDI_STATUS TdiStatus;
} TDI_REQUEST32, *PTDI_REQUEST32;
AFD_CHECK32on64(TDI_REQUEST,Handle);
AFD_CHECK32on64(TDI_REQUEST,RequestNotifyObject);
AFD_CHECK32on64(TDI_REQUEST,RequestContext);
AFD_CHECK32on64(TDI_REQUEST,TdiStatus);

typedef UNALIGNED struct _TDI_CONNECTION_INFORMATION32 {
    LONG UserDataLength;            // length of user data buffer
    AFD_POINTER_32 UserData;        // pointer to user data buffer
    LONG OptionsLength;             // length of follwoing buffer
    AFD_POINTER_32 Options;         // pointer to buffer containing options
    LONG RemoteAddressLength;       // length of following buffer
    AFD_POINTER_32 RemoteAddress;   // buffer containing the remote address
} TDI_CONNECTION_INFORMATION32, *PTDI_CONNECTION_INFORMATION32;
AFD_CHECK32on64(TDI_CONNECTION_INFORMATION,UserDataLength);
AFD_CHECK32on64(TDI_CONNECTION_INFORMATION,UserData);
AFD_CHECK32on64(TDI_CONNECTION_INFORMATION,OptionsLength);
AFD_CHECK32on64(TDI_CONNECTION_INFORMATION,Options);
AFD_CHECK32on64(TDI_CONNECTION_INFORMATION,RemoteAddressLength);
AFD_CHECK32on64(TDI_CONNECTION_INFORMATION,RemoteAddress);

typedef UNALIGNED struct _TDI_REQUEST_SEND_DATAGRAM32 {
    TDI_REQUEST32 Request;
    AFD_POINTER_32 SendDatagramInformation;
} TDI_REQUEST_SEND_DATAGRAM32, *PTDI_REQUEST_SEND_DATAGRAM32;
AFD_CHECK32on64(TDI_REQUEST_SEND_DATAGRAM,Request);
AFD_CHECK32on64(TDI_REQUEST_SEND_DATAGRAM,SendDatagramInformation);


typedef UNALIGNED struct _AFD_SEND_DATAGRAM_INFO32 {
    AFD_POINTER_32 BufferArray;
    ULONG BufferCount;
    ULONG AfdFlags;
    TDI_REQUEST_SEND_DATAGRAM32 TdiRequest;
    TDI_CONNECTION_INFORMATION32 TdiConnInfo;
} AFD_SEND_DATAGRAM_INFO32, *PAFD_SEND_DATAGRAM_INFO32;
AFD_CHECK32on64(AFD_SEND_DATAGRAM_INFO,BufferArray);
AFD_CHECK32on64(AFD_SEND_DATAGRAM_INFO,BufferCount);
AFD_CHECK32on64(AFD_SEND_DATAGRAM_INFO,AfdFlags);
AFD_CHECK32on64(AFD_SEND_DATAGRAM_INFO,TdiRequest);
AFD_CHECK32on64(AFD_SEND_DATAGRAM_INFO,TdiConnInfo);

typedef UNALIGNED struct _AFD_RECV_INFO32 {
    AFD_POINTER_32 BufferArray;
    ULONG BufferCount;
    ULONG AfdFlags;
    ULONG TdiFlags;
} AFD_RECV_INFO32, *PAFD_RECV_INFO32;
AFD_CHECK32on64(AFD_RECV_INFO,BufferArray);
AFD_CHECK32on64(AFD_RECV_INFO,BufferCount);
AFD_CHECK32on64(AFD_RECV_INFO,AfdFlags);
AFD_CHECK32on64(AFD_RECV_INFO,TdiFlags);

typedef UNALIGNED struct _AFD_RECV_DATAGRAM_INFO32 {
    AFD_POINTER_32 BufferArray;
    ULONG BufferCount;
    ULONG AfdFlags;
    ULONG TdiFlags;
    AFD_POINTER_32 Address;
    AFD_POINTER_32 AddressLength;
} AFD_RECV_DATAGRAM_INFO32, *PAFD_RECV_DATAGRAM_INFO32;
AFD_CHECK32on64(AFD_RECV_DATAGRAM_INFO,BufferArray);
AFD_CHECK32on64(AFD_RECV_DATAGRAM_INFO,BufferCount);
AFD_CHECK32on64(AFD_RECV_DATAGRAM_INFO,AfdFlags);
AFD_CHECK32on64(AFD_RECV_DATAGRAM_INFO,TdiFlags);
AFD_CHECK32on64(AFD_RECV_DATAGRAM_INFO,Address);
AFD_CHECK32on64(AFD_RECV_DATAGRAM_INFO,AddressLength);

typedef UNALIGNED struct _AFD_CONNECT_JOIN_INFO32 {
    BOOLEAN     SanActive;
    VOID * POINTER_32   RootEndpoint;   // Root endpoint for joins
    VOID * POINTER_32   ConnectEndpoint;// Connect/leaf endpoint for async connects
    TRANSPORT_ADDRESS   RemoteAddress;  // Remote address
} AFD_CONNECT_JOIN_INFO32, *PAFD_CONNECT_JOIN_INFO32;
AFD_CHECK32on64(AFD_CONNECT_JOIN_INFO,SanActive);
AFD_CHECK32on64(AFD_CONNECT_JOIN_INFO,RootEndpoint);
AFD_CHECK32on64(AFD_CONNECT_JOIN_INFO,ConnectEndpoint);
AFD_CHECK32on64(AFD_CONNECT_JOIN_INFO,RemoteAddress);

typedef UNALIGNED struct _AFD_EVENT_SELECT_INFO32 {
    VOID * POINTER_32 Event;
    ULONG PollEvents;
} AFD_EVENT_SELECT_INFO32, *PAFD_EVENT_SELECT_INFO32;
AFD_CHECK32on64(AFD_EVENT_SELECT_INFO,Event);
AFD_CHECK32on64(AFD_EVENT_SELECT_INFO,PollEvents);

typedef UNALIGNED struct _AFD_QOS_INFO32 {
    QOS32 Qos;
    BOOLEAN GroupQos;
} AFD_QOS_INFO32, *PAFD_QOS_INFO32;
AFD_CHECK32on64(AFD_QOS_INFO,Qos);
AFD_CHECK32on64(AFD_QOS_INFO,GroupQos);

typedef UNALIGNED struct _AFD_TRANSPORT_IOCTL_INFO32 {
    VOID *  POINTER_32 Handle;
    AFD_POINTER_32 InputBuffer;
    ULONG   InputBufferLength;
    ULONG   IoControlCode;
    ULONG   AfdFlags;
    ULONG   PollEvent;
} AFD_TRANSPORT_IOCTL_INFO32, *PAFD_TRANSPORT_IOCTL_INFO32;
AFD_CHECK32on64(AFD_TRANSPORT_IOCTL_INFO,Handle);
AFD_CHECK32on64(AFD_TRANSPORT_IOCTL_INFO,InputBuffer);
AFD_CHECK32on64(AFD_TRANSPORT_IOCTL_INFO,InputBufferLength);
AFD_CHECK32on64(AFD_TRANSPORT_IOCTL_INFO,IoControlCode);
AFD_CHECK32on64(AFD_TRANSPORT_IOCTL_INFO,AfdFlags);
AFD_CHECK32on64(AFD_TRANSPORT_IOCTL_INFO,PollEvent);

typedef UNALIGNED struct _TRANSMIT_PACKETS_ELEMENT32 {
    ULONG dwElFlags;
#define TP_MEMORY   1
#define TP_FILE     2
#define TP_EOP      4
    ULONG cLength;
    union {
        struct {
            LARGE_INTEGER       nFileOffset;
            VOID *  POINTER_32  hFile;
        };
        AFD_POINTER_32          pBuffer;
    };
} TRANSMIT_PACKETS_ELEMENT32, *LPTRANSMIT_PACKETS_ELEMENT32;
AFD_CHECK32on64(TRANSMIT_PACKETS_ELEMENT,dwElFlags);
AFD_CHECK32on64(TRANSMIT_PACKETS_ELEMENT,nFileOffset);
AFD_CHECK32on64(TRANSMIT_PACKETS_ELEMENT,hFile);
AFD_CHECK32on64(TRANSMIT_PACKETS_ELEMENT,pBuffer);

typedef UNALIGNED struct _AFD_TPACKETS_INFO32 {
    AFD_POINTER_32              ElementArray;
    ULONG                       ElementCount;
    ULONG                       SendSize;
    ULONG                       Flags;
} AFD_TPACKETS_INFO32, *PAFD_TPACKETS_INFO32;
AFD_CHECK32on64(AFD_TPACKETS_INFO,ElementArray);
AFD_CHECK32on64(AFD_TPACKETS_INFO,ElementCount);
AFD_CHECK32on64(AFD_TPACKETS_INFO,SendSize);
AFD_CHECK32on64(AFD_TPACKETS_INFO,Flags);

typedef UNALIGNED struct _AFD_RECV_MESSAGE_INFO32 {
    AFD_RECV_DATAGRAM_INFO32    dgi;
    AFD_POINTER_32              ControlBuffer;
    AFD_POINTER_32              ControlLength;
    AFD_POINTER_32              MsgFlags;
} AFD_RECV_MESSAGE_INFO32, *PAFD_RECV_MESSAGE_INFO32;
AFD_CHECK32on64(AFD_RECV_MESSAGE_INFO,dgi);
AFD_CHECK32on64(AFD_RECV_MESSAGE_INFO,MsgFlags);
AFD_CHECK32on64(AFD_RECV_MESSAGE_INFO,ControlBuffer);
AFD_CHECK32on64(AFD_RECV_MESSAGE_INFO,ControlLength);


typedef UNALIGNED struct _AFD_SWITCH_OPEN_PACKET32 {
    VOID * POINTER_32   CompletionPort; 
    VOID * POINTER_32   CompletionEvent;
} AFD_SWITCH_OPEN_PACKET32, *PAFD_SWITCH_OPEN_PACKET32;
AFD_CHECK32on64(AFD_SWITCH_OPEN_PACKET,CompletionPort);
AFD_CHECK32on64(AFD_SWITCH_OPEN_PACKET,CompletionEvent);

typedef UNALIGNED struct _AFD_SWITCH_CONTEXT_INFO32 {
    VOID * POINTER_32               SocketHandle;
    AFD_POINTER_32                  SwitchContext;
} AFD_SWITCH_CONTEXT_INFO32, *PAFD_SWITCH_CONTEXT_INFO32;
AFD_CHECK32on64(AFD_SWITCH_CONTEXT_INFO,SocketHandle);
AFD_CHECK32on64(AFD_SWITCH_CONTEXT_INFO,SwitchContext);

typedef UNALIGNED struct _AFD_SWITCH_CONNECT_INFO32 {
    VOID * POINTER_32               ListenHandle;
    AFD_POINTER_32                  SwitchContext;
    TRANSPORT_ADDRESS               RemoteAddress;
} AFD_SWITCH_CONNECT_INFO32, *PAFD_SWITCH_CONNECT_INFO32;
AFD_CHECK32on64(AFD_SWITCH_CONNECT_INFO,ListenHandle);
AFD_CHECK32on64(AFD_SWITCH_CONNECT_INFO,SwitchContext);
AFD_CHECK32on64(AFD_SWITCH_CONNECT_INFO,RemoteAddress);

typedef UNALIGNED struct _AFD_SWITCH_ACCEPT_INFO32 {
    VOID * POINTER_32   AcceptHandle;
    ULONG               ReceiveLength;
} AFD_SWITCH_ACCEPT_INFO32, *PAFD_SWITCH_ACCEPT_INFO32;
AFD_CHECK32on64(AFD_SWITCH_ACCEPT_INFO,AcceptHandle);
AFD_CHECK32on64(AFD_SWITCH_ACCEPT_INFO,ReceiveLength);

typedef UNALIGNED struct _AFD_SWITCH_EVENT_INFO32 {
    VOID * POINTER_32   SocketHandle;
    AFD_POINTER_32      SwitchContext;
    ULONG               EventBit;
    NTSTATUS            Status;
} AFD_SWITCH_EVENT_INFO32, *PAFD_SWITCH_EVENT_INFO32;
AFD_CHECK32on64(AFD_SWITCH_EVENT_INFO,SocketHandle);
AFD_CHECK32on64(AFD_SWITCH_EVENT_INFO,SwitchContext);
AFD_CHECK32on64(AFD_SWITCH_EVENT_INFO,EventBit);
AFD_CHECK32on64(AFD_SWITCH_EVENT_INFO,Status);

typedef UNALIGNED struct _AFD_SWITCH_REQUEST_INFO32 {
    VOID * POINTER_32   SocketHandle;
    AFD_POINTER_32      SwitchContext;
    AFD_POINTER_32      RequestContext;
    NTSTATUS            RequestStatus;
    ULONG               DataOffset;
} AFD_SWITCH_REQUEST_INFO32, *PAFD_SWITCH_REQUEST_INFO32;
AFD_CHECK32on64(AFD_SWITCH_REQUEST_INFO,SocketHandle);
AFD_CHECK32on64(AFD_SWITCH_REQUEST_INFO,SwitchContext);
AFD_CHECK32on64(AFD_SWITCH_REQUEST_INFO,RequestContext);
AFD_CHECK32on64(AFD_SWITCH_REQUEST_INFO,RequestStatus);
AFD_CHECK32on64(AFD_SWITCH_REQUEST_INFO,DataOffset);

typedef UNALIGNED struct _AFD_SWITCH_ACQUIRE_CTX_INFO32 {
    VOID * POINTER_32   SocketHandle;
    AFD_POINTER_32      SwitchContext;
    AFD_POINTER_32      SocketCtxBuf;
    ULONG               SocketCtxBufSize;
} AFD_SWITCH_ACQUIRE_CTX_INFO32, *PAFD_SWITCH_ACQUIRE_CTX_INFO32;
AFD_CHECK32on64(AFD_SWITCH_ACQUIRE_CTX_INFO,SocketHandle);
AFD_CHECK32on64(AFD_SWITCH_ACQUIRE_CTX_INFO,SwitchContext);
AFD_CHECK32on64(AFD_SWITCH_ACQUIRE_CTX_INFO,SocketCtxBuf);
AFD_CHECK32on64(AFD_SWITCH_ACQUIRE_CTX_INFO,SocketCtxBufSize);

typedef UNALIGNED struct _AFD_SWITCH_TRANSFER_CTX_INFO32 {
    VOID * POINTER_32   SocketHandle;
    AFD_POINTER_32      SwitchContext;
    AFD_POINTER_32      RequestContext;
    AFD_POINTER_32      SocketCtxBuf;
    ULONG               SocketCtxBufSize;
    AFD_POINTER_32      RcvBufferArray;
    ULONG               RcvBufferCount;
    NTSTATUS            Status;
} AFD_SWITCH_TRANSFER_CTX_INFO32, *PAFD_SWITCH_TRANSFER_CTX_INFO32;
AFD_CHECK32on64(AFD_SWITCH_TRANSFER_CTX_INFO,SocketHandle);
AFD_CHECK32on64(AFD_SWITCH_TRANSFER_CTX_INFO,SwitchContext);
AFD_CHECK32on64(AFD_SWITCH_TRANSFER_CTX_INFO,RequestContext);
AFD_CHECK32on64(AFD_SWITCH_TRANSFER_CTX_INFO,SocketCtxBuf);
AFD_CHECK32on64(AFD_SWITCH_TRANSFER_CTX_INFO,SocketCtxBufSize);
AFD_CHECK32on64(AFD_SWITCH_TRANSFER_CTX_INFO,RcvBufferArray);
AFD_CHECK32on64(AFD_SWITCH_TRANSFER_CTX_INFO,RcvBufferCount);
AFD_CHECK32on64(AFD_SWITCH_TRANSFER_CTX_INFO,Status);

typedef UNALIGNED struct _AFD_PARTIAL_DISCONNECT_INFO32 {
    ULONG DisconnectMode;
    LARGE_INTEGER Timeout;
} AFD_PARTIAL_DISCONNECT_INFO32, *PAFD_PARTIAL_DISCONNECT_INFO32;
AFD_CHECK32on64(AFD_PARTIAL_DISCONNECT_INFO,DisconnectMode);
AFD_CHECK32on64(AFD_PARTIAL_DISCONNECT_INFO,Timeout);

typedef UNALIGNED struct _AFD_SUPER_DISCONNECT_INFO32 {
    ULONG  Flags;
} AFD_SUPER_DISCONNECT_INFO32, *PAFD_SUPER_DISCONNECT_INFO32;
AFD_CHECK32on64(AFD_SUPER_DISCONNECT_INFO,Flags);

typedef UNALIGNED struct _AFD_INFORMATION32 {
    ULONG InformationType;
    union {
        BOOLEAN Boolean;
        ULONG Ulong;
        LARGE_INTEGER LargeInteger;
    } Information;
} AFD_INFORMATION32, *PAFD_INFORMATION32;
AFD_CHECK32on64(AFD_INFORMATION,InformationType);
AFD_CHECK32on64(AFD_INFORMATION,Information);
AFD_CHECK32on64(AFD_INFORMATION,Information.Boolean);
AFD_CHECK32on64(AFD_INFORMATION,Information.Ulong);
AFD_CHECK32on64(AFD_INFORMATION,Information.LargeInteger);


typedef UNALIGNED struct _TDI_CMSGHDR32 {
    ULONG       cmsg_len;
    LONG        cmsg_level;
    LONG        cmsg_type;
    /* followed by UCHAR cmsg_data[] */
} TDI_CMSGHDR32, *PTDI_CMSGHDR32;
AFD_CHECK32on64(TDI_CMSGHDR,cmsg_len);
AFD_CHECK32on64(TDI_CMSGHDR,cmsg_level);
AFD_CHECK32on64(TDI_CMSGHDR,cmsg_type);

#ifdef _WIN64
#define TDI_CMSGHDR_ALIGN32(length)                         \
            ( ((length) + TYPE_ALIGNMENT(TDI_CMSGHDR32)-1) &\
                (~(TYPE_ALIGNMENT(TDI_CMSGHDR32)-1)) )      \

#define TDI_CMSGDATA_ALIGN32(length)                        \
            ( ((length) + AFD_MAX_NATURAL_ALIGNMENT32-1) &  \
                (~(AFD_MAX_NATURAL_ALIGNMENT32-1)) )
#endif //_WIN64

#endif // ndef _AFDSTR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\blkendp.c ===
/*++

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    blkendp.c

Abstract:

    This module contains allocate, free, close, reference, and dereference
    routines for AFD endpoints.

Author:

    David Treadwell (davidtr)    10-Mar-1992

Revision History:
    Vadim Eydelman (vadime)     1999 - Don't attach to system proces, use system handles instead
                                        Delayed acceptance endpoints.

--*/

#include "afdp.h"

VOID
AfdFreeEndpointResources (
    PAFD_ENDPOINT   endpoint
    );

VOID
AfdFreeEndpoint (
    IN PVOID Context
    );

PAFD_ENDPOINT
AfdReuseEndpoint (
    VOID
    );

VOID
AfdFreeTransportInfo (
    PAFD_TRANSPORT_INFO TransportInfo
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfdAllocateEndpoint )
#pragma alloc_text( PAGE, AfdFreeEndpointResources )
#pragma alloc_text( PAGE, AfdFreeEndpoint )
#pragma alloc_text( PAGE, AfdReuseEndpoint )
#pragma alloc_text( PAGE, AfdGetTransportInfo )
#pragma alloc_text( PAGE, AfdFreeTransportInfo )
#pragma alloc_text( PAGEAFD, AfdRefreshEndpoint )
#pragma alloc_text( PAGEAFD, AfdDereferenceEndpoint )
#if REFERENCE_DEBUG
#pragma alloc_text( PAGEAFD, AfdReferenceEndpoint )
#endif
#pragma alloc_text( PAGEAFD, AfdFreeQueuedConnections )
#endif


NTSTATUS
AfdAllocateEndpoint (
    OUT PAFD_ENDPOINT * NewEndpoint,
    IN PUNICODE_STRING TransportDeviceName,
    IN LONG GroupID
    )

/*++

Routine Description:

    Allocates and initializes a new AFD endpoint structure.

Arguments:

    NewEndpoint - Receives a pointer to the new endpoint structure if
        successful.

    TransportDeviceName - the name of the TDI transport provider
        corresponding to the endpoint structure.

    GroupID - Identifies the group ID for the new endpoint.

Return Value:

    NTSTATUS - The completion status.

--*/

{
    PAFD_ENDPOINT endpoint;
    PAFD_TRANSPORT_INFO transportInfo = NULL;
    NTSTATUS status;
    AFD_GROUP_TYPE groupType;

    PAGED_CODE( );

    DEBUG *NewEndpoint = NULL;

    if ( TransportDeviceName != NULL ) {
        //
        // First, make sure that the transport device name is stored globally
        // for AFD.  Since there will typically only be a small number of
        // transport device names, we store the name strings once globally
        // for access by all endpoints.
        //

        status = AfdGetTransportInfo( TransportDeviceName, &transportInfo );

        //
        // If transport device is not activated, we'll try again during bind
        //
        if ( !NT_SUCCESS (status) && 
                (status!=STATUS_OBJECT_NAME_NOT_FOUND) &&
                (status!=STATUS_OBJECT_PATH_NOT_FOUND) &&
                (status!=STATUS_NO_SUCH_DEVICE) ) {
            //
            // Dereference transport info structure if one was created for us.
            // (Should not happen in current implementation).
            //
            ASSERT (transportInfo==NULL);
            return status;
        }

        ASSERT (transportInfo!=NULL);
    }


    //
    // Validate the incoming group ID, allocate a new one if necessary.
    //

    if( AfdGetGroup( &GroupID, &groupType ) ) {
        PEPROCESS process = IoGetCurrentProcess ();


        status = PsChargeProcessPoolQuota(
                process,
                NonPagedPool,
                sizeof (AFD_ENDPOINT)
                );

        if (!NT_SUCCESS (status)) {

           KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                        "AfdAllocateEndpoint: PsChargeProcessPoolQuota failed.\n" ));

           goto Cleanup;
        }

        // See if we have too many endpoins waiting to be freed and reuse one of them
        if ((AfdEndpointsFreeing<AFD_ENDPOINTS_FREEING_MAX)
                || ((endpoint = AfdReuseEndpoint ())==NULL)) {
            //
            // Allocate a buffer to hold the endpoint structure.
            // We use the priority version of this routine because
            // we are going to charge the process for this allocation
            // before it can make any use of it.
            //

            endpoint = AFD_ALLOCATE_POOL_PRIORITY(
                           NonPagedPool,
                           sizeof(AFD_ENDPOINT),
                           AFD_ENDPOINT_POOL_TAG,
                           NormalPoolPriority
                           );
        }

        if ( endpoint != NULL ) {

            AfdRecordQuotaHistory(
                process,
                (LONG)sizeof (AFD_ENDPOINT),
                "CreateEndp  ",
                endpoint
                );

            AfdRecordPoolQuotaCharged(sizeof (AFD_ENDPOINT));

            RtlZeroMemory( endpoint, sizeof(AFD_ENDPOINT) );

            //
            // Initialize the reference count to 2--one for the caller's
            // reference, one for the active reference.
            //

            endpoint->ReferenceCount = 2;

            //
            // Initialize the endpoint structure.
            //

            if ( TransportDeviceName == NULL ) {
                endpoint->Type = AfdBlockTypeHelper;
                endpoint->State = AfdEndpointStateInvalid;
            } else {
                endpoint->Type = AfdBlockTypeEndpoint;
                endpoint->State = AfdEndpointStateOpen;
                endpoint->TransportInfo = transportInfo;
                //
                // Cache service flags for quick determination of provider characteristics
                // such as bufferring and messaging
                //
                if (transportInfo->InfoValid) {
                    endpoint->TdiServiceFlags = endpoint->TransportInfo->ProviderInfo.ServiceFlags;
                }
            }

            endpoint->GroupID = GroupID;
            endpoint->GroupType = groupType;


            AfdInitializeSpinLock( &endpoint->SpinLock );
            InitializeListHead (&endpoint->RoutingNotifications);
            InitializeListHead (&endpoint->RequestList);

#if DBG
            InitializeListHead( &endpoint->OutstandingIrpListHead );
#endif

            //
            // Remember the process which opened the endpoint.  We'll use this to
            // charge quota to the process as necessary.  Reference the process
            // so that it does not go away until we have returned all charged
            // quota to the process.
            //

            endpoint->OwningProcess = process;

            ObReferenceObject(endpoint->OwningProcess);

            //
            // Insert the endpoint on the global list.
            //

            AfdInsertNewEndpointInList( endpoint );

            //
            // Return a pointer to the new endpoint to the caller.
            //

            IF_DEBUG(ENDPOINT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdAllocateEndpoint: new endpoint at %p\n",
                            endpoint ));
            }

            *NewEndpoint = endpoint;
            return STATUS_SUCCESS;
        }
        else {
            PsReturnPoolQuota(
                process,
                NonPagedPool,
                sizeof (AFD_ENDPOINT)
                );
            status= STATUS_INSUFFICIENT_RESOURCES;
        }

Cleanup:
        if( GroupID != 0 ) {
            AfdDereferenceGroup( GroupID );
        }

    }
    else {
        status = STATUS_INVALID_PARAMETER;
    }


    if (transportInfo!=NULL) {
        if (InterlockedDecrement (&transportInfo->ReferenceCount)==0) {
            AfdFreeTransportInfo (transportInfo);
        }
    }

    return status;
} // AfdAllocateEndpoint


VOID
AfdFreeQueuedConnections (
    IN PAFD_ENDPOINT Endpoint
    )

/*++

Routine Description:

    Frees queued connection objects on a listening AFD endpoint.

Arguments:

    Endpoint - a pointer to the AFD endpoint structure.

Return Value:

    None.

--*/

{
    AFD_LOCK_QUEUE_HANDLE  lockHandle;
    KIRQL               oldIrql;
    PAFD_CONNECTION connection;
    PIRP    irp;

    ASSERT( Endpoint->Type == AfdBlockTypeVcListening ||
            Endpoint->Type == AfdBlockTypeVcBoth );

    //
    // Free the unaccepted connections.
    //
    // We must hold endpoint spinLock to call AfdGetUnacceptedConnection,
    // but we may not hold it when calling AfdDereferenceConnection.
    //

    KeRaiseIrql (DISPATCH_LEVEL, &oldIrql);

    AfdAcquireSpinLockAtDpcLevel( &Endpoint->SpinLock, &lockHandle );

    while ( (connection = AfdGetUnacceptedConnection( Endpoint )) != NULL ) {
        ASSERT( connection->Endpoint == Endpoint );

        AfdReleaseSpinLockFromDpcLevel( &Endpoint->SpinLock, &lockHandle );
        if (connection->SanConnection) {
            AfdSanAbortConnection ( connection );
        }
        else {
            AfdAbortConnection( connection );
        }
        AfdAcquireSpinLockAtDpcLevel( &Endpoint->SpinLock, &lockHandle );

    }


    //
    // Free the returned connections.
    //

    while ( (connection = AfdGetReturnedConnection( Endpoint, 0 )) != NULL ) {

        ASSERT( connection->Endpoint == Endpoint );

        AfdReleaseSpinLockFromDpcLevel( &Endpoint->SpinLock, &lockHandle );
        if (connection->SanConnection) {
            AfdSanAbortConnection ( connection );
        }
        else {
            AfdAbortConnection( connection );
        }
        
        AfdAcquireSpinLockAtDpcLevel( &Endpoint->SpinLock, &lockHandle );

    }



    if (IS_DELAYED_ACCEPTANCE_ENDPOINT (Endpoint)) {
        while (!IsListEmpty (&Endpoint->Common.VcListening.ListenConnectionListHead)) {
            PIRP    listenIrp;
            connection = CONTAINING_RECORD (
                            Endpoint->Common.VcListening.ListenConnectionListHead.Flink,
                            AFD_CONNECTION,
                            ListEntry
                            );
            RemoveEntryList (&connection->ListEntry);
            listenIrp = InterlockedExchangePointer ((PVOID *)&connection->ListenIrp, NULL);
            if (listenIrp!=NULL) {
                IoAcquireCancelSpinLock (&listenIrp->CancelIrql);
                ASSERT (listenIrp->CancelIrql==DISPATCH_LEVEL);
                AfdReleaseSpinLockFromDpcLevel (&Endpoint->SpinLock, &lockHandle);

                AfdCancelIrp (listenIrp);

                AfdAcquireSpinLockAtDpcLevel( &Endpoint->SpinLock, &lockHandle );
            }
        }
        AfdReleaseSpinLockFromDpcLevel( &Endpoint->SpinLock, &lockHandle );
    }
    else {
        AfdReleaseSpinLockFromDpcLevel( &Endpoint->SpinLock, &lockHandle );
        //
        // And finally, purge the free connection queue.
        //

        while ( (connection = AfdGetFreeConnection( Endpoint, &irp )) != NULL ) {
            ASSERT( connection->Type == AfdBlockTypeConnection );
            if (irp!=NULL) {
                AfdCleanupSuperAccept (irp, STATUS_CANCELLED);
                if (irp->Cancel) {
                    KIRQL cancelIrql;
                    //
                    // Need to sycn with cancel routine which may
                    // have been called from AfdCleanup for accepting
                    // endpoint
                    //
                    IoAcquireCancelSpinLock (&cancelIrql);
                    IoReleaseCancelSpinLock (cancelIrql);
                }
                IoCompleteRequest (irp, AfdPriorityBoost);
            }
            DEREFERENCE_CONNECTION( connection );
        }
    }
    KeLowerIrql (oldIrql);

    return;

} // AfdFreeQueuedConnections



VOID
AfdFreeEndpointResources (
    PAFD_ENDPOINT   endpoint
    )
/*++

Routine Description:
    Does the actual work to deallocate an AFD endpoint structure and
    associated structures.  Note that all other references to the
    endpoint structure must be gone before this routine is called, since
    it frees the endpoint and assumes that nobody else will be looking
    at the endpoint.

Arguments:
    Endpoint to be cleaned up

Return Value:

    None
--*/
{
    NTSTATUS status;
    PLIST_ENTRY listEntry;

    PAGED_CODE ();

    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    ASSERT( endpoint->ReferenceCount == 0 );
    ASSERT( endpoint->State == AfdEndpointStateClosing );
    ASSERT( endpoint->ObReferenceBias == 0 );
    ASSERT( KeGetCurrentIrql( ) == 0 );

    //
    // If this is a listening endpoint, then purge the endpoint of all
    // queued connections.
    //

    if ( (endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening ) {

        AfdFreeQueuedConnections( endpoint );

    }

    //
    // Dereference any group ID associated with this endpoint.
    //

    if( endpoint->GroupID != 0 ) {

        AfdDereferenceGroup( endpoint->GroupID );

    }

    //
    // If this is a bufferring datagram endpoint, remove all the
    // bufferred datagrams from the endpoint's list and free them.
    //

    if ( IS_DGRAM_ENDPOINT(endpoint) &&
             endpoint->ReceiveDatagramBufferListHead.Flink != NULL ) {

        while ( !IsListEmpty( &endpoint->ReceiveDatagramBufferListHead ) ) {

            PAFD_BUFFER_HEADER afdBuffer;

            listEntry = RemoveHeadList( &endpoint->ReceiveDatagramBufferListHead );
            afdBuffer = CONTAINING_RECORD( listEntry, AFD_BUFFER_HEADER, BufferListEntry );
            AfdReturnBuffer( afdBuffer, endpoint->OwningProcess );
        }
    }

    //
    // Close and dereference the TDI address object on the endpoint, if
    // any.
    //

    if ( endpoint->AddressFileObject != NULL ) {
        //
        // Little extra precaution.  It is possible that there exists
        // a duplicated handle in user process, so transport can in
        // theory call event handler with bogus endpoint pointer that
        // we are about to free.  The event handlers for datagram
        // endpoints are reset in AfdCleanup.
        // Connection-oriented accepted endpoints cannot have address handles
        // in their structures because they share them with listening
        // endpoint (it would be a grave mistake if we tried to close
        // address handle owned by listening endpoint while closing connection
        // accepted on it).
        //
        if ( endpoint->AddressHandle != NULL &&
                IS_VC_ENDPOINT (endpoint)) {

            ASSERT (((endpoint->Type&AfdBlockTypeVcConnecting)!=AfdBlockTypeVcConnecting) 
                        || (endpoint->Common.VcConnecting.ListenEndpoint==NULL));


            status = AfdSetEventHandler(
                         endpoint->AddressFileObject,
                         TDI_EVENT_ERROR,
                         NULL,
                         NULL
                         );
            //ASSERT( NT_SUCCESS(status) );

            status = AfdSetEventHandler(
                         endpoint->AddressFileObject,
                         TDI_EVENT_DISCONNECT,
                         NULL,
                         NULL
                         );
            //ASSERT( NT_SUCCESS(status) );

            status = AfdSetEventHandler(
                         endpoint->AddressFileObject,
                         TDI_EVENT_RECEIVE,
                         NULL,
                         NULL
                         );

            //ASSERT( NT_SUCCESS(status) );

            if (IS_TDI_EXPEDITED (endpoint)) {
                status = AfdSetEventHandler(
                         endpoint->AddressFileObject,
                         TDI_EVENT_RECEIVE_EXPEDITED,
                         NULL,
                         NULL
                         );
                //ASSERT( NT_SUCCESS(status) );
            }

            if ( IS_TDI_BUFFERRING(endpoint) ) {
                status = AfdSetEventHandler(
                             endpoint->AddressFileObject,
                             TDI_EVENT_SEND_POSSIBLE,
                             NULL,
                             NULL
                             );
                //ASSERT( NT_SUCCESS(status) );
            }
            else {
                status = AfdSetEventHandler(
                             endpoint->AddressFileObject,
                             TDI_EVENT_CHAINED_RECEIVE,
                             NULL,
                             NULL
                             );
                //ASSERT( NT_SUCCESS(status) );
            }
        }
        ObDereferenceObject( endpoint->AddressFileObject );
        endpoint->AddressFileObject = NULL;
        endpoint->AddressDeviceObject = NULL;
        AfdRecordAddrDeref();
    }
    else {
        if (endpoint->SecurityDescriptor!=NULL) {
            ObDereferenceSecurityDescriptor( endpoint->SecurityDescriptor, 1 );
        }
        endpoint->SecurityDescriptor = NULL;
    }

    if ( endpoint->AddressHandle != NULL ) {
#if DBG
        {
            NTSTATUS    status1;
            OBJECT_HANDLE_FLAG_INFORMATION  handleInfo;
            handleInfo.Inherit = FALSE;
            handleInfo.ProtectFromClose = FALSE;
            status1 = ZwSetInformationObject (
                            endpoint->AddressHandle,
                            ObjectHandleFlagInformation,
                            &handleInfo,
                            sizeof (handleInfo)
                            );
            ASSERT (NT_SUCCESS (status1));
        }
#endif
        status = ZwClose( endpoint->AddressHandle );
        ASSERT( NT_SUCCESS(status) );
        endpoint->AddressHandle = NULL;
        AfdRecordAddrClosed();
    }

    //
    // Remove the endpoint from the global list.  Do this before any
    // deallocations to prevent someone else from seeing an endpoint in
    // an invalid state.
    //

    AfdRemoveEndpointFromList( endpoint );

    //
    // Return the quota we charged to this process when we allocated
    // the endpoint object.
    //

    PsReturnPoolQuota(
        endpoint->OwningProcess,
        NonPagedPool,
        sizeof (AFD_ENDPOINT)
        );
    AfdRecordQuotaHistory(
        endpoint->OwningProcess,
        -(LONG)sizeof (AFD_ENDPOINT),
        "EndpDealloc ",
        endpoint
        );
    AfdRecordPoolQuotaReturned(
        sizeof (AFD_ENDPOINT)
        );

    //
    // Dereference the owning process.
    //

    ObDereferenceObject( endpoint->OwningProcess );
    endpoint->OwningProcess = NULL;


    //
    // Dereference the listening or c-root endpoint on the endpoint, if
    // any.
    //

    if ( endpoint->Type == AfdBlockTypeVcConnecting &&
             endpoint->Common.VcConnecting.ListenEndpoint != NULL ) {
        PAFD_ENDPOINT   listenEndpoint = endpoint->Common.VcConnecting.ListenEndpoint;
        ASSERT (((listenEndpoint->Type&AfdBlockTypeVcListening)==AfdBlockTypeVcListening) ||
                 IS_CROOT_ENDPOINT (listenEndpoint));
        ASSERT (endpoint->LocalAddress==listenEndpoint->LocalAddress);
        DEREFERENCE_ENDPOINT( listenEndpoint );

        endpoint->Common.VcConnecting.ListenEndpoint = NULL;
        //
        // We used the local address from the listening endpoint,
        // simply reset it, it will be freed when listening endpoint
        // is freed.
        //
        endpoint->LocalAddress = NULL;
        endpoint->LocalAddressLength = 0;
    }

    if (IS_SAN_ENDPOINT (endpoint)) {
        AfdSanCleanupEndpoint (endpoint);

    }
    else if (IS_SAN_HELPER (endpoint)) {
        AfdSanCleanupHelper (endpoint);
    }
    //
    // Free local and remote address buffers.
    //

    if ( endpoint->LocalAddress != NULL ) {
        AFD_FREE_POOL(
            endpoint->LocalAddress,
            AFD_LOCAL_ADDRESS_POOL_TAG
            );
        endpoint->LocalAddress = NULL;
    }

    if ( IS_DGRAM_ENDPOINT(endpoint) &&
             endpoint->Common.Datagram.RemoteAddress != NULL ) {
        AFD_RETURN_REMOTE_ADDRESS(
            endpoint->Common.Datagram.RemoteAddress,
            endpoint->Common.Datagram.RemoteAddressLength
            );
        endpoint->Common.Datagram.RemoteAddress = NULL;
    }

    //
    // Free context and connect data buffers.
    //

    if ( endpoint->Context != NULL ) {

        AFD_FREE_POOL(
            endpoint->Context,
            AFD_CONTEXT_POOL_TAG
            );
        endpoint->Context = NULL;

    }

    if ( IS_VC_ENDPOINT (endpoint) &&
              endpoint->Common.VirtualCircuit.ConnectDataBuffers != NULL ) {
        AfdFreeConnectDataBuffers( endpoint->Common.VirtualCircuit.ConnectDataBuffers );
    }

    //
    // If there's an active EventSelect() on this endpoint, dereference
    // the associated event object.
    //

    if( endpoint->EventObject != NULL ) {
        ObDereferenceObject( endpoint->EventObject );
        endpoint->EventObject = NULL;
    }

    // ASSERT ( endpoint->Irp == NULL );


    if (endpoint->TransportInfo!=NULL) {
        if  (InterlockedDecrement (&endpoint->TransportInfo->ReferenceCount)==0) {
            AfdFreeTransportInfo (endpoint->TransportInfo);
        }
        endpoint->TransportInfo = NULL;
    }

    ASSERT (endpoint->OutstandingIrpCount==0);

    IF_DEBUG(ENDPOINT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdFreeEndpoint: freeing endpoint at %p\n",
                    endpoint ));
    }

    endpoint->Type = AfdBlockTypeInvalidEndpoint;

}


VOID
AfdFreeEndpoint (
    IN PVOID Context
    )

/*++

Routine Description:
    Calls AfdFreeEndpointResources to cleanup endpoint and frees the
    endpoint structure itself

Arguments:

    Context - Actually points to the endpoint's embedded AFD_WORK_ITEM
        structure. From this we can determine the endpoint to free.

Return Value:

    None.

--*/

{
    PAFD_ENDPOINT endpoint;
    PAGED_CODE( );


    ASSERT( Context != NULL );

    InterlockedDecrement(&AfdEndpointsFreeing);

    endpoint = CONTAINING_RECORD(
                   Context,
                   AFD_ENDPOINT,
                   WorkItem
                   );


    AfdFreeEndpointResources (endpoint);
    //
    // Free the pool used for the endpoint itself.
    //

    AFD_FREE_POOL(
        endpoint,
        AFD_ENDPOINT_POOL_TAG
        );

} // AfdFreeEndpoint


PAFD_ENDPOINT
AfdReuseEndpoint (
    VOID
    )

/*++

Routine Description:
    Finds a AfdFreeEndpoint work item in the list and calls
     AfdFreeEndpointResources to cleanup endpoint

Arguments:
    None

Return Value:

    Reinitialized endpoint.

--*/

{
    PAFD_ENDPOINT endpoint;
    PVOID       Context;

    PAGED_CODE( );

    Context = AfdGetWorkerByRoutine (AfdFreeEndpoint);
    if (Context==NULL)
        return NULL;

    endpoint = CONTAINING_RECORD(
                   Context,
                   AFD_ENDPOINT,
                   WorkItem
                   );


    AfdFreeEndpointResources (endpoint);
    return endpoint;
} // AfdReuseEndpoint


#if REFERENCE_DEBUG
VOID
AfdDereferenceEndpoint (
    IN PAFD_ENDPOINT Endpoint,
    IN LONG  LocationId,
    IN ULONG Param
    )
#else
VOID
AfdDereferenceEndpoint (
    IN PAFD_ENDPOINT Endpoint
    )
#endif

/*++

Routine Description:

    Dereferences an AFD endpoint and calls the routine to free it if
    appropriate.

Arguments:

    Endpoint - a pointer to the AFD endpoint structure.

Return Value:

    None.

--*/

{
    LONG result;

#if REFERENCE_DEBUG
    IF_DEBUG(ENDPOINT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdDereferenceEndpoint: endpoint at %p, new refcnt %ld\n",
                    Endpoint, Endpoint->ReferenceCount-1 ));
    }

    ASSERT( IS_AFD_ENDPOINT_TYPE( Endpoint ) );
    ASSERT( Endpoint->ReferenceCount > 0 );
    ASSERT( Endpoint->ReferenceCount != 0xDAADF00D );

    AFD_UPDATE_REFERENCE_DEBUG(Endpoint, Endpoint->ReferenceCount-1, LocationId, Param);



    //
    // We must hold AfdSpinLock while doing the dereference and check
    // for free.  This is because some code makes the assumption that
    // the connection structure will not go away while AfdSpinLock is
    // held, and that code references the endpoint before releasing
    // AfdSpinLock.  If we did the InterlockedDecrement() without the
    // lock held, our count may go to zero, that code may reference the
    // connection, and then a double free might occur.
    //
    // It is still valuable to use the interlocked routines for
    // increment and decrement of structures because it allows us to
    // avoid having to hold the spin lock for a reference.
    //
    // In NT40+ we use InterlockedCompareExchange and make sure that
    // we do not increment reference count if it is 0, so holding
    // a spinlock is no longer necessary

    //
    // Decrement the reference count; if it is 0, we may need to
    // free the endpoint.
    //

#endif
    result = InterlockedDecrement( (PLONG)&Endpoint->ReferenceCount );

    if ( result == 0 ) {

        ASSERT( Endpoint->State == AfdEndpointStateClosing );

        if ((Endpoint->Type==AfdBlockTypeVcConnecting) &&
                (Endpoint->Common.VcConnecting.ListenEndpoint != NULL) &&
                (KeGetCurrentIrql()==PASSIVE_LEVEL)) {

            ASSERT (Endpoint->AddressHandle==NULL);
            //
            // If this is a connecting endpoint assoicated with the
            // listening endpoint and we already at passive level,
            // free the endpoint here.  We can do this because in such
            // a case we know that reference to the transport object
            // is not the last one - at least one more is still in the
            // listening endpoint and we remove transport object reference 
            // before dereferencing listening endpoint.
            // 
            //

            AfdFreeEndpointResources (Endpoint);

            //
            // Free the pool used for the endpoint itself.
            //

            AFD_FREE_POOL(
                Endpoint,
                AFD_ENDPOINT_POOL_TAG
                );
        }
        else
        {
            //
            // We're going to do this by queueing a request to an executive
            // worker thread.  We do this for several reasons: to ensure
            // that we're at IRQL 0 so we can free pageable memory, and to
            // ensure that we're in a legitimate context for a close
            // operation and not in conntext of event indication from
            // the transport driver
            //

            InterlockedIncrement(&AfdEndpointsFreeing);

            AfdQueueWorkItem(
                AfdFreeEndpoint,
                &Endpoint->WorkItem
                );
        }
    }

} // AfdDereferenceEndpoint

#if REFERENCE_DEBUG

VOID
AfdReferenceEndpoint (
    IN PAFD_ENDPOINT Endpoint,
    IN LONG  LocationId,
    IN ULONG Param
    )

/*++

Routine Description:

    References an AFD endpoint.

Arguments:

    Endpoint - a pointer to the AFD endpoint structure.

Return Value:

    None.

--*/

{

    LONG result;

    ASSERT( Endpoint->ReferenceCount > 0 );

    ASSERT( Endpoint->ReferenceCount < 0xFFFF || 
        ((Endpoint->Listening ||
        Endpoint->afdC_Root) && Endpoint->ReferenceCount<0xFFFFFFF));

    result = InterlockedIncrement( (PLONG)&Endpoint->ReferenceCount );
    AFD_UPDATE_REFERENCE_DEBUG(Endpoint, result, LocationId, Param);

    IF_DEBUG(ENDPOINT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdReferenceEndpoint: endpoint at %p, new refcnt %ld\n",
                    Endpoint, result ));
    }

} // AfdReferenceEndpoint

VOID
AfdUpdateEndpoint (
    IN PAFD_ENDPOINT Endpoint,
    IN LONG  LocationId,
    IN ULONG Param
    )

/*++

Routine Description:

    Update an AFD endpoint reference debug information.

Arguments:

    Endpoint - a pointer to the AFD endpoint structure.

Return Value:

    None.

--*/

{
    ASSERT( Endpoint->ReferenceCount > 0 );

    ASSERT( Endpoint->ReferenceCount < 0xFFFF || 
        ((Endpoint->Listening ||
        Endpoint->afdC_Root) && Endpoint->ReferenceCount<0xFFFFFFF));

    AFD_UPDATE_REFERENCE_DEBUG(Endpoint, Endpoint->ReferenceCount, LocationId, Param);


} // AfdUpdateEndpoint
#endif


#if REFERENCE_DEBUG
BOOLEAN
AfdCheckAndReferenceEndpoint (
    IN PAFD_ENDPOINT Endpoint,
    IN LONG  LocationId,
    IN ULONG Param
    )
#else
BOOLEAN
AfdCheckAndReferenceEndpoint (
    IN PAFD_ENDPOINT Endpoint
    )
#endif
{
    LONG            result;

    do {
        result = Endpoint->ReferenceCount;
        if (result<=0)
            break;
    }
    while (InterlockedCompareExchange ((PLONG)&Endpoint->ReferenceCount,
                                                (result+1),
                                                result)!=result);



    if (result>0) {

#if REFERENCE_DEBUG
        AFD_UPDATE_REFERENCE_DEBUG(Endpoint, result+1, LocationId, Param);

        IF_DEBUG(ENDPOINT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdReferenceEndpoint: endpoint at %p, new refcnt %ld\n",
                Endpoint, result+1 ));
        }

        ASSERT( Endpoint->ReferenceCount < 0xFFFF || 
            ((Endpoint->Listening ||
            Endpoint->afdC_Root) && Endpoint->ReferenceCount<0xFFFFFFF));
#endif
        return TRUE;
    }
    else {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_ERROR_LEVEL,
                    "AfdCheckAndReferenceEndpoint: Endpoint %p is gone (refcount: %ld)!\n",
                    Endpoint, result));
        return FALSE;
    }
}


VOID
AfdRefreshEndpoint (
    IN PAFD_ENDPOINT Endpoint
    )

/*++

Routine Description:

    Prepares an AFD endpoint structure to be reused.  All other
    references to the endpoint must be freed before this routine is
    called, since this routine assumes that nobody will access the old
    information in the endpoint structure.
    This fact is ensured by the state change primitive.

Arguments:

    Endpoint - a pointer to the AFD endpoint structure.

Return Value:

    None.

--*/

{
    AFD_ENDPOINT_STATE_FLAGS flags;

    ASSERT( Endpoint->Type == AfdBlockTypeVcConnecting );
    ASSERT( Endpoint->Common.VcConnecting.Connection == NULL );
    ASSERT( Endpoint->StateChangeInProgress!=0);
    ASSERT( Endpoint->State == AfdEndpointStateTransmitClosing );

    if ( Endpoint->Common.VcConnecting.ListenEndpoint != NULL ) {
        //
        // TransmitFile after SuperAccept, cleanup back to open state.
        //

        //
        // Dereference the listening endpoint and its address object.
        //

        PAFD_ENDPOINT   listenEndpoint = Endpoint->Common.VcConnecting.ListenEndpoint;
        ASSERT (((listenEndpoint->Type&AfdBlockTypeVcListening)==AfdBlockTypeVcListening) ||
                 IS_CROOT_ENDPOINT (listenEndpoint));
        ASSERT (Endpoint->LocalAddress==listenEndpoint->LocalAddress);
        ASSERT (Endpoint->AddressFileObject==listenEndpoint->AddressFileObject);

        DEREFERENCE_ENDPOINT( listenEndpoint );
        Endpoint->Common.VcConnecting.ListenEndpoint = NULL;

        //
        // Close and dereference the TDI address object on the endpoint, if
        // any.
        //


        ObDereferenceObject( Endpoint->AddressFileObject );
        Endpoint->AddressFileObject = NULL;
        Endpoint->AddressDeviceObject = NULL;
        AfdRecordAddrDeref();

        //
        // We used the local address from the listening endpoint,
        // simply reset it, it will be freed when listening endpoint
        // is freed.
        //
        Endpoint->LocalAddress = NULL;
        Endpoint->LocalAddressLength = 0;
        ASSERT (Endpoint->AddressHandle == NULL);

        //
        // Reinitialize the endpoint structure.
        //

        Endpoint->Type = AfdBlockTypeEndpoint;
        Endpoint->State = AfdEndpointStateOpen;
    }
    else {
        //
        // TransmitFile after SuperConnect, cleanup back to bound state.
        //
        Endpoint->Type = AfdBlockTypeEndpoint;
        ASSERT (Endpoint->AddressHandle!=NULL);
        ASSERT (Endpoint->AddressFileObject!=NULL);
        ASSERT (Endpoint->AddressDeviceObject!=NULL);
        Endpoint->State = AfdEndpointStateBound;
    }

    //
    // Remember if poll is pending on this endpoint, to enable cleanup
    // is socket gets closed
    //
    flags.EndpointStateFlags = 0; // reset
    flags.PollCalled = Endpoint->PollCalled;

    Endpoint->EndpointStateFlags = flags.EndpointStateFlags;
    Endpoint->DisconnectMode = 0;
    Endpoint->EventsActive = 0;
    AfdRecordEndpointsReused ();
    return;

} // AfdRefreshEndpoint


NTSTATUS
AfdGetTransportInfo (
    IN  PUNICODE_STRING TransportDeviceName,
    IN OUT PAFD_TRANSPORT_INFO *TransportInfo
    )

/*++

Routine Description:

    Returns a transport information structure corresponding to the
    specified TDI transport provider.  Each unique transport string gets
    a single provider structure, so that multiple endpoints for the same
    transport share the same transport information structure.

Arguments:

    TransportDeviceName - the name of the TDI transport provider.
    TransportInfo    - place to return referenced pointer to transport info

Return Value:

    STATUS_SUCCESS  - returned transport info is valid.
    STATUS_INSUFFICIENT_RESOURCES - not enough memory to allocate
                                    transport info structure
    STATUS_OBJECT_NAME_NOT_FOUND - transport's device is not available yet

--*/

{
    PLIST_ENTRY listEntry;
    PAFD_TRANSPORT_INFO transportInfo;
    ULONG structureLength;
    NTSTATUS status;
    TDI_PROVIDER_INFO   localProviderInfo;
    BOOLEAN resourceShared = TRUE;
#ifdef _AFD_VARIABLE_STACK_
    CCHAR stackSize;
#endif // _AFD_VARIABLE_STACK_


    PAGED_CODE( );

    //
    // Make sure the thread in which we execute cannot get
    // suspeneded in APC while we own the global resource.
    //
    KeEnterCriticalRegion ();
    ExAcquireResourceSharedLite( AfdResource, TRUE );

    //
    // If this is the first endpoint, we may be paged out 
    // entirely.
    //
    if (!AfdLoaded) {
        //
        // Take the exclusive lock and page the locked sections in
        // if necessary
        //

        //
        // There should be no endpoints in the list.
        //
        ASSERT (IsListEmpty (&AfdEndpointListHead));

        ExReleaseResourceLite ( AfdResource);

        ExAcquireResourceExclusiveLite( AfdResource, TRUE );
        resourceShared = FALSE;
        if (!AfdLoaded) {
            //
            // There should be no endpoints in the list.
            //
            ASSERT (IsListEmpty (&AfdEndpointListHead));
            MmResetDriverPaging ((PVOID)DriverEntry);
            AfdLoaded = (PKEVENT)1;
        }
    }
    ASSERT (AfdLoaded==(PKEVENT)1);

    if (*TransportInfo==NULL) {

    ScanTransportList:
        //
        // If caller did not have transport info allocated, walk the list 
        // of transport device names looking for an identical name.
        //


        for ( listEntry = AfdTransportInfoListHead.Flink;
              listEntry != &AfdTransportInfoListHead;
              listEntry = listEntry->Flink ) 
        {

            transportInfo = CONTAINING_RECORD(
                                listEntry,
                                AFD_TRANSPORT_INFO,
                                TransportInfoListEntry
                                );

            if ( RtlCompareUnicodeString(
                     &transportInfo->TransportDeviceName,
                     TransportDeviceName,
                     TRUE ) == 0 ) {

                //
                // We found an exact match. Reference the structure
                // to return it to the caller
                //

                do {
                    LONG localCount;
                    localCount = transportInfo->ReferenceCount;
                    if (localCount==0) {
                        //
                        // We hit a small window when the structure is
                        // about to be freed.  We can't stop this from
                        // happenning, so we'll go on to allocate and
                        // requery.  After all info is not valid anyway,
                        // thus we are just loosing on the allocation/dealocation
                        // code.
                        //
                        ASSERT (transportInfo->InfoValid==FALSE);
                        goto AllocateInfo;
                    }

                    if (InterlockedCompareExchange (
                                (PLONG)&transportInfo->ReferenceCount,
                                (localCount+1),
                                localCount)==localCount) {
                        if (transportInfo->InfoValid) {
                            //
                            // Info is valid return referenced pointer to
                            // the caller.
                            //
                            *TransportInfo = transportInfo;
                            ExReleaseResourceLite( AfdResource );
                            KeLeaveCriticalRegion ();
                            return STATUS_SUCCESS;
                        }
                        else {
                            //
                            // We found match, but info is not valid
                            //
                            goto QueryInfo;
                        }
                    }
                }
                while (1);
            }
        } // for

    AllocateInfo:
        if (resourceShared) {
            //
            // If we do not own resource exlusively, we will
            // have to release and reacquire it and then
            // rescan the list
            //
            ExReleaseResourceLite ( AfdResource);
            ExAcquireResourceExclusiveLite( AfdResource, TRUE );
            resourceShared = FALSE;
            goto ScanTransportList;
        }
        //
        // This is a brand new device name, allocate transport info
        // structure for it.
        //

        structureLength = sizeof(AFD_TRANSPORT_INFO) +
                              TransportDeviceName->Length + sizeof(UNICODE_NULL);

        transportInfo = AFD_ALLOCATE_POOL_PRIORITY(
                            NonPagedPool,
                            structureLength,
                            AFD_TRANSPORT_INFO_POOL_TAG,
                            NormalPoolPriority
                            );

        if ( transportInfo == NULL ) {
            ExReleaseResourceLite( AfdResource );
            KeLeaveCriticalRegion ();
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Initialize the structure
        //
        transportInfo->ReferenceCount = 1;
        transportInfo->InfoValid = FALSE;
#ifdef _AFD_VARIABLE_STACK_
        transportInfo->StackSize = 0;
        transportInfo->GetBuffer = AfdGetBufferFast;
        transportInfo->GetTpInfo = AfdGetTpInfoFast;
        transportInfo->CallDriver = IofCallDriver;
#endif // _AFD_VARIABLE_STACK_

        //
        // Fill in the transport device name.
        //

        transportInfo->TransportDeviceName.MaximumLength =
            TransportDeviceName->Length + sizeof(WCHAR);
        transportInfo->TransportDeviceName.Buffer =
            (PWSTR)(transportInfo + 1);

        RtlCopyUnicodeString(
            &transportInfo->TransportDeviceName,
            TransportDeviceName
            );
        //
        // Insert the structure into the list so that the successive callers
        // can reuse it.
        //
        InsertHeadList (&AfdTransportInfoListHead,
                                &transportInfo->TransportInfoListEntry);
    }
    else {
        transportInfo = *TransportInfo;
        //
        // Caller has already referenced info in the list
        // but transport device was not available at the
        // time of the call.  Recheck if it is valid under the lock
        //
        if (transportInfo->InfoValid) {
            //
            // Yes, it is, return success
            //
            ExReleaseResourceLite( AfdResource );
            KeLeaveCriticalRegion ();
            return STATUS_SUCCESS;
        }
    }


QueryInfo:
    //
    // Release the resource and leave critical region to let
    // the IRP's in AfdQueryProviderInfo complete
    //
    ExReleaseResourceLite (AfdResource);
    KeLeaveCriticalRegion ();

    status = AfdQueryProviderInfo (TransportDeviceName,
#ifdef _AFD_VARIABLE_STACK_
                                    &stackSize, 
#endif // _AFD_VARIABLE_STACK_
                                    &localProviderInfo);

    //
    // Make sure the thread in which we execute cannot get
    // suspeneded in APC while we own the global resource.
    //
    KeEnterCriticalRegion ();
    ExAcquireResourceExclusiveLite( AfdResource, TRUE );

    if (NT_SUCCESS (status)) {
        //
        // Check if someone did not get the info in parallel with us.
        //
        if (!transportInfo->InfoValid) {
            //
            // Copy local info structure to the one in the list.
            //
            transportInfo->ProviderInfo = localProviderInfo;

            //
            // Bump the reference count on this info structure
            // as we know that it is a valid TDI provider and we
            // want to cache, it so it stays even of all endpoints
            // that use it are gone.
            //
            InterlockedIncrement ((PLONG)&transportInfo->ReferenceCount);

            //
            // Set the flag so that everyone knows it is now valid.
            //
            transportInfo->InfoValid = TRUE;
#ifdef _AFD_VARIABLE_STACK_
            transportInfo->StackSize = stackSize;
#endif // _AFD_VARIABLE_STACK_
        }

        *TransportInfo = transportInfo;
    }
    else {
        if (status==STATUS_OBJECT_NAME_NOT_FOUND ||
                status==STATUS_OBJECT_PATH_NOT_FOUND ||
                status==STATUS_NO_SUCH_DEVICE) {
            //
            // Transport driver must not have been loaded yet
            // Return transport info structure anyway
            // Caller will know that info structure is not
            // valid because we did not set the flag
            //
            *TransportInfo = transportInfo;
        }
        else {
            //
            // Something else went wrong, free the strucuture
            // if it was allocated in this routine
            //

            if (*TransportInfo==NULL) {
                if (InterlockedDecrement ((PLONG)&transportInfo->ReferenceCount)==0) {
                    RemoveEntryList (&transportInfo->TransportInfoListEntry);
                    AFD_FREE_POOL(
                        transportInfo,
                        AFD_TRANSPORT_INFO_POOL_TAG
                        );
                }
            }
        }
    }

    ExReleaseResourceLite( AfdResource );
    KeLeaveCriticalRegion ();
    return status;

} // AfdGetTransportInfo


VOID
AfdFreeTransportInfo (
    PAFD_TRANSPORT_INFO TransportInfo
    )
{
    //
    // Reference count has gone to 0, we need to remove the structure
    // from the global list and free it.
    // Note that no code increments reference count if doesn't
    // know for fact that its current reference count is above 0).
    //
    //
    // Make sure the thread in which we execute cannot get
    // suspeneded in APC while we own the global resource.
    //
    KeEnterCriticalRegion ();
    ExAcquireResourceExclusiveLite( AfdResource, TRUE );
    
    ASSERT (TransportInfo->ReferenceCount==0);
    ASSERT (TransportInfo->InfoValid==FALSE);
    RemoveEntryList (&TransportInfo->TransportInfoListEntry);
    ExReleaseResourceLite( AfdResource );
    
    KeLeaveCriticalRegion ();
    AFD_FREE_POOL (TransportInfo, AFD_TRANSPORT_INFO_POOL_TAG);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\close.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    close.c

Abstract:

    This module contains code for cleanup and close IRPs.

Author:

    David Treadwell (davidtr)    18-Mar-1992

Revision History:

--*/

#include "afdp.h"




#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfdClose )
#pragma alloc_text( PAGEAFD, AfdCleanup )
#endif


NTSTATUS
FASTCALL
AfdCleanup (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the routine that handles Cleanup IRPs in AFD.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    NTSTATUS status;
    PAFD_ENDPOINT endpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PLIST_ENTRY listEntry;
    LARGE_INTEGER processExitTime;

    UNREFERENCED_PARAMETER (Irp);

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    IF_DEBUG(OPEN_CLOSE) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
            "AfdCleanup: cleanup on file object %p, endpoint %p, connection %p\n",
            IrpSp->FileObject,
            endpoint,
            AFD_CONNECTION_FROM_ENDPOINT( endpoint )
            ));
    }

    //
    // Get the process exit time while still at low IRQL.
    //

    processExitTime = PsGetProcessExitTime( );

    //
    // Indicate that there was a local close on this endpoint.  If there
    // are any outstanding polls on this endpoint, they will be
    // completed now.
    //
    AfdIndicatePollEvent(
        endpoint,
        AFD_POLL_LOCAL_CLOSE,
        STATUS_SUCCESS
        );

    //
    // Remember that the endpoint has been cleaned up.  This is important
    // because it allows AfdRestartAccept to know that the endpoint has
    // been cleaned up and that it should toss the connection.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    AfdIndicateEventSelectEvent (endpoint, AFD_POLL_LOCAL_CLOSE, STATUS_SUCCESS);

    ASSERT( endpoint->EndpointCleanedUp == FALSE);
    endpoint->EndpointCleanedUp = TRUE;

    //
    // If this a datagram endpoint, cancel all IRPs and free any buffers
    // of data.  Note that if the state of the endpoint is just "open"
    // (not bound, etc.) then we can't have any pended IRPs or datagrams
    // on the endpoint.  Also, the lists of IRPs and datagrams may not
    // yet been initialized if the state is just open.
    //

    if ( IS_DGRAM_ENDPOINT(endpoint) ) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

        if ( endpoint->State == AfdEndpointStateBound ||
                endpoint->State == AfdEndpointStateConnected) {

            //
            // Reset the counts of datagrams bufferred on the endpoint.
            // This prevents anyone from thinking that there is bufferred
            // data on the endpoint.
            //

            endpoint->DgBufferredReceiveCount = 0;
            endpoint->DgBufferredReceiveBytes = 0;

            //
            // Cancel all receive datagram and peek datagram IRPs on the
            // endpoint.
            //

            AfdCompleteIrpList(
                &endpoint->ReceiveDatagramIrpListHead,
                endpoint,
                STATUS_CANCELLED,
                AfdCleanupReceiveDatagramIrp
                );

            AfdCompleteIrpList(
                &endpoint->PeekDatagramIrpListHead,
                endpoint,
                STATUS_CANCELLED,
                AfdCleanupReceiveDatagramIrp
                );

        }
    }
    else if (IS_SAN_ENDPOINT (endpoint)) {
        if (!IsListEmpty (&endpoint->Common.SanEndp.IrpList)) {
            AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
            AfdSanRestartRequestProcessing (endpoint, STATUS_CANCELLED);
        }
        else {
            AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        }
    }
    else if (IS_SAN_HELPER (endpoint)) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        if (endpoint->OwningProcess==IoGetCurrentProcess ()) {
            AfdSanHelperCleanup (endpoint);
        }
        else {
            ASSERT ((endpoint->Common.SanHlpr.PendingRequests & 1) != 0);
        }
    }
    else {
        PAFD_CONNECTION connection;

        connection = AFD_CONNECTION_FROM_ENDPOINT( endpoint );
        ASSERT( connection == NULL || connection->Type == AfdBlockTypeConnection );

        //
        // Reference the connection object so that it does not go away while
        // we are freeing the resources
        //

        if (connection!=NULL) {
            REFERENCE_CONNECTION (connection);

            //
            // If this is a connected non-datagram socket and the send side has
            // not been disconnected and there is no outstanding data to be
            // received, begin a graceful disconnect on the connection.  If there
            // is unreceived data out outstanding IO, abort the connection.
            //

            if ( (endpoint->State == AfdEndpointStateConnected 
                        || endpoint->State==AfdEndpointStateBound
                        || endpoint->State==AfdEndpointStateTransmitClosing)
                                // Endpoint is in bound state when connection
                                // request is in progress, we still need
                                // to abort those.
        
                    &&
                connection->ConnectedReferenceAdded

                    &&

                !endpoint->afdC_Root        // these are connected on bind

                    &&

                ( (endpoint->DisconnectMode & AFD_ABORTIVE_DISCONNECT) == 0)

                    &&

                ( (endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_SEND) == 0 ||
                  IS_DATA_ON_CONNECTION(connection) ||
                  IS_EXPEDITED_DATA_ON_CONNECTION(connection) ||
                  ( !IS_TDI_BUFFERRING(endpoint) &&
                    connection->Common.NonBufferring.ReceiveBytesInTransport > 0 ) ||
                    endpoint->StateChangeInProgress)

                    &&

                !connection->Aborted ) {

                ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );

                if ( IS_DATA_ON_CONNECTION( connection )

                     ||

                     IS_EXPEDITED_DATA_ON_CONNECTION( connection )

                     ||

                     ( !IS_TDI_BUFFERRING(endpoint) &&
                        connection->Common.NonBufferring.ReceiveBytesInTransport > 0 )

                     ||

                     processExitTime.QuadPart != 0

                     ||

                     endpoint->OutstandingIrpCount != 0

                     ||
             
                     endpoint->StateChangeInProgress

                     ||

                     ( !IS_TDI_BUFFERRING(endpoint) &&
                          (!IsListEmpty( &connection->VcReceiveIrpListHead ) ||
                           !IsListEmpty( &connection->VcSendIrpListHead )) )

                     ) {

#if DBG
                    if ( processExitTime.QuadPart != 0 ) {
                        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                                    "AfdCleanup: process exiting w/o closesocket, aborting endp %p\n",
                                    endpoint ));
                    }
                    else {
                        if ( IS_DATA_ON_CONNECTION( connection ) ) {
                            if (IS_TDI_BUFFERRING(endpoint)) {
                                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                                            "AfdCleanup: unrecv'd data on endp %p, aborting.  "
                                            "%ld ind, %ld taken, %ld out\n",
                                            endpoint,
                                            connection->Common.Bufferring.ReceiveBytesIndicated,
                                            connection->Common.Bufferring.ReceiveBytesTaken,
                                            connection->Common.Bufferring.ReceiveBytesOutstanding ));
                            }
                            else {
                                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                                            "AfdCleanup: unrecv'd data (%ld) on endp %p, aborting.\n",
                                            connection->Common.NonBufferring.BufferredReceiveBytes,
                                            endpoint ));
                            }
                        }

                        if ( IS_EXPEDITED_DATA_ON_CONNECTION( connection ) ) {
                            if (IS_TDI_BUFFERRING(endpoint)) {
                                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                                            "AfdCleanup: unrecv'd exp data on endp %p, aborting.  "
                                            "%ld ind, %ld taken, %ld out\n",
                                            endpoint,
                                            connection->Common.Bufferring.ReceiveExpeditedBytesIndicated,
                                            connection->Common.Bufferring.ReceiveExpeditedBytesTaken,
                                            connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding ));
                            }
                            else {
                                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                                            "AfdCleanup: unrecv'd exp data (%ld) on endp %p, aborting.\n",
                                            connection->Common.NonBufferring.BufferredExpeditedBytes,
                                            endpoint ));
                            }
                        }

                        if ( !IS_TDI_BUFFERRING(endpoint) &&
                            connection->Common.NonBufferring.ReceiveBytesInTransport > 0 ) {
                            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                                        "AfdCleanup: unrecv'd data (%ld) in transport on endp %p, aborting.\n",
                                        connection->Common.NonBufferring.ReceiveBytesInTransport,
                                        endpoint));
                        }

                        if ( endpoint->OutstandingIrpCount != 0 ) {
                            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                                        "AfdCleanup: %ld IRPs %s outstanding on endpoint %p, "
                                        "aborting.\n",
                                        endpoint->OutstandingIrpCount,
                                        (endpoint->StateChangeInProgress 
                                            ? "(accept, connect, or transmit file)"
                                            : ""),
                                        endpoint ));
                        }
                    }
#endif

                    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

                    (VOID)AfdBeginAbort( connection );

                } else {

                    endpoint->DisconnectMode |= AFD_PARTIAL_DISCONNECT_RECEIVE;
                    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

                    status = AfdBeginDisconnect( endpoint, NULL, NULL );
                    if (!NT_SUCCESS (status)) {
                        //
                        // If disconnect failed, we have no choice but to abort the
                        // connection because we cannot return error from close and
                        // have application try it again.  If we don't abort, connection
                        // ends up hanging there forever.
                        //
                        (VOID)AfdBeginAbort (connection);
                    }
                }

            } else {

                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            }

            //
            // If this is a connected VC endpoint on a nonbufferring TDI provider,
            // cancel all outstanding send and receive IRPs.
            //

            if ( !IS_TDI_BUFFERRING(endpoint) ) {

                AfdCompleteIrpList(
                    &connection->VcReceiveIrpListHead,
                    endpoint,
                    STATUS_CANCELLED,
                    NULL
                    );

                AfdCompleteIrpList(
                    &connection->VcSendIrpListHead,
                    endpoint,
                    STATUS_CANCELLED,
                    AfdCleanupSendIrp
                    );
            }

            //
            // Remember that we have started cleanup on this connection.
            // We know that we'll never get a request on the connection
            // after we start cleanup on the connection.
            //

            AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
            connection->CleanupBegun = TRUE;

            //
            // Attempt to remove the connected reference.
            //

            AfdDeleteConnectedReference( connection, TRUE );
            AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

            //
            // Remove connection reference added in the beginning of this
            // function.  We can't access connection object after this point
            // because in can be freed inside the AfdDereferenceConnection.
            //

            DEREFERENCE_CONNECTION (connection);
            connection = NULL;
        }
        else {
            AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        }

        //
        // Complete any outstanding wait for listen IRPs on the endpoint.
        //

        if ( (endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening ) {

            AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
            while ( !IsListEmpty( &endpoint->Common.VcListening.ListeningIrpListHead ) ) {

                PIRP waitForListenIrp;
                PIO_STACK_LOCATION irpSp;

                listEntry = RemoveHeadList( &endpoint->Common.VcListening.ListeningIrpListHead );
                waitForListenIrp = CONTAINING_RECORD(
                                       listEntry,
                                       IRP,
                                       Tail.Overlay.ListEntry
                                       );
                //
                // Set FLink to NULL so that cancel routine won't touch the IRP.
                //

                listEntry->Flink = NULL;

                irpSp = IoGetCurrentIrpStackLocation (waitForListenIrp);
                if (irpSp->MajorFunction==IRP_MJ_INTERNAL_DEVICE_CONTROL) {
                    AfdCleanupSuperAccept (waitForListenIrp, STATUS_CANCELLED);
                }
                else {
                    waitForListenIrp->IoStatus.Status = STATUS_CANCELLED;
                    waitForListenIrp->IoStatus.Information = 0;
                }

                //
                // Release the AFD spin lock so that we can complete the
                // wait for listen IRP.
                //

                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

                //
                // Cancel the IRP.
                //

                //
                // Reset the cancel routine in the IRP.
                //

                if ( IoSetCancelRoutine( waitForListenIrp, NULL ) == NULL ) {
                    KIRQL cancelIrql;

                    //
                    // If the cancel routine was NULL then cancel routine
                    // may be running.  Wait on the cancel spinlock until
                    // the cancel routine is done.
                    //
                    // Note: The cancel routine will not find the IRP
                    // since it is not in the list.
                    //
                
                    IoAcquireCancelSpinLock( &cancelIrql );
                    ASSERT( waitForListenIrp->Cancel );
                    IoReleaseCancelSpinLock( cancelIrql );

                }

                IoCompleteRequest( waitForListenIrp, AfdPriorityBoost );

                //
                // Reacquire the AFD spin lock for the next pass through the
                // loop.
                //

                AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
            }

            //
            // Free all queued (free, unaccepted, and returned) connections
            // on the endpoint.
            //

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            AfdFreeQueuedConnections( endpoint );
            endpoint->Common.VcListening.FailedConnectionAdds = 0;
        }
    }

    if (endpoint->RoutingQueryReferenced) {
        AfdCleanupRoutingChange (endpoint);
    }


    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
    while (!IsListEmpty (&endpoint->RequestList)) {
        PAFD_REQUEST_CONTEXT    requestCtx;
        listEntry = RemoveHeadList (&endpoint->RequestList);
        listEntry->Flink = NULL;
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        requestCtx = CONTAINING_RECORD (listEntry,
                                        AFD_REQUEST_CONTEXT,
                                        EndpointListLink);
        (*requestCtx->CleanupRoutine) (endpoint, requestCtx);
        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
    }

    if ( endpoint->Irp != NULL) {

        PIRP transmitIrp;
        KIRQL cancelIrql;

        //
        // Release the endpoint and acquire the cancel spinlock
        // and then the enpoint spinlock.
        //
        
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        IoAcquireCancelSpinLock( &cancelIrql );
        AfdAcquireSpinLockAtDpcLevel( &endpoint->SpinLock, &lockHandle );

        //
        // Make sure there is still a transmit IRP.
        //

        transmitIrp = endpoint->Irp;

        if ( transmitIrp != NULL ) {
            PDRIVER_CANCEL  cancelRoutine;

            // indicate that it has to be cancelled
            transmitIrp->Cancel = TRUE;
            cancelRoutine = IoSetCancelRoutine( transmitIrp, NULL );
            if ( cancelRoutine != NULL ) {

                //
                // The IRP needs to be canceled.  Release the
                // endpoint spinlock.  The value in endpoint->Irp can
                // now change, but the IRP cannot be completed while the
                // cancel spinlock is held since we set the cancel flag
                // in the IRP.
                //

                AfdReleaseSpinLockFromDpcLevel( &endpoint->SpinLock, &lockHandle );

                transmitIrp->CancelIrql = cancelIrql;
                cancelRoutine ( NULL, transmitIrp );   
            }
            else {
                // The IRP has not been completely setup yet
                // and will be cancelled in the dispatch routine
                AfdReleaseSpinLockFromDpcLevel( &endpoint->SpinLock, &lockHandle );
                IoReleaseCancelSpinLock( cancelIrql );
            }

        } else {

            //
            // The IRP has been completed or canceled.  Release the locks
            // and continue.
            //

            AfdReleaseSpinLockFromDpcLevel( &endpoint->SpinLock, &lockHandle );
            IoReleaseCancelSpinLock( cancelIrql );
        }

    } else {
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
    }

    //
    // Reset relevant event handlers on the endpoint.  This prevents
    // getting indications after we free the endpoint and connection
    // objects.  We should not be able to get new connects after this
    // handle has been cleaned up.
    //
    // Note that these calls can fail if, for example, DHCP changes the
    // host's IP address while the endpoint is active.
    //
    //

    if ((endpoint->AddressHandle != NULL) && (endpoint->State != AfdEndpointStateOpen)) {

        if (endpoint->Listening) {

            status = AfdSetEventHandler(
                         endpoint->AddressFileObject,
                         TDI_EVENT_CONNECT,
                         NULL,
                         NULL
                         );
            // ASSERT(NT_SUCCESS(status));

            if (IS_TDI_ADDRESS_SECURITY(endpoint)) {
                status = AfdUnbind(endpoint);
                // ASSERT(NT_SUCCESS(status));
            }

        } else if (IS_VC_ENDPOINT(endpoint)) {

            //
            // Connection-oriented accepted endpoints cannot have address handles
            // in their structures because they share them with listening
            // endpoint. So, this is an endpoint on which connect was done.
            // We need to call AfdUnbind() on it to allow other endpoints to
            // bind to the address held by this endpoint. 
            // We cannot wait for final dereference on address file object for
            // unbind to take place, because that can be delayed till all
            // endpoint ref counts go to 0. So, we must do explicit unbind here
            //
            
            if (IS_TDI_ADDRESS_SECURITY (endpoint)) {
                status = AfdUnbind(endpoint);
                // ASSERT(NT_SUCCESS(status));
            }

        } else if (IS_DGRAM_ENDPOINT(endpoint)) {

            status = AfdSetEventHandler(
                         endpoint->AddressFileObject,
                         TDI_EVENT_RECEIVE_DATAGRAM,
                         NULL,
                         NULL
                         );
            // ASSERT(NT_SUCCESS(status));

            status = AfdSetEventHandler(
                         endpoint->AddressFileObject,
                         TDI_EVENT_ERROR_EX,
                         NULL,
                         NULL
                         );
            // ASSERT(NT_SUCCESS(status));

            status = AfdSetEventHandler(
                         endpoint->AddressFileObject,
                         TDI_EVENT_ERROR,
                         NULL,
                         NULL
                         );
            // ASSERT(NT_SUCCESS(status));

            //
            // We need to call AfdUnbind() on this endpoint to allow other endpoints to
            // bind to the address held by this endpoint. 
            // We cannot wait for final dereference on address file object for
            // unbind to take place, because that can be delayed till all
            // endpoint ref counts go to 0. So, we must do explicit unbind here
            //

            if (IS_TDI_ADDRESS_SECURITY (endpoint)) {
                status = AfdUnbind(endpoint);
                // ASSERT(NT_SUCCESS(status));
            }

        }

    } // if (endpoint->State != AfdEndpointStateOpen)

    InterlockedIncrement(&AfdEndpointsCleanedUp);

    return STATUS_SUCCESS;

} // AfdCleanup


NTSTATUS
FASTCALL
AfdClose (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the routine that handles Close IRPs in AFD.  It
    dereferences the endpoint specified in the IRP, which will result in
    the endpoint being freed when all other references go away.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;

    UNREFERENCED_PARAMETER (Irp);
    PAGED_CODE( );

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    IF_DEBUG(OPEN_CLOSE) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdClose: closing file object %p, endpoint %p\n",
                    IrpSp->FileObject, endpoint ));
    }

    IF_DEBUG(ENDPOINT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdClose: closing endpoint at %p\n",
                    endpoint ));
    }

    connection = AFD_CONNECTION_FROM_ENDPOINT (endpoint);

    //
    // If there is a connection on this endpoint, dereference it here
    // rather than in AfdDereferenceEndpoint, because the connection
    // has a referenced pointer to the endpoint which must be removed
    // before the endpoint can dereference the connection.
    //

    if (connection != NULL) {
        endpoint->Common.VcConnecting.Connection = NULL;
        DEREFERENCE_CONNECTION (connection);
        //
        // This is to simplify debugging.
        // If connection is not being closed by the transport
        // we want to be able to find it in the debugger faster
        // then thru !poolfind AfdC.
        //
        endpoint->WorkItem.Context = connection;
    }
    else if (IS_SAN_ENDPOINT (endpoint) &&
                endpoint->Common.SanEndp.SwitchContext!=NULL) {
        PVOID requestCtx;
        endpoint->Common.SanEndp.FileObject = NULL;
        requestCtx = AFD_SWITCH_MAKE_REQUEST_CONTEXT(
                            ((ULONG)0xFFFFFFFF),
                            AFD_SWITCH_REQUEST_CLOSE); 
        IoSetIoCompletion (
                    endpoint->Common.SanEndp.SanHlpr->Common.SanHlpr.IoCompletionPort,// Port
                    endpoint->Common.SanEndp.SwitchContext,     // Key
                    requestCtx,                                 // ApcContext
                    STATUS_SUCCESS,                             // Status
                    0,                                          // Information
                    FALSE                                       // ChargeQuota
                    );
    }

    //
    // Set the state of the endpoint to closing and dereference to
    // get rid of the active reference.
    //

    ASSERT (endpoint->State!=AfdEndpointStateClosing);
    endpoint->State = AfdEndpointStateClosing;

    //
    // Dereference the endpoint to get rid of the active reference.
    // This will result in the endpoint storage being freed as soon
    // as all other references go away.
    //

    DEREFERENCE_ENDPOINT( endpoint );

    return STATUS_SUCCESS;

} // AfdClose
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\buffer.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    buffer.c

Abstract:

    This module contains routines for handling non-bufferring TDI
    providers.  The AFD interface assumes that bufferring will be done
    below AFD; if the TDI provider doesn't buffer, then AFD must.

Author:

    David Treadwell (davidtr)    21-Feb-1992

Revision History:

--*/

#include "afdp.h"

PAFD_BUFFER
AfdInitializeBuffer (
    IN PVOID MemBlock,
    IN ULONG BufferDataSize,
    IN ULONG AddressSize,
    IN CCHAR StackSize
    );

VOID
AfdInitializeBufferTag (
    IN PAFD_BUFFER_TAG AfdBufferTag,
    IN ULONG AddressSize
    );

PAFD_BUFFER
AfdGetBufferSlow (
    IN ULONG BufferDataSize,
    IN ULONG AddressSize,
    IN PEPROCESS Process,
    IN CCHAR StackSize
    );


#if DBG
VOID
AfdFreeBufferReal (
    PVOID   AfdBuffer
    );
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGEAFD, AfdAllocateBuffer )
#pragma alloc_text( PAGEAFD, AfdFreeBuffer )
#if DBG
#pragma alloc_text( PAGEAFD, AfdFreeBufferReal )
#endif
#pragma alloc_text( PAGEAFD, AfdCalculateBufferSize )
#pragma alloc_text( PAGEAFD, AfdInitializeBuffer )
#pragma alloc_text( PAGEAFD, AfdGetBufferFast )
#ifdef _AFD_VARIABLE_STACK_
#pragma alloc_text( PAGEAFD, AfdGetBufferWithMaxStackSize )
#endif //_AFD_VARIABLE_STACK_
#pragma alloc_text( PAGEAFD, AfdGetBufferSlow )
#pragma alloc_text( PAGEAFD, AfdReturnBuffer )
#pragma alloc_text( PAGEAFD, AfdAllocateBufferTag )
#pragma alloc_text( PAGEAFD, AfdFreeBufferTag )
#pragma alloc_text( PAGEAFD, AfdAllocateRemoteAddress )
#pragma alloc_text( PAGEAFD, AfdFreeRemoteAddress )
#pragma alloc_text( PAGEAFD, AfdInitializeBufferTag )
#pragma alloc_text( PAGEAFD, AfdGetBufferTag )
#pragma alloc_text( INIT, AfdInitializeBufferManager)
#endif


PVOID
AfdAllocateBuffer (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )

/*++

Routine Description:

    Used by the lookaside list allocation function to allocate a new
    AFD buffer structure.  The returned structure will be fully
    initialized.

Arguments:

    PoolType - passed to ExAllocatePoolWithTag.

    NumberOfBytes - the number of bytes required for the data buffer
        portion of the AFD buffer.

    Tag - passed to ExAllocatePoolWithTag.

Return Value:

    PVOID - a fully initialized PAFD_BUFFER, or NULL if the allocation
        attempt fails.

--*/

{
    ULONG       dataLength;
    PVOID       memBlock;

    //
    // Get nonpaged pool for the buffer.
    //

    memBlock = AFD_ALLOCATE_POOL( PoolType, NumberOfBytes, Tag );
    if ( memBlock == NULL ) {
        return NULL;
    }

    if (NumberOfBytes==AfdLookasideLists->SmallBufferList.L.Size) {
        dataLength = AfdSmallBufferSize;
    }
    else if (NumberOfBytes==AfdLookasideLists->MediumBufferList.L.Size) {
        dataLength = AfdMediumBufferSize;
    }
    else if (NumberOfBytes==AfdLookasideLists->LargeBufferList.L.Size) {
        dataLength = AfdLargeBufferSize;
    }
    else {
        ASSERT (!"Unknown buffer length");
        return NULL;
    }
    //
    // Initialize the buffer and return a pointer to it.
    //
#if DBG
    {
        PAFD_BUFFER afdBuffer = AfdInitializeBuffer( memBlock, 
                                                    dataLength, 
                                                    AfdStandardAddressLength, 
                                                    AfdTdiStackSize );
        ASSERT ((PCHAR)afdBuffer+sizeof (AFD_BUFFER)<=(PCHAR)memBlock+NumberOfBytes &&
                    (PCHAR)afdBuffer->Buffer+dataLength<=(PCHAR)memBlock+NumberOfBytes &&
                    (PCHAR)afdBuffer->Irp+IoSizeOfIrp(AfdTdiStackSize)<=(PCHAR)memBlock+NumberOfBytes &&
                    (PCHAR)afdBuffer->Mdl+MmSizeOfMdl(afdBuffer->Buffer, dataLength)<=(PCHAR)memBlock+NumberOfBytes &&
                    (PCHAR)afdBuffer->TdiInfo.RemoteAddress+AfdStandardAddressLength<=(PCHAR)memBlock+NumberOfBytes);
        return afdBuffer;
    }
#else
    return AfdInitializeBuffer( memBlock, dataLength, AfdStandardAddressLength, AfdTdiStackSize );
#endif


} // AfdAllocateBuffer


VOID
NTAPI
AfdFreeBuffer (
    PVOID   AfdBuffer
    )
{
    ASSERT( ((PAFD_BUFFER)AfdBuffer)->BufferLength == AfdSmallBufferSize ||
            ((PAFD_BUFFER)AfdBuffer)->BufferLength == AfdMediumBufferSize ||
            ((PAFD_BUFFER)AfdBuffer)->BufferLength == AfdLargeBufferSize );
#if DBG
    AfdFreeBufferReal (AfdBuffer);
}

VOID
NTAPI
AfdFreeBufferReal (
    PVOID   AfdBuffer
    )
{
#endif
    {
        PAFD_BUFFER hdr = AfdBuffer;
        switch (hdr->Placement) {
        case AFD_PLACEMENT_BUFFER:
            AfdBuffer = hdr->Buffer;
            break;
        case AFD_PLACEMENT_HDR:
            AfdBuffer = hdr;
            break;
        case AFD_PLACEMENT_MDL:
            AfdBuffer = hdr->Mdl;
            break;
        case AFD_PLACEMENT_IRP:
            AfdBuffer = hdr->Irp;
            break;
        default:
            ASSERT (!"Unknown placement!");
            __assume (0);
        }
        if (hdr->AlignmentAdjusted) {
            //
            // The original memory block was adjusted to meet alignment
            // requirement of AFD buffers.
            // The amount of adjustment should be stored in the space
            // used for adjustment (right below the first piece).
            //
            ASSERT ((*(((PSIZE_T)AfdBuffer)-1))>0 &&
                        (*(((PSIZE_T)AfdBuffer)-1))<AfdBufferAlignment);
            AfdBuffer = (PUCHAR)AfdBuffer - (*(((PSIZE_T)AfdBuffer)-1));
        }
        AFD_FREE_POOL (AfdBuffer, AFD_DATA_BUFFER_POOL_TAG);
    }
}


PVOID
AfdAllocateBufferTag (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )

/*++

Routine Description:

    Used by the lookaside list allocation function to allocate a new
    AFD buffer tag structure.  The returned structure will be fully
    initialized.

Arguments:

    PoolType - passed to ExAllocatePoolWithTag.

    NumberOfBytes - the number of bytes required for the data buffer
        portion of the AFD buffer tag (0).

    Tag - passed to ExAllocatePoolWithTag.

Return Value:

    PVOID - a fully initialized PAFD_BUFFER_TAG, or NULL if the allocation
        attempt fails.

--*/

{
    PAFD_BUFFER_TAG afdBufferTag;

    //
    // The requested length must be the same as buffer tag size
    //

    ASSERT(NumberOfBytes == sizeof (AFD_BUFFER_TAG) );

    //
    // Get nonpaged pool for the buffer tag.
    //

    afdBufferTag = AFD_ALLOCATE_POOL( PoolType, NumberOfBytes, Tag );
    if ( afdBufferTag == NULL ) {
        return NULL;
    }

    //
    // Initialize the buffer tag and return a pointer to it.
    //

    AfdInitializeBufferTag( afdBufferTag, 0 );

    return afdBufferTag;


} // AfdAllocateBufferTag

VOID
NTAPI
AfdFreeBufferTag (
    PVOID   AfdBufferTag
    )
{
    AFD_FREE_POOL (AfdBufferTag, AFD_DATA_BUFFER_POOL_TAG);
}


PVOID
AfdAllocateRemoteAddress (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )

/*++

Routine Description:

    Used by the lookaside list allocation function to allocate a new
    remote address structure.  The returned structure will be fully
    initialized.

Arguments:

    PoolType - passed to ExAllocatePoolWithTag.

    NumberOfBytes - the number of bytes required for the data buffer
        portion of the AFD buffer tag (0).

    Tag - passed to ExAllocatePoolWithTag.

Return Value:

    PVOID - a fully initialized remote address, or NULL if the allocation
        attempt fails.

--*/

{
    //
    // The requested length must be the same as standard address size
    //

    ASSERT(NumberOfBytes == AfdStandardAddressLength );

    //
    // Get nonpaged pool for the remote address.
    //

    return AFD_ALLOCATE_POOL( PoolType, NumberOfBytes, Tag );


} // AfdAllocateRemoteAddress

VOID
NTAPI
AfdFreeRemoteAddress (
    PVOID   AfdBufferTag
    )
{
    AFD_FREE_POOL (AfdBufferTag, AFD_REMOTE_ADDRESS_POOL_TAG);
}


ULONG
AfdCalculateBufferSize (
    IN ULONG BufferDataSize,
    IN ULONG AddressSize,
    IN CCHAR StackSize
    )

/*++

Routine Description:

    Determines the size of an AFD buffer structure given the amount of
    data that the buffer contains.

Arguments:

    BufferDataSize - data length of the buffer.

    AddressSize - length of address structure for the buffer.

Return Value:

    Number of bytes needed for an AFD_BUFFER structure for data of
    this size.

--*/

{
    ULONG irpSize;
    ULONG mdlSize;
    ULONG hdrSize;
    ULONG size;

    //
    // Determine the sizes of the various components of an AFD_BUFFER
    // structure.
    //

    hdrSize = sizeof (AFD_BUFFER);
    irpSize = IoSizeOfIrp( StackSize );
    //
    // For mdl size calculation we rely on ex guarantee that buffer will be
    // aligned on the page boundary (for allocations >= PAGE_SIZE)
    // or will not spawn pages (for allocations < PAGE_SIZE).
    //
    mdlSize = (CLONG)MmSizeOfMdl( NULL, BufferDataSize );

    size = ALIGN_UP_A(hdrSize,AFD_MINIMUM_BUFFER_ALIGNMENT) +
                ALIGN_UP_A(irpSize,AFD_MINIMUM_BUFFER_ALIGNMENT) +
                ALIGN_UP_A(mdlSize,AFD_MINIMUM_BUFFER_ALIGNMENT) +
                ALIGN_UP_A(BufferDataSize,AFD_MINIMUM_BUFFER_ALIGNMENT) +
                AddressSize;
    if (size>=PAGE_SIZE) {
        return size;
    }
    else {
        if (StackSize==AfdTdiStackSize) {
            size += AfdAlignmentOverhead;
        }
        else {
            size += AfdBufferAlignment-AFD_MINIMUM_BUFFER_ALIGNMENT;
        }

        if (size>=PAGE_SIZE) {
            //
            // PAGE_SIZE allocations are aligned, ignore any extra overhead
            //
            return PAGE_SIZE;
        }
        else {
            return size;
        }
    }
} // AfdCalculateBufferSize


PAFD_BUFFER
FASTCALL
AfdGetBufferFast (
    IN ULONG BufferDataSize,
    IN ULONG  AddressSize,
    IN PEPROCESS Process
    )

/*++

Routine Description:

    Obtains a buffer of the appropriate size for the caller.  Uses
    the preallocated buffers if possible, or else allocates a new buffer
    structure if required.

Arguments:

    BufferDataSize - the size of the data buffer that goes along with the
        buffer structure.

    AddressSize - size of the address field required for the buffer.

Return Value:

    PAFD_BUFFER - a pointer to an AFD_BUFFER structure, or NULL if one
        was not available or could not be allocated.

--*/

{
    PAFD_BUFFER afdBuffer;
    NTSTATUS    status;

    //
    // If possible, allocate the buffer from one of the lookaside lists.
    //

    if ( AddressSize <= AfdStandardAddressLength &&
             BufferDataSize <= AfdLargeBufferSize ) {
        PNPAGED_LOOKASIDE_LIST lookasideList;

        if ( BufferDataSize <= AfdSmallBufferSize ) {

            lookasideList = &AfdLookasideLists->SmallBufferList;

        } else if ( BufferDataSize <= AfdMediumBufferSize ) {

            lookasideList = &AfdLookasideLists->MediumBufferList;

        } else {

            lookasideList = &AfdLookasideLists->LargeBufferList;
        }

        afdBuffer = ExAllocateFromNPagedLookasideList( lookasideList );
        if ( afdBuffer != NULL) {

            if (!afdBuffer->Lookaside) {
                status = PsChargeProcessPoolQuota (
                                (PEPROCESS)((ULONG_PTR)Process & (~AFDB_RAISE_ON_FAILURE)),
                                NonPagedPool,
                                lookasideList->L.Size);

                if (!NT_SUCCESS (status)) {
                    AfdFreeBuffer (afdBuffer);
                    goto ExitQuotaFailure;
                }

                AfdRecordQuotaHistory(
                    process,
                    (LONG)lookasideList->L.Size,
                    "BuffAlloc   ",
                    afdBuffer
                    );
                AfdRecordPoolQuotaCharged(lookasideList->L.Size);
            }

#if DBG
            RtlGetCallersAddress(
                &afdBuffer->Caller,
                &afdBuffer->CallersCaller
                );
#endif
            return afdBuffer;
        }
    }
    else {
        afdBuffer = AfdGetBufferSlow (BufferDataSize, AddressSize, Process, AfdTdiStackSize);
#if DBG
        if (afdBuffer!=NULL) {
            RtlGetCallersAddress(
                &afdBuffer->Caller,
                &afdBuffer->CallersCaller
                );
        }
#endif
        return afdBuffer;
    }

    status = STATUS_INSUFFICIENT_RESOURCES;

ExitQuotaFailure:
    if ((ULONG_PTR)Process & AFDB_RAISE_ON_FAILURE) {
        ExRaiseStatus (status);
    }

    return NULL;
} // AfdGetBuffer

#ifdef _AFD_VARIABLE_STACK_
PAFD_BUFFER
FASTCALL
AfdGetBufferWithMaxStackSize (
    IN ULONG BufferDataSize,
    IN ULONG AddressSize,
    IN PEPROCESS Process
    )
{
    PAFD_BUFFER afdBuffer;

    afdBuffer = AfdGetBufferSlow (BufferDataSize, AddressSize, Process, AfdMaxStackSize);
#if DBG
    if (afdBuffer!=NULL) {
            RtlGetCallersAddress(
                &afdBuffer->Caller,
                &afdBuffer->CallersCaller
                );
    }
#endif
    return afdBuffer;
}
#endif // _AFD_VARIABLE_STACK_

PAFD_BUFFER
AfdGetBufferSlow (
    IN ULONG BufferDataSize,
    IN ULONG AddressSize,
    IN PEPROCESS Process,
    IN CCHAR StackSize
    )
{
    NTSTATUS    status;

    if (AddressSize<=0xFFFF) {
        PVOID       memBlock;
        LONG        sz;
        ULONG       bufferSize;

        //
        // Couldn't find an appropriate buffer that was preallocated.
        // Allocate one manually.  If the buffer size requested was
        // zero bytes, give them four bytes.  This is because some of
        // the routines like MmSizeOfMdl() cannot handle getting passed
        // in a length of zero.
        //
        // !!! It would be good to ROUND_TO_PAGES for this allocation
        //     if appropriate, then use entire buffer size.
        //

        if ( BufferDataSize == 0 ) {
            BufferDataSize = sizeof(ULONG);
        }

        bufferSize = AfdCalculateBufferSize( BufferDataSize, AddressSize, StackSize );

        //
        // Check for overflow (stack size comes from trusted source - no need to check
        // for overflow).
        //
        if (bufferSize>=BufferDataSize && bufferSize>=AddressSize) {

            memBlock = AFD_ALLOCATE_POOL(
                            NonPagedPool,
                            bufferSize,
                            AFD_DATA_BUFFER_POOL_TAG
                            );

            if ( memBlock != NULL) {
                status = PsChargeProcessPoolQuota (
                                (PEPROCESS)((ULONG_PTR)Process & (~AFDB_RAISE_ON_FAILURE)),
                                NonPagedPool,
                                sz = BufferDataSize
                                    +AfdBufferOverhead
                                    +AddressSize
                                    -AfdStandardAddressLength
                                    +BufferDataSize<PAGE_SIZE
                                        ? min (AfdAlignmentOverhead, PAGE_SIZE-BufferDataSize)
                                        : 0);
                if (NT_SUCCESS (status)) {
                    PAFD_BUFFER afdBuffer;

                    //
                    // Initialize the AFD buffer structure and return it.
                    //

                    afdBuffer = AfdInitializeBuffer( memBlock,
                                                    BufferDataSize,
                                                    AddressSize, 
                                                    StackSize);

                    ASSERT ((PCHAR)afdBuffer+sizeof (AFD_BUFFER)<=(PCHAR)memBlock+bufferSize &&
                                (PCHAR)afdBuffer->Buffer+BufferDataSize<=(PCHAR)memBlock+bufferSize &&
                                (PCHAR)afdBuffer->Irp+IoSizeOfIrp(StackSize)<=(PCHAR)memBlock+bufferSize &&
                                (PCHAR)afdBuffer->Mdl+MmSizeOfMdl(afdBuffer->Buffer, BufferDataSize)<=(PCHAR)memBlock+bufferSize &&
                                (PCHAR)afdBuffer->TdiInfo.RemoteAddress+AddressSize<=(PCHAR)memBlock+bufferSize);

                    AfdRecordPoolQuotaCharged(sz);
                
                    AfdRecordQuotaHistory(
                        process,
                        sz,
                        "BuffAlloc   ",
                        afdBuffer
                        );

                    return afdBuffer;
                }
                else {
                    AFD_FREE_POOL (memBlock, AFD_DATA_BUFFER_POOL_TAG);
                    goto ExitQuotaFailure;
                }
            } // memblock==NULL
        } // overflow
    }
    else {
        // TDI does not support addresses > USHORT
        ASSERT (FALSE);
    }

    //
    // This is default status code.
    // Quota failures jump directly to the
    // label below to raise the status returned by
    // the quota charging code if requested by the caller..
    //
    status = STATUS_INSUFFICIENT_RESOURCES;

ExitQuotaFailure:
    if ((ULONG_PTR)Process & AFDB_RAISE_ON_FAILURE) {
        ExRaiseStatus (status);
    }
    return NULL;
}


PAFD_BUFFER_TAG
AfdGetBufferTag (
    IN ULONG AddressSize,
    IN PEPROCESS Process
    )

/*++

Routine Description:

    Obtains a buffer for tagging TDSU received via chained indication.  Uses
    the preallocated buffers if possible, or else allocates a new buffer
    structure if required.

Arguments:

    AddressSize - size of the address field required for the buffer.

Return Value:

    PAFD_BUFFER_TAG - a pointer to an AFD_BUFFER_TAG structure, or NULL if one
        was not available or could not be allocated.

--*/

{
    PAFD_BUFFER_TAG afdBufferTag;
    ULONG           bufferSize;
    NTSTATUS        status;

    if ( AddressSize <= AfdStandardAddressLength) {
        if (AddressSize>0)
            AddressSize = AfdStandardAddressLength;
        afdBufferTag = ExAllocateFromNPagedLookasideList( 
                                &AfdLookasideLists->BufferTagList );
        if ( afdBufferTag != NULL &&
                ( AddressSize==0 || 
                    (afdBufferTag->TdiInfo.RemoteAddress = 
                                ExAllocateFromNPagedLookasideList( 
                                &AfdLookasideLists->RemoteAddrList ))!=NULL ) ) {

            afdBufferTag->AllocatedAddressLength = (USHORT)AddressSize;
            if (!afdBufferTag->Lookaside) {
                status = PsChargeProcessPoolQuota (
                                (PEPROCESS)((ULONG_PTR)Process & (~AFDB_RAISE_ON_FAILURE)),
                                NonPagedPool,
                                sizeof (AFD_BUFFER_TAG)+AddressSize);
                if (!NT_SUCCESS (status)) {
                    if ((afdBufferTag->TdiInfo.RemoteAddress!=NULL) &&
                            (afdBufferTag->TdiInfo.RemoteAddress != (PVOID)(afdBufferTag+1))) {
                        ExFreeToNPagedLookasideList( &AfdLookasideLists->RemoteAddrList, 
                                                            afdBufferTag->TdiInfo.RemoteAddress );
                    }
                    AFD_FREE_POOL (afdBufferTag, AFD_DATA_BUFFER_POOL_TAG);
                    goto ExitQuotaFailure;
                }

                AfdRecordQuotaHistory(
                    process,
                    (LONG)(sizeof (AFD_BUFFER_TAG)+AddressSize),
                    "BuffAlloc   ",
                    afdBufferTag
                    );
                AfdRecordPoolQuotaCharged(sizeof (AFD_BUFFER_TAG)+AddressSize);
            }
#if DBG
            RtlGetCallersAddress(
                &afdBufferTag->Caller,
                &afdBufferTag->CallersCaller
                );
#endif
            return afdBufferTag;
        } // afdBufferTag==NULL || RemoteAddress==NULL
    }
    else if (AddressSize<=0xFFFF) {
        bufferSize = sizeof (AFD_BUFFER_TAG) + AddressSize;

        afdBufferTag = AFD_ALLOCATE_POOL(
                        NonPagedPool,
                        bufferSize,
                        AFD_DATA_BUFFER_POOL_TAG
                        );

        if (afdBufferTag!=NULL) {
            status = PsChargeProcessPoolQuota (
                                (PEPROCESS)((ULONG_PTR)Process & (~AFDB_RAISE_ON_FAILURE)),
                                NonPagedPool,
                                bufferSize);
            if (NT_SUCCESS (status)) {

                //
                // Initialize the AFD buffer structure and return it.
                //

                AfdInitializeBufferTag (afdBufferTag, AddressSize);
                AfdRecordQuotaHistory(
                    process,
                    (LONG)bufferSize,
                    "BuffAlloc   ",
                    afdBufferTag
                    );

                AfdRecordPoolQuotaCharged(bufferSize);
#if DBG
                RtlGetCallersAddress(
                    &afdBufferTag->Caller,
                    &afdBufferTag->CallersCaller
                    );
#endif
                return afdBufferTag;
            }
            else {
                AFD_FREE_POOL (afdBufferTag, AFD_DATA_BUFFER_POOL_TAG);
                goto ExitQuotaFailure;
            }
        }
    }
    else {
        // TDI does not support addresses > USHORT
        ASSERT (FALSE);
    }

    //
    // This is default status code.
    // Quota failures jump directly to the
    // label below to raise the status returned by
    // the quota charging code if requested by the caller..
    //

    status = STATUS_INSUFFICIENT_RESOURCES;

ExitQuotaFailure:

    if ((ULONG_PTR)Process & AFDB_RAISE_ON_FAILURE) {
        ExRaiseStatus (status);
    }

    return NULL;
}


VOID
AfdReturnBuffer (
    IN PAFD_BUFFER_HEADER AfdBufferHeader,
    IN PEPROCESS Process
    )

/*++

Routine Description:

    Returns an AFD buffer to the appropriate global list, or frees
    it if necessary.

Arguments:

    AfdBufferHeader - points to the AFD_BUFFER_HEADER structure to return or free.

Return Value:

    None.

--*/

{

    
    if (AfdBufferHeader->BufferLength!=AfdBufferTagSize) {
        PNPAGED_LOOKASIDE_LIST lookasideList;
        PAFD_BUFFER AfdBuffer = CONTAINING_RECORD (AfdBufferHeader, AFD_BUFFER, Header);

        ASSERT (IS_VALID_AFD_BUFFER (AfdBuffer));
        
        //
        // Most of the AFD buffer must be zeroed when returning the buffer.
        //

        ASSERT( !AfdBuffer->ExpeditedData );
        ASSERT( AfdBuffer->Mdl->ByteCount == AfdBuffer->BufferLength );
        ASSERT( AfdBuffer->Mdl->Next == NULL );

        //
        // If appropriate, return the buffer to one of the AFD buffer
        // lookaside lists.
        //
#ifdef _AFD_VARIABLE_STACK_
        if (AfdBuffer->Irp->StackCount==AfdTdiStackSize &&
                    AfdBuffer->AllocatedAddressLength == AfdStandardAddressLength &&
                    AfdBuffer->BufferLength <= AfdLargeBufferSize) {
#else // _AFD_VARIABLE_STACK_
        ASSERT (AfdBuffer->Irp->StackCount==AfdTdiStackSize);
        if (AfdBuffer->AllocatedAddressLength == AfdStandardAddressLength &&
                    AfdBuffer->BufferLength <= AfdLargeBufferSize) {
#endif // _AFD_VARIABLE_STACK_

            if (AfdBuffer->BufferLength==AfdSmallBufferSize) {
                lookasideList = &AfdLookasideLists->SmallBufferList;
            } else if (AfdBuffer->BufferLength == AfdMediumBufferSize) {
                lookasideList = &AfdLookasideLists->MediumBufferList;
            } else { 
                ASSERT (AfdBuffer->BufferLength==AfdLargeBufferSize);
                lookasideList = &AfdLookasideLists->LargeBufferList;
            }

            if (!AfdBuffer->Lookaside) {
                PsReturnPoolQuota (Process, NonPagedPool, lookasideList->L.Size);
                AfdRecordQuotaHistory(
                    Process,
                    -(LONG)lookasideList->L.Size,
                    "BuffDealloc ",
                    AfdBuffer
                    );
                AfdRecordPoolQuotaReturned(
                    lookasideList->L.Size
                    );
                AfdBuffer->Lookaside = TRUE;
            }
            ExFreeToNPagedLookasideList( lookasideList, AfdBuffer );

            return;

        }

        // The buffer was not from a lookaside list allocation, so just free
        // the pool we used for it.
        //

#ifdef _AFD_VARIABLE_STACK_
        ASSERT (AfdBuffer->Irp->StackCount>=AfdTdiStackSize &&
                    AfdBuffer->Irp->StackCount<=AfdMaxStackSize);
#endif // _AFD_VARIABLE_STACK_
        ASSERT (AfdBuffer->Lookaside==FALSE);
        {
            LONG    sz;
            PsReturnPoolQuota (Process,
                                  NonPagedPool,
                                  sz=AfdBuffer->BufferLength
                                        +AfdBufferOverhead
                                        +AfdBuffer->AllocatedAddressLength
                                        -AfdStandardAddressLength
                                        +AfdBuffer->BufferLength<PAGE_SIZE 
                                            ? min (AfdAlignmentOverhead, PAGE_SIZE-AfdBuffer->BufferLength)
                                            : 0);
            AfdRecordQuotaHistory(
                Process,
                -(LONG)sz,
                "BuffDealloc ",
                AfdBuffer
                );
            AfdRecordPoolQuotaReturned(
                sz
                );
        }
#if DBG
        AfdFreeBufferReal (AfdBuffer);
#else
        AfdFreeBuffer (AfdBuffer);
#endif

        return;
    }
    else {
        PAFD_BUFFER_TAG AfdBufferTag = CONTAINING_RECORD (AfdBufferHeader, AFD_BUFFER_TAG, Header);

        ASSERT( !AfdBufferTag->ExpeditedData );

        if (AfdBufferTag->NdisPacket) {
            AfdBufferTag->NdisPacket = FALSE;
            TdiReturnChainedReceives (&AfdBufferTag->Context, 1);
        }

        if (AfdBufferTag->TdiInfo.RemoteAddress != (PVOID)(AfdBufferTag+1)) {
            if (AfdBufferTag->TdiInfo.RemoteAddress!=NULL) {
                ASSERT (AfdBufferTag->AllocatedAddressLength==AfdStandardAddressLength);
                ExFreeToNPagedLookasideList( &AfdLookasideLists->RemoteAddrList, 
                                                    AfdBufferTag->TdiInfo.RemoteAddress );
                AfdBufferTag->TdiInfo.RemoteAddress = NULL;
            }
            else {
                ASSERT (AfdBufferTag->AllocatedAddressLength==0);
            }

            if (!AfdBufferTag->Lookaside) {
                LONG    sz;
                PsReturnPoolQuota (
                                Process,
                                NonPagedPool,
                                sz=sizeof (AFD_BUFFER_TAG) 
                                        + AfdBufferTag->AllocatedAddressLength);
                AfdRecordQuotaHistory(
                    Process,
                    -(LONG)sz,
                    "BuffDealloc ",
                    AfdBufferTag
                    );
                AfdRecordPoolQuotaReturned(
                    sz
                    );
                AfdBufferTag->Lookaside = TRUE;
            }
            ExFreeToNPagedLookasideList( &AfdLookasideLists->BufferTagList, AfdBufferTag );
        }
        else {
            LONG    sz;
            ASSERT (AfdBufferTag->AllocatedAddressLength>AfdStandardAddressLength);
            ASSERT (AfdBufferTag->Lookaside == FALSE);
            PsReturnPoolQuota (
                                Process,
                                NonPagedPool,
                                sz = sizeof (AFD_BUFFER_TAG) 
                                        + AfdBufferTag->AllocatedAddressLength);
            AfdRecordQuotaHistory(
                Process,
                -(LONG)sz,
                "BuffDealloc ",
                AfdBufferTag
                );
            AfdRecordPoolQuotaReturned(
                sz
                );
            AFD_FREE_POOL(
                AfdBufferTag,
                AFD_DATA_BUFFER_POOL_TAG
                );
        }
    }

} // AfdReturnBuffer





PAFD_BUFFER
AfdInitializeBuffer (
    IN PVOID MemoryBlock,
    IN ULONG BufferDataSize,
    IN ULONG AddressSize,
    IN CCHAR StackSize
    )

/*++

Routine Description:

    Initializes an AFD buffer.  Sets up fields in the actual AFD_BUFFER
    structure and initializes the IRP and MDL associated with the
    buffer.  This routine assumes that the caller has properly allocated
    sufficient space for all this.

Arguments:

    AfdBuffer - points to the AFD_BUFFER structure to initialize.

    BufferDataSize - the size of the data buffer that goes along with the
        buffer structure.

    AddressSize - the size of data allocated for the address buffer.

    ListHead - the global list this buffer belongs to, or NULL if it
        doesn't belong on any list.  This routine does NOT place the
        buffer structure on the list.

Return Value:

    None.

--*/

{
    USHORT  irpSize;
    SIZE_T  mdlSize;
    SIZE_T  hdrSize;
    PAFD_BUFFER hdr;
    PMDL    mdl;
    PIRP    irp;
    PVOID   buf;
    PVOID   addr;
    UCHAR   placement;
    SIZE_T  alignment;
#ifdef AFD_CHECK_ALIGNMENT
    PLONG  alignmentCounters = (PLONG)&AfdAlignmentTable[AfdAlignmentTableSize];
#endif
    irpSize = IoSizeOfIrp( StackSize );
    mdlSize = (ULONG)MmSizeOfMdl( NULL, BufferDataSize );
    hdrSize = sizeof (AFD_BUFFER);

    //
    // Compute the index into (mis)alignment table to determine
    // what placement of the buffer block elements (e.g. hdr, IRP, MDL,
    // and data buffer itself) we need to choose to compensate and
    // align data buffer on AfdBufferAlignment boundary.
    //
    ASSERT ((PtrToUlong(MemoryBlock)%AFD_MINIMUM_BUFFER_ALIGNMENT)==0);
#ifdef _AFD_VARIABLE_STACK_
    if (PAGE_ALIGN (MemoryBlock)==MemoryBlock || StackSize!=AfdTdiStackSize) {
        ASSERT (StackSize>=AfdTdiStackSize && StackSize<=AfdMaxStackSize);
#else // _AFD_VARIABLE_STACK
    if (PAGE_ALIGN (MemoryBlock)==MemoryBlock) {
#endif // _AFD_VARIABLE_STACK
        //
        // For page-aligned blocks (which are >= page size),
        // we always place the buffer first.
        // Same thing for big IRP stacks - allocate more memory to
        // compensate for alignment.
        //
        placement = AFD_PLACEMENT_BUFFER;
    }
    else {
        placement = AfdAlignmentTable[
                (PtrToUlong(MemoryBlock)&(AfdBufferAlignment-1))/AFD_MINIMUM_BUFFER_ALIGNMENT];
    }

#ifdef AFD_CHECK_ALIGNMENT
    InterlockedIncrement (&alignmentCounters[
            (PtrToUlong(MemoryBlock)&(AfdBufferAlignment-1))/AFD_MINIMUM_BUFFER_ALIGNMENT]);
#endif

    switch (placement) {
    case AFD_PLACEMENT_BUFFER:
        //
        // Perfect case: the memory is aready aligned as we need it.
        //
        buf = ALIGN_UP_A_POINTER(MemoryBlock, AfdBufferAlignment);
        alignment = (PUCHAR)buf-(PUCHAR)MemoryBlock;
#ifdef _AFD_VARIABLE_STACK_
        ASSERT (alignment<=AfdAlignmentOverhead || (StackSize!=AfdTdiStackSize));
#else // _AFD_VARIABLE_STACK_
        ASSERT (alignment<=AfdAlignmentOverhead);
#endif // _AFD_VARIABLE_STACK_
        hdr = ALIGN_UP_TO_TYPE_POINTER((PCHAR)buf+BufferDataSize, AFD_BUFFER);
        irp = ALIGN_UP_TO_TYPE_POINTER((PCHAR)hdr+hdrSize, IRP);
        mdl = ALIGN_UP_TO_TYPE_POINTER((PCHAR)irp+irpSize, MDL);
        addr = (PCHAR)mdl+mdlSize;
        break;

        //
        // Other cases, we use hdr, mdl, and IRP to try to compensate
        // and have the data buffer aligned at the AfdBufferAlignment
        // boundary.
        //
    case AFD_PLACEMENT_HDR:
        hdr = ALIGN_UP_TO_TYPE_POINTER(MemoryBlock, AFD_BUFFER);
        alignment = (PUCHAR)hdr-(PUCHAR)MemoryBlock;
        ASSERT (alignment<=AfdAlignmentOverhead);
        buf = ALIGN_UP_A_POINTER((PCHAR)hdr+hdrSize, AfdBufferAlignment);
        irp = ALIGN_UP_TO_TYPE_POINTER((PCHAR)buf+BufferDataSize, IRP);
        mdl = ALIGN_UP_TO_TYPE_POINTER((PCHAR)irp+irpSize, MDL);
        addr = (PCHAR)mdl+mdlSize;
        break;

    case AFD_PLACEMENT_MDL:
        mdl = ALIGN_UP_TO_TYPE_POINTER(MemoryBlock, MDL);
        alignment = (PUCHAR)mdl-(PUCHAR)MemoryBlock;
        ASSERT (alignment<=AfdAlignmentOverhead);
        buf = ALIGN_UP_A_POINTER((PCHAR)mdl+mdlSize, AfdBufferAlignment);
        hdr = ALIGN_UP_TO_TYPE_POINTER((PCHAR)buf+BufferDataSize, AFD_BUFFER);
        irp = ALIGN_UP_TO_TYPE_POINTER((PCHAR)hdr+hdrSize, IRP);
        addr = (PCHAR)irp+irpSize;
        break;
    case AFD_PLACEMENT_IRP:
        irp = ALIGN_UP_TO_TYPE_POINTER(MemoryBlock, IRP);
        alignment = (PUCHAR)irp-(PUCHAR)MemoryBlock;
        ASSERT (alignment<=AfdAlignmentOverhead);
        buf = ALIGN_UP_A_POINTER((PCHAR)irp+irpSize, AfdBufferAlignment);
        hdr = ALIGN_UP_TO_TYPE_POINTER((PCHAR)buf+BufferDataSize, AFD_BUFFER);
        mdl = ALIGN_UP_TO_TYPE_POINTER((PCHAR)hdr+hdrSize, MDL);
        addr = (PCHAR)mdl+mdlSize;
        break;
    case AFD_PLACEMENT_HDR_IRP:
        hdr = ALIGN_UP_TO_TYPE_POINTER(MemoryBlock, AFD_BUFFER);
        alignment = (PUCHAR)hdr-(PUCHAR)MemoryBlock;
        ASSERT (alignment<=AfdAlignmentOverhead);
        irp = ALIGN_UP_TO_TYPE_POINTER((PCHAR)hdr+hdrSize, IRP);
        buf = ALIGN_UP_A_POINTER((PCHAR)irp+irpSize, AfdBufferAlignment);
        mdl = ALIGN_UP_TO_TYPE_POINTER((PCHAR)buf+BufferDataSize, MDL);
        addr = (PCHAR)mdl+mdlSize;
        break;
    case AFD_PLACEMENT_HDR_MDL:
        hdr = ALIGN_UP_TO_TYPE_POINTER(MemoryBlock, AFD_BUFFER);
        alignment = (PUCHAR)hdr-(PUCHAR)MemoryBlock;
        ASSERT (alignment<=AfdAlignmentOverhead);
        mdl = ALIGN_UP_TO_TYPE_POINTER((PCHAR)hdr+hdrSize, MDL);
        buf = ALIGN_UP_A_POINTER((PCHAR)mdl+mdlSize, AfdBufferAlignment);
        irp = ALIGN_UP_TO_TYPE_POINTER((PCHAR)buf+BufferDataSize, IRP);
        addr = (PCHAR)irp+irpSize;
        break;
    case AFD_PLACEMENT_IRP_MDL:
        irp = ALIGN_UP_TO_TYPE_POINTER(MemoryBlock, IRP);
        alignment = (PUCHAR)irp-(PUCHAR)MemoryBlock;
        ASSERT (alignment<=AfdAlignmentOverhead);
        mdl = ALIGN_UP_TO_TYPE_POINTER((PCHAR)irp+irpSize, MDL);
        buf = ALIGN_UP_A_POINTER((PCHAR)mdl+mdlSize, AfdBufferAlignment);
        hdr = ALIGN_UP_TO_TYPE_POINTER((PCHAR)buf+BufferDataSize, AFD_BUFFER);
        addr = (PCHAR)hdr+hdrSize;
        break;
    case AFD_PLACEMENT_HDR_IRP_MDL:
        hdr = ALIGN_UP_TO_TYPE_POINTER(MemoryBlock, AFD_BUFFER);
        alignment = (PUCHAR)hdr-(PUCHAR)MemoryBlock;
        ASSERT (alignment<=AfdAlignmentOverhead);
        irp = ALIGN_UP_TO_TYPE_POINTER((PCHAR)hdr+hdrSize, IRP);
        mdl = ALIGN_UP_TO_TYPE_POINTER((PCHAR)irp+irpSize, MDL);
        buf = ALIGN_UP_A_POINTER((PCHAR)mdl+mdlSize, AfdBufferAlignment);
        addr = (PCHAR)buf+BufferDataSize;
        break;
    default:
        ASSERT (!"Unknown placement!");
        __assume (0);
    }

    
    //
    // Initialize the AfdBuffer - most fields need to be 0.
    //

    RtlZeroMemory( hdr, sizeof(*hdr) );

    //
    // Setup buffer
    //
    hdr->Buffer = buf;
    hdr->BufferLength = BufferDataSize;
    
    //
    // We just need to store first two bits of placement
    // so we know which part comes first to free it properly.
    //
    hdr->Placement = placement & 3;

    //
    // If we have to align the memory block to meet the requirement
    // store this information right below the first piece.
    //
    if (alignment!=0) {
        C_ASSERT (AFD_MINIMUM_BUFFER_ALIGNMENT>=sizeof (SIZE_T));
        C_ASSERT ((AFD_MINIMUM_BUFFER_ALIGNMENT & (sizeof(SIZE_T)-1))==0);
        ASSERT (alignment>=sizeof (SIZE_T));
        hdr->AlignmentAdjusted = TRUE;
        *(((PSIZE_T)(((PUCHAR)MemoryBlock)+alignment))-1) = alignment;
    }


    //
    // Initialize the IRP pointer.
    //

    hdr->Irp = irp;
    IoInitializeIrp( hdr->Irp, irpSize, StackSize );
    hdr->Irp->MdlAddress = mdl;

    //
    // Set up the MDL pointer.
    //

    hdr->Mdl = mdl;
    MmInitializeMdl( hdr->Mdl, buf, BufferDataSize );
    MmBuildMdlForNonPagedPool( hdr->Mdl );
    
    //
    // Set up the address buffer pointer.
    //

    if (AddressSize>0) {
        hdr->TdiInfo.RemoteAddress = ALIGN_UP_TO_TYPE_POINTER(addr, TRANSPORT_ADDRESS);;
        hdr->AllocatedAddressLength = (USHORT)AddressSize;
    }


#if DBG
    hdr->BufferListEntry.Flink = UIntToPtr( 0xE0E1E2E3 );
    hdr->BufferListEntry.Blink = UIntToPtr( 0xE4E5E6E7 );
#endif

    return hdr;

} // AfdInitializeBuffer


VOID
AfdInitializeBufferTag (
    IN PAFD_BUFFER_TAG AfdBufferTag,
    IN CLONG           AddressSize
    )

/*++

Routine Description:

    Initializes an AFD buffer.  Sets up fields in the actual AFD_BUFFER
    structure and initializes the IRP and MDL associated with the
    buffer.  This routine assumes that the caller has properly allocated
    sufficient space for all this.

Arguments:

    AfdBuffer - points to the AFD_BUFFER structure to initialize.

    BufferDataSize - the size of the data buffer that goes along with the
        buffer structure.

    AddressSize - the size of data allocated for the address buffer.

    ListHead - the global list this buffer belongs to, or NULL if it
        doesn't belong on any list.  This routine does NOT place the
        buffer structure on the list.

Return Value:

    None.

--*/

{
    AfdBufferTag->Mdl = NULL;
    AfdBufferTag->BufferLength = AfdBufferTagSize;
    AfdBufferTag->TdiInfo.RemoteAddress = AddressSize ? AfdBufferTag+1 : NULL;
    AfdBufferTag->AllocatedAddressLength = (USHORT)AddressSize;
    AfdBufferTag->Flags = 0;

#if DBG
    AfdBufferTag->BufferListEntry.Flink = UIntToPtr( 0xE0E1E2E3 );
    AfdBufferTag->BufferListEntry.Blink = UIntToPtr( 0xE4E5E6E7 );
    AfdBufferTag->Caller = NULL;
    AfdBufferTag->CallersCaller = NULL;
#endif
}


VOID
AfdInitializeBufferManager (
    VOID
    )
{
    SIZE_T  irpSize = ALIGN_UP_A(IoSizeOfIrp (AfdTdiStackSize), AFD_MINIMUM_BUFFER_ALIGNMENT);
    SIZE_T  hdrSize = ALIGN_UP_A(sizeof (AFD_BUFFER), AFD_MINIMUM_BUFFER_ALIGNMENT);
    SIZE_T  mdlSize = ALIGN_UP_A(MmSizeOfMdl (NULL, PAGE_SIZE),AFD_MINIMUM_BUFFER_ALIGNMENT);
    UCHAR   placement;
    ULONG   i;
    ULONG   currentOverhead;

    //
    // Initialize the alignment table.
    // This table is used to determine what kind of element
    // placement to use in AFD_BUFFER depending on the alignment
    // of the memory block returned by the executive pool manager.
    // The goal is to align the data buffer on the cache line
    // boundary.  However, since executive only guarantees alignment of
    // it's blocks at the CPU alignment requirements, we need to 
    // adjust and potentially waste up to CACHE_LIST_SIZE-CPU_ALIGNMENT_SIZE.
    // With some machines having cache line alignment at 128 such memory
    // waste is prohibitive (small buffers with default size of 128 will double
    // in size).
    // The table below allows us to rearrange pieces in AFD_BUFFER structure,
    // namely, the header, IRP, MDL, and data buffer, so that pieces with
    // lower alignment requirement can be used to consume the space needed
    // to adjust the memory block to the cache line boundary.
    
    //
    // AfdAlignmentTable has an entry for each possible case of memory block
    // misaligned against cache line size.  For example, in typical X86 system
    // case executive pool manager always returns blocks aligned on 8 byte bounday,
    // while cache lines are typically 64 bytes long, so memory manager can 
    // theoretically return blocks misaligned against cache by:
    //        8, 16, 24, 32, 40, 48, 56.
    // For each of these cases we will try to adjust the alignment by using
    // any possible combination of header, IRP, and MDL.  There will be some
    // cases that cannot be adjusted exactly, and we will have to pad.
    //

    //
    // First initialize the table assuming the data buffer is placed first.
    //
    RtlFillMemory (AfdAlignmentTable, AfdAlignmentTableSize, AFD_PLACEMENT_BUFFER);
#ifdef AFD_CHECK_ALIGNMENT
    RtlZeroMemory (&AfdAlignmentTable[AfdAlignmentTableSize],
                        AfdAlignmentTableSize*sizeof(LONG));
#endif
    //
    // Now identify the entries that can be padded with some combination of
    // header, IRP, and MDL:
    //      extract the bits that can be used for padding
    //      reverse to get corresponding memory block alignments
    //      divide by the step of the alignment table
    //      make sure we won't go past table size (last entry => 0 entry).
    //
#define AfdInitAlignmentTableRow(_size,_plcmnt)                     \
    AfdAlignmentTable[                                              \
            ((AfdBufferAlignment-(_size&(AfdBufferAlignment-1)))    \
                /AFD_MINIMUM_BUFFER_ALIGNMENT)                      \
                &(AfdAlignmentTableSize-1)] = _plcmnt

    //
    // We let placements beginning with header override others,
    // since it is more natural and easier to debug (header has references
    // to other pieces).
    //

    AfdInitAlignmentTableRow(mdlSize,AFD_PLACEMENT_MDL);
    AfdInitAlignmentTableRow(irpSize,AFD_PLACEMENT_IRP);
    AfdInitAlignmentTableRow((irpSize+mdlSize),AFD_PLACEMENT_IRP_MDL);
    AfdInitAlignmentTableRow((hdrSize+mdlSize),AFD_PLACEMENT_HDR_MDL);
    AfdInitAlignmentTableRow((hdrSize+irpSize),AFD_PLACEMENT_HDR_IRP);
    AfdInitAlignmentTableRow((hdrSize+irpSize+mdlSize),AFD_PLACEMENT_HDR_IRP_MDL);
    AfdInitAlignmentTableRow(hdrSize,AFD_PLACEMENT_HDR);

    //
    // Now scan the table from top to bottom and fill entries that do not have
    // exact match using the above combinations. Use the closest entry above and
    // in the process compute how much do we need to pad in addition to padding
    // achieved via placement.
    //
    AfdAlignmentOverhead = 0;
    currentOverhead = 0;
    //
    // By default use the placement of aligned block.
    //
    placement = AfdAlignmentTable[0];
    for (i=AfdAlignmentTableSize-1; i>0; i--) {
        if (AfdAlignmentTable[i]==AFD_PLACEMENT_BUFFER) {
            AfdAlignmentTable[i] = placement;
            currentOverhead += AFD_MINIMUM_BUFFER_ALIGNMENT;
        }
        else {
            placement = AfdAlignmentTable[i];
            if (AfdAlignmentOverhead<currentOverhead) {
                AfdAlignmentOverhead = currentOverhead;
            }
            currentOverhead = 0;
        }
    }
    if (AfdAlignmentOverhead<currentOverhead) {
        AfdAlignmentOverhead = currentOverhead;
    }


    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                "AfdInitializeBufferManager: Alignment requirements: MM-%d, cache-%d, overhead-%d\n",
                        AFD_MINIMUM_BUFFER_ALIGNMENT,
                        AfdBufferAlignment,
                        AfdAlignmentOverhead));
    {
        CLONG   oldBufferLengthForOnePage = AfdBufferLengthForOnePage;

        AfdBufferOverhead = AfdCalculateBufferSize(
                                        PAGE_SIZE,
                                        AfdStandardAddressLength,
                                        AfdTdiStackSize) - PAGE_SIZE;
        AfdBufferLengthForOnePage = ALIGN_DOWN_A(
                                        PAGE_SIZE-AfdBufferOverhead,
                                        AFD_MINIMUM_BUFFER_ALIGNMENT);
        if (AfdLargeBufferSize==oldBufferLengthForOnePage) {
            AfdLargeBufferSize = AfdBufferLengthForOnePage;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\blkconn.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    blkconn.c

Abstract:

    This module contains allocate, free, close, reference, and dereference
    routines for AFD connections.

Author:

    David Treadwell (davidtr)    10-Mar-1992

Revision History:

--*/

#include "afdp.h"

VOID
AfdFreeConnection (
    IN PVOID Context
    );

VOID
AfdFreeConnectionResources (
    PAFD_CONNECTION connection
    );

VOID
AfdFreeNPConnectionResources (
    PAFD_CONNECTION connection
    );

VOID
AfdRefreshConnection (
    PAFD_CONNECTION connection
    );

PAFD_CONNECTION
AfdReuseConnection (
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfdAddFreeConnection )
#pragma alloc_text( PAGE, AfdAllocateConnection )
#pragma alloc_text( PAGE, AfdCreateConnection )
#pragma alloc_text( PAGE, AfdFreeConnection )
#pragma alloc_text( PAGE, AfdFreeConnectionResources )
#pragma alloc_text( PAGE, AfdReuseConnection )
#pragma alloc_text( PAGEAFD, AfdRefreshConnection )
#pragma alloc_text( PAGEAFD, AfdFreeNPConnectionResources )
#pragma alloc_text( PAGEAFD, AfdGetConnectionReferenceFromEndpoint )
#if REFERENCE_DEBUG
#pragma alloc_text( PAGEAFD, AfdReferenceConnection )
#pragma alloc_text( PAGEAFD, AfdDereferenceConnection )
#else
#pragma alloc_text( PAGEAFD, AfdCloseConnection )
#endif
#pragma alloc_text( PAGEAFD, AfdGetFreeConnection )
#pragma alloc_text( PAGEAFD, AfdGetReturnedConnection )
#pragma alloc_text( PAGEAFD, AfdFindReturnedConnection )
#pragma alloc_text( PAGEAFD, AfdGetUnacceptedConnection )
#pragma alloc_text( PAGEAFD, AfdAddConnectedReference )
#pragma alloc_text( PAGEAFD, AfdDeleteConnectedReference )
#endif

#if GLOBAL_REFERENCE_DEBUG
AFD_GLOBAL_REFERENCE_DEBUG AfdGlobalReference[MAX_GLOBAL_REFERENCE];
LONG AfdGlobalReferenceSlot = -1;
#endif

#if AFD_PERF_DBG
#define CONNECTION_REUSE_DISABLED   (AfdDisableConnectionReuse)
#else
#define CONNECTION_REUSE_DISABLED   (FALSE)
#endif


NTSTATUS
AfdAddFreeConnection (
    IN PAFD_ENDPOINT Endpoint
    )

/*++

Routine Description:

    Adds a connection object to an endpoints pool of connections available
    to satisfy a connect indication.

Arguments:

    Endpoint - a pointer to the endpoint to which to add a connection.

Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    PAFD_CONNECTION connection;
    NTSTATUS status;

    PAGED_CODE( );

    ASSERT( Endpoint->Type == AfdBlockTypeVcListening ||
            Endpoint->Type == AfdBlockTypeVcBoth );

    //
    // Create a new connection block and associated connection object.
    //

    status = AfdCreateConnection(
                 Endpoint->TransportInfo,
                 Endpoint->AddressHandle,
                 IS_TDI_BUFFERRING(Endpoint),
                 Endpoint->InLine,
                 Endpoint->OwningProcess,
                 &connection
                 );

    if ( NT_SUCCESS(status) ) {
        ASSERT( IS_TDI_BUFFERRING(Endpoint) == connection->TdiBufferring );

        if (IS_DELAYED_ACCEPTANCE_ENDPOINT (Endpoint)) {
            status = AfdDelayedAcceptListen (Endpoint, connection);
            if (!NT_SUCCESS (status)) {
                DEREFERENCE_CONNECTION (connection);
            }
        }
        else {
            //
            // Set up the handle in the listening connection structure and place
            // the connection on the endpoint's list of listening connections.
            //

            ASSERT (connection->Endpoint==NULL);
            InterlockedPushEntrySList(
                &Endpoint->Common.VcListening.FreeConnectionListHead,
                &connection->SListEntry);
            status = STATUS_SUCCESS;
        }
    }

    return status;
} // AfdAddFreeConnection


PAFD_CONNECTION
AfdAllocateConnection (
    VOID
    )
{
    PAFD_CONNECTION connection;

    PAGED_CODE( );

    if ((AfdConnectionsFreeing<AFD_CONNECTIONS_FREEING_MAX)
            || ((connection = AfdReuseConnection ())==NULL)) {

        //
        // Allocate a buffer to hold the connection structure.
        //

        connection = AFD_ALLOCATE_POOL(
                         NonPagedPool,
                         sizeof(AFD_CONNECTION),
                         AFD_CONNECTION_POOL_TAG
                         );

        if ( connection == NULL ) {
            return NULL;
        }
    }

    RtlZeroMemory( connection, sizeof(AFD_CONNECTION) );

    //
    // Initialize the reference count to 1 to account for the caller's
    // reference.  Connection blocks are temporary--as soon as the last
    // reference goes away, so does the connection.  There is no active
    // reference on a connection block.
    //

    connection->ReferenceCount = 1;

    //
    // Initialize the connection structure.
    //

    connection->Type = AfdBlockTypeConnection;
    connection->State = AfdConnectionStateFree;
    //connection->Handle = NULL;
    //connection->FileObject = NULL;
    //connection->RemoteAddress = NULL;
    //connection->Endpoint = NULL;
    //connection->ReceiveBytesIndicated = 0;
    //connection->ReceiveBytesTaken = 0;
    //connection->ReceiveBytesOutstanding = 0;
    //connection->ReceiveExpeditedBytesIndicated = 0;
    //connection->ReceiveExpeditedBytesTaken = 0;
    //connection->ReceiveExpeditedBytesOutstanding = 0;
    //connection->ConnectDataBuffers = NULL;
    //connection->DisconnectIndicated = FALSE;
    //connection->Aborted = FALSE;
    //connection->AbortIndicated = FALSE;
    //connection->AbortFailed = FALSE;
    //connection->ConnectedReferenceAdded = FALSE;
    //connection->SpecialCondition = FALSE;
    //connection->CleanupBegun = FALSE;
    //connection->OwningProcess = NULL;
    //connection->ClosePendedTransmit = FALSE;

    //
    // Return a pointer to the new connection to the caller.
    //

    IF_DEBUG(CONNECTION) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdAllocateConnection: connection at %p\n", connection ));
    }

    return connection;

} // AfdAllocateConnection


NTSTATUS
AfdCreateConnection (
    IN PAFD_TRANSPORT_INFO TransportInfo,
    IN HANDLE AddressHandle,
    IN BOOLEAN TdiBufferring,
    IN LOGICAL InLine,
    IN PEPROCESS ProcessToCharge,
    OUT PAFD_CONNECTION *Connection
    )

/*++

Routine Description:

    Allocates a connection block and creates a connection object to
    go with the block.  This routine also associates the connection
    with the specified address handle (if any).

Arguments:

    TransportDeviceName - Name to use when creating the connection object.

    AddressHandle - a handle to an address object for the specified
        transport.  If specified (non NULL), the connection object that
        is created is associated with the address object.

    TdiBufferring - whether the TDI provider supports data bufferring.
        Only passed so that it can be stored in the connection
        structure.

    InLine - if TRUE, the endpoint should be created in OOB inline
        mode.

    ProcessToCharge - the process which should be charged the quota
        for this connection.

    Connection - receives a pointer to the new connection.

Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    CHAR eaBuffer[sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                  TDI_CONNECTION_CONTEXT_LENGTH + 1 +
                  sizeof(CONNECTION_CONTEXT)];
    PFILE_FULL_EA_INFORMATION ea;
    CONNECTION_CONTEXT UNALIGNED *ctx;
    PAFD_CONNECTION connection;

    PAGED_CODE( );


    //
    // Attempt to charge this process quota for the data bufferring we
    // will do on its behalf.
    //

    status = PsChargeProcessPoolQuota(
        ProcessToCharge,
        NonPagedPool,
        sizeof (AFD_CONNECTION)
        );
    if (!NT_SUCCESS (status)) {
       KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdCreateConnection: PsChargeProcessPoolQuota failed.\n" ));

       return status;
    }

    //
    // Allocate a connection block.
    //

    connection = AfdAllocateConnection( );

    if ( connection == NULL ) {
        PsReturnPoolQuota(
            ProcessToCharge,
            NonPagedPool,
            sizeof (AFD_CONNECTION)
            );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    AfdRecordQuotaHistory(
        ProcessToCharge,
        (LONG)sizeof (AFD_CONNECTION),
        "CreateConn  ",
        connection
        );

    AfdRecordPoolQuotaCharged(sizeof (AFD_CONNECTION));

    //
    // Remember the process that got charged the pool quota for this
    // connection object.  Also reference the process to which we're
    // going to charge the quota so that it is still around when we
    // return the quota.
    //

    ASSERT( connection->OwningProcess == NULL );
    connection->OwningProcess = ProcessToCharge;

    ObReferenceObject( ProcessToCharge );

    //
    // If the provider does not buffer, initialize appropriate lists in
    // the connection object.
    //

    connection->TdiBufferring = TdiBufferring;

    if ( !TdiBufferring ) {

        InitializeListHead( &connection->VcReceiveIrpListHead );
        InitializeListHead( &connection->VcSendIrpListHead );
        InitializeListHead( &connection->VcReceiveBufferListHead );

        connection->VcBufferredReceiveBytes = 0;
        connection->VcBufferredExpeditedBytes = 0;
        connection->VcBufferredReceiveCount = 0;
        connection->VcBufferredExpeditedCount = 0;

        connection->VcReceiveBytesInTransport = 0;

#if DBG
        connection->VcReceiveIrpsInTransport = 0;
#endif

        connection->VcBufferredSendBytes = 0;
        connection->VcBufferredSendCount = 0;

    } else {

        connection->VcNonBlockingSendPossible = TRUE;
        connection->VcZeroByteReceiveIndicated = FALSE;
    }

    //
    // Set up the send and receive window with default maximums.
    //

    connection->MaxBufferredReceiveBytes = AfdReceiveWindowSize;

    connection->MaxBufferredSendBytes = AfdSendWindowSize;

    //
    // We need to open a connection object to the TDI provider for this
    // endpoint.  First create the EA for the connection context and the
    // object attributes structure which will be used for all the
    // connections we open here.
    //

    ea = (PFILE_FULL_EA_INFORMATION)eaBuffer;
    ea->NextEntryOffset = 0;
    ea->Flags = 0;
    ea->EaNameLength = TDI_CONNECTION_CONTEXT_LENGTH;
    ea->EaValueLength = sizeof(CONNECTION_CONTEXT);

    RtlMoveMemory( ea->EaName, TdiConnectionContext, ea->EaNameLength + 1 );

    //
    // Use the pointer to the connection block as the connection context.
    //

    ctx = (CONNECTION_CONTEXT UNALIGNED *)&ea->EaName[ea->EaNameLength + 1];
    *ctx = (CONNECTION_CONTEXT)connection;

    // We ask to create a kernel handle which is
    // the handle in the context of the system process
    // so that application cannot close it on us while
    // we are creating and referencing it.
    InitializeObjectAttributes(
        &objectAttributes,
        &TransportInfo->TransportDeviceName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,       // attributes
        NULL,
        NULL
        );

    //
    // Do the actual open of the connection object.
    //

    status = IoCreateFile(
                &connection->Handle,
                GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                &objectAttributes,
                &ioStatusBlock,
                NULL,                               // AllocationSize
                0,                                  // FileAttributes
                0,                                  // ShareAccess
                FILE_CREATE,                        // CreateDisposition
                0,                                  // CreateOptions
                eaBuffer,
                FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +
                            ea->EaNameLength + 1 + ea->EaValueLength,
                CreateFileTypeNone,                 // CreateFileType
                NULL,                               // ExtraCreateParameters
                IO_NO_PARAMETER_CHECKING            // Options
                );

    if ( NT_SUCCESS(status) ) {
        status = ioStatusBlock.Status;
    }
    if ( !NT_SUCCESS(status) ) {
        DEREFERENCE_CONNECTION( connection );
        return status;
    }

#if DBG
    {
        NTSTATUS    status1;
        OBJECT_HANDLE_FLAG_INFORMATION  handleInfo;
        handleInfo.Inherit = FALSE;
        handleInfo.ProtectFromClose = TRUE;
        status1 = ZwSetInformationObject (
                        connection->Handle,
                        ObjectHandleFlagInformation,
                        &handleInfo,
                        sizeof (handleInfo)
                        );
        ASSERT (NT_SUCCESS (status1));
    }
#endif
    AfdRecordConnOpened();

    //
    // Reference the connection's file object.
    //

    status = ObReferenceObjectByHandle(
                connection->Handle,
                0,
                (POBJECT_TYPE) NULL,
                KernelMode,
                (PVOID *)&connection->FileObject,
                NULL
                );

    ASSERT( NT_SUCCESS(status) );


    IF_DEBUG(OPEN_CLOSE) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
            "AfdCreateConnection: file object for connection %p at %p\n",
            connection, connection->FileObject ));
    }

    AfdRecordConnRef();

    //
    // Remember the device object to which we need to give requests for
    // this connection object.  We can't just use the
    // fileObject->DeviceObject pointer because there may be a device
    // attached to the transport protocol.
    //

    connection->DeviceObject =
        IoGetRelatedDeviceObject( connection->FileObject );

#ifdef _AFD_VARIABLE_STACK_
    if (connection->DeviceObject->StackSize!=TransportInfo->StackSize &&
            connection->DeviceObject->StackSize > AfdTdiStackSize) {
        AfdFixTransportEntryPointsForBigStackSize (
                        TransportInfo,
                        connection->DeviceObject->StackSize);
    }
#endif // _AFD_VARIABLE_STACK_
    //
    // Associate the connection with the address object on the endpoint if
    // an address handle was specified.
    //

    if ( AddressHandle != NULL ) {

        TDI_REQUEST_KERNEL_ASSOCIATE associateRequest;

        associateRequest.AddressHandle = AddressHandle;

        status = AfdIssueDeviceControl(
                    connection->FileObject,
                    &associateRequest,
                    sizeof (associateRequest),
                    NULL,
                    0,
                    TDI_ASSOCIATE_ADDRESS
                    );
        if ( !NT_SUCCESS(status) ) {
            DEREFERENCE_CONNECTION( connection );
            return status;
        }
    }

    //
    // If requested, set the connection to be inline.
    //

    if ( InLine ) {
        status = AfdSetInLineMode( connection, TRUE );
        if ( !NT_SUCCESS(status) ) {
            DEREFERENCE_CONNECTION( connection );
            return status;
        }
    }

    //
    // Set up the connection pointer and return.
    //

    *Connection = connection;

    UPDATE_CONN2( connection, "Connection object handle: 0x%lX", HandleToUlong (connection->Handle));

    return STATUS_SUCCESS;

} // AfdCreateConnection


VOID
AfdFreeConnection (
    IN PVOID Context
    )
{
    PAFD_CONNECTION connection;
    PAFD_ENDPOINT   listenEndpoint;

    PAGED_CODE( );

    InterlockedDecrement (&AfdConnectionsFreeing);
    ASSERT( Context != NULL );

    connection = CONTAINING_RECORD(
                     Context,
                     AFD_CONNECTION,
                     WorkItem
                     );

    if (connection->Endpoint != NULL &&
             !CONNECTION_REUSE_DISABLED &&
             (!connection->AbortFailed || connection->AbortIndicated) &&
             !connection->Endpoint->EndpointCleanedUp &&
             connection->Endpoint->Type == AfdBlockTypeVcConnecting &&
             (listenEndpoint=connection->Endpoint->Common.VcConnecting.ListenEndpoint) != NULL &&
             -listenEndpoint->Common.VcListening.FailedConnectionAdds <
                    listenEndpoint->Common.VcListening.MaxExtraConnections &&
             (IS_DELAYED_ACCEPTANCE_ENDPOINT (listenEndpoint) ||
                ExQueryDepthSList (
                    &listenEndpoint->Common.VcListening.FreeConnectionListHead)
                        < AFD_MAXIMUM_FREE_CONNECTIONS ) ) {

        AfdRefreshConnection (connection);
    }
    else {
        AfdFreeConnectionResources (connection);

        //
        // Free the space that holds the connection itself.
        //

        IF_DEBUG(CONNECTION) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdFreeConnection: Freeing connection at %p\n", 
                        connection ));
        }

        connection->Type = AfdBlockTypeInvalidConnection;

        AFD_FREE_POOL(
            connection,
            AFD_CONNECTION_POOL_TAG
            );
    }

} // AfdFreeConnection


PAFD_CONNECTION
AfdReuseConnection (
    ) {
    PAFD_CONNECTION connection;
    PAFD_ENDPOINT   listenEndpoint;
    PVOID           Context;

    PAGED_CODE( );

    while ((Context = AfdGetWorkerByRoutine (AfdFreeConnection))!=NULL) {
        connection = CONTAINING_RECORD(
                   Context,
                   AFD_CONNECTION,
                   WorkItem
                   );
        if (connection->Endpoint != NULL &&
                 !CONNECTION_REUSE_DISABLED &&
                 (!connection->AbortFailed || connection->AbortIndicated) &&
                 !connection->Endpoint->EndpointCleanedUp &&
                 connection->Endpoint->Type == AfdBlockTypeVcConnecting &&
                 (listenEndpoint=connection->Endpoint->Common.VcConnecting.ListenEndpoint) != NULL &&
                 -listenEndpoint->Common.VcListening.FailedConnectionAdds <
                        listenEndpoint->Common.VcListening.MaxExtraConnections &&
                 (IS_DELAYED_ACCEPTANCE_ENDPOINT (listenEndpoint) ||
                    ExQueryDepthSList (
                        &listenEndpoint->Common.VcListening.FreeConnectionListHead)
                            < AFD_MAXIMUM_FREE_CONNECTIONS ) ) {
            AfdRefreshConnection (connection);
        }
        else {
            AfdFreeConnectionResources (connection);
            return connection;
        }
    }

    return NULL;
}


VOID
AfdFreeNPConnectionResources (
    PAFD_CONNECTION connection
    )
{

    if ( !connection->TdiBufferring && connection->VcDisconnectIrp != NULL ) {
        IoFreeIrp( connection->VcDisconnectIrp );
        connection->VcDisconnectIrp = NULL;
    }

    if ( connection->ConnectDataBuffers != NULL ) {
        AfdFreeConnectDataBuffers( connection->ConnectDataBuffers );
        connection->ConnectDataBuffers = NULL;
    }

    //
    // If this is a bufferring connection, remove all the AFD buffers
    // from the connection's lists and free them.
    //

    if ( !connection->TdiBufferring ) {

        PAFD_BUFFER_HEADER  afdBuffer;

        PLIST_ENTRY         listEntry;

        ASSERT( IsListEmpty( &connection->VcReceiveIrpListHead ) );
        ASSERT( IsListEmpty( &connection->VcSendIrpListHead ) );

        while ( !IsListEmpty( &connection->VcReceiveBufferListHead  ) ) {

            listEntry = RemoveHeadList( &connection->VcReceiveBufferListHead );
            afdBuffer = CONTAINING_RECORD( listEntry, AFD_BUFFER_HEADER, BufferListEntry );
            ASSERT (afdBuffer->RefCount == 1);

            afdBuffer->ExpeditedData = FALSE;

            AfdReturnBuffer( afdBuffer, connection->OwningProcess );
        }
    }

    if ( connection->Endpoint != NULL ) {

        //
        // If there is a transmit file IRP on the endpoint, complete it.
        //

        if ( connection->ClosePendedTransmit ) {
            AfdCompleteClosePendedTPackets( connection->Endpoint );
        }

        DEREFERENCE_ENDPOINT( connection->Endpoint );
        connection->Endpoint = NULL;
    }
}


VOID
AfdRefreshConnection (
    PAFD_CONNECTION connection
    )
{
    PAFD_ENDPOINT listeningEndpoint;

    ASSERT( connection->ReferenceCount == 0 );
    ASSERT( connection->Type == AfdBlockTypeConnection );
    ASSERT( connection->OnLRList == FALSE );

    UPDATE_CONN( connection);

    //
    // Reference the listening endpoint so that it does not
    // go away while we are cleaning up this connection object
    // for reuse.  Note that we actually have an implicit reference
    // to the listening endpoint through the connection's endpoint
    //

    listeningEndpoint = connection->Endpoint->Common.VcConnecting.ListenEndpoint;

#if REFERENCE_DEBUG
    {
        BOOLEAN res;
        CHECK_REFERENCE_ENDPOINT (listeningEndpoint, res);
        ASSERT (res);
    }
#else
    REFERENCE_ENDPOINT( listeningEndpoint );
#endif

    ASSERT( listeningEndpoint->Type == AfdBlockTypeVcListening ||
            listeningEndpoint->Type == AfdBlockTypeVcBoth );

    AfdFreeNPConnectionResources (connection);


    //
    // Reinitialize various fields in the connection object.
    //

    connection->ReferenceCount = 1;
    ASSERT( connection->Type == AfdBlockTypeConnection );
    connection->State = AfdConnectionStateFree;

    connection->ConnectionStateFlags = 0;

    connection->TdiBufferring = IS_TDI_BUFFERRING (listeningEndpoint);
    if ( !connection->TdiBufferring ) {

        ASSERT( IsListEmpty( &connection->VcReceiveIrpListHead ) );
        ASSERT( IsListEmpty( &connection->VcSendIrpListHead ) );
        ASSERT( IsListEmpty( &connection->VcReceiveBufferListHead ) );

        connection->VcBufferredReceiveBytes = 0;
        connection->VcBufferredExpeditedBytes = 0;
        connection->VcBufferredReceiveCount = 0;
        connection->VcBufferredExpeditedCount = 0;

        connection->VcReceiveBytesInTransport = 0;
#if DBG
        connection->VcReceiveIrpsInTransport = 0;
#endif

        connection->VcBufferredSendBytes = 0;
        connection->VcBufferredSendCount = 0;

    } else {

        connection->VcNonBlockingSendPossible = TRUE;
        connection->VcZeroByteReceiveIndicated = FALSE;
    }

    if (IS_DELAYED_ACCEPTANCE_ENDPOINT (listeningEndpoint)) {
        NTSTATUS    status;
        status = AfdDelayedAcceptListen (listeningEndpoint, connection);
        if (NT_SUCCESS (status)) {
            //
            // Reduce the count of failed connection adds on the listening
            // endpoint to account for this connection object which we're
            // adding back onto the queue.
            //

            InterlockedDecrement(
                &listeningEndpoint->Common.VcListening.FailedConnectionAdds
                );

            AfdRecordConnectionsReused ();
        }
        else {
            DEREFERENCE_CONNECTION (connection);
        }
    }
    else {
        //
        // Place the connection on the listening endpoint's list of
        // available connections.
        //

        ASSERT (connection->Endpoint == NULL);
        InterlockedPushEntrySList(
            &listeningEndpoint->Common.VcListening.FreeConnectionListHead,
            &connection->SListEntry);
        //
        // Reduce the count of failed connection adds on the listening
        // endpoint to account for this connection object which we're
        // adding back onto the queue.
        //

        InterlockedDecrement(
            &listeningEndpoint->Common.VcListening.FailedConnectionAdds
            );

        AfdRecordConnectionsReused ();
    }


    //
    // Get rid of the reference we added to the listening endpoint
    // above.
    //

    DEREFERENCE_ENDPOINT( listeningEndpoint );
}


VOID
AfdFreeConnectionResources (
    PAFD_CONNECTION connection
    )
{
    NTSTATUS status;

    PAGED_CODE( );

    ASSERT( connection->ReferenceCount == 0 );
    ASSERT( connection->Type == AfdBlockTypeConnection );
    ASSERT( connection->OnLRList == FALSE );

    UPDATE_CONN( connection );


    //
    // Free and dereference the various objects on the connection.
    // Close and dereference the TDI connection object on the endpoint,
    // if any.
    //

    if ( connection->Handle != NULL ) {


        //
        // Disassociate this connection object from the address object.
        //

        status = AfdIssueDeviceControl(
                    connection->FileObject,
                    NULL,
                    0,
                    NULL,
                    0,
                    TDI_DISASSOCIATE_ADDRESS
                    );
        // ASSERT( NT_SUCCESS(status) );


        //
        // Close the handle.
        //

#if DBG
        {
            NTSTATUS    status1;
            OBJECT_HANDLE_FLAG_INFORMATION  handleInfo;
            handleInfo.Inherit = FALSE;
            handleInfo.ProtectFromClose = FALSE;
            status1 = ZwSetInformationObject (
                            connection->Handle,
                            ObjectHandleFlagInformation,
                            &handleInfo,
                            sizeof (handleInfo)
                            );
            ASSERT (NT_SUCCESS (status1));
        }
#endif
        status = ZwClose( connection->Handle );

#if DBG
        if (!NT_SUCCESS(status) ) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_ERROR_LEVEL,
                "AfdFreeConnectionResources: ZwClose() failed (%lx)\n",
                status));
            ASSERT (FALSE);
        }
#endif
        AfdRecordConnClosed();
    }

    if ( connection->FileObject != NULL ) {

        ObDereferenceObject( connection->FileObject );
        connection->FileObject = NULL;
        AfdRecordConnDeref();

    }
    //
    // Free remaining buffers and return quota charges associated with them.
    //

    AfdFreeNPConnectionResources (connection);

    //
    // Return the quota we charged to this process when we allocated
    // the connection object and buffered data on it.
    //

    PsReturnPoolQuota(
        connection->OwningProcess,
        NonPagedPool,
        sizeof (AFD_CONNECTION)
        );
    AfdRecordQuotaHistory(
        connection->OwningProcess,
        -(LONG)sizeof (AFD_CONNECTION),
        "ConnDealloc ",
        connection
        );
    AfdRecordPoolQuotaReturned(
        sizeof (AFD_CONNECTION)
        );

    //
    // Dereference the process that  got the quota charge.
    //

    ASSERT( connection->OwningProcess != NULL );
    ObDereferenceObject( connection->OwningProcess );
    connection->OwningProcess = NULL;

    if ( connection->RemoteAddress != NULL ) {
        AFD_RETURN_REMOTE_ADDRESS (
            connection->RemoteAddress,
            connection->RemoteAddressLength
            );
        connection->RemoteAddress = NULL;
    }

}


#if REFERENCE_DEBUG
VOID
AfdReferenceConnection (
    IN PAFD_CONNECTION Connection,
    IN LONG  LocationId,
    IN ULONG Param
    )
{

    LONG result;

    ASSERT( Connection->Type == AfdBlockTypeConnection );
    ASSERT( Connection->ReferenceCount > 0 );
    ASSERT( Connection->ReferenceCount != 0xD1000000 );

    IF_DEBUG(CONNECTION) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdReferenceConnection: connection %p, new refcnt %ld\n",
                    Connection, Connection->ReferenceCount+1 ));
    }

    //
    // Do the actual increment of the reference count.
    //

    result = InterlockedIncrement( (PLONG)&Connection->ReferenceCount );

#if REFERENCE_DEBUG
    AFD_UPDATE_REFERENCE_DEBUG(Connection, result, LocationId, Param);
#endif

} // AfdReferenceConnection
#endif


PAFD_CONNECTION
AfdGetConnectionReferenceFromEndpoint (
    PAFD_ENDPOINT   Endpoint
    )
// Why do we need this routine?
// If VC endpoint is in connected state it maintains the referenced
// pointer to the connection object until it is closed (e.g. all references
// to the underlying file object are removed). So checking for connected
// state should be enough in any dispatch routine (or any routine called
// from the dispatch routine) because Irp that used to get to AFD maintains
// a reference to the corresponding file object.
// However, there exist a notable exception from this case: TransmitFile
// can remove the reference to the connection object in the process of endpoint
// reuse.  So, to be 100% safe, it is better to use this routine in all cases.
{
    AFD_LOCK_QUEUE_HANDLE   lockHandle;
    PAFD_CONNECTION connection;

    AfdAcquireSpinLock (&Endpoint->SpinLock, &lockHandle);
    connection = AFD_CONNECTION_FROM_ENDPOINT (Endpoint);
    if (connection!=NULL) {
        REFERENCE_CONNECTION (connection);
    }
    AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);

    return connection;
}


#if REFERENCE_DEBUG
VOID
AfdDereferenceConnection (
    IN PAFD_CONNECTION Connection,
    IN LONG  LocationId,
    IN ULONG Param
    )
{
    LONG result;
    PAFD_ENDPOINT   listenEndpoint;

    ASSERT( Connection->Type == AfdBlockTypeConnection );
    ASSERT( Connection->ReferenceCount > 0 );
    ASSERT( Connection->ReferenceCount != 0xD1000000 );

    IF_DEBUG(CONNECTION) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdDereferenceConnection: connection %p, new refcnt %ld\n",
                    Connection, Connection->ReferenceCount-1 ));
    }

    //
    // Note that if we're tracking refcnts, we *must* call
    // AfdUpdateConnectionTrack before doing the dereference.  This is
    // because the connection object might go away in another thread as
    // soon as we do the dereference.  However, because of this,
    // the refcnt we store with this may sometimes be incorrect.
    //

    AFD_UPDATE_REFERENCE_DEBUG(Connection, Connection->ReferenceCount-1, LocationId, Param);
    
    //
    // We must hold AfdSpinLock while doing the dereference and check
    // for free.  This is because some code makes the assumption that
    // the connection structure will not go away while AfdSpinLock is
    // held, and that code references the endpoint before releasing
    // AfdSpinLock.  If we did the InterlockedDecrement() without the
    // lock held, our count may go to zero, that code may reference the
    // connection, and then a double free might occur.
    //
    // There is no such code anymore. The endpoint spinlock is now
    // held when getting a connection from endpoint structure.
    // Other code uses InterlockedCompareExchange to never increment
    // connection reference if it is at 0.
    //
    //

    result = InterlockedDecrement( (PLONG)&Connection->ReferenceCount );

    //
    // If the reference count is now 0, free the connection in an
    // executive worker thread.
    //

    if ( result == 0 ) {
#else
VOID
AfdCloseConnection (
    IN PAFD_CONNECTION Connection
    )
{
    PAFD_ENDPOINT   listenEndpoint;
#endif

    if (Connection->Endpoint != NULL &&
             !CONNECTION_REUSE_DISABLED &&
             (!Connection->AbortFailed || Connection->AbortIndicated) &&
             !Connection->Endpoint->EndpointCleanedUp &&
             Connection->Endpoint->Type == AfdBlockTypeVcConnecting &&
             (listenEndpoint=Connection->Endpoint->Common.VcConnecting.ListenEndpoint) != NULL &&
             -listenEndpoint->Common.VcListening.FailedConnectionAdds <
                    listenEndpoint->Common.VcListening.MaxExtraConnections &&
             (IS_DELAYED_ACCEPTANCE_ENDPOINT (listenEndpoint) ||
                ExQueryDepthSList (
                    &listenEndpoint->Common.VcListening.FreeConnectionListHead)
                        < AFD_MAXIMUM_FREE_CONNECTIONS ) ) {

        AfdRefreshConnection (Connection);
    }
    else {
        InterlockedIncrement (&AfdConnectionsFreeing);
        //
        // We're going to do this by queueing a request to an executive
        // worker thread.  We do this for several reasons: to ensure
        // that we're at IRQL 0 so we can free pageable memory, and to
        // ensure that we're in a legitimate context for a close
        // operation
        //

        AfdQueueWorkItem(
            AfdFreeConnection,
            &Connection->WorkItem
            );
    }
#if REFERENCE_DEBUG
    }
} // AfdDereferenceConnection
#else
} // AfdCloseConnection
#endif



#if REFERENCE_DEBUG
BOOLEAN
AfdCheckAndReferenceConnection (
    PAFD_CONNECTION     Connection,
    IN LONG  LocationId,
    IN ULONG Param
    )
#else
BOOLEAN
AfdCheckAndReferenceConnection (
    PAFD_CONNECTION     Connection
    )
#endif
{
    LONG            result;

    do {
        result = Connection->ReferenceCount;
        if (result<=0) {
            result = 0;
            break;
        }
    }
    while (InterlockedCompareExchange ((PLONG)&Connection->ReferenceCount,
                                                (result+1),
                                                result)!=result);

    if (result>0) {
#if REFERENCE_DEBUG
        AFD_UPDATE_REFERENCE_DEBUG(Connection, result+1, LocationId, Param);
#endif
        ASSERT( result < 0xFFFF );
        return TRUE;
    }
    else {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_ERROR_LEVEL,
                    "AfdCheckAndReferenceConnection: Connection %p is gone (refcount: %ld!\n",
                    Connection, result));
        return FALSE;
    }
}

PAFD_CONNECTION
AfdGetFreeConnection (
    IN  PAFD_ENDPOINT   Endpoint,
    OUT PIRP            *Irp
    )

/*++

Routine Description:

    Takes a connection off of the endpoint's queue of listening
    connections.

Arguments:

    Endpoint - a pointer to the endpoint from which to get a connection.
    Irp     - place to return a super accept IRP if we have any

Return Value:

    AFD_CONNECTION - a pointer to an AFD connection block.

--*/

{
    PAFD_CONNECTION connection;
    PSLIST_ENTRY listEntry;
    PIRP    irp;

    ASSERT( Endpoint->Type == AfdBlockTypeVcListening ||
            Endpoint->Type == AfdBlockTypeVcBoth );


    //
    // First try pre-accepted connections
    //

    while ((listEntry = InterlockedPopEntrySList (
                 &Endpoint->Common.VcListening.PreacceptedConnectionsListHead
                 ))!=NULL) {


        //
        // Find the connection pointer from the list entry and return a
        // pointer to the connection object.
        //

        connection = CONTAINING_RECORD(
                         listEntry,
                         AFD_CONNECTION,
                         SListEntry
                         );

        //
        // Check if super accept Irp has not been cancelled
        //
        irp = InterlockedExchangePointer ((PVOID *)&connection->AcceptIrp, NULL);
        if ((irp!=NULL) && (IoSetCancelRoutine (irp, NULL)!=NULL)) {
            //
            // Return the IRP to the caller along with the connection.
            //
            *Irp = irp;
            return connection;
        }

        //
        // Irp has been or is about to be cancelled
        //
        if (irp!=NULL) {
            KIRQL   cancelIrql;

            //
            // Cleanup and cancel the super accept IRP.
            //
            AfdCleanupSuperAccept (irp, STATUS_CANCELLED);

            //
            // The cancel routine won't find the IRP in the connection,
            // so we need to cancel it ourselves.  Just make sure that
            // the cancel routine is done before doing so.
            //
            IoAcquireCancelSpinLock (&cancelIrql);
            IoReleaseCancelSpinLock (cancelIrql);

            IoCompleteRequest (irp, AfdPriorityBoost);
        }

        //
        // This connection has already been diassociated from endpoint.
        // If backlog is below the level we need, put it on the free
        // list, otherwise, get rid of it.
        //

        ASSERT (connection->Endpoint==NULL);
        if (Endpoint->Common.VcListening.FailedConnectionAdds>=0 &&
                ExQueryDepthSList (&Endpoint->Common.VcListening.FreeConnectionListHead)<AFD_MAXIMUM_FREE_CONNECTIONS) {
            InterlockedPushEntrySList (
                            &Endpoint->Common.VcListening.FreeConnectionListHead,
                            &connection->SListEntry);
        }
        else {
            InterlockedIncrement (&Endpoint->Common.VcListening.FailedConnectionAdds);
            DEREFERENCE_CONNECTION (connection);
        }
    }

    //
    // Remove the first entry from the list.  If the list is empty,
    // return NULL.
    //

    listEntry = InterlockedPopEntrySList (
                 &Endpoint->Common.VcListening.FreeConnectionListHead);
    if (listEntry==NULL) {
        return NULL;
    }

    //
    // Find the connection pointer from the list entry and return a
    // pointer to the connection object.
    //

    connection = CONTAINING_RECORD(
                     listEntry,
                     AFD_CONNECTION,
                     SListEntry
                     );

    *Irp = NULL;

    return connection;

} // AfdGetFreeConnection


PAFD_CONNECTION
AfdGetReturnedConnection (
    IN PAFD_ENDPOINT Endpoint,
    IN LONG Sequence
    )

/*++

Routine Description:

    Takes a connection off of the endpoint's queue of returned
    connections.

    *** NOTE: This routine must be called with endpoint spinlock held!!

Arguments:

    Endpoint - a pointer to the endpoint from which to get a connection.

    Sequence - the sequence the connection must match.  If 0, the first returned
        connection is used.

Return Value:

    AFD_CONNECTION - a pointer to an AFD connection block.

--*/

{
    PAFD_CONNECTION connection;
    PLIST_ENTRY listEntry;

    ASSERT( Endpoint->Type == AfdBlockTypeVcListening ||
            Endpoint->Type == AfdBlockTypeVcBoth );
    ASSERT( KeGetCurrentIrql( ) == DISPATCH_LEVEL );


    //
    // Walk the endpoint's list of returned connections until we reach
    // the end or until we find one with a matching sequence.
    //

    for ( listEntry = Endpoint->Common.VcListening.ReturnedConnectionListHead.Flink;
          listEntry != &Endpoint->Common.VcListening.ReturnedConnectionListHead;
          listEntry = listEntry->Flink ) {


        connection = CONTAINING_RECORD(
                         listEntry,
                         AFD_CONNECTION,
                         ListEntry
                         );

        if ( Sequence == connection->Sequence || Sequence == 0 ) {

            //
            // Found the connection we were looking for.  Remove
            // the connection from the list, release the spin lock,
            // and return the connection.
            //

            RemoveEntryList( listEntry );

            return connection;
        }
    }

    return NULL;

} // AfdGetReturnedConnection


PAFD_CONNECTION
AfdFindReturnedConnection(
    IN PAFD_ENDPOINT Endpoint,
    IN LONG Sequence
    )

/*++

Routine Description:

    Scans the endpoints queue of returned connections looking for one
    with the specified sequence number.

Arguments:

    Endpoint - A pointer to the endpoint from which to get a connection.

    Sequence - The sequence the connection must match.

Return Value:

    AFD_CONNECTION - A pointer to an AFD connection block if successful,
        NULL if not.

--*/

{

    PAFD_CONNECTION connection;
    PLIST_ENTRY listEntry;

    ASSERT( Endpoint != NULL );
    ASSERT( IS_AFD_ENDPOINT_TYPE( Endpoint ) );
    ASSERT( KeGetCurrentIrql( ) == DISPATCH_LEVEL );

    //
    // Walk the endpoint's list of returned connections until we reach
    // the end or until we find one with a matching sequence.
    //

    for( listEntry = Endpoint->Common.VcListening.ReturnedConnectionListHead.Flink;
         listEntry != &Endpoint->Common.VcListening.ReturnedConnectionListHead;
         listEntry = listEntry->Flink ) {

        connection = CONTAINING_RECORD(
                         listEntry,
                         AFD_CONNECTION,
                         ListEntry
                         );

        if( Sequence == connection->Sequence ) {

            return connection;

        }

    }

    return NULL;

}   // AfdFindReturnedConnection


PAFD_CONNECTION
AfdGetUnacceptedConnection (
    IN PAFD_ENDPOINT Endpoint
    )

/*++

Routine Description:

    Takes a connection of the endpoint's queue of unaccpted connections.

    *** NOTE: This routine must be called with endpoint spinlock held!!

Arguments:

    Endpoint - a pointer to the endpoint from which to get a connection.

Return Value:

    AFD_CONNECTION - a pointer to an AFD connection block.

--*/

{
    PAFD_CONNECTION connection;
    PLIST_ENTRY listEntry;

    ASSERT( Endpoint->Type == AfdBlockTypeVcListening ||
            Endpoint->Type == AfdBlockTypeVcBoth );
    ASSERT( KeGetCurrentIrql( ) == DISPATCH_LEVEL );

    if ( IsListEmpty( &Endpoint->Common.VcListening.UnacceptedConnectionListHead ) ) {
        return NULL;
    }

    //
    // Dequeue a listening connection and remember its handle.
    //

    listEntry = RemoveHeadList( &Endpoint->Common.VcListening.UnacceptedConnectionListHead );
    connection = CONTAINING_RECORD( listEntry, AFD_CONNECTION, ListEntry );

    return connection;

} // AfdGetUnacceptedConnection



VOID
AfdAddConnectedReference (
    IN PAFD_CONNECTION Connection
    )

/*++

Routine Description:

    Adds the connected reference to an AFD connection block.  The
    connected reference is special because it prevents the connection
    object from being freed until we receive a disconnect event, or know
    through some other means that the virtual circuit is disconnected.

Arguments:

    Connection - a pointer to an AFD connection block.

Return Value:

    None.

--*/

{
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    AfdAcquireSpinLock( &Connection->Endpoint->SpinLock, &lockHandle );

    IF_DEBUG(CONNECTION) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdAddConnectedReference: connection %p, new refcnt %ld\n",
                    Connection, Connection->ReferenceCount+1 ));
    }

    ASSERT( !Connection->ConnectedReferenceAdded );
    ASSERT( Connection->Type == AfdBlockTypeConnection );

    //
    // Increment the reference count and remember that the connected
    // reference has been placed on the connection object.
    //

    Connection->ConnectedReferenceAdded = TRUE;
    AfdRecordConnectedReferencesAdded();

    AfdReleaseSpinLock( &Connection->Endpoint->SpinLock, &lockHandle );

    REFERENCE_CONNECTION( Connection );

} // AfdAddConnectedReference


VOID
AfdDeleteConnectedReference (
    IN PAFD_CONNECTION Connection,
    IN BOOLEAN EndpointLockHeld
    )

/*++

Routine Description:

    Removes the connected reference to an AFD connection block.  If the
    connected reference has already been removed, this routine does
    nothing.  The connected reference should be removed as soon as we
    know that it is OK to close the connection object handle, but not
    before.  Removing this reference too soon could abort a connection
    which shouldn't get aborted.

Arguments:

    Connection - a pointer to an AFD connection block.

    EndpointLockHeld - TRUE if the caller already has the endpoint
      spin lock.  The lock remains held on exit.

Return Value:

    None.

--*/

{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_ENDPOINT endpoint;

    endpoint = Connection->Endpoint;

    if ( !EndpointLockHeld ) {
        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
    }
    else {
#if DBG
        AFD_W4_INIT lockHandle.SpinLock = NULL;
#endif
    }

    //
    // Only do a dereference if the connected reference is still active
    // on the connectiuon object.
    //

    if ( Connection->ConnectedReferenceAdded ) {

        //
        // Three things must be true before we can remove the connected
        // reference:
        //
        // 1) There must be no sends outstanding on the connection if
        //    the TDI provider does not support bufferring.  This is
        //    because AfdRestartBufferSend() looks at the connection
        //    object.
        //
        // 2) Cleanup must have started on the endpoint.  Until we get a
        //    cleanup IRP on the endpoint, we could still get new sends.
        //
        // 3) We have been indicated with a disconnect on the
        //    connection.  We want to keep the connection object around
        //    until we get a disconnect indication in order to avoid
        //    premature closes on the connection object resulting in an
        //    unintended abort.  If the transport does not support
        //    orderly release, then this condition is not necessary.
        //

        if ( (Connection->TdiBufferring ||
                 Connection->VcBufferredSendCount == 0)

                 &&

             Connection->CleanupBegun

                 &&

             (Connection->Aborted || Connection->DisconnectIndicated ||
                  !IS_TDI_ORDERLY_RELEASE(endpoint) ||
                  IS_CROOT_ENDPOINT(endpoint)) ) {

            IF_DEBUG(CONNECTION) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdDeleteConnectedReference: connection %p, new refcnt %ld\n",
                              Connection, Connection->ReferenceCount-1 ));
            }

            //
            // Be careful about the order of things here.  We must FIRST
            // reset the flag, then release the spin lock and call
            // AfdDereferenceConnection().  Note that it is illegal to
            // call AfdDereferenceConnection() with a spin lock held.
            //

            Connection->ConnectedReferenceAdded = FALSE;
            AfdRecordConnectedReferencesDeleted();

            if ( !EndpointLockHeld ) {
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            }

            DEREFERENCE_CONNECTION( Connection );

        } else {

            IF_DEBUG(CONNECTION) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdDeleteConnectedReference: connection %p, %ld sends pending\n",
                            Connection, Connection->VcBufferredSendCount ));
            }

            UPDATE_CONN2( Connection, "Not removing cref, state flags: 0x%lX",
                                                Connection->ConnectionStateFlags);
            //
            // Remember that the connected reference deletion is still
            // pending, i.e.  there is a special condition on the
            // endpoint.  This will cause AfdRestartBufferSend() to do
            // the actual dereference when the last send completes.
            //

            Connection->SpecialCondition = TRUE;

            if ( !EndpointLockHeld ) {
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            }
        }

    } else {

        IF_DEBUG(CONNECTION) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdDeleteConnectedReference: already removed on  connection %p, refcnt %ld\n",
                        Connection, Connection->ReferenceCount ));
        }

        if ( !EndpointLockHeld ) {
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        }
    }

    return;

} // AfdDeleteConnectedReference


#if REFERENCE_DEBUG


VOID
AfdUpdateConnectionTrack (
    IN PAFD_CONNECTION Connection,
    IN LONG  LocationId,
    IN ULONG Param
    )
{
    AFD_UPDATE_REFERENCE_DEBUG (Connection, Connection->ReferenceCount, LocationId, Param);

#if GLOBAL_REFERENCE_DEBUG
    {
        PAFD_GLOBAL_REFERENCE_DEBUG globalSlot;

        newSlot = InterlockedIncrement( &AfdGlobalReferenceSlot );
        globalSlot = &AfdGlobalReference[newSlot % MAX_GLOBAL_REFERENCE];

        globalSlot->Info1 = Info1;
        globalSlot->Info2 = Info2;
        globalSlot->Action = Action;
        globalSlot->NewCount = NewReferenceCount;
        globalSlot->Connection = Connection;
        KeQueryTickCount( &globalSlot->TickCounter );
    }
#endif

} // AfdUpdateConnectionTrack

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\connect.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    connect.c

Abstract:

    This module contains the code for passing on connect IRPs to
    TDI providers.

Author:

    David Treadwell (davidtr)    2-Mar-1992

Revision History:

    Vadim Eydelman (vadime) 1999  JoinLeaf implementation
                                    Datagram connect via transport
                                    Connect optimizations and syncronization with
                                    user mode code.

--*/

#include "afdp.h"

NTSTATUS
AfdDoDatagramConnect (
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN BOOLEAN HalfConnect
    );

NTSTATUS
AfdRestartConnect (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdRestartDgConnect (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
AfdSetupConnectDataBuffers (
    IN PAFD_ENDPOINT Endpoint,
    IN PAFD_CONNECTION Connection,
    IN OUT PTDI_CONNECTION_INFORMATION *RequestConnectionInformation,
    IN OUT PTDI_CONNECTION_INFORMATION *ReturnConnectionInformation
    );

BOOLEAN
AfdConnectionStart (
    IN PAFD_ENDPOINT Endpoint
    );

VOID
AfdEnableFailedConnectEvent(
    IN PAFD_ENDPOINT Endpoint
    );


NTSTATUS
AfdRestartJoin (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
AfdJoinInviteSetup (
    PAFD_ENDPOINT   RootEndpoint,
    PAFD_ENDPOINT   LeafEndpoint
    );

VOID
AfdConnectApcKernelRoutine (
    IN struct _KAPC         *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID            *NormalContext,
    IN OUT PVOID            *SystemArgument1,
    IN OUT PVOID            *SystemArgument2
    );

VOID
AfdConnectApcRundownRoutine (
    IN struct _KAPC *Apc
    );

VOID
AfdFinishConnect (
    PAFD_ENDPOINT   Endpoint,
    PIRP            Irp,
    PAFD_ENDPOINT   RootEndpoint
    );

NTSTATUS
AfdRestartSuperConnect (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfdConnect )
#pragma alloc_text( PAGEAFD, AfdDoDatagramConnect )
#pragma alloc_text( PAGEAFD, AfdRestartConnect )
#pragma alloc_text( PAGEAFD, AfdRestartDgConnect )
#pragma alloc_text( PAGEAFD, AfdSetupConnectDataBuffers )
#pragma alloc_text( PAGEAFD, AfdEnableFailedConnectEvent )
#pragma alloc_text( PAGE, AfdJoinLeaf )
#pragma alloc_text( PAGEAFD, AfdRestartJoin )
#pragma alloc_text( PAGEAFD, AfdJoinInviteSetup )
#pragma alloc_text( PAGE, AfdConnectApcKernelRoutine )
#pragma alloc_text( PAGE, AfdConnectApcRundownRoutine )
#pragma alloc_text( PAGEAFD, AfdFinishConnect )
#pragma alloc_text( PAGE, AfdSuperConnect )
#pragma alloc_text( PAGEAFD, AfdRestartSuperConnect )
#endif

typedef struct _AFD_CONNECT_CONTEXT {
    TDI_CONNECTION_INFORMATION  RequestConnectionInfo;
    TDI_CONNECTION_INFORMATION  ReturnConnectionInfo;
    TRANSPORT_ADDRESS           RemoteAddress;
} AFD_CONNECT_CONTEXT, *PAFD_CONNECT_CONTEXT;

C_ASSERT ( (FIELD_OFFSET (AFD_CONNECTION, SListEntry) % MEMORY_ALLOCATION_ALIGNMENT) == 0 );

NTSTATUS
FASTCALL
AfdConnect (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Handles the IOCTL_AFD_CONNECT IOCTL.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    NTSTATUS status;
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    PAFD_CONNECT_CONTEXT context;
    HANDLE connectEndpointHandle;
    PFILE_OBJECT fileObject;
    PTRANSPORT_ADDRESS remoteAddress;
    ULONG  remoteAddressLength;
    BOOLEAN sanActive;
    PTDI_CONNECTION_INFORMATION requestConnectionInfo, returnConnectionInfo;

    PAGED_CODE( );

    //
    // Initialize for proper cleanup
    //


    fileObject = NULL;
    context = NULL;

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<
                    (ULONG)FIELD_OFFSET(AFD_CONNECT_JOIN_INFO32, RemoteAddress.Address[0].Address) ||
                (IrpSp->Parameters.DeviceIoControl.OutputBufferLength!=0
                    && IrpSp->Parameters.DeviceIoControl.OutputBufferLength<
                        sizeof (IO_STATUS_BLOCK32))){
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }
        AFD_W4_INIT status = STATUS_SUCCESS;
        try {
            if( Irp->RequestorMode != KernelMode ) {

                ProbeForRead(
                    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                    IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                    PROBE_ALIGNMENT32 (AFD_CONNECT_JOIN_INFO32)
                    );

            }

            sanActive = ((PAFD_CONNECT_JOIN_INFO32)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer)->SanActive;
            connectEndpointHandle = 
                ((PAFD_CONNECT_JOIN_INFO32)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer)->ConnectEndpoint;
            remoteAddress = (PTRANSPORT_ADDRESS)
                &((PAFD_CONNECT_JOIN_INFO32)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer)->RemoteAddress;
            ASSERT (((ULONG_PTR)remoteAddress & (PROBE_ALIGNMENT(TRANSPORT_ADDRESS)-1))==0);
            remoteAddressLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength
                                    - FIELD_OFFSET (AFD_CONNECT_JOIN_INFO32, RemoteAddress);
        }
        except (AFD_EXCEPTION_FILTER (status)) {
            ASSERT (NT_ERROR (status));
            goto complete;
        }
    }
    else 
#endif //_WIN64
    {

        //
        // Determine where in the system buffer the request and return
        // connection information structures exist.  Pass pointers to
        // these locations instead of the user-mode pointers in the
        // tdiRequest structure so that the memory will be nonpageable.
        //

        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<
                (ULONG)FIELD_OFFSET(AFD_CONNECT_JOIN_INFO, RemoteAddress.Address[0].Address) ||
                (IrpSp->Parameters.DeviceIoControl.OutputBufferLength!=0 &&
                    IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                        sizeof (IO_STATUS_BLOCK))) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }
        AFD_W4_INIT status = STATUS_SUCCESS;
        try {
            PAFD_CONNECT_JOIN_INFO  connectInfo;

            if( Irp->RequestorMode != KernelMode ) {

                ProbeForRead(
                    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                    IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                    PROBE_ALIGNMENT (AFD_CONNECT_JOIN_INFO)
                    );

            }

            connectInfo = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

            sanActive = connectInfo->SanActive;
            connectEndpointHandle = connectInfo->ConnectEndpoint;
            remoteAddress = &connectInfo->RemoteAddress;
            remoteAddressLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength
                                    - FIELD_OFFSET (AFD_CONNECT_JOIN_INFO, RemoteAddress);
        }
        except (AFD_EXCEPTION_FILTER (status)) {
            ASSERT (NT_ERROR (status));
            goto complete;
        }
    }

    //
    // Do sanity check on remoteAddressLength to prevent addition overflow below
    //
    if ((LONG)remoteAddressLength < 0) {
        //
        // address length is unreasonably large
        //
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    //
    // Check for if the caller is unaware of the SAN
    // provider activation and report the error.
    //
    if (!sanActive && AfdSanServiceHelper!=NULL) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AFD: Process %p is being told to enable SAN on connect\n",
                    PsGetCurrentProcessId ()));
        status = STATUS_INVALID_PARAMETER_12;
        goto complete;
    }

    AFD_W4_INIT ASSERT (status == STATUS_SUCCESS);
    try {

        context = AFD_ALLOCATE_POOL_WITH_QUOTA (NonPagedPool,
                            FIELD_OFFSET (AFD_CONNECT_CONTEXT, RemoteAddress)
                                + remoteAddressLength,
                            AFD_TDI_POOL_TAG
                            );
        // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets POOL_RAISE_IF_ALLOCATION_FAILURE flag
        ASSERT (context!=NULL);

        Irp->AssociatedIrp.SystemBuffer = context;
        RtlZeroMemory (context,
              FIELD_OFFSET (AFD_CONNECT_CONTEXT, RemoteAddress));

        RtlCopyMemory (&context->RemoteAddress,
                remoteAddress,
                remoteAddressLength);
        //
        // Validate internal consistency of the transport address structure.
        // Note that we HAVE to do this after copying since the malicious
        // application can change the content of the buffer on us any time
        // and our check will be bypassed.
        //
        if ((context->RemoteAddress.TAAddressCount!=1) ||
                (LONG)remoteAddressLength<
                    FIELD_OFFSET (TRANSPORT_ADDRESS,
                        Address[0].Address[context->RemoteAddress.Address[0].AddressLength])) {
            ExRaiseStatus (STATUS_INVALID_PARAMETER);
        }

        context->RequestConnectionInfo.RemoteAddress = &context->RemoteAddress;
        context->RequestConnectionInfo.RemoteAddressLength = remoteAddressLength;

    
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength>0 && 
                Irp->RequestorMode==UserMode) {
            ProbeForWriteIoStatusEx (
                ((PIO_STATUS_BLOCK)Irp->UserBuffer),
                IoIs32bitProcess (Irp));
        }
    }
    except (AFD_EXCEPTION_FILTER(status)) {
        ASSERT (NT_ERROR (status));
        goto complete;
    }

    fileObject = IrpSp->FileObject;
    endpoint = fileObject->FsContext;

    if (endpoint->Type==AfdBlockTypeHelper) {
        //
        // This is async connect which uses helper endpoint to
        // communicate to AFD. Get the real endpoint.
        //
        status = ObReferenceObjectByHandle(
                    connectEndpointHandle,
                    (IrpSp->Parameters.DeviceIoControl.IoControlCode>>14) & 3,
                                                // DesiredAccess
                    *IoFileObjectType,          // ObjectType
                    Irp->RequestorMode,
                    (PVOID *)&fileObject,
                    NULL
                    );
        if (!NT_SUCCESS (status)) {
            goto complete;
        }

        if (fileObject->DeviceObject!=AfdDeviceObject) {
            status = STATUS_INVALID_HANDLE;
            goto complete_deref;
        }
        endpoint = fileObject->FsContext;
        IrpSp->FileObject = fileObject;
    }
    else {
        ObReferenceObject (fileObject);
    }

    IF_DEBUG(CONNECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdConnect: starting connect on endpoint %p\n",
                    endpoint ));
    }

    //
    // If this is a datagram endpoint, simply remember the specified
    // address so that we can use it on sends, receives, writes, and
    // reads.
    //

    if ( IS_DGRAM_ENDPOINT(endpoint) ) {
        return AfdDoDatagramConnect( fileObject, Irp, FALSE );
    }

    if (!AFD_START_STATE_CHANGE (endpoint, AfdEndpointStateConnected)) {
        status = STATUS_INVALID_PARAMETER;
        goto complete_deref;
    }

    if ( endpoint->Type != AfdBlockTypeEndpoint &&
                endpoint->Type != AfdBlockTypeVcConnecting ) {
        status = STATUS_INVALID_PARAMETER;
        goto complete_state_change;
    }

    //
    // If the endpoint is not bound, then this is an invalid request.
    // Listening endpoints are not allowed as well.
    //

    if ( endpoint->Listening ||
            endpoint->State != AfdEndpointStateBound ) {
        status = STATUS_INVALID_PARAMETER;
        goto complete_state_change;
    }

    //
    // Create a connection object to use for the connect operation.
    //

    status = AfdCreateConnection(
                 endpoint->TransportInfo,
                 endpoint->AddressHandle,
                 IS_TDI_BUFFERRING(endpoint),
                 endpoint->InLine,
                 endpoint->OwningProcess,
                 &connection
                 );

    if ( !NT_SUCCESS(status) ) {
        goto complete_state_change;
    }

    //
    // Set up a referenced pointer from the connection to the endpoint.
    // Note that we set up the connection's pointer to the endpoint
    // BEFORE the endpoint's pointer to the connection so that AfdPoll
    // doesn't try to back reference the endpoint from the connection.
    //

    REFERENCE_ENDPOINT( endpoint );
    connection->Endpoint = endpoint;

    //
    // Remember that this is now a connecting type of endpoint, and set
    // up a pointer to the connection in the endpoint.  This is
    // implicitly a referenced pointer.
    //

    endpoint->Common.VcConnecting.Connection = connection;
    endpoint->Type = AfdBlockTypeVcConnecting;

    ASSERT( IS_TDI_BUFFERRING(endpoint) == connection->TdiBufferring );

    //
    // Add an additional reference to the connection.  This prevents the
    // connection from being closed until the disconnect event handler
    // is called.
    //

    AfdAddConnectedReference( connection );

    //
    // If there are connect data buffers, move them from the endpoint
    // structure to the connection structure and set up the necessary
    // pointers in the connection request we're going to give to the TDI
    // provider.  Do this in a subroutine so this routine can be pageable.
    //

    requestConnectionInfo = &context->RequestConnectionInfo;
    returnConnectionInfo = &context->ReturnConnectionInfo;

    if ( endpoint->Common.VirtualCircuit.ConnectDataBuffers != NULL ) {
        AfdSetupConnectDataBuffers(
            endpoint,
            connection,
            &requestConnectionInfo,
            &returnConnectionInfo
            );
    }


    //
    // Since we may be reissuing a connect after a previous failed connect,
    // reenable the failed connect event bit.
    //

    AfdEnableFailedConnectEvent( endpoint );


    //
    // Reference the connection block so it does not go away even if
    // endpoint's reference to it is removed (in cleanup)
    //

    REFERENCE_CONNECTION (connection);

    //
    // Build a TDI kernel-mode connect request in the next stack location
    // of the IRP.
    //

    TdiBuildConnect(
        Irp,
        connection->DeviceObject,
        connection->FileObject,
        AfdRestartConnect,
        connection,
        &AfdInfiniteTimeout,
        requestConnectionInfo,
        returnConnectionInfo
        );



    AFD_VERIFY_ADDRESS (connection, &requestConnectionInfo->RemoteAddress);
    //
    // Call the transport to actually perform the connect operation.
    //

    return AfdIoCallDriver( endpoint, connection->DeviceObject, Irp );

complete_state_change:
    AFD_END_STATE_CHANGE (endpoint);

complete_deref:
    ASSERT (fileObject!=NULL);
    ObDereferenceObject (fileObject);

complete:

    if (context!=NULL) {
        AFD_FREE_POOL (context, AFD_TDI_POOL_TAG);
        ASSERT (Irp->AssociatedIrp.SystemBuffer==context);
        Irp->AssociatedIrp.SystemBuffer = NULL;
    }

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

} // AfdConnect


NTSTATUS
AfdDoDatagramConnect (
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN BOOLEAN HalfConnect
    )
{
    PAFD_ENDPOINT   endpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    NTSTATUS status;
    PAFD_CONNECT_CONTEXT context;

    endpoint = FileObject->FsContext;
    context = Irp->AssociatedIrp.SystemBuffer;

    if (!AFD_START_STATE_CHANGE (endpoint, AfdEndpointStateConnected)) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    if (endpoint->State!=AfdEndpointStateBound &&
            endpoint->State!=AfdEndpointStateConnected) {
        status = STATUS_INVALID_PARAMETER;
        goto complete_state_change;
    }
            
    //
    // Save the remote address on the endpoint.  We'll use this to
    // send datagrams in the future and to compare received datagram's
    // source addresses.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
    if ((endpoint->Common.Datagram.RemoteAddress==NULL) ||
            (endpoint->Common.Datagram.RemoteAddressLength<
                (ULONG)context->RequestConnectionInfo.RemoteAddressLength)) {
        
        PTRANSPORT_ADDRESS remoteAddress;

        remoteAddress =
            AFD_ALLOCATE_REMOTE_ADDRESS (
                    context->RequestConnectionInfo.RemoteAddressLength);

        if (remoteAddress == NULL) {
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto complete_state_change;
        }            

        if ( endpoint->Common.Datagram.RemoteAddress != NULL ) {
            AFD_RETURN_REMOTE_ADDRESS (
                endpoint->Common.Datagram.RemoteAddress,
                endpoint->Common.Datagram.RemoteAddressLength
                );
        }

        endpoint->Common.Datagram.RemoteAddress = remoteAddress;
    }

    RtlCopyMemory(
        endpoint->Common.Datagram.RemoteAddress,
        context->RequestConnectionInfo.RemoteAddress,
        context->RequestConnectionInfo.RemoteAddressLength
        );

    endpoint->Common.Datagram.RemoteAddressLength =
        context->RequestConnectionInfo.RemoteAddressLength;


    endpoint->DisconnectMode = 0;

    endpoint->Common.Datagram.HalfConnect = HalfConnect;

    if (!IS_TDI_DGRAM_CONNECTION(endpoint)) {
    
        endpoint->State = AfdEndpointStateConnected;

        //
        // Indicate that the connect completed.  Implicitly, the
        // successful completion of a connect also means that the caller
        // can do a send on the socket.
        //

        endpoint->EnableSendEvent = TRUE;
        AfdIndicateEventSelectEvent(
            endpoint,
            AFD_POLL_CONNECT | AFD_POLL_SEND,
            STATUS_SUCCESS
            );
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        AfdIndicatePollEvent(
            endpoint,
            AFD_POLL_CONNECT | AFD_POLL_SEND,
            STATUS_SUCCESS
            );
        status = STATUS_SUCCESS;
    }
    else {

        //
        // Reset the connect status to success so that the poll code will
        // know if a connect failure occurs.
        // Do this inline as we already hold spinlock
        //

        endpoint->EventsActive &= ~AFD_POLL_CONNECT_FAIL;
        endpoint->EventStatus[AFD_POLL_CONNECT_FAIL_BIT] = STATUS_SUCCESS;

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Build a TDI kernel-mode connect request in the next stack location
        // of the IRP.
        //

        TdiBuildConnect(
            Irp,
            endpoint->AddressDeviceObject,
            endpoint->AddressFileObject,
            AfdRestartDgConnect,
            endpoint,
            &AfdInfiniteTimeout,
            &context->RequestConnectionInfo,
            &context->ReturnConnectionInfo
            );

        //
        // Call the transport to actually perform the connect operation.
        //

        return AfdIoCallDriver( endpoint, endpoint->AddressDeviceObject, Irp );
    }

complete_state_change:
    AFD_END_STATE_CHANGE (endpoint);

complete:
    ObDereferenceObject (FileObject);

    AFD_FREE_POOL (context, AFD_TDI_POOL_TAG);
    ASSERT (Irp->AssociatedIrp.SystemBuffer==context);
    Irp->AssociatedIrp.SystemBuffer = NULL;

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

} // AfdDoDatagramConnect


VOID
AfdSetupConnectDataBuffers (
    IN PAFD_ENDPOINT Endpoint,
    IN PAFD_CONNECTION Connection,
    IN OUT PTDI_CONNECTION_INFORMATION *RequestConnectionInformation,
    IN OUT PTDI_CONNECTION_INFORMATION *ReturnConnectionInformation
    )
{
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    ASSERT (Endpoint->Type!=AfdBlockTypeDatagram);

    AfdAcquireSpinLock( &Endpoint->SpinLock, &lockHandle );

    if ( Endpoint->Common.VirtualCircuit.ConnectDataBuffers != NULL ) {
        PTDI_CONNECTION_INFORMATION requestConnectionInformation,
                                    returnConnectionInformation;

        ASSERT( Connection->ConnectDataBuffers == NULL );

        Connection->ConnectDataBuffers = Endpoint->Common.VirtualCircuit.ConnectDataBuffers;
        Endpoint->Common.VirtualCircuit.ConnectDataBuffers = NULL;

        requestConnectionInformation = &Connection->ConnectDataBuffers->RequestConnectionInfo,
        requestConnectionInformation->UserData =
            Connection->ConnectDataBuffers->SendConnectData.Buffer;
        requestConnectionInformation->UserDataLength =
            Connection->ConnectDataBuffers->SendConnectData.BufferLength;
        requestConnectionInformation->Options =
            Connection->ConnectDataBuffers->SendConnectOptions.Buffer;
        requestConnectionInformation->OptionsLength =
            Connection->ConnectDataBuffers->SendConnectOptions.BufferLength;
        requestConnectionInformation->RemoteAddress = 
            (*RequestConnectionInformation)->RemoteAddress;
        requestConnectionInformation->RemoteAddressLength = 
            (*RequestConnectionInformation)->RemoteAddressLength;
        *RequestConnectionInformation = requestConnectionInformation;

        returnConnectionInformation = &Connection->ConnectDataBuffers->ReturnConnectionInfo;
        returnConnectionInformation->UserData =
            Connection->ConnectDataBuffers->ReceiveConnectData.Buffer;
        returnConnectionInformation->UserDataLength =
            Connection->ConnectDataBuffers->ReceiveConnectData.BufferLength;
        returnConnectionInformation->Options =
            Connection->ConnectDataBuffers->ReceiveConnectOptions.Buffer;
        returnConnectionInformation->OptionsLength =
            Connection->ConnectDataBuffers->ReceiveConnectOptions.BufferLength;
        returnConnectionInformation->RemoteAddress = 
            (*ReturnConnectionInformation)->RemoteAddress;
        returnConnectionInformation->RemoteAddressLength = 
            (*ReturnConnectionInformation)->RemoteAddressLength;
        *ReturnConnectionInformation = returnConnectionInformation;
    }

    AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );

} // AfdSetupConnectDataBuffers


NTSTATUS
AfdRestartConnect (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Handles the IOCTL_AFD_CONNECT IOCTL.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PIO_STACK_LOCATION irpSp;
    PFILE_OBJECT    fileObject;
    PAFD_CONNECT_CONTEXT context;

    UNREFERENCED_PARAMETER (DeviceObject);

    connection = Context;
    ASSERT( connection->Type == AfdBlockTypeConnection );

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    fileObject = irpSp->FileObject;
    ASSERT( fileObject->DeviceObject==AfdDeviceObject );
    
    endpoint = fileObject->FsContext;
    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );
    ASSERT( endpoint==connection->Endpoint );

    context = Irp->AssociatedIrp.SystemBuffer;
    ASSERT( context != NULL );

    IF_DEBUG(CONNECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdRestartConnect: connect completed, status = %X, endpoint = %p\n", 
                    Irp->IoStatus.Status, endpoint ));
    }


    if ( connection->ConnectDataBuffers != NULL ) {

        //
        // If there are connect buffers on this endpoint, remember the
        // size of the return connect data.
        //

        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Double-check under the lock
        //

        if ( connection->ConnectDataBuffers != NULL ) {
            NTSTATUS    status;

            status = AfdSaveReceivedConnectData(
                         &connection->ConnectDataBuffers,
                         IOCTL_AFD_SET_CONNECT_DATA,
                         connection->ConnectDataBuffers->ReturnConnectionInfo.UserData,
                         connection->ConnectDataBuffers->ReturnConnectionInfo.UserDataLength
                         );
            ASSERT (NT_SUCCESS (status));

            status = AfdSaveReceivedConnectData(
                         &connection->ConnectDataBuffers,
                         IOCTL_AFD_SET_CONNECT_OPTIONS,
                         connection->ConnectDataBuffers->ReturnConnectionInfo.Options,
                         connection->ConnectDataBuffers->ReturnConnectionInfo.OptionsLength
                         );
            ASSERT (NT_SUCCESS (status));
        }

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
    }

    //
    // Indicate that the connect completed.  Implicitly, the successful
    // completion of a connect also means that the caller can do a send
    // on the socket.
    //

    if ( NT_SUCCESS(Irp->IoStatus.Status)) {


        //
        // If the request succeeded, set the endpoint to the connected
        // state.  The endpoint type has already been set to
        // AfdBlockTypeVcConnecting.
        //

        endpoint->State = AfdEndpointStateConnected;
        ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );

        //
        // Remember the time that the connection started.
        //

        connection->ConnectTime = KeQueryInterruptTime();

    } else {

        //
        // The connect failed, so reset the type to open.
        // Otherwise, we won't be able to start another connect
        //
        endpoint->Type = AfdBlockTypeEndpoint;

        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

        if (endpoint->Common.VcConnecting.Connection!=NULL) {
            ASSERT (connection==endpoint->Common.VcConnecting.Connection);
            endpoint->Common.VcConnecting.Connection = NULL;

            //
            // Manually delete the connected reference if somebody else
            // hasn't already done so.  We can't use
            // AfdDeleteConnectedReference() because it refuses to delete
            // the connected reference until the endpoint has been cleaned
            // up.
            //

            if ( connection->ConnectedReferenceAdded ) {
                connection->ConnectedReferenceAdded = FALSE;
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                DEREFERENCE_CONNECTION( connection );
            } else {
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            }
            //
            // Dereference the connection block stored on the endpoint.
            // This should cause the connection object reference count to go
            // to zero to the connection object can be deleted.
            //
            DEREFERENCE_CONNECTION( connection );
        }
        else {
            //
            // The endpoint's reference to connection was removed
            // (perhaps in cleanup);
            //
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        }


    }

    AFD_FREE_POOL (context, AFD_TDI_POOL_TAG);
    Irp->AssociatedIrp.SystemBuffer = NULL;

    //
    // If pending has be returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending(Irp);
    }

    AfdCompleteOutstandingIrp( endpoint, Irp );

    //
    // Dereference connection to account for reference we added in AfdConnect
    //
    DEREFERENCE_CONNECTION( connection );

    //
    // Try to queue kernel APC to the user thread that
    // started the connection operation, so we can
    // communicate the status of the connect operation to
    // msafd.dll before we inform the application through
    // the select or EventSelect.  Otherwise, we run into the
    // race condition when application learns about connect first,
    // calls msafd.dll that is not aware of the completion and
    // returns WSAENOTCONN.
    //
    if ((Irp->RequestorMode==UserMode) && // Must be user mode calls
            (Irp->UserBuffer!=NULL) &&   // Must be interested in status
                                         // Thread should be able to 
                                         // run APCs.
            (KeInitializeApc (&endpoint->Common.VcConnecting.Apc,
                            PsGetThreadTcb (Irp->Tail.Overlay.Thread),
                            Irp->ApcEnvironment,
                            AfdConnectApcKernelRoutine,
                            AfdConnectApcRundownRoutine,
                            (PKNORMAL_ROUTINE)NULL,
                            KernelMode,
                            NULL
                            ),
                KeInsertQueueApc (&endpoint->Common.VcConnecting.Apc,
                                    Irp,
                                    NULL,
                                    AfdPriorityBoost))) {
        //
        // We will complete the IRP in the APC.
        //
        return STATUS_MORE_PROCESSING_REQUIRED;
    }
    else {
        //
        // APC was not necessary or did not work.
        // Complete it here.
        //
        AfdFinishConnect (endpoint, Irp, NULL);
        return STATUS_SUCCESS;
    }

} // AfdRestartConnect



VOID
AfdConnectApcKernelRoutine (
    IN struct _KAPC         *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID            *NormalContext,
    IN OUT PVOID            *SystemArgument1,
    IN OUT PVOID            *SystemArgument2
    )
{
    PIRP            irp;
    PIO_STACK_LOCATION irpSp;
    PAFD_ENDPOINT   endpoint, rootEndpoint;

    UNREFERENCED_PARAMETER (NormalContext);

#if DBG
    try {
        ASSERT (*NormalRoutine==NULL);
#else
        UNREFERENCED_PARAMETER (NormalRoutine);
#endif

    //
    // Validate parameters.
    //

    endpoint = CONTAINING_RECORD (Apc, AFD_ENDPOINT, Common.VcConnecting.Apc);
    ASSERT (IS_AFD_ENDPOINT_TYPE (endpoint));

    irp = *SystemArgument1;
    ASSERT (irp->UserBuffer!=NULL && irp->RequestorMode==UserMode);

    irpSp = IoGetCurrentIrpStackLocation( irp );

    rootEndpoint = *SystemArgument2;
    ASSERT (rootEndpoint==NULL || IS_AFD_ENDPOINT_TYPE (endpoint));
    //
    // Update the status for the user mode caller before
    // signalling events.
    //
    try {
#ifdef _WIN64
        if (IoIs32bitProcess (irp)) {
            ((PIO_STATUS_BLOCK32)irp->UserBuffer)->Status = (LONG)irp->IoStatus.Status;
        }
        else
#endif //_WIN64
        {
            ((PIO_STATUS_BLOCK)irp->UserBuffer)->Status = irp->IoStatus.Status;
        }
    }
    except (AFD_EXCEPTION_FILTER_NO_STATUS()) {
        NOTHING;
    }

    AfdFinishConnect (endpoint, irp, rootEndpoint);
    IoCompleteRequest (irp, AfdPriorityBoost);
#if DBG
    }
    except (AfdApcExceptionFilter (GetExceptionInformation (),
                                    __FILE__,
                                    __LINE__)) {
        DbgBreakPoint ();
    }
#endif
}

VOID
AfdConnectApcRundownRoutine (
    IN struct _KAPC *Apc
    )
{
    PIRP            irp;
    PAFD_ENDPOINT   endpoint, rootEndpoint;
#if DBG
    try {
#endif

    endpoint = CONTAINING_RECORD (Apc, AFD_ENDPOINT, Common.VcConnecting.Apc);
    ASSERT (IS_AFD_ENDPOINT_TYPE (endpoint));
    irp = Apc->SystemArgument1;
    rootEndpoint = Apc->SystemArgument2;
    ASSERT (rootEndpoint==NULL || IS_AFD_ENDPOINT_TYPE (endpoint));
    
    ASSERT (irp->UserBuffer!=NULL && irp->RequestorMode==UserMode);

    //
    // Thread is exiting, don't bother updating user mode status.
    // Just signal the events and complet the IRP.
    //

    AfdFinishConnect (endpoint, irp, rootEndpoint);
    IoCompleteRequest (irp, AfdPriorityBoost);
#if DBG
    }
    except (AfdApcExceptionFilter (GetExceptionInformation (),
                                    __FILE__,
                                    __LINE__)) {
        DbgBreakPoint ();
    }
#endif
}


VOID
AfdFinishConnect (
    PAFD_ENDPOINT   Endpoint,
    PIRP            Irp,
    PAFD_ENDPOINT   RootEndpoint
    )
{

    PIO_STACK_LOCATION irpSp;
    PFILE_OBJECT fileObject;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    ULONG eventMask;

    if (NT_SUCCESS(Irp->IoStatus.Status)) {
        eventMask = AFD_POLL_CONNECT;
    }
    else {
        eventMask = AFD_POLL_CONNECT_FAIL;
    }

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    fileObject = irpSp->FileObject;

    if (RootEndpoint != NULL) {

        AfdAcquireSpinLock(&RootEndpoint->SpinLock, &lockHandle);

        //
        // mswsock.dll will reissue join leaf call for non-blocking sockets
        // in its async helper if the original requesting thread exits
        // causing the connect IRP to cancel.  We only want to signal events
        // based upon the final resolution of the join leaf call (once only)!
        // However if the endpoint is now cleaning up, a followup call to
        // join leaf will fail without signalling the events.
        //

        if (RootEndpoint->EndpointCleanedUp ||
            (Irp->IoStatus.Status != STATUS_CANCELLED) ||
            !RootEndpoint->NonBlocking) {

            AfdIndicateEventSelectEvent(RootEndpoint, eventMask, Irp->IoStatus.Status);
            AfdReleaseSpinLock(&RootEndpoint->SpinLock, &lockHandle);
            AfdIndicatePollEvent(RootEndpoint, eventMask, Irp->IoStatus.Status);

            //
            // Only indicate connection once to the root control plane.
            //

            eventMask = 0;

        } else {

            AfdReleaseSpinLock(&RootEndpoint->SpinLock, &lockHandle);

        }

        AFD_END_STATE_CHANGE(RootEndpoint);
        
        if (!NT_SUCCESS(Irp->IoStatus.Status))
            DEREFERENCE_ENDPOINT(RootEndpoint);

    } // if (RootEndpoint != NULL)

    AfdAcquireSpinLock(&Endpoint->SpinLock, &lockHandle);

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        eventMask |= AFD_POLL_SEND;
        Endpoint->EnableSendEvent = TRUE;

        if (Endpoint->Common.VcConnecting.Connection != NULL) {

            Endpoint->Common.VcConnecting.Connection->State = AfdConnectionStateConnected;

            if (IS_DATA_ON_CONNECTION(Endpoint->Common.VcConnecting.Connection)) {
                eventMask |= AFD_POLL_RECEIVE;
            }

        }

    } else {

        //
        // mswsock.dll will reissue connect call for non-blocking sockets
        // in its async helper if the original requesting thread exits
        // causing the connect IRP to cancel.  We only want to signal events
        // based upon the final resolution of the connect call (once only)!
        // However if the endpoint is now cleaning up, a followup call to
        // connect will fail without signalling the events.
        //

        if ((Irp->IoStatus.Status == STATUS_CANCELLED) &&
            !Endpoint->EndpointCleanedUp &&
            Endpoint->NonBlocking) {

            eventMask = 0;

        }
        
    } // if (NT_SUCCESS(Irp->IoStatus.Status))

    if (eventMask) {

        AfdIndicateEventSelectEvent(Endpoint, eventMask, Irp->IoStatus.Status);
        AfdReleaseSpinLock(&Endpoint->SpinLock, &lockHandle);
        AfdIndicatePollEvent(Endpoint, eventMask, Irp->IoStatus.Status);

    }
    else {

        AfdReleaseSpinLock(&Endpoint->SpinLock, &lockHandle);

    }

    AFD_END_STATE_CHANGE(Endpoint);
    ObDereferenceObject(fileObject);

}



NTSTATUS
AfdRestartDgConnect (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Handles the IOCTL_AFD_CONNECT IOCTL.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PAFD_ENDPOINT endpoint;
    PIO_STACK_LOCATION irpSp;
    PFILE_OBJECT    fileObject;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    ULONG       eventMask;

    UNREFERENCED_PARAMETER (DeviceObject);

    endpoint = Context;
    ASSERT( IS_DGRAM_ENDPOINT(endpoint) );

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    fileObject = irpSp->FileObject;

    ASSERT (endpoint == fileObject->FsContext);

    IF_DEBUG(CONNECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdRestartDgConnect: connect completed, status = %X, endpoint = %p\n",
                Irp->IoStatus.Status, endpoint ));
    }




    //
    // Indicate that the connect completed.  Implicitly, the successful
    // completion of a connect also means that the caller can do a send
    // on the socket.
    //

    AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    if ( NT_SUCCESS(Irp->IoStatus.Status) ) {

        endpoint->State = AfdEndpointStateConnected;

        endpoint->EnableSendEvent = TRUE;
        eventMask = AFD_POLL_CONNECT | AFD_POLL_SEND;

    } else {

        eventMask = AFD_POLL_CONNECT_FAIL;

    }
    AfdIndicateEventSelectEvent (endpoint, eventMask, Irp->IoStatus.Status);
    AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
    AfdIndicatePollEvent (endpoint, eventMask, Irp->IoStatus.Status);

    AFD_END_STATE_CHANGE (endpoint);

    ASSERT (Irp->AssociatedIrp.SystemBuffer!=NULL);
    AFD_FREE_POOL (Irp->AssociatedIrp.SystemBuffer, AFD_TDI_POOL_TAG);
    Irp->AssociatedIrp.SystemBuffer = NULL;

    //
    // If pending has be returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending(Irp);
    }

    AfdCompleteOutstandingIrp( endpoint, Irp );

    //
    // Remove reference added in AfdConnect
    //
    ObDereferenceObject (fileObject);

    return STATUS_SUCCESS;

} // AfdRestartDgConnect



VOID
AfdEnableFailedConnectEvent(
    IN PAFD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Reenables the failed connect poll bit on the specified endpoint.
    This is off in a separate (nonpageable) routine so that the bulk
    of AfdConnect() can remain pageable.

Arguments:

    Endpoint - The endpoint to enable.

Return Value:

    None.

--*/

{
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    AfdAcquireSpinLock( &Endpoint->SpinLock, &lockHandle );

    ASSERT( ( Endpoint->EventsActive & AFD_POLL_CONNECT ) == 0 );
    Endpoint->EventsActive &= ~AFD_POLL_CONNECT_FAIL;
    Endpoint->EventStatus[AFD_POLL_CONNECT_FAIL_BIT] = STATUS_SUCCESS;

    IF_DEBUG(EVENT_SELECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdConnect: Endp %08lX, Active %08lX\n",
                    Endpoint,
                    Endpoint->EventsActive
                    ));
    }

    AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );

}   // AfdEnableFailedConnectEvent



NTSTATUS
FASTCALL
AfdJoinLeaf (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Handles the IOCTL_AFD_JOIN_LEAF IOCTL.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    NTSTATUS status;
    PAFD_ENDPOINT leafEndpoint;
    PAFD_CONNECTION connection;
    PAFD_CONNECT_CONTEXT context;
    HANDLE connectEndpointHandle;
    HANDLE rootEndpointHandle;
    PFILE_OBJECT fileObject;
    PTRANSPORT_ADDRESS remoteAddress;
    ULONG  remoteAddressLength;
    PTDI_CONNECTION_INFORMATION requestConnectionInfo, returnConnectionInfo;

    PAGED_CODE( );

    //
    // Initialize for proper cleanup
    //

    fileObject = NULL;
    connection = NULL;
    context = NULL;

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<
                    (ULONG)FIELD_OFFSET(AFD_CONNECT_JOIN_INFO32, RemoteAddress.Address[0].Address) ||
                (IrpSp->Parameters.DeviceIoControl.OutputBufferLength!=0 &&
                    IrpSp->Parameters.DeviceIoControl.OutputBufferLength<
                        sizeof (IO_STATUS_BLOCK32))){
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }
        AFD_W4_INIT status = STATUS_SUCCESS;
        try {
            if( Irp->RequestorMode != KernelMode ) {

                ProbeForRead(
                    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                    IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                    PROBE_ALIGNMENT32 (AFD_CONNECT_JOIN_INFO32)
                    );

            }

            connectEndpointHandle = 
                ((PAFD_CONNECT_JOIN_INFO32)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer)->ConnectEndpoint;
            rootEndpointHandle = 
                ((PAFD_CONNECT_JOIN_INFO32)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer)->RootEndpoint;
            remoteAddress = (PTRANSPORT_ADDRESS)&((PAFD_CONNECT_JOIN_INFO32)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer)->RemoteAddress;
            ASSERT (((ULONG_PTR)remoteAddress & (PROBE_ALIGNMENT(TRANSPORT_ADDRESS)-1))==0);
            remoteAddressLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength
                                    - FIELD_OFFSET (AFD_CONNECT_JOIN_INFO32, RemoteAddress);
        }
        except (AFD_EXCEPTION_FILTER (status)) {
            ASSERT (NT_ERROR (status));
            goto complete;
        }
    }
    else
#endif //_WIN64
    {

        //
        // Determine where in the system buffer the request and return
        // connection information structures exist.  Pass pointers to
        // these locations instead of the user-mode pointers in the
        // tdiRequest structure so that the memory will be nonpageable.
        //

        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<
                (ULONG)FIELD_OFFSET (AFD_CONNECT_JOIN_INFO, RemoteAddress.Address[0].Address) ||
                (IrpSp->Parameters.DeviceIoControl.OutputBufferLength!=0 &&
                    IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                        sizeof (IO_STATUS_BLOCK))) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }

        AFD_W4_INIT status = STATUS_SUCCESS;
        try {
            if( Irp->RequestorMode != KernelMode ) {

                ProbeForRead(
                    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                    IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                    PROBE_ALIGNMENT (AFD_CONNECT_JOIN_INFO)
                    );

            }

            connectEndpointHandle = 
                ((PAFD_CONNECT_JOIN_INFO)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer)->ConnectEndpoint;
            rootEndpointHandle = 
                ((PAFD_CONNECT_JOIN_INFO)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer)->RootEndpoint;
            remoteAddress = &((PAFD_CONNECT_JOIN_INFO)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer)->RemoteAddress;
            remoteAddressLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength
                                    - FIELD_OFFSET (AFD_CONNECT_JOIN_INFO, RemoteAddress);
        }
        except (AFD_EXCEPTION_FILTER (status)) {
            ASSERT (NT_ERROR (status));
            goto complete;
        }
    }

    //
    // Do sanity check on remoteAddressLength to prevent addition overflow below
    //
    if ((LONG)remoteAddressLength < 0) {
        //
        // address length is unreasonably large
        //
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    AFD_W4_INIT ASSERT (status == STATUS_SUCCESS);
    try {

        context = AFD_ALLOCATE_POOL_WITH_QUOTA (NonPagedPool,
                            FIELD_OFFSET (AFD_CONNECT_CONTEXT, RemoteAddress)
                                + remoteAddressLength,
                            AFD_TDI_POOL_TAG
                            );
        // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets POOL_RAISE_IF_ALLOCATION_FAILURE flag
        ASSERT (context!=NULL);

        Irp->AssociatedIrp.SystemBuffer = context;
        RtlZeroMemory (context,
              FIELD_OFFSET (AFD_CONNECT_CONTEXT, RemoteAddress));

        RtlCopyMemory (&context->RemoteAddress,
                remoteAddress,
                remoteAddressLength);
        //
        // Validate internal consistency of the transport address structure.
        // Note that we HAVE to do this after copying since the malicious
        // application can change the content of the buffer on us any time
        // and our check will be bypassed.
        //
        if ((context->RemoteAddress.TAAddressCount!=1) ||
                (LONG)remoteAddressLength<
                    FIELD_OFFSET (TRANSPORT_ADDRESS,
                        Address[0].Address[context->RemoteAddress.Address[0].AddressLength])) {
            ExRaiseStatus (STATUS_INVALID_PARAMETER);
        }

        context->RequestConnectionInfo.RemoteAddress = &context->RemoteAddress;
        context->RequestConnectionInfo.RemoteAddressLength = remoteAddressLength;

    
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength>0 && 
                Irp->RequestorMode==UserMode) {
            ProbeForWriteIoStatusEx (
                ((PIO_STATUS_BLOCK)Irp->UserBuffer),
                IoIs32bitProcess (Irp));
        }
    }
    except (AFD_EXCEPTION_FILTER(status)) {
        ASSERT (NT_ERROR (status));
        goto complete;
    }

    fileObject = IrpSp->FileObject;
    leafEndpoint = fileObject->FsContext;

    if (leafEndpoint->Type==AfdBlockTypeHelper) {
        //
        // This is async join leaf which uses helper endpoint to
        // communicate to AFD. Get the real endpoint.
        //
        status = ObReferenceObjectByHandle(
                    connectEndpointHandle,
                    (IrpSp->Parameters.DeviceIoControl.IoControlCode>>14) & 3,
                                                // DesiredAccess
                    *IoFileObjectType,          // ObjectType
                    Irp->RequestorMode,
                    (PVOID *)&fileObject,
                    NULL
                    );
        if (!NT_SUCCESS (status)) {
            goto complete;
        }

        if (fileObject->DeviceObject!=AfdDeviceObject) {
            status = STATUS_INVALID_HANDLE;
            goto complete_deref;
        }

        leafEndpoint = fileObject->FsContext;
        IrpSp->FileObject = fileObject;
    }
    else
        ObReferenceObject (fileObject);


    if (rootEndpointHandle!=NULL) {
        //
        // Root inviting leaf
        //
        PFILE_OBJECT    rootObject;
        PAFD_ENDPOINT   rootEndpoint;

        status = ObReferenceObjectByHandle(
                    rootEndpointHandle,
                    (IrpSp->Parameters.DeviceIoControl.IoControlCode>>14) & 3,
                                                // DesiredAccess
                    *IoFileObjectType,          // ObjectType
                    Irp->RequestorMode,
                    (PVOID *)&rootObject,
                    NULL
                    );
        if (!NT_SUCCESS (status)) {
            goto complete_deref;
        }

        if (rootObject->DeviceObject!=AfdDeviceObject) {
            ObDereferenceObject (rootObject);
            status = STATUS_INVALID_HANDLE;
            goto complete_deref;
        }

        //
        // Get the endpoint structure of the file object
        //

        rootEndpoint = rootObject->FsContext;

        if (!AFD_START_STATE_CHANGE (leafEndpoint, AfdEndpointStateConnected)) {
            ObDereferenceObject (rootObject);
            status = STATUS_INVALID_PARAMETER;
            goto complete_deref;
        }

        //
        // Verify root and leaf endpoint's type and states
        //
        if (IS_VC_ENDPOINT(rootEndpoint) &&
                rootEndpoint->afdC_Root &&
                rootEndpoint->State==AfdEndpointStateConnected &&
                (leafEndpoint->Type == AfdBlockTypeEndpoint ||
                    leafEndpoint->Type == AfdBlockTypeVcConnecting) &&
                leafEndpoint->TransportInfo==rootEndpoint->TransportInfo &&
                leafEndpoint->State==AfdEndpointStateOpen) {
            //
            // Create a connection object to use for the connect operation.
            //

            status = AfdCreateConnection(
                         rootEndpoint->TransportInfo,
                         rootEndpoint->AddressHandle,
                         IS_TDI_BUFFERRING(rootEndpoint),
                         leafEndpoint->InLine,
                         leafEndpoint->OwningProcess,
                         &connection
                         );

            //
            // No more joins are allowed while this one is active
            //

            if (AFD_START_STATE_CHANGE (rootEndpoint, rootEndpoint->State)) {
                AfdJoinInviteSetup (rootEndpoint, leafEndpoint);
            }
            else {
                status = STATUS_INVALID_PARAMETER;
            }

        }
        else {
            status = STATUS_INVALID_PARAMETER;
        }

        //
        // We referenced root endpoint in invite routine, so
        // we no longer need reference to root file object
        //
        ObDereferenceObject (rootObject);

        if (!NT_SUCCESS (status)) {
            goto complete_state_change;
        }
    }
    else {
        //
        // If this is a datagram endpoint, simply remember the specified
        // address so that we can use it on sends, and writes.
        //

        if ( IS_DGRAM_ENDPOINT(leafEndpoint) ) {
            if (leafEndpoint->State!=AfdEndpointStateConnected) {
                return AfdDoDatagramConnect( fileObject, Irp, TRUE);
            }
            else {
                //
                // If endpoint is already connected, that connection takes
                // precedence
                //
                status = STATUS_SUCCESS;
                goto complete_deref;
            }
        }
        else {

            if (!AFD_START_STATE_CHANGE (leafEndpoint, AfdEndpointStateConnected)) {
                status = STATUS_INVALID_PARAMETER;
                goto complete_deref;
            }

            if ((leafEndpoint->Type != AfdBlockTypeEndpoint &&
                    leafEndpoint->Type != AfdBlockTypeVcConnecting) ||
                leafEndpoint->State != AfdEndpointStateBound) {
                status = STATUS_INVALID_PARAMETER;
                goto complete_state_change;
            }
            //
            // Create a connection object to use for the connect operation.
            //

            status = AfdCreateConnection(
                         leafEndpoint->TransportInfo,
                         leafEndpoint->AddressHandle,
                         IS_TDI_BUFFERRING(leafEndpoint),
                         leafEndpoint->InLine,
                         leafEndpoint->OwningProcess,
                         &connection
                         );

            if ( !NT_SUCCESS(status) ) {
                goto complete_state_change;
            }
        }
    }


    IF_DEBUG(CONNECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdJoinLeaf: starting join for endpoint %p\n",
                    leafEndpoint ));
    }


        

    //
    // Set up a referenced pointer from the connection to the endpoint.
    // Note that we set up the connection's pointer to the endpoint
    // BEFORE the endpoint's pointer to the connection so that AfdPoll
    // doesn't try to back reference the endpoint from the connection.
    //

    REFERENCE_ENDPOINT( leafEndpoint );
    connection->Endpoint = leafEndpoint;

    //
    // Remember that this is now a connecting type of endpoint, and set
    // up a pointer to the connection in the endpoint.  This is
    // implicitly a referenced pointer.
    //

    leafEndpoint->Common.VcConnecting.Connection = connection;
    leafEndpoint->Type = AfdBlockTypeVcConnecting;

    ASSERT( IS_TDI_BUFFERRING(leafEndpoint) == connection->TdiBufferring );

    //
    // Add an additional reference to the connection.  This prevents the
    // connection from being closed until the disconnect event handler
    // is called.
    //

    AfdAddConnectedReference( connection );

    //
    // If there are connect data buffers, move them from the endpoint
    // structure to the connection structure and set up the necessary
    // pointers in the connection request we're going to give to the TDI
    // provider.  Do this in a subroutine so this routine can be pageable.
    //

    requestConnectionInfo = &context->RequestConnectionInfo;
    returnConnectionInfo = &context->ReturnConnectionInfo;

    if ( leafEndpoint->Common.VirtualCircuit.ConnectDataBuffers != NULL ) {
        AfdSetupConnectDataBuffers(
            leafEndpoint,
            connection,
            &requestConnectionInfo,
            &returnConnectionInfo
            );
    }

    //
    // Since we may be reissuing a connect after a previous failed connect,
    // reenable the failed connect event bit.
    //

    AfdEnableFailedConnectEvent( leafEndpoint );


    REFERENCE_CONNECTION (connection);
    
    //
    // Build a TDI kernel-mode connect request in the next stack location
    // of the IRP.
    //

    TdiBuildConnect(
        Irp,
        connection->DeviceObject,
        connection->FileObject,
        AfdRestartJoin,
        connection,
        &AfdInfiniteTimeout,
        requestConnectionInfo,
        returnConnectionInfo
        );

    AFD_VERIFY_ADDRESS (connection, &context->ReturnConnectionInfo->RemoteAddress);

    //
    // Call the transport to actually perform the connect operation.
    //

    return AfdIoCallDriver( leafEndpoint, connection->DeviceObject, Irp );

complete_state_change:
    AFD_END_STATE_CHANGE (leafEndpoint);


complete_deref:
    ObDereferenceObject (fileObject);

complete:

    if (context!=NULL) {
        AFD_FREE_POOL (context, AFD_TDI_POOL_TAG);
        ASSERT (Irp->AssociatedIrp.SystemBuffer==context);
        Irp->AssociatedIrp.SystemBuffer = NULL;
    }

    if (connection!=NULL) {
        DEREFERENCE_CONNECTION (connection);
    }

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );


    return status;

} // AfdJoinLeaf


VOID
AfdJoinInviteSetup (
    PAFD_ENDPOINT   RootEndpoint,
    PAFD_ENDPOINT   LeafEndpoint
    )
{
    NTSTATUS    status;
    AFD_LOCK_QUEUE_HANDLE lockHandle;


    RootEndpoint->EventsActive &= ~AFD_POLL_CONNECT;

    AfdAcquireSpinLock (&LeafEndpoint->SpinLock, &lockHandle);
    LeafEndpoint->TdiServiceFlags = RootEndpoint->TdiServiceFlags;

    //
    // Set up a referenced pointer to the root endpoint.  This is
    // necessary so that the endpoint does not go away until all
    // leaf endpoints have gone away.  Without this, we can free
    // several shared strucutures that are associated with root
    // endpoint and then attempt to use them in leaf endpoints.
    //

    REFERENCE_ENDPOINT (RootEndpoint);
    LeafEndpoint->Common.VcConnecting.ListenEndpoint = RootEndpoint;

    //
    // Set up a referenced pointer in the accepted endpoint to the
    // TDI address object.
    //

    ObReferenceObject( RootEndpoint->AddressFileObject );
    AfdRecordAddrRef();

    LeafEndpoint->AddressFileObject = RootEndpoint->AddressFileObject;
    LeafEndpoint->AddressDeviceObject = RootEndpoint->AddressDeviceObject;

    //
    // Copy the pointer to the local address. Because we keep listen
    // endpoint alive for as long as any of its connection is
    // active, we can rely on the fact that address structure won't go
    // away as well.
    //
    LeafEndpoint->LocalAddress = RootEndpoint->LocalAddress;
    LeafEndpoint->LocalAddressLength = RootEndpoint->LocalAddressLength;
    status = STATUS_SUCCESS;
    AfdReleaseSpinLock (&LeafEndpoint->SpinLock, &lockHandle);

} // AfdJoinInviteSetup



NTSTATUS
AfdRestartJoin (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Handles the IOCTL_AFD_CONNECT IOCTL.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PAFD_ENDPOINT endpoint, rootEndpoint;
    PAFD_CONNECTION connection;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PIO_STACK_LOCATION irpSp;
    PFILE_OBJECT    fileObject;
    PAFD_CONNECT_CONTEXT context;

    UNREFERENCED_PARAMETER (DeviceObject);

    connection = Context;
    ASSERT( connection->Type == AfdBlockTypeConnection );

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    fileObject = irpSp->FileObject;
    ASSERT( fileObject->DeviceObject == AfdDeviceObject );

    endpoint = fileObject->FsContext;
    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );

    context = Irp->AssociatedIrp.SystemBuffer;
    ASSERT( context != NULL );


    IF_DEBUG(CONNECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdRestartJoin: join completed, status = %X, "
                    "LeafEndpoint = %p, RootEndpoint = %p\n", 
                    Irp->IoStatus.Status, endpoint,
                    endpoint->Common.VcConnecting.ListenEndpoint ));
    }

    //
    // If this endpoint has root associated with it, 
    // we need to update it as well.
    //
    rootEndpoint = endpoint->Common.VcConnecting.ListenEndpoint;
    ASSERT ( rootEndpoint==NULL || 
                (rootEndpoint->afdC_Root &&
                    (rootEndpoint->Type == AfdBlockTypeVcConnecting ||
                        rootEndpoint->Type == AfdBlockTypeVcBoth) ) );

    //
    // If there are connect buffers on this endpoint, remember the
    // size of the return connect data.
    //


    if ( connection->ConnectDataBuffers != NULL ) {
        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Double-check under the lock
        //

        if ( connection->ConnectDataBuffers != NULL ) {
            NTSTATUS    status;

            status = AfdSaveReceivedConnectData(
                         &connection->ConnectDataBuffers,
                         IOCTL_AFD_SET_CONNECT_DATA,
                         connection->ConnectDataBuffers->ReturnConnectionInfo.UserData,
                         connection->ConnectDataBuffers->ReturnConnectionInfo.UserDataLength
                         );
            ASSERT (NT_SUCCESS (status));

            status = AfdSaveReceivedConnectData(
                         &connection->ConnectDataBuffers,
                         IOCTL_AFD_SET_CONNECT_OPTIONS,
                         connection->ConnectDataBuffers->ReturnConnectionInfo.Options,
                         connection->ConnectDataBuffers->ReturnConnectionInfo.OptionsLength
                         );
            ASSERT (NT_SUCCESS (status));
        }

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
    }


    //
    // Indicate that the connect completed.  Implicitly, the successful
    // completion of a connect also means that the caller can do a send
    // on the socket.
    //

    if ( NT_SUCCESS(Irp->IoStatus.Status) ) {


        //
        // If the request succeeded, set the endpoint to the connected
        // state.  The endpoint type has already been set to
        // AfdBlockTypeVcConnecting.
        //

        endpoint->State = AfdEndpointStateConnected;
        ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );

        //
        // Remember the time that the connection started.
        //

        connection->ConnectTime = KeQueryInterruptTime();

    } else {

        //
        // The connect failed, so reset the type to open.
        // If we don't reset, we won't be able to start
        // another join
        //
        endpoint->Type = AfdBlockTypeEndpoint;

        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
        //
        // Remove references to listening endpoint and connection
        // Actual dereferncing is below after we release the spinlock

        if (rootEndpoint!=NULL) {
            endpoint->Common.VcConnecting.ListenEndpoint = NULL;
            //
            // We used the local address from the listening endpoint,
            // simply reset it, it will be freed when listening endpoint
            // is freed.
            //

            ASSERT (endpoint->LocalAddress==rootEndpoint->LocalAddress);
            endpoint->LocalAddress = NULL;
            endpoint->LocalAddressLength = 0;
        }

        if (endpoint->Common.VcConnecting.Connection != NULL) {
            endpoint->Common.VcConnecting.Connection = NULL;

            //
            // Manually delete the connected reference if somebody else
            // hasn't already done so.  We can't use
            // AfdDeleteConnectedReference() because it refuses to delete
            // the connected reference until the endpoint has been cleaned
            // up.
            //

            if ( connection->ConnectedReferenceAdded ) {
                connection->ConnectedReferenceAdded = FALSE;
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                DEREFERENCE_CONNECTION( connection );
            } else {
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            }

            //
            // Dereference the connection block stored on the endpoint.
            // This should cause the connection object reference count to go
            // to zero to the connection object can be deleted.
            //

            DEREFERENCE_CONNECTION( connection );
        }
        else {
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        }

    }


    AFD_FREE_POOL (context, AFD_TDI_POOL_TAG);
    Irp->AssociatedIrp.SystemBuffer = NULL;

    //
    // If pending has be returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending(Irp);
    }


    AfdCompleteOutstandingIrp( endpoint, Irp );

    //
    // Dereference connection  to account for reference
    // we added in AfdConnect
    //
    DEREFERENCE_CONNECTION( connection );

    //
    // Try to queue kernel APC to the user thread that
    // started the connection operation, so we can
    // communicate the status of the connect operation to
    // msafd.dll before we inform the application through
    // the select or EventSelect.  Otherwise, we run into the
    // race condition when application learns about connect first,
    // calls msafd.dll that is not aware of the completion and
    // returns WSAENOTCONN.
    //
    if ((Irp->RequestorMode==UserMode) && // Must be user mode calls
            (Irp->UserBuffer!=NULL) &&   // Must be interested in status
                                         // Thread should be able to 
                                         // run APCs.
            (KeInitializeApc (&endpoint->Common.VcConnecting.Apc,
                            PsGetThreadTcb (Irp->Tail.Overlay.Thread),
                            Irp->ApcEnvironment,
                            AfdConnectApcKernelRoutine,
                            AfdConnectApcRundownRoutine,
                            (PKNORMAL_ROUTINE)NULL,
                            KernelMode,
                            NULL
                            ),
                KeInsertQueueApc (&endpoint->Common.VcConnecting.Apc,
                                    Irp,
                                    rootEndpoint,
                                    AfdPriorityBoost))) {
        //
        // We will complete the IRP in the APC.
        //
        return STATUS_MORE_PROCESSING_REQUIRED;
    }
    else {
        //
        // APC was not necessary or did not work.
        // Complete it here.
        //
        AfdFinishConnect (endpoint, Irp, rootEndpoint);
        return STATUS_SUCCESS;
    }
} // AfdRestartJoin


NTSTATUS
FASTCALL
AfdSuperConnect (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Handles the IOCTL_AFD_SUPER_CONNECT IOCTL.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    NTSTATUS status;
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    PAFD_BUFFER afdBuffer;
    PAFD_SUPER_CONNECT_INFO connectInfo;
    PTRANSPORT_ADDRESS remoteAddress;
    PVOID context;
    PTDI_CONNECTION_INFORMATION requestConnectionInfo, returnConnectionInfo;

    PAGED_CODE( );

    //
    // Initialize for proper cleanup
    //


    afdBuffer = NULL;
    endpoint = IrpSp->FileObject->FsContext;



    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<
            (ULONG)FIELD_OFFSET(AFD_SUPER_CONNECT_INFO, RemoteAddress.Address[0].Address)) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    AFD_W4_INIT status = STATUS_SUCCESS;
    try {
        if( Irp->RequestorMode != KernelMode ) {

            ProbeForRead(
                IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                PROBE_ALIGNMENT (AFD_SUPER_CONNECT_INFO)
                );

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength!=0) {
                ProbeForRead (Irp->UserBuffer,
                                IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                sizeof (UCHAR));
            }
        }

        connectInfo = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
        //
        // Check for if the caller is unaware of the SAN
        // provider activation and report the error.
        //
        if (!connectInfo->SanActive && AfdSanServiceHelper!=NULL) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                        "AFD: Process %p is being told to enable SAN on connect\n",
                        PsGetCurrentProcessId ()));
            status = STATUS_INVALID_PARAMETER_12;
            goto complete;
        }

        afdBuffer = AfdGetBufferRaiseOnFailure (
                            endpoint,
                            IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                            IrpSp->Parameters.DeviceIoControl.InputBufferLength-
                                FIELD_OFFSET(AFD_SUPER_CONNECT_INFO, RemoteAddress),
                            endpoint->OwningProcess
                            );

        remoteAddress = afdBuffer->TdiInfo.RemoteAddress; 
        afdBuffer->TdiInfo.RemoteAddressLength = 
                IrpSp->Parameters.DeviceIoControl.InputBufferLength-
                FIELD_OFFSET(AFD_SUPER_CONNECT_INFO, RemoteAddress);
        RtlCopyMemory (afdBuffer->TdiInfo.RemoteAddress,
                &connectInfo->RemoteAddress,
                afdBuffer->TdiInfo.RemoteAddressLength);
        //
        // Validate internal consistency of the transport address structure.
        // Note that we HAVE to do this after copying since the malicious
        // application can change the content of the buffer on us any time
        // and our check will be bypassed.
        //
        if ((remoteAddress->TAAddressCount!=1) ||
                (LONG)afdBuffer->TdiInfo.RemoteAddressLength<
                    FIELD_OFFSET (TRANSPORT_ADDRESS,
                        Address[0].Address[remoteAddress->Address[0].AddressLength])) {
            ExRaiseStatus (STATUS_INVALID_PARAMETER);
        }

        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength>0) {
            RtlCopyMemory (afdBuffer->Buffer,
                            Irp->UserBuffer,
                            IrpSp->Parameters.DeviceIoControl.OutputBufferLength
                            );
            afdBuffer->DataLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
        }
        else {
            afdBuffer->DataLength = 0;
        }
    
    }
    except (AFD_EXCEPTION_FILTER(status)) {
        ASSERT (NT_ERROR (status));
        goto complete;
    }

    if (!AFD_START_STATE_CHANGE (endpoint, AfdEndpointStateConnected)) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    //
    // If the endpoint is not bound, then this is an invalid request.
    // Listening endpoints are not allowed as well.
    // We do not support sending data with TDI buffering transports too.
    //

    if ( endpoint->Type != AfdBlockTypeEndpoint ||
            endpoint->State != AfdEndpointStateBound ||
            endpoint->Listening ||
            (IS_TDI_BUFFERRING (endpoint) && 
                IrpSp->Parameters.DeviceIoControl.OutputBufferLength!=0)) {
        if (endpoint->State==AfdEndpointStateConnected) {
            status = STATUS_CONNECTION_ACTIVE;
        }
        else {
            status = STATUS_INVALID_PARAMETER;
        }
        goto complete_state_change;
    }

    IF_DEBUG(CONNECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdSuperConnect: starting connect on endpoint %p\n",
                    endpoint ));
    }


    //
    // Create a connection object to use for the connect operation.
    //

    status = AfdCreateConnection(
                 endpoint->TransportInfo,
                 endpoint->AddressHandle,
                 IS_TDI_BUFFERRING(endpoint),
                 endpoint->InLine,
                 endpoint->OwningProcess,
                 &connection
                 );

    if ( !NT_SUCCESS(status) ) {
        goto complete_state_change;
    }

    //
    // Set up a referenced pointer from the connection to the endpoint.
    // Note that we set up the connection's pointer to the endpoint
    // BEFORE the endpoint's pointer to the connection so that AfdPoll
    // doesn't try to back reference the endpoint from the connection.
    //

    REFERENCE_ENDPOINT( endpoint );
    connection->Endpoint = endpoint;

    //
    // Remember that this is now a connecting type of endpoint, and set
    // up a pointer to the connection in the endpoint.  This is
    // implicitly a referenced pointer.
    //

    endpoint->Common.VcConnecting.Connection = connection;
    endpoint->Type = AfdBlockTypeVcConnecting;

    ASSERT( IS_TDI_BUFFERRING(endpoint) == connection->TdiBufferring );

    //
    // Add an additional reference to the connection.  This prevents the
    // connection from being closed until the disconnect event handler
    // is called.
    //

    AfdAddConnectedReference( connection );

    //
    // Since we may be reissuing a connect after a previous failed connect,
    // reenable the failed connect event bit.
    //

    AfdEnableFailedConnectEvent( endpoint );


    //
    // Copy remote address to the user mode context
    //
    context = AfdLockEndpointContext (endpoint);
    if ( (((CLONG)(endpoint->Common.VcConnecting.RemoteSocketAddressOffset+
                endpoint->Common.VcConnecting.RemoteSocketAddressLength)) <
                endpoint->ContextLength) &&
            (endpoint->Common.VcConnecting.RemoteSocketAddressLength >=
                remoteAddress->Address[0].AddressLength +
                                          sizeof(u_short))) {

        RtlMoveMemory ((PUCHAR)context +
                            endpoint->Common.VcConnecting.RemoteSocketAddressOffset,
            &remoteAddress->Address[0].AddressType,
            remoteAddress->Address[0].AddressLength +
                                          sizeof(u_short));
    }
    else {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                    "AfdSuperConnect: Could not copy remote address for AcceptEx on endpoint: %p, process: %p\n",
                    endpoint, endpoint->OwningProcess));
    }
    AfdUnlockEndpointContext (endpoint, context);
    //
    // Reference the connection block so it does not go away even if
    // endpoint's reference to it is removed (in cleanup)
    //

    REFERENCE_CONNECTION (connection);

    //
    // If there are connect data buffers, move them from the endpoint
    // structure to the connection structure and set up the necessary
    // pointers in the connection request we're going to give to the TDI
    // provider.  Do this in a subroutine so this routine can be pageable.
    //

    requestConnectionInfo = &afdBuffer->TdiInfo;
    afdBuffer->TdiInfo.UserDataLength = 0;
    afdBuffer->TdiInfo.UserData = NULL;
    afdBuffer->TdiInfo.OptionsLength = 0;
    afdBuffer->TdiInfo.Options = NULL;
    //
    // Temporarily use IRP embedded in afd buffer
    // for return connection information.
    //
    {
        C_ASSERT (sizeof (TDI_CONNECTION_INFORMATION)<=
                    sizeof (IO_STACK_LOCATION));
    }
    returnConnectionInfo = 
        (PTDI_CONNECTION_INFORMATION)IoGetNextIrpStackLocation (afdBuffer->Irp);
    RtlZeroMemory (returnConnectionInfo, sizeof (*returnConnectionInfo));

    if ( endpoint->Common.VirtualCircuit.ConnectDataBuffers != NULL ) {
        AfdSetupConnectDataBuffers(
            endpoint,
            connection,
            &requestConnectionInfo,
            &returnConnectionInfo
            );
    }

    afdBuffer->Context = connection;

    //
    // Build a TDI kernel-mode connect request in the next stack location
    // of the IRP.
    //

    TdiBuildConnect(
        Irp,
        connection->DeviceObject,
        connection->FileObject,
        AfdRestartSuperConnect,
        afdBuffer,
        &AfdInfiniteTimeout,
        requestConnectionInfo,
        returnConnectionInfo
        );



    AFD_VERIFY_ADDRESS (connection, afdBuffer->TdiInfo.RemoteAddress);

    ObReferenceObject (IrpSp->FileObject);
    //
    // Call the transport to actually perform the connect operation.
    //

    return AfdIoCallDriver( endpoint, connection->DeviceObject, Irp );

complete_state_change:
    AFD_END_STATE_CHANGE (endpoint);

complete:

    if (afdBuffer!=NULL) {
        AfdReturnBuffer (&afdBuffer->Header, endpoint->OwningProcess);
    }

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

} // AfdSuperConnect

NTSTATUS
AfdRestartSuperConnect (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Handles the IOCTL_AFD_CONNECT IOCTL.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PIO_STACK_LOCATION irpSp;
    PAFD_BUFFER afdBuffer;

    UNREFERENCED_PARAMETER (DeviceObject);

    afdBuffer = Context;
    connection = afdBuffer->Context;
    ASSERT( connection->Type == AfdBlockTypeConnection );

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    
    endpoint = irpSp->FileObject->FsContext;
    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );
    ASSERT( endpoint==connection->Endpoint );

    IF_DEBUG(CONNECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdRestartConnect: connect completed, status = %X, endpoint = %p\n",
                    Irp->IoStatus.Status, endpoint ));
    }


    if ( connection->ConnectDataBuffers != NULL ) {

        //
        // If there are connect buffers on this endpoint, remember the
        // size of the return connect data.
        //

        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Double-check under the lock
        //

        if ( connection->ConnectDataBuffers != NULL ) {
            AfdSaveReceivedConnectData(
                         &connection->ConnectDataBuffers,
                         IOCTL_AFD_SET_CONNECT_DATA,
                         connection->ConnectDataBuffers->ReturnConnectionInfo.UserData,
                         connection->ConnectDataBuffers->ReturnConnectionInfo.UserDataLength
                         );

            AfdSaveReceivedConnectData(
                         &connection->ConnectDataBuffers,
                         IOCTL_AFD_SET_CONNECT_OPTIONS,
                         connection->ConnectDataBuffers->ReturnConnectionInfo.Options,
                         connection->ConnectDataBuffers->ReturnConnectionInfo.OptionsLength
                         );
        }

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
    }

    //
    // Indicate that the connect completed.  Implicitly, the successful
    // completion of a connect also means that the caller can do a send
    // on the socket.
    //

    if ( NT_SUCCESS(Irp->IoStatus.Status)) {


        //
        // If the request succeeded, set the endpoint to the connected
        // state.  The endpoint type has already been set to
        // AfdBlockTypeVcConnecting.
        //

        endpoint->State = AfdEndpointStateConnected;
        ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );

        //
        // Remember the time that the connection started.
        //

        connection->ConnectTime = KeQueryInterruptTime();

    } else {


        //
        // The connect failed, so reset the type to open.
        // Otherwise, we won't be able to start another connect
        //
        endpoint->Type = AfdBlockTypeEndpoint;

        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

        if (endpoint->Common.VcConnecting.Connection!=NULL) {
            ASSERT (connection==endpoint->Common.VcConnecting.Connection);
            endpoint->Common.VcConnecting.Connection = NULL;

            //
            // Manually delete the connected reference if somebody else
            // hasn't already done so.  We can't use
            // AfdDeleteConnectedReference() because it refuses to delete
            // the connected reference until the endpoint has been cleaned
            // up.
            //

            if ( connection->ConnectedReferenceAdded ) {
                connection->ConnectedReferenceAdded = FALSE;
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                DEREFERENCE_CONNECTION( connection );
            } else {
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            }
            //
            // Dereference the connection block stored on the endpoint.
            // This should cause the connection object reference count to go
            // to zero to the connection object can be deleted.
            //
            DEREFERENCE_CONNECTION( connection );
        }
        else {
            //
            // The endpoint's reference to connection was removed
            // (perhaps in cleanup);
            //
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        }


    }

    //
    // If pending has be returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending(Irp);
    }

    AfdCompleteOutstandingIrp( endpoint, Irp );

    AfdFinishConnect (endpoint, Irp, NULL);

    if (NT_SUCCESS (Irp->IoStatus.Status) && afdBuffer->DataLength>0) {
        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        if ( !connection->CleanupBegun && !connection->Aborted ) {
            NTSTATUS status;
            //
            // Update count of send bytes pending on the connection.
            //

            connection->VcBufferredSendBytes += afdBuffer->DataLength;
            connection->VcBufferredSendCount += 1;
            AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

            afdBuffer->Mdl->ByteCount = afdBuffer->DataLength;
            ASSERT (afdBuffer->Context == connection );

            TdiBuildSend(
                afdBuffer->Irp,
                connection->DeviceObject,
                connection->FileObject,
                AfdRestartBufferSend,
                afdBuffer,
                afdBuffer->Mdl,
                0,
                afdBuffer->DataLength
                );

            Irp->IoStatus.Information = afdBuffer->DataLength;


            //
            // Call the transport to actually perform the send.
            //

            status = IoCallDriver (
                         connection->DeviceObject,
                         afdBuffer->Irp
                         );
            if (!NT_SUCCESS (status)) {
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
            }

            goto exit;
        }
        if (connection->CleanupBegun) {
            Irp->IoStatus.Status = STATUS_LOCAL_DISCONNECT;
        }
        else {
            ASSERT (connection->Aborted);
            Irp->IoStatus.Status = STATUS_REMOTE_DISCONNECT;
        }
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
    }

    afdBuffer->DataOffset = 0;
    AfdReturnBuffer (&afdBuffer->Header, endpoint->OwningProcess);
    //
    // Dereference connection to account for reference we added in AfdConnect
    //
    DEREFERENCE_CONNECTION (connection);

exit:
    return STATUS_SUCCESS;

} // AfdRestartSuperConnect
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\dispatch.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    This module contains the dispatch routines for AFD.

Author:

    David Treadwell (davidtr)    21-Feb-1992

Revision History:

--*/

#include "afdp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGEAFD, AfdDispatch )
#pragma alloc_text( PAGEAFD, AfdDispatchDeviceControl )
#endif


NTSTATUS
AfdDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for AFD.

Arguments:

    DeviceObject - Pointer to device object for target device

    Irp - Pointer to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
#if DBG
    KIRQL currentIrql;

    currentIrql = KeGetCurrentIrql( );
#endif

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    switch ( irpSp->MajorFunction ) {

    case IRP_MJ_WRITE:

        //
        // Make the IRP look like a send IRP.
        //

        ASSERT( FIELD_OFFSET( IO_STACK_LOCATION, Parameters.Write.Length ) ==
                FIELD_OFFSET( IO_STACK_LOCATION, Parameters.DeviceIoControl.OutputBufferLength ) );
        ASSERT( FIELD_OFFSET( IO_STACK_LOCATION, Parameters.Write.Key ) ==
                FIELD_OFFSET( IO_STACK_LOCATION, Parameters.DeviceIoControl.InputBufferLength ) );
        irpSp->Parameters.Write.Key = 0;

        if (IS_SAN_ENDPOINT ((PAFD_ENDPOINT)irpSp->FileObject->FsContext)) {
            status = AfdSanRedirectRequest (Irp, irpSp);
        }
        else {
            status = AfdSend( Irp, irpSp );
        }

        ASSERT( KeGetCurrentIrql( ) == currentIrql );

        return status;

    case IRP_MJ_READ:

        //
        // Make the IRP look like a receive IRP.
        //

        ASSERT( FIELD_OFFSET( IO_STACK_LOCATION, Parameters.Read.Length ) ==
                FIELD_OFFSET( IO_STACK_LOCATION, Parameters.DeviceIoControl.OutputBufferLength ) );
        ASSERT( FIELD_OFFSET( IO_STACK_LOCATION, Parameters.Read.Key ) ==
                FIELD_OFFSET( IO_STACK_LOCATION, Parameters.DeviceIoControl.InputBufferLength ) );
        irpSp->Parameters.Read.Key = 0;

        if (IS_SAN_ENDPOINT ((PAFD_ENDPOINT)irpSp->FileObject->FsContext)) {
            status = AfdSanRedirectRequest (Irp, irpSp);
        }
        else {
            status = AfdReceive( Irp, irpSp );
        }

        ASSERT( KeGetCurrentIrql( ) == currentIrql );

        return status;

    case IRP_MJ_CREATE:

        status = AfdCreate( Irp, irpSp );

        ASSERT( KeGetCurrentIrql( ) == currentIrql );

        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, AfdPriorityBoost );

        return status;

    case IRP_MJ_CLEANUP:

        status = AfdCleanup( Irp, irpSp );

        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, AfdPriorityBoost );

        ASSERT( KeGetCurrentIrql( ) == currentIrql );

        return status;

    case IRP_MJ_CLOSE:

        status = AfdClose( Irp, irpSp );

        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, AfdPriorityBoost );

        ASSERT( KeGetCurrentIrql( ) == currentIrql );

        return status;
    case IRP_MJ_PNP:
        status = AfdPnpPower (Irp, irpSp );

        ASSERT( KeGetCurrentIrql( ) == currentIrql );

        return status;
    case IRP_MJ_DEVICE_CONTROL:

        return AfdDispatchDeviceControl( DeviceObject, Irp );

    case IRP_MJ_QUERY_SECURITY:
        status = AfdGetSecurity (
                        irpSp->FileObject->FsContext,
                        irpSp->Parameters.QuerySecurity.SecurityInformation,
                        irpSp->Parameters.QuerySecurity.Length,
                        Irp->UserBuffer,
                        &Irp->IoStatus.Information
                        );
        
        ASSERT( KeGetCurrentIrql( ) == currentIrql );

        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, AfdPriorityBoost );
        return status;

    case IRP_MJ_SET_SECURITY:
        status = AfdSetSecurity (
                        irpSp->FileObject->FsContext,
                        irpSp->Parameters.SetSecurity.SecurityInformation,
                        irpSp->Parameters.SetSecurity.SecurityDescriptor
                        );
        
        ASSERT( KeGetCurrentIrql( ) == currentIrql );

        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, AfdPriorityBoost );
        return status;
    default:
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdDispatch: Invalid major function %lx\n",
                    irpSp->MajorFunction ));
        Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
        IoCompleteRequest( Irp, AfdPriorityBoost );

        return STATUS_NOT_IMPLEMENTED;
    }

} // AfdDispatch


NTSTATUS
AfdDispatchDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for AFD IOCTLs.

Arguments:

    DeviceObject - Pointer to device object for target device

    Irp - Pointer to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    ULONG code;
    ULONG request;
    NTSTATUS status;
    PAFD_IRP_CALL irpProc;
    PIO_STACK_LOCATION  IrpSp = IoGetCurrentIrpStackLocation (Irp);
#if DBG
    KIRQL currentIrql;

    currentIrql = KeGetCurrentIrql( );
#endif
    UNREFERENCED_PARAMETER (DeviceObject);


    //
    // Extract the IOCTL control code and process the request.
    //

    code = IrpSp->Parameters.DeviceIoControl.IoControlCode;
    request = _AFD_REQUEST(code);

    if( request < AFD_NUM_IOCTLS && AfdIoctlTable[request] == code ) {

        //
        // Helps in debugging.
        //
        IrpSp->MinorFunction = (UCHAR)request;

        //
        // Try IRP dispatch first
        //
        irpProc = AfdIrpCallDispatch[request];
        if (irpProc!=NULL) {
            status = (*irpProc)(Irp, IrpSp);

            ASSERT( KeGetCurrentIrql( ) == currentIrql );

            return status;
        }
    }
//
// This is currently not used by helper dlls.
// Commented out because of security concerns
//
#if 0
    else if (request==AFD_TRANSPORT_IOCTL) {
        //
        // This is a "special" used to pass request
        // to transport driver using socket handle in
        // order to facilitate proper completion 
        // on sockets associated with completion port.
        // It accepts and properly handles all methods.
        //
        status = AfdDoTransportIoctl (Irp, IrpSp);
        ASSERT( KeGetCurrentIrql() == currentIrql );
        return status;
    }
#endif

    //
    // If we made it this far, then the ioctl is invalid.
    //

    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                "AfdDispatchDeviceControl: invalid IOCTL %08lX\n",
                code
                ));

    Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
    IoCompleteRequest( Irp, AfdPriorityBoost );

    return STATUS_INVALID_DEVICE_REQUEST;

} // AfdDispatchDeviceControl

NTSTATUS
FASTCALL
AfdDispatchImmediateIrp(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    PAFD_IMMEDIATE_CALL immProc;
    ULONG code;
    ULONG request;
    NTSTATUS status;
#if DBG
    KIRQL currentIrql;

    currentIrql = KeGetCurrentIrql( );
#endif

    code = IrpSp->Parameters.DeviceIoControl.IoControlCode;
    request = _AFD_REQUEST(code);

    immProc = AfdImmediateCallDispatch[request];
    if (immProc!=NULL) {
        //
        // Must be METHOD_NEITHER for the below code to be
        // valid.
        //
        ASSERT ( (code & 3) == METHOD_NEITHER );
#if DBG
        if (Irp->RequestorMode!=KernelMode) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                        "AfdDispatchDeviceControl: "
                        "User mode application somehow bypassed fast io dispatch\n"));
        }
#endif
        status = (*immProc) (
                    IrpSp->FileObject,
                    code,
                    Irp->RequestorMode,
                    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                    IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                    Irp->UserBuffer,
                    IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                    &Irp->IoStatus.Information
                    );

        ASSERT( KeGetCurrentIrql( ) == currentIrql );

    }
    else {
        ASSERT (!"Missing IOCTL in dispatch table!!!");
        status = STATUS_INVALID_DEVICE_REQUEST;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\disconn.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    disconn.c

Abstract:

    This module contains the dispatch routines for AFD.

Author:

    David Treadwell (davidtr)    31-Mar-1992

Revision History:

--*/

#include "afdp.h"



NTSTATUS
AfdRestartAbort(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdRestartDisconnect(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdRestartDgDisconnect(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

typedef struct _AFD_ABORT_CONTEXT {
    PAFD_CONNECTION Connection;
} AFD_ABORT_CONTEXT, *PAFD_ABORT_CONTEXT;

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGEAFD, AfdPartialDisconnect )
#pragma alloc_text( PAGEAFD, AfdDisconnectEventHandler )
#pragma alloc_text( PAGEAFD, AfdBeginAbort )
#pragma alloc_text( PAGEAFD, AfdRestartAbort )
#pragma alloc_text( PAGEAFD, AfdAbortConnection )
#pragma alloc_text( PAGEAFD, AfdBeginDisconnect )
#pragma alloc_text( PAGEAFD, AfdRestartDisconnect )
#endif


NTSTATUS
AfdPartialDisconnect(
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    )
{
    NTSTATUS status;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    AFD_PARTIAL_DISCONNECT_INFO disconnectInfo;

    UNREFERENCED_PARAMETER (IoctlCode);
    UNREFERENCED_PARAMETER (OutputBuffer);
    UNREFERENCED_PARAMETER (OutputBufferLength);

    //
    // Nothing to return.
    //

    *Information = 0;

    status = STATUS_SUCCESS;
    connection = NULL;

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
#ifdef _WIN64
    {
        C_ASSERT (sizeof (AFD_PARTIAL_DISCONNECT_INFO)==sizeof (AFD_PARTIAL_DISCONNECT_INFO32));
    }
#endif
    if (InputBufferLength<sizeof (disconnectInfo)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit;
    }
    AFD_W4_INIT ASSERT (status == STATUS_SUCCESS);
    try {

#ifdef _WIN64
        if (IoIs32bitProcess (NULL)) {
            //
            // Validate the input structure if it comes from the user mode
            // application
            //

            if (RequestorMode != KernelMode ) {
                ProbeForReadSmallStructure (InputBuffer,
                                sizeof (disconnectInfo),
                                PROBE_ALIGNMENT32 (AFD_PARTIAL_DISCONNECT_INFO32));
            }

            //
            // Make local copies of the embeded pointer and parameters
            // that we will be using more than once in case malicios
            // application attempts to change them while we are
            // validating
            //

            disconnectInfo.DisconnectMode = ((PAFD_PARTIAL_DISCONNECT_INFO32)InputBuffer)->DisconnectMode;
            disconnectInfo.Timeout = ((PAFD_PARTIAL_DISCONNECT_INFO32)InputBuffer)->Timeout;
        }
        else
#endif _WIN64
        {
            //
            // Validate the input structure if it comes from the user mode
            // application
            //

            if (RequestorMode != KernelMode ) {
                ProbeForReadSmallStructure (InputBuffer,
                                sizeof (disconnectInfo),
                                PROBE_ALIGNMENT (AFD_PARTIAL_DISCONNECT_INFO));
            }

            //
            // Make local copies of the embeded pointer and parameters
            // that we will be using more than once in case malicios
            // application attempts to change them while we are
            // validating
            //

            disconnectInfo = *((PAFD_PARTIAL_DISCONNECT_INFO)InputBuffer);
        }
    } except( AFD_EXCEPTION_FILTER(status) ) {
        ASSERT (NT_ERROR (status));
        goto exit;
    }

    IF_DEBUG(CONNECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdPartialDisconnect: disconnecting endpoint %p, "
                    "mode %lx, endp mode %lx\n",
                    endpoint, disconnectInfo.DisconnectMode,
                    endpoint->DisconnectMode ));
    }

    //
    // If this is a datagram endpoint, just remember how the endpoint
    // was shut down, don't actually do anything.  Note that it is legal
    // to do a shutdown() on an unconnected datagram socket, so the
    // test that the socket must be connected is after this case.
    //

    if ( IS_DGRAM_ENDPOINT(endpoint) ) {

        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

        if ( (disconnectInfo.DisconnectMode & AFD_ABORTIVE_DISCONNECT) != 0 ) {
            endpoint->DisconnectMode |= AFD_PARTIAL_DISCONNECT_RECEIVE;
            endpoint->DisconnectMode |= AFD_PARTIAL_DISCONNECT_SEND;
            endpoint->DisconnectMode |= AFD_ABORTIVE_DISCONNECT;
        }

        if ( (disconnectInfo.DisconnectMode & AFD_PARTIAL_DISCONNECT_RECEIVE) != 0 ) {
            endpoint->DisconnectMode |= AFD_PARTIAL_DISCONNECT_RECEIVE;
        }

        if ( (disconnectInfo.DisconnectMode & AFD_PARTIAL_DISCONNECT_SEND) != 0 ) {
            endpoint->DisconnectMode |= AFD_PARTIAL_DISCONNECT_SEND;
        }

        if (AFD_START_STATE_CHANGE (endpoint, AfdEndpointStateBound)) {
            if ( (disconnectInfo.DisconnectMode & AFD_UNCONNECT_DATAGRAM) != 0 &&
                    endpoint->State==AfdEndpointStateConnected) {
                if( endpoint->Common.Datagram.RemoteAddress != NULL ) {
                    AFD_RETURN_REMOTE_ADDRESS(
                        endpoint->Common.Datagram.RemoteAddress,
                        endpoint->Common.Datagram.RemoteAddressLength
                        );
                }
                endpoint->Common.Datagram.RemoteAddress = NULL;
                endpoint->Common.Datagram.RemoteAddressLength = 0;
                
                //
                // Even if disconnect fails, we consider
                // ourselves not connected anymore
                //
                endpoint->State = AfdEndpointStateBound;

                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

                if (IS_TDI_DGRAM_CONNECTION(endpoint)) {
                    PIRP            irp;
                    KEVENT          event;
                    IO_STATUS_BLOCK ioStatusBlock;


                    KeInitializeEvent( &event, SynchronizationEvent, FALSE );
                    irp = TdiBuildInternalDeviceControlIrp (
                                TDI_DISCONNECT,
                                endpoint->AddressDeviceObject,
                                endpoint->AddressFileObject,
                                &event,
                                &ioStatusBlock
                                );

                    if ( irp != NULL ) {
                        TdiBuildDisconnect(
                            irp,
                            endpoint->AddressDeviceObject,
                            endpoint->AddressFileObject,
                            NULL,
                            NULL,
                            &disconnectInfo.Timeout,
                            (disconnectInfo.DisconnectMode & AFD_ABORTIVE_DISCONNECT)
                                ? TDI_DISCONNECT_ABORT
                                : TDI_DISCONNECT_RELEASE,
                            NULL,
                            NULL
                            );

                        status = IoCallDriver( endpoint->AddressDeviceObject, irp );
                        if ( status == STATUS_PENDING ) {
                            status = KeWaitForSingleObject( (PVOID)&event, Executive, KernelMode,  FALSE, NULL );
                            ASSERT (status==STATUS_SUCCESS);
                        }
                        else {
                            //
                            // The IRP must have been completed then and event set.
                            //
                            ASSERT (NT_ERROR (status) || KeReadStateEvent (&event));
                        }
                    }
                    else {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
            }
            else {
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                status = STATUS_SUCCESS;
            }

            AFD_END_STATE_CHANGE (endpoint);
        }
        else {
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            status = STATUS_INVALID_PARAMETER;
        }

        goto exit;
    }

    //
    // Make sure that the endpoint is in the correct state.
    //

    if ( (endpoint->Type & AfdBlockTypeVcConnecting)!=AfdBlockTypeVcConnecting ||
            endpoint->Listening || 
            endpoint->afdC_Root ||
            endpoint->State != AfdEndpointStateConnected ||
            ((connection=AfdGetConnectionReferenceFromEndpoint (endpoint))==NULL)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    ASSERT( connection->Type == AfdBlockTypeConnection );

    //
    // If we're doing an abortive disconnect, remember that the receive
    // side is shut down and issue a disorderly release.
    //

    if ( (disconnectInfo.DisconnectMode & AFD_ABORTIVE_DISCONNECT) != 0 ) {

        IF_DEBUG(CONNECT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdPartialDisconnect: abortively disconnecting endp %p\n",
                        endpoint ));
        }

        status = AfdBeginAbort( connection );
        if ( status == STATUS_PENDING ) {
            status = STATUS_SUCCESS;
        }

        goto exit;
    }

    //
    // If the receive side of the connection is being shut down,
    // remember the fact in the endpoint.  If there is pending data on
    // the VC, do a disorderly release on the endpoint.  If the receive
    // side has already been shut down, do nothing.
    //

    if ( (disconnectInfo.DisconnectMode & AFD_PARTIAL_DISCONNECT_RECEIVE) != 0 &&
         (endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_RECEIVE) == 0 ) {

        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Determine whether there is pending data.
        //

        if ( IS_DATA_ON_CONNECTION( connection ) ||
                 IS_EXPEDITED_DATA_ON_CONNECTION( connection ) ) {

            //
            // There is unreceived data.  Abort the connection.
            //

            IF_DEBUG(CONNECT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdPartialDisconnect: unreceived data on endp %p, conn %p, aborting.\n",
                              endpoint, connection ));
            }

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

            (VOID)AfdBeginAbort( connection );

            status = STATUS_SUCCESS;
            goto exit;

        } else {

            IF_DEBUG(CONNECT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdPartialDisconnect: disconnecting recv for endp %p\n",
                            endpoint ));
            }

            //
            // Remember that the receive side is shut down.  This will cause
            // the receive indication handlers to dump any data that
            // arrived.
            //
            // !!! This is a minor violation of RFC1122 4.2.2.13.  We
            //     should really do an abortive disconnect if data
            //     arrives after a receive shutdown.
            //

            endpoint->DisconnectMode |= AFD_PARTIAL_DISCONNECT_RECEIVE;

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        }
    }

    //
    // If the send side is being shut down, remember it in the endpoint
    // and pass the request on to the TDI provider for a graceful
    // disconnect.  If the send side is already shut down, do nothing here.
    //

    if ( (disconnectInfo.DisconnectMode & AFD_PARTIAL_DISCONNECT_SEND) != 0 &&
         (endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_SEND) == 0 ) {

        status = AfdBeginDisconnect( endpoint, &disconnectInfo.Timeout, NULL );
        if ( !NT_SUCCESS(status) ) {
            goto exit;
        }
    }

    status = STATUS_SUCCESS;

exit:
    if (connection!=NULL) {
        DEREFERENCE_CONNECTION (connection);
    }

    return status;
} // AfdPartialDisconnect


NTSTATUS
AfdDisconnectEventHandler(
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN int DisconnectDataLength,
    IN PVOID DisconnectData,
    IN int DisconnectInformationLength,
    IN PVOID DisconnectInformation,
    IN ULONG DisconnectFlags
    )
{
    PAFD_CONNECTION connection = ConnectionContext;
    PAFD_ENDPOINT endpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    NTSTATUS status;
    BOOLEAN result;

    UNREFERENCED_PARAMETER (TdiEventContext);

    ASSERT( connection != NULL );

    //
    // Reference the connection object so that it does not go away while
    // we're processing it inside this function.  Without this
    // reference, the user application could close the endpoint object,
    // the connection reference count could go to zero, and the
    // AfdDeleteConnectedReference call at the end of this function
    // could cause a crash if the AFD connection object has been
    // completely cleaned up.
    //

    CHECK_REFERENCE_CONNECTION( connection, result);
    if (!result) {
        return STATUS_SUCCESS;
    }

    ASSERT( connection->Type == AfdBlockTypeConnection );

    endpoint = connection->Endpoint;
    if (endpoint==NULL) {
        //
        // Indication after connection reuse, ignore.
        //
        DEREFERENCE_CONNECTION (connection);
        return STATUS_SUCCESS;
    }

    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcListening ||
            endpoint->Type == AfdBlockTypeVcBoth);

    IF_DEBUG(CONNECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdDisconnectEventHandler called for endpoint %p, connection %p\n",
                    connection->Endpoint, connection ));
    }

    UPDATE_CONN2( connection, "DisconnectEvent, flags: 0x%lX", DisconnectFlags );


    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Check if connection was accepted and use accept endpoint instead
    // of the listening.  Note that accept cannot happen while we are
    // holding listening endpoint spinlock, nor can endpoint change after
    // the accept and while connection is referenced, so it is safe to 
    // release listening spinlock if we discover that endpoint was accepted.
    //
    if (((endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening)
            && (connection->Endpoint != endpoint)) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

        endpoint = connection->Endpoint;
        ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );
        ASSERT( !IS_TDI_BUFFERRING(endpoint) );
        ASSERT(  IS_VC_ENDPOINT (endpoint) );

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    }

    //
    // Set up in the connection the fact that the remote side has
    // disconnected or aborted.
    //

    if ( (DisconnectFlags & TDI_DISCONNECT_ABORT) != 0 ) {
        connection->Aborted = TRUE;
        connection->AbortIndicated = TRUE;
        status = STATUS_REMOTE_DISCONNECT;
        AfdRecordAbortiveDisconnectIndications();
    } else {
        connection->DisconnectIndicated = TRUE;
        if ( !IS_MESSAGE_ENDPOINT(endpoint) ) {
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_GRACEFUL_DISCONNECT;
        }
        AfdRecordGracefulDisconnectIndications();
    }

    if (connection->State==AfdConnectionStateConnected) {
        ASSERT (endpoint->Type & AfdBlockTypeVcConnecting);
        if ( (DisconnectFlags & TDI_DISCONNECT_ABORT) != 0 ) {

            AfdIndicateEventSelectEvent(
                endpoint,
                AFD_POLL_ABORT,
                STATUS_SUCCESS
                );

        } else {

            AfdIndicateEventSelectEvent(
                endpoint,
                AFD_POLL_DISCONNECT,
                STATUS_SUCCESS
                );

        }
    }

    //
    // If this is a nonbufferring transport, complete any pended receives.
    //

    if ( !connection->TdiBufferring ) {

        //
        // If this is an abort indication, complete all pended sends and
        // discard any bufferred receive data.
        //

        if ( DisconnectFlags & TDI_DISCONNECT_ABORT ) {

            connection->VcBufferredReceiveBytes = 0;
            connection->VcBufferredReceiveCount = 0;
            connection->VcBufferredExpeditedBytes = 0;
            connection->VcBufferredExpeditedCount = 0;
            connection->VcReceiveBytesInTransport = 0;

            while ( !IsListEmpty( &connection->VcReceiveBufferListHead ) ) {

                PAFD_BUFFER_HEADER afdBuffer;
                PLIST_ENTRY listEntry;

                listEntry = RemoveHeadList( &connection->VcReceiveBufferListHead );
                afdBuffer = CONTAINING_RECORD( listEntry, AFD_BUFFER_HEADER, BufferListEntry );

                DEBUG afdBuffer->BufferListEntry.Flink = NULL;

                if (afdBuffer->RefCount==1 || // Can't change once off the list
                        InterlockedDecrement (&afdBuffer->RefCount)==0) {
                    afdBuffer->ExpeditedData = FALSE;
                    AfdReturnBuffer( afdBuffer, connection->OwningProcess);
                }
            }

            //
            // Check for the most typical case where we do not
            // have anything to complete and thus do not need to
            // make a call and take/release the spinlock.
            //
            if ( (IsListEmpty (&connection->VcSendIrpListHead) &&
                        IsListEmpty (&connection->VcReceiveIrpListHead)) ||
                    ((endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening) ) {
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            }
            else {

                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                AfdCompleteIrpList(
                    &connection->VcSendIrpListHead,
                    endpoint,
                    status,
                    AfdCleanupSendIrp
                    );

                AfdCompleteIrpList(
                    &connection->VcReceiveIrpListHead,
                    endpoint,
                    status,
                    NULL
                    );
            }
        }
        else {
            //
            // Check for the most typical case where we do not
            // have anything to complete and thus do not need to
            // make a call and take/release the spinlock.
            //
            if ( IsListEmpty (&connection->VcReceiveIrpListHead) ||
                    ((endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening)) {
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            }
            else {
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                AfdCompleteIrpList(
                    &connection->VcReceiveIrpListHead,
                    endpoint,
                    status,
                    NULL
                    );
            }
        }


    }
    else {
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
    }

    //
    // If we got disconnect data or options, save it.
    //

    if( ( DisconnectData != NULL && DisconnectDataLength > 0 ) ||
        ( DisconnectInformation != NULL && DisconnectInformationLength > 0 ) ) {

        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Check if connection was accepted and use accept endpoint instead
        // of the listening.  Note that accept cannot happen while we are
        // holding listening endpoint spinlock, nor can endpoint change after
        // the accept and while connection is referenced, so it is safe to 
        // release listening spinlock if we discover that endpoint was accepted.
        //
        if (((endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening)
                && (connection->Endpoint != endpoint)) {
            AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

            endpoint = connection->Endpoint;
            ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );
            ASSERT( !IS_TDI_BUFFERRING(endpoint) );
            ASSERT(  IS_VC_ENDPOINT (endpoint) );

            AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        }

        if( DisconnectData != NULL && DisconnectDataLength > 0 ) {

            status = AfdSaveReceivedConnectData(
                         &connection->ConnectDataBuffers,
                         IOCTL_AFD_SET_DISCONNECT_DATA,
                         DisconnectData,
                         DisconnectDataLength
                         );

            if( !NT_SUCCESS(status) ) {

                //
                // We hit an allocation failure, but press on regardless.
                //

                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                    "AfdSaveReceivedConnectData failed: %08lx\n",
                    status
                    ));

            }

        }

        if( DisconnectInformation != NULL && DisconnectInformationLength > 0 ) {

            status = AfdSaveReceivedConnectData(
                         &connection->ConnectDataBuffers,
                         IOCTL_AFD_SET_DISCONNECT_DATA,
                         DisconnectInformation,
                         DisconnectInformationLength
                         );

            if( !NT_SUCCESS(status) ) {

                //
                // We hit an allocation failure, but press on regardless.
                //

                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                    "AfdSaveReceivedConnectData failed: %08lx\n",
                    status
                    ));

            }

        }

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    }

    //
    // Call AfdIndicatePollEvent in case anyone is polling on this
    // connection getting disconnected or aborted.
    //
    // Make sure the connection was accepted/connected
    // in order not to signal on listening endpoint
    //

    if (connection->State==AfdConnectionStateConnected) {
        ASSERT (endpoint->Type & AfdBlockTypeVcConnecting);
        if ( (DisconnectFlags & TDI_DISCONNECT_ABORT) != 0 ) {

            AfdIndicatePollEvent(
                endpoint,
                AFD_POLL_ABORT,
                STATUS_SUCCESS
                );

        } else {

            AfdIndicatePollEvent(
                endpoint,
                AFD_POLL_DISCONNECT,
                STATUS_SUCCESS
                );

        }
    }

    //
    // Remove the connected reference on the connection object.  We must
    // do this AFTER setting up the flag which remembers the disconnect
    // type that occurred.  We must also do this AFTER we have finished
    // handling everything in the endpoint, since the endpoint structure
    // may no longer have any information about the connection object if
    // a transmit request with AFD_TF_REUSE_SOCKET happenned on it.
    //

    AfdDeleteConnectedReference( connection, FALSE );

    //
    // Dereference the connection from the reference added above.
    //

    DEREFERENCE_CONNECTION( connection );

    return STATUS_SUCCESS;

} // AfdDisconnectEventHandler


NTSTATUS
AfdBeginAbort(
    IN PAFD_CONNECTION Connection
    )
{
    PAFD_ENDPOINT endpoint = Connection->Endpoint;
    PIRP irp;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    IF_DEBUG(CONNECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdBeginAbort: aborting on endpoint %p\n",
                    endpoint ));
    }

    UPDATE_CONN( Connection );

    //
    // Build an IRP to reset the connection.  First get the address
    // of the target device object.
    //

    ASSERT( Connection->Type == AfdBlockTypeConnection );
    fileObject = Connection->FileObject;
    ASSERT( fileObject != NULL );
    deviceObject = IoGetRelatedDeviceObject( fileObject );

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Check if connection was accepted and use accept endpoint instead
    // of the listening.  Note that accept cannot happen while we are
    // holding listening endpoint spinlock, nor can endpoint change after
    // the accept and while connection is referenced, so it is safe to 
    // release listening spinlock if we discover that endpoint was accepted.
    //
    if (((endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening)
            && (Connection->Endpoint != endpoint)) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

        endpoint = Connection->Endpoint;
        ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );
        ASSERT( !IS_TDI_BUFFERRING(endpoint) );
        ASSERT(  IS_VC_ENDPOINT (endpoint) );

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    }

    //
    // If the endpoint has already been abortively disconnected,
    // or if has been gracefully disconnected and the transport
    // does not support orderly (i.e. two-phase) release, then just
    // succeed this request.
    //
    // Note that, since the abort completion routine (AfdRestartAbort)
    // will not be called, we must delete the connected reference
    // ourselves and complete outstanding send IRPs if ANY.
    //

    if ( Connection->Aborted ||
         (Connection->DisconnectIndicated &&
             !IS_TDI_ORDERLY_RELEASE(endpoint) )) {
        if ( !IS_TDI_BUFFERRING(endpoint) &&
                endpoint->Type != AfdBlockTypeVcListening ) {
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            AfdCompleteIrpList(
                &Connection->VcSendIrpListHead,
                endpoint,
                STATUS_LOCAL_DISCONNECT,
                AfdCleanupSendIrp
                );
        }
        else {
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        }
        AfdDeleteConnectedReference( Connection, FALSE );
        return STATUS_SUCCESS;
    }

    //
    // Remember that the connection has been aborted.
    //

    if ( (endpoint->Type & AfdBlockTypeVcListening)!= AfdBlockTypeVcListening ) {
        endpoint->DisconnectMode |= AFD_PARTIAL_DISCONNECT_RECEIVE;
        endpoint->DisconnectMode |= AFD_PARTIAL_DISCONNECT_SEND;
        endpoint->DisconnectMode |= AFD_ABORTIVE_DISCONNECT;
    }

    Connection->Aborted = TRUE;

    //
    // Set the BytesTaken fields equal to the BytesIndicated fields so
    // that no more AFD_POLL_RECEIVE or AFD_POLL_RECEIVE_EXPEDITED
    // events get completed.
    //

    if ( IS_TDI_BUFFERRING(endpoint) ) {

        Connection->Common.Bufferring.ReceiveBytesTaken =
            Connection->Common.Bufferring.ReceiveBytesIndicated;
        Connection->Common.Bufferring.ReceiveExpeditedBytesTaken =
            Connection->Common.Bufferring.ReceiveExpeditedBytesIndicated;

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    } else if ( endpoint->Type != AfdBlockTypeVcListening ) {

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Complete all of the connection's pended sends and receives.
        //

        AfdCompleteIrpList(
            &Connection->VcReceiveIrpListHead,
            endpoint,
            STATUS_LOCAL_DISCONNECT,
            NULL
            );

        AfdCompleteIrpList(
            &Connection->VcSendIrpListHead,
            endpoint,
            STATUS_LOCAL_DISCONNECT,
            AfdCleanupSendIrp
            );

    } else {

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
    }

    //
    // Allocate an IRP.  The stack size is one higher than that of the
    // target device, to allow for the caller's completion routine.
    //

    irp = IoAllocateIrp( (CCHAR)(deviceObject->StackSize), FALSE );

    if ( irp == NULL ) {
        //
        // Note that abort failed so we do not attempt to
        // reuse the connection.
        //
        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
        Connection->AbortFailed = TRUE;
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the IRP for an abortive disconnect.
    //

    irp->MdlAddress = NULL;

    irp->Flags = 0;
    irp->RequestorMode = KernelMode;
    irp->PendingReturned = FALSE;

    irp->UserIosb = NULL;
    irp->UserEvent = NULL;

    irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;

    irp->AssociatedIrp.SystemBuffer = NULL;
    irp->UserBuffer = NULL;

    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.AuxiliaryBuffer = NULL;

    TdiBuildDisconnect(
        irp,
        deviceObject,
        fileObject,
        AfdRestartAbort,
        Connection,
        NULL,
        TDI_DISCONNECT_ABORT,
        NULL,
        NULL
        );

    //
    // Reference the connection object so that it does not go away
    // until the abort completes.
    //

    REFERENCE_CONNECTION( Connection );

    AfdRecordAbortiveDisconnectsInitiated();

    //
    // Pass the request to the transport provider.
    //

    return IoCallDriver( deviceObject, irp );

} // AfdBeginAbort



NTSTATUS
AfdRestartAbort(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{

    PAFD_CONNECTION connection;
    PAFD_ENDPOINT endpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    UNREFERENCED_PARAMETER (DeviceObject);

    connection = Context;
    ASSERT( connection != NULL );
    ASSERT( connection->Type == AfdBlockTypeConnection );

    IF_DEBUG(CONNECT) {

        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
            "AfdRestartAbort: abort completed, status = %X, endpoint = %p\n",
            Irp->IoStatus.Status,
            connection->Endpoint
            ));

    }
    endpoint = connection->Endpoint;

    UPDATE_CONN2 ( connection, "Restart abort, status: 0x%lX", Irp->IoStatus.Status);
    AfdRecordAbortiveDisconnectsCompleted();

    //
    // Remember that the connection has been aborted, and indicate if
    // necessary.
    //


    AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    if (!NT_SUCCESS (Irp->IoStatus.Status)) {
        //
        // Note that abort failed so we do not attempt to reuse
        // the connection.
        //
        connection->AbortFailed = TRUE;
    }

    if( connection->State==AfdConnectionStateConnected ) {
        ASSERT (endpoint->Type & AfdBlockTypeVcConnecting);

        AfdIndicateEventSelectEvent (
            endpoint,
            AFD_POLL_ABORT,
            STATUS_SUCCESS
            );
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

        AfdIndicatePollEvent(
            endpoint,
            AFD_POLL_ABORT,
            STATUS_SUCCESS
            );

    }
    else {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
    }

    if( !connection->TdiBufferring ) {

        //
        // Complete all of the connection's pended sends and receives.
        //

        AfdCompleteIrpList(
            &connection->VcReceiveIrpListHead,
            endpoint,
            STATUS_LOCAL_DISCONNECT,
            NULL
            );

        AfdCompleteIrpList(
            &connection->VcSendIrpListHead,
            endpoint,
            STATUS_LOCAL_DISCONNECT,
            AfdCleanupSendIrp
            );

    }

    //
    // Remove the connected reference from the connection, since we
    // know that the connection will not be active any longer.
    //

    AfdDeleteConnectedReference( connection, FALSE );

    //
    // Dereference the AFD connection object.
    //

    DEREFERENCE_CONNECTION( connection );

    //
    // Free the IRP now since it is no longer needed.
    //

    IoFreeIrp( Irp );

    //
    // Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
    // will stop working on the IRP.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

} // AfdRestartAbort


VOID
AfdAbortConnection (
    IN PAFD_CONNECTION Connection
    )
/*++

Routine Description:

    Aborts connection not yet associated with the accepting endpoint
    Forces cleanup path by dereferencing connection.

Arguments:

    Connection - a pointer to the  connection.

Return Value:
    
    None.

--*/
{

    NTSTATUS status;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    ASSERT( Connection->Endpoint != NULL );
    ASSERT( Connection->ConnectedReferenceAdded );

    //
    // Abort the connection. We need to set the CleanupBegun flag
    // before initiating the abort so that the connected reference
    // will get properly removed in AfdRestartAbort.
    //
    // Note that if AfdBeginAbort fails then AfdRestartAbort will not
    // get invoked, so we must remove the connected reference ourselves.
    //

    AfdAcquireSpinLock (&Connection->Endpoint->SpinLock, &lockHandle);
    Connection->CleanupBegun = TRUE;
    AfdReleaseSpinLock (&Connection->Endpoint->SpinLock, &lockHandle);

    status = AfdBeginAbort( Connection );

    if( !NT_SUCCESS(status) ) {
        AfdDeleteConnectedReference( Connection, FALSE );
    }

    //
    // Remove the active reference.
    //

    DEREFERENCE_CONNECTION( Connection );

} // AfdAbortConnection



NTSTATUS
AfdBeginDisconnect(
    IN PAFD_ENDPOINT Endpoint,
    IN PLARGE_INTEGER Timeout OPTIONAL,
    OUT PIRP *DisconnectIrp OPTIONAL
    )
{
    PTDI_CONNECTION_INFORMATION requestConnectionInformation = NULL;
    PTDI_CONNECTION_INFORMATION returnConnectionInformation = NULL;
    PAFD_CONNECTION connection;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PAFD_DISCONNECT_CONTEXT disconnectContext;
    PIRP irp;


    if ( DisconnectIrp != NULL ) {
        *DisconnectIrp = NULL;
    }

    AfdAcquireSpinLock( &Endpoint->SpinLock, &lockHandle );

    ASSERT( Endpoint->Type == AfdBlockTypeVcConnecting );

    connection = AFD_CONNECTION_FROM_ENDPOINT( Endpoint );

    if (connection==NULL) {
        AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );
        return STATUS_SUCCESS;
    }

    ASSERT( connection->Type == AfdBlockTypeConnection );
    UPDATE_CONN( connection );


    //
    // If the endpoint has already been abortively disconnected,
    // just succeed this request.
    //
    if ( connection->Aborted ) {
        AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );
        return STATUS_SUCCESS;
    }

    //
    // If this connection has already been disconnected, just succeed.
    //

    if ( (Endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_SEND) != 0 ) {
        AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );
        return STATUS_SUCCESS;
    }

    fileObject = connection->FileObject;
    ASSERT( fileObject != NULL );
    deviceObject = IoGetRelatedDeviceObject( fileObject );


    //
    // Allocate and initialize a disconnect IRP.
    //

    irp = IoAllocateIrp( (CCHAR)(deviceObject->StackSize), FALSE );
    if ( irp == NULL ) {
        AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the IRP.
    //

    irp->MdlAddress = NULL;

    irp->Flags = 0;
    irp->RequestorMode = KernelMode;
    irp->PendingReturned = FALSE;

    irp->UserIosb = NULL;
    irp->UserEvent = NULL;

    irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;

    irp->AssociatedIrp.SystemBuffer = NULL;
    irp->UserBuffer = NULL;

    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.AuxiliaryBuffer = NULL;


    //
    // Use the disconnect context space in the connection structure.
    //

    disconnectContext = &connection->DisconnectContext;
    disconnectContext->Irp = irp;

    //
    // Remember that the send side has been disconnected.
    //

    Endpoint->DisconnectMode |= AFD_PARTIAL_DISCONNECT_SEND;

    //
    // If there are disconnect data buffers, allocate request
    // and return connection information structures and copy over
    // pointers to the structures.
    //

    if ( connection->ConnectDataBuffers != NULL ) {

        requestConnectionInformation = &connection->ConnectDataBuffers->RequestConnectionInfo;
        RtlZeroMemory (requestConnectionInformation, sizeof (*requestConnectionInformation));

        requestConnectionInformation->UserData =
            connection->ConnectDataBuffers->SendDisconnectData.Buffer;
        requestConnectionInformation->UserDataLength =
            connection->ConnectDataBuffers->SendDisconnectData.BufferLength;
        requestConnectionInformation->Options =
            connection->ConnectDataBuffers->SendDisconnectOptions.Buffer;
        requestConnectionInformation->OptionsLength =
            connection->ConnectDataBuffers->SendDisconnectOptions.BufferLength;

        returnConnectionInformation = &connection->ConnectDataBuffers->ReturnConnectionInfo;
        RtlZeroMemory (returnConnectionInformation, sizeof (*returnConnectionInformation));

        returnConnectionInformation->UserData =
            connection->ConnectDataBuffers->ReceiveDisconnectData.Buffer;
        returnConnectionInformation->UserDataLength =
            connection->ConnectDataBuffers->ReceiveDisconnectData.BufferLength;
        returnConnectionInformation->Options =
            connection->ConnectDataBuffers->ReceiveDisconnectOptions.Buffer;
        returnConnectionInformation->OptionsLength =
            connection->ConnectDataBuffers->ReceiveDisconnectOptions.BufferLength;
    }

    //
    // Set up the timeout for the disconnect.
    //

    if (Timeout==NULL) {
        disconnectContext->Timeout.QuadPart = -1;
    }
    else {
        disconnectContext->Timeout.QuadPart = Timeout->QuadPart;
    }

    //
    // Build a disconnect Irp to pass to the TDI provider.
    //

    TdiBuildDisconnect(
        irp,
        connection->DeviceObject,
        connection->FileObject,
        AfdRestartDisconnect,
        connection,
        &disconnectContext->Timeout,
        TDI_DISCONNECT_RELEASE,
        requestConnectionInformation,
        returnConnectionInformation
        );

    IF_DEBUG(CONNECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdBeginDisconnect: disconnecting endpoint %p\n",
                    Endpoint ));
    }

    //
    // Reference the connection so the space stays
    // allocated until the disconnect completes.
    //

    REFERENCE_CONNECTION( connection );

    //
    // If there are still outstanding sends and this is a nonbufferring
    // TDI transport which does not support orderly release, pend the
    // IRP until all the sends have completed.
    //

    if ( !IS_TDI_ORDERLY_RELEASE(Endpoint) &&
         !IS_TDI_BUFFERRING(Endpoint) && connection->VcBufferredSendCount != 0 ) {

        ASSERT( connection->VcDisconnectIrp == NULL );

        connection->VcDisconnectIrp = irp;
        connection->SpecialCondition = TRUE;
        AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );

        return STATUS_PENDING;
    }

    AfdRecordGracefulDisconnectsInitiated();
    AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );


    //
    // Pass the disconnect request on to the TDI provider.
    //

    if ( DisconnectIrp == NULL ) {
        return IoCallDriver( connection->DeviceObject, irp );
    } else {
        *DisconnectIrp = irp;
        return STATUS_SUCCESS;
    }

} // AfdBeginDisconnect


NTSTATUS
AfdRestartDisconnect(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PAFD_CONNECT_DATA_BUFFERS connectDataBuffers;
    PAFD_CONNECTION connection=Context;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    UNREFERENCED_PARAMETER (DeviceObject);

    UPDATE_CONN2( connection, "Restart disconnect, status: 0x%lX", Irp->IoStatus.Status );
    AfdRecordGracefulDisconnectsCompleted();

    ASSERT( connection != NULL );
    ASSERT( connection->Type == AfdBlockTypeConnection );

    IF_DEBUG(CONNECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdRestartDisconnect: disconnect completed, status = %X, endpoint = %p\n",
                    Irp->IoStatus.Status, connection->Endpoint ));
    }

    if (NT_SUCCESS (Irp->IoStatus.Status)) {
        if (connection->ConnectDataBuffers!=NULL) {
            PAFD_ENDPOINT   endpoint = connection->Endpoint;

            AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);

            //
            // Check if connection was accepted and use accept endpoint instead
            // of the listening.  Note that accept cannot happen while we are
            // holding listening endpoint spinlock, nor can endpoint change after
            // the accept and while connection is referenced, so it is safe to 
            // release listening spinlock if we discover that endpoint was accepted.
            //
            if (((endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening)
                    && (connection->Endpoint != endpoint)) {
                AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

                endpoint = connection->Endpoint;
                ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );
                ASSERT( !IS_TDI_BUFFERRING(endpoint) );
                ASSERT( IS_VC_ENDPOINT (endpoint) );

                AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
            }

            connectDataBuffers = connection->ConnectDataBuffers;
            if (connectDataBuffers!=NULL) {
                if( connectDataBuffers->ReturnConnectionInfo.UserData != NULL && 
                        connectDataBuffers->ReturnConnectionInfo.UserDataLength > 0 ) {
                    NTSTATUS    status;


                    status = AfdSaveReceivedConnectData(
                                 &connectDataBuffers,
                                 IOCTL_AFD_SET_DISCONNECT_DATA,
                                 connectDataBuffers->ReturnConnectionInfo.UserData,
                                 connectDataBuffers->ReturnConnectionInfo.UserDataLength
                                 );
                    ASSERT (NT_SUCCESS(status));
                }

                if( connectDataBuffers->ReturnConnectionInfo.Options != NULL &&
                        connectDataBuffers->ReturnConnectionInfo.OptionsLength > 0 ) {
                    NTSTATUS    status;

                    status = AfdSaveReceivedConnectData(
                                 &connectDataBuffers,
                                 IOCTL_AFD_SET_DISCONNECT_OPTIONS,
                                 connectDataBuffers->ReturnConnectionInfo.Options,
                                 connectDataBuffers->ReturnConnectionInfo.OptionsLength
                                 );

                    ASSERT (NT_SUCCESS(status));
                }

            }
            AfdReleaseSpinLock (&connection->Endpoint->SpinLock, &lockHandle);
        }
    }
    else {
        AfdBeginAbort (connection);
    }


    DEREFERENCE_CONNECTION( connection );

    //
    // Free the IRP and return a status code so that the IO system will
    // stop working on the IRP.
    //

    IoFreeIrp( Irp );
    return STATUS_MORE_PROCESSING_REQUIRED;

} // AfdRestartDisconnect
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\create.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    This module contains code for opening a handle to AFD.

Author:

    David Treadwell (davidtr)    21-Feb-1992

Revision History:

--*/

#include "afdp.h"

BOOLEAN
AfdPerformSecurityCheck (
    PIRP                Irp,
    PIO_STACK_LOCATION  IrpSp,
    PNTSTATUS           Status
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfdCreate )
#pragma alloc_text( PAGE, AfdPerformSecurityCheck )
#endif




NTSTATUS
FASTCALL
AfdCreate (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the routine that handles Create IRPs in AFD.  If creates an
    AFD_ENDPOINT structure and fills it in with the information
    specified in the open packet.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PAFD_ENDPOINT endpoint;
    PFILE_FULL_EA_INFORMATION eaBuffer;
    UNICODE_STRING transportDeviceName;
    NTSTATUS status;

    PAGED_CODE( );

    DEBUG endpoint = NULL;

    //
    // Find the open packet from the EA buffer in the system buffer of
    // the associated IRP.  Fail the request if there was no EA
    // buffer specified.
    //

    eaBuffer = Irp->AssociatedIrp.SystemBuffer;

    if ( eaBuffer == NULL ) {

        //
        // Allocate an AFD "helper" endpoint.
        //

        status = AfdAllocateEndpoint(
                     &endpoint,
                     NULL,
                     0
                     );

        if( !NT_SUCCESS(status) ) {
            return status;
        }

    } else {
        STRING  EaName;
        STRING  CString;

        EaName.MaximumLength = eaBuffer->EaNameLength+1;
        EaName.Length = eaBuffer->EaNameLength;
        EaName.Buffer = eaBuffer->EaName;

        if (RtlInitString (&CString, AfdOpenPacket),
                RtlEqualString(&CString, &EaName, FALSE)) {
            PAFD_OPEN_PACKET openPacket;
            ULONG   length;
            openPacket = (PAFD_OPEN_PACKET)(eaBuffer->EaName +
                                            eaBuffer->EaNameLength + 1);

            //
            // Make sure that the transport address fits within the specified
            // EA buffer.
            //

            if ((eaBuffer->EaValueLength<sizeof (*openPacket)) ||
                    //
                    // Make sure the cast to USHORT below is valid
                    //
                    (length = openPacket->TransportDeviceNameLength +
                                    sizeof (UNICODE_NULL)) > MAXUSHORT ||
                    //
                    // Check for overflow
                    //
                    length < openPacket->TransportDeviceNameLength ||
                    FIELD_OFFSET(AFD_OPEN_PACKET,
                                TransportDeviceName[length/sizeof (WCHAR)]) <
                        FIELD_OFFSET(AFD_OPEN_PACKET, TransportDeviceName[1]) ||

                    //
                    // Check if string + NULL fits into the buffer
                    //
                    eaBuffer->EaValueLength <
                        FIELD_OFFSET(AFD_OPEN_PACKET,
                                    TransportDeviceName[length/sizeof(WCHAR)]) ) {
                return STATUS_ACCESS_VIOLATION;
            }
            //
            // Validate parameters in the open packet.
            //

            if ( (openPacket->afdEndpointFlags&(~AFD_ENDPOINT_VALID_FLAGS)) ||
                 ( (length / sizeof(WCHAR))*sizeof(WCHAR) != length) // odd-value length
                 ) {

                          
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Set up a string that describes the transport device name.
            //

            transportDeviceName.Buffer = openPacket->TransportDeviceName;
            transportDeviceName.Length = (USHORT)openPacket->TransportDeviceNameLength;
            transportDeviceName.MaximumLength = (USHORT)length;



            //
            // Allocate an AFD endpoint.
            //

            status = AfdAllocateEndpoint(
                         &endpoint,
                         &transportDeviceName,
                         openPacket->GroupID
                         );

            if( !NT_SUCCESS(status) ) {
                return status;
            }
            //
            // Store the flags.
            //
            endpoint->afdEndpointFlags = openPacket->afdEndpointFlags;

            //
            // Remember the type of endpoint that this is.  If this is a datagram
            // endpoint, change the block type to reflect this.
            //


            if (openPacket->afdConnectionLess) {

                endpoint->Type = AfdBlockTypeDatagram;

                //
                // Initialize lists which exist only in datagram endpoints.
                //

                InitializeListHead( &endpoint->ReceiveDatagramIrpListHead );
                InitializeListHead( &endpoint->PeekDatagramIrpListHead );
                InitializeListHead( &endpoint->ReceiveDatagramBufferListHead );

                endpoint->Common.Datagram.MaxBufferredReceiveBytes = AfdReceiveWindowSize;
                endpoint->Common.Datagram.MaxBufferredSendBytes = AfdSendWindowSize;
            }
        }
        else if (RtlInitString (&CString, AfdSwitchOpenPacket),
                RtlEqualString(&CString, &EaName, FALSE)) {
            status = AfdSanCreateHelper (Irp, eaBuffer, &endpoint);
            if (!NT_SUCCESS (status))
                return status;
        }
        else {
            IF_DEBUG(OPEN_CLOSE) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdCreate: Invalid ea name.\n"));
            }
            return STATUS_INVALID_PARAMETER;
        }
    }

    ASSERT( endpoint != NULL );

    //
    // Perform security check on caller.
    // We need this for giving access to raw sockets (for transports
    // that do not support access checks) and SAN helpers.

    if (IS_SAN_HELPER(endpoint) || 
            (endpoint->afdRaw && 
                (!endpoint->TransportInfo->InfoValid ||
                 !IS_TDI_FORCE_ACCESS_CHECK(endpoint)) ) ) {
        endpoint->AdminAccessGranted = AfdPerformSecurityCheck (Irp, IrpSp, &status);
    }


    //
    // Set up a pointer to the endpoint in the file object so that we
    // can find the endpoint in future calls.
    //

    IrpSp->FileObject->FsContext = endpoint;
    //
    // Setting this field to non-NULL value enable fast IO code path
    // for reads and writes.
    //
    IrpSp->FileObject->PrivateCacheMap = (PVOID)-1;

    IF_DEBUG(OPEN_CLOSE) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdCreate: opened file object = %p, endpoint = %p\n",
                    IrpSp->FileObject, endpoint ));

    }

    //
    // The open worked.  Dereference the endpoint and return success.
    //

    DEREFERENCE_ENDPOINT( endpoint );

    return STATUS_SUCCESS;

} // AfdCreate


BOOLEAN
AfdPerformSecurityCheck (
    PIRP                Irp,
    PIO_STACK_LOCATION  IrpSp,
    PNTSTATUS           Status
    )
/*++

Routine Description:

    Compares security context of the endpoint creator to that
    of the administrator and local system.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

    Status - returns status generated by access check on failure.

Return Value:

    TRUE    - the socket creator has admin or local system privilige
    FALSE    - the socket creator is just a plain user

--*/

{
    BOOLEAN               accessGranted;
    PACCESS_STATE         accessState;
    PIO_SECURITY_CONTEXT  securityContext;
    PPRIVILEGE_SET        privileges = NULL;
    ACCESS_MASK           grantedAccess;
    PGENERIC_MAPPING GenericMapping;
    ACCESS_MASK AccessMask = GENERIC_ALL;

    //
    // Enable access to all the globally defined SIDs
    //

    GenericMapping = IoGetFileObjectGenericMapping();

    RtlMapGenericMask( &AccessMask, GenericMapping );


    securityContext = IrpSp->Parameters.Create.SecurityContext;
    accessState = securityContext->AccessState;

    SeLockSubjectContext(&accessState->SubjectSecurityContext);

    accessGranted = SeAccessCheck(
                        AfdAdminSecurityDescriptor,
                        &accessState->SubjectSecurityContext,
                        TRUE,
                        AccessMask,
                        0,
                        &privileges,
                        IoGetFileObjectGenericMapping(),
                        (KPROCESSOR_MODE)((IrpSp->Flags & SL_FORCE_ACCESS_CHECK)
                            ? UserMode
                            : Irp->RequestorMode),
                        &grantedAccess,
                        Status
                        );

    if (privileges) {
        (VOID) SeAppendPrivileges(
                   accessState,
                   privileges
                   );
        SeFreePrivileges(privileges);
    }

    if (accessGranted) {
        accessState->PreviouslyGrantedAccess |= grantedAccess;
        accessState->RemainingDesiredAccess &= ~( grantedAccess | MAXIMUM_ALLOWED );
        ASSERT (NT_SUCCESS (*Status));
    }
    else {
        ASSERT (!NT_SUCCESS (*Status));
    }
    SeUnlockSubjectContext(&accessState->SubjectSecurityContext);

    return accessGranted;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\init.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module performs initialization for the AFD device driver.

Author:

    David Treadwell (davidtr)    21-Feb-1992

Revision History:

--*/

#include "afdp.h"

//
// Location of AFD configurable parameters in the registyr.
//
#define REGISTRY_AFD_INFORMATION \
            L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Afd"
#define REGISTRY_PARAMETERS                     L"Parameters"

//
// Parameter value names.
//
#define REGISTRY_BUFFER_ALIGNMENT               L"BufferAlignment"
#define REGISTRY_IRP_STACK_SIZE                 L"IrpStackSize"
#define REGISTRY_PRIORITY_BOOST                 L"PriorityBoost"
#define REGISTRY_IGNORE_PUSH_BIT                L"IgnorePushBitOnReceives"
#define REGISTRY_NO_RAW_SECURITY                L"DisableRawSecurity"
#define REGISTRY_NO_DIRECT_ACCEPTEX             L"DisableDirectAcceptEx"
#define REGISTRY_DISABLE_CHAINED_RECV           L"DisableChainedReceive"
#ifdef TDI_SERVICE_SEND_AND_DISCONNECT
#define REGISTRY_USE_TDI_SEND_AND_DISCONNECT    L"UseTdiSendAndDisconnect"
#endif // TDI_SERVICE_SEND_AND_DISCONNECT

#define REGISTRY_STANDARD_ADDRESS_LENGTH        L"StandardAddressLength"
#define REGISTRY_DEFAULT_RECEIVE_WINDOW         L"DefaultReceiveWindow"
#define REGISTRY_DEFAULT_SEND_WINDOW            L"DefaultSendWindow"

#define REGISTRY_LARGE_BUFFER_SIZE              L"LargeBufferSize"
#define REGISTRY_LARGE_BUFFER_LIST_DEPTH        L"LargeBufferListDepth"
#define REGISTRY_MEDIUM_BUFFER_SIZE             L"MediumBufferSize"
#define REGISTRY_MEDIUM_BUFFER_LIST_DEPTH       L"MediumBufferListDepth"
#define REGISTRY_SMALL_BUFFER_SIZE              L"SmallBufferSize"
#define REGISTRY_SMALL_BUFFER_LIST_DEPTH        L"SmallBufferListDepth"
#define REGISTRY_BUFFER_TAG_LIST_DEPTH          L"BufferTagListDepth"

#define REGISTRY_MAX_ACTIVE_TRANSMIT_FILE_COUNT L"MaxActiveTransmitFileCount"
#define REGISTRY_DEFAULT_PACKET_ELEMENT_COUNT   L"DefaultPacketElementCount"
#define REGISTRY_TRANSMIT_WORKER                L"TransmitWorker"

#define REGISTRY_ENABLE_DYNAMIC_BACKLOG         L"EnableDynamicBacklog"
#define REGISTRY_MINIMUM_DYNAMIC_BACKLOG        L"MinimumDynamicBacklog"
#define REGISTRY_MAXIMUM_DYNAMIC_BACKLOG        L"MaximumDynamicBacklog"
#define REGISTRY_DYNAMIC_BACKLOG_GROWTH_DELTA   L"DynamicBacklogGrowthDelta"

#define REGISTRY_VOLATILE_PARAMETERS            L"VolatileParameters"

#define REGISTRY_BLOCKING_SEND_COPY_THRESHOLD   L"BlockingSendCopyThreshold"
#define REGISTRY_FAST_SEND_DATAGRAM_THRESHOLD   L"FastSendDatagramThreshold"
#define REGISTRY_PACKET_FRAGMENT_COPY_THRESHOLD L"PacketFragmentCopyThreshold"
#define REGISTRY_TRANSMIT_IO_LENGTH             L"TransmitIoLength"
#define REGISTRY_MAX_FAST_TRANSMIT              L"MaxFastTransmit"
#define REGISTRY_MAX_FAST_COPY_TRANSMIT         L"MaxFastCopyTransmit"

#if DBG
#define REGISTRY_DEBUG_FLAGS                    L"DebugFlags"
#define REGISTRY_BREAK_ON_STARTUP               L"BreakOnStartup"
#define REGISTRY_USE_PRIVATE_ASSERT             L"UsePrivateAssert"
#endif

#if AFD_PERF_DBG
#define REGISTRY_DISABLE_FAST_IO                L"DisableFastIO"
#define REGISTRY_DISABLE_CONN_REUSE             L"DisableConnectionReuse"
#endif

//
// A list of longwords that are configured by the registry.
//

struct _AfdConfigInfo {
    PWCHAR RegistryValueName;
    PULONG Variable;
} AfdConfigInfo[] = {
    { REGISTRY_STANDARD_ADDRESS_LENGTH,         &AfdStandardAddressLength },
    { REGISTRY_DEFAULT_RECEIVE_WINDOW,          &AfdReceiveWindowSize },
    { REGISTRY_DEFAULT_SEND_WINDOW,             &AfdSendWindowSize },

    { REGISTRY_LARGE_BUFFER_SIZE,               &AfdLargeBufferSize },
    { REGISTRY_LARGE_BUFFER_LIST_DEPTH,         &AfdLargeBufferListDepth },
    { REGISTRY_MEDIUM_BUFFER_SIZE,              &AfdMediumBufferSize },
    { REGISTRY_MEDIUM_BUFFER_LIST_DEPTH,        &AfdMediumBufferListDepth },
    { REGISTRY_SMALL_BUFFER_SIZE,               &AfdSmallBufferSize },
    { REGISTRY_SMALL_BUFFER_LIST_DEPTH,         &AfdSmallBufferListDepth },
    { REGISTRY_BUFFER_TAG_LIST_DEPTH,           &AfdBufferTagListDepth },

    { REGISTRY_BLOCKING_SEND_COPY_THRESHOLD,    &AfdBlockingSendCopyThreshold },
    { REGISTRY_FAST_SEND_DATAGRAM_THRESHOLD,    &AfdFastSendDatagramThreshold },
    { REGISTRY_PACKET_FRAGMENT_COPY_THRESHOLD,  &AfdTPacketsCopyThreshold },
    { REGISTRY_TRANSMIT_IO_LENGTH,              &AfdTransmitIoLength },
    { REGISTRY_MAX_FAST_TRANSMIT,               &AfdMaxFastTransmit },
    { REGISTRY_MAX_FAST_COPY_TRANSMIT,          &AfdMaxFastCopyTransmit },

    { REGISTRY_DEFAULT_PACKET_ELEMENT_COUNT,    &AfdDefaultTpInfoElementCount },
    { REGISTRY_TRANSMIT_WORKER,                 &AfdDefaultTransmitWorker},

    { REGISTRY_MINIMUM_DYNAMIC_BACKLOG,         (PULONG)&AfdMinimumDynamicBacklog },
    { REGISTRY_MAXIMUM_DYNAMIC_BACKLOG,         (PULONG)&AfdMaximumDynamicBacklog },
    { REGISTRY_DYNAMIC_BACKLOG_GROWTH_DELTA,    (PULONG)&AfdDynamicBacklogGrowthDelta }
},

//
// A list of volatile longword parameters.
//
AfdVolatileConfigInfo []= {
    { REGISTRY_BLOCKING_SEND_COPY_THRESHOLD,    &AfdBlockingSendCopyThreshold },
    { REGISTRY_FAST_SEND_DATAGRAM_THRESHOLD,    &AfdFastSendDatagramThreshold },
    { REGISTRY_PACKET_FRAGMENT_COPY_THRESHOLD,  &AfdTPacketsCopyThreshold },
    { REGISTRY_TRANSMIT_IO_LENGTH,              &AfdTransmitIoLength },
    { REGISTRY_MAX_FAST_TRANSMIT,               &AfdMaxFastTransmit },
    { REGISTRY_MAX_FAST_COPY_TRANSMIT,          &AfdMaxFastCopyTransmit },
};


#define AFD_CONFIG_VAR_COUNT (sizeof(AfdConfigInfo) / sizeof(AfdConfigInfo[0]))
#define AFD_VOLATILE_CONFIG_VAR_COUNT (sizeof(AfdVolatileConfigInfo) / sizeof(AfdVolatileConfigInfo[0]))

VOID
AfdReadVolatileParameters (
    PVOID   Parameter
    );

VOID
AfdReleaseRegistryHandleWait (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

ULONG
AfdReadSingleParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN LONG DefaultValue
    );

NTSTATUS
AfdOpenRegistry(
    IN PUNICODE_STRING BaseName,
    OUT PHANDLE ParametersHandle
    );

VOID
AfdReadRegistry (
    VOID
    );

VOID
AfdUnload (
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
AfdCreateSecurityDescriptor(
    VOID
    );

NTSTATUS
AfdBuildDeviceAcl(
    OUT PACL *DeviceAcl
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, DriverEntry )
#pragma alloc_text( PAGE, AfdReadSingleParameter )
#pragma alloc_text( INIT, AfdOpenRegistry )
#pragma alloc_text( INIT, AfdReadRegistry )
#pragma alloc_text( INIT, AfdCreateSecurityDescriptor )
#pragma alloc_text( INIT, AfdBuildDeviceAcl )
#pragma alloc_text( PAGE, AfdUnload )
#pragma alloc_text( PAGE, AfdReadVolatileParameters )
#pragma alloc_text( PAGE, AfdReleaseRegistryHandleWait )
#endif


NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the AFD device driver.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    NTSTATUS status;
    UNICODE_STRING deviceName;
    CLONG i;
    BOOLEAN success;
    ULONG   size;

    UNREFERENCED_PARAMETER (RegistryPath);
    PAGED_CODE( );

    //
    // Create the device object.  (IoCreateDevice zeroes the memory
    // occupied by the object.)
    //
    // !!! Apply an ACL to the device object.
    //

    RtlInitUnicodeString( &deviceName, AFD_DEVICE_NAME );

    status = IoCreateDevice(
                 DriverObject,                   // DriverObject
                 0,                              // DeviceExtension
                 &deviceName,                    // DeviceName
                 FILE_DEVICE_NAMED_PIPE,         // DeviceType
                 0,                              // DeviceCharacteristics
                 FALSE,                          // Exclusive
                 &AfdDeviceObject                // DeviceObject
                 );


    if ( !NT_SUCCESS(status) ) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_ERROR_LEVEL,
                    "AFD DriverEntry: unable to create device object: %lx\n",
                    status ));
        goto error_exit;
    }

    AfdWorkQueueItem = IoAllocateWorkItem (AfdDeviceObject);
    if (AfdWorkQueueItem==NULL) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AFD DriverEntry: unable to allocate work queue item\n" ));
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto error_exit;
    }

    KeInitializeEvent (&AfdContextWaitEvent, NotificationEvent, FALSE);

    //
    // Create the security descriptor used for socket access checks.
    //
    status = AfdCreateSecurityDescriptor();

    if (!NT_SUCCESS(status)) {
        goto error_exit;
    }


    //
    // Initialize global data.
    //
    AfdInitializeData( );

    //
    // Read registry information.
    // This may override hard-coded global
    // initialization above.
    //

    AfdReadRegistry( );

#ifdef AFD_CHECK_ALIGNMENT
    AfdGlobalData = AFD_ALLOCATE_POOL_PRIORITY(
                      NonPagedPool,
                      FIELD_OFFSET (AFD_GLOBAL_DATA, BufferAlignmentTable[AfdAlignmentTableSize])
                      // Note that although we have an array of UCHARs above
                      // we do not need to align the array of ULONGs 
                      // since the UCHAR array size is aligned
                      // to processor requirement.
                        + AfdAlignmentTableSize*sizeof(LONG),
                      AFD_RESOURCE_POOL_TAG,
                      HighPoolPriority
                      );
#else
    AfdGlobalData = AFD_ALLOCATE_POOL_PRIORITY(
                      NonPagedPool,
                      FIELD_OFFSET (AFD_GLOBAL_DATA, BufferAlignmentTable[AfdAlignmentTableSize]),
                      AFD_RESOURCE_POOL_TAG,
                      HighPoolPriority
                      );
#endif

    if ( AfdGlobalData == NULL ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto error_exit;
    }

    ExInitializeResourceLite( AfdResource );

    AfdInitializeBufferManager();

    //
    // Initialize the AFD buffer lookaside lists.  These must be
    // initialized *after* the registry data has been read.
    //

    size = AfdCalculateBufferSize (AfdLargeBufferSize,
                                    AfdStandardAddressLength,
                                    AfdTdiStackSize);
    ExInitializeNPagedLookasideList(
        &AfdLookasideLists->LargeBufferList,
        AfdAllocateBuffer,
        AfdFreeBuffer,
        0,
        size,
        AFD_DATA_BUFFER_POOL_TAG,
        (USHORT)AfdLargeBufferListDepth
        );

    //
    // Make sure that if as the result of alignment the allocation size is adjusted
    // to equal to the larger one, the actual buffer sizes are adjusted as well.
    // This is necessary to avoid confusing block allocator which determines
    // buffer size based on the allocation size passed by the lookaside list
    // code.
    //
    size = AfdCalculateBufferSize (AfdMediumBufferSize, 
                                    AfdStandardAddressLength,
                                    AfdTdiStackSize);
    if (size==AfdLookasideLists->LargeBufferList.L.Size) {
        AfdMediumBufferSize = AfdLargeBufferSize;
    }
    else {
        ASSERT (size<AfdLookasideLists->LargeBufferList.L.Size);
    }
    ExInitializeNPagedLookasideList(
        &AfdLookasideLists->MediumBufferList,
        AfdAllocateBuffer,
        AfdFreeBuffer,
        0,
        size,
        AFD_DATA_BUFFER_POOL_TAG,
        (USHORT)AfdMediumBufferListDepth
        );

    size = AfdCalculateBufferSize (AfdSmallBufferSize,
                                    AfdStandardAddressLength, 
                                    AfdTdiStackSize);
    if (size==AfdLookasideLists->MediumBufferList.L.Size) {
        AfdSmallBufferSize = AfdMediumBufferSize;
    }
    else {
        ASSERT (size<AfdLookasideLists->MediumBufferList.L.Size);
    }
    ExInitializeNPagedLookasideList(
        &AfdLookasideLists->SmallBufferList,
        AfdAllocateBuffer,
        AfdFreeBuffer,
        0,
        size,
        AFD_DATA_BUFFER_POOL_TAG,
        (USHORT)AfdSmallBufferListDepth
        );

    ExInitializeNPagedLookasideList(
        &AfdLookasideLists->BufferTagList,
        AfdAllocateBufferTag,
        AfdFreeBufferTag,
        0,
        sizeof (AFD_BUFFER_TAG),
        AFD_DATA_BUFFER_POOL_TAG,
        (USHORT)AfdBufferTagListDepth
        );

    ExInitializeNPagedLookasideList(
        &AfdLookasideLists->TpInfoList,
        AfdAllocateTpInfo,
        AfdFreeTpInfo,
        0,
        AfdComputeTpInfoSize (AfdDefaultTpInfoElementCount,
                                AfdTdiStackSize),
        AFD_TRANSMIT_INFO_POOL_TAG,
        0
        );

    ExInitializeNPagedLookasideList(
        &AfdLookasideLists->RemoteAddrList,
        AfdAllocateRemoteAddress,
        AfdFreeRemoteAddress,
        0,
        AfdStandardAddressLength,
        AFD_REMOTE_ADDRESS_POOL_TAG,
        (USHORT)AfdBufferTagListDepth
        );

    AfdLookasideLists->TrimFlags = 0;

    //
    // Initialize group ID manager.
    //

    success = AfdInitializeGroup();
    if ( !success ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto error_exit;
    }



    //
    // Initialize the driver object for this file system driver.
    //

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = AfdDispatch;
    }
    //
    // Special case for IRP_MJ_DEVICE_CONTROL since it is
    // the most often used function in AFD.
    //
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] =
            AfdDispatchDeviceControl;

    DriverObject->FastIoDispatch = &AfdFastIoDispatch;
    DriverObject->DriverUnload = AfdUnload;

    //
    // Initialize our device object.
    //

    AfdDeviceObject->Flags |= DO_DIRECT_IO;
    AfdDeviceObject->StackSize = AfdIrpStackSize;

    //
    // Remember a pointer to the system process.  We'll use this pointer
    // for KeAttachProcess() calls so that we can open handles in the
    // context of the system process.
    //

    AfdSystemProcess = (PKPROCESS)IoGetCurrentProcess();

    //
    // Start notification for volatile parameters if necessary.
    //
    if (AfdParametersNotifyHandle) {
        AfdReadVolatileParameters (NULL);
    }

    //
    // Tell MM that it can page all of AFD it is desires.  We will reset
    // to normal paging of AFD code as soon as an AFD endpoint is
    // opened.
    //

    AfdLoaded = NULL;

    MmPageEntireDriver( (PVOID)DriverEntry );

    return (status);

error_exit:


    //
    // Terminate the group ID manager.
    //

    AfdTerminateGroup();

    if (AfdAdminSecurityDescriptor!=NULL) {
        ExFreePool (AfdAdminSecurityDescriptor);
        AfdAdminSecurityDescriptor = NULL;
    }

    if( AfdGlobalData != NULL ) {

        ExDeleteNPagedLookasideList( &AfdLookasideLists->LargeBufferList );
        ExDeleteNPagedLookasideList( &AfdLookasideLists->MediumBufferList );
        ExDeleteNPagedLookasideList( &AfdLookasideLists->SmallBufferList );
        ExDeleteNPagedLookasideList( &AfdLookasideLists->BufferTagList );
        ExDeleteNPagedLookasideList( &AfdLookasideLists->TpInfoList );
        ExDeleteNPagedLookasideList( &AfdLookasideLists->RemoteAddrList );

        ExDeleteResourceLite( AfdResource );

        AFD_FREE_POOL(
            AfdGlobalData,
            AFD_RESOURCE_POOL_TAG
            );
        AfdGlobalData = NULL;

    }

    if (AfdWorkQueueItem!=NULL) {
        IoFreeWorkItem (AfdWorkQueueItem);
        AfdWorkQueueItem = NULL;
    }

    if (AfdDeviceObject!=NULL) {
        IoDeleteDevice(AfdDeviceObject);
        AfdDeviceObject = NULL;
    }

    return status;

} // DriverEntry


VOID
AfdUnload (
    IN PDRIVER_OBJECT DriverObject
    )
{

    PLIST_ENTRY listEntry;
    KEVENT      event;
    BOOLEAN     wait;

    UNREFERENCED_PARAMETER( DriverObject );

    PAGED_CODE( );

    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                "AfdUnload called.\n" ));

    if (AfdParametersNotifyHandle!=NULL) {
        NTSTATUS    status;
        KeEnterCriticalRegion ();
        ExAcquireResourceExclusiveLite( AfdResource, TRUE );
        ZwClose (AfdParametersNotifyHandle);
        AfdParametersNotifyHandle = NULL;
        KeInitializeEvent( &event, SynchronizationEvent, FALSE );
        AfdParametersUnloadEvent = &event;
        ExReleaseResourceLite( AfdResource );
        KeLeaveCriticalRegion ();

        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL, 
                    "AfdUnload: Waiting for registry notification to fire...\n"));
        status = KeWaitForSingleObject( (PVOID)&event, Executive, KernelMode,  FALSE, NULL );
        ASSERT (NT_SUCCESS (status));
    }
    //
    // Check if AFD has already cleaned up all endpoints and
    // is ready to get unloaded.
    //
    KeEnterCriticalRegion ();
    ExAcquireResourceExclusiveLite( AfdResource, TRUE );
    if (AfdLoaded!=NULL) {
        //
        // Some work still needs to be done. Setup the wait.
        //
        ASSERT (AfdLoaded==(PKEVENT)1);
        KeInitializeEvent( &event, SynchronizationEvent, FALSE );
        AfdLoaded = &event;
        wait = TRUE;
    }
    else
        wait = FALSE;

    ExReleaseResourceLite( AfdResource );
    KeLeaveCriticalRegion ();

    if (wait) {
        NTSTATUS    status;
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL, 
                    "AfdUnload: Waiting for endpoints to cleanup...\n"));
        status = KeWaitForSingleObject( (PVOID)&event, Executive, KernelMode,  FALSE, NULL );
        ASSERT (NT_SUCCESS (status));
    }

    //
    // Kill the transport info list.
    //

    while( !IsListEmpty( &AfdTransportInfoListHead ) ) {
        PAFD_TRANSPORT_INFO transportInfo;

        listEntry = RemoveHeadList( &AfdTransportInfoListHead );

        transportInfo = CONTAINING_RECORD(
                            listEntry,
                            AFD_TRANSPORT_INFO,
                            TransportInfoListEntry
                            );

        ASSERT (transportInfo->ReferenceCount == 1);


        AFD_FREE_POOL(
            transportInfo,
            AFD_TRANSPORT_INFO_POOL_TAG
            );

    }

    //
    // Free address list and associated structures
    //
    AfdDeregisterPnPHandlers (NULL);

    if (AfdAddressListLock) {

        ExDeleteResourceLite( AfdAddressListLock );

        AFD_FREE_POOL(
            AfdAddressListLock,
            AFD_RESOURCE_POOL_TAG
            );
    }

    if (AfdTdiPnPHandlerLock) {

        ExDeleteResourceLite( AfdTdiPnPHandlerLock );

        AFD_FREE_POOL(
            AfdTdiPnPHandlerLock,
            AFD_RESOURCE_POOL_TAG
            );
    }

    //
    // Do some cleanup for SAN
    //
    if (IoCompletionObjectType!=NULL) {
        ObDereferenceObject (IoCompletionObjectType);
        IoCompletionObjectType = NULL;
    }

    if (AfdAdminSecurityDescriptor!=NULL) {
        ExFreePool (AfdAdminSecurityDescriptor);
        AfdAdminSecurityDescriptor = NULL;
    }

    //
    // Terminate the group ID manager.
    //

    AfdTerminateGroup();
#if DBG || REFERENCE_DEBUG
    AfdFreeDebugData ();
#endif

    //
    // Kill the lookaside lists and resource in the global data
    //

    if( AfdGlobalData != NULL ) {

        ExDeleteNPagedLookasideList( &AfdLookasideLists->LargeBufferList );
        ExDeleteNPagedLookasideList( &AfdLookasideLists->MediumBufferList );
        ExDeleteNPagedLookasideList( &AfdLookasideLists->SmallBufferList );
        ExDeleteNPagedLookasideList( &AfdLookasideLists->BufferTagList );
        ExDeleteNPagedLookasideList( &AfdLookasideLists->TpInfoList );
        ExDeleteNPagedLookasideList( &AfdLookasideLists->RemoteAddrList );

        ExDeleteResourceLite( AfdResource );

        AFD_FREE_POOL(
            AfdGlobalData,
            AFD_RESOURCE_POOL_TAG
            );

        AfdGlobalData = NULL;

    }

    //
    // Delete our device object.
    //

    IoDeleteDevice( AfdDeviceObject );

} // AfdUnload


VOID
AfdReadRegistry (
    VOID
    )

/*++

Routine Description:

    Reads the AFD section of the registry.  Any values listed in the
    registry override defaults.

Arguments:

    None.

Return Value:

    None -- if anything fails, the default value is used.

--*/
{
    HANDLE parametersHandle;
    NTSTATUS status;
    ULONG stackSize;
    ULONG priorityBoost;
    ULONG bufferAlignment;
    UNICODE_STRING registryPath;
    ULONG i;

    PAGED_CODE( );

    RtlInitUnicodeString( &registryPath, REGISTRY_AFD_INFORMATION );

    status = AfdOpenRegistry( &registryPath, &parametersHandle );

    if (status != STATUS_SUCCESS) {
        return;
    }

#if DBG
    //
    // Read the debug flags from the registry.
    //

    AfdDebug = AfdReadSingleParameter(
                   parametersHandle,
                   REGISTRY_DEBUG_FLAGS,
                   AfdDebug
                   );

    //
    // Force a breakpoint if so requested.
    //

    if( AfdReadSingleParameter(
            parametersHandle,
            REGISTRY_BREAK_ON_STARTUP,
            0 ) != 0 ) {
        DbgBreakPoint();
    }

    //
    // Enable private assert function if requested.
    //

    AfdUsePrivateAssert = (BOOLEAN)(AfdReadSingleParameter(
                              parametersHandle,
                              REGISTRY_USE_PRIVATE_ASSERT,
                              (LONG)AfdUsePrivateAssert
                              ) != 0);
#endif

#if AFD_PERF_DBG
    //
    // Read a flag from the registry that allows us to disable Fast IO.
    //

    AfdDisableFastIo = (BOOLEAN)(AfdReadSingleParameter(
                           parametersHandle,
                           REGISTRY_DISABLE_FAST_IO,
                           (LONG)AfdDisableFastIo
                           ) != 0);

    //
    // Read a flag from the registry that allows us to disable connection
    // reuse.
    //

    AfdDisableConnectionReuse = (BOOLEAN)(AfdReadSingleParameter(
                                    parametersHandle,
                                    REGISTRY_DISABLE_CONN_REUSE,
                                    (LONG)AfdDisableConnectionReuse
                                    ) != 0);

#endif

    //
    // Read the stack size and priority boost values from the registry.
    //

    stackSize = AfdReadSingleParameter(
                    parametersHandle,
                    REGISTRY_IRP_STACK_SIZE,
                    (ULONG)AfdIrpStackSize
                    );

    //
    // We do not support more than 63 layers below us.
    // (The system allows for 127, but some can be sitting above us
    // as well.
    //
    if ( stackSize > 64 ) {
        stackSize = 64;
    }

    if (stackSize<2) {
        //
        // Can't be less than two since we have to call
        // at least one driver below us.
        //
        stackSize = 2;
    }

    AfdIrpStackSize = (CCHAR)stackSize;
    AfdTdiStackSize = AfdIrpStackSize-1;
#ifdef _AFD_VARIABLE_STACK_
    AfdMaxStackSize = AfdTdiStackSize;
#endif // _AFD_VARIABLE_STACK_

    priorityBoost = AfdReadSingleParameter(
                        parametersHandle,
                        REGISTRY_PRIORITY_BOOST,
                        (ULONG)AfdPriorityBoost
                        );

    if ( priorityBoost > 16 ) {
        priorityBoost = AFD_DEFAULT_PRIORITY_BOOST;
    }

    AfdPriorityBoost = (CCHAR)priorityBoost;

    //
    // Read other config variables from the registry.
    //

    for ( i = 0; i < AFD_CONFIG_VAR_COUNT; i++ ) {

        *AfdConfigInfo[i].Variable =
            AfdReadSingleParameter(
                parametersHandle,
                AfdConfigInfo[i].RegistryValueName,
                *AfdConfigInfo[i].Variable
                );
    }

    //
    // Validate standard buffer sizes.
    // (we use buffer for KAPC or WORK_QUEUE_ITEM storage
    // in fast transmit file processing).
    //
    if (AfdSmallBufferSize<max (sizeof(KAPC),sizeof (WORK_QUEUE_ITEM))) {
        DbgPrint("AFD: Too small %ls registry parameter value: %ld\n"
                 "AFD: Adjusting to %ld\n",
                    REGISTRY_SMALL_BUFFER_SIZE,
                    AfdSmallBufferSize,
                    max (sizeof(KAPC),sizeof (WORK_QUEUE_ITEM)));
        AfdSmallBufferSize = max (sizeof(KAPC),sizeof (WORK_QUEUE_ITEM));
    }
    if (AfdMediumBufferSize<AfdSmallBufferSize) {
        DbgPrint("AFD: Too small %ls registry parameter value: %ld\n"
                 "AFD: Adjusting to %ld\n",
                    REGISTRY_MEDIUM_BUFFER_SIZE,
                    AfdMediumBufferSize,
                    AfdSmallBufferSize);
        AfdMediumBufferSize = AfdSmallBufferSize;
    }
    if (AfdLargeBufferSize<AfdMediumBufferSize) {
        DbgPrint("AFD: Too small %ls registry parameter value: %ld\n"
                 "AFD: Adjusting to %ld\n",
                    REGISTRY_LARGE_BUFFER_SIZE,
                    AfdLargeBufferSize,
                    AfdMediumBufferSize);
        AfdLargeBufferSize = AfdMediumBufferSize;
    }


    AfdIgnorePushBitOnReceives = (BOOLEAN)(AfdReadSingleParameter(
                        parametersHandle,
                        REGISTRY_IGNORE_PUSH_BIT,
                        (LONG)AfdIgnorePushBitOnReceives
                        )!=0);


    AfdDisableRawSecurity = (BOOLEAN)(AfdReadSingleParameter(
                             parametersHandle,
                             REGISTRY_NO_RAW_SECURITY,
                             (LONG)AfdDisableRawSecurity
                             )!=0);

    AfdDisableDirectSuperAccept = (BOOLEAN)(AfdReadSingleParameter(
                             parametersHandle,
                             REGISTRY_NO_DIRECT_ACCEPTEX,
                             (LONG)AfdDisableDirectSuperAccept
                             )!=0);

    AfdDisableChainedReceive = (BOOLEAN)(AfdReadSingleParameter(
                                     parametersHandle,
                                     REGISTRY_DISABLE_CHAINED_RECV,
                                     (LONG)AfdDisableChainedReceive
                                     ) != 0);

#ifdef TDI_SERVICE_SEND_AND_DISCONNECT
    AfdUseTdiSendAndDisconnect = (BOOLEAN)(AfdReadSingleParameter(
                                     parametersHandle,
                                     REGISTRY_USE_TDI_SEND_AND_DISCONNECT,
                                     (LONG)AfdUseTdiSendAndDisconnect
                                     ) != 0);
#endif //TDI_SERVICE_SEND_AND_DISCONNECT
    if( MmIsThisAnNtAsSystem() ) {

        //
        // On the NT Server product, make the maximum active TransmitFile
        // count configurable. This value is fixed (not configurable) on
        // the NT Workstation product.
        //

        AfdMaxActiveTransmitFileCount = AfdReadSingleParameter(
                                            parametersHandle,
                                            REGISTRY_MAX_ACTIVE_TRANSMIT_FILE_COUNT,
                                            (LONG)AfdMaxActiveTransmitFileCount
                                            );

        //
        // Dynamic backlog is only possible on NT Server.
        //

        AfdEnableDynamicBacklog = (BOOLEAN)(AfdReadSingleParameter(
                                         parametersHandle,
                                         REGISTRY_ENABLE_DYNAMIC_BACKLOG,
                                         (LONG)AfdEnableDynamicBacklog
                                         ) != 0);

    } else {

        AfdEnableDynamicBacklog = FALSE;

    }

    switch (AfdDefaultTransmitWorker) {
    case AFD_TF_USE_SYSTEM_THREAD:
    case AFD_TF_USE_KERNEL_APC:
        break;
    default:
        DbgPrint ("AFD: Invalid %ls registry parameter value: %ld\n"
                  "AFD: Using default - %ld\n",
                    REGISTRY_TRANSMIT_WORKER,
                    AfdDefaultTransmitWorker,
                    AFD_DEFAULT_TRANSMIT_WORKER);
        AfdDefaultTransmitWorker = AFD_DEFAULT_TRANSMIT_WORKER;
        break;

    }

    bufferAlignment = AfdReadSingleParameter(
                             parametersHandle,
                             REGISTRY_BUFFER_ALIGNMENT,
                             (LONG)AfdBufferAlignment
                             );
    if (bufferAlignment!=AfdBufferAlignment) {
        if (bufferAlignment<AFD_MINIMUM_BUFFER_ALIGNMENT ||
                bufferAlignment>PAGE_SIZE ||
                (bufferAlignment & (bufferAlignment-1))!=0) {
            DbgPrint("AFD: Invalid %ls registry parameter value: %ld\n"
                     "AFD: Using default - %ld\n",
                        REGISTRY_BUFFER_ALIGNMENT,
                        bufferAlignment,
                        AfdBufferAlignment);
        }
        else {
            AfdBufferAlignment = bufferAlignment;
            AfdAlignmentTableSize = AfdBufferAlignment/AFD_MINIMUM_BUFFER_ALIGNMENT;
        }
    }

    AfdVolatileConfig = (BOOLEAN)(AfdReadSingleParameter (
                                parametersHandle,
                                REGISTRY_VOLATILE_PARAMETERS,
                                (LONG)AfdVolatileConfig)!=0);
    if (AfdVolatileConfig) {
        AfdParametersNotifyHandle = parametersHandle;
        ExInitializeWorkItem (&AfdParametersNotifyWorker, AfdReadVolatileParameters, NULL);
    }
    else {
        ZwClose( parametersHandle );
    }

    //
    // Need to recalculate size of the page-long buffer if standard
    // address length has changed
    //
    if (AfdStandardAddressLength!=AFD_DEFAULT_STD_ADDRESS_LENGTH) {
        CLONG   oldBufferLengthForOnePage = AfdBufferLengthForOnePage;

        AfdBufferOverhead = AfdCalculateBufferSize( PAGE_SIZE,
                                                    AfdStandardAddressLength, 
                                                    AfdTdiStackSize) - PAGE_SIZE;
        AfdBufferLengthForOnePage = ALIGN_DOWN_A(
                                        PAGE_SIZE-AfdBufferOverhead,
                                        AFD_MINIMUM_BUFFER_ALIGNMENT);
        if (AfdLargeBufferSize==oldBufferLengthForOnePage) {
            AfdLargeBufferSize = AfdBufferLengthForOnePage;
        }
    }

    if (AfdBlockingSendCopyThreshold < AfdBufferLengthForOnePage) {
        DbgPrint("AFD: Too small %ls registry parameter value: %ld\n"
                 "AFD: Adjusting to %ld\n",
                    REGISTRY_BLOCKING_SEND_COPY_THRESHOLD,
                    AfdBlockingSendCopyThreshold,
                    AfdBufferLengthForOnePage);
        AfdBlockingSendCopyThreshold = AfdBufferLengthForOnePage;
    }

    return;

} // AfdReadRegistry


NTSTATUS
AfdOpenRegistry(
    IN PUNICODE_STRING BaseName,
    OUT PHANDLE ParametersHandle
    )

/*++

Routine Description:

    This routine is called by AFD to open the registry. If the registry
    tree exists, then it opens it and returns an error. If not, it
    creates the appropriate keys in the registry, opens it, and
    returns STATUS_SUCCESS.

Arguments:

    BaseName - Where in the registry to start looking for the information.

    LinkageHandle - Returns the handle used to read linkage information.

    ParametersHandle - Returns the handle used to read other
        parameters.

Return Value:

    The status of the request.

--*/
{

    HANDLE configHandle;
    NTSTATUS status;
    PWSTR parametersString = REGISTRY_PARAMETERS;
    UNICODE_STRING parametersKeyName;
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG disposition;

    PAGED_CODE( );

    //
    // Open the registry for the initial string.
    //

    InitializeObjectAttributes(
        &objectAttributes,
        BaseName,                   // name
        OBJ_CASE_INSENSITIVE,       // attributes
        NULL,                       // root
        NULL                        // security descriptor
        );

    status = ZwCreateKey(
                 &configHandle,
                 KEY_WRITE,
                 &objectAttributes,
                 0,                 // title index
                 NULL,              // class
                 0,                 // create options
                 &disposition       // disposition
                 );

    if (!NT_SUCCESS(status)) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Now open the parameters key.
    //

    RtlInitUnicodeString (&parametersKeyName, parametersString);

    InitializeObjectAttributes(
        &objectAttributes,
        &parametersKeyName,         // name
        OBJ_CASE_INSENSITIVE,       // attributes
        configHandle,               // root
        NULL                        // security descriptor
        );

    status = ZwOpenKey(
                 ParametersHandle,
                 KEY_READ,
                 &objectAttributes
                 );
    if (!NT_SUCCESS(status)) {

        ZwClose( configHandle );
        return status;
    }

    //
    // All keys successfully opened or created.
    //

    ZwClose( configHandle );
    return STATUS_SUCCESS;

} // AfdOpenRegistry


ULONG
AfdReadSingleParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN LONG DefaultValue
    )

/*++

Routine Description:

    This routine is called by AFD to read a single parameter
    from the registry. If the parameter is found it is stored
    in Data.

Arguments:

    ParametersHandle - A pointer to the open registry.

    ValueName - The name of the value to search for.

    DefaultValue - The default value.

Return Value:

    The value to use; will be the default if the value is not
    found or is not in the correct range.

--*/

{
    ULONG informationBuffer[32];   // declare ULONG to get it aligned
    PKEY_VALUE_FULL_INFORMATION information =
        (PKEY_VALUE_FULL_INFORMATION)informationBuffer;
    UNICODE_STRING valueKeyName;
    ULONG informationLength;
    LONG returnValue;
    NTSTATUS status;

    PAGED_CODE( );

    RtlInitUnicodeString( &valueKeyName, ValueName );

    status = ZwQueryValueKey(
                 ParametersHandle,
                 &valueKeyName,
                 KeyValueFullInformation,
                 (PVOID)information,
                 sizeof (informationBuffer),
                 &informationLength
                 );

    if (status == STATUS_SUCCESS && 
            information->DataLength == sizeof(ULONG) &&
            information->Type==REG_DWORD) {

        RtlMoveMemory(
            (PVOID)&returnValue,
            ((PUCHAR)information) + information->DataOffset,
            sizeof(ULONG)
            );

        if (returnValue < 0) {

            returnValue = DefaultValue;

        }
        else if (returnValue!=DefaultValue) {
            DbgPrint ("AFD: Read %ls from the registry, value: 0x%lx (%s: 0x%lx))\n",
                ValueName, returnValue, 
                AfdVolatileConfig ? "previous" : "default",
                DefaultValue);

        }

    } else {

        returnValue = DefaultValue;
    }

    return returnValue;

} // AfdReadSingleParameter


NTSTATUS
AfdBuildDeviceAcl(
    OUT PACL *DeviceAcl
    )

/*++

Routine Description:

    This routine builds an ACL which gives Administrators, LocalSystem,
    and NetworkService principals full access. All other principals have no access.

Arguments:

    DeviceAcl - Output pointer to the new ACL.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    PGENERIC_MAPPING GenericMapping;
    ULONG AclLength;
    NTSTATUS Status;
    ACCESS_MASK AccessMask = GENERIC_ALL;
    PACL NewAcl;

    //
    // Enable access to all the globally defined SIDs
    //

    GenericMapping = IoGetFileObjectGenericMapping();

    RtlMapGenericMask( &AccessMask, GenericMapping );

    AclLength = sizeof( ACL )                    +
                3 * FIELD_OFFSET (ACCESS_ALLOWED_ACE, SidStart) +
                RtlLengthSid( SeExports->SeAliasAdminsSid ) +
                RtlLengthSid( SeExports->SeLocalSystemSid ) +
                RtlLengthSid( SeExports->SeNetworkServiceSid );

    NewAcl = AFD_ALLOCATE_POOL_PRIORITY (
                 PagedPool,
                 AclLength,
                 AFD_SECURITY_POOL_TAG,
                 HighPoolPriority
                 );

    if (NewAcl == NULL) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    Status = RtlCreateAcl (NewAcl, AclLength, ACL_REVISION );

    if (!NT_SUCCESS( Status )) {
        AFD_FREE_POOL(
            NewAcl,
            AFD_SECURITY_POOL_TAG
            );
        return( Status );
    }

    Status = RtlAddAccessAllowedAce (
                 NewAcl,
                 ACL_REVISION2,
                 AccessMask,
                 SeExports->SeAliasAdminsSid
                 );

    ASSERT( NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewAcl,
                 ACL_REVISION2,
                 AccessMask,
                 SeExports->SeLocalSystemSid
                 );

    ASSERT( NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewAcl,
                 ACL_REVISION2,
                 AccessMask,
                 SeExports->SeNetworkServiceSid
                 );

    ASSERT( NT_SUCCESS( Status ));

    *DeviceAcl = NewAcl;

    return( STATUS_SUCCESS );

} // AfdBuildDeviceAcl


NTSTATUS
AfdCreateSecurityDescriptor(
    VOID
    )

/*++

Routine Description:

    This routine creates a security descriptor which gives access
    only to certain priviliged accounts. This descriptor is used
    to access check raw endpoint opens and exclisive access to transport
    addresses.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    PACL                  devAcl = NULL;
    NTSTATUS              status;
    BOOLEAN               memoryAllocated = FALSE;
    PSECURITY_DESCRIPTOR  afdSecurityDescriptor;
    ULONG                 afdSecurityDescriptorLength;
    CHAR                  buffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PSECURITY_DESCRIPTOR  localSecurityDescriptor =
                             (PSECURITY_DESCRIPTOR)buffer;
    PSECURITY_DESCRIPTOR  localAfdAdminSecurityDescriptor;
    SECURITY_INFORMATION  securityInformation = DACL_SECURITY_INFORMATION;


    //
    // Get a pointer to the security descriptor from the AFD device object.
    //
    status = ObGetObjectSecurity(
                 AfdDeviceObject,
                 &afdSecurityDescriptor,
                 &memoryAllocated
                 );

    if (!NT_SUCCESS(status)) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_ERROR_LEVEL,
            "AFD: Unable to get security descriptor, error: %x\n",
            status
            ));
        ASSERT(memoryAllocated == FALSE);
        return(status);
    }

    //
    // Build a local security descriptor with an ACL giving only
    // certain priviliged accounts.
    //
    status = AfdBuildDeviceAcl(&devAcl);

    if (!NT_SUCCESS(status)) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_ERROR_LEVEL,
                    "AFD: Unable to create Raw ACL, error: %x\n", status));
        goto error_exit;
    }

    (VOID) RtlCreateSecurityDescriptor(
                localSecurityDescriptor,
                SECURITY_DESCRIPTOR_REVISION
                );

    (VOID) RtlSetDaclSecurityDescriptor(
                localSecurityDescriptor,
                TRUE,
                devAcl,
                FALSE
                );

    //
    // Make a copy of the AFD descriptor. This copy will be the raw descriptor.
    //
    afdSecurityDescriptorLength = RtlLengthSecurityDescriptor(
                                      afdSecurityDescriptor
                                      );

    localAfdAdminSecurityDescriptor = ExAllocatePoolWithTag (
                                        PagedPool,
                                        afdSecurityDescriptorLength,
                                        AFD_SECURITY_POOL_TAG
                                        );

    if (localAfdAdminSecurityDescriptor == NULL) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_ERROR_LEVEL,
                    "AFD: couldn't allocate security descriptor\n"));
        goto error_exit;
    }

    RtlMoveMemory(
        localAfdAdminSecurityDescriptor,
        afdSecurityDescriptor,
        afdSecurityDescriptorLength
        );

    AfdAdminSecurityDescriptor = localAfdAdminSecurityDescriptor;

    //
    // Now apply the local descriptor to the raw descriptor.
    //
    status = SeSetSecurityDescriptorInfo(
                 NULL,
                 &securityInformation,
                 localSecurityDescriptor,
                 &AfdAdminSecurityDescriptor,
                 PagedPool,
                 IoGetFileObjectGenericMapping()
                 );

    if (!NT_SUCCESS(status)) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_ERROR_LEVEL,
                    "AFD: SeSetSecurity failed, %lx\n",
                    status));
        ASSERT (AfdAdminSecurityDescriptor==localAfdAdminSecurityDescriptor);
        ExFreePool (AfdAdminSecurityDescriptor);
        AfdAdminSecurityDescriptor = NULL;
        goto error_exit;
    }

    if (AfdAdminSecurityDescriptor!=localAfdAdminSecurityDescriptor) {
        ExFreePool (localAfdAdminSecurityDescriptor);
    }

    status = STATUS_SUCCESS;

error_exit:

    ObReleaseObjectSecurity(
        afdSecurityDescriptor,
        memoryAllocated
        );

    if (devAcl!=NULL) {
        AFD_FREE_POOL(
            devAcl,
            AFD_SECURITY_POOL_TAG
            );
    }

    return(status);
}


VOID
AfdReadVolatileParameters (
    PVOID   Parameter
    )
{
    
    UNREFERENCED_PARAMETER (Parameter);
    PAGED_CODE ();
    ExAcquireResourceExclusiveLite( AfdResource, TRUE );

    if (AfdParametersNotifyHandle!=NULL) {
        ULONG   i;
        NTSTATUS status;
        status = ZwNotifyChangeKey (
                        AfdParametersNotifyHandle,
                        NULL,
                        (PIO_APC_ROUTINE)(ULONG_PTR)&AfdParametersNotifyWorker,
                        (PVOID)(UINT_PTR)(unsigned int)DelayedWorkQueue,
                        &AfdDontCareIoStatus,
                        REG_NOTIFY_CHANGE_LAST_SET,
                        FALSE,
                        NULL, 0,
                        TRUE);

        if (NT_SUCCESS (status)) {
            for ( i = 0; i < AFD_VOLATILE_CONFIG_VAR_COUNT; i++ ) {

                *AfdVolatileConfigInfo[i].Variable =
                    AfdReadSingleParameter(
                        AfdParametersNotifyHandle,
                        AfdVolatileConfigInfo[i].RegistryValueName,
                        *AfdVolatileConfigInfo[i].Variable
                        );
            }
        }
        else {
            DbgPrint (
                "AFD: Failed to start notification for volatile parameter changes, status: %lx\n",
                        status);
            ZwClose (AfdParametersNotifyHandle);
            AfdParametersNotifyHandle = NULL;
        }
    }
    else {
        ASSERT (AfdParametersUnloadEvent!=NULL);
        IoQueueWorkItem (AfdWorkQueueItem,
                            AfdReleaseRegistryHandleWait,
                            DelayedWorkQueue,
                            NULL);

    }
    ExReleaseResourceLite( AfdResource );
}


VOID
AfdReleaseRegistryHandleWait (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
{
    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (Context);
    ASSERT (AfdParametersUnloadEvent!=NULL);
    KeSetEvent (AfdParametersUnloadEvent, AfdPriorityBoost, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\eventsel.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    eventsel.c

Abstract:

    This module contains routines for supporting the WinSock 2.0
    WSAEventSelect() and WSAEnumNetworkEvents() APIs.

Author:

    Keith Moore (keithmo)        02-Aug-1995

Revision History:

--*/

#include "afdp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGEAFD, AfdEventSelect )
#pragma alloc_text( PAGEAFD, AfdEnumNetworkEvents )
#endif



NTSTATUS
AfdEventSelect (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    )

/*++

Routine Description:

    Associates an event object with the socket such that the event object
    will be signalled when any of the specified network events becomes
    active.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the APC was successfully queued.

--*/

{

    NTSTATUS status;
    PAFD_ENDPOINT endpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PKEVENT eventObject;
    ULONG eventMask;
    AFD_EVENT_SELECT_INFO eventInfo;
    ULONG previousRecord = 0;
    BOOLEAN countsUpdated = FALSE;

    UNREFERENCED_PARAMETER (IoctlCode);
    UNREFERENCED_PARAMETER (OutputBuffer);
    UNREFERENCED_PARAMETER (OutputBufferLength);

    *Information = 0;
    AFD_W4_INIT status = STATUS_SUCCESS;
    try {
#ifdef _WIN64
        if (IoIs32bitProcess (NULL)) {

            PAFD_EVENT_SELECT_INFO32 eventInfo32 = InputBuffer;

            if( InputBufferLength < sizeof(*eventInfo32)) {
                return STATUS_INVALID_PARAMETER;
            }
            //
            // Validate the input structure if it comes from the user mode
            // application
            //

            if (RequestorMode != KernelMode ) {
                ProbeForReadSmallStructure (InputBuffer,
                                sizeof (*eventInfo32),
                                PROBE_ALIGNMENT32(AFD_EVENT_SELECT_INFO32));
            }

            //
            // Make local copies of the embeded pointer and parameters
            // that we will be using more than once in case malicios
            // application attempts to change them while we are
            // validating
            //

            eventInfo.Event = eventInfo32->Event;
            eventInfo.PollEvents = eventInfo32->PollEvents;
        }
        else
#endif
        {

            if(InputBufferLength < sizeof(eventInfo)) {
                return STATUS_INVALID_PARAMETER;
            }

            if (RequestorMode != KernelMode ) {
                ProbeForReadSmallStructure (InputBuffer,
                                sizeof (eventInfo),
                                PROBE_ALIGNMENT(AFD_EVENT_SELECT_INFO));
            }

            //
            // Make local copies of the embeded pointer and parameters
            // that we will be using more than once in case malicios
            // application attempts to change them while we are
            // validating
            //

            eventInfo = *((PAFD_EVENT_SELECT_INFO)InputBuffer);
        }
    }
    except (AFD_EXCEPTION_FILTER (status)) {
        ASSERT (NT_ERROR (status));
        return status;
    }

    if ( eventInfo.Event == NULL &&
            eventInfo.PollEvents != 0 )  {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Grab the endpoint from the socket handle.
    //

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    //
    // Reference the target event object.
    //


    eventObject = NULL;

    if( eventInfo.Event != NULL ) {

        status = AfdReferenceEventObjectByHandle(
                     eventInfo.Event,
                     RequestorMode,
                     (PVOID *)&eventObject
                     );

        if( !NT_SUCCESS(status) ) {
            return status;
        }

        ASSERT( eventObject != NULL );

        if (IS_SAN_ENDPOINT (endpoint)) {
            //
            // Inform the switch that select is active on this endpoint.
            //
            status = AfdSanPollBegin (endpoint, eventInfo.PollEvents);

            if (!NT_SUCCESS (status)) {
                ObDereferenceObject (eventObject);
                return status;
            }
            countsUpdated = TRUE;
        }

    }

    //
    // Acquire the spinlock protecting the endpoint.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // If this endpoint has an active EventSelect, dereference the
    // associated event object.
    //

    if( endpoint->EventObject != NULL ) {

        ObDereferenceObject( endpoint->EventObject );

        if (IS_SAN_ENDPOINT (endpoint)) {
            previousRecord = endpoint->EventsEnabled;
        }

    }

    //
    // Fill in the info.
    //

    endpoint->EventObject = eventObject;
    endpoint->EventsEnabled = eventInfo.PollEvents;

    if (countsUpdated) {
        endpoint->EventsEnabled |= AFD_POLL_SANCOUNTS_UPDATED;
        //
        // AfdSanPollBegin puts latest events into 
        // Endpoint->Common.SanEndp.SelectEventsActive. This is fine for
        // select/AsyncSelect, but not for EventSelect. So, if being called
        // for the first time, then read current active events from there.
        //
        if (!(previousRecord & AFD_POLL_SANCOUNTS_UPDATED)) {
            endpoint->EventsActive = endpoint->Common.SanEndp.SelectEventsActive;
        }
    }

    IF_DEBUG(EVENT_SELECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdEventSelect: Endpoint-%p, eventOb-%p, enabled-%lx, active-%lx\n",
                    endpoint,
                    eventObject,
                    endpoint->EventsEnabled,
                    endpoint->EventsActive
                    ));
    }

    //
    // While we've got the spinlock held, determine if any conditions
    // are met, and if so, signal the event object.
    //

    eventMask = endpoint->EventsActive & endpoint->EventsEnabled;

    if( eventMask != 0 && eventObject != NULL ) {

        IF_DEBUG(EVENT_SELECT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdEventSelect: Setting event %p\n",
                eventObject
                ));
        }

        KeSetEvent(
            eventObject,
            AfdPriorityBoost,
            FALSE
            );

    }

    //
    // Release the spin lock and return.
    //

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    if (previousRecord & AFD_POLL_SANCOUNTS_UPDATED) {
        AfdSanPollEnd (endpoint, previousRecord);
    }

    return STATUS_SUCCESS;

} // AfdEventSelect


NTSTATUS
AfdEnumNetworkEvents (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    )

/*++

Routine Description:

    Retrieves event select information from the socket.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the APC was successfully queued.

--*/

{

    NTSTATUS status;
    PAFD_ENDPOINT endpoint;
    AFD_ENUM_NETWORK_EVENTS_INFO eventInfo;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PKEVENT eventObject;
    ULONG pollEvents;

    UNREFERENCED_PARAMETER (IoctlCode);
    UNREFERENCED_PARAMETER (InputBufferLength);

    *Information = 0;

    //
    // Validate the parameters.
    //

    if(OutputBufferLength < sizeof(eventInfo) ) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Reference the target event object.
    //

    eventObject = NULL;

    if( InputBuffer != NULL ) {

        status = AfdReferenceEventObjectByHandle(
                     InputBuffer,
                     RequestorMode,
                     (PVOID *)&eventObject
                     );

        if( !NT_SUCCESS(status) ) {

            return status;

        }

        ASSERT( eventObject != NULL );

    }

    //
    // Grab the endpoint from the socket handle.
    //

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    //
    // Acquire the spinlock protecting the endpoint.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    IF_DEBUG(EVENT_SELECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
            "AfdEnumNetworkEvents: endp-%p, eventobj-%p, enabled-%lx, active-%lx\n",
            endpoint,
            eventObject,
            endpoint->EventsEnabled,
            endpoint->EventsActive
            ));
    }

    //
    // Copy the data to the user's structure.
    //

    pollEvents = endpoint->EventsActive & endpoint->EventsEnabled;
    eventInfo.PollEvents = pollEvents;

    RtlCopyMemory(
        eventInfo.EventStatus,
        endpoint->EventStatus,
        sizeof(eventInfo.EventStatus)
        );

    //
    // If there was an event object handle passed in with this
    // request, reset and dereference it.
    //

    if( eventObject != NULL ) {

        IF_DEBUG(EVENT_SELECT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdEnumNetworkEvents: Resetting event %p\n",
                eventObject
                ));
        }

        KeResetEvent( eventObject );
        ObDereferenceObject( eventObject );

    }


    //
    // Reset internal event record for all the events that
    // we could potentially report to the application
    //

    endpoint->EventsActive &= ~(endpoint->EventsEnabled);

    //
    // Release the spin lock and return.
    //

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    AFD_W4_INIT status = STATUS_SUCCESS;
    try {
        //
        // Validate the output structure if it comes from the user mode
        // application
        //

        if (RequestorMode != KernelMode ) {
            ProbeForWrite (OutputBuffer,
                            sizeof (eventInfo),
                            PROBE_ALIGNMENT (AFD_ENUM_NETWORK_EVENTS_INFO));
        }

        //
        // Copy parameters back to application's memory
        //

        *((PAFD_ENUM_NETWORK_EVENTS_INFO)OutputBuffer) = eventInfo;

    } except( AFD_EXCEPTION_FILTER(status) ) {
        ASSERT (NT_ERROR (status));
        return status;
    }

    //
    // Before returning, tell the I/O subsystem how may bytes to copy
    // to the user's output buffer.
    //

    *Information = sizeof(eventInfo);

    return STATUS_SUCCESS;

} // AfdEnumNetworkEvents


VOID
AfdIndicateEventSelectEvent (
    IN PAFD_ENDPOINT Endpoint,
    IN ULONG PollEventMask,
    IN NTSTATUS Status
    )
{
    ULONG oldEventsActive;
    ULONG eventBit;

    //
    // Sanity check.
    //

    ASSERT( IS_AFD_ENDPOINT_TYPE( Endpoint ) );
    ASSERT (PollEventMask!=0);
    ASSERT (((~((1<<AFD_NUM_POLL_EVENTS)-1)) & PollEventMask)==0);
    ASSERT( KeGetCurrentIrql() >= DISPATCH_LEVEL );

    //
    // Note that AFD_POLL_ABORT implies AFD_POLL_SEND.
    //
    if( PollEventMask & AFD_POLL_ABORT ) {
        PollEventMask |= AFD_POLL_SEND;
    }

    //
    // Special handling of send event. Don't record if not enabled
    // and disable further indication upon recording (it is only enabled
    // after we fail non-blocking send
    //

    //
    // Update the counts for the polls that were issued before
    // the endpoint was converted to SAN.
    //
    if ( IS_SAN_ENDPOINT (Endpoint) && 
            !(Endpoint->EventsEnabled & AFD_POLL_SANCOUNTS_UPDATED) &&
            Endpoint->Common.SanEndp.LocalContext!=NULL) {
        AfdSanPollUpdate (Endpoint, Endpoint->EventsEnabled);
        Endpoint->EventsEnabled |= AFD_POLL_SANCOUNTS_UPDATED;
    }

    if (PollEventMask&AFD_POLL_SEND) {
        if (Endpoint->EnableSendEvent) {
            Endpoint ->EnableSendEvent = FALSE;
        }
        else {
            PollEventMask &= (~AFD_POLL_SEND);
            if (PollEventMask==0) {
                return;
            }
        }
    }

    //
    // Calculate the actual event bit.
    //

    oldEventsActive = Endpoint->EventsActive;
    Endpoint->EventsActive |= PollEventMask;
    for (eventBit=0; eventBit<AFD_NUM_POLL_EVENTS; eventBit++) {
        if ((1<<eventBit) & PollEventMask) {
            Endpoint->EventStatus[eventBit] = Status;
        }
    }

    IF_DEBUG(EVENT_SELECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
            "AfdIndicateEventSelectEvent: endp-%p, eventobj-%p, enabled-%lx, active-%lx, indicated-%lx\n",
            Endpoint,
            Endpoint->EventObject,
            Endpoint->EventsEnabled,
            Endpoint->EventsActive,
            PollEventMask
            ));
    }

    //
    // Only signal the endpoint's event object if the current event
    // is enabled, AND the current event was not already active, AND
    // there is an event object associated with this endpoint.
    //

    PollEventMask &= Endpoint->EventsEnabled & ~oldEventsActive;

    if( PollEventMask != 0 && Endpoint->EventObject != NULL ) {

        IF_DEBUG(EVENT_SELECT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdIndicateEventSelectEvent: Setting event %p\n",
                Endpoint->EventObject
                ));
        }

        KeSetEvent(
            Endpoint->EventObject,
            AfdPriorityBoost,
            FALSE
            );

    }

} // AfdIndicateEventSelectEvent
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\group.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    group.c

Abstract:

    This module contains Group ID managment routines.

    Group IDs identify an AFD_GROUP_ENTRY structure in a lookup table.
    Each AFD_GROUP_ENTRY contains a reference count and a type (either
    GroupTypeConstrained or GroupTypeUnconstrained). Free group IDs are
    linked together in a doubly-linked list. As group IDs are allocated,
    they are removed from this list. Once the free list becomes empty,
    the lookup table is grown appropriately.

Author:

    Keith Moore (keithmo)        06-Jun-1996

Revision History:

--*/

#include "afdp.h"


//
// Private constants.
//

#define AFD_GROUP_TABLE_GROWTH  32  // entries


//
// Private types.
//

typedef struct _AFD_GROUP_ENTRY {
    union {
        LIST_ENTRY ListEntry;
        struct {
            AFD_GROUP_TYPE GroupType;
            LONG ReferenceCount;
        };
    };
} AFD_GROUP_ENTRY, *PAFD_GROUP_ENTRY;


//
// Private globals.
//

PERESOURCE AfdGroupTableResource;
PAFD_GROUP_ENTRY AfdGroupTable;
LIST_ENTRY AfdFreeGroupList;
LONG AfdGroupTableSize;


//
// Private functions.
//

PAFD_GROUP_ENTRY
AfdMapGroupToEntry(
    IN LONG Group
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, AfdInitializeGroup )
#pragma alloc_text( PAGE, AfdTerminateGroup )
#pragma alloc_text( PAGE, AfdReferenceGroup )
#pragma alloc_text( PAGE, AfdDereferenceGroup )
#pragma alloc_text( PAGE, AfdGetGroup )
#endif


BOOLEAN
AfdInitializeGroup(
    VOID
    )

/*++

Routine Description:

    Initializes any globals necessary for the group ID package.

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--*/

{

    //
    // Initialize the group globals.
    //

    AfdGroupTableResource = AFD_ALLOCATE_POOL_PRIORITY(
                                NonPagedPool,
                                sizeof(*AfdGroupTableResource),
                                AFD_RESOURCE_POOL_TAG,
                                HighPoolPriority
                                );

    if( AfdGroupTableResource == NULL ) {

        return FALSE;

    }

    ExInitializeResourceLite( AfdGroupTableResource );

    AfdGroupTable = NULL;
    InitializeListHead( &AfdFreeGroupList );
    AfdGroupTableSize = 0;

    return TRUE;

}   // AfdInitializeGroup


VOID
AfdTerminateGroup(
    VOID
    )

/*++

Routine Description:

    Destroys any globals created for the group ID package.

--*/

{

    if( AfdGroupTableResource != NULL ) {

        ExDeleteResourceLite( AfdGroupTableResource );

        AFD_FREE_POOL(
            AfdGroupTableResource,
            AFD_RESOURCE_POOL_TAG
            );

        AfdGroupTableResource = NULL;

    }

    if( AfdGroupTable != NULL ) {

        AFD_FREE_POOL(
            AfdGroupTable,
            AFD_GROUP_POOL_TAG
            );

        AfdGroupTable = NULL;

    }

    InitializeListHead( &AfdFreeGroupList );
    AfdGroupTableSize = 0;

}   // AfdTerminateGroup


BOOLEAN
AfdReferenceGroup(
    IN LONG Group,
    OUT PAFD_GROUP_TYPE GroupType
    )

/*++

Routine Description:

    Bumps the reference count associated with the given group ID.

Arguments:

    Group - The group ID to reference.

    GroupType - Returns the type of the group.

Returns:

    BOOLEAN - TRUE if the group ID was valid, FALSE otherwise.

--*/

{

    PAFD_GROUP_ENTRY groupEntry;
    AFD_GROUP_TYPE groupType;

    groupEntry = AfdMapGroupToEntry( Group );

    if( groupEntry != NULL ) {

        groupType = groupEntry->GroupType;

        if( groupType == GroupTypeConstrained ||
            groupType == GroupTypeUnconstrained ) {

            groupEntry->ReferenceCount++;
            *GroupType = groupType;

        } else {

            groupEntry = NULL;

        }

        ExReleaseResourceLite( AfdGroupTableResource );
        KeLeaveCriticalRegion ();

    }

    return (BOOLEAN)( groupEntry != NULL );

}   // AfdReferenceGroup


BOOLEAN
AfdDereferenceGroup(
    IN LONG Group
    )

/*++

Routine Description:

    Decrements the reference count associated with the given group ID.
    If the ref count drops to zero, the group ID is freed.

Arguments:

    Group - The group ID to dereference.

Returns:

    BOOLEAN - TRUE if the group ID was valid, FALSE otherwise.

--*/

{

    PAFD_GROUP_ENTRY groupEntry;
    AFD_GROUP_TYPE groupType;

    groupEntry = AfdMapGroupToEntry( Group );

    if( groupEntry != NULL ) {

        groupType = groupEntry->GroupType;

        if( groupType == GroupTypeConstrained ||
            groupType == GroupTypeUnconstrained ) {

            ASSERT( groupEntry->ReferenceCount > 0 );
            groupEntry->ReferenceCount--;

            if( groupEntry->ReferenceCount == 0 ) {

                InsertTailList(
                    &AfdFreeGroupList,
                    &groupEntry->ListEntry
                    );

            }

        } else {

            groupEntry = NULL;

        }

        ExReleaseResourceLite( AfdGroupTableResource );
        KeLeaveCriticalRegion ();

    }

    return (BOOLEAN)( groupEntry != NULL );

}   // AfdDereferenceGroup


BOOLEAN
AfdGetGroup(
    IN OUT PLONG Group,
    OUT PAFD_GROUP_TYPE GroupType
    )

/*++

Routine Description:

    Examines the incoming group. If is zero, then nothing is done. If it
    is SG_CONSTRAINED_GROUP, then a new constrained group ID is created.
    If it is SG_UNCONSTRAINED_GROUP, then a new unconstrained group ID is
    created. Otherwise, it must identify an existing group, so that group
    is referenced.

Arguments:

    Group - Points to the group ID to examine/modify.

    GroupType - Returns the type of the group.

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--*/

{

    LONG groupValue;
    PAFD_GROUP_ENTRY groupEntry;
    PAFD_GROUP_ENTRY newGroupTable;
    LONG newGroupTableSize;
    LONG i;
    PLIST_ENTRY listEntry;

    groupValue = *Group;

    //
    // Zero means "no group", so just ignore it.
    //

    if( groupValue == 0 ) {

        *GroupType = GroupTypeNeither;
        return TRUE;

    }

    //
    // If we're being asked to create a new group, do it.
    //

    if( groupValue == SG_CONSTRAINED_GROUP ||
        groupValue == SG_UNCONSTRAINED_GROUP ) {

        //
        // Lock the table.
        //

        //
        // Make sure the thread in which we execute cannot get
        // suspeneded in APC while we own the global resource.
        //
        KeEnterCriticalRegion ();
        ExAcquireResourceExclusiveLite( AfdGroupTableResource, TRUE );

        //
        // See if there's room at the inn.
        //

        if( IsListEmpty( &AfdFreeGroupList ) ) {

            //
            // No room, we'll need to create/expand the table.
            //

            newGroupTableSize = AfdGroupTableSize + AFD_GROUP_TABLE_GROWTH;

            newGroupTable = AFD_ALLOCATE_POOL(
                                PagedPool,
                                newGroupTableSize * sizeof(AFD_GROUP_ENTRY),
                                AFD_GROUP_POOL_TAG
                                );

            if( newGroupTable == NULL ) {

                ExReleaseResourceLite( AfdGroupTableResource );
                KeLeaveCriticalRegion ();
                return FALSE;

            }

            if( AfdGroupTable == NULL ) {

                //
                // This is the initial table allocation, so reserve the
                // first three entries (0, SG_UNCONSTRAINED_GROUP, and
                // SG_CONSTRAINED_GROUP).
                //

                for( ;
                     AfdGroupTableSize <= SG_CONSTRAINED_GROUP ||
                     AfdGroupTableSize <= SG_UNCONSTRAINED_GROUP ;
                     AfdGroupTableSize++ ) {

                    newGroupTable[AfdGroupTableSize].ReferenceCount = 0;
                    newGroupTable[AfdGroupTableSize].GroupType = GroupTypeNeither;

                }

            } else {

                //
                // Copy the old table into the new table, then free the
                // old table.
                //

                RtlCopyMemory(
                    newGroupTable,
                    AfdGroupTable,
                    AfdGroupTableSize * sizeof(AFD_GROUP_ENTRY)
                    );

                AFD_FREE_POOL(
                    AfdGroupTable,
                    AFD_GROUP_POOL_TAG
                    );

            }

            //
            // Add the new entries to the free list.
            //

            for( i = newGroupTableSize - 1 ; i >= AfdGroupTableSize ; i-- ) {

                InsertHeadList(
                    &AfdFreeGroupList,
                    &newGroupTable[i].ListEntry
                    );

            }

            AfdGroupTable = newGroupTable;
            AfdGroupTableSize = newGroupTableSize;

        }

        //
        // Pull the next free entry off the list.
        //

        ASSERT( !IsListEmpty( &AfdFreeGroupList ) );

        listEntry = RemoveHeadList( &AfdFreeGroupList );

        groupEntry = CONTAINING_RECORD(
                         listEntry,
                         AFD_GROUP_ENTRY,
                         ListEntry
                         );

        groupEntry->ReferenceCount = 1;
        groupEntry->GroupType = (AFD_GROUP_TYPE)groupValue;

        *Group = (LONG)( groupEntry - AfdGroupTable );
        *GroupType = groupEntry->GroupType;

        ExReleaseResourceLite( AfdGroupTableResource );
        KeLeaveCriticalRegion ();
        return TRUE;

    }

    //
    // Otherwise, just reference the group.
    //

    return AfdReferenceGroup( groupValue, GroupType );

}   // AfdGetGroup


PAFD_GROUP_ENTRY
AfdMapGroupToEntry(
    IN LONG Group
    )

/*++

Routine Description:

    Maps the given group ID to the corresponding AFD_GROUP_ENTRY structure.

    N.B. This routine returns with AfdGroupTableResource held if successful.

Arguments:

    Group - The group ID to map.

Return Value:

    PAFD_GROUP_ENTRY - The entry corresponding to the group ID if successful,
        NULL otherwise.

--*/

{

    PAFD_GROUP_ENTRY groupEntry;

    //
    // Lock the table.
    //

    //
    // Make sure the thread in which we execute cannot get
    // suspeneded in APC while we own the global resource.
    //
    KeEnterCriticalRegion ();
    ExAcquireResourceExclusiveLite( AfdGroupTableResource, TRUE );

    //
    // Validate the group ID.
    //

    if( Group > 0 && Group < AfdGroupTableSize ) {

        groupEntry = AfdGroupTable + Group;

        //
        // The group ID is within legal range. Ensure it's in use.
        // In the AFD_GROUP_ENTRY structure, the GroupType field is
        // overlayed with ListEntry.Flink due to the internal union.
        // We can use this knowledge to quickly validate that this
        // entry is in use.
        //

        if( groupEntry->GroupType == GroupTypeConstrained ||
            groupEntry->GroupType == GroupTypeUnconstrained ) {

            return groupEntry;

        }

    }

    //
    // Invalid group ID, fail it.
    //

    ExReleaseResourceLite( AfdGroupTableResource );
    KeLeaveCriticalRegion ();
    return NULL;

}   // AfdMapGroupToEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\fastio.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    fastio.c

Abstract:

    This module contains routines for handling fast ("turbo") IO
    in AFD.

Author:

    David Treadwell (davidtr)    12-Oct-1992

Revision History:
    VadimE  14-Jan-1998 Restructurred the code.

--*/

#include "afdp.h"


BOOLEAN
AfdFastConnectionReceive (
    IN PAFD_ENDPOINT        endpoint,
    IN PAFD_RECV_INFO       recvInfo,
    IN ULONG                recvLength,
    OUT PIO_STATUS_BLOCK    IoStatus
    );

BOOLEAN
AfdFastDatagramReceive (
    IN PAFD_ENDPOINT            endpoint,
    IN PAFD_RECV_MESSAGE_INFO   recvInfo,
    IN ULONG                    recvLength,
    OUT PIO_STATUS_BLOCK        IoStatus
    );

BOOLEAN
AfdFastConnectionSend (
    IN PAFD_ENDPOINT        endpoint,
    IN PAFD_SEND_INFO       sendInfo,
    IN ULONG                sendLength,
    OUT PIO_STATUS_BLOCK    IoStatus
    );

BOOLEAN
AfdFastDatagramSend (
    IN PAFD_ENDPOINT            endpoint,
    IN PAFD_SEND_DATAGRAM_INFO  sendInfo,
    IN ULONG                    sendLength,
    OUT PIO_STATUS_BLOCK        IoStatus
    );

NTSTATUS
AfdRestartFastDatagramSend (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfdFastIoDeviceControl )
#pragma alloc_text( PAGE, AfdFastIoRead )
#pragma alloc_text( PAGE, AfdFastIoWrite )
#pragma alloc_text( PAGEAFD, AfdFastDatagramSend )
#pragma alloc_text( PAGEAFD, AfdFastDatagramReceive )
#pragma alloc_text( PAGEAFD, AfdFastConnectionSend )
#pragma alloc_text( PAGEAFD, AfdFastConnectionReceive )
#pragma alloc_text( PAGEAFD, AfdRestartFastDatagramSend )
#pragma alloc_text( PAGEAFD, AfdShouldSendBlock )
#endif


#if AFD_PERF_DBG
BOOLEAN
AfdFastIoReadReal (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
AfdFastIoRead (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    BOOLEAN success;

    ASSERT( KeGetCurrentIrql( ) == LOW_LEVEL );

    success = AfdFastIoReadReal (
                FileObject,
                FileOffset,
                Length,
                Wait,
                LockKey,
                Buffer,
                IoStatus,
                DeviceObject
                );

    ASSERT( KeGetCurrentIrql( ) == LOW_LEVEL );
    if ( success ) {
        InterlockedIncrement (&AfdFastReadsSucceeded);
        ASSERT (IoStatus->Status == STATUS_SUCCESS ||
                    IoStatus->Status == STATUS_DEVICE_NOT_READY );
    } else {
        InterlockedIncrement (&AfdFastReadsFailed);
    }
    return success;
}

BOOLEAN
AfdFastIoReadReal (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )

#else // AFD_PERF_DBG

BOOLEAN
AfdFastIoRead (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
#endif  // AFD_PERF_DBG
{

    PAFD_ENDPOINT   endpoint;
    WSABUF          buf;

    UNREFERENCED_PARAMETER (FileOffset);
    UNREFERENCED_PARAMETER (Wait);
    UNREFERENCED_PARAMETER (LockKey);
    UNREFERENCED_PARAMETER (DeviceObject);

    PAGED_CODE( );

    //
    // All we want to do is pass the request through to the TDI provider
    // if possible.  If not, we want to bail out of this code path back
    // onto the main code path (with IRPs) with as little performance
    // overhead as possible.
    //
    // Thus this routine only does general preliminary checks and input
    // parameter validation. If it is determined that fast io path is
    // likely to succeed, an operation specific routine is called
    // to handle all the details.
    //

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );


    //
    // If fast IO recv is disabled
    //      or the endpoint is shut down in any way
    //      or the endpoint isn't connected yet
    //      or the TDI provider for this endpoint supports bufferring,
    // we do not want to do fast IO on it
    //
    if (endpoint->DisableFastIoRecv ||
            endpoint->DisconnectMode != 0 ||
            endpoint->State != AfdEndpointStateConnected ||
            IS_TDI_BUFFERRING(endpoint)) {
        return FALSE;
    }

    //
    // Fake buffer array.
    //

    buf.buf = Buffer;
    buf.len = Length;

    //
    // Call routine based on endpoint type
    //
    if ( IS_DGRAM_ENDPOINT(endpoint) ) {
        //
        // Fake input parameter strucuture
        //
        AFD_RECV_MESSAGE_INFO  msgInfo;

        msgInfo.dgi.BufferArray = &buf;
        msgInfo.dgi.BufferCount = 1;
        msgInfo.dgi.AfdFlags = AFD_OVERLAPPED;
        msgInfo.dgi.TdiFlags = TDI_RECEIVE_NORMAL;
        msgInfo.dgi.Address = NULL;
        msgInfo.dgi.AddressLength = 0;
        msgInfo.ControlBuffer = NULL;
        msgInfo.ControlLength = NULL;
        msgInfo.MsgFlags = NULL;

        return AfdFastDatagramReceive(
                   endpoint,
                   &msgInfo,
                   Length,
                   IoStatus
                   );
    }
    else if (IS_VC_ENDPOINT(endpoint)) {
        //
        // Fake input parameter strucuture
        //
        AFD_RECV_INFO  recvInfo;

        recvInfo.BufferArray = &buf;
        recvInfo.BufferCount = 1;
        recvInfo.AfdFlags = AFD_OVERLAPPED;
        recvInfo.TdiFlags = TDI_RECEIVE_NORMAL;

        return AfdFastConnectionReceive (
                    endpoint,
                    &recvInfo,
                    Length,
                    IoStatus);
    }
    else
        return FALSE;

} // AfdFastIoRead

#if AFD_PERF_DBG
BOOLEAN
AfdFastIoWriteReal (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
AfdFastIoWrite (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    BOOLEAN success;

    ASSERT( KeGetCurrentIrql( ) == LOW_LEVEL );

    success = AfdFastIoWriteReal (
                    FileObject,
                    FileOffset,
                    Length,
                    Wait,
                    LockKey,
                    Buffer,
                    IoStatus,
                    DeviceObject
                    );

    ASSERT( KeGetCurrentIrql( ) == LOW_LEVEL );
    if ( success ) {
        InterlockedIncrement (&AfdFastWritesSucceeded);
        ASSERT (IoStatus->Status == STATUS_SUCCESS ||
                    IoStatus->Status == STATUS_DEVICE_NOT_READY);
    } else {
        InterlockedIncrement (&AfdFastWritesFailed);
    }
    return success;
}

BOOLEAN
AfdFastIoWriteReal (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )

#else // AFD_PERF_DBG

BOOLEAN
AfdFastIoWrite (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
#endif  // AFD_PERF_DBG
{


    PAFD_ENDPOINT   endpoint;
    WSABUF          buf;

    UNREFERENCED_PARAMETER (FileOffset);
    UNREFERENCED_PARAMETER (Wait);
    UNREFERENCED_PARAMETER (LockKey);
    UNREFERENCED_PARAMETER (DeviceObject);
    PAGED_CODE( );

    //
    // All we want to do is pass the request through to the TDI provider
    // if possible.  If not, we want to bail out of this code path back
    // onto the main code path (with IRPs) with as little performance
    // overhead as possible.
    //
    // Thus this routine only does general preliminary checks and input
    // parameter validation. If it is determined that fast io path is
    // likely to succeed, an operation specific routine is called
    // to handle all the details.
    //

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );


    //
    // If fast IO send is disabled
    //      or the endpoint is shut down in any way
    //      or the endpoint isn't connected yet
    //      or the TDI provider for this endpoint supports bufferring,
    // we do not want to do fast IO on it
    //
    if (endpoint->DisableFastIoSend ||
            endpoint->DisconnectMode != 0 ||
            endpoint->State != AfdEndpointStateConnected ||
            IS_TDI_BUFFERRING(endpoint) ) {
        return FALSE;
    }

    //
    // Fake buffer array.
    //
    buf.buf = Buffer;
    buf.len = Length;

    //
    // Call routine based on endpoint type
    //
    if ( IS_DGRAM_ENDPOINT(endpoint) ) {
        //
        // Fake input parameter strucuture
        //
        AFD_SEND_DATAGRAM_INFO  sendInfo;

        sendInfo.BufferArray = &buf;
        sendInfo.BufferCount = 1;
        sendInfo.AfdFlags = AFD_OVERLAPPED;
        sendInfo.TdiConnInfo.RemoteAddress = NULL;
        sendInfo.TdiConnInfo.RemoteAddressLength = 0;

        return AfdFastDatagramSend(
                   endpoint,
                   &sendInfo,
                   Length,
                   IoStatus
                   );
    }
    else if (IS_VC_ENDPOINT (endpoint)) {
        //
        // Fake input parameter strucuture
        //
        AFD_SEND_INFO  sendInfo;

        sendInfo.BufferArray = &buf;
        sendInfo.BufferCount = 1;
        sendInfo.AfdFlags = AFD_OVERLAPPED;
        sendInfo.TdiFlags = 0;

        return AfdFastConnectionSend (
                    endpoint,
                    &sendInfo,
                    Length,
                    IoStatus);
    }
    else
        return FALSE;
} // AfdFastIoWrite

#if AFD_PERF_DBG

BOOLEAN
AfdFastIoDeviceControlReal (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );


BOOLEAN
AfdFastIoDeviceControl (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    BOOLEAN success;

    ASSERT( KeGetCurrentIrql( ) == LOW_LEVEL );

    success = AfdFastIoDeviceControlReal (
                  FileObject,
                  Wait,
                  InputBuffer,
                  InputBufferLength,
                  OutputBuffer,
                  OutputBufferLength,
                  IoControlCode,
                  IoStatus,
                  DeviceObject
                  );

    ASSERT( KeGetCurrentIrql( ) == LOW_LEVEL );

    switch ( IoControlCode ) {

    case IOCTL_AFD_SEND:

        if ( success ) {
            InterlockedIncrement (&AfdFastSendsSucceeded);
        } else {
            InterlockedIncrement (&AfdFastSendsFailed);
        }
        break;

    case IOCTL_AFD_RECEIVE:

        if ( success ) {
            InterlockedIncrement (&AfdFastReceivesSucceeded);
        } else {
            InterlockedIncrement (&AfdFastReceivesFailed);
        }
        break;

    case IOCTL_AFD_SEND_DATAGRAM:

        if ( success ) {
            InterlockedIncrement (&AfdFastSendDatagramsSucceeded);
        } else {
            InterlockedIncrement (&AfdFastSendDatagramsFailed);
        }
        break;

    case IOCTL_AFD_RECEIVE_MESSAGE:
    case IOCTL_AFD_RECEIVE_DATAGRAM:

        if ( success ) {
            InterlockedIncrement (&AfdFastReceiveDatagramsSucceeded);
        } else {
            InterlockedIncrement (&AfdFastReceiveDatagramsFailed);
        }
        break;
    case IOCTL_AFD_TRANSMIT_FILE:

        if ( success ) {
            InterlockedIncrement (&AfdFastTfSucceeded);
        } else {
            InterlockedIncrement (&AfdFastTfFailed);
        }
        break;
    }


    return success;

} // AfdFastIoDeviceControl


BOOLEAN
AfdFastIoDeviceControlReal (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
#else
BOOLEAN
AfdFastIoDeviceControl (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
#endif
{   
    PAFD_ENDPOINT   endpoint;
    KPROCESSOR_MODE previousMode;
    BOOLEAN         res;
    PAFD_IMMEDIATE_CALL proc;
    ULONG       request;

#ifdef _WIN64
    WSABUF          localArray[8];
    LPWSABUF        pArray = localArray;
#endif

    UNREFERENCED_PARAMETER (Wait);
    UNREFERENCED_PARAMETER (DeviceObject);

    PAGED_CODE( );

    //
    // All we want to do is pass the request through to the TDI provider
    // if possible.  If not, we want to bail out of this code path back
    // onto the main code path (with IRPs) with as little performance
    // overhead as possible.
    //
    // Thus this routine only does general preliminary checks and input
    // parameter validation. If it is determined that fast io path is
    // likely to succeed, an operation specific routine is called
    // to handle all the details.
    //

    //
    // First get the endpoint pointer and previous mode for input parameter 
    // validation.
    //

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    previousMode = ExGetPreviousMode ();

    //
    // Switch based on control code
    //
    switch (IoControlCode) {
    case IOCTL_AFD_RECEIVE: 
        {
            union {
                AFD_RECV_INFO           recvInfo;
                AFD_RECV_MESSAGE_INFO   msgInfo;
            } u;
            ULONG   recvLength;

            //
            // Check the validity of the union above.
            //
            C_ASSERT (FIELD_OFFSET (AFD_RECV_MESSAGE_INFO, dgi.BufferArray)
                        == FIELD_OFFSET (AFD_RECV_INFO, BufferArray));
            C_ASSERT (FIELD_OFFSET (AFD_RECV_MESSAGE_INFO, dgi.BufferCount)
                        == FIELD_OFFSET (AFD_RECV_INFO, BufferCount));
            C_ASSERT (FIELD_OFFSET (AFD_RECV_MESSAGE_INFO, dgi.AfdFlags)
                        == FIELD_OFFSET (AFD_RECV_INFO, AfdFlags));
            C_ASSERT (FIELD_OFFSET (AFD_RECV_MESSAGE_INFO, dgi.TdiFlags)
                        == FIELD_OFFSET (AFD_RECV_INFO, TdiFlags));

            //
            //
            // If fast IO send is disabled
            //      or the endpoint is shut down in any way
            //      or the endpoint isn't connected yet
            //      or the TDI provider for this endpoint supports bufferring,
            // we do not want to do fast IO on it
            //
            if (endpoint->DisableFastIoRecv ||
                    endpoint->DisconnectMode != 0 ||
                    endpoint->State != AfdEndpointStateConnected ||
                    IS_TDI_BUFFERRING(endpoint) ) {
                res = FALSE;
                break;
            }

            try {

#ifdef _WIN64
                if (IoIs32bitProcess (NULL)) {
                    PAFD_RECV_INFO32    recvInfo32;
                    LPWSABUF32          tempArray;
                    ULONG               i;
                    

                    //
                    // If the input structure isn't large enough, return error.
                    //

                    if( InputBufferLength < sizeof(*recvInfo32) ) {
                        // Fast io can't handle error returns
                        // if call is overlapped (completion port)
                        // IoStatus->Status = STATUS_INVALID_PARAMETER;
                        res = FALSE;
                        break;
                    }


                    //
                    // Validate the input structure if it comes from the user mode
                    // application
                    //

                    if (previousMode != KernelMode ) {
                        ProbeForReadSmallStructure (InputBuffer,
                                        sizeof (*recvInfo32),
                                        PROBE_ALIGNMENT32(AFD_RECV_INFO32));
                    }

                    recvInfo32 = InputBuffer;


                    //
                    // Make local copies of the embeded pointer and parameters
                    // that we will be using more than once in case malicios
                    // application attempts to change them while we are
                    // validating
                    //
                    tempArray = UlongToPtr(recvInfo32->BufferArray);
                    u.recvInfo.BufferCount = recvInfo32->BufferCount;
                    u.recvInfo.AfdFlags = recvInfo32->AfdFlags;
                    u.recvInfo.TdiFlags = recvInfo32->TdiFlags;

                    //
                    // If fast IO is not possible or this is not a normal receive.
                    // bail.
                    //
                    if( (u.recvInfo.AfdFlags & AFD_NO_FAST_IO) ||
                        u.recvInfo.TdiFlags != TDI_RECEIVE_NORMAL ) {
                        res = FALSE;
                        break;
                    }

                    //
                    // Validate all the pointers that app gave to us and
                    // calculate the length of the send buffer.
                    // Buffers in the array will be validated in the
                    // process of copying
                    //

                    if ((tempArray == NULL) ||
                            (u.recvInfo.BufferCount == 0) ||
                            // Check for integer overflow (disabled by compiler)
                            (u.recvInfo.BufferCount>(MAXULONG/sizeof (WSABUF32))) ) {
                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }

                    if (previousMode != KernelMode) {
                        ProbeForRead(
                            tempArray,                                  // Address
                            // Note check for overflow above (should actually be
                            // done here by the compiler generating code
                            // that causes exception on integer overflow)
                            u.recvInfo.BufferCount * sizeof (WSABUF32), // Length
                            PROBE_ALIGNMENT32(WSABUF32)             // Alignment
                            );
                    }

                    if (u.recvInfo.BufferCount>sizeof(localArray)/sizeof(localArray[0])) {
                        try {
                            pArray = AFD_ALLOCATE_POOL_WITH_QUOTA (
                                            NonPagedPool,
                                            sizeof (WSABUF)*u.recvInfo.BufferCount,
                                            AFD_TEMPORARY_POOL_TAG);
                            // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets 
                            // POOL_RAISE_IF_ALLOCATION_FAILURE flag
                            ASSERT (pArray!=NULL);
                        }
                        except (EXCEPTION_EXECUTE_HANDLER) {
                            // Fast io can't handle error returns
                            // if call is overlapped (completion port)
                            // IoStatus->Status = GetExceptionCode ();
                            pArray = localArray;
                            res = FALSE;
                            break;
                        }
                    }

                    for (i=0; i<u.recvInfo.BufferCount; i++) {
                        pArray[i].buf = UlongToPtr(tempArray[i].buf);
                        pArray[i].len = tempArray[i].len;
                    }

                    u.recvInfo.BufferArray = pArray;

                }
                else
#endif // _WIN64
                {
                    //
                    // If the input structure isn't large enough, return error.
                    //

                    if( InputBufferLength < sizeof(u.recvInfo) ) {
                        // Fast io can't handle error returns
                        // if call is overlapped (completion port)
                        // IoStatus->Status = STATUS_INVALID_PARAMETER;
                        res = FALSE;
                        break;
                    }


                    //
                    // Validate the input structure if it comes from the user mode
                    // application
                    //

                    if (previousMode != KernelMode ) {
                        ProbeForReadSmallStructure (InputBuffer,
                                        sizeof (u.recvInfo),
                                        PROBE_ALIGNMENT(AFD_RECV_INFO));
                    }

                    //
                    // Make local copies of the embeded pointer and parameters
                    // that we will be using more than once in case malicios
                    // application attempts to change them while we are
                    // validating
                    //

                    u.recvInfo = *((PAFD_RECV_INFO)InputBuffer);
                    //
                    // If fast IO is not possible or this is not a normal receive.
                    // bail.
                    //
                    if( (u.recvInfo.AfdFlags & AFD_NO_FAST_IO) ||
                        u.recvInfo.TdiFlags != TDI_RECEIVE_NORMAL ) {
                        res = FALSE;
                        break;
                    }

                    //
                    // Validate all the pointers that app gave to us and
                    // calculate the length of the send buffer.
                    // Buffers in the array will be validated in the
                    // process of copying
                    //

                    if ((u.recvInfo.BufferArray == NULL) ||
                            (u.recvInfo.BufferCount == 0) ||
                            // Check for integer overflow (disabled by compiler)
                            (u.recvInfo.BufferCount>(MAXULONG/sizeof (WSABUF))) ) {
                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }

                    if (previousMode != KernelMode) {
                        ProbeForRead(
                            u.recvInfo.BufferArray,                     // Address
                            // Note check for overflow above (should actually be
                            // done here by the compiler generating code
                            // that causes exception on integer overflow)
                            u.recvInfo.BufferCount * sizeof (WSABUF),   // Length
                            PROBE_ALIGNMENT(WSABUF)                     // Alignment
                            );
                    }
                }

                recvLength = AfdCalcBufferArrayByteLength(
                                     u.recvInfo.BufferArray,
                                     u.recvInfo.BufferCount
                                     );

            } except( AFD_EXCEPTION_FILTER_NO_STATUS() ) {

                // Fast io can't handle error returns
                // if call is overlapped (completion port)
                // IoStatus->Status = GetExceptionCode ();
                res = FALSE;
                break;
            }

            //
            // Call routine based on endpoint type
            //
            if ( IS_DGRAM_ENDPOINT(endpoint) ) {
                u.msgInfo.dgi.Address = NULL;
                u.msgInfo.dgi.AddressLength = 0;
                u.msgInfo.ControlBuffer = NULL;
                u.msgInfo.ControlLength = NULL;
                u.msgInfo.MsgFlags = NULL;


                res = AfdFastDatagramReceive(
                           endpoint,
                           &u.msgInfo,
                           recvLength,
                           IoStatus
                           );
            }
            else if (IS_VC_ENDPOINT (endpoint)) {
                res = AfdFastConnectionReceive (
                            endpoint,
           